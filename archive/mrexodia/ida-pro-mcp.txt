Project Path: arc_mrexodia_ida-pro-mcp_6q1gdias

Source Tree:

```txt
arc_mrexodia_ida-pro-mcp_6q1gdias
├── CLAUDE.md
├── LICENSE
├── README.md
├── devdocs
│   └── test-framework.md
├── ida-plugin.json
├── pyproject.toml
├── skills
│   └── idapython
│       ├── SKILL.md
│       └── docs
│           ├── ida_auto.md
│           ├── ida_auto.rst
│           ├── ida_bitrange.md
│           ├── ida_bitrange.rst
│           ├── ida_bytes.md
│           ├── ida_bytes.rst
│           ├── ida_dbg.md
│           ├── ida_dbg.rst
│           ├── ida_dirtree.md
│           ├── ida_dirtree.rst
│           ├── ida_diskio.md
│           ├── ida_diskio.rst
│           ├── ida_entry.md
│           ├── ida_entry.rst
│           ├── ida_expr.md
│           ├── ida_expr.rst
│           ├── ida_fixup.md
│           ├── ida_fixup.rst
│           ├── ida_fpro.md
│           ├── ida_fpro.rst
│           ├── ida_frame.md
│           ├── ida_frame.rst
│           ├── ida_funcs.md
│           ├── ida_funcs.rst
│           ├── ida_gdl.md
│           ├── ida_gdl.rst
│           ├── ida_graph.md
│           ├── ida_graph.rst
│           ├── ida_hexrays.md
│           ├── ida_hexrays.rst
│           ├── ida_ida.md
│           ├── ida_ida.rst
│           ├── ida_idaapi.md
│           ├── ida_idaapi.rst
│           ├── ida_idc.md
│           ├── ida_idc.rst
│           ├── ida_idd.md
│           ├── ida_idd.rst
│           ├── ida_idp.md
│           ├── ida_idp.rst
│           ├── ida_ieee.md
│           ├── ida_ieee.rst
│           ├── ida_kernwin.md
│           ├── ida_kernwin.rst
│           ├── ida_libfuncs.md
│           ├── ida_libfuncs.rst
│           ├── ida_lines.md
│           ├── ida_lines.rst
│           ├── ida_loader.md
│           ├── ida_loader.rst
│           ├── ida_merge.md
│           ├── ida_merge.rst
│           ├── ida_mergemod.md
│           ├── ida_mergemod.rst
│           ├── ida_moves.md
│           ├── ida_moves.rst
│           ├── ida_nalt.md
│           ├── ida_nalt.rst
│           ├── ida_name.md
│           ├── ida_name.rst
│           ├── ida_netnode.md
│           ├── ida_netnode.rst
│           ├── ida_offset.md
│           ├── ida_offset.rst
│           ├── ida_pro.md
│           ├── ida_pro.rst
│           ├── ida_problems.md
│           ├── ida_problems.rst
│           ├── ida_range.md
│           ├── ida_range.rst
│           ├── ida_regfinder.md
│           ├── ida_regfinder.rst
│           ├── ida_registry.md
│           ├── ida_registry.rst
│           ├── ida_search.md
│           ├── ida_search.rst
│           ├── ida_segment.md
│           ├── ida_segment.rst
│           ├── ida_segregs.md
│           ├── ida_segregs.rst
│           ├── ida_srclang.md
│           ├── ida_srclang.rst
│           ├── ida_strlist.md
│           ├── ida_strlist.rst
│           ├── ida_tryblks.md
│           ├── ida_tryblks.rst
│           ├── ida_typeinf.md
│           ├── ida_typeinf.rst
│           ├── ida_ua.md
│           ├── ida_ua.rst
│           ├── ida_undo.md
│           ├── ida_undo.rst
│           ├── ida_xref.md
│           ├── ida_xref.rst
│           ├── idaapi.md
│           ├── idaapi.rst
│           ├── idadex.md
│           ├── idadex.rst
│           ├── idautils.md
│           ├── idautils.rst
│           ├── idc.md
│           ├── idc.rst
│           ├── init.md
│           └── init.rst
├── src
│   └── ida_pro_mcp
│       ├── __init__.py
│       ├── __main__.py
│       ├── ida_mcp
│       │   ├── __init__.py
│       │   ├── api_analysis.py
│       │   ├── api_core.py
│       │   ├── api_debug.py
│       │   ├── api_memory.py
│       │   ├── api_modify.py
│       │   ├── api_python.py
│       │   ├── api_resources.py
│       │   ├── api_stack.py
│       │   ├── api_types.py
│       │   ├── framework.py
│       │   ├── http.py
│       │   ├── rpc.py
│       │   ├── sync.py
│       │   ├── tests
│       │   │   ├── __init__.py
│       │   │   ├── test_api_analysis.py
│       │   │   ├── test_api_core.py
│       │   │   ├── test_api_memory.py
│       │   │   ├── test_api_modify.py
│       │   │   ├── test_api_resources.py
│       │   │   ├── test_api_stack.py
│       │   │   └── test_api_types.py
│       │   ├── utils.py
│       │   └── zeromcp
│       │       ├── __init__.py
│       │       ├── jsonrpc.py
│       │       └── mcp.py
│       ├── ida_mcp.py
│       ├── idalib_server.py
│       ├── idalib_session_manager.py
│       ├── server.py
│       └── test.py
├── tests
│   └── binary_info.py
├── uv-package.sh
└── uv.lock

```

`CLAUDE.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

IDA Pro MCP Server - enables LLM-assisted reverse engineering by bridging IDA Pro with Model Context Protocol clients through a JSON-RPC HTTP server.

**Architecture**: Dual-process design
- **MCP Server** (`server.py`): Python >=3.11, runs via `uv`, proxies to the MCP server hosted by IDA
- **IDA Plugin** (`ida_mcp/`): Runs inside IDA Pro, exposes MCP server over HTTP (port 13337+)

## Development Commands

### Testing MCP Server
```bash
# Interactive MCP inspector (web UI at http://localhost:5173)
uv run mcp dev src/ida_pro_mcp/server.py
```

### Installation
```bash
# Install package + configure all MCP clients + install IDA plugin
pip install https://github.com/mrexodia/ida-pro-mcp/archive/refs/heads/main.zip
ida-pro-mcp --install

# Manual plugin install (creates symlinks or copies to IDA plugins folder)
uv run ida-pro-mcp --install

# Uninstall everything
uv run ida-pro-mcp --uninstall
```

### Running
```bash
# Standard stdio transport (used by most MCP clients)
uv run ida-pro-mcp

# SSE transport for headless/remote use
uv run ida-pro-mcp --transport http://127.0.0.1:8744/sse

# Headless mode with idalib (no GUI)
uv run idalib-mcp --host 127.0.0.1 --port 8745 path/to/binary

# Enable unsafe debugger functions
uv run ida-pro-mcp --unsafe
```

### Changelog Generation
```bash
# Direct commits to main since tag
git log --first-parent --no-merges 1.2.0..main "--pretty=- %s"
```

## Architecture Deep Dive

### Plugin Architecture (ida_mcp/)

**Modular API**: 9 specialized modules
- `api_core.py`: IDB metadata, function/string/import listing
- `api_analysis.py`: Decompilation, disassembly, xrefs, paths, patterns
- `api_memory.py`: Read bytes/integers/strings, patch operations
- `api_types.py`: Structures, type inference, type application
- `api_modify.py`: Comments, assembly patching, renaming
- `api_stack.py`: Stack frame operations
- `api_debug.py`: Debugger control (unsafe, requires `--unsafe` flag)
- `api_python.py`: Python code execution in IDA context
- `api_resources.py`: MCP resources (24 URI patterns for RESTful access via `ida://` URIs)

**Infrastructure**:
- `rpc.py`: JSON-RPC registry + type checking (`@tool`, `@resource`, `@unsafe` decorators)
- `sync.py`: IDA thread synchronization (`@idasync` decorator)
- `zeromcp/mcp.py`: HTTP/SSE server implementation (Streamable HTTP + SSE transports)
- `utils.py`: TypedDict schemas, address parsing, pagination helpers

### Decorator Chain Pattern

Every API function follows this pattern:
```python
@tool             # 1. Register MCP tool
@idasync          # 2. Execute on IDA's main thread
def my_api(param: Annotated[str, "description"]) -> ReturnType:
    """Docstring becomes MCP tool description"""
    # Implementation uses IDA SDK
```

### Thread Safety

**All IDA SDK calls MUST run on main thread** - enforced by `@idasync`:
- Use `@idasync` for all IDA SDK operations (both read and write)
- Implementation: `sync_wrapper()` uses `idaapi.execute_sync()` with queue-based result passing

### Type Annotations

**Batch-first API convention**: Most functions accept `str` (comma-separated) OR `list`:
```python
def my_api(addrs: Annotated[str, "Addresses (0x401000, 0x402000) or list"]):
    parsed = normalize_list_input(addrs)  # Handles both formats
```

**Annotated types**: Description text becomes MCP parameter description
```python
count: Annotated[int, "Maximum number of results"]
```

## Adding New API Functions

### Step-by-step

1. Choose the appropriate `api_*.py` file (or create new one following `api_*.py` pattern)
2. Import required IDA SDK modules and decorators:
   ```python
   from .rpc import tool
   from .sync import idasync
   ```
3. Define function with full type hints:
   ```python
   @tool
   @idasync
   def my_function(param: Annotated[str, "param description"]) -> dict:
       """Tool description (first line used in MCP schema)"""
       # Use IDA SDK here
       return {"result": value}
   ```
4. Test with MCP inspector: `uv run mcp dev src/ida_pro_mcp/server.py`

**No other changes needed** - AST parsing auto-discovers and registers the function.

### Unsafe Functions

Mark debugger operations or destructive actions as unsafe:
```python
@unsafe           # Requires --unsafe flag
@tool
@idasync
def dangerous_op():
    pass
```

### MCP Resources

Expose RESTful URI-based access to IDA data using `@resource`:
```python
@resource(uri="ida://functions/{pattern}")
@idasync
def functions_resource(pattern: str = "*") -> list[dict]:
    """Get functions matching pattern via ida://functions/pattern URI"""
    # Return data accessible via MCP resource protocol
    return filtered_functions
```

Resources provide read-only access to IDA data via URI patterns. All resources use `@idasync`.

## Common Patterns

### Address Parsing
```python
addr = parse_address(input_str)  # Handles hex, decimal, function names
```

### Batch Operations
```python
addrs = normalize_list_input(input)  # "0x401000, main" -> [0x401000, 0x140001000]
results = []
for addr in addrs:
    try:
        results.append({"addr": addr, "data": process(addr), "error": None})
    except Exception as e:
        results.append({"addr": addr, "error": str(e)})
return results
```

### Pagination
```python
from .utils import paginate, Page

@tool
@idasync
def list_items(queries: Annotated[str, "offset:count or pattern"]) -> Page:
    all_items = get_all_items()
    return paginate(all_items, queries)
```

### Pattern Filtering
```python
from .utils import pattern_filter

filtered = pattern_filter(items, "name", pattern)  # Glob-style matching
```

## Testing Workflow

1. **Install plugin symlink**: `uv run ida-pro-mcp --install` (one-time)
2. **Load binary in IDA**: Plugin appears under Edit → Plugins → MCP (Ctrl+Alt+M)
3. **Start MCP server**: Click plugin menu item or hotkey
4. **Test via MCP inspector**: `uv run mcp dev src/ida_pro_mcp/server.py`
5. **Direct JSON-RPC testing**: POST to `http://localhost:13337/mcp`:
   ```json
   {"jsonrpc": "2.0", "method": "my_function", "params": ["arg"], "id": 1}
   ```

## Error Handling

- **IDAError**: Raised for IDA-specific errors (function not found, invalid address)
- **JSONRPCError**: Protocol-level errors (invalid params, method not found)
- **IDASyncError**: Thread synchronization failures (should never happen in production)

## Transport Modes

1. **stdio** (default): Standard MCP client transport
2. **Streamable HTTP**: `POST /mcp` with `Mcp-Session-Id` header
3. **SSE**: `GET /sse` for connection, `POST /sse?session=X` for requests

Server auto-negotiates based on client request.

## Prompting Best Practices

**Critical for LLM accuracy**:
- Always use `int_convert` tool for number base conversions (LLMs hallucinate on hex/decimal)
- Remove obfuscation before LLM analysis (string encryption, control flow flattening)
- Use FLIRT/Lumina to resolve library functions first
- Avoid asking LLM to brute force - derive solutions from disassembly

**Recommended prompt template** (from README:169-182):
> - Inspect decompilation and add comments
> - Rename variables to sensible names
> - Change types if necessary (especially pointers/arrays)
> - NEVER convert number bases yourself - use `int_convert` MCP tool
> - Do not brute force - derive solutions from disassembly

## File Structure

```
src/ida_pro_mcp/
├── server.py              # MCP server + AST parser + installer
├── idalib_server.py       # Headless idalib support
├── ida_mcp.py             # IDA plugin loader
└── ida_mcp/
    ├── __init__.py        # Package exports
    ├── rpc.py             # JSON-RPC registry
    ├── sync.py            # IDA thread sync
    ├── utils.py           # Shared helpers
    ├── zeromcp/           # Vendored MCP server implementation
    │   ├── mcp.py         # HTTP/SSE server
    │   └── jsonrpc.py     # JSON-RPC protocol
    └── api_*.py           # Modular API implementations
```

## Installation Mechanics

**Plugin installation**:
- Tries symlink first (development-friendly)
- Falls back to copy on Windows/permission issues
- Installs both `ida_mcp.py` (loader) and `ida_mcp/` (package)

**MCP client configuration**:
- Auto-detects Cline/Roo Code/Claude/Cursor/Windsurf/etc config paths
- Injects server config into JSON/TOML files
- Sets `autoApprove`/`alwaysAllow` for safe functions (non-debugger)

## Python Version Requirements

- **Server**: Python >=3.11 (uses vendored zeromcp MCP implementation)
- **Plugin**: Python >=3.11
- **IDA Pro**: 8.3+ (9.0 recommended), **IDA Free not supported** (no plugin API)

Use `idapyswitch` to upgrade IDA's Python interpreter if needed.

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Duncan Ogilvie

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IDA Pro MCP

Simple [MCP Server](https://modelcontextprotocol.io/introduction) to allow vibe reversing in IDA Pro.

https://github.com/user-attachments/assets/6ebeaa92-a9db-43fa-b756-eececce2aca0

The binaries and prompt for the video are available in the [mcp-reversing-dataset](https://github.com/mrexodia/mcp-reversing-dataset) repository.

## Prerequisites

- [Python](https://www.python.org/downloads/) (**3.11 or higher**)
  - Use `idapyswitch` to switch to the newest Python version
- [IDA Pro](https://hex-rays.com/ida-pro) (8.3 or higher, 9 recommended), **IDA Free is not supported**
- Supported MCP Client (pick one you like)
  - [Amazon Q Developer CLI](https://aws.amazon.com/q/developer/)
  - [Augment Code](https://www.augmentcode.com/)
  - [Claude](https://claude.ai/download)
  - [Claude Code](https://www.anthropic.com/code)
  - [Cline](https://cline.bot)
  - [Codex](https://github.com/openai/codex)
  - [Copilot CLI](https://docs.github.com/en/copilot)
  - [Crush](https://github.com/charmbracelet/crush)
  - [Cursor](https://cursor.com)
  - [Gemini CLI](https://google-gemini.github.io/gemini-cli/)
  - [Kilo Code](https://www.kilocode.com/)
  - [Kiro](https://kiro.dev/)
  - [LM Studio](https://lmstudio.ai/)
  - [Opencode](https://opencode.ai/)
  - [Qodo Gen](https://www.qodo.ai/)
  - [Qwen Coder](https://qwenlm.github.io/qwen-code-docs/)
  - [Roo Code](https://roocode.com)
  - [Trae](https://trae.ai/)
  - [VS Code](https://code.visualstudio.com/)
  - [VS Code Insiders](https://code.visualstudio.com/insiders)
  - [Warp](https://www.warp.dev/)
  - [Windsurf](https://windsurf.com)
  - [Zed](https://zed.dev/)
  - [Other MCP Clients](https://modelcontextprotocol.io/clients#example-clients): Run `ida-pro-mcp --config` to get the JSON config for your client.

## Installation

Install the latest version of the IDA Pro MCP package:

```sh
pip uninstall ida-pro-mcp
pip install https://github.com/mrexodia/ida-pro-mcp/archive/refs/heads/main.zip
```

Configure the MCP servers and install the IDA Plugin:

```
ida-pro-mcp --install
```

**Important**: Make sure you completely restart IDA and your MCP client for the installation to take effect. Some clients (like Claude) run in the background and need to be quit from the tray icon.

https://github.com/user-attachments/assets/65ed3373-a187-4dd5-a807-425dca1d8ee9

_Note_: You need to load a binary in IDA before the plugin menu will show up.

## Prompt Engineering

LLMs are prone to hallucinations and you need to be specific with your prompting. For reverse engineering the conversion between integers and bytes are especially problematic. Below is a minimal example prompt, feel free to start a discussion or open an issue if you have good results with a different prompt:

```md
Your task is to analyze a crackme in IDA Pro. You can use the MCP tools to retrieve information. In general use the following strategy:

- Inspect the decompilation and add comments with your findings
- Rename variables to more sensible names
- Change the variable and argument types if necessary (especially pointer and array types)
- Change function names to be more descriptive
- If more details are necessary, disassemble the function and add comments with your findings
- NEVER convert number bases yourself. Use the `int_convert` MCP tool if needed!
- Do not attempt brute forcing, derive any solutions purely from the disassembly and simple python scripts
- Create a report.md with your findings and steps taken at the end
- When you find a solution, prompt to user for feedback with the password you found
```

This prompt was just the first experiment, please share if you found ways to improve the output!

Another prompt by [@can1357](https://github.com/can1357):

```md
Your task is to create a complete and comprehensive reverse engineering analysis. Reference AGENTS.md to understand the project goals and ensure the analysis serves our purposes.

Use the following systematic methodology:

1. **Decompilation Analysis**
   - Thoroughly inspect the decompiler output
   - Add detailed comments documenting your findings
   - Focus on understanding the actual functionality and purpose of each component (do not rely on old, incorrect comments)

2. **Improve Readability in the Database**
   - Rename variables to sensible, descriptive names
   - Correct variable and argument types where necessary (especially pointers and array types)
   - Update function names to be descriptive of their actual purpose

3. **Deep Dive When Needed**
   - If more details are necessary, examine the disassembly and add comments with findings
   - Document any low-level behaviors that aren't clear from the decompilation alone
   - Use sub-agents to perform detailed analysis

4. **Important Constraints**
   - NEVER convert number bases yourself - use the int_convert MCP tool if needed
   - Use MCP tools to retrieve information as necessary
   - Derive all conclusions from actual analysis, not assumptions

5. **Documentation**
   - Produce comprehensive RE/*.md files with your findings
   - Document the steps taken and methodology used
   - When asked by the user, ensure accuracy over previous analysis file
   - Organize findings in a way that serves the project goals outlined in AGENTS.md or CLAUDE.md
```

Live stream discussing prompting and showing some real-world malware analysis:

[![](https://img.youtube.com/vi/iFxNuk3kxhk/0.jpg)](https://www.youtube.com/watch?v=iFxNuk3kxhk)

## Tips for Enhancing LLM Accuracy

Large Language Models (LLMs) are powerful tools, but they can sometimes struggle with complex mathematical calculations or exhibit "hallucinations" (making up facts). Make sure to tell the LLM to use the `int_convert` MCP tool and you might also need [math-mcp](https://github.com/EthanHenrickson/math-mcp) for certain operations.

Another thing to keep in mind is that LLMs will not perform well on obfuscated code. Before trying to use an LLM to solve the problem, take a look around the binary and spend some time (automatically) removing the following things:

- String encryption
- Import hashing
- Control flow flattening
- Code encryption
- Anti-decompilation tricks

You should also use a tool like Lumina or FLIRT to try and resolve all the open source library code and the C++ STL, this will further improve the accuracy.

## SSE Transport & Headless MCP

You can run an SSE server to connect to the user interface like this:

```sh
uv run ida-pro-mcp --transport http://127.0.0.1:8744/sse
```

After installing [`idalib`](https://docs.hex-rays.com/user-guide/idalib) you can also run a headless SSE server:

```sh
uv run idalib-mcp --host 127.0.0.1 --port 8745 path/to/executable
```

_Note_: The `idalib` feature was contributed by [Willi Ballenthin](https://github.com/williballenthin).


## MCP Resources

**Resources** represent browsable state (read-only data) following MCP's philosophy.

**Core IDB State:**
- `ida://idb/metadata` - IDB file info (path, arch, base, size, hashes)
- `ida://idb/segments` - Memory segments with permissions
- `ida://idb/entrypoints` - Entry points (main, TLS callbacks, etc.)

**UI State:**
- `ida://cursor` - Current cursor position and function
- `ida://selection` - Current selection range

**Type Information:**
- `ida://types` - All local types
- `ida://structs` - All structures/unions
- `ida://struct/{name}` - Structure definition with fields

**Lookups:**
- `ida://import/{name}` - Import details by name
- `ida://export/{name}` - Export details by name
- `ida://xrefs/from/{addr}` - Cross-references from address

## Core Functions

- `lookup_funcs(queries)`: Get function(s) by address or name (auto-detects, accepts list or comma-separated string).
- `int_convert(inputs)`: Convert numbers to different formats (decimal, hex, bytes, ASCII, binary).
- `list_funcs(queries)`: List functions (paginated, filtered).
- `list_globals(queries)`: List global variables (paginated, filtered).
- `imports(offset, count)`: List all imported symbols with module names (paginated).
- `decompile(addr)`: Decompile function at the given address.
- `disasm(addr)`: Disassemble function with full details (arguments, stack frame, etc).
- `xrefs_to(addrs)`: Get all cross-references to address(es).
- `xrefs_to_field(queries)`: Get cross-references to specific struct field(s).
- `callees(addrs)`: Get functions called by function(s) at address(es).

## Modification Operations

- `set_comments(items)`: Set comments at address(es) in both disassembly and decompiler views.
- `patch_asm(items)`: Patch assembly instructions at address(es).
- `declare_type(decls)`: Declare C type(s) in the local type library.
- `define_func(items)`: Define function(s) at address(es). Optionally specify `end` for explicit bounds.
- `define_code(items)`: Convert bytes to code instruction(s) at address(es).
- `undefine(items)`: Undefine item(s) at address(es), converting back to raw bytes. Optionally specify `end` or `size`.

## Memory Reading Operations

- `get_bytes(addrs)`: Read raw bytes at address(es).
- `get_int(queries)`: Read integer values using ty (i8/u64/i16le/i16be/etc).
- `get_string(addrs)`: Read null-terminated string(s).
- `get_global_value(queries)`: Read global variable value(s) by address or name (auto-detects, compile-time values).

## Stack Frame Operations

- `stack_frame(addrs)`: Get stack frame variables for function(s).
- `declare_stack(items)`: Create stack variable(s) at specified offset(s).
- `delete_stack(items)`: Delete stack variable(s) by name.

## Structure Operations

- `read_struct(queries)`: Read structure field values at specific address(es).
- `search_structs(filter)`: Search structures by name pattern.

## Debugger Operations (Extension)

Debugger tools are hidden by default. Enable with `?ext=dbg` query parameter:

```
http://127.0.0.1:13337/mcp?ext=dbg
```

**Control:**
- `dbg_start()`: Start debugger process.
- `dbg_exit()`: Exit debugger process.
- `dbg_continue()`: Continue execution.
- `dbg_run_to(addr)`: Run to address.
- `dbg_step_into()`: Step into instruction.
- `dbg_step_over()`: Step over instruction.

**Breakpoints:**
- `dbg_bps()`: List all breakpoints.
- `dbg_add_bp(addrs)`: Add breakpoint(s).
- `dbg_delete_bp(addrs)`: Delete breakpoint(s).
- `dbg_toggle_bp(items)`: Enable/disable breakpoint(s).

**Registers:**
- `dbg_regs()`: All registers, current thread.
- `dbg_regs_all()`: All registers, all threads.
- `dbg_regs_remote(tids)`: All registers, specific thread(s).
- `dbg_gpregs()`: GP registers, current thread.
- `dbg_gpregs_remote(tids)`: GP registers, specific thread(s).
- `dbg_regs_named(names)`: Named registers, current thread.
- `dbg_regs_named_remote(tid, names)`: Named registers, specific thread.

**Stack & Memory:**
- `dbg_stacktrace()`: Call stack with module/symbol info.
- `dbg_read(regions)`: Read memory from debugged process.
- `dbg_write(regions)`: Write memory to debugged process.

## Advanced Analysis Operations

- `py_eval(code)`: Execute arbitrary Python code in IDA context (returns dict with result/stdout/stderr, supports Jupyter-style evaluation).
- `analyze_funcs(addrs)`: Comprehensive function analysis (decompilation, assembly, xrefs, callees, callers, strings, constants, basic blocks).

## Pattern Matching & Search

- `find_regex(queries)`: Search strings with case-insensitive regex (paginated).
- `find_bytes(patterns, limit=1000, offset=0)`: Find byte pattern(s) in binary (e.g., "48 8B ?? ??"). Max limit: 10000.
- `find_insns(sequences, limit=1000, offset=0)`: Find instruction sequence(s) in code. Max limit: 10000.
- `find(type, targets, limit=1000, offset=0)`: Advanced search (immediate values, strings, data/code references). Max limit: 10000.

## Control Flow Analysis

- `basic_blocks(addrs)`: Get basic blocks with successors and predecessors.

## Type Operations

- `set_type(edits)`: Apply type(s) to functions, globals, locals, or stack variables.
- `infer_types(addrs)`: Infer types at address(es) using Hex-Rays or heuristics.

## Export Operations

- `export_funcs(addrs, format)`: Export function(s) in specified format (json, c_header, or prototypes).

## Graph Operations

- `callgraph(roots, max_depth)`: Build call graph from root function(s) with configurable depth.

## Batch Operations

- `rename(batch)`: Unified batch rename operation for functions, globals, locals, and stack variables (accepts dict with optional `func`, `data`, `local`, `stack` keys).
- `patch(patches)`: Patch multiple byte sequences at once.
- `put_int(items)`: Write integer values using ty (i8/u64/i16le/i16be/etc).

**Key Features:**

- **Type-safe API**: All functions use strongly-typed parameters with TypedDict schemas for better IDE support and LLM structured outputs
- **Batch-first design**: Most operations accept both single items and lists
- **Consistent error handling**: All batch operations return `[{..., error: null|string}, ...]`
- **Cursor-based pagination**: Search functions return `cursor: {next: offset}` or `{done: true}` (default limit: 1000, enforced max: 10000 to prevent token overflow)
- **Performance**: Strings are cached with MD5-based invalidation to avoid repeated `build_strlist` calls in large projects

## Comparison with other MCP servers

There are a few IDA Pro MCP servers floating around, but I created my own for a few reasons:

1. Installation should be fully automated.
2. The architecture of other plugins make it difficult to add new functionality quickly (too much boilerplate of unnecessary dependencies).
3. Learning new technologies is fun!

If you want to check them out, here is a list (in the order I discovered them):

- https://github.com/taida957789/ida-mcp-server-plugin (SSE protocol only, requires installing dependencies in IDAPython).
- https://github.com/fdrechsler/mcp-server-idapro (MCP Server in TypeScript, excessive boilerplate required to add new functionality).
- https://github.com/MxIris-Reverse-Engineering/ida-mcp-server (custom socket protocol, boilerplate).

Feel free to open a PR to add your IDA Pro MCP server here.

## Development

Adding new features is a super easy and streamlined process. All you have to do is add a new `@tool` function to the modular API files in `src/ida_pro_mcp/ida_mcp/api_*.py` and your function will be available in the MCP server without any additional boilerplate! Below is a video where I add the `get_metadata` function in less than 2 minutes (including testing):

https://github.com/user-attachments/assets/951de823-88ea-4235-adcb-9257e316ae64

To test the MCP server itself:

```sh
npx -y @modelcontextprotocol/inspector
```

This will open a web interface at http://localhost:5173 and allow you to interact with the MCP tools for testing.

For testing I create a symbolic link to the IDA plugin and then POST a JSON-RPC request directly to `http://localhost:13337/mcp`. After [enabling symbolic links](https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development) you can run the following command:

```sh
uv run ida-pro-mcp --install
```

Generate the changelog of direct commits to `main`:

```sh
git log --first-parent --no-merges 1.2.0..main "--pretty=- %s"
```

```

`devdocs/test-framework.md`:

```md
# IDA Pro MCP Test Framework

This document provides detailed documentation for the test framework used in ida-pro-mcp.

## Overview

The test framework is a custom, lightweight testing solution designed specifically for testing IDA Pro MCP tools. It supports:

- **Inline tests** - Tests defined right after the functions they test in `api_*.py` files
- **IDA console runner** - Run tests interactively inside IDA Pro
- **Standalone runner** - Run tests headlessly using idalib
- **Code coverage** - Measure code coverage of API implementations
- **Binary-agnostic assertions** - Tests that work on any binary

## Architecture

```
src/ida_pro_mcp/
├── ida_mcp/
│   ├── framework.py          # Test framework core
│   │   ├── @test decorator   # Register test functions
│   │   ├── run_tests()       # Test runner
│   │   ├── TestResults       # Result aggregation
│   │   ├── assert_*          # Assertion helpers
│   │   └── get_any_*         # Test data helpers
│   ├── tests/                # Separate test files
│   │   ├── test_api_core.py
│   │   ├── test_api_analysis.py
│   │   ├── test_api_memory.py
│   │   ├── test_api_modify.py
│   │   ├── test_api_types.py
│   │   ├── test_api_stack.py
│   │   └── test_api_resources.py
│   ├── api_core.py           # API implementations
│   ├── api_analysis.py
│   └── ...
├── test.py                   # Standalone runner (idalib)
└── ...
tests/
├── crackme03.elf             # Test binary
└── binary_info.py            # Binary info extraction
```

## Test Registration

### The `@test` Decorator

```python
from .tests import test

@test()
def test_idb_meta():
    """Test description"""
    meta = idb_meta()
    assert_has_keys(meta, "path", "module", "base")
```

#### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `binary` | `str` | `""` | Specific binary this test runs for |
| `skip` | `bool` | `False` | Skip this test |

#### Examples

```python
# Basic test
@test()
def test_basic():
    pass

# Skipped test
@test(skip=True)
def test_broken():
    pass
```

### Test Placement

Tests should be placed **immediately after** the function they test:

```python
@tool
@idasync
def idb_meta() -> Metadata:
    """Get IDB metadata"""
    return Metadata(...)


@test()
def test_idb_meta():
    """idb_meta returns valid metadata"""
    meta = idb_meta()
    assert_has_keys(meta, "path", "module")
```

This keeps tests close to implementation and makes it easy to see test coverage.

### Test Auto-Discovery

Tests are automatically discovered and categorized by their module:

```python
# In api_core.py
@test()
def test_idb_meta():  # Registered as category="api_core"
    pass

# In api_analysis.py
@test()
def test_decompile():  # Registered as category="api_analysis"
    pass
```

## Assertion Helpers

Import helpers from `tests.py`:

```python
from .tests import (
    test,
    assert_has_keys,
    assert_valid_address,
    assert_non_empty,
    assert_is_list,
    assert_all_have_keys,
)
```

### `assert_has_keys(d, *keys)`

Assert a dict contains all specified keys:

```python
meta = idb_meta()
assert_has_keys(meta, "path", "module", "base", "size")
```

### `assert_valid_address(addr)`

Assert a string is a valid hex address:

```python
assert_valid_address("0x401000")    # OK
assert_valid_address("-0x10")       # OK (negative)
assert_valid_address("401000")      # FAIL - no 0x prefix
assert_valid_address("not_addr")    # FAIL - not hex
```

### `assert_non_empty(value)`

Assert value is not None and not empty:

```python
assert_non_empty("hello")           # OK
assert_non_empty([1, 2, 3])         # OK
assert_non_empty("")                # FAIL
assert_non_empty([])                # FAIL
assert_non_empty(None)              # FAIL
```

### `assert_is_list(value, min_length=0)`

Assert value is a list with minimum length:

```python
assert_is_list([1, 2, 3])           # OK
assert_is_list([1, 2], min_length=2) # OK
assert_is_list([1], min_length=2)   # FAIL - too short
assert_is_list("string")            # FAIL - not a list
```

### `assert_all_have_keys(items, *keys)`

Assert all dicts in a list have specified keys:

```python
funcs = [{"addr": "0x1", "name": "a"}, {"addr": "0x2", "name": "b"}]
assert_all_have_keys(funcs, "addr", "name")  # OK
assert_all_have_keys(funcs, "addr", "size")  # FAIL - missing "size"
```

## Test Data Helpers

### `get_any_function() -> Optional[str]`

Get address of first function (for tests needing a valid function):

```python
fn_addr = get_any_function()
if not fn_addr:
    return  # Skip test if no functions

result = decompile(fn_addr)
assert result[0]["code"] is not None
```

### `get_any_string() -> Optional[str]`

Get address of first string:

```python
str_addr = get_any_string()
if not str_addr:
    return  # Skip if no strings

result = get_string(str_addr)
assert result[0]["value"] is not None
```

### `get_first_segment() -> Optional[tuple[str, str]]`

Get first segment's (start, end) addresses:

```python
seg = get_first_segment()
if not seg:
    return

start_addr, end_addr = seg
result = get_bytes({"addr": start_addr, "size": 16})
```

## Running Tests

### From IDA Console

```python
from ida_mcp.tests import run_tests

# Run all tests
run_tests()

# Run specific category
run_tests(category="api_core")

# Run tests matching pattern
run_tests(pattern="*decompile*")

# Combine filters
run_tests(pattern="test_list_*", category="api_core")

# Stop on first failure
run_tests(stop_on_failure=True)

# Quiet mode (just summary)
run_tests(verbose=False)
```

### From Command Line

```bash
# Basic usage
ida-mcp-test tests/crackme03.elf

# Filter by category
ida-mcp-test tests/crackme03.elf --category api_core

# Filter by pattern
ida-mcp-test tests/crackme03.elf --pattern "*meta*"

# List available tests
ida-mcp-test tests/crackme03.elf --list

# Stop on first failure
ida-mcp-test tests/crackme03.elf --stop-on-failure

# With code coverage
ida-mcp-test tests/crackme03.elf --coverage

# HTML coverage report
ida-mcp-test tests/crackme03.elf --coverage --coverage-report html
```

## Code Coverage

Code coverage is measured using the `coverage` package with `uv run coverage run`.

### Running with Coverage

```bash
# Run tests with coverage
uv run coverage run -m ida_pro_mcp.test crackme03.elf

# Show coverage report in terminal
uv run coverage report --show-missing

# Generate HTML report
uv run coverage html
open htmlcov/index.html

# Generate XML report (for CI)
uv run coverage xml

# Generate JSON report
uv run coverage json

# Combine multiple coverage runs
uv run coverage combine
uv run coverage report
```

### Coverage Configuration

Create a `.coveragerc` file or add to `pyproject.toml`:

```toml
[tool.coverage.run]
source = ["ida_pro_mcp.ida_mcp"]
omit = [
    "*/tests.py",
    "*/zeromcp/*",
    "*/__init__.py",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "if TYPE_CHECKING:",
    "raise NotImplementedError",
]
```

## Test Patterns

### 1. Schema Validation

Verify return types match expected structure:

```python
@test()
def test_idb_meta():
    """idb_meta returns properly structured metadata"""
    meta = idb_meta()
    assert_has_keys(meta, "path", "module", "base", "size", "md5", "sha256")
    assert_valid_address(meta["base"])
```

### 2. Non-Empty Results

Verify APIs return data on valid binaries:

```python
@test()
def test_list_funcs():
    """list_funcs returns at least one function"""
    result = list_funcs({})
    assert_is_list(result, min_length=1)
    assert_is_list(result[0]["data"], min_length=1)
```

### 3. Error Handling

Verify invalid inputs raise `IDAError`:

```python
from .sync import IDAError

@test()
def test_decompile_invalid():
    """decompile raises IDAError for invalid address"""
    try:
        decompile("0xDEADBEEFDEADBEEF")
        assert False, "Expected IDAError"
    except IDAError:
        pass  # Expected
```

### 4. Referential Integrity

Verify cross-API consistency:

```python
@test()
def test_functions_are_decompilable():
    """Functions from list_funcs can be decompiled"""
    result = list_funcs({"count": 3})
    for fn in result[0]["data"]:
        dec = decompile(fn["addr"])
        # Should either have code or specific error, not crash
        assert "code" in dec[0] or "error" in dec[0]
```

### 5. Round-Trip with Cleanup

Test modifications and restore original state:

```python
@test()
def test_rename_roundtrip():
    """rename function works and can be undone"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Get original name
    original = lookup_funcs(fn_addr)[0]["fn"]["name"]

    try:
        # Rename
        rename({"func": [{"addr": fn_addr, "name": "__test__"}]})

        # Verify
        new_name = lookup_funcs(fn_addr)[0]["fn"]["name"]
        assert new_name == "__test__"
    finally:
        # Restore
        rename({"func": [{"addr": fn_addr, "name": original}]})
```

### 6. Batch Operations

Verify batch input handling:

```python
@test()
def test_batch_operations():
    """Operations handle multiple inputs"""
    result = list_funcs({"count": 3})
    addrs = [fn["addr"] for fn in result[0]["data"]]

    # Batch lookup
    results = lookup_funcs(addrs)
    assert len(results) == len(addrs)
```

## Test Results

### `TestResult` Structure

```python
@dataclass
class TestResult:
    name: str                          # Test function name
    category: str                      # Module category (api_core, etc.)
    status: Literal["passed", "failed", "skipped"]
    duration: float                    # Execution time in seconds
    error: Optional[str]               # Error message if failed
    traceback: Optional[str]           # Full traceback if failed
```

### `TestResults` Aggregate

```python
@dataclass
class TestResults:
    passed: int
    failed: int
    skipped: int
    total_time: float
    results: list[TestResult]
```

### Programmatic Access

```python
results = run_tests(verbose=False)

print(f"Passed: {results.passed}")
print(f"Failed: {results.failed}")

for r in results.results:
    if r.status == "failed":
        print(f"{r.name}: {r.error}")
        print(r.traceback)
```

## Adding New Tests

### Step-by-Step

1. **Identify the function to test** in the appropriate `api_*.py` file

2. **Add imports** at the top of the file:
   ```python
   from .tests import (
       test,
       assert_has_keys,
       assert_valid_address,
       # ... other helpers you need
   )
   ```

3. **Write the test** immediately after the function:
   ```python
   @tool
   @idasync
   def my_function(...):
       ...


   @test()
   def test_my_function():
       """Description of what the test verifies"""
       result = my_function(...)
       assert_has_keys(result, "key1", "key2")
   ```

4. **Run the test**:
   ```bash
   ida-mcp-test tests/crackme03.elf --pattern "test_my_function"
   ```

### Best Practices

1. **Test name**: Use `test_<function_name>` or `test_<function_name>_<scenario>`

2. **Docstring**: First line describes what the test verifies

3. **Binary-agnostic**: Don't hardcode addresses or expected values

4. **Skip gracefully**: Return early if required data isn't available
   ```python
   fn_addr = get_any_function()
   if not fn_addr:
       return  # Skip, don't fail
   ```

5. **Cleanup**: Restore state for tests that modify the IDB
   ```python
   try:
       # Modify
   finally:
       # Restore
   ```

6. **Error handling**: Use `try/except IDAError` for expected errors

## Coverage-Guided Test Development

Tests should be **coverage-guided**: use coverage data to identify gaps in our wrapper code, then write tests that exercise those specific code paths.

### Methodology

**Key Principle**: We're testing *our wrapper code*, not IDA's correctness. Don't write tests that verify IDA returns expected values - IDA works. Instead, write tests that trigger edge cases and error paths in our code.

#### Workflow

1. **Run coverage**:
   ```bash
   uv run coverage run -m ida_pro_mcp.test tests/crackme03.elf
   uv run coverage report --show-missing --include="src/ida_pro_mcp/ida_mcp/api_*.py"
   ```

2. **Identify uncovered lines** and understand what conditions trigger them

3. **Determine test type**:
   - **Generic test**: If the gap can be triggered with invalid/edge-case inputs (preferred)
   - **Binary-specific test**: Only if the gap requires specific binary properties

4. **Write minimal test** that triggers the specific code path

5. **Re-run coverage** to verify the gap is closed

#### Example: Coverage-Guided Test Development

Coverage shows lines 252-256 in `api_core.py` are uncovered:
```python
except ValueError:
    results.append(
        {"input": text, "result": None, "error": f"Invalid number: {text}"}
    )
```

This is an error path for invalid input. Write a generic test:
```python
@test()
def test_int_convert_invalid_text():
    """int_convert handles invalid number text (covers lines 252-256)"""
    result = int_convert({"text": "not_a_number"})
    assert result[0]["result"] is None
    assert "Invalid number" in result[0]["error"]
```

### Deterministic Sampling

For broader test coverage, test on multiple items rather than just one. The framework provides helpers that select a deterministic sample based on binary name.

#### Sample Size Configuration

Sample size is configured via command line:
```bash
# Default: 5 items
uv run ida-mcp-test tests/crackme03.elf

# More thorough testing with 10 items
uv run ida-mcp-test tests/crackme03.elf --sample-size 10

# Quick smoke test with 2 items
uv run ida-mcp-test tests/crackme03.elf --sample-size 2
```

#### Sampling Helpers

```python
from .tests import get_n_functions, get_n_strings, get_functions_with_calls

@test()
def test_decompile_multiple():
    """decompile works on multiple functions (sampling test)"""
    addrs = get_n_functions()  # Uses configured sample size
    if len(addrs) < 2:
        return

    results = decompile(addrs)
    assert len(results) == len(addrs)
    # At least some should succeed
    successes = [r for r in results if r.get("code")]
    assert len(successes) > 0
```

#### Available Helpers

| Helper | Description |
|--------|-------------|
| `get_n_functions(n=None)` | N deterministically-selected function addresses |
| `get_n_strings(n=None)` | N deterministically-selected string addresses |
| `get_functions_with_calls()` | Functions that contain call instructions |
| `get_functions_with_callers()` | Functions that are called by others |
| `get_data_address()` | Address in a data (non-code) segment |
| `get_unmapped_address()` | Invalid address for error path testing |

### Test Categories

#### 1. Schema Tests
Verify return structure matches expected schema:
```python
@test()
def test_idb_meta_schema():
    result = idb_meta()
    assert_has_keys(result, "path", "module", "base", "size")
```

#### 2. Error Path Tests
Verify error handling for invalid inputs:
```python
@test()
def test_decompile_invalid_address():
    """Covers error handling path"""
    result = decompile(get_unmapped_address())
    assert result[0].get("error") is not None
```

#### 3. Edge Case Tests
Cover specific code paths identified by coverage:
```python
@test()
def test_lookup_funcs_wildcard():
    """lookup_funcs with '*' returns all functions (covers lines 132-134)"""
    result = lookup_funcs("*")
    assert len(result) > 0
    assert result[0]["query"] == "*"
```

#### 4. Sampling Tests
Test on multiple items for broader coverage:
```python
@test()
def test_callees_multiple():
    """callees works on multiple functions (sampling test)"""
    addrs = get_n_functions()
    result = callees(addrs)
    assert len(result) == len(addrs)
```

### Binary-Specific Tests (Use Sparingly)

Binary-specific tests should only be used when:
1. A code path requires specific binary properties (e.g., C++ mangled names)
2. The edge case cannot be triggered with generic inputs

```python
@test(binary="crackme03.elf")
def test_crackme_specific_edge_case():
    """Tests a code path that requires specific binary structure"""
    # Only runs when crackme03.elf is loaded
    ...
```

**Do NOT use binary-specific tests to verify IDA correctness** (e.g., "main is at 0x123e").

### Coverage Targets

| Module | Target | Notes |
|--------|--------|-------|
| api_core | 90%+ | Core functionality |
| api_analysis | 85%+ | Complex decompilation paths |
| api_memory | 85%+ | Read/write operations |
| api_types | 80%+ | Type system edge cases |
| api_modify | 70%+ | Modification operations |
| api_resources | 85%+ | Resource URIs |
| api_stack | 80%+ | Stack frame operations |
| api_debug | Skip | Requires active debugger |
| api_python | Skip | Requires special setup |

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "IDA Pro MCP",
    "entryPoint": "src/ida_pro_mcp/ida_mcp.py",
    "categories": ["api-scripting-and-automation", "debugging-and-tracing", "malware-analysis"],
    "logoPath": ".github/logo.png",
    "description": "AI-powered reverse engineering assistant that bridges IDA Pro with language models through MCP.",
    "idaVersions": ">=8.3",
    "version": "2.0.0"
  }
}
```

`pyproject.toml`:

```toml
[project]
name = "ida-pro-mcp"
version = "2.0.0"
description = "Vibe reversing with IDA Pro"
readme = "README.md"
requires-python = ">=3.11"
authors = [
    { name = "mrexodia" },
    { name = "can1357" },
    { name = "IDA Pro MCP Contributors" },
]
keywords = ["ida", "mcp", "llm", "plugin"]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Operating System :: MacOS",
    "Operating System :: Microsoft :: Windows",
]
dependencies = [
    "idapro>=0.0.7",
    "tomli-w>=1.0.0",
]

[project.urls]
Repository = "https://github.com/mrexodia/ida-pro-mcp"
Issues = "https://github.com/mrexodia/ida-pro-mcp/issues"

[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project.scripts]
ida-pro-mcp = "ida_pro_mcp.server:main"
idalib-mcp = "ida_pro_mcp.idalib_server:main"
ida-mcp-test = "ida_pro_mcp.test:main"

[tool.pyright]
include = ["src/ida_pro_mcp"]

[tool.ruff]
exclude = ["src/ida_pro_mcp/ida_mcp/zeromcp/*.py"]

```

`skills/idapython/SKILL.md`:

```md
---
name: idapython
description: IDA Pro Python scripting for reverse engineering. Use when writing IDAPython scripts, analyzing binaries, working with IDA's API for disassembly, decompilation (Hex-Rays), type systems, cross-references, functions, segments, or any IDA database manipulation. Covers ida_* modules (50+), idautils iterators, and common patterns.
---

# IDAPython

Use modern `ida_*` modules. Avoid legacy `idc` module.

## Module Router

| Task | Module | Key Items |
|------|--------|-----------|
| Bytes/memory | `ida_bytes` | `get_bytes`, `patch_bytes`, `get_flags`, `create_*` |
| Functions | `ida_funcs` | `func_t`, `get_func`, `add_func`, `get_func_name` |
| Names | `ida_name` | `set_name`, `get_name`, `demangle_name` |
| Types | `ida_typeinf` | `tinfo_t`, `apply_tinfo`, `parse_decl` |
| Decompiler | `ida_hexrays` | `decompile`, `cfunc_t`, `lvar_t`, ctree visitor |
| Segments | `ida_segment` | `segment_t`, `getseg`, `add_segm` |
| Xrefs | `ida_xref` | `xrefblk_t`, `add_cref`, `add_dref` |
| Instructions | `ida_ua` | `insn_t`, `op_t`, `decode_insn` |
| Stack frames | `ida_frame` | `get_frame`, `define_stkvar` |
| Iteration | `idautils` | `Functions()`, `Heads()`, `XrefsTo()`, `Strings()` |
| UI/dialogs | `ida_kernwin` | `msg`, `ask_*`, `jumpto`, `Choose` |
| Database info | `ida_ida` | `inf_get_*`, `inf_is_64bit()` |
| Analysis | `ida_auto` | `auto_wait`, `plan_and_wait` |
| Flow graphs | `ida_gdl` | `FlowChart`, `BasicBlock` |
| Register tracking | `ida_regfinder` | `find_reg_value`, `reg_value_info_t` |

## Core Patterns

### Iterate functions
```python
for ea in idautils.Functions():
    name = ida_funcs.get_func_name(ea)
    func = ida_funcs.get_func(ea)
```

### Iterate instructions in function
```python
for head in idautils.FuncItems(func_ea):
    insn = ida_ua.insn_t()
    if ida_ua.decode_insn(insn, head):
        print(f"{head:#x}: {insn.itype}")
```

### Cross-references
```python
for xref in idautils.XrefsTo(ea):
    print(f"{xref.frm:#x} -> {xref.to:#x} type={xref.type}")
```

### Read/write bytes
```python
data = ida_bytes.get_bytes(ea, size)
ida_bytes.patch_bytes(ea, b"\x90\x90")
```

### Names
```python
name = ida_name.get_name(ea)
ida_name.set_name(ea, "new_name", ida_name.SN_NOCHECK)
```

### Decompile function
```python
cfunc = ida_hexrays.decompile(ea)
if cfunc:
    print(cfunc)  # pseudocode
    for lvar in cfunc.lvars:
        print(f"{lvar.name}: {lvar.type()}")
```

### Walk ctree (decompiled AST)
```python
class MyVisitor(ida_hexrays.ctree_visitor_t):
    def visit_expr(self, e):
        if e.op == ida_hexrays.cot_call:
            print(f"Call at {e.ea:#x}")
        return 0

cfunc = ida_hexrays.decompile(ea)
MyVisitor().apply_to(cfunc.body, None)
```

### Apply type
```python
tif = ida_typeinf.tinfo_t()
if ida_typeinf.parse_decl(tif, None, "int (*)(char *, int)", 0):
    ida_typeinf.apply_tinfo(ea, tif, ida_typeinf.TINFO_DEFINITE)
```

### Create structure
```python
udt = ida_typeinf.udt_type_data_t()
m = ida_typeinf.udm_t()
m.name = "field1"
m.type = ida_typeinf.tinfo_t(ida_typeinf.BTF_INT32)
m.offset = 0
m.size = 4
udt.push_back(m)
tif = ida_typeinf.tinfo_t()
tif.create_udt(udt, ida_typeinf.BTF_STRUCT)
tif.set_named_type(ida_typeinf.get_idati(), "MyStruct")
```

### Strings list
```python
for s in idautils.Strings():
    print(f"{s.ea:#x}: {str(s)}")
```

### Wait for analysis
```python
ida_auto.auto_wait()  # Block until autoanalysis completes
```

## Key Constants

| Constant | Value/Use |
|----------|-----------|
| `BADADDR` | Invalid address sentinel |
| `ida_name.SN_NOCHECK` | Skip name validation |
| `ida_typeinf.TINFO_DEFINITE` | Force type application |
| `o_reg`, `o_mem`, `o_imm`, `o_displ`, `o_near` | Operand types |
| `dt_byte`, `dt_word`, `dt_dword`, `dt_qword` | Data types |
| `fl_CF`, `fl_CN`, `fl_JF`, `fl_JN`, `fl_F` | Code xref types |
| `dr_R`, `dr_W`, `dr_O` | Data xref types |

## Critical Rules

1. **NEVER convert hex/decimal manually** — use `int_convert` MCP tool
2. **Wait for analysis**: Call `ida_auto.auto_wait()` before reading results
3. **Thread safety**: IDA SDK calls must run on main thread (use `@idasync`)
4. **64-bit addresses**: Always assume `ea_t` can be 64-bit

## Anti-Patterns

| Avoid | Do Instead |
|-------|------------|
| `idc.*` functions | Use `ida_*` modules |
| Hardcoded addresses | Use names, patterns, or xrefs |
| Manual hex conversion | Use `int_convert` tool |
| Blocking main thread | Use `execute_sync()` for long ops |
| Guessing at types | Derive from disassembly/decompilation |

## Detailed API Reference

For comprehensive documentation on any module, read `docs/<module>.md`:
- **High-use**: `ida_bytes`, `ida_funcs`, `ida_hexrays`, `ida_typeinf`, `ida_name`, `idautils`
- **Medium-use**: `ida_segment`, `ida_xref`, `ida_ua`, `ida_frame`, `ida_kernwin`
- **Specialized**: `ida_dbg` (debugger), `ida_nalt` (netnode storage), `ida_regfinder` (register tracking)

Full RST sources from hex-rays.com available at `docs/<module>.rst`.

```

`skills/idapython/docs/ida_auto.md`:

```md
# ida_auto

Autoanalysis queue management and IDA status indicators.

## Key Functions

### Auto State Management
- `get_auto_state()` - Get current autoanalyzer state (AU_NONE when idle)
- `set_auto_state(new_state)` - Set autoanalyzer state
- `auto_is_ok()` - Check if all queues empty (analysis finished)
- `is_auto_enabled()` / `enable_auto(enable)` - Get/set autoanalyzer enabled state

### Queue Operations
- `auto_mark(ea, type)` - Add single address to queue (sorted)
- `auto_mark_range(start, end, type)` - Add address range to queue
- `auto_unmark(start, end, type)` - Remove range from queue
- `auto_cancel(ea1, ea2)` - Remove range from AU_CODE/AU_PROC/AU_USED queues

### Analysis Planning
- `plan_ea(ea)` / `plan_range(sEA, eEA)` - Plan reanalysis
- `auto_make_code(ea)` - Plan to make code
- `auto_make_proc(ea)` - Plan to make code+function
- `reanalyze_callers(ea, noret)` - Reanalyze all callers of address
- `revert_ida_decisions(ea1, ea2)` - Delete IDA-generated analysis for range

### Synchronous Analysis
- `auto_wait()` - Process all queues and wait (returns false if cancelled)
- `auto_wait_range(ea1, ea2)` - Process range and wait (returns step count or -1)
- `plan_and_wait(ea1, ea2, final_pass=True)` - Analyze range synchronously
- `auto_make_step(ea1, ea2)` - Analyze one address in range

### Queue Types (atype_t)
- `AU_CODE` (1) - Convert to instruction
- `AU_PROC` (3) - Convert to procedure start
- `AU_USED` (6) - Reanalyze
- `AU_TYPE` (8) - Apply type information
- `AU_FINAL` (13) - Final pass

### IDA State (idastate_t)
- `st_Ready` - IDA idle
- `st_Think` - Autoanalysis on
- `st_Waiting` - Waiting for input
- `st_Work` - IDA busy

## See Also
Full docs: skill/docs/ida_auto.rst

```

`skills/idapython/docs/ida_auto.rst`:

```rst
ida_auto
========

.. py:module:: ida_auto

.. autoapi-nested-parse::

   Functions that work with the autoanalyzer queue.

   The autoanalyzer works when IDA is not busy processing the user keystrokes. 
   It has several queues, each queue having its own priority. The analyzer stops 
   when all queues are empty.

   A queue contains addresses or address ranges. The addresses are kept sorted by 
   their values. The analyzer will process all addresses from the first queue, 
   then switch to the second queue and so on. There are no limitations on the 
   size of the queues.

   This file also contains functions that deal with the IDA status indicator and 
   the autoanalysis indicator. You may use these functions to change the 
   indicator value.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For auto-analysis operations, see :mod:`ida_domain.database`.



Attributes
----------

.. autoapisummary::

   ida_auto.cvar
   ida_auto.AU_NONE
   ida_auto.AU_UNK
   ida_auto.AU_CODE
   ida_auto.AU_WEAK
   ida_auto.AU_PROC
   ida_auto.AU_TAIL
   ida_auto.AU_FCHUNK
   ida_auto.AU_USED
   ida_auto.AU_USD2
   ida_auto.AU_TYPE
   ida_auto.AU_LIBF
   ida_auto.AU_LBF2
   ida_auto.AU_LBF3
   ida_auto.AU_CHLB
   ida_auto.AU_FINAL
   ida_auto.st_Ready
   ida_auto.st_Think
   ida_auto.st_Waiting
   ida_auto.st_Work


Classes
-------

.. autoapisummary::

   ida_auto.auto_display_t


Functions
---------

.. autoapisummary::

   ida_auto.get_auto_state
   ida_auto.set_auto_state
   ida_auto.get_auto_display
   ida_auto.show_auto
   ida_auto.show_addr
   ida_auto.set_ida_state
   ida_auto.may_create_stkvars
   ida_auto.may_trace_sp
   ida_auto.auto_mark_range
   ida_auto.auto_mark
   ida_auto.auto_unmark
   ida_auto.plan_ea
   ida_auto.plan_range
   ida_auto.auto_make_code
   ida_auto.auto_make_proc
   ida_auto.auto_postpone_analysis
   ida_auto.reanalyze_callers
   ida_auto.revert_ida_decisions
   ida_auto.auto_apply_type
   ida_auto.auto_apply_tail
   ida_auto.plan_and_wait
   ida_auto.auto_wait
   ida_auto.auto_wait_range
   ida_auto.auto_make_step
   ida_auto.auto_cancel
   ida_auto.auto_is_ok
   ida_auto.peek_auto_queue
   ida_auto.auto_get
   ida_auto.auto_recreate_insn
   ida_auto.is_auto_enabled
   ida_auto.enable_auto


Module Contents
---------------

.. py:function:: get_auto_state() -> atype_t

   Get current state of autoanalyzer. If auto_state == AU_NONE, IDA is currently not running the analysis (it could be temporarily interrupted to perform the user's requests, for example). 
           


.. py:function:: set_auto_state(new_state: atype_t) -> atype_t

   Set current state of autoanalyzer. 
           
   :param new_state: new state of autoanalyzer
   :returns: previous state


.. py:class:: auto_display_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: type
      :type:  atype_t


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: state
      :type:  idastate_t


.. py:data:: cvar

.. py:data:: AU_NONE

   placeholder, not used


.. py:data:: AU_UNK

   0: convert to unexplored


.. py:data:: AU_CODE

   1: convert to instruction


.. py:data:: AU_WEAK

   2: convert to instruction (ida decision)


.. py:data:: AU_PROC

   3: convert to procedure start


.. py:data:: AU_TAIL

   4: add a procedure tail


.. py:data:: AU_FCHUNK

   5: find func chunks


.. py:data:: AU_USED

   6: reanalyze


.. py:data:: AU_USD2

   7: reanalyze, second pass


.. py:data:: AU_TYPE

   8: apply type information


.. py:data:: AU_LIBF

   9: apply signature to address


.. py:data:: AU_LBF2

   10: the same, second pass


.. py:data:: AU_LBF3

   11: the same, third pass


.. py:data:: AU_CHLB

   12: load signature file (file name is kept separately)


.. py:data:: AU_FINAL

   13: final pass


.. py:data:: st_Ready

   READY: IDA is doing nothing.


.. py:data:: st_Think

   THINKING: Autoanalysis on, the user may press keys.


.. py:data:: st_Waiting

   WAITING: Waiting for the user input.


.. py:data:: st_Work

   BUSY: IDA is busy.


.. py:function:: get_auto_display(auto_display: auto_display_t) -> bool

   Get structure which holds the autoanalysis indicator contents.


.. py:function:: show_auto(*args) -> None

   Change autoanalysis indicator value. 
           
   :param ea: linear address being analyzed
   :param type: autoanalysis type (see Autoanalysis queues)


.. py:function:: show_addr(ea: ida_idaapi.ea_t) -> None

   Show an address on the autoanalysis indicator. The address is displayed in the form " @:12345678". 
           
   :param ea: - linear address to display


.. py:function:: set_ida_state(st: idastate_t) -> idastate_t

   Change IDA status indicator value 
           
   :param st: - new indicator status
   :returns: old indicator status


.. py:function:: may_create_stkvars() -> bool

   Is it allowed to create stack variables automatically?. This function should be used by IDP modules before creating stack vars. 
           


.. py:function:: may_trace_sp() -> bool

   Is it allowed to trace stack pointer automatically?. This function should be used by IDP modules before tracing sp. 
           


.. py:function:: auto_mark_range(start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, type: atype_t) -> None

   Put range of addresses into a queue. 'start' may be higher than 'end', the kernel will swap them in this case. 'end' doesn't belong to the range. 
           


.. py:function:: auto_mark(ea: ida_idaapi.ea_t, type: atype_t) -> None

   Put single address into a queue. Queues keep addresses sorted.


.. py:function:: auto_unmark(start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, type: atype_t) -> None

   Remove range of addresses from a queue. 'start' may be higher than 'end', the kernel will swap them in this case. 'end' doesn't belong to the range. 
           


.. py:function:: plan_ea(ea: ida_idaapi.ea_t) -> None

   Plan to perform reanalysis.


.. py:function:: plan_range(sEA: ida_idaapi.ea_t, eEA: ida_idaapi.ea_t) -> None

   Plan to perform reanalysis.


.. py:function:: auto_make_code(ea: ida_idaapi.ea_t) -> None

   Plan to make code.


.. py:function:: auto_make_proc(ea: ida_idaapi.ea_t) -> None

   Plan to make code&function.


.. py:function:: auto_postpone_analysis(ea: ida_idaapi.ea_t) -> bool

   Plan to reanalyze on the second pass The typical usage of this function in emu.cpp is: if ( !auto_postpone_analysis(ea) ) op_offset(ea, 0, ...); (we make an offset only on the second pass) 
           


.. py:function:: reanalyze_callers(ea: ida_idaapi.ea_t, noret: bool) -> None

   Plan to reanalyze callers of the specified address. This function will add to AU_USED queue all instructions that call (not jump to) the specified address. 
           
   :param ea: linear address of callee
   :param noret: !=0: the callee doesn't return, mark to undefine subsequent instructions in the caller. 0: do nothing.


.. py:function:: revert_ida_decisions(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None

   Delete all analysis info that IDA generated for for the given range.


.. py:function:: auto_apply_type(caller: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None

   Plan to apply the callee's type to the calling point.


.. py:function:: auto_apply_tail(tail_ea: ida_idaapi.ea_t, parent_ea: ida_idaapi.ea_t) -> None

   Plan to apply the tail_ea chunk to the parent 
           
   :param tail_ea: linear address of start of tail
   :param parent_ea: linear address within parent. If BADADDR, automatically try to find parent via xrefs.


.. py:function:: plan_and_wait(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, final_pass: bool = True) -> int

   Analyze the specified range. Try to create instructions where possible. Make the final pass over the specified range if specified. This function doesn't return until the range is analyzed. 
           
   :returns: 1: ok
   :returns: 0: Ctrl-Break was pressed


.. py:function:: auto_wait() -> bool

   Process everything in the queues and return true. 
           
   :returns: false if the user clicked cancel. (the wait box must be displayed by the caller if desired)


.. py:function:: auto_wait_range(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> ssize_t

   Process everything in the specified range and return true. 
           
   :returns: number of autoanalysis steps made. -1 if the user clicked cancel. (the wait box must be displayed by the caller if desired)


.. py:function:: auto_make_step(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool

   Analyze one address in the specified range and return true. 
           
   :returns: if processed anything. false means that there is nothing to process in the specified range.


.. py:function:: auto_cancel(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None

   Remove an address range (ea1..ea2) from queues AU_CODE, AU_PROC, AU_USED. To remove an address range from other queues use auto_unmark() function. 'ea1' may be higher than 'ea2', the kernel will swap them in this case. 'ea2' doesn't belong to the range. 
           


.. py:function:: auto_is_ok() -> bool

   Are all queues empty? (i.e. has autoanalysis finished?). 
           


.. py:function:: peek_auto_queue(low_ea: ida_idaapi.ea_t, type: atype_t) -> ida_idaapi.ea_t

   Peek into a queue 'type' for an address not lower than 'low_ea'. Do not remove address from the queue. 
           
   :returns: the address or BADADDR


.. py:function:: auto_get(type: atype_t *, lowEA: ida_idaapi.ea_t, highEA: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Retrieve an address from queues regarding their priority. Returns BADADDR if no addresses not lower than 'lowEA' and less than 'highEA' are found in the queues. Otherwise *type will have queue type. 
           


.. py:function:: auto_recreate_insn(ea: ida_idaapi.ea_t) -> int

   Try to create instruction 
           
   :param ea: linear address of callee
   :returns: the length of the instruction or 0


.. py:function:: is_auto_enabled() -> bool

   Get autoanalyzer state.


.. py:function:: enable_auto(enable: bool) -> bool

   Temporarily enable/disable autoanalyzer. Not user-facing, but rather because IDA sometimes need to turn AA on/off regardless of inf.s_genflags:INFFL_AUTO 
           
   :returns: old state



```

`skills/idapython/docs/ida_bitrange.md`:

```md
# ida_bitrange

Bitfield and bit-level range operations (low-priority, specialized use).

## Key Class

### bitrange_t
Represents a range of bits within a larger value.

- `init(bit_ofs, size_in_bits)` - Initialize offset and size
- `reset()` - Make empty
- `empty()` - Check if empty
- `bitoff()` / `bitsize()` / `bytesize()` - Get offset/size
- `mask64()` - Convert to 64-bit mask
- `has_common(r)` - Check overlap with another bitrange
- `intersect(r)` - Intersect two ranges
- `create_union(r)` - Union including hole between ranges
- `shift_down(cnt)` / `shift_up(cnt)` - Shift range left/right

## See Also
Full docs: skill/docs/ida_bitrange.rst

```

`skills/idapython/docs/ida_bitrange.rst`:

```rst
ida_bitrange
============

.. py:module:: ida_bitrange

.. autoapi-nested-parse::

   Definition of the bitrange_t class.



Classes
-------

.. autoapisummary::

   ida_bitrange.bitrange_t


Module Contents
---------------

.. py:class:: bitrange_t(bit_ofs: uint16 = 0, size_in_bits: uint16 = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: init(bit_ofs: uint16, size_in_bits: uint16) -> None

      Initialize offset and size to given values.



   .. py:method:: reset() -> None

      Make the bitrange empty.



   .. py:method:: empty() -> bool

      Is the bitrange empty?



   .. py:method:: bitoff() -> uint

      Get offset of 1st bit.



   .. py:method:: bitsize() -> uint

      Get size of the value in bits.



   .. py:method:: bytesize() -> uint

      Size of the value in bytes.



   .. py:method:: mask64() -> uint64

      Convert to mask of 64 bits.



   .. py:method:: has_common(r: bitrange_t) -> bool

      Does have common bits with another bitrange?



   .. py:method:: apply_mask(subrange: bitrange_t) -> bool

      Apply mask to a bitrange 
              
      :param subrange: range *inside* the main bitrange to keep After this operation the main bitrange will be truncated to have only the bits that are specified by subrange. Example: [off=8,nbits=4], subrange[off=1,nbits=2] => [off=9,nbits=2]
      :returns: success



   .. py:method:: intersect(r: bitrange_t) -> None

      Intersect two ranges.



   .. py:method:: create_union(r: bitrange_t) -> None

      Create union of 2 ranges including the hole between them.



   .. py:method:: sub(r: bitrange_t) -> bool

      Subtract a bitrange.



   .. py:method:: shift_down(cnt: uint) -> None

      Shift range down (left)



   .. py:method:: shift_up(cnt: uint) -> None

      Shift range up (right)



   .. py:method:: extract(src: void const *, is_mf: bool) -> bool


   .. py:method:: inject(dst: void *, src: bytevec_t const &, is_mf: bool) -> bool


   .. py:method:: compare(r: bitrange_t) -> int



```

`skills/idapython/docs/ida_bytes.md`:

```md
# ida_bytes

Byte-level operations: reading, writing, patching, flags, and data type creation.

## Navigation

### Head/Item Navigation
- `next_head(ea, maxea)` / `prev_head(ea, minea)` - Next/prev item head
- `get_item_head(ea)` - Get start of item containing ea
- `get_item_end(ea)` - Get address after item
- `get_item_size(ea)` - Get item size in bytes
- `next_chunk(ea, maxea)` / `prev_chunk(ea, minea)` - Next/prev contiguous chunk
- `next_unknown(ea, maxea)` / `prev_unknown(ea, minea)` - Next/prev undefined byte

## Reading Bytes

### Single Values
- `get_byte(ea)` / `get_word(ea)` / `get_dword(ea)` / `get_qword(ea)` - Read values
- `get_original_byte(ea)` - Read original file byte (before patches)
- `get_wide_byte(ea)` / `get_wide_word(ea)` - Read with byte size from inf.cc.size_i/size_s
- `get_data_value(ea, size)` - Read data item value (up to 64 bits)

### Bulk Operations
- `get_bytes(ea, size, gmb_flags=GMB_READALL)` - Read byte array
- `get_bytes_and_mask(ea, size, gmb_flags)` - Read bytes + mask (for wildcards)
- `get_strlit_contents(ea, length, strtype)` - Extract string literal

## Writing/Patching Bytes

### Patching (modifies IDB + file)
- `patch_byte(ea, value)` / `patch_word(ea)` / `patch_dword(ea)` / `patch_qword(ea)` - Patch values
- `patch_bytes(ea, buf)` - Patch byte array
- `revert_byte(ea)` - Revert to original file byte

### IDB Only (no file modification)
- `put_byte(ea, value)` / `put_word(ea)` / `put_dword(ea)` / `put_qword(ea)` - Update IDB only
- `put_bytes(ea, buf)` - Update byte array in IDB

## Flags & Type Checking

### Item Type
- `is_code(flags)` / `is_data(flags)` / `is_unknown(flags)` - Check item type
- `is_byte(ea)` / `is_word(ea)` / `is_dword(ea)` / `is_qword(ea)` - Check data size
- `is_strlit(ea)` - Check if string literal
- `is_struct(ea)` - Check if structure
- `is_tail(ea)` - Check if tail byte (not item head)

### Flag Operations
- `get_flags(ea)` - Get flags for address
- `get_full_flags(ea)` - Get full flags (includes hidden/extra data)

## Creating Data Items

### Basic Types
- `create_byte(ea, length, force=False)` - Create byte array
- `create_word(ea, length, force)` - Create word array
- `create_dword(ea, length, force)` - Create dword array
- `create_qword(ea, length, force)` - Create qword array
- `create_float(ea)` / `create_double(ea)` / `create_packed_real(ea)` - Create floats

### String & Struct
- `create_strlit(ea, length, strtype)` - Create string literal
- `create_struct(ea, size, tid)` - Apply structure at address
- `del_items(ea, flags=0, nbytes=1)` - Undefine items in range

## Searching

### Pattern Search
- `find_bytes(bs, range_start, range_size, mask, flags)` - Find byte pattern
- `bin_search(start, end, pattern, flags)` - Binary pattern search
- `parse_binpat_str(pattern, radix, strlits)` - Parse pattern string to compiled form

### Simple Search
- `find_byte(sEA, size, value, flags)` - Find single byte value
- `find_byter(sEA, size, value, flags)` - Find byte (reverse direction)

## Operand Representation

### Number Display
- `op_hex(ea, n)` / `op_dec(ea, n)` / `op_oct(ea, n)` / `op_bin(ea, n)` - Set operand radix
- `op_chr(ea, n)` - Display as character
- `op_num(ea, n)` - Display as number (default radix)
- `toggle_sign(ea, n)` - Toggle sign display

### Complex Types
- `op_offset(ea, n, reftype, target, base, tdelta)` - Create offset reference
- `op_enum(ea, n, enum_id, serial)` - Apply enum
- `op_stroff(ea, n, path, path_len, delta)` - Create structure offset
- `op_stkvar(ea, n)` - Reference stack variable

## Comments
- `get_cmt(ea, rptble)` / `set_cmt(ea, comm, rptble)` - Get/set comment
- `append_cmt(ea, str, rptble)` - Append to comment

## Constants

### Item Type Flags
- `FF_CODE` / `FF_DATA` / `FF_TAIL` / `FF_UNK` - Main type flags
- `FF_BYTE` / `FF_WORD` / `FF_DWORD` / `FF_QWORD` - Data size flags

### Search Flags
- `BIN_SEARCH_FORWARD` / `BIN_SEARCH_BACKWARD` - Search direction
- `BIN_SEARCH_CASE` / `BIN_SEARCH_NOCASE` - Case sensitivity
- `BIN_SEARCH_NOSHOW` - Suppress progress dialog

## See Also
Full docs: skill/docs/ida_bytes.rst

```

`skills/idapython/docs/ida_bytes.rst`:

```rst
ida_bytes
=========

.. py:module:: ida_bytes

.. autoapi-nested-parse::

   Contains functions that deal with individual byte characteristics.

   Each byte of the disassembled program is represented by a 32-bit value. We will 
   call this value 'flags'. The structure of the flags is here.

   You are not allowed to inspect individual bits of flags and modify them directly. 
   Use special functions to inspect and/or modify flags.

   Flags are kept in a virtual array file (*.id1). Addresses (ea) are all 32-bit 
   (or 64-bit) quantities.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For byte-level operations, see :mod:`ida_domain.bytes`.



Attributes
----------

.. autoapisummary::

   ida_bytes.ITEM_END_FIXUP
   ida_bytes.ITEM_END_INITED
   ida_bytes.ITEM_END_NAME
   ida_bytes.ITEM_END_XREF
   ida_bytes.ITEM_END_CANCEL
   ida_bytes.GFE_VALUE
   ida_bytes.GFE_IDB_VALUE
   ida_bytes.GFE_32BIT
   ida_bytes.MS_VAL
   ida_bytes.FF_IVL
   ida_bytes.GMB_READALL
   ida_bytes.GMB_WAITBOX
   ida_bytes.MS_CLS
   ida_bytes.FF_CODE
   ida_bytes.FF_DATA
   ida_bytes.FF_TAIL
   ida_bytes.FF_UNK
   ida_bytes.DELIT_SIMPLE
   ida_bytes.DELIT_EXPAND
   ida_bytes.DELIT_DELNAMES
   ida_bytes.DELIT_NOTRUNC
   ida_bytes.DELIT_NOUNAME
   ida_bytes.DELIT_NOCMT
   ida_bytes.DELIT_KEEPFUNC
   ida_bytes.MS_COMM
   ida_bytes.FF_COMM
   ida_bytes.FF_REF
   ida_bytes.FF_LINE
   ida_bytes.FF_NAME
   ida_bytes.FF_LABL
   ida_bytes.FF_FLOW
   ida_bytes.FF_SIGN
   ida_bytes.FF_BNOT
   ida_bytes.FF_UNUSED
   ida_bytes.FF_ANYNAME
   ida_bytes.MS_N_TYPE
   ida_bytes.FF_N_VOID
   ida_bytes.FF_N_NUMH
   ida_bytes.FF_N_NUMD
   ida_bytes.FF_N_CHAR
   ida_bytes.FF_N_SEG
   ida_bytes.FF_N_OFF
   ida_bytes.FF_N_NUMB
   ida_bytes.FF_N_NUMO
   ida_bytes.FF_N_ENUM
   ida_bytes.FF_N_FOP
   ida_bytes.FF_N_STRO
   ida_bytes.FF_N_STK
   ida_bytes.FF_N_FLT
   ida_bytes.FF_N_CUST
   ida_bytes.OPND_OUTER
   ida_bytes.OPND_MASK
   ida_bytes.OPND_ALL
   ida_bytes.DT_TYPE
   ida_bytes.FF_BYTE
   ida_bytes.FF_WORD
   ida_bytes.FF_DWORD
   ida_bytes.FF_QWORD
   ida_bytes.FF_TBYTE
   ida_bytes.FF_STRLIT
   ida_bytes.FF_STRUCT
   ida_bytes.FF_OWORD
   ida_bytes.FF_FLOAT
   ida_bytes.FF_DOUBLE
   ida_bytes.FF_PACKREAL
   ida_bytes.FF_ALIGN
   ida_bytes.FF_CUSTOM
   ida_bytes.FF_YWORD
   ida_bytes.FF_ZWORD
   ida_bytes.ALOPT_IGNHEADS
   ida_bytes.ALOPT_IGNPRINT
   ida_bytes.ALOPT_IGNCLT
   ida_bytes.ALOPT_MAX4K
   ida_bytes.ALOPT_ONLYTERM
   ida_bytes.ALOPT_APPEND
   ida_bytes.STRCONV_ESCAPE
   ida_bytes.STRCONV_REPLCHAR
   ida_bytes.STRCONV_INCLLEN
   ida_bytes.PSTF_TNORM
   ida_bytes.PSTF_TBRIEF
   ida_bytes.PSTF_TINLIN
   ida_bytes.PSTF_TMASK
   ida_bytes.PSTF_HOTKEY
   ida_bytes.PSTF_ENC
   ida_bytes.PSTF_ONLY_ENC
   ida_bytes.PSTF_ATTRIB
   ida_bytes.MS_CODE
   ida_bytes.FF_FUNC
   ida_bytes.FF_IMMD
   ida_bytes.FF_JUMP
   ida_bytes.DTP_NODUP
   ida_bytes.PBSENC_DEF1BPU
   ida_bytes.PBSENC_ALL
   ida_bytes.BIN_SEARCH_CASE
   ida_bytes.BIN_SEARCH_NOCASE
   ida_bytes.BIN_SEARCH_NOBREAK
   ida_bytes.BIN_SEARCH_INITED
   ida_bytes.BIN_SEARCH_NOSHOW
   ida_bytes.BIN_SEARCH_FORWARD
   ida_bytes.BIN_SEARCH_BACKWARD
   ida_bytes.BIN_SEARCH_BITMASK
   ida_bytes.MS_0TYPE
   ida_bytes.FF_0VOID
   ida_bytes.FF_0NUMH
   ida_bytes.FF_0NUMD
   ida_bytes.FF_0CHAR
   ida_bytes.FF_0SEG
   ida_bytes.FF_0OFF
   ida_bytes.FF_0NUMB
   ida_bytes.FF_0NUMO
   ida_bytes.FF_0ENUM
   ida_bytes.FF_0FOP
   ida_bytes.FF_0STRO
   ida_bytes.FF_0STK
   ida_bytes.FF_0FLT
   ida_bytes.FF_0CUST
   ida_bytes.MS_1TYPE
   ida_bytes.FF_1VOID
   ida_bytes.FF_1NUMH
   ida_bytes.FF_1NUMD
   ida_bytes.FF_1CHAR
   ida_bytes.FF_1SEG
   ida_bytes.FF_1OFF
   ida_bytes.FF_1NUMB
   ida_bytes.FF_1NUMO
   ida_bytes.FF_1ENUM
   ida_bytes.FF_1FOP
   ida_bytes.FF_1STRO
   ida_bytes.FF_1STK
   ida_bytes.FF_1FLT
   ida_bytes.FF_1CUST
   ida_bytes.DTP_NODUP


Classes
-------

.. autoapisummary::

   ida_bytes.compiled_binpat_vec_t
   ida_bytes.octet_generator_t
   ida_bytes.data_type_t
   ida_bytes.data_format_t
   ida_bytes.compiled_binpat_t
   ida_bytes.hidden_range_t


Functions
---------

.. autoapisummary::

   ida_bytes.enable_flags
   ida_bytes.disable_flags
   ida_bytes.change_storage_type
   ida_bytes.next_addr
   ida_bytes.prev_addr
   ida_bytes.next_chunk
   ida_bytes.prev_chunk
   ida_bytes.chunk_start
   ida_bytes.chunk_size
   ida_bytes.find_free_chunk
   ida_bytes.next_that
   ida_bytes.next_unknown
   ida_bytes.prev_that
   ida_bytes.prev_unknown
   ida_bytes.prev_head
   ida_bytes.next_head
   ida_bytes.prev_not_tail
   ida_bytes.next_not_tail
   ida_bytes.prev_visea
   ida_bytes.next_visea
   ida_bytes.get_item_head
   ida_bytes.get_item_end
   ida_bytes.calc_max_item_end
   ida_bytes.get_item_size
   ida_bytes.is_mapped
   ida_bytes.get_flags_ex
   ida_bytes.get_flags32
   ida_bytes.get_flags
   ida_bytes.get_full_flags
   ida_bytes.get_item_flag
   ida_bytes.get_item_refinfo
   ida_bytes.has_value
   ida_bytes.del_value
   ida_bytes.is_loaded
   ida_bytes.nbits
   ida_bytes.bytesize
   ida_bytes.get_byte
   ida_bytes.get_db_byte
   ida_bytes.get_word
   ida_bytes.get_dword
   ida_bytes.get_qword
   ida_bytes.get_wide_byte
   ida_bytes.get_wide_word
   ida_bytes.get_wide_dword
   ida_bytes.get_octet
   ida_bytes.get_16bit
   ida_bytes.get_32bit
   ida_bytes.get_64bit
   ida_bytes.get_data_value
   ida_bytes.get_original_byte
   ida_bytes.get_original_word
   ida_bytes.get_original_dword
   ida_bytes.get_original_qword
   ida_bytes.put_byte
   ida_bytes.put_word
   ida_bytes.put_dword
   ida_bytes.put_qword
   ida_bytes.patch_byte
   ida_bytes.patch_word
   ida_bytes.patch_dword
   ida_bytes.patch_qword
   ida_bytes.revert_byte
   ida_bytes.add_byte
   ida_bytes.add_word
   ida_bytes.add_dword
   ida_bytes.add_qword
   ida_bytes.get_zero_ranges
   ida_bytes.put_bytes
   ida_bytes.patch_bytes
   ida_bytes.is_code
   ida_bytes.f_is_code
   ida_bytes.is_data
   ida_bytes.f_is_data
   ida_bytes.is_tail
   ida_bytes.f_is_tail
   ida_bytes.is_not_tail
   ida_bytes.f_is_not_tail
   ida_bytes.is_unknown
   ida_bytes.is_head
   ida_bytes.f_is_head
   ida_bytes.del_items
   ida_bytes.is_manual_insn
   ida_bytes.get_manual_insn
   ida_bytes.set_manual_insn
   ida_bytes.is_flow
   ida_bytes.has_extra_cmts
   ida_bytes.f_has_extra_cmts
   ida_bytes.has_cmt
   ida_bytes.f_has_cmt
   ida_bytes.has_xref
   ida_bytes.f_has_xref
   ida_bytes.has_name
   ida_bytes.f_has_name
   ida_bytes.has_dummy_name
   ida_bytes.f_has_dummy_name
   ida_bytes.has_auto_name
   ida_bytes.has_any_name
   ida_bytes.has_user_name
   ida_bytes.f_has_user_name
   ida_bytes.is_invsign
   ida_bytes.toggle_sign
   ida_bytes.is_bnot
   ida_bytes.toggle_bnot
   ida_bytes.is_lzero
   ida_bytes.set_lzero
   ida_bytes.clr_lzero
   ida_bytes.toggle_lzero
   ida_bytes.leading_zero_important
   ida_bytes.get_operand_type_shift
   ida_bytes.get_operand_flag
   ida_bytes.is_flag_for_operand
   ida_bytes.is_defarg0
   ida_bytes.is_defarg1
   ida_bytes.is_off0
   ida_bytes.is_off1
   ida_bytes.is_char0
   ida_bytes.is_char1
   ida_bytes.is_seg0
   ida_bytes.is_seg1
   ida_bytes.is_enum0
   ida_bytes.is_enum1
   ida_bytes.is_stroff0
   ida_bytes.is_stroff1
   ida_bytes.is_stkvar0
   ida_bytes.is_stkvar1
   ida_bytes.is_float0
   ida_bytes.is_float1
   ida_bytes.is_custfmt0
   ida_bytes.is_custfmt1
   ida_bytes.is_numop0
   ida_bytes.is_numop1
   ida_bytes.get_optype_flags0
   ida_bytes.get_optype_flags1
   ida_bytes.is_defarg
   ida_bytes.is_off
   ida_bytes.is_char
   ida_bytes.is_seg
   ida_bytes.is_enum
   ida_bytes.is_manual
   ida_bytes.is_stroff
   ida_bytes.is_stkvar
   ida_bytes.is_fltnum
   ida_bytes.is_custfmt
   ida_bytes.is_numop
   ida_bytes.is_suspop
   ida_bytes.op_adds_xrefs
   ida_bytes.set_op_type
   ida_bytes.op_seg
   ida_bytes.op_enum
   ida_bytes.get_enum_id
   ida_bytes.op_based_stroff
   ida_bytes.op_stkvar
   ida_bytes.set_forced_operand
   ida_bytes.get_forced_operand
   ida_bytes.is_forced_operand
   ida_bytes.combine_flags
   ida_bytes.char_flag
   ida_bytes.off_flag
   ida_bytes.enum_flag
   ida_bytes.stroff_flag
   ida_bytes.stkvar_flag
   ida_bytes.flt_flag
   ida_bytes.custfmt_flag
   ida_bytes.seg_flag
   ida_bytes.num_flag
   ida_bytes.hex_flag
   ida_bytes.dec_flag
   ida_bytes.oct_flag
   ida_bytes.bin_flag
   ida_bytes.op_chr
   ida_bytes.op_num
   ida_bytes.op_hex
   ida_bytes.op_dec
   ida_bytes.op_oct
   ida_bytes.op_bin
   ida_bytes.op_flt
   ida_bytes.op_custfmt
   ida_bytes.clr_op_type
   ida_bytes.get_default_radix
   ida_bytes.get_radix
   ida_bytes.code_flag
   ida_bytes.byte_flag
   ida_bytes.word_flag
   ida_bytes.dword_flag
   ida_bytes.qword_flag
   ida_bytes.oword_flag
   ida_bytes.yword_flag
   ida_bytes.zword_flag
   ida_bytes.tbyte_flag
   ida_bytes.strlit_flag
   ida_bytes.stru_flag
   ida_bytes.cust_flag
   ida_bytes.align_flag
   ida_bytes.float_flag
   ida_bytes.double_flag
   ida_bytes.packreal_flag
   ida_bytes.is_byte
   ida_bytes.is_word
   ida_bytes.is_dword
   ida_bytes.is_qword
   ida_bytes.is_oword
   ida_bytes.is_yword
   ida_bytes.is_zword
   ida_bytes.is_tbyte
   ida_bytes.is_float
   ida_bytes.is_double
   ida_bytes.is_pack_real
   ida_bytes.is_strlit
   ida_bytes.is_struct
   ida_bytes.is_align
   ida_bytes.is_custom
   ida_bytes.f_is_byte
   ida_bytes.f_is_word
   ida_bytes.f_is_dword
   ida_bytes.f_is_qword
   ida_bytes.f_is_oword
   ida_bytes.f_is_yword
   ida_bytes.f_is_tbyte
   ida_bytes.f_is_float
   ida_bytes.f_is_double
   ida_bytes.f_is_pack_real
   ida_bytes.f_is_strlit
   ida_bytes.f_is_struct
   ida_bytes.f_is_align
   ida_bytes.f_is_custom
   ida_bytes.is_same_data_type
   ida_bytes.get_flags_by_size
   ida_bytes.create_data
   ida_bytes.calc_dflags
   ida_bytes.create_byte
   ida_bytes.create_word
   ida_bytes.create_dword
   ida_bytes.create_qword
   ida_bytes.create_oword
   ida_bytes.create_yword
   ida_bytes.create_zword
   ida_bytes.create_tbyte
   ida_bytes.create_float
   ida_bytes.create_double
   ida_bytes.create_packed_real
   ida_bytes.create_struct
   ida_bytes.create_custdata
   ida_bytes.create_align
   ida_bytes.calc_min_align
   ida_bytes.calc_max_align
   ida_bytes.calc_def_align
   ida_bytes.create_16bit_data
   ida_bytes.create_32bit_data
   ida_bytes.get_max_strlit_length
   ida_bytes.create_strlit
   ida_bytes.get_opinfo
   ida_bytes.set_opinfo
   ida_bytes.get_data_elsize
   ida_bytes.get_full_data_elsize
   ida_bytes.is_varsize_item
   ida_bytes.get_possible_item_varsize
   ida_bytes.can_define_item
   ida_bytes.has_immd
   ida_bytes.is_func
   ida_bytes.set_immd
   ida_bytes.get_custom_data_type
   ida_bytes.get_custom_data_format
   ida_bytes.attach_custom_data_format
   ida_bytes.detach_custom_data_format
   ida_bytes.is_attached_custom_data_format
   ida_bytes.get_custom_data_types
   ida_bytes.get_custom_data_formats
   ida_bytes.find_custom_data_type
   ida_bytes.find_custom_data_format
   ida_bytes.set_cmt
   ida_bytes.get_cmt
   ida_bytes.append_cmt
   ida_bytes.get_predef_insn_cmt
   ida_bytes.find_byte
   ida_bytes.find_byter
   ida_bytes.parse_binpat_str
   ida_bytes.bin_search
   ida_bytes.next_inited
   ida_bytes.prev_inited
   ida_bytes.equal_bytes
   ida_bytes.update_hidden_range
   ida_bytes.add_hidden_range
   ida_bytes.get_hidden_range
   ida_bytes.getn_hidden_range
   ida_bytes.get_hidden_range_qty
   ida_bytes.get_hidden_range_num
   ida_bytes.get_prev_hidden_range
   ida_bytes.get_next_hidden_range
   ida_bytes.get_first_hidden_range
   ida_bytes.get_last_hidden_range
   ida_bytes.del_hidden_range
   ida_bytes.add_mapping
   ida_bytes.del_mapping
   ida_bytes.use_mapping
   ida_bytes.get_mappings_qty
   ida_bytes.get_mapping
   ida_bytes.visit_patched_bytes
   ida_bytes.get_bytes
   ida_bytes.get_bytes_and_mask
   ida_bytes.get_strlit_contents
   ida_bytes.print_strlit_type
   ida_bytes.op_stroff
   ida_bytes.get_stroff_path
   ida_bytes.register_custom_data_type
   ida_bytes.unregister_custom_data_type
   ida_bytes.register_custom_data_format
   ida_bytes.unregister_custom_data_format
   ida_bytes.register_data_types_and_formats
   ida_bytes.unregister_data_types_and_formats
   ida_bytes.find_bytes
   ida_bytes.find_string


Module Contents
---------------

.. py:class:: compiled_binpat_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> compiled_binpat_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> compiled_binpat_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: compiled_binpat_vec_t) -> None


   .. py:method:: extract() -> compiled_binpat_t *


   .. py:method:: inject(s: compiled_binpat_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< compiled_binpat_t >::const_iterator


   .. py:method:: end(*args) -> qvector< compiled_binpat_t >::const_iterator


   .. py:method:: insert(it: compiled_binpat_t, x: compiled_binpat_t) -> qvector< compiled_binpat_t >::iterator


   .. py:method:: erase(*args) -> qvector< compiled_binpat_t >::iterator


   .. py:method:: find(*args) -> qvector< compiled_binpat_t >::const_iterator


   .. py:method:: has(x: compiled_binpat_t) -> bool


   .. py:method:: add_unique(x: compiled_binpat_t) -> bool


   .. py:method:: append(x: compiled_binpat_t) -> None


   .. py:method:: extend(x: compiled_binpat_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


   .. py:method:: parse(ea: ida_idaapi.ea_t, text: str, radix: int = -1, strlits_encoding: int = -1) -> compiled_binpat_vec_t
      :staticmethod:


      Convert user-specified binary string to internal representation.

      The 'in' parameter contains space-separated tokens:

          *numbers (numeric base is determined by 'radix')
              - if value of number fits a byte, it is considered as a byte
              - if value of number fits a word, it is considered as 2 bytes
              - if value of number fits a dword,it is considered as 4 bytes
          * "..." string constants
          * 'x'  single-character constants
          * ?    variable bytes

      Note that string constants are surrounded with double quotes.

      Here are a few examples (assuming base 16):

          * CD 21          - bytes 0xCD, 0x21
          * 21CD           - bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)
          * "Hello", 0     - the null terminated string "Hello"
          * L"Hello"       - 'H', 0, 'e', 0, 'l', 0, 'l', 0, 'o', 0
          * B8 ? ? ? ? 90  - byte 0xB8, 4 bytes with any value, byte 0x90

      This method will throw an exception if the pattern could not be parsed

      :param ea: linear address to convert for (the conversion depends on the
                 address, because the number of bits in a byte depend on the
                 segment type)
      :param text: input text string
      :param radix: numeric base of numbers (8,10,16). If `-1` (the default), then the default radix will be used (see get_default_radix)
      :param strlits_encoding: the target encoding into which the string
                           literals present in 'in', should be encoded.
                           Can be any from [1, get_encoding_qty()), or
                           the special values PBSENC_*
      :returns: a set of patterns



.. py:function:: enable_flags(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, stt: storage_type_t) -> error_t

   Allocate flags for address range. This function does not change the storage type of existing ranges. Exit with an error message if not enough disk space. 
           
   :param start_ea: should be lower than end_ea.
   :param end_ea: does not belong to the range.
   :param stt: storage_type_t
   :returns: 0 if ok, otherwise an error code


.. py:function:: disable_flags(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t) -> error_t

   Deallocate flags for address range. Exit with an error message if not enough disk space (this may occur too). 
           
   :param start_ea: should be lower than end_ea.
   :param end_ea: does not belong to the range.
   :returns: 0 if ok, otherwise return error code


.. py:function:: change_storage_type(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, stt: storage_type_t) -> error_t

   Change flag storage type for address range. 
           
   :param start_ea: should be lower than end_ea.
   :param end_ea: does not belong to the range.
   :param stt: storage_type_t
   :returns: error code


.. py:function:: next_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get next address in the program (i.e. next address which has flags). 
           
   :returns: BADADDR if no such address exist.


.. py:function:: prev_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get previous address in the program. 
           
   :returns: BADADDR if no such address exist.


.. py:function:: next_chunk(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get the first address of next contiguous chunk in the program. 
           
   :returns: BADADDR if next chunk doesn't exist.


.. py:function:: prev_chunk(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get the last address of previous contiguous chunk in the program. 
           
   :returns: BADADDR if previous chunk doesn't exist.


.. py:function:: chunk_start(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get start of the contiguous address block containing 'ea'. 
           
   :returns: BADADDR if 'ea' doesn't belong to the program.


.. py:function:: chunk_size(ea: ida_idaapi.ea_t) -> asize_t

   Get size of the contiguous address block containing 'ea'. 
           
   :returns: 0 if 'ea' doesn't belong to the program.


.. py:function:: find_free_chunk(start: ida_idaapi.ea_t, size: asize_t, alignment: asize_t) -> ida_idaapi.ea_t

   Search for a hole in the addressing space of the program. 
           
   :param start: Address to start searching from
   :param size: Size of the desired empty range
   :param alignment: Alignment bitmask, must be a pow2-1. (for example, 0xF would align the returned range to 16 bytes).
   :returns: Start of the found empty range or BADADDR


.. py:function:: next_that(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t, testf: testf_t *) -> ida_idaapi.ea_t

   Find next address with a flag satisfying the function 'testf'. 
           
   :param ea: start searching at this address + 1
   :param maxea: not included in the search range.
   :param testf: test function to find next address
   :returns: the found address or BADADDR.


.. py:function:: next_unknown(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Similar to next_that(), but will find the next address that is unexplored.


.. py:function:: prev_that(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t, testf: testf_t *) -> ida_idaapi.ea_t

   Find previous address with a flag satisfying the function 'testf'. 
           
   :param ea: start searching from this address - 1.
   :param minea: included in the search range.
   :param testf: test function to find previous address
   :returns: the found address or BADADDR.


.. py:function:: prev_unknown(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Similar to prev_that(), but will find the previous address that is unexplored.


.. py:function:: prev_head(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get start of previous defined item. 
           
   :param ea: begin search at this address
   :param minea: included in the search range
   :returns: BADADDR if none exists.


.. py:function:: next_head(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get start of next defined item. 
           
   :param ea: begin search at this address
   :param maxea: not included in the search range
   :returns: BADADDR if none exists.


.. py:function:: prev_not_tail(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get address of previous non-tail byte. 
           
   :returns: BADADDR if none exists.


.. py:function:: next_not_tail(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get address of next non-tail byte. 
           
   :returns: BADADDR if none exists.


.. py:function:: prev_visea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get previous visible address. 
           
   :returns: BADADDR if none exists.


.. py:function:: next_visea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get next visible address. 
           
   :returns: BADADDR if none exists.


.. py:function:: get_item_head(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get the start address of the item at 'ea'. If there is no current item, then 'ea' will be returned (see definition at the end of bytes.hpp source) 
           


.. py:function:: get_item_end(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get the end address of the item at 'ea'. The returned address doesn't belong to the current item. Unexplored bytes are counted as 1 byte entities. 
           


.. py:function:: calc_max_item_end(ea: ida_idaapi.ea_t, how: int = 15) -> ida_idaapi.ea_t

   Calculate maximal reasonable end address of a new item. This function will limit the item with the current segment bounds. 
           
   :param ea: linear address
   :param how: when to stop the search. A combination of Item end search flags
   :returns: end of new item. If it is not possible to create an item, it will return 'ea'. If operation was cancelled by user, it will return 'ea'


.. py:data:: ITEM_END_FIXUP

   stop at the first fixup


.. py:data:: ITEM_END_INITED

   stop when initialization changes i.e.
   * if is_loaded(ea): stop if uninitialized byte is encountered
   * if !is_loaded(ea): stop if initialized byte is encountered 


           


.. py:data:: ITEM_END_NAME

   stop at the first named location


.. py:data:: ITEM_END_XREF

   stop at the first referenced location


.. py:data:: ITEM_END_CANCEL

   stop when operation cancelled, it is the responsibility of the caller to show the wait dialog 
           


.. py:function:: get_item_size(ea: ida_idaapi.ea_t) -> asize_t

   Get size of item (instruction/data) in bytes. Unexplored bytes have length of 1 byte. This function returns 0 only for BADADDR. 
           


.. py:function:: is_mapped(ea: ida_idaapi.ea_t) -> bool

   Is the specified address 'ea' present in the program?


.. py:function:: get_flags_ex(ea: ida_idaapi.ea_t, how: int) -> flags64_t

   Get flags for the specified address, extended form.


.. py:data:: GFE_VALUE

   get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because the kernel needs to read the process memory. 
           


.. py:data:: GFE_IDB_VALUE

   get flags with FF_IVL & MS_VAL. but never use the debugger memory. 
           


.. py:data:: GFE_32BIT

   get only low 32 bits of flags


.. py:function:: get_flags32(ea: ida_idaapi.ea_t) -> flags64_t

   Get only 32 low bits of flags. This function returns the most commonly used bits of the flags. However, it does not return the operand info for the operands beyond the first two operands (0,1). If you need to deal with the operands (2..n), then use get_flags(). It is customary to assign the return value to the variable named "F32", to distinguish is from 64-bit flags. 
           
   :returns: 0 if address is not present in the program


.. py:function:: get_flags(ea: ida_idaapi.ea_t) -> flags64_t

   Get flags value for address 'ea'. The byte value is not included in the flags. This function should be used if the operand types of any operand beyond the first two operands is required. This function is more expensive to use than get_flags32() 
           
   :returns: 0 if address is not present in the program


.. py:function:: get_full_flags(ea: ida_idaapi.ea_t) -> flags64_t

   Get full flags value for address 'ea'. This function returns the byte value in the flags as well. See FF_IVL and MS_VAL. This function is more expensive to use than get_flags() 
           
   :returns: 0 if address is not present in the program


.. py:function:: get_item_flag(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, appzero: bool) -> flags64_t

   Get flag of the item at 'ea' even if it is a tail byte of some array or structure. This function is used to get flags of structure members or array elements. 
           
   :param n: operand number which refers to 'ea' or OPND_ALL for one of the operands
   :param ea: the referenced address
   :param appzero: append a struct field name if the field offset is zero? meaningful only if the name refers to a structure.
   :returns: flags or 0 (if failed)


.. py:function:: get_item_refinfo(ri: refinfo_t, ea: ida_idaapi.ea_t, n: int) -> bool

   Get refinfo of the item at 'ea'. This function works for a regular offset operand as well as for a tail byte of a structure variable (in this case refinfo to corresponding structure member will be returned) 
           
   :param ri: refinfo holder
   :param ea: the item address
   :param n: operand number which refers to 'ea' or OPND_ALL for one of the operands
   :returns: success


.. py:data:: MS_VAL

   Mask for byte value.


.. py:data:: FF_IVL

   Byte has value ?


.. py:function:: has_value(F: flags64_t) -> bool

   Do flags contain byte value?


.. py:function:: del_value(ea: ida_idaapi.ea_t) -> None

   Delete byte value from flags. The corresponding byte becomes uninitialized. 
           


.. py:function:: is_loaded(ea: ida_idaapi.ea_t) -> bool

   Does the specified address have a byte value (is initialized?)


.. py:function:: nbits(ea: ida_idaapi.ea_t) -> int

   Get number of bits in a byte at the given address. 
           
   :returns: processor_t::dnbits() if the address doesn't belong to a segment, otherwise the result depends on the segment type


.. py:function:: bytesize(ea: ida_idaapi.ea_t) -> int

   Get number of bytes required to store a byte at the given address.


.. py:function:: get_byte(ea: ida_idaapi.ea_t) -> uchar

   Get one byte (8-bit) of the program at 'ea'. This function works only for 8bit byte processors. 
           


.. py:function:: get_db_byte(ea: ida_idaapi.ea_t) -> uchar

   Get one byte (8-bit) of the program at 'ea' from the database. Works even if the debugger is active. See also get_dbg_byte() to read the process memory directly. This function works only for 8bit byte processors. 
           


.. py:function:: get_word(ea: ida_idaapi.ea_t) -> ushort

   Get one word (16-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
           


.. py:function:: get_dword(ea: ida_idaapi.ea_t) -> int

   Get one dword (32-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
           


.. py:function:: get_qword(ea: ida_idaapi.ea_t) -> uint64

   Get one qword (64-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
           


.. py:function:: get_wide_byte(ea: ida_idaapi.ea_t) -> uint64

   Get one wide byte of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. 
           


.. py:function:: get_wide_word(ea: ida_idaapi.ea_t) -> uint64

   Get one wide word (2 'byte') of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() 
           


.. py:function:: get_wide_dword(ea: ida_idaapi.ea_t) -> uint64

   Get two wide words (4 'bytes') of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() 
           


.. py:class:: octet_generator_t(_ea: ida_idaapi.ea_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: value
      :type:  uint64


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: avail_bits
      :type:  int


   .. py:attribute:: high_byte_first
      :type:  bool


   .. py:method:: invert_byte_order() -> None


.. py:function:: get_octet(ogen: octet_generator_t) -> uchar *

.. py:function:: get_16bit(ea: ida_idaapi.ea_t) -> int

   Get 16bits of the program at 'ea'. 
           
   :returns: 1 byte (getFullByte()) if the current processor has 16-bit byte, otherwise return get_word()


.. py:function:: get_32bit(ea: ida_idaapi.ea_t) -> int

   Get not more than 32bits of the program at 'ea'. 
           
   :returns: 32 bit value, depending on processor_t::nbits:
   * if ( nbits <= 8 ) return get_dword(ea);
   * if ( nbits <= 16) return get_wide_word(ea);
   * return get_wide_byte(ea);


.. py:function:: get_64bit(ea: ida_idaapi.ea_t) -> uint64

   Get not more than 64bits of the program at 'ea'. 
           
   :returns: 64 bit value, depending on processor_t::nbits:
   * if ( nbits <= 8 ) return get_qword(ea);
   * if ( nbits <= 16) return get_wide_dword(ea);
   * return get_wide_byte(ea);


.. py:function:: get_data_value(v: uval_t *, ea: ida_idaapi.ea_t, size: asize_t) -> bool

   Get the value at of the item at 'ea'. This function works with entities up to sizeof(ea_t) (bytes, word, etc) 
           
   :param v: pointer to the result. may be nullptr
   :param ea: linear address
   :param size: size of data to read. If 0, then the item type at 'ea' will be used
   :returns: success


.. py:function:: get_original_byte(ea: ida_idaapi.ea_t) -> uint64

   Get original byte value (that was before patching). This function works for wide byte processors too. 
           


.. py:function:: get_original_word(ea: ida_idaapi.ea_t) -> uint64

   Get original word value (that was before patching). This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
           


.. py:function:: get_original_dword(ea: ida_idaapi.ea_t) -> uint64

   Get original dword (that was before patching) This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
           


.. py:function:: get_original_qword(ea: ida_idaapi.ea_t) -> uint64

   Get original qword value (that was before patching) This function DOESN'T work for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
           


.. py:function:: put_byte(ea: ida_idaapi.ea_t, x: uint64) -> bool

   Set value of one byte of the program. This function modifies the database. If the debugger is active then the debugged process memory is patched too. 
           
   :param ea: linear address
   :param x: byte value
   :returns: true if the database has been modified


.. py:function:: put_word(ea: ida_idaapi.ea_t, x: uint64) -> None

   Set value of one word of the program. This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. 
           


.. py:function:: put_dword(ea: ida_idaapi.ea_t, x: uint64) -> None

   Set value of one dword of the program. This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. 
           
   :param ea: linear address
   :param x: dword value


.. py:function:: put_qword(ea: ida_idaapi.ea_t, x: uint64) -> None

   Set value of one qword (8 bytes) of the program. This function takes into account order of bytes specified in idainfo::is_be() This function DOESN'T works for wide byte processors. 
           
   :param ea: linear address
   :param x: qword value


.. py:function:: patch_byte(ea: ida_idaapi.ea_t, x: uint64) -> bool

   Patch a byte of the program. The original value of the byte is saved and can be obtained by get_original_byte(). This function works for wide byte processors too. 
           
   :returns: true: the database has been modified,
   :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.


.. py:function:: patch_word(ea: ida_idaapi.ea_t, x: uint64) -> bool

   Patch a word of the program. The original value of the word is saved and can be obtained by get_original_word(). This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
           
   :returns: true: the database has been modified,
   :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.


.. py:function:: patch_dword(ea: ida_idaapi.ea_t, x: uint64) -> bool

   Patch a dword of the program. The original value of the dword is saved and can be obtained by get_original_dword(). This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
           
   :returns: true: the database has been modified,
   :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.


.. py:function:: patch_qword(ea: ida_idaapi.ea_t, x: uint64) -> bool

   Patch a qword of the program. The original value of the qword is saved and can be obtained by get_original_qword(). This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
           
   :returns: true: the database has been modified,
   :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.


.. py:function:: revert_byte(ea: ida_idaapi.ea_t) -> bool

   Revert patched byte 
           
   :returns: true: byte was patched before and reverted now


.. py:function:: add_byte(ea: ida_idaapi.ea_t, value: int) -> None

   Add a value to one byte of the program. This function works for wide byte processors too. 
           
   :param ea: linear address
   :param value: byte value


.. py:function:: add_word(ea: ida_idaapi.ea_t, value: uint64) -> None

   Add a value to one word of the program. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
           
   :param ea: linear address
   :param value: byte value


.. py:function:: add_dword(ea: ida_idaapi.ea_t, value: uint64) -> None

   Add a value to one dword of the program. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
           
   :param ea: linear address
   :param value: byte value


.. py:function:: add_qword(ea: ida_idaapi.ea_t, value: uint64) -> None

   Add a value to one qword of the program. This function does not work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
           
   :param ea: linear address
   :param value: byte value


.. py:function:: get_zero_ranges(zranges: rangeset_t, range: range_t) -> bool

   Return set of ranges with zero initialized bytes. The returned set includes only big zero initialized ranges (at least >1KB). Some zero initialized byte ranges may be not included. Only zero bytes that use the sparse storage method (STT_MM) are reported. 
           
   :param zranges: pointer to the return value. cannot be nullptr
   :param range: the range of addresses to verify. can be nullptr - means all ranges
   :returns: true if the result is a non-empty set


.. py:data:: GMB_READALL

   try to read all bytes; if this bit is not set, fail at first uninited byte 
           


.. py:data:: GMB_WAITBOX

   show wait box (may return -1 in this case)


.. py:function:: put_bytes(ea: ida_idaapi.ea_t, buf: void const *) -> None

   Modify the specified number of bytes of the program. This function does not save the original values of bytes. See also patch_bytes(). 
           
   :param ea: linear address
   :param buf: buffer with new values of bytes


.. py:function:: patch_bytes(ea: ida_idaapi.ea_t, buf: void const *) -> None

   Patch the specified number of bytes of the program. Original values of bytes are saved and are available with get_original...() functions. See also put_bytes(). 
           
   :param ea: linear address
   :param buf: buffer with new values of bytes


.. py:data:: MS_CLS

   Mask for typing.


.. py:data:: FF_CODE

   Code ?


.. py:data:: FF_DATA

   Data ?


.. py:data:: FF_TAIL

   Tail ?


.. py:data:: FF_UNK

   Unknown ?


.. py:function:: is_code(F: flags64_t) -> bool

   Does flag denote start of an instruction?


.. py:function:: f_is_code(F: flags64_t, arg2: void *) -> bool

   Does flag denote start of an instruction?


.. py:function:: is_data(F: flags64_t) -> bool

   Does flag denote start of data?


.. py:function:: f_is_data(F: flags64_t, arg2: void *) -> bool

   Does flag denote start of data?


.. py:function:: is_tail(F: flags64_t) -> bool

   Does flag denote tail byte?


.. py:function:: f_is_tail(F: flags64_t, arg2: void *) -> bool

   Does flag denote tail byte?


.. py:function:: is_not_tail(F: flags64_t) -> bool

   Does flag denote tail byte?


.. py:function:: f_is_not_tail(F: flags64_t, arg2: void *) -> bool

   Does flag denote tail byte?


.. py:function:: is_unknown(F: flags64_t) -> bool

   Does flag denote unexplored byte?


.. py:function:: is_head(F: flags64_t) -> bool

   Does flag denote start of instruction OR data?


.. py:function:: f_is_head(F: flags64_t, arg2: void *) -> bool

   Does flag denote start of instruction OR data?


.. py:function:: del_items(ea: ida_idaapi.ea_t, flags: int = 0, nbytes: asize_t = 1, may_destroy: may_destroy_cb_t * = None) -> bool

   Convert item (instruction/data) to unexplored bytes. The whole item (including the head and tail bytes) will be destroyed. It is allowed to pass any address in the item to this function 
           
   :param ea: any address within the first item to delete
   :param flags: combination of Unexplored byte conversion flags
   :param nbytes: number of bytes in the range to be undefined
   :param may_destroy: optional routine invoked before deleting a head item. If callback returns false then item is not to be deleted and operation fails
   :returns: true on sucessful operation, otherwise false


.. py:data:: DELIT_SIMPLE

   simply undefine the specified item(s)


.. py:data:: DELIT_EXPAND

   propagate undefined items; for example if removing an instruction removes all references to the next instruction, then plan to convert to unexplored the next instruction too. 
           


.. py:data:: DELIT_DELNAMES

   delete any names at the specified address range (except for the starting address). this bit is valid if nbytes > 1 
           


.. py:data:: DELIT_NOTRUNC

   don't truncate the current function even if AF_TRFUNC is set 
           


.. py:data:: DELIT_NOUNAME

   reject to delete if a user name is in address range (except for the starting address). this bit is valid if nbytes > 1 
           


.. py:data:: DELIT_NOCMT

   reject to delete if a comment is in address range (except for the starting address). this bit is valid if nbytes > 1 
           


.. py:data:: DELIT_KEEPFUNC

   do not undefine the function start. Just delete xrefs, ops e.t.c. 
           


.. py:function:: is_manual_insn(ea: ida_idaapi.ea_t) -> bool

   Is the instruction overridden? 
           
   :param ea: linear address of the instruction or data item


.. py:function:: get_manual_insn(ea: ida_idaapi.ea_t) -> str

   Retrieve the user-specified string for the manual instruction. 
           
   :param ea: linear address of the instruction or data item
   :returns: size of manual instruction or -1


.. py:function:: set_manual_insn(ea: ida_idaapi.ea_t, manual_insn: str) -> None

   Set manual instruction string. 
           
   :param ea: linear address of the instruction or data item
   :param manual_insn: "" - delete manual string. nullptr - do nothing


.. py:data:: MS_COMM

   Mask of common bits.


.. py:data:: FF_COMM

   Has comment?


.. py:data:: FF_REF

   has references


.. py:data:: FF_LINE

   Has next or prev lines?


.. py:data:: FF_NAME

   Has name?


.. py:data:: FF_LABL

   Has dummy name?


.. py:data:: FF_FLOW

   Exec flow from prev instruction.


.. py:data:: FF_SIGN

   Inverted sign of operands.


.. py:data:: FF_BNOT

   Bitwise negation of operands.


.. py:data:: FF_UNUSED

   unused bit (was used for variable bytes)


.. py:function:: is_flow(F: flags64_t) -> bool

   Does the previous instruction exist and pass execution flow to the current byte?


.. py:function:: has_extra_cmts(F: flags64_t) -> bool

   Does the current byte have additional anterior or posterior lines?


.. py:function:: f_has_extra_cmts(f: flags64_t, arg2: void *) -> bool

.. py:function:: has_cmt(F: flags64_t) -> bool

   Does the current byte have an indented comment?


.. py:function:: f_has_cmt(f: flags64_t, arg2: void *) -> bool

.. py:function:: has_xref(F: flags64_t) -> bool

   Does the current byte have cross-references to it?


.. py:function:: f_has_xref(f: flags64_t, arg2: void *) -> bool

   Does the current byte have cross-references to it?


.. py:function:: has_name(F: flags64_t) -> bool

   Does the current byte have non-trivial (non-dummy) name?


.. py:function:: f_has_name(f: flags64_t, arg2: void *) -> bool

   Does the current byte have non-trivial (non-dummy) name?


.. py:data:: FF_ANYNAME

   Has name or dummy name?


.. py:function:: has_dummy_name(F: flags64_t) -> bool

   Does the current byte have dummy (auto-generated, with special prefix) name?


.. py:function:: f_has_dummy_name(f: flags64_t, arg2: void *) -> bool

   Does the current byte have dummy (auto-generated, with special prefix) name?


.. py:function:: has_auto_name(F: flags64_t) -> bool

   Does the current byte have auto-generated (no special prefix) name?


.. py:function:: has_any_name(F: flags64_t) -> bool

   Does the current byte have any name?


.. py:function:: has_user_name(F: flags64_t) -> bool

   Does the current byte have user-specified name?


.. py:function:: f_has_user_name(F: flags64_t, arg2: void *) -> bool

   Does the current byte have user-specified name?


.. py:function:: is_invsign(ea: ida_idaapi.ea_t, F: flags64_t, n: int) -> bool

   Should sign of n-th operand inverted during output?. allowed values of n: 0-first operand, 1-other operands 
           


.. py:function:: toggle_sign(ea: ida_idaapi.ea_t, n: int) -> bool

   Toggle sign of n-th operand. allowed values of n: 0-first operand, 1-other operands 
           


.. py:function:: is_bnot(ea: ida_idaapi.ea_t, F: flags64_t, n: int) -> bool

   Should we negate the operand?. asm_t::a_bnot should be defined in the idp module in order to work with this function 
           


.. py:function:: toggle_bnot(ea: ida_idaapi.ea_t, n: int) -> bool

   Toggle binary negation of operand. also see is_bnot()


.. py:function:: is_lzero(ea: ida_idaapi.ea_t, n: int) -> bool

   Display leading zeroes? Display leading zeroes in operands. The global switch for the leading zeroes is in idainfo::s_genflags Note: the leading zeroes doesn't work if for the target assembler octal numbers start with 0. 
           
   :param ea: the item (insn/data) address
   :param n: the operand number (0-first operand, 1-other operands)
   :returns: success


.. py:function:: set_lzero(ea: ida_idaapi.ea_t, n: int) -> bool

   Set toggle lzero bit. This function changes the display of leading zeroes for the specified operand. If the default is not to display leading zeroes, this function will display them and vice versa. 
           
   :param ea: the item (insn/data) address
   :param n: the operand number (0-first operand, 1-other operands)
   :returns: success


.. py:function:: clr_lzero(ea: ida_idaapi.ea_t, n: int) -> bool

   Clear toggle lzero bit. This function reset the display of leading zeroes for the specified operand to the default. If the default is not to display leading zeroes, leading zeroes will not be displayed, as vice versa. 
           
   :param ea: the item (insn/data) address
   :param n: the operand number (0-first operand, 1-other operands)
   :returns: success


.. py:function:: toggle_lzero(ea: ida_idaapi.ea_t, n: int) -> bool

   Toggle lzero bit. 
           
   :param ea: the item (insn/data) address
   :param n: the operand number (0-first operand, 1-other operands)
   :returns: success


.. py:function:: leading_zero_important(ea: ida_idaapi.ea_t, n: int) -> bool

   Check if leading zeroes are important.


.. py:data:: MS_N_TYPE

   Mask for nth arg (a 64-bit constant)


.. py:data:: FF_N_VOID

   Void (unknown)?


.. py:data:: FF_N_NUMH

   Hexadecimal number?


.. py:data:: FF_N_NUMD

   Decimal number?


.. py:data:: FF_N_CHAR

   Char ('x')?


.. py:data:: FF_N_SEG

   Segment?


.. py:data:: FF_N_OFF

   Offset?


.. py:data:: FF_N_NUMB

   Binary number?


.. py:data:: FF_N_NUMO

   Octal number?


.. py:data:: FF_N_ENUM

   Enumeration?


.. py:data:: FF_N_FOP

   Forced operand?


.. py:data:: FF_N_STRO

   Struct offset?


.. py:data:: FF_N_STK

   Stack variable?


.. py:data:: FF_N_FLT

   Floating point number?


.. py:data:: FF_N_CUST

   Custom representation?


.. py:function:: get_operand_type_shift(n: int) -> int

   Get the shift in `flags64_t` for the nibble representing operand `n`'s type
   Note: n must be < UA_MAXOP, and is not checked

   :param n: the operand number
   :returns: the shift to the nibble


.. py:function:: get_operand_flag(typebits: uint8, n: int) -> flags64_t

   Place operand `n`'s type flag in the right nibble of a 64-bit flags set.

   :param typebits: the type bits (one of `FF_N_`)
   :param n: the operand number
   :returns: the shift to the nibble


.. py:function:: is_flag_for_operand(F: flags64_t, typebits: uint8, n: int) -> bool

   Check that the 64-bit flags set has the expected type for operand `n`.

   :param F: the flags
   :param typebits: the type bits (one of `FF_N_`)
   :param n: the operand number
   :returns: success


.. py:function:: is_defarg0(F: flags64_t) -> bool

   Is the first operand defined? Initially operand has no defined representation.


.. py:function:: is_defarg1(F: flags64_t) -> bool

   Is the second operand defined? Initially operand has no defined representation.


.. py:function:: is_off0(F: flags64_t) -> bool

   Is the first operand offset? (example: push offset xxx)


.. py:function:: is_off1(F: flags64_t) -> bool

   Is the second operand offset? (example: mov ax, offset xxx)


.. py:function:: is_char0(F: flags64_t) -> bool

   Is the first operand character constant? (example: push 'a')


.. py:function:: is_char1(F: flags64_t) -> bool

   Is the second operand character constant? (example: mov al, 'a')


.. py:function:: is_seg0(F: flags64_t) -> bool

   Is the first operand segment selector? (example: push seg seg001)


.. py:function:: is_seg1(F: flags64_t) -> bool

   Is the second operand segment selector? (example: mov dx, seg dseg)


.. py:function:: is_enum0(F: flags64_t) -> bool

   Is the first operand a symbolic constant (enum member)?


.. py:function:: is_enum1(F: flags64_t) -> bool

   Is the second operand a symbolic constant (enum member)?


.. py:function:: is_stroff0(F: flags64_t) -> bool

   Is the first operand an offset within a struct?


.. py:function:: is_stroff1(F: flags64_t) -> bool

   Is the second operand an offset within a struct?


.. py:function:: is_stkvar0(F: flags64_t) -> bool

   Is the first operand a stack variable?


.. py:function:: is_stkvar1(F: flags64_t) -> bool

   Is the second operand a stack variable?


.. py:function:: is_float0(F: flags64_t) -> bool

   Is the first operand a floating point number?


.. py:function:: is_float1(F: flags64_t) -> bool

   Is the second operand a floating point number?


.. py:function:: is_custfmt0(F: flags64_t) -> bool

   Does the first operand use a custom data representation?


.. py:function:: is_custfmt1(F: flags64_t) -> bool

   Does the second operand use a custom data representation?


.. py:function:: is_numop0(F: flags64_t) -> bool

   Is the first operand a number (i.e. binary, octal, decimal or hex?)


.. py:function:: is_numop1(F: flags64_t) -> bool

   Is the second operand a number (i.e. binary, octal, decimal or hex?)


.. py:function:: get_optype_flags0(F: flags64_t) -> flags64_t

   Get flags for first operand.


.. py:function:: get_optype_flags1(F: flags64_t) -> flags64_t

   Get flags for second operand.


.. py:data:: OPND_OUTER

   outer offset base (combined with operand number). used only in set, get, del_offset() functions 
           


.. py:data:: OPND_MASK

   mask for operand number


.. py:data:: OPND_ALL

   all operands


.. py:function:: is_defarg(F: flags64_t, n: int) -> bool

   is defined?


.. py:function:: is_off(F: flags64_t, n: int) -> bool

   is offset?


.. py:function:: is_char(F: flags64_t, n: int) -> bool

   is character constant?


.. py:function:: is_seg(F: flags64_t, n: int) -> bool

   is segment?


.. py:function:: is_enum(F: flags64_t, n: int) -> bool

   is enum?


.. py:function:: is_manual(F: flags64_t, n: int) -> bool

   is forced operand? (use is_forced_operand())


.. py:function:: is_stroff(F: flags64_t, n: int) -> bool

   is struct offset?


.. py:function:: is_stkvar(F: flags64_t, n: int) -> bool

   is stack variable?


.. py:function:: is_fltnum(F: flags64_t, n: int) -> bool

   is floating point number?


.. py:function:: is_custfmt(F: flags64_t, n: int) -> bool

   is custom data format?


.. py:function:: is_numop(F: flags64_t, n: int) -> bool

   is number (bin, oct, dec, hex)?


.. py:function:: is_suspop(ea: ida_idaapi.ea_t, F: flags64_t, n: int) -> bool

   is suspicious operand?


.. py:function:: op_adds_xrefs(F: flags64_t, n: int) -> bool

   Should processor module create xrefs from the operand?. Currently 'offset', 'structure offset', 'stack' and 'enum' operands create xrefs 
           


.. py:function:: set_op_type(ea: ida_idaapi.ea_t, type: flags64_t, n: int) -> bool

   (internal function) change representation of operand(s). 
           
   :param ea: linear address
   :param type: new flag value (should be obtained from char_flag(), num_flag() and similar functions)
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
   :returns: 1: ok
   :returns: 0: failed (applied to a tail byte)


.. py:function:: op_seg(ea: ida_idaapi.ea_t, n: int) -> bool

   Set operand representation to be 'segment'. If applied to unexplored bytes, converts them to 16/32bit word data 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
   :returns: success


.. py:function:: op_enum(ea: ida_idaapi.ea_t, n: int, id: tid_t, serial: uchar = 0) -> bool

   Set operand representation to be enum type If applied to unexplored bytes, converts them to 16/32bit word data 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
   :param id: id of enum
   :param serial: the serial number of the constant in the enumeration, usually 0. the serial numbers are used if the enumeration contains several constants with the same value
   :returns: success


.. py:function:: get_enum_id(ea: ida_idaapi.ea_t, n: int) -> uchar *

   Get enum id of 'enum' operand. 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL one of the operands
   :returns: id of enum or BADNODE


.. py:function:: op_based_stroff(insn: insn_t const &, n: int, opval: adiff_t, base: ida_idaapi.ea_t) -> bool

   Set operand representation to be 'struct offset' if the operand likely points to a structure member. For example, let's there is a structure at 1000 1000 stru_1000 Elf32_Sym <...> the operand #8 will be represented as '#Elf32_Sym.st_size' after the call of 'op_based_stroff(..., 8, 0x1000)' By the way, after the call of 'op_plain_offset(..., 0x1000)' it will be represented as '#(stru_1000.st_size - 0x1000)' 
           
   :param insn: the instruction
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
   :param opval: operand value (usually op_t::value or op_t::addr)
   :param base: base reference
   :returns: success


.. py:function:: op_stkvar(ea: ida_idaapi.ea_t, n: int) -> bool

   Set operand representation to be 'stack variable'. Should be applied to an instruction within a function. Should be applied after creating a stack var using insn_t::create_stkvar(). 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
   :returns: success


.. py:function:: set_forced_operand(ea: ida_idaapi.ea_t, n: int, op: str) -> bool

   Set forced operand. 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number
   :param op: text of operand
   * nullptr: do nothing (return 0)
   * "" : delete forced operand
   :returns: success


.. py:function:: get_forced_operand(ea: ida_idaapi.ea_t, n: int) -> str

   Get forced operand. 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number
   :returns: size of forced operand or -1


.. py:function:: is_forced_operand(ea: ida_idaapi.ea_t, n: int) -> bool

   Is operand manually defined?. 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number


.. py:function:: combine_flags(F: flags64_t) -> flags64_t

.. py:function:: char_flag() -> flags64_t

   see FF_opbits


.. py:function:: off_flag() -> flags64_t

   see FF_opbits


.. py:function:: enum_flag() -> flags64_t

   see FF_opbits


.. py:function:: stroff_flag() -> flags64_t

   see FF_opbits


.. py:function:: stkvar_flag() -> flags64_t

   see FF_opbits


.. py:function:: flt_flag() -> flags64_t

   see FF_opbits


.. py:function:: custfmt_flag() -> flags64_t

   see FF_opbits


.. py:function:: seg_flag() -> flags64_t

   see FF_opbits


.. py:function:: num_flag() -> flags64_t

   Get number of default base (bin, oct, dec, hex) 
           


.. py:function:: hex_flag() -> flags64_t

   Get number flag of the base, regardless of current processor - better to use num_flag()


.. py:function:: dec_flag() -> flags64_t

   Get number flag of the base, regardless of current processor - better to use num_flag()


.. py:function:: oct_flag() -> flags64_t

   Get number flag of the base, regardless of current processor - better to use num_flag()


.. py:function:: bin_flag() -> flags64_t

   Get number flag of the base, regardless of current processor - better to use num_flag()


.. py:function:: op_chr(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to char_flag()


.. py:function:: op_num(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to num_flag()


.. py:function:: op_hex(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to hex_flag()


.. py:function:: op_dec(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to dec_flag()


.. py:function:: op_oct(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to oct_flag()


.. py:function:: op_bin(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to bin_flag()


.. py:function:: op_flt(ea: ida_idaapi.ea_t, n: int) -> bool

   set op type to flt_flag()


.. py:function:: op_custfmt(ea: ida_idaapi.ea_t, n: int, fid: int) -> bool

   Set custom data format for operand (fid-custom data format id)


.. py:function:: clr_op_type(ea: ida_idaapi.ea_t, n: int) -> bool

   Remove operand representation information. (set operand representation to be 'undefined') 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
   :returns: success


.. py:function:: get_default_radix() -> int

   Get default base of number for the current processor. 
           
   :returns: 2, 8, 10, 16


.. py:function:: get_radix(F: flags64_t, n: int) -> int

   Get radix of the operand, in: flags. If the operand is not a number, returns get_default_radix() 
           
   :param F: flags
   :param n: number of operand (0, 1, -1)
   :returns: 2, 8, 10, 16


.. py:data:: DT_TYPE

   Mask for DATA typing.


.. py:data:: FF_BYTE

   byte


.. py:data:: FF_WORD

   word


.. py:data:: FF_DWORD

   double word


.. py:data:: FF_QWORD

   quadro word


.. py:data:: FF_TBYTE

   tbyte


.. py:data:: FF_STRLIT

   string literal


.. py:data:: FF_STRUCT

   struct variable


.. py:data:: FF_OWORD

   octaword/xmm word (16 bytes/128 bits)


.. py:data:: FF_FLOAT

   float


.. py:data:: FF_DOUBLE

   double


.. py:data:: FF_PACKREAL

   packed decimal real


.. py:data:: FF_ALIGN

   alignment directive


.. py:data:: FF_CUSTOM

   custom data type


.. py:data:: FF_YWORD

   ymm word (32 bytes/256 bits)


.. py:data:: FF_ZWORD

   zmm word (64 bytes/512 bits)


.. py:function:: code_flag() -> flags64_t

   FF_CODE


.. py:function:: byte_flag() -> flags64_t

   Get a flags64_t representing a byte.


.. py:function:: word_flag() -> flags64_t

   Get a flags64_t representing a word.


.. py:function:: dword_flag() -> flags64_t

   Get a flags64_t representing a double word.


.. py:function:: qword_flag() -> flags64_t

   Get a flags64_t representing a quad word.


.. py:function:: oword_flag() -> flags64_t

   Get a flags64_t representing a octaword.


.. py:function:: yword_flag() -> flags64_t

   Get a flags64_t representing a ymm word.


.. py:function:: zword_flag() -> flags64_t

   Get a flags64_t representing a zmm word.


.. py:function:: tbyte_flag() -> flags64_t

   Get a flags64_t representing a tbyte.


.. py:function:: strlit_flag() -> flags64_t

   Get a flags64_t representing a string literal.


.. py:function:: stru_flag() -> flags64_t

   Get a flags64_t representing a struct.


.. py:function:: cust_flag() -> flags64_t

   Get a flags64_t representing custom type data.


.. py:function:: align_flag() -> flags64_t

   Get a flags64_t representing an alignment directive.


.. py:function:: float_flag() -> flags64_t

   Get a flags64_t representing a float.


.. py:function:: double_flag() -> flags64_t

   Get a flags64_t representing a double.


.. py:function:: packreal_flag() -> flags64_t

   Get a flags64_t representing a packed decimal real.


.. py:function:: is_byte(F: flags64_t) -> bool

   FF_BYTE


.. py:function:: is_word(F: flags64_t) -> bool

   FF_WORD


.. py:function:: is_dword(F: flags64_t) -> bool

   FF_DWORD


.. py:function:: is_qword(F: flags64_t) -> bool

   FF_QWORD


.. py:function:: is_oword(F: flags64_t) -> bool

   FF_OWORD


.. py:function:: is_yword(F: flags64_t) -> bool

   FF_YWORD


.. py:function:: is_zword(F: flags64_t) -> bool

   FF_ZWORD


.. py:function:: is_tbyte(F: flags64_t) -> bool

   FF_TBYTE


.. py:function:: is_float(F: flags64_t) -> bool

   FF_FLOAT


.. py:function:: is_double(F: flags64_t) -> bool

   FF_DOUBLE


.. py:function:: is_pack_real(F: flags64_t) -> bool

   FF_PACKREAL


.. py:function:: is_strlit(F: flags64_t) -> bool

   FF_STRLIT


.. py:function:: is_struct(F: flags64_t) -> bool

   FF_STRUCT


.. py:function:: is_align(F: flags64_t) -> bool

   FF_ALIGN


.. py:function:: is_custom(F: flags64_t) -> bool

   FF_CUSTOM


.. py:function:: f_is_byte(F: flags64_t, arg2: void *) -> bool

   See is_byte()


.. py:function:: f_is_word(F: flags64_t, arg2: void *) -> bool

   See is_word()


.. py:function:: f_is_dword(F: flags64_t, arg2: void *) -> bool

   See is_dword()


.. py:function:: f_is_qword(F: flags64_t, arg2: void *) -> bool

   See is_qword()


.. py:function:: f_is_oword(F: flags64_t, arg2: void *) -> bool

   See is_oword()


.. py:function:: f_is_yword(F: flags64_t, arg2: void *) -> bool

   See is_yword()


.. py:function:: f_is_tbyte(F: flags64_t, arg2: void *) -> bool

   See is_tbyte()


.. py:function:: f_is_float(F: flags64_t, arg2: void *) -> bool

   See is_float()


.. py:function:: f_is_double(F: flags64_t, arg2: void *) -> bool

   See is_double()


.. py:function:: f_is_pack_real(F: flags64_t, arg2: void *) -> bool

   See is_pack_real()


.. py:function:: f_is_strlit(F: flags64_t, arg2: void *) -> bool

   See is_strlit()


.. py:function:: f_is_struct(F: flags64_t, arg2: void *) -> bool

   See is_struct()


.. py:function:: f_is_align(F: flags64_t, arg2: void *) -> bool

   See is_align()


.. py:function:: f_is_custom(F: flags64_t, arg2: void *) -> bool

   See is_custom()


.. py:function:: is_same_data_type(F1: flags64_t, F2: flags64_t) -> bool

   Do the given flags specify the same data type?


.. py:function:: get_flags_by_size(size: size_t) -> flags64_t

   Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32. For other sizes returns 0 
           


.. py:function:: create_data(ea: ida_idaapi.ea_t, dataflag: flags64_t, size: asize_t, tid: tid_t) -> bool

   Convert to data (byte, word, dword, etc). This function may be used to create arrays. 
           
   :param ea: linear address
   :param dataflag: type of data. Value of function byte_flag(), word_flag(), etc.
   :param size: size of array in bytes. should be divisible by the size of one item of the specified type. for variable sized items it can be specified as 0, and the kernel will try to calculate the size.
   :param tid: type id. If the specified type is a structure, then tid is structure id. Otherwise should be BADNODE.
   :returns: success


.. py:function:: calc_dflags(f: flags64_t, force: bool) -> flags64_t

.. py:function:: create_byte(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to byte.


.. py:function:: create_word(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to word.


.. py:function:: create_dword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to dword.


.. py:function:: create_qword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to quadword.


.. py:function:: create_oword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to octaword/xmm word.


.. py:function:: create_yword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to ymm word.


.. py:function:: create_zword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to zmm word.


.. py:function:: create_tbyte(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to tbyte.


.. py:function:: create_float(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to float.


.. py:function:: create_double(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to double.


.. py:function:: create_packed_real(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool

   Convert to packed decimal real.


.. py:function:: create_struct(ea: ida_idaapi.ea_t, length: asize_t, tid: tid_t, force: bool = False) -> bool

   Convert to struct.


.. py:function:: create_custdata(ea: ida_idaapi.ea_t, length: asize_t, dtid: int, fid: int, force: bool = False) -> bool

   Convert to custom data type.


.. py:function:: create_align(ea: ida_idaapi.ea_t, length: asize_t, alignment: int) -> bool

   Create an alignment item. 
           
   :param ea: linear address
   :param length: size of the item in bytes. 0 means to infer from ALIGNMENT
   :param alignment: alignment exponent. Example: 3 means align to 8 bytes. 0 means to infer from LENGTH It is forbidden to specify both LENGTH and ALIGNMENT as 0.
   :returns: success


.. py:function:: calc_min_align(length: asize_t) -> int

   Calculate the minimal possible alignment exponent. 
           
   :param length: size of the item in bytes.
   :returns: a value in the 1..32 range


.. py:function:: calc_max_align(endea: ida_idaapi.ea_t) -> int

   Calculate the maximal possible alignment exponent. 
           
   :param endea: end address of the alignment item.
   :returns: a value in the 0..32 range


.. py:function:: calc_def_align(ea: ida_idaapi.ea_t, mina: int, maxa: int) -> int

   Calculate the default alignment exponent. 
           
   :param ea: linear address
   :param mina: minimal possible alignment exponent.
   :param maxa: minimal possible alignment exponent.


.. py:function:: create_16bit_data(ea: ida_idaapi.ea_t, length: asize_t) -> bool

   Convert to 16-bit quantity (take the byte size into account)


.. py:function:: create_32bit_data(ea: ida_idaapi.ea_t, length: asize_t) -> bool

   Convert to 32-bit quantity (take the byte size into account)


.. py:data:: ALOPT_IGNHEADS

   don't stop if another data item is encountered. only the byte values will be used to determine the string length. if not set, a defined data item or instruction will truncate the string 
           


.. py:data:: ALOPT_IGNPRINT

   if set, don't stop at non-printable codepoints, but only at the terminating character (or not unicode-mapped character (e.g., 0x8f in CP1252)) 
           


.. py:data:: ALOPT_IGNCLT

   if set, don't stop at codepoints that are not part of the current 'culture'; accept all those that are graphical (this is typically used used by user-initiated actions creating string literals.) 
           


.. py:data:: ALOPT_MAX4K

   if string length is more than 4K, return the accumulated length 
           


.. py:data:: ALOPT_ONLYTERM

   only the termination characters can be at the string end. Without this option illegal characters also terminate the string. 
           


.. py:data:: ALOPT_APPEND

   if an existing strlit is encountered, then append it to the string. 
           


.. py:function:: get_max_strlit_length(ea: ida_idaapi.ea_t, strtype: int, options: int = 0) -> size_t

   Determine maximum length of string literal.
   If the string literal has a length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the length of that prefix (i.e., 2) will be part of the returned value.

   :param ea: starting address
   :param strtype: string type. one of String type codes
   :param options: combination of string literal length options
   :returns: length of the string in octets (octet==8bit)


.. py:data:: STRCONV_ESCAPE

   convert non-printable characters to C escapes (
   , \xNN, \uNNNN)


.. py:data:: STRCONV_REPLCHAR

   convert non-printable characters to the Unicode replacement character (U+FFFD)


.. py:data:: STRCONV_INCLLEN

   for Pascal-style strings, include the prefixing length byte(s) as C-escaped sequence


.. py:function:: create_strlit(start: ida_idaapi.ea_t, len: size_t, strtype: int) -> bool

   Convert to string literal and give a meaningful name. 'start' may be higher than 'end', the kernel will swap them in this case 
           
   :param start: starting address
   :param len: length of the string in bytes. if 0, then get_max_strlit_length() will be used to determine the length
   :param strtype: string type. one of String type codes
   :returns: success


.. py:data:: PSTF_TNORM

   use normal name


.. py:data:: PSTF_TBRIEF

   use brief name (e.g., in the 'Strings' window)


.. py:data:: PSTF_TINLIN

   use 'inline' name (e.g., in the structures comments)


.. py:data:: PSTF_TMASK

   type mask


.. py:data:: PSTF_HOTKEY

   have hotkey markers part of the name


.. py:data:: PSTF_ENC

   if encoding is specified, append it


.. py:data:: PSTF_ONLY_ENC

   generate only the encoding name


.. py:data:: PSTF_ATTRIB

   generate for type attribute usage


.. py:function:: get_opinfo(buf: opinfo_t, ea: ida_idaapi.ea_t, n: int, flags: flags64_t) -> opinfo_t *

   Get additional information about an operand representation. 
           
   :param buf: buffer to receive the result. may not be nullptr
   :param ea: linear address of item
   :param n: number of operand, 0 or 1
   :param flags: flags of the item
   :returns: nullptr if no additional representation information


.. py:function:: set_opinfo(ea: ida_idaapi.ea_t, n: int, flag: flags64_t, ti: opinfo_t, suppress_events: bool = False) -> bool

   Set additional information about an operand representation. This function is a low level one. Only the kernel should use it. 
           
   :param ea: linear address of the item
   :param n: number of operand, 0 or 1 (see the note below)
   :param flag: flags of the item
   :param ti: additional representation information
   :param suppress_events: do not generate changing_op_type and op_type_changed events
   :returns: success


.. py:function:: get_data_elsize(ea: ida_idaapi.ea_t, F: flags64_t, ti: opinfo_t = None) -> asize_t

   Get size of data type specified in flags 'F'. 
           
   :param ea: linear address of the item
   :param F: flags
   :param ti: additional information about the data type. For example, if the current item is a structure instance, then ti->tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database
   :returns: * byte : 1
   * word : 2
   * etc...


.. py:function:: get_full_data_elsize(ea: ida_idaapi.ea_t, F: flags64_t, ti: opinfo_t = None) -> asize_t

   Get full size of data type specified in flags 'F'. takes into account processors with wide bytes e.g. returns 2 for a byte element with 16-bit bytes 
           


.. py:function:: is_varsize_item(ea: ida_idaapi.ea_t, F: flags64_t, ti: opinfo_t = None, itemsize: asize_t * = None) -> int

   Is the item at 'ea' variable size?. 
           
   :param ea: linear address of the item
   :param F: flags
   :param ti: additional information about the data type. For example, if the current item is a structure instance, then ti->tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database
   :param itemsize: if not nullptr and the item is varsize, itemsize will contain the calculated item size (for struct types, the minimal size is returned)
   :returns: 1: varsize item
   :returns: 0: fixed item
   :returns: -1: error (bad data definition)


.. py:function:: get_possible_item_varsize(ea: ida_idaapi.ea_t, tif: tinfo_t) -> asize_t

   Return the possible size of the item at EA of type TIF if TIF is the variable structure. 
           
   :param ea: the linear address of the item
   :param tif: the item type
   :returns: the possible size
   :returns: asize_t(-1): TIF is not a variable structure


.. py:function:: can_define_item(ea: ida_idaapi.ea_t, length: asize_t, flags: flags64_t) -> bool

   Can define item (instruction/data) of the specified 'length', starting at 'ea'? 
   * a new item would cross segment boundaries
   * a new item would overlap with existing items (except items specified by 'flags') 


           
   :param ea: start of the range for the new item
   :param length: length of the new item in bytes
   :param flags: if not 0, then the kernel will ignore the data types specified by the flags and destroy them. For example: 
                    1000 dw 5
                    1002 db 5 ; undef
                    1003 db 5 ; undef
                    1004 dw 5
                    1006 dd 5
                     can_define_item(1000, 6, 0) - false because of dw at 1004 
    can_define_item(1000, 6, word_flag()) - true, word at 1004 is destroyed
   :returns: 1-yes, 0-no


.. py:data:: MS_CODE

   Mask for code bits.


.. py:data:: FF_FUNC

   function start?


.. py:data:: FF_IMMD

   Has Immediate value ?


.. py:data:: FF_JUMP

   Has jump table or switch_info?


.. py:function:: has_immd(F: flags64_t) -> bool

   Has immediate value?


.. py:function:: is_func(F: flags64_t) -> bool

   Is function start?


.. py:function:: set_immd(ea: ida_idaapi.ea_t) -> bool

   Set 'has immediate operand' flag. Returns true if the FF_IMMD bit was not set and now is set 
           


.. py:class:: data_type_t(_self: PyObject *, name: str, value_size: asize_t = 0, menu_name: str = None, hotkey: str = None, asm_keyword: str = None, props: int = 0)

   Bases: :py:obj:`object`


   Information about a data type


   .. py:attribute:: thisown


   .. py:attribute:: props
      :type:  int

      properties



   .. py:attribute:: name
      :type:  str

      name of the data type. must be unique



   .. py:attribute:: menu_name
      :type:  str

      Visible data type name to use in menus if nullptr, no menu item will be created 
              



   .. py:attribute:: hotkey
      :type:  str

      Hotkey for the corresponding menu item if nullptr, no hotkey will be associated with the menu item 
              



   .. py:attribute:: asm_keyword
      :type:  str

      keyword to use for this type in the assembly if nullptr, the data type cannot be used in the listing it can still be used in cpuregs window 
              



   .. py:attribute:: value_size
      :type:  asize_t

      size of the value in bytes



   .. py:method:: is_present_in_menus() -> bool

      Should this type be shown in UI menus 
              
      :returns: success



   .. py:attribute:: id


.. py:data:: DTP_NODUP

   do not use dup construct


.. py:class:: data_format_t(_self: PyObject *, name: str, value_size: asize_t = 0, menu_name: str = None, props: int = 0, hotkey: str = None, text_width: int = 0)

   Bases: :py:obj:`object`


   Information about a data format


   .. py:attribute:: thisown


   .. py:attribute:: props
      :type:  int

      properties (currently 0)



   .. py:attribute:: name
      :type:  str

      Format name, must be unique.



   .. py:attribute:: menu_name
      :type:  str

      Visible format name to use in menus if nullptr, no menu item will be created 
              



   .. py:attribute:: hotkey
      :type:  str

      Hotkey for the corresponding menu item if nullptr, no hotkey will be associated with the menu item 
              



   .. py:attribute:: value_size
      :type:  asize_t

      size of the value in bytes 0 means any size is ok data formats that are registered for standard types (dtid 0) may be called with any value_size (instruction operands only) 
              



   .. py:attribute:: text_width
      :type:  int

      Usual width of the text representation This value is used to calculate the width of the control to display values of this type 
              



   .. py:method:: is_present_in_menus() -> bool

      Should this format be shown in UI menus 
              
      :returns: success



   .. py:attribute:: id


.. py:function:: get_custom_data_type(dtid: int) -> data_type_t const *

   Get definition of a registered custom data type. 
           
   :param dtid: data type id
   :returns: data type definition or nullptr


.. py:function:: get_custom_data_format(dfid: int) -> data_format_t const *

   Get definition of a registered custom data format. 
           
   :param dfid: data format id
   :returns: data format definition or nullptr


.. py:function:: attach_custom_data_format(dtid: int, dfid: int) -> bool

   Attach the data format to the data type. 
           
   :param dtid: data type id that can use the data format. 0 means all standard data types. Such data formats can be applied to any data item or instruction operands. For instruction operands, the data_format_t::value_size check is not performed by the kernel.
   :param dfid: data format id
   :returns: true: ok
   :returns: false: no such `dtid`, or no such `dfid', or the data format has already been attached to the data type


.. py:function:: detach_custom_data_format(dtid: int, dfid: int) -> bool

   Detach the data format from the data type. Unregistering a custom data type detaches all attached data formats, no need to detach them explicitly. You still need unregister them. Unregistering a custom data format detaches it from all attached data types. 
           
   :param dtid: data type id to detach data format from
   :param dfid: data format id to detach
   :returns: true: ok
   :returns: false: no such `dtid`, or no such `dfid', or the data format was not attached to the data type


.. py:function:: is_attached_custom_data_format(dtid: int, dfid: int) -> bool

   Is the custom data format attached to the custom data type? 
           
   :param dtid: data type id
   :param dfid: data format id
   :returns: true or false


.. py:function:: get_custom_data_types(*args) -> int

   Get list of registered custom data type ids. 
           
   :param out: buffer for the output. may be nullptr
   :param min_size: minimum value size
   :param max_size: maximum value size
   :returns: number of custom data types with the specified size limits


.. py:function:: get_custom_data_formats(out: intvec_t *, dtid: int) -> int

   Get list of attached custom data formats for the specified data type. 
           
   :param out: buffer for the output. may be nullptr
   :param dtid: data type id
   :returns: number of returned custom data formats. if error, returns -1


.. py:function:: find_custom_data_type(name: str) -> int

   Get id of a custom data type. 
           
   :param name: name of the custom data type
   :returns: id or -1


.. py:function:: find_custom_data_format(name: str) -> int

   Get id of a custom data format. 
           
   :param name: name of the custom data format
   :returns: id or -1


.. py:function:: set_cmt(ea: ida_idaapi.ea_t, comm: str, rptble: bool) -> bool

   Set an indented comment. 
           
   :param ea: linear address
   :param comm: comment string
   * nullptr: do nothing (return 0)
   * "" : delete comment
   :param rptble: is repeatable?
   :returns: success


.. py:function:: get_cmt(ea: ida_idaapi.ea_t, rptble: bool) -> str

   Get an indented comment. 
           
   :param ea: linear address. may point to tail byte, the function will find start of the item
   :param rptble: get repeatable comment?
   :returns: size of comment or -1


.. py:function:: append_cmt(ea: ida_idaapi.ea_t, str: append_cmt.str, rptble: bool) -> bool

   Append to an indented comment. Creates a new comment if none exists. Appends a newline character and the specified string otherwise. 
           
   :param ea: linear address
   :param str: comment string to append
   :param rptble: append to repeatable comment?
   :returns: success


.. py:function:: get_predef_insn_cmt(ins: insn_t const &) -> str

   Get predefined comment. 
           
   :param ins: current instruction information
   :returns: size of comment or -1


.. py:function:: find_byte(sEA: ida_idaapi.ea_t, size: asize_t, value: uchar, bin_search_flags: int) -> ida_idaapi.ea_t

   Find forward a byte with the specified value (only 8-bit value from the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6 
           
   :param sEA: linear address
   :param size: number of bytes to inspect
   :param value: value to find
   :param bin_search_flags: combination of Search flags
   :returns: address of byte or BADADDR


.. py:function:: find_byter(sEA: ida_idaapi.ea_t, size: asize_t, value: uchar, bin_search_flags: int) -> ida_idaapi.ea_t

   Find reverse a byte with the specified value (only 8-bit value from the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4 
           
   :param sEA: the lower address of the search range
   :param size: number of bytes to inspect
   :param value: value to find
   :param bin_search_flags: combination of Search flags
   :returns: address of byte or BADADDR


.. py:class:: compiled_binpat_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: bytes
      :type:  bytevec_t


   .. py:attribute:: mask
      :type:  bytevec_t


   .. py:attribute:: strlits
      :type:  rangevec_t


   .. py:attribute:: encidx
      :type:  int


   .. py:method:: all_bytes_defined() -> bool


   .. py:method:: qclear() -> None


.. py:data:: PBSENC_DEF1BPU

   Use the default 1 byte-per-unit IDB encoding.


.. py:data:: PBSENC_ALL

   Use all IDB encodings.


.. py:function:: parse_binpat_str(out: compiled_binpat_vec_t, ea: ida_idaapi.ea_t, _in: str, radix: int, strlits_encoding: int = 0) -> bool

   Deprecated.

   Please use compiled_binpat_vec_t.from_pattern() instead.


.. py:function:: bin_search(*args)

   Search for a set of bytes in the program

   This function has the following signatures:

       1. bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t, flags: int) -> Tuple[ida_idaapi.ea_t, int]
       2. bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, image: bytes, mask: bytes, len: int, flags: int) -> ida_idaapi.ea_t

   The return value type will differ depending on the form:

       1. a tuple `(matched-address, index-in-compiled_binpat_vec_t)` (1st form)
       2. the address of a match, or ida_idaapi.BADADDR if not found (2nd form)

   This is a low-level function; more user-friendly alternatives
   are available. Please see 'find_bytes' and 'find_string'.

   :param start_ea: linear address, start of range to search
   :param end_ea: linear address, end of range to search (exclusive)
   :param data: (1st form) the prepared data to search for (see parse_binpat_str())
   :param bytes: (2nd form) a set of bytes to match
   :param mask: (2nd form) a mask to apply to the set of bytes
   :param flags: combination of BIN_SEARCH_* flags
   :returns: either a tuple holding both the address of the match and the index of the compiled pattern that matched, or the address of a match (ida_idaapi.BADADDR if not found)


.. py:data:: BIN_SEARCH_CASE

   case sensitive


.. py:data:: BIN_SEARCH_NOCASE

   case insensitive


.. py:data:: BIN_SEARCH_NOBREAK

   don't check for Ctrl-Break


.. py:data:: BIN_SEARCH_INITED

   find_byte, find_byter: any initilized value


.. py:data:: BIN_SEARCH_NOSHOW

   don't show search progress or update screen


.. py:data:: BIN_SEARCH_FORWARD

   search forward for bytes


.. py:data:: BIN_SEARCH_BACKWARD

   search backward for bytes


.. py:data:: BIN_SEARCH_BITMASK

   searching using strict bit mask


.. py:function:: next_inited(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Find the next initialized address.


.. py:function:: prev_inited(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Find the previous initialized address.


.. py:function:: equal_bytes(ea: ida_idaapi.ea_t, image: uchar const *, mask: uchar const *, len: size_t, bin_search_flags: int) -> bool

   Compare 'len' bytes of the program starting from 'ea' with 'image'. 
           
   :param ea: linear address
   :param image: bytes to compare with
   :param mask: array of mask bytes, it's length is 'len'. if the flag BIN_SEARCH_BITMASK is passsed, 'bitwise AND' is used to compare. if not; 1 means to perform the comparison of the corresponding byte. 0 means not to perform. if mask == nullptr, then all bytes of 'image' will be compared. if mask == SKIP_FF_MASK then 0xFF bytes will be skipped
   :param len: length of block to compare in bytes.
   :param bin_search_flags: combination of Search flags
   :returns: 1: equal
   :returns: 0: not equal


.. py:class:: hidden_range_t

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: description
      :type:  char *

      description to display if the range is collapsed



   .. py:attribute:: header
      :type:  char *

      header lines to display if the range is expanded



   .. py:attribute:: footer
      :type:  char *

      footer lines to display if the range is expanded



   .. py:attribute:: visible
      :type:  bool

      the range state



   .. py:attribute:: color
      :type:  bgcolor_t

      range color



.. py:function:: update_hidden_range(ha: hidden_range_t) -> bool

   Update hidden range information in the database. You cannot use this function to change the range boundaries 
           
   :param ha: range to update
   :returns: success


.. py:function:: add_hidden_range(*args) -> bool

   Mark a range of addresses as hidden. The range will be created in the invisible state with the default color 
           
   :param ea1: linear address of start of the address range
   :param ea2: linear address of end of the address range
   :param description: range parameters
   :param header: range parameters
   :param footer: range parameters
   :param color: the range color
   :returns: success


.. py:function:: get_hidden_range(ea: ida_idaapi.ea_t) -> hidden_range_t *

   Get pointer to hidden range structure, in: linear address. 
           
   :param ea: any address in the hidden range


.. py:function:: getn_hidden_range(n: int) -> hidden_range_t *

   Get pointer to hidden range structure, in: number of hidden range. 
           
   :param n: number of hidden range, is in range 0..get_hidden_range_qty()-1


.. py:function:: get_hidden_range_qty() -> int

   Get number of hidden ranges.


.. py:function:: get_hidden_range_num(ea: ida_idaapi.ea_t) -> int

   Get number of a hidden range. 
           
   :param ea: any address in the hidden range
   :returns: number of hidden range (0..get_hidden_range_qty()-1)


.. py:function:: get_prev_hidden_range(ea: ida_idaapi.ea_t) -> hidden_range_t *

   Get pointer to previous hidden range. 
           
   :param ea: any address in the program
   :returns: ptr to hidden range or nullptr if previous hidden range doesn't exist


.. py:function:: get_next_hidden_range(ea: ida_idaapi.ea_t) -> hidden_range_t *

   Get pointer to next hidden range. 
           
   :param ea: any address in the program
   :returns: ptr to hidden range or nullptr if next hidden range doesn't exist


.. py:function:: get_first_hidden_range() -> hidden_range_t *

   Get pointer to the first hidden range. 
           
   :returns: ptr to hidden range or nullptr


.. py:function:: get_last_hidden_range() -> hidden_range_t *

   Get pointer to the last hidden range. 
           
   :returns: ptr to hidden range or nullptr


.. py:function:: del_hidden_range(ea: ida_idaapi.ea_t) -> bool

   Delete hidden range. 
           
   :param ea: any address in the hidden range
   :returns: success


.. py:function:: add_mapping(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: asize_t) -> bool

   IDA supports memory mapping. References to the addresses from the mapped range use data and meta-data from the mapping range. 
           
   :param to: start of the mapping range (existent address)
   :param size: size of the range
   :returns: success


.. py:function:: del_mapping(ea: ida_idaapi.ea_t) -> None

   Delete memory mapping range. 
           
   :param ea: any address in the mapped range


.. py:function:: use_mapping(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Translate address according to current mappings. 
           
   :param ea: address to translate
   :returns: translated address


.. py:function:: get_mappings_qty() -> size_t

   Get number of mappings.


.. py:function:: get_mapping(n: size_t) -> ea_t *, ea_t *, asize_t *

   Get memory mapping range by its number. 
           
   :param n: number of mapping range (0..get_mappings_qty()-1)
   :returns: false if the specified range doesn't exist, otherwise returns `from`, `to`, `size`


.. py:data:: MS_0TYPE

.. py:data:: FF_0VOID

.. py:data:: FF_0NUMH

.. py:data:: FF_0NUMD

.. py:data:: FF_0CHAR

.. py:data:: FF_0SEG

.. py:data:: FF_0OFF

.. py:data:: FF_0NUMB

.. py:data:: FF_0NUMO

.. py:data:: FF_0ENUM

.. py:data:: FF_0FOP

.. py:data:: FF_0STRO

.. py:data:: FF_0STK

.. py:data:: FF_0FLT

.. py:data:: FF_0CUST

.. py:data:: MS_1TYPE

.. py:data:: FF_1VOID

.. py:data:: FF_1NUMH

.. py:data:: FF_1NUMD

.. py:data:: FF_1CHAR

.. py:data:: FF_1SEG

.. py:data:: FF_1OFF

.. py:data:: FF_1NUMB

.. py:data:: FF_1NUMO

.. py:data:: FF_1ENUM

.. py:data:: FF_1FOP

.. py:data:: FF_1STRO

.. py:data:: FF_1STK

.. py:data:: FF_1FLT

.. py:data:: FF_1CUST

.. py:function:: visit_patched_bytes(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, callable)

   Enumerates patched bytes in the given range and invokes a callable

   :param ea1: start address
   :param ea2: end address
   :param callable: a Python callable with the following prototype:
                    callable(ea, fpos, org_val, patch_val).
                    If the callable returns non-zero then that value will be
                    returned to the caller and the enumeration will be
                    interrupted.
   :returns: Zero if the enumeration was successful or the return
            value of the callback if enumeration was interrupted.


.. py:function:: get_bytes(ea: ida_idaapi.ea_t, size: int, gmb_flags: int = GMB_READALL)

   Get the specified number of bytes of the program.

   :param ea: program address
   :param size: number of bytes to return
   :param gmb_flags: OR'ed combination of GMB_* values (defaults to GMB_READALL)
   :returns: the bytes (as bytes object), or None in case of failure


.. py:function:: get_bytes_and_mask(ea: ida_idaapi.ea_t, size: int, gmb_flags: int = GMB_READALL)

   Get the specified number of bytes of the program, and a bitmask
   specifying what bytes are defined and what bytes are not.

   :param ea: program address
   :param size: number of bytes to return
   :param gmb_flags: OR'ed combination of GMB_* values (defaults to GMB_READALL)
   :returns: a tuple (bytes, mask), or None in case of failure.
            Both 'bytes' and 'mask' are 'str' instances.


.. py:function:: get_strlit_contents(ea: ida_idaapi.ea_t, len: int, type: int, flags: int = 0)

   Get contents of string literal, as UTF-8-encoded codepoints.
   It works even if the string has not been created in the database yet.

   Note that the returned value will be of type 'bytes'; if
   you want auto-conversion to unicode strings (that is: real Python
   strings), you should probably be using the idautils.Strings class.

   :param ea: linear address of the string
   :param len: length of the string in bytes (including terminating 0)
   :param type: type of the string. Represents both the character encoding,
                <u>and</u> the 'type' of string at the given location.
   :param flags: combination of STRCONV_..., to perform output conversion.
   :returns: a bytes-filled str object.


.. py:function:: print_strlit_type(strtype: int, flags: int = 0) -> PyObject *

   Get string type information: the string type name (possibly decorated with hotkey markers), and the tooltip.

   :param strtype: the string type
   :param flags: or'ed PSTF_* constants
   :returns: length of generated text


.. py:function:: op_stroff(*args) -> bool

   Set operand representation to be 'struct offset'.

   This function has the following signatures:

       1. op_stroff(ins: ida_ua.insn_t, n: int, path: List[int], delta: int)
       2. op_stroff(ins: ida_ua.insn_t, n: int, path: ida_pro.tid_array, path_len: int, delta: int) (backward-compatibility only)

   Here is an example using this function:

       ins = ida_ua.insn_t()
       if ida_ua.decode_insn(ins, some_address):
           operand = 0
           path = [ida_typeinf.get_named_type_tid("my_stucture_t")] # a one-element path
           ida_bytes.op_stroff(ins, operand, path, 0)


.. py:function:: get_stroff_path(*args)

   Get the structure offset path for operand `n`, at the
   specified address.

   This function has the following signatures:

       1. get_stroff_path(ea: ida_idaapi.ea_t, n : int) -> Tuple[List[int], int]
       2. get_stroff_path(path: tid_array, delta: sval_pointer, ea: ida_idaapi.ea_t, n : int) (backward-compatibility only)

   :param ea: address where the operand holds a path to a structure offset (1st form)
   :param n: operand number (1st form)
   :returns: a tuple holding a (list_of_tid_t's, delta_within_the_last_type), or (None, None)


.. py:function:: register_custom_data_type(dt)

   Registers a custom data type.

   :param dt: an instance of the data_type_t class
   :returns: < 0 if failed to register
   :returns: > 0 data type id


.. py:function:: unregister_custom_data_type(dtid)

   Unregisters a custom data type.

   :param dtid: the data type id
   :returns: Boolean


.. py:function:: register_custom_data_format(df)

   Registers a custom data format with a given data type.

   :param df: an instance of data_format_t
   :returns: < 0 if failed to register
   :returns: > 0 data format id


.. py:function:: unregister_custom_data_format(dfid)

   Unregisters a custom data format

   :param dfid: data format id
   :returns: Boolean


.. py:data:: DTP_NODUP
   :value: 1


   do not use dup construct


.. py:function:: register_data_types_and_formats(formats)

   Registers multiple data types and formats at once.
   To register one type/format at a time use register_custom_data_type/register_custom_data_format

   It employs a special table of types and formats described below:

   The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
   If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
   many_formats = [
     (pascal_data_type(), pascal_data_format()),
     (simplevm_data_type(), simplevm_data_format()),
     (makedword_data_format(),),
     (simplevm_data_format(),)
   ]
   The first two tuples describe data types and their associated formats.
   The last two tuples describe two data formats to be used with built-in data types.
   The data format may be attached to several data types. The id of the
   data format is stored in the first data_format_t object. For example:
   assert many_formats[1][1] != -1
   assert many_formats[2][0] != -1
   assert many_formats[3][0] == -1


.. py:function:: unregister_data_types_and_formats(formats)

   As opposed to register_data_types_and_formats(), this function
   unregisters multiple data types and formats at once.


.. py:function:: find_bytes(bs: Union[bytes, bytearray, str], range_start: int, range_size: Optional[int] = None, range_end: Optional[int] = ida_idaapi.BADADDR, mask: Optional[Union[bytes, bytearray]] = None, flags: Optional[int] = BIN_SEARCH_FORWARD | BIN_SEARCH_NOSHOW, radix: Optional[int] = 16, strlit_encoding: Optional[Union[int, str]] = PBSENC_DEF1BPU) -> int

.. py:function:: find_string(_str: str, range_start: int, range_end: Optional[int] = ida_idaapi.BADADDR, range_size: Optional[int] = None, strlit_encoding: Optional[Union[int, str]] = PBSENC_DEF1BPU, flags: Optional[int] = BIN_SEARCH_FORWARD | BIN_SEARCH_NOSHOW) -> int


```

`skills/idapython/docs/ida_dbg.md`:

```md
# ida_dbg

Debugger control and tracing (unsafe operations require --unsafe flag).

## Process Control

### Start/Stop
- `start_process(path, args, sdir)` / `request_start_process(...)` - Start debugging
- `attach_process(pid, event_id)` / `request_attach_process(...)` - Attach to process
- `detach_process()` / `request_detach_process()` - Detach from process
- `exit_process()` / `request_exit_process()` - Terminate debugged process
- `get_process_state()` / `set_process_state(state)` - Get/set state (DSTATE_SUSP/RUN/NOTASK)

### Execution
- `suspend_process()` / `continue_process()` - Pause/resume execution
- `step_into()` / `step_over()` - Single step (into/over calls)
- `step_until_ret()` - Run until return
- `run_to(ea)` - Run until address
- `run_to_backwards(ea)` / `continue_backwards()` - Reverse execution (if debugger supports)

### State
- `is_debugger_busy()` - Check if debugger processing request
- `get_running_request()` / `is_request_running()` - Query pending requests
- `invalidate_dbg_state(what)` - Invalidate cached state (DBGINV_MEMORY/REGS/ALL)

## Threads

- `get_thread_qty()` - Get thread count
- `getn_thread(idx)` - Get thread ID by index
- `get_current_thread()` - Get current thread ID
- `select_thread(tid)` - Switch to thread
- `suspend_thread(tid)` / `resume_thread(tid)` - Pause/resume thread

## Breakpoints

### Management
- `add_bpt(ea, size, bpt_type)` - Add breakpoint (BPT_BRK/BPT_TRACE)
- `del_bpt(ea)` - Delete breakpoint
- `enable_bpt(ea, enable)` - Enable/disable breakpoint
- `update_bpt(bpt)` - Update breakpoint properties
- `get_bpt_qty()` / `getn_bpt(idx)` / `get_bpt(ea)` - Query breakpoints

### Breakpoint Types
- `BPT_BRK` - Stop execution
- `BPT_TRACE` - Log and continue
- `BPT_ENABLED` - Breakpoint active
- `BPT_LOWCND` - Has condition

### Location Types
- `BPLT_ABS` - Absolute address
- `BPLT_REL` - Relative to module
- `BPLT_SYM` - Symbol name
- `BPLT_SRC` - Source file:line

## Registers

- `get_dbg_reg_info(reg_name)` - Get register info
- `get_sp_val()` / `get_ip_val()` - Get stack/instruction pointer
- `is_reg_integer(reg_name)` / `is_reg_float(reg_name)` - Check register type

## Tracing

### Step Trace
- `enable_step_trace(enable)` / `is_step_trace_enabled()` - Enable/check step tracing
- `set_step_trace_options(opts)` / `get_step_trace_options()` - Configure tracing
- `ST_OVER_DEBUG_SEG` / `ST_OVER_LIB_FUNC` / `ST_SKIP_LOOPS` - Step options

### Instruction/Function/Block Trace
- `enable_insn_trace(enable)` / `enable_func_trace(enable)` / `enable_bblk_trace(enable)` - Enable tracing
- `set_insn_trace_options(opts)` / `set_func_trace_options(opts)` - Configure
- `IT_LOG_SAME_IP` / `FT_LOG_RET` / `BT_LOG_INSTS` - Trace options

### Trace Events
- `get_tev_qty()` - Get trace event count
- `get_tev_info(tev)` - Get trace event details
- `get_insn_tev_reg_val(tev, reg)` - Get register value at instruction event
- `clear_trace()` - Clear trace buffer
- `set_trace_size(size)` - Set trace buffer size

## Event Types

### Debug Events
- `dbg_process_start` / `dbg_process_exit` - Process lifetime
- `dbg_thread_start` / `dbg_thread_exit` - Thread lifetime
- `dbg_library_load` / `dbg_library_unload` - Module events
- `dbg_bpt` / `dbg_exception` - Exception events
- `dbg_step_into` / `dbg_step_over` / `dbg_run_to` - Step events

### Trace Event Types
- `tev_insn` - Instruction execution
- `tev_call` - Function call
- `tev_ret` - Function return
- `tev_bpt` - Breakpoint hit
- `tev_mem` - Memory access

## Debugger Options (DOPT_*)
- `DOPT_START_BPT` - Break on process start
- `DOPT_ENTRY_BPT` - Break on entry point
- `DOPT_THREAD_BPT` - Break on new thread
- `DOPT_LIB_BPT` - Break on library load
- `DOPT_SUSPEND_ON_EXCEPTION` - Stop on exception

## DBG_Hooks
Override methods to receive debugger events (use `ida_dbg.DBG_Hooks` base class).

## See Also
Full docs: skill/docs/ida_dbg.rst

```

`skills/idapython/docs/ida_dbg.rst`:

```rst
ida_dbg
=======

.. py:module:: ida_dbg

.. autoapi-nested-parse::

   Contains functions to control the debugging of a process.

   See Debugger functions for a complete explanation of these functions.
   These functions are inlined for the kernel. They are not inlined for the user-interfaces. 
       



Attributes
----------

.. autoapisummary::

   ida_dbg.dbg_null
   ida_dbg.dbg_process_start
   ida_dbg.dbg_process_exit
   ida_dbg.dbg_process_attach
   ida_dbg.dbg_process_detach
   ida_dbg.dbg_thread_start
   ida_dbg.dbg_thread_exit
   ida_dbg.dbg_library_load
   ida_dbg.dbg_library_unload
   ida_dbg.dbg_information
   ida_dbg.dbg_exception
   ida_dbg.dbg_suspend_process
   ida_dbg.dbg_bpt
   ida_dbg.dbg_trace
   ida_dbg.dbg_request_error
   ida_dbg.dbg_step_into
   ida_dbg.dbg_step_over
   ida_dbg.dbg_run_to
   ida_dbg.dbg_step_until_ret
   ida_dbg.dbg_bpt_changed
   ida_dbg.dbg_started_loading_bpts
   ida_dbg.dbg_finished_loading_bpts
   ida_dbg.dbg_last
   ida_dbg.BPTEV_ADDED
   ida_dbg.BPTEV_REMOVED
   ida_dbg.BPTEV_CHANGED
   ida_dbg.DSTATE_SUSP
   ida_dbg.DSTATE_NOTASK
   ida_dbg.DSTATE_RUN
   ida_dbg.DBGINV_MEMORY
   ida_dbg.DBGINV_MEMCFG
   ida_dbg.DBGINV_REGS
   ida_dbg.DBGINV_ALL
   ida_dbg.DBGINV_REDRAW
   ida_dbg.DBGINV_NONE
   ida_dbg.MOVBPT_OK
   ida_dbg.MOVBPT_NOT_FOUND
   ida_dbg.MOVBPT_DEST_BUSY
   ida_dbg.MOVBPT_BAD_TYPE
   ida_dbg.BPLT_ABS
   ida_dbg.BPLT_REL
   ida_dbg.BPLT_SYM
   ida_dbg.BPLT_SRC
   ida_dbg.BPT_BRK
   ida_dbg.BPT_TRACE
   ida_dbg.BPT_UPDMEM
   ida_dbg.BPT_ENABLED
   ida_dbg.BPT_LOWCND
   ida_dbg.BPT_TRACEON
   ida_dbg.BPT_TRACE_INSN
   ida_dbg.BPT_TRACE_FUNC
   ida_dbg.BPT_TRACE_BBLK
   ida_dbg.BPT_TRACE_TYPES
   ida_dbg.BPT_ELANG_MASK
   ida_dbg.BPT_ELANG_SHIFT
   ida_dbg.BKPT_BADBPT
   ida_dbg.BKPT_LISTBPT
   ida_dbg.BKPT_TRACE
   ida_dbg.BKPT_ACTIVE
   ida_dbg.BKPT_PARTIAL
   ida_dbg.BKPT_CNDREADY
   ida_dbg.BKPT_FAKEPEND
   ida_dbg.BKPT_PAGE
   ida_dbg.BPTCK_NONE
   ida_dbg.BPTCK_NO
   ida_dbg.BPTCK_YES
   ida_dbg.BPTCK_ACT
   ida_dbg.ST_OVER_DEBUG_SEG
   ida_dbg.ST_OVER_LIB_FUNC
   ida_dbg.ST_ALREADY_LOGGED
   ida_dbg.ST_SKIP_LOOPS
   ida_dbg.ST_DIFFERENTIAL
   ida_dbg.ST_OPTIONS_MASK
   ida_dbg.ST_OPTIONS_DEFAULT
   ida_dbg.IT_LOG_SAME_IP
   ida_dbg.FT_LOG_RET
   ida_dbg.BT_LOG_INSTS
   ida_dbg.tev_none
   ida_dbg.tev_insn
   ida_dbg.tev_call
   ida_dbg.tev_ret
   ida_dbg.tev_bpt
   ida_dbg.tev_mem
   ida_dbg.tev_event
   ida_dbg.tev_max
   ida_dbg.SAVE_ALL_VALUES
   ida_dbg.SAVE_DIFF
   ida_dbg.SAVE_NONE
   ida_dbg.DEC_NOTASK
   ida_dbg.DEC_ERROR
   ida_dbg.DEC_TIMEOUT
   ida_dbg.WFNE_ANY
   ida_dbg.WFNE_SUSP
   ida_dbg.WFNE_SILENT
   ida_dbg.WFNE_CONT
   ida_dbg.WFNE_NOWAIT
   ida_dbg.WFNE_USEC
   ida_dbg.DOPT_SEGM_MSGS
   ida_dbg.DOPT_START_BPT
   ida_dbg.DOPT_THREAD_MSGS
   ida_dbg.DOPT_THREAD_BPT
   ida_dbg.DOPT_BPT_MSGS
   ida_dbg.DOPT_LIB_MSGS
   ida_dbg.DOPT_LIB_BPT
   ida_dbg.DOPT_INFO_MSGS
   ida_dbg.DOPT_INFO_BPT
   ida_dbg.DOPT_REAL_MEMORY
   ida_dbg.DOPT_REDO_STACK
   ida_dbg.DOPT_ENTRY_BPT
   ida_dbg.DOPT_EXCDLG
   ida_dbg.EXCDLG_NEVER
   ida_dbg.EXCDLG_UNKNOWN
   ida_dbg.EXCDLG_ALWAYS
   ida_dbg.DOPT_LOAD_DINFO
   ida_dbg.DOPT_END_BPT
   ida_dbg.DOPT_TEMP_HWBPT
   ida_dbg.DOPT_FAST_STEP
   ida_dbg.DOPT_DISABLE_ASLR
   ida_dbg.SRCIT_NONE
   ida_dbg.SRCIT_MODULE
   ida_dbg.SRCIT_FUNC
   ida_dbg.SRCIT_STMT
   ida_dbg.SRCIT_EXPR
   ida_dbg.SRCIT_STTVAR
   ida_dbg.SRCIT_LOCVAR
   ida_dbg.SRCDBG_PROV_VERSION
   ida_dbg.move_bpt_to_grp


Classes
-------

.. autoapisummary::

   ida_dbg.bpt_vec_t
   ida_dbg.tev_reg_values_t
   ida_dbg.tevinforeg_vec_t
   ida_dbg.memreg_infos_t
   ida_dbg.bptaddrs_t
   ida_dbg.bpt_location_t
   ida_dbg.bpt_t
   ida_dbg.tev_info_t
   ida_dbg.memreg_info_t
   ida_dbg.tev_reg_value_t
   ida_dbg.tev_info_reg_t
   ida_dbg.eval_ctx_t
   ida_dbg.DBG_Hooks


Functions
---------

.. autoapisummary::

   ida_dbg.run_to
   ida_dbg.request_run_to
   ida_dbg.run_requests
   ida_dbg.get_running_request
   ida_dbg.is_request_running
   ida_dbg.get_running_notification
   ida_dbg.clear_requests_queue
   ida_dbg.get_process_state
   ida_dbg.is_valid_dstate
   ida_dbg.set_process_state
   ida_dbg.invalidate_dbg_state
   ida_dbg.start_process
   ida_dbg.request_start_process
   ida_dbg.suspend_process
   ida_dbg.request_suspend_process
   ida_dbg.continue_process
   ida_dbg.request_continue_process
   ida_dbg.continue_backwards
   ida_dbg.request_continue_backwards
   ida_dbg.exit_process
   ida_dbg.request_exit_process
   ida_dbg.get_processes
   ida_dbg.attach_process
   ida_dbg.request_attach_process
   ida_dbg.detach_process
   ida_dbg.request_detach_process
   ida_dbg.is_debugger_busy
   ida_dbg.get_thread_qty
   ida_dbg.getn_thread
   ida_dbg.get_current_thread
   ida_dbg.getn_thread_name
   ida_dbg.select_thread
   ida_dbg.request_select_thread
   ida_dbg.suspend_thread
   ida_dbg.request_suspend_thread
   ida_dbg.resume_thread
   ida_dbg.request_resume_thread
   ida_dbg.get_first_module
   ida_dbg.get_next_module
   ida_dbg.step_into
   ida_dbg.request_step_into
   ida_dbg.step_over
   ida_dbg.request_step_over
   ida_dbg.step_into_backwards
   ida_dbg.request_step_into_backwards
   ida_dbg.step_over_backwards
   ida_dbg.request_step_over_backwards
   ida_dbg.run_to_backwards
   ida_dbg.request_run_to_backwards
   ida_dbg.step_until_ret
   ida_dbg.request_step_until_ret
   ida_dbg.set_resume_mode
   ida_dbg.request_set_resume_mode
   ida_dbg.get_dbg_reg_info
   ida_dbg.get_sp_val
   ida_dbg.get_ip_val
   ida_dbg.is_reg_integer
   ida_dbg.is_reg_float
   ida_dbg.is_reg_custom
   ida_dbg.set_bptloc_string
   ida_dbg.get_bptloc_string
   ida_dbg.get_bpt_qty
   ida_dbg.getn_bpt
   ida_dbg.get_bpt
   ida_dbg.exist_bpt
   ida_dbg.add_bpt
   ida_dbg.request_add_bpt
   ida_dbg.del_bpt
   ida_dbg.request_del_bpt
   ida_dbg.update_bpt
   ida_dbg.find_bpt
   ida_dbg.enable_bpt
   ida_dbg.disable_bpt
   ida_dbg.request_enable_bpt
   ida_dbg.request_disable_bpt
   ida_dbg.check_bpt
   ida_dbg.set_trace_size
   ida_dbg.clear_trace
   ida_dbg.request_clear_trace
   ida_dbg.is_step_trace_enabled
   ida_dbg.enable_step_trace
   ida_dbg.disable_step_trace
   ida_dbg.request_enable_step_trace
   ida_dbg.request_disable_step_trace
   ida_dbg.get_step_trace_options
   ida_dbg.set_step_trace_options
   ida_dbg.request_set_step_trace_options
   ida_dbg.is_insn_trace_enabled
   ida_dbg.enable_insn_trace
   ida_dbg.disable_insn_trace
   ida_dbg.request_enable_insn_trace
   ida_dbg.request_disable_insn_trace
   ida_dbg.get_insn_trace_options
   ida_dbg.set_insn_trace_options
   ida_dbg.request_set_insn_trace_options
   ida_dbg.is_func_trace_enabled
   ida_dbg.enable_func_trace
   ida_dbg.disable_func_trace
   ida_dbg.request_enable_func_trace
   ida_dbg.request_disable_func_trace
   ida_dbg.get_func_trace_options
   ida_dbg.set_func_trace_options
   ida_dbg.request_set_func_trace_options
   ida_dbg.enable_bblk_trace
   ida_dbg.disable_bblk_trace
   ida_dbg.request_enable_bblk_trace
   ida_dbg.request_disable_bblk_trace
   ida_dbg.is_bblk_trace_enabled
   ida_dbg.get_bblk_trace_options
   ida_dbg.set_bblk_trace_options
   ida_dbg.request_set_bblk_trace_options
   ida_dbg.get_tev_qty
   ida_dbg.get_tev_info
   ida_dbg.get_insn_tev_reg_val
   ida_dbg.get_insn_tev_reg_mem
   ida_dbg.get_insn_tev_reg_result
   ida_dbg.get_call_tev_callee
   ida_dbg.get_ret_tev_return
   ida_dbg.get_bpt_tev_ea
   ida_dbg.get_tev_memory_info
   ida_dbg.get_tev_event
   ida_dbg.get_trace_base_address
   ida_dbg.set_trace_base_address
   ida_dbg.dbg_add_thread
   ida_dbg.dbg_del_thread
   ida_dbg.dbg_add_tev
   ida_dbg.dbg_add_many_tevs
   ida_dbg.dbg_add_insn_tev
   ida_dbg.dbg_add_bpt_tev
   ida_dbg.dbg_add_call_tev
   ida_dbg.dbg_add_ret_tev
   ida_dbg.dbg_add_debug_event
   ida_dbg.load_trace_file
   ida_dbg.save_trace_file
   ida_dbg.is_valid_trace_file
   ida_dbg.set_trace_file_desc
   ida_dbg.get_trace_file_desc
   ida_dbg.choose_trace_file
   ida_dbg.diff_trace_file
   ida_dbg.graph_trace
   ida_dbg.set_highlight_trace_options
   ida_dbg.set_trace_platform
   ida_dbg.get_trace_platform
   ida_dbg.set_trace_dynamic_register_set
   ida_dbg.get_trace_dynamic_register_set
   ida_dbg.wait_for_next_event
   ida_dbg.get_debug_event
   ida_dbg.set_debugger_options
   ida_dbg.set_remote_debugger
   ida_dbg.get_process_options2
   ida_dbg.retrieve_exceptions
   ida_dbg.store_exceptions
   ida_dbg.define_exception
   ida_dbg.create_source_viewer
   ida_dbg.get_dbg_byte
   ida_dbg.put_dbg_byte
   ida_dbg.invalidate_dbgmem_config
   ida_dbg.invalidate_dbgmem_contents
   ida_dbg.is_debugger_on
   ida_dbg.is_debugger_memory
   ida_dbg.get_tev_ea
   ida_dbg.get_tev_type
   ida_dbg.get_tev_tid
   ida_dbg.bring_debugger_to_front
   ida_dbg.set_manual_regions
   ida_dbg.edit_manual_regions
   ida_dbg.enable_manual_regions
   ida_dbg.handle_debug_event
   ida_dbg.add_virt_module
   ida_dbg.del_virt_module
   ida_dbg.internal_ioctl
   ida_dbg.get_dbg_memory_info
   ida_dbg.set_bpt_group
   ida_dbg.set_bptloc_group
   ida_dbg.get_bpt_group
   ida_dbg.rename_bptgrp
   ida_dbg.del_bptgrp
   ida_dbg.get_grp_bpts
   ida_dbg.enable_bptgrp
   ida_dbg.get_local_vars
   ida_dbg.srcdbg_request_step_into
   ida_dbg.srcdbg_request_step_over
   ida_dbg.srcdbg_request_step_until_ret
   ida_dbg.hide_all_bpts
   ida_dbg.read_dbg_memory
   ida_dbg.get_module_info
   ida_dbg.dbg_bin_search
   ida_dbg.load_debugger
   ida_dbg.collect_stack_trace
   ida_dbg.get_global_var
   ida_dbg.get_local_var
   ida_dbg.get_srcinfo_provider
   ida_dbg.get_current_source_file
   ida_dbg.get_current_source_line
   ida_dbg.add_path_mapping
   ida_dbg.srcdbg_step_into
   ida_dbg.srcdbg_step_over
   ida_dbg.srcdbg_step_until_ret
   ida_dbg.set_debugger_event_cond
   ida_dbg.get_debugger_event_cond
   ida_dbg.set_process_options
   ida_dbg.get_process_options
   ida_dbg.get_manual_regions
   ida_dbg.dbg_is_loaded
   ida_dbg.refresh_debugger_memory
   ida_dbg.list_bptgrps
   ida_dbg.internal_get_sreg_base
   ida_dbg.write_dbg_memory
   ida_dbg.dbg_can_query
   ida_dbg.set_reg_val
   ida_dbg.request_set_reg_val
   ida_dbg.get_reg_val
   ida_dbg.get_reg_vals
   ida_dbg.get_tev_reg_val
   ida_dbg.get_tev_reg_mem_qty
   ida_dbg.get_tev_reg_mem
   ida_dbg.get_tev_reg_mem_ea
   ida_dbg.send_dbg_command


Module Contents
---------------

.. py:class:: bpt_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> bpt_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> bpt_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: bpt_vec_t) -> None


   .. py:method:: extract() -> bpt_t *


   .. py:method:: inject(s: bpt_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< bpt_t >::const_iterator


   .. py:method:: end(*args) -> qvector< bpt_t >::const_iterator


   .. py:method:: insert(it: bpt_t, x: bpt_t) -> qvector< bpt_t >::iterator


   .. py:method:: erase(*args) -> qvector< bpt_t >::iterator


   .. py:method:: append(x: bpt_t) -> None


   .. py:method:: extend(x: bpt_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: tev_reg_values_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> tev_reg_value_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> tev_reg_value_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: tev_reg_values_t) -> None


   .. py:method:: extract() -> tev_reg_value_t *


   .. py:method:: inject(s: tev_reg_value_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< tev_reg_value_t >::const_iterator


   .. py:method:: end(*args) -> qvector< tev_reg_value_t >::const_iterator


   .. py:method:: insert(it: tev_reg_value_t, x: tev_reg_value_t) -> qvector< tev_reg_value_t >::iterator


   .. py:method:: erase(*args) -> qvector< tev_reg_value_t >::iterator


   .. py:method:: append(x: tev_reg_value_t) -> None


   .. py:method:: extend(x: tev_reg_values_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: tevinforeg_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> tev_info_reg_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> tev_info_reg_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: tevinforeg_vec_t) -> None


   .. py:method:: extract() -> tev_info_reg_t *


   .. py:method:: inject(s: tev_info_reg_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< tev_info_reg_t >::const_iterator


   .. py:method:: end(*args) -> qvector< tev_info_reg_t >::const_iterator


   .. py:method:: insert(it: tev_info_reg_t, x: tev_info_reg_t) -> qvector< tev_info_reg_t >::iterator


   .. py:method:: erase(*args) -> qvector< tev_info_reg_t >::iterator


   .. py:method:: append(x: tev_info_reg_t) -> None


   .. py:method:: extend(x: tevinforeg_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: memreg_infos_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> memreg_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> memreg_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: memreg_infos_t) -> None


   .. py:method:: extract() -> memreg_info_t *


   .. py:method:: inject(s: memreg_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< memreg_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< memreg_info_t >::const_iterator


   .. py:method:: insert(it: memreg_info_t, x: memreg_info_t) -> qvector< memreg_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< memreg_info_t >::iterator


   .. py:method:: append(x: memreg_info_t) -> None


   .. py:method:: extend(x: memreg_infos_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: run_to(*args) -> bool

   Execute the process until the given address is reached. If no process is active, a new process is started. Technically, the debugger sets up a temporary breakpoint at the given address, and continues (or starts) the execution of the whole process. So, all threads continue their execution! \sq{Type, Asynchronous function - available as Request, Notification, dbg_run_to} 
           
   :param ea: target address
   :param pid: not used yet. please do not specify this parameter.
   :param tid: not used yet. please do not specify this parameter.


.. py:function:: request_run_to(*args) -> bool

   Post a run_to() request.


.. py:data:: dbg_null

.. py:data:: dbg_process_start

.. py:data:: dbg_process_exit

.. py:data:: dbg_process_attach

.. py:data:: dbg_process_detach

.. py:data:: dbg_thread_start

.. py:data:: dbg_thread_exit

.. py:data:: dbg_library_load

.. py:data:: dbg_library_unload

.. py:data:: dbg_information

.. py:data:: dbg_exception

.. py:data:: dbg_suspend_process

   The process is now suspended. 
             


.. py:data:: dbg_bpt

   A user defined breakpoint was reached. 
             


.. py:data:: dbg_trace

   A step occurred (one instruction was executed). This event notification is only generated if step tracing is enabled. 
             


.. py:data:: dbg_request_error

   An error occurred during the processing of a request. 
             


.. py:data:: dbg_step_into

.. py:data:: dbg_step_over

.. py:data:: dbg_run_to

.. py:data:: dbg_step_until_ret

.. py:data:: dbg_bpt_changed

   Breakpoint has been changed. 
             


.. py:data:: dbg_started_loading_bpts

   Started loading breakpoint info from idb.


.. py:data:: dbg_finished_loading_bpts

   Finished loading breakpoint info from idb.


.. py:data:: dbg_last

   The last debugger notification code.


.. py:data:: BPTEV_ADDED

   Breakpoint has been added.


.. py:data:: BPTEV_REMOVED

   Breakpoint has been removed.


.. py:data:: BPTEV_CHANGED

   Breakpoint has been modified.


.. py:function:: run_requests() -> bool

   Execute requests until all requests are processed or an asynchronous function is called. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: false if not all requests could be processed (indicates an asynchronous function was started)


.. py:function:: get_running_request() -> ui_notification_t

   Get the current running request. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: ui_null if no running request


.. py:function:: is_request_running() -> bool

   Is a request currently running?


.. py:function:: get_running_notification() -> dbg_notification_t

   Get the notification associated (if any) with the current running request. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: dbg_null if no running request


.. py:function:: clear_requests_queue() -> None

   Clear the queue of waiting requests. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: get_process_state() -> int

   Return the state of the currently debugged process. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: one of Debugged process states


.. py:data:: DSTATE_SUSP

   process is suspended and will not continue


.. py:data:: DSTATE_NOTASK

   no process is currently debugged


.. py:data:: DSTATE_RUN

   process is running


.. py:function:: is_valid_dstate(state: int) -> bool

.. py:data:: DBGINV_MEMORY

   invalidate cached memory contents


.. py:data:: DBGINV_MEMCFG

   invalidate cached process segmentation


.. py:data:: DBGINV_REGS

   invalidate cached register values


.. py:data:: DBGINV_ALL

   invalidate everything


.. py:data:: DBGINV_REDRAW

   refresh the screen


.. py:data:: DBGINV_NONE

   invalidate nothing


.. py:function:: set_process_state(newstate: int, p_thid: thid_t *, dbginv: int) -> int

   Set new state for the debugged process. Notifies the IDA kernel about the change of the debugged process state. For example, a debugger module could call this function when it knows that the process is suspended for a short period of time. Some IDA API calls can be made only when the process is suspended. The process state is usually restored before returning control to the caller. You must know that it is ok to change the process state, doing it at arbitrary moments may crash the application or IDA. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param newstate: new process state (one of Debugged process states) if DSTATE_NOTASK is passed then the state is not changed
   :param p_thid: ptr to new thread id. may be nullptr or pointer to NO_THREAD. the pointed variable will contain the old thread id upon return
   :param dbginv: Debugged process invalidation options
   :returns: old debugger state (one of Debugged process states)


.. py:function:: invalidate_dbg_state(dbginv: int) -> int

   Invalidate cached debugger information. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param dbginv: Debugged process invalidation options
   :returns: current debugger state (one of Debugged process states)


.. py:function:: start_process(path: str = None, args: str = None, sdir: str = None) -> int

   Start a process in the debugger. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_start} 
           
   :param path: path to the executable to start
   :param args: arguments to pass to process
   :param sdir: starting directory for the process
   :returns: -1: impossible to create the process
   :returns: 0: the starting of the process was cancelled by the user
   :returns: 1: the process was properly started


.. py:function:: request_start_process(path: str = None, args: str = None, sdir: str = None) -> int

   Post a start_process() request.


.. py:function:: suspend_process() -> bool

   Suspend the process in the debugger. \sq{ Type,
   * Synchronous function (if in a notification handler)
   * Asynchronous function (everywhere else)
   * available as Request, Notification,
   * none (if in a notification handler)
   * dbg_suspend_process (everywhere else) }



.. py:function:: request_suspend_process() -> bool

   Post a suspend_process() request.


.. py:function:: continue_process() -> bool

   Continue the execution of the process in the debugger. \sq{Type, Synchronous function - available as Request, Notification, none (synchronous function)} 
           


.. py:function:: request_continue_process() -> bool

   Post a continue_process() request. 
           


.. py:function:: continue_backwards() -> bool

   Continue the execution of the process in the debugger backwards. Can only be used with debuggers that support time-travel debugging. \sq{Type, Synchronous function - available as Request, Notification, none (synchronous function)} 
           


.. py:function:: request_continue_backwards() -> bool

   Post a continue_backwards() request. 
           


.. py:function:: exit_process() -> bool

   Terminate the debugging of the current process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_exit} 
           


.. py:function:: request_exit_process() -> bool

   Post an exit_process() request.


.. py:function:: get_processes(proclist: procinfo_vec_t) -> ssize_t

   Take a snapshot of running processes and return their description. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param proclist: array with information about each running process
   :returns: number of processes or -1 on error


.. py:function:: attach_process(*args) -> int

   Attach the debugger to a running process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_attach} 
           
   :param pid: PID of the process to attach to. If NO_PROCESS, a dialog box will interactively ask the user for the process to attach to.
   :param event_id: event to trigger upon attaching
   :returns: -4: debugger was not inited
   :returns: -3: the attaching is not supported
   :returns: -2: impossible to find a compatible process
   :returns: -1: impossible to attach to the given process (process died, privilege needed, not supported by the debugger plugin, ...)
   :returns: 0: the user cancelled the attaching to the process
   :returns: 1: the debugger properly attached to the process


.. py:function:: request_attach_process(pid: pid_t, event_id: int) -> int

   Post an attach_process() request.


.. py:function:: detach_process() -> bool

   Detach the debugger from the debugged process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_detach} 
           


.. py:function:: request_detach_process() -> bool

   Post a detach_process() request.


.. py:function:: is_debugger_busy() -> bool

   Is the debugger busy?. Some debuggers do not accept any commands while the debugged application is running. For such a debugger, it is unsafe to do anything with the database (even simple queries like get_byte may lead to undesired consequences). Returns: true if the debugged application is running under such a debugger 
           


.. py:function:: get_thread_qty() -> int

   Get number of threads. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: getn_thread(n: int) -> thid_t

   Get the ID of a thread. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of thread, is in range 0..get_thread_qty()-1
   :returns: NO_THREAD if the thread doesn't exist.


.. py:function:: get_current_thread() -> thid_t

   Get current thread ID. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: getn_thread_name(n: int) -> str

   Get the NAME of a thread \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of thread, is in range 0..get_thread_qty()-1 or -1 for the current thread
   :returns: thread name or nullptr if the thread doesn't exist.


.. py:function:: select_thread(tid: thid_t) -> bool

   Select the given thread as the current debugged thread. All thread related execution functions will work on this thread. The process must be suspended to select a new thread. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           
   :param tid: ID of the thread to select
   :returns: false if the thread doesn't exist.


.. py:function:: request_select_thread(tid: thid_t) -> bool

   Post a select_thread() request.


.. py:function:: suspend_thread(tid: thid_t) -> int

   Suspend thread. Suspending a thread may deadlock the whole application if the suspended was owning some synchronization objects. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           
   :param tid: thread id
   :returns: -1: network error
   :returns: 0: failed
   :returns: 1: ok


.. py:function:: request_suspend_thread(tid: thid_t) -> int

   Post a suspend_thread() request.


.. py:function:: resume_thread(tid: thid_t) -> int

   Resume thread. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           
   :param tid: thread id
   :returns: -1: network error
   :returns: 0: failed
   :returns: 1: ok


.. py:function:: request_resume_thread(tid: thid_t) -> int

   Post a resume_thread() request.


.. py:function:: get_first_module(modinfo: modinfo_t) -> bool

.. py:function:: get_next_module(modinfo: modinfo_t) -> bool

.. py:function:: step_into() -> bool

   Execute one instruction in the current thread. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_into} 
           


.. py:function:: request_step_into() -> bool

   Post a step_into() request.


.. py:function:: step_over() -> bool

   Execute one instruction in the current thread, but without entering into functions. Others threads keep suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_over} 
           


.. py:function:: request_step_over() -> bool

   Post a step_over() request.


.. py:function:: step_into_backwards() -> bool

   Execute one instruction backwards in the current thread. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_into} 
           


.. py:function:: request_step_into_backwards() -> bool

   Post a step_into_backwards() request.


.. py:function:: step_over_backwards() -> bool

   Execute one instruction backwards in the current thread, but without entering into functions. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_over} 
           


.. py:function:: request_step_over_backwards() -> bool

   Post a step_over_backwards() request.


.. py:function:: run_to_backwards(*args) -> bool

   Execute the process backwards until the given address is reached. Technically, the debugger sets up a temporary breakpoint at the given address, and continues (or starts) the execution of the whole process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_run_to} 
           
   :param ea: target address
   :param pid: not used yet. please do not specify this parameter.
   :param tid: not used yet. please do not specify this parameter.


.. py:function:: request_run_to_backwards(*args) -> bool

   Post a run_to_backwards() request.


.. py:function:: step_until_ret() -> bool

   Execute instructions in the current thread until a function return instruction is executed (aka "step out"). Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_until_ret} 
           


.. py:function:: request_step_until_ret() -> bool

   Post a step_until_ret() request.


.. py:function:: set_resume_mode(tid: thid_t, mode: resume_mode_t) -> bool

   How to resume the application. Set resume mode but do not resume process. 
           


.. py:function:: request_set_resume_mode(tid: thid_t, mode: resume_mode_t) -> bool

   Post a set_resume_mode() request.


.. py:function:: get_dbg_reg_info(regname: str, ri: register_info_t) -> bool

   Get register information \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: get_sp_val() -> uint64 *

   Get value of the SP register for the current thread. Requires a suspended debugger. 
           


.. py:function:: get_ip_val() -> uint64 *

   Get value of the IP (program counter) register for the current thread. Requires a suspended debugger. 
           


.. py:function:: is_reg_integer(regname: str) -> bool

   Does a register contain an integer value? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: is_reg_float(regname: str) -> bool

   Does a register contain a floating point value? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: is_reg_custom(regname: str) -> bool

   Does a register contain a value of a custom data type? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: set_bptloc_string(s: str) -> int

.. py:function:: get_bptloc_string(i: int) -> str

.. py:data:: MOVBPT_OK

   moved ok


.. py:data:: MOVBPT_NOT_FOUND

   source bpt not found


.. py:data:: MOVBPT_DEST_BUSY

   destination location is busy (we already have such a bpt)


.. py:data:: MOVBPT_BAD_TYPE

   BPLT_ABS is not supported.


.. py:class:: bptaddrs_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: bpt
      :type:  bpt_t *


.. py:data:: BPLT_ABS

   absolute address: ea


.. py:data:: BPLT_REL

   relative address: module_path, offset


.. py:data:: BPLT_SYM

   symbolic: symbol_name, offset


.. py:data:: BPLT_SRC

   source level: filename, lineno


.. py:class:: bpt_location_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: info
      :type:  ida_idaapi.ea_t


   .. py:attribute:: index
      :type:  int


   .. py:attribute:: loctype
      :type:  bpt_loctype_t


   .. py:method:: type() -> bpt_loctype_t

      Get bpt type.



   .. py:method:: is_empty_path() -> bool

      No path/filename specified? (BPLT_REL, BPLT_SRC)



   .. py:method:: path() -> str

      Get path/filename (BPLT_REL, BPLT_SRC)



   .. py:method:: symbol() -> str

      Get symbol name (BPLT_SYM)



   .. py:method:: lineno() -> int

      Get line number (BPLT_SRC)



   .. py:method:: offset() -> int

      Get offset (BPLT_REL, BPLT_SYM)



   .. py:method:: ea() -> ida_idaapi.ea_t

      Get address (BPLT_ABS)



   .. py:method:: set_abs_bpt(a: ida_idaapi.ea_t) -> None

      Specify an absolute address location.



   .. py:method:: set_src_bpt(fn: str, _lineno: int) -> None

      Specify a source level location.



   .. py:method:: set_sym_bpt(_symbol: str, _offset: int = 0) -> None

      Specify a symbolic location.



   .. py:method:: set_rel_bpt(mod: str, _offset: int) -> None

      Specify a relative address location.



   .. py:method:: compare(r: bpt_location_t) -> int

      Lexically compare two breakpoint locations. Bpt locations are first compared based on type (i.e. BPLT_ABS < BPLT_REL). BPLT_ABS locations are compared based on their ea values. For all other location types, locations are first compared based on their string (path/filename/symbol), then their offset/lineno. 
              



.. py:class:: bpt_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  size_t

      size of this structure



   .. py:attribute:: loc
      :type:  bpt_location_t

      Location.



   .. py:attribute:: pid
      :type:  pid_t

      breakpoint process id



   .. py:attribute:: tid
      :type:  thid_t

      breakpoint thread id



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      Address, if known. For BPLT_SRC, index into an internal data struct.



   .. py:attribute:: type
      :type:  bpttype_t

      Breakpoint type.



   .. py:attribute:: pass_count
      :type:  int

      Number of times the breakpoint is hit before stopping (default is 0: stop always) 
              



   .. py:attribute:: flags
      :type:  int

      Breakpoint property bits 
              



   .. py:attribute:: props
      :type:  int

      Internal breakpoint properties 
              



   .. py:attribute:: size
      :type:  int

      Size of the breakpoint (0 for software breakpoints)



   .. py:attribute:: cndidx
      :type:  int

      Internal number of the condition (<0-none)



   .. py:attribute:: bptid
      :type:  inode_t

      Internal breakpoint id.



   .. py:method:: is_hwbpt() -> bool

      Is hardware breakpoint?



   .. py:method:: enabled() -> bool

      Is breakpoint enabled?



   .. py:method:: is_low_level() -> bool

      Is bpt condition calculated at low level?



   .. py:method:: badbpt() -> bool

      Failed to write bpt to process memory?



   .. py:method:: listbpt() -> bool

      Include in the bpt list?



   .. py:method:: is_compiled() -> bool

      Condition has been compiled? 
              



   .. py:method:: is_active() -> bool

      Written completely to process?



   .. py:method:: is_partially_active() -> bool

      Written partially to process?



   .. py:method:: is_inactive() -> bool

      Not written to process at all?



   .. py:method:: is_page_bpt() -> bool

      Page breakpoint?



   .. py:method:: get_size() -> int

      Get bpt size.



   .. py:method:: set_abs_bpt(a: ida_idaapi.ea_t) -> None

      Set bpt location to an absolute address.



   .. py:method:: set_src_bpt(fn: str, lineno: int) -> None

      Set bpt location to a source line.



   .. py:method:: set_sym_bpt(sym: str, o: int) -> None

      Set bpt location to a symbol.



   .. py:method:: set_rel_bpt(mod: str, o: int) -> None

      Set bpt location to a relative address.



   .. py:method:: is_absbpt() -> bool

      Is absolute address breakpoint?



   .. py:method:: is_relbpt() -> bool

      Is relative address breakpoint?



   .. py:method:: is_symbpt() -> bool

      Is symbolic breakpoint?



   .. py:method:: is_srcbpt() -> bool

      Is source level breakpoint?



   .. py:method:: is_tracemodebpt() -> bool

      Does breakpoint trace anything?



   .. py:method:: is_traceonbpt() -> bool

      Is this a tracing breakpoint, and is tracing enabled?



   .. py:method:: is_traceoffbpt() -> bool

      Is this a tracing breakpoint, and is tracing disabled?



   .. py:method:: set_trace_action(enable: bool, trace_types: int) -> bool

      Configure tracing options.



   .. py:method:: get_cnd_elang_idx() -> size_t


   .. py:attribute:: condition
      :type:  PyObject *


   .. py:attribute:: elang
      :type:  PyObject *


.. py:data:: BPT_BRK

   suspend execution upon hit


.. py:data:: BPT_TRACE

   add trace information upon hit


.. py:data:: BPT_UPDMEM

   refresh the memory layout and contents before evaluating bpt condition


.. py:data:: BPT_ENABLED

   enabled?


.. py:data:: BPT_LOWCND

   condition is calculated at low level (on the server side)


.. py:data:: BPT_TRACEON

   enable tracing when the breakpoint is reached


.. py:data:: BPT_TRACE_INSN

   instruction tracing


.. py:data:: BPT_TRACE_FUNC

   function tracing


.. py:data:: BPT_TRACE_BBLK

   basic block tracing


.. py:data:: BPT_TRACE_TYPES

   trace insns, functions, and basic blocks. if any of BPT_TRACE_TYPES bits are set but BPT_TRACEON is clear, then turn off tracing for the specified trace types 
           


.. py:data:: BPT_ELANG_MASK

.. py:data:: BPT_ELANG_SHIFT

   index of the extlang (scripting language) of the condition


.. py:data:: BKPT_BADBPT

   failed to write the bpt to the process memory (at least one location)


.. py:data:: BKPT_LISTBPT

   include in bpt list (user-defined bpt)


.. py:data:: BKPT_TRACE

   trace bpt; should not be deleted when the process gets suspended


.. py:data:: BKPT_ACTIVE

   active?


.. py:data:: BKPT_PARTIAL

   partially active? (some locations were not written yet)


.. py:data:: BKPT_CNDREADY

   condition has been compiled


.. py:data:: BKPT_FAKEPEND

   fake pending bpt: it is inactive but another bpt of the same type is active at the same address(es) 
           


.. py:data:: BKPT_PAGE

   written to the process as a page bpt. Available only after writing the bpt to the process. 
           


.. py:function:: get_bpt_qty() -> int

   Get number of breakpoints. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: getn_bpt(n: int, bpt: bpt_t) -> bool

   Get the characteristics of a breakpoint. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of breakpoint, is in range 0..get_bpt_qty()-1
   :param bpt: filled with the characteristics.
   :returns: false if no breakpoint exists


.. py:function:: get_bpt(ea: ida_idaapi.ea_t, bpt: bpt_t) -> bool

   Get the characteristics of a breakpoint. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param ea: any address in the breakpoint range
   :param bpt: if not nullptr, is filled with the characteristics.
   :returns: false if no breakpoint exists


.. py:function:: exist_bpt(ea: ida_idaapi.ea_t) -> bool

   Does a breakpoint exist at the given location?


.. py:function:: add_bpt(*args) -> bool

   This function has the following signatures:

       0. add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
       1. add_bpt(bpt: const bpt_t &) -> bool

   # 0: add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool

   Add a new breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           

   # 1: add_bpt(bpt: const bpt_t &) -> bool

   Add a new breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           


.. py:function:: request_add_bpt(*args) -> bool

   This function has the following signatures:

       0. request_add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
       1. request_add_bpt(bpt: const bpt_t &) -> bool

   # 0: request_add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool

   Post an add_bpt(ea_t, asize_t, bpttype_t) request.


   # 1: request_add_bpt(bpt: const bpt_t &) -> bool

   Post an add_bpt(const bpt_t &) request.


.. py:function:: del_bpt(*args) -> bool

   This function has the following signatures:

       0. del_bpt(ea: ida_idaapi.ea_t) -> bool
       1. del_bpt(bptloc: const bpt_location_t &) -> bool

   # 0: del_bpt(ea: ida_idaapi.ea_t) -> bool

   Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           

   # 1: del_bpt(bptloc: const bpt_location_t &) -> bool

   Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           


.. py:function:: request_del_bpt(*args) -> bool

   This function has the following signatures:

       0. request_del_bpt(ea: ida_idaapi.ea_t) -> bool
       1. request_del_bpt(bptloc: const bpt_location_t &) -> bool

   # 0: request_del_bpt(ea: ida_idaapi.ea_t) -> bool

   Post a del_bpt(ea_t) request.


   # 1: request_del_bpt(bptloc: const bpt_location_t &) -> bool

   Post a del_bpt(const bpt_location_t &) request.


.. py:function:: update_bpt(bpt: bpt_t) -> bool

   Update modifiable characteristics of an existing breakpoint. To update the breakpoint location, use change_bptlocs() \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: find_bpt(bptloc: bpt_location_t, bpt: bpt_t) -> bool

   Find a breakpoint by location. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           
   :param bptloc: Breakpoint location
   :param bpt: bpt is filled if the breakpoint was found


.. py:function:: enable_bpt(*args) -> bool

.. py:function:: disable_bpt(*args) -> bool

.. py:function:: request_enable_bpt(*args) -> bool

.. py:function:: request_disable_bpt(*args) -> bool

.. py:function:: check_bpt(ea: ida_idaapi.ea_t) -> int

   Check the breakpoint at the specified address. 
           
   :returns: one of Breakpoint status codes


.. py:data:: BPTCK_NONE

   breakpoint does not exist


.. py:data:: BPTCK_NO

   breakpoint is disabled


.. py:data:: BPTCK_YES

   breakpoint is enabled


.. py:data:: BPTCK_ACT

   breakpoint is active (written to the process)


.. py:function:: set_trace_size(size: int) -> bool

   Specify the new size of the circular buffer. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param size: if 0, buffer isn't circular and events are never removed. If the new size is smaller than the existing number of trace events, a corresponding number of trace events are removed.


.. py:function:: clear_trace() -> None

   Clear all events in the trace buffer. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           


.. py:function:: request_clear_trace() -> None

   Post a clear_trace() request.


.. py:function:: is_step_trace_enabled() -> bool

   Get current state of step tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: enable_step_trace(enable: int = 1) -> bool

.. py:function:: disable_step_trace() -> bool

.. py:function:: request_enable_step_trace(enable: int = 1) -> bool

.. py:function:: request_disable_step_trace() -> bool

.. py:data:: ST_OVER_DEBUG_SEG

   step tracing will be disabled when IP is in a debugger segment


.. py:data:: ST_OVER_LIB_FUNC

   step tracing will be disabled when IP is in a library function


.. py:data:: ST_ALREADY_LOGGED

   step tracing will be disabled when IP is already logged


.. py:data:: ST_SKIP_LOOPS

   step tracing will try to skip loops already recorded


.. py:data:: ST_DIFFERENTIAL

   tracing: log only new instructions (not previously logged) 
           


.. py:data:: ST_OPTIONS_MASK

   mask of available options, to ensure compatibility with newer IDA versions


.. py:data:: ST_OPTIONS_DEFAULT

.. py:data:: IT_LOG_SAME_IP

   specific options for instruction tracing (see set_insn_trace_options())

   instruction tracing will log new instructions even when IP doesn't change 
           


.. py:data:: FT_LOG_RET

   specific options for function tracing (see set_func_trace_options())

   function tracing will log returning instructions 
           


.. py:data:: BT_LOG_INSTS

   specific options for basic block tracing (see set_bblk_trace_options())

   log all instructions in the current basic block 
           


.. py:function:: get_step_trace_options() -> int

   Get current step tracing options. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: Step trace options


.. py:function:: set_step_trace_options(options: int) -> None

   Modify step tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           


.. py:function:: request_set_step_trace_options(options: int) -> None

   Post a set_step_trace_options() request.


.. py:function:: is_insn_trace_enabled() -> bool

   Get current state of instruction tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: enable_insn_trace(enable: bool = True) -> bool

.. py:function:: disable_insn_trace() -> bool

.. py:function:: request_enable_insn_trace(enable: bool = True) -> bool

.. py:function:: request_disable_insn_trace() -> bool

.. py:function:: get_insn_trace_options() -> int

   Get current instruction tracing options. Also see IT_LOG_SAME_IP \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: set_insn_trace_options(options: int) -> None

   Modify instruction tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           


.. py:function:: request_set_insn_trace_options(options: int) -> None

   Post a set_insn_trace_options() request.


.. py:function:: is_func_trace_enabled() -> bool

   Get current state of functions tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: enable_func_trace(enable: bool = True) -> bool

.. py:function:: disable_func_trace() -> bool

.. py:function:: request_enable_func_trace(enable: bool = True) -> bool

.. py:function:: request_disable_func_trace() -> bool

.. py:function:: get_func_trace_options() -> int

   Get current function tracing options. Also see FT_LOG_RET \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: set_func_trace_options(options: int) -> None

   Modify function tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
           


.. py:function:: request_set_func_trace_options(options: int) -> None

   Post a set_func_trace_options() request.


.. py:function:: enable_bblk_trace(enable: bool = True) -> bool

.. py:function:: disable_bblk_trace() -> bool

.. py:function:: request_enable_bblk_trace(enable: bool = True) -> bool

.. py:function:: request_disable_bblk_trace() -> bool

.. py:function:: is_bblk_trace_enabled() -> bool

.. py:function:: get_bblk_trace_options() -> int

   Get current basic block tracing options. Also see BT_LOG_INSTS \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: set_bblk_trace_options(options: int) -> None

   Modify basic block tracing options (see BT_LOG_INSTS)


.. py:function:: request_set_bblk_trace_options(options: int) -> None

   Post a set_bblk_trace_options() request.


.. py:data:: tev_none

   no event


.. py:data:: tev_insn

   an instruction trace


.. py:data:: tev_call

   a function call trace


.. py:data:: tev_ret

   a function return trace


.. py:data:: tev_bpt

   write, read/write, execution trace


.. py:data:: tev_mem

   memory layout changed


.. py:data:: tev_event

   debug event occurred


.. py:data:: tev_max

   first unused event type


.. py:class:: tev_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: type
      :type:  tev_type_t

      trace event type



   .. py:attribute:: tid
      :type:  thid_t

      thread where the event was recorded



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      address where the event occurred



.. py:class:: memreg_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:method:: get_bytes() -> PyObject *


   .. py:attribute:: bytes


.. py:function:: get_tev_qty() -> int

   Get number of trace events available in trace buffer. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: get_tev_info(n: int, tev_info: tev_info_t) -> bool

   Get main information about a trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :param tev_info: result
   :returns: success


.. py:function:: get_insn_tev_reg_val(n: int, regname: str, regval: regval_t) -> bool

   Read a register value from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :param regname: name of desired register
   :param regval: result
   :returns: false if not an instruction event.


.. py:function:: get_insn_tev_reg_mem(n: int, memmap: memreg_infos_t) -> bool

   Read the memory pointed by register values from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :param memmap: result
   :returns: false if not an instruction event or no memory is available


.. py:function:: get_insn_tev_reg_result(n: int, regname: str, regval: regval_t) -> bool

   Read the resulting register value from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :param regname: name of desired register
   :param regval: result
   :returns: false if not an instruction trace event or register wasn't modified.


.. py:function:: get_call_tev_callee(n: int) -> ida_idaapi.ea_t

   Get the called function from a function call trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :returns: BADADDR if not a function call event.


.. py:function:: get_ret_tev_return(n: int) -> ida_idaapi.ea_t

   Get the return address from a function return trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :returns: BADADDR if not a function return event.


.. py:function:: get_bpt_tev_ea(n: int) -> ida_idaapi.ea_t

   Get the address associated to a read, read/write or execution trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :returns: BADADDR if not a read, read/write or execution trace event.


.. py:function:: get_tev_memory_info(n: int, mi: meminfo_vec_t) -> bool

   Get the memory layout, if any, for the specified tev object. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :param mi: result
   :returns: false if the tev_t object is not of type tev_mem, true otherwise, with the new memory layout in "mi".


.. py:function:: get_tev_event(n: int, d: debug_event_t) -> bool

   Get the corresponding debug event, if any, for the specified tev object. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
   :param d: result
   :returns: false if the tev_t object doesn't have any associated debug event, true otherwise, with the debug event in "d".


.. py:function:: get_trace_base_address() -> ida_idaapi.ea_t

   Get the base address of the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: the base address of the currently loaded trace


.. py:function:: set_trace_base_address(ea: ida_idaapi.ea_t) -> None

   Set the base address of the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: dbg_add_thread(tid: thid_t) -> None

   Add a thread to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: dbg_del_thread(tid: thid_t) -> None

   Delete a thread from the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: dbg_add_tev(type: tev_type_t, tid: thid_t, address: ida_idaapi.ea_t) -> None

   Add a new trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:class:: tev_reg_value_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: value
      :type:  regval_t


   .. py:attribute:: reg_idx
      :type:  int


.. py:class:: tev_info_reg_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: info
      :type:  tev_info_t


   .. py:attribute:: registers
      :type:  tev_reg_values_t


.. py:data:: SAVE_ALL_VALUES

.. py:data:: SAVE_DIFF

.. py:data:: SAVE_NONE

.. py:function:: dbg_add_many_tevs(new_tevs: tevinforeg_vec_t) -> bool

   Add many new trace elements to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: false if the operation failed for any tev_info_t object


.. py:function:: dbg_add_insn_tev(tid: thid_t, ea: ida_idaapi.ea_t, save: save_reg_values_t = SAVE_DIFF) -> bool

   Add a new instruction trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: false if the operation failed, true otherwise


.. py:function:: dbg_add_bpt_tev(tid: thid_t, ea: ida_idaapi.ea_t, bp: ida_idaapi.ea_t) -> bool

   Add a new breakpoint trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :returns: false if the operation failed, true otherwise


.. py:function:: dbg_add_call_tev(tid: thid_t, caller: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None

   Add a new call trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: dbg_add_ret_tev(tid: thid_t, ret_insn: ida_idaapi.ea_t, return_to: ida_idaapi.ea_t) -> None

   Add a new return trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: dbg_add_debug_event(event: debug_event_t) -> None

   Add a new debug event to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           


.. py:function:: load_trace_file(filename: str) -> str

   Load a recorded trace file in the 'Tracing' window. If the call succeeds and 'buf' is not null, the description of the trace stored in the binary trace file will be returned in 'buf' 
           


.. py:function:: save_trace_file(filename: str, description: str) -> bool

   Save the current trace in the specified file.


.. py:function:: is_valid_trace_file(filename: str) -> bool

   Is the specified file a valid trace file for the current database?


.. py:function:: set_trace_file_desc(filename: str, description: str) -> bool

   Change the description of the specified trace file.


.. py:function:: get_trace_file_desc(filename: str) -> str

   Get the file header of the specified trace file.


.. py:function:: choose_trace_file() -> str

   Show the choose trace dialog.


.. py:function:: diff_trace_file(NONNULL_filename: str) -> bool

   Show difference between the current trace and the one from 'filename'.


.. py:function:: graph_trace() -> bool

   Show the trace callgraph.


.. py:function:: set_highlight_trace_options(hilight: bool, color: bgcolor_t, diff: bgcolor_t) -> None

   Set highlight trace parameters.


.. py:function:: set_trace_platform(platform: str) -> None

   Set platform name of current trace.


.. py:function:: get_trace_platform() -> str

   Get platform name of current trace.


.. py:function:: set_trace_dynamic_register_set(idaregs: dynamic_register_set_t &) -> None

   Set dynamic register set of current trace.


.. py:function:: get_trace_dynamic_register_set(idaregs: dynamic_register_set_t *) -> None

   Get dynamic register set of current trace.


.. py:data:: DEC_NOTASK

   process does not exist


.. py:data:: DEC_ERROR

   error


.. py:data:: DEC_TIMEOUT

   timeout


.. py:data:: WFNE_ANY

   return the first event (even if it doesn't suspend the process)


.. py:data:: WFNE_SUSP

   wait until the process gets suspended


.. py:data:: WFNE_SILENT

   1: be silent, 0:display modal boxes if necessary


.. py:data:: WFNE_CONT

   continue from the suspended state


.. py:data:: WFNE_NOWAIT

   do not wait for any event, immediately return DEC_TIMEOUT (to be used with WFNE_CONT) 
           


.. py:data:: WFNE_USEC

   timeout is specified in microseconds (minimum non-zero timeout is 40000us) 
           


.. py:data:: DOPT_SEGM_MSGS

   log debugger segments modifications


.. py:data:: DOPT_START_BPT

   break on process start


.. py:data:: DOPT_THREAD_MSGS

   log thread starts/exits


.. py:data:: DOPT_THREAD_BPT

   break on thread start/exit


.. py:data:: DOPT_BPT_MSGS

   log breakpoints


.. py:data:: DOPT_LIB_MSGS

   log library loads/unloads


.. py:data:: DOPT_LIB_BPT

   break on library load/unload


.. py:data:: DOPT_INFO_MSGS

   log debugging info events


.. py:data:: DOPT_INFO_BPT

   break on debugging information


.. py:data:: DOPT_REAL_MEMORY

   do not hide breakpoint instructions


.. py:data:: DOPT_REDO_STACK

   reconstruct the stack


.. py:data:: DOPT_ENTRY_BPT

   break on program entry point


.. py:data:: DOPT_EXCDLG

   exception dialogs:


.. py:data:: EXCDLG_NEVER

   never display exception dialogs


.. py:data:: EXCDLG_UNKNOWN

   display for unknown exceptions


.. py:data:: EXCDLG_ALWAYS

   always display


.. py:data:: DOPT_LOAD_DINFO

   automatically load debug files (pdb)


.. py:data:: DOPT_END_BPT

   evaluate event condition on process end


.. py:data:: DOPT_TEMP_HWBPT

   when possible use hardware bpts for temp bpts


.. py:data:: DOPT_FAST_STEP

   prevent debugger memory refreshes when single-stepping


.. py:data:: DOPT_DISABLE_ASLR

   disable ASLR


.. py:function:: wait_for_next_event(wfne: int, timeout: int) -> dbg_event_code_t

   Wait for the next event.
   This function (optionally) resumes the process execution, and waits for a debugger event until a possible timeout occurs.

   :param wfne: combination of Wait for debugger event flags constants
   :param timeout: number of seconds to wait, -1-infinity
   :returns: either an event_id_t (if > 0), or a dbg_event_code_t (if <= 0)


.. py:function:: get_debug_event() -> debug_event_t const *

   Get the current debugger event.


.. py:function:: set_debugger_options(options: uint) -> uint

   Set debugger options. Replaces debugger options with the specification combination Debugger options 
           
   :returns: the old debugger options


.. py:function:: set_remote_debugger(host: str, _pass: str, port: int = -1) -> None

   Set remote debugging options. Should be used before starting the debugger. 
           
   :param host: If empty, IDA will use local debugger. If nullptr, the host will not be set.
   :param port: If -1, the default port number will be used


.. py:function:: get_process_options2() -> qstring *, qstring *, launch_env_t *, qstring *, qstring *, qstring *, int *

.. py:function:: retrieve_exceptions() -> excvec_t *

   Retrieve the exception information. You may freely modify the returned vector and add/edit/delete exceptions You must call store_exceptions() after any modifications Note: exceptions with code zero, multiple exception codes or names are prohibited 
           


.. py:function:: store_exceptions() -> bool

   Update the exception information stored in the debugger module by invoking its dbg->set_exception_info callback 
           


.. py:function:: define_exception(code: uint, name: str, desc: str, flags: int) -> str

   Convenience function: define new exception code. 
           
   :param code: exception code (cannot be 0)
   :param name: exception name (cannot be empty or nullptr)
   :param desc: exception description (maybe nullptr)
   :param flags: combination of Exception info flags
   :returns: failure message or nullptr. You must call store_exceptions() if this function succeeds


.. py:class:: eval_ctx_t(_ea: ida_idaapi.ea_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


.. py:data:: SRCIT_NONE

   unknown


.. py:data:: SRCIT_MODULE

   module


.. py:data:: SRCIT_FUNC

   function


.. py:data:: SRCIT_STMT

   a statement (if/while/for...)


.. py:data:: SRCIT_EXPR

   an expression (a+b*c)


.. py:data:: SRCIT_STTVAR

   static variable/code


.. py:data:: SRCIT_LOCVAR

   a stack, register, or register-relative local variable or parameter


.. py:data:: SRCDBG_PROV_VERSION

.. py:function:: create_source_viewer(out_ccv: TWidget **, parent: TWidget *, custview: TWidget *, sf: source_file_ptr, lines: strvec_t *, lnnum: int, colnum: int, flags: int) -> source_view_t *

   Create a source code view.


.. py:function:: get_dbg_byte(ea: ida_idaapi.ea_t) -> uint32 *

   Get one byte of the debugged process memory. 
           
   :param ea: linear address
   :returns: success
   :returns: true: success
   :returns: false: address inaccessible or debugger not running


.. py:function:: put_dbg_byte(ea: ida_idaapi.ea_t, x: int) -> bool

   Change one byte of the debugged process memory. 
           
   :param ea: linear address
   :param x: byte value
   :returns: true if the process memory has been modified


.. py:function:: invalidate_dbgmem_config() -> None

   Invalidate the debugged process memory configuration. Call this function if the debugged process might have changed its memory layout (allocated more memory, for example) 
           


.. py:function:: invalidate_dbgmem_contents(ea: ida_idaapi.ea_t, size: asize_t) -> None

   Invalidate the debugged process memory contents. Call this function each time the process has been stopped or the process memory is modified. If ea == BADADDR, then the whole memory contents will be invalidated 
           


.. py:function:: is_debugger_on() -> bool

   Is the debugger currently running?


.. py:function:: is_debugger_memory(ea: ida_idaapi.ea_t) -> bool

   Is the address mapped to debugger memory?


.. py:function:: get_tev_ea(n: int) -> ida_idaapi.ea_t

.. py:function:: get_tev_type(n: int) -> int

.. py:function:: get_tev_tid(n: int) -> int

.. py:function:: bring_debugger_to_front() -> None

.. py:function:: set_manual_regions(ranges: meminfo_vec_t) -> None

.. py:function:: edit_manual_regions() -> None

.. py:function:: enable_manual_regions(enable: bool) -> None

.. py:function:: handle_debug_event(ev: debug_event_t, rqflags: int) -> int

.. py:function:: add_virt_module(mod: modinfo_t) -> bool

.. py:function:: del_virt_module(base: ea_t const) -> bool

.. py:function:: internal_ioctl(fn: int, buf: void const *, poutbuf: void **, poutsize: ssize_t *) -> int

.. py:function:: get_dbg_memory_info(ranges: meminfo_vec_t) -> int

.. py:function:: set_bpt_group(bpt: bpt_t, grp_name: str) -> bool

   Move a bpt into a folder in the breakpoint dirtree if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param bpt: bpt that will be moved
   :param grp_name: absolute path to the breakpoint dirtree folder
   :returns: success


.. py:function:: set_bptloc_group(bptloc: bpt_location_t, grp_name: str) -> bool

   Move a bpt into a folder in the breakpoint dirtree based on the bpt_location find_bpt is called to retrieve the bpt and then set_bpt_group if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param bptloc: bptlocation of the bpt that will be moved
   :param grp_name: absolute path to the breakpoint dirtree folder
   :returns: success


.. py:function:: get_bpt_group(bptloc: bpt_location_t) -> str

   Retrieve the absolute path to the folder of the bpt based on the bpt_location find_bpt is called to retrieve the bpt \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param bptloc: bptlocation of the bpt
   :returns: success
   :returns: true: breakpoint correclty moved to the directory


.. py:function:: rename_bptgrp(old_name: str, new_name: str) -> bool

   Rename a folder of bpt dirtree \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param old_name: absolute path to the folder to be renamed
   :param new_name: absolute path of the new folder name
   :returns: success


.. py:function:: del_bptgrp(name: str) -> bool

   Delete a folder, bpt that were part of this folder are moved to the root folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param name: full path to the folder to be deleted
   :returns: success


.. py:function:: get_grp_bpts(bpts: bpt_vec_t, grp_name: str) -> ssize_t

   Retrieve a copy the bpts stored in a folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param bpts: : pointer to a vector where the copy of bpts are stored
   :param grp_name: absolute path to the folder
   :returns: number of bpts present in the vector


.. py:function:: enable_bptgrp(bptgrp_name: str, enable: bool = True) -> int

   Enable (or disable) all bpts in a folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
           
   :param bptgrp_name: absolute path to the folder
   :param enable: by default true, enable bpts, false disable bpts
   :returns: -1: an error occured
   :returns: 0: no changes
   :returns: >0: nubmers of bpts udpated


.. py:function:: get_local_vars(prov: srcinfo_provider_t *, ea: ida_idaapi.ea_t, out: source_items_t *) -> bool

.. py:function:: srcdbg_request_step_into() -> bool

.. py:function:: srcdbg_request_step_over() -> bool

.. py:function:: srcdbg_request_step_until_ret() -> bool

.. py:function:: hide_all_bpts() -> int

.. py:function:: read_dbg_memory(ea: ida_idaapi.ea_t, buffer: void *, size: size_t) -> ssize_t

.. py:function:: get_module_info(ea: ida_idaapi.ea_t, modinfo: modinfo_t) -> bool

.. py:function:: dbg_bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t const &, srch_flags: int) -> str

.. py:function:: load_debugger(dbgname: str, use_remote: bool) -> bool

.. py:function:: collect_stack_trace(tid: thid_t, trace: call_stack_t) -> bool

.. py:function:: get_global_var(prov: srcinfo_provider_t *, ea: ida_idaapi.ea_t, name: str, out: source_item_ptr *) -> bool

.. py:function:: get_local_var(prov: srcinfo_provider_t *, ea: ida_idaapi.ea_t, name: str, out: source_item_ptr *) -> bool

.. py:function:: get_srcinfo_provider(name: str) -> srcinfo_provider_t *

.. py:function:: get_current_source_file() -> str

.. py:function:: get_current_source_line() -> int

.. py:function:: add_path_mapping(src: str, dst: str) -> None

.. py:function:: srcdbg_step_into() -> bool

.. py:function:: srcdbg_step_over() -> bool

.. py:function:: srcdbg_step_until_ret() -> bool

.. py:function:: set_debugger_event_cond(NONNULL_evcond: str) -> None

.. py:function:: get_debugger_event_cond() -> str

.. py:function:: set_process_options(*args) -> None

   Set process options. Any of the arguments may be nullptr, which means 'do not modify' 
           


.. py:function:: get_process_options() -> qstring *, qstring *, qstring *, qstring *, qstring *, int *

   Get process options. Any of the arguments may be nullptr 
           


.. py:function:: get_manual_regions(*args)

   Returns the manual memory regions

   This function has the following signatures:

       1. get_manual_regions() -> List[Tuple(ida_idaapi.ea_t, ida_idaapi.ea_t, str, str, ida_idaapi.ea_t, int, int)]
          Where each tuple holds (start_ea, end_ea, name, sclass, sbase, bitness, perm)
       2. get_manual_regions(storage: meminfo_vec_t) -> None


.. py:function:: dbg_is_loaded()

   Checks if a debugger is loaded

   :returns: Boolean


.. py:function:: refresh_debugger_memory()

   Refreshes the debugger memory

   :returns: Nothing


.. py:class:: DBG_Hooks(_flags: int = 0, _hkcb_flags: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: hook() -> bool


   .. py:method:: unhook() -> bool


   .. py:method:: dbg_process_start(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: asize_t) -> None


   .. py:method:: dbg_process_exit(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, exit_code: int) -> None


   .. py:method:: dbg_process_attach(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: asize_t) -> None


   .. py:method:: dbg_process_detach(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t) -> None


   .. py:method:: dbg_thread_start(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t) -> None


   .. py:method:: dbg_thread_exit(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, exit_code: int) -> None


   .. py:method:: dbg_library_load(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: asize_t) -> None


   .. py:method:: dbg_library_unload(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, info: str) -> None


   .. py:method:: dbg_information(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, info: str) -> None


   .. py:method:: dbg_exception(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, exc_code: int, exc_can_cont: bool, exc_ea: ida_idaapi.ea_t, exc_info: str) -> int


   .. py:method:: dbg_suspend_process() -> None

      The process is now suspended. 
                



   .. py:method:: dbg_bpt(tid: thid_t, bptea: ida_idaapi.ea_t) -> int

      A user defined breakpoint was reached. 
                
      :param tid: (thid_t)
      :param bptea: (::ea_t)



   .. py:method:: dbg_trace(tid: thid_t, ip: ida_idaapi.ea_t) -> int

      A step occurred (one instruction was executed). This event notification is only generated if step tracing is enabled. 
                
      :param tid: (thid_t) thread ID
      :param ip: (::ea_t) current instruction pointer. usually points after the executed instruction
      :returns: 1: do not log this trace event
      :returns: 0: log it



   .. py:method:: dbg_request_error(failed_command: int, failed_dbg_notification: int) -> None

      An error occurred during the processing of a request. 
                
      :param failed_command: (ui_notification_t)
      :param failed_dbg_notification: (dbg_notification_t)



   .. py:method:: dbg_step_into() -> None


   .. py:method:: dbg_step_over() -> None


   .. py:method:: dbg_run_to(pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t) -> None


   .. py:method:: dbg_step_until_ret() -> None


   .. py:method:: dbg_bpt_changed(bptev_code: int, bpt: bpt_t) -> None

      Breakpoint has been changed. 
                
      :param bptev_code: (int) Breakpoint modification events
      :param bpt: (bpt_t *)



   .. py:method:: dbg_started_loading_bpts() -> None

      Started loading breakpoint info from idb.



   .. py:method:: dbg_finished_loading_bpts() -> None

      Finished loading breakpoint info from idb.



.. py:function:: list_bptgrps() -> List[str]

   Retrieve the list of absolute path of all folders of bpt dirtree.
   Synchronous function, Notification, none (synchronous function)


.. py:function:: internal_get_sreg_base(tid: int, sreg_value: int)

   Get the sreg base, for the given thread.

   :param tid: the thread ID
   :param sreg_value: the sreg value
   :returns: The sreg base, or BADADDR on failure.


.. py:function:: write_dbg_memory(*args) -> ssize_t

.. py:function:: dbg_can_query()

   This function can be used to check if the debugger can be queried:
     - debugger is loaded
     - process is suspended
     - process is not suspended but can take requests. In this case some requests like
       memory read/write, bpt management succeed and register querying will fail.
       Check if idaapi.get_process_state() < 0 to tell if the process is suspended

   :returns: Boolean


.. py:function:: set_reg_val(*args) -> bool

   Set a register value by name

   This function has the following signatures:
       1. set_reg_val(name: str, value: Union[int, float, bytes]) -> bool
       1. set_reg_val(tid: int, regidx: int, value: Union[int, float, bytes]) -> bool

   Depending on the register type, this will expect
   either an integer, a float or, in the case of large
   vector registers, a bytes sequence.

   :param name: (1st form) the register name
   :param tid: (2nd form) the thread ID
   :param regidx: (2nd form) the register index
   :param value: the register value
   :returns: success


.. py:function:: request_set_reg_val(regname: str, o: PyObject *) -> PyObject *

   Post a set_reg_val() request.


.. py:function:: get_reg_val(*args)

   Get a register value.

   This function has the following signatures:

       1. get_reg_val(name: str) -> Union[int, float, bytes]
       2. get_reg_val(name: str, regval: regval_t) -> bool

   The first (and most user-friendly) form will return
   a value whose type is related to the register type.
   I.e., either an integer, a float or, in the case of large
   vector registers, a bytes sequence.

   :param name: the register name
   :returns: the register value (1st form)


.. py:function:: get_reg_vals(tid: int, clsmask: int = -1) -> ida_idd.regvals_t

   Fetch live registers values for the thread

   :param tid: The ID of the thread to read registers for
   :param clsmask: An OR'ed mask of register classes to
          read values for (can be used to speed up the
          retrieval process)

   :returns: a list of register values (empty if an error occurs)


.. py:function:: get_tev_reg_val(tev, reg)

.. py:function:: get_tev_reg_mem_qty(tev)

.. py:function:: get_tev_reg_mem(tev, idx)

.. py:function:: get_tev_reg_mem_ea(tev, idx)

.. py:function:: send_dbg_command(command)

   Send a direct command to the debugger backend, and
   retrieve the result as a string.

   Note: any double-quotes in 'command' must be backslash-escaped.
   Note: this only works with some debugger backends: Bochs, WinDbg, GDB.

   Returns: (True, <result string>) on success, or (False, <Error message string>) on failure


.. py:data:: move_bpt_to_grp


```

`skills/idapython/docs/ida_dirtree.md`:

```md
# ida_dirtree

Directory tree organization for IDA items (types, functions, names, etc).

## Overview
Provides virtual directory structure over collections accessed by inode (ID). Used for organizing local types, structures, enums, functions, names, bookmarks, etc.

## Standard Trees
- `DIRTREE_LOCAL_TYPES` - Local type library
- `DIRTREE_FUNCS` - Function list
- `DIRTREE_NAMES` - Named locations
- `DIRTREE_IMPORTS` - Imported functions
- `DIRTREE_BPTS` - Breakpoints
- `get_std_dirtree(id)` - Access standard tree

## Key Classes

### dirtree_t
Main directory tree interface.

- `chdir(path)` / `getcwd()` - Navigate directories
- `mkdir(path)` / `rmdir(path)` - Create/delete directories
- `link(path/inode)` / `unlink(path/inode)` - Add/remove items
- `rename(from, to)` - Rename entry
- `resolve_path(path)` - Convert path to direntry_t
- `get_abspath(cursor/relpath)` - Get absolute path
- `isdir(path/de)` / `isfile(path/de)` - Check entry type
- `findfirst(ff, pattern)` / `findnext(ff)` - Iterate entries
- `traverse(visitor)` - Depth-first traversal with callback

### direntry_t
Represents a directory entry (inode or directory).

- `idx` - inode_t or diridx_t
- `isdir` - True if directory, false if file
- `valid()` - Check if entry exists

### dirtree_cursor_t
Cursor for navigating tree.

- `parent` - Parent directory index
- `rank` - Index within parent
- `is_root_cursor()` / `set_root_cursor()` - Root operations

### dirspec_t
Specialization interface (defines how inodes map to items).

- `get_name(inode, name_flags)` - Get item name
- `get_inode(dirpath, name)` - Lookup inode by name
- `rename_inode(inode, newname)` - Rename item
- `unlink_inode(inode)` - Notification when unlinked

## Error Codes
- `DTE_OK` - Success
- `DTE_ALREADY_EXISTS` - Item exists
- `DTE_NOT_FOUND` - Item not found
- `DTE_NOT_DIRECTORY` - Not a directory
- `DTE_NOT_EMPTY` - Directory not empty
- `DTE_BAD_PATH` - Invalid path

## See Also
Full docs: skill/docs/ida_dirtree.rst

```

`skills/idapython/docs/ida_dirtree.rst`:

```rst
ida_dirtree
===========

.. py:module:: ida_dirtree

.. autoapi-nested-parse::

   Types involved in grouping of item into folders.

   The dirtree_t class is used to organize a directory tree on top of any collection that allows for accessing its elements by an id (inode).
   No requirements are imposed on the inodes apart from the forbidden value -1 (used to denote a bad inode).
   The dirspec_t class is used to specialize the dirtree. It can be used to introduce a directory structure for:
   * local types
   * structs
   * enums
   * functions
   * names
   * etc




Attributes
----------

.. autoapisummary::

   ida_dirtree.DTN_FULL_NAME
   ida_dirtree.DTN_DISPLAY_NAME
   ida_dirtree.DTE_OK
   ida_dirtree.DTE_ALREADY_EXISTS
   ida_dirtree.DTE_NOT_FOUND
   ida_dirtree.DTE_NOT_DIRECTORY
   ida_dirtree.DTE_NOT_EMPTY
   ida_dirtree.DTE_BAD_PATH
   ida_dirtree.DTE_CANT_RENAME
   ida_dirtree.DTE_OWN_CHILD
   ida_dirtree.DTE_MAX_DIR
   ida_dirtree.DTE_LAST
   ida_dirtree.DIRTREE_LOCAL_TYPES
   ida_dirtree.DIRTREE_FUNCS
   ida_dirtree.DIRTREE_NAMES
   ida_dirtree.DIRTREE_IMPORTS
   ida_dirtree.DIRTREE_IDAPLACE_BOOKMARKS
   ida_dirtree.DIRTREE_BPTS
   ida_dirtree.DIRTREE_LTYPES_BOOKMARKS
   ida_dirtree.DIRTREE_END


Classes
-------

.. autoapisummary::

   ida_dirtree.direntry_vec_t
   ida_dirtree.dirtree_cursor_vec_t
   ida_dirtree.direntry_t
   ida_dirtree.dirspec_t
   ida_dirtree.dirtree_cursor_t
   ida_dirtree.dirtree_selection_t
   ida_dirtree.dirtree_iterator_t
   ida_dirtree.dirtree_visitor_t
   ida_dirtree.dirtree_t


Functions
---------

.. autoapisummary::

   ida_dirtree.get_std_dirtree


Module Contents
---------------

.. py:class:: direntry_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> direntry_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> direntry_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: direntry_vec_t) -> None


   .. py:method:: extract() -> direntry_t *


   .. py:method:: inject(s: direntry_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< direntry_t >::const_iterator


   .. py:method:: end(*args) -> qvector< direntry_t >::const_iterator


   .. py:method:: insert(it: direntry_t, x: direntry_t) -> qvector< direntry_t >::iterator


   .. py:method:: erase(*args) -> qvector< direntry_t >::iterator


   .. py:method:: find(*args) -> qvector< direntry_t >::const_iterator


   .. py:method:: has(x: direntry_t) -> bool


   .. py:method:: add_unique(x: direntry_t) -> bool


   .. py:method:: append(x: direntry_t) -> None


   .. py:method:: extend(x: direntry_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: dirtree_cursor_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> dirtree_cursor_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> dirtree_cursor_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: dirtree_cursor_vec_t) -> None


   .. py:method:: extract() -> dirtree_cursor_t *


   .. py:method:: inject(s: dirtree_cursor_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< dirtree_cursor_t >::const_iterator


   .. py:method:: end(*args) -> qvector< dirtree_cursor_t >::const_iterator


   .. py:method:: insert(it: dirtree_cursor_t, x: dirtree_cursor_t) -> qvector< dirtree_cursor_t >::iterator


   .. py:method:: erase(*args) -> qvector< dirtree_cursor_t >::iterator


   .. py:method:: find(*args) -> qvector< dirtree_cursor_t >::const_iterator


   .. py:method:: has(x: dirtree_cursor_t) -> bool


   .. py:method:: add_unique(x: dirtree_cursor_t) -> bool


   .. py:method:: append(x: dirtree_cursor_t) -> None


   .. py:method:: extend(x: dirtree_cursor_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: direntry_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: idx
      :type:  int

      diridx_t or inode_t



   .. py:attribute:: isdir
      :type:  bool

      is 'idx' a diridx_t, or an inode_t



   .. py:attribute:: BADIDX


   .. py:attribute:: ROOTIDX


   .. py:method:: valid() -> bool


.. py:data:: DTN_FULL_NAME

   use long form of the entry name. That name is unique. 
             


.. py:data:: DTN_DISPLAY_NAME

   use short, displayable form of the entry name. for example, 'std::string' instead of 'std::basic_string<char, ...>'. Note that more than one "full name" can have the same displayable name. 
             


.. py:class:: dirspec_t(nm: str = None, f: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int


   .. py:attribute:: DSF_INODE_EA


   .. py:attribute:: DSF_PRIVRANGE


   .. py:attribute:: DSF_ORDERABLE


   .. py:attribute:: id
      :type:  str


   .. py:method:: get_name(inode: inode_t, name_flags: int = DTN_FULL_NAME) -> bool

      get the entry name. for example, the structure name 
              
      :param inode: inode number of the entry
      :param name_flags: how exactly the name should be retrieved. combination of bits for get_...name() methods bits
      :returns: false if the entry does not exist.



   .. py:method:: get_inode(dirpath: str, name: str) -> inode_t

      get the entry inode in the specified directory 
              
      :param dirpath: the absolute directory path with trailing slash
      :param name: the entry name in the directory
      :returns: the entry inode



   .. py:method:: get_attrs(inode: inode_t) -> str


   .. py:method:: rename_inode(inode: inode_t, newname: str) -> bool

      rename the entry 
              
      :returns: success



   .. py:method:: unlink_inode(inode: inode_t) -> None

      event: unlinked an inode 
              



   .. py:method:: is_orderable() -> bool


   .. py:attribute:: nodename


.. py:class:: dirtree_cursor_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: parent
      :type:  diridx_t

      the parent directory



   .. py:attribute:: rank
      :type:  size_t

      the index into the parent directory



   .. py:method:: valid() -> bool


   .. py:method:: is_root_cursor() -> bool


   .. py:method:: set_root_cursor() -> None


   .. py:method:: root_cursor() -> dirtree_cursor_t
      :staticmethod:



   .. py:method:: compare(r: dirtree_cursor_t) -> int


.. py:class:: dirtree_selection_t

   Bases: :py:obj:`dirtree_cursor_vec_t`


   .. py:attribute:: thisown


.. py:class:: dirtree_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: pattern
      :type:  str


   .. py:attribute:: cursor
      :type:  dirtree_cursor_t


.. py:data:: DTE_OK

   ok


.. py:data:: DTE_ALREADY_EXISTS

   item already exists


.. py:data:: DTE_NOT_FOUND

   item not found


.. py:data:: DTE_NOT_DIRECTORY

   item is not a directory


.. py:data:: DTE_NOT_EMPTY

   directory is not empty


.. py:data:: DTE_BAD_PATH

   invalid path


.. py:data:: DTE_CANT_RENAME

   failed to rename an item


.. py:data:: DTE_OWN_CHILD

   moving inside subdirectory of itself


.. py:data:: DTE_MAX_DIR

   maximum directory count achieved


.. py:data:: DTE_LAST

.. py:class:: dirtree_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit(c: dirtree_cursor_t, de: direntry_t) -> ssize_t

      Will be called for each entry in the dirtree_t If something other than 0 is returned, iteration will stop. 
              
      :param c: the current cursor
      :param de: the current entry
      :returns: 0 to keep iterating, or anything else to stop



.. py:class:: dirtree_t(ds: dirspec_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: errstr(err: dterr_t) -> str
      :staticmethod:


      Get textual representation of the error code.



   .. py:method:: is_orderable() -> bool

      Is dirtree orderable? 
              
      :returns: true if the dirtree is orderable



   .. py:method:: chdir(path: str) -> dterr_t

      Change current directory 
              
      :param path: new current directory
      :returns: dterr_t error code



   .. py:method:: getcwd() -> str

      Get current directory 
              
      :returns: the current working directory



   .. py:method:: get_abspath(*args) -> str

      This function has the following signatures:

          0. get_abspath(cursor: const dirtree_cursor_t &, name_flags: int=DTN_FULL_NAME) -> str
          1. get_abspath(relpath: str) -> str

      # 0: get_abspath(cursor: const dirtree_cursor_t &, name_flags: int=DTN_FULL_NAME) -> str

      Get absolute path pointed by the cursor 
              
      :returns: path; empty string if error

      # 1: get_abspath(relpath: str) -> str

      Construct an absolute path from the specified relative path. This function verifies the directory part of the specified path. The last component of the specified path is not verified. 
              
      :returns: path. empty path means wrong directory part of RELPATH



   .. py:method:: resolve_cursor(cursor: dirtree_cursor_t) -> direntry_t

      Resolve cursor 
              
      :param cursor: to analyze
      :returns: directory entry; if the cursor is bad, the resolved entry will be invalid.



   .. py:method:: resolve_path(path: str) -> direntry_t

      Resolve path 
              
      :param path: to analyze
      :returns: directory entry



   .. py:method:: isdir(*args) -> bool

      This function has the following signatures:

          0. isdir(path: str) -> bool
          1. isdir(de: const direntry_t &) -> bool

      # 0: isdir(path: str) -> bool

      Is a directory? 
              
      :returns: true if the specified path is a directory

      # 1: isdir(de: const direntry_t &) -> bool



   .. py:method:: isfile(*args) -> bool

      This function has the following signatures:

          0. isfile(path: str) -> bool
          1. isfile(de: const direntry_t &) -> bool

      # 0: isfile(path: str) -> bool

      Is a file? 
              
      :returns: true if the specified path is a file

      # 1: isfile(de: const direntry_t &) -> bool



   .. py:method:: get_entry_name(de: direntry_t, name_flags: int = DTN_FULL_NAME) -> str

      Get entry name 
              
      :param de: directory entry
      :param name_flags: how exactly the name should be retrieved. combination of bits for get_...name() methods bits
      :returns: name



   .. py:method:: is_dir_ordered(diridx: diridx_t) -> bool

      Is dir ordered? 
              
      :returns: true if the dirtree has natural ordering



   .. py:method:: set_natural_order(diridx: diridx_t, enable: bool) -> bool

      Enable/disable natural inode order in a directory. 
              
      :param diridx: directory index
      :param enable: action to do TRUE - enable ordering: re-order existing entries so that all subdirs are at the to beginning of the list, file entries are sorted and placed after the subdirs FALSE - disable ordering, no changes to existing entries
      :returns: SUCCESS



   .. py:method:: get_dir_size(diridx: diridx_t) -> ssize_t

      Get dir size 
              
      :param diridx: directory index
      :returns: number of entries under this directory; if error, return -1



   .. py:method:: get_entry_attrs(de: direntry_t) -> str

      Get entry attributes 
              
      :param de: directory entry
      :returns: name



   .. py:method:: findfirst(ff: dirtree_iterator_t, pattern: str) -> bool

      Start iterating over files in a directory 
              
      :param ff: directory iterator. it will be initialized by the function
      :param pattern: pattern to search for
      :returns: success



   .. py:method:: findnext(ff: dirtree_iterator_t) -> bool

      Continue iterating over files in a directory 
              
      :param ff: directory iterator
      :returns: success



   .. py:method:: mkdir(path: str) -> dterr_t

      Create a directory. 
              
      :param path: directory to create
      :returns: dterr_t error code



   .. py:method:: rmdir(path: str) -> dterr_t

      Remove a directory. 
              
      :param path: directory to delete
      :returns: dterr_t error code



   .. py:method:: link(*args) -> dterr_t

      This function has the following signatures:

          0. link(path: str) -> dterr_t
          1. link(inode: inode_t) -> dterr_t

      # 0: link(path: str) -> dterr_t

      Add a file item into a directory. 
              
      :returns: dterr_t error code

      # 1: link(inode: inode_t) -> dterr_t

      Add an inode into the current directory 
              
      :returns: dterr_t error code



   .. py:method:: unlink(*args) -> dterr_t

      This function has the following signatures:

          0. unlink(path: str) -> dterr_t
          1. unlink(inode: inode_t) -> dterr_t

      # 0: unlink(path: str) -> dterr_t

      Remove a file item from a directory. 
              
      :returns: dterr_t error code

      # 1: unlink(inode: inode_t) -> dterr_t

      Remove an inode from the current directory 
              
      :returns: dterr_t error code



   .. py:method:: rename(_from: str, to: str) -> dterr_t

      Rename a directory entry. 
              
      :param to: destination path
      :returns: dterr_t error code



   .. py:method:: get_rank(diridx: diridx_t, de: direntry_t) -> ssize_t

      Get ordering rank of an item. 
              
      :param diridx: index of the parent directory
      :param de: directory entry
      :returns: number in a range of [0..n) where n is the number of entries in the parent directory. -1 if error



   .. py:method:: change_rank(path: str, rank_delta: ssize_t) -> dterr_t

      Change ordering rank of an item. 
              
      :param path: path to the item
      :param rank_delta: the amount of the change. positive numbers mean to move down in the list; negative numbers mean to move up.
      :returns: dterr_t error code



   .. py:method:: get_parent_cursor(cursor: dirtree_cursor_t) -> dirtree_cursor_t

      Get parent cursor. 
              
      :param cursor: a valid ditree cursor
      :returns: cursor's parent



   .. py:method:: load() -> bool

      Load the tree structure from the netnode. If dirspec_t::id is empty, the operation will be considered a success. In addition, calling load() more than once will not do anything, and will be considered a success. 
              
      :returns: success



   .. py:method:: save() -> bool

      Save the tree structure to the netnode. 
              
      :returns: success



   .. py:method:: get_id() -> str

      netnode name



   .. py:method:: set_id(nm: str) -> None


   .. py:method:: notify_dirtree(added: bool, inode: inode_t) -> None

      Notify dirtree about a change of an inode. 
              
      :param added: are we adding or deleting an inode?
      :param inode: inode in question



   .. py:method:: traverse(v: dirtree_visitor_t) -> ssize_t

      Traverse dirtree, and be notified at each entry If the the visitor returns anything other than 0, iteration will stop, and that value returned. The tree is traversed using a depth-first algorithm. It is forbidden to modify the dirtree_t during traversal; doing so will result in undefined behavior. 
              
      :param v: the callback
      :returns: 0, or whatever the visitor returned



   .. py:method:: find_entry(de: direntry_t) -> dirtree_cursor_t

      Find the cursor corresponding to an entry of a directory 
              
      :param de: directory entry
      :returns: cursor corresponding to the directory entry



   .. py:attribute:: get_nodename


   .. py:attribute:: set_nodename


.. py:data:: DIRTREE_LOCAL_TYPES

.. py:data:: DIRTREE_FUNCS

.. py:data:: DIRTREE_NAMES

.. py:data:: DIRTREE_IMPORTS

.. py:data:: DIRTREE_IDAPLACE_BOOKMARKS

.. py:data:: DIRTREE_BPTS

.. py:data:: DIRTREE_LTYPES_BOOKMARKS

.. py:data:: DIRTREE_END

.. py:function:: get_std_dirtree(id: dirtree_id_t) -> dirtree_t *


```

`skills/idapython/docs/ida_diskio.md`:

```md
# ida_diskio

File I/O and IDA directory/resource management.

## IDA Directories

### Path Queries
- `idadir(subdir)` - Get IDA install directory or subdirectory
- `get_user_idadir()` - Get user data directory ($IDAUSR or default)
- `get_ida_subdirs(subdir, flags)` - List all search paths for resource
- `getsysfile(filename, subdir)` - Search for file in IDA paths

### Subdirectory Constants
- `CFG_SUBDIR` - Configuration files
- `IDC_SUBDIR` - IDC scripts
- `IDS_SUBDIR` - IDS files (function signatures)
- `IDP_SUBDIR` - Processor modules
- `LDR_SUBDIR` - Loader modules
- `SIG_SUBDIR` - FLIRT signatures
- `TIL_SUBDIR` - Type libraries
- `PLG_SUBDIR` - Plugins
- `THM_SUBDIR` - Themes

### Search Flags
- `IDA_SUBDIR_IDP` - Append processor name
- `IDA_SUBDIR_IDADIR_FIRST` - Search $IDADIR before $IDAUSR
- `IDA_SUBDIR_ONLY_EXISTING` - Only return existing directories

## File Operations

### Standard I/O Wrappers (use instead of C stdio)
- `fopenRT(file)` / `fopenWT(file)` - Open text read/write
- `fopenRB(file)` / `fopenWB(file)` - Open binary read/write
- `fopenM(file)` - Open for modification
- `fopenA(file)` - Open for append

## Linput (IDA Binary Input)

### Creation
- `open_linput(file, remote)` - Open file as linput
- `create_memory_linput(start, size)` - Create from IDB memory range
- `create_bytearray_linput(s)` - Create from Python bytes
- `create_generic_linput(gl)` - Create from custom reader

### Operations
- `qlgetz(li, fpos)` - Read null-terminated string at position
- `get_linput_type(li)` - Get linput type (LINPUT_LOCAL/RFILE/PROCMEM/GENERIC)
- `close_linput(li)` - Close linput

### Linput Types
- `LINPUT_LOCAL` - Local file
- `LINPUT_RFILE` - Remote file
- `LINPUT_PROCMEM` - Process memory
- `LINPUT_GENERIC` - Custom reader

### generic_linput_t
Base class for custom binary readers.

- `filesize` - Total size
- `blocksize` - Read block size
- `read(off, buffer, nbytes)` - Read bytes at offset

## File Enumeration
- `enumerate_files(path, fname, callback)` - Enumerate files matching pattern

## Platform Folders
- `get_special_folder(csidl)` - Get OS-specific folders
  - `CSIDL_APPDATA` - Application data
  - `CSIDL_LOCAL_APPDATA` - Local app data
  - `CSIDL_PROGRAM_FILES` - Program files directory

## See Also
Full docs: skill/docs/ida_diskio.rst

```

`skills/idapython/docs/ida_diskio.rst`:

```rst
ida_diskio
==========

.. py:module:: ida_diskio

.. autoapi-nested-parse::

   File I/O functions for IDA.

   You should not use standard C file I/O functions in modules. Use functions from this header, pro.h and fpro.h instead.
   This file also declares a call_system() function. 
       



Attributes
----------

.. autoapisummary::

   ida_diskio.VAULT_CACHE_SUBDIR
   ida_diskio.VAULT_CACHE_FNAME
   ida_diskio.CFG_SUBDIR
   ida_diskio.IDC_SUBDIR
   ida_diskio.IDS_SUBDIR
   ida_diskio.IDP_SUBDIR
   ida_diskio.LDR_SUBDIR
   ida_diskio.SIG_SUBDIR
   ida_diskio.TIL_SUBDIR
   ida_diskio.PLG_SUBDIR
   ida_diskio.THM_SUBDIR
   ida_diskio.IDA_SUBDIR_IDP
   ida_diskio.IDA_SUBDIR_IDADIR_FIRST
   ida_diskio.IDA_SUBDIR_ONLY_EXISTING
   ida_diskio.CSIDL_APPDATA
   ida_diskio.CSIDL_LOCAL_APPDATA
   ida_diskio.CSIDL_PROGRAM_FILES
   ida_diskio.CSIDL_PROGRAM_FILES_COMMON
   ida_diskio.CSIDL_PROGRAM_FILESX86
   ida_diskio.LINPUT_NONE
   ida_diskio.LINPUT_LOCAL
   ida_diskio.LINPUT_RFILE
   ida_diskio.LINPUT_PROCMEM
   ida_diskio.LINPUT_GENERIC
   ida_diskio.LOC_CLOSE
   ida_diskio.LOC_UNMAKE
   ida_diskio.LOC_KEEP


Classes
-------

.. autoapisummary::

   ida_diskio.file_enumerator_t
   ida_diskio.ioports_fallback_t
   ida_diskio.choose_ioport_parser_t
   ida_diskio.generic_linput_t


Functions
---------

.. autoapisummary::

   ida_diskio.idadir
   ida_diskio.getsysfile
   ida_diskio.get_user_idadir
   ida_diskio.get_ida_subdirs
   ida_diskio.get_special_folder
   ida_diskio.fopenWT
   ida_diskio.fopenWB
   ida_diskio.fopenRT
   ida_diskio.fopenRB
   ida_diskio.fopenM
   ida_diskio.fopenA
   ida_diskio.read_ioports
   ida_diskio.choose_ioport_device2
   ida_diskio.qlgetz
   ida_diskio.open_linput
   ida_diskio.create_generic_linput
   ida_diskio.create_memory_linput
   ida_diskio.get_linput_type
   ida_diskio.enumerate_files
   ida_diskio.create_bytearray_linput
   ida_diskio.close_linput


Module Contents
---------------

.. py:data:: VAULT_CACHE_SUBDIR

   subdir name for cached deltas and old files


.. py:data:: VAULT_CACHE_FNAME

   to store file caches


.. py:function:: idadir(subdir: str) -> str

   Get IDA directory (if subdir==nullptr) or the specified subdirectory (see IDA subdirectories) 
           


.. py:function:: getsysfile(filename: str, subdir: str) -> str

   Search for IDA system file. This function searches for a file in:
   0. each directory specified by IDAUSR%
   1. ida directory [+ subdir]


   and returns the first match. 
           
   :param filename: name of file to search
   :param subdir: if specified, the file is looked for in the specified subdirectory of the ida directory first (see IDA subdirectories)
   :returns: nullptr if not found, otherwise a pointer to full file name.


.. py:data:: CFG_SUBDIR

.. py:data:: IDC_SUBDIR

.. py:data:: IDS_SUBDIR

.. py:data:: IDP_SUBDIR

.. py:data:: LDR_SUBDIR

.. py:data:: SIG_SUBDIR

.. py:data:: TIL_SUBDIR

.. py:data:: PLG_SUBDIR

.. py:data:: THM_SUBDIR

.. py:function:: get_user_idadir() -> str

   Get user ida related directory. 
   if $IDAUSR is defined:
      - the first element in $IDAUSR
   else
      - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)


      


.. py:function:: get_ida_subdirs(subdir: str, flags: int = 0) -> qstrvec_t *

   Get list of directories in which to find a specific IDA resource (see IDA subdirectories). The order of the resulting list is as follows: 
        [$IDAUSR/subdir (0..N entries)]
        $IDADIR/subdir


           
   :param subdir: name of the resource to list (can be nullptr)
   :param flags: Subdirectory modification flags bits
   :returns: number of directories appended to 'dirs'


.. py:data:: IDA_SUBDIR_IDP

   append the processor name as a subdirectory


.. py:data:: IDA_SUBDIR_IDADIR_FIRST

   $IDADIR/subdir will be first, not last


.. py:data:: IDA_SUBDIR_ONLY_EXISTING

   only existing directories will be present


.. py:function:: get_special_folder(csidl: int) -> str

   Get a folder location by CSIDL (see Common CSIDLs). Path should be of at least MAX_PATH size 
           


.. py:data:: CSIDL_APPDATA

.. py:data:: CSIDL_LOCAL_APPDATA

.. py:data:: CSIDL_PROGRAM_FILES

.. py:data:: CSIDL_PROGRAM_FILES_COMMON

.. py:data:: CSIDL_PROGRAM_FILESX86

.. py:class:: file_enumerator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit_file(file: str) -> int


.. py:function:: fopenWT(file: str) -> FILE *

.. py:function:: fopenWB(file: str) -> FILE *

.. py:function:: fopenRT(file: str) -> FILE *

.. py:function:: fopenRB(file: str) -> FILE *

.. py:function:: fopenM(file: str) -> FILE *

.. py:function:: fopenA(file: str) -> FILE *

.. py:class:: ioports_fallback_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: handle(ports: ioports_t const &, line: str) -> bool

      :param ports: i/o port definitions
      :param line: input line to parse
      :returns: success or fills ERRBUF with an error message



.. py:function:: read_ioports(ports: ioports_t *, device: str, file: str, callback: ioports_fallback_t = None) -> ssize_t

.. py:class:: choose_ioport_parser_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: parse(param: str, line: str) -> bool

      :returns: true: and fill PARAM with a displayed string
      :returns: false: and empty PARAM to skip the current device
      :returns: false: and fill PARAM with an error message



.. py:function:: choose_ioport_device2(_device: str, file: str, parse_params: choose_ioport_parser_t) -> bool

.. py:data:: LINPUT_NONE

.. py:data:: LINPUT_LOCAL

.. py:data:: LINPUT_RFILE

.. py:data:: LINPUT_PROCMEM

.. py:data:: LINPUT_GENERIC

.. py:function:: qlgetz(li: linput_t *, fpos: int64) -> str

.. py:function:: open_linput(file: str, remote: bool) -> linput_t *

.. py:class:: generic_linput_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: filesize
      :type:  uint64


   .. py:attribute:: blocksize
      :type:  int


   .. py:method:: read(off: qoff64_t, buffer: void *, nbytes: size_t) -> ssize_t


.. py:function:: create_generic_linput(gl: generic_linput_t) -> linput_t *

.. py:function:: create_memory_linput(start: ida_idaapi.ea_t, size: asize_t) -> linput_t *

.. py:function:: get_linput_type(li: linput_t *) -> linput_type_t

.. py:data:: LOC_CLOSE

   close the inner linput


.. py:data:: LOC_UNMAKE

   unmake the inner linput


.. py:data:: LOC_KEEP

   do nothing


.. py:function:: enumerate_files(path, fname, callback)

   Enumerate files in the specified directory while the callback returns 0.

   :param path: directory to enumerate files in
   :param fname: mask of file names to enumerate
   :param callback: a callable object that takes the filename as
                    its first argument and it returns 0 to continue
                    enumeration or non-zero to stop enumeration.
   :returns: tuple(code, fname) : If the callback returns non-zero, or None in case of script errors


.. py:function:: create_bytearray_linput(s: str) -> linput_t *

.. py:function:: close_linput(li: linput_t *) -> None


```

`skills/idapython/docs/ida_entry.md`:

```md
# ida_entry

Entry point and exported function management - addresses, names, and ordinal numbers.

## Key Functions

- `get_entry_qty() -> int` - Get number of entry points
- `add_entry(ord, ea, name, makecode, flags=0) -> bool` - Add entry point with ordinal number
- `get_entry(ord) -> ea_t` - Get address by ordinal number
- `get_entry_ordinal(idx) -> int` - Get ordinal by index (0..get_entry_qty()-1)
- `get_entry_name(ord) -> str` - Get entry point name by ordinal
- `rename_entry(ord, name, flags=0) -> bool` - Rename entry point
- `set_entry_forwarder(ord, name, flags=0) -> bool` - Set forwarder name (for DLL exports)
- `get_entry_forwarder(ord) -> str` - Get forwarder name

## Flags (AEF_*)

- `AEF_UTF8` - Name is UTF-8 encoded (default)
- `AEF_IDBENC` - Name is IDB encoded (implies AEF_NODUMMY)
- `AEF_NODUMMY` - Prepend '_' if name begins with dummy suffix
- `AEF_WEAK` - Make name weak
- `AEF_NOFORCE` - Append to comment if name exists (unless old name is weak)

## See Also
Full docs: skill/docs/ida_entry.rst

```

`skills/idapython/docs/ida_entry.rst`:

```rst
ida_entry
=========

.. py:module:: ida_entry

.. autoapi-nested-parse::

   Functions that deal with entry points.

   Exported functions are considered as entry points as well.
   IDA maintains list of entry points to the program. Each entry point:
      * has an address
      * has a name
      * may have an ordinal number 

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For entry point management, see :mod:`ida_domain.entries`.



Attributes
----------

.. autoapisummary::

   ida_entry.AEF_UTF8
   ida_entry.AEF_IDBENC
   ida_entry.AEF_NODUMMY
   ida_entry.AEF_WEAK
   ida_entry.AEF_NOFORCE


Functions
---------

.. autoapisummary::

   ida_entry.get_entry_qty
   ida_entry.add_entry
   ida_entry.get_entry_ordinal
   ida_entry.get_entry
   ida_entry.get_entry_name
   ida_entry.rename_entry
   ida_entry.set_entry_forwarder
   ida_entry.get_entry_forwarder


Module Contents
---------------

.. py:function:: get_entry_qty() -> size_t

   Get number of entry points.


.. py:data:: AEF_UTF8

   the name is given in UTF-8 (default)


.. py:data:: AEF_IDBENC

   the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly. Specifying AEF_IDBENC also implies AEF_NODUMMY 
           


.. py:data:: AEF_NODUMMY

   automatically prepend the name with '_' if it begins with a dummy suffix. See also AEF_IDBENC 
           


.. py:data:: AEF_WEAK

   make name weak


.. py:data:: AEF_NOFORCE

   if the specified address already has a name, the new name will be appended to the regular comment, except for the case when the old name is weak and the new one is not. 
           


.. py:function:: add_entry(ord: int, ea: ida_idaapi.ea_t, name: str, makecode: bool, flags: int = 0) -> bool

   Add an entry point to the list of entry points. 
           
   :param ord: ordinal number if ordinal number is equal to 'ea' then ordinal is not used
   :param ea: linear address
   :param name: name of entry point. If the specified location already has a name, the old name will be appended to the regular comment.
   :param makecode: should the kernel convert bytes at the entry point to instruction(s)
   :param flags: See AEF_*
   :returns: success (currently always true)


.. py:function:: get_entry_ordinal(idx: size_t) -> int

   Get ordinal number of an entry point. 
           
   :param idx: internal number of entry point. Should be in the range 0..get_entry_qty()-1
   :returns: ordinal number or 0.


.. py:function:: get_entry(ord: int) -> ida_idaapi.ea_t

   Get entry point address by its ordinal 
           
   :param ord: ordinal number of entry point
   :returns: address or BADADDR


.. py:function:: get_entry_name(ord: int) -> str

   Get name of the entry point by its ordinal. 
           
   :param ord: ordinal number of entry point
   :returns: size of entry name or -1


.. py:function:: rename_entry(ord: int, name: str, flags: int = 0) -> bool

   Rename entry point. 
           
   :param ord: ordinal number of the entry point
   :param name: name of entry point. If the specified location already has a name, the old name will be appended to a repeatable comment.
   :param flags: See AEF_*
   :returns: success


.. py:function:: set_entry_forwarder(ord: int, name: str, flags: int = 0) -> bool

   Set forwarder name for ordinal. 
           
   :param ord: ordinal number of the entry point
   :param name: forwarder name for entry point.
   :param flags: See AEF_*
   :returns: success


.. py:function:: get_entry_forwarder(ord: int) -> str

   Get forwarder name for the entry point by its ordinal. 
           
   :param ord: ordinal number of entry point
   :returns: size of entry forwarder name or -1



```

`skills/idapython/docs/ida_expr.md`:

```md
# ida_expr

IDC language interpreter - compile/execute IDC scripts, evaluate expressions, manipulate IDC values and objects.

## Key Functions

### Expression Evaluation
- `eval_expr(rv, where, line) -> str` - Compile and evaluate expression at address context
- `eval_idc_expr(rv, where, line) -> str` - Same as eval_expr but forces IDC interpreter

### Script Execution
- `compile_idc_file(line) -> str` - Compile IDC file
- `compile_idc_text(line) -> str` - Compile IDC text
- `compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> str` - Compile text into named function
- `exec_idc_script(result, path, func, args, argsnum) -> str` - Compile and execute function from file
- `exec_system_script(file, complain_if_no_file=True) -> bool` - Compile and execute "main" from system file

### IDC Value Manipulation
- `idcv_long(v) -> error_t` - Convert to 32/64-bit number
- `idcv_int64(v) -> error_t` - Convert to 64-bit number
- `idcv_num(v) -> error_t` - Convert to long ("true"→1, "false"→0)
- `idcv_string(v) -> error_t` - Convert to string
- `idcv_float(v) -> error_t` - Convert to float
- `idcv_object(v, icls=None) -> error_t` - Create IDC object
- `move_idcv(dst, src) -> error_t` - Move value (efficient, no copy)
- `copy_idcv(dst, src) -> error_t` - Shallow copy (objects copied by reference)
- `deep_copy_idcv(dst, src) -> error_t` - Deep copy objects
- `free_idcv(v)` - Free VT_STR/VT_OBJ storage
- `swap_idcvs(v1, v2)` - Swap two variables

### Object/Attribute Access
- `get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t` - Get object attribute
- `set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t` - Set object attribute
- `del_idcv_attr(obj, attr) -> error_t` - Delete attribute
- `first_idcv_attr(obj) -> str`, `last_idcv_attr(obj) -> str` - Iterate attributes
- `get_idcv_slice(res, v, i1, i2, flags=0) -> error_t` - Get slice of string/object
- `set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t` - Set slice

### Class/Variable Management
- `add_idc_class(name, super=None) -> idc_class_t*` - Create IDC class
- `find_idc_class(name) -> idc_class_t*` - Find existing class
- `add_idc_gvar(name) -> idc_value_t*` - Add global variable
- `find_idc_gvar(name) -> idc_value_t*` - Find global variable
- `find_idc_func(prefix, n=0) -> str` - Find IDC function by prefix

## idc_value_t Class

Core IDC value container with variant type support.

### Attributes
- `vtype: char` - Type (VT_LONG, VT_FLOAT, VT_STR, VT_OBJ, VT_FUNC, VT_PVOID, VT_INT64, VT_REF)
- `num: int` - Integer value (VT_LONG)
- `i64: int64` - 64-bit integer (VT_INT64)
- `e: fpvalue_t` - Float value (VT_FLOAT)
- `obj: idc_object_t*` - Object reference (VT_OBJ)

### Methods
- `clear()` - Free storage
- `qstr() -> str`, `c_str() -> str` - Get string value
- `set_string(...)`, `set_long(v)`, `set_int64(v)`, `set_float(f)` - Set typed values
- `is_zero() -> bool`, `is_integral() -> bool`, `is_convertible() -> bool` - Type checks

## Value Types (VT_*)
- `VT_LONG` - Integer
- `VT_INT64` - 64-bit integer
- `VT_FLOAT` - Floating point
- `VT_STR` - String
- `VT_OBJ` - Object
- `VT_FUNC` - Function
- `VT_PVOID` - void pointer
- `VT_REF` - Reference

## Compilation Flags (CPL_*)
- `CPL_DEL_MACROS` - Delete macros after compilation
- `CPL_USE_LABELS` - Allow program labels
- `CPL_ONLY_SAFE` - Only thread-safe functions

## Function Flags (EXTFUN_*)
- `EXTFUN_BASE` - Requires open database
- `EXTFUN_NORET` - Does not return
- `EXTFUN_SAFE` - Thread-safe, callable from any thread

## See Also
Full docs: skill/docs/ida_expr.rst

```

`skills/idapython/docs/ida_expr.rst`:

```rst
ida_expr
========

.. py:module:: ida_expr

.. autoapi-nested-parse::

   Functions that deal with C-like expressions and built-in IDC language.

   Functions marked THREAD_SAFE may be called from any thread. No simultaneous calls should be made for the same variable. We protect only global structures, individual variables must be protected manually. 
       



Attributes
----------

.. autoapisummary::

   ida_expr.IDC_LANG_EXT
   ida_expr.VARSLICE_SINGLE
   ida_expr.VREF_LOOP
   ida_expr.VREF_ONCE
   ida_expr.VREF_COPY
   ida_expr.VT_LONG
   ida_expr.VT_FLOAT
   ida_expr.VT_WILD
   ida_expr.VT_OBJ
   ida_expr.VT_FUNC
   ida_expr.VT_STR
   ida_expr.VT_PVOID
   ida_expr.VT_INT64
   ida_expr.VT_REF
   ida_expr.eExecThrow
   ida_expr.HF_DEFAULT
   ida_expr.HF_KEYWORD1
   ida_expr.HF_KEYWORD2
   ida_expr.HF_KEYWORD3
   ida_expr.HF_STRING
   ida_expr.HF_COMMENT
   ida_expr.HF_PREPROC
   ida_expr.HF_NUMBER
   ida_expr.HF_USER1
   ida_expr.HF_USER2
   ida_expr.HF_USER3
   ida_expr.HF_USER4
   ida_expr.HF_MAX
   ida_expr.CPL_DEL_MACROS
   ida_expr.CPL_USE_LABELS
   ida_expr.CPL_ONLY_SAFE
   ida_expr.EXTFUN_BASE
   ida_expr.EXTFUN_NORET
   ida_expr.EXTFUN_SAFE


Classes
-------

.. autoapisummary::

   ida_expr.idc_value_t
   ida_expr.idc_global_t
   ida_expr.highlighter_cbs_t
   ida_expr.idc_values_t


Functions
---------

.. autoapisummary::

   ida_expr.compile_idc_file
   ida_expr.compile_idc_text
   ida_expr.py_get_call_idc_func
   ida_expr.pyw_register_idc_func
   ida_expr.pyw_unregister_idc_func
   ida_expr.pyw_convert_defvals
   ida_expr.py_add_idc_func
   ida_expr.eval_expr
   ida_expr.eval_idc_expr
   ida_expr.idcv_long
   ida_expr.idcv_int64
   ida_expr.idcv_num
   ida_expr.idcv_string
   ida_expr.idcv_float
   ida_expr.idcv_object
   ida_expr.move_idcv
   ida_expr.copy_idcv
   ida_expr.deep_copy_idcv
   ida_expr.free_idcv
   ida_expr.swap_idcvs
   ida_expr.get_idcv_class_name
   ida_expr.get_idcv_attr
   ida_expr.set_idcv_attr
   ida_expr.del_idcv_attr
   ida_expr.first_idcv_attr
   ida_expr.last_idcv_attr
   ida_expr.next_idcv_attr
   ida_expr.prev_idcv_attr
   ida_expr.print_idcv
   ida_expr.get_idcv_slice
   ida_expr.set_idcv_slice
   ida_expr.add_idc_class
   ida_expr.find_idc_class
   ida_expr.deref_idcv
   ida_expr.create_idcv_ref
   ida_expr.add_idc_gvar
   ida_expr.find_idc_gvar
   ida_expr.find_idc_func
   ida_expr.set_header_path
   ida_expr.get_idc_filename
   ida_expr.exec_system_script
   ida_expr.compile_idc_snippet
   ida_expr.exec_idc_script
   ida_expr.throw_idc_exception
   ida_expr.del_idc_func
   ida_expr.add_idc_func


Module Contents
---------------

.. py:function:: compile_idc_file(nonnul_line: str) -> str

.. py:function:: compile_idc_text(nonnul_line: str) -> str

.. py:function:: py_get_call_idc_func() -> size_t

.. py:function:: pyw_register_idc_func(name: str, args: str, py_fp: PyObject *) -> size_t

.. py:function:: pyw_unregister_idc_func(ctxptr: size_t) -> bool

.. py:function:: pyw_convert_defvals(out: idc_values_t, py_seq: PyObject *) -> bool

.. py:function:: py_add_idc_func(name: str, fp_ptr: size_t, args: str, defvals: idc_values_t, flags: int) -> bool

.. py:function:: eval_expr(rv: idc_value_t, where: ida_idaapi.ea_t, line: str) -> str

   Compile and calculate an expression. 
           
   :param rv: pointer to the result
   :param where: the current linear address in the addressing space of the program being disassembled. If will be used to resolve names of local variables etc. if not applicable, then should be BADADDR.
   :param line: the expression to evaluate
   :returns: true: ok
   :returns: false: error, see errbuf


.. py:function:: eval_idc_expr(rv: idc_value_t, where: ida_idaapi.ea_t, line: str) -> str

   Same as eval_expr(), but will always use the IDC interpreter regardless of the currently installed extlang. 
           


.. py:data:: IDC_LANG_EXT

   IDC script extension.


.. py:function:: idcv_long(v: idc_value_t) -> error_t

   Convert IDC variable to a long (32/64bit) number. 
           
   :returns: v = 0 if impossible to convert to long


.. py:function:: idcv_int64(v: idc_value_t) -> error_t

   Convert IDC variable to a 64bit number. 
           
   :returns: v = 0 if impossible to convert to int64


.. py:function:: idcv_num(v: idc_value_t) -> error_t

   Convert IDC variable to a long number. 
           
   :returns: * v = 0 if IDC variable = "false" string
   * v = 1 if IDC variable = "true" string
   * v = number if IDC variable is number or string containing a number
   * eTypeConflict if IDC variable = empty string


.. py:function:: idcv_string(v: idc_value_t) -> error_t

   Convert IDC variable to a text string.


.. py:function:: idcv_float(v: idc_value_t) -> error_t

   Convert IDC variable to a floating point.


.. py:function:: idcv_object(v: idc_value_t, icls: idc_class_t const * = None) -> error_t

   Create an IDC object. The original value of 'v' is discarded (freed). 
           
   :param v: variable to hold the object. any previous value will be cleaned
   :param icls: ptr to the desired class. nullptr means "object" class this ptr must be returned by add_idc_class() or find_idc_class()
   :returns: always eOk


.. py:function:: move_idcv(dst: idc_value_t, src: idc_value_t) -> error_t

   Move 'src' to 'dst'. This function is more effective than copy_idcv since it never copies big amounts of data. 
           


.. py:function:: copy_idcv(dst: idc_value_t, src: idc_value_t) -> error_t

   Copy 'src' to 'dst'. For idc objects only a reference is copied. 
           


.. py:function:: deep_copy_idcv(dst: idc_value_t, src: idc_value_t) -> error_t

   Deep copy an IDC object. This function performs deep copy of idc objects. If 'src' is not an object, copy_idcv() will be called 
           


.. py:function:: free_idcv(v: idc_value_t) -> None

   Free storage used by VT_STR/VT_OBJ IDC variables. After this call the variable has a numeric value 0 
           


.. py:function:: swap_idcvs(v1: idc_value_t, v2: idc_value_t) -> None

   Swap 2 variables.


.. py:function:: get_idcv_class_name(obj: idc_value_t) -> str

   Retrieves the IDC object class name. 
           
   :param obj: class instance variable
   :returns: error code, eOk on success


.. py:function:: get_idcv_attr(res: idc_value_t, obj: idc_value_t, attr: str, may_use_getattr: bool = False) -> error_t

   Get an object attribute. 
           
   :param res: buffer for the attribute value
   :param obj: variable that holds an object reference. if obj is nullptr it searches global variables, then user functions
   :param attr: attribute name
   :param may_use_getattr: may call getattr functions to calculate the attribute if it does not exist
   :returns: error code, eOk on success


.. py:function:: set_idcv_attr(obj: idc_value_t, attr: str, value: idc_value_t, may_use_setattr: bool = False) -> error_t

   Set an object attribute. 
           
   :param obj: variable that holds an object reference. if obj is nullptr then it tries to modify a global variable with the attribute name
   :param attr: attribute name
   :param value: new attribute value
   :param may_use_setattr: may call setattr functions for the class
   :returns: error code, eOk on success


.. py:function:: del_idcv_attr(obj: idc_value_t, attr: str) -> error_t

   Delete an object attribute. 
           
   :param obj: variable that holds an object reference
   :param attr: attribute name
   :returns: error code, eOk on success


.. py:function:: first_idcv_attr(obj: idc_value_t) -> str

.. py:function:: last_idcv_attr(obj: idc_value_t) -> str

.. py:function:: next_idcv_attr(obj: idc_value_t, attr: str) -> str

.. py:function:: prev_idcv_attr(obj: idc_value_t, attr: str) -> str

.. py:function:: print_idcv(v: idc_value_t, name: str = None, indent: int = 0) -> str

   Get text representation of idc_value_t.


.. py:function:: get_idcv_slice(res: idc_value_t, v: idc_value_t, i1: int, i2: int, flags: int = 0) -> error_t

   Get slice. 
           
   :param res: output variable that will contain the slice
   :param v: input variable (string or object)
   :param i1: slice start index
   :param i2: slice end index (excluded)
   :param flags: IDC variable slice flags or 0
   :returns: eOk if success


.. py:data:: VARSLICE_SINGLE

   return single index (i2 is ignored)


.. py:function:: set_idcv_slice(v: idc_value_t, i1: int, i2: int, _in: idc_value_t, flags: int = 0) -> error_t

   Set slice. 
           
   :param v: variable to modify (string or object)
   :param i1: slice start index
   :param i2: slice end index (excluded)
   :param flags: IDC variable slice flags or 0
   :returns: eOk on success


.. py:function:: add_idc_class(name: str, super: idc_class_t const * = None) -> idc_class_t *

   Create a new IDC class. 
           
   :param name: name of the new class
   :param super: the base class for the new class. if the new class is not based on any other class, pass nullptr
   :returns: pointer to the created class. If such a class already exists, a pointer to it will be returned. Pointers to other existing classes may be invalidated by this call.


.. py:function:: find_idc_class(name: str) -> idc_class_t *

   Find an existing IDC class by its name. 
           
   :param name: name of the class
   :returns: pointer to the class or nullptr. The returned pointer is valid until a new call to add_idc_class()


.. py:function:: deref_idcv(v: idc_value_t, vref_flags: int) -> idc_value_t *

   Dereference a VT_REF variable. 
           
   :param v: variable to dereference
   :param vref_flags: Dereference IDC variable flags
   :returns: pointer to the dereference result or nullptr. If returns nullptr, qerrno is set to eExecBadRef "Illegal variable reference"


.. py:data:: VREF_LOOP

   dereference until we get a non VT_REF


.. py:data:: VREF_ONCE

   dereference only once, do not loop


.. py:data:: VREF_COPY

   copy the result to the input var (v)


.. py:function:: create_idcv_ref(ref: idc_value_t, v: idc_value_t) -> bool

   Create a variable reference. Currently only references to global variables can be created. 
           
   :param ref: ptr to the result
   :param v: variable to reference
   :returns: success


.. py:function:: add_idc_gvar(name: str) -> idc_value_t *

   Add global IDC variable. 
           
   :param name: name of the global variable
   :returns: pointer to the created variable or existing variable. NB: the returned pointer is valid until a new global var is added.


.. py:function:: find_idc_gvar(name: str) -> idc_value_t *

   Find an existing global IDC variable by its name. 
           
   :param name: name of the global variable
   :returns: pointer to the variable or nullptr. NB: the returned pointer is valid until a new global var is added. FIXME: it is difficult to use this function in a thread safe manner


.. py:class:: idc_value_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: vtype
      :type:  char

      IDC value types



   .. py:attribute:: num
      :type:  int

      VT_LONG



   .. py:attribute:: e
      :type:  fpvalue_t

      VT_FLOAT



   .. py:attribute:: obj
      :type:  idc_object_t *


   .. py:attribute:: funcidx
      :type:  int

      VT_FUNC



   .. py:attribute:: pvoid
      :type:  void *

      VT_PVOID



   .. py:attribute:: i64
      :type:  int64

      VT_INT64



   .. py:attribute:: reserve
      :type:  uchar [sizeof(qstring)]

      VT_STR.



   .. py:method:: clear() -> None

      See free_idcv()



   .. py:method:: qstr() -> str

      VT_STR



   .. py:method:: c_str() -> str

      VT_STR



   .. py:method:: u_str() -> uchar const *

      VT_STR



   .. py:method:: swap(v: idc_value_t) -> None

      Set this = r and v = this.



   .. py:method:: is_zero() -> bool

      Does value represent the integer 0?



   .. py:method:: is_integral() -> bool

      Does value represent a whole number? 
              



   .. py:method:: is_convertible() -> bool

      Convertible types are VT_LONG, VT_FLOAT, VT_INT64, and VT_STR.



   .. py:method:: create_empty_string() -> None


   .. py:method:: set_string(*args) -> None


   .. py:method:: set_long(v: int) -> None


   .. py:method:: set_pvoid(p: void *) -> None


   .. py:method:: set_int64(v: int64) -> None


   .. py:method:: set_float(f: fpvalue_t const &) -> None


   .. py:attribute:: str


.. py:data:: VT_LONG

   Integer (see idc_value_t::num)


.. py:data:: VT_FLOAT

   Floating point (see idc_value_t::e)


.. py:data:: VT_WILD

   Function with arbitrary number of arguments. The actual number of arguments will be passed in idc_value_t::num. This value should not be used for idc_value_t. 
           


.. py:data:: VT_OBJ

   Object (see idc_value_t::obj)


.. py:data:: VT_FUNC

   Function (see idc_value_t::funcidx)


.. py:data:: VT_STR

   String (see qstr() and similar functions)


.. py:data:: VT_PVOID

   void *


.. py:data:: VT_INT64

   i64


.. py:data:: VT_REF

   Reference.


.. py:class:: idc_global_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: value
      :type:  idc_value_t


.. py:data:: eExecThrow

   See return value of idc_func_t.


.. py:function:: find_idc_func(prefix: str, n: int = 0) -> str

.. py:data:: HF_DEFAULT

.. py:data:: HF_KEYWORD1

.. py:data:: HF_KEYWORD2

.. py:data:: HF_KEYWORD3

.. py:data:: HF_STRING

.. py:data:: HF_COMMENT

.. py:data:: HF_PREPROC

.. py:data:: HF_NUMBER

.. py:data:: HF_USER1

.. py:data:: HF_USER2

.. py:data:: HF_USER3

.. py:data:: HF_USER4

.. py:data:: HF_MAX

.. py:class:: highlighter_cbs_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: set_style(arg0: int, arg1: int, arg2: syntax_highlight_style) -> None


   .. py:method:: prev_block_state() -> int


   .. py:method:: cur_block_state() -> int


   .. py:method:: set_block_state(arg0: int) -> None


.. py:function:: set_header_path(path: str, add: bool) -> bool

   Set or append a header path. IDA looks for the include files in the appended header paths, then in the ida executable directory. 
           
   :param path: list of directories to add (separated by ';') may be nullptr, in this case nothing is added
   :param add: true: append. false: remove old paths.
   :returns: true: success
   :returns: false: no memory


.. py:function:: get_idc_filename(file: str) -> str

   Get full name of IDC file name. Search for file in list of include directories, IDCPATH directory and system directories. 
           
   :param file: file name without full path
   :returns: nullptr is file not found. otherwise returns pointer to buf


.. py:function:: exec_system_script(file: str, complain_if_no_file: bool = True) -> bool

   Compile and execute "main" function from system file. 
           
   :param file: file name with IDC function(s). The file will be searched using get_idc_filename().
   :param complain_if_no_file: * 1: display warning if the file is not found
   * 0: don't complain if file doesn't exist
   :returns: 1: ok, file is compiled and executed
   :returns: 0: failure, compilation or execution error, warning is displayed


.. py:data:: CPL_DEL_MACROS

   delete macros at the end of compilation


.. py:data:: CPL_USE_LABELS

   allow program labels in the script


.. py:data:: CPL_ONLY_SAFE

   allow calls of only thread-safe functions


.. py:function:: compile_idc_snippet(func: str, text: str, resolver: idc_resolver_t * = None, only_safe_funcs: bool = False) -> str

   Compile text with IDC statements. 
           
   :param func: name of the function to create out of the snippet
   :param text: text to compile
   :param resolver: callback object to get values of undefined variables This object will be called if IDC function contains references to undefined variables. May be nullptr.
   :param only_safe_funcs: if true, any calls to functions without EXTFUN_SAFE flag will lead to a compilation error.
   :returns: true: ok
   :returns: false: error, see errbuf


.. py:function:: exec_idc_script(result: idc_value_t, path: str, func: str, args: idc_value_t, argsnum: size_t) -> str

   Compile and execute IDC function(s) from file. 
           
   :param result: ptr to idc_value_t to hold result of the function. If execution fails, this variable will contain the exception information. You may pass nullptr if you are not interested in the returned value.
   :param path: text file containing text of IDC functions
   :param func: function name to execute
   :param args: array of parameters
   :param argsnum: number of parameters to pass to 'fname' This number should be equal to number of parameters the function expects.
   :returns: true: ok
   :returns: false: error, see errbuf


.. py:function:: throw_idc_exception(r: idc_value_t, desc: str) -> error_t

   Create an idc execution exception object. This helper function can be used to return an exception from C++ code to IDC. In other words this function can be called from idc_func_t() callbacks. Sample usage: if ( !ok ) return throw_idc_exception(r, "detailed error msg"); 
           
   :param r: object to hold the exception object
   :param desc: exception description
   :returns: eExecThrow


.. py:class:: idc_values_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> idc_value_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> idc_value_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: idc_values_t) -> None


   .. py:method:: extract() -> idc_value_t *


   .. py:method:: inject(s: idc_value_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< idc_value_t >::const_iterator


   .. py:method:: end(*args) -> qvector< idc_value_t >::const_iterator


   .. py:method:: insert(it: idc_value_t, x: idc_value_t) -> qvector< idc_value_t >::iterator


   .. py:method:: erase(*args) -> qvector< idc_value_t >::iterator


   .. py:method:: append(x: idc_value_t) -> None


   .. py:method:: extend(x: idc_values_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: EXTFUN_BASE
   :value: 1


   requires open database.


.. py:data:: EXTFUN_NORET
   :value: 2


   does not return. the interpreter may clean up its state before calling it. 
           


.. py:data:: EXTFUN_SAFE
   :value: 4


   thread safe function. may be called from any thread. 
           


.. py:function:: del_idc_func(name)

   Delete an IDC function 
           


.. py:function:: add_idc_func(name, fp, args, defvals=(), flags=0)

   Add an IDC function. This function does not modify the predefined kernel functions. Example: 
        error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
       
         msg("myfunc is called with arg0=%a and arg1=%s\n", argv[0].num, argv[1].str);
         res->num = 5;     // let's return 5
         return eOk;
       
        const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
        const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args, nullptr, 0, EXTFUN_BASE };
       
        after this:
       
       
        there is a new IDC function which can be called like this:
        "test");


           
   :returns: success



```

`skills/idapython/docs/ida_fixup.md`:

```md
# ida_fixup

Relocation/fixup information for loaders - manage target addresses, offsets, and displacement values.

## Key Functions

- `get_fixup(fd, source) -> bool` - Get fixup information at address
- `exists_fixup(source) -> bool` - Check if fixup exists
- `set_fixup(source, fd)` - Set fixup information (loaders use this)
- `del_fixup(source)` - Delete fixup
- `get_first_fixup_ea() -> ea_t` - Get first fixup address
- `get_next_fixup_ea(ea) -> ea_t` - Next fixup after ea
- `get_prev_fixup_ea(ea) -> ea_t` - Previous fixup before ea
- `get_fixup_value(ea, type) -> int` - Read bytes and convert to operand value (get relocation addend)
- `patch_fixup_value(ea, fd) -> bool` - Update bytes from fixup data
- `get_fixup_desc(source, fd) -> str` - Get description comment
- `calc_fixup_size(type) -> int` - Calculate fixup size in bytes (-1 on error)
- `contains_fixups(ea, size) -> bool` - Check if range contains fixups
- `gen_fix_fixups(from, to, size)` - Relocate bytes when moving segments/rebasing

## fixup_data_t Class

Fixup metadata container.

### Attributes
- `sel: sel_t` - Target segment selector (BADSEL for absolute)
- `off: ea_t` - Target offset
- `displacement: adiff_t` - Displacement from target

### Methods
- `get_type() -> fixup_type_t`, `set_type(type)` - Fixup type access
- `set_type_and_flags(type, flags=0)` - Set both type and flags
- `is_custom() -> bool` - Is processor-specific fixup
- `get_flags() -> int` - Get flags
- `is_extdef() -> bool`, `set_extdef()`, `clr_extdef()` - Target is symbol vs segment offset
- `is_unused() -> bool`, `set_unused()`, `clr_unused()` - IDA ignores this fixup
- `has_base() -> bool` - Is relative fixup (vs segment-relative)
- `was_created() -> bool` - Was created by IDA (not in original file)
- `get_base() -> ea_t`, `set_base(new_base)` - Base address for relative fixups
- `set(source)` - set_fixup wrapper
- `get(source) -> bool` - get_fixup wrapper
- `calc_size() -> int` - Fixup size

## Fixup Types (FIXUP_*)

- `FIXUP_OFF8`, `FIXUP_OFF16`, `FIXUP_OFF32`, `FIXUP_OFF64` - Unsigned offsets (8/16/32/64-bit)
- `FIXUP_OFF8S`, `FIXUP_OFF16S`, `FIXUP_OFF32S` - Signed offsets
- `FIXUP_SEG16` - 16-bit segment selector
- `FIXUP_PTR16` - 32-bit pointer (16:16 base:offset)
- `FIXUP_PTR32` - 48-bit pointer (16:32 base:offset)
- `FIXUP_HI8`, `FIXUP_HI16` - High 8/16 bits of offset
- `FIXUP_LOW8`, `FIXUP_LOW16` - Low 8/16 bits of offset
- `FIXUP_CUSTOM` - Start of custom (processor-specific) types

## Fixup Flags (FIXUPF_*)

- `FIXUPF_REL` - Relative to linear address `base` (else segment-relative)
- `FIXUPF_EXTDEF` - Target is symbol (else segment offset)
- `FIXUPF_UNUSED` - Ignored by IDA, disables operand conversion
- `FIXUPF_CREATED` - Not present in input file
- `FIXUPF_LOADER_MASK` - Loader-specific flags (not stored in DB)

## See Also
Full docs: skill/docs/ida_fixup.rst

```

`skills/idapython/docs/ida_fixup.rst`:

```rst
ida_fixup
=========

.. py:module:: ida_fixup

.. autoapi-nested-parse::

   Functions that deal with fixup information.

   A loader should setup fixup information using set_fixup(). 
       



Attributes
----------

.. autoapisummary::

   ida_fixup.FIXUP_OFF8
   ida_fixup.FIXUP_OFF16
   ida_fixup.FIXUP_SEG16
   ida_fixup.FIXUP_PTR16
   ida_fixup.FIXUP_OFF32
   ida_fixup.FIXUP_PTR32
   ida_fixup.FIXUP_HI8
   ida_fixup.FIXUP_HI16
   ida_fixup.FIXUP_LOW8
   ida_fixup.FIXUP_LOW16
   ida_fixup.V695_FIXUP_VHIGH
   ida_fixup.V695_FIXUP_VLOW
   ida_fixup.FIXUP_OFF64
   ida_fixup.FIXUP_OFF8S
   ida_fixup.FIXUP_OFF16S
   ida_fixup.FIXUP_OFF32S
   ida_fixup.FIXUP_CUSTOM
   ida_fixup.FIXUPF_REL
   ida_fixup.FIXUPF_EXTDEF
   ida_fixup.FIXUPF_UNUSED
   ida_fixup.FIXUPF_CREATED
   ida_fixup.FIXUPF_LOADER_MASK


Classes
-------

.. autoapisummary::

   ida_fixup.fixup_data_t
   ida_fixup.fixup_info_t


Functions
---------

.. autoapisummary::

   ida_fixup.is_fixup_custom
   ida_fixup.get_fixup
   ida_fixup.exists_fixup
   ida_fixup.set_fixup
   ida_fixup.del_fixup
   ida_fixup.get_first_fixup_ea
   ida_fixup.get_next_fixup_ea
   ida_fixup.get_prev_fixup_ea
   ida_fixup.get_fixup_handler
   ida_fixup.get_fixup_value
   ida_fixup.patch_fixup_value
   ida_fixup.get_fixup_desc
   ida_fixup.calc_fixup_size
   ida_fixup.find_custom_fixup
   ida_fixup.get_fixups
   ida_fixup.contains_fixups
   ida_fixup.gen_fix_fixups
   ida_fixup.handle_fixups_in_macro


Module Contents
---------------

.. py:data:: FIXUP_OFF8

   8-bit offset


.. py:data:: FIXUP_OFF16

   16-bit offset


.. py:data:: FIXUP_SEG16

   16-bit base-logical segment base (selector)


.. py:data:: FIXUP_PTR16

   32-bit long pointer (16-bit base:16-bit offset) 
           


.. py:data:: FIXUP_OFF32

   32-bit offset


.. py:data:: FIXUP_PTR32

   48-bit pointer (16-bit base:32-bit offset)


.. py:data:: FIXUP_HI8

   high 8 bits of 16bit offset


.. py:data:: FIXUP_HI16

   high 16 bits of 32bit offset


.. py:data:: FIXUP_LOW8

   low 8 bits of 16bit offset


.. py:data:: FIXUP_LOW16

   low 16 bits of 32bit offset


.. py:data:: V695_FIXUP_VHIGH

   obsolete


.. py:data:: V695_FIXUP_VLOW

   obsolete


.. py:data:: FIXUP_OFF64

   64-bit offset


.. py:data:: FIXUP_OFF8S

   8-bit signed offset


.. py:data:: FIXUP_OFF16S

   16-bit signed offset


.. py:data:: FIXUP_OFF32S

   32-bit signed offset


.. py:data:: FIXUP_CUSTOM

   start of the custom types range


.. py:function:: is_fixup_custom(type: fixup_type_t) -> bool

   Is fixup processed by processor module?


.. py:data:: FIXUPF_REL

   fixup is relative to the linear address `base`. Otherwise fixup is relative to the start of the segment with `sel` selector. 
           


.. py:data:: FIXUPF_EXTDEF

   target is a location (otherwise - segment). Use this bit if the target is a symbol rather than an offset from the beginning of a segment. 
           


.. py:data:: FIXUPF_UNUSED

   fixup is ignored by IDA
   * disallows the kernel to convert operands
   * this fixup is not used during output 


           


.. py:data:: FIXUPF_CREATED

   fixup was not present in the input file


.. py:data:: FIXUPF_LOADER_MASK

   additional flags. The bits from this mask are not stored in the database and can be used by the loader at its discretion. 
           


.. py:class:: fixup_data_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: sel
      :type:  sel_t

      selector of the target segment. BADSEL means an absolute (zero based) target. 
              



   .. py:attribute:: off
      :type:  ida_idaapi.ea_t

      target offset 
              



   .. py:attribute:: displacement
      :type:  adiff_t

      displacement (offset from the target)



   .. py:method:: get_type() -> fixup_type_t

      Fixup type Types of fixups.



   .. py:method:: set_type(type_: fixup_type_t) -> None


   .. py:method:: set_type_and_flags(type_: fixup_type_t, flags_: int = 0) -> None


   .. py:method:: is_custom() -> bool

      is_fixup_custom()



   .. py:method:: get_flags() -> int

      Fixup flags Fixup flags.



   .. py:method:: is_extdef() -> bool


   .. py:method:: set_extdef() -> None


   .. py:method:: clr_extdef() -> None


   .. py:method:: is_unused() -> bool


   .. py:method:: set_unused() -> None


   .. py:method:: clr_unused() -> None


   .. py:method:: has_base() -> bool

      Is fixup relative?



   .. py:method:: was_created() -> bool

      Is fixup artificial?



   .. py:method:: get_base() -> ida_idaapi.ea_t

      Get base of fixup. 
              



   .. py:method:: set_base(new_base: ida_idaapi.ea_t) -> None

      Set base of fixup. The target should be set before a call of this function. 
              



   .. py:method:: set_sel(seg: segment_t const *) -> None


   .. py:method:: set_target_sel() -> None

      Set selector of fixup to the target. The target should be set before a call of this function. 
              



   .. py:method:: set(source: ida_idaapi.ea_t) -> None

      set_fixup()



   .. py:method:: get(source: ida_idaapi.ea_t) -> bool

      get_fixup()



   .. py:method:: get_handler() -> fixup_handler_t const *

      get_fixup_handler()



   .. py:method:: get_desc(source: ida_idaapi.ea_t) -> str

      get_fixup_desc()



   .. py:method:: calc_size() -> int

      calc_fixup_size()



   .. py:method:: get_value(ea: ida_idaapi.ea_t) -> int

      get_fixup_value()



   .. py:method:: patch_value(ea: ida_idaapi.ea_t) -> bool

      patch_fixup_value()



.. py:function:: get_fixup(fd: fixup_data_t, source: ida_idaapi.ea_t) -> bool

   Get fixup information.


.. py:function:: exists_fixup(source: ida_idaapi.ea_t) -> bool

   Check that a fixup exists at the given address.


.. py:function:: set_fixup(source: ida_idaapi.ea_t, fd: fixup_data_t) -> None

   Set fixup information. You should fill fixup_data_t and call this function and the kernel will remember information in the database. 
           
   :param source: the fixup source address, i.e. the address modified by the fixup
   :param fd: fixup data


.. py:function:: del_fixup(source: ida_idaapi.ea_t) -> None

   Delete fixup information.


.. py:function:: get_first_fixup_ea() -> ida_idaapi.ea_t

.. py:function:: get_next_fixup_ea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: get_prev_fixup_ea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: get_fixup_handler(type: fixup_type_t) -> fixup_handler_t const *

   Get handler of standard or custom fixup.


.. py:function:: get_fixup_value(ea: ida_idaapi.ea_t, type: fixup_type_t) -> int

   Get the operand value. This function get fixup bytes from data or an instruction at `ea` and convert them to the operand value (maybe partially). It is opposite in meaning to the `patch_fixup_value()`. For example, FIXUP_HI8 read a byte at `ea` and shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low 26 bits of the insn at `ea` and shifts it left by 2 bits. This function is mainly used to get a relocation addend. 
           
   :param ea: address to get fixup bytes from, the size of the fixup bytes depends on the fixup type.
   :param type: fixup type
   :returns: operand: value


.. py:function:: patch_fixup_value(ea: ida_idaapi.ea_t, fd: fixup_data_t) -> bool

   Patch the fixup bytes. This function updates data or an instruction at `ea` to the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea` to the high byte of `fd->off`, or AArch64's custom fixup BRANCH26 updates low 26 bits of the insn at `ea` to the value of `fd->off` shifted right by 2. 
           
   :param ea: address where data are changed, the size of the changed data depends on the fixup type.
   :param fd: fixup data
   :returns: false: the fixup bytes do not fit (e.g. `fd->off` is greater than 0xFFFFFFC for BRANCH26). The database is changed even in this case.


.. py:function:: get_fixup_desc(source: ida_idaapi.ea_t, fd: fixup_data_t) -> str

   Get FIXUP description comment.


.. py:function:: calc_fixup_size(type: fixup_type_t) -> int

   Calculate size of fixup in bytes (the number of bytes the fixup patches) 
           
   :returns: -1: means error


.. py:function:: find_custom_fixup(name: str) -> fixup_type_t

.. py:class:: fixup_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: fd
      :type:  fixup_data_t


.. py:function:: get_fixups(out: fixups_t *, ea: ida_idaapi.ea_t, size: asize_t) -> bool

.. py:function:: contains_fixups(ea: ida_idaapi.ea_t, size: asize_t) -> bool

   Does the specified address range contain any fixup information?


.. py:function:: gen_fix_fixups(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: asize_t) -> None

   Relocate the bytes with fixup information once more (generic function). This function may be called from loader_t::move_segm() if it suits the goal. If loader_t::move_segm is not defined then this function will be called automatically when moving segments or rebasing the entire program. Special parameter values (from = BADADDR, size = 0, to = delta) are used when the function is called from rebase_program(delta). 
           


.. py:function:: handle_fixups_in_macro(ri: refinfo_t, ea: ida_idaapi.ea_t, other: fixup_type_t, macro_reft_and_flags: int) -> bool

   Handle two fixups in a macro. We often combine two instruction that load parts of a value into one macro instruction. For example: 
          ADRP  X0, #var@PAGE
              ADD   X0, X0, #var@PAGEOFF  --> ADRL X0, var
         lui   $v0, %hi(var)
              addiu $v0, $v0, %lo(var)    --> la   $v0, var


           
   :returns: success ('false' means that RI was not changed)



```

`skills/idapython/docs/ida_fpro.md`:

```md
# ida_fpro

System-independent FILE* operations - cross-module file I/O (use these instead of C stdlib functions).

## qfile_t Class

IDA's FILE* wrapper for cross-module compatibility.

### Constructor Methods
- `open(filename, mode) -> bool` - Open file (fopen-style mode string)
- `from_fp(fp) -> qfile_t*` - Wrap existing FILE*
- `from_capsule(pycapsule) -> qfile_t*` - Wrap Python capsule
- `tmpfile() -> qfile_t*` - Create temporary file

### File Operations
- `close()` - Close file
- `opened() -> bool` - Check if open
- `flush()` - Flush buffers
- `size() -> int64` - Get file size
- `filename() -> str` - Get filename

### Reading
- `read(size) -> str` - Read bytes (None on error)
- `readbytes(size, big_endian) -> str` - Read with endianness conversion
- `gets(len) -> str` - Read line (None on EOF)
- `get_byte() -> int` - Read single byte (None on EOF)

### Writing
- `write(buf) -> int` - Write bytes (0 on error, else bytes written)
- `writebytes(size, big_endian) -> int` - Write with endianness conversion
- `puts(str) -> int` - Write string
- `put_byte(chr)` - Write single byte

### Positioning
- `seek(offset, whence=SEEK_SET) -> int` - Seek (returns new position, not 0 like fseek)
- `tell() -> int` - Get current position

## Functions

- `qfclose(fp)` - Close FILE*

## Move Flags (QMOVE_*)
- `QMOVE_CROSS_FS` - Allow cross-filesystem moves
- `QMOVE_OVERWRITE` - Overwrite existing files
- `QMOVE_OVR_RO` - Overwrite read-only files

## Important

**Never mix C stdlib FILE* functions with IDA kernel functions.** Each module has its own FILE* state when statically linked. Use qfile_t for all file I/O in plugins.

## See Also
Full docs: skill/docs/ida_fpro.rst

```

`skills/idapython/docs/ida_fpro.rst`:

```rst
ida_fpro
========

.. py:module:: ida_fpro

.. autoapi-nested-parse::

   System independent counterparts of FILE* related functions from Clib.

   You should not use C standard I/O functions in your modules. The reason: Each module compiled with Borland (and statically linked to Borland's library) will host a copy of the FILE * information.
   So, if you open a file in the plugin and pass the handle to the kernel, the kernel will not be able to use it.
   If you really need to use the standard functions, define USE_STANDARD_FILE_FUNCTIONS. In this case do not mix them with q... functions. 
       



Attributes
----------

.. autoapisummary::

   ida_fpro.QMOVE_CROSS_FS
   ida_fpro.QMOVE_OVERWRITE
   ida_fpro.QMOVE_OVR_RO
   ida_fpro.qfile_t_from_fp
   ida_fpro.qfile_t_from_capsule
   ida_fpro.qfile_t_tmpfile


Classes
-------

.. autoapisummary::

   ida_fpro.qfile_t


Functions
---------

.. autoapisummary::

   ida_fpro.qfclose


Module Contents
---------------

.. py:class:: qfile_t(*args)

   Bases: :py:obj:`object`


   A helper class to work with FILE related functions.


   .. py:attribute:: thisown


   .. py:method:: opened()

      Checks if the file is opened or not



   .. py:method:: close()

      Closes the file



   .. py:method:: open(filename, mode)

      Opens a file

      :param filename: the file name
      :param mode: The mode string, ala fopen() style
      :returns: Boolean



   .. py:method:: from_fp(fp: FILE *) -> qfile_t *
      :staticmethod:



   .. py:method:: from_capsule(pycapsule: PyObject *) -> qfile_t *
      :staticmethod:



   .. py:method:: tmpfile()
      :staticmethod:


      A static method to construct an instance using a temporary file



   .. py:method:: get_fp() -> FILE *


   .. py:method:: seek(offset, whence=ida_idaapi.SEEK_SET)

      Set input source position

      :param offset: the seek offset
      :param whence: the position to seek from
      :returns: the new position (not 0 as fseek!)



   .. py:method:: tell()

      Returns the current position



   .. py:method:: readbytes(size, big_endian)

      Similar to read() but it respect the endianness

      :param size: the maximum number of bytes to read
      :param big_endian: endianness
      :returns: a str, or None



   .. py:method:: read(size)

      Reads from the file. Returns the buffer or None

      :param size: the maximum number of bytes to read
      :returns: a str, or None



   .. py:method:: gets(len)

      Reads a line from the input file. Returns the read line or None

      :param len: the maximum line length



   .. py:method:: writebytes(size, big_endian)

      Similar to write() but it respect the endianness

      :param buf: the str to write
      :param big_endian: endianness
      :returns: result code



   .. py:method:: write(buf)

      Writes to the file. Returns 0 or the number of bytes written

      :param buf: the str to write
      :returns: result code



   .. py:method:: puts(str: qfile_t.puts.str) -> int


   .. py:method:: size() -> int64


   .. py:method:: flush()


   .. py:method:: filename() -> PyObject *


   .. py:method:: get_byte()

      Reads a single byte from the file. Returns None if EOF or the read byte



   .. py:method:: put_byte()

      Writes a single byte to the file

      :param chr: the byte value



.. py:function:: qfclose(fp: FILE *) -> int

.. py:data:: QMOVE_CROSS_FS

.. py:data:: QMOVE_OVERWRITE

.. py:data:: QMOVE_OVR_RO

.. py:data:: qfile_t_from_fp

.. py:data:: qfile_t_from_capsule

.. py:data:: qfile_t_tmpfile


```

`skills/idapython/docs/ida_frame.md`:

```md
# ida_frame

Function stack frame manipulation - local variables, register variables, stack pointer tracking.

## Frame Structure

```
+------------------------------------------------+
| function arguments                             |
+------------------------------------------------+
| return address                                 |
+------------------------------------------------+
| saved registers (SI, DI, etc)                  |
+------------------------------------------------+ <- typical BP
|                                                |
| local variables                                |
|                                                |
+------------------------------------------------+ <- SP
```

Access via: `tinfo_t::get_func_frame(pfn)` or `get_func_frame(out, pfn)` + `tinfo_t::get_udt_details()`

## Key Functions

### Frame Management
- `add_frame(pfn, frsize, frregs, argsize) -> bool` - Create frame (frsize=locals, frregs=saved regs, argsize=purged bytes)
- `del_frame(pfn) -> bool` - Delete frame
- `set_frame_size(pfn, frsize, frregs, argsize) -> bool` - Resize frame
- `get_frame_size(pfn) -> asize_t` - Full size (locals + saved regs + retaddr + purged bytes)
- `get_frame_retsize(pfn) -> int` - Return address size
- `get_func_frame(out, pfn) -> bool` - Get frame type info

### Frame Parts
- `frame_off_args(pfn) -> ea_t` - Arguments section start
- `frame_off_retaddr(pfn) -> ea_t` - Return address section start
- `frame_off_savregs(pfn) -> ea_t` - Saved registers section start
- `frame_off_lvars(pfn) -> ea_t` - Local variables section start
- `get_frame_part(range, pfn, part)` - Get part offsets (FPC_ARGS/FPC_RETADDR/FPC_SAVREGS/FPC_LVARS)

### Stack Variables
- `define_stkvar(pfn, name, off, tif, repr=None) -> bool` - Define stack var (negative off=locals, positive=args)
- `add_frame_member(pfn, name, offset, tif, repr=None, etf_flags=0) -> bool` - Add member to frame type
- `set_frame_member_type(pfn, offset, tif, repr=None, etf_flags=0) -> bool` - Change member type
- `delete_frame_members(pfn, start_offset, end_offset) -> bool` - Delete members in range
- `build_stkvar_name(pfn, v) -> str` - Auto-generate stack var name
- `calc_stkvar_struc_offset(pfn, insn, n) -> ea_t` - Calculate stack var offset in frame
- `calc_frame_offset(pfn, off, insn=None, op=None) -> int` - Calculate offset in frame from SP/BP offset
- `build_stkvar_xrefs(out, pfn, start_offset, end_offset)` - Get xrefs to stack frame range

### Utilities
- `is_funcarg_off(pfn, frameoff) -> bool` - Is offset in arguments range
- `lvar_off(pfn, frameoff) -> int` - Convert to local var offset
- `is_anonymous_member_name(name) -> bool` - Prefixed with "anonymous"
- `is_dummy_member_name(name) -> bool` - Auto-generated name
- `is_special_frame_member(tid) -> bool` - Is retaddr or saved regs slot
- `soff_to_fpoff(pfn, soff) -> int` - Convert struct offset to FP-relative
- `update_fpd(pfn, fpd) -> bool` - Update frame pointer delta
- `set_purged(ea, nbytes, override_old_value) -> bool` - Set purged bytes (__stdcall/__pascal)

### Register Variables
- `add_regvar(pfn, ea1, ea2, canon, user, cmt) -> int` - Define register variable in range
- `find_regvar(pfn, ea, canon) -> regvar_t*` - Find register variable definition
- `has_regvar(pfn, ea) -> bool` - Check if regvar exists
- `rename_regvar(pfn, v, user) -> int` - Rename register variable
- `set_regvar_cmt(pfn, v, cmt) -> int` - Set comment
- `del_regvar(pfn, ea1, ea2, canon) -> int` - Delete register variable
- `free_regvar(v)` - Free regvar_t

### Stack Pointer Tracking
- `get_spd(pfn, ea) -> int` - Get SP delta before instruction (initial SP - current SP)
- `get_effective_spd(pfn, ea) -> int` - Get SP delta used by instruction (differs for "pop [esp+N]")
- `get_sp_delta(pfn, ea) -> int` - Get SP modification at location (0 if no change point)
- `add_auto_stkpnt(pfn, ea, delta) -> bool` - Add automatic SP change point
- `add_user_stkpnt(ea, delta) -> bool` - Add user-defined SP change point
- `del_stkpnt(pfn, ea) -> bool` - Delete SP change point
- `set_auto_spd(pfn, ea, new_spd) -> bool` - Set cumulative SP delta at address
- `recalc_spd(cur_ea) -> bool` - Recalculate SP for non-fallthrough instructions
- `recalc_spd_for_basic_block(pfn, cur_ea) -> bool` - Recalculate SP for basic block

## regvar_t Class

Register variable definition (extends range_t).

### Attributes
- `canon: str` - Canonical register name (case-insensitive)
- `user: str` - User-defined name
- `cmt: str` - Comment near definition

## Error Codes

- `REGVAR_ERROR_OK` - Success
- `REGVAR_ERROR_ARG` - Bad function arguments
- `REGVAR_ERROR_RANGE` - Bad definition range
- `REGVAR_ERROR_NAME` - Name can't be accepted

## Flags

- `STKVAR_VALID_SIZE` - dtyp contains correct variable type (off for "lea")
- `STKVAR_KEEP_EXISTING` - Don't create new var if one exists

## See Also
Full docs: skill/docs/ida_frame.rst

```

`skills/idapython/docs/ida_frame.rst`:

```rst
ida_frame
=========

.. py:module:: ida_frame

.. autoapi-nested-parse::

   Routines to manipulate function stack frames, stack variables, register variables and local labels.

   The frame is represented as a structure::

     +------------------------------------------------+
     | function arguments                             |
     +------------------------------------------------+
     | return address (isn't stored in func_t)        |
     +------------------------------------------------+
     | saved registers (SI, DI, etc - func_t::frregs) |
     +------------------------------------------------+ <- typical BP
     |                                                |  |
     |                                                |  | func_t::fpd
     |                                                |  |
     |                                                | <- real BP
     | local variables (func_t::frsize)               |
     |                                                |
     |                                                |
     +------------------------------------------------+ <- SP

   To access the structure of a function frame and stack variables, use:

   * tinfo_t::get_func_frame(const func_t *pfn) (the preferred way)
   * get_func_frame(tinfo_t *out, const func_t *pfn)
   * tinfo_t::get_udt_details() gives info about stack variables: their type, 
     names, offset, etc

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For function frame operations, see :mod:`ida_domain.functions`.



Attributes
----------

.. autoapisummary::

   ida_frame.FRAME_UDM_NAME_R
   ida_frame.FRAME_UDM_NAME_S
   ida_frame.FPC_ARGS
   ida_frame.FPC_RETADDR
   ida_frame.FPC_SAVREGS
   ida_frame.FPC_LVARS
   ida_frame.STKVAR_VALID_SIZE
   ida_frame.STKVAR_KEEP_EXISTING
   ida_frame.REGVAR_ERROR_OK
   ida_frame.REGVAR_ERROR_ARG
   ida_frame.REGVAR_ERROR_RANGE
   ida_frame.REGVAR_ERROR_NAME


Classes
-------

.. autoapisummary::

   ida_frame.xreflist_t
   ida_frame.stkpnt_t
   ida_frame.stkpnts_t
   ida_frame.regvar_t
   ida_frame.xreflist_entry_t


Functions
---------

.. autoapisummary::

   ida_frame.is_funcarg_off
   ida_frame.lvar_off
   ida_frame.add_frame
   ida_frame.del_frame
   ida_frame.set_frame_size
   ida_frame.get_frame_size
   ida_frame.get_frame_retsize
   ida_frame.get_frame_part
   ida_frame.frame_off_args
   ida_frame.frame_off_retaddr
   ida_frame.frame_off_savregs
   ida_frame.frame_off_lvars
   ida_frame.get_func_frame
   ida_frame.soff_to_fpoff
   ida_frame.update_fpd
   ida_frame.set_purged
   ida_frame.define_stkvar
   ida_frame.add_frame_member
   ida_frame.is_anonymous_member_name
   ida_frame.is_dummy_member_name
   ida_frame.is_special_frame_member
   ida_frame.set_frame_member_type
   ida_frame.delete_frame_members
   ida_frame.build_stkvar_name
   ida_frame.calc_stkvar_struc_offset
   ida_frame.calc_frame_offset
   ida_frame.free_regvar
   ida_frame.add_regvar
   ida_frame.find_regvar
   ida_frame.has_regvar
   ida_frame.rename_regvar
   ida_frame.set_regvar_cmt
   ida_frame.del_regvar
   ida_frame.add_auto_stkpnt
   ida_frame.add_user_stkpnt
   ida_frame.del_stkpnt
   ida_frame.get_spd
   ida_frame.get_effective_spd
   ida_frame.get_sp_delta
   ida_frame.set_auto_spd
   ida_frame.recalc_spd
   ida_frame.recalc_spd_for_basic_block
   ida_frame.build_stkvar_xrefs


Module Contents
---------------

.. py:class:: xreflist_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> xreflist_entry_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> xreflist_entry_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: xreflist_t) -> None


   .. py:method:: extract() -> xreflist_entry_t *


   .. py:method:: inject(s: xreflist_entry_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< xreflist_entry_t >::const_iterator


   .. py:method:: end(*args) -> qvector< xreflist_entry_t >::const_iterator


   .. py:method:: insert(it: xreflist_entry_t, x: xreflist_entry_t) -> qvector< xreflist_entry_t >::iterator


   .. py:method:: erase(*args) -> qvector< xreflist_entry_t >::iterator


   .. py:method:: find(*args) -> qvector< xreflist_entry_t >::const_iterator


   .. py:method:: has(x: xreflist_entry_t) -> bool


   .. py:method:: add_unique(x: xreflist_entry_t) -> bool


   .. py:method:: append(x: xreflist_entry_t) -> None


   .. py:method:: extend(x: xreflist_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: is_funcarg_off(pfn: func_t const *, frameoff: int) -> bool

.. py:function:: lvar_off(pfn: func_t const *, frameoff: int) -> int

.. py:data:: FRAME_UDM_NAME_R

.. py:data:: FRAME_UDM_NAME_S

.. py:class:: stkpnt_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: spd
      :type:  int


   .. py:method:: compare(r: stkpnt_t) -> int


.. py:class:: stkpnts_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: compare(r: stkpnts_t) -> int


.. py:function:: add_frame(pfn: func_t *, frsize: int, frregs: ushort, argsize: asize_t) -> bool

   Add function frame. 
           
   :param pfn: pointer to function structure
   :param frsize: size of function local variables
   :param frregs: size of saved registers
   :param argsize: size of function arguments range which will be purged upon return. this parameter is used for __stdcall and __pascal calling conventions. for other calling conventions please pass 0.
   :returns: 1: ok
   :returns: 0: failed (no function, frame already exists)


.. py:function:: del_frame(pfn: func_t *) -> bool

   Delete a function frame. 
           
   :param pfn: pointer to function structure
   :returns: success


.. py:function:: set_frame_size(pfn: func_t *, frsize: asize_t, frregs: ushort, argsize: asize_t) -> bool

   Set size of function frame. Note: The returned size may not include all stack arguments. It does so only for __stdcall and __fastcall calling conventions. To get the entire frame size for all cases use frame.get_func_frame(pfn).get_size() 
           
   :param pfn: pointer to function structure
   :param frsize: size of function local variables
   :param frregs: size of saved registers
   :param argsize: size of function arguments that will be purged from the stack upon return
   :returns: success


.. py:function:: get_frame_size(pfn: func_t const *) -> asize_t

   Get full size of a function frame. This function takes into account size of local variables + size of saved registers + size of return address + number of purged bytes. The purged bytes correspond to the arguments of the functions with __stdcall and __fastcall calling conventions. 
           
   :param pfn: pointer to function structure, may be nullptr
   :returns: size of frame in bytes or zero


.. py:function:: get_frame_retsize(pfn: func_t const *) -> int

   Get size of function return address. 
           
   :param pfn: pointer to function structure, can't be nullptr


.. py:data:: FPC_ARGS

.. py:data:: FPC_RETADDR

.. py:data:: FPC_SAVREGS

.. py:data:: FPC_LVARS

.. py:function:: get_frame_part(range: range_t, pfn: func_t const *, part: frame_part_t) -> None

   Get offsets of the frame part in the frame. 
           
   :param range: pointer to the output buffer with the frame part start/end(exclusive) offsets, can't be nullptr
   :param pfn: pointer to function structure, can't be nullptr
   :param part: frame part


.. py:function:: frame_off_args(pfn: func_t const *) -> ida_idaapi.ea_t

   Get starting address of arguments section.


.. py:function:: frame_off_retaddr(pfn: func_t const *) -> ida_idaapi.ea_t

   Get starting address of return address section.


.. py:function:: frame_off_savregs(pfn: func_t const *) -> ida_idaapi.ea_t

   Get starting address of saved registers section.


.. py:function:: frame_off_lvars(pfn: func_t const *) -> ida_idaapi.ea_t

   Get start address of local variables section.


.. py:function:: get_func_frame(out: tinfo_t, pfn: func_t const *) -> bool

   Get type of function frame 
           
   :param out: type info
   :param pfn: pointer to function structure
   :returns: success


.. py:function:: soff_to_fpoff(pfn: func_t *, soff: int) -> int

   Convert struct offsets into fp-relative offsets. This function converts the offsets inside the udt_type_data_t object into the frame pointer offsets (for example, EBP-relative). 
           


.. py:function:: update_fpd(pfn: func_t *, fpd: asize_t) -> bool

   Update frame pointer delta. 
           
   :param pfn: pointer to function structure
   :param fpd: new fpd value. cannot be bigger than the local variable range size.
   :returns: success


.. py:function:: set_purged(ea: ida_idaapi.ea_t, nbytes: int, override_old_value: bool) -> bool

   Set the number of purged bytes for a function or data item (funcptr). This function will update the database and plan to reanalyze items referencing the specified address. It works only for processors with PR_PURGING bit in 16 and 32 bit modes. 
           
   :param ea: address of the function of item
   :param nbytes: number of purged bytes
   :param override_old_value: may overwrite old information about purged bytes
   :returns: success


.. py:data:: STKVAR_VALID_SIZE

   x.dtyp contains correct variable type (for insns like 'lea' this bit must be off). In general, dr_O references do not allow to determine the variable size 
           


.. py:data:: STKVAR_KEEP_EXISTING

   if a stack variable for this operand already exists then we do not create a new variable 
           


.. py:function:: define_stkvar(pfn: func_t *, name: str, off: int, tif: tinfo_t, repr: value_repr_t = None) -> bool

   Define/redefine a stack variable. 
           
   :param pfn: pointer to function
   :param name: variable name, nullptr means autogenerate a name
   :param off: offset of the stack variable in the frame. negative values denote local variables, positive - function arguments.
   :param tif: variable type
   :param repr: variable representation
   :returns: success


.. py:function:: add_frame_member(pfn: func_t const *, name: str, offset: int, tif: tinfo_t, repr: value_repr_t = None, etf_flags: uint = 0) -> bool

   Add member to the frame type 
           
   :param pfn: pointer to function
   :param name: variable name, nullptr means autogenerate a name
   :param offset: member offset in the frame structure, in bytes
   :param tif: variable type
   :param repr: variable representation
   :returns: success


.. py:function:: is_anonymous_member_name(name: str) -> bool

   Is member name prefixed with "anonymous"?


.. py:function:: is_dummy_member_name(name: str) -> bool

   Is member name an auto-generated name?


.. py:function:: is_special_frame_member(tid: tid_t) -> bool

   Is stkvar with TID the return address slot or the saved registers slot ? 
           
   :param tid: frame member type id return address or saved registers member?


.. py:function:: set_frame_member_type(pfn: func_t const *, offset: int, tif: tinfo_t, repr: value_repr_t = None, etf_flags: uint = 0) -> bool

   Change type of the frame member 
           
   :param pfn: pointer to function
   :param offset: member offset in the frame structure, in bytes
   :param tif: variable type
   :param repr: variable representation
   :returns: success


.. py:function:: delete_frame_members(pfn: func_t const *, start_offset: int, end_offset: int) -> bool

   Delete frame members 
           
   :param pfn: pointer to function
   :param start_offset: member offset to start deletion from, in bytes
   :param end_offset: member offset which not included in the deletion, in bytes
   :returns: success


.. py:function:: build_stkvar_name(pfn: func_t const *, v: int) -> str

   Build automatic stack variable name. 
           
   :param pfn: pointer to function (can't be nullptr!)
   :param v: value of variable offset
   :returns: length of stack variable name or -1


.. py:function:: calc_stkvar_struc_offset(pfn: func_t *, insn: insn_t const &, n: int) -> ida_idaapi.ea_t

   Calculate offset of stack variable in the frame structure. 
           
   :param pfn: pointer to function (cannot be nullptr)
   :param insn: the instruction
   :param n: 0..UA_MAXOP-1 operand number -1 if error, return BADADDR
   :returns: BADADDR if some error (issue a warning if stack frame is bad)


.. py:function:: calc_frame_offset(pfn: func_t *, off: int, insn: insn_t const * = None, op: op_t const * = None) -> int

   Calculate the offset of stack variable in the frame. 
           
   :param pfn: pointer to function (cannot be nullptr)
   :param off: the offset relative to stack pointer or frame pointer
   :param insn: the instruction
   :param op: the operand
   :returns: the offset in the frame


.. py:function:: free_regvar(v: regvar_t) -> None

.. py:class:: regvar_t(*args)

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: canon
      :type:  char *

      canonical register name (case-insensitive)



   .. py:attribute:: user
      :type:  char *

      user-defined register name



   .. py:attribute:: cmt
      :type:  char *

      comment to appear near definition



   .. py:method:: swap(r: regvar_t) -> None


.. py:function:: add_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str, cmt: str) -> int

   Define a register variable. 
           
   :param pfn: function in which the definition will be created
   :param ea1: range of addresses within the function where the definition will be used
   :param ea2: range of addresses within the function where the definition will be used
   :param canon: name of a general register
   :param user: user-defined name for the register
   :param cmt: comment for the definition
   :returns: Register variable error codes


.. py:data:: REGVAR_ERROR_OK

   all ok


.. py:data:: REGVAR_ERROR_ARG

   function arguments are bad


.. py:data:: REGVAR_ERROR_RANGE

   the definition range is bad


.. py:data:: REGVAR_ERROR_NAME

   the provided name(s) can't be accepted


.. py:function:: find_regvar(*args) -> regvar_t *

   This function has the following signatures:

       0. find_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str) -> regvar_t *
       1. find_regvar(pfn: func_t *, ea: ida_idaapi.ea_t, canon: str) -> regvar_t *

   # 0: find_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str) -> regvar_t *

   Find a register variable definition (powerful version). One of 'canon' and 'user' should be nullptr. If both 'canon' and 'user' are nullptr it returns the first regvar definition in the range. 
           
   :returns: nullptr-not found, otherwise ptr to regvar_t

   # 1: find_regvar(pfn: func_t *, ea: ida_idaapi.ea_t, canon: str) -> regvar_t *

   Find a register variable definition. 
           
   :returns: nullptr-not found, otherwise ptr to regvar_t


.. py:function:: has_regvar(pfn: func_t *, ea: ida_idaapi.ea_t) -> bool

   Is there a register variable definition? 
           
   :param pfn: function in question
   :param ea: current address


.. py:function:: rename_regvar(pfn: func_t *, v: regvar_t, user: str) -> int

   Rename a register variable. 
           
   :param pfn: function in question
   :param v: variable to rename
   :param user: new user-defined name for the register
   :returns: Register variable error codes


.. py:function:: set_regvar_cmt(pfn: func_t *, v: regvar_t, cmt: str) -> int

   Set comment for a register variable. 
           
   :param pfn: function in question
   :param v: variable to rename
   :param cmt: new comment
   :returns: Register variable error codes


.. py:function:: del_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str) -> int

   Delete a register variable definition. 
           
   :param pfn: function in question
   :param ea1: range of addresses within the function where the definition holds
   :param ea2: range of addresses within the function where the definition holds
   :param canon: name of a general register
   :returns: Register variable error codes


.. py:function:: add_auto_stkpnt(pfn: func_t *, ea: ida_idaapi.ea_t, delta: int) -> bool

   Add automatic SP register change point. 
           
   :param pfn: pointer to the function. may be nullptr.
   :param ea: linear address where SP changes. usually this is the end of the instruction which modifies the stack pointer ( insn_t::ea+ insn_t::size)
   :param delta: difference between old and new values of SP
   :returns: success


.. py:function:: add_user_stkpnt(ea: ida_idaapi.ea_t, delta: int) -> bool

   Add user-defined SP register change point. 
           
   :param ea: linear address where SP changes
   :param delta: difference between old and new values of SP
   :returns: success


.. py:function:: del_stkpnt(pfn: func_t *, ea: ida_idaapi.ea_t) -> bool

   Delete SP register change point. 
           
   :param pfn: pointer to the function. may be nullptr.
   :param ea: linear address
   :returns: success


.. py:function:: get_spd(pfn: func_t *, ea: ida_idaapi.ea_t) -> int

   Get difference between the initial and current values of ESP. 
           
   :param pfn: pointer to the function. may be nullptr.
   :param ea: linear address of the instruction
   :returns: 0 or the difference, usually a negative number. returns the sp-diff before executing the instruction.


.. py:function:: get_effective_spd(pfn: func_t *, ea: ida_idaapi.ea_t) -> int

   Get effective difference between the initial and current values of ESP. This function returns the sp-diff used by the instruction. The difference between get_spd() and get_effective_spd() is present only for instructions like "pop [esp+N]": they modify sp and use the modified value. 
           
   :param pfn: pointer to the function. may be nullptr.
   :param ea: linear address
   :returns: 0 or the difference, usually a negative number


.. py:function:: get_sp_delta(pfn: func_t *, ea: ida_idaapi.ea_t) -> int

   Get modification of SP made at the specified location 
           
   :param pfn: pointer to the function. may be nullptr.
   :param ea: linear address
   :returns: 0 if the specified location doesn't contain a SP change point. otherwise return delta of SP modification.


.. py:function:: set_auto_spd(pfn: func_t *, ea: ida_idaapi.ea_t, new_spd: int) -> bool

   Add such an automatic SP register change point so that at EA the new cumulative SP delta (that is, the difference between the initial and current values of SP) would be equal to NEW_SPD. 
           
   :param pfn: pointer to the function. may be nullptr.
   :param ea: linear address of the instruction
   :param new_spd: new value of the cumulative SP delta
   :returns: success


.. py:function:: recalc_spd(cur_ea: ida_idaapi.ea_t) -> bool

   Recalculate SP delta for an instruction that stops execution. The next instruction is not reached from the current instruction. We need to recalculate SP for the next instruction.
   This function will create a new automatic SP register change point if necessary. It should be called from the emulator (emu.cpp) when auto_state == AU_USED if the current instruction doesn't pass the execution flow to the next instruction. 
           
   :param cur_ea: linear address of the current instruction
   :returns: 1: new stkpnt is added
   :returns: 0: nothing is changed


.. py:function:: recalc_spd_for_basic_block(pfn: func_t *, cur_ea: ida_idaapi.ea_t) -> bool

   Recalculate SP delta for the current instruction. The typical code snippet to calculate SP delta in a proc module is:

   if ( may_trace_sp() && pfn != nullptr )
     if ( !recalc_spd_for_basic_block(pfn, insn.ea) )
       trace_sp(pfn, insn);

   where trace_sp() is a typical name for a function that emulates the SP change of an instruction.

   :param pfn: pointer to the function
   :param cur_ea: linear address of the current instruction
   :returns: true: the cumulative SP delta is set
   :returns: false: the instruction at CUR_EA passes flow to the next instruction. SP delta must be set as a result of emulating the current instruction.


.. py:class:: xreflist_entry_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      Location of the insn referencing the stack frame member.



   .. py:attribute:: opnum
      :type:  uchar

      Number of the operand of that instruction.



   .. py:attribute:: type
      :type:  uchar

      The type of xref (cref_t & dref_t)



   .. py:method:: compare(r: xreflist_entry_t) -> int


.. py:function:: build_stkvar_xrefs(out: xreflist_t, pfn: func_t *, start_offset: int, end_offset: int) -> None

   Fill 'out' with a list of all the xrefs made from function 'pfn' to specified range of the pfn's stack frame. 
           
   :param out: the list of xrefs to fill.
   :param pfn: the function to scan.
   :param start_offset: start frame structure offset, in bytes
   :param end_offset: end frame structure offset, in bytes



```

`skills/idapython/docs/ida_funcs.md`:

```md
# ida_funcs

Function management - define, modify, analyze functions and function chunks. Includes FLIRT signature support.

## Architecture

Functions consist of:
- **Entry chunk** - function start (required)
- **Tail chunks** - optional additional code ranges shared between functions
- Each tail has an **owner** function

## func_t Class

Core function descriptor (extends range_t).

### Key Attributes
- `flags: uint64` - Function flags (FUNC_*)
- `frame: int` - Frame structure netnode ID
- `frsize: asize_t` - Local variables size
- `frregs: ushort` - Saved registers size
- `argsize: asize_t` - Purged bytes on return (__stdcall/__pascal)
- `fpd: asize_t` - Frame pointer delta (usually 0)
- `color: bgcolor_t` - User-defined color
- `points: stkpnt_t*`, `pntqty: int` - SP change points
- `regvars: regvar_t*`, `regvarqty: int` - Register variables
- `regargs: regarg_t*`, `regargqty: int` - Register arguments (temporary, cleared when type determined)
- `tails: range_t*`, `tailqty: int` - Function tails
- `owner: ea_t` - Tail owner address
- `referers: ea_t*`, `refqty: int` - Parent functions using this tail

### Methods
- `is_far() -> bool` - Far function
- `does_return() -> bool` - Returns to caller
- `analyzed_sp() -> bool` - SP-analysis performed
- `need_prolog_analysis() -> bool` - Needs prolog analysis
- `get_name() -> str` - Function name
- `get_prototype() -> tinfo_t` - Function prototype
- `get_frame_object() -> tinfo_t` - Frame structure
- `addresses()`, `code_items()`, `data_items()`, `head_items()`, `not_tails()` - Iterators

## Key Functions

### Querying Functions
- `get_func(ea) -> func_t*` - Get function by address (returns entry chunk)
- `getn_func(n) -> func_t*` - Get function by index (0..get_func_qty()-1)
- `get_func_qty() -> size_t` - Total function count
- `get_func_num(ea) -> int` - Get function index (-1 if not found)
- `get_prev_func(ea) -> func_t*`, `get_next_func(ea) -> func_t*` - Navigate functions
- `func_contains(pfn, ea) -> bool` - Does function contain address
- `is_same_func(ea1, ea2) -> bool` - Do addresses belong to same function
- `get_func_chunknum(pfn, ea) -> int` - Get chunk number (-1=not contained, 0=entry, >0=tail)

### Creating/Modifying Functions
- `add_func(ea1, ea2=BADADDR) -> bool` - Create function (auto-determines bounds if ea2=BADADDR)
- `add_func_ex(pfn) -> bool` - Create from func_t struct
- `del_func(ea) -> bool` - Delete function
- `update_func(pfn) -> bool` - Update function info (don't use for start/end changes)
- `set_func_start(ea, newstart) -> int` - Move start address (returns MOVE_FUNC_*)
- `set_func_end(ea, newend) -> bool` - Move end address
- `find_func_bounds(nfn, flags) -> int` - Auto-determine boundaries (returns FIND_FUNC_*)
- `reanalyze_function(pfn, ea1=None, ea2=None, analyze_parents=False)` - Reanalyze function

### Function Information
- `get_func_name(ea) -> str` - Get name
- `get_func_cmt(pfn, repeatable) -> str`, `set_func_cmt(pfn, cmt, repeatable) -> bool` - Comments
- `get_func_ranges(ranges, pfn) -> ea_t` - Get all ranges
- `calc_func_size(pfn) -> asize_t` - Total size including tails
- `get_func_bitness(ea) -> int` - Bitness (0=16, 1=32, 2=64, -1=error)
- `get_func_bits(ea) -> int` - Bits (16/32/64)
- `get_func_bytes(ea) -> bytes` - Function bytes
- `is_visible_func(pfn) -> bool`, `set_visible_func(pfn, visible)` - Visibility control
- `is_finally_visible_func(pfn) -> bool` - Final visibility after all checks

### Function Analysis
- `func_does_return(ea) -> bool` - Does function return
- `reanalyze_noret_flag(ea)` - Reanalyze non-return flag
- `set_noret_insn(ea, noret)` - Mark instruction as non-returning
- `calc_thunk_func_target(pfn) -> ea_t` - Get thunk target
- `set_func_name_if_jumpfunc(pfn, name)` - Auto-name jump functions

### Function Chunks (Tails)
- `get_fchunk(ea) -> func_t*` - Get chunk by address (entry or tail)
- `getn_fchunk(n) -> func_t*` - Get chunk by index
- `get_fchunk_qty() -> size_t` - Total chunk count
- `get_fchunk_num(ea) -> int` - Get chunk index
- `get_prev_fchunk(ea) -> func_t*`, `get_next_fchunk(ea) -> func_t*` - Navigate chunks
- `append_func_tail(pfn, tail_ea1, tail_ea2) -> bool` - Add tail to function
- `remove_func_tail(pfn, tail_ea) -> bool` - Remove tail
- `set_tail_owner(tail, owner_ea) -> bool` - Change tail owner
- `get_fchunk_referer(ea, idx) -> ea_t` - Get parent function using tail
- `func_tail_iterator_set(pfn, fti)` - Initialize tail iterator
- `func_parent_iterator_set(pfn, fpi)` - Initialize parent iterator

### Locking
- `lock_func_range(pfn, lock)` - Lock function pointer (prevents deletion/move)
- `is_func_locked(pfn) -> bool` - Check if locked
- `lock_func(pfn)`, `lock_func_with_tails_t(pfn)` - RAII lock helpers

### FLIRT Signatures
- `plan_to_apply_idasgn(name) -> int` - Plan signature application (returns IDASGN_*)
- `apply_idasgn_to(name, ea, may_show_wait_box) -> int` - Apply signature at address
- `get_idasgn_qty() -> int` - Number of loaded signatures
- `get_current_idasgn() -> str` - Current signature name
- `calc_idasgn_state(n) -> int` - Signature state (IDASGN_*)
- `del_idasgn(n)` - Delete signature
- `get_idasgn_title(n) -> str` - Get signature title
- `get_idasgn_desc(n) -> str` - Get description
- `get_idasgn_desc_with_matches(n) -> str` - Get description with match count
- `apply_startup_sig(ea1, ea2)` - Apply startup signature
- `try_to_add_libfunc(pfn, ea) -> int` - Try to add library function (returns LIBFUNC_*)

### Register Arguments
- `read_regargs(pfn) -> dyn_regarg_array` - Read register arguments
- `add_regarg(pfn, reg, type, name) -> bool` - Add register argument

## Function Flags (FUNC_*)

- `FUNC_NORET` - Doesn't return
- `FUNC_FAR` - Far function
- `FUNC_LIB` - Library function
- `FUNC_STATICDEF` - Static
- `FUNC_FRAME` - Uses frame pointer (BP)
- `FUNC_USERFAR` - User-specified far
- `FUNC_HIDDEN` - Hidden chunk
- `FUNC_THUNK` - Jump/thunk function
- `FUNC_BOTTOMBP` - BP points to stack frame bottom
- `FUNC_NORET_PENDING` - Non-return analysis pending
- `FUNC_SP_READY` - SP-analysis complete
- `FUNC_FUZZY_SP` - SP changes untraceably (e.g., "and esp, 0FFFFFFF0h")
- `FUNC_PROLOG_OK` - Prolog analyzed
- `FUNC_PURGED_OK` - argsize validated
- `FUNC_TAIL` - Function tail chunk
- `FUNC_LUMINA` - Info from Lumina
- `FUNC_OUTLINE` - Outlined code, not real function
- `FUNC_REANALYZE` - Frame changed, needs reanalysis
- `FUNC_UNWIND` - Exception unwind handler
- `FUNC_CATCH` - Exception catch handler

## Return Codes

### MOVE_FUNC_*
- `MOVE_FUNC_OK` - Success
- `MOVE_FUNC_NOCODE` - No instruction at newstart
- `MOVE_FUNC_BADSTART` - Bad new start
- `MOVE_FUNC_NOFUNC` - No function at ea
- `MOVE_FUNC_REFUSED` - Plugin refused

### FIND_FUNC_* (flags)
- `FIND_FUNC_NORMAL` - Stop on undefined byte
- `FIND_FUNC_DEFINE` - Create instruction on undefined byte
- `FIND_FUNC_IGNOREFN` - Ignore existing function boundaries
- `FIND_FUNC_KEEPBD` - Don't modify boundaries, just create instructions

### FIND_FUNC_* (results)
- `FIND_FUNC_OK` - Ready for add_func()
- `FIND_FUNC_EXIST` - Already exists
- `FIND_FUNC_UNDEF` - Has unexplored bytes

### IDASGN_*
- `IDASGN_OK` - Success
- `IDASGN_BADARG` - Bad argument
- `IDASGN_APPLIED` - Already applied
- `IDASGN_CURRENT` - Current signature
- `IDASGN_PLANNED` - Planned for application

### LIBFUNC_*
- `LIBFUNC_FOUND` - Found and added
- `LIBFUNC_NONE` - Not found
- `LIBFUNC_DELAY` - Delayed (needs more analysis)

## Iterators

- `func_tail_iterator_t` - Iterate function tails
- `func_item_iterator_t` - Iterate function items (addresses/code/data/heads)
- `func_parent_iterator_t` - Iterate parent functions using tail

## See Also
Full docs: skill/docs/ida_funcs.rst

```

`skills/idapython/docs/ida_funcs.rst`:

```rst
ida_funcs
=========

.. py:module:: ida_funcs

.. autoapi-nested-parse::

   Routines for working with functions within the disassembled program.

   This file also contains routines for working with library signatures (e.g. FLIRT).

   Each function consists of function chunks. At least one function chunk must be present in the function definition - the function entry chunk. Other chunks are called function tails. There may be several of them for a function.

   A function tail is a continuous range of addresses. It can be used in the definition of one or more functions. One function using the tail is singled out and called the tail owner. This function is considered as 'possessing' the tail. get_func() on a tail address will return the function possessing the tail. You can enumerate the functions using the tail by using func_parent_iterator_t.

   Each function chunk in the disassembly is represented as an "range" (a range of addresses, see range.hpp for details) with characteristics.
   A function entry must start with an instruction (code) byte. 

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For function management and analysis, see :mod:`ida_domain.functions`.



Attributes
----------

.. autoapisummary::

   ida_funcs.FUNC_NORET
   ida_funcs.FUNC_FAR
   ida_funcs.FUNC_LIB
   ida_funcs.FUNC_STATICDEF
   ida_funcs.FUNC_FRAME
   ida_funcs.FUNC_USERFAR
   ida_funcs.FUNC_HIDDEN
   ida_funcs.FUNC_THUNK
   ida_funcs.FUNC_BOTTOMBP
   ida_funcs.FUNC_NORET_PENDING
   ida_funcs.FUNC_SP_READY
   ida_funcs.FUNC_FUZZY_SP
   ida_funcs.FUNC_PROLOG_OK
   ida_funcs.FUNC_PURGED_OK
   ida_funcs.FUNC_TAIL
   ida_funcs.FUNC_LUMINA
   ida_funcs.FUNC_OUTLINE
   ida_funcs.FUNC_REANALYZE
   ida_funcs.FUNC_UNWIND
   ida_funcs.FUNC_CATCH
   ida_funcs.MOVE_FUNC_OK
   ida_funcs.MOVE_FUNC_NOCODE
   ida_funcs.MOVE_FUNC_BADSTART
   ida_funcs.MOVE_FUNC_NOFUNC
   ida_funcs.MOVE_FUNC_REFUSED
   ida_funcs.FIND_FUNC_NORMAL
   ida_funcs.FIND_FUNC_DEFINE
   ida_funcs.FIND_FUNC_IGNOREFN
   ida_funcs.FIND_FUNC_KEEPBD
   ida_funcs.FIND_FUNC_UNDEF
   ida_funcs.FIND_FUNC_OK
   ida_funcs.FIND_FUNC_EXIST
   ida_funcs.IDASGN_OK
   ida_funcs.IDASGN_BADARG
   ida_funcs.IDASGN_APPLIED
   ida_funcs.IDASGN_CURRENT
   ida_funcs.IDASGN_PLANNED
   ida_funcs.LIBFUNC_FOUND
   ida_funcs.LIBFUNC_NONE
   ida_funcs.LIBFUNC_DELAY


Classes
-------

.. autoapisummary::

   ida_funcs.dyn_stkpnt_array
   ida_funcs.dyn_regvar_array
   ida_funcs.dyn_range_array
   ida_funcs.dyn_ea_array
   ida_funcs.dyn_regarg_array
   ida_funcs.regarg_t
   ida_funcs.func_t
   ida_funcs.lock_func
   ida_funcs.lock_func_with_tails_t
   ida_funcs.func_tail_iterator_t
   ida_funcs.func_item_iterator_t
   ida_funcs.func_parent_iterator_t


Functions
---------

.. autoapisummary::

   ida_funcs.free_regarg
   ida_funcs.is_func_entry
   ida_funcs.is_func_tail
   ida_funcs.lock_func_range
   ida_funcs.is_func_locked
   ida_funcs.get_func
   ida_funcs.get_func_chunknum
   ida_funcs.func_contains
   ida_funcs.is_same_func
   ida_funcs.getn_func
   ida_funcs.get_func_qty
   ida_funcs.get_func_num
   ida_funcs.get_prev_func
   ida_funcs.get_next_func
   ida_funcs.get_func_ranges
   ida_funcs.get_func_cmt
   ida_funcs.set_func_cmt
   ida_funcs.update_func
   ida_funcs.add_func_ex
   ida_funcs.add_func
   ida_funcs.del_func
   ida_funcs.set_func_start
   ida_funcs.set_func_end
   ida_funcs.reanalyze_function
   ida_funcs.find_func_bounds
   ida_funcs.get_func_name
   ida_funcs.calc_func_size
   ida_funcs.get_func_bitness
   ida_funcs.get_func_bits
   ida_funcs.get_func_bytes
   ida_funcs.is_visible_func
   ida_funcs.is_finally_visible_func
   ida_funcs.set_visible_func
   ida_funcs.set_func_name_if_jumpfunc
   ida_funcs.calc_thunk_func_target
   ida_funcs.func_does_return
   ida_funcs.reanalyze_noret_flag
   ida_funcs.set_noret_insn
   ida_funcs.get_fchunk
   ida_funcs.getn_fchunk
   ida_funcs.get_fchunk_qty
   ida_funcs.get_fchunk_num
   ida_funcs.get_prev_fchunk
   ida_funcs.get_next_fchunk
   ida_funcs.append_func_tail
   ida_funcs.remove_func_tail
   ida_funcs.set_tail_owner
   ida_funcs.func_tail_iterator_set
   ida_funcs.func_tail_iterator_set_ea
   ida_funcs.func_parent_iterator_set
   ida_funcs.f_any
   ida_funcs.get_prev_func_addr
   ida_funcs.get_next_func_addr
   ida_funcs.read_regargs
   ida_funcs.add_regarg
   ida_funcs.plan_to_apply_idasgn
   ida_funcs.apply_idasgn_to
   ida_funcs.get_idasgn_qty
   ida_funcs.get_current_idasgn
   ida_funcs.calc_idasgn_state
   ida_funcs.del_idasgn
   ida_funcs.get_idasgn_title
   ida_funcs.apply_startup_sig
   ida_funcs.try_to_add_libfunc
   ida_funcs.get_fchunk_referer
   ida_funcs.get_idasgn_desc
   ida_funcs.get_idasgn_desc_with_matches
   ida_funcs.func_t__from_ptrval__
   ida_funcs.calc_thunk_func_target


Module Contents
---------------

.. py:class:: dyn_stkpnt_array(_data: stkpnt_t *, _count: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  stkpnt_t *


   .. py:attribute:: count
      :type:  size_t


.. py:class:: dyn_regvar_array(_data: regvar_t *, _count: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  regvar_t *


   .. py:attribute:: count
      :type:  size_t


.. py:class:: dyn_range_array(_data: range_t, _count: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  range_t *


   .. py:attribute:: count
      :type:  size_t


.. py:class:: dyn_ea_array(_data: unsigned long long *, _count: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  unsigned long long *


   .. py:attribute:: count
      :type:  size_t


.. py:class:: dyn_regarg_array(_data: regarg_t, _count: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  regarg_t *


   .. py:attribute:: count
      :type:  size_t


.. py:function:: free_regarg(v: regarg_t) -> None

.. py:class:: regarg_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: reg
      :type:  int


   .. py:attribute:: type
      :type:  type_t *


   .. py:attribute:: name
      :type:  char *


   .. py:method:: swap(r: regarg_t) -> None


.. py:class:: func_t(start: ida_idaapi.ea_t = 0, end: ida_idaapi.ea_t = 0, f: flags64_t = 0)

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  uint64

      Function flags 
              



   .. py:method:: is_far() -> bool

      Is a far function?



   .. py:method:: does_return() -> bool

      Does function return?



   .. py:method:: analyzed_sp() -> bool

      Has SP-analysis been performed?



   .. py:method:: need_prolog_analysis() -> bool

      Needs prolog analysis?



   .. py:attribute:: frame
      :type:  int

      netnode id of frame structure - see frame.hpp



   .. py:attribute:: frsize
      :type:  asize_t

      size of local variables part of frame in bytes. If FUNC_FRAME is set and fpd==0, the frame pointer (EBP) is assumed to point to the top of the local variables range. 
              



   .. py:attribute:: frregs
      :type:  ushort

      size of saved registers in frame. This range is immediately above the local variables range. 
              



   .. py:attribute:: argsize
      :type:  asize_t

      number of bytes purged from the stack upon returning 
              



   .. py:attribute:: fpd
      :type:  asize_t

      frame pointer delta. (usually 0, i.e. realBP==typicalBP) use update_fpd() to modify it. 
              



   .. py:attribute:: color
      :type:  bgcolor_t

      user defined function color



   .. py:attribute:: pntqty
      :type:  int

      number of SP change points



   .. py:attribute:: points
      :type:  stkpnt_t *

      array of SP change points. use ...stkpnt...() functions to access this array. 
              



   .. py:attribute:: regvarqty
      :type:  int

      number of register variables (-1-not read in yet) use find_regvar() to read register variables 
              



   .. py:attribute:: regvars
      :type:  regvar_t *

      array of register variables. this array is sorted by: start_ea. use ...regvar...() functions to access this array. 
              



   .. py:attribute:: regargqty
      :type:  int

      number of register arguments. During analysis IDA tries to guess the register arguments. It stores store the guessing outcome in this field. As soon as it determines the final function prototype, regargqty is set to zero. 
              



   .. py:attribute:: regargs
      :type:  regarg_t *

      unsorted array of register arguments. use ...regarg...() functions to access this array. regargs are destroyed when the full function type is determined. 
              



   .. py:attribute:: tailqty
      :type:  int

      number of function tails



   .. py:attribute:: tails
      :type:  range_t *

      array of tails, sorted by ea. use func_tail_iterator_t to access function tails. 
              



   .. py:attribute:: owner
      :type:  ida_idaapi.ea_t

      the address of the main function possessing this tail



   .. py:attribute:: refqty
      :type:  int

      number of referers



   .. py:attribute:: referers
      :type:  ea_t *

      array of referers (function start addresses). use func_parent_iterator_t to access the referers. 
              



   .. py:method:: addresses()

      Alias for func_item_iterator_t(self).addresses()



   .. py:method:: code_items()

      Alias for func_item_iterator_t(self).code_items()



   .. py:method:: data_items()

      Alias for func_item_iterator_t(self).data_items()



   .. py:method:: head_items()

      Alias for func_item_iterator_t(self).head_items()



   .. py:method:: not_tails()

      Alias for func_item_iterator_t(self).not_tails()



   .. py:method:: get_frame_object()

      Retrieve the function frame, in the form of a structure
      where frame offsets that are accessed by the program, as well
      as areas for "saved registers" and "return address", are
      represented by structure members.

      If the function has no associated frame, return None

      :returns: a ida_typeinf.tinfo_t object representing the frame, or None



   .. py:method:: get_name()

      Get the function name

      :returns: the function name



   .. py:method:: get_prototype()

      Retrieve the function prototype.

      Once you have obtained the prototype, you can:

      * retrieve the return type through ida_typeinf.tinfo_t.get_rettype()
      * iterate on the arguments using ida_typeinf.tinfo_t.iter_func()

      If the function has no associated prototype, return None

      :returns: a ida_typeinf.tinfo_t object representing the prototype, or None



   .. py:attribute:: frame_object


   .. py:attribute:: name


   .. py:attribute:: prototype


.. py:data:: FUNC_NORET

   Function doesn't return.


.. py:data:: FUNC_FAR

   Far function.


.. py:data:: FUNC_LIB

   Library function.


.. py:data:: FUNC_STATICDEF

   Static function.


.. py:data:: FUNC_FRAME

   Function uses frame pointer (BP)


.. py:data:: FUNC_USERFAR

   User has specified far-ness of the function 
           


.. py:data:: FUNC_HIDDEN

   A hidden function chunk.


.. py:data:: FUNC_THUNK

   Thunk (jump) function.


.. py:data:: FUNC_BOTTOMBP

   BP points to the bottom of the stack frame.


.. py:data:: FUNC_NORET_PENDING

   Function 'non-return' analysis must be performed. This flag is verified upon func_does_return() 
           


.. py:data:: FUNC_SP_READY

   SP-analysis has been performed. If this flag is on, the stack change points should not be not modified anymore. Currently this analysis is performed only for PC 
           


.. py:data:: FUNC_FUZZY_SP

   Function changes SP in untraceable way, for example: and esp, 0FFFFFFF0h 
           


.. py:data:: FUNC_PROLOG_OK

   Prolog analysis has been performed by last SP-analysis 
           


.. py:data:: FUNC_PURGED_OK

   'argsize' field has been validated. If this bit is clear and 'argsize' is 0, then we do not known the real number of bytes removed from the stack. This bit is handled by the processor module. 
           


.. py:data:: FUNC_TAIL

   This is a function tail. Other bits must be clear (except FUNC_HIDDEN). 
           


.. py:data:: FUNC_LUMINA

   Function info is provided by Lumina.


.. py:data:: FUNC_OUTLINE

   Outlined code, not a real function.


.. py:data:: FUNC_REANALYZE

   Function frame changed, request to reanalyze the function after the last insn is analyzed. 
           


.. py:data:: FUNC_UNWIND

   function is an exception unwind handler


.. py:data:: FUNC_CATCH

   function is an exception catch handler


.. py:function:: is_func_entry(pfn: func_t) -> bool

   Does function describe a function entry chunk?


.. py:function:: is_func_tail(pfn: func_t) -> bool

   Does function describe a function tail chunk?


.. py:function:: lock_func_range(pfn: func_t, lock: bool) -> None

   Lock function pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers cannot be deleted or moved. 
           


.. py:class:: lock_func(_pfn: func_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:class:: lock_func_with_tails_t(pfn: func_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:function:: is_func_locked(pfn: func_t) -> bool

   Is the function pointer locked?


.. py:function:: get_func(ea: ida_idaapi.ea_t) -> func_t *

   Get pointer to function structure by address. 
           
   :param ea: any address in a function
   :returns: ptr to a function or nullptr. This function returns a function entry chunk.


.. py:function:: get_func_chunknum(pfn: func_t, ea: ida_idaapi.ea_t) -> int

   Get the containing tail chunk of 'ea'. 
           
   :returns: -1: means 'does not contain ea'
   :returns: 0: means the 'pfn' itself contains ea
   :returns: >0: the number of the containing function tail chunk


.. py:function:: func_contains(pfn: func_t, ea: ida_idaapi.ea_t) -> bool

   Does the given function contain the given address?


.. py:function:: is_same_func(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool

   Do two addresses belong to the same function?


.. py:function:: getn_func(n: size_t) -> func_t *

   Get pointer to function structure by number. 
           
   :param n: number of function, is in range 0..get_func_qty()-1
   :returns: ptr to a function or nullptr. This function returns a function entry chunk.


.. py:function:: get_func_qty() -> size_t

   Get total number of functions in the program.


.. py:function:: get_func_num(ea: ida_idaapi.ea_t) -> int

   Get ordinal number of a function. 
           
   :param ea: any address in the function
   :returns: number of function (0..get_func_qty()-1). -1 means 'no function at the specified address'.


.. py:function:: get_prev_func(ea: ida_idaapi.ea_t) -> func_t *

   Get pointer to the previous function. 
           
   :param ea: any address in the program
   :returns: ptr to function or nullptr if previous function doesn't exist


.. py:function:: get_next_func(ea: ida_idaapi.ea_t) -> func_t *

   Get pointer to the next function. 
           
   :param ea: any address in the program
   :returns: ptr to function or nullptr if next function doesn't exist


.. py:function:: get_func_ranges(ranges: rangeset_t, pfn: func_t) -> ida_idaapi.ea_t

   Get function ranges. 
           
   :param ranges: buffer to receive the range info
   :param pfn: ptr to function structure
   :returns: end address of the last function range (BADADDR-error)


.. py:function:: get_func_cmt(pfn: func_t, repeatable: bool) -> str

   Get function comment. 
           
   :param pfn: ptr to function structure
   :param repeatable: get repeatable comment?
   :returns: size of comment or -1 In fact this function works with function chunks too.


.. py:function:: set_func_cmt(pfn: func_t, cmt: str, repeatable: bool) -> bool

   Set function comment. This function works with function chunks too. 
           
   :param pfn: ptr to function structure
   :param cmt: comment string, may be multiline (with '
   '). Use empty str ("") to delete comment
   :param repeatable: set repeatable comment?


.. py:function:: update_func(pfn: func_t) -> bool

   Update information about a function in the database (func_t). You must not change the function start and end addresses using this function. Use set_func_start() and set_func_end() for it. 
           
   :param pfn: ptr to function structure
   :returns: success


.. py:function:: add_func_ex(pfn: func_t) -> bool

   Add a new function. If the fn->end_ea is BADADDR, then IDA will try to determine the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE). 
           
   :param pfn: ptr to filled function structure
   :returns: success


.. py:function:: add_func(*args) -> bool

   Add a new function. If the function end address is BADADDR, then IDA will try to determine the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE). 
           
   :param ea1: start address
   :param ea2: end address
   :returns: success


.. py:function:: del_func(ea: ida_idaapi.ea_t) -> bool

   Delete a function. 
           
   :param ea: any address in the function entry chunk
   :returns: success


.. py:function:: set_func_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t) -> int

   Move function chunk start address. 
           
   :param ea: any address in the function
   :param newstart: new end address of the function
   :returns: Function move result codes


.. py:data:: MOVE_FUNC_OK

   ok


.. py:data:: MOVE_FUNC_NOCODE

   no instruction at 'newstart'


.. py:data:: MOVE_FUNC_BADSTART

   bad new start address


.. py:data:: MOVE_FUNC_NOFUNC

   no function at 'ea'


.. py:data:: MOVE_FUNC_REFUSED

   a plugin refused the action


.. py:function:: set_func_end(ea: ida_idaapi.ea_t, newend: ida_idaapi.ea_t) -> bool

   Move function chunk end address. 
           
   :param ea: any address in the function
   :param newend: new end address of the function
   :returns: success


.. py:function:: reanalyze_function(*args) -> None

   Reanalyze a function. This function plans to analyzes all chunks of the given function. Optional parameters (ea1, ea2) may be used to narrow the analyzed range. 
           
   :param pfn: pointer to a function
   :param ea1: start of the range to analyze
   :param ea2: end of range to analyze
   :param analyze_parents: meaningful only if pfn points to a function tail. if true, all tail parents will be reanalyzed. if false, only the given tail will be reanalyzed.


.. py:function:: find_func_bounds(nfn: func_t, flags: int) -> int

   Determine the boundaries of a new function. This function tries to find the start and end addresses of a new function. It calls the module with processor_t::func_bounds in order to fine tune the function boundaries. 
           
   :param nfn: structure to fill with information \ nfn->start_ea points to the start address of the new function.
   :param flags: Find function bounds flags
   :returns: Find function bounds result codes


.. py:data:: FIND_FUNC_NORMAL

   stop processing if undefined byte is encountered


.. py:data:: FIND_FUNC_DEFINE

   create instruction if undefined byte is encountered


.. py:data:: FIND_FUNC_IGNOREFN

   ignore existing function boundaries. by default the function returns function boundaries if ea belongs to a function. 
           


.. py:data:: FIND_FUNC_KEEPBD

   do not modify incoming function boundaries, just create instructions inside the boundaries. 
           


.. py:data:: FIND_FUNC_UNDEF

   function has instructions that pass execution flow to unexplored bytes. nfn->end_ea will have the address of the unexplored byte. 
           


.. py:data:: FIND_FUNC_OK

   ok, 'nfn' is ready for add_func()


.. py:data:: FIND_FUNC_EXIST

   function exists already. its bounds are returned in 'nfn'. 
           


.. py:function:: get_func_name(ea: ida_idaapi.ea_t) -> str

   Get function name. 
           
   :param ea: any address in the function
   :returns: length of the function name


.. py:function:: calc_func_size(pfn: func_t) -> asize_t

   Calculate function size. This function takes into account all fragments of the function. 
           
   :param pfn: ptr to function structure


.. py:function:: get_func_bitness(pfn: func_t) -> int

   Get function bitness (which is equal to the function segment bitness). pfn==nullptr => returns 0 
           
   :returns: 0: 16
   :returns: 1: 32
   :returns: 2: 64


.. py:function:: get_func_bits(pfn: func_t) -> int

   Get number of bits in the function addressing.


.. py:function:: get_func_bytes(pfn: func_t) -> int

   Get number of bytes in the function addressing.


.. py:function:: is_visible_func(pfn: func_t) -> bool

   Is the function visible (not hidden)?


.. py:function:: is_finally_visible_func(pfn: func_t) -> bool

   Is the function visible (event after considering SCF_SHHID_FUNC)?


.. py:function:: set_visible_func(pfn: func_t, visible: bool) -> None

   Set visibility of function.


.. py:function:: set_func_name_if_jumpfunc(pfn: func_t, oldname: str) -> int

   Give a meaningful name to function if it consists of only 'jump' instruction. 
           
   :param pfn: pointer to function (may be nullptr)
   :param oldname: old name of function. if old name was in "j_..." form, then we may discard it and set a new name. if oldname is not known, you may pass nullptr.
   :returns: success


.. py:function:: calc_thunk_func_target(pfn: func_t) -> ea_t *

   Calculate target of a thunk function. 
           
   :param pfn: pointer to function (may not be nullptr)
   :returns: the target function or BADADDR


.. py:function:: func_does_return(callee: ida_idaapi.ea_t) -> bool

   Does the function return?. To calculate the answer, FUNC_NORET flag and is_noret() are consulted The latter is required for imported functions in the .idata section. Since in .idata we have only function pointers but not functions, we have to introduce a special flag for them. 
           


.. py:function:: reanalyze_noret_flag(ea: ida_idaapi.ea_t) -> bool

   Plan to reanalyze noret flag. This function does not remove FUNC_NORET if it is already present. It just plans to reanalysis. 
           


.. py:function:: set_noret_insn(insn_ea: ida_idaapi.ea_t, noret: bool) -> bool

   Signal a non-returning instruction. This function can be used by the processor module to tell the kernel about non-returning instructions (like call exit). The kernel will perform the global function analysis and find out if the function returns at all. This analysis will be done at the first call to func_does_return() 
           
   :returns: true if the instruction 'noret' flag has been changed


.. py:function:: get_fchunk(ea: ida_idaapi.ea_t) -> func_t *

   Get pointer to function chunk structure by address. 
           
   :param ea: any address in a function chunk
   :returns: ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail.


.. py:function:: getn_fchunk(n: int) -> func_t *

   Get pointer to function chunk structure by number. 
           
   :param n: number of function chunk, is in range 0..get_fchunk_qty()-1
   :returns: ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail.


.. py:function:: get_fchunk_qty() -> size_t

   Get total number of function chunks in the program.


.. py:function:: get_fchunk_num(ea: ida_idaapi.ea_t) -> int

   Get ordinal number of a function chunk in the global list of function chunks. 
           
   :param ea: any address in the function chunk
   :returns: number of function chunk (0..get_fchunk_qty()-1). -1 means 'no function chunk at the specified address'.


.. py:function:: get_prev_fchunk(ea: ida_idaapi.ea_t) -> func_t *

   Get pointer to the previous function chunk in the global list. 
           
   :param ea: any address in the program
   :returns: ptr to function chunk or nullptr if previous function chunk doesn't exist


.. py:function:: get_next_fchunk(ea: ida_idaapi.ea_t) -> func_t *

   Get pointer to the next function chunk in the global list. 
           
   :param ea: any address in the program
   :returns: ptr to function chunk or nullptr if next function chunk doesn't exist


.. py:function:: append_func_tail(pfn: func_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool

   Append a new tail chunk to the function definition. If the tail already exists, then it will simply be added to the function tail list Otherwise a new tail will be created and its owner will be set to be our function If a new tail cannot be created, then this function will fail. 
           
   :param pfn: pointer to the function
   :param ea1: start of the tail. If a tail already exists at the specified address it must start at 'ea1'
   :param ea2: end of the tail. If a tail already exists at the specified address it must end at 'ea2'. If specified as BADADDR, IDA will determine the end address itself.


.. py:function:: remove_func_tail(pfn: func_t, tail_ea: ida_idaapi.ea_t) -> bool

   Remove a function tail. If the tail belongs only to one function, it will be completely removed. Otherwise if the function was the tail owner, the first function using this tail becomes the owner of the tail. 
           
   :param pfn: pointer to the function
   :param tail_ea: any address inside the tail to remove


.. py:function:: set_tail_owner(fnt: func_t, new_owner: ida_idaapi.ea_t) -> bool

   Set a new owner of a function tail. The new owner function must be already referring to the tail (after append_func_tail). 
           
   :param fnt: pointer to the function tail
   :param new_owner: the entry point of the new owner function


.. py:function:: func_tail_iterator_set(fti: func_tail_iterator_t, pfn: func_t, ea: ida_idaapi.ea_t) -> bool

.. py:function:: func_tail_iterator_set_ea(fti: func_tail_iterator_t, ea: ida_idaapi.ea_t) -> bool

.. py:function:: func_parent_iterator_set(fpi: func_parent_iterator_t, pfn: func_t) -> bool

.. py:function:: f_any(arg1: flags64_t, arg2: void *) -> bool

   Helper function to accept any address.


.. py:class:: func_tail_iterator_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: set(*args) -> bool


   .. py:method:: set_ea(ea: ida_idaapi.ea_t) -> bool


   .. py:method:: set_range(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool


   .. py:method:: chunk() -> range_t const &


   .. py:method:: first() -> bool


   .. py:method:: last() -> bool


   .. py:method:: prev() -> bool


   .. py:method:: main() -> bool


   .. py:attribute:: next


.. py:class:: func_item_iterator_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: set(*args) -> bool

      Set a function range. if pfn == nullptr then a segment range will be set.



   .. py:method:: set_range(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool

      Set an arbitrary range.



   .. py:method:: first() -> bool


   .. py:method:: last() -> bool


   .. py:method:: current() -> ida_idaapi.ea_t


   .. py:method:: set_ea(_ea: ida_idaapi.ea_t) -> bool


   .. py:method:: chunk() -> range_t const &


   .. py:method:: prev(func: testf_t *) -> bool


   .. py:method:: next_addr() -> bool


   .. py:method:: next_head() -> bool


   .. py:method:: next_code() -> bool


   .. py:method:: next_data() -> bool


   .. py:method:: next_not_tail() -> bool


   .. py:method:: prev_addr() -> bool


   .. py:method:: prev_head() -> bool


   .. py:method:: prev_code() -> bool


   .. py:method:: prev_data() -> bool


   .. py:method:: prev_not_tail() -> bool


   .. py:method:: decode_prev_insn(out: insn_t *) -> bool


   .. py:method:: decode_preceding_insn(visited: eavec_t *, p_farref: bool *, out: insn_t *) -> bool


   .. py:method:: succ(func: testf_t *) -> bool

      Similar to next(), but succ() iterates the chunks from low to high addresses, while next() iterates through chunks starting at the function entry chunk 
              



   .. py:method:: succ_code() -> bool


   .. py:attribute:: next


   .. py:method:: addresses()

      Provide an iterator on addresses contained within the function



   .. py:method:: code_items()

      Provide an iterator on code items contained within the function



   .. py:method:: data_items()

      Provide an iterator on data items contained within the function



   .. py:method:: head_items()

      Provide an iterator on item heads contained within the function



   .. py:method:: not_tails()

      Provide an iterator on non-tail addresses contained within the function



.. py:class:: func_parent_iterator_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: set(_fnt: func_t) -> bool


   .. py:method:: parent() -> ida_idaapi.ea_t


   .. py:method:: first() -> bool


   .. py:method:: last() -> bool


   .. py:method:: prev() -> bool


   .. py:method:: reset_fnt(_fnt: func_t) -> None


   .. py:attribute:: next


.. py:function:: get_prev_func_addr(pfn: func_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: get_next_func_addr(pfn: func_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: read_regargs(pfn: func_t) -> None

.. py:function:: add_regarg(pfn: func_t, reg: int, tif: tinfo_t, name: str) -> None

.. py:data:: IDASGN_OK

   ok


.. py:data:: IDASGN_BADARG

   bad number of signature


.. py:data:: IDASGN_APPLIED

   signature is already applied


.. py:data:: IDASGN_CURRENT

   signature is currently being applied


.. py:data:: IDASGN_PLANNED

   signature is planned to be applied


.. py:function:: plan_to_apply_idasgn(fname: str) -> int

   Add a signature file to the list of planned signature files. 
           
   :param fname: file name. should not contain directory part.
   :returns: 0 if failed, otherwise number of planned (and applied) signatures


.. py:function:: apply_idasgn_to(signame: str, ea: ida_idaapi.ea_t, is_startup: bool) -> int

   Apply a signature file to the specified address. 
           
   :param signame: short name of signature file (the file name without path)
   :param ea: address to apply the signature
   :param is_startup: if set, then the signature is treated as a startup one for startup signature ida doesn't rename the first function of the applied module.
   :returns: Library function codes


.. py:function:: get_idasgn_qty() -> int

   Get number of signatures in the list of planned and applied signatures. 
           
   :returns: 0..n


.. py:function:: get_current_idasgn() -> int

   Get number of the the current signature. 
           
   :returns: 0..n-1


.. py:function:: calc_idasgn_state(n: int) -> int

   Get state of a signature in the list of planned signatures 
           
   :param n: number of signature in the list (0..get_idasgn_qty()-1)
   :returns: state of signature or IDASGN_BADARG


.. py:function:: del_idasgn(n: int) -> int

   Remove signature from the list of planned signatures. 
           
   :param n: number of signature in the list (0..get_idasgn_qty()-1)
   :returns: IDASGN_OK, IDASGN_BADARG, IDASGN_APPLIED


.. py:function:: get_idasgn_title(name: str) -> str

   Get full description of the signature by its short name. 
           
   :param name: short name of a signature
   :returns: size of signature description or -1


.. py:function:: apply_startup_sig(ea: ida_idaapi.ea_t, startup: str) -> bool

   Apply a startup signature file to the specified address. 
           
   :param ea: address to apply the signature to; usually idainfo::start_ea
   :param startup: the name of the signature file without path and extension
   :returns: true if successfully applied the signature


.. py:function:: try_to_add_libfunc(ea: ida_idaapi.ea_t) -> int

   Apply the currently loaded signature file to the specified address. If a library function is found, then create a function and name it accordingly. 
           
   :param ea: any address in the program
   :returns: Library function codes


.. py:data:: LIBFUNC_FOUND

   ok, library function is found


.. py:data:: LIBFUNC_NONE

   no, this is not a library function


.. py:data:: LIBFUNC_DELAY

   no decision because of lack of information


.. py:function:: get_fchunk_referer(ea: int, idx)

.. py:function:: get_idasgn_desc(n)

   Get information about a signature in the list.
   It returns: (name of signature, names of optional libraries)

   See also: get_idasgn_desc_with_matches

   :param n: number of signature in the list (0..get_idasgn_qty()-1)
   :returns: None on failure or tuple(signame, optlibs)


.. py:function:: get_idasgn_desc_with_matches(n)

   Get information about a signature in the list.
   It returns: (name of signature, names of optional libraries, number of matches)

   :param n: number of signature in the list (0..get_idasgn_qty()-1)
   :returns: None on failure or tuple(signame, optlibs, nmatches)


.. py:function:: func_t__from_ptrval__(ptrval: size_t) -> func_t *

.. py:function:: calc_thunk_func_target(*args)

   Calculate target of a thunk function. 
           
   :param pfn: pointer to function (may not be nullptr)
   :param fptr: out: will hold address of a function pointer (if indirect jump)
   :returns: the target function or BADADDR



```

`skills/idapython/docs/ida_gdl.md`:

```md
# ida_gdl

Low level graph drawing operations - flow charts and call graphs.

## Key Classes

### FlowChart
Pythonic flowchart class for determining basic blocks.
- `FlowChart(f, bounds, flags)` - Create flow chart for function
- `size` - Number of blocks in flow chart
- `refresh()` - Refresh flow chart
- Iterate blocks directly: `for bb in fc: ...`

### BasicBlock
Basic block within a flowchart.
- `id` - Block number
- `start_ea`, `end_ea` - Address range
- `type` - Block type (fcb_normal, fcb_ret, fcb_noret, etc.)
- `preds()` - Iterator over predecessor blocks
- `succs()` - Iterator over successor blocks

### qflow_chart_t
Low-level flow chart builder (use FlowChart instead for Python).
- `create(title, pfn, ea1, ea2, flags)` - Build flow chart
- `nsucc(node)`, `npred(node)` - Successor/predecessor counts
- `succ(node, i)`, `pred(node, i)` - Get nth successor/predecessor

## Key Functions

- `gen_flow_graph(filename, title, pfn, ea1, ea2, gflags)` - Generate flow graph to .dot/.gdl
- `gen_simple_call_chart(filename, wait, title, gflags)` - Simple call graph
- `is_ret_block(btype)` - Check if block returns
- `is_noret_block(btype)` - Check if block never returns

## Constants

**Block types**: fcb_normal, fcb_indjump, fcb_ret, fcb_cndret, fcb_noret, fcb_enoret, fcb_extern, fcb_error

**Flow chart flags**: FC_NOEXT (no external blocks), FC_CALL_ENDS (calls end blocks), FC_NOPREDS (skip predecessors)

**Chart generation**: CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH, CHART_NOLIBFUNCS

## See Also
Full docs: skill/docs/ida_gdl.rst

```

`skills/idapython/docs/ida_gdl.rst`:

```rst
ida_gdl
=======

.. py:module:: ida_gdl

.. autoapi-nested-parse::

   Low level graph drawing operations.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For graph operations, see :mod:`ida_domain.functions`.



Attributes
----------

.. autoapisummary::

   ida_gdl.fcb_normal
   ida_gdl.fcb_indjump
   ida_gdl.fcb_ret
   ida_gdl.fcb_cndret
   ida_gdl.fcb_noret
   ida_gdl.fcb_enoret
   ida_gdl.fcb_extern
   ida_gdl.fcb_error
   ida_gdl.EDGE_NONE
   ida_gdl.EDGE_TREE
   ida_gdl.EDGE_FORWARD
   ida_gdl.EDGE_BACK
   ida_gdl.EDGE_CROSS
   ida_gdl.EDGE_SUBGRAPH
   ida_gdl.CHART_PRINT_NAMES
   ida_gdl.CHART_GEN_DOT
   ida_gdl.CHART_GEN_GDL
   ida_gdl.CHART_WINGRAPH
   ida_gdl.CHART_NOLIBFUNCS
   ida_gdl.CHART_REFERENCING
   ida_gdl.CHART_REFERENCED
   ida_gdl.CHART_RECURSIVE
   ida_gdl.CHART_FOLLOW_DIRECTION
   ida_gdl.CHART_IGNORE_XTRN
   ida_gdl.CHART_IGNORE_DATA_BSS
   ida_gdl.CHART_IGNORE_LIB_TO
   ida_gdl.CHART_IGNORE_LIB_FROM
   ida_gdl.CHART_PRINT_COMMENTS
   ida_gdl.CHART_PRINT_DOTS
   ida_gdl.FC_PRINT
   ida_gdl.FC_NOEXT
   ida_gdl.FC_RESERVED
   ida_gdl.FC_APPND
   ida_gdl.FC_CHKBREAK
   ida_gdl.FC_CALL_ENDS
   ida_gdl.FC_NOPREDS
   ida_gdl.FC_OUTLINES
   ida_gdl.FC_PREDS


Classes
-------

.. autoapisummary::

   ida_gdl.edge_t
   ida_gdl.edgevec_t
   ida_gdl.node_ordering_t
   ida_gdl.node_iterator
   ida_gdl.gdl_graph_t
   ida_gdl.cancellable_graph_t
   ida_gdl.qbasic_block_t
   ida_gdl.qflow_chart_t
   ida_gdl.BasicBlock
   ida_gdl.FlowChart


Functions
---------

.. autoapisummary::

   ida_gdl.gen_gdl
   ida_gdl.display_gdl
   ida_gdl.gen_flow_graph
   ida_gdl.gen_simple_call_chart
   ida_gdl.gen_complex_call_chart
   ida_gdl.is_noret_block
   ida_gdl.is_ret_block


Module Contents
---------------

.. py:data:: fcb_normal

   normal block


.. py:data:: fcb_indjump

   block ends with indirect jump


.. py:data:: fcb_ret

   return block


.. py:data:: fcb_cndret

   conditional return block


.. py:data:: fcb_noret

   noreturn block


.. py:data:: fcb_enoret

   external noreturn block (does not belong to the function)


.. py:data:: fcb_extern

   external normal block


.. py:data:: fcb_error

   block passes execution past the function end


.. py:class:: edge_t(x: int = 0, y: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: src
      :type:  int

      source node number



   .. py:attribute:: dst
      :type:  int

      destination node number



.. py:class:: edgevec_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:data:: EDGE_NONE

.. py:data:: EDGE_TREE

.. py:data:: EDGE_FORWARD

.. py:data:: EDGE_BACK

.. py:data:: EDGE_CROSS

.. py:data:: EDGE_SUBGRAPH

.. py:class:: node_ordering_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: clear() -> None


   .. py:method:: resize(n: int) -> None


   .. py:method:: size() -> size_t


   .. py:method:: set(_node: int, num: int) -> None


   .. py:method:: clr(_node: int) -> bool


   .. py:method:: node(_order: size_t) -> int


   .. py:method:: order(_node: int) -> int


.. py:class:: node_iterator(_g: gdl_graph_t, n: int)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:class:: gdl_graph_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: get_node_label(n: int) -> char *


   .. py:method:: print_graph_attributes(fp: FILE *) -> None


   .. py:method:: print_node(fp: FILE *, n: int) -> bool


   .. py:method:: print_edge(fp: FILE *, i: int, j: int) -> bool


   .. py:method:: print_node_attributes(fp: FILE *, n: int) -> None


   .. py:method:: size() -> int


   .. py:method:: node_qty() -> int


   .. py:method:: exists(node: int) -> bool


   .. py:method:: entry() -> int


   .. py:method:: exit() -> int


   .. py:method:: nsucc(node: int) -> int


   .. py:method:: npred(node: int) -> int


   .. py:method:: succ(node: int, i: int) -> int


   .. py:method:: pred(node: int, i: int) -> int


   .. py:method:: empty() -> bool


   .. py:method:: get_node_color(n: int) -> bgcolor_t


   .. py:method:: get_edge_color(i: int, j: int) -> bgcolor_t


   .. py:method:: nedge(node: int, ispred: bool) -> size_t


   .. py:method:: edge(node: int, i: int, ispred: bool) -> int


   .. py:method:: front() -> int


   .. py:method:: begin() -> node_iterator


   .. py:method:: end() -> node_iterator


.. py:function:: gen_gdl(g: gdl_graph_t, fname: str) -> None

   Create GDL file for graph.


.. py:function:: display_gdl(fname: str) -> int

   Display GDL file by calling wingraph32. The exact name of the grapher is taken from the configuration file and set up by setup_graph_subsystem(). The path should point to a temporary file: when wingraph32 succeeds showing the graph, the input file will be deleted. 
           
   :returns: error code from os, 0 if ok


.. py:function:: gen_flow_graph(filename: str, title: str, pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, gflags: int) -> bool

   Build and display a flow graph. 
           
   :param filename: output file name. the file extension is not used. maybe nullptr.
   :param title: graph title
   :param pfn: function to graph
   :param ea1: if pfn == nullptr, then the address range
   :param ea2: if pfn == nullptr, then the address range
   :param gflags: combination of Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false
   :returns: success. if fails, a warning message is displayed on the screen


.. py:data:: CHART_PRINT_NAMES

   print labels for each block?


.. py:data:: CHART_GEN_DOT

   generate .dot file (file extension is forced to .dot)


.. py:data:: CHART_GEN_GDL

   generate .gdl file (file extension is forced to .gdl)


.. py:data:: CHART_WINGRAPH

   call grapher to display the graph


.. py:function:: gen_simple_call_chart(filename: str, wait: str, title: str, gflags: int) -> bool

   Build and display a simple function call graph. 
           
   :param filename: output file name. the file extension is not used. maybe nullptr.
   :param wait: message to display during graph building
   :param title: graph title
   :param gflags: combination of CHART_NOLIBFUNCS and Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false.
   :returns: success. if fails, a warning message is displayed on the screen


.. py:function:: gen_complex_call_chart(filename: str, wait: str, title: str, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, flags: int, recursion_depth: int = -1) -> bool

   Build and display a complex xref graph. 
           
   :param filename: output file name. the file extension is not used. maybe nullptr.
   :param wait: message to display during graph building
   :param title: graph title
   :param ea1: address range
   :param ea2: address range
   :param flags: combination of Call chart building flags and Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false.
   :param recursion_depth: optional limit of recursion
   :returns: success. if fails, a warning message is displayed on the screen


.. py:data:: CHART_NOLIBFUNCS

   don't include library functions in the graph


.. py:data:: CHART_REFERENCING

   references to the addresses in the list


.. py:data:: CHART_REFERENCED

   references from the addresses in the list


.. py:data:: CHART_RECURSIVE

   analyze added blocks


.. py:data:: CHART_FOLLOW_DIRECTION

   analyze references to added blocks only in the direction of the reference who discovered the current block


.. py:data:: CHART_IGNORE_XTRN

.. py:data:: CHART_IGNORE_DATA_BSS

.. py:data:: CHART_IGNORE_LIB_TO

   ignore references to library functions


.. py:data:: CHART_IGNORE_LIB_FROM

   ignore references from library functions


.. py:data:: CHART_PRINT_COMMENTS

.. py:data:: CHART_PRINT_DOTS

   print dots if xrefs exist outside of the range recursion depth


.. py:class:: cancellable_graph_t

   Bases: :py:obj:`gdl_graph_t`


   .. py:attribute:: thisown


   .. py:attribute:: cancelled
      :type:  bool


.. py:class:: qbasic_block_t

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


.. py:function:: is_noret_block(btype: fc_block_type_t) -> bool

   Does this block never return?


.. py:function:: is_ret_block(btype: fc_block_type_t) -> bool

   Does this block return?


.. py:data:: FC_PRINT

   print names (used only by display_flow_chart())


.. py:data:: FC_NOEXT

   do not compute external blocks. Use this to prevent jumps leaving the function from appearing in the flow chart. Unless specified, the targets of those outgoing jumps will be present in the flow chart under the form of one-instruction blocks 
           


.. py:data:: FC_RESERVED

   former FC_PREDS


.. py:data:: FC_APPND

   multirange flowchart (set by append_to_flowchart)


.. py:data:: FC_CHKBREAK

   build_qflow_chart() may be aborted by user


.. py:data:: FC_CALL_ENDS

   call instructions terminate basic blocks


.. py:data:: FC_NOPREDS

   do not compute predecessor lists


.. py:data:: FC_OUTLINES

   include outlined code (with FUNC_OUTLINE)


.. py:class:: qflow_chart_t(*args)

   Bases: :py:obj:`cancellable_graph_t`


   .. py:attribute:: thisown


   .. py:attribute:: title
      :type:  str


   .. py:attribute:: bounds
      :type:  range_t

      overall bounds of the qflow_chart_t instance



   .. py:attribute:: pfn
      :type:  func_t *

      the function this instance was built upon



   .. py:attribute:: flags
      :type:  int

      flags. See Flow chart flags



   .. py:attribute:: nproper
      :type:  int

      number of basic blocks belonging to the specified range



   .. py:method:: create(*args) -> None

      This function has the following signatures:

          0. create(_title: str, _pfn: func_t *, _ea1: ida_idaapi.ea_t, _ea2: ida_idaapi.ea_t, _flags: int) -> None
          1. create(_title: str, ranges: const rangevec_t &, _flags: int) -> None

      # 0: create(_title: str, _pfn: func_t *, _ea1: ida_idaapi.ea_t, _ea2: ida_idaapi.ea_t, _flags: int) -> None


      # 1: create(_title: str, ranges: const rangevec_t &, _flags: int) -> None



   .. py:method:: append_to_flowchart(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None


   .. py:method:: refresh() -> None


   .. py:method:: calc_block_type(blknum: size_t) -> fc_block_type_t


   .. py:method:: is_ret_block(blknum: size_t) -> bool


   .. py:method:: is_noret_block(blknum: size_t) -> bool


   .. py:method:: print_node_attributes(fp: FILE *, n: int) -> None


   .. py:method:: nsucc(node: int) -> int


   .. py:method:: npred(node: int) -> int


   .. py:method:: succ(node: int, i: int) -> int


   .. py:method:: pred(node: int, i: int) -> int


   .. py:method:: get_node_label(*args) -> char *


   .. py:method:: size() -> int


   .. py:method:: print_names() -> bool


.. py:class:: BasicBlock(id, bb, fc)

   Bases: :py:obj:`object`


   Basic block class. It is returned by the Flowchart class


   .. py:attribute:: id

      Basic block ID



   .. py:attribute:: start_ea

      start_ea of basic block



   .. py:attribute:: end_ea

      end_ea of basic block



   .. py:attribute:: type

      Block type (check fc_block_type_t enum)



   .. py:method:: preds()

      Iterates the predecessors list



   .. py:method:: succs()

      Iterates the successors list



.. py:class:: FlowChart(f=None, bounds=None, flags=0)

   Bases: :py:obj:`object`


   Flowchart class used to determine basic blocks.
   Check ex_gdl_qflow_chart.py for sample usage.


   .. py:attribute:: size

      Number of blocks in the flow chart



   .. py:method:: refresh()

      Refreshes the flow chart



.. py:data:: FC_PREDS
   :value: 0



```

`skills/idapython/docs/ida_graph.md`:

```md
# ida_graph

Graph view management - custom graph visualization and interaction (medium priority for typical reverse engineering).

## Key Classes

### GraphViewer
Pythonic class for creating custom graph views.
- Override `OnRefresh()` - Populate graph nodes/edges
- Override `OnGetText(node)` - Get node display text
- Override `OnDblClick(node)` - Handle double-click
- Override `OnClick(node)` - Handle single-click
- `Show()` - Display graph viewer
- `Close()` - Close graph viewer

### interactive_graph_t
Low-level interactive graph implementation (use GraphViewer instead for Python).

### mutable_graph_t
Abstract graph structure for manipulation.
- `create_mutable_graph()` - Create new graph
- `delete_mutable_graph(g)` - Delete graph

## Key Functions

### Graph Creation
- `create_graph_viewer(title, gid, callback)` - Create graph viewer widget
- `create_interactive_graph(title)` - Create interactive graph
- `create_disasm_graph(ea)` - Create disassembly graph at address

### Graph Manipulation
- `get_node_info(graph, node)` - Get node display info (color, text, etc.)
- `set_node_info(graph, node, info, flags)` - Set node properties
- `del_node_info(graph, node)` - Delete node info
- `viewer_set_node_info(viewer, node, info, flags)` - Set node info in viewer

### Graph Navigation
- `viewer_get_curnode(viewer)` - Get currently selected node
- `viewer_center_on(viewer, node)` - Center view on node
- `viewer_fit_window(viewer)` - Zoom to fit
- `viewer_get_selection(viewer)` - Get selected items

### Graph Groups
- `viewer_create_groups(viewer, groups)` - Create node groups
- `viewer_delete_groups(viewer, groups)` - Delete groups
- `viewer_set_groups_visibility(viewer, groups, visible)` - Show/hide groups

## Constants

**Node info flags**: NIF_BG_COLOR, NIF_FRAME_COLOR, NIF_EA, NIF_TEXT, NIF_FLAGS, NIF_ALL

**Layout types**: layout_digraph, layout_tree, layout_circle, layout_polar_tree, layout_orthogonal, layout_radial_tree

**Graph item types**: git_none, git_edge, git_node, git_tool, git_text

## See Also
Full docs: skill/docs/ida_graph.rst

```

`skills/idapython/docs/ida_graph.rst`:

```rst
ida_graph
=========

.. py:module:: ida_graph

.. autoapi-nested-parse::

   Graph view management.



Attributes
----------

.. autoapisummary::

   ida_graph.NIF_BG_COLOR
   ida_graph.NIF_FRAME_COLOR
   ida_graph.NIF_EA
   ida_graph.NIF_TEXT
   ida_graph.NIF_FLAGS
   ida_graph.NIF_ALL
   ida_graph.GLICTL_CENTER
   ida_graph.NIFF_SHOW_CONTENTS
   ida_graph.cvar
   ida_graph.layout_none
   ida_graph.layout_digraph
   ida_graph.layout_tree
   ida_graph.layout_circle
   ida_graph.layout_polar_tree
   ida_graph.layout_orthogonal
   ida_graph.layout_radial_tree
   ida_graph.git_none
   ida_graph.git_edge
   ida_graph.git_node
   ida_graph.git_tool
   ida_graph.git_text
   ida_graph.git_elp
   ida_graph.ygap
   ida_graph.xgap
   ida_graph.arrow_height
   ida_graph.arrow_width
   ida_graph.MTG_GROUP_NODE
   ida_graph.MTG_DOT_NODE
   ida_graph.MTG_NON_DISPLAYABLE_NODE
   ida_graph.COLLAPSED_NODE
   ida_graph.grcode_calculating_layout
   ida_graph.grcode_layout_calculated
   ida_graph.grcode_changed_graph
   ida_graph.grcode_reserved
   ida_graph.grcode_clicked
   ida_graph.grcode_dblclicked
   ida_graph.grcode_creating_group
   ida_graph.grcode_deleting_group
   ida_graph.grcode_group_visibility
   ida_graph.grcode_gotfocus
   ida_graph.grcode_lostfocus
   ida_graph.grcode_user_refresh
   ida_graph.grcode_reserved2
   ida_graph.grcode_user_text
   ida_graph.grcode_user_size
   ida_graph.grcode_user_title
   ida_graph.grcode_user_draw
   ida_graph.grcode_user_hint
   ida_graph.grcode_destroyed
   ida_graph.grcode_create_graph_viewer
   ida_graph.grcode_get_graph_viewer
   ida_graph.grcode_get_viewer_graph
   ida_graph.grcode_create_interactive_graph
   ida_graph.grcode_set_viewer_graph
   ida_graph.grcode_refresh_viewer
   ida_graph.grcode_fit_window
   ida_graph.grcode_get_curnode
   ida_graph.grcode_center_on
   ida_graph.grcode_get_selection
   ida_graph.grcode_del_custom_layout
   ida_graph.grcode_set_custom_layout
   ida_graph.grcode_set_graph_groups
   ida_graph.grcode_clear
   ida_graph.grcode_create_digraph_layout
   ida_graph.grcode_create_tree_layout
   ida_graph.grcode_create_circle_layout
   ida_graph.grcode_get_node_representative
   ida_graph.grcode_find_subgraph_node
   ida_graph.grcode_create_group
   ida_graph.grcode_get_custom_layout
   ida_graph.grcode_get_graph_groups
   ida_graph.grcode_empty
   ida_graph.grcode_is_visible_node
   ida_graph.grcode_delete_group
   ida_graph.grcode_change_group_visibility
   ida_graph.grcode_set_edge
   ida_graph.grcode_node_qty
   ida_graph.grcode_nrect
   ida_graph.grcode_set_titlebar_height
   ida_graph.grcode_create_user_graph_place
   ida_graph.grcode_create_disasm_graph1
   ida_graph.grcode_create_disasm_graph2
   ida_graph.grcode_set_node_info
   ida_graph.grcode_get_node_info
   ida_graph.grcode_del_node_info
   ida_graph.grcode_viewer_create_groups
   ida_graph.grcode_viewer_delete_groups
   ida_graph.grcode_viewer_groups_visibility
   ida_graph.grcode_viewer_create_groups_vec
   ida_graph.grcode_viewer_delete_groups_vec
   ida_graph.grcode_viewer_groups_visibility_vec
   ida_graph.grcode_delete_interactive_graph
   ida_graph.grcode_edge_infos_wrapper_copy
   ida_graph.grcode_edge_infos_wrapper_clear
   ida_graph.grcode_attach_menu_item
   ida_graph.grcode_set_gli
   ida_graph.grcode_get_gli
   ida_graph.edge_t
   ida_graph.node_ordering_t
   ida_graph.abstract_graph_t
   ida_graph.mutable_graph_t
   ida_graph.create_mutable_graph
   ida_graph.delete_mutable_graph
   ida_graph.grcode_create_mutable_graph
   ida_graph.grcode_create_mutable_graph


Classes
-------

.. autoapisummary::

   ida_graph.screen_graph_selection_base_t
   ida_graph.node_layout_t
   ida_graph.pointvec_t
   ida_graph.node_info_t
   ida_graph.graph_node_visitor_t
   ida_graph.graph_path_visitor_t
   ida_graph.point_t
   ida_graph.pointseq_t
   ida_graph.rect_t
   ida_graph.TPointDouble
   ida_graph.edge_info_t
   ida_graph.edge_layout_point_t
   ida_graph.selection_item_t
   ida_graph.screen_graph_selection_t
   ida_graph.edge_segment_t
   ida_graph.graph_item_t
   ida_graph.interval_t
   ida_graph.row_info_t
   ida_graph.drawable_graph_t
   ida_graph.edge_infos_wrapper_t
   ida_graph.interactive_graph_t
   ida_graph.graph_visitor_t
   ida_graph.group_crinfo_t
   ida_graph.user_graph_place_t
   ida_graph.GraphViewer


Functions
---------

.. autoapisummary::

   ida_graph.get_node_info
   ida_graph.set_node_info
   ida_graph.del_node_info
   ida_graph.clr_node_info
   ida_graph.calc_dist
   ida_graph.create_graph_viewer
   ida_graph.get_graph_viewer
   ida_graph.create_interactive_graph
   ida_graph.create_disasm_graph
   ida_graph.get_viewer_graph
   ida_graph.set_viewer_graph
   ida_graph.refresh_viewer
   ida_graph.viewer_fit_window
   ida_graph.viewer_get_curnode
   ida_graph.viewer_center_on
   ida_graph.viewer_set_gli
   ida_graph.viewer_get_gli
   ida_graph.viewer_set_node_info
   ida_graph.viewer_get_node_info
   ida_graph.viewer_del_node_info
   ida_graph.viewer_create_groups
   ida_graph.viewer_delete_groups
   ida_graph.viewer_set_groups_visibility
   ida_graph.viewer_attach_menu_item
   ida_graph.viewer_get_selection
   ida_graph.viewer_set_titlebar_height
   ida_graph.delete_interactive_graph
   ida_graph.create_user_graph_place
   ida_graph.pyg_close
   ida_graph.pyg_select_node
   ida_graph.pyg_show


Module Contents
---------------

.. py:class:: screen_graph_selection_base_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> selection_item_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> selection_item_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: screen_graph_selection_base_t) -> None


   .. py:method:: extract() -> selection_item_t *


   .. py:method:: inject(s: selection_item_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< selection_item_t >::const_iterator


   .. py:method:: end(*args) -> qvector< selection_item_t >::const_iterator


   .. py:method:: insert(it: selection_item_t, x: selection_item_t) -> qvector< selection_item_t >::iterator


   .. py:method:: erase(*args) -> qvector< selection_item_t >::iterator


   .. py:method:: find(*args) -> qvector< selection_item_t >::const_iterator


   .. py:method:: has(x: selection_item_t) -> bool


   .. py:method:: add_unique(x: selection_item_t) -> bool


   .. py:method:: append(x: selection_item_t) -> None


   .. py:method:: extend(x: screen_graph_selection_base_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: node_layout_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> rect_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> rect_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: node_layout_t) -> None


   .. py:method:: extract() -> rect_t *


   .. py:method:: inject(s: rect_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< rect_t >::const_iterator


   .. py:method:: end(*args) -> qvector< rect_t >::const_iterator


   .. py:method:: insert(it: rect_t, x: rect_t) -> qvector< rect_t >::iterator


   .. py:method:: erase(*args) -> qvector< rect_t >::iterator


   .. py:method:: find(*args) -> qvector< rect_t >::const_iterator


   .. py:method:: has(x: rect_t) -> bool


   .. py:method:: add_unique(x: rect_t) -> bool


   .. py:method:: append(x: rect_t) -> None


   .. py:method:: extend(x: node_layout_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: pointvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> point_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> point_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: pointvec_t) -> None


   .. py:method:: extract() -> point_t *


   .. py:method:: inject(s: point_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< point_t >::const_iterator


   .. py:method:: end(*args) -> qvector< point_t >::const_iterator


   .. py:method:: insert(it: point_t, x: point_t) -> qvector< point_t >::iterator


   .. py:method:: erase(*args) -> qvector< point_t >::iterator


   .. py:method:: find(*args) -> qvector< point_t >::const_iterator


   .. py:method:: has(x: point_t) -> bool


   .. py:method:: add_unique(x: point_t) -> bool


   .. py:method:: append(x: point_t) -> None


   .. py:method:: extend(x: pointvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: NIF_BG_COLOR

   node_info_t::bg_color


.. py:data:: NIF_FRAME_COLOR

   node_info_t::frame_color


.. py:data:: NIF_EA

   node_info_t::ea


.. py:data:: NIF_TEXT

   node_info_t::text


.. py:data:: NIF_FLAGS

   node_info_t::flags


.. py:data:: NIF_ALL

.. py:data:: GLICTL_CENTER

   the gli should be set/get as center


.. py:class:: node_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: bg_color
      :type:  bgcolor_t

      background color



   .. py:attribute:: frame_color
      :type:  bgcolor_t

      color of enclosing frame



   .. py:attribute:: flags
      :type:  int

      flags



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      address



   .. py:attribute:: text
      :type:  str

      node contents



   .. py:method:: valid_bg_color() -> bool

      Has valid bg_color?



   .. py:method:: valid_frame_color() -> bool

      Has valid frame_color?



   .. py:method:: valid_ea() -> bool

      Has valid ea?



   .. py:method:: valid_text() -> bool

      Has non-empty text?



   .. py:method:: valid_flags() -> bool

      Has valid flags?



   .. py:method:: get_flags_for_valid() -> int

      Get combination of Node info flags describing which attributes are valid.



.. py:data:: NIFF_SHOW_CONTENTS

.. py:function:: get_node_info(out: node_info_t, gid: graph_id_t, node: int) -> bool

   Get node info. 
           
   :param out: result
   :param gid: id of desired graph
   :param node: node number
   :returns: success


.. py:function:: set_node_info(gid: graph_id_t, node: int, ni: node_info_t, flags: int) -> None

   Set node info. 
           
   :param gid: id of desired graph
   :param node: node number
   :param ni: node info to use
   :param flags: combination of Node info flags, identifying which fields of 'ni' will be used


.. py:function:: del_node_info(gid: graph_id_t, node: int) -> None

   Delete the node_info_t for the given node.


.. py:function:: clr_node_info(gid: graph_id_t, node: int, flags: int) -> None

   Clear node info for the given node. 
           
   :param gid: id of desired graph
   :param node: node number
   :param flags: combination of Node info flags, identifying which fields of node_info_t will be cleared


.. py:class:: graph_node_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: reinit() -> None

      Reset visited nodes.



   .. py:method:: set_visited(n: int) -> None

      Mark node as visited.



   .. py:method:: is_visited(n: int) -> bool

      Have we already visited the given node?



   .. py:method:: visit_node(arg0: int) -> int

      Implements action to take when a node is visited.



   .. py:method:: is_forbidden_edge(arg0: int, arg1: int) -> bool

      Should the edge between 'n' and 'm' be ignored?



.. py:class:: graph_path_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: path
      :type:  intvec_t

      current path



   .. py:attribute:: prune
      :type:  bool

      walk_forward(): prune := true means to stop the current path 
              



   .. py:method:: walk_forward(arg0: int) -> int


   .. py:method:: walk_backward(arg0: int) -> int


.. py:class:: point_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  int


   .. py:attribute:: y
      :type:  int


   .. py:method:: add(r: point_t) -> point_t &


   .. py:method:: sub(r: point_t) -> point_t &


   .. py:method:: negate() -> None


.. py:function:: calc_dist(p: point_t, q: point_t) -> double

   Calculate distance between p and q.


.. py:class:: pointseq_t

   Bases: :py:obj:`pointvec_t`


   .. py:attribute:: thisown


.. py:class:: rect_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: left
      :type:  int


   .. py:attribute:: top
      :type:  int


   .. py:attribute:: right
      :type:  int


   .. py:attribute:: bottom
      :type:  int


   .. py:method:: verify() -> None


   .. py:method:: width() -> int


   .. py:method:: height() -> int


   .. py:method:: move_to(p: point_t) -> None


   .. py:method:: move_by(p: point_t) -> None


   .. py:method:: center() -> point_t


   .. py:method:: topleft() -> point_t


   .. py:method:: bottomright() -> point_t


   .. py:method:: grow(delta: int) -> None


   .. py:method:: intersect(r: rect_t) -> None


   .. py:method:: make_union(r: rect_t) -> None


   .. py:method:: empty() -> bool


   .. py:method:: is_intersection_empty(r: rect_t) -> bool


   .. py:method:: contains(p: point_t) -> bool


   .. py:method:: area() -> int


.. py:class:: TPointDouble(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  double


   .. py:attribute:: y
      :type:  double


   .. py:method:: add(r: TPointDouble) -> None


   .. py:method:: sub(r: TPointDouble) -> None


   .. py:method:: negate() -> None


.. py:class:: edge_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: color
      :type:  bgcolor_t

      edge color



   .. py:attribute:: width
      :type:  int

      edge width



   .. py:attribute:: srcoff
      :type:  int

      source: edge port offset from the left



   .. py:attribute:: dstoff
      :type:  int

      destination: edge port offset from the left



   .. py:attribute:: layout
      :type:  pointseq_t

      describes geometry of edge



   .. py:method:: reverse_layout() -> None


.. py:data:: cvar

.. py:data:: layout_none

.. py:data:: layout_digraph

.. py:data:: layout_tree

.. py:data:: layout_circle

.. py:data:: layout_polar_tree

.. py:data:: layout_orthogonal

.. py:data:: layout_radial_tree

.. py:class:: edge_layout_point_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: pidx
      :type:  int

      index into edge_info_t::layout



   .. py:attribute:: e
      :type:  edge_t

      parent edge



   .. py:method:: compare(r: edge_layout_point_t) -> int


.. py:class:: selection_item_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: is_node
      :type:  bool

      represents a selected node?



   .. py:attribute:: node
      :type:  int

      node number (is_node = true)



   .. py:attribute:: elp
      :type:  edge_layout_point_t

      edge layout point (is_node = false)



   .. py:method:: compare(r: selection_item_t) -> int


.. py:class:: screen_graph_selection_t

   Bases: :py:obj:`screen_graph_selection_base_t`


   .. py:attribute:: thisown


   .. py:method:: has(item: selection_item_t) -> bool


   .. py:method:: add(s: screen_graph_selection_t) -> None


   .. py:method:: sub(s: screen_graph_selection_t) -> None


   .. py:method:: add_node(node: int) -> None


   .. py:method:: del_node(node: int) -> None


   .. py:method:: add_point(e: edge_t, idx: int) -> None


   .. py:method:: del_point(e: edge_t, idx: int) -> None


   .. py:method:: nodes_count() -> size_t


   .. py:method:: points_count() -> size_t


   .. py:method:: items_count(look_for_nodes: bool) -> size_t


.. py:class:: edge_segment_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: e
      :type:  edge_t


   .. py:attribute:: nseg
      :type:  int


   .. py:attribute:: x0
      :type:  int


   .. py:attribute:: x1
      :type:  int


   .. py:method:: length() -> size_t


   .. py:method:: toright() -> bool


.. py:data:: git_none

   nothing


.. py:data:: git_edge

   edge (graph_item_t::e, graph_item_t::n. n is farthest edge endpoint)


.. py:data:: git_node

   node title (graph_item_t::n)


.. py:data:: git_tool

   node title button (graph_item_t::n, graph_item_t::b)


.. py:data:: git_text

   node text (graph_item_t::n, graph_item_t::p)


.. py:data:: git_elp

   edge layout point (graph_item_t::elp)


.. py:class:: graph_item_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: type
      :type:  graph_item_type_t

      type



   .. py:attribute:: e
      :type:  edge_t

      edge source and destination



   .. py:attribute:: n
      :type:  int

      node number



   .. py:attribute:: b
      :type:  int

      button number



   .. py:attribute:: p
      :type:  point_t

      text coordinates in the node



   .. py:attribute:: elp
      :type:  edge_layout_point_t

      edge layout point



   .. py:method:: is_node() -> bool


   .. py:method:: is_edge() -> bool


.. py:class:: interval_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x0
      :type:  int


   .. py:attribute:: x1
      :type:  int


   .. py:method:: empty() -> bool


   .. py:method:: intersect(r: interval_t) -> None


   .. py:method:: make_union(r: interval_t) -> None


   .. py:method:: move_by(shift: int) -> None


   .. py:method:: length() -> int


   .. py:method:: contains(x: int) -> bool


.. py:class:: row_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: nodes
      :type:  intvec_t

      list of nodes at the row



   .. py:attribute:: top
      :type:  int

      top y coord of the row



   .. py:attribute:: bottom
      :type:  int

      bottom y coord of the row



   .. py:method:: height() -> int


.. py:class:: drawable_graph_t

   Bases: :py:obj:`ida_gdl.gdl_graph_t`


   .. py:attribute:: thisown


   .. py:attribute:: title
      :type:  str

      graph title



   .. py:attribute:: rect_edges_made
      :type:  bool

      have create rectangular edges?



   .. py:attribute:: current_layout
      :type:  layout_type_t

      see Proximity view layouts



   .. py:attribute:: circle_center
      :type:  point_t

      for layout_circle



   .. py:attribute:: circle_radius
      :type:  int

      for layout_circle



   .. py:attribute:: callback_ud
      :type:  void *

      user data for callback



   .. py:method:: create_tree_layout() -> bool


   .. py:method:: create_circle_layout(p: point_t, radius: int) -> bool


   .. py:method:: set_callback(_callback: hook_cb_t *, _ud: void *) -> None


   .. py:method:: grcall(code: int) -> ssize_t


   .. py:method:: get_edge(e: edge_t) -> edge_info_t *


   .. py:method:: nrect(n: int) -> rect_t


.. py:data:: ygap

.. py:data:: xgap

.. py:data:: arrow_height

.. py:data:: arrow_width

.. py:class:: edge_infos_wrapper_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: clear() -> None


   .. py:attribute:: ptr
      :type:  edge_infos_t *


.. py:class:: interactive_graph_t(*args, **kwargs)

   Bases: :py:obj:`drawable_graph_t`


   .. py:attribute:: thisown


   .. py:attribute:: gid
      :type:  int

      graph id - unique for the database for flowcharts it is equal to the function start_ea 
              



   .. py:attribute:: belongs
      :type:  intvec_t

      the subgraph the node belongs to INT_MAX means that the node doesn't exist sign bit means collapsed node 
              



   .. py:attribute:: node_flags
      :type:  bytevec_t

      node flags



   .. py:attribute:: org_succs
      :type:  array_of_intvec_t


   .. py:attribute:: org_preds
      :type:  array_of_intvec_t


   .. py:attribute:: succs
      :type:  array_of_intvec_t


   .. py:attribute:: preds
      :type:  array_of_intvec_t


   .. py:attribute:: nodes
      :type:  interactive_graph_t::node_layout_t


   .. py:attribute:: edges
      :type:  edge_infos_wrapper_t


   .. py:method:: size() -> int

      Get the total number of nodes (including group nodes, and including hidden nodes.)
      See also node_qty()

      :returns: the total number of nodes in the graph



   .. py:method:: node_qty() -> int

      Get the number of visible nodes (the list can be retrieved using gdl.hpp's node_iterator)
      See also size()

      :returns: the number of visible nodes



   .. py:method:: empty() -> bool

      Is the graph (visually) empty? 
              
      :returns: true if there are no visible nodes



   .. py:method:: exists(node: int) -> bool

      Is the node visible?

      :param node: the node number
      :returns: success



   .. py:method:: get_node_representative(node: int) -> int

      Get the node that currently visually represents 'node'. This will find the "closest" parent group node that's visible, by attempting to walk up the group nodes that contain 'node', and will stop when it finds a node that is currently visible.
      See also get_group_node() 
              
      :param node: the node
      :returns: the node that represents 'node', or 'node' if it's not part of any group



   .. py:method:: get_node_group(node: int) -> int


   .. py:method:: set_node_group(node: int, group: int) -> None


   .. py:method:: is_deleted_node(node: int) -> bool


   .. py:method:: set_deleted_node(node: int) -> None


   .. py:method:: is_subgraph_node(node: int) -> bool


   .. py:method:: is_dot_node(node: int) -> bool


   .. py:method:: is_group_node(node: int) -> bool


   .. py:method:: is_displayable_node(node: int) -> bool


   .. py:method:: is_simple_node(node: int) -> bool


   .. py:method:: is_collapsed_node(node: int) -> bool


   .. py:method:: is_uncollapsed_node(node: int) -> bool


   .. py:method:: is_visible_node(node: int) -> bool

      Is the node currently visible?
      An invisible node is a node that's part of a group that's currently collapsed.

      :param node: the node
      :returns: success



   .. py:method:: get_first_subgraph_node(group: int) -> int


   .. py:method:: get_next_subgraph_node(group: int, current: int) -> int


   .. py:method:: create_group(nodes: intvec_t const &) -> int

      Create a new group node, that will contain all the nodes in 'nodes'.

      :param nodes: the nodes that will be part of the group
      :returns: the group node, or -1 in case of error



   .. py:method:: delete_group(group: int) -> bool

      Delete a group node.
      This deletes the group node only; it does not delete nodes that are part of the group.

      :param group: the group node
      :returns: success



   .. py:method:: change_group_visibility(group: int, expand: bool) -> bool

      Expand/collapse a group node

      :param group: the group node
      :param expand: whether to expand or collapse
      :returns: success



   .. py:method:: nsucc(b: int) -> int


   .. py:method:: npred(b: int) -> int


   .. py:method:: succ(b: int, i: int) -> int


   .. py:method:: pred(b: int, i: int) -> int


   .. py:method:: succset(b: int) -> intvec_t const &


   .. py:method:: predset(b: int) -> intvec_t const &


   .. py:method:: reset() -> None


   .. py:method:: redo_layout() -> bool

      Recompute the layout, according to the value of 'current_layout'.

      :returns: success



   .. py:method:: resize(n: int) -> None

      Resize the graph to 'n' nodes

      :param n: the new size



   .. py:method:: add_node(r: rect_t) -> int

      Add a node, possibly with a specific geometry

      :param r: the node geometry (can be nullptr)
      :returns: the new node



   .. py:method:: del_node(n: int) -> ssize_t

      Delete a node

      :param n: the node to delete
      :returns: the number of deleted edges



   .. py:method:: add_edge(i: int, j: int, ei: edge_info_t) -> bool


   .. py:method:: del_edge(i: int, j: int) -> bool


   .. py:method:: replace_edge(i: int, j: int, x: int, y: int) -> bool


   .. py:method:: refresh() -> bool

      Refresh the graph
      A graph needs refreshing when it's "backing data". E.g., if the number (or contents) of the objects in the above example, change.
      Let's say the user's plugin ends up finding a 5th piece of scattered data. It should then add it to its internal list of known objects, and tell IDA that the graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
      * discard all its internal rendering information,
      * call interactive_graph_t::refresh() on the graph so that the user's plugin has a chance to "sync" the number of nodes & edges that this graph contains, to the information that the plugin has collected so far
      * re-create internal rendering information, and
      * repaint the view



      :returns: success



   .. py:method:: set_nrect(n: int, r: rect_t) -> bool


   .. py:method:: set_edge(e: edge_t, ei: edge_info_t) -> bool


   .. py:method:: create_digraph_layout() -> bool


   .. py:method:: del_custom_layout() -> None


   .. py:method:: get_custom_layout() -> bool


   .. py:method:: set_custom_layout() -> None


   .. py:method:: get_graph_groups() -> bool


   .. py:method:: set_graph_groups() -> None


   .. py:method:: calc_group_ea(arg2: intvec_t const &) -> ida_idaapi.ea_t


   .. py:method:: is_user_graph() -> bool


.. py:data:: MTG_GROUP_NODE

   is group node?


.. py:data:: MTG_DOT_NODE

   is dot node?


.. py:data:: MTG_NON_DISPLAYABLE_NODE

   for disassembly graphs - non-displayable nodes have a visible area that is too large to generate disassembly lines for without IDA slowing down significantly (see MAX_VISIBLE_NODE_AREA) 
           


.. py:data:: COLLAPSED_NODE

.. py:class:: graph_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit_node(arg2: int, arg3: rect_t) -> int


   .. py:method:: visit_edge(arg2: edge_t, arg3: edge_info_t) -> int


.. py:data:: grcode_calculating_layout

   calculating user-defined graph layout. 
             


.. py:data:: grcode_layout_calculated

   graph layout calculated. 
             


.. py:data:: grcode_changed_graph

   new graph has been set. 
             


.. py:data:: grcode_reserved

.. py:data:: grcode_clicked

   graph is being clicked. this callback allows you to ignore some clicks. it occurs too early, internal graph variables are not updated yet. current_item1, current_item2 point to the same thing. item2 has more information. see also: custom_viewer_click_t 
             


.. py:data:: grcode_dblclicked

   a graph node has been double clicked. 
             


.. py:data:: grcode_creating_group

   a group is being created. this provides an opportunity for the graph to forbid creation of the group. Note that groups management is done by the interactive_graph_t instance itself: there is no need to modify the graph in this callback. 
             


.. py:data:: grcode_deleting_group

   a group is being deleted. this provides an opportunity for the graph to forbid deletion of the group. Note that groups management is done by the interactive_graph_t instance itself: there is no need to modify the graph in this callback. 
             


.. py:data:: grcode_group_visibility

   a group is being collapsed/uncollapsed this provides an opportunity for the graph to forbid changing the visibility of the group. Note that groups management is done by the interactive_graph_t instance itself: there is no need to modify the graph in this callback. 
             


.. py:data:: grcode_gotfocus

   a graph viewer got focus. 
             


.. py:data:: grcode_lostfocus

   a graph viewer lost focus. 
             


.. py:data:: grcode_user_refresh

   refresh user-defined graph nodes and edges This is called when the UI considers that it is necessary to recreate the graph layout, and thus has to ensure that the 'interactive_graph_t' instance it is using, is up-to-date. For example:
   * at graph creation-time
   * if a refresh_viewer() call was made



.. py:data:: grcode_reserved2

.. py:data:: grcode_user_text

   retrieve text for user-defined graph node. NB: do not use anything calling GDI! 
             


.. py:data:: grcode_user_size

   calculate node size for user-defined graph. 
             


.. py:data:: grcode_user_title

   render node title of a user-defined graph. 
             


.. py:data:: grcode_user_draw

   render node of a user-defined graph. NB: draw only on the specified DC and nowhere else! 
             


.. py:data:: grcode_user_hint

   retrieve hint for the user-defined graph. 
             


.. py:data:: grcode_destroyed

   graph is being destroyed. Note that this doesn't mean the graph viewer is being destroyed; this only means that the graph that is being displayed by it is being destroyed, and that, e.g., any possibly cached data should be invalidated (this event can happen when, for example, the user decides to group nodes together: that operation will effectively create a new graph, that will replace the old one.) To be notified when the graph viewer itself is being destroyed, please see notification 'view_close', in kernwin.hpp 
             


.. py:data:: grcode_create_graph_viewer

   use create_graph_viewer()


.. py:data:: grcode_get_graph_viewer

   use get_graph_viewer()


.. py:data:: grcode_get_viewer_graph

   use get_viewer_graph()


.. py:data:: grcode_create_interactive_graph

   use create_interactive_graph()


.. py:data:: grcode_set_viewer_graph

   use set_viewer_graph()


.. py:data:: grcode_refresh_viewer

   use refresh_viewer()


.. py:data:: grcode_fit_window

   use viewer_fit_window()


.. py:data:: grcode_get_curnode

   use viewer_get_curnode()


.. py:data:: grcode_center_on

   use viewer_center_on()


.. py:data:: grcode_get_selection

   use viewer_get_selection()


.. py:data:: grcode_del_custom_layout

   use interactive_graph_t::del_custom_layout()


.. py:data:: grcode_set_custom_layout

   use interactive_graph_t::set_custom_layout()


.. py:data:: grcode_set_graph_groups

   use interactive_graph_t::set_graph_groups()


.. py:data:: grcode_clear

   use interactive_graph_t::clear()


.. py:data:: grcode_create_digraph_layout

   use interactive_graph_t::create_digraph_layout()


.. py:data:: grcode_create_tree_layout

   use drawable_graph_t::create_tree_layout()


.. py:data:: grcode_create_circle_layout

   use drawable_graph_t::create_circle_layout()


.. py:data:: grcode_get_node_representative

   use interactive_graph_t::get_node_representative()


.. py:data:: grcode_find_subgraph_node

   use interactive_graph_t::_find_subgraph_node()


.. py:data:: grcode_create_group

   use interactive_graph_t::create_group()


.. py:data:: grcode_get_custom_layout

   use interactive_graph_t::get_custom_layout()


.. py:data:: grcode_get_graph_groups

   use interactive_graph_t::get_graph_groups()


.. py:data:: grcode_empty

   use interactive_graph_t::empty()


.. py:data:: grcode_is_visible_node

   use interactive_graph_t::is_visible_node()


.. py:data:: grcode_delete_group

   use interactive_graph_t::delete_group()


.. py:data:: grcode_change_group_visibility

   use interactive_graph_t::change_group_visibility()


.. py:data:: grcode_set_edge

   use interactive_graph_t::set_edge()


.. py:data:: grcode_node_qty

   use interactive_graph_t::node_qty()


.. py:data:: grcode_nrect

   use interactive_graph_t::nrect()


.. py:data:: grcode_set_titlebar_height

   use viewer_set_titlebar_height()


.. py:data:: grcode_create_user_graph_place

   use create_user_graph_place()


.. py:data:: grcode_create_disasm_graph1

   use create_disasm_graph(ea_t ea)


.. py:data:: grcode_create_disasm_graph2

   use create_disasm_graph(const rangevec_t &ranges)


.. py:data:: grcode_set_node_info

   use viewer_set_node_info()


.. py:data:: grcode_get_node_info

   use viewer_get_node_info()


.. py:data:: grcode_del_node_info

   use viewer_del_node_info()


.. py:data:: grcode_viewer_create_groups

.. py:data:: grcode_viewer_delete_groups

.. py:data:: grcode_viewer_groups_visibility

.. py:data:: grcode_viewer_create_groups_vec

   use viewer_create_groups()


.. py:data:: grcode_viewer_delete_groups_vec

   use viewer_delete_groups()


.. py:data:: grcode_viewer_groups_visibility_vec

   use viewer_set_groups_visibility()


.. py:data:: grcode_delete_interactive_graph

   use delete_interactive_graph()


.. py:data:: grcode_edge_infos_wrapper_copy

   use edge_infos_wrapper_t::operator=()


.. py:data:: grcode_edge_infos_wrapper_clear

   use edge_infos_wrapper_t::clear()


.. py:data:: grcode_attach_menu_item

.. py:data:: grcode_set_gli

   use viewer_set_gli()


.. py:data:: grcode_get_gli

   use viewer_get_gli()


.. py:class:: group_crinfo_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: nodes
      :type:  intvec_t


   .. py:attribute:: text
      :type:  str


.. py:function:: create_graph_viewer(title: str, id: int, callback: hook_cb_t *, ud: void *, title_height: int, parent: TWidget * = None) -> graph_viewer_t *

   Create a custom graph viewer. 
           
   :param title: the widget title
   :param id: graph id
   :param callback: callback to handle graph notifications (graph_notification_t)
   :param ud: user data passed to callback
   :param title_height: node title height
   :param parent: the parent widget of the graph viewer
   :returns: new viewer


.. py:function:: get_graph_viewer(parent: TWidget *) -> graph_viewer_t *

   Get custom graph viewer for given form.


.. py:function:: create_interactive_graph(id: int) -> interactive_graph_t *

   Create a new empty graph with given id.


.. py:function:: create_disasm_graph(*args) -> interactive_graph_t *

   This function has the following signatures:

       0. create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
       1. create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *

   # 0: create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *

   Create a graph for the function that contains 'ea'.


   # 1: create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *

   Create a graph using an arbitrary set of ranges.


.. py:function:: get_viewer_graph(gv: graph_viewer_t *) -> interactive_graph_t *

   Get graph object for given custom graph viewer.


.. py:function:: set_viewer_graph(gv: graph_viewer_t *, g: interactive_graph_t) -> None

   Set the underlying graph object for the given viewer.


.. py:function:: refresh_viewer(gv: graph_viewer_t *) -> None

   Redraw the graph in the given view.


.. py:function:: viewer_fit_window(gv: graph_viewer_t *) -> None

   Fit graph viewer to its parent form.


.. py:function:: viewer_get_curnode(gv: graph_viewer_t *) -> int

   Get number of currently selected node (-1 if none)


.. py:function:: viewer_center_on(gv: graph_viewer_t *, node: int) -> None

   Center the graph view on the given node.


.. py:function:: viewer_set_gli(gv: graph_viewer_t *, gli: graph_location_info_t const *, flags: int = 0) -> None

   Set location info for given graph view If flags contains GLICTL_CENTER, then the gli will be set to be the center of the view. Otherwise it will be the top-left. 
           


.. py:function:: viewer_get_gli(out: graph_location_info_t *, gv: graph_viewer_t *, flags: int = 0) -> bool

   Get location info for given graph view If flags contains GLICTL_CENTER, then the gli that will be retrieved, will be the one at the center of the view. Otherwise it will be the top-left. 
           


.. py:function:: viewer_set_node_info(gv: graph_viewer_t *, n: int, ni: node_info_t, flags: int) -> None

   Set node info for node in given viewer (see set_node_info())


.. py:function:: viewer_get_node_info(gv: graph_viewer_t *, out: node_info_t, n: int) -> bool

   Get node info for node in given viewer (see get_node_info())


.. py:function:: viewer_del_node_info(gv: graph_viewer_t *, n: int) -> None

   Delete node info for node in given viewer (see del_node_info())


.. py:function:: viewer_create_groups(gv: graph_viewer_t *, out_group_nodes: intvec_t *, gi: groups_crinfos_t const &) -> bool

   This will perform an operation similar to what happens when a user manually selects a set of nodes, right-clicks and selects "Create group". This is a wrapper around interactive_graph_t::create_group that will, in essence:
   * clone the current graph
   * for each group_crinfo_t, attempt creating group in that new graph
   * if all were successful, animate to that new graph.



.. py:function:: viewer_delete_groups(gv: graph_viewer_t *, groups: intvec_t const &, new_current: int = -1) -> bool

   Wrapper around interactive_graph_t::delete_group. This function will:
   * clone the current graph
   * attempt deleting the groups in that new graph
   * if successful, animate to that new graph. 


           


.. py:function:: viewer_set_groups_visibility(gv: graph_viewer_t *, groups: intvec_t const &, expand: bool, new_current: int = -1) -> bool

   Wrapper around interactive_graph_t::change_visibility. This function will:
   * clone the current graph
   * attempt changing visibility of the groups in that new graph
   * if successful, animate to that new graph. 


           


.. py:function:: viewer_attach_menu_item(g: graph_viewer_t *, name: str) -> bool

   Attach a previously-registered action to the view's context menu. See kernwin.hpp for how to register actions. 
           
   :param g: graph viewer
   :param name: action name
   :returns: success


.. py:function:: viewer_get_selection(gv: graph_viewer_t *, sgs: screen_graph_selection_t) -> bool

   Get currently selected items for graph viewer.


.. py:function:: viewer_set_titlebar_height(gv: graph_viewer_t *, height: int) -> int

   Set height of node title bars (grcode_set_titlebar_height)


.. py:function:: delete_interactive_graph(g: interactive_graph_t) -> None

   Delete graph object. 
           


.. py:class:: user_graph_place_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: node
      :type:  int


.. py:function:: create_user_graph_place(node: int, lnnum: int) -> user_graph_place_t *

   Get a copy of a user_graph_place_t (returns a pointer to static storage)


.. py:function:: pyg_close(_self: PyObject *) -> None

.. py:function:: pyg_select_node(_self: PyObject *, nid: int) -> None

.. py:function:: pyg_show(_self: PyObject *) -> bool

.. py:data:: edge_t

.. py:data:: node_ordering_t

.. py:data:: abstract_graph_t

.. py:data:: mutable_graph_t

.. py:data:: create_mutable_graph

.. py:data:: delete_mutable_graph

.. py:data:: grcode_create_mutable_graph

.. py:data:: grcode_create_mutable_graph

.. py:class:: GraphViewer(title, close_open=False)

   Bases: :py:obj:`ida_kernwin.CustomIDAMemo`


   .. py:class:: UI_Hooks_Trampoline(v)

      Bases: :py:obj:`ida_kernwin.UI_Hooks`


      .. py:attribute:: v


      .. py:method:: populating_widget_popup(w, popup_handle)

         IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
         Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)

         :param widget: (TWidget *)
         :param popup_handle: (TPopupMenu *)
         :param ctx: (const action_activation_ctx_t *)
         :returns: void




   .. py:attribute:: ui_hooks_trampoline


   .. py:method:: AddNode(obj)

      Creates a node associated with the given object and returns the node id



   .. py:method:: AddEdge(src_node, dest_node)

      Creates an edge between two given node ids



   .. py:method:: Clear()

      Clears all the nodes and edges



   .. py:method:: Count()

      Returns the node count



   .. py:method:: Close()

      Closes the graph.
      It is possible to call Show() again (which will recreate the graph)



   .. py:method:: Show()

      Shows an existing graph or creates a new one

      :returns: Boolean



   .. py:method:: Select(node_id)

      Selects a node on the graph



   .. py:method:: OnRefresh()

      Event called when the graph is refreshed or first created.
      From this event you are supposed to create nodes and edges.
      This callback is mandatory.

      NOTE: ***It is important to clear previous nodes before adding nodes.***

      :returns: Returning True tells the graph viewer to use the items. Otherwise old items will be used.



   .. py:method:: AddCommand(title, shortcut)


   .. py:method:: OnPopup(widget, popup_handle)


   .. py:method:: OnCommand(cmd_id)



```

`skills/idapython/docs/ida_hexrays.md`:

```md
# ida_hexrays

Hex-Rays decompiler - microcode and ctree (AST) representations. **Critical for decompilation work.**

## Core Architecture

**Two representations**:
- **Microcode**: Low-level optimized IR (mba_t, mblock_t, minsn_t, mop_t)
- **Ctree**: High-level AST-like C code (cfunc_t, cinsn_t, cexpr_t)

## Key Functions

### Decompilation
- `decompile(ea, hf=None, flags=0)` - Decompile function at address, returns cfuncptr_t
- `decompile_func(pfn, hf=None, flags=0)` - Decompile func_t object
- `gen_microcode(mbr, hf=None, retlist=None, flags=0, reqmat=MMAT_GLBOPT3)` - Generate microcode only

### Callbacks
- `install_hexrays_callback(callback)` - Register event hook (hxe_maturity, hxe_print_func, etc.)

## Ctree Classes (High-Level)

### cfunc_t
Decompiled function - the main result.
- `body` - Root cinsn_t (function body)
- `lvars` - List of local variables (lvar_t)
- `mba` - Underlying microcode (mba_t)
- `get_pseudocode()` - Get text as list of lines
- `build_c_tree()` - Rebuild ctree from microcode
- `verify(allow_cot_empty)` - Validate ctree integrity

### cinsn_t
C statement (if, for, while, return, expression, block, etc.).
- `op` - Statement type (cit_block, cit_if, cit_for, cit_while, cit_return, etc.)
- `ea` - Associated address
- `cif`, `cfor`, `cwhile`, `creturn`, `cexpr` - Type-specific data unions
- Access via: `insn.cif.expr` (if condition), `insn.cblock` (compound statement)

### cexpr_t
C expression (operators, variables, constants, calls, etc.).
- `op` - Expression type (cot_var, cot_num, cot_call, cot_add, cot_cast, etc.)
- `type` - Expression type info (tinfo_t)
- `x`, `y`, `z` - Operands (for binary/ternary ops)
- `n` - Number value (cnumber_t)
- `v` - Variable reference (var_ref_t)
- `obj_ea` - Global variable/function address
- `print1()` - Format as text

### citem_t
Base class for cinsn_t and cexpr_t.
- `ea` - Address
- `op` - Opcode (ctype_t enum)
- `contains_label()` - Has goto label

## Microcode Classes (Low-Level)

### mba_t
Microcode array - function as basic blocks.
- `qty` - Number of blocks
- `get_mblock(n)` - Get block by index
- `natural` - Natural (entry) block array
- `vars` - Local variables (lvars_t)
- `maturity` - Optimization level (MMAT_ZERO to MMAT_LVARS)
- `build_graph()` - Construct CFG
- `optimize_local(blk)` - Optimize single block
- `optimize_global()` - Global optimization pass

### mblock_t
Basic block in microcode.
- `head`, `tail` - First/last instruction (minsn_t)
- `start`, `end` - Address range
- `type` - Block type (BLT_STOP, BLT_1WAY, BLT_2WAY, BLT_NWAY)
- `nsucc()`, `npred()` - Successor/predecessor counts
- `succ(n)`, `pred(n)` - Get nth successor/predecessor
- `for_all_insns(visitor)` - Iterate instructions
- `insert_into_block(ins, where)` - Add instruction

### minsn_t
Microcode instruction.
- `opcode` - Operation (m_mov, m_add, m_call, m_ldx, m_stx, etc.)
- `l`, `r`, `d` - Left, right, destination operands (mop_t)
- `ea` - Instruction address
- `next`, `prev` - Linked list pointers
- `is_assert()` - Check if assertion
- `equal_mops(other)` - Compare operands
- `for_all_ops(visitor)` - Iterate operands

### mop_t
Microcode operand.
- `t` - Operand type (mop_z=none, mop_r=register, mop_n=immediate, mop_S=stack, mop_v=global, mop_b=block, mop_f=case, mop_l=local var, mop_a=address, mop_h=helper, mop_str=string, mop_c=call, mop_fn=function, mop_p=pair, mop_sc=scattered)
- `r` - Register number (if mop_r)
- `nnn` - Immediate value (mnumber_t, if mop_n)
- `g` - Global address (if mop_v)
- `s` - Stack offset (stkvar_ref_t, if mop_S)
- `l` - Local var reference (lvar_t, if mop_l)
- `size` - Operand size in bytes
- `is_reg(reg, size)` - Check if specific register
- `is_const()` - Check if constant

### lvar_t
Local variable (stack/register).
- `name` - Variable name
- `type` - Variable type (tinfo_t)
- `location` - vdloc_t (register or stack location)
- `defea` - Definition address
- `width` - Size in bytes
- `is_stk_var()`, `is_reg_var()` - Location checks
- `set_lvar_type(tif)` - Change type

## Key Event Types

**Maturity levels** (microcode optimization stages):
- MMAT_ZERO - Unoptimized
- MMAT_GENERATED - After instruction generation
- MMAT_PREOPTIMIZED - After pre-optimization
- MMAT_LOCOPT - After local optimization
- MMAT_CALLS - After call analysis
- MMAT_GLBOPT1/2/3 - Global optimization passes
- MMAT_LVARS - After local variable allocation

**Callback events**:
- hxe_maturity - Microcode maturity changed
- hxe_print_func - About to print function
- hxe_func_printed - Function printed
- hxe_open_pseudocode - Pseudocode window opened
- hxe_create_hint - Create hover hint

## Common Patterns

### Decompile and get text
```python
cfunc = ida_hexrays.decompile(ea)
for line in cfunc.get_pseudocode():
    print(line.line)
```

### Modify variable name/type
```python
cfunc = ida_hexrays.decompile(ea)
lvar = cfunc.lvars[0]
lvar.name = "new_name"
lvar.set_lvar_type(new_tinfo)
cfunc.save_user_labels()
```

### Walk ctree
```python
class visitor(ida_hexrays.ctree_visitor_t):
    def visit_expr(self, e):
        if e.op == ida_hexrays.cot_call:
            print(f"Call at {e.ea:#x}")
        return 0

cfunc = ida_hexrays.decompile(ea)
visitor().apply_to(cfunc.body, None)
```

### Walk microcode
```python
mba = ida_hexrays.gen_microcode(...)
for blk in mba.natural:
    ins = blk.head
    while ins:
        print(f"{ins.ea:#x}: {ins.opcode}")
        ins = ins.next
```

## See Also
Full docs: skill/docs/ida_hexrays.rst

**External resources**:
- https://hex-rays.com/blog/hex-rays-decompiler-primer
- https://hex-rays.com/blog/microcode-in-pictures

```

`skills/idapython/docs/ida_hexrays.rst`:

```rst
ida_hexrays
===========

.. py:module:: ida_hexrays

.. autoapi-nested-parse::

   There are 2 representations of the binary code in the decompiler:

   Hex-Rays Decompiler project Copyright (c) 1990-2025 Hex-Rays ALL RIGHTS RESERVED.

   * microcode: processor instructions are translated into it and then the decompiler optimizes and transforms it
   * ctree: ctree is built from the optimized microcode and represents AST-like tree with C statements and expressions. It can be printed as C code.


   Microcode is represented by the following classes:
   * mba_t keeps general info about the decompiled code and array of basic blocks. usually mba_t is named 'mba'
   * mblock_t a basic block. includes list of instructions
   * minsn_t an instruction. contains 3 operands: left, right, and destination
   * mop_t an operand. depending on its type may hold various info like a number, register, stack variable, etc.
   * mlist_t list of memory or register locations; can hold vast areas of memory and multiple registers. this class is used very extensively in the decompiler. it may represent list of locations accessed by an instruction or even an entire basic block. it is also used as argument of many functions. for example, there is a function that searches for an instruction that refers to a mlist_t.


   See [https://hex-rays.com/blog/microcode-in-pictures](https://hex-rays.com/blog/microcode-in-pictures) for a few pictures.
   Ctree is represented by:
   * cfunc_t keeps general info about the decompiled code, including a pointer to mba_t. deleting cfunc_t will delete mba_t too (however, decompiler returns cfuncptr_t, which is a reference counting object and deletes the underlying function as soon as all references to it go out of scope). cfunc_t has 'body', which represents the decompiled function body as cinsn_t.
   * cinsn_t a C statement. can be a compound statement or any other legal C statements (like if, for, while, return, expression-statement, etc). depending on the statement type has pointers to additional info. for example, the 'if' statement has poiner to cif_t, which holds the 'if' condition, 'then' branch, and optionally 'else' branch. Please note that despite of the name cinsn_t we say "statements", not "instructions". For us instructions are part of microcode, not ctree.
   * cexpr_t a C expression. is used as part of a C statement, when necessary. cexpr_t has 'type' field, which keeps the expression type.
   * citem_t a base class for cinsn_t and cexpr_t, holds common info like the address, label, and opcode.
   * cnumber_t a constant 64-bit number. in addition to its value also holds information how to represent it: decimal, hex, or as a symbolic constant (enum member). please note that numbers are represented by another class (mnumber_t) in microcode.


   See [https://hex-rays.com/blog/hex-rays-decompiler-primer](https://hex-rays.com/blog/hex-rays-decompiler-primer) for more pictures and more details.
   Both microcode and ctree use the following class:
   * lvar_t a local variable. may represent a stack or register variable. a variable has a name, type, location, etc. the list of variables is stored in mba->vars.
   * lvar_locator_t holds a variable location (vdloc_t) and its definition address.
   * vdloc_t describes a variable location, like a register number, a stack offset, or, in complex cases, can be a mix of register and stack locations. very similar to argloc_t, which is used in ida. the differences between argloc_t and vdloc_t are:
   * vdloc_t never uses ARGLOC_REG2
   * vdloc_t uses micro register numbers instead of processor register numbers
   * the stack offsets are never negative in vdloc_t, while in argloc_t there can be negative offsets




   The above are the most important classes in this header file. There are many auxiliary classes, please see their definitions in the header file.
   See also the description of Virtual Machine used by Microcode. 
       



Attributes
----------

.. autoapisummary::

   ida_hexrays.MAX_SUPPORTED_STACK_SIZE
   ida_hexrays.MAX_VLR_SIZE
   ida_hexrays.CMP_NZ
   ida_hexrays.CMP_Z
   ida_hexrays.CMP_AE
   ida_hexrays.CMP_B
   ida_hexrays.CMP_A
   ida_hexrays.CMP_BE
   ida_hexrays.CMP_GT
   ida_hexrays.CMP_GE
   ida_hexrays.CMP_LT
   ida_hexrays.CMP_LE
   ida_hexrays.cvar
   ida_hexrays.MAX_VLR_VALUE
   ida_hexrays.MAX_VLR_SVALUE
   ida_hexrays.MIN_VLR_SVALUE
   ida_hexrays.MERR_OK
   ida_hexrays.MERR_BLOCK
   ida_hexrays.MERR_INTERR
   ida_hexrays.MERR_INSN
   ida_hexrays.MERR_MEM
   ida_hexrays.MERR_BADBLK
   ida_hexrays.MERR_BADSP
   ida_hexrays.MERR_PROLOG
   ida_hexrays.MERR_SWITCH
   ida_hexrays.MERR_EXCEPTION
   ida_hexrays.MERR_HUGESTACK
   ida_hexrays.MERR_LVARS
   ida_hexrays.MERR_BITNESS
   ida_hexrays.MERR_BADCALL
   ida_hexrays.MERR_BADFRAME
   ida_hexrays.MERR_UNKTYPE
   ida_hexrays.MERR_BADIDB
   ida_hexrays.MERR_SIZEOF
   ida_hexrays.MERR_REDO
   ida_hexrays.MERR_CANCELED
   ida_hexrays.MERR_RECDEPTH
   ida_hexrays.MERR_OVERLAP
   ida_hexrays.MERR_PARTINIT
   ida_hexrays.MERR_COMPLEX
   ida_hexrays.MERR_LICENSE
   ida_hexrays.MERR_ONLY32
   ida_hexrays.MERR_ONLY64
   ida_hexrays.MERR_BUSY
   ida_hexrays.MERR_FARPTR
   ida_hexrays.MERR_EXTERN
   ida_hexrays.MERR_FUNCSIZE
   ida_hexrays.MERR_BADRANGES
   ida_hexrays.MERR_BADARCH
   ida_hexrays.MERR_DSLOT
   ida_hexrays.MERR_STOP
   ida_hexrays.MERR_CLOUD
   ida_hexrays.MERR_EMULATOR
   ida_hexrays.MERR_MAX_ERR
   ida_hexrays.MERR_LOOP
   ida_hexrays.m_nop
   ida_hexrays.m_stx
   ida_hexrays.m_ldx
   ida_hexrays.m_ldc
   ida_hexrays.m_mov
   ida_hexrays.m_neg
   ida_hexrays.m_lnot
   ida_hexrays.m_bnot
   ida_hexrays.m_xds
   ida_hexrays.m_xdu
   ida_hexrays.m_low
   ida_hexrays.m_high
   ida_hexrays.m_add
   ida_hexrays.m_sub
   ida_hexrays.m_mul
   ida_hexrays.m_udiv
   ida_hexrays.m_sdiv
   ida_hexrays.m_umod
   ida_hexrays.m_smod
   ida_hexrays.m_or
   ida_hexrays.m_and
   ida_hexrays.m_xor
   ida_hexrays.m_shl
   ida_hexrays.m_shr
   ida_hexrays.m_sar
   ida_hexrays.m_cfadd
   ida_hexrays.m_ofadd
   ida_hexrays.m_cfshl
   ida_hexrays.m_cfshr
   ida_hexrays.m_sets
   ida_hexrays.m_seto
   ida_hexrays.m_setp
   ida_hexrays.m_setnz
   ida_hexrays.m_setz
   ida_hexrays.m_setae
   ida_hexrays.m_setb
   ida_hexrays.m_seta
   ida_hexrays.m_setbe
   ida_hexrays.m_setg
   ida_hexrays.m_setge
   ida_hexrays.m_setl
   ida_hexrays.m_setle
   ida_hexrays.m_jcnd
   ida_hexrays.m_jnz
   ida_hexrays.m_jz
   ida_hexrays.m_jae
   ida_hexrays.m_jb
   ida_hexrays.m_ja
   ida_hexrays.m_jbe
   ida_hexrays.m_jg
   ida_hexrays.m_jge
   ida_hexrays.m_jl
   ida_hexrays.m_jle
   ida_hexrays.m_jtbl
   ida_hexrays.m_ijmp
   ida_hexrays.m_goto
   ida_hexrays.m_call
   ida_hexrays.m_icall
   ida_hexrays.m_ret
   ida_hexrays.m_push
   ida_hexrays.m_pop
   ida_hexrays.m_und
   ida_hexrays.m_ext
   ida_hexrays.m_f2i
   ida_hexrays.m_f2u
   ida_hexrays.m_i2f
   ida_hexrays.m_u2f
   ida_hexrays.m_f2f
   ida_hexrays.m_fneg
   ida_hexrays.m_fadd
   ida_hexrays.m_fsub
   ida_hexrays.m_fmul
   ida_hexrays.m_fdiv
   ida_hexrays.MUST_ACCESS
   ida_hexrays.MAY_ACCESS
   ida_hexrays.MAYMUST_ACCESS_MASK
   ida_hexrays.ONE_ACCESS_TYPE
   ida_hexrays.INCLUDE_SPOILED_REGS
   ida_hexrays.EXCLUDE_PASS_REGS
   ida_hexrays.FULL_XDSU
   ida_hexrays.WITH_ASSERTS
   ida_hexrays.EXCLUDE_VOLATILE
   ida_hexrays.INCLUDE_UNUSED_SRC
   ida_hexrays.INCLUDE_DEAD_RETREGS
   ida_hexrays.INCLUDE_RESTRICTED
   ida_hexrays.CALL_SPOILS_ONLY_ARGS
   ida_hexrays.mr_none
   ida_hexrays.mr_cf
   ida_hexrays.mr_zf
   ida_hexrays.mr_sf
   ida_hexrays.mr_of
   ida_hexrays.mr_pf
   ida_hexrays.cc_count
   ida_hexrays.mr_cc
   ida_hexrays.mr_first
   ida_hexrays.NF_FIXED
   ida_hexrays.NF_NEGDONE
   ida_hexrays.NF_BINVDONE
   ida_hexrays.NF_NEGATE
   ida_hexrays.NF_BITNOT
   ida_hexrays.NF_VALID
   ida_hexrays.GUESSED_NONE
   ida_hexrays.GUESSED_WEAK
   ida_hexrays.GUESSED_FUNC
   ida_hexrays.GUESSED_DATA
   ida_hexrays.TS_NOELL
   ida_hexrays.TS_SHRINK
   ida_hexrays.TS_DONTREF
   ida_hexrays.TS_MASK
   ida_hexrays.SVW_INT
   ida_hexrays.SVW_FLOAT
   ida_hexrays.SVW_SOFT
   ida_hexrays.LVINF_KEEP
   ida_hexrays.LVINF_SPLIT
   ida_hexrays.LVINF_NOPTR
   ida_hexrays.LVINF_NOMAP
   ida_hexrays.LVINF_UNUSED
   ida_hexrays.ULV_PRECISE_DEFEA
   ida_hexrays.MLI_NAME
   ida_hexrays.MLI_TYPE
   ida_hexrays.MLI_CMT
   ida_hexrays.MLI_SET_FLAGS
   ida_hexrays.MLI_CLR_FLAGS
   ida_hexrays.bitset_width
   ida_hexrays.bitset_align
   ida_hexrays.bitset_shift
   ida_hexrays.mop_z
   ida_hexrays.mop_r
   ida_hexrays.mop_n
   ida_hexrays.mop_str
   ida_hexrays.mop_d
   ida_hexrays.mop_S
   ida_hexrays.mop_v
   ida_hexrays.mop_b
   ida_hexrays.mop_f
   ida_hexrays.mop_l
   ida_hexrays.mop_a
   ida_hexrays.mop_h
   ida_hexrays.mop_c
   ida_hexrays.mop_fn
   ida_hexrays.mop_p
   ida_hexrays.mop_sc
   ida_hexrays.NOSIZE
   ida_hexrays.SHINS_NUMADDR
   ida_hexrays.SHINS_VALNUM
   ida_hexrays.SHINS_SHORT
   ida_hexrays.SHINS_LDXEA
   ida_hexrays.NO_SIDEFF
   ida_hexrays.WITH_SIDEFF
   ida_hexrays.ONLY_SIDEFF
   ida_hexrays.ANY_REGSIZE
   ida_hexrays.ANY_FPSIZE
   ida_hexrays.OPROP_IMPDONE
   ida_hexrays.OPROP_UDT
   ida_hexrays.OPROP_FLOAT
   ida_hexrays.OPROP_CCFLAGS
   ida_hexrays.OPROP_UDEFVAL
   ida_hexrays.OPROP_LOWADDR
   ida_hexrays.OPROP_ABI
   ida_hexrays.ROLE_UNK
   ida_hexrays.ROLE_EMPTY
   ida_hexrays.ROLE_MEMSET
   ida_hexrays.ROLE_MEMSET32
   ida_hexrays.ROLE_MEMSET64
   ida_hexrays.ROLE_MEMCPY
   ida_hexrays.ROLE_STRCPY
   ida_hexrays.ROLE_STRLEN
   ida_hexrays.ROLE_STRCAT
   ida_hexrays.ROLE_TAIL
   ida_hexrays.ROLE_BUG
   ida_hexrays.ROLE_ALLOCA
   ida_hexrays.ROLE_BSWAP
   ida_hexrays.ROLE_PRESENT
   ida_hexrays.ROLE_CONTAINING_RECORD
   ida_hexrays.ROLE_FASTFAIL
   ida_hexrays.ROLE_READFLAGS
   ida_hexrays.ROLE_IS_MUL_OK
   ida_hexrays.ROLE_SATURATED_MUL
   ida_hexrays.ROLE_BITTEST
   ida_hexrays.ROLE_BITTESTANDSET
   ida_hexrays.ROLE_BITTESTANDRESET
   ida_hexrays.ROLE_BITTESTANDCOMPLEMENT
   ida_hexrays.ROLE_VA_ARG
   ida_hexrays.ROLE_VA_COPY
   ida_hexrays.ROLE_VA_START
   ida_hexrays.ROLE_VA_END
   ida_hexrays.ROLE_ROL
   ida_hexrays.ROLE_ROR
   ida_hexrays.ROLE_CFSUB3
   ida_hexrays.ROLE_OFSUB3
   ida_hexrays.ROLE_ABS
   ida_hexrays.ROLE_3WAYCMP0
   ida_hexrays.ROLE_3WAYCMP1
   ida_hexrays.ROLE_WMEMCPY
   ida_hexrays.ROLE_WMEMSET
   ida_hexrays.ROLE_WCSCPY
   ida_hexrays.ROLE_WCSLEN
   ida_hexrays.ROLE_WCSCAT
   ida_hexrays.ROLE_SSE_CMP4
   ida_hexrays.ROLE_SSE_CMP8
   ida_hexrays.FUNC_NAME_MEMCPY
   ida_hexrays.FUNC_NAME_WMEMCPY
   ida_hexrays.FUNC_NAME_MEMSET
   ida_hexrays.FUNC_NAME_WMEMSET
   ida_hexrays.FUNC_NAME_MEMSET32
   ida_hexrays.FUNC_NAME_MEMSET64
   ida_hexrays.FUNC_NAME_STRCPY
   ida_hexrays.FUNC_NAME_WCSCPY
   ida_hexrays.FUNC_NAME_STRLEN
   ida_hexrays.FUNC_NAME_WCSLEN
   ida_hexrays.FUNC_NAME_STRCAT
   ida_hexrays.FUNC_NAME_WCSCAT
   ida_hexrays.FUNC_NAME_TAIL
   ida_hexrays.FUNC_NAME_VA_ARG
   ida_hexrays.FUNC_NAME_EMPTY
   ida_hexrays.FUNC_NAME_PRESENT
   ida_hexrays.FUNC_NAME_CONTAINING_RECORD
   ida_hexrays.FUNC_NAME_MORESTACK
   ida_hexrays.FCI_PROP
   ida_hexrays.FCI_DEAD
   ida_hexrays.FCI_FINAL
   ida_hexrays.FCI_NORET
   ida_hexrays.FCI_PURE
   ida_hexrays.FCI_NOSIDE
   ida_hexrays.FCI_SPLOK
   ida_hexrays.FCI_HASCALL
   ida_hexrays.FCI_HASFMT
   ida_hexrays.FCI_EXPLOCS
   ida_hexrays.CHF_INITED
   ida_hexrays.CHF_REPLACED
   ida_hexrays.CHF_OVER
   ida_hexrays.CHF_FAKE
   ida_hexrays.CHF_PASSTHRU
   ida_hexrays.CHF_TERM
   ida_hexrays.SIZEOF_BLOCK_CHAINS
   ida_hexrays.GCA_EMPTY
   ida_hexrays.GCA_SPEC
   ida_hexrays.GCA_ALLOC
   ida_hexrays.GCA_NALLOC
   ida_hexrays.GCA_OFIRST
   ida_hexrays.GCA_OLAST
   ida_hexrays.IPROP_OPTIONAL
   ida_hexrays.IPROP_PERSIST
   ida_hexrays.IPROP_WILDMATCH
   ida_hexrays.IPROP_CLNPOP
   ida_hexrays.IPROP_FPINSN
   ida_hexrays.IPROP_FARCALL
   ida_hexrays.IPROP_TAILCALL
   ida_hexrays.IPROP_ASSERT
   ida_hexrays.IPROP_SPLIT
   ida_hexrays.IPROP_SPLIT1
   ida_hexrays.IPROP_SPLIT2
   ida_hexrays.IPROP_SPLIT4
   ida_hexrays.IPROP_SPLIT8
   ida_hexrays.IPROP_COMBINED
   ida_hexrays.IPROP_EXTSTX
   ida_hexrays.IPROP_IGNLOWSRC
   ida_hexrays.IPROP_INV_JX
   ida_hexrays.IPROP_WAS_NORET
   ida_hexrays.IPROP_MULTI_MOV
   ida_hexrays.IPROP_DONT_PROP
   ida_hexrays.IPROP_DONT_COMB
   ida_hexrays.IPROP_MBARRIER
   ida_hexrays.IPROP_UNMERGED
   ida_hexrays.IPROP_UNPAIRED
   ida_hexrays.OPTI_ADDREXPRS
   ida_hexrays.OPTI_MINSTKREF
   ida_hexrays.OPTI_COMBINSNS
   ida_hexrays.OPTI_NO_LDXOPT
   ida_hexrays.OPTI_NO_VALRNG
   ida_hexrays.EQ_IGNSIZE
   ida_hexrays.EQ_IGNCODE
   ida_hexrays.EQ_CMPDEST
   ida_hexrays.EQ_OPTINSN
   ida_hexrays.NORET_IGNORE_WAS_NORET_ICALL
   ida_hexrays.NORET_FORBID_ANALYSIS
   ida_hexrays.BLT_NONE
   ida_hexrays.BLT_STOP
   ida_hexrays.BLT_0WAY
   ida_hexrays.BLT_1WAY
   ida_hexrays.BLT_2WAY
   ida_hexrays.BLT_NWAY
   ida_hexrays.BLT_XTRN
   ida_hexrays.MBL_PRIV
   ida_hexrays.MBL_NONFAKE
   ida_hexrays.MBL_FAKE
   ida_hexrays.MBL_GOTO
   ida_hexrays.MBL_TCAL
   ida_hexrays.MBL_PUSH
   ida_hexrays.MBL_DMT64
   ida_hexrays.MBL_COMB
   ida_hexrays.MBL_PROP
   ida_hexrays.MBL_DEAD
   ida_hexrays.MBL_LIST
   ida_hexrays.MBL_INCONST
   ida_hexrays.MBL_CALL
   ida_hexrays.MBL_BACKPROP
   ida_hexrays.MBL_NORET
   ida_hexrays.MBL_DSLOT
   ida_hexrays.MBL_VALRANGES
   ida_hexrays.MBL_KEEP
   ida_hexrays.MBL_INLINED
   ida_hexrays.MBL_EXTFRAME
   ida_hexrays.FD_BACKWARD
   ida_hexrays.FD_FORWARD
   ida_hexrays.FD_USE
   ida_hexrays.FD_DEF
   ida_hexrays.FD_DIRTY
   ida_hexrays.VR_AT_START
   ida_hexrays.VR_AT_END
   ida_hexrays.VR_EXACT
   ida_hexrays.WARN_VARARG_REGS
   ida_hexrays.WARN_ILL_PURGED
   ida_hexrays.WARN_ILL_FUNCTYPE
   ida_hexrays.WARN_VARARG_TCAL
   ida_hexrays.WARN_VARARG_NOSTK
   ida_hexrays.WARN_VARARG_MANY
   ida_hexrays.WARN_ADDR_OUTARGS
   ida_hexrays.WARN_DEP_UNK_CALLS
   ida_hexrays.WARN_ILL_ELLIPSIS
   ida_hexrays.WARN_GUESSED_TYPE
   ida_hexrays.WARN_EXP_LINVAR
   ida_hexrays.WARN_WIDEN_CHAINS
   ida_hexrays.WARN_BAD_PURGED
   ida_hexrays.WARN_CBUILD_LOOPS
   ida_hexrays.WARN_NO_SAVE_REST
   ida_hexrays.WARN_ODD_INPUT_REG
   ida_hexrays.WARN_ODD_ADDR_USE
   ida_hexrays.WARN_MUST_RET_FP
   ida_hexrays.WARN_ILL_FPU_STACK
   ida_hexrays.WARN_SELFREF_PROP
   ida_hexrays.WARN_WOULD_OVERLAP
   ida_hexrays.WARN_ARRAY_INARG
   ida_hexrays.WARN_MAX_ARGS
   ida_hexrays.WARN_BAD_FIELD_TYPE
   ida_hexrays.WARN_WRITE_CONST
   ida_hexrays.WARN_BAD_RETVAR
   ida_hexrays.WARN_FRAG_LVAR
   ida_hexrays.WARN_HUGE_STKOFF
   ida_hexrays.WARN_UNINITED_REG
   ida_hexrays.WARN_FIXED_INSN
   ida_hexrays.WARN_WRONG_VA_OFF
   ida_hexrays.WARN_CR_NOFIELD
   ida_hexrays.WARN_CR_BADOFF
   ida_hexrays.WARN_BAD_STROFF
   ida_hexrays.WARN_BAD_VARSIZE
   ida_hexrays.WARN_UNSUPP_REG
   ida_hexrays.WARN_UNALIGNED_ARG
   ida_hexrays.WARN_BAD_STD_TYPE
   ida_hexrays.WARN_BAD_CALL_SP
   ida_hexrays.WARN_MISSED_SWITCH
   ida_hexrays.WARN_BAD_SP
   ida_hexrays.WARN_BAD_STKPNT
   ida_hexrays.WARN_UNDEF_LVAR
   ida_hexrays.WARN_JUMPOUT
   ida_hexrays.WARN_BAD_VALRNG
   ida_hexrays.WARN_BAD_SHADOW
   ida_hexrays.WARN_OPT_VALRNG
   ida_hexrays.WARN_RET_LOCREF
   ida_hexrays.WARN_BAD_MAPDST
   ida_hexrays.WARN_BAD_INSN
   ida_hexrays.WARN_ODD_ABI
   ida_hexrays.WARN_UNBALANCED_STACK
   ida_hexrays.WARN_OPT_VALRNG2
   ida_hexrays.WARN_OPT_VALRNG3
   ida_hexrays.WARN_OPT_USELESS_JCND
   ida_hexrays.WARN_SUBFRAME_OVERFLOW
   ida_hexrays.WARN_OPT_VALRNG4
   ida_hexrays.WARN_MAX
   ida_hexrays.MMAT_ZERO
   ida_hexrays.MMAT_GENERATED
   ida_hexrays.MMAT_PREOPTIMIZED
   ida_hexrays.MMAT_LOCOPT
   ida_hexrays.MMAT_CALLS
   ida_hexrays.MMAT_GLBOPT1
   ida_hexrays.MMAT_GLBOPT2
   ida_hexrays.MMAT_GLBOPT3
   ida_hexrays.MMAT_LVARS
   ida_hexrays.MMIDX_GLBLOW
   ida_hexrays.MMIDX_LVARS
   ida_hexrays.MMIDX_RETADDR
   ida_hexrays.MMIDX_SHADOW
   ida_hexrays.MMIDX_ARGS
   ida_hexrays.MMIDX_GLBHIGH
   ida_hexrays.MBA_PRCDEFS
   ida_hexrays.MBA_NOFUNC
   ida_hexrays.MBA_PATTERN
   ida_hexrays.MBA_LOADED
   ida_hexrays.MBA_RETFP
   ida_hexrays.MBA_SPLINFO
   ida_hexrays.MBA_PASSREGS
   ida_hexrays.MBA_THUNK
   ida_hexrays.MBA_CMNSTK
   ida_hexrays.MBA_PREOPT
   ida_hexrays.MBA_CMBBLK
   ida_hexrays.MBA_ASRTOK
   ida_hexrays.MBA_CALLS
   ida_hexrays.MBA_ASRPROP
   ida_hexrays.MBA_SAVRST
   ida_hexrays.MBA_RETREF
   ida_hexrays.MBA_GLBOPT
   ida_hexrays.MBA_LVARS0
   ida_hexrays.MBA_LVARS1
   ida_hexrays.MBA_DELPAIRS
   ida_hexrays.MBA_CHVARS
   ida_hexrays.MBA_SHORT
   ida_hexrays.MBA_COLGDL
   ida_hexrays.MBA_INSGDL
   ida_hexrays.MBA_NICE
   ida_hexrays.MBA_REFINE
   ida_hexrays.MBA_WINGR32
   ida_hexrays.MBA_NUMADDR
   ida_hexrays.MBA_VALNUM
   ida_hexrays.MBA_INITIAL_FLAGS
   ida_hexrays.MBA2_LVARNAMES_OK
   ida_hexrays.MBA2_LVARS_RENAMED
   ida_hexrays.MBA2_OVER_CHAINS
   ida_hexrays.MBA2_VALRNG_DONE
   ida_hexrays.MBA2_IS_CTR
   ida_hexrays.MBA2_IS_DTR
   ida_hexrays.MBA2_ARGIDX_OK
   ida_hexrays.MBA2_NO_DUP_CALLS
   ida_hexrays.MBA2_NO_DUP_LVARS
   ida_hexrays.MBA2_UNDEF_RETVAR
   ida_hexrays.MBA2_ARGIDX_SORTED
   ida_hexrays.MBA2_CODE16_BIT
   ida_hexrays.MBA2_STACK_RETVAL
   ida_hexrays.MBA2_HAS_OUTLINES
   ida_hexrays.MBA2_NO_FRAME
   ida_hexrays.MBA2_PROP_COMPLEX
   ida_hexrays.MBA2_DONT_VERIFY
   ida_hexrays.MBA2_INITIAL_FLAGS
   ida_hexrays.MBA2_ALL_FLAGS
   ida_hexrays.NALT_VD
   ida_hexrays.LOCOPT_ALL
   ida_hexrays.LOCOPT_REFINE
   ida_hexrays.LOCOPT_REFINE2
   ida_hexrays.ACFL_LOCOPT
   ida_hexrays.ACFL_BLKOPT
   ida_hexrays.ACFL_GLBPROP
   ida_hexrays.ACFL_GLBDEL
   ida_hexrays.ACFL_GUESS
   ida_hexrays.CPBLK_FAST
   ida_hexrays.CPBLK_MINREF
   ida_hexrays.CPBLK_OPTJMP
   ida_hexrays.INLINE_EXTFRAME
   ida_hexrays.INLINE_DONTCOPY
   ida_hexrays.GC_REGS_AND_STKVARS
   ida_hexrays.GC_ASR
   ida_hexrays.GC_XDSU
   ida_hexrays.GC_END
   ida_hexrays.GC_DIRTY_ALL
   ida_hexrays.OPF_REUSE
   ida_hexrays.OPF_NEW_WINDOW
   ida_hexrays.OPF_REUSE_ACTIVE
   ida_hexrays.OPF_NO_WAIT
   ida_hexrays.OPF_WINDOW_MGMT_MASK
   ida_hexrays.VDRUN_NEWFILE
   ida_hexrays.VDRUN_APPEND
   ida_hexrays.VDRUN_ONLYNEW
   ida_hexrays.VDRUN_SILENT
   ida_hexrays.VDRUN_SENDIDB
   ida_hexrays.VDRUN_MAYSTOP
   ida_hexrays.VDRUN_CMDLINE
   ida_hexrays.VDRUN_STATS
   ida_hexrays.VDRUN_LUMINA
   ida_hexrays.VDRUN_PERF
   ida_hexrays.GCO_STK
   ida_hexrays.GCO_REG
   ida_hexrays.GCO_USE
   ida_hexrays.GCO_DEF
   ida_hexrays.cot_empty
   ida_hexrays.cot_comma
   ida_hexrays.cot_asg
   ida_hexrays.cot_asgbor
   ida_hexrays.cot_asgxor
   ida_hexrays.cot_asgband
   ida_hexrays.cot_asgadd
   ida_hexrays.cot_asgsub
   ida_hexrays.cot_asgmul
   ida_hexrays.cot_asgsshr
   ida_hexrays.cot_asgushr
   ida_hexrays.cot_asgshl
   ida_hexrays.cot_asgsdiv
   ida_hexrays.cot_asgudiv
   ida_hexrays.cot_asgsmod
   ida_hexrays.cot_asgumod
   ida_hexrays.cot_tern
   ida_hexrays.cot_lor
   ida_hexrays.cot_land
   ida_hexrays.cot_bor
   ida_hexrays.cot_xor
   ida_hexrays.cot_band
   ida_hexrays.cot_eq
   ida_hexrays.cot_ne
   ida_hexrays.cot_sge
   ida_hexrays.cot_uge
   ida_hexrays.cot_sle
   ida_hexrays.cot_ule
   ida_hexrays.cot_sgt
   ida_hexrays.cot_ugt
   ida_hexrays.cot_slt
   ida_hexrays.cot_ult
   ida_hexrays.cot_sshr
   ida_hexrays.cot_ushr
   ida_hexrays.cot_shl
   ida_hexrays.cot_add
   ida_hexrays.cot_sub
   ida_hexrays.cot_mul
   ida_hexrays.cot_sdiv
   ida_hexrays.cot_udiv
   ida_hexrays.cot_smod
   ida_hexrays.cot_umod
   ida_hexrays.cot_fadd
   ida_hexrays.cot_fsub
   ida_hexrays.cot_fmul
   ida_hexrays.cot_fdiv
   ida_hexrays.cot_fneg
   ida_hexrays.cot_neg
   ida_hexrays.cot_cast
   ida_hexrays.cot_lnot
   ida_hexrays.cot_bnot
   ida_hexrays.cot_ptr
   ida_hexrays.cot_ref
   ida_hexrays.cot_postinc
   ida_hexrays.cot_postdec
   ida_hexrays.cot_preinc
   ida_hexrays.cot_predec
   ida_hexrays.cot_call
   ida_hexrays.cot_idx
   ida_hexrays.cot_memref
   ida_hexrays.cot_memptr
   ida_hexrays.cot_num
   ida_hexrays.cot_fnum
   ida_hexrays.cot_str
   ida_hexrays.cot_obj
   ida_hexrays.cot_var
   ida_hexrays.cot_insn
   ida_hexrays.cot_sizeof
   ida_hexrays.cot_helper
   ida_hexrays.cot_type
   ida_hexrays.cot_last
   ida_hexrays.cit_empty
   ida_hexrays.cit_block
   ida_hexrays.cit_expr
   ida_hexrays.cit_if
   ida_hexrays.cit_for
   ida_hexrays.cit_while
   ida_hexrays.cit_do
   ida_hexrays.cit_switch
   ida_hexrays.cit_break
   ida_hexrays.cit_continue
   ida_hexrays.cit_return
   ida_hexrays.cit_goto
   ida_hexrays.cit_asm
   ida_hexrays.cit_try
   ida_hexrays.cit_throw
   ida_hexrays.cit_end
   ida_hexrays.CMAT_ZERO
   ida_hexrays.CMAT_BUILT
   ida_hexrays.CMAT_TRANS1
   ida_hexrays.CMAT_NICE
   ida_hexrays.CMAT_TRANS2
   ida_hexrays.CMAT_CPA
   ida_hexrays.CMAT_TRANS3
   ida_hexrays.CMAT_CASTED
   ida_hexrays.CMAT_FINAL
   ida_hexrays.ITP_EMPTY
   ida_hexrays.ITP_ARG1
   ida_hexrays.ITP_ARG64
   ida_hexrays.ITP_BRACE1
   ida_hexrays.ITP_INNER_LAST
   ida_hexrays.ITP_ASM
   ida_hexrays.ITP_ELSE
   ida_hexrays.ITP_DO
   ida_hexrays.ITP_SEMI
   ida_hexrays.ITP_CURLY1
   ida_hexrays.ITP_CURLY2
   ida_hexrays.ITP_BRACE2
   ida_hexrays.ITP_COLON
   ida_hexrays.ITP_BLOCK1
   ida_hexrays.ITP_BLOCK2
   ida_hexrays.ITP_TRY
   ida_hexrays.ITP_CASE
   ida_hexrays.ITP_SIGN
   ida_hexrays.RETRIEVE_ONCE
   ida_hexrays.RETRIEVE_ALWAYS
   ida_hexrays.EXFL_CPADONE
   ida_hexrays.EXFL_LVALUE
   ida_hexrays.EXFL_FPOP
   ida_hexrays.EXFL_ALONE
   ida_hexrays.EXFL_CSTR
   ida_hexrays.EXFL_PARTIAL
   ida_hexrays.EXFL_UNDEF
   ida_hexrays.EXFL_JUMPOUT
   ida_hexrays.EXFL_VFTABLE
   ida_hexrays.EXFL_ALL
   ida_hexrays.CALC_CURLY_BRACES
   ida_hexrays.NO_CURLY_BRACES
   ida_hexrays.USE_CURLY_BRACES
   ida_hexrays.CFL_FINAL
   ida_hexrays.CFL_HELPER
   ida_hexrays.CFL_NORET
   ida_hexrays.CV_FAST
   ida_hexrays.CV_PRUNE
   ida_hexrays.CV_PARENTS
   ida_hexrays.CV_POST
   ida_hexrays.CV_RESTART
   ida_hexrays.CV_INSNS
   ida_hexrays.ANCHOR_INDEX
   ida_hexrays.ANCHOR_MASK
   ida_hexrays.ANCHOR_CITEM
   ida_hexrays.ANCHOR_LVAR
   ida_hexrays.ANCHOR_ITP
   ida_hexrays.ANCHOR_BLKCMT
   ida_hexrays.VDI_NONE
   ida_hexrays.VDI_EXPR
   ida_hexrays.VDI_LVAR
   ida_hexrays.VDI_FUNC
   ida_hexrays.VDI_TAIL
   ida_hexrays.GLN_CURRENT
   ida_hexrays.GLN_GOTO_TARGET
   ida_hexrays.GLN_ALL
   ida_hexrays.FORBID_UNUSED_LABELS
   ida_hexrays.ALLOW_UNUSED_LABELS
   ida_hexrays.CIT_COLLAPSED
   ida_hexrays.CFS_BOUNDS
   ida_hexrays.CFS_TEXT
   ida_hexrays.CFS_LVARS_HIDDEN
   ida_hexrays.CFS_LOCKED
   ida_hexrays.DECOMP_NO_WAIT
   ida_hexrays.DECOMP_NO_CACHE
   ida_hexrays.DECOMP_NO_FRAME
   ida_hexrays.DECOMP_WARNINGS
   ida_hexrays.DECOMP_ALL_BLKS
   ida_hexrays.DECOMP_NO_HIDE
   ida_hexrays.DECOMP_GXREFS_DEFLT
   ida_hexrays.DECOMP_GXREFS_NOUPD
   ida_hexrays.DECOMP_GXREFS_FORCE
   ida_hexrays.DECOMP_VOID_MBA
   ida_hexrays.DECOMP_OUTLINE
   ida_hexrays.hxe_flowchart
   ida_hexrays.hxe_stkpnts
   ida_hexrays.hxe_prolog
   ida_hexrays.hxe_microcode
   ida_hexrays.hxe_preoptimized
   ida_hexrays.hxe_locopt
   ida_hexrays.hxe_prealloc
   ida_hexrays.hxe_glbopt
   ida_hexrays.hxe_pre_structural
   ida_hexrays.hxe_structural
   ida_hexrays.hxe_maturity
   ida_hexrays.hxe_interr
   ida_hexrays.hxe_combine
   ida_hexrays.hxe_print_func
   ida_hexrays.hxe_func_printed
   ida_hexrays.hxe_resolve_stkaddrs
   ida_hexrays.hxe_build_callinfo
   ida_hexrays.hxe_callinfo_built
   ida_hexrays.hxe_calls_done
   ida_hexrays.hxe_begin_inlining
   ida_hexrays.hxe_inlining_func
   ida_hexrays.hxe_inlined_func
   ida_hexrays.hxe_collect_warnings
   ida_hexrays.hxe_open_pseudocode
   ida_hexrays.hxe_switch_pseudocode
   ida_hexrays.hxe_refresh_pseudocode
   ida_hexrays.hxe_close_pseudocode
   ida_hexrays.hxe_keyboard
   ida_hexrays.hxe_right_click
   ida_hexrays.hxe_double_click
   ida_hexrays.hxe_curpos
   ida_hexrays.hxe_create_hint
   ida_hexrays.hxe_text_ready
   ida_hexrays.hxe_populating_popup
   ida_hexrays.lxe_lvar_name_changed
   ida_hexrays.lxe_lvar_type_changed
   ida_hexrays.lxe_lvar_cmt_changed
   ida_hexrays.lxe_lvar_mapping_changed
   ida_hexrays.hxe_cmt_changed
   ida_hexrays.hxe_mba_maturity
   ida_hexrays.USE_KEYBOARD
   ida_hexrays.USE_MOUSE
   ida_hexrays.HEXRAYS_API_MAGIC
   ida_hexrays.CMT_NONE
   ida_hexrays.CMT_TAIL
   ida_hexrays.CMT_BLOCK1
   ida_hexrays.CMT_BLOCK2
   ida_hexrays.CMT_LVAR
   ida_hexrays.CMT_FUNC
   ida_hexrays.CMT_ALL
   ida_hexrays.VDUI_VISIBLE
   ida_hexrays.VDUI_VALID
   ida_hexrays.hx_user_numforms_begin
   ida_hexrays.hx_user_numforms_end
   ida_hexrays.hx_user_numforms_next
   ida_hexrays.hx_user_numforms_prev
   ida_hexrays.hx_user_numforms_first
   ida_hexrays.hx_user_numforms_second
   ida_hexrays.hx_user_numforms_find
   ida_hexrays.hx_user_numforms_insert
   ida_hexrays.hx_user_numforms_erase
   ida_hexrays.hx_user_numforms_clear
   ida_hexrays.hx_user_numforms_size
   ida_hexrays.hx_user_numforms_free
   ida_hexrays.hx_user_numforms_new
   ida_hexrays.hx_lvar_mapping_begin
   ida_hexrays.hx_lvar_mapping_end
   ida_hexrays.hx_lvar_mapping_next
   ida_hexrays.hx_lvar_mapping_prev
   ida_hexrays.hx_lvar_mapping_first
   ida_hexrays.hx_lvar_mapping_second
   ida_hexrays.hx_lvar_mapping_find
   ida_hexrays.hx_lvar_mapping_insert
   ida_hexrays.hx_lvar_mapping_erase
   ida_hexrays.hx_lvar_mapping_clear
   ida_hexrays.hx_lvar_mapping_size
   ida_hexrays.hx_lvar_mapping_free
   ida_hexrays.hx_lvar_mapping_new
   ida_hexrays.hx_udcall_map_begin
   ida_hexrays.hx_udcall_map_end
   ida_hexrays.hx_udcall_map_next
   ida_hexrays.hx_udcall_map_prev
   ida_hexrays.hx_udcall_map_first
   ida_hexrays.hx_udcall_map_second
   ida_hexrays.hx_udcall_map_find
   ida_hexrays.hx_udcall_map_insert
   ida_hexrays.hx_udcall_map_erase
   ida_hexrays.hx_udcall_map_clear
   ida_hexrays.hx_udcall_map_size
   ida_hexrays.hx_udcall_map_free
   ida_hexrays.hx_udcall_map_new
   ida_hexrays.hx_user_cmts_begin
   ida_hexrays.hx_user_cmts_end
   ida_hexrays.hx_user_cmts_next
   ida_hexrays.hx_user_cmts_prev
   ida_hexrays.hx_user_cmts_first
   ida_hexrays.hx_user_cmts_second
   ida_hexrays.hx_user_cmts_find
   ida_hexrays.hx_user_cmts_insert
   ida_hexrays.hx_user_cmts_erase
   ida_hexrays.hx_user_cmts_clear
   ida_hexrays.hx_user_cmts_size
   ida_hexrays.hx_user_cmts_free
   ida_hexrays.hx_user_cmts_new
   ida_hexrays.hx_user_iflags_begin
   ida_hexrays.hx_user_iflags_end
   ida_hexrays.hx_user_iflags_next
   ida_hexrays.hx_user_iflags_prev
   ida_hexrays.hx_user_iflags_first
   ida_hexrays.hx_user_iflags_second
   ida_hexrays.hx_user_iflags_find
   ida_hexrays.hx_user_iflags_insert
   ida_hexrays.hx_user_iflags_erase
   ida_hexrays.hx_user_iflags_clear
   ida_hexrays.hx_user_iflags_size
   ida_hexrays.hx_user_iflags_free
   ida_hexrays.hx_user_iflags_new
   ida_hexrays.hx_user_unions_begin
   ida_hexrays.hx_user_unions_end
   ida_hexrays.hx_user_unions_next
   ida_hexrays.hx_user_unions_prev
   ida_hexrays.hx_user_unions_first
   ida_hexrays.hx_user_unions_second
   ida_hexrays.hx_user_unions_find
   ida_hexrays.hx_user_unions_insert
   ida_hexrays.hx_user_unions_erase
   ida_hexrays.hx_user_unions_clear
   ida_hexrays.hx_user_unions_size
   ida_hexrays.hx_user_unions_free
   ida_hexrays.hx_user_unions_new
   ida_hexrays.hx_user_labels_begin
   ida_hexrays.hx_user_labels_end
   ida_hexrays.hx_user_labels_next
   ida_hexrays.hx_user_labels_prev
   ida_hexrays.hx_user_labels_first
   ida_hexrays.hx_user_labels_second
   ida_hexrays.hx_user_labels_find
   ida_hexrays.hx_user_labels_insert
   ida_hexrays.hx_user_labels_erase
   ida_hexrays.hx_user_labels_clear
   ida_hexrays.hx_user_labels_size
   ida_hexrays.hx_user_labels_free
   ida_hexrays.hx_user_labels_new
   ida_hexrays.hx_eamap_begin
   ida_hexrays.hx_eamap_end
   ida_hexrays.hx_eamap_next
   ida_hexrays.hx_eamap_prev
   ida_hexrays.hx_eamap_first
   ida_hexrays.hx_eamap_second
   ida_hexrays.hx_eamap_find
   ida_hexrays.hx_eamap_insert
   ida_hexrays.hx_eamap_erase
   ida_hexrays.hx_eamap_clear
   ida_hexrays.hx_eamap_size
   ida_hexrays.hx_eamap_free
   ida_hexrays.hx_eamap_new
   ida_hexrays.hx_boundaries_begin
   ida_hexrays.hx_boundaries_end
   ida_hexrays.hx_boundaries_next
   ida_hexrays.hx_boundaries_prev
   ida_hexrays.hx_boundaries_first
   ida_hexrays.hx_boundaries_second
   ida_hexrays.hx_boundaries_find
   ida_hexrays.hx_boundaries_insert
   ida_hexrays.hx_boundaries_erase
   ida_hexrays.hx_boundaries_clear
   ida_hexrays.hx_boundaries_size
   ida_hexrays.hx_boundaries_free
   ida_hexrays.hx_boundaries_new
   ida_hexrays.hx_block_chains_begin
   ida_hexrays.hx_block_chains_end
   ida_hexrays.hx_block_chains_next
   ida_hexrays.hx_block_chains_prev
   ida_hexrays.hx_block_chains_get
   ida_hexrays.hx_block_chains_find
   ida_hexrays.hx_block_chains_insert
   ida_hexrays.hx_block_chains_erase
   ida_hexrays.hx_block_chains_clear
   ida_hexrays.hx_block_chains_size
   ida_hexrays.hx_block_chains_free
   ida_hexrays.hx_block_chains_new
   ida_hexrays.hx_hexrays_alloc
   ida_hexrays.hx_hexrays_free
   ida_hexrays.hx_valrng_t_clear
   ida_hexrays.hx_valrng_t_copy
   ida_hexrays.hx_valrng_t_assign
   ida_hexrays.hx_valrng_t_compare
   ida_hexrays.hx_valrng_t_set_eq
   ida_hexrays.hx_valrng_t_set_cmp
   ida_hexrays.hx_valrng_t_reduce_size
   ida_hexrays.hx_valrng_t_intersect_with
   ida_hexrays.hx_valrng_t_unite_with
   ida_hexrays.hx_valrng_t_inverse
   ida_hexrays.hx_valrng_t_has
   ida_hexrays.hx_valrng_t_print
   ida_hexrays.hx_valrng_t_dstr
   ida_hexrays.hx_valrng_t_cvt_to_single_value
   ida_hexrays.hx_valrng_t_cvt_to_cmp
   ida_hexrays.hx_get_merror_desc
   ida_hexrays.hx_must_mcode_close_block
   ida_hexrays.hx_is_mcode_propagatable
   ida_hexrays.hx_negate_mcode_relation
   ida_hexrays.hx_swap_mcode_relation
   ida_hexrays.hx_get_signed_mcode
   ida_hexrays.hx_get_unsigned_mcode
   ida_hexrays.hx_mcode_modifies_d
   ida_hexrays.hx_operand_locator_t_compare
   ida_hexrays.hx_vd_printer_t_print
   ida_hexrays.hx_file_printer_t_print
   ida_hexrays.hx_qstring_printer_t_print
   ida_hexrays.hx_dstr
   ida_hexrays.hx_is_type_correct
   ida_hexrays.hx_is_small_udt
   ida_hexrays.hx_is_nonbool_type
   ida_hexrays.hx_is_bool_type
   ida_hexrays.hx_partial_type_num
   ida_hexrays.hx_get_float_type
   ida_hexrays.hx_get_int_type_by_width_and_sign
   ida_hexrays.hx_get_unk_type
   ida_hexrays.hx_dummy_ptrtype
   ida_hexrays.hx_get_member_type
   ida_hexrays.hx_make_pointer
   ida_hexrays.hx_create_typedef
   ida_hexrays.hx_get_type
   ida_hexrays.hx_set_type
   ida_hexrays.hx_vdloc_t_dstr
   ida_hexrays.hx_vdloc_t_compare
   ida_hexrays.hx_vdloc_t_is_aliasable
   ida_hexrays.hx_print_vdloc
   ida_hexrays.hx_arglocs_overlap
   ida_hexrays.hx_lvar_locator_t_compare
   ida_hexrays.hx_lvar_locator_t_dstr
   ida_hexrays.hx_lvar_t_dstr
   ida_hexrays.hx_lvar_t_is_promoted_arg
   ida_hexrays.hx_lvar_t_accepts_type
   ida_hexrays.hx_lvar_t_set_lvar_type
   ida_hexrays.hx_lvar_t_set_width
   ida_hexrays.hx_lvar_t_append_list
   ida_hexrays.hx_lvar_t_append_list_
   ida_hexrays.hx_lvars_t_find_stkvar
   ida_hexrays.hx_lvars_t_find
   ida_hexrays.hx_lvars_t_find_lvar
   ida_hexrays.hx_restore_user_lvar_settings
   ida_hexrays.hx_save_user_lvar_settings
   ida_hexrays.hx_modify_user_lvars
   ida_hexrays.hx_modify_user_lvar_info
   ida_hexrays.hx_locate_lvar
   ida_hexrays.hx_restore_user_defined_calls
   ida_hexrays.hx_save_user_defined_calls
   ida_hexrays.hx_parse_user_call
   ida_hexrays.hx_convert_to_user_call
   ida_hexrays.hx_install_microcode_filter
   ida_hexrays.hx_udc_filter_t_cleanup
   ida_hexrays.hx_udc_filter_t_init
   ida_hexrays.hx_udc_filter_t_apply
   ida_hexrays.hx_bitset_t_bitset_t
   ida_hexrays.hx_bitset_t_copy
   ida_hexrays.hx_bitset_t_add
   ida_hexrays.hx_bitset_t_add_
   ida_hexrays.hx_bitset_t_add__
   ida_hexrays.hx_bitset_t_sub
   ida_hexrays.hx_bitset_t_sub_
   ida_hexrays.hx_bitset_t_sub__
   ida_hexrays.hx_bitset_t_cut_at
   ida_hexrays.hx_bitset_t_shift_down
   ida_hexrays.hx_bitset_t_has
   ida_hexrays.hx_bitset_t_has_all
   ida_hexrays.hx_bitset_t_has_any
   ida_hexrays.hx_bitset_t_dstr
   ida_hexrays.hx_bitset_t_empty
   ida_hexrays.hx_bitset_t_count
   ida_hexrays.hx_bitset_t_count_
   ida_hexrays.hx_bitset_t_last
   ida_hexrays.hx_bitset_t_fill_with_ones
   ida_hexrays.hx_bitset_t_fill_gaps
   ida_hexrays.hx_bitset_t_has_common
   ida_hexrays.hx_bitset_t_intersect
   ida_hexrays.hx_bitset_t_is_subset_of
   ida_hexrays.hx_bitset_t_compare
   ida_hexrays.hx_bitset_t_goup
   ida_hexrays.hx_ivl_t_dstr
   ida_hexrays.hx_ivl_t_compare
   ida_hexrays.hx_ivlset_t_add
   ida_hexrays.hx_ivlset_t_add_
   ida_hexrays.hx_ivlset_t_addmasked
   ida_hexrays.hx_ivlset_t_sub
   ida_hexrays.hx_ivlset_t_sub_
   ida_hexrays.hx_ivlset_t_has_common
   ida_hexrays.hx_ivlset_t_print
   ida_hexrays.hx_ivlset_t_dstr
   ida_hexrays.hx_ivlset_t_count
   ida_hexrays.hx_ivlset_t_has_common_
   ida_hexrays.hx_ivlset_t_contains
   ida_hexrays.hx_ivlset_t_includes
   ida_hexrays.hx_ivlset_t_intersect
   ida_hexrays.hx_ivlset_t_compare
   ida_hexrays.hx_rlist_t_print
   ida_hexrays.hx_rlist_t_dstr
   ida_hexrays.hx_mlist_t_addmem
   ida_hexrays.hx_mlist_t_print
   ida_hexrays.hx_mlist_t_dstr
   ida_hexrays.hx_mlist_t_compare
   ida_hexrays.hx_get_temp_regs
   ida_hexrays.hx_is_kreg
   ida_hexrays.hx_reg2mreg
   ida_hexrays.hx_mreg2reg
   ida_hexrays.hx_get_mreg_name
   ida_hexrays.hx_install_optinsn_handler
   ida_hexrays.hx_remove_optinsn_handler
   ida_hexrays.hx_install_optblock_handler
   ida_hexrays.hx_remove_optblock_handler
   ida_hexrays.hx_simple_graph_t_compute_dominators
   ida_hexrays.hx_simple_graph_t_compute_immediate_dominators
   ida_hexrays.hx_simple_graph_t_depth_first_preorder
   ida_hexrays.hx_simple_graph_t_depth_first_postorder
   ida_hexrays.hx_simple_graph_t_goup
   ida_hexrays.hx_mutable_graph_t_resize
   ida_hexrays.hx_mutable_graph_t_goup
   ida_hexrays.hx_mutable_graph_t_del_edge
   ida_hexrays.hx_lvar_ref_t_compare
   ida_hexrays.hx_lvar_ref_t_var
   ida_hexrays.hx_stkvar_ref_t_compare
   ida_hexrays.hx_stkvar_ref_t_get_stkvar
   ida_hexrays.hx_fnumber_t_print
   ida_hexrays.hx_fnumber_t_dstr
   ida_hexrays.hx_mop_t_copy
   ida_hexrays.hx_mop_t_assign
   ida_hexrays.hx_mop_t_swap
   ida_hexrays.hx_mop_t_erase
   ida_hexrays.hx_mop_t_print
   ida_hexrays.hx_mop_t_dstr
   ida_hexrays.hx_mop_t_create_from_mlist
   ida_hexrays.hx_mop_t_create_from_ivlset
   ida_hexrays.hx_mop_t_create_from_vdloc
   ida_hexrays.hx_mop_t_create_from_scattered_vdloc
   ida_hexrays.hx_mop_t_create_from_insn
   ida_hexrays.hx_mop_t_make_number
   ida_hexrays.hx_mop_t_make_fpnum
   ida_hexrays.hx_mop_t__make_gvar
   ida_hexrays.hx_mop_t_make_gvar
   ida_hexrays.hx_mop_t_make_reg_pair
   ida_hexrays.hx_mop_t_make_helper
   ida_hexrays.hx_mop_t_is_bit_reg
   ida_hexrays.hx_mop_t_may_use_aliased_memory
   ida_hexrays.hx_mop_t_is01
   ida_hexrays.hx_mop_t_is_sign_extended_from
   ida_hexrays.hx_mop_t_is_zero_extended_from
   ida_hexrays.hx_mop_t_equal_mops
   ida_hexrays.hx_mop_t_lexcompare
   ida_hexrays.hx_mop_t_for_all_ops
   ida_hexrays.hx_mop_t_for_all_scattered_submops
   ida_hexrays.hx_mop_t_is_constant
   ida_hexrays.hx_mop_t_get_stkoff
   ida_hexrays.hx_mop_t_make_low_half
   ida_hexrays.hx_mop_t_make_high_half
   ida_hexrays.hx_mop_t_make_first_half
   ida_hexrays.hx_mop_t_make_second_half
   ida_hexrays.hx_mop_t_shift_mop
   ida_hexrays.hx_mop_t_change_size
   ida_hexrays.hx_mop_t_preserve_side_effects
   ida_hexrays.hx_mop_t_apply_ld_mcode
   ida_hexrays.hx_mcallarg_t_print
   ida_hexrays.hx_mcallarg_t_dstr
   ida_hexrays.hx_mcallarg_t_set_regarg
   ida_hexrays.hx_mcallinfo_t_lexcompare
   ida_hexrays.hx_mcallinfo_t_set_type
   ida_hexrays.hx_mcallinfo_t_get_type
   ida_hexrays.hx_mcallinfo_t_print
   ida_hexrays.hx_mcallinfo_t_dstr
   ida_hexrays.hx_mcases_t_compare
   ida_hexrays.hx_mcases_t_print
   ida_hexrays.hx_mcases_t_dstr
   ida_hexrays.hx_vivl_t_extend_to_cover
   ida_hexrays.hx_vivl_t_intersect
   ida_hexrays.hx_vivl_t_print
   ida_hexrays.hx_vivl_t_dstr
   ida_hexrays.hx_chain_t_print
   ida_hexrays.hx_chain_t_dstr
   ida_hexrays.hx_chain_t_append_list
   ida_hexrays.hx_chain_t_append_list_
   ida_hexrays.hx_block_chains_t_get_chain
   ida_hexrays.hx_block_chains_t_print
   ida_hexrays.hx_block_chains_t_dstr
   ida_hexrays.hx_graph_chains_t_for_all_chains
   ida_hexrays.hx_graph_chains_t_release
   ida_hexrays.hx_minsn_t_init
   ida_hexrays.hx_minsn_t_copy
   ida_hexrays.hx_minsn_t_set_combined
   ida_hexrays.hx_minsn_t_swap
   ida_hexrays.hx_minsn_t_print
   ida_hexrays.hx_minsn_t_dstr
   ida_hexrays.hx_minsn_t_setaddr
   ida_hexrays.hx_minsn_t_optimize_subtree
   ida_hexrays.hx_minsn_t_for_all_ops
   ida_hexrays.hx_minsn_t_for_all_insns
   ida_hexrays.hx_minsn_t__make_nop
   ida_hexrays.hx_minsn_t_equal_insns
   ida_hexrays.hx_minsn_t_lexcompare
   ida_hexrays.hx_minsn_t_is_noret_call
   ida_hexrays.hx_minsn_t_is_helper
   ida_hexrays.hx_minsn_t_find_call
   ida_hexrays.hx_minsn_t_has_side_effects
   ida_hexrays.hx_minsn_t_find_opcode
   ida_hexrays.hx_minsn_t_find_ins_op
   ida_hexrays.hx_minsn_t_find_num_op
   ida_hexrays.hx_minsn_t_modifies_d
   ida_hexrays.hx_minsn_t_is_between
   ida_hexrays.hx_minsn_t_may_use_aliased_memory
   ida_hexrays.hx_minsn_t_serialize
   ida_hexrays.hx_minsn_t_deserialize
   ida_hexrays.hx_getf_reginsn
   ida_hexrays.hx_getb_reginsn
   ida_hexrays.hx_mblock_t_init
   ida_hexrays.hx_mblock_t_print
   ida_hexrays.hx_mblock_t_dump
   ida_hexrays.hx_mblock_t_vdump_block
   ida_hexrays.hx_mblock_t_insert_into_block
   ida_hexrays.hx_mblock_t_remove_from_block
   ida_hexrays.hx_mblock_t_for_all_insns
   ida_hexrays.hx_mblock_t_for_all_ops
   ida_hexrays.hx_mblock_t_for_all_uses
   ida_hexrays.hx_mblock_t_optimize_insn
   ida_hexrays.hx_mblock_t_optimize_block
   ida_hexrays.hx_mblock_t_build_lists
   ida_hexrays.hx_mblock_t_optimize_useless_jump
   ida_hexrays.hx_mblock_t_append_use_list
   ida_hexrays.hx_mblock_t_append_def_list
   ida_hexrays.hx_mblock_t_build_use_list
   ida_hexrays.hx_mblock_t_build_def_list
   ida_hexrays.hx_mblock_t_find_first_use
   ida_hexrays.hx_mblock_t_find_redefinition
   ida_hexrays.hx_mblock_t_is_rhs_redefined
   ida_hexrays.hx_mblock_t_find_access
   ida_hexrays.hx_mblock_t_get_valranges
   ida_hexrays.hx_mblock_t_get_valranges_
   ida_hexrays.hx_mblock_t_get_reginsn_qty
   ida_hexrays.hx_mba_ranges_t_range_contains
   ida_hexrays.hx_mba_t_stkoff_vd2ida
   ida_hexrays.hx_mba_t_stkoff_ida2vd
   ida_hexrays.hx_mba_t_idaloc2vd
   ida_hexrays.hx_mba_t_idaloc2vd_
   ida_hexrays.hx_mba_t_vd2idaloc
   ida_hexrays.hx_mba_t_vd2idaloc_
   ida_hexrays.hx_mba_t_term
   ida_hexrays.hx_mba_t_get_curfunc
   ida_hexrays.hx_mba_t_set_maturity
   ida_hexrays.hx_mba_t_optimize_local
   ida_hexrays.hx_mba_t_build_graph
   ida_hexrays.hx_mba_t_get_graph
   ida_hexrays.hx_mba_t_analyze_calls
   ida_hexrays.hx_mba_t_optimize_global
   ida_hexrays.hx_mba_t_alloc_lvars
   ida_hexrays.hx_mba_t_dump
   ida_hexrays.hx_mba_t_vdump_mba
   ida_hexrays.hx_mba_t_print
   ida_hexrays.hx_mba_t_verify
   ida_hexrays.hx_mba_t_mark_chains_dirty
   ida_hexrays.hx_mba_t_insert_block
   ida_hexrays.hx_mba_t_remove_block
   ida_hexrays.hx_mba_t_copy_block
   ida_hexrays.hx_mba_t_remove_empty_and_unreachable_blocks
   ida_hexrays.hx_mba_t_merge_blocks
   ida_hexrays.hx_mba_t_for_all_ops
   ida_hexrays.hx_mba_t_for_all_insns
   ida_hexrays.hx_mba_t_for_all_topinsns
   ida_hexrays.hx_mba_t_find_mop
   ida_hexrays.hx_mba_t_create_helper_call
   ida_hexrays.hx_mba_t_get_func_output_lists
   ida_hexrays.hx_mba_t_arg
   ida_hexrays.hx_mba_t_alloc_fict_ea
   ida_hexrays.hx_mba_t_map_fict_ea
   ida_hexrays.hx_mba_t_serialize
   ida_hexrays.hx_mba_t_deserialize
   ida_hexrays.hx_mba_t_save_snapshot
   ida_hexrays.hx_mba_t_alloc_kreg
   ida_hexrays.hx_mba_t_free_kreg
   ida_hexrays.hx_mba_t_inline_func
   ida_hexrays.hx_mba_t_locate_stkpnt
   ida_hexrays.hx_mba_t_set_lvar_name
   ida_hexrays.hx_mbl_graph_t_is_accessed_globally
   ida_hexrays.hx_mbl_graph_t_get_ud
   ida_hexrays.hx_mbl_graph_t_get_du
   ida_hexrays.hx_cdg_insn_iterator_t_next
   ida_hexrays.hx_codegen_t_clear
   ida_hexrays.hx_codegen_t_emit
   ida_hexrays.hx_codegen_t_emit_
   ida_hexrays.hx_change_hexrays_config
   ida_hexrays.hx_get_hexrays_version
   ida_hexrays.hx_open_pseudocode
   ida_hexrays.hx_close_pseudocode
   ida_hexrays.hx_get_widget_vdui
   ida_hexrays.hx_decompile_many
   ida_hexrays.hx_hexrays_failure_t_desc
   ida_hexrays.hx_send_database
   ida_hexrays.hx_gco_info_t_append_to_list
   ida_hexrays.hx_get_current_operand
   ida_hexrays.hx_remitem
   ida_hexrays.hx_negated_relation
   ida_hexrays.hx_swapped_relation
   ida_hexrays.hx_get_op_signness
   ida_hexrays.hx_asgop
   ida_hexrays.hx_asgop_revert
   ida_hexrays.hx_cnumber_t_print
   ida_hexrays.hx_cnumber_t_value
   ida_hexrays.hx_cnumber_t_assign
   ida_hexrays.hx_cnumber_t_compare
   ida_hexrays.hx_var_ref_t_compare
   ida_hexrays.hx_ctree_visitor_t_apply_to
   ida_hexrays.hx_ctree_visitor_t_apply_to_exprs
   ida_hexrays.hx_ctree_parentee_t_recalc_parent_types
   ida_hexrays.hx_cfunc_parentee_t_calc_rvalue_type
   ida_hexrays.hx_citem_locator_t_compare
   ida_hexrays.hx_citem_t_contains_expr
   ida_hexrays.hx_citem_t_contains_label
   ida_hexrays.hx_citem_t_find_parent_of
   ida_hexrays.hx_citem_t_find_closest_addr
   ida_hexrays.hx_cexpr_t_assign
   ida_hexrays.hx_cexpr_t_compare
   ida_hexrays.hx_cexpr_t_replace_by
   ida_hexrays.hx_cexpr_t_cleanup
   ida_hexrays.hx_cexpr_t_put_number
   ida_hexrays.hx_cexpr_t_print1
   ida_hexrays.hx_cexpr_t_calc_type
   ida_hexrays.hx_cexpr_t_equal_effect
   ida_hexrays.hx_cexpr_t_is_child_of
   ida_hexrays.hx_cexpr_t_contains_operator
   ida_hexrays.hx_cexpr_t_get_high_nbit_bound
   ida_hexrays.hx_cexpr_t_get_low_nbit_bound
   ida_hexrays.hx_cexpr_t_requires_lvalue
   ida_hexrays.hx_cexpr_t_has_side_effects
   ida_hexrays.hx_cexpr_t_maybe_ptr
   ida_hexrays.hx_cexpr_t_dstr
   ida_hexrays.hx_cif_t_assign
   ida_hexrays.hx_cif_t_compare
   ida_hexrays.hx_cloop_t_assign
   ida_hexrays.hx_cfor_t_compare
   ida_hexrays.hx_cwhile_t_compare
   ida_hexrays.hx_cdo_t_compare
   ida_hexrays.hx_creturn_t_compare
   ida_hexrays.hx_cthrow_t_compare
   ida_hexrays.hx_cgoto_t_compare
   ida_hexrays.hx_casm_t_compare
   ida_hexrays.hx_cinsn_t_assign
   ida_hexrays.hx_cinsn_t_compare
   ida_hexrays.hx_cinsn_t_replace_by
   ida_hexrays.hx_cinsn_t_cleanup
   ida_hexrays.hx_cinsn_t_new_insn
   ida_hexrays.hx_cinsn_t_create_if
   ida_hexrays.hx_cinsn_t_print
   ida_hexrays.hx_cinsn_t_print1
   ida_hexrays.hx_cinsn_t_is_ordinary_flow
   ida_hexrays.hx_cinsn_t_contains_insn
   ida_hexrays.hx_cinsn_t_collect_free_breaks
   ida_hexrays.hx_cinsn_t_collect_free_continues
   ida_hexrays.hx_cinsn_t_dstr
   ida_hexrays.hx_cblock_t_compare
   ida_hexrays.hx_carglist_t_compare
   ida_hexrays.hx_ccase_t_compare
   ida_hexrays.hx_ccases_t_compare
   ida_hexrays.hx_cswitch_t_compare
   ida_hexrays.hx_ccatch_t_compare
   ida_hexrays.hx_ctry_t_compare
   ida_hexrays.hx_ctree_item_t_get_udm
   ida_hexrays.hx_ctree_item_t_get_edm
   ida_hexrays.hx_ctree_item_t_get_lvar
   ida_hexrays.hx_ctree_item_t_get_ea
   ida_hexrays.hx_ctree_item_t_get_label_num
   ida_hexrays.hx_ctree_item_t_print
   ida_hexrays.hx_ctree_item_t_dstr
   ida_hexrays.hx_lnot
   ida_hexrays.hx_new_block
   ida_hexrays.hx_vcreate_helper
   ida_hexrays.hx_vcall_helper
   ida_hexrays.hx_make_num
   ida_hexrays.hx_make_ref
   ida_hexrays.hx_dereference
   ida_hexrays.hx_save_user_labels
   ida_hexrays.hx_save_user_cmts
   ida_hexrays.hx_save_user_numforms
   ida_hexrays.hx_save_user_iflags
   ida_hexrays.hx_save_user_unions
   ida_hexrays.hx_restore_user_labels
   ida_hexrays.hx_restore_user_cmts
   ida_hexrays.hx_restore_user_numforms
   ida_hexrays.hx_restore_user_iflags
   ida_hexrays.hx_restore_user_unions
   ida_hexrays.hx_cfunc_t_build_c_tree
   ida_hexrays.hx_cfunc_t_verify
   ida_hexrays.hx_cfunc_t_print_dcl
   ida_hexrays.hx_cfunc_t_print_func
   ida_hexrays.hx_cfunc_t_get_func_type
   ida_hexrays.hx_cfunc_t_get_lvars
   ida_hexrays.hx_cfunc_t_get_stkoff_delta
   ida_hexrays.hx_cfunc_t_find_label
   ida_hexrays.hx_cfunc_t_remove_unused_labels
   ida_hexrays.hx_cfunc_t_get_user_cmt
   ida_hexrays.hx_cfunc_t_set_user_cmt
   ida_hexrays.hx_cfunc_t_get_user_iflags
   ida_hexrays.hx_cfunc_t_set_user_iflags
   ida_hexrays.hx_cfunc_t_has_orphan_cmts
   ida_hexrays.hx_cfunc_t_del_orphan_cmts
   ida_hexrays.hx_cfunc_t_get_user_union_selection
   ida_hexrays.hx_cfunc_t_set_user_union_selection
   ida_hexrays.hx_cfunc_t_save_user_labels
   ida_hexrays.hx_cfunc_t_save_user_cmts
   ida_hexrays.hx_cfunc_t_save_user_numforms
   ida_hexrays.hx_cfunc_t_save_user_iflags
   ida_hexrays.hx_cfunc_t_save_user_unions
   ida_hexrays.hx_cfunc_t_get_line_item
   ida_hexrays.hx_cfunc_t_get_warnings
   ida_hexrays.hx_cfunc_t_get_eamap
   ida_hexrays.hx_cfunc_t_get_boundaries
   ida_hexrays.hx_cfunc_t_get_pseudocode
   ida_hexrays.hx_cfunc_t_refresh_func_ctext
   ida_hexrays.hx_cfunc_t_gather_derefs
   ida_hexrays.hx_cfunc_t_find_item_coords
   ida_hexrays.hx_cfunc_t_cleanup
   ida_hexrays.hx_close_hexrays_waitbox
   ida_hexrays.hx_decompile
   ida_hexrays.hx_gen_microcode
   ida_hexrays.hx_create_cfunc
   ida_hexrays.hx_mark_cfunc_dirty
   ida_hexrays.hx_clear_cached_cfuncs
   ida_hexrays.hx_has_cached_cfunc
   ida_hexrays.hx_get_ctype_name
   ida_hexrays.hx_create_field_name
   ida_hexrays.hx_install_hexrays_callback
   ida_hexrays.hx_remove_hexrays_callback
   ida_hexrays.hx_vdui_t_set_locked
   ida_hexrays.hx_vdui_t_refresh_view
   ida_hexrays.hx_vdui_t_refresh_ctext
   ida_hexrays.hx_vdui_t_switch_to
   ida_hexrays.hx_vdui_t_get_number
   ida_hexrays.hx_vdui_t_get_current_label
   ida_hexrays.hx_vdui_t_clear
   ida_hexrays.hx_vdui_t_refresh_cpos
   ida_hexrays.hx_vdui_t_get_current_item
   ida_hexrays.hx_vdui_t_ui_rename_lvar
   ida_hexrays.hx_vdui_t_rename_lvar
   ida_hexrays.hx_vdui_t_ui_set_call_type
   ida_hexrays.hx_vdui_t_ui_set_lvar_type
   ida_hexrays.hx_vdui_t_set_lvar_type
   ida_hexrays.hx_vdui_t_set_noptr_lvar
   ida_hexrays.hx_vdui_t_ui_edit_lvar_cmt
   ida_hexrays.hx_vdui_t_set_lvar_cmt
   ida_hexrays.hx_vdui_t_ui_map_lvar
   ida_hexrays.hx_vdui_t_ui_unmap_lvar
   ida_hexrays.hx_vdui_t_map_lvar
   ida_hexrays.hx_vdui_t_set_udm_type
   ida_hexrays.hx_vdui_t_rename_udm
   ida_hexrays.hx_vdui_t_set_global_type
   ida_hexrays.hx_vdui_t_rename_global
   ida_hexrays.hx_vdui_t_rename_label
   ida_hexrays.hx_vdui_t_jump_enter
   ida_hexrays.hx_vdui_t_ctree_to_disasm
   ida_hexrays.hx_vdui_t_calc_cmt_type
   ida_hexrays.hx_vdui_t_edit_cmt
   ida_hexrays.hx_vdui_t_edit_func_cmt
   ida_hexrays.hx_vdui_t_del_orphan_cmts
   ida_hexrays.hx_vdui_t_set_num_radix
   ida_hexrays.hx_vdui_t_set_num_enum
   ida_hexrays.hx_vdui_t_set_num_stroff
   ida_hexrays.hx_vdui_t_invert_sign
   ida_hexrays.hx_vdui_t_invert_bits
   ida_hexrays.hx_vdui_t_collapse_item
   ida_hexrays.hx_vdui_t_collapse_lvars
   ida_hexrays.hx_vdui_t_split_item
   ida_hexrays.hx_select_udt_by_offset
   ida_hexrays.hx_catchexpr_t_compare
   ida_hexrays.hx_mba_t_split_block
   ida_hexrays.hx_mba_t_remove_blocks
   ida_hexrays.hx_cfunc_t_recalc_item_addresses
   ida_hexrays.hx_int64_emulator_t_mop_value
   ida_hexrays.hx_int64_emulator_t_minsn_value
   ida_hexrays.is_allowed_on_small_struni
   ida_hexrays.is_small_struni
   ida_hexrays.mbl_array_t


Exceptions
----------

.. autoapisummary::

   ida_hexrays.DecompilationFailure


Classes
-------

.. autoapisummary::

   ida_hexrays.array_of_bitsets
   ida_hexrays.mopvec_t
   ida_hexrays.mcallargs_t
   ida_hexrays.block_chains_vec_t
   ida_hexrays.user_numforms_t
   ida_hexrays.lvar_mapping_t
   ida_hexrays.hexwarns_t
   ida_hexrays.ctree_items_t
   ida_hexrays.user_labels_t
   ida_hexrays.user_cmts_t
   ida_hexrays.user_iflags_t
   ida_hexrays.user_unions_t
   ida_hexrays.cinsnptrvec_t
   ida_hexrays.eamap_t
   ida_hexrays.boundaries_t
   ida_hexrays.cfuncptr_t
   ida_hexrays.qvector_history_t
   ida_hexrays.history_t
   ida_hexrays.cinsn_list_t_iterator
   ida_hexrays.cinsn_list_t
   ida_hexrays.qvector_lvar_t
   ida_hexrays.qvector_carg_t
   ida_hexrays.qvector_ccase_t
   ida_hexrays.qvector_catchexprs_t
   ida_hexrays.qvector_ccatchvec_t
   ida_hexrays.cblock_posvec_t
   ida_hexrays.lvar_saved_infos_t
   ida_hexrays.ui_stroff_ops_t
   ida_hexrays.Hexrays_Hooks
   ida_hexrays.uval_ivl_t
   ida_hexrays.uval_ivl_ivlset_t
   ida_hexrays.array_of_ivlsets
   ida_hexrays.valrng_t
   ida_hexrays.operand_locator_t
   ida_hexrays.number_format_t
   ida_hexrays.vd_printer_t
   ida_hexrays.vc_printer_t
   ida_hexrays.qstring_printer_t
   ida_hexrays.vdloc_t
   ida_hexrays.lvar_locator_t
   ida_hexrays.lvar_t
   ida_hexrays.lvars_t
   ida_hexrays.lvar_saved_info_t
   ida_hexrays.lvar_uservec_t
   ida_hexrays.user_lvar_modifier_t
   ida_hexrays.udcall_t
   ida_hexrays.microcode_filter_t
   ida_hexrays.udc_filter_t
   ida_hexrays.bitset_t
   ida_hexrays.iterator
   ida_hexrays.node_bitset_t
   ida_hexrays.array_of_node_bitset_t
   ida_hexrays.ivl_t
   ida_hexrays.ivl_with_name_t
   ida_hexrays.ivlset_t
   ida_hexrays.rlist_t
   ida_hexrays.mlist_t
   ida_hexrays.optinsn_t
   ida_hexrays.optblock_t
   ida_hexrays.simple_graph_t
   ida_hexrays.op_parent_info_t
   ida_hexrays.minsn_visitor_t
   ida_hexrays.mop_visitor_t
   ida_hexrays.scif_visitor_t
   ida_hexrays.mlist_mop_visitor_t
   ida_hexrays.lvar_ref_t
   ida_hexrays.stkvar_ref_t
   ida_hexrays.scif_t
   ida_hexrays.mnumber_t
   ida_hexrays.fnumber_t
   ida_hexrays.mop_t
   ida_hexrays.mop_pair_t
   ida_hexrays.mop_addr_t
   ida_hexrays.mcallarg_t
   ida_hexrays.mcallinfo_t
   ida_hexrays.mcases_t
   ida_hexrays.voff_t
   ida_hexrays.vivl_t
   ida_hexrays.chain_t
   ida_hexrays.block_chains_t
   ida_hexrays.chain_visitor_t
   ida_hexrays.graph_chains_t
   ida_hexrays.minsn_t
   ida_hexrays.intval64_t
   ida_hexrays.int64_emulator_t
   ida_hexrays.mblock_t
   ida_hexrays.hexwarn_t
   ida_hexrays.mba_ranges_t
   ida_hexrays.mba_range_iterator_t
   ida_hexrays.mba_t
   ida_hexrays.chain_keeper_t
   ida_hexrays.mbl_graph_t
   ida_hexrays.cdg_insn_iterator_t
   ida_hexrays.codegen_t
   ida_hexrays.hexrays_failure_t
   ida_hexrays.vd_failure_t
   ida_hexrays.vd_interr_t
   ida_hexrays.gco_info_t
   ida_hexrays.cnumber_t
   ida_hexrays.var_ref_t
   ida_hexrays.treeloc_t
   ida_hexrays.citem_cmt_t
   ida_hexrays.citem_locator_t
   ida_hexrays.bit_bound_t
   ida_hexrays.citem_t
   ida_hexrays.cexpr_t
   ida_hexrays.ceinsn_t
   ida_hexrays.cif_t
   ida_hexrays.cloop_t
   ida_hexrays.cfor_t
   ida_hexrays.cwhile_t
   ida_hexrays.cdo_t
   ida_hexrays.creturn_t
   ida_hexrays.cgoto_t
   ida_hexrays.casm_t
   ida_hexrays.cinsn_t
   ida_hexrays.cblock_t
   ida_hexrays.carg_t
   ida_hexrays.carglist_t
   ida_hexrays.ccase_t
   ida_hexrays.ccases_t
   ida_hexrays.cswitch_t
   ida_hexrays.catchexpr_t
   ida_hexrays.ccatch_t
   ida_hexrays.ctry_t
   ida_hexrays.cthrow_t
   ida_hexrays.cblock_pos_t
   ida_hexrays.ctree_visitor_t
   ida_hexrays.ctree_parentee_t
   ida_hexrays.cfunc_parentee_t
   ida_hexrays.ctree_anchor_t
   ida_hexrays.ctree_item_t
   ida_hexrays.cfunc_t
   ida_hexrays.ctext_position_t
   ida_hexrays.history_item_t
   ida_hexrays.vdui_t
   ida_hexrays.ui_stroff_op_t
   ida_hexrays.ui_stroff_applicator_t
   ida_hexrays.user_numforms_iterator_t
   ida_hexrays.lvar_mapping_iterator_t
   ida_hexrays.udcall_map_iterator_t
   ida_hexrays.user_cmts_iterator_t
   ida_hexrays.user_iflags_iterator_t
   ida_hexrays.user_unions_iterator_t
   ida_hexrays.user_labels_iterator_t
   ida_hexrays.eamap_iterator_t
   ida_hexrays.boundaries_iterator_t
   ida_hexrays.block_chains_iterator_t


Functions
---------

.. autoapisummary::

   ida_hexrays.user_iflags_second
   ida_hexrays.qswap
   ida_hexrays.debug_hexrays_ctree
   ida_hexrays.init_hexrays_plugin
   ida_hexrays.get_widget_vdui
   ida_hexrays.boundaries_find
   ida_hexrays.boundaries_insert
   ida_hexrays.term_hexrays_plugin
   ida_hexrays.hexrays_alloc
   ida_hexrays.hexrays_free
   ida_hexrays.max_vlr_value
   ida_hexrays.min_vlr_svalue
   ida_hexrays.max_vlr_svalue
   ida_hexrays.is_unsigned_cmpop
   ida_hexrays.is_signed_cmpop
   ida_hexrays.is_cmpop_with_eq
   ida_hexrays.is_cmpop_without_eq
   ida_hexrays.is_may_access
   ida_hexrays.get_merror_desc
   ida_hexrays.must_mcode_close_block
   ida_hexrays.is_mcode_propagatable
   ida_hexrays.is_mcode_addsub
   ida_hexrays.is_mcode_xdsu
   ida_hexrays.is_mcode_set
   ida_hexrays.is_mcode_set1
   ida_hexrays.is_mcode_j1
   ida_hexrays.is_mcode_jcond
   ida_hexrays.is_mcode_convertible_to_jmp
   ida_hexrays.is_mcode_convertible_to_set
   ida_hexrays.is_mcode_call
   ida_hexrays.is_mcode_fpu
   ida_hexrays.is_mcode_commutative
   ida_hexrays.is_mcode_shift
   ida_hexrays.is_mcode_divmod
   ida_hexrays.has_mcode_seloff
   ida_hexrays.set2jcnd
   ida_hexrays.jcnd2set
   ida_hexrays.negate_mcode_relation
   ida_hexrays.swap_mcode_relation
   ida_hexrays.get_signed_mcode
   ida_hexrays.get_unsigned_mcode
   ida_hexrays.is_signed_mcode
   ida_hexrays.is_unsigned_mcode
   ida_hexrays.mcode_modifies_d
   ida_hexrays.dstr
   ida_hexrays.is_type_correct
   ida_hexrays.is_small_udt
   ida_hexrays.is_nonbool_type
   ida_hexrays.is_bool_type
   ida_hexrays.is_ptr_or_array
   ida_hexrays.is_paf
   ida_hexrays.is_inplace_def
   ida_hexrays.partial_type_num
   ida_hexrays.get_float_type
   ida_hexrays.get_int_type_by_width_and_sign
   ida_hexrays.get_unk_type
   ida_hexrays.dummy_ptrtype
   ida_hexrays.make_pointer
   ida_hexrays.create_typedef
   ida_hexrays.get_type
   ida_hexrays.set_type
   ida_hexrays.print_vdloc
   ida_hexrays.arglocs_overlap
   ida_hexrays.restore_user_lvar_settings
   ida_hexrays.save_user_lvar_settings
   ida_hexrays.modify_user_lvars
   ida_hexrays.modify_user_lvar_info
   ida_hexrays.locate_lvar
   ida_hexrays.rename_lvar
   ida_hexrays.restore_user_defined_calls
   ida_hexrays.save_user_defined_calls
   ida_hexrays.parse_user_call
   ida_hexrays.convert_to_user_call
   ida_hexrays.install_microcode_filter
   ida_hexrays.get_temp_regs
   ida_hexrays.is_kreg
   ida_hexrays.reg2mreg
   ida_hexrays.mreg2reg
   ida_hexrays.get_mreg_name
   ida_hexrays.lexcompare
   ida_hexrays.getf_reginsn
   ida_hexrays.getb_reginsn
   ida_hexrays.change_hexrays_config
   ida_hexrays.get_hexrays_version
   ida_hexrays.open_pseudocode
   ida_hexrays.close_pseudocode
   ida_hexrays.decompile_many
   ida_hexrays.send_database
   ida_hexrays.get_current_operand
   ida_hexrays.remitem
   ida_hexrays.negated_relation
   ida_hexrays.swapped_relation
   ida_hexrays.get_op_signness
   ida_hexrays.asgop
   ida_hexrays.asgop_revert
   ida_hexrays.op_uses_x
   ida_hexrays.op_uses_y
   ida_hexrays.op_uses_z
   ida_hexrays.is_binary
   ida_hexrays.is_unary
   ida_hexrays.is_relational
   ida_hexrays.is_assignment
   ida_hexrays.accepts_udts
   ida_hexrays.is_prepost
   ida_hexrays.is_commutative
   ida_hexrays.is_additive
   ida_hexrays.is_multiplicative
   ida_hexrays.is_bitop
   ida_hexrays.is_logical
   ida_hexrays.is_loop
   ida_hexrays.is_break_consumer
   ida_hexrays.is_lvalue
   ida_hexrays.accepts_small_udts
   ida_hexrays.save_user_labels
   ida_hexrays.save_user_cmts
   ida_hexrays.save_user_numforms
   ida_hexrays.save_user_iflags
   ida_hexrays.save_user_unions
   ida_hexrays.restore_user_labels
   ida_hexrays.restore_user_cmts
   ida_hexrays.restore_user_numforms
   ida_hexrays.restore_user_iflags
   ida_hexrays.restore_user_unions
   ida_hexrays.close_hexrays_waitbox
   ida_hexrays.decompile
   ida_hexrays.decompile_func
   ida_hexrays.gen_microcode
   ida_hexrays.create_empty_mba
   ida_hexrays.create_cfunc
   ida_hexrays.mark_cfunc_dirty
   ida_hexrays.clear_cached_cfuncs
   ida_hexrays.has_cached_cfunc
   ida_hexrays.get_ctype_name
   ida_hexrays.create_field_name
   ida_hexrays.select_udt_by_offset
   ida_hexrays.user_numforms_first
   ida_hexrays.user_numforms_second
   ida_hexrays.user_numforms_find
   ida_hexrays.user_numforms_insert
   ida_hexrays.user_numforms_begin
   ida_hexrays.user_numforms_end
   ida_hexrays.user_numforms_next
   ida_hexrays.user_numforms_prev
   ida_hexrays.user_numforms_erase
   ida_hexrays.user_numforms_clear
   ida_hexrays.user_numforms_size
   ida_hexrays.user_numforms_free
   ida_hexrays.user_numforms_new
   ida_hexrays.lvar_mapping_first
   ida_hexrays.lvar_mapping_second
   ida_hexrays.lvar_mapping_find
   ida_hexrays.lvar_mapping_insert
   ida_hexrays.lvar_mapping_begin
   ida_hexrays.lvar_mapping_end
   ida_hexrays.lvar_mapping_next
   ida_hexrays.lvar_mapping_prev
   ida_hexrays.lvar_mapping_erase
   ida_hexrays.lvar_mapping_clear
   ida_hexrays.lvar_mapping_size
   ida_hexrays.lvar_mapping_free
   ida_hexrays.lvar_mapping_new
   ida_hexrays.udcall_map_first
   ida_hexrays.udcall_map_second
   ida_hexrays.udcall_map_find
   ida_hexrays.udcall_map_insert
   ida_hexrays.udcall_map_begin
   ida_hexrays.udcall_map_end
   ida_hexrays.udcall_map_next
   ida_hexrays.udcall_map_prev
   ida_hexrays.udcall_map_erase
   ida_hexrays.udcall_map_clear
   ida_hexrays.udcall_map_size
   ida_hexrays.udcall_map_free
   ida_hexrays.udcall_map_new
   ida_hexrays.user_cmts_first
   ida_hexrays.user_cmts_second
   ida_hexrays.user_cmts_find
   ida_hexrays.user_cmts_insert
   ida_hexrays.user_cmts_begin
   ida_hexrays.user_cmts_end
   ida_hexrays.user_cmts_next
   ida_hexrays.user_cmts_prev
   ida_hexrays.user_cmts_erase
   ida_hexrays.user_cmts_clear
   ida_hexrays.user_cmts_size
   ida_hexrays.user_cmts_free
   ida_hexrays.user_cmts_new
   ida_hexrays.user_iflags_first
   ida_hexrays.user_iflags_find
   ida_hexrays.user_iflags_insert
   ida_hexrays.user_iflags_begin
   ida_hexrays.user_iflags_end
   ida_hexrays.user_iflags_next
   ida_hexrays.user_iflags_prev
   ida_hexrays.user_iflags_erase
   ida_hexrays.user_iflags_clear
   ida_hexrays.user_iflags_size
   ida_hexrays.user_iflags_free
   ida_hexrays.user_iflags_new
   ida_hexrays.user_unions_first
   ida_hexrays.user_unions_second
   ida_hexrays.user_unions_find
   ida_hexrays.user_unions_insert
   ida_hexrays.user_unions_begin
   ida_hexrays.user_unions_end
   ida_hexrays.user_unions_next
   ida_hexrays.user_unions_prev
   ida_hexrays.user_unions_erase
   ida_hexrays.user_unions_clear
   ida_hexrays.user_unions_size
   ida_hexrays.user_unions_free
   ida_hexrays.user_unions_new
   ida_hexrays.user_labels_first
   ida_hexrays.user_labels_second
   ida_hexrays.user_labels_find
   ida_hexrays.user_labels_insert
   ida_hexrays.user_labels_begin
   ida_hexrays.user_labels_end
   ida_hexrays.user_labels_next
   ida_hexrays.user_labels_prev
   ida_hexrays.user_labels_erase
   ida_hexrays.user_labels_clear
   ida_hexrays.user_labels_size
   ida_hexrays.user_labels_free
   ida_hexrays.user_labels_new
   ida_hexrays.eamap_first
   ida_hexrays.eamap_second
   ida_hexrays.eamap_find
   ida_hexrays.eamap_insert
   ida_hexrays.eamap_begin
   ida_hexrays.eamap_end
   ida_hexrays.eamap_next
   ida_hexrays.eamap_prev
   ida_hexrays.eamap_erase
   ida_hexrays.eamap_clear
   ida_hexrays.eamap_size
   ida_hexrays.eamap_free
   ida_hexrays.eamap_new
   ida_hexrays.boundaries_first
   ida_hexrays.boundaries_second
   ida_hexrays.boundaries_begin
   ida_hexrays.boundaries_end
   ida_hexrays.boundaries_next
   ida_hexrays.boundaries_prev
   ida_hexrays.boundaries_erase
   ida_hexrays.boundaries_clear
   ida_hexrays.boundaries_size
   ida_hexrays.boundaries_free
   ida_hexrays.boundaries_new
   ida_hexrays.block_chains_get
   ida_hexrays.block_chains_find
   ida_hexrays.block_chains_insert
   ida_hexrays.block_chains_begin
   ida_hexrays.block_chains_end
   ida_hexrays.block_chains_next
   ida_hexrays.block_chains_prev
   ida_hexrays.block_chains_erase
   ida_hexrays.block_chains_clear
   ida_hexrays.block_chains_size
   ida_hexrays.block_chains_free
   ida_hexrays.block_chains_new
   ida_hexrays.decompile
   ida_hexrays.citem_to_specific_type
   ida_hexrays.property_op_to_typename
   ida_hexrays.cexpr_operands
   ida_hexrays.cinsn_details
   ida_hexrays.cfunc_type
   ida_hexrays.lnot
   ida_hexrays.make_ref
   ida_hexrays.dereference
   ida_hexrays.call_helper
   ida_hexrays.new_block
   ida_hexrays.make_num
   ida_hexrays.create_helper
   ida_hexrays.install_hexrays_callback
   ida_hexrays.remove_hexrays_callback


Module Contents
---------------

.. py:class:: array_of_bitsets(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> bitset_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> bitset_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: array_of_bitsets) -> None


   .. py:method:: extract() -> bitset_t *


   .. py:method:: inject(s: bitset_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< bitset_t >::const_iterator


   .. py:method:: end(*args) -> qvector< bitset_t >::const_iterator


   .. py:method:: insert(it: bitset_t, x: bitset_t) -> qvector< bitset_t >::iterator


   .. py:method:: erase(*args) -> qvector< bitset_t >::iterator


   .. py:method:: find(*args) -> qvector< bitset_t >::const_iterator


   .. py:method:: has(x: bitset_t) -> bool


   .. py:method:: add_unique(x: bitset_t) -> bool


   .. py:method:: append(x: bitset_t) -> None


   .. py:method:: extend(x: array_of_bitsets) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: mopvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> mop_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> mop_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: mopvec_t) -> None


   .. py:method:: extract() -> mop_t *


   .. py:method:: inject(s: mop_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< mop_t >::const_iterator


   .. py:method:: end(*args) -> qvector< mop_t >::const_iterator


   .. py:method:: insert(it: mop_t, x: mop_t) -> qvector< mop_t >::iterator


   .. py:method:: erase(*args) -> qvector< mop_t >::iterator


   .. py:method:: find(*args) -> qvector< mop_t >::const_iterator


   .. py:method:: has(x: mop_t) -> bool


   .. py:method:: add_unique(x: mop_t) -> bool


   .. py:method:: append(x: mop_t) -> None


   .. py:method:: extend(x: mopvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: mcallargs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> mcallarg_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> mcallarg_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: mcallargs_t) -> None


   .. py:method:: extract() -> mcallarg_t *


   .. py:method:: inject(s: mcallarg_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< mcallarg_t >::const_iterator


   .. py:method:: end(*args) -> qvector< mcallarg_t >::const_iterator


   .. py:method:: insert(it: mcallarg_t, x: mcallarg_t) -> qvector< mcallarg_t >::iterator


   .. py:method:: erase(*args) -> qvector< mcallarg_t >::iterator


   .. py:method:: find(*args) -> qvector< mcallarg_t >::const_iterator


   .. py:method:: has(x: mcallarg_t) -> bool


   .. py:method:: add_unique(x: mcallarg_t) -> bool


   .. py:method:: append(x: mcallarg_t) -> None


   .. py:method:: extend(x: mcallargs_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: block_chains_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> block_chains_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> block_chains_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: block_chains_vec_t) -> None


   .. py:method:: extract() -> block_chains_t *


   .. py:method:: inject(s: block_chains_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< block_chains_t >::const_iterator


   .. py:method:: end(*args) -> qvector< block_chains_t >::const_iterator


   .. py:method:: insert(it: block_chains_t, x: block_chains_t) -> qvector< block_chains_t >::iterator


   .. py:method:: erase(*args) -> qvector< block_chains_t >::iterator


   .. py:method:: append(x: block_chains_t) -> None


   .. py:method:: extend(x: block_chains_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: user_numforms_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: operand_locator_t) -> number_format_t &


   .. py:method:: size() -> size_t


.. py:class:: lvar_mapping_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: lvar_locator_t) -> lvar_locator_t &


   .. py:method:: size() -> size_t


.. py:class:: hexwarns_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> hexwarn_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> hexwarn_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: hexwarns_t) -> None


   .. py:method:: extract() -> hexwarn_t *


   .. py:method:: inject(s: hexwarn_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< hexwarn_t >::const_iterator


   .. py:method:: end(*args) -> qvector< hexwarn_t >::const_iterator


   .. py:method:: insert(it: hexwarn_t, x: hexwarn_t) -> qvector< hexwarn_t >::iterator


   .. py:method:: erase(*args) -> qvector< hexwarn_t >::iterator


   .. py:method:: find(*args) -> qvector< hexwarn_t >::const_iterator


   .. py:method:: has(x: hexwarn_t) -> bool


   .. py:method:: add_unique(x: hexwarn_t) -> bool


   .. py:method:: append(x: hexwarn_t) -> None


   .. py:method:: extend(x: hexwarns_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: ctree_items_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> citem_t *&


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> citem_t *const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: ctree_items_t) -> None


   .. py:method:: extract() -> citem_t **


   .. py:method:: inject(s: citem_t **, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< citem_t * >::const_iterator


   .. py:method:: end(*args) -> qvector< citem_t * >::const_iterator


   .. py:method:: insert(it: qvector< citem_t * >::iterator, x: citem_t) -> qvector< citem_t * >::iterator


   .. py:method:: erase(*args) -> qvector< citem_t * >::iterator


   .. py:method:: find(*args) -> qvector< citem_t * >::const_iterator


   .. py:method:: has(x: citem_t) -> bool


   .. py:method:: add_unique(x: citem_t) -> bool


   .. py:method:: append(x: citem_t) -> None


   .. py:method:: extend(x: ctree_items_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: user_labels_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: int const &) -> _qstring< char > &


   .. py:method:: size() -> size_t


.. py:class:: user_cmts_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: treeloc_t) -> citem_cmt_t &


   .. py:method:: size() -> size_t


.. py:class:: user_iflags_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: citem_locator_t) -> int &


   .. py:method:: size() -> size_t


.. py:class:: user_unions_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: unsigned long long const &) -> qvector< int > &


   .. py:method:: size() -> size_t


.. py:class:: cinsnptrvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> cinsn_t *&


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> cinsn_t *const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: cinsnptrvec_t) -> None


   .. py:method:: extract() -> cinsn_t **


   .. py:method:: inject(s: cinsn_t **, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< cinsn_t * >::const_iterator


   .. py:method:: end(*args) -> qvector< cinsn_t * >::const_iterator


   .. py:method:: insert(it: qvector< cinsn_t * >::iterator, x: cinsn_t) -> qvector< cinsn_t * >::iterator


   .. py:method:: erase(*args) -> qvector< cinsn_t * >::iterator


   .. py:method:: find(*args) -> qvector< cinsn_t * >::const_iterator


   .. py:method:: has(x: cinsn_t) -> bool


   .. py:method:: add_unique(x: cinsn_t) -> bool


   .. py:method:: append(x: cinsn_t) -> None


   .. py:method:: extend(x: cinsnptrvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: eamap_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: unsigned long long const &) -> cinsnptrvec_t &


   .. py:method:: size() -> size_t


.. py:class:: boundaries_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: at(_Keyval: cinsn_t) -> rangeset_t &


   .. py:method:: size() -> size_t


.. py:function:: user_iflags_second(p: user_iflags_iterator_t) -> int32 const &

   Get reference to the current map value.


.. py:class:: cfuncptr_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: reset() -> None


   .. py:attribute:: entry_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: mba
      :type:  mba_t *


   .. py:attribute:: body
      :type:  cinsn_t


   .. py:attribute:: argidx
      :type:  intvec_t &


   .. py:attribute:: maturity
      :type:  ctree_maturity_t


   .. py:attribute:: user_labels
      :type:  user_labels_t *


   .. py:attribute:: user_cmts
      :type:  user_cmts_t *


   .. py:attribute:: numforms
      :type:  user_numforms_t *


   .. py:attribute:: user_iflags
      :type:  user_iflags_t *


   .. py:attribute:: user_unions
      :type:  user_unions_t *


   .. py:attribute:: refcnt
      :type:  int


   .. py:attribute:: statebits
      :type:  int


   .. py:attribute:: hdrlines
      :type:  int


   .. py:attribute:: treeitems
      :type:  citem_pointers_t


   .. py:method:: release() -> None


   .. py:method:: build_c_tree() -> None


   .. py:method:: verify(aul: allow_unused_labels_t, even_without_debugger: bool) -> None


   .. py:method:: print_dcl() -> None


   .. py:method:: print_func(vp: vc_printer_t) -> None


   .. py:method:: get_func_type(type: tinfo_t) -> bool


   .. py:method:: get_lvars() -> lvars_t *


   .. py:method:: get_stkoff_delta() -> int


   .. py:method:: find_label(label: int) -> citem_t *


   .. py:method:: remove_unused_labels() -> None


   .. py:method:: get_user_cmt(loc: treeloc_t, rt: cmt_retrieval_type_t) -> str


   .. py:method:: set_user_cmt(loc: treeloc_t, cmt: str) -> None


   .. py:method:: get_user_iflags(loc: citem_locator_t) -> int


   .. py:method:: set_user_iflags(loc: citem_locator_t, iflags: int) -> None


   .. py:method:: has_orphan_cmts() -> bool


   .. py:method:: del_orphan_cmts() -> int


   .. py:method:: get_user_union_selection(ea: ida_idaapi.ea_t, path: intvec_t) -> bool


   .. py:method:: set_user_union_selection(ea: ida_idaapi.ea_t, path: intvec_t) -> None


   .. py:method:: save_user_labels() -> None

      Save user defined labels into the database. 
              



   .. py:method:: save_user_cmts() -> None

      Save user defined comments into the database. 
              



   .. py:method:: save_user_numforms() -> None

      Save user defined number formats into the database. 
              



   .. py:method:: save_user_iflags() -> None

      Save user defined citem iflags into the database. 
              



   .. py:method:: save_user_unions() -> None

      Save user defined union field selections into the database. 
              



   .. py:method:: get_line_item(line: str, x: int, is_ctree_line: bool, phead: ctree_item_t, pitem: ctree_item_t, ptail: ctree_item_t) -> bool


   .. py:method:: get_warnings() -> hexwarns_t &


   .. py:method:: get_eamap() -> eamap_t &


   .. py:method:: get_boundaries() -> boundaries_t &


   .. py:method:: get_pseudocode() -> strvec_t const &


   .. py:method:: refresh_func_ctext() -> None


   .. py:method:: recalc_item_addresses() -> None


   .. py:method:: gather_derefs(ci: ctree_item_t, udm: udt_type_data_t = None) -> bool


   .. py:method:: find_item_coords(*args)

      This method has the following signatures:

          1. find_item_coords(item: citem_t) -> Tuple[int, int]
          2. find_item_coords(item: citem_t, x: int_pointer, y: int_pointer) -> bool

      NOTE: The second form is retained for backward-compatibility,
      but we strongly recommend using the first.

      :param item: The item to find coordinates for in the pseudocode listing



   .. py:method:: locked() -> bool


.. py:class:: qvector_history_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> history_item_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> history_item_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_history_t) -> None


   .. py:method:: extract() -> history_item_t *


   .. py:method:: inject(s: history_item_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< history_item_t >::const_iterator


   .. py:method:: end(*args) -> qvector< history_item_t >::const_iterator


   .. py:method:: insert(it: history_item_t, x: history_item_t) -> qvector< history_item_t >::iterator


   .. py:method:: erase(*args) -> qvector< history_item_t >::iterator


   .. py:method:: find(*args) -> qvector< history_item_t >::const_iterator


   .. py:method:: has(x: history_item_t) -> bool


   .. py:method:: add_unique(x: history_item_t) -> bool


   .. py:method:: append(x: history_item_t) -> None


   .. py:method:: extend(x: qvector_history_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: history_t

   Bases: :py:obj:`qvector_history_t`


   .. py:attribute:: thisown


   .. py:method:: pop() -> history_item_t


   .. py:method:: top(*args) -> history_item_t &


   .. py:method:: push(v: history_item_t) -> None


.. py:class:: cinsn_list_t_iterator

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cur
      :type:  cinsn_t const &


   .. py:attribute:: next


.. py:class:: cinsn_list_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: swap(x: cinsn_list_t) -> None


   .. py:method:: empty() -> bool


   .. py:method:: size() -> size_t


   .. py:method:: front(*args) -> cinsn_t const &


   .. py:method:: back(*args) -> cinsn_t const &


   .. py:method:: rbegin(*args) -> qlist< cinsn_t >::const_reverse_iterator


   .. py:method:: rend(*args) -> qlist< cinsn_t >::const_reverse_iterator


   .. py:method:: push_front(x: cinsn_t) -> None


   .. py:method:: push_back(*args) -> cinsn_t &


   .. py:method:: clear() -> None


   .. py:method:: pop_front() -> None


   .. py:method:: pop_back() -> None


   .. py:method:: splice(pos: qlist< cinsn_t >::iterator, other: cinsn_list_t, first: qlist< cinsn_t >::iterator, last: qlist< cinsn_t >::iterator) -> None


   .. py:method:: remove(v: cinsn_t) -> bool


   .. py:method:: find(item)


   .. py:method:: index(item)


   .. py:method:: at(index)


   .. py:method:: begin() -> cinsn_list_t_iterator


   .. py:method:: end() -> cinsn_list_t_iterator


   .. py:method:: insert(*args) -> cinsn_list_t_iterator


   .. py:method:: erase(p: cinsn_list_t_iterator) -> None


.. py:class:: qvector_lvar_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> lvar_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> lvar_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_lvar_t) -> None


   .. py:method:: extract() -> lvar_t *


   .. py:method:: inject(s: lvar_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< lvar_t >::const_iterator


   .. py:method:: end(*args) -> qvector< lvar_t >::const_iterator


   .. py:method:: insert(it: lvar_t, x: lvar_t) -> qvector< lvar_t >::iterator


   .. py:method:: erase(*args) -> qvector< lvar_t >::iterator


   .. py:method:: find(*args) -> qvector< lvar_t >::const_iterator


   .. py:method:: has(x: lvar_t) -> bool


   .. py:method:: add_unique(x: lvar_t) -> bool


   .. py:method:: append(x: lvar_t) -> None


   .. py:method:: extend(x: qvector_lvar_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: qvector_carg_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> carg_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> carg_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_carg_t) -> None


   .. py:method:: extract() -> carg_t *


   .. py:method:: inject(s: carg_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< carg_t >::const_iterator


   .. py:method:: end(*args) -> qvector< carg_t >::const_iterator


   .. py:method:: insert(it: carg_t, x: carg_t) -> qvector< carg_t >::iterator


   .. py:method:: erase(*args) -> qvector< carg_t >::iterator


   .. py:method:: find(*args) -> qvector< carg_t >::const_iterator


   .. py:method:: has(x: carg_t) -> bool


   .. py:method:: add_unique(x: carg_t) -> bool


   .. py:method:: append(x: carg_t) -> None


   .. py:method:: extend(x: qvector_carg_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: qvector_ccase_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> ccase_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> ccase_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_ccase_t) -> None


   .. py:method:: extract() -> ccase_t *


   .. py:method:: inject(s: ccase_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< ccase_t >::const_iterator


   .. py:method:: end(*args) -> qvector< ccase_t >::const_iterator


   .. py:method:: insert(it: ccase_t, x: ccase_t) -> qvector< ccase_t >::iterator


   .. py:method:: erase(*args) -> qvector< ccase_t >::iterator


   .. py:method:: find(*args) -> qvector< ccase_t >::const_iterator


   .. py:method:: has(x: ccase_t) -> bool


   .. py:method:: add_unique(x: ccase_t) -> bool


   .. py:method:: append(x: ccase_t) -> None


   .. py:method:: extend(x: qvector_ccase_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: qvector_catchexprs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> catchexpr_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> catchexpr_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_catchexprs_t) -> None


   .. py:method:: extract() -> catchexpr_t *


   .. py:method:: inject(s: catchexpr_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< catchexpr_t >::const_iterator


   .. py:method:: end(*args) -> qvector< catchexpr_t >::const_iterator


   .. py:method:: insert(it: catchexpr_t, x: catchexpr_t) -> qvector< catchexpr_t >::iterator


   .. py:method:: erase(*args) -> qvector< catchexpr_t >::iterator


   .. py:method:: find(*args) -> qvector< catchexpr_t >::const_iterator


   .. py:method:: has(x: catchexpr_t) -> bool


   .. py:method:: add_unique(x: catchexpr_t) -> bool


   .. py:method:: append(x: catchexpr_t) -> None


   .. py:method:: extend(x: qvector_catchexprs_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: qvector_ccatchvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> ccatch_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> ccatch_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_ccatchvec_t) -> None


   .. py:method:: extract() -> ccatch_t *


   .. py:method:: inject(s: ccatch_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< ccatch_t >::const_iterator


   .. py:method:: end(*args) -> qvector< ccatch_t >::const_iterator


   .. py:method:: insert(it: ccatch_t, x: ccatch_t) -> qvector< ccatch_t >::iterator


   .. py:method:: erase(*args) -> qvector< ccatch_t >::iterator


   .. py:method:: find(*args) -> qvector< ccatch_t >::const_iterator


   .. py:method:: has(x: ccatch_t) -> bool


   .. py:method:: add_unique(x: ccatch_t) -> bool


   .. py:method:: append(x: ccatch_t) -> None


   .. py:method:: extend(x: qvector_ccatchvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: cblock_posvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> cblock_pos_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> cblock_pos_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: cblock_posvec_t) -> None


   .. py:method:: extract() -> cblock_pos_t *


   .. py:method:: inject(s: cblock_pos_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< cblock_pos_t >::const_iterator


   .. py:method:: end(*args) -> qvector< cblock_pos_t >::const_iterator


   .. py:method:: insert(it: cblock_pos_t, x: cblock_pos_t) -> qvector< cblock_pos_t >::iterator


   .. py:method:: erase(*args) -> qvector< cblock_pos_t >::iterator


   .. py:method:: append(x: cblock_pos_t) -> None


   .. py:method:: extend(x: cblock_posvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: lvar_saved_infos_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> lvar_saved_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> lvar_saved_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: lvar_saved_infos_t) -> None


   .. py:method:: extract() -> lvar_saved_info_t *


   .. py:method:: inject(s: lvar_saved_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< lvar_saved_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< lvar_saved_info_t >::const_iterator


   .. py:method:: insert(it: lvar_saved_info_t, x: lvar_saved_info_t) -> qvector< lvar_saved_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< lvar_saved_info_t >::iterator


   .. py:method:: find(*args) -> qvector< lvar_saved_info_t >::const_iterator


   .. py:method:: has(x: lvar_saved_info_t) -> bool


   .. py:method:: add_unique(x: lvar_saved_info_t) -> bool


   .. py:method:: append(x: lvar_saved_info_t) -> None


   .. py:method:: extend(x: lvar_saved_infos_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: ui_stroff_ops_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> ui_stroff_op_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> ui_stroff_op_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: ui_stroff_ops_t) -> None


   .. py:method:: extract() -> ui_stroff_op_t *


   .. py:method:: inject(s: ui_stroff_op_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< ui_stroff_op_t >::const_iterator


   .. py:method:: end(*args) -> qvector< ui_stroff_op_t >::const_iterator


   .. py:method:: insert(it: ui_stroff_op_t, x: ui_stroff_op_t) -> qvector< ui_stroff_op_t >::iterator


   .. py:method:: erase(*args) -> qvector< ui_stroff_op_t >::iterator


   .. py:method:: find(*args) -> qvector< ui_stroff_op_t >::const_iterator


   .. py:method:: has(x: ui_stroff_op_t) -> bool


   .. py:method:: add_unique(x: ui_stroff_op_t) -> bool


   .. py:method:: append(x: ui_stroff_op_t) -> None


   .. py:method:: extend(x: ui_stroff_ops_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: qswap(a: cinsn_t, b: cinsn_t) -> None

.. py:function:: debug_hexrays_ctree(level: int, msg: str) -> None

.. py:function:: init_hexrays_plugin(flags: int = 0) -> bool

   Check that your plugin is compatible with hex-rays decompiler. This function must be called before calling any other decompiler function. 
           
   :param flags: reserved, must be 0
   :returns: true if the decompiler exists and is compatible with your plugin


.. py:function:: get_widget_vdui(f: TWidget *) -> vdui_t *

   Get the vdui_t instance associated to the TWidget 
           
   :param f: pointer to window
   :returns: a vdui_t *, or nullptr


.. py:function:: boundaries_find(map: boundaries_t, key: cinsn_t) -> boundaries_iterator_t

   Find the specified key in boundaries_t.


.. py:function:: boundaries_insert(map: boundaries_t, key: cinsn_t, val: rangeset_t) -> boundaries_iterator_t

   Insert new (cinsn_t *, rangeset_t) pair into boundaries_t.


.. py:function:: term_hexrays_plugin() -> None

   Stop working with hex-rays decompiler.


.. py:class:: Hexrays_Hooks(_flags: int = 0, _hkcb_flags: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: hook() -> bool


   .. py:method:: unhook() -> bool


   .. py:method:: flowchart(fc: qflow_chart_t, mba: mba_t, reachable_blocks: bitset_t, decomp_flags: int) -> int

      Flowchart has been generated. 
                
      :param fc: (qflow_chart_t *)
      :param mba: (mba_t *)
      :param reachable_blocks: (bitset_t *)
      :param decomp_flags: (int)
      :returns: Microcode error code



   .. py:method:: stkpnts(mba: mba_t, _sps: stkpnts_t *) -> int

      SP change points have been calculated. 
                
      :param mba: (mba_t *)
      :returns: Microcode error code This event is generated for each inlined range as well.



   .. py:method:: prolog(mba: mba_t, fc: qflow_chart_t, reachable_blocks: bitset_t, decomp_flags: int) -> int

      Prolog analysis has been finished. 
                
      :param mba: (mba_t *)
      :param fc: (qflow_chart_t *)
      :param reachable_blocks: (const bitset_t *)
      :param decomp_flags: (int)
      :returns: Microcode error code This event is generated for each inlined range as well.



   .. py:method:: microcode(mba: mba_t) -> int

      Microcode has been generated. 
                
      :param mba: (mba_t *)
      :returns: Microcode error code



   .. py:method:: preoptimized(mba: mba_t) -> int

      Microcode has been preoptimized. 
                
      :param mba: (mba_t *)
      :returns: Microcode error code



   .. py:method:: locopt(mba: mba_t) -> int

      Basic block level optimization has been finished. 
                
      :param mba: (mba_t *)
      :returns: Microcode error code



   .. py:method:: prealloc(mba: mba_t) -> int

      Local variables: preallocation step begins. 
                
      :param mba: (mba_t *) This event may occur several times. Should return: 1 if modified microcode Negative values are Microcode error code



   .. py:method:: glbopt(mba: mba_t) -> int

      Global optimization has been finished. If microcode is modified, MERR_LOOP must be returned. It will cause a complete restart of the optimization. 
                
      :param mba: (mba_t *)
      :returns: Microcode error code



   .. py:method:: pre_structural(ct: control_graph_t *, cfunc: cfunc_t, g: simple_graph_t) -> int

      Structure analysis is starting. 
                
      :param ct: (control_graph_t *) in/out: control graph
      :param cfunc: (cfunc_t *) in: the current function
      :param g: (const simple_graph_t *) in: control flow graph
      :returns: Microcode error code; MERR_BLOCK means that the analysis has been performed by a plugin



   .. py:method:: structural(ct: control_graph_t *) -> int

      Structural analysis has been finished. 
                
      :param ct: (control_graph_t *)



   .. py:method:: maturity(cfunc: cfunc_t, new_maturity: ctree_maturity_t) -> int

      Ctree maturity level is being changed. 
                
      :param cfunc: (cfunc_t *)
      :param new_maturity: (ctree_maturity_t)



   .. py:method:: interr(errcode: int) -> int

      Internal error has occurred. 
                
      :param errcode: (int )



   .. py:method:: combine(blk: mblock_t, insn: minsn_t) -> int

      Trying to combine instructions of basic block. 
                
      :param blk: (mblock_t *)
      :param insn: (minsn_t *) Should return: 1 if combined the current instruction with a preceding one -1 if the instruction should not be combined 0 else



   .. py:method:: print_func(cfunc: cfunc_t, vp: vc_printer_t) -> int

      Printing ctree and generating text. 
                
      :param cfunc: (cfunc_t *)
      :param vp: (vc_printer_t *) Returns: 1 if text has been generated by the plugin It is forbidden to modify ctree at this event.



   .. py:method:: func_printed(cfunc: cfunc_t) -> int

      Function text has been generated. Plugins may modify the text in cfunc_t::sv. However, it is too late to modify the ctree or microcode. The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store pointers to ctree items. 
                
      :param cfunc: (cfunc_t *)



   .. py:method:: resolve_stkaddrs(mba: mba_t) -> int

      The optimizer is about to resolve stack addresses. 
                
      :param mba: (mba_t *)



   .. py:method:: build_callinfo(blk: mblock_t, type: tinfo_t) -> PyObject *

      Analyzing a call instruction. 
                
      :param blk: (mblock_t *) blk->tail is the call.
      :param type: (tinfo_t *) buffer for the output type.



   .. py:method:: callinfo_built(blk: mblock_t) -> int

      A call instruction has been anallyzed. 
                
      :param blk: (mblock_t *) blk->tail is the call.



   .. py:method:: calls_done(mba: mba_t) -> int

      All calls have been analyzed. 
                
      :param mba: (mba_t *) This event is generated immediately after analyzing all calls, before any optimizitions, call unmerging and block merging.



   .. py:method:: begin_inlining(cdg: codegen_t, decomp_flags: int) -> int

      Starting to inline outlined functions. 
                
      :param cdg: (codegen_t *)
      :param decomp_flags: (int)
      :returns: Microcode error code This is an opportunity to inline other ranges.



   .. py:method:: inlining_func(cdg: codegen_t, blk: int, mbr: mba_ranges_t) -> int

      A set of ranges is going to be inlined. 
                
      :param cdg: (codegen_t *)
      :param blk: (int) the block containing call/jump to inline
      :param mbr: (mba_ranges_t *) the range to inline



   .. py:method:: inlined_func(cdg: codegen_t, blk: int, mbr: mba_ranges_t, i1: int, i2: int) -> int

      A set of ranges got inlined. 
                
      :param cdg: (codegen_t *)
      :param blk: (int) the block containing call/jump to inline
      :param mbr: (mba_ranges_t *) the range to inline
      :param i1: (int) blknum of the first inlined block
      :param i2: (int) blknum of the last inlined block (excluded)



   .. py:method:: collect_warnings(cfunc: cfunc_t) -> int

      Collect warning messages from plugins. These warnings will be displayed at the function header, after the user-defined comments. 
                
      :param cfunc: (cfunc_t *)



   .. py:method:: open_pseudocode(vu: vdui_t) -> int

      New pseudocode view has been opened. 
                
      :param vu: (vdui_t *)



   .. py:method:: switch_pseudocode(vu: vdui_t) -> int

      Existing pseudocode view has been reloaded with a new function. Its text has not been refreshed yet, only cfunc and mba pointers are ready. 
                
      :param vu: (vdui_t *)



   .. py:method:: refresh_pseudocode(vu: vdui_t) -> int

      Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is forbidden in this event. 
                
      :param vu: (vdui_t *) See also hxe_text_ready, which happens earlier



   .. py:method:: close_pseudocode(vu: vdui_t) -> int

      Pseudocode view is being closed. 
                
      :param vu: (vdui_t *)



   .. py:method:: keyboard(vu: vdui_t, key_code: int, shift_state: int) -> int

      Keyboard has been hit. 
                
      :param vu: (vdui_t *)
      :param key_code: (int) VK_...
      :param shift_state: (int) Should return: 1 if the event has been handled



   .. py:method:: right_click(vu: vdui_t) -> int

      Mouse right click. Use hxe_populating_popup instead, in case you want to add items in the popup menu. 
                
      :param vu: (vdui_t *)



   .. py:method:: double_click(vu: vdui_t, shift_state: int) -> int

      Mouse double click. 
                
      :param vu: (vdui_t *)
      :param shift_state: (int) Should return: 1 if the event has been handled



   .. py:method:: curpos(vu: vdui_t) -> int

      Current cursor position has been changed. (for example, by left-clicking or using keyboard)

                
      :param vu: (vdui_t *)



   .. py:method:: create_hint(vu: vdui_t) -> PyObject *

      Create a hint for the current item. 
                
      :param vu: (vdui_t *)
      :returns: 0: continue collecting hints with other subscribers
      :returns: 1: stop collecting hints



   .. py:method:: text_ready(vu: vdui_t) -> int

      Decompiled text is ready. 
                
      :param vu: (vdui_t *) This event can be used to modify the output text (sv). Obsolete. Please use hxe_func_printed instead.



   .. py:method:: populating_popup(widget: TWidget *, popup_handle: TPopupMenu *, vu: vdui_t) -> int

      Populating popup menu. We can add menu items now. 
                
      :param widget: (TWidget *)
      :param popup_handle: (TPopupMenu *)
      :param vu: (vdui_t *)



   .. py:method:: lvar_name_changed(vu: vdui_t, v: lvar_t, name: str, is_user_name: bool) -> int

      Local variable got renamed. 
                
      :param vu: (vdui_t *)
      :param v: (lvar_t *)
      :param name: (const char *)
      :param is_user_name: (bool) Please note that it is possible to read/write user settings for lvars directly from the idb.



   .. py:method:: lvar_type_changed(vu: vdui_t, v: lvar_t, tinfo: tinfo_t) -> int

      Local variable type got changed. 
                
      :param vu: (vdui_t *)
      :param v: (lvar_t *)
      :param tinfo: (const tinfo_t *) Please note that it is possible to read/write user settings for lvars directly from the idb.



   .. py:method:: lvar_cmt_changed(vu: vdui_t, v: lvar_t, cmt: str) -> int

      Local variable comment got changed. 
                
      :param vu: (vdui_t *)
      :param v: (lvar_t *)
      :param cmt: (const char *) Please note that it is possible to read/write user settings for lvars directly from the idb.



   .. py:method:: lvar_mapping_changed(vu: vdui_t, frm: lvar_t, to: lvar_t) -> int

      Local variable mapping got changed. 
                
      :param vu: (vdui_t *)
      :param to: (lvar_t *) Please note that it is possible to read/write user settings for lvars directly from the idb.



   .. py:method:: cmt_changed(cfunc: cfunc_t, loc: treeloc_t, cmt: str) -> int

      Comment got changed. 
                
      :param cfunc: (cfunc_t *)
      :param loc: (const treeloc_t *)
      :param cmt: (const char *)



   .. py:method:: mba_maturity(mba: mba_t, reqmat: mba_maturity_t) -> int

      Maturity level of an MBA was changed. 
                
      :param mba: (mba_t *)
      :param reqmat: (mba_maturity_t) requested maturity level
      :returns: Microcode error code



.. py:class:: uval_ivl_t(_off: unsigned long long, _size: unsigned long long)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: off
      :type:  unsigned long long


   .. py:attribute:: size
      :type:  unsigned long long


   .. py:method:: valid() -> bool


   .. py:method:: end() -> unsigned long long


   .. py:method:: last() -> unsigned long long


.. py:class:: uval_ivl_ivlset_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: swap(r: uval_ivl_ivlset_t) -> None


   .. py:method:: getivl(idx: int) -> ivl_t const &


   .. py:method:: lastivl() -> ivl_t const &


   .. py:method:: nivls() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: clear() -> None


   .. py:method:: qclear() -> None


   .. py:method:: all_values() -> bool


   .. py:method:: set_all_values() -> None


   .. py:method:: single_value(*args) -> bool


   .. py:method:: begin(*args) -> ivlset_tpl< ivl_t,unsigned long long >::iterator


   .. py:method:: end(*args) -> ivlset_tpl< ivl_t,unsigned long long >::iterator


.. py:class:: array_of_ivlsets(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> ivlset_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> ivlset_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: array_of_ivlsets) -> None


   .. py:method:: extract() -> ivlset_t *


   .. py:method:: inject(s: ivlset_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< ivlset_t >::const_iterator


   .. py:method:: end(*args) -> qvector< ivlset_t >::const_iterator


   .. py:method:: insert(it: ivlset_t, x: ivlset_t) -> qvector< ivlset_t >::iterator


   .. py:method:: erase(*args) -> qvector< ivlset_t >::iterator


   .. py:method:: find(*args) -> qvector< ivlset_t >::const_iterator


   .. py:method:: has(x: ivlset_t) -> bool


   .. py:method:: add_unique(x: ivlset_t) -> bool


   .. py:method:: append(x: ivlset_t) -> None


   .. py:method:: extend(x: array_of_ivlsets) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: MAX_SUPPORTED_STACK_SIZE

.. py:function:: hexrays_alloc(size: size_t) -> void *

.. py:function:: hexrays_free(ptr: void *) -> None

.. py:data:: MAX_VLR_SIZE

.. py:function:: max_vlr_value(size: int) -> uvlr_t

.. py:function:: min_vlr_svalue(size: int) -> uvlr_t

.. py:function:: max_vlr_svalue(size: int) -> uvlr_t

.. py:data:: CMP_NZ

.. py:data:: CMP_Z

.. py:data:: CMP_AE

.. py:data:: CMP_B

.. py:data:: CMP_A

.. py:data:: CMP_BE

.. py:data:: CMP_GT

.. py:data:: CMP_GE

.. py:data:: CMP_LT

.. py:data:: CMP_LE

.. py:function:: is_unsigned_cmpop(cmpop: cmpop_t) -> bool

.. py:function:: is_signed_cmpop(cmpop: cmpop_t) -> bool

.. py:function:: is_cmpop_with_eq(cmpop: cmpop_t) -> bool

.. py:function:: is_cmpop_without_eq(cmpop: cmpop_t) -> bool

.. py:class:: valrng_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: swap(r: valrng_t) -> None


   .. py:method:: compare(r: valrng_t) -> int


   .. py:method:: set_none() -> None


   .. py:method:: set_all() -> None


   .. py:method:: set_unk() -> None


   .. py:method:: set_eq(v: uvlr_t) -> None


   .. py:method:: set_cmp(cmp: cmpop_t, _value: uvlr_t) -> None


   .. py:method:: reduce_size(new_size: int) -> bool


   .. py:method:: intersect_with(r: valrng_t) -> bool


   .. py:method:: unite_with(r: valrng_t) -> bool


   .. py:method:: inverse() -> None


   .. py:method:: empty() -> bool


   .. py:method:: all_values() -> bool


   .. py:method:: is_unknown() -> bool


   .. py:method:: has(v: uvlr_t) -> bool


   .. py:method:: dstr() -> str


   .. py:method:: cvt_to_single_value() -> bool


   .. py:method:: cvt_to_cmp() -> bool


   .. py:method:: get_size() -> int


   .. py:method:: max_value() -> uvlr_t


   .. py:method:: min_svalue() -> uvlr_t


   .. py:method:: max_svalue() -> uvlr_t


.. py:data:: cvar

.. py:data:: MAX_VLR_VALUE

.. py:data:: MAX_VLR_SVALUE

.. py:data:: MIN_VLR_SVALUE

.. py:function:: is_may_access(maymust: maymust_t) -> bool

.. py:data:: MERR_OK

   ok


.. py:data:: MERR_BLOCK

   no error, switch to new block


.. py:data:: MERR_INTERR

   internal error


.. py:data:: MERR_INSN

   cannot convert to microcode


.. py:data:: MERR_MEM

   not enough memory


.. py:data:: MERR_BADBLK

   bad block found


.. py:data:: MERR_BADSP

   positive sp value has been found


.. py:data:: MERR_PROLOG

   prolog analysis failed


.. py:data:: MERR_SWITCH

   wrong switch idiom


.. py:data:: MERR_EXCEPTION

   exception analysis failed


.. py:data:: MERR_HUGESTACK

   stack frame is too big


.. py:data:: MERR_LVARS

   local variable allocation failed


.. py:data:: MERR_BITNESS

   16-bit functions cannot be decompiled


.. py:data:: MERR_BADCALL

   could not determine call arguments


.. py:data:: MERR_BADFRAME

   function frame is wrong


.. py:data:: MERR_UNKTYPE

   undefined type s (currently unused error code)


.. py:data:: MERR_BADIDB

   inconsistent database information


.. py:data:: MERR_SIZEOF

   wrong basic type sizes in compiler settings


.. py:data:: MERR_REDO

   redecompilation has been requested


.. py:data:: MERR_CANCELED

   decompilation has been cancelled


.. py:data:: MERR_RECDEPTH

   max recursion depth reached during lvar allocation


.. py:data:: MERR_OVERLAP

   variables would overlap: s


.. py:data:: MERR_PARTINIT

   partially initialized variable s


.. py:data:: MERR_COMPLEX

   too complex function


.. py:data:: MERR_LICENSE

   no license available


.. py:data:: MERR_ONLY32

   only 32-bit functions can be decompiled for the current database


.. py:data:: MERR_ONLY64

   only 64-bit functions can be decompiled for the current database


.. py:data:: MERR_BUSY

   already decompiling a function


.. py:data:: MERR_FARPTR

   far memory model is supported only for pc


.. py:data:: MERR_EXTERN

   special segments cannot be decompiled


.. py:data:: MERR_FUNCSIZE

   too big function


.. py:data:: MERR_BADRANGES

   bad input ranges


.. py:data:: MERR_BADARCH

   current architecture is not supported


.. py:data:: MERR_DSLOT

   bad instruction in the delay slot


.. py:data:: MERR_STOP

   no error, stop the analysis


.. py:data:: MERR_CLOUD

   cloud: s


.. py:data:: MERR_EMULATOR

   emulator: s


.. py:data:: MERR_MAX_ERR

.. py:data:: MERR_LOOP

   internal code: redo last loop (never reported)


.. py:function:: get_merror_desc(code: merror_t, mba: mba_t) -> str

   Get textual description of an error code 
           
   :param code: Microcode error code
   :param mba: the microcode array
   :returns: the error address


.. py:data:: m_nop

.. py:data:: m_stx

.. py:data:: m_ldx

.. py:data:: m_ldc

.. py:data:: m_mov

.. py:data:: m_neg

.. py:data:: m_lnot

.. py:data:: m_bnot

.. py:data:: m_xds

.. py:data:: m_xdu

.. py:data:: m_low

.. py:data:: m_high

.. py:data:: m_add

.. py:data:: m_sub

.. py:data:: m_mul

.. py:data:: m_udiv

.. py:data:: m_sdiv

.. py:data:: m_umod

.. py:data:: m_smod

.. py:data:: m_or

.. py:data:: m_and

.. py:data:: m_xor

.. py:data:: m_shl

.. py:data:: m_shr

.. py:data:: m_sar

.. py:data:: m_cfadd

.. py:data:: m_ofadd

.. py:data:: m_cfshl

.. py:data:: m_cfshr

.. py:data:: m_sets

.. py:data:: m_seto

.. py:data:: m_setp

.. py:data:: m_setnz

.. py:data:: m_setz

.. py:data:: m_setae

.. py:data:: m_setb

.. py:data:: m_seta

.. py:data:: m_setbe

.. py:data:: m_setg

.. py:data:: m_setge

.. py:data:: m_setl

.. py:data:: m_setle

.. py:data:: m_jcnd

.. py:data:: m_jnz

.. py:data:: m_jz

.. py:data:: m_jae

.. py:data:: m_jb

.. py:data:: m_ja

.. py:data:: m_jbe

.. py:data:: m_jg

.. py:data:: m_jge

.. py:data:: m_jl

.. py:data:: m_jle

.. py:data:: m_jtbl

.. py:data:: m_ijmp

.. py:data:: m_goto

.. py:data:: m_call

.. py:data:: m_icall

.. py:data:: m_ret

.. py:data:: m_push

.. py:data:: m_pop

.. py:data:: m_und

.. py:data:: m_ext

.. py:data:: m_f2i

.. py:data:: m_f2u

.. py:data:: m_i2f

.. py:data:: m_u2f

.. py:data:: m_f2f

.. py:data:: m_fneg

.. py:data:: m_fadd

.. py:data:: m_fsub

.. py:data:: m_fmul

.. py:data:: m_fdiv

.. py:function:: must_mcode_close_block(mcode: mcode_t, including_calls: bool) -> bool

   Must an instruction with the given opcode be the last one in a block? Such opcodes are called closing opcodes. 
           
   :param mcode: instruction opcode
   :param including_calls: should m_call/m_icall be considered as the closing opcodes? If this function returns true, the opcode cannot appear in the middle of a block. Calls are a special case: unknown calls (is_unknown_call) are considered as closing opcodes.


.. py:function:: is_mcode_propagatable(mcode: mcode_t) -> bool

   May opcode be propagated? Such opcodes can be used in sub-instructions (nested instructions) There is a handful of non-propagatable opcodes, like jumps, ret, nop, etc All other regular opcodes are propagatable and may appear in a nested instruction. 
           


.. py:function:: is_mcode_addsub(mcode: mcode_t) -> bool

.. py:function:: is_mcode_xdsu(mcode: mcode_t) -> bool

.. py:function:: is_mcode_set(mcode: mcode_t) -> bool

.. py:function:: is_mcode_set1(mcode: mcode_t) -> bool

.. py:function:: is_mcode_j1(mcode: mcode_t) -> bool

.. py:function:: is_mcode_jcond(mcode: mcode_t) -> bool

.. py:function:: is_mcode_convertible_to_jmp(mcode: mcode_t) -> bool

.. py:function:: is_mcode_convertible_to_set(mcode: mcode_t) -> bool

.. py:function:: is_mcode_call(mcode: mcode_t) -> bool

.. py:function:: is_mcode_fpu(mcode: mcode_t) -> bool

.. py:function:: is_mcode_commutative(mcode: mcode_t) -> bool

.. py:function:: is_mcode_shift(mcode: mcode_t) -> bool

.. py:function:: is_mcode_divmod(op: mcode_t) -> bool

.. py:function:: has_mcode_seloff(op: mcode_t) -> bool

.. py:function:: set2jcnd(code: mcode_t) -> mcode_t

.. py:function:: jcnd2set(code: mcode_t) -> mcode_t

.. py:function:: negate_mcode_relation(code: mcode_t) -> mcode_t

.. py:function:: swap_mcode_relation(code: mcode_t) -> mcode_t

.. py:function:: get_signed_mcode(code: mcode_t) -> mcode_t

.. py:function:: get_unsigned_mcode(code: mcode_t) -> mcode_t

.. py:function:: is_signed_mcode(code: mcode_t) -> bool

.. py:function:: is_unsigned_mcode(code: mcode_t) -> bool

.. py:function:: mcode_modifies_d(mcode: mcode_t) -> bool

.. py:class:: operand_locator_t(_ea: ida_idaapi.ea_t, _opnum: int)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      address of the original processor instruction



   .. py:attribute:: opnum
      :type:  int

      operand number in the instruction



   .. py:method:: compare(r: operand_locator_t) -> int


.. py:data:: MUST_ACCESS

.. py:data:: MAY_ACCESS

.. py:data:: MAYMUST_ACCESS_MASK

.. py:data:: ONE_ACCESS_TYPE

.. py:data:: INCLUDE_SPOILED_REGS

.. py:data:: EXCLUDE_PASS_REGS

.. py:data:: FULL_XDSU

.. py:data:: WITH_ASSERTS

.. py:data:: EXCLUDE_VOLATILE

.. py:data:: INCLUDE_UNUSED_SRC

.. py:data:: INCLUDE_DEAD_RETREGS

.. py:data:: INCLUDE_RESTRICTED

.. py:data:: CALL_SPOILS_ONLY_ARGS

.. py:data:: mr_none

.. py:data:: mr_cf

.. py:data:: mr_zf

.. py:data:: mr_sf

.. py:data:: mr_of

.. py:data:: mr_pf

.. py:data:: cc_count

.. py:data:: mr_cc

.. py:data:: mr_first

.. py:class:: number_format_t(_opnum: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags32
      :type:  flags_t

      low 32bit of flags (for compatibility)



   .. py:attribute:: opnum
      :type:  char

      operand number: 0..UA_MAXOP



   .. py:attribute:: props
      :type:  char

      properties: combination of NF_ bits (Number format property bits) 
              



   .. py:attribute:: serial
      :type:  uchar

      for enums: constant serial number



   .. py:attribute:: org_nbytes
      :type:  char

      original number size in bytes



   .. py:attribute:: type_name
      :type:  str

      for stroffs: structure for offsetof()
      for enums: enum name 
              



   .. py:attribute:: flags
      :type:  flags64_t

      ida flags, which describe number radix, enum, etc 
              



   .. py:method:: get_radix() -> int

      Get number radix 
              
      :returns: 2,8,10, or 16



   .. py:method:: is_fixed() -> bool

      Is number representation fixed? Fixed representation cannot be modified by the decompiler 
              



   .. py:method:: is_hex() -> bool

      Is a hexadecimal number?



   .. py:method:: is_dec() -> bool

      Is a decimal number?



   .. py:method:: is_oct() -> bool

      Is a octal number?



   .. py:method:: is_enum() -> bool

      Is a symbolic constant?



   .. py:method:: is_char() -> bool

      Is a character constant?



   .. py:method:: is_stroff() -> bool

      Is a structure field offset?



   .. py:method:: is_numop() -> bool

      Is a number?



   .. py:method:: needs_to_be_inverted() -> bool

      Does the number need to be negated or bitwise negated? Returns true if the user requested a negation but it is not done yet 
              



   .. py:method:: has_unmutable_type() -> bool


.. py:data:: NF_FIXED

   number format has been defined by the user


.. py:data:: NF_NEGDONE

   temporary internal bit: negation has been performed


.. py:data:: NF_BINVDONE

   temporary internal bit: inverting bits is done


.. py:data:: NF_NEGATE

   The user asked to negate the constant.


.. py:data:: NF_BITNOT

   The user asked to invert bits of the constant.


.. py:data:: NF_VALID

   internal bit: stroff or enum is valid for enums: this bit is set immediately for stroffs: this bit is set at the end of decompilation 
           


.. py:class:: vd_printer_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: tmpbuf
      :type:  str


   .. py:attribute:: hdrlines
      :type:  int

      number of header lines (prototype+typedef+lvars) valid at the end of print process 
              



.. py:class:: vc_printer_t(f: cfunc_t)

   Bases: :py:obj:`vd_printer_t`


   .. py:attribute:: thisown


   .. py:attribute:: func
      :type:  cfunc_t const *

      cfunc_t to generate text for



   .. py:attribute:: lastchar
      :type:  char

      internal: last printed character 
              



   .. py:method:: oneliner() -> bool

      Are we generating one-line text representation? 
              
      :returns: `true` if the output will occupy one line without line breaks



.. py:class:: qstring_printer_t(f: cfunc_t, tags: bool)

   Bases: :py:obj:`vc_printer_t`


   .. py:attribute:: thisown


   .. py:attribute:: with_tags
      :type:  bool

      Generate output with color tags.



   .. py:attribute:: s
      :type:  str

      Reference to the output string 
              



   .. py:method:: get_s() -> str


.. py:function:: dstr(tif: tinfo_t) -> str

   Print the specified type info. This function can be used from a debugger by typing "tif->dstr()" 
           


.. py:function:: is_type_correct(ptr: type_t const *) -> bool

   Verify a type string. 
           
   :returns: true if type string is correct


.. py:function:: is_small_udt(tif: tinfo_t) -> bool

   Is a small structure or union? 
           
   :returns: true if the type is a small UDT (user defined type). Small UDTs fit into a register (or pair or registers) as a rule.


.. py:function:: is_nonbool_type(type: tinfo_t) -> bool

   Is definitely a non-boolean type? 
           
   :returns: true if the type is a non-boolean type (non bool and well defined)


.. py:function:: is_bool_type(type: tinfo_t) -> bool

   Is a boolean type? 
           
   :returns: true if the type is a boolean type


.. py:function:: is_ptr_or_array(t: type_t) -> bool

   Is a pointer or array type?


.. py:function:: is_paf(t: type_t) -> bool

   Is a pointer, array, or function type?


.. py:function:: is_inplace_def(type: tinfo_t) -> bool

   Is struct/union/enum definition (not declaration)?


.. py:function:: partial_type_num(type: tinfo_t) -> int

   Calculate number of partial subtypes. 
           
   :returns: number of partial subtypes. The bigger is this number, the uglier is the type.


.. py:function:: get_float_type(width: int) -> tinfo_t

   Get a type of a floating point value with the specified width 
           
   :param width: width of the desired type
   :returns: type info object


.. py:function:: get_int_type_by_width_and_sign(srcwidth: int, sign: type_sign_t) -> tinfo_t

   Create a type info by width and sign. Returns a simple type (examples: int, short) with the given width and sign. 
           
   :param srcwidth: size of the type in bytes
   :param sign: sign of the type


.. py:function:: get_unk_type(size: int) -> tinfo_t

   Create a partial type info by width. Returns a partially defined type (examples: _DWORD, _BYTE) with the given width. 
           
   :param size: size of the type in bytes


.. py:function:: dummy_ptrtype(ptrsize: int, isfp: bool) -> tinfo_t

   Generate a dummy pointer type 
           
   :param ptrsize: size of pointed object
   :param isfp: is floating point object?


.. py:function:: make_pointer(type: tinfo_t) -> tinfo_t

   Create a pointer type. This function performs the following conversion: "type" -> "type*" 
           
   :param type: object type.
   :returns: "type*". for example, if 'char' is passed as the argument,


.. py:function:: create_typedef(*args) -> tinfo_t

   This function has the following signatures:

       0. create_typedef(name: str) -> tinfo_t
       1. create_typedef(n: int) -> tinfo_t

   # 0: create_typedef(name: str) -> tinfo_t

   Create a reference to a named type. 
           
   :returns: type which refers to the specified name. For example, if name is "DWORD", the type info which refers to "DWORD" is created.

   # 1: create_typedef(n: int) -> tinfo_t

   Create a reference to an ordinal type. 
           
   :returns: type which refers to the specified ordinal. For example, if n is 1, the type info which refers to ordinal type 1 is created.


.. py:data:: GUESSED_NONE

.. py:data:: GUESSED_WEAK

.. py:data:: GUESSED_FUNC

.. py:data:: GUESSED_DATA

.. py:data:: TS_NOELL

.. py:data:: TS_SHRINK

.. py:data:: TS_DONTREF

.. py:data:: TS_MASK

.. py:function:: get_type(id: int, tif: tinfo_t, guess: type_source_t) -> bool

   Get a global type. Global types are types of addressable objects and struct/union/enum types 
           
   :param id: address or id of the object
   :param tif: buffer for the answer
   :param guess: what kind of types to consider
   :returns: success


.. py:function:: set_type(id: int, tif: tinfo_t, source: type_source_t, force: bool = False) -> bool

   Set a global type. 
           
   :param id: address or id of the object
   :param tif: new type info
   :param source: where the type comes from
   :param force: true means to set the type as is, false means to merge the new type with the possibly existing old type info.
   :returns: success


.. py:class:: vdloc_t

   Bases: :py:obj:`ida_typeinf.argloc_t`


   .. py:attribute:: thisown


   .. py:method:: reg1() -> int

      Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
              



   .. py:method:: set_reg1(r1: int) -> None

      Set register location.



   .. py:method:: compare(r: vdloc_t) -> int


   .. py:method:: is_aliasable(mb: mba_t, size: int) -> bool


.. py:function:: print_vdloc(loc: vdloc_t, nbytes: int) -> str

   Print vdloc. Since vdloc does not always carry the size info, we pass it as NBYTES.. 
           


.. py:function:: arglocs_overlap(loc1: vdloc_t, w1: size_t, loc2: vdloc_t, w2: size_t) -> bool

   Do two arglocs overlap?


.. py:class:: lvar_locator_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: location
      :type:  vdloc_t

      Variable location.



   .. py:attribute:: defea
      :type:  ida_idaapi.ea_t

      Definition address. Usually, this is the address of the instruction that initializes the variable. In some cases it can be a fictional address. 
              



   .. py:method:: get_stkoff() -> int

      Get offset of the varialbe in the stack frame. 
              
      :returns: a non-negative value for stack variables. The value is an offset from the bottom of the stack frame in terms of vd-offsets. negative values mean error (not a stack variable)



   .. py:method:: is_reg1() -> bool

      Is variable located on one register?



   .. py:method:: is_reg2() -> bool

      Is variable located on two registers?



   .. py:method:: is_reg_var() -> bool

      Is variable located on register(s)?



   .. py:method:: is_stk_var() -> bool

      Is variable located on the stack?



   .. py:method:: is_scattered() -> bool

      Is variable scattered?



   .. py:method:: get_reg1() -> mreg_t

      Get the register number of the variable.



   .. py:method:: get_reg2() -> mreg_t

      Get the number of the second register (works only for ALOC_REG2 lvars)



   .. py:method:: get_scattered() -> scattered_aloc_t &

      Get information about scattered variable.



   .. py:method:: compare(r: lvar_locator_t) -> int


.. py:class:: lvar_t(*args, **kwargs)

   Bases: :py:obj:`lvar_locator_t`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      variable name. use mba_t::set_nice_lvar_name() and mba_t::set_user_lvar_name() to modify it 
              



   .. py:attribute:: cmt
      :type:  str

      variable comment string



   .. py:attribute:: tif
      :type:  tinfo_t

      variable type



   .. py:attribute:: width
      :type:  int

      variable size in bytes



   .. py:attribute:: defblk
      :type:  int

      first block defining the variable. 0 for args, -1 if unknown 
              



   .. py:attribute:: divisor
      :type:  uint64

      max known divisor of the variable



   .. py:method:: used() -> bool

      Is the variable used in the code?



   .. py:method:: typed() -> bool

      Has the variable a type?



   .. py:method:: mreg_done() -> bool

      Have corresponding microregs been replaced by references to this variable?



   .. py:method:: has_nice_name() -> bool

      Does the variable have a nice name?



   .. py:method:: is_unknown_width() -> bool

      Do we know the width of the variable?



   .. py:method:: has_user_info() -> bool

      Has any user-defined information?



   .. py:method:: has_user_name() -> bool

      Has user-defined name?



   .. py:method:: has_user_type() -> bool

      Has user-defined type?



   .. py:method:: is_result_var() -> bool

      Is the function result?



   .. py:method:: is_arg_var() -> bool

      Is the function argument?



   .. py:method:: is_fake_var() -> bool

      Is fake return variable?



   .. py:method:: is_overlapped_var() -> bool

      Is overlapped variable?



   .. py:method:: is_floating_var() -> bool

      Used by a fpu insn?



   .. py:method:: is_spoiled_var() -> bool

      Is spoiled var? (meaningful only during lvar allocation)



   .. py:method:: is_noptr_var() -> bool

      Variable type should not be a pointer.



   .. py:method:: is_mapdst_var() -> bool

      Other variable(s) map to this var?



   .. py:method:: is_thisarg() -> bool

      Is 'this' argument of a C++ member function?



   .. py:method:: is_split_var() -> bool

      Is a split variable?



   .. py:method:: has_regname() -> bool

      Has a register name? (like _RAX)



   .. py:method:: in_asm() -> bool

      Is variable used in an instruction translated into __asm?



   .. py:method:: is_dummy_arg() -> bool

      Is a dummy argument (added to fill a hole in the argument list)



   .. py:method:: is_notarg() -> bool

      Is a local variable? (local variable cannot be an input argument)



   .. py:method:: is_automapped() -> bool

      Was the variable automatically mapped to another variable?



   .. py:method:: is_used_byref() -> bool

      Was the address of the variable taken?



   .. py:method:: is_decl_unused() -> bool

      Was declared as __unused by the user? See CVAR_UNUSED.



   .. py:method:: is_shared() -> bool

      Is lvar mapped to several chains.



   .. py:method:: was_scattered_arg() -> bool

      Was lvar transformed from a scattered argument?



   .. py:method:: set_used() -> None


   .. py:method:: clear_used() -> None


   .. py:method:: set_typed() -> None


   .. py:method:: set_non_typed() -> None


   .. py:method:: clr_user_info() -> None


   .. py:method:: set_user_name() -> None


   .. py:method:: set_user_type() -> None


   .. py:method:: clr_user_type() -> None


   .. py:method:: clr_user_name() -> None


   .. py:method:: set_mreg_done() -> None


   .. py:method:: clr_mreg_done() -> None


   .. py:method:: set_unknown_width() -> None


   .. py:method:: clr_unknown_width() -> None


   .. py:method:: set_arg_var() -> None


   .. py:method:: clr_arg_var() -> None


   .. py:method:: set_fake_var() -> None


   .. py:method:: clr_fake_var() -> None


   .. py:method:: set_overlapped_var() -> None


   .. py:method:: clr_overlapped_var() -> None


   .. py:method:: set_floating_var() -> None


   .. py:method:: clr_floating_var() -> None


   .. py:method:: set_spoiled_var() -> None


   .. py:method:: clr_spoiled_var() -> None


   .. py:method:: set_mapdst_var() -> None


   .. py:method:: clr_mapdst_var() -> None


   .. py:method:: set_noptr_var() -> None


   .. py:method:: clr_noptr_var() -> None


   .. py:method:: set_thisarg() -> None


   .. py:method:: clr_thisarg() -> None


   .. py:method:: set_split_var() -> None


   .. py:method:: clr_split_var() -> None


   .. py:method:: set_dummy_arg() -> None


   .. py:method:: clr_dummy_arg() -> None


   .. py:method:: set_notarg() -> None


   .. py:method:: clr_notarg() -> None


   .. py:method:: set_automapped() -> None


   .. py:method:: clr_automapped() -> None


   .. py:method:: set_used_byref() -> None


   .. py:method:: clr_used_byref() -> None


   .. py:method:: set_decl_unused() -> None


   .. py:method:: clr_decl_unused() -> None


   .. py:method:: set_shared() -> None


   .. py:method:: clr_shared() -> None


   .. py:method:: set_scattered_arg() -> None


   .. py:method:: clr_scattered_arg() -> None


   .. py:method:: has_common(v: lvar_t) -> bool

      Do variables overlap?



   .. py:method:: has_common_bit(loc: vdloc_t, width2: asize_t) -> bool

      Does the variable overlap with the specified location?



   .. py:method:: type() -> tinfo_t &

      Get variable type.



   .. py:method:: accepts_type(t: tinfo_t, may_change_thisarg: bool = False) -> bool

      Check if the variable accept the specified type. Some types are forbidden (void, function types, wrong arrays, etc) 
              



   .. py:method:: set_lvar_type(t: tinfo_t, may_fail: bool = False) -> bool

      Set variable type Note: this function does not modify the idb, only the lvar instance in the memory. For permanent changes see modify_user_lvars() Also, the variable type is not considered as final by the decompiler and may be modified later by the type derivation. In some cases set_final_var_type() may work better, but it does not do persistent changes to the database neither. 
              
      :param t: new type
      :param may_fail: if false and type is bad, interr
      :returns: success



   .. py:method:: set_final_lvar_type(t: tinfo_t) -> None

      Set final variable type.



   .. py:method:: set_width(w: int, svw_flags: int = 0) -> bool

      Change the variable width. We call the variable size 'width', it is represents the number of bytes. This function may change the variable type using set_lvar_type(). 
              
      :param w: new width
      :param svw_flags: combination of SVW_... bits
      :returns: success



   .. py:method:: append_list(mba: mba_t, lst: mlist_t, pad_if_scattered: bool = False) -> None

      Append local variable to mlist. 
              
      :param mba: ptr to the current mba_t
      :param lst: list to append to
      :param pad_if_scattered: if true, append padding bytes in case of scattered lvar



   .. py:method:: is_aliasable(mba: mba_t) -> bool

      Is the variable aliasable? 
              
      :param mba: ptr to the current mba_t Aliasable variables may be modified indirectly (through a pointer)



.. py:data:: SVW_INT

.. py:data:: SVW_FLOAT

.. py:data:: SVW_SOFT

.. py:class:: lvars_t

   Bases: :py:obj:`qvector_lvar_t`


   .. py:attribute:: thisown


   .. py:method:: find_input_lvar(argloc: vdloc_t, _size: int) -> int

      Find an input variable at the specified location. 
              
      :param argloc: variable location
      :param _size: variable size in bytes
      :returns: -1 if failed, otherwise an index into 'vars'



   .. py:method:: find_input_reg(reg: int, _size: int = 1) -> int

      Find an input register variable. 
              
      :param reg: register to find
      :param _size: variable size in bytes
      :returns: -1 if failed, otherwise an index into 'vars'



   .. py:method:: find_stkvar(spoff: int, width: int) -> int

      Find a stack variable at the specified location. 
              
      :param spoff: offset from the minimal sp
      :param width: variable size in bytes
      :returns: -1 if failed, otherwise an index into 'vars'



   .. py:method:: find(ll: lvar_locator_t) -> lvar_t *

      Find a variable at the specified location. 
              
      :param ll: variable location
      :returns: pointer to variable or nullptr



   .. py:method:: find_lvar(location: vdloc_t, width: int, defblk: int = -1) -> int

      Find a variable at the specified location. 
              
      :param location: variable location
      :param width: variable size in bytes
      :param defblk: definition block of the lvar. -1 means any block
      :returns: -1 if failed, otherwise an index into 'vars'



.. py:class:: lvar_saved_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ll
      :type:  lvar_locator_t

      Variable locator.



   .. py:attribute:: name
      :type:  str

      Name.



   .. py:attribute:: type
      :type:  tinfo_t

      Type.



   .. py:attribute:: cmt
      :type:  str

      Comment.



   .. py:attribute:: size
      :type:  ssize_t

      Type size (if not initialized then -1)



   .. py:attribute:: flags
      :type:  int

      saved user lvar info property bits 
              



   .. py:method:: has_info() -> bool


   .. py:method:: is_kept() -> bool


   .. py:method:: clear_keep() -> None


   .. py:method:: set_keep() -> None


   .. py:method:: is_split_lvar() -> bool


   .. py:method:: set_split_lvar() -> None


   .. py:method:: clr_split_lvar() -> None


   .. py:method:: is_noptr_lvar() -> bool


   .. py:method:: set_noptr_lvar() -> None


   .. py:method:: clr_noptr_lvar() -> None


   .. py:method:: is_nomap_lvar() -> bool


   .. py:method:: set_nomap_lvar() -> None


   .. py:method:: clr_nomap_lvar() -> None


   .. py:method:: is_unused_lvar() -> bool


   .. py:method:: set_unused_lvar() -> None


   .. py:method:: clr_unused_lvar() -> None


.. py:data:: LVINF_KEEP

   preserve saved user settings regardless of vars for example, if a var loses all its user-defined attributes or even gets destroyed, keep its lvar_saved_info_t. this is used for ephemeral variables that get destroyed by macro recognition. 
           


.. py:data:: LVINF_SPLIT

   split allocation of a new variable. forces the decompiler to create a new variable at ll.defea 
           


.. py:data:: LVINF_NOPTR

   variable type should not be a pointer


.. py:data:: LVINF_NOMAP

   forbid automatic mapping of the variable


.. py:data:: LVINF_UNUSED

   unused argument, corresponds to CVAR_UNUSED


.. py:class:: lvar_uservec_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: lvvec
      :type:  lvar_saved_infos_t

      User-specified names, types, comments for lvars. Variables without user-specified info are not present in this vector. 
              



   .. py:attribute:: lmaps
      :type:  lvar_mapping_t

      Local variable mapping (used for merging variables)



   .. py:attribute:: stkoff_delta
      :type:  int

      Delta to add to IDA stack offset to calculate Hex-Rays stack offsets. Should be set by the caller before calling save_user_lvar_settings(); 
              



   .. py:attribute:: ulv_flags
      :type:  int

      Various flags. Possible values are from lvar_uservec_t property bits.



   .. py:method:: swap(r: lvar_uservec_t) -> None


   .. py:method:: clear() -> None


   .. py:method:: empty() -> bool


   .. py:method:: find_info(vloc: lvar_locator_t) -> lvar_saved_info_t *

      find saved user settings for given var



   .. py:method:: keep_info(v: lvar_t) -> None

      Preserve user settings for given var.



.. py:data:: ULV_PRECISE_DEFEA

   Use precise defea's for lvar locations.


.. py:function:: restore_user_lvar_settings(lvinf: lvar_uservec_t, func_ea: ida_idaapi.ea_t) -> bool

   Restore user defined local variable settings in the database. 
           
   :param lvinf: ptr to output buffer
   :param func_ea: entry address of the function
   :returns: success


.. py:function:: save_user_lvar_settings(func_ea: ida_idaapi.ea_t, lvinf: lvar_uservec_t) -> None

   Save user defined local variable settings into the database. 
           
   :param func_ea: entry address of the function
   :param lvinf: user-specified info about local variables


.. py:class:: user_lvar_modifier_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: modify_lvars(lvinf: lvar_uservec_t) -> bool

      Modify lvar settings. Returns: true-modified 
              



.. py:function:: modify_user_lvars(entry_ea: ida_idaapi.ea_t, mlv: user_lvar_modifier_t) -> bool

   Modify saved local variable settings. 
           
   :param entry_ea: function start address
   :param mlv: local variable modifier
   :returns: true if modified variables


.. py:function:: modify_user_lvar_info(func_ea: ida_idaapi.ea_t, mli_flags: uint, info: lvar_saved_info_t) -> bool

   Modify saved local variable settings of one variable. 
           
   :param func_ea: function start address
   :param mli_flags: bits that specify which attrs defined by INFO are to be set
   :param info: local variable info attrs
   :returns: true if modified, false if invalid MLI_FLAGS passed


.. py:data:: MLI_NAME

   apply lvar name


.. py:data:: MLI_TYPE

   apply lvar type


.. py:data:: MLI_CMT

   apply lvar comment


.. py:data:: MLI_SET_FLAGS

   set LVINF_... bits


.. py:data:: MLI_CLR_FLAGS

   clear LVINF_... bits


.. py:function:: locate_lvar(out: lvar_locator_t, func_ea: ida_idaapi.ea_t, varname: str) -> bool

   Find a variable by name. 
           
   :param out: output buffer for the variable locator
   :param func_ea: function start address
   :param varname: variable name
   :returns: success Since VARNAME is not always enough to find the variable, it may decompile the function.


.. py:function:: rename_lvar(func_ea: ida_idaapi.ea_t, oldname: str, newname: str) -> bool

   Rename a local variable. 
           
   :param func_ea: function start address
   :param oldname: old name of the variable
   :param newname: new name of the variable
   :returns: success This is a convenience function. For bulk renaming consider using modify_user_lvars.


.. py:class:: udcall_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: tif
      :type:  tinfo_t


   .. py:method:: compare(r: udcall_t) -> int


   .. py:method:: empty() -> bool


.. py:function:: restore_user_defined_calls(udcalls: udcall_map_t *, func_ea: ida_idaapi.ea_t) -> bool

   Restore user defined function calls from the database. 
           
   :param udcalls: ptr to output buffer
   :param func_ea: entry address of the function
   :returns: success


.. py:function:: save_user_defined_calls(func_ea: ida_idaapi.ea_t, udcalls: udcall_map_t const &) -> None

   Save user defined local function calls into the database. 
           
   :param func_ea: entry address of the function
   :param udcalls: user-specified info about user defined function calls


.. py:function:: parse_user_call(udc: udcall_t, decl: str, silent: bool) -> bool

   Convert function type declaration into internal structure 
           
   :param udc: - pointer to output structure
   :param decl: - function type declaration
   :param silent: - if TRUE: do not show warning in case of incorrect type
   :returns: success


.. py:function:: convert_to_user_call(udc: udcall_t, cdg: codegen_t) -> merror_t

   try to generate user-defined call for an instruction 
           
   :returns: Microcode error code code: MERR_OK - user-defined call generated else - error (MERR_INSN == inacceptable udc.tif)


.. py:class:: microcode_filter_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: match(cdg: codegen_t) -> bool

      check if the filter object is to be applied 
              
      :returns: success



   .. py:method:: apply(cdg: codegen_t) -> merror_t

      generate microcode for an instruction 
              
      :returns: MERR_... code: MERR_OK - user-defined microcode generated, go to the next instruction MERR_INSN - not generated - the caller should try the standard way else - error



.. py:function:: install_microcode_filter(filter: microcode_filter_t, install: bool = True) -> bool

   register/unregister non-standard microcode generator 
           
   :param filter: - microcode generator object
   :param install: - TRUE - register the object, FALSE - unregister
   :returns: success


.. py:class:: udc_filter_t

   Bases: :py:obj:`microcode_filter_t`


   .. py:attribute:: thisown


   .. py:method:: cleanup() -> None

      Cleanup the filter This function properly clears type information associated to this filter. 
              



   .. py:method:: match(cdg: codegen_t) -> bool

      return true if the filter object should be applied to given instruction



   .. py:method:: apply(cdg: codegen_t) -> merror_t

      generate microcode for an instruction 
              
      :returns: MERR_... code: MERR_OK - user-defined microcode generated, go to the next instruction MERR_INSN - not generated - the caller should try the standard way else - error



   .. py:method:: empty() -> bool


   .. py:method:: install() -> None


   .. py:method:: remove() -> bool


   .. py:method:: init(decl: str) -> bool


.. py:class:: bitset_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: swap(r: bitset_t) -> None


   .. py:method:: copy(m: bitset_t) -> bitset_t &


   .. py:method:: add(*args) -> bool

      This function has the following signatures:

          0. add(bit: int) -> bool
          1. add(bit: int, width: int) -> bool
          2. add(ml: const bitset_t &) -> bool

      # 0: add(bit: int) -> bool


      # 1: add(bit: int, width: int) -> bool


      # 2: add(ml: const bitset_t &) -> bool



   .. py:method:: sub(*args) -> bool

      This function has the following signatures:

          0. sub(bit: int) -> bool
          1. sub(bit: int, width: int) -> bool
          2. sub(ml: const bitset_t &) -> bool

      # 0: sub(bit: int) -> bool


      # 1: sub(bit: int, width: int) -> bool


      # 2: sub(ml: const bitset_t &) -> bool



   .. py:method:: cut_at(maxbit: int) -> bool


   .. py:method:: shift_down(shift: int) -> None


   .. py:method:: has(bit: int) -> bool


   .. py:method:: has_all(bit: int, width: int) -> bool


   .. py:method:: has_any(bit: int, width: int) -> bool


   .. py:method:: dstr() -> str


   .. py:method:: empty() -> bool


   .. py:method:: count(*args) -> int

      This function has the following signatures:

          0. count() -> int
          1. count(bit: int) -> int

      # 0: count() -> int


      # 1: count(bit: int) -> int



   .. py:method:: last() -> int


   .. py:method:: clear() -> None


   .. py:method:: fill_with_ones(maxbit: int) -> None


   .. py:method:: has_common(ml: bitset_t) -> bool


   .. py:method:: intersect(ml: bitset_t) -> bool


   .. py:method:: is_subset_of(ml: bitset_t) -> bool


   .. py:method:: includes(ml: bitset_t) -> bool


   .. py:method:: compare(r: bitset_t) -> int


   .. py:method:: itat(n: int) -> bitset_t::iterator


   .. py:method:: begin() -> bitset_t::iterator


   .. py:method:: end() -> bitset_t::iterator


   .. py:method:: front() -> int


   .. py:method:: back() -> int


   .. py:method:: inc(p: iterator, n: int = 1) -> None


   .. py:method:: itv(it: iterator) -> int


.. py:data:: bitset_width

.. py:data:: bitset_align

.. py:data:: bitset_shift

.. py:class:: iterator(n: int = -1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:class:: node_bitset_t(*args)

   Bases: :py:obj:`bitset_t`


   .. py:attribute:: thisown


.. py:class:: array_of_node_bitset_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:class:: ivl_t(_off: int = 0, _size: int = 0)

   Bases: :py:obj:`uval_ivl_t`


   .. py:attribute:: thisown


   .. py:method:: empty() -> bool


   .. py:method:: clear() -> None


   .. py:method:: dstr() -> str


   .. py:method:: extend_to_cover(r: ivl_t) -> bool


   .. py:method:: intersect(r: ivl_t) -> None


   .. py:method:: overlap(ivl: ivl_t) -> bool


   .. py:method:: includes(ivl: ivl_t) -> bool


   .. py:method:: contains(off2: int) -> bool


   .. py:method:: compare(r: ivl_t) -> int


.. py:class:: ivl_with_name_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ivl
      :type:  ivl_t


   .. py:attribute:: whole
      :type:  str


   .. py:attribute:: part
      :type:  str


.. py:class:: ivlset_t(*args)

   Bases: :py:obj:`uval_ivl_ivlset_t`


   .. py:attribute:: thisown


   .. py:method:: add(*args) -> bool

      This function has the following signatures:

          0. add(ivl: const ivl_t &) -> bool
          1. add(ea: ida_idaapi.ea_t, size: asize_t) -> bool
          2. add(ivs: const ivlset_t &) -> bool

      # 0: add(ivl: const ivl_t &) -> bool


      # 1: add(ea: ida_idaapi.ea_t, size: asize_t) -> bool


      # 2: add(ivs: const ivlset_t &) -> bool



   .. py:method:: addmasked(ivs: ivlset_t, mask: ivl_t) -> bool


   .. py:method:: sub(*args) -> bool

      This function has the following signatures:

          0. sub(ivl: const ivl_t &) -> bool
          1. sub(ea: ida_idaapi.ea_t, size: asize_t) -> bool
          2. sub(ivs: const ivlset_t &) -> bool

      # 0: sub(ivl: const ivl_t &) -> bool


      # 1: sub(ea: ida_idaapi.ea_t, size: asize_t) -> bool


      # 2: sub(ivs: const ivlset_t &) -> bool



   .. py:method:: dstr() -> str


   .. py:method:: count() -> asize_t


   .. py:method:: has_common(*args) -> bool

      This function has the following signatures:

          0. has_common(ivl: const ivl_t &, strict: bool=false) -> bool
          1. has_common(ivs: const ivlset_t &) -> bool

      # 0: has_common(ivl: const ivl_t &, strict: bool=false) -> bool


      # 1: has_common(ivs: const ivlset_t &) -> bool



   .. py:method:: contains(off: int) -> bool


   .. py:method:: includes(ivs: ivlset_t) -> bool


   .. py:method:: intersect(ivs: ivlset_t) -> bool


   .. py:method:: compare(r: ivlset_t) -> int


.. py:class:: rlist_t(*args)

   Bases: :py:obj:`bitset_t`


   .. py:attribute:: thisown


   .. py:method:: dstr() -> str


.. py:class:: mlist_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: reg
      :type:  rlist_t


   .. py:attribute:: mem
      :type:  ivlset_t


   .. py:method:: swap(r: mlist_t) -> None


   .. py:method:: addmem(ea: ida_idaapi.ea_t, size: asize_t) -> bool


   .. py:method:: add(*args) -> bool

      This function has the following signatures:

          0. add(r: mreg_t, size: int) -> bool
          1. add(r: const rlist_t &) -> bool
          2. add(ivl: const ivl_t &) -> bool
          3. add(lst: const mlist_t &) -> bool

      # 0: add(r: mreg_t, size: int) -> bool


      # 1: add(r: const rlist_t &) -> bool


      # 2: add(ivl: const ivl_t &) -> bool


      # 3: add(lst: const mlist_t &) -> bool



   .. py:method:: sub(*args) -> bool

      This function has the following signatures:

          0. sub(r: mreg_t, size: int) -> bool
          1. sub(ivl: const ivl_t &) -> bool
          2. sub(lst: const mlist_t &) -> bool

      # 0: sub(r: mreg_t, size: int) -> bool


      # 1: sub(ivl: const ivl_t &) -> bool


      # 2: sub(lst: const mlist_t &) -> bool



   .. py:method:: count() -> asize_t


   .. py:method:: dstr() -> str


   .. py:method:: empty() -> bool


   .. py:method:: clear() -> None


   .. py:method:: has(r: mreg_t) -> bool


   .. py:method:: has_all(r: mreg_t, size: int) -> bool


   .. py:method:: has_any(r: mreg_t, size: int) -> bool


   .. py:method:: has_memory() -> bool


   .. py:method:: has_common(lst: mlist_t) -> bool


   .. py:method:: includes(lst: mlist_t) -> bool


   .. py:method:: intersect(lst: mlist_t) -> bool


   .. py:method:: is_subset_of(lst: mlist_t) -> bool


   .. py:method:: compare(r: mlist_t) -> int


.. py:function:: get_temp_regs() -> mlist_t const &

   Get list of temporary registers. Tempregs are temporary registers that are used during code generation. They do not map to regular processor registers. They are used only to store temporary values during execution of one instruction. Tempregs may not be used to pass a value from one block to another. In other words, at the end of a block all tempregs must be dead. 
           


.. py:function:: is_kreg(r: mreg_t) -> bool

   Is a kernel register? Kernel registers are temporary registers that can be used freely. They may be used to store values that cross instruction or basic block boundaries. Kernel registers do not map to regular processor registers. See also mba_t::alloc_kreg() 
           


.. py:function:: reg2mreg(reg: int) -> mreg_t

   Map a processor register to a microregister. 
           
   :param reg: processor register number
   :returns: microregister register id or mr_none


.. py:function:: mreg2reg(reg: mreg_t, width: int) -> int

   Map a microregister to a processor register. 
           
   :param reg: microregister number
   :param width: size of microregister in bytes
   :returns: processor register id or -1


.. py:function:: get_mreg_name(reg: mreg_t, width: int, ud: void * = None) -> str

   Get the microregister name. 
           
   :param reg: microregister number
   :param width: size of microregister in bytes. may be bigger than the real register size.
   :param ud: reserved, must be nullptr
   :returns: width of the printed register. this value may be less than the WIDTH argument.


.. py:class:: optinsn_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: func(blk: mblock_t, ins: minsn_t, optflags: int) -> int

      Optimize an instruction. 
              
      :param blk: current basic block. maybe nullptr, which means that the instruction must be optimized without context
      :param ins: instruction to optimize; it is always a top-level instruction. the callback may not delete the instruction but may convert it into nop (see mblock_t::make_nop). to optimize sub-instructions, visit them using minsn_visitor_t. sub-instructions may not be converted into nop but can be converted to "mov x,x". for example: add x,0,x => mov x,x this callback may change other instructions in the block, but should do this with care, e.g. to no break the propagation algorithm if called with OPTI_NO_LDXOPT.
      :param optflags: combination of optimization flags bits
      :returns: number of changes made to the instruction. if after this call the instruction's use/def lists have changed, you must mark the block level lists as dirty (see mark_lists_dirty)



   .. py:method:: install() -> None


   .. py:method:: remove() -> bool


.. py:class:: optblock_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: func(blk: mblock_t) -> int

      Optimize a block. This function usually performs the optimizations that require analyzing the entire block and/or its neighbors. For example it can recognize patterns and perform conversions like: b0: b0: ... ... jnz x, 0, @b2 => jnz x, 0, @b2 b1: b1: add x, 0, y mov x, y ... ... 
              
      :param blk: Basic block to optimize as a whole.
      :returns: number of changes made to the block. See also mark_lists_dirty.



   .. py:method:: install() -> None


   .. py:method:: remove() -> bool


.. py:class:: simple_graph_t(*args, **kwargs)

   Bases: :py:obj:`ida_gdl.gdl_graph_t`


   .. py:attribute:: thisown


   .. py:attribute:: title
      :type:  str


   .. py:attribute:: colored_gdl_edges
      :type:  bool


   .. py:method:: compute_dominators(domin: array_of_node_bitset_t, post: bool = False) -> None


   .. py:method:: compute_immediate_dominators(domin: array_of_node_bitset_t, idomin: intvec_t, post: bool = False) -> None


   .. py:method:: depth_first_preorder(pre: node_ordering_t) -> int


   .. py:method:: depth_first_postorder(post: node_ordering_t) -> int


   .. py:method:: begin() -> simple_graph_t::iterator


   .. py:method:: end() -> simple_graph_t::iterator


   .. py:method:: front() -> int


   .. py:method:: inc(p: simple_graph_t::iterator &, n: int = 1) -> None


   .. py:method:: goup(node: int) -> int


.. py:class:: op_parent_info_t(_mba: mba_t = None, _blk: mblock_t = None, _topins: minsn_t = None)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t *


   .. py:attribute:: blk
      :type:  mblock_t *


   .. py:attribute:: topins
      :type:  minsn_t *


   .. py:attribute:: curins
      :type:  minsn_t *


.. py:class:: minsn_visitor_t(_mba: mba_t = None, _blk: mblock_t = None, _topins: minsn_t = None)

   Bases: :py:obj:`op_parent_info_t`


   .. py:attribute:: thisown


   .. py:method:: visit_minsn() -> int


.. py:class:: mop_visitor_t(_mba: mba_t = None, _blk: mblock_t = None, _topins: minsn_t = None)

   Bases: :py:obj:`op_parent_info_t`


   .. py:attribute:: thisown


   .. py:attribute:: prune
      :type:  bool

      Should skip sub-operands of the current operand? visit_mop() may set 'prune=true' for that. 
              



   .. py:method:: visit_mop(op: mop_t, type: tinfo_t, is_target: bool) -> int


.. py:class:: scif_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit_scif_mop(r: mop_t, off: int) -> int


.. py:class:: mlist_mop_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: topins
      :type:  minsn_t *


   .. py:attribute:: curins
      :type:  minsn_t *


   .. py:attribute:: changed
      :type:  bool


   .. py:attribute:: list
      :type:  mlist_t *


   .. py:attribute:: prune
      :type:  bool

      Should skip sub-operands of the current operand? visit_mop() may set 'prune=true' for that. 
              



   .. py:method:: visit_mop(op: mop_t) -> int


.. py:class:: lvar_ref_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t *const

      Pointer to the parent mba_t object. Since we need to access the 'mba->vars' array in order to retrieve the referenced variable, we keep a pointer to mba_t here. Note: this means this class and consequently mop_t, minsn_t, mblock_t are specific to a mba_t object and cannot migrate between them. fortunately this is not something we need to do. second, lvar_ref_t's appear only after MMAT_LVARS. 
              



   .. py:attribute:: off
      :type:  int

      offset from the beginning of the variable



   .. py:attribute:: idx
      :type:  int

      index into mba->vars



   .. py:method:: compare(r: lvar_ref_t) -> int


   .. py:method:: swap(r: lvar_ref_t) -> None


   .. py:method:: var() -> lvar_t &

      Retrieve the referenced variable.



.. py:data:: mop_z

   none


.. py:data:: mop_r

   register (they exist until MMAT_LVARS)


.. py:data:: mop_n

   immediate number constant


.. py:data:: mop_str

   immediate string constant (user representation)


.. py:data:: mop_d

   result of another instruction


.. py:data:: mop_S

   local stack variable (they exist until MMAT_LVARS)


.. py:data:: mop_v

   global variable


.. py:data:: mop_b

   micro basic block (mblock_t)


.. py:data:: mop_f

   list of arguments


.. py:data:: mop_l

   local variable


.. py:data:: mop_a

   mop_addr_t: address of operand (mop_l, mop_v, mop_S, mop_r)


.. py:data:: mop_h

   helper function


.. py:data:: mop_c

   mcases


.. py:data:: mop_fn

   floating point constant


.. py:data:: mop_p

   operand pair


.. py:data:: mop_sc

   scattered


.. py:data:: NOSIZE

   wrong or unexisting operand size


.. py:class:: stkvar_ref_t(m: mba_t, o: int)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t *const

      Pointer to the parent mba_t object. We need it in order to retrieve the referenced stack variable. See notes for lvar_ref_t::mba. 
              



   .. py:attribute:: off
      :type:  int

      Offset to the stack variable from the bottom of the stack frame. It is called 'decompiler stkoff' and it is different from IDA stkoff. See a note and a picture about 'decompiler stkoff' below. 
              



   .. py:method:: compare(r: stkvar_ref_t) -> int


   .. py:method:: swap(r: stkvar_ref_t) -> None


   .. py:method:: get_stkvar(udm: udm_t = None, p_idaoff: uval_t * = None) -> ssize_t

      Retrieve the referenced stack variable. 
              
      :param udm: stkvar, may be nullptr
      :param p_idaoff: if specified, will hold IDA stkoff after the call.
      :returns: index of stkvar in the frame or -1



.. py:class:: scif_t(_mba: mba_t, tif: tinfo_t, n: str = None)

   Bases: :py:obj:`vdloc_t`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t *

      Pointer to the parent mba_t object. Some operations may convert a scattered operand into something simpler, (a stack operand, for example). We will need to create stkvar_ref_t at that moment, this is why we need this pointer. See notes for lvar_ref_t::mba. 
              



   .. py:attribute:: name
      :type:  str

      Usually scattered operands are created from a function prototype, which has the name information. We preserve it and use it to name the corresponding local variable. 
              



   .. py:attribute:: type
      :type:  tinfo_t

      Scattered operands always have type info assigned to them because without it we won't be able to manipulte them. 
              



.. py:class:: mnumber_t(*args)

   Bases: :py:obj:`operand_locator_t`


   .. py:attribute:: thisown


   .. py:attribute:: value
      :type:  uint64


   .. py:attribute:: org_value
      :type:  uint64


   .. py:method:: compare(r: mnumber_t) -> int


   .. py:method:: update_value(val64: uint64) -> None


.. py:class:: fnumber_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: fnum
      :type:  fpvalue_t

      Internal representation of the number.



   .. py:attribute:: nbytes
      :type:  int

      Original size of the constant in bytes.



   .. py:method:: dereference_uint16() -> uint16 *


   .. py:method:: dereference_const_uint16() -> uint16 const *


   .. py:method:: compare(r: fnumber_t) -> int


   .. py:method:: calc_max_exp() -> int


   .. py:method:: is_nan() -> bool


.. py:data:: SHINS_NUMADDR

   display definition addresses for numbers


.. py:data:: SHINS_VALNUM

   display value numbers


.. py:data:: SHINS_SHORT

   do not display use-def chains and other attrs


.. py:data:: SHINS_LDXEA

   display address of ldx expressions (not used)


.. py:data:: NO_SIDEFF

   change operand size but ignore side effects if you decide to keep the changed operand, handle_new_size() must be called 
             


.. py:data:: WITH_SIDEFF

   change operand size and handle side effects


.. py:data:: ONLY_SIDEFF

   only handle side effects


.. py:data:: ANY_REGSIZE

   any register size is permitted


.. py:data:: ANY_FPSIZE

   any size of floating operand is permitted


.. py:class:: mop_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: t
      :type:  mopt_t

      Operand type.



   .. py:attribute:: oprops
      :type:  uint8

      Operand properties.



   .. py:attribute:: valnum
      :type:  uint16

      Value number. Zero means unknown. Operands with the same value number are equal. 
              



   .. py:attribute:: size
      :type:  int

      Operand size. Usually it is 1,2,4,8 or NOSIZE but for UDTs other sizes are permitted 
              



   .. py:method:: set_impptr_done() -> None


   .. py:method:: set_udt() -> None


   .. py:method:: set_undef_val() -> None


   .. py:method:: set_lowaddr() -> None


   .. py:method:: set_for_abi() -> None


   .. py:method:: is_impptr_done() -> bool


   .. py:method:: is_udt() -> bool


   .. py:method:: probably_floating() -> bool


   .. py:method:: is_undef_val() -> bool


   .. py:method:: is_lowaddr() -> bool


   .. py:method:: is_for_abi() -> bool


   .. py:method:: is_ccflags() -> bool


   .. py:method:: is_pcval() -> bool


   .. py:method:: is_glbaddr_from_fixup() -> bool


   .. py:method:: assign(rop: mop_t) -> mop_t &


   .. py:method:: zero() -> None


   .. py:method:: swap(rop: mop_t) -> None


   .. py:method:: erase() -> None


   .. py:method:: erase_but_keep_size() -> None


   .. py:method:: dstr() -> str


   .. py:method:: create_from_mlist(mba: mba_t, lst: mlist_t, fullsize: int) -> bool

      Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our operand will be (t=mop_r, r=R0, size=4) 
              
      :param mba: pointer to microcode
      :param lst: list of locations
      :param fullsize: mba->fullsize
      :returns: success



   .. py:method:: create_from_ivlset(mba: mba_t, ivs: ivlset_t, fullsize: int) -> bool

      Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4) 
              
      :param mba: pointer to microcode
      :param ivs: set of memory intervals
      :param fullsize: mba->fullsize
      :returns: success



   .. py:method:: create_from_vdloc(mba: mba_t, loc: vdloc_t, _size: int) -> None

      Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0, size=_SIZE) 
              
      :param mba: pointer to microcode
      :param loc: location
      :param _size: operand size Note: this function cannot handle scattered locations.
      :returns: success



   .. py:method:: create_from_scattered_vdloc(mba: mba_t, name: str, type: tinfo_t, loc: vdloc_t) -> None

      Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4, EDX.4}) 
              
      :param mba: pointer to microcode
      :param name: name of the operand, if available
      :param type: type of the operand, must be present
      :param loc: a scattered location
      :returns: success



   .. py:method:: create_from_insn(m: minsn_t) -> None

      Create operand from an instruction. This function creates a nested instruction that can be used as an operand. Example: if m="add x,y,z", our operand will be (t=mop_d,d=m). The destination operand of 'add' (z) is lost. 
              
      :param m: instruction to embed into operand. may not be nullptr.



   .. py:method:: make_number(*args) -> None

      Create an integer constant operand. 
              
      :param _value: value to store in the operand
      :param _size: size of the value in bytes (1,2,4,8)
      :param _ea: address of the processor instruction that made the value
      :param opnum: operand number of the processor instruction



   .. py:method:: make_fpnum(bytes: void const *) -> bool

      Create a floating point constant operand. 
              
      :param bytes: pointer to the floating point value as used by the current processor (e.g. for x86 it must be in IEEE 754)
      :returns: success



   .. py:method:: make_reg(*args) -> None

      This function has the following signatures:

          0. make_reg(reg: mreg_t) -> None
          1. make_reg(reg: mreg_t, _size: int) -> None

      # 0: make_reg(reg: mreg_t) -> None

      Create a register operand.


      # 1: make_reg(reg: mreg_t, _size: int) -> None



   .. py:method:: make_gvar(ea: ida_idaapi.ea_t) -> None

      Create a global variable operand.



   .. py:method:: make_stkvar(mba: mba_t, off: int) -> None


   .. py:method:: make_reg_pair(loreg: int, hireg: int, halfsize: int) -> None

      Create pair of registers. 
              
      :param loreg: register holding the low part of the value
      :param hireg: register holding the high part of the value
      :param halfsize: the size of each of loreg/hireg



   .. py:method:: make_insn(ins: minsn_t) -> None

      Create a nested instruction.



   .. py:method:: make_blkref(blknum: int) -> None

      Create a global variable operand.



   .. py:method:: make_helper(name: str) -> None

      Create a helper operand. A helper operand usually keeps a built-in function name like "va_start" It is essentially just an arbitrary identifier without any additional info. 
              



   .. py:method:: empty() -> bool


   .. py:method:: is_glbvar() -> bool

      Is a global variable?



   .. py:method:: is_stkvar() -> bool

      Is a stack variable?



   .. py:method:: is_reg(*args) -> bool

      This function has the following signatures:

          0. is_reg() -> bool
          1. is_reg(_r: mreg_t) -> bool
          2. is_reg(_r: mreg_t, _size: int) -> bool

      # 0: is_reg() -> bool

      Is a register operand? See also get_mreg_name() 
              

      # 1: is_reg(_r: mreg_t) -> bool

      Is the specified register?


      # 2: is_reg(_r: mreg_t, _size: int) -> bool

      Is the specified register of the specified size?



   .. py:method:: is_arglist() -> bool

      Is a list of arguments?



   .. py:method:: is_cc() -> bool

      Is a condition code?



   .. py:method:: is_bit_reg(*args) -> bool

      This function has the following signatures:

          0. is_bit_reg() -> bool
          1. is_bit_reg(reg: mreg_t) -> bool

      # 0: is_bit_reg() -> bool


      # 1: is_bit_reg(reg: mreg_t) -> bool

      Is a bit register? This includes condition codes and eventually other bit registers 
              



   .. py:method:: is_kreg() -> bool

      Is a kernel register?



   .. py:method:: is_mblock(*args) -> bool

      This function has the following signatures:

          0. is_mblock() -> bool
          1. is_mblock(serial: int) -> bool

      # 0: is_mblock() -> bool

      Is a block reference?


      # 1: is_mblock(serial: int) -> bool

      Is a block reference to the specified block?



   .. py:method:: is_scattered() -> bool

      Is a scattered operand?



   .. py:method:: is_glbaddr(*args) -> bool

      This function has the following signatures:

          0. is_glbaddr() -> bool
          1. is_glbaddr(ea: ida_idaapi.ea_t) -> bool

      # 0: is_glbaddr() -> bool

      Is address of a global memory cell?


      # 1: is_glbaddr(ea: ida_idaapi.ea_t) -> bool

      Is address of the specified global memory cell?



   .. py:method:: is_stkaddr() -> bool

      Is address of a stack variable?



   .. py:method:: is_insn(*args) -> bool

      This function has the following signatures:

          0. is_insn() -> bool
          1. is_insn(code: mcode_t) -> bool

      # 0: is_insn() -> bool

      Is a sub-instruction?


      # 1: is_insn(code: mcode_t) -> bool

      Is a sub-instruction with the specified opcode?



   .. py:method:: has_side_effects(include_ldx_and_divs: bool = False) -> bool

      Has any side effects? 
              
      :param include_ldx_and_divs: consider ldx/div/mod as having side effects?



   .. py:method:: may_use_aliased_memory() -> bool

      Is it possible for the operand to use aliased memory?



   .. py:method:: is01() -> bool

      Are the possible values of the operand only 0 and 1? This function returns true for 0/1 constants, bit registers, the result of 'set' insns, etc. 
              



   .. py:method:: is_sign_extended_from(nbytes: int) -> bool

      Does the high part of the operand consist of the sign bytes? 
              
      :param nbytes: number of bytes that were sign extended. the remaining size-nbytes high bytes must be sign bytes Example: is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3 bytes are certainly sign bits



   .. py:method:: is_zero_extended_from(nbytes: int) -> bool

      Does the high part of the operand consist of zero bytes? 
              
      :param nbytes: number of bytes that were zero extended. the remaining size-nbytes high bytes must be zero Example: is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6 bytes are certainly zero



   .. py:method:: is_extended_from(nbytes: int, is_signed: bool) -> bool

      Does the high part of the operand consist of zero or sign bytes?



   .. py:method:: equal_mops(rop: mop_t, eqflags: int) -> bool

      Compare operands. This is the main comparison function for operands. 
              
      :param rop: operand to compare with
      :param eqflags: combination of comparison bits bits



   .. py:method:: lexcompare(rop: mop_t) -> int


   .. py:method:: for_all_ops(mv: mop_visitor_t, type: tinfo_t = None, is_target: bool = False) -> int

      Visit the operand and all its sub-operands. This function visits the current operand as well. 
              
      :param mv: visitor object
      :param type: operand type
      :param is_target: is a destination operand?



   .. py:method:: for_all_scattered_submops(sv: scif_visitor_t) -> int

      Visit all sub-operands of a scattered operand. This function does not visit the current operand, only its sub-operands. All sub-operands are synthetic and are destroyed after the visitor. This function works only with scattered operands. 
              
      :param sv: visitor object



   .. py:method:: value(is_signed: bool) -> uint64

      Retrieve value of a constant integer operand. These functions can be called only for mop_n operands. See is_constant() that can be called on any operand. 
              



   .. py:method:: signed_value() -> int64


   .. py:method:: unsigned_value() -> uint64


   .. py:method:: update_numop_value(val: uint64) -> None


   .. py:method:: is_constant(is_signed: bool = True) -> bool

      Retrieve value of a constant integer operand. 
              
      :param is_signed: should treat the value as signed
      :returns: true if the operand is mop_n



   .. py:method:: is_equal_to(n: uint64, is_signed: bool = True) -> bool


   .. py:method:: is_zero() -> bool


   .. py:method:: is_one() -> bool


   .. py:method:: is_positive_constant() -> bool


   .. py:method:: is_negative_constant() -> bool


   .. py:method:: get_stkvar(udm: udm_t = None, p_idaoff: uval_t * = None) -> ssize_t

      Retrieve the referenced stack variable. 
              
      :param udm: stkvar, may be nullptr
      :param p_idaoff: if specified, will hold IDA stkoff after the call.
      :returns: index of stkvar in the frame or -1



   .. py:method:: get_stkoff(p_vdoff: sval_t *) -> bool

      Get the referenced stack offset. This function can also handle mop_sc if it is entirely mapped into a continuous stack region. 
              
      :param p_vdoff: the output buffer
      :returns: success



   .. py:method:: get_insn(code: mcode_t) -> minsn_t *

      Get subinstruction of the operand. If the operand has a subinstruction with the specified opcode, return it. 
              
      :param code: desired opcode
      :returns: pointer to the instruction or nullptr



   .. py:method:: make_low_half(width: int) -> bool

      Make the low part of the operand. This function takes into account the memory endianness (byte sex) 
              
      :param width: the desired size of the operand part in bytes
      :returns: success



   .. py:method:: make_high_half(width: int) -> bool

      Make the high part of the operand. This function takes into account the memory endianness (byte sex) 
              
      :param width: the desired size of the operand part in bytes
      :returns: success



   .. py:method:: make_first_half(width: int) -> bool

      Make the first part of the operand. This function does not care about the memory endianness 
              
      :param width: the desired size of the operand part in bytes
      :returns: success



   .. py:method:: make_second_half(width: int) -> bool

      Make the second part of the operand. This function does not care about the memory endianness 
              
      :param width: the desired size of the operand part in bytes
      :returns: success



   .. py:method:: shift_mop(offset: int) -> bool

      Shift the operand. This function shifts only the beginning of the operand. The operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1 
              
      :param offset: shift count (the number of bytes to shift)
      :returns: success



   .. py:method:: change_size(nsize: int, sideff: side_effect_t = WITH_SIDEFF) -> bool

      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2 change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1 
              
      :param nsize: new operand size
      :param sideff: may modify the database because of the size change?
      :returns: success



   .. py:method:: double_size(sideff: side_effect_t = WITH_SIDEFF) -> bool


   .. py:method:: preserve_side_effects(blk: mblock_t, top: minsn_t, moved_calls: bool * = None) -> bool

      Move subinstructions with side effects out of the operand. If we decide to delete an instruction operand, it is a good idea to call this function. Alternatively we should skip such operands by calling mop_t::has_side_effects() For example, if we transform: jnz x, x, @blk => goto @blk then we must call this function before deleting the X operands. 
              
      :param blk: current block
      :param top: top level instruction that contains our operand
      :param moved_calls: pointer to the boolean that will track if all side effects get handled correctly. must be false initially.
      :returns: false failed to preserve a side effect, it is not safe to delete the operand true no side effects or successfully preserved them



   .. py:method:: apply_ld_mcode(mcode: mcode_t, ea: ida_idaapi.ea_t, newsize: int) -> None

      Apply a unary opcode to the operand. 
              
      :param mcode: opcode to apply. it must accept 'l' and 'd' operands but not 'r'. examples: m_low/m_high/m_xds/m_xdu
      :param ea: value of minsn_t::ea for the newly created insruction
      :param newsize: new operand size Example: apply_ld_mcode(m_low) will convert op => low(op)



   .. py:method:: apply_xdu(ea: ida_idaapi.ea_t, newsize: int) -> None


   .. py:method:: apply_xds(ea: ida_idaapi.ea_t, newsize: int) -> None


   .. py:attribute:: obj_id


   .. py:method:: replace_by(o)


   .. py:attribute:: meminfo


   .. py:property:: nnn


   .. py:property:: d


   .. py:property:: s


   .. py:property:: f


   .. py:property:: l


   .. py:property:: a


   .. py:property:: c


   .. py:property:: fpc


   .. py:property:: pair


   .. py:property:: scif


   .. py:property:: r


   .. py:property:: g


   .. py:property:: b


   .. py:property:: cstr


   .. py:property:: helper


.. py:data:: OPROP_IMPDONE

   imported operand (a pointer) has been dereferenced


.. py:data:: OPROP_UDT

   a struct or union


.. py:data:: OPROP_FLOAT

   possibly floating value


.. py:data:: OPROP_CCFLAGS

   mop_n: a pc-relative value mop_a: an address obtained from a relocation else: value of a condition code register (like mr_cc) 
           


.. py:data:: OPROP_UDEFVAL

   uses undefined value


.. py:data:: OPROP_LOWADDR

   a low address offset


.. py:data:: OPROP_ABI

   is used to organize arg/retval of a call such operands should be combined more carefully than others at least on BE platforms 
           


.. py:function:: lexcompare(a: mop_t, b: mop_t) -> int

.. py:class:: mop_pair_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: lop
      :type:  mop_t

      low operand



   .. py:attribute:: hop
      :type:  mop_t

      high operand



.. py:class:: mop_addr_t(*args)

   Bases: :py:obj:`mop_t`


   .. py:attribute:: thisown


   .. py:attribute:: insize
      :type:  int


   .. py:attribute:: outsize
      :type:  int


   .. py:method:: lexcompare(ra: mop_addr_t) -> int


.. py:class:: mcallarg_t(*args)

   Bases: :py:obj:`mop_t`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      address where the argument was initialized. BADADDR means unknown. 
              



   .. py:attribute:: type
      :type:  tinfo_t

      formal argument type



   .. py:attribute:: name
      :type:  str

      formal argument name



   .. py:attribute:: argloc
      :type:  argloc_t

      ida argloc



   .. py:attribute:: flags
      :type:  int

      FAI_...



   .. py:method:: copy_mop(op: mop_t) -> None


   .. py:method:: dstr() -> str


   .. py:method:: set_regarg(*args) -> None

      This function has the following signatures:

          0. set_regarg(mr: mreg_t, sz: int, tif: const tinfo_t &) -> None
          1. set_regarg(mr: mreg_t, tif: const tinfo_t &) -> None
          2. set_regarg(mr: mreg_t, dt: char, sign: type_sign_t=type_unsigned) -> None

      # 0: set_regarg(mr: mreg_t, sz: int, tif: const tinfo_t &) -> None


      # 1: set_regarg(mr: mreg_t, tif: const tinfo_t &) -> None


      # 2: set_regarg(mr: mreg_t, dt: char, sign: type_sign_t=type_unsigned) -> None



   .. py:method:: make_int(val: int, val_ea: ida_idaapi.ea_t, opno: int = 0) -> None


   .. py:method:: make_uint(val: int, val_ea: ida_idaapi.ea_t, opno: int = 0) -> None


.. py:data:: ROLE_UNK

   unknown function role


.. py:data:: ROLE_EMPTY

   empty, does not do anything (maybe spoils regs)


.. py:data:: ROLE_MEMSET

   memset(void *dst, uchar value, size_t count);


.. py:data:: ROLE_MEMSET32

   memset32(void *dst, uint32 value, size_t count);


.. py:data:: ROLE_MEMSET64

   memset64(void *dst, uint64 value, size_t count);


.. py:data:: ROLE_MEMCPY

   memcpy(void *dst, const void *src, size_t count);


.. py:data:: ROLE_STRCPY

   strcpy(char *dst, const char *src);


.. py:data:: ROLE_STRLEN

   strlen(const char *src);


.. py:data:: ROLE_STRCAT

   strcat(char *dst, const char *src);


.. py:data:: ROLE_TAIL

   char *tail(const char *str);


.. py:data:: ROLE_BUG

   BUG() helper macro: never returns, causes exception.


.. py:data:: ROLE_ALLOCA

   alloca() function


.. py:data:: ROLE_BSWAP

   bswap() function (any size)


.. py:data:: ROLE_PRESENT

   present() function (used in patterns)


.. py:data:: ROLE_CONTAINING_RECORD

   CONTAINING_RECORD() macro.


.. py:data:: ROLE_FASTFAIL

   __fastfail()


.. py:data:: ROLE_READFLAGS

   __readeflags, __readcallersflags


.. py:data:: ROLE_IS_MUL_OK

   is_mul_ok


.. py:data:: ROLE_SATURATED_MUL

   saturated_mul


.. py:data:: ROLE_BITTEST

   [lock] bt


.. py:data:: ROLE_BITTESTANDSET

   [lock] bts


.. py:data:: ROLE_BITTESTANDRESET

   [lock] btr


.. py:data:: ROLE_BITTESTANDCOMPLEMENT

   [lock] btc


.. py:data:: ROLE_VA_ARG

   va_arg() macro


.. py:data:: ROLE_VA_COPY

   va_copy() function


.. py:data:: ROLE_VA_START

   va_start() function


.. py:data:: ROLE_VA_END

   va_end() function


.. py:data:: ROLE_ROL

   rotate left


.. py:data:: ROLE_ROR

   rotate right


.. py:data:: ROLE_CFSUB3

   carry flag after subtract with carry


.. py:data:: ROLE_OFSUB3

   overflow flag after subtract with carry


.. py:data:: ROLE_ABS

   integer absolute value


.. py:data:: ROLE_3WAYCMP0

   3-way compare helper, returns -1/0/1


.. py:data:: ROLE_3WAYCMP1

   3-way compare helper, returns 0/1/2


.. py:data:: ROLE_WMEMCPY

   wchar_t *wmemcpy(wchar_t *dst, const wchar_t *src, size_t n)


.. py:data:: ROLE_WMEMSET

   wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)


.. py:data:: ROLE_WCSCPY

   wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);


.. py:data:: ROLE_WCSLEN

   size_t wcslen(const wchar_t *s)


.. py:data:: ROLE_WCSCAT

   wchar_t *wcscat(wchar_t *dst, const wchar_t *src)


.. py:data:: ROLE_SSE_CMP4

   e.g. _mm_cmpgt_ss


.. py:data:: ROLE_SSE_CMP8

   e.g. _mm_cmpgt_sd


.. py:data:: FUNC_NAME_MEMCPY

.. py:data:: FUNC_NAME_WMEMCPY

.. py:data:: FUNC_NAME_MEMSET

.. py:data:: FUNC_NAME_WMEMSET

.. py:data:: FUNC_NAME_MEMSET32

.. py:data:: FUNC_NAME_MEMSET64

.. py:data:: FUNC_NAME_STRCPY

.. py:data:: FUNC_NAME_WCSCPY

.. py:data:: FUNC_NAME_STRLEN

.. py:data:: FUNC_NAME_WCSLEN

.. py:data:: FUNC_NAME_STRCAT

.. py:data:: FUNC_NAME_WCSCAT

.. py:data:: FUNC_NAME_TAIL

.. py:data:: FUNC_NAME_VA_ARG

.. py:data:: FUNC_NAME_EMPTY

.. py:data:: FUNC_NAME_PRESENT

.. py:data:: FUNC_NAME_CONTAINING_RECORD

.. py:data:: FUNC_NAME_MORESTACK

.. py:class:: mcallinfo_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: callee
      :type:  ida_idaapi.ea_t

      address of the called function, if known



   .. py:attribute:: solid_args
      :type:  int

      number of solid args. there may be variadic args in addtion 
              



   .. py:attribute:: call_spd
      :type:  int

      sp value at call insn



   .. py:attribute:: stkargs_top
      :type:  int

      first offset past stack arguments



   .. py:attribute:: cc
      :type:  callcnv_t

      calling convention



   .. py:attribute:: args
      :type:  mcallargs_t

      call arguments



   .. py:attribute:: retregs
      :type:  mopvec_t

      return register(s) (e.g., AX, AX:DX, etc.) this vector is built from return_regs 
              



   .. py:attribute:: return_type
      :type:  tinfo_t

      type of the returned value



   .. py:attribute:: return_argloc
      :type:  argloc_t

      location of the returned value



   .. py:attribute:: return_regs
      :type:  mlist_t

      list of values returned by the function



   .. py:attribute:: spoiled
      :type:  mlist_t

      list of spoiled locations (includes return_regs)



   .. py:attribute:: pass_regs
      :type:  mlist_t

      passthrough registers: registers that depend on input values (subset of spoiled) 
              



   .. py:attribute:: visible_memory
      :type:  ivlset_t

      what memory is visible to the call?



   .. py:attribute:: dead_regs
      :type:  mlist_t

      registers defined by the function but never used. upon propagation we do the following:
      * dead_regs += return_regs
      * retregs.clear() since the call is propagated 


              



   .. py:attribute:: flags
      :type:  int

      combination of Call properties... bits 
              



   .. py:attribute:: role
      :type:  funcrole_t

      function role



   .. py:attribute:: fti_attrs
      :type:  type_attrs_t

      extended function attributes



   .. py:method:: lexcompare(f: mcallinfo_t) -> int


   .. py:method:: set_type(type: tinfo_t) -> bool


   .. py:method:: get_type() -> tinfo_t


   .. py:method:: is_vararg() -> bool


   .. py:method:: dstr() -> str


.. py:data:: FCI_PROP

   call has been propagated


.. py:data:: FCI_DEAD

   some return registers were determined dead


.. py:data:: FCI_FINAL

   call type is final, should not be changed


.. py:data:: FCI_NORET

   call does not return


.. py:data:: FCI_PURE

   pure function


.. py:data:: FCI_NOSIDE

   call does not have side effects


.. py:data:: FCI_SPLOK

   spoiled/visible_memory lists have been optimized. for some functions we can reduce them as soon as information about the arguments becomes available. in order not to try optimize them again we use this bit. 
           


.. py:data:: FCI_HASCALL

   A function is an synthetic helper combined from several instructions and at least one of them was a call to a real functions 
           


.. py:data:: FCI_HASFMT

   A variadic function with recognized printf- or scanf-style format string 
           


.. py:data:: FCI_EXPLOCS

   all arglocs are specified explicitly


.. py:class:: mcases_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: values
      :type:  casevec_t

      expression values for each target



   .. py:attribute:: targets
      :type:  intvec_t

      target block numbers



   .. py:method:: swap(r: mcases_t) -> None


   .. py:method:: compare(r: mcases_t) -> int


   .. py:method:: empty() -> bool


   .. py:method:: size() -> size_t


   .. py:method:: resize(s: int) -> None


   .. py:method:: dstr() -> str


.. py:class:: voff_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: off
      :type:  int

      register number or stack offset



   .. py:attribute:: type
      :type:  mopt_t

      mop_r - register, mop_S - stack, mop_z - undefined



   .. py:method:: set(_type: mopt_t, _off: int) -> None


   .. py:method:: set_stkoff(stkoff: int) -> None


   .. py:method:: set_reg(mreg: mreg_t) -> None


   .. py:method:: undef() -> None


   .. py:method:: defined() -> bool


   .. py:method:: is_reg() -> bool


   .. py:method:: is_stkoff() -> bool


   .. py:method:: get_reg() -> mreg_t


   .. py:method:: get_stkoff() -> int


   .. py:method:: inc(delta: int) -> None


   .. py:method:: add(width: int) -> voff_t


   .. py:method:: diff(r: voff_t) -> int


   .. py:method:: compare(r: voff_t) -> int


.. py:class:: vivl_t(*args)

   Bases: :py:obj:`voff_t`


   .. py:attribute:: thisown


   .. py:attribute:: size
      :type:  int

      Interval size in bytes.



   .. py:method:: set(*args) -> None

      This function has the following signatures:

          0. set(_type: mopt_t, _off: int, _size: int=0) -> None
          1. set(voff: const voff_t &, _size: int) -> None

      # 0: set(_type: mopt_t, _off: int, _size: int=0) -> None


      # 1: set(voff: const voff_t &, _size: int) -> None



   .. py:method:: set_stkoff(stkoff: int, sz: int = 0) -> None


   .. py:method:: set_reg(mreg: mreg_t, sz: int = 0) -> None


   .. py:method:: extend_to_cover(r: vivl_t) -> bool

      Extend a value interval using another value interval of the same type 
              
      :returns: success



   .. py:method:: intersect(r: vivl_t) -> int

      Intersect value intervals the same type 
              
      :returns: size of the resulting intersection



   .. py:method:: overlap(r: vivl_t) -> bool

      Do two value intervals overlap?



   .. py:method:: includes(r: vivl_t) -> bool

      Does our value interval include another?



   .. py:method:: contains(voff2: voff_t) -> bool

      Does our value interval contain the specified value offset?



   .. py:method:: compare(r: vivl_t) -> int


   .. py:method:: dstr() -> str


.. py:class:: chain_t(*args)

   Bases: :py:obj:`ida_pro.intvec_t`


   .. py:attribute:: thisown


   .. py:attribute:: width
      :type:  int

      size of the value in bytes



   .. py:attribute:: varnum
      :type:  int

      allocated variable index (-1 - not allocated yet)



   .. py:attribute:: flags
      :type:  uchar

      combination Chain properties bits 
              



   .. py:method:: set_value(r: chain_t) -> None


   .. py:method:: key() -> voff_t const &


   .. py:method:: is_inited() -> bool


   .. py:method:: is_reg() -> bool


   .. py:method:: is_stkoff() -> bool


   .. py:method:: is_replaced() -> bool


   .. py:method:: is_overlapped() -> bool


   .. py:method:: is_fake() -> bool


   .. py:method:: is_passreg() -> bool


   .. py:method:: is_term() -> bool


   .. py:method:: set_inited(b: bool) -> None


   .. py:method:: set_replaced(b: bool) -> None


   .. py:method:: set_overlapped(b: bool) -> None


   .. py:method:: set_term(b: bool) -> None


   .. py:method:: get_reg() -> mreg_t


   .. py:method:: get_stkoff() -> int


   .. py:method:: overlap(r: chain_t) -> bool


   .. py:method:: includes(r: chain_t) -> bool


   .. py:method:: endoff() -> voff_t const


   .. py:method:: dstr() -> str


   .. py:method:: append_list(mba: mba_t, list: mlist_t) -> None

      Append the contents of the chain to the specified list of locations.



   .. py:method:: clear_varnum() -> None


.. py:data:: CHF_INITED

   is chain initialized? (valid only after lvar allocation)


.. py:data:: CHF_REPLACED

   chain operands have been replaced?


.. py:data:: CHF_OVER

   overlapped chain


.. py:data:: CHF_FAKE

   fake chain created by widen_chains()


.. py:data:: CHF_PASSTHRU

   pass-thru chain, must use the input variable to the block


.. py:data:: CHF_TERM

   terminating chain; the variable does not survive across the block


.. py:data:: SIZEOF_BLOCK_CHAINS

.. py:class:: block_chains_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: get_reg_chain(reg: mreg_t, width: int = 1) -> chain_t *

      Get chain for the specified register 
              
      :param reg: register number
      :param width: size of register in bytes



   .. py:method:: get_stk_chain(off: int, width: int = 1) -> chain_t *

      Get chain for the specified stack offset 
              
      :param off: stack offset
      :param width: size of stack value in bytes



   .. py:method:: get_chain(*args) -> chain_t *

      This function has the following signatures:

          0. get_chain(k: const voff_t &, width: int=1) -> const chain_t *
          1. get_chain(k: const voff_t &, width: int=1) -> chain_t *
          2. get_chain(ch: const chain_t &) -> const chain_t *
          3. get_chain(ch: const chain_t &) -> chain_t *

      # 0: get_chain(k: const voff_t &, width: int=1) -> const chain_t *

      Get chain for the specified value offset. 
              

      # 1: get_chain(k: const voff_t &, width: int=1) -> chain_t *


      # 2: get_chain(ch: const chain_t &) -> const chain_t *

      Get chain similar to the specified chain 
              

      # 3: get_chain(ch: const chain_t &) -> chain_t *



   .. py:method:: dstr() -> str


.. py:class:: chain_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: parent
      :type:  block_chains_t *

      parent of the current chain



   .. py:method:: visit_chain(nblock: int, ch: chain_t) -> int


.. py:class:: graph_chains_t

   Bases: :py:obj:`block_chains_vec_t`


   .. py:attribute:: thisown


   .. py:method:: for_all_chains(cv: chain_visitor_t, gca_flags: int) -> int

      Visit all chains 
              
      :param cv: chain visitor
      :param gca_flags: combination of GCA_ bits



   .. py:method:: is_locked() -> bool

      Are the chains locked? It is a good idea to lock the chains before using them. This ensures that they won't be recalculated and reallocated during the use. See the chain_keeper_t class for that. 
              



   .. py:method:: acquire() -> None

      Lock the chains.



   .. py:method:: release() -> None

      Unlock the chains.



   .. py:method:: swap(r: graph_chains_t) -> None


.. py:data:: GCA_EMPTY

   include empty chains


.. py:data:: GCA_SPEC

   include chains for special registers


.. py:data:: GCA_ALLOC

   enumerate only allocated chains


.. py:data:: GCA_NALLOC

   enumerate only non-allocated chains


.. py:data:: GCA_OFIRST

   consider only chains of the first block


.. py:data:: GCA_OLAST

   consider only chains of the last block


.. py:class:: minsn_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: opcode
      :type:  mcode_t

      instruction opcode



   .. py:attribute:: iprops
      :type:  int

      combination of instruction property bits bits



   .. py:attribute:: next
      :type:  minsn_t *

      next insn in doubly linked list. check also nexti()



   .. py:attribute:: prev
      :type:  minsn_t *

      prev insn in doubly linked list. check also previ()



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      instruction address



   .. py:attribute:: l
      :type:  mop_t

      left operand



   .. py:attribute:: r
      :type:  mop_t

      right operand



   .. py:attribute:: d
      :type:  mop_t

      destination operand



   .. py:method:: is_optional() -> bool


   .. py:method:: is_combined() -> bool


   .. py:method:: is_farcall() -> bool


   .. py:method:: is_cleaning_pop() -> bool


   .. py:method:: is_extstx() -> bool


   .. py:method:: is_tailcall() -> bool


   .. py:method:: is_fpinsn() -> bool


   .. py:method:: is_assert() -> bool


   .. py:method:: is_persistent() -> bool


   .. py:method:: is_wild_match() -> bool


   .. py:method:: is_propagatable() -> bool


   .. py:method:: is_ignlowsrc() -> bool


   .. py:method:: is_inverted_jx() -> bool


   .. py:method:: was_noret_icall() -> bool


   .. py:method:: is_multimov() -> bool


   .. py:method:: is_combinable() -> bool


   .. py:method:: was_split() -> bool


   .. py:method:: is_mbarrier() -> bool


   .. py:method:: was_unmerged() -> bool


   .. py:method:: was_unpaired() -> bool


   .. py:method:: set_optional() -> None


   .. py:method:: clr_combined() -> None


   .. py:method:: set_farcall() -> None


   .. py:method:: set_cleaning_pop() -> None


   .. py:method:: set_extstx() -> None


   .. py:method:: set_tailcall() -> None


   .. py:method:: clr_tailcall() -> None


   .. py:method:: set_fpinsn() -> None


   .. py:method:: clr_fpinsn() -> None


   .. py:method:: set_assert() -> None


   .. py:method:: clr_assert() -> None


   .. py:method:: set_persistent() -> None


   .. py:method:: set_wild_match() -> None


   .. py:method:: clr_propagatable() -> None


   .. py:method:: set_ignlowsrc() -> None


   .. py:method:: clr_ignlowsrc() -> None


   .. py:method:: set_inverted_jx() -> None


   .. py:method:: set_noret_icall() -> None


   .. py:method:: clr_noret_icall() -> None


   .. py:method:: set_multimov() -> None


   .. py:method:: clr_multimov() -> None


   .. py:method:: set_combinable() -> None


   .. py:method:: clr_combinable() -> None


   .. py:method:: set_mbarrier() -> None


   .. py:method:: set_unmerged() -> None


   .. py:method:: set_split_size(s: int) -> None


   .. py:method:: get_split_size() -> int


   .. py:method:: swap(m: minsn_t) -> None

      Swap two instructions. The prev/next fields are not modified by this function because it would corrupt the doubly linked list. 
              



   .. py:method:: dstr() -> str

      Get displayable text without tags in a static buffer.



   .. py:method:: setaddr(new_ea: ida_idaapi.ea_t) -> None

      Change the instruction address. This function modifies subinstructions as well. 
              



   .. py:method:: optimize_solo(optflags: int = 0) -> int

      Optimize one instruction without context. This function does not have access to the instruction context (the previous and next instructions in the list, the block number, etc). It performs only basic optimizations that are available without this info. 
              
      :param optflags: combination of optimization flags bits
      :returns: number of changes, 0-unchanged See also mblock_t::optimize_insn()



   .. py:method:: optimize_subtree(blk: mblock_t, top: minsn_t, parent: minsn_t, converted_call: ea_t *, optflags: int = 2) -> int

      Optimize instruction in its context. Do not use this function, use mblock_t::optimize() 
              



   .. py:method:: for_all_ops(mv: mop_visitor_t) -> int

      Visit all instruction operands. This function visits subinstruction operands as well. 
              
      :param mv: operand visitor
      :returns: non-zero value returned by mv.visit_mop() or zero



   .. py:method:: for_all_insns(mv: minsn_visitor_t) -> int

      Visit all instructions. This function visits the instruction itself and all its subinstructions. 
              
      :param mv: instruction visitor
      :returns: non-zero value returned by mv.visit_mop() or zero



   .. py:method:: equal_insns(m: minsn_t, eqflags: int) -> bool

      Compare instructions. This is the main comparison function for instructions. 
              
      :param m: instruction to compare with
      :param eqflags: combination of comparison bits bits



   .. py:method:: lexcompare(ri: minsn_t) -> int


   .. py:method:: is_noret_call(flags: int = 0) -> bool

      Is a non-returing call? 
              
      :param flags: combination of NORET_... bits



   .. py:method:: is_unknown_call() -> bool

      Is an unknown call? Unknown calls are calls without the argument list (mcallinfo_t). Usually the argument lists are determined by mba_t::analyze_calls(). Unknown calls exist until the MMAT_CALLS maturity level. See also mblock_t::is_call_block 
              



   .. py:method:: is_helper(name: str) -> bool

      Is a helper call with the specified name? Helper calls usually have well-known function names (see Well known function names) but they may have any other name. The decompiler does not assume any special meaning for non-well-known names. 
              



   .. py:method:: find_call(with_helpers: bool = False) -> minsn_t *

      Find a call instruction. Check for the current instruction and its subinstructions. 
              
      :param with_helpers: consider helper calls as well?



   .. py:method:: contains_call(with_helpers: bool = False) -> bool

      Does the instruction contain a call?



   .. py:method:: has_side_effects(include_ldx_and_divs: bool = False) -> bool

      Does the instruction have a side effect? 
              
      :param include_ldx_and_divs: consider ldx/div/mod as having side effects? stx is always considered as having side effects. Apart from ldx/std only call may have side effects.



   .. py:method:: get_role() -> funcrole_t

      Get the function role of a call.



   .. py:method:: is_memcpy() -> bool


   .. py:method:: is_memset() -> bool


   .. py:method:: is_alloca() -> bool


   .. py:method:: is_bswap() -> bool


   .. py:method:: is_readflags() -> bool


   .. py:method:: contains_opcode(mcode: mcode_t) -> bool

      Does the instruction have the specified opcode? This function searches subinstructions as well. 
              
      :param mcode: opcode to search for.



   .. py:method:: find_opcode(mcode: mcode_t) -> minsn_t *

      Find a (sub)insruction with the specified opcode. 
              
      :param mcode: opcode to search for.



   .. py:method:: find_ins_op(op: mcode_t = m_nop) -> minsn_t *

      Find an operand that is a subinsruction with the specified opcode. This function checks only the 'l' and 'r' operands of the current insn. 
              
      :param op: opcode to search for
      :returns: &l or &r or nullptr



   .. py:method:: find_num_op() -> mop_t *

      Find a numeric operand of the current instruction. This function checks only the 'l' and 'r' operands of the current insn. 
              
      :returns: &l or &r or nullptr



   .. py:method:: is_mov() -> bool


   .. py:method:: is_like_move() -> bool


   .. py:method:: modifies_d() -> bool

      Does the instruction modify its 'd' operand? Some instructions (e.g. m_stx) do not modify the 'd' operand. 
              



   .. py:method:: modifies_pair_mop() -> bool


   .. py:method:: is_between(m1: minsn_t, m2: minsn_t) -> bool

      Is the instruction in the specified range of instructions? 
              
      :param m1: beginning of the range in the doubly linked list
      :param m2: end of the range in the doubly linked list (excluded, may be nullptr) This function assumes that m1 and m2 belong to the same basic block and they are top level instructions.



   .. py:method:: is_after(m: minsn_t) -> bool

      Is the instruction after the specified one? 
              
      :param m: the instruction to compare against in the list



   .. py:method:: may_use_aliased_memory() -> bool

      Is it possible for the instruction to use aliased memory?



   .. py:method:: serialize(b: bytevec_t *) -> int

      Serialize an instruction 
              
      :param b: the output buffer
      :returns: the serialization format that was used to store info



   .. py:method:: deserialize(bytes: uchar const *, format_version: int) -> bool

      Deserialize an instruction 
              
      :param bytes: pointer to serialized data
      :param format_version: serialization format version. this value is returned by minsn_t::serialize()
      :returns: success



   .. py:attribute:: obj_id


   .. py:method:: replace_by(o)


   .. py:attribute:: meminfo


.. py:data:: IPROP_OPTIONAL

   optional instruction


.. py:data:: IPROP_PERSIST

   persistent insn; they are not destroyed


.. py:data:: IPROP_WILDMATCH

   match multiple insns


.. py:data:: IPROP_CLNPOP

   the purpose of the instruction is to clean stack (e.g. "pop ecx" is often used for that) 
           


.. py:data:: IPROP_FPINSN

   floating point insn


.. py:data:: IPROP_FARCALL

   call of a far function using push cs/call sequence


.. py:data:: IPROP_TAILCALL

   tail call


.. py:data:: IPROP_ASSERT

   assertion: usually mov #val, op. assertions are used to help the optimizer. assertions are ignored when generating ctree 
           


.. py:data:: IPROP_SPLIT

   the instruction has been split:


.. py:data:: IPROP_SPLIT1

   into 1 byte


.. py:data:: IPROP_SPLIT2

   into 2 bytes


.. py:data:: IPROP_SPLIT4

   into 4 bytes


.. py:data:: IPROP_SPLIT8

   into 8 bytes


.. py:data:: IPROP_COMBINED

   insn has been modified because of a partial reference


.. py:data:: IPROP_EXTSTX

   this is m_ext propagated into m_stx


.. py:data:: IPROP_IGNLOWSRC

   low part of the instruction source operand has been created artificially (this bit is used only for 'and x, 80...') 
           


.. py:data:: IPROP_INV_JX

   inverted conditional jump


.. py:data:: IPROP_WAS_NORET

   was noret icall


.. py:data:: IPROP_MULTI_MOV

   bits that can be set by plugins:

   the minsn was generated as part of insn that moves multiple registers (example: STM on ARM may transfer multiple registers) 
           


.. py:data:: IPROP_DONT_PROP

   may not propagate


.. py:data:: IPROP_DONT_COMB

   may not combine this instruction with others


.. py:data:: IPROP_MBARRIER

   this instruction acts as a memory barrier (instructions accessing memory may not be reordered past it) 
           


.. py:data:: IPROP_UNMERGED

   'goto' instruction was transformed info 'call'


.. py:data:: IPROP_UNPAIRED

   instruction is a result of del_dest_pairs() transformation


.. py:data:: OPTI_ADDREXPRS

   optimize all address expressions (&x+N; &x-&y)


.. py:data:: OPTI_MINSTKREF

   may update minstkref


.. py:data:: OPTI_COMBINSNS

   may combine insns (only for optimize_insn)


.. py:data:: OPTI_NO_LDXOPT

   the function is called after the propagation attempt, we do not optimize low/high(ldx) in this case 
           


.. py:data:: OPTI_NO_VALRNG

   forbid using valranges


.. py:data:: EQ_IGNSIZE

   ignore source operand sizes


.. py:data:: EQ_IGNCODE

   ignore instruction opcodes


.. py:data:: EQ_CMPDEST

   compare instruction destinations


.. py:data:: EQ_OPTINSN

   optimize mop_d operands


.. py:data:: NORET_IGNORE_WAS_NORET_ICALL

.. py:data:: NORET_FORBID_ANALYSIS

.. py:function:: getf_reginsn(ins: minsn_t) -> minsn_t *

   Skip assertions forward.


.. py:function:: getb_reginsn(ins: minsn_t) -> minsn_t *

   Skip assertions backward.


.. py:class:: intval64_t(v: uint64 = 0, _s: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: val
      :type:  uint64


   .. py:attribute:: size
      :type:  int


   .. py:method:: sval() -> int64


   .. py:method:: uval() -> uint64


   .. py:method:: sext(target_sz: int) -> intval64_t


   .. py:method:: zext(target_sz: int) -> intval64_t


   .. py:method:: low(target_sz: int) -> intval64_t


   .. py:method:: high(target_sz: int) -> intval64_t


   .. py:method:: sdiv(o: intval64_t) -> intval64_t


   .. py:method:: smod(o: intval64_t) -> intval64_t


   .. py:method:: sar(o: intval64_t) -> intval64_t


.. py:class:: int64_emulator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: get_mop_value(mop: mop_t) -> intval64_t


   .. py:method:: mop_value(mop: mop_t) -> intval64_t


   .. py:method:: minsn_value(insn: minsn_t) -> intval64_t


.. py:data:: BLT_NONE

   unknown block type


.. py:data:: BLT_STOP

   stops execution regularly (must be the last block)


.. py:data:: BLT_0WAY

   does not have successors (tail is a noret function)


.. py:data:: BLT_1WAY

   passes execution to one block (regular or goto block)


.. py:data:: BLT_2WAY

   passes execution to two blocks (conditional jump)


.. py:data:: BLT_NWAY

   passes execution to many blocks (switch idiom)


.. py:data:: BLT_XTRN

   external block (out of function address)


.. py:class:: mblock_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: nextb
      :type:  mblock_t *

      next block in the doubly linked list



   .. py:attribute:: prevb
      :type:  mblock_t *

      previous block in the doubly linked list



   .. py:attribute:: flags
      :type:  int

      combination of Basic block properties bits 
              



   .. py:attribute:: start
      :type:  ida_idaapi.ea_t

      start address



   .. py:attribute:: end
      :type:  ida_idaapi.ea_t

      end address note: we cannot rely on start/end addresses very much because instructions are propagated between blocks 
              



   .. py:attribute:: head
      :type:  minsn_t *

      pointer to the first instruction of the block



   .. py:attribute:: tail
      :type:  minsn_t *

      pointer to the last instruction of the block



   .. py:attribute:: mba
      :type:  mba_t *

      the parent micro block array



   .. py:attribute:: serial
      :type:  int

      block number



   .. py:attribute:: type
      :type:  mblock_type_t

      block type (BLT_NONE - not computed yet)



   .. py:attribute:: dead_at_start
      :type:  mlist_t

      data that is dead at the block entry



   .. py:attribute:: mustbuse
      :type:  mlist_t

      data that must be used by the block



   .. py:attribute:: maybuse
      :type:  mlist_t

      data that may be used by the block



   .. py:attribute:: mustbdef
      :type:  mlist_t

      data that must be defined by the block



   .. py:attribute:: maybdef
      :type:  mlist_t

      data that may be defined by the block



   .. py:attribute:: dnu
      :type:  mlist_t

      data that is defined but not used in the block



   .. py:attribute:: maxbsp
      :type:  int

      maximal sp value in the block (0...stacksize)



   .. py:attribute:: minbstkref
      :type:  int

      lowest stack location accessible with indirect addressing (offset from the stack bottom) initially it is 0 (not computed) 
              



   .. py:attribute:: minbargref
      :type:  int

      the same for arguments



   .. py:attribute:: predset
      :type:  intvec_t

      control flow graph: list of our predecessors use npred() and pred() to access it 
              



   .. py:attribute:: succset
      :type:  intvec_t

      control flow graph: list of our successors use nsucc() and succ() to access it 
              



   .. py:method:: mark_lists_dirty() -> None


   .. py:method:: request_propagation() -> None


   .. py:method:: needs_propagation() -> bool


   .. py:method:: request_demote64() -> None


   .. py:method:: lists_dirty() -> bool


   .. py:method:: lists_ready() -> bool


   .. py:method:: make_lists_ready() -> int


   .. py:method:: npred() -> int

      Get number of block predecessors.



   .. py:method:: nsucc() -> int

      Get number of block successors.



   .. py:method:: pred(n: int) -> int


   .. py:method:: succ(n: int) -> int


   .. py:method:: empty() -> bool


   .. py:method:: dump() -> None

      Dump block info. This function is useful for debugging, see mba_t::dump for info 
              



   .. py:method:: dump_block(title: str) -> None


   .. py:method:: insert_into_block(nm: minsn_t, om: minsn_t) -> minsn_t *

      Insert instruction into the doubly linked list 
              
      :param nm: new instruction
      :param om: existing instruction, part of the doubly linked list if nullptr, then the instruction will be inserted at the beginning of the list NM will be inserted immediately after OM
      :returns: pointer to NM



   .. py:method:: remove_from_block(m: minsn_t) -> minsn_t *

      Remove instruction from the doubly linked list 
              
      :param m: instruction to remove The removed instruction is not deleted, the caller gets its ownership
      :returns: pointer to the next instruction



   .. py:method:: for_all_insns(mv: minsn_visitor_t) -> int

      Visit all instructions. This function visits subinstructions too. 
              
      :param mv: instruction visitor
      :returns: zero or the value returned by mv.visit_insn() See also mba_t::for_all_topinsns()



   .. py:method:: for_all_ops(mv: mop_visitor_t) -> int

      Visit all operands. This function visit subinstruction operands too. 
              
      :param mv: operand visitor
      :returns: zero or the value returned by mv.visit_mop()



   .. py:method:: for_all_uses(list: mlist_t, i1: minsn_t, i2: minsn_t, mmv: mlist_mop_visitor_t) -> int

      Visit all operands that use LIST. 
              
      :param list: ptr to the list of locations. it may be modified: parts that get redefined by the instructions in [i1,i2) will be deleted.
      :param i1: starting instruction. must be a top level insn.
      :param i2: ending instruction (excluded). must be a top level insn.
      :param mmv: operand visitor
      :returns: zero or the value returned by mmv.visit_mop()



   .. py:method:: optimize_insn(*args) -> int

      Optimize one instruction in the context of the block. 
              
      :param m: pointer to a top level instruction
      :param optflags: combination of optimization flags bits
      :returns: number of changes made to the block This function may change other instructions in the block too. However, it will not destroy top level instructions (it may convert them to nop's). This function performs only intrablock modifications. See also minsn_t::optimize_solo()



   .. py:method:: optimize_block() -> int

      Optimize a basic block. Usually there is no need to call this function explicitly because the decompiler will call it itself if optinsn_t::func or optblock_t::func return non-zero. 
              
      :returns: number of changes made to the block



   .. py:method:: build_lists(kill_deads: bool) -> int

      Build def-use lists and eliminate deads. 
              
      :param kill_deads: do delete dead instructions?
      :returns: the number of eliminated instructions Better mblock_t::call make_lists_ready() rather than this function.



   .. py:method:: optimize_useless_jump() -> int

      Remove a jump at the end of the block if it is useless. This function preserves any side effects when removing a useless jump. Both conditional and unconditional jumps are handled (and jtbl too). This function deletes useless jumps, not only replaces them with a nop. (please note that \optimize_insn does not handle useless jumps). 
              
      :returns: number of changes made to the block



   .. py:method:: append_use_list(*args) -> None

      Append use-list of an operand. This function calculates list of locations that may or must be used by the operand and appends it to LIST. 
              
      :param list: ptr to the output buffer. we will append to it.
      :param op: operand to calculate the use list of
      :param maymust: should we calculate 'may-use' or 'must-use' list? see maymust_t for more details.
      :param mask: if only part of the operand should be considered, a bitmask can be used to specify which part. example: op=AX,mask=0xFF means that we will consider only AL.



   .. py:method:: append_def_list(list: mlist_t, op: mop_t, maymust: maymust_t) -> None

      Append def-list of an operand. This function calculates list of locations that may or must be modified by the operand and appends it to LIST. 
              
      :param list: ptr to the output buffer. we will append to it.
      :param op: operand to calculate the def list of
      :param maymust: should we calculate 'may-def' or 'must-def' list? see maymust_t for more details.



   .. py:method:: build_use_list(ins: minsn_t, maymust: maymust_t) -> mlist_t

      Build use-list of an instruction. This function calculates list of locations that may or must be used by the instruction. Examples: "ldx ds.2, eax.4, ebx.4", may-list: all aliasable memory "ldx ds.2, eax.4, ebx.4", must-list: empty Since LDX uses EAX for indirect access, it may access any aliasable memory. On the other hand, we cannot tell for sure which memory cells will be accessed, this is why the must-list is empty. 
              
      :param ins: instruction to calculate the use list of
      :param maymust: should we calculate 'may-use' or 'must-use' list? see maymust_t for more details.
      :returns: the calculated use-list



   .. py:method:: build_def_list(ins: minsn_t, maymust: maymust_t) -> mlist_t

      Build def-list of an instruction. This function calculates list of locations that may or must be modified by the instruction. Examples: "stx ebx.4, ds.2, eax.4", may-list: all aliasable memory "stx ebx.4, ds.2, eax.4", must-list: empty Since STX uses EAX for indirect access, it may modify any aliasable memory. On the other hand, we cannot tell for sure which memory cells will be modified, this is why the must-list is empty. 
              
      :param ins: instruction to calculate the def list of
      :param maymust: should we calculate 'may-def' or 'must-def' list? see maymust_t for more details.
      :returns: the calculated def-list



   .. py:method:: is_used(*args) -> bool

      Is the list used by the specified instruction range? 
              
      :param list: list of locations. LIST may be modified by the function: redefined locations will be removed from it.
      :param i1: starting instruction of the range (must be a top level insn)
      :param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
      :param maymust: should we search in 'may-access' or 'must-access' mode?



   .. py:method:: find_first_use(*args) -> minsn_t *

      This function has the following signatures:

          0. find_first_use(list: mlist_t *, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
          1. find_first_use(list: mlist_t *, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *

      # 0: find_first_use(list: mlist_t *, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *

      Find the first insn that uses the specified list in the insn range. 
              
      :returns: pointer to such instruction or nullptr. Upon return LIST will contain only locations not redefined by insns [i1..result]

      # 1: find_first_use(list: mlist_t *, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *



   .. py:method:: is_redefined(*args) -> bool

      Is the list redefined by the specified instructions? 
              
      :param list: list of locations to check.
      :param i1: starting instruction of the range (must be a top level insn)
      :param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
      :param maymust: should we search in 'may-access' or 'must-access' mode?



   .. py:method:: find_redefinition(*args) -> minsn_t *

      This function has the following signatures:

          0. find_redefinition(list: const mlist_t &, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
          1. find_redefinition(list: const mlist_t &, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *

      # 0: find_redefinition(list: const mlist_t &, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *

      Find the first insn that redefines any part of the list in the insn range. 
              
      :returns: pointer to such instruction or nullptr.

      # 1: find_redefinition(list: const mlist_t &, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *



   .. py:method:: is_rhs_redefined(ins: minsn_t, i1: minsn_t, i2: minsn_t) -> bool

      Is the right hand side of the instruction redefined the insn range? "right hand side" corresponds to the source operands of the instruction. 
              
      :param ins: instruction to consider
      :param i1: starting instruction of the range (must be a top level insn)
      :param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.



   .. py:method:: find_access(op: mop_t, parent: minsn_t **, mend: minsn_t, fdflags: int) -> minsn_t *

      Find the instruction that accesses the specified operand. This function search inside one block. 
              
      :param op: operand to search for
      :param parent: ptr to ptr to a top level instruction. in: denotes the beginning of the search range. out: denotes the parent of the found instruction.
      :param mend: end instruction of the range (must be a top level insn) mend is excluded from the range. it can be specified as nullptr. parent and mend must belong to the same block.
      :param fdflags: combination of bits for mblock_t::find_access bits
      :returns: the instruction that accesses the operand. this instruction may be a sub-instruction. to find out the top level instruction, check out *parent. nullptr means 'not found'.



   .. py:method:: find_def(op: mop_t, p_i1: minsn_t **, i2: minsn_t, fdflags: int) -> minsn_t *


   .. py:method:: find_use(op: mop_t, p_i1: minsn_t **, i2: minsn_t, fdflags: int) -> minsn_t *


   .. py:method:: get_valranges(*args) -> bool

      This function has the following signatures:

          0. get_valranges(res: valrng_t *, vivl: const vivl_t &, vrflags: int) -> bool
          1. get_valranges(res: valrng_t *, vivl: const vivl_t &, m: const minsn_t *, vrflags: int) -> bool

      # 0: get_valranges(res: valrng_t *, vivl: const vivl_t &, vrflags: int) -> bool

      Find possible values for a block. 
              

      # 1: get_valranges(res: valrng_t *, vivl: const vivl_t &, m: const minsn_t *, vrflags: int) -> bool

      Find possible values for an instruction. 
              



   .. py:method:: make_nop(m: minsn_t) -> None

      Erase the instruction (convert it to nop) and mark the lists dirty. This is the recommended function to use because it also marks the block use-def lists dirty. 
              



   .. py:method:: get_reginsn_qty() -> size_t

      Calculate number of regular instructions in the block. Assertions are skipped by this function. 
              
      :returns: Number of non-assertion instructions in the block.



   .. py:method:: is_call_block() -> bool


   .. py:method:: is_unknown_call() -> bool


   .. py:method:: is_nway() -> bool


   .. py:method:: is_branch() -> bool


   .. py:method:: is_simple_goto_block() -> bool


   .. py:method:: is_simple_jcnd_block() -> bool


   .. py:method:: preds()

      Iterates the list of predecessor blocks



   .. py:method:: succs()

      Iterates the list of successor blocks



.. py:data:: MBL_PRIV

   private block - no instructions except the specified are accepted (used in patterns) 
           


.. py:data:: MBL_NONFAKE

   regular block


.. py:data:: MBL_FAKE

   fake block


.. py:data:: MBL_GOTO

   this block is a goto target


.. py:data:: MBL_TCAL

   aritifical call block for tail calls


.. py:data:: MBL_PUSH

   needs "convert push/pop instructions"


.. py:data:: MBL_DMT64

   needs "demote 64bits"


.. py:data:: MBL_COMB

   needs "combine" pass


.. py:data:: MBL_PROP

   needs 'propagation' pass


.. py:data:: MBL_DEAD

   needs "eliminate deads" pass


.. py:data:: MBL_LIST

   use/def lists are ready (not dirty)


.. py:data:: MBL_INCONST

   inconsistent lists: we are building them


.. py:data:: MBL_CALL

   call information has been built


.. py:data:: MBL_BACKPROP

   performed backprop_cc


.. py:data:: MBL_NORET

   dead end block: doesn't return execution control


.. py:data:: MBL_DSLOT

   block for delay slot


.. py:data:: MBL_VALRANGES

   should optimize using value ranges


.. py:data:: MBL_KEEP

   do not remove even if unreachable


.. py:data:: MBL_INLINED

   block was inlined, not originally part of mbr


.. py:data:: MBL_EXTFRAME

   an inlined block with an external frame


.. py:data:: FD_BACKWARD

   search direction


.. py:data:: FD_FORWARD

   search direction


.. py:data:: FD_USE

   look for use


.. py:data:: FD_DEF

   look for definition


.. py:data:: FD_DIRTY

   ignore possible implicit definitions by function calls and indirect memory access 
           


.. py:data:: VR_AT_START

   get value ranges before the instruction or at the block start (if M is nullptr) 
           


.. py:data:: VR_AT_END

   get value ranges after the instruction or at the block end, just after the last instruction (if M is nullptr) 
           


.. py:data:: VR_EXACT

   find exact match. if not set, the returned valrng size will be >= vivl.size 
           


.. py:data:: WARN_VARARG_REGS

   0 cannot handle register arguments in vararg function, discarded them


.. py:data:: WARN_ILL_PURGED

   1 odd caller purged bytes d, correcting


.. py:data:: WARN_ILL_FUNCTYPE

   2 invalid function type 's' has been ignored


.. py:data:: WARN_VARARG_TCAL

   3 cannot handle tail call to vararg


.. py:data:: WARN_VARARG_NOSTK

   4 call vararg without local stack


.. py:data:: WARN_VARARG_MANY

   5 too many varargs, some ignored


.. py:data:: WARN_ADDR_OUTARGS

   6 cannot handle address arithmetics in outgoing argument area of stack frame - unused


.. py:data:: WARN_DEP_UNK_CALLS

   7 found interdependent unknown calls


.. py:data:: WARN_ILL_ELLIPSIS

   8 erroneously detected ellipsis type has been ignored


.. py:data:: WARN_GUESSED_TYPE

   9 using guessed type s;


.. py:data:: WARN_EXP_LINVAR

   10 failed to expand a linear variable


.. py:data:: WARN_WIDEN_CHAINS

   11 failed to widen chains


.. py:data:: WARN_BAD_PURGED

   12 inconsistent function type and number of purged bytes


.. py:data:: WARN_CBUILD_LOOPS

   13 too many cbuild loops


.. py:data:: WARN_NO_SAVE_REST

   14 could not find valid save-restore pair for s


.. py:data:: WARN_ODD_INPUT_REG

   15 odd input register s


.. py:data:: WARN_ODD_ADDR_USE

   16 odd use of a variable address


.. py:data:: WARN_MUST_RET_FP

   17 function return type is incorrect (must be floating point)


.. py:data:: WARN_ILL_FPU_STACK

   18 inconsistent fpu stack


.. py:data:: WARN_SELFREF_PROP

   19 self-referencing variable has been detected


.. py:data:: WARN_WOULD_OVERLAP

   20 variables would overlap: s


.. py:data:: WARN_ARRAY_INARG

   21 array has been used for an input argument


.. py:data:: WARN_MAX_ARGS

   22 too many input arguments, some ignored


.. py:data:: WARN_BAD_FIELD_TYPE

   23 incorrect structure member type for s::s, ignored


.. py:data:: WARN_WRITE_CONST

   24 write access to const memory at a has been detected


.. py:data:: WARN_BAD_RETVAR

   25 wrong return variable


.. py:data:: WARN_FRAG_LVAR

   26 fragmented variable at s may be wrong


.. py:data:: WARN_HUGE_STKOFF

   27 exceedingly huge offset into the stack frame


.. py:data:: WARN_UNINITED_REG

   28 reference to an uninitialized register has been removed: s


.. py:data:: WARN_FIXED_INSN

   29 fixed broken insn


.. py:data:: WARN_WRONG_VA_OFF

   30 wrong offset of va_list variable


.. py:data:: WARN_CR_NOFIELD

   31 CONTAINING_RECORD: no field 's' in struct 's' at d


.. py:data:: WARN_CR_BADOFF

   32 CONTAINING_RECORD: too small offset d for struct 's'


.. py:data:: WARN_BAD_STROFF

   33 user specified stroff has not been processed: s


.. py:data:: WARN_BAD_VARSIZE

   34 inconsistent variable size for 's'


.. py:data:: WARN_UNSUPP_REG

   35 unsupported processor register 's'


.. py:data:: WARN_UNALIGNED_ARG

   36 unaligned function argument 's'


.. py:data:: WARN_BAD_STD_TYPE

   37 corrupted or unexisting local type 's'


.. py:data:: WARN_BAD_CALL_SP

   38 bad sp value at call


.. py:data:: WARN_MISSED_SWITCH

   39 wrong markup of switch jump, skipped it


.. py:data:: WARN_BAD_SP

   40 positive sp value a has been found


.. py:data:: WARN_BAD_STKPNT

   41 wrong sp change point


.. py:data:: WARN_UNDEF_LVAR

   42 variable 's' is possibly undefined


.. py:data:: WARN_JUMPOUT

   43 control flows out of bounds


.. py:data:: WARN_BAD_VALRNG

   44 values range analysis failed


.. py:data:: WARN_BAD_SHADOW

   45 ignored the value written to the shadow area of the succeeding call


.. py:data:: WARN_OPT_VALRNG

   46 conditional instruction was optimized away because s


.. py:data:: WARN_RET_LOCREF

   47 returning address of temporary local variable 's'


.. py:data:: WARN_BAD_MAPDST

   48 too short map destination 's' for variable 's'


.. py:data:: WARN_BAD_INSN

   49 bad instruction


.. py:data:: WARN_ODD_ABI

   50 encountered odd instruction for the current ABI


.. py:data:: WARN_UNBALANCED_STACK

   51 unbalanced stack, ignored a potential tail call


.. py:data:: WARN_OPT_VALRNG2

   52 mask 0xX is shortened because s <= 0xX"


.. py:data:: WARN_OPT_VALRNG3

   53 masking with 0XX was optimized away because s <= 0xX


.. py:data:: WARN_OPT_USELESS_JCND

   54 simplified comparisons for 's': s became s


.. py:data:: WARN_SUBFRAME_OVERFLOW

   55 call arguments overflow the function chunk frame


.. py:data:: WARN_OPT_VALRNG4

   56 the cases s were optimized away because s


.. py:data:: WARN_MAX

   may be used in notes as a placeholder when the warning id is not available 
             


.. py:class:: hexwarn_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      Address where the warning occurred.



   .. py:attribute:: id
      :type:  warnid_t

      Warning id.



   .. py:attribute:: text
      :type:  str

      Fully formatted text of the warning.



   .. py:method:: compare(r: hexwarn_t) -> int


.. py:data:: MMAT_ZERO

   microcode does not exist


.. py:data:: MMAT_GENERATED

   generated microcode


.. py:data:: MMAT_PREOPTIMIZED

   preoptimized pass is complete


.. py:data:: MMAT_LOCOPT

   local optimization of each basic block is complete. control flow graph is ready too. 
             


.. py:data:: MMAT_CALLS

   detected call arguments. see also hxe_calls_done


.. py:data:: MMAT_GLBOPT1

   performed the first pass of global optimization


.. py:data:: MMAT_GLBOPT2

   most global optimization passes are done


.. py:data:: MMAT_GLBOPT3

   completed all global optimization. microcode is fixed now.


.. py:data:: MMAT_LVARS

   allocated local variables


.. py:data:: MMIDX_GLBLOW

   global memory: low part


.. py:data:: MMIDX_LVARS

   stack: local variables


.. py:data:: MMIDX_RETADDR

   stack: return address


.. py:data:: MMIDX_SHADOW

   stack: shadow arguments


.. py:data:: MMIDX_ARGS

   stack: regular stack arguments


.. py:data:: MMIDX_GLBHIGH

   global memory: high part


.. py:class:: mba_ranges_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: pfn
      :type:  func_t *

      function to decompile. if not null, then function mode.



   .. py:attribute:: ranges
      :type:  rangevec_t

      snippet mode: ranges to decompile. function mode: list of outlined ranges 
              



   .. py:method:: start() -> ida_idaapi.ea_t


   .. py:method:: empty() -> bool


   .. py:method:: clear() -> None


   .. py:method:: is_snippet() -> bool


   .. py:method:: is_fragmented() -> bool


.. py:class:: mba_range_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: rii
      :type:  range_chunk_iterator_t


   .. py:attribute:: fii
      :type:  func_tail_iterator_t


   .. py:method:: is_snippet() -> bool


   .. py:method:: set(mbr: mba_ranges_t) -> bool


   .. py:method:: next() -> bool


   .. py:method:: chunk() -> range_t const &


.. py:class:: mba_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: precise_defeas() -> bool


   .. py:method:: optimized() -> bool


   .. py:method:: short_display() -> bool


   .. py:method:: show_reduction() -> bool


   .. py:method:: graph_insns() -> bool


   .. py:method:: loaded_gdl() -> bool


   .. py:method:: should_beautify() -> bool


   .. py:method:: rtype_refined() -> bool


   .. py:method:: may_refine_rettype() -> bool


   .. py:method:: use_wingraph32() -> bool


   .. py:method:: display_numaddrs() -> bool


   .. py:method:: display_valnums() -> bool


   .. py:method:: is_pattern() -> bool


   .. py:method:: is_thunk() -> bool


   .. py:method:: saverest_done() -> bool


   .. py:method:: callinfo_built() -> bool


   .. py:method:: really_alloc() -> bool


   .. py:method:: lvars_allocated() -> bool


   .. py:method:: chain_varnums_ok() -> bool


   .. py:method:: returns_fpval() -> bool


   .. py:method:: has_passregs() -> bool


   .. py:method:: generated_asserts() -> bool


   .. py:method:: propagated_asserts() -> bool


   .. py:method:: deleted_pairs() -> bool


   .. py:method:: common_stkvars_stkargs() -> bool


   .. py:method:: lvar_names_ok() -> bool


   .. py:method:: lvars_renamed() -> bool


   .. py:method:: has_over_chains() -> bool


   .. py:method:: valranges_done() -> bool


   .. py:method:: argidx_ok() -> bool


   .. py:method:: argidx_sorted() -> bool


   .. py:method:: code16_bit_removed() -> bool


   .. py:method:: has_stack_retval() -> bool


   .. py:method:: has_outlines() -> bool


   .. py:method:: is_ctr() -> bool


   .. py:method:: is_dtr() -> bool


   .. py:method:: is_cdtr() -> bool


   .. py:method:: prop_complex() -> bool


   .. py:method:: get_mba_flags() -> int


   .. py:method:: get_mba_flags2() -> int


   .. py:method:: set_mba_flags(f: int) -> None


   .. py:method:: clr_mba_flags(f: int) -> None


   .. py:method:: set_mba_flags2(f: int) -> None


   .. py:method:: clr_mba_flags2(f: int) -> None


   .. py:method:: clr_cdtr() -> None


   .. py:method:: calc_shins_flags() -> int


   .. py:method:: stkoff_vd2ida(off: int) -> int


   .. py:method:: stkoff_ida2vd(off: int) -> int


   .. py:method:: argbase() -> int


   .. py:method:: idaloc2vd(loc: argloc_t, width: int) -> vdloc_t


   .. py:method:: vd2idaloc(*args) -> argloc_t

      This function has the following signatures:

          0. vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
          1. vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t

      # 0: vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t


      # 1: vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t



   .. py:method:: is_stkarg(v: lvar_t) -> bool


   .. py:method:: get_ida_argloc(v: lvar_t) -> argloc_t


   .. py:attribute:: mbr
      :type:  mba_ranges_t


   .. py:attribute:: entry_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: last_prolog_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: first_epilog_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: qty
      :type:  int

      number of basic blocks



   .. py:attribute:: npurged
      :type:  int

      -1 - unknown



   .. py:attribute:: cc
      :type:  callcnv_t

      calling convention



   .. py:attribute:: tmpstk_size
      :type:  int

      size of the temporary stack part (which dynamically changes with push/pops) 
              



   .. py:attribute:: frsize
      :type:  int

      size of local stkvars range in the stack frame



   .. py:attribute:: frregs
      :type:  int

      size of saved registers range in the stack frame



   .. py:attribute:: fpd
      :type:  int

      frame pointer delta



   .. py:attribute:: pfn_flags
      :type:  int

      copy of func_t::flags



   .. py:attribute:: retsize
      :type:  int

      size of return address in the stack frame



   .. py:attribute:: shadow_args
      :type:  int

      size of shadow argument area



   .. py:attribute:: fullsize
      :type:  int

      Full stack size including incoming args.



   .. py:attribute:: stacksize
      :type:  int

      The maximal size of the function stack including bytes allocated for outgoing call arguments (up to retaddr) 
              



   .. py:attribute:: inargoff
      :type:  int

      offset of the first stack argument; after fix_scattered_movs() INARGOFF may be less than STACKSIZE 
              



   .. py:attribute:: minstkref
      :type:  int

      The lowest stack location whose address was taken.



   .. py:attribute:: minstkref_ea
      :type:  ida_idaapi.ea_t

      address with lowest minstkref (for debugging)



   .. py:attribute:: minargref
      :type:  int

      The lowest stack argument location whose address was taken This location and locations above it can be aliased It controls locations >= inargoff-shadow_args 
              



   .. py:attribute:: spd_adjust
      :type:  int

      If sp>0, the max positive sp value.



   .. py:attribute:: gotoff_stkvars
      :type:  ivlset_t

      stkvars that hold .got offsets. considered to be unaliasable



   .. py:attribute:: restricted_memory
      :type:  ivlset_t


   .. py:attribute:: aliased_memory
      :type:  ivlset_t

      aliased_memory+restricted_memory=ALLMEM



   .. py:attribute:: nodel_memory
      :type:  mlist_t

      global dead elimination may not delete references to this area



   .. py:attribute:: consumed_argregs
      :type:  rlist_t

      registers converted into stack arguments, should not be used as arguments



   .. py:attribute:: maturity
      :type:  mba_maturity_t

      current maturity level



   .. py:attribute:: reqmat
      :type:  mba_maturity_t

      required maturity level



   .. py:attribute:: final_type
      :type:  bool

      is the function type final? (specified by the user)



   .. py:attribute:: idb_type
      :type:  tinfo_t

      function type as retrieved from the database



   .. py:attribute:: idb_spoiled
      :type:  reginfovec_t

      MBA_SPLINFO && final_type: info in ida format.



   .. py:attribute:: spoiled_list
      :type:  mlist_t

      MBA_SPLINFO && !final_type: info in vd format.



   .. py:attribute:: fti_flags
      :type:  int

      FTI_... constants for the current function.



   .. py:attribute:: label
      :type:  str

      name of the function or pattern (colored)



   .. py:attribute:: vars
      :type:  lvars_t

      local variables



   .. py:attribute:: argidx
      :type:  intvec_t

      input arguments (indexes into 'vars')



   .. py:attribute:: retvaridx
      :type:  int

      index of variable holding the return value -1 means none 
              



   .. py:attribute:: error_ea
      :type:  ida_idaapi.ea_t

      during microcode generation holds ins.ea



   .. py:attribute:: error_strarg
      :type:  str


   .. py:attribute:: blocks
      :type:  mblock_t *

      double linked list of blocks



   .. py:attribute:: natural
      :type:  mblock_t **

      natural order of blocks



   .. py:attribute:: std_ivls
      :type:  ivl_with_name_t [6]

      we treat memory as consisting of 6 parts see memreg_index_t 
              



   .. py:attribute:: notes
      :type:  hexwarns_t


   .. py:attribute:: occurred_warns
      :type:  uchar [32]


   .. py:method:: write_to_const_detected() -> bool


   .. py:method:: bad_call_sp_detected() -> bool


   .. py:method:: regargs_is_not_aligned() -> bool


   .. py:method:: has_bad_sp() -> bool


   .. py:method:: term() -> None


   .. py:method:: get_curfunc() -> func_t *


   .. py:method:: use_frame() -> bool


   .. py:method:: is_snippet() -> bool


   .. py:method:: set_maturity(mat: mba_maturity_t) -> merror_t

      Set maturity level. 
              
      :param mat: new maturity level
      :returns: error code Plugins may use this function to skip some parts of the analysis. The maturity level cannot be decreased.



   .. py:method:: optimize_local(locopt_bits: int) -> int

      Optimize each basic block locally 
              
      :param locopt_bits: combination of Bits for optimize_local() bits
      :returns: number of changes. 0 means nothing changed This function is called by the decompiler, usually there is no need to call it explicitly.



   .. py:method:: build_graph() -> merror_t

      Build control flow graph. This function may be called only once. It calculates the type of each basic block and the adjacency list. optimize_local() calls this function if necessary. You need to call this function only before MMAT_LOCOPT. 
              
      :returns: error code



   .. py:method:: get_graph() -> mbl_graph_t *

      Get control graph. Call build_graph() if you need the graph before MMAT_LOCOPT. 
              



   .. py:method:: analyze_calls(acflags: int) -> int

      Analyze calls and determine calling conventions. 
              
      :param acflags: permitted actions that are necessary for successful detection of calling conventions. See Bits for analyze_calls()
      :returns: number of calls. -1 means error.



   .. py:method:: optimize_global() -> merror_t

      Optimize microcode globally. This function applies various optimization methods until we reach the fixed point. After that it preallocates lvars unless reqmat forbids it. 
              
      :returns: error code



   .. py:method:: alloc_lvars() -> None

      Allocate local variables. Must be called only immediately after optimize_global(), with no modifications to the microcode. Converts registers, stack variables, and similar operands into mop_l. This call will not fail because all necessary checks were performed in optimize_global(). After this call the microcode reaches its final state. 
              



   .. py:method:: dump() -> None

      Dump microcode to a file. The file will be created in the directory pointed by IDA_DUMPDIR envvar. Dump will be created only if IDA is run under debugger. 
              



   .. py:method:: dump_mba(_verify: bool, title: str) -> None


   .. py:method:: verify(always: bool) -> None

      Verify microcode consistency. 
              
      :param always: if false, the check will be performed only if ida runs under debugger If any inconsistency is discovered, an internal error will be generated. We strongly recommend you to call this function before returing control to the decompiler from your callbacks, in the case if you modified the microcode. If the microcode is inconsistent, this function will generate an internal error. We provide the source code of this function in the plugins/hexrays_sdk/verifier directory for your reference.



   .. py:method:: mark_chains_dirty() -> None

      Mark the microcode use-def chains dirty. Call this function is any inter-block data dependencies got changed because of your modifications to the microcode. Failing to do so may cause an internal error. 
              



   .. py:method:: get_mblock(n: uint) -> mblock_t *

      Get basic block by its serial number.



   .. py:method:: insert_block(bblk: int) -> mblock_t *

      Insert a block in the middle of the mbl array. The very first block of microcode must be empty, it is the entry block. The very last block of microcode must be BLT_STOP, it is the exit block. Therefore inserting a new block before the entry point or after the exit block is not a good idea. 
              
      :param bblk: the new block will be inserted before BBLK
      :returns: ptr to the new block



   .. py:method:: split_block(blk: mblock_t, start_insn: minsn_t) -> mblock_t *

      Split a block: insert a new one after the block, move some instructions to new block 
              
      :param blk: block to be split
      :param start_insn: all instructions to be moved to new block: starting with this one up to the end
      :returns: ptr to the new block



   .. py:method:: remove_block(blk: mblock_t) -> bool

      Delete a block. 
              
      :param blk: block to delete
      :returns: true if at least one of the other blocks became empty or unreachable



   .. py:method:: remove_blocks(start_blk: int, end_blk: int) -> bool


   .. py:method:: copy_block(blk: mblock_t, new_serial: int, cpblk_flags: int = 3) -> mblock_t *

      Make a copy of a block. This function makes a simple copy of the block. It does not fix the predecessor and successor lists, they must be fixed if necessary. 
              
      :param blk: block to copy
      :param new_serial: position of the copied block
      :param cpblk_flags: combination of Batch decompilation bits... bits
      :returns: pointer to the new copy



   .. py:method:: remove_empty_and_unreachable_blocks() -> bool

      Delete all empty and unreachable blocks. Blocks marked with MBL_KEEP won't be deleted. 
              



   .. py:method:: merge_blocks() -> bool

      Merge blocks. This function merges blocks constituting linear flow. It calls remove_empty_and_unreachable_blocks() as well. 
              
      :returns: true if changed any blocks



   .. py:method:: for_all_ops(mv: mop_visitor_t) -> int

      Visit all operands of all instructions. 
              
      :param mv: operand visitor
      :returns: non-zero value returned by mv.visit_mop() or zero



   .. py:method:: for_all_insns(mv: minsn_visitor_t) -> int

      Visit all instructions. This function visits all instruction and subinstructions. 
              
      :param mv: instruction visitor
      :returns: non-zero value returned by mv.visit_mop() or zero



   .. py:method:: for_all_topinsns(mv: minsn_visitor_t) -> int

      Visit all top level instructions. 
              
      :param mv: instruction visitor
      :returns: non-zero value returned by mv.visit_mop() or zero



   .. py:method:: find_mop(ctx: op_parent_info_t, ea: ida_idaapi.ea_t, is_dest: bool, list: mlist_t) -> mop_t *

      Find an operand in the microcode. This function tries to find the operand that matches LIST. Any operand that overlaps with LIST is considered as a match. 
              
      :param ctx: context information for the result
      :param ea: desired address of the operand. BADADDR means to accept any address.
      :param is_dest: search for destination operand? this argument may be ignored if the exact match could not be found
      :param list: list of locations the correspond to the operand
      :returns: pointer to the operand or nullptr.



   .. py:method:: create_helper_call(ea: ida_idaapi.ea_t, helper: str, rettype: tinfo_t = None, callargs: mcallargs_t = None, out: mop_t = None) -> minsn_t *

      Create a call of a helper function. 
              
      :param ea: The desired address of the instruction
      :param helper: The helper name
      :param rettype: The return type (nullptr or empty type means 'void')
      :param callargs: The helper arguments (nullptr-no arguments)
      :param out: The operand where the call result should be stored. If this argument is not nullptr, "mov helper_call(), out" will be generated. Otherwise "call helper()" will be generated. Note: the size of this operand must be equal to the RETTYPE size
      :returns: pointer to the created instruction or nullptr if error



   .. py:method:: get_func_output_lists(*args) -> None

      Prepare the lists of registers & memory that are defined/killed by a function 
              
      :param return_regs: defined regs to return (eax,edx)
      :param spoiled: spoiled regs (flags,ecx,mem)
      :param type: the function type
      :param call_ea: the call insn address (if known)
      :param tail_call: is it the tail call?



   .. py:method:: arg(n: int) -> lvar_t &

      Get input argument of the decompiled function. 
              
      :param n: argument number (0..nargs-1)



   .. py:method:: alloc_fict_ea(real_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

      Allocate a fictional address. This function can be used to allocate a new unique address for a new instruction, if re-using any existing address leads to conflicts. For example, if the last instruction of the function modifies R0 and falls through to the next function, it will be a tail call: LDM R0!, {R4,R7} end of the function start of another function In this case R0 generates two different lvars at the same address:
      * one modified by LDM
      * another that represents the return value from the tail call


      Another example: a third-party plugin makes a copy of an instruction. This may lead to the generation of two variables at the same address. Example 3: fictional addresses can be used for new instructions created while modifying the microcode. This function can be used to allocate a new unique address for a new instruction or a variable. The fictional address is selected from an unallocated address range. 
              
      :param real_ea: real instruction address (BADADDR is ok too)
      :returns: a unique fictional address



   .. py:method:: map_fict_ea(fict_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

      Resolve a fictional address. This function provides a reverse of the mapping made by alloc_fict_ea(). 
              
      :param fict_ea: fictional definition address
      :returns: the real instruction address



   .. py:method:: get_std_region(idx: memreg_index_t) -> ivl_t const &

      Get information about various memory regions. We map the stack frame to the global memory, to some unused range. 
              



   .. py:method:: get_lvars_region() -> ivl_t const &


   .. py:method:: get_shadow_region() -> ivl_t const &


   .. py:method:: get_args_region() -> ivl_t const &


   .. py:method:: get_stack_region() -> ivl_t


   .. py:method:: serialize() -> None

      Serialize mbl array into a sequence of bytes.



   .. py:method:: deserialize(bytes: uchar const *) -> mba_t *
      :staticmethod:


      Deserialize a byte sequence into mbl array. 
              
      :param bytes: pointer to the beginning of the byte sequence.
      :returns: new mbl array



   .. py:method:: save_snapshot(description: str) -> None

      Create and save microcode snapshot.



   .. py:method:: alloc_kreg(size: size_t, check_size: bool = True) -> mreg_t

      Allocate a kernel register. 
              
      :param size: size of the register in bytes
      :param check_size: if true, only the sizes that correspond to a size of a basic type will be accepted.
      :returns: allocated register. mr_none means failure.



   .. py:method:: free_kreg(reg: mreg_t, size: size_t) -> None

      Free a kernel register. If wrong arguments are passed, this function will generate an internal error. 
              
      :param reg: a previously allocated kernel register
      :param size: size of the register in bytes



   .. py:method:: inline_func(cdg: codegen_t, blknum: int, ranges: mba_ranges_t, decomp_flags: int = 0, inline_flags: int = 0) -> merror_t

      Inline a range. This function may be called only during the initial microcode generation phase. 
              
      :param cdg: the codegenerator object
      :param blknum: the block contaning the call/jump instruction to inline
      :param ranges: the set of ranges to inline. in the case of multiple calls to inline_func(), ranges will be compared using their start addresses. if two ranges have the same address, they will be considered the same.
      :param decomp_flags: combination of decompile() flags bits
      :param inline_flags: combination of inline_func() flags bits
      :returns: error code



   .. py:method:: locate_stkpnt(ea: ida_idaapi.ea_t) -> stkpnt_t const *


   .. py:method:: set_lvar_name(v: lvar_t, name: str, flagbits: int) -> bool


   .. py:method:: set_nice_lvar_name(v: lvar_t, name: str) -> bool


   .. py:method:: set_user_lvar_name(v: lvar_t, name: str) -> bool


   .. py:attribute:: idb_node


.. py:data:: MBA_PRCDEFS

   use precise defeas for chain-allocated lvars


.. py:data:: MBA_NOFUNC

   function is not present, addresses might be wrong


.. py:data:: MBA_PATTERN

   microcode pattern, callinfo is present


.. py:data:: MBA_LOADED

   loaded gdl, no instructions (debugging)


.. py:data:: MBA_RETFP

   function returns floating point value


.. py:data:: MBA_SPLINFO

   (final_type ? idb_spoiled : spoiled_regs) is valid


.. py:data:: MBA_PASSREGS

   has mcallinfo_t::pass_regs


.. py:data:: MBA_THUNK

   thunk function


.. py:data:: MBA_CMNSTK

   stkvars+stkargs should be considered as one area


.. py:data:: MBA_PREOPT

   preoptimization stage complete


.. py:data:: MBA_CMBBLK

   request to combine blocks


.. py:data:: MBA_ASRTOK

   assertions have been generated


.. py:data:: MBA_CALLS

   callinfo has been built


.. py:data:: MBA_ASRPROP

   assertion have been propagated


.. py:data:: MBA_SAVRST

   save-restore analysis has been performed


.. py:data:: MBA_RETREF

   return type has been refined


.. py:data:: MBA_GLBOPT

   microcode has been optimized globally


.. py:data:: MBA_LVARS0

   lvar pre-allocation has been performed


.. py:data:: MBA_LVARS1

   lvar real allocation has been performed


.. py:data:: MBA_DELPAIRS

   pairs have been deleted once


.. py:data:: MBA_CHVARS

   can verify chain varnums


.. py:data:: MBA_SHORT

   use short display


.. py:data:: MBA_COLGDL

   display graph after each reduction


.. py:data:: MBA_INSGDL

   display instruction in graphs


.. py:data:: MBA_NICE

   apply transformations to c code


.. py:data:: MBA_REFINE

   may refine return value size


.. py:data:: MBA_WINGR32

   use wingraph32


.. py:data:: MBA_NUMADDR

   display definition addresses for numbers


.. py:data:: MBA_VALNUM

   display value numbers


.. py:data:: MBA_INITIAL_FLAGS

.. py:data:: MBA2_LVARNAMES_OK

   may verify lvar_names?


.. py:data:: MBA2_LVARS_RENAMED

   accept empty names now?


.. py:data:: MBA2_OVER_CHAINS

   has overlapped chains?


.. py:data:: MBA2_VALRNG_DONE

   calculated valranges?


.. py:data:: MBA2_IS_CTR

   is constructor?


.. py:data:: MBA2_IS_DTR

   is destructor?


.. py:data:: MBA2_ARGIDX_OK

   may verify input argument list?


.. py:data:: MBA2_NO_DUP_CALLS

   forbid multiple calls with the same ea


.. py:data:: MBA2_NO_DUP_LVARS

   forbid multiple lvars with the same ea


.. py:data:: MBA2_UNDEF_RETVAR

   return value is undefined


.. py:data:: MBA2_ARGIDX_SORTED

   args finally sorted according to ABI (e.g. reverse stkarg order in Borland) 
           


.. py:data:: MBA2_CODE16_BIT

   the code16 bit got removed


.. py:data:: MBA2_STACK_RETVAL

   the return value (or its part) is on the stack


.. py:data:: MBA2_HAS_OUTLINES

   calls to outlined code have been inlined


.. py:data:: MBA2_NO_FRAME

   do not use function frame info (only snippet mode)


.. py:data:: MBA2_PROP_COMPLEX

   allow propagation of more complex variable definitions


.. py:data:: MBA2_DONT_VERIFY

   Do not verify microcode. This flag is recomended to be set only when debugging decompiler plugins 
           


.. py:data:: MBA2_INITIAL_FLAGS

.. py:data:: MBA2_ALL_FLAGS

.. py:data:: NALT_VD

   this index is not used by ida


.. py:data:: LOCOPT_ALL

   redo optimization for all blocks. if this bit is not set, only dirty blocks will be optimized 
           


.. py:data:: LOCOPT_REFINE

   refine return type, ok to fail


.. py:data:: LOCOPT_REFINE2

   refine return type, try harder


.. py:data:: ACFL_LOCOPT

   perform local propagation (requires ACFL_BLKOPT)


.. py:data:: ACFL_BLKOPT

   perform interblock transformations


.. py:data:: ACFL_GLBPROP

   perform global propagation


.. py:data:: ACFL_GLBDEL

   perform dead code eliminition


.. py:data:: ACFL_GUESS

   may guess calling conventions


.. py:data:: CPBLK_FAST

   do not update minbstkref and minbargref


.. py:data:: CPBLK_MINREF

   update minbstkref and minbargref


.. py:data:: CPBLK_OPTJMP

   del the jump insn at the end of the block if it becomes useless 
           


.. py:data:: INLINE_EXTFRAME

   Inlined function has its own (external) frame.


.. py:data:: INLINE_DONTCOPY

   Do not reuse old inlined copy even if it exists.


.. py:class:: chain_keeper_t(_gc: graph_chains_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: front() -> block_chains_t &


   .. py:method:: back() -> block_chains_t &


   .. py:method:: for_all_chains(cv: chain_visitor_t, gca: int) -> int


.. py:data:: GC_REGS_AND_STKVARS

   registers and stkvars (restricted memory only)


.. py:data:: GC_ASR

   all the above and assertions


.. py:data:: GC_XDSU

   only registers calculated with FULL_XDSU


.. py:data:: GC_END

   number of chain types


.. py:data:: GC_DIRTY_ALL

   bitmask to represent all chains


.. py:class:: mbl_graph_t(*args, **kwargs)

   Bases: :py:obj:`simple_graph_t`


   .. py:attribute:: thisown


   .. py:method:: is_ud_chain_dirty(gctype: gctype_t) -> bool

      Is the use-def chain of the specified kind dirty?



   .. py:method:: is_du_chain_dirty(gctype: gctype_t) -> bool

      Is the def-use chain of the specified kind dirty?



   .. py:method:: get_chain_stamp() -> int


   .. py:method:: get_ud(gctype: gctype_t) -> graph_chains_t *

      Get use-def chains.



   .. py:method:: get_du(gctype: gctype_t) -> graph_chains_t *

      Get def-use chains.



   .. py:method:: is_redefined_globally(*args) -> bool

      Is LIST redefined in the graph?



   .. py:method:: is_used_globally(*args) -> bool

      Is LIST used in the graph?



   .. py:method:: get_mblock(n: int) -> mblock_t *


.. py:class:: cdg_insn_iterator_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t const *


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: end
      :type:  ida_idaapi.ea_t


   .. py:attribute:: dslot
      :type:  ida_idaapi.ea_t


   .. py:attribute:: dslot_insn
      :type:  insn_t


   .. py:attribute:: severed_branch
      :type:  ida_idaapi.ea_t


   .. py:attribute:: is_likely_dslot
      :type:  bool


   .. py:method:: ok() -> bool


   .. py:method:: has_dslot() -> bool


   .. py:method:: dslot_with_xrefs() -> bool


   .. py:method:: is_severed_dslot() -> bool


   .. py:method:: start(rng: range_t) -> None


   .. py:method:: next(ins: insn_t *) -> merror_t


.. py:class:: codegen_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t *


   .. py:attribute:: mb
      :type:  mblock_t *


   .. py:attribute:: insn
      :type:  insn_t


   .. py:attribute:: ignore_micro
      :type:  char


   .. py:attribute:: ii
      :type:  cdg_insn_iterator_t


   .. py:method:: clear() -> None


   .. py:method:: analyze_prolog(fc: qflow_chart_t, reachable: bitset_t) -> merror_t

      Analyze prolog/epilog of the function to decompile. If prolog is found, allocate and fill 'mba->pi' structure. 
              
      :param fc: flow chart
      :param reachable: bitmap of reachable blocks
      :returns: error code



   .. py:method:: gen_micro() -> merror_t

      Generate microcode for one instruction. The instruction is in INSN 
              
      :returns: MERR_OK - all ok MERR_BLOCK - all ok, need to switch to new block MERR_BADBLK - delete current block and continue other error codes are fatal



   .. py:method:: load_operand(opnum: int, flags: int = 0) -> mreg_t

      Generate microcode to load one operand. 
              
      :param opnum: number of INSN operand
      :param flags: reserved for future use
      :returns: register containing the operand.



   .. py:method:: microgen_completed() -> None

      This method is called when the microcode generation is done.



   .. py:method:: prepare_gen_micro() -> merror_t

      Setup internal data to handle new instruction. This method should be called before calling gen_micro(). Usually gen_micro() is called by the decompiler. You have to call this function explicitly only if you yourself call gen_micro(). The instruction is in INSN 
              
      :returns: MERR_OK - all ok other error codes are fatal



   .. py:method:: load_effective_address(n: int, flags: int = 0) -> mreg_t

      Generate microcode to calculate the address of a memory operand. 
              
      :param n: - number of INSN operand
      :param flags: - reserved for future use
      :returns: register containing the operand address. mr_none - failed (not a memory operand)



   .. py:method:: store_operand(n: int, mop: mop_t, flags: int = 0, outins: minsn_t ** = None) -> bool

      Generate microcode to store an operand. In case of success an arbitrary number of instructions can be generated (and even no instruction if the source and target are the same) 
              
      :param n: - number of target INSN operand
      :param mop: - operand to be stored
      :param flags: - reserved for future use
      :param outins: - (OUT) the last generated instruction
      :returns: success



   .. py:method:: emit_micro_mvm(code: mcode_t, dtype: op_dtype_t, l: int, r: int, d: int, offsize: int) -> minsn_t *

      Emit one microinstruction. This variant takes a data type not a size. 
              



   .. py:method:: emit(*args) -> minsn_t *

      This function has the following signatures:

          0. emit(code: mcode_t, width: int, l: int, r: int, d: int, offsize: int) -> minsn_t *
          1. emit(code: mcode_t, l: const mop_t *, r: const mop_t *, d: const mop_t *) -> minsn_t *

      # 0: emit(code: mcode_t, width: int, l: int, r: int, d: int, offsize: int) -> minsn_t *

      Emit one microinstruction. The L, R, D arguments usually mean the register number. However, they depend on CODE. For example:
      * for m_goto and m_jcnd L is the target address
      * for m_ldc L is the constant value to load



      :returns: created microinstruction. can be nullptr if the instruction got immediately optimized away.

      # 1: emit(code: mcode_t, l: const mop_t *, r: const mop_t *, d: const mop_t *) -> minsn_t *

      Emit one microinstruction. This variant accepts pointers to operands. It is more difficult to use but permits to create virtually any instruction. Operands may be nullptr when it makes sense. 
              



.. py:function:: change_hexrays_config(directive: str) -> bool

   Parse DIRECTIVE and update the current configuration variables. For the syntax see hexrays.cfg 
           


.. py:function:: get_hexrays_version() -> str

   Get decompiler version. The returned string is of the form <major>.<minor>.<revision>.<build-date> 
           
   :returns: pointer to version string. For example: "2.0.0.140605"


.. py:data:: OPF_REUSE

   reuse existing window


.. py:data:: OPF_NEW_WINDOW

   open new window


.. py:data:: OPF_REUSE_ACTIVE

   reuse existing window, only if the currently active widget is a pseudocode view 
           


.. py:data:: OPF_NO_WAIT

   do not display waitbox if decompilation happens


.. py:data:: OPF_WINDOW_MGMT_MASK

.. py:function:: open_pseudocode(ea: ida_idaapi.ea_t, flags: int) -> vdui_t *

   Open pseudocode window. The specified function is decompiled and the pseudocode window is opened. 
           
   :param ea: function to decompile
   :param flags: a combination of OPF_ flags
   :returns: false if failed


.. py:function:: close_pseudocode(f: TWidget *) -> bool

   Close pseudocode window. 
           
   :param f: pointer to window
   :returns: false if failed


.. py:data:: VDRUN_NEWFILE

   Create a new file or overwrite existing file.


.. py:data:: VDRUN_APPEND

   Create a new file or append to existing file.


.. py:data:: VDRUN_ONLYNEW

   Fail if output file already exists.


.. py:data:: VDRUN_SILENT

   Silent decompilation.


.. py:data:: VDRUN_SENDIDB

   Send problematic databases to hex-rays.com.


.. py:data:: VDRUN_MAYSTOP

   The user can cancel decompilation.


.. py:data:: VDRUN_CMDLINE

   Called from ida's command line.


.. py:data:: VDRUN_STATS

   Print statistics into vd_stats.txt.


.. py:data:: VDRUN_LUMINA

   Use lumina server.


.. py:data:: VDRUN_PERF

   Print performance stats to ida.log.


.. py:function:: decompile_many(outfile: str, funcaddrs: uint64vec_t, flags: int) -> bool

   Batch decompilation. Decompile all or the specified functions 
           
   :param outfile: name of the output file
   :param funcaddrs: list of functions to decompile. If nullptr or empty, then decompile all nonlib functions
   :param flags: Batch decompilation bits
   :returns: true if no internal error occurred and the user has not cancelled decompilation


.. py:class:: hexrays_failure_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: code
      :type:  merror_t

      Microcode error code



   .. py:attribute:: errea
      :type:  ida_idaapi.ea_t

      associated address



   .. py:attribute:: str
      :type:  hexrays_failure_t.str

      string information



   .. py:method:: desc() -> str


.. py:class:: vd_failure_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: hf
      :type:  hexrays_failure_t


   .. py:method:: desc() -> str


.. py:class:: vd_interr_t(ea: ida_idaapi.ea_t, buf: str)

   Bases: :py:obj:`vd_failure_t`


   .. py:attribute:: thisown


.. py:function:: send_database(err: hexrays_failure_t, silent: bool) -> None

   Send the database to Hex-Rays. This function sends the current database to the Hex-Rays server. The database is sent in the compressed form over an encrypted (SSL) connection. 
           
   :param err: failure description object. Empty hexrays_failure_t object can be used if error information is not available.
   :param silent: if false, a dialog box will be displayed before sending the database.


.. py:class:: gco_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      register or stkvar name



   .. py:attribute:: stkoff
      :type:  int

      if stkvar, stack offset



   .. py:attribute:: regnum
      :type:  int

      if register, the register id



   .. py:attribute:: size
      :type:  int

      operand size



   .. py:attribute:: flags
      :type:  int


   .. py:method:: is_reg() -> bool


   .. py:method:: is_use() -> bool


   .. py:method:: is_def() -> bool


   .. py:method:: append_to_list(list: mlist_t, mba: mba_t) -> bool

      Append operand info to LIST. This function converts IDA register number or stack offset to a decompiler list. 
              
      :param list: list to append to
      :param mba: microcode object



   .. py:method:: cvt_to_ivl() -> vivl_t

      Convert operand info to VIVL. The returned VIVL can be used, for example, in a call of get_valranges(). 
              



.. py:data:: GCO_STK

   a stack variable


.. py:data:: GCO_REG

   is register? otherwise a stack variable


.. py:data:: GCO_USE

   is source operand?


.. py:data:: GCO_DEF

   is destination operand?


.. py:function:: get_current_operand(out: gco_info_t) -> bool

   Get the instruction operand under the cursor. This function determines the operand that is under the cursor in the active disassembly listing. If the operand refers to a register or stack variable, it returns true. 
           


.. py:function:: remitem(e: citem_t) -> None

.. py:data:: cot_empty

.. py:data:: cot_comma

   x, y


.. py:data:: cot_asg

   x = y


.. py:data:: cot_asgbor

   x |= y


.. py:data:: cot_asgxor

   x ^= y


.. py:data:: cot_asgband

   x &= y


.. py:data:: cot_asgadd

   x += y


.. py:data:: cot_asgsub

   x -= y


.. py:data:: cot_asgmul

   x *= y


.. py:data:: cot_asgsshr

   x >>= y signed


.. py:data:: cot_asgushr

   x >>= y unsigned


.. py:data:: cot_asgshl

   x <<= y


.. py:data:: cot_asgsdiv

   x /= y signed


.. py:data:: cot_asgudiv

   x /= y unsigned


.. py:data:: cot_asgsmod

   x %= y signed


.. py:data:: cot_asgumod

   x %= y unsigned


.. py:data:: cot_tern

   x ? y : z


.. py:data:: cot_lor

   x || y


.. py:data:: cot_land

   x && y


.. py:data:: cot_bor

   x | y


.. py:data:: cot_xor

   x ^ y


.. py:data:: cot_band

   x & y


.. py:data:: cot_eq

   x == y int or fpu (see EXFL_FPOP)


.. py:data:: cot_ne

   x != y int or fpu (see EXFL_FPOP)


.. py:data:: cot_sge

   x >= y signed or fpu (see EXFL_FPOP)


.. py:data:: cot_uge

   x >= y unsigned


.. py:data:: cot_sle

   x <= y signed or fpu (see EXFL_FPOP)


.. py:data:: cot_ule

   x <= y unsigned


.. py:data:: cot_sgt

   x > y signed or fpu (see EXFL_FPOP)


.. py:data:: cot_ugt

   x > y unsigned


.. py:data:: cot_slt

   x < y signed or fpu (see EXFL_FPOP)


.. py:data:: cot_ult

   x < y unsigned


.. py:data:: cot_sshr

   x >> y signed


.. py:data:: cot_ushr

   x >> y unsigned


.. py:data:: cot_shl

   x << y


.. py:data:: cot_add

   x + y


.. py:data:: cot_sub

   x - y


.. py:data:: cot_mul

   x * y


.. py:data:: cot_sdiv

   x / y signed


.. py:data:: cot_udiv

   x / y unsigned


.. py:data:: cot_smod

   x % y signed


.. py:data:: cot_umod

   x % y unsigned


.. py:data:: cot_fadd

   x + y fp


.. py:data:: cot_fsub

   x - y fp


.. py:data:: cot_fmul

   x * y fp


.. py:data:: cot_fdiv

   x / y fp


.. py:data:: cot_fneg

   -x fp


.. py:data:: cot_neg

   -x


.. py:data:: cot_cast

   (type)x


.. py:data:: cot_lnot

   !x


.. py:data:: cot_bnot

   ~x


.. py:data:: cot_ptr

   *x, access size in 'ptrsize'


.. py:data:: cot_ref

   &x


.. py:data:: cot_postinc

   x++


.. py:data:: cot_postdec

   x-


.. py:data:: cot_preinc

   ++x


.. py:data:: cot_predec

   -x


.. py:data:: cot_call

   x(...)


.. py:data:: cot_idx

   x[y]


.. py:data:: cot_memref

   x.m


.. py:data:: cot_memptr

   x->m, access size in 'ptrsize'


.. py:data:: cot_num

   n


.. py:data:: cot_fnum

   fpc


.. py:data:: cot_str

   string constant (user representation)


.. py:data:: cot_obj

   obj_ea


.. py:data:: cot_var

   v


.. py:data:: cot_insn

   instruction in expression, internal representation only


.. py:data:: cot_sizeof

   sizeof(x)


.. py:data:: cot_helper

   arbitrary name


.. py:data:: cot_type

   arbitrary type


.. py:data:: cot_last

.. py:data:: cit_empty

   instruction types start here


.. py:data:: cit_block

   block-statement: { ... }


.. py:data:: cit_expr

   expression-statement: expr;


.. py:data:: cit_if

   if-statement


.. py:data:: cit_for

   for-statement


.. py:data:: cit_while

   while-statement


.. py:data:: cit_do

   do-statement


.. py:data:: cit_switch

   switch-statement


.. py:data:: cit_break

   break-statement


.. py:data:: cit_continue

   continue-statement


.. py:data:: cit_return

   return-statement


.. py:data:: cit_goto

   goto-statement


.. py:data:: cit_asm

   asm-statement


.. py:data:: cit_try

   C++ try-statement.


.. py:data:: cit_throw

   C++ throw-statement.


.. py:data:: cit_end

.. py:function:: negated_relation(op: ctype_t) -> ctype_t

   Negate a comparison operator. For example, cot_sge becomes cot_slt.


.. py:function:: swapped_relation(op: ctype_t) -> ctype_t

   Swap a comparison operator. For example, cot_sge becomes cot_sle.


.. py:function:: get_op_signness(op: ctype_t) -> type_sign_t

   Get operator sign. Meaningful for sign-dependent operators, like cot_sdiv.


.. py:function:: asgop(cop: ctype_t) -> ctype_t

   Convert plain operator into assignment operator. For example, cot_add returns cot_asgadd.


.. py:function:: asgop_revert(cop: ctype_t) -> ctype_t

   Convert assignment operator into plain operator. For example, cot_asgadd returns cot_add 
           
   :returns: cot_empty is the input operator is not an assignment operator.


.. py:function:: op_uses_x(op: ctype_t) -> bool

   Does operator use the 'x' field of cexpr_t?


.. py:function:: op_uses_y(op: ctype_t) -> bool

   Does operator use the 'y' field of cexpr_t?


.. py:function:: op_uses_z(op: ctype_t) -> bool

   Does operator use the 'z' field of cexpr_t?


.. py:function:: is_binary(op: ctype_t) -> bool

   Is binary operator?


.. py:function:: is_unary(op: ctype_t) -> bool

   Is unary operator?


.. py:function:: is_relational(op: ctype_t) -> bool

   Is comparison operator?


.. py:function:: is_assignment(op: ctype_t) -> bool

   Is assignment operator?


.. py:function:: accepts_udts(op: ctype_t) -> bool

.. py:function:: is_prepost(op: ctype_t) -> bool

   Is pre/post increment/decrement operator?


.. py:function:: is_commutative(op: ctype_t) -> bool

   Is commutative operator?


.. py:function:: is_additive(op: ctype_t) -> bool

   Is additive operator?


.. py:function:: is_multiplicative(op: ctype_t) -> bool

   Is multiplicative operator?


.. py:function:: is_bitop(op: ctype_t) -> bool

   Is bit related operator?


.. py:function:: is_logical(op: ctype_t) -> bool

   Is logical operator?


.. py:function:: is_loop(op: ctype_t) -> bool

   Is loop statement code?


.. py:function:: is_break_consumer(op: ctype_t) -> bool

   Does a break statement influence the specified statement code?


.. py:function:: is_lvalue(op: ctype_t) -> bool

   Is Lvalue operator?


.. py:function:: accepts_small_udts(op: ctype_t) -> bool

   Is the operator allowed on small structure or union?


.. py:class:: cnumber_t(_opnum: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: nf
      :type:  number_format_t

      how to represent it



   .. py:method:: value(type: tinfo_t) -> uint64

      Get value. This function will properly extend the number sign to 64bits depending on the type sign. 
              



   .. py:method:: assign(v: uint64, nbytes: int, sign: type_sign_t) -> None

      Assign new value 
              
      :param v: new value
      :param nbytes: size of the new value in bytes
      :param sign: sign of the value



   .. py:method:: compare(r: cnumber_t) -> int


.. py:class:: var_ref_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: mba
      :type:  mba_t *

      pointer to the underlying micro array



   .. py:attribute:: idx
      :type:  int

      index into lvars_t



   .. py:method:: getv() -> lvar_t &


   .. py:method:: compare(r: var_ref_t) -> int


.. py:data:: CMAT_ZERO

   does not exist


.. py:data:: CMAT_BUILT

   just generated


.. py:data:: CMAT_TRANS1

   applied first wave of transformations


.. py:data:: CMAT_NICE

   nicefied expressions


.. py:data:: CMAT_TRANS2

   applied second wave of transformations


.. py:data:: CMAT_CPA

   corrected pointer arithmetic


.. py:data:: CMAT_TRANS3

   applied third wave of transformations


.. py:data:: CMAT_CASTED

   added necessary casts


.. py:data:: CMAT_FINAL

   ready-to-use


.. py:data:: ITP_EMPTY

   nothing


.. py:data:: ITP_ARG1

   , (64 entries are reserved for 64 call arguments)


.. py:data:: ITP_ARG64

.. py:data:: ITP_BRACE1

.. py:data:: ITP_INNER_LAST

.. py:data:: ITP_ASM

   __asm-line


.. py:data:: ITP_ELSE

   else-line


.. py:data:: ITP_DO

   do-line


.. py:data:: ITP_SEMI

   semicolon


.. py:data:: ITP_CURLY1

   {


.. py:data:: ITP_CURLY2

   }


.. py:data:: ITP_BRACE2

   )


.. py:data:: ITP_COLON

   : (label)


.. py:data:: ITP_BLOCK1

   opening block comment. this comment is printed before the item (other comments are indented and printed after the item) 
             


.. py:data:: ITP_BLOCK2

   closing block comment.


.. py:data:: ITP_TRY

   C++ try statement.


.. py:data:: ITP_CASE

   bit for switch cases


.. py:data:: ITP_SIGN

   if this bit is set too, then we have a negative case value


.. py:class:: treeloc_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: itp
      :type:  item_preciser_t


.. py:data:: RETRIEVE_ONCE

   Retrieve comment if it has not been used yet.


.. py:data:: RETRIEVE_ALWAYS

   Retrieve comment even if it has been used.


.. py:class:: citem_cmt_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: used
      :type:  bool

      the comment has been retrieved?



   .. py:method:: c_str() -> str


.. py:class:: citem_locator_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      citem address



   .. py:attribute:: op
      :type:  ctype_t

      citem operation



   .. py:method:: compare(r: citem_locator_t) -> int


.. py:class:: bit_bound_t(n: int = 0, s: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: nbits
      :type:  int16


   .. py:attribute:: sbits
      :type:  int16


.. py:class:: citem_t(o: ctype_t = cot_empty)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      address that corresponds to the item. may be BADADDR



   .. py:attribute:: label_num
      :type:  int

      label number. -1 means no label. items of the expression types (cot_...) should not have labels at the final maturity level, but at the intermediate levels any ctree item may have a label. Labels must be unique. Usually they correspond to the basic block numbers. 
              



   .. py:attribute:: index
      :type:  int

      an index in cfunc_t::treeitems. meaningful only after print_func() 
              



   .. py:method:: swap(r: citem_t) -> None

      Swap two citem_t.



   .. py:method:: is_expr() -> bool

      Is an expression?



   .. py:method:: contains_expr(e: cexpr_t) -> bool

      Does the item contain an expression?



   .. py:method:: contains_label() -> bool

      Does the item contain a label?



   .. py:method:: find_parent_of(item: citem_t) -> citem_t *

      Find parent of the specified item. 
              
      :param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
      :returns: nullptr if not found



   .. py:method:: find_closest_addr(_ea: ida_idaapi.ea_t) -> citem_t *


   .. py:method:: print1(func: cfunc_t) -> None

      Print item into one line. 
              
      :param func: parent function. This argument is used to find out the referenced variable names.
      :returns: length of the generated text.



   .. py:attribute:: cinsn
      :type:  cinsn_t *const


   .. py:attribute:: cexpr
      :type:  cexpr_t *const


   .. py:attribute:: op

      item type



   .. py:attribute:: obj_id


   .. py:method:: replace_by(o)


   .. py:attribute:: meminfo


.. py:class:: cexpr_t(*args)

   Bases: :py:obj:`citem_t`


   .. py:attribute:: thisown


   .. py:attribute:: type
      :type:  tinfo_t

      expression type. must be carefully maintained



   .. py:attribute:: exflags
      :type:  int

      Expression attributes 
              



   .. py:method:: cpadone() -> bool

      Pointer arithmetic correction done for this expression?



   .. py:method:: is_odd_lvalue() -> bool


   .. py:method:: is_fpop() -> bool


   .. py:method:: is_cstr() -> bool


   .. py:method:: is_undef_val() -> bool


   .. py:method:: is_jumpout() -> bool


   .. py:method:: is_vftable() -> bool


   .. py:method:: set_cpadone() -> None


   .. py:method:: set_vftable() -> None


   .. py:method:: swap(r: cexpr_t) -> None

      Swap two citem_t.



   .. py:method:: assign(r: cexpr_t) -> cexpr_t &


   .. py:method:: compare(r: cexpr_t) -> int


   .. py:method:: cleanup() -> None

      Cleanup the expression. This function properly deletes all children and sets the item type to cot_empty. 
              



   .. py:method:: put_number(*args) -> None

      Assign a number to the expression. 
              
      :param func: current function
      :param value: number value
      :param nbytes: size of the number in bytes
      :param sign: number sign



   .. py:method:: print1(func: cfunc_t) -> None

      Print expression into one line. 
              
      :param func: parent function. This argument is used to find out the referenced variable names.



   .. py:method:: calc_type(recursive: bool) -> None

      Calculate the type of the expression. Use this function to calculate the expression type when a new expression is built 
              
      :param recursive: if true, types of all children expression will be calculated before calculating our type



   .. py:method:: equal_effect(r: cexpr_t) -> bool

      Compare two expressions. This function tries to compare two expressions in an 'intelligent' manner. For example, it knows about commutitive operators and can ignore useless casts. 
              
      :param r: the expression to compare against the current expression
      :returns: true expressions can be considered equal



   .. py:method:: is_child_of(parent: citem_t) -> bool

      Verify if the specified item is our parent. 
              
      :param parent: possible parent item
      :returns: true if the specified item is our parent



   .. py:method:: contains_operator(needed_op: ctype_t, times: int = 1) -> bool

      Check if the expression contains the specified operator. 
              
      :param needed_op: operator code to search for
      :param times: how many times the operator code should be present
      :returns: true if the expression has at least TIMES children with NEEDED_OP



   .. py:method:: contains_comma(times: int = 1) -> bool

      Does the expression contain a comma operator?



   .. py:method:: contains_insn(times: int = 1) -> bool

      Does the expression contain an embedded statement operator?



   .. py:method:: contains_insn_or_label() -> bool

      Does the expression contain an embedded statement operator or a label?



   .. py:method:: contains_comma_or_insn_or_label(maxcommas: int = 1) -> bool

      Does the expression contain a comma operator or an embedded statement operator or a label?



   .. py:method:: is_nice_expr() -> bool

      Is nice expression? Nice expressions do not contain comma operators, embedded statements, or labels. 
              



   .. py:method:: is_nice_cond() -> bool

      Is nice condition?. Nice condition is a nice expression of the boolean type. 
              



   .. py:method:: is_call_object_of(parent: citem_t) -> bool

      Is call object? 
              
      :returns: true if our expression is the call object of the specified parent expression.



   .. py:method:: is_call_arg_of(parent: citem_t) -> bool

      Is call argument? 
              
      :returns: true if our expression is a call argument of the specified parent expression.



   .. py:method:: get_type_sign() -> type_sign_t

      Get expression sign.



   .. py:method:: is_type_unsigned() -> bool

      Is expression unsigned?



   .. py:method:: is_type_signed() -> bool

      Is expression signed?



   .. py:method:: get_high_nbit_bound() -> bit_bound_t

      Get max number of bits that can really be used by the expression. For example, x % 16 can yield only 4 non-zero bits, higher bits are zero 
              



   .. py:method:: get_low_nbit_bound() -> int

      Get min number of bits that are certainly required to represent the expression. For example, constant 16 always uses 5 bits: 10000. 
              



   .. py:method:: requires_lvalue(child: cexpr_t) -> bool

      Check if the expression requires an lvalue. 
              
      :param child: The function will check if this child of our expression must be an lvalue.
      :returns: true if child must be an lvalue.



   .. py:method:: has_side_effects() -> bool

      Check if the expression has side effects. Calls, pre/post inc/dec, and assignments have side effects. 
              



   .. py:method:: numval() -> uint64

      Get numeric value of the expression. This function can be called only on cot_num expressions! 
              



   .. py:method:: is_const_value(_v: uint64) -> bool

      Check if the expression is a number with the specified value.



   .. py:method:: is_negative_const() -> bool

      Check if the expression is a negative number.



   .. py:method:: is_non_negative_const() -> bool

      Check if the expression is a non-negative number.



   .. py:method:: is_non_zero_const() -> bool

      Check if the expression is a non-zero number.



   .. py:method:: is_zero_const() -> bool

      Check if the expression is a zero.



   .. py:method:: get_const_value() -> bool

      Get expression value. 
              
      :returns: true if the expression is a number.



   .. py:method:: maybe_ptr() -> bool

      May the expression be a pointer?



   .. py:method:: get_ptr_or_array() -> cexpr_t *

      Find pointer or array child.



   .. py:method:: find_op(_op: ctype_t) -> cexpr_t *

      Find the child with the specified operator.



   .. py:method:: find_num_op() -> cexpr_t *

      Find the operand with a numeric value.



   .. py:method:: theother(what: cexpr_t) -> cexpr_t *

      Get the other operand. This function returns the other operand (not the specified one) for binary expressions. 
              



   .. py:method:: get_1num_op(o1: cexpr_t **, o2: cexpr_t **) -> bool

      Get pointers to operands. at last one operand should be a number o1 will be pointer to the number 
              



   .. py:method:: dstr() -> str


   .. py:method:: get_v() -> var_ref_t *


   .. py:method:: set_v(v: var_ref_t) -> None


   .. py:attribute:: v

      used for cot_var



   .. py:property:: n


   .. py:property:: fpc


   .. py:property:: x


   .. py:property:: y


   .. py:property:: z


   .. py:property:: a


   .. py:property:: insn


   .. py:property:: m


   .. py:property:: ptrsize


   .. py:property:: obj_ea


   .. py:property:: refwidth


   .. py:property:: helper


   .. py:property:: string


.. py:data:: EXFL_CPADONE

   pointer arithmetic correction done


.. py:data:: EXFL_LVALUE

   expression is lvalue even if it doesn't look like it


.. py:data:: EXFL_FPOP

   floating point operation


.. py:data:: EXFL_ALONE

   standalone helper


.. py:data:: EXFL_CSTR

   string literal


.. py:data:: EXFL_PARTIAL

   type of the expression is considered partial


.. py:data:: EXFL_UNDEF

   expression uses undefined value


.. py:data:: EXFL_JUMPOUT

   jump out-of-function


.. py:data:: EXFL_VFTABLE

   is ptr to vftable (used for cot_memptr, cot_memref)


.. py:data:: EXFL_ALL

   all currently defined bits


.. py:class:: ceinsn_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: expr
      :type:  cexpr_t

      Expression of the statement.



.. py:data:: CALC_CURLY_BRACES

   print curly braces if necessary


.. py:data:: NO_CURLY_BRACES

   don't print curly braces


.. py:data:: USE_CURLY_BRACES

   print curly braces without any checks


.. py:class:: cif_t(*args)

   Bases: :py:obj:`ceinsn_t`


   .. py:attribute:: thisown


   .. py:attribute:: ithen
      :type:  cinsn_t *

      Then-branch of the if-statement.



   .. py:attribute:: ielse
      :type:  cinsn_t *

      Else-branch of the if-statement. May be nullptr.



   .. py:method:: assign(r: cif_t) -> cif_t &


   .. py:method:: compare(r: cif_t) -> int


   .. py:method:: cleanup() -> None


.. py:class:: cloop_t(*args)

   Bases: :py:obj:`ceinsn_t`


   .. py:attribute:: thisown


   .. py:attribute:: body
      :type:  cinsn_t *


   .. py:method:: assign(r: cloop_t) -> cloop_t &


   .. py:method:: cleanup() -> None


.. py:class:: cfor_t

   Bases: :py:obj:`cloop_t`


   .. py:attribute:: thisown


   .. py:attribute:: init
      :type:  cexpr_t

      Initialization expression.



   .. py:attribute:: step
      :type:  cexpr_t

      Step expression.



   .. py:method:: compare(r: cfor_t) -> int


.. py:class:: cwhile_t

   Bases: :py:obj:`cloop_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: cwhile_t) -> int


.. py:class:: cdo_t

   Bases: :py:obj:`cloop_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: cdo_t) -> int


.. py:class:: creturn_t

   Bases: :py:obj:`ceinsn_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: creturn_t) -> int


.. py:class:: cgoto_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: label_num
      :type:  int

      Target label number.



   .. py:method:: compare(r: cgoto_t) -> int


.. py:class:: casm_t(*args)

   Bases: :py:obj:`ida_pro.eavec_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: casm_t) -> int


   .. py:method:: one_insn() -> bool


.. py:class:: cinsn_t(*args)

   Bases: :py:obj:`citem_t`


   .. py:attribute:: thisown


   .. py:attribute:: ctry
      :type:  ctry_t *

      details of try-statement



   .. py:attribute:: cthrow
      :type:  cthrow_t *

      details of throw-statement



   .. py:method:: swap(r: cinsn_t) -> None

      Swap two citem_t.



   .. py:method:: assign(r: cinsn_t) -> cinsn_t &


   .. py:method:: compare(r: cinsn_t) -> int


   .. py:method:: cleanup() -> None

      Cleanup the statement. This function properly deletes all children and sets the item type to cit_empty. 
              



   .. py:method:: zero() -> None

      Overwrite with zeroes without cleaning memory or deleting children.



   .. py:method:: new_insn(insn_ea: ida_idaapi.ea_t) -> cinsn_t &

      Create a new statement. The current statement must be a block. The new statement will be appended to it. 
              
      :param insn_ea: statement address



   .. py:method:: create_if(cnd: cexpr_t) -> cif_t &

      Create a new if-statement. The current statement must be a block. The new statement will be appended to it. 
              
      :param cnd: if condition. It will be deleted after being copied.



   .. py:method:: print1(func: cfunc_t) -> None

      Print the statement into one line. Currently this function is not available. 
              
      :param func: parent function. This argument is used to find out the referenced variable names.



   .. py:method:: is_ordinary_flow() -> bool

      Check if the statement passes execution to the next statement. 
              
      :returns: false if the statement breaks the control flow (like goto, return, etc)



   .. py:method:: contains_insn(type: ctype_t, times: int = 1) -> bool

      Check if the statement contains a statement of the specified type. 
              
      :param type: statement opcode to look for
      :param times: how many times TYPE should be present
      :returns: true if the statement has at least TIMES children with opcode == TYPE



   .. py:method:: collect_free_breaks(breaks: cinsnptrvec_t) -> bool

      Collect free `break` statements. This function finds all free `break` statements within the current statement. A `break` statement is free if it does not have a loop or switch parent that that is also within the current statement. 
              
      :param breaks: pointer to the variable where the vector of all found free `break` statements is returned. This argument can be nullptr.
      :returns: true if some free `break` statements have been found



   .. py:method:: collect_free_continues(continues: cinsnptrvec_t) -> bool

      Collect free `continue` statements. This function finds all free `continue` statements within the current statement. A `continue` statement is free if it does not have a loop parent that that is also within the current statement. 
              
      :param continues: pointer to the variable where the vector of all found free `continue` statements is returned. This argument can be nullptr.
      :returns: true if some free `continue` statements have been found



   .. py:method:: contains_free_break() -> bool

      Check if the statement has free `break` statements.



   .. py:method:: contains_free_continue() -> bool

      Check if the statement has free `continue` statements.



   .. py:method:: dstr() -> str


   .. py:method:: insn_is_epilog(insn: cinsn_t) -> bool
      :staticmethod:



   .. py:method:: is_epilog()


   .. py:property:: cblock


   .. py:property:: cexpr


   .. py:property:: cif


   .. py:property:: cfor


   .. py:property:: cwhile


   .. py:property:: cdo


   .. py:property:: cswitch


   .. py:property:: creturn


   .. py:property:: cgoto


   .. py:property:: casm


.. py:class:: cblock_t

   Bases: :py:obj:`cinsn_list_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: cblock_t) -> int


.. py:class:: carg_t

   Bases: :py:obj:`cexpr_t`


   .. py:attribute:: thisown


   .. py:attribute:: is_vararg
      :type:  bool

      is a vararg (matches ...)



   .. py:attribute:: formal_type
      :type:  tinfo_t

      formal parameter type (if known)



   .. py:method:: consume_cexpr(e: cexpr_t) -> None


   .. py:method:: compare(r: carg_t) -> int


.. py:class:: carglist_t(*args)

   Bases: :py:obj:`qvector_carg_t`


   .. py:attribute:: thisown


   .. py:attribute:: functype
      :type:  tinfo_t

      function object type



   .. py:attribute:: flags
      :type:  int

      call flags



   .. py:method:: compare(r: carglist_t) -> int


.. py:data:: CFL_FINAL

   call type is final, should not be changed


.. py:data:: CFL_HELPER

   created from a decompiler helper function


.. py:data:: CFL_NORET

   call does not return


.. py:class:: ccase_t

   Bases: :py:obj:`cinsn_t`


   .. py:attribute:: thisown


   .. py:attribute:: values
      :type:  uint64vec_t

      List of case values. if empty, then 'default' case 
              



   .. py:method:: compare(r: ccase_t) -> int


   .. py:method:: size() -> size_t


   .. py:method:: value(i: int) -> uint64 const &


.. py:class:: ccases_t

   Bases: :py:obj:`qvector_ccase_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: ccases_t) -> int


.. py:class:: cswitch_t

   Bases: :py:obj:`ceinsn_t`


   .. py:attribute:: thisown


   .. py:attribute:: mvnf
      :type:  cnumber_t

      Maximal switch value and number format.



   .. py:attribute:: cases
      :type:  ccases_t

      Switch cases: values and instructions.



   .. py:method:: compare(r: cswitch_t) -> int


.. py:class:: catchexpr_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: obj
      :type:  cexpr_t

      the caught object. if obj.op==cot_empty, no object. ideally, obj.op==cot_var 
              



   .. py:attribute:: fake_type
      :type:  str

      if not empty, type of the caught object. ideally, obj.type should be enough. however, in some cases the detailed type info is not available. 
              



   .. py:method:: compare(r: catchexpr_t) -> int


   .. py:method:: swap(r: catchexpr_t) -> None


   .. py:method:: is_catch_all() -> bool


.. py:class:: ccatch_t(*args, **kwargs)

   Bases: :py:obj:`cblock_t`


   .. py:attribute:: thisown


   .. py:attribute:: exprs
      :type:  catchexprs_t


   .. py:method:: compare(r: ccatch_t) -> int


   .. py:method:: is_catch_all() -> bool


   .. py:method:: swap(r: ccatch_t) -> None


.. py:class:: ctry_t(*args, **kwargs)

   Bases: :py:obj:`cblock_t`


   .. py:attribute:: thisown


   .. py:attribute:: catchs
      :type:  ccatchvec_t

      "catch all", if present, must be the last element. wind-statements must have "catch all" and nothing else. 
              



   .. py:attribute:: old_state
      :type:  size_t

      old state number (internal, MSVC related)



   .. py:attribute:: new_state
      :type:  size_t

      new state number (internal, MSVC related)



   .. py:attribute:: is_wind
      :type:  bool

      Is C++ wind statement? (not part of the C++ language) MSVC generates code like the following to keep track of constructed objects and destroy them upon an exception. Example:
      // an object is constructed at this point __wind { // some other code that may throw an exception } __unwind { // this code is executed only if there was an exception // in the __wind block. normally here we destroy the object // after that the exception is passed to the // exception handler, regular control flow is interrupted here. } // regular logic continues here, if there were no exceptions // also the object's destructor is called 
              



   .. py:method:: compare(r: ctry_t) -> int


.. py:class:: cthrow_t

   Bases: :py:obj:`ceinsn_t`


   .. py:attribute:: thisown


   .. py:method:: compare(r: cthrow_t) -> int


.. py:class:: cblock_pos_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: blk
      :type:  cblock_t *


   .. py:attribute:: p
      :type:  cblock_t::iterator


   .. py:method:: is_first_insn() -> bool


   .. py:method:: insn() -> cinsn_t *


   .. py:method:: prev_insn() -> cinsn_t *


.. py:class:: ctree_visitor_t(_flags: int)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cv_flags
      :type:  int

      Ctree visitor property bits 
              



   .. py:method:: maintain_parents() -> bool

      Should the parent information by maintained?



   .. py:method:: must_prune() -> bool

      Should the traversal skip the children of the current item?



   .. py:method:: must_restart() -> bool

      Should the traversal restart?



   .. py:method:: is_postorder() -> bool

      Should the leave...() functions be called?



   .. py:method:: only_insns() -> bool

      Should all expressions be automatically pruned?



   .. py:method:: prune_now() -> None

      Prune children. This function may be called by a visitor() to skip all children of the current item. 
              



   .. py:method:: clr_prune() -> None

      Do not prune children. This is an internal function, no need to call it.



   .. py:method:: set_restart() -> None

      Restart the travesal. Meaningful only in apply_to_exprs()



   .. py:method:: clr_restart() -> None

      Do not restart. This is an internal function, no need to call it.



   .. py:attribute:: parents
      :type:  parents_t

      Vector of parents of the current item.



   .. py:attribute:: bposvec
      :type:  cblock_posvec_t

      Vector of block positions. Only cit_block and cit_try parents have the corresponding element in this vector. 
              



   .. py:method:: apply_to(item: citem_t, parent: citem_t) -> int

      Traverse ctree. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
              
      :param item: root of the ctree to traverse
      :param parent: parent of the specified item. can be specified as nullptr.
      :returns: 0 or a non-zero value returned by a visit_...() function



   .. py:method:: apply_to_exprs(item: citem_t, parent: citem_t) -> int

      Traverse only expressions. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
              
      :param item: root of the ctree to traverse
      :param parent: parent of the specified item. can be specified as nullptr.
      :returns: 0 or a non-zero value returned by a visit_...() function



   .. py:method:: parent_item() -> citem_t *

      Get parent of the current item as an item (statement or expression)



   .. py:method:: parent_expr() -> cexpr_t *

      Get parent of the current item as an expression.



   .. py:method:: parent_insn() -> cinsn_t *

      Get parent of the current item as a statement.



   .. py:method:: visit_insn(arg0: cinsn_t) -> int

      Visit a statement. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
              
      :returns: 0 to continue the traversal, nonzero to stop.



   .. py:method:: visit_expr(arg0: cexpr_t) -> int

      Visit an expression. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
              
      :returns: 0 to continue the traversal, nonzero to stop.



   .. py:method:: leave_insn(arg0: cinsn_t) -> int

      Visit a statement after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
              
      :returns: 0 to continue the traversal, nonzero to stop.



   .. py:method:: leave_expr(arg0: cexpr_t) -> int

      Visit an expression after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
              
      :returns: 0 to continue the traversal, nonzero to stop.



.. py:data:: CV_FAST

   do not maintain parent information


.. py:data:: CV_PRUNE

   this bit is set by visit...() to prune the walk


.. py:data:: CV_PARENTS

   maintain parent information


.. py:data:: CV_POST

   call the leave...() functions


.. py:data:: CV_RESTART

   restart enumeration at the top expr (apply_to_exprs)


.. py:data:: CV_INSNS

   visit only statements, prune all expressions do not use before the final ctree maturity because expressions may contain statements at intermediate stages (see cot_insn). Otherwise you risk missing statements embedded into expressions. 
           


.. py:class:: ctree_parentee_t(post: bool = False)

   Bases: :py:obj:`ctree_visitor_t`


   .. py:attribute:: thisown


   .. py:method:: recalc_parent_types() -> bool

      Recalculate type of parent nodes. If a node type has been changed, the visitor must recalculate all parent types, otherwise the ctree becomes inconsistent. If during this recalculation a parent node is added/deleted, this function returns true. In this case the traversal must be stopped because the information about parent nodes is stale. 
              
      :returns: false-ok to continue the traversal, true-must stop.



.. py:class:: cfunc_parentee_t(f: cfunc_t, post: bool = False)

   Bases: :py:obj:`ctree_parentee_t`


   .. py:attribute:: thisown


   .. py:attribute:: func
      :type:  cfunc_t *

      Pointer to current function.



   .. py:method:: calc_rvalue_type(target: tinfo_t, e: cexpr_t) -> bool

      Calculate rvalue type. This function tries to determine the type of the specified item based on its context. For example, if the current expression is the right side of an assignment operator, the type of its left side will be returned. This function can be used to determine the 'best' type of the specified expression. 
              
      :param target: 'best' type of the expression will be returned here
      :param e: expression to determine the desired type
      :returns: false if failed



.. py:class:: ctree_anchor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: value
      :type:  int


   .. py:method:: get_index() -> int


   .. py:method:: get_itp() -> item_preciser_t


   .. py:method:: is_valid_anchor() -> bool


   .. py:method:: is_citem_anchor() -> bool


   .. py:method:: is_lvar_anchor() -> bool


   .. py:method:: is_itp_anchor() -> bool


   .. py:method:: is_blkcmt_anchor() -> bool


.. py:data:: ANCHOR_INDEX

.. py:data:: ANCHOR_MASK

.. py:data:: ANCHOR_CITEM

   c-tree item


.. py:data:: ANCHOR_LVAR

   declaration of local variable


.. py:data:: ANCHOR_ITP

   item type preciser


.. py:data:: ANCHOR_BLKCMT

   block comment (for ctree items)


.. py:data:: VDI_NONE

   undefined


.. py:data:: VDI_EXPR

   c-tree item


.. py:data:: VDI_LVAR

   declaration of local variable


.. py:data:: VDI_FUNC

   the function itself (the very first line with the function prototype)


.. py:data:: VDI_TAIL

   cursor is at (beyond) the line end (commentable line)


.. py:class:: ctree_item_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: citype
      :type:  cursor_item_type_t

      Item type.



   .. py:attribute:: it
      :type:  citem_t *


   .. py:attribute:: e
      :type:  cexpr_t *

      VDI_EXPR: Expression.



   .. py:attribute:: i
      :type:  cinsn_t *

      VDI_EXPR: Statement.



   .. py:attribute:: l
      :type:  lvar_t *

      VDI_LVAR: Local variable.



   .. py:attribute:: f
      :type:  cfunc_t *

      VDI_FUNC: Function.



   .. py:method:: get_udm(udm: udm_t = None, parent: tinfo_t = None, p_offset: uint64 * = None) -> int

      Get type of a structure field. If the current item is a structure/union field, this function will return information about it. 
              
      :param udm: pointer to buffer for the udt member info.
      :param parent: pointer to buffer for the struct/union type.
      :param p_offset: pointer to the offset in bits inside udt.
      :returns: member index or -1 if failed Both output parameters can be nullptr.



   .. py:method:: get_edm(parent: tinfo_t) -> int

      Get type of an enum member. If the current item is a symbolic constant, this function will return information about it. 
              
      :param parent: pointer to buffer for the enum type.
      :returns: member index or -1 if failed



   .. py:method:: get_lvar() -> lvar_t *

      Get pointer to local variable. If the current item is a local variable, this function will return pointer to its definition. 
              
      :returns: nullptr if failed



   .. py:method:: get_ea() -> ida_idaapi.ea_t

      Get address of the current item. Each ctree item has an address. 
              
      :returns: BADADDR if failed



   .. py:method:: get_label_num(gln_flags: int) -> int

      Get label number of the current item. 
              
      :param gln_flags: Combination of get_label_num control bits
      :returns: -1 if failed or no label



   .. py:method:: is_citem() -> bool

      Is the current item is a ctree item?



   .. py:method:: dstr() -> str


   .. py:attribute:: loc
      :type:  treeloc_t *const

      VDI_TAIL: Line tail.



.. py:data:: GLN_CURRENT

   get label of the current item


.. py:data:: GLN_GOTO_TARGET

   get goto target


.. py:data:: GLN_ALL

   get both


.. py:data:: FORBID_UNUSED_LABELS

   Unused labels cause interr.


.. py:data:: ALLOW_UNUSED_LABELS

   Unused labels are permitted.


.. py:function:: save_user_labels(func_ea: ida_idaapi.ea_t, user_labels: user_labels_t, func: cfunc_t = None) -> None

   Save user defined labels into the database. 
           
   :param func_ea: the entry address of the function, ignored if FUNC != nullptr
   :param user_labels: collection of user defined labels
   :param func: pointer to current function, if FUNC != nullptr, then save labels using a more stable method that preserves them even when the decompiler output drastically changes


.. py:function:: save_user_cmts(func_ea: ida_idaapi.ea_t, user_cmts: user_cmts_t) -> None

   Save user defined comments into the database. 
           
   :param func_ea: the entry address of the function
   :param user_cmts: collection of user defined comments


.. py:function:: save_user_numforms(func_ea: ida_idaapi.ea_t, numforms: user_numforms_t) -> None

   Save user defined number formats into the database. 
           
   :param func_ea: the entry address of the function
   :param numforms: collection of user defined comments


.. py:function:: save_user_iflags(func_ea: ida_idaapi.ea_t, iflags: user_iflags_t) -> None

   Save user defined citem iflags into the database. 
           
   :param func_ea: the entry address of the function
   :param iflags: collection of user defined citem iflags


.. py:function:: save_user_unions(func_ea: ida_idaapi.ea_t, unions: user_unions_t) -> None

   Save user defined union field selections into the database. 
           
   :param func_ea: the entry address of the function
   :param unions: collection of union field selections


.. py:function:: restore_user_labels(func_ea: ida_idaapi.ea_t, func: cfunc_t = None) -> user_labels_t *

   Restore user defined labels from the database. 
           
   :param func_ea: the entry address of the function, ignored if FUNC != nullptr
   :param func: pointer to current function
   :returns: collection of user defined labels. The returned object must be deleted by the caller using delete_user_labels()


.. py:function:: restore_user_cmts(func_ea: ida_idaapi.ea_t) -> user_cmts_t *

   Restore user defined comments from the database. 
           
   :param func_ea: the entry address of the function
   :returns: collection of user defined comments. The returned object must be deleted by the caller using delete_user_cmts()


.. py:function:: restore_user_numforms(func_ea: ida_idaapi.ea_t) -> user_numforms_t *

   Restore user defined number formats from the database. 
           
   :param func_ea: the entry address of the function
   :returns: collection of user defined number formats. The returned object must be deleted by the caller using delete_user_numforms()


.. py:function:: restore_user_iflags(func_ea: ida_idaapi.ea_t) -> user_iflags_t *

   Restore user defined citem iflags from the database. 
           
   :param func_ea: the entry address of the function
   :returns: collection of user defined iflags. The returned object must be deleted by the caller using delete_user_iflags()


.. py:function:: restore_user_unions(func_ea: ida_idaapi.ea_t) -> user_unions_t *

   Restore user defined union field selections from the database. 
           
   :param func_ea: the entry address of the function
   :returns: collection of union field selections The returned object must be deleted by the caller using delete_user_unions()


.. py:class:: cfunc_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: entry_ea
      :type:  ida_idaapi.ea_t

      function entry address



   .. py:attribute:: mba
      :type:  mba_t *

      underlying microcode



   .. py:attribute:: body
      :type:  cinsn_t

      function body, must be a block



   .. py:attribute:: argidx
      :type:  intvec_t &

      list of arguments (indexes into vars)



   .. py:attribute:: maturity
      :type:  ctree_maturity_t

      maturity level



   .. py:attribute:: user_labels
      :type:  user_labels_t *

      user-defined labels.



   .. py:attribute:: user_cmts
      :type:  user_cmts_t *

      user-defined comments.



   .. py:attribute:: numforms
      :type:  user_numforms_t *

      user-defined number formats.



   .. py:attribute:: user_iflags
      :type:  user_iflags_t *

      user-defined item flags ctree item iflags bits



   .. py:attribute:: user_unions
      :type:  user_unions_t *

      user-defined union field selections. 
              



   .. py:attribute:: refcnt
      :type:  int

      reference count to this object. use cfuncptr_t



   .. py:attribute:: statebits
      :type:  int

      current cfunc_t state. see cfunc state bits 
              



   .. py:attribute:: hdrlines
      :type:  int

      number of lines in the declaration area



   .. py:attribute:: treeitems
      :type:  citem_pointers_t

      vector of pointers to citem_t objects (nodes constituting the ctree)



   .. py:method:: release() -> None


   .. py:method:: build_c_tree() -> None

      Generate the function body. This function (re)generates the function body from the underlying microcode. 
              



   .. py:method:: verify(aul: allow_unused_labels_t, even_without_debugger: bool) -> None

      Verify the ctree. This function verifies the ctree. If the ctree is malformed, an internal error is generated. Use it to verify the ctree after your modifications. 
              
      :param aul: Are unused labels acceptable?
      :param even_without_debugger: if false and there is no debugger, the verification will be skipped



   .. py:method:: print_dcl() -> None

      Print function prototype. 
              



   .. py:method:: print_func(vp: vc_printer_t) -> None

      Print function text. 
              
      :param vp: printer helper class to receive the generated text.



   .. py:method:: get_func_type(type: tinfo_t) -> bool

      Get the function type. 
              
      :param type: variable where the function type is returned
      :returns: false if failure



   .. py:method:: get_lvars() -> lvars_t *

      Get vector of local variables. 
              
      :returns: pointer to the vector of local variables. If you modify this vector, the ctree must be regenerated in order to have correct cast operators. Use build_c_tree() for that. Removing lvars should be done carefully: all references in ctree and microcode must be corrected after that.



   .. py:method:: get_stkoff_delta() -> int

      Get stack offset delta. The local variable stack offsets retrieved by v.location.stkoff() should be adjusted before being used as stack frame offsets in IDA. 
              
      :returns: the delta to apply. example: ida_stkoff = v.location.stkoff() - f->get_stkoff_delta()



   .. py:method:: find_label(label: int) -> citem_t *

      Find the label. 
              
      :returns: pointer to the ctree item with the specified label number.



   .. py:method:: remove_unused_labels() -> None

      Remove unused labels. This function checks what labels are really used by the function and removes the unused ones. You must call it after deleting a goto statement. 
              



   .. py:method:: get_user_cmt(loc: treeloc_t, rt: cmt_retrieval_type_t) -> str

      Retrieve a user defined comment. 
              
      :param loc: ctree location
      :param rt: should already retrieved comments retrieved again?
      :returns: pointer to the comment string or nullptr



   .. py:method:: set_user_cmt(loc: treeloc_t, cmt: str) -> None

      Set a user defined comment. This function stores the specified comment in the cfunc_t structure. The save_user_cmts() function must be called after it. 
              
      :param loc: ctree location
      :param cmt: new comment. if empty or nullptr, then an existing comment is deleted.



   .. py:method:: get_user_iflags(loc: citem_locator_t) -> int

      Retrieve citem iflags. 
              
      :param loc: citem locator
      :returns: ctree item iflags bits or 0



   .. py:method:: set_user_iflags(loc: citem_locator_t, iflags: int) -> None

      Set citem iflags. 
              
      :param loc: citem locator
      :param iflags: new iflags



   .. py:method:: has_orphan_cmts() -> bool

      Check if there are orphan comments.



   .. py:method:: del_orphan_cmts() -> int

      Delete all orphan comments. The save_user_cmts() function must be called after this call. 
              



   .. py:method:: get_user_union_selection(ea: ida_idaapi.ea_t, path: intvec_t) -> bool

      Retrieve a user defined union field selection. 
              
      :param ea: address
      :param path: out: path describing the union selection.
      :returns: pointer to the path or nullptr



   .. py:method:: set_user_union_selection(ea: ida_idaapi.ea_t, path: intvec_t) -> None

      Set a union field selection. The save_user_unions() function must be called after calling this function. 
              
      :param ea: address
      :param path: in: path describing the union selection.



   .. py:method:: save_user_labels() -> None

      Save user-defined labels into the database.



   .. py:method:: save_user_cmts() -> None

      Save user-defined comments into the database.



   .. py:method:: save_user_numforms() -> None

      Save user-defined number formats into the database.



   .. py:method:: save_user_iflags() -> None

      Save user-defined iflags into the database.



   .. py:method:: save_user_unions() -> None

      Save user-defined union field selections into the database.



   .. py:method:: get_line_item(line: str, x: int, is_ctree_line: bool, phead: ctree_item_t, pitem: ctree_item_t, ptail: ctree_item_t) -> bool

      Get ctree item for the specified cursor position. 
              
      :param line: line of decompilation text (element of sv)
      :param x: x cursor coordinate in the line
      :param is_ctree_line: does the line belong to statement area? (if not, it is assumed to belong to the declaration area)
      :param phead: ptr to the first item on the line (used to attach block comments). May be nullptr
      :param pitem: ptr to the current item. May be nullptr
      :param ptail: ptr to the last item on the line (used to attach indented comments). May be nullptr
      :returns: false if failed to get the current item



   .. py:method:: get_warnings() -> hexwarns_t &

      Get information about decompilation warnings. 
              
      :returns: reference to the vector of warnings



   .. py:method:: get_eamap() -> eamap_t &

      Get pointer to ea->insn map. This function initializes eamap if not done yet. 
              



   .. py:method:: get_boundaries() -> boundaries_t &

      Get pointer to map of instruction boundaries. This function initializes the boundary map if not done yet. 
              



   .. py:method:: get_pseudocode() -> strvec_t const &

      Get pointer to decompilation output: the pseudocode. This function generates pseudocode if not done yet. 
              



   .. py:method:: refresh_func_ctext() -> None

      Refresh ctext after a ctree modification. This function informs the decompiler that ctree (body) have been modified and ctext (sv) does not correspond to it anymore. It also refreshes the pseudocode windows if there is any. 
              



   .. py:method:: recalc_item_addresses() -> None

      Recalculate item adresses. This function may be required after shuffling ctree items. For example, when adding or removing statements of a block, or changing 'if' statements. 
              



   .. py:method:: gather_derefs(ci: ctree_item_t, udm: udt_type_data_t = None) -> bool


   .. py:method:: locked() -> bool


   .. py:method:: find_item_coords(*args)

      This method has the following signatures:

          1. find_item_coords(item: citem_t) -> Tuple[int, int]
          2. find_item_coords(item: citem_t, x: int_pointer, y: int_pointer) -> bool

      NOTE: The second form is retained for backward-compatibility,
      but we strongly recommend using the first.

      :param item: The item to find coordinates for in the pseudocode listing



.. py:data:: CIT_COLLAPSED

   display ctree item in collapsed form


.. py:data:: CFS_BOUNDS

   'eamap' and 'boundaries' are ready


.. py:data:: CFS_TEXT

   'sv' is ready (and hdrlines)


.. py:data:: CFS_LVARS_HIDDEN

   local variable definitions are collapsed


.. py:data:: CFS_LOCKED

   cfunc is temporarily locked


.. py:data:: DECOMP_NO_WAIT

   do not display waitbox


.. py:data:: DECOMP_NO_CACHE

   do not use decompilation cache (snippets are never cached)


.. py:data:: DECOMP_NO_FRAME

   do not use function frame info (only snippet mode)


.. py:data:: DECOMP_WARNINGS

   display warnings in the output window


.. py:data:: DECOMP_ALL_BLKS

   generate microcode for unreachable blocks


.. py:data:: DECOMP_NO_HIDE

   do not close display waitbox. see close_hexrays_waitbox()


.. py:data:: DECOMP_GXREFS_DEFLT

   the default behavior: do not update the global xrefs cache upon decompile() call, but when the pseudocode text is generated (e.g., through cfunc_t.get_pseudocode()) 
           


.. py:data:: DECOMP_GXREFS_NOUPD

   do not update the global xrefs cache


.. py:data:: DECOMP_GXREFS_FORCE

   update the global xrefs cache immediately


.. py:data:: DECOMP_VOID_MBA

   return empty mba object (to be used with gen_microcode)


.. py:data:: DECOMP_OUTLINE

   generate code for an outline


.. py:function:: close_hexrays_waitbox() -> None

   Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_HIDE was used during decompilation. 
           


.. py:function:: decompile(mbr: mba_ranges_t, hf: hexrays_failure_t = None, decomp_flags: int = 0) -> cfuncptr_t

   Decompile a snippet or a function. 
           
   :param mbr: what to decompile
   :param hf: extended error information (if failed)
   :param decomp_flags: bitwise combination of decompile() flags... bits
   :returns: pointer to the decompilation result (a reference counted pointer). nullptr if failed.


.. py:function:: decompile_func(pfn: func_t *, hf: hexrays_failure_t = None, decomp_flags: int = 0) -> cfuncptr_t

   Decompile a function. Multiple decompilations of the same function return the same object. 
           
   :param pfn: pointer to function to decompile
   :param hf: extended error information (if failed)
   :param decomp_flags: bitwise combination of decompile() flags... bits
   :returns: pointer to the decompilation result (a reference counted pointer). nullptr if failed.


.. py:function:: gen_microcode(mbr: mba_ranges_t, hf: hexrays_failure_t = None, retlist: mlist_t = None, decomp_flags: int = 0, reqmat: mba_maturity_t = MMAT_GLBOPT3) -> mba_t *

   Generate microcode of an arbitrary code snippet 
           
   :param mbr: snippet ranges
   :param hf: extended error information (if failed)
   :param retlist: list of registers the snippet returns
   :param decomp_flags: bitwise combination of decompile() flags... bits
   :param reqmat: required microcode maturity
   :returns: pointer to the microcode, nullptr if failed.


.. py:function:: create_empty_mba(mbr: mba_ranges_t, hf: hexrays_failure_t = None) -> mba_t *

   Create an empty microcode object.


.. py:function:: create_cfunc(mba: mba_t) -> cfuncptr_t

   Create a new cfunc_t object. 
           
   :param mba: microcode object. After creating the cfunc object it takes the ownership of MBA.


.. py:function:: mark_cfunc_dirty(ea: ida_idaapi.ea_t, close_views: bool = False) -> bool

   Flush the cached decompilation results. Erases a cache entry for the specified function. 
           
   :param ea: function to erase from the cache
   :param close_views: close pseudocode windows that show the function
   :returns: if a cache entry existed.


.. py:function:: clear_cached_cfuncs() -> None

   Flush all cached decompilation results.


.. py:function:: has_cached_cfunc(ea: ida_idaapi.ea_t) -> bool

   Do we have a cached decompilation result for 'ea'?


.. py:function:: get_ctype_name(op: ctype_t) -> str

.. py:function:: create_field_name(*args) -> str

.. py:data:: hxe_flowchart

   Flowchart has been generated. 
             


.. py:data:: hxe_stkpnts

   SP change points have been calculated. 
             


.. py:data:: hxe_prolog

   Prolog analysis has been finished. 
             


.. py:data:: hxe_microcode

   Microcode has been generated. 
             


.. py:data:: hxe_preoptimized

   Microcode has been preoptimized. 
             


.. py:data:: hxe_locopt

   Basic block level optimization has been finished. 
             


.. py:data:: hxe_prealloc

   Local variables: preallocation step begins. 
             


.. py:data:: hxe_glbopt

   Global optimization has been finished. If microcode is modified, MERR_LOOP must be returned. It will cause a complete restart of the optimization. 
             


.. py:data:: hxe_pre_structural

   Structure analysis is starting. 
             


.. py:data:: hxe_structural

   Structural analysis has been finished. 
             


.. py:data:: hxe_maturity

   Ctree maturity level is being changed. 
             


.. py:data:: hxe_interr

   Internal error has occurred. 
             


.. py:data:: hxe_combine

   Trying to combine instructions of basic block. 
             


.. py:data:: hxe_print_func

   Printing ctree and generating text. 
             


.. py:data:: hxe_func_printed

   Function text has been generated. Plugins may modify the text in cfunc_t::sv. However, it is too late to modify the ctree or microcode. The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store pointers to ctree items. 
             


.. py:data:: hxe_resolve_stkaddrs

   The optimizer is about to resolve stack addresses. 
             


.. py:data:: hxe_build_callinfo

   Analyzing a call instruction. 
             


.. py:data:: hxe_callinfo_built

   A call instruction has been anallyzed. 
             


.. py:data:: hxe_calls_done

   All calls have been analyzed. 
             


.. py:data:: hxe_begin_inlining

   Starting to inline outlined functions. 
             


.. py:data:: hxe_inlining_func

   A set of ranges is going to be inlined. 
             


.. py:data:: hxe_inlined_func

   A set of ranges got inlined. 
             


.. py:data:: hxe_collect_warnings

   Collect warning messages from plugins. These warnings will be displayed at the function header, after the user-defined comments. 
             


.. py:data:: hxe_open_pseudocode

   New pseudocode view has been opened. 
             


.. py:data:: hxe_switch_pseudocode

   Existing pseudocode view has been reloaded with a new function. Its text has not been refreshed yet, only cfunc and mba pointers are ready. 
             


.. py:data:: hxe_refresh_pseudocode

   Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is forbidden in this event. 
             


.. py:data:: hxe_close_pseudocode

   Pseudocode view is being closed. 
             


.. py:data:: hxe_keyboard

   Keyboard has been hit. 
             


.. py:data:: hxe_right_click

   Mouse right click. Use hxe_populating_popup instead, in case you want to add items in the popup menu. 
             


.. py:data:: hxe_double_click

   Mouse double click. 
             


.. py:data:: hxe_curpos

   Current cursor position has been changed. (for example, by left-clicking or using keyboard)

             


.. py:data:: hxe_create_hint

   Create a hint for the current item. 
             


.. py:data:: hxe_text_ready

   Decompiled text is ready. 
             


.. py:data:: hxe_populating_popup

   Populating popup menu. We can add menu items now. 
             


.. py:data:: lxe_lvar_name_changed

   Local variable got renamed. 
             


.. py:data:: lxe_lvar_type_changed

   Local variable type got changed. 
             


.. py:data:: lxe_lvar_cmt_changed

   Local variable comment got changed. 
             


.. py:data:: lxe_lvar_mapping_changed

   Local variable mapping got changed. 
             


.. py:data:: hxe_cmt_changed

   Comment got changed. 
             


.. py:data:: hxe_mba_maturity

   Maturity level of an MBA was changed. 
             


.. py:data:: USE_KEYBOARD

   Keyboard.


.. py:data:: USE_MOUSE

   Mouse.


.. py:class:: ctext_position_t(_lnnum: int = -1, _x: int = 0, _y: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: lnnum
      :type:  int

      Line number.



   .. py:attribute:: x
      :type:  int

      x coordinate of the cursor within the window



   .. py:attribute:: y
      :type:  int

      y coordinate of the cursor within the window 
              



   .. py:method:: in_ctree(hdrlines: int) -> bool

      Is the cursor in the variable/type declaration area? 
              
      :param hdrlines: Number of lines of the declaration area



   .. py:method:: compare(r: ctext_position_t) -> int


.. py:data:: HEXRAYS_API_MAGIC

.. py:class:: history_item_t(*args)

   Bases: :py:obj:`ctext_position_t`


   .. py:attribute:: thisown


   .. py:attribute:: func_ea
      :type:  ida_idaapi.ea_t

      The entry address of the decompiled function.



   .. py:attribute:: curr_ea
      :type:  ida_idaapi.ea_t

      Current address.



   .. py:attribute:: end
      :type:  ida_idaapi.ea_t

      BADADDR-decompile a function; otherwise end of the range.



.. py:class:: vdui_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int

      Properties of pseudocode window 
              



   .. py:method:: visible() -> bool

      Is the pseudocode window visible? if not, it might be invisible or destroyed 
              



   .. py:method:: valid() -> bool

      Does the pseudocode window contain valid code? It can become invalid if the function type gets changed in IDA. 
              



   .. py:method:: locked() -> bool

      Does the pseudocode window contain valid code? We lock windows before modifying them, to avoid recursion due to the events generated by the IDA kernel. 
              
      :returns: true: The window is locked and may have stale info



   .. py:method:: set_visible(v: bool) -> None


   .. py:method:: set_valid(v: bool) -> None


   .. py:method:: set_locked(v: bool) -> bool


   .. py:attribute:: view_idx
      :type:  int

      pseudocode window index (0..)



   .. py:attribute:: ct
      :type:  TWidget *

      pseudocode view



   .. py:attribute:: toplevel
      :type:  TWidget *


   .. py:attribute:: mba
      :type:  mba_t *

      pointer to underlying microcode



   .. py:attribute:: cfunc
      :type:  cfuncptr_t

      pointer to function object



   .. py:attribute:: last_code
      :type:  merror_t

      result of the last user action. See Microcode error code



   .. py:attribute:: cpos
      :type:  ctext_position_t

      Current ctext position.



   .. py:attribute:: head
      :type:  ctree_item_t

      First ctree item on the current line (for block comments)



   .. py:attribute:: item
      :type:  ctree_item_t

      Current ctree item.



   .. py:attribute:: tail
      :type:  ctree_item_t

      Tail ctree item on the current line (for indented comments)



   .. py:method:: refresh_view(redo_mba: bool) -> None

      Refresh pseudocode window. This is the highest level refresh function. It causes the most profound refresh possible and can lead to redecompilation of the current function. Please consider using refresh_ctext() if you need a more superficial refresh. 
              
      :param redo_mba: true means to redecompile the current function
       false means to rebuild ctree without regenerating microcode



   .. py:method:: refresh_ctext(activate: bool = True) -> None

      Refresh pseudocode window. This function refreshes the pseudocode window by regenerating its text from cfunc_t. Instead of this function use refresh_func_ctext(), which refreshes all pseudocode windows for the function. 
              



   .. py:method:: switch_to(f: cfuncptr_t, activate: bool) -> None

      Display the specified pseudocode. This function replaces the pseudocode window contents with the specified cfunc_t. 
              
      :param f: pointer to the function to display.
      :param activate: should the pseudocode window get focus?



   .. py:method:: in_ctree() -> bool

      Is the current item a statement?

      :returns: false if the cursor is in the local variable/type declaration area
       true if the cursor is in the statement area



   .. py:method:: get_number() -> cnumber_t *

      Get current number. If the current item is a number, return pointer to it. 
              
      :returns: nullptr if the current item is not a number This function returns non-null for the cases of a 'switch' statement Also, if the current item is a casted number, then this function will succeed.



   .. py:method:: get_current_label() -> int

      Get current label. If there is a label under the cursor, return its number. 
              
      :returns: -1 if there is no label under the cursor. prereq: get_current_item() has been called



   .. py:method:: clear() -> None

      Clear the pseudocode window. It deletes the current function and microcode. 
              



   .. py:method:: refresh_cpos(idv: input_device_t) -> bool

      Refresh the current position. This function refreshes the cpos field. 
              
      :param idv: keyboard or mouse
      :returns: false if failed



   .. py:method:: get_current_item(idv: input_device_t) -> bool

      Get current item. This function refreshes the cpos, item, tail fields. 
              
      :param idv: keyboard or mouse
      :returns: false if failed



   .. py:method:: ui_rename_lvar(v: lvar_t) -> bool

      Rename local variable. This function displays a dialog box and allows the user to rename a local variable. 
              
      :param v: pointer to local variable
      :returns: false if failed or cancelled



   .. py:method:: rename_lvar(v: lvar_t, name: str, is_user_name: bool) -> bool

      Rename local variable. This function permanently renames a local variable. 
              
      :param v: pointer to local variable
      :param name: new variable name
      :param is_user_name: use true to save the new name into the database. use false to delete the saved name.
      :returns: false if failed



   .. py:method:: ui_set_call_type(e: cexpr_t) -> bool

      Set type of a function call This function displays a dialog box and allows the user to change the type of a function call 
              
      :param e: pointer to call expression
      :returns: false if failed or cancelled



   .. py:method:: ui_set_lvar_type(v: lvar_t) -> bool

      Set local variable type. This function displays a dialog box and allows the user to change the type of a local variable. 
              
      :param v: pointer to local variable
      :returns: false if failed or cancelled



   .. py:method:: set_lvar_type(v: lvar_t, type: tinfo_t) -> bool

      Set local variable type. This function permanently sets a local variable type and clears NOPTR flag if it was set before by function 'set_noptr_lvar' 
              
      :param v: pointer to local variable
      :param type: new variable type
      :returns: false if failed



   .. py:method:: set_noptr_lvar(v: lvar_t) -> bool

      Inform that local variable should have a non-pointer type This function permanently sets a corresponding variable flag (NOPTR) and removes type if it was set before by function 'set_lvar_type' 
              
      :param v: pointer to local variable
      :returns: false if failed



   .. py:method:: ui_edit_lvar_cmt(v: lvar_t) -> bool

      Set local variable comment. This function displays a dialog box and allows the user to edit the comment of a local variable. 
              
      :param v: pointer to local variable
      :returns: false if failed or cancelled



   .. py:method:: set_lvar_cmt(v: lvar_t, cmt: str) -> bool

      Set local variable comment. This function permanently sets a variable comment. 
              
      :param v: pointer to local variable
      :param cmt: new comment
      :returns: false if failed



   .. py:method:: ui_map_lvar(v: lvar_t) -> bool

      Map a local variable to another. This function displays a variable list and allows the user to select mapping. 
              
      :param v: pointer to local variable
      :returns: false if failed or cancelled



   .. py:method:: ui_unmap_lvar(v: lvar_t) -> bool

      Unmap a local variable. This function displays list of variables mapped to the specified variable and allows the user to select a variable to unmap. 
              
      :param v: pointer to local variable
      :returns: false if failed or cancelled



   .. py:method:: map_lvar(frm: lvar_t, to: lvar_t) -> bool

      Map a local variable to another. This function permanently maps one lvar to another. All occurrences of the mapped variable are replaced by the new variable 
              
      :param to: the variable to map to. if nullptr, unmaps the variable
      :returns: false if failed



   .. py:method:: set_udm_type(udt_type: tinfo_t, udm_idx: int) -> bool

      Set structure field type. This function displays a dialog box and allows the user to change the type of a structure field. 
              
      :param udt_type: structure/union type
      :param udm_idx: index of the structure/union member
      :returns: false if failed or cancelled



   .. py:method:: rename_udm(udt_type: tinfo_t, udm_idx: int) -> bool

      Rename structure field. This function displays a dialog box and allows the user to rename a structure field. 
              
      :param udt_type: structure/union type
      :param udm_idx: index of the structure/union member
      :returns: false if failed or cancelled



   .. py:method:: set_global_type(ea: ida_idaapi.ea_t) -> bool

      Set global item type. This function displays a dialog box and allows the user to change the type of a global item (data or function). 
              
      :param ea: address of the global item
      :returns: false if failed or cancelled



   .. py:method:: rename_global(ea: ida_idaapi.ea_t) -> bool

      Rename global item. This function displays a dialog box and allows the user to rename a global item (data or function). 
              
      :param ea: address of the global item
      :returns: false if failed or cancelled



   .. py:method:: rename_label(label: int) -> bool

      Rename a label. This function displays a dialog box and allows the user to rename a statement label. 
              
      :param label: label number
      :returns: false if failed or cancelled



   .. py:method:: jump_enter(idv: input_device_t, omflags: int) -> bool

      Process the Enter key. This function jumps to the definition of the item under the cursor. If the current item is a function, it will be decompiled. If the current item is a global data, its disassemly text will be displayed. 
              
      :param idv: what cursor must be used, the keyboard or the mouse
      :param omflags: OM_NEWWIN: new pseudocode window will open, 0: reuse the existing window
      :returns: false if failed



   .. py:method:: ctree_to_disasm() -> bool

      Jump to disassembly. This function jumps to the address in the disassembly window which corresponds to the current item. The current item is determined based on the current keyboard cursor position. 
              
      :returns: false if failed



   .. py:method:: calc_cmt_type(lnnum: size_t, cmttype: cmt_type_t) -> cmt_type_t

      Check if the specified line can have a comment. Due to the coordinate system for comments: ([https://hex-rays.com/blog/coordinate-system-for-hex-rays](https://hex-rays.com/blog/coordinate-system-for-hex-rays)) some function lines cannot have comments. This function checks if a comment can be attached to the specified line. 
              
      :param lnnum: line number (0 based)
      :param cmttype: comment types to check
      :returns: possible comment types



   .. py:method:: edit_cmt(loc: treeloc_t) -> bool

      Edit an indented comment. This function displays a dialog box and allows the user to edit the comment for the specified ctree location. 
              
      :param loc: comment location
      :returns: false if failed or cancelled



   .. py:method:: edit_func_cmt() -> bool

      Edit a function comment. This function displays a dialog box and allows the user to edit the function comment. 
              
      :returns: false if failed or cancelled



   .. py:method:: del_orphan_cmts() -> bool

      Delete all orphan comments. Delete all orphan comments and refresh the screen. 
              
      :returns: true



   .. py:method:: set_num_radix(base: int) -> bool

      Change number base. This function changes the current number representation. 
              
      :param base: number radix (10 or 16)
       0 means a character constant
      :returns: false if failed



   .. py:method:: set_num_enum() -> bool

      Convert number to symbolic constant. This function displays a dialog box and allows the user to select a symbolic constant to represent the number. 
              
      :returns: false if failed or cancelled



   .. py:method:: set_num_stroff() -> bool

      Convert number to structure field offset. Currently not implemented. 
              
      :returns: false if failed or cancelled



   .. py:method:: invert_sign() -> bool

      Negate a number. This function negates the current number. 
              
      :returns: false if failed.



   .. py:method:: invert_bits() -> bool

      Bitwise negate a number. This function inverts all bits of the current number. 
              
      :returns: false if failed.



   .. py:method:: collapse_item(hide: bool) -> bool

      Collapse/uncollapse item. This function collapses the current item. 
              
      :returns: false if failed.



   .. py:method:: collapse_lvars(hide: bool) -> bool

      Collapse/uncollapse local variable declarations. 
              
      :returns: false if failed.



   .. py:method:: split_item(split: bool) -> bool

      Split/unsplit item. This function splits the current assignment expression. 
              
      :returns: false if failed.



.. py:data:: CMT_NONE

   No comment is possible.


.. py:data:: CMT_TAIL

   Indented comment.


.. py:data:: CMT_BLOCK1

   Anterioir block comment.


.. py:data:: CMT_BLOCK2

   Posterior block comment.


.. py:data:: CMT_LVAR

   Local variable comment.


.. py:data:: CMT_FUNC

   Function comment.


.. py:data:: CMT_ALL

   All comments.


.. py:data:: VDUI_VISIBLE

   is visible?


.. py:data:: VDUI_VALID

   is valid?


.. py:class:: ui_stroff_op_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: text
      :type:  str

      any text for the column "Operand" of widget



   .. py:attribute:: offset
      :type:  int

      operand offset, will be used when calculating the UDT path



.. py:class:: ui_stroff_applicator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: apply(opnum: size_t, path: intvec_t, top_tif: tinfo_t, spath: str) -> bool

      :param opnum: operand ordinal number, see below
      :param path: path describing the union selection, maybe empty
      :param top_tif: tinfo_t of the selected toplevel UDT
      :param spath: selected path



.. py:function:: select_udt_by_offset(udts: qvector< tinfo_t > const *, ops: ui_stroff_ops_t, applicator: ui_stroff_applicator_t) -> int

   Select UDT 
           
   :param udts: list of UDT tinfo_t for the selection, if nullptr or empty then UDTs from the "Local types" will be used
   :param ops: operands
   :param applicator: callback will be called to apply the selection for every operand


.. py:data:: hx_user_numforms_begin

.. py:data:: hx_user_numforms_end

.. py:data:: hx_user_numforms_next

.. py:data:: hx_user_numforms_prev

.. py:data:: hx_user_numforms_first

.. py:data:: hx_user_numforms_second

.. py:data:: hx_user_numforms_find

.. py:data:: hx_user_numforms_insert

.. py:data:: hx_user_numforms_erase

.. py:data:: hx_user_numforms_clear

.. py:data:: hx_user_numforms_size

.. py:data:: hx_user_numforms_free

.. py:data:: hx_user_numforms_new

.. py:data:: hx_lvar_mapping_begin

.. py:data:: hx_lvar_mapping_end

.. py:data:: hx_lvar_mapping_next

.. py:data:: hx_lvar_mapping_prev

.. py:data:: hx_lvar_mapping_first

.. py:data:: hx_lvar_mapping_second

.. py:data:: hx_lvar_mapping_find

.. py:data:: hx_lvar_mapping_insert

.. py:data:: hx_lvar_mapping_erase

.. py:data:: hx_lvar_mapping_clear

.. py:data:: hx_lvar_mapping_size

.. py:data:: hx_lvar_mapping_free

.. py:data:: hx_lvar_mapping_new

.. py:data:: hx_udcall_map_begin

.. py:data:: hx_udcall_map_end

.. py:data:: hx_udcall_map_next

.. py:data:: hx_udcall_map_prev

.. py:data:: hx_udcall_map_first

.. py:data:: hx_udcall_map_second

.. py:data:: hx_udcall_map_find

.. py:data:: hx_udcall_map_insert

.. py:data:: hx_udcall_map_erase

.. py:data:: hx_udcall_map_clear

.. py:data:: hx_udcall_map_size

.. py:data:: hx_udcall_map_free

.. py:data:: hx_udcall_map_new

.. py:data:: hx_user_cmts_begin

.. py:data:: hx_user_cmts_end

.. py:data:: hx_user_cmts_next

.. py:data:: hx_user_cmts_prev

.. py:data:: hx_user_cmts_first

.. py:data:: hx_user_cmts_second

.. py:data:: hx_user_cmts_find

.. py:data:: hx_user_cmts_insert

.. py:data:: hx_user_cmts_erase

.. py:data:: hx_user_cmts_clear

.. py:data:: hx_user_cmts_size

.. py:data:: hx_user_cmts_free

.. py:data:: hx_user_cmts_new

.. py:data:: hx_user_iflags_begin

.. py:data:: hx_user_iflags_end

.. py:data:: hx_user_iflags_next

.. py:data:: hx_user_iflags_prev

.. py:data:: hx_user_iflags_first

.. py:data:: hx_user_iflags_second

.. py:data:: hx_user_iflags_find

.. py:data:: hx_user_iflags_insert

.. py:data:: hx_user_iflags_erase

.. py:data:: hx_user_iflags_clear

.. py:data:: hx_user_iflags_size

.. py:data:: hx_user_iflags_free

.. py:data:: hx_user_iflags_new

.. py:data:: hx_user_unions_begin

.. py:data:: hx_user_unions_end

.. py:data:: hx_user_unions_next

.. py:data:: hx_user_unions_prev

.. py:data:: hx_user_unions_first

.. py:data:: hx_user_unions_second

.. py:data:: hx_user_unions_find

.. py:data:: hx_user_unions_insert

.. py:data:: hx_user_unions_erase

.. py:data:: hx_user_unions_clear

.. py:data:: hx_user_unions_size

.. py:data:: hx_user_unions_free

.. py:data:: hx_user_unions_new

.. py:data:: hx_user_labels_begin

.. py:data:: hx_user_labels_end

.. py:data:: hx_user_labels_next

.. py:data:: hx_user_labels_prev

.. py:data:: hx_user_labels_first

.. py:data:: hx_user_labels_second

.. py:data:: hx_user_labels_find

.. py:data:: hx_user_labels_insert

.. py:data:: hx_user_labels_erase

.. py:data:: hx_user_labels_clear

.. py:data:: hx_user_labels_size

.. py:data:: hx_user_labels_free

.. py:data:: hx_user_labels_new

.. py:data:: hx_eamap_begin

.. py:data:: hx_eamap_end

.. py:data:: hx_eamap_next

.. py:data:: hx_eamap_prev

.. py:data:: hx_eamap_first

.. py:data:: hx_eamap_second

.. py:data:: hx_eamap_find

.. py:data:: hx_eamap_insert

.. py:data:: hx_eamap_erase

.. py:data:: hx_eamap_clear

.. py:data:: hx_eamap_size

.. py:data:: hx_eamap_free

.. py:data:: hx_eamap_new

.. py:data:: hx_boundaries_begin

.. py:data:: hx_boundaries_end

.. py:data:: hx_boundaries_next

.. py:data:: hx_boundaries_prev

.. py:data:: hx_boundaries_first

.. py:data:: hx_boundaries_second

.. py:data:: hx_boundaries_find

.. py:data:: hx_boundaries_insert

.. py:data:: hx_boundaries_erase

.. py:data:: hx_boundaries_clear

.. py:data:: hx_boundaries_size

.. py:data:: hx_boundaries_free

.. py:data:: hx_boundaries_new

.. py:data:: hx_block_chains_begin

.. py:data:: hx_block_chains_end

.. py:data:: hx_block_chains_next

.. py:data:: hx_block_chains_prev

.. py:data:: hx_block_chains_get

.. py:data:: hx_block_chains_find

.. py:data:: hx_block_chains_insert

.. py:data:: hx_block_chains_erase

.. py:data:: hx_block_chains_clear

.. py:data:: hx_block_chains_size

.. py:data:: hx_block_chains_free

.. py:data:: hx_block_chains_new

.. py:data:: hx_hexrays_alloc

.. py:data:: hx_hexrays_free

.. py:data:: hx_valrng_t_clear

.. py:data:: hx_valrng_t_copy

.. py:data:: hx_valrng_t_assign

.. py:data:: hx_valrng_t_compare

.. py:data:: hx_valrng_t_set_eq

.. py:data:: hx_valrng_t_set_cmp

.. py:data:: hx_valrng_t_reduce_size

.. py:data:: hx_valrng_t_intersect_with

.. py:data:: hx_valrng_t_unite_with

.. py:data:: hx_valrng_t_inverse

.. py:data:: hx_valrng_t_has

.. py:data:: hx_valrng_t_print

.. py:data:: hx_valrng_t_dstr

.. py:data:: hx_valrng_t_cvt_to_single_value

.. py:data:: hx_valrng_t_cvt_to_cmp

.. py:data:: hx_get_merror_desc

.. py:data:: hx_must_mcode_close_block

.. py:data:: hx_is_mcode_propagatable

.. py:data:: hx_negate_mcode_relation

.. py:data:: hx_swap_mcode_relation

.. py:data:: hx_get_signed_mcode

.. py:data:: hx_get_unsigned_mcode

.. py:data:: hx_mcode_modifies_d

.. py:data:: hx_operand_locator_t_compare

.. py:data:: hx_vd_printer_t_print

.. py:data:: hx_file_printer_t_print

.. py:data:: hx_qstring_printer_t_print

.. py:data:: hx_dstr

.. py:data:: hx_is_type_correct

.. py:data:: hx_is_small_udt

.. py:data:: hx_is_nonbool_type

.. py:data:: hx_is_bool_type

.. py:data:: hx_partial_type_num

.. py:data:: hx_get_float_type

.. py:data:: hx_get_int_type_by_width_and_sign

.. py:data:: hx_get_unk_type

.. py:data:: hx_dummy_ptrtype

.. py:data:: hx_get_member_type

.. py:data:: hx_make_pointer

.. py:data:: hx_create_typedef

.. py:data:: hx_get_type

.. py:data:: hx_set_type

.. py:data:: hx_vdloc_t_dstr

.. py:data:: hx_vdloc_t_compare

.. py:data:: hx_vdloc_t_is_aliasable

.. py:data:: hx_print_vdloc

.. py:data:: hx_arglocs_overlap

.. py:data:: hx_lvar_locator_t_compare

.. py:data:: hx_lvar_locator_t_dstr

.. py:data:: hx_lvar_t_dstr

.. py:data:: hx_lvar_t_is_promoted_arg

.. py:data:: hx_lvar_t_accepts_type

.. py:data:: hx_lvar_t_set_lvar_type

.. py:data:: hx_lvar_t_set_width

.. py:data:: hx_lvar_t_append_list

.. py:data:: hx_lvar_t_append_list_

.. py:data:: hx_lvars_t_find_stkvar

.. py:data:: hx_lvars_t_find

.. py:data:: hx_lvars_t_find_lvar

.. py:data:: hx_restore_user_lvar_settings

.. py:data:: hx_save_user_lvar_settings

.. py:data:: hx_modify_user_lvars

.. py:data:: hx_modify_user_lvar_info

.. py:data:: hx_locate_lvar

.. py:data:: hx_restore_user_defined_calls

.. py:data:: hx_save_user_defined_calls

.. py:data:: hx_parse_user_call

.. py:data:: hx_convert_to_user_call

.. py:data:: hx_install_microcode_filter

.. py:data:: hx_udc_filter_t_cleanup

.. py:data:: hx_udc_filter_t_init

.. py:data:: hx_udc_filter_t_apply

.. py:data:: hx_bitset_t_bitset_t

.. py:data:: hx_bitset_t_copy

.. py:data:: hx_bitset_t_add

.. py:data:: hx_bitset_t_add_

.. py:data:: hx_bitset_t_add__

.. py:data:: hx_bitset_t_sub

.. py:data:: hx_bitset_t_sub_

.. py:data:: hx_bitset_t_sub__

.. py:data:: hx_bitset_t_cut_at

.. py:data:: hx_bitset_t_shift_down

.. py:data:: hx_bitset_t_has

.. py:data:: hx_bitset_t_has_all

.. py:data:: hx_bitset_t_has_any

.. py:data:: hx_bitset_t_dstr

.. py:data:: hx_bitset_t_empty

.. py:data:: hx_bitset_t_count

.. py:data:: hx_bitset_t_count_

.. py:data:: hx_bitset_t_last

.. py:data:: hx_bitset_t_fill_with_ones

.. py:data:: hx_bitset_t_fill_gaps

.. py:data:: hx_bitset_t_has_common

.. py:data:: hx_bitset_t_intersect

.. py:data:: hx_bitset_t_is_subset_of

.. py:data:: hx_bitset_t_compare

.. py:data:: hx_bitset_t_goup

.. py:data:: hx_ivl_t_dstr

.. py:data:: hx_ivl_t_compare

.. py:data:: hx_ivlset_t_add

.. py:data:: hx_ivlset_t_add_

.. py:data:: hx_ivlset_t_addmasked

.. py:data:: hx_ivlset_t_sub

.. py:data:: hx_ivlset_t_sub_

.. py:data:: hx_ivlset_t_has_common

.. py:data:: hx_ivlset_t_print

.. py:data:: hx_ivlset_t_dstr

.. py:data:: hx_ivlset_t_count

.. py:data:: hx_ivlset_t_has_common_

.. py:data:: hx_ivlset_t_contains

.. py:data:: hx_ivlset_t_includes

.. py:data:: hx_ivlset_t_intersect

.. py:data:: hx_ivlset_t_compare

.. py:data:: hx_rlist_t_print

.. py:data:: hx_rlist_t_dstr

.. py:data:: hx_mlist_t_addmem

.. py:data:: hx_mlist_t_print

.. py:data:: hx_mlist_t_dstr

.. py:data:: hx_mlist_t_compare

.. py:data:: hx_get_temp_regs

.. py:data:: hx_is_kreg

.. py:data:: hx_reg2mreg

.. py:data:: hx_mreg2reg

.. py:data:: hx_get_mreg_name

.. py:data:: hx_install_optinsn_handler

.. py:data:: hx_remove_optinsn_handler

.. py:data:: hx_install_optblock_handler

.. py:data:: hx_remove_optblock_handler

.. py:data:: hx_simple_graph_t_compute_dominators

.. py:data:: hx_simple_graph_t_compute_immediate_dominators

.. py:data:: hx_simple_graph_t_depth_first_preorder

.. py:data:: hx_simple_graph_t_depth_first_postorder

.. py:data:: hx_simple_graph_t_goup

.. py:data:: hx_mutable_graph_t_resize

.. py:data:: hx_mutable_graph_t_goup

.. py:data:: hx_mutable_graph_t_del_edge

.. py:data:: hx_lvar_ref_t_compare

.. py:data:: hx_lvar_ref_t_var

.. py:data:: hx_stkvar_ref_t_compare

.. py:data:: hx_stkvar_ref_t_get_stkvar

.. py:data:: hx_fnumber_t_print

.. py:data:: hx_fnumber_t_dstr

.. py:data:: hx_mop_t_copy

.. py:data:: hx_mop_t_assign

.. py:data:: hx_mop_t_swap

.. py:data:: hx_mop_t_erase

.. py:data:: hx_mop_t_print

.. py:data:: hx_mop_t_dstr

.. py:data:: hx_mop_t_create_from_mlist

.. py:data:: hx_mop_t_create_from_ivlset

.. py:data:: hx_mop_t_create_from_vdloc

.. py:data:: hx_mop_t_create_from_scattered_vdloc

.. py:data:: hx_mop_t_create_from_insn

.. py:data:: hx_mop_t_make_number

.. py:data:: hx_mop_t_make_fpnum

.. py:data:: hx_mop_t__make_gvar

.. py:data:: hx_mop_t_make_gvar

.. py:data:: hx_mop_t_make_reg_pair

.. py:data:: hx_mop_t_make_helper

.. py:data:: hx_mop_t_is_bit_reg

.. py:data:: hx_mop_t_may_use_aliased_memory

.. py:data:: hx_mop_t_is01

.. py:data:: hx_mop_t_is_sign_extended_from

.. py:data:: hx_mop_t_is_zero_extended_from

.. py:data:: hx_mop_t_equal_mops

.. py:data:: hx_mop_t_lexcompare

.. py:data:: hx_mop_t_for_all_ops

.. py:data:: hx_mop_t_for_all_scattered_submops

.. py:data:: hx_mop_t_is_constant

.. py:data:: hx_mop_t_get_stkoff

.. py:data:: hx_mop_t_make_low_half

.. py:data:: hx_mop_t_make_high_half

.. py:data:: hx_mop_t_make_first_half

.. py:data:: hx_mop_t_make_second_half

.. py:data:: hx_mop_t_shift_mop

.. py:data:: hx_mop_t_change_size

.. py:data:: hx_mop_t_preserve_side_effects

.. py:data:: hx_mop_t_apply_ld_mcode

.. py:data:: hx_mcallarg_t_print

.. py:data:: hx_mcallarg_t_dstr

.. py:data:: hx_mcallarg_t_set_regarg

.. py:data:: hx_mcallinfo_t_lexcompare

.. py:data:: hx_mcallinfo_t_set_type

.. py:data:: hx_mcallinfo_t_get_type

.. py:data:: hx_mcallinfo_t_print

.. py:data:: hx_mcallinfo_t_dstr

.. py:data:: hx_mcases_t_compare

.. py:data:: hx_mcases_t_print

.. py:data:: hx_mcases_t_dstr

.. py:data:: hx_vivl_t_extend_to_cover

.. py:data:: hx_vivl_t_intersect

.. py:data:: hx_vivl_t_print

.. py:data:: hx_vivl_t_dstr

.. py:data:: hx_chain_t_print

.. py:data:: hx_chain_t_dstr

.. py:data:: hx_chain_t_append_list

.. py:data:: hx_chain_t_append_list_

.. py:data:: hx_block_chains_t_get_chain

.. py:data:: hx_block_chains_t_print

.. py:data:: hx_block_chains_t_dstr

.. py:data:: hx_graph_chains_t_for_all_chains

.. py:data:: hx_graph_chains_t_release

.. py:data:: hx_minsn_t_init

.. py:data:: hx_minsn_t_copy

.. py:data:: hx_minsn_t_set_combined

.. py:data:: hx_minsn_t_swap

.. py:data:: hx_minsn_t_print

.. py:data:: hx_minsn_t_dstr

.. py:data:: hx_minsn_t_setaddr

.. py:data:: hx_minsn_t_optimize_subtree

.. py:data:: hx_minsn_t_for_all_ops

.. py:data:: hx_minsn_t_for_all_insns

.. py:data:: hx_minsn_t__make_nop

.. py:data:: hx_minsn_t_equal_insns

.. py:data:: hx_minsn_t_lexcompare

.. py:data:: hx_minsn_t_is_noret_call

.. py:data:: hx_minsn_t_is_helper

.. py:data:: hx_minsn_t_find_call

.. py:data:: hx_minsn_t_has_side_effects

.. py:data:: hx_minsn_t_find_opcode

.. py:data:: hx_minsn_t_find_ins_op

.. py:data:: hx_minsn_t_find_num_op

.. py:data:: hx_minsn_t_modifies_d

.. py:data:: hx_minsn_t_is_between

.. py:data:: hx_minsn_t_may_use_aliased_memory

.. py:data:: hx_minsn_t_serialize

.. py:data:: hx_minsn_t_deserialize

.. py:data:: hx_getf_reginsn

.. py:data:: hx_getb_reginsn

.. py:data:: hx_mblock_t_init

.. py:data:: hx_mblock_t_print

.. py:data:: hx_mblock_t_dump

.. py:data:: hx_mblock_t_vdump_block

.. py:data:: hx_mblock_t_insert_into_block

.. py:data:: hx_mblock_t_remove_from_block

.. py:data:: hx_mblock_t_for_all_insns

.. py:data:: hx_mblock_t_for_all_ops

.. py:data:: hx_mblock_t_for_all_uses

.. py:data:: hx_mblock_t_optimize_insn

.. py:data:: hx_mblock_t_optimize_block

.. py:data:: hx_mblock_t_build_lists

.. py:data:: hx_mblock_t_optimize_useless_jump

.. py:data:: hx_mblock_t_append_use_list

.. py:data:: hx_mblock_t_append_def_list

.. py:data:: hx_mblock_t_build_use_list

.. py:data:: hx_mblock_t_build_def_list

.. py:data:: hx_mblock_t_find_first_use

.. py:data:: hx_mblock_t_find_redefinition

.. py:data:: hx_mblock_t_is_rhs_redefined

.. py:data:: hx_mblock_t_find_access

.. py:data:: hx_mblock_t_get_valranges

.. py:data:: hx_mblock_t_get_valranges_

.. py:data:: hx_mblock_t_get_reginsn_qty

.. py:data:: hx_mba_ranges_t_range_contains

.. py:data:: hx_mba_t_stkoff_vd2ida

.. py:data:: hx_mba_t_stkoff_ida2vd

.. py:data:: hx_mba_t_idaloc2vd

.. py:data:: hx_mba_t_idaloc2vd_

.. py:data:: hx_mba_t_vd2idaloc

.. py:data:: hx_mba_t_vd2idaloc_

.. py:data:: hx_mba_t_term

.. py:data:: hx_mba_t_get_curfunc

.. py:data:: hx_mba_t_set_maturity

.. py:data:: hx_mba_t_optimize_local

.. py:data:: hx_mba_t_build_graph

.. py:data:: hx_mba_t_get_graph

.. py:data:: hx_mba_t_analyze_calls

.. py:data:: hx_mba_t_optimize_global

.. py:data:: hx_mba_t_alloc_lvars

.. py:data:: hx_mba_t_dump

.. py:data:: hx_mba_t_vdump_mba

.. py:data:: hx_mba_t_print

.. py:data:: hx_mba_t_verify

.. py:data:: hx_mba_t_mark_chains_dirty

.. py:data:: hx_mba_t_insert_block

.. py:data:: hx_mba_t_remove_block

.. py:data:: hx_mba_t_copy_block

.. py:data:: hx_mba_t_remove_empty_and_unreachable_blocks

.. py:data:: hx_mba_t_merge_blocks

.. py:data:: hx_mba_t_for_all_ops

.. py:data:: hx_mba_t_for_all_insns

.. py:data:: hx_mba_t_for_all_topinsns

.. py:data:: hx_mba_t_find_mop

.. py:data:: hx_mba_t_create_helper_call

.. py:data:: hx_mba_t_get_func_output_lists

.. py:data:: hx_mba_t_arg

.. py:data:: hx_mba_t_alloc_fict_ea

.. py:data:: hx_mba_t_map_fict_ea

.. py:data:: hx_mba_t_serialize

.. py:data:: hx_mba_t_deserialize

.. py:data:: hx_mba_t_save_snapshot

.. py:data:: hx_mba_t_alloc_kreg

.. py:data:: hx_mba_t_free_kreg

.. py:data:: hx_mba_t_inline_func

.. py:data:: hx_mba_t_locate_stkpnt

.. py:data:: hx_mba_t_set_lvar_name

.. py:data:: hx_mbl_graph_t_is_accessed_globally

.. py:data:: hx_mbl_graph_t_get_ud

.. py:data:: hx_mbl_graph_t_get_du

.. py:data:: hx_cdg_insn_iterator_t_next

.. py:data:: hx_codegen_t_clear

.. py:data:: hx_codegen_t_emit

.. py:data:: hx_codegen_t_emit_

.. py:data:: hx_change_hexrays_config

.. py:data:: hx_get_hexrays_version

.. py:data:: hx_open_pseudocode

.. py:data:: hx_close_pseudocode

.. py:data:: hx_get_widget_vdui

.. py:data:: hx_decompile_many

.. py:data:: hx_hexrays_failure_t_desc

.. py:data:: hx_send_database

.. py:data:: hx_gco_info_t_append_to_list

.. py:data:: hx_get_current_operand

.. py:data:: hx_remitem

.. py:data:: hx_negated_relation

.. py:data:: hx_swapped_relation

.. py:data:: hx_get_op_signness

.. py:data:: hx_asgop

.. py:data:: hx_asgop_revert

.. py:data:: hx_cnumber_t_print

.. py:data:: hx_cnumber_t_value

.. py:data:: hx_cnumber_t_assign

.. py:data:: hx_cnumber_t_compare

.. py:data:: hx_var_ref_t_compare

.. py:data:: hx_ctree_visitor_t_apply_to

.. py:data:: hx_ctree_visitor_t_apply_to_exprs

.. py:data:: hx_ctree_parentee_t_recalc_parent_types

.. py:data:: hx_cfunc_parentee_t_calc_rvalue_type

.. py:data:: hx_citem_locator_t_compare

.. py:data:: hx_citem_t_contains_expr

.. py:data:: hx_citem_t_contains_label

.. py:data:: hx_citem_t_find_parent_of

.. py:data:: hx_citem_t_find_closest_addr

.. py:data:: hx_cexpr_t_assign

.. py:data:: hx_cexpr_t_compare

.. py:data:: hx_cexpr_t_replace_by

.. py:data:: hx_cexpr_t_cleanup

.. py:data:: hx_cexpr_t_put_number

.. py:data:: hx_cexpr_t_print1

.. py:data:: hx_cexpr_t_calc_type

.. py:data:: hx_cexpr_t_equal_effect

.. py:data:: hx_cexpr_t_is_child_of

.. py:data:: hx_cexpr_t_contains_operator

.. py:data:: hx_cexpr_t_get_high_nbit_bound

.. py:data:: hx_cexpr_t_get_low_nbit_bound

.. py:data:: hx_cexpr_t_requires_lvalue

.. py:data:: hx_cexpr_t_has_side_effects

.. py:data:: hx_cexpr_t_maybe_ptr

.. py:data:: hx_cexpr_t_dstr

.. py:data:: hx_cif_t_assign

.. py:data:: hx_cif_t_compare

.. py:data:: hx_cloop_t_assign

.. py:data:: hx_cfor_t_compare

.. py:data:: hx_cwhile_t_compare

.. py:data:: hx_cdo_t_compare

.. py:data:: hx_creturn_t_compare

.. py:data:: hx_cthrow_t_compare

.. py:data:: hx_cgoto_t_compare

.. py:data:: hx_casm_t_compare

.. py:data:: hx_cinsn_t_assign

.. py:data:: hx_cinsn_t_compare

.. py:data:: hx_cinsn_t_replace_by

.. py:data:: hx_cinsn_t_cleanup

.. py:data:: hx_cinsn_t_new_insn

.. py:data:: hx_cinsn_t_create_if

.. py:data:: hx_cinsn_t_print

.. py:data:: hx_cinsn_t_print1

.. py:data:: hx_cinsn_t_is_ordinary_flow

.. py:data:: hx_cinsn_t_contains_insn

.. py:data:: hx_cinsn_t_collect_free_breaks

.. py:data:: hx_cinsn_t_collect_free_continues

.. py:data:: hx_cinsn_t_dstr

.. py:data:: hx_cblock_t_compare

.. py:data:: hx_carglist_t_compare

.. py:data:: hx_ccase_t_compare

.. py:data:: hx_ccases_t_compare

.. py:data:: hx_cswitch_t_compare

.. py:data:: hx_ccatch_t_compare

.. py:data:: hx_ctry_t_compare

.. py:data:: hx_ctree_item_t_get_udm

.. py:data:: hx_ctree_item_t_get_edm

.. py:data:: hx_ctree_item_t_get_lvar

.. py:data:: hx_ctree_item_t_get_ea

.. py:data:: hx_ctree_item_t_get_label_num

.. py:data:: hx_ctree_item_t_print

.. py:data:: hx_ctree_item_t_dstr

.. py:data:: hx_lnot

.. py:data:: hx_new_block

.. py:data:: hx_vcreate_helper

.. py:data:: hx_vcall_helper

.. py:data:: hx_make_num

.. py:data:: hx_make_ref

.. py:data:: hx_dereference

.. py:data:: hx_save_user_labels

.. py:data:: hx_save_user_cmts

.. py:data:: hx_save_user_numforms

.. py:data:: hx_save_user_iflags

.. py:data:: hx_save_user_unions

.. py:data:: hx_restore_user_labels

.. py:data:: hx_restore_user_cmts

.. py:data:: hx_restore_user_numforms

.. py:data:: hx_restore_user_iflags

.. py:data:: hx_restore_user_unions

.. py:data:: hx_cfunc_t_build_c_tree

.. py:data:: hx_cfunc_t_verify

.. py:data:: hx_cfunc_t_print_dcl

.. py:data:: hx_cfunc_t_print_func

.. py:data:: hx_cfunc_t_get_func_type

.. py:data:: hx_cfunc_t_get_lvars

.. py:data:: hx_cfunc_t_get_stkoff_delta

.. py:data:: hx_cfunc_t_find_label

.. py:data:: hx_cfunc_t_remove_unused_labels

.. py:data:: hx_cfunc_t_get_user_cmt

.. py:data:: hx_cfunc_t_set_user_cmt

.. py:data:: hx_cfunc_t_get_user_iflags

.. py:data:: hx_cfunc_t_set_user_iflags

.. py:data:: hx_cfunc_t_has_orphan_cmts

.. py:data:: hx_cfunc_t_del_orphan_cmts

.. py:data:: hx_cfunc_t_get_user_union_selection

.. py:data:: hx_cfunc_t_set_user_union_selection

.. py:data:: hx_cfunc_t_save_user_labels

.. py:data:: hx_cfunc_t_save_user_cmts

.. py:data:: hx_cfunc_t_save_user_numforms

.. py:data:: hx_cfunc_t_save_user_iflags

.. py:data:: hx_cfunc_t_save_user_unions

.. py:data:: hx_cfunc_t_get_line_item

.. py:data:: hx_cfunc_t_get_warnings

.. py:data:: hx_cfunc_t_get_eamap

.. py:data:: hx_cfunc_t_get_boundaries

.. py:data:: hx_cfunc_t_get_pseudocode

.. py:data:: hx_cfunc_t_refresh_func_ctext

.. py:data:: hx_cfunc_t_gather_derefs

.. py:data:: hx_cfunc_t_find_item_coords

.. py:data:: hx_cfunc_t_cleanup

.. py:data:: hx_close_hexrays_waitbox

.. py:data:: hx_decompile

.. py:data:: hx_gen_microcode

.. py:data:: hx_create_cfunc

.. py:data:: hx_mark_cfunc_dirty

.. py:data:: hx_clear_cached_cfuncs

.. py:data:: hx_has_cached_cfunc

.. py:data:: hx_get_ctype_name

.. py:data:: hx_create_field_name

.. py:data:: hx_install_hexrays_callback

.. py:data:: hx_remove_hexrays_callback

.. py:data:: hx_vdui_t_set_locked

.. py:data:: hx_vdui_t_refresh_view

.. py:data:: hx_vdui_t_refresh_ctext

.. py:data:: hx_vdui_t_switch_to

.. py:data:: hx_vdui_t_get_number

.. py:data:: hx_vdui_t_get_current_label

.. py:data:: hx_vdui_t_clear

.. py:data:: hx_vdui_t_refresh_cpos

.. py:data:: hx_vdui_t_get_current_item

.. py:data:: hx_vdui_t_ui_rename_lvar

.. py:data:: hx_vdui_t_rename_lvar

.. py:data:: hx_vdui_t_ui_set_call_type

.. py:data:: hx_vdui_t_ui_set_lvar_type

.. py:data:: hx_vdui_t_set_lvar_type

.. py:data:: hx_vdui_t_set_noptr_lvar

.. py:data:: hx_vdui_t_ui_edit_lvar_cmt

.. py:data:: hx_vdui_t_set_lvar_cmt

.. py:data:: hx_vdui_t_ui_map_lvar

.. py:data:: hx_vdui_t_ui_unmap_lvar

.. py:data:: hx_vdui_t_map_lvar

.. py:data:: hx_vdui_t_set_udm_type

.. py:data:: hx_vdui_t_rename_udm

.. py:data:: hx_vdui_t_set_global_type

.. py:data:: hx_vdui_t_rename_global

.. py:data:: hx_vdui_t_rename_label

.. py:data:: hx_vdui_t_jump_enter

.. py:data:: hx_vdui_t_ctree_to_disasm

.. py:data:: hx_vdui_t_calc_cmt_type

.. py:data:: hx_vdui_t_edit_cmt

.. py:data:: hx_vdui_t_edit_func_cmt

.. py:data:: hx_vdui_t_del_orphan_cmts

.. py:data:: hx_vdui_t_set_num_radix

.. py:data:: hx_vdui_t_set_num_enum

.. py:data:: hx_vdui_t_set_num_stroff

.. py:data:: hx_vdui_t_invert_sign

.. py:data:: hx_vdui_t_invert_bits

.. py:data:: hx_vdui_t_collapse_item

.. py:data:: hx_vdui_t_collapse_lvars

.. py:data:: hx_vdui_t_split_item

.. py:data:: hx_select_udt_by_offset

.. py:data:: hx_catchexpr_t_compare

.. py:data:: hx_mba_t_split_block

.. py:data:: hx_mba_t_remove_blocks

.. py:data:: hx_cfunc_t_recalc_item_addresses

.. py:data:: hx_int64_emulator_t_mop_value

.. py:data:: hx_int64_emulator_t_minsn_value

.. py:class:: user_numforms_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: user_numforms_first(p: user_numforms_iterator_t) -> operand_locator_t const &

   Get reference to the current map key.


.. py:function:: user_numforms_second(p: user_numforms_iterator_t) -> number_format_t &

   Get reference to the current map value.


.. py:function:: user_numforms_find(map: user_numforms_t, key: operand_locator_t) -> user_numforms_iterator_t

   Find the specified key in user_numforms_t.


.. py:function:: user_numforms_insert(map: user_numforms_t, key: operand_locator_t, val: number_format_t) -> user_numforms_iterator_t

   Insert new (operand_locator_t, number_format_t) pair into user_numforms_t.


.. py:function:: user_numforms_begin(map: user_numforms_t) -> user_numforms_iterator_t

   Get iterator pointing to the beginning of user_numforms_t.


.. py:function:: user_numforms_end(map: user_numforms_t) -> user_numforms_iterator_t

   Get iterator pointing to the end of user_numforms_t.


.. py:function:: user_numforms_next(p: user_numforms_iterator_t) -> user_numforms_iterator_t

   Move to the next element.


.. py:function:: user_numforms_prev(p: user_numforms_iterator_t) -> user_numforms_iterator_t

   Move to the previous element.


.. py:function:: user_numforms_erase(map: user_numforms_t, p: user_numforms_iterator_t) -> None

   Erase current element from user_numforms_t.


.. py:function:: user_numforms_clear(map: user_numforms_t) -> None

   Clear user_numforms_t.


.. py:function:: user_numforms_size(map: user_numforms_t) -> size_t

   Get size of user_numforms_t.


.. py:function:: user_numforms_free(map: user_numforms_t) -> None

   Delete user_numforms_t instance.


.. py:function:: user_numforms_new() -> user_numforms_t *

   Create a new user_numforms_t instance.


.. py:class:: lvar_mapping_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: lvar_mapping_first(p: lvar_mapping_iterator_t) -> lvar_locator_t const &

   Get reference to the current map key.


.. py:function:: lvar_mapping_second(p: lvar_mapping_iterator_t) -> lvar_locator_t &

   Get reference to the current map value.


.. py:function:: lvar_mapping_find(map: lvar_mapping_t, key: lvar_locator_t) -> lvar_mapping_iterator_t

   Find the specified key in lvar_mapping_t.


.. py:function:: lvar_mapping_insert(map: lvar_mapping_t, key: lvar_locator_t, val: lvar_locator_t) -> lvar_mapping_iterator_t

   Insert new (lvar_locator_t, lvar_locator_t) pair into lvar_mapping_t.


.. py:function:: lvar_mapping_begin(map: lvar_mapping_t) -> lvar_mapping_iterator_t

   Get iterator pointing to the beginning of lvar_mapping_t.


.. py:function:: lvar_mapping_end(map: lvar_mapping_t) -> lvar_mapping_iterator_t

   Get iterator pointing to the end of lvar_mapping_t.


.. py:function:: lvar_mapping_next(p: lvar_mapping_iterator_t) -> lvar_mapping_iterator_t

   Move to the next element.


.. py:function:: lvar_mapping_prev(p: lvar_mapping_iterator_t) -> lvar_mapping_iterator_t

   Move to the previous element.


.. py:function:: lvar_mapping_erase(map: lvar_mapping_t, p: lvar_mapping_iterator_t) -> None

   Erase current element from lvar_mapping_t.


.. py:function:: lvar_mapping_clear(map: lvar_mapping_t) -> None

   Clear lvar_mapping_t.


.. py:function:: lvar_mapping_size(map: lvar_mapping_t) -> size_t

   Get size of lvar_mapping_t.


.. py:function:: lvar_mapping_free(map: lvar_mapping_t) -> None

   Delete lvar_mapping_t instance.


.. py:function:: lvar_mapping_new() -> lvar_mapping_t *

   Create a new lvar_mapping_t instance.


.. py:class:: udcall_map_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: udcall_map_first(p: udcall_map_iterator_t) -> ea_t const &

   Get reference to the current map key.


.. py:function:: udcall_map_second(p: udcall_map_iterator_t) -> udcall_t &

   Get reference to the current map value.


.. py:function:: udcall_map_find(map: udcall_map_t const *, key: ea_t const &) -> udcall_map_iterator_t

   Find the specified key in udcall_map_t.


.. py:function:: udcall_map_insert(map: udcall_map_t *, key: ea_t const &, val: udcall_t) -> udcall_map_iterator_t

   Insert new (ea_t, udcall_t) pair into udcall_map_t.


.. py:function:: udcall_map_begin(map: udcall_map_t const *) -> udcall_map_iterator_t

   Get iterator pointing to the beginning of udcall_map_t.


.. py:function:: udcall_map_end(map: udcall_map_t const *) -> udcall_map_iterator_t

   Get iterator pointing to the end of udcall_map_t.


.. py:function:: udcall_map_next(p: udcall_map_iterator_t) -> udcall_map_iterator_t

   Move to the next element.


.. py:function:: udcall_map_prev(p: udcall_map_iterator_t) -> udcall_map_iterator_t

   Move to the previous element.


.. py:function:: udcall_map_erase(map: udcall_map_t *, p: udcall_map_iterator_t) -> None

   Erase current element from udcall_map_t.


.. py:function:: udcall_map_clear(map: udcall_map_t *) -> None

   Clear udcall_map_t.


.. py:function:: udcall_map_size(map: udcall_map_t *) -> size_t

   Get size of udcall_map_t.


.. py:function:: udcall_map_free(map: udcall_map_t *) -> None

   Delete udcall_map_t instance.


.. py:function:: udcall_map_new() -> udcall_map_t *

   Create a new udcall_map_t instance.


.. py:class:: user_cmts_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: user_cmts_first(p: user_cmts_iterator_t) -> treeloc_t const &

   Get reference to the current map key.


.. py:function:: user_cmts_second(p: user_cmts_iterator_t) -> citem_cmt_t &

   Get reference to the current map value.


.. py:function:: user_cmts_find(map: user_cmts_t, key: treeloc_t) -> user_cmts_iterator_t

   Find the specified key in user_cmts_t.


.. py:function:: user_cmts_insert(map: user_cmts_t, key: treeloc_t, val: citem_cmt_t) -> user_cmts_iterator_t

   Insert new (treeloc_t, citem_cmt_t) pair into user_cmts_t.


.. py:function:: user_cmts_begin(map: user_cmts_t) -> user_cmts_iterator_t

   Get iterator pointing to the beginning of user_cmts_t.


.. py:function:: user_cmts_end(map: user_cmts_t) -> user_cmts_iterator_t

   Get iterator pointing to the end of user_cmts_t.


.. py:function:: user_cmts_next(p: user_cmts_iterator_t) -> user_cmts_iterator_t

   Move to the next element.


.. py:function:: user_cmts_prev(p: user_cmts_iterator_t) -> user_cmts_iterator_t

   Move to the previous element.


.. py:function:: user_cmts_erase(map: user_cmts_t, p: user_cmts_iterator_t) -> None

   Erase current element from user_cmts_t.


.. py:function:: user_cmts_clear(map: user_cmts_t) -> None

   Clear user_cmts_t.


.. py:function:: user_cmts_size(map: user_cmts_t) -> size_t

   Get size of user_cmts_t.


.. py:function:: user_cmts_free(map: user_cmts_t) -> None

   Delete user_cmts_t instance.


.. py:function:: user_cmts_new() -> user_cmts_t *

   Create a new user_cmts_t instance.


.. py:class:: user_iflags_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: user_iflags_first(p: user_iflags_iterator_t) -> citem_locator_t const &

   Get reference to the current map key.


.. py:function:: user_iflags_find(map: user_iflags_t, key: citem_locator_t) -> user_iflags_iterator_t

   Find the specified key in user_iflags_t.


.. py:function:: user_iflags_insert(map: user_iflags_t, key: citem_locator_t, val: int32 const &) -> user_iflags_iterator_t

   Insert new (citem_locator_t, int32) pair into user_iflags_t.


.. py:function:: user_iflags_begin(map: user_iflags_t) -> user_iflags_iterator_t

   Get iterator pointing to the beginning of user_iflags_t.


.. py:function:: user_iflags_end(map: user_iflags_t) -> user_iflags_iterator_t

   Get iterator pointing to the end of user_iflags_t.


.. py:function:: user_iflags_next(p: user_iflags_iterator_t) -> user_iflags_iterator_t

   Move to the next element.


.. py:function:: user_iflags_prev(p: user_iflags_iterator_t) -> user_iflags_iterator_t

   Move to the previous element.


.. py:function:: user_iflags_erase(map: user_iflags_t, p: user_iflags_iterator_t) -> None

   Erase current element from user_iflags_t.


.. py:function:: user_iflags_clear(map: user_iflags_t) -> None

   Clear user_iflags_t.


.. py:function:: user_iflags_size(map: user_iflags_t) -> size_t

   Get size of user_iflags_t.


.. py:function:: user_iflags_free(map: user_iflags_t) -> None

   Delete user_iflags_t instance.


.. py:function:: user_iflags_new() -> user_iflags_t *

   Create a new user_iflags_t instance.


.. py:class:: user_unions_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: user_unions_first(p: user_unions_iterator_t) -> ea_t const &

   Get reference to the current map key.


.. py:function:: user_unions_second(p: user_unions_iterator_t) -> intvec_t &

   Get reference to the current map value.


.. py:function:: user_unions_find(map: user_unions_t, key: ea_t const &) -> user_unions_iterator_t

   Find the specified key in user_unions_t.


.. py:function:: user_unions_insert(map: user_unions_t, key: ea_t const &, val: intvec_t) -> user_unions_iterator_t

   Insert new (ea_t, intvec_t) pair into user_unions_t.


.. py:function:: user_unions_begin(map: user_unions_t) -> user_unions_iterator_t

   Get iterator pointing to the beginning of user_unions_t.


.. py:function:: user_unions_end(map: user_unions_t) -> user_unions_iterator_t

   Get iterator pointing to the end of user_unions_t.


.. py:function:: user_unions_next(p: user_unions_iterator_t) -> user_unions_iterator_t

   Move to the next element.


.. py:function:: user_unions_prev(p: user_unions_iterator_t) -> user_unions_iterator_t

   Move to the previous element.


.. py:function:: user_unions_erase(map: user_unions_t, p: user_unions_iterator_t) -> None

   Erase current element from user_unions_t.


.. py:function:: user_unions_clear(map: user_unions_t) -> None

   Clear user_unions_t.


.. py:function:: user_unions_size(map: user_unions_t) -> size_t

   Get size of user_unions_t.


.. py:function:: user_unions_free(map: user_unions_t) -> None

   Delete user_unions_t instance.


.. py:function:: user_unions_new() -> user_unions_t *

   Create a new user_unions_t instance.


.. py:class:: user_labels_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: user_labels_first(p: user_labels_iterator_t) -> int const &

   Get reference to the current map key.


.. py:function:: user_labels_second(p: user_labels_iterator_t) -> str

   Get reference to the current map value.


.. py:function:: user_labels_find(map: user_labels_t, key: int const &) -> user_labels_iterator_t

   Find the specified key in user_labels_t.


.. py:function:: user_labels_insert(map: user_labels_t, key: int const &, val: str) -> user_labels_iterator_t

   Insert new (int, qstring) pair into user_labels_t.


.. py:function:: user_labels_begin(map: user_labels_t) -> user_labels_iterator_t

   Get iterator pointing to the beginning of user_labels_t.


.. py:function:: user_labels_end(map: user_labels_t) -> user_labels_iterator_t

   Get iterator pointing to the end of user_labels_t.


.. py:function:: user_labels_next(p: user_labels_iterator_t) -> user_labels_iterator_t

   Move to the next element.


.. py:function:: user_labels_prev(p: user_labels_iterator_t) -> user_labels_iterator_t

   Move to the previous element.


.. py:function:: user_labels_erase(map: user_labels_t, p: user_labels_iterator_t) -> None

   Erase current element from user_labels_t.


.. py:function:: user_labels_clear(map: user_labels_t) -> None

   Clear user_labels_t.


.. py:function:: user_labels_size(map: user_labels_t) -> size_t

   Get size of user_labels_t.


.. py:function:: user_labels_free(map: user_labels_t) -> None

   Delete user_labels_t instance.


.. py:function:: user_labels_new() -> user_labels_t *

   Create a new user_labels_t instance.


.. py:class:: eamap_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: eamap_first(p: eamap_iterator_t) -> ea_t const &

   Get reference to the current map key.


.. py:function:: eamap_second(p: eamap_iterator_t) -> cinsnptrvec_t &

   Get reference to the current map value.


.. py:function:: eamap_find(map: eamap_t, key: ea_t const &) -> eamap_iterator_t

   Find the specified key in eamap_t.


.. py:function:: eamap_insert(map: eamap_t, key: ea_t const &, val: cinsnptrvec_t) -> eamap_iterator_t

   Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.


.. py:function:: eamap_begin(map: eamap_t) -> eamap_iterator_t

   Get iterator pointing to the beginning of eamap_t.


.. py:function:: eamap_end(map: eamap_t) -> eamap_iterator_t

   Get iterator pointing to the end of eamap_t.


.. py:function:: eamap_next(p: eamap_iterator_t) -> eamap_iterator_t

   Move to the next element.


.. py:function:: eamap_prev(p: eamap_iterator_t) -> eamap_iterator_t

   Move to the previous element.


.. py:function:: eamap_erase(map: eamap_t, p: eamap_iterator_t) -> None

   Erase current element from eamap_t.


.. py:function:: eamap_clear(map: eamap_t) -> None

   Clear eamap_t.


.. py:function:: eamap_size(map: eamap_t) -> size_t

   Get size of eamap_t.


.. py:function:: eamap_free(map: eamap_t) -> None

   Delete eamap_t instance.


.. py:function:: eamap_new() -> eamap_t *

   Create a new eamap_t instance.


.. py:class:: boundaries_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: boundaries_first(p: boundaries_iterator_t) -> cinsn_t *const &

   Get reference to the current map key.


.. py:function:: boundaries_second(p: boundaries_iterator_t) -> rangeset_t &

   Get reference to the current map value.


.. py:function:: boundaries_begin(map: boundaries_t) -> boundaries_iterator_t

   Get iterator pointing to the beginning of boundaries_t.


.. py:function:: boundaries_end(map: boundaries_t) -> boundaries_iterator_t

   Get iterator pointing to the end of boundaries_t.


.. py:function:: boundaries_next(p: boundaries_iterator_t) -> boundaries_iterator_t

   Move to the next element.


.. py:function:: boundaries_prev(p: boundaries_iterator_t) -> boundaries_iterator_t

   Move to the previous element.


.. py:function:: boundaries_erase(map: boundaries_t, p: boundaries_iterator_t) -> None

   Erase current element from boundaries_t.


.. py:function:: boundaries_clear(map: boundaries_t) -> None

   Clear boundaries_t.


.. py:function:: boundaries_size(map: boundaries_t) -> size_t

   Get size of boundaries_t.


.. py:function:: boundaries_free(map: boundaries_t) -> None

   Delete boundaries_t instance.


.. py:function:: boundaries_new() -> boundaries_t *

   Create a new boundaries_t instance.


.. py:class:: block_chains_iterator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  iterator_word


.. py:function:: block_chains_get(p: block_chains_iterator_t) -> chain_t &

   Get reference to the current set value.


.. py:function:: block_chains_find(set: block_chains_t, val: chain_t) -> block_chains_iterator_t

   Find the specified key in set block_chains_t.


.. py:function:: block_chains_insert(set: block_chains_t, val: chain_t) -> block_chains_iterator_t

   Insert new (chain_t) into set block_chains_t.


.. py:function:: block_chains_begin(set: block_chains_t) -> block_chains_iterator_t

   Get iterator pointing to the beginning of block_chains_t.


.. py:function:: block_chains_end(set: block_chains_t) -> block_chains_iterator_t

   Get iterator pointing to the end of block_chains_t.


.. py:function:: block_chains_next(p: block_chains_iterator_t) -> block_chains_iterator_t

   Move to the next element.


.. py:function:: block_chains_prev(p: block_chains_iterator_t) -> block_chains_iterator_t

   Move to the previous element.


.. py:function:: block_chains_erase(set: block_chains_t, p: block_chains_iterator_t) -> None

   Erase current element from block_chains_t.


.. py:function:: block_chains_clear(set: block_chains_t) -> None

   Clear block_chains_t.


.. py:function:: block_chains_size(set: block_chains_t) -> size_t

   Get size of block_chains_t.


.. py:function:: block_chains_free(set: block_chains_t) -> None

   Delete block_chains_t instance.


.. py:function:: block_chains_new() -> block_chains_t *

   Create a new block_chains_t instance.


.. py:data:: is_allowed_on_small_struni

.. py:data:: is_small_struni

.. py:data:: mbl_array_t

.. py:exception:: DecompilationFailure

   Bases: :py:obj:`Exception`


   Common base class for all non-exit exceptions.


.. py:function:: decompile(ea, hf=None, flags=0)

   Decompile a snippet or a function. 
           
   :param hf: extended error information (if failed)
   :returns: pointer to the decompilation result (a reference counted pointer). nullptr if failed.


.. py:function:: citem_to_specific_type(self)

   cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 


.. py:function:: property_op_to_typename(self)

.. py:function:: cexpr_operands(self)

   return a dictionary with the operands of a cexpr_t. 


.. py:function:: cinsn_details(self)

   return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.


.. py:function:: cfunc_type(self)

   Get the function's return type tinfo_t object. 


.. py:function:: lnot(e)

   Logically negate the specified expression. The specified expression will be logically negated. For example, "x == y" is converted into "x != y" by this function. 
           
   :param e: expression to negate. After the call, e must not be used anymore because it can be changed by the function. The function return value must be used to refer to the expression.
   :returns: logically negated expression.


.. py:function:: make_ref(e)

   Create a reference. This function performs the following conversion: "obj" => "&obj". It can handle casts, annihilate "&*", and process other special cases. 
           


.. py:function:: dereference(e, ptrsize, is_float=False)

   Dereference a pointer. This function dereferences a pointer expression. It performs the following conversion: "ptr" => "*ptr" It can handle discrepancies in the pointer type and the access size. 
           
   :param e: expression to deference
   :param ptrsize: access size
   :returns: dereferenced expression


.. py:function:: call_helper(rettype, args, *rest)

   Create a helper call.


.. py:function:: new_block()

   Create a new block-statement.


.. py:function:: make_num(*args)

   Create a number expression 
           
   :param n: value
   :param func: current function
   :param ea: definition address of the number
   :param opnum: operand number of the number (in the disassembly listing)
   :param sign: number sign
   :param size: size of number in bytes Please note that the type of the resulting expression can be anything because it can be inherited from the disassembly listing or taken from the user specified number representation in the pseudocode view.


.. py:function:: create_helper(*args)

   Create a helper object..


.. py:function:: install_hexrays_callback(callback)

   Install handler for decompiler events. 
           
   :param callback: handler to install
   :returns: false if failed


.. py:function:: remove_hexrays_callback(callback)

   Uninstall handler for decompiler events. 
           
   :param callback: handler to uninstall
   :returns: number of uninstalled handlers.



```

`skills/idapython/docs/ida_ida.md`:

```md
# ida_ida

Database-wide configuration via the `inf` structure - processor info, file type, address ranges, and analysis flags.

## Key Functions

### Database Properties
- `inf_get_min_ea()`, `inf_set_min_ea(ea)` - Database address range start
- `inf_get_max_ea()`, `inf_set_max_ea(ea)` - Database address range end
- `inf_get_start_ea()`, `inf_set_start_ea(ea)` - Entry point address
- `inf_get_baseaddr()`, `inf_set_baseaddr(ea)` - Image base address
- `inf_get_main()`, `inf_set_main(ea)` - Main function address

### Architecture Info
- `inf_is_16bit()`, `inf_is_32bit_exactly()`, `inf_is_64bit()` - Architecture bit width
- `inf_set_32bit(v)`, `inf_set_64bit(v)` - Set architecture
- `inf_is_be()`, `inf_set_be(v)` - Big-endian check/set
- `inf_is_dll()`, `inf_set_dll(v)` - DLL vs executable

### File Information
- `inf_get_procname()`, `inf_set_procname(name)` - Processor name (x86, ARM, etc.)
- `inf_get_filetype()`, `inf_set_filetype(ft)` - File type (f_PE, f_ELF, f_MACHO, etc.)
- `inf_get_md5()`, `inf_get_sha256()` - File hashes
- `inf_get_input_file_path()` - Original input file path
- `inf_get_imagebase()` - PE/ELF image base

### Analysis Flags
- `inf_get_af()`, `inf_set_af(flags)` - Get/set all analysis flags
- `inf_get_af2()`, `inf_set_af2(flags)` - Secondary analysis flags
- Analysis flag constants: AF_CODE, AF_JUMPTBL, AF_PROC, AF_LVAR, AF_TRACE, AF_FLIRT, etc.

### Display Options
- `inf_is_graph_view()`, `inf_set_graph_view(v)` - Default to graph vs text view
- `inf_get_indent()`, `inf_set_indent(n)` - Disassembly indentation
- `inf_get_margin()`, `inf_set_margin(n)` - Right margin

### Database State
- `inf_is_auto_enabled()`, `inf_set_auto_enabled(v)` - Auto-analysis state
- `inf_readonly_idb()`, `inf_set_readonly_idb(v)` - Read-only mode
- `inf_get_database_change_count()` - Change counter (for caching)

### Compiler Info
- `inf_get_cc_id()`, `inf_set_cc_id(id)` - Calling convention ID
- `inf_get_cc_size_i()`, `inf_get_cc_size_l()` - sizeof(int), sizeof(long)
- `inf_get_abibits()`, `inf_set_abibits(bits)` - ABI flags

## Key Constants

**File types**: f_PE, f_ELF, f_MACHO, f_BIN, f_COFF, f_OMF, f_AOUT, f_HEX

**Analysis flags**: AF_CODE (create instructions), AF_JUMPTBL (analyze jump tables), AF_PROC (create functions), AF_LVAR (local variables), AF_FLIRT (apply FLIRT signatures)

**Loader flags**: LFLG_64BIT, LFLG_IS_DLL, LFLG_PC_FLAT (flat memory model)

**Name display**: NM_REL_OFF (show offsets), NM_EA (show addresses), NM_SHORT (short names)

**Demangling**: DEMNAM_GCC3 (GCC v3 ABI), DEMNAM_CMNT (show in comments), DEMNAM_NAME (show as name)

## See Also
Full docs: skill/docs/ida_ida.rst

```

`skills/idapython/docs/ida_ida.rst`:

```rst
ida_ida
=======

.. py:module:: ida_ida

.. autoapi-nested-parse::

   Contains the ::inf structure definition and some functions common to the whole IDA project.

   The ::inf structure is saved in the database and contains information specific 
   to the current program being disassembled. Initially it is filled with values 
   from ida.cfg.

   Although it is not a good idea to change values in ::inf structure (because you 
   will overwrite values taken from ida.cfg), you are allowed to do it if you feel 
   it necessary.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For database operations, see :mod:`ida_domain.database`.



Attributes
----------

.. autoapisummary::

   ida_ida.AF_FINAL
   ida_ida.f_EXE_old
   ida_ida.f_COM_old
   ida_ida.f_BIN
   ida_ida.f_DRV
   ida_ida.f_WIN
   ida_ida.f_HEX
   ida_ida.f_MEX
   ida_ida.f_LX
   ida_ida.f_LE
   ida_ida.f_NLM
   ida_ida.f_COFF
   ida_ida.f_PE
   ida_ida.f_OMF
   ida_ida.f_SREC
   ida_ida.f_ZIP
   ida_ida.f_OMFLIB
   ida_ida.f_AR
   ida_ida.f_LOADER
   ida_ida.f_ELF
   ida_ida.f_W32RUN
   ida_ida.f_AOUT
   ida_ida.f_PRC
   ida_ida.f_EXE
   ida_ida.f_COM
   ida_ida.f_AIXAR
   ida_ida.f_MACHO
   ida_ida.f_PSXOBJ
   ida_ida.f_MD1IMG
   ida_ida.STT_CUR
   ida_ida.STT_VA
   ida_ida.STT_MM
   ida_ida.STT_DBG
   ida_ida.IDAINFO_TAG_SIZE
   ida_ida.IDAINFO_PROCNAME_SIZE
   ida_ida.IDAINFO_STRLIT_PREF_SIZE
   ida_ida.INFFL_AUTO
   ida_ida.INFFL_ALLASM
   ida_ida.INFFL_LOADIDC
   ida_ida.INFFL_NOUSER
   ida_ida.INFFL_READONLY
   ida_ida.INFFL_CHKOPS
   ida_ida.INFFL_NMOPS
   ida_ida.INFFL_GRAPH_VIEW
   ida_ida.LFLG_PC_FPP
   ida_ida.LFLG_PC_FLAT
   ida_ida.LFLG_64BIT
   ida_ida.LFLG_IS_DLL
   ida_ida.LFLG_FLAT_OFF32
   ida_ida.LFLG_MSF
   ida_ida.LFLG_WIDE_HBF
   ida_ida.LFLG_DBG_NOPATH
   ida_ida.LFLG_SNAPSHOT
   ida_ida.LFLG_PACK
   ida_ida.LFLG_COMPRESS
   ida_ida.LFLG_KERNMODE
   ida_ida.LFLG_ILP32
   ida_ida.IDB_UNPACKED
   ida_ida.IDB_PACKED
   ida_ida.IDB_COMPRESSED
   ida_ida.AF_CODE
   ida_ida.AF_MARKCODE
   ida_ida.AF_JUMPTBL
   ida_ida.AF_PURDAT
   ida_ida.AF_USED
   ida_ida.AF_UNK
   ida_ida.AF_PROCPTR
   ida_ida.AF_PROC
   ida_ida.AF_FTAIL
   ida_ida.AF_LVAR
   ida_ida.AF_STKARG
   ida_ida.AF_REGARG
   ida_ida.AF_TRACE
   ida_ida.AF_VERSP
   ida_ida.AF_ANORET
   ida_ida.AF_MEMFUNC
   ida_ida.AF_TRFUNC
   ida_ida.AF_STRLIT
   ida_ida.AF_CHKUNI
   ida_ida.AF_FIXUP
   ida_ida.AF_DREFOFF
   ida_ida.AF_IMMOFF
   ida_ida.AF_DATOFF
   ida_ida.AF_FLIRT
   ida_ida.AF_SIGCMT
   ida_ida.AF_SIGMLT
   ida_ida.AF_HFLIRT
   ida_ida.AF_JFUNC
   ida_ida.AF_NULLSUB
   ida_ida.AF_DODATA
   ida_ida.AF_DOCODE
   ida_ida.AF2_DOEH
   ida_ida.AF2_DORTTI
   ida_ida.AF2_MACRO
   ida_ida.AF2_MERGESTR
   ida_ida.SW_SEGXRF
   ida_ida.SW_XRFMRK
   ida_ida.SW_XRFFNC
   ida_ida.SW_XRFVAL
   ida_ida.NM_REL_OFF
   ida_ida.NM_PTR_OFF
   ida_ida.NM_NAM_OFF
   ida_ida.NM_REL_EA
   ida_ida.NM_PTR_EA
   ida_ida.NM_NAM_EA
   ida_ida.NM_EA
   ida_ida.NM_EA4
   ida_ida.NM_EA8
   ida_ida.NM_SHORT
   ida_ida.NM_SERIAL
   ida_ida.DEMNAM_MASK
   ida_ida.DEMNAM_CMNT
   ida_ida.DEMNAM_NAME
   ida_ida.DEMNAM_NONE
   ida_ida.DEMNAM_GCC3
   ida_ida.DEMNAM_FIRST
   ida_ida.LN_NORMAL
   ida_ida.LN_PUBLIC
   ida_ida.LN_AUTO
   ida_ida.LN_WEAK
   ida_ida.OFLG_SHOW_VOID
   ida_ida.OFLG_SHOW_AUTO
   ida_ida.OFLG_GEN_NULL
   ida_ida.OFLG_SHOW_PREF
   ida_ida.OFLG_PREF_SEG
   ida_ida.OFLG_LZERO
   ida_ida.OFLG_GEN_ORG
   ida_ida.OFLG_GEN_ASSUME
   ida_ida.OFLG_GEN_TRYBLKS
   ida_ida.SCF_RPTCMT
   ida_ida.SCF_ALLCMT
   ida_ida.SCF_NOCMT
   ida_ida.SCF_LINNUM
   ida_ida.SCF_TESTMODE
   ida_ida.SCF_SHHID_ITEM
   ida_ida.SCF_SHHID_FUNC
   ida_ida.SCF_SHHID_SEGM
   ida_ida.LMT_THIN
   ida_ida.LMT_THICK
   ida_ida.LMT_EMPTY
   ida_ida.PREF_SEGADR
   ida_ida.PREF_FNCOFF
   ida_ida.PREF_STACK
   ida_ida.PREF_PFXTRUNC
   ida_ida.STRF_GEN
   ida_ida.STRF_AUTO
   ida_ida.STRF_SERIAL
   ida_ida.STRF_UNICODE
   ida_ida.STRF_COMMENT
   ida_ida.STRF_SAVECASE
   ida_ida.ABI_8ALIGN4
   ida_ida.ABI_PACK_STKARGS
   ida_ida.ABI_BIGARG_ALIGN
   ida_ida.ABI_STACK_LDBL
   ida_ida.ABI_STACK_VARARGS
   ida_ida.ABI_HARD_FLOAT
   ida_ida.ABI_SET_BY_USER
   ida_ida.ABI_GCC_LAYOUT
   ida_ida.ABI_MAP_STKARGS
   ida_ida.ABI_HUGEARG_ALIGN
   ida_ida.INF_VERSION
   ida_ida.INF_PROCNAME
   ida_ida.INF_GENFLAGS
   ida_ida.INF_LFLAGS
   ida_ida.INF_DATABASE_CHANGE_COUNT
   ida_ida.INF_FILETYPE
   ida_ida.INF_OSTYPE
   ida_ida.INF_APPTYPE
   ida_ida.INF_ASMTYPE
   ida_ida.INF_SPECSEGS
   ida_ida.INF_AF
   ida_ida.INF_AF2
   ida_ida.INF_BASEADDR
   ida_ida.INF_START_SS
   ida_ida.INF_START_CS
   ida_ida.INF_START_IP
   ida_ida.INF_START_EA
   ida_ida.INF_START_SP
   ida_ida.INF_MAIN
   ida_ida.INF_MIN_EA
   ida_ida.INF_MAX_EA
   ida_ida.INF_OMIN_EA
   ida_ida.INF_OMAX_EA
   ida_ida.INF_LOWOFF
   ida_ida.INF_HIGHOFF
   ida_ida.INF_MAXREF
   ida_ida.INF_PRIVRANGE
   ida_ida.INF_PRIVRANGE_START_EA
   ida_ida.INF_PRIVRANGE_END_EA
   ida_ida.INF_NETDELTA
   ida_ida.INF_XREFNUM
   ida_ida.INF_TYPE_XREFNUM
   ida_ida.INF_REFCMTNUM
   ida_ida.INF_XREFFLAG
   ida_ida.INF_MAX_AUTONAME_LEN
   ida_ida.INF_NAMETYPE
   ida_ida.INF_SHORT_DEMNAMES
   ida_ida.INF_LONG_DEMNAMES
   ida_ida.INF_DEMNAMES
   ida_ida.INF_LISTNAMES
   ida_ida.INF_INDENT
   ida_ida.INF_CMT_INDENT
   ida_ida.INF_MARGIN
   ida_ida.INF_LENXREF
   ida_ida.INF_OUTFLAGS
   ida_ida.INF_CMTFLG
   ida_ida.INF_LIMITER
   ida_ida.INF_BIN_PREFIX_SIZE
   ida_ida.INF_PREFFLAG
   ida_ida.INF_STRLIT_FLAGS
   ida_ida.INF_STRLIT_BREAK
   ida_ida.INF_STRLIT_ZEROES
   ida_ida.INF_STRTYPE
   ida_ida.INF_STRLIT_PREF
   ida_ida.INF_STRLIT_SERNUM
   ida_ida.INF_DATATYPES
   ida_ida.INF_OBSOLETE_CC
   ida_ida.INF_CC_ID
   ida_ida.INF_CC_CM
   ida_ida.INF_CC_SIZE_I
   ida_ida.INF_CC_SIZE_B
   ida_ida.INF_CC_SIZE_E
   ida_ida.INF_CC_DEFALIGN
   ida_ida.INF_CC_SIZE_S
   ida_ida.INF_CC_SIZE_L
   ida_ida.INF_CC_SIZE_LL
   ida_ida.INF_CC_SIZE_LDBL
   ida_ida.INF_ABIBITS
   ida_ida.INF_APPCALL_OPTIONS
   ida_ida.INF_FILE_FORMAT_NAME
   ida_ida.INF_GROUPS
   ida_ida.INF_H_PATH
   ida_ida.INF_C_MACROS
   ida_ida.INF_INCLUDE
   ida_ida.INF_DUALOP_GRAPH
   ida_ida.INF_DUALOP_TEXT
   ida_ida.INF_MD5
   ida_ida.INF_IDA_VERSION
   ida_ida.INF_STR_ENCODINGS
   ida_ida.INF_DBG_BINPATHS
   ida_ida.INF_SHA256
   ida_ida.INF_ABINAME
   ida_ida.INF_ARCHIVE_PATH
   ida_ida.INF_PROBLEMS
   ida_ida.INF_SELECTORS
   ida_ida.INF_NOTEPAD
   ida_ida.INF_SRCDBG_PATHS
   ida_ida.INF_SRCDBG_UNDESIRED
   ida_ida.INF_INITIAL_VERSION
   ida_ida.INF_CTIME
   ida_ida.INF_ELAPSED
   ida_ida.INF_NOPENS
   ida_ida.INF_CRC32
   ida_ida.INF_IMAGEBASE
   ida_ida.INF_IDSNODE
   ida_ida.INF_FSIZE
   ida_ida.INF_OUTFILEENC
   ida_ida.INF_INPUT_FILE_PATH
   ida_ida.INF_COMPILER_INFO
   ida_ida.INF_CALLCNV
   ida_ida.INF_LAST
   ida_ida.UA_MAXOP
   ida_ida.IDB_EXT32
   ida_ida.IDB_EXT64
   ida_ida.IDB_EXT
   ida_ida.VLD_AUTO_REPAIR
   ida_ida.VLD_DIALOG
   ida_ida.VLD_SILENT
   ida_ida.IDI_STRUCFLD
   ida_ida.IDI_ALTVAL
   ida_ida.IDI_SUPVAL
   ida_ida.IDI_VALOBJ
   ida_ida.IDI_BLOB
   ida_ida.IDI_SCALAR
   ida_ida.IDI_CSTR
   ida_ida.IDI_QSTRING
   ida_ida.IDI_BYTEARRAY
   ida_ida.IDI_EA_HEX
   ida_ida.IDI_DEC
   ida_ida.IDI_HEX
   ida_ida.IDI_INC
   ida_ida.IDI_MAP_VAL
   ida_ida.IDI_HASH
   ida_ida.IDI_HLPSTRUC
   ida_ida.IDI_READONLY
   ida_ida.IDI_BITMAP
   ida_ida.IDI_ONOFF
   ida_ida.IDI_NOMERGE
   ida_ida.IDI_NODEVAL
   ida_ida.IDI_BUFVAR
   ida_ida.idainfo_big_arg_align
   ida_ida.idainfo_gen_null
   ida_ida.idainfo_set_gen_null
   ida_ida.idainfo_gen_lzero
   ida_ida.idainfo_set_gen_lzero
   ida_ida.idainfo_gen_tryblks
   ida_ida.idainfo_set_gen_tryblks
   ida_ida.idainfo_get_demname_form
   ida_ida.idainfo_get_pack_mode
   ida_ida.idainfo_set_pack_mode
   ida_ida.idainfo_is_64bit
   ida_ida.idainfo_set_64bit
   ida_ida.idainfo_is_auto_enabled
   ida_ida.idainfo_set_auto_enabled
   ida_ida.idainfo_is_be
   ida_ida.idainfo_set_be
   ida_ida.idainfo_is_dll
   ida_ida.idainfo_is_flat_off32
   ida_ida.idainfo_is_graph_view
   ida_ida.idainfo_set_graph_view
   ida_ida.idainfo_is_hard_float
   ida_ida.idainfo_is_kernel_mode
   ida_ida.idainfo_is_mem_aligned4
   ida_ida.idainfo_is_snapshot
   ida_ida.idainfo_is_wide_high_byte_first
   ida_ida.idainfo_set_wide_high_byte_first
   ida_ida.idainfo_like_binary
   ida_ida.idainfo_line_pref_with_seg
   ida_ida.idainfo_set_line_pref_with_seg
   ida_ida.idainfo_show_auto
   ida_ida.idainfo_set_show_auto
   ida_ida.idainfo_show_line_pref
   ida_ida.idainfo_set_show_line_pref
   ida_ida.idainfo_show_void
   ida_ida.idainfo_set_show_void
   ida_ida.idainfo_loading_idc
   ida_ida.idainfo_map_stkargs
   ida_ida.idainfo_pack_stkargs
   ida_ida.idainfo_readonly_idb
   ida_ida.idainfo_set_store_user_info
   ida_ida.idainfo_stack_ldbl
   ida_ida.idainfo_stack_varargs
   ida_ida.idainfo_use_allasm
   ida_ida.idainfo_use_gcc_layout
   ida_ida.macros_enabled
   ida_ida.should_create_stkvars
   ida_ida.should_trace_sp
   ida_ida.show_all_comments
   ida_ida.show_comments
   ida_ida.show_repeatables
   ida_ida.inf_get_comment
   ida_ida.inf_set_comment
   ida_ida.idainfo_comment_get
   ida_ida.idainfo_comment_set


Classes
-------

.. autoapisummary::

   ida_ida.compiler_info_t
   ida_ida.idainfo
   ida_ida.idbattr_valmap_t
   ida_ida.idbattr_info_t


Functions
---------

.. autoapisummary::

   ida_ida.is_filetype_like_binary
   ida_ida.getinf_str
   ida_ida.delinf
   ida_ida.inf_get_version
   ida_ida.inf_set_version
   ida_ida.inf_get_genflags
   ida_ida.inf_set_genflags
   ida_ida.inf_is_auto_enabled
   ida_ida.inf_set_auto_enabled
   ida_ida.inf_use_allasm
   ida_ida.inf_set_use_allasm
   ida_ida.inf_loading_idc
   ida_ida.inf_set_loading_idc
   ida_ida.inf_no_store_user_info
   ida_ida.inf_set_no_store_user_info
   ida_ida.inf_readonly_idb
   ida_ida.inf_set_readonly_idb
   ida_ida.inf_check_manual_ops
   ida_ida.inf_set_check_manual_ops
   ida_ida.inf_allow_non_matched_ops
   ida_ida.inf_set_allow_non_matched_ops
   ida_ida.inf_is_graph_view
   ida_ida.inf_set_graph_view
   ida_ida.inf_get_lflags
   ida_ida.inf_set_lflags
   ida_ida.inf_decode_fpp
   ida_ida.inf_set_decode_fpp
   ida_ida.inf_is_32bit_or_higher
   ida_ida.inf_is_32bit_exactly
   ida_ida.inf_set_32bit
   ida_ida.inf_is_16bit
   ida_ida.inf_is_64bit
   ida_ida.inf_set_64bit
   ida_ida.inf_is_ilp32
   ida_ida.inf_set_ilp32
   ida_ida.inf_is_dll
   ida_ida.inf_set_dll
   ida_ida.inf_is_flat_off32
   ida_ida.inf_set_flat_off32
   ida_ida.inf_is_be
   ida_ida.inf_set_be
   ida_ida.inf_is_wide_high_byte_first
   ida_ida.inf_set_wide_high_byte_first
   ida_ida.inf_dbg_no_store_path
   ida_ida.inf_set_dbg_no_store_path
   ida_ida.inf_is_snapshot
   ida_ida.inf_set_snapshot
   ida_ida.inf_pack_idb
   ida_ida.inf_set_pack_idb
   ida_ida.inf_compress_idb
   ida_ida.inf_set_compress_idb
   ida_ida.inf_is_kernel_mode
   ida_ida.inf_set_kernel_mode
   ida_ida.inf_get_app_bitness
   ida_ida.inf_set_app_bitness
   ida_ida.inf_get_database_change_count
   ida_ida.inf_set_database_change_count
   ida_ida.inf_get_filetype
   ida_ida.inf_set_filetype
   ida_ida.inf_get_ostype
   ida_ida.inf_set_ostype
   ida_ida.inf_get_apptype
   ida_ida.inf_set_apptype
   ida_ida.inf_get_asmtype
   ida_ida.inf_set_asmtype
   ida_ida.inf_get_specsegs
   ida_ida.inf_set_specsegs
   ida_ida.inf_get_af
   ida_ida.inf_set_af
   ida_ida.inf_trace_flow
   ida_ida.inf_set_trace_flow
   ida_ida.inf_mark_code
   ida_ida.inf_set_mark_code
   ida_ida.inf_create_jump_tables
   ida_ida.inf_set_create_jump_tables
   ida_ida.inf_noflow_to_data
   ida_ida.inf_set_noflow_to_data
   ida_ida.inf_create_all_xrefs
   ida_ida.inf_set_create_all_xrefs
   ida_ida.inf_del_no_xref_insns
   ida_ida.inf_set_del_no_xref_insns
   ida_ida.inf_create_func_from_ptr
   ida_ida.inf_set_create_func_from_ptr
   ida_ida.inf_create_func_from_call
   ida_ida.inf_set_create_func_from_call
   ida_ida.inf_create_func_tails
   ida_ida.inf_set_create_func_tails
   ida_ida.inf_should_create_stkvars
   ida_ida.inf_set_should_create_stkvars
   ida_ida.inf_propagate_stkargs
   ida_ida.inf_set_propagate_stkargs
   ida_ida.inf_propagate_regargs
   ida_ida.inf_set_propagate_regargs
   ida_ida.inf_should_trace_sp
   ida_ida.inf_set_should_trace_sp
   ida_ida.inf_full_sp_ana
   ida_ida.inf_set_full_sp_ana
   ida_ida.inf_noret_ana
   ida_ida.inf_set_noret_ana
   ida_ida.inf_guess_func_type
   ida_ida.inf_set_guess_func_type
   ida_ida.inf_truncate_on_del
   ida_ida.inf_set_truncate_on_del
   ida_ida.inf_create_strlit_on_xref
   ida_ida.inf_set_create_strlit_on_xref
   ida_ida.inf_check_unicode_strlits
   ida_ida.inf_set_check_unicode_strlits
   ida_ida.inf_create_off_using_fixup
   ida_ida.inf_set_create_off_using_fixup
   ida_ida.inf_create_off_on_dref
   ida_ida.inf_set_create_off_on_dref
   ida_ida.inf_op_offset
   ida_ida.inf_set_op_offset
   ida_ida.inf_data_offset
   ida_ida.inf_set_data_offset
   ida_ida.inf_use_flirt
   ida_ida.inf_set_use_flirt
   ida_ida.inf_append_sigcmt
   ida_ida.inf_set_append_sigcmt
   ida_ida.inf_allow_sigmulti
   ida_ida.inf_set_allow_sigmulti
   ida_ida.inf_hide_libfuncs
   ida_ida.inf_set_hide_libfuncs
   ida_ida.inf_rename_jumpfunc
   ida_ida.inf_set_rename_jumpfunc
   ida_ida.inf_rename_nullsub
   ida_ida.inf_set_rename_nullsub
   ida_ida.inf_coagulate_data
   ida_ida.inf_set_coagulate_data
   ida_ida.inf_coagulate_code
   ida_ida.inf_set_coagulate_code
   ida_ida.inf_final_pass
   ida_ida.inf_set_final_pass
   ida_ida.inf_get_af2
   ida_ida.inf_set_af2
   ida_ida.inf_handle_eh
   ida_ida.inf_set_handle_eh
   ida_ida.inf_handle_rtti
   ida_ida.inf_set_handle_rtti
   ida_ida.inf_macros_enabled
   ida_ida.inf_set_macros_enabled
   ida_ida.inf_merge_strlits
   ida_ida.inf_set_merge_strlits
   ida_ida.inf_get_baseaddr
   ida_ida.inf_set_baseaddr
   ida_ida.inf_get_start_ss
   ida_ida.inf_set_start_ss
   ida_ida.inf_get_start_cs
   ida_ida.inf_set_start_cs
   ida_ida.inf_get_start_ip
   ida_ida.inf_set_start_ip
   ida_ida.inf_get_start_ea
   ida_ida.inf_set_start_ea
   ida_ida.inf_get_start_sp
   ida_ida.inf_set_start_sp
   ida_ida.inf_get_main
   ida_ida.inf_set_main
   ida_ida.inf_get_min_ea
   ida_ida.inf_set_min_ea
   ida_ida.inf_get_max_ea
   ida_ida.inf_set_max_ea
   ida_ida.inf_get_omin_ea
   ida_ida.inf_set_omin_ea
   ida_ida.inf_get_omax_ea
   ida_ida.inf_set_omax_ea
   ida_ida.inf_get_lowoff
   ida_ida.inf_set_lowoff
   ida_ida.inf_get_highoff
   ida_ida.inf_set_highoff
   ida_ida.inf_get_maxref
   ida_ida.inf_set_maxref
   ida_ida.inf_get_netdelta
   ida_ida.inf_set_netdelta
   ida_ida.inf_get_xrefnum
   ida_ida.inf_set_xrefnum
   ida_ida.inf_get_type_xrefnum
   ida_ida.inf_set_type_xrefnum
   ida_ida.inf_get_refcmtnum
   ida_ida.inf_set_refcmtnum
   ida_ida.inf_get_xrefflag
   ida_ida.inf_set_xrefflag
   ida_ida.inf_show_xref_seg
   ida_ida.inf_set_show_xref_seg
   ida_ida.inf_show_xref_tmarks
   ida_ida.inf_set_show_xref_tmarks
   ida_ida.inf_show_xref_fncoff
   ida_ida.inf_set_show_xref_fncoff
   ida_ida.inf_show_xref_val
   ida_ida.inf_set_show_xref_val
   ida_ida.inf_get_max_autoname_len
   ida_ida.inf_set_max_autoname_len
   ida_ida.inf_get_nametype
   ida_ida.inf_set_nametype
   ida_ida.inf_get_short_demnames
   ida_ida.inf_set_short_demnames
   ida_ida.inf_get_long_demnames
   ida_ida.inf_set_long_demnames
   ida_ida.inf_get_demnames
   ida_ida.inf_set_demnames
   ida_ida.inf_get_listnames
   ida_ida.inf_set_listnames
   ida_ida.inf_get_indent
   ida_ida.inf_set_indent
   ida_ida.inf_get_cmt_indent
   ida_ida.inf_set_cmt_indent
   ida_ida.inf_get_margin
   ida_ida.inf_set_margin
   ida_ida.inf_get_lenxref
   ida_ida.inf_set_lenxref
   ida_ida.inf_get_outflags
   ida_ida.inf_set_outflags
   ida_ida.inf_show_void
   ida_ida.inf_set_show_void
   ida_ida.inf_show_auto
   ida_ida.inf_set_show_auto
   ida_ida.inf_gen_null
   ida_ida.inf_set_gen_null
   ida_ida.inf_show_line_pref
   ida_ida.inf_set_show_line_pref
   ida_ida.inf_line_pref_with_seg
   ida_ida.inf_set_line_pref_with_seg
   ida_ida.inf_gen_lzero
   ida_ida.inf_set_gen_lzero
   ida_ida.inf_gen_org
   ida_ida.inf_set_gen_org
   ida_ida.inf_gen_assume
   ida_ida.inf_set_gen_assume
   ida_ida.inf_gen_tryblks
   ida_ida.inf_set_gen_tryblks
   ida_ida.inf_get_cmtflg
   ida_ida.inf_set_cmtflg
   ida_ida.inf_show_repeatables
   ida_ida.inf_set_show_repeatables
   ida_ida.inf_show_all_comments
   ida_ida.inf_set_show_all_comments
   ida_ida.inf_hide_comments
   ida_ida.inf_set_hide_comments
   ida_ida.inf_show_src_linnum
   ida_ida.inf_set_show_src_linnum
   ida_ida.inf_test_mode
   ida_ida.inf_show_hidden_insns
   ida_ida.inf_set_show_hidden_insns
   ida_ida.inf_show_hidden_funcs
   ida_ida.inf_set_show_hidden_funcs
   ida_ida.inf_show_hidden_segms
   ida_ida.inf_set_show_hidden_segms
   ida_ida.inf_get_limiter
   ida_ida.inf_set_limiter
   ida_ida.inf_is_limiter_thin
   ida_ida.inf_set_limiter_thin
   ida_ida.inf_is_limiter_thick
   ida_ida.inf_set_limiter_thick
   ida_ida.inf_is_limiter_empty
   ida_ida.inf_set_limiter_empty
   ida_ida.inf_get_bin_prefix_size
   ida_ida.inf_set_bin_prefix_size
   ida_ida.inf_get_prefflag
   ida_ida.inf_set_prefflag
   ida_ida.inf_prefix_show_segaddr
   ida_ida.inf_set_prefix_show_segaddr
   ida_ida.inf_prefix_show_funcoff
   ida_ida.inf_set_prefix_show_funcoff
   ida_ida.inf_prefix_show_stack
   ida_ida.inf_set_prefix_show_stack
   ida_ida.inf_prefix_truncate_opcode_bytes
   ida_ida.inf_set_prefix_truncate_opcode_bytes
   ida_ida.inf_get_strlit_flags
   ida_ida.inf_set_strlit_flags
   ida_ida.inf_strlit_names
   ida_ida.inf_set_strlit_names
   ida_ida.inf_strlit_name_bit
   ida_ida.inf_set_strlit_name_bit
   ida_ida.inf_strlit_serial_names
   ida_ida.inf_set_strlit_serial_names
   ida_ida.inf_unicode_strlits
   ida_ida.inf_set_unicode_strlits
   ida_ida.inf_strlit_autocmt
   ida_ida.inf_set_strlit_autocmt
   ida_ida.inf_strlit_savecase
   ida_ida.inf_set_strlit_savecase
   ida_ida.inf_get_strlit_break
   ida_ida.inf_set_strlit_break
   ida_ida.inf_get_strlit_zeroes
   ida_ida.inf_set_strlit_zeroes
   ida_ida.inf_get_strtype
   ida_ida.inf_set_strtype
   ida_ida.inf_get_strlit_sernum
   ida_ida.inf_set_strlit_sernum
   ida_ida.inf_get_datatypes
   ida_ida.inf_set_datatypes
   ida_ida.inf_get_abibits
   ida_ida.inf_set_abibits
   ida_ida.inf_is_mem_aligned4
   ida_ida.inf_set_mem_aligned4
   ida_ida.inf_pack_stkargs
   ida_ida.inf_set_pack_stkargs
   ida_ida.inf_big_arg_align
   ida_ida.inf_set_big_arg_align
   ida_ida.inf_stack_ldbl
   ida_ida.inf_set_stack_ldbl
   ida_ida.inf_stack_varargs
   ida_ida.inf_set_stack_varargs
   ida_ida.inf_is_hard_float
   ida_ida.inf_set_hard_float
   ida_ida.inf_abi_set_by_user
   ida_ida.inf_set_abi_set_by_user
   ida_ida.inf_use_gcc_layout
   ida_ida.inf_set_use_gcc_layout
   ida_ida.inf_map_stkargs
   ida_ida.inf_set_map_stkargs
   ida_ida.inf_huge_arg_align
   ida_ida.inf_set_huge_arg_align
   ida_ida.inf_get_appcall_options
   ida_ida.inf_set_appcall_options
   ida_ida.inf_get_privrange_start_ea
   ida_ida.inf_set_privrange_start_ea
   ida_ida.inf_get_privrange_end_ea
   ida_ida.inf_set_privrange_end_ea
   ida_ida.inf_get_cc_id
   ida_ida.inf_set_cc_id
   ida_ida.inf_get_cc_cm
   ida_ida.inf_set_cc_cm
   ida_ida.inf_get_callcnv
   ida_ida.inf_set_callcnv
   ida_ida.inf_get_cc_size_i
   ida_ida.inf_set_cc_size_i
   ida_ida.inf_get_cc_size_b
   ida_ida.inf_set_cc_size_b
   ida_ida.inf_get_cc_size_e
   ida_ida.inf_set_cc_size_e
   ida_ida.inf_get_cc_defalign
   ida_ida.inf_set_cc_defalign
   ida_ida.inf_get_cc_size_s
   ida_ida.inf_set_cc_size_s
   ida_ida.inf_get_cc_size_l
   ida_ida.inf_set_cc_size_l
   ida_ida.inf_get_cc_size_ll
   ida_ida.inf_set_cc_size_ll
   ida_ida.inf_get_cc_size_ldbl
   ida_ida.inf_set_cc_size_ldbl
   ida_ida.inf_get_procname
   ida_ida.inf_set_procname
   ida_ida.inf_get_strlit_pref
   ida_ida.inf_set_strlit_pref
   ida_ida.inf_get_cc
   ida_ida.inf_set_cc
   ida_ida.inf_set_privrange
   ida_ida.inf_get_privrange
   ida_ida.inf_get_af_low
   ida_ida.inf_set_af_low
   ida_ida.inf_get_af_high
   ida_ida.inf_set_af_high
   ida_ida.inf_get_af2_low
   ida_ida.inf_set_af2_low
   ida_ida.inf_get_pack_mode
   ida_ida.inf_set_pack_mode
   ida_ida.inf_inc_database_change_count
   ida_ida.inf_get_demname_form
   ida_ida.inf_postinc_strlit_sernum
   ida_ida.inf_like_binary
   ida_ida.calc_default_idaplace_flags
   ida_ida.to_ea
   ida_ida.get_dbctx_id
   ida_ida.get_dbctx_qty
   ida_ida.switch_dbctx
   ida_ida.is_database_busy
   ida_ida.validate_idb
   ida_ida.move_privrange
   ida_ida.idainfo_is_32bit


Module Contents
---------------

.. py:data:: AF_FINAL

   Final pass of analysis.


.. py:data:: f_EXE_old

   MS DOS EXE File.


.. py:data:: f_COM_old

   MS DOS COM File.


.. py:data:: f_BIN

   Binary File.


.. py:data:: f_DRV

   MS DOS Driver.


.. py:data:: f_WIN

   New Executable (NE)


.. py:data:: f_HEX

   Intel Hex Object File.


.. py:data:: f_MEX

   MOS Technology Hex Object File.


.. py:data:: f_LX

   Linear Executable (LX)


.. py:data:: f_LE

   Linear Executable (LE)


.. py:data:: f_NLM

   Netware Loadable Module (NLM)


.. py:data:: f_COFF

   Common Object File Format (COFF)


.. py:data:: f_PE

   Portable Executable (PE)


.. py:data:: f_OMF

   Object Module Format.


.. py:data:: f_SREC

   Motorola SREC (S-record)


.. py:data:: f_ZIP

   ZIP file (this file is never loaded to IDA database)


.. py:data:: f_OMFLIB

   Library of OMF Modules.


.. py:data:: f_AR

   ar library


.. py:data:: f_LOADER

   file is loaded using LOADER DLL


.. py:data:: f_ELF

   Executable and Linkable Format (ELF)


.. py:data:: f_W32RUN

   Watcom DOS32 Extender (W32RUN)


.. py:data:: f_AOUT

   Linux a.out (AOUT)


.. py:data:: f_PRC

   PalmPilot program file.


.. py:data:: f_EXE

   MS DOS EXE File.


.. py:data:: f_COM

   MS DOS COM File.


.. py:data:: f_AIXAR

   AIX ar library.


.. py:data:: f_MACHO

   Mac OS X Mach-O.


.. py:data:: f_PSXOBJ

   Sony Playstation PSX object file.


.. py:data:: f_MD1IMG

   Mediatek Firmware Image.


.. py:function:: is_filetype_like_binary(ft: filetype_t) -> bool

   Is unstructured input file?


.. py:class:: compiler_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: id
      :type:  comp_t

      compiler id (see Compiler IDs)



   .. py:attribute:: cm
      :type:  cm_t

      memory model and calling convention (see CM) see also get_cc/set_cc 
              



   .. py:attribute:: size_i
      :type:  uchar

      sizeof(int)



   .. py:attribute:: size_b
      :type:  uchar

      sizeof(bool)



   .. py:attribute:: size_e
      :type:  uchar

      sizeof(enum)



   .. py:attribute:: defalign
      :type:  uchar

      default alignment for structures



   .. py:attribute:: size_s
      :type:  uchar

      short



   .. py:attribute:: size_l
      :type:  uchar

      long



   .. py:attribute:: size_ll
      :type:  uchar

      longlong



   .. py:attribute:: size_ldbl
      :type:  uchar

      longdouble (if different from processor_t::tbyte_size)



   .. py:method:: get_cc() -> callcnv_t


   .. py:method:: set_cc(cc: callcnv_t) -> None


.. py:data:: STT_CUR

   use current storage type (may be used only as a function argument)


.. py:data:: STT_VA

   regular storage: virtual arrays, an explicit flag for each byte


.. py:data:: STT_MM

   memory map: sparse storage. useful for huge objects


.. py:data:: STT_DBG

   memory map: temporary debugger storage. used internally


.. py:data:: IDAINFO_TAG_SIZE

   The database parameters. This structure is kept in the ida database. It contains the essential parameters for the current program 
           


.. py:data:: IDAINFO_PROCNAME_SIZE

.. py:data:: IDAINFO_STRLIT_PREF_SIZE

.. py:class:: idainfo(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: tag
      :type:  char [3]

      'IDA'



   .. py:attribute:: version
      :type:  ushort

      Version of database.



   .. py:attribute:: procname
      :type:  char [16]

      Name of the current processor (with \0)



   .. py:attribute:: s_genflags
      :type:  ushort

      General idainfo flags 
              



   .. py:attribute:: database_change_count
      :type:  int

      incremented after each byte and regular segment modifications 
              



   .. py:attribute:: filetype
      :type:  ushort

      The input file type.



   .. py:attribute:: ostype
      :type:  ushort

      OS type the program is for bit definitions in libfuncs.hpp 
              



   .. py:attribute:: apptype
      :type:  ushort

      Application type bit definitions in libfuncs.hpp 
              



   .. py:attribute:: asmtype
      :type:  uchar

      target assembler number



   .. py:attribute:: specsegs
      :type:  uchar

      What format do special segments use? 0-unspecified, 4-entries are 4 bytes, 8- entries are 8 bytes.



   .. py:attribute:: af
      :type:  int

      Analysis flags 
              



   .. py:attribute:: af2
      :type:  int

      Analysis flags 2 
              



   .. py:attribute:: baseaddr
      :type:  int

      remaining 28 bits are reserved

      base address of the program (paragraphs) 
              



   .. py:attribute:: start_ss
      :type:  sel_t

      selector of the initial stack segment



   .. py:attribute:: start_cs
      :type:  sel_t

      selector of the segment with the main entry point



   .. py:attribute:: start_ip
      :type:  ida_idaapi.ea_t

      IP register value at the start of program execution 
              



   .. py:attribute:: start_ea
      :type:  ida_idaapi.ea_t

      Linear address of program entry point.



   .. py:attribute:: start_sp
      :type:  ida_idaapi.ea_t

      SP register value at the start of program execution 
              



   .. py:attribute:: main
      :type:  ida_idaapi.ea_t

      address of main()



   .. py:attribute:: min_ea
      :type:  ida_idaapi.ea_t

      current limits of program



   .. py:attribute:: max_ea
      :type:  ida_idaapi.ea_t

      maxEA is excluded



   .. py:attribute:: omin_ea
      :type:  ida_idaapi.ea_t

      original minEA (is set after loading the input file)



   .. py:attribute:: omax_ea
      :type:  ida_idaapi.ea_t

      original maxEA (is set after loading the input file)



   .. py:attribute:: lowoff
      :type:  ida_idaapi.ea_t

      Low limit for offsets (used in calculation of 'void' operands) 
              



   .. py:attribute:: highoff
      :type:  ida_idaapi.ea_t

      High limit for offsets (used in calculation of 'void' operands) 
              



   .. py:attribute:: maxref
      :type:  int

      Max tail for references.



   .. py:attribute:: xrefnum
      :type:  uchar

      CROSS REFERENCES.

      Number of references to generate in the disassembly listing 0 - xrefs won't be generated at all 
              



   .. py:attribute:: type_xrefnum
      :type:  uchar

      Number of references to generate in the struct & enum windows 0 - xrefs won't be generated at all 
              



   .. py:attribute:: refcmtnum
      :type:  uchar

      Number of comment lines to generate for refs to string literals or demangled names 0 - such comments won't be generated at all 
              



   .. py:attribute:: s_xrefflag
      :type:  uchar

      Xref options 
              



   .. py:attribute:: max_autoname_len
      :type:  ushort

      NAMES.

      max autogenerated name length (without zero byte) 
              



   .. py:attribute:: nametype
      :type:  char

      Dummy names representation types 
              



   .. py:attribute:: short_demnames
      :type:  int

      short form of demangled names



   .. py:attribute:: long_demnames
      :type:  int

      long form of demangled names see demangle.h for definitions 
              



   .. py:attribute:: demnames
      :type:  uchar

      Demangled name flags 
              



   .. py:attribute:: listnames
      :type:  uchar

      Name list options 
              



   .. py:attribute:: indent
      :type:  uchar

      DISASSEMBLY LISTING DETAILS.

      Indentation for instructions 
              



   .. py:attribute:: cmt_indent
      :type:  uchar

      Indentation for comments.



   .. py:attribute:: margin
      :type:  ushort

      max length of data lines



   .. py:attribute:: lenxref
      :type:  ushort

      max length of line with xrefs



   .. py:attribute:: outflags
      :type:  int

      output flags 
              



   .. py:attribute:: s_cmtflg
      :type:  uchar

      Comment options 
              



   .. py:attribute:: s_limiter
      :type:  uchar

      Delimiter options 
              



   .. py:attribute:: bin_prefix_size
      :type:  short

      Number of instruction bytes (opcodes) to show in line prefix.



   .. py:attribute:: s_prefflag
      :type:  uchar

      Line prefix options 
              



   .. py:attribute:: strlit_flags
      :type:  uchar

      STRING LITERALS.

      string literal flags 
              



   .. py:attribute:: strlit_break
      :type:  uchar

      string literal line break symbol



   .. py:attribute:: strlit_zeroes
      :type:  char

      leading zeroes



   .. py:attribute:: strtype
      :type:  int

      current ascii string type see nalt.hpp for string types 
              



   .. py:attribute:: strlit_pref
      :type:  char [16]

      prefix for string literal names



   .. py:attribute:: strlit_sernum
      :type:  int

      serial number



   .. py:attribute:: datatypes
      :type:  int

      data types allowed in data carousel



   .. py:attribute:: cc
      :type:  compiler_info_t

      COMPILER.

      Target compiler 
              



   .. py:attribute:: abibits
      :type:  int

      ABI features. Depends on info returned by get_abi_name() Processor modules may modify them in set_compiler 
              



   .. py:attribute:: appcall_options
      :type:  int

      appcall options, see idd.hpp



   .. py:method:: get_abiname() -> str


   .. py:attribute:: abiname


   .. py:attribute:: lflags

      Misc. database flags 
              



   .. py:attribute:: minEA


   .. py:attribute:: maxEA


   .. py:attribute:: procName


.. py:data:: INFFL_AUTO

   Autoanalysis is enabled?


.. py:data:: INFFL_ALLASM

   may use constructs not supported by the target assembler 
           


.. py:data:: INFFL_LOADIDC

   loading an idc file that contains database info


.. py:data:: INFFL_NOUSER

   do not store user info in the database


.. py:data:: INFFL_READONLY

   (internal) temporary interdiction to modify the database


.. py:data:: INFFL_CHKOPS

   check manual operands? (unused)


.. py:data:: INFFL_NMOPS

   allow non-matched operands? (unused)


.. py:data:: INFFL_GRAPH_VIEW

   currently using graph options ( text_options_t::graph)


.. py:data:: LFLG_PC_FPP

   decode floating point processor instructions?


.. py:data:: LFLG_PC_FLAT

   32-bit program (or higher)?


.. py:data:: LFLG_64BIT

   64-bit program?


.. py:data:: LFLG_IS_DLL

   Is dynamic library?


.. py:data:: LFLG_FLAT_OFF32

   treat REF_OFF32 as 32-bit offset for 16bit segments (otherwise try SEG16:OFF16)


.. py:data:: LFLG_MSF

   Byte order: is MSB first?


.. py:data:: LFLG_WIDE_HBF

   Bit order of wide bytes: high byte first? (wide bytes: processor_t::dnbits > 8) 
           


.. py:data:: LFLG_DBG_NOPATH

   do not store input full path in debugger process options


.. py:data:: LFLG_SNAPSHOT

   memory snapshot was taken?


.. py:data:: LFLG_PACK

   pack the database?


.. py:data:: LFLG_COMPRESS

   compress the database?


.. py:data:: LFLG_KERNMODE

   is kernel mode binary?


.. py:data:: LFLG_ILP32

   64-bit instructions with 64-bit registers, but 32-bit pointers and address space. this bit is mutually exclusive with LFLG_64BIT 
           


.. py:data:: IDB_UNPACKED

   leave database components unpacked


.. py:data:: IDB_PACKED

   pack database components into .idb


.. py:data:: IDB_COMPRESSED

   compress & pack database components


.. py:data:: AF_CODE

   Trace execution flow.


.. py:data:: AF_MARKCODE

   Mark typical code sequences as code.


.. py:data:: AF_JUMPTBL

   Locate and create jump tables.


.. py:data:: AF_PURDAT

   Control flow to data segment is ignored.


.. py:data:: AF_USED

   Analyze and create all xrefs.


.. py:data:: AF_UNK

   Delete instructions with no xrefs.


.. py:data:: AF_PROCPTR

   Create function if data xref data->code32 exists.


.. py:data:: AF_PROC

   Create functions if call is present.


.. py:data:: AF_FTAIL

   Create function tails.


.. py:data:: AF_LVAR

   Create stack variables.


.. py:data:: AF_STKARG

   Propagate stack argument information.


.. py:data:: AF_REGARG

   Propagate register argument information.


.. py:data:: AF_TRACE

   Trace stack pointer.


.. py:data:: AF_VERSP

   Perform full SP-analysis. ( processor_t::verify_sp)


.. py:data:: AF_ANORET

   Perform 'no-return' analysis.


.. py:data:: AF_MEMFUNC

   Try to guess member function types.


.. py:data:: AF_TRFUNC

   Truncate functions upon code deletion.


.. py:data:: AF_STRLIT

   Create string literal if data xref exists.


.. py:data:: AF_CHKUNI

   Check for unicode strings.


.. py:data:: AF_FIXUP

   Create offsets and segments using fixup info.


.. py:data:: AF_DREFOFF

   Create offset if data xref to seg32 exists.


.. py:data:: AF_IMMOFF

   Convert 32bit instruction operand to offset.


.. py:data:: AF_DATOFF

   Automatically convert data to offsets.


.. py:data:: AF_FLIRT

   Use flirt signatures.


.. py:data:: AF_SIGCMT

   Append a signature name comment for recognized anonymous library functions.


.. py:data:: AF_SIGMLT

   Allow recognition of several copies of the same function.


.. py:data:: AF_HFLIRT

   Automatically hide library functions.


.. py:data:: AF_JFUNC

   Rename jump functions as j_...


.. py:data:: AF_NULLSUB

   Rename empty functions as nullsub_...


.. py:data:: AF_DODATA

   Coagulate data segs at the final pass.


.. py:data:: AF_DOCODE

   Coagulate code segs at the final pass.


.. py:data:: AF2_DOEH

   Handle EH information.


.. py:data:: AF2_DORTTI

   Handle RTTI information.


.. py:data:: AF2_MACRO

   Try to combine several instructions into a macro instruction 
           


.. py:data:: AF2_MERGESTR

   Merge string literals created using data xrefs 
           


.. py:data:: SW_SEGXRF

   show segments in xrefs?


.. py:data:: SW_XRFMRK

   show xref type marks?


.. py:data:: SW_XRFFNC

   show function offsets?


.. py:data:: SW_XRFVAL

   show xref values? (otherwise-"...")


.. py:data:: NM_REL_OFF

.. py:data:: NM_PTR_OFF

.. py:data:: NM_NAM_OFF

.. py:data:: NM_REL_EA

.. py:data:: NM_PTR_EA

.. py:data:: NM_NAM_EA

.. py:data:: NM_EA

.. py:data:: NM_EA4

.. py:data:: NM_EA8

.. py:data:: NM_SHORT

.. py:data:: NM_SERIAL

.. py:data:: DEMNAM_MASK

   mask for name form


.. py:data:: DEMNAM_CMNT

   display demangled names as comments


.. py:data:: DEMNAM_NAME

   display demangled names as regular names


.. py:data:: DEMNAM_NONE

   don't display demangled names


.. py:data:: DEMNAM_GCC3

   assume gcc3 names (valid for gnu compiler)


.. py:data:: DEMNAM_FIRST

   override type info


.. py:data:: LN_NORMAL

   include normal names


.. py:data:: LN_PUBLIC

   include public names


.. py:data:: LN_AUTO

   include autogenerated names


.. py:data:: LN_WEAK

   include weak names


.. py:data:: OFLG_SHOW_VOID

   Display void marks?


.. py:data:: OFLG_SHOW_AUTO

   Display autoanalysis indicator?


.. py:data:: OFLG_GEN_NULL

   Generate empty lines?


.. py:data:: OFLG_SHOW_PREF

   Show line prefixes?


.. py:data:: OFLG_PREF_SEG

   line prefixes with segment name?


.. py:data:: OFLG_LZERO

   generate leading zeroes in numbers


.. py:data:: OFLG_GEN_ORG

   Generate 'org' directives?


.. py:data:: OFLG_GEN_ASSUME

   Generate 'assume' directives?


.. py:data:: OFLG_GEN_TRYBLKS

   Generate try/catch directives?


.. py:data:: SCF_RPTCMT

   show repeatable comments?


.. py:data:: SCF_ALLCMT

   comment all lines?


.. py:data:: SCF_NOCMT

   no comments at all


.. py:data:: SCF_LINNUM

   show source line numbers


.. py:data:: SCF_TESTMODE

   testida.idc is running


.. py:data:: SCF_SHHID_ITEM

   show hidden instructions


.. py:data:: SCF_SHHID_FUNC

   show hidden functions


.. py:data:: SCF_SHHID_SEGM

   show hidden segments


.. py:data:: LMT_THIN

   thin borders


.. py:data:: LMT_THICK

   thick borders


.. py:data:: LMT_EMPTY

   empty lines at the end of basic blocks


.. py:data:: PREF_SEGADR

   show segment addresses?


.. py:data:: PREF_FNCOFF

   show function offsets?


.. py:data:: PREF_STACK

   show stack pointer?


.. py:data:: PREF_PFXTRUNC

   truncate instruction bytes if they would need more than 1 line


.. py:data:: STRF_GEN

   generate names?


.. py:data:: STRF_AUTO

   names have 'autogenerated' bit?


.. py:data:: STRF_SERIAL

   generate serial names?


.. py:data:: STRF_UNICODE

   unicode strings are present?


.. py:data:: STRF_COMMENT

   generate auto comment for string references?


.. py:data:: STRF_SAVECASE

   preserve case of strings for identifiers


.. py:data:: ABI_8ALIGN4

   4 byte alignment for 8byte scalars (__int64/double) inside structures?


.. py:data:: ABI_PACK_STKARGS

   do not align stack arguments to stack slots


.. py:data:: ABI_BIGARG_ALIGN

   use natural type alignment for argument if the alignment exceeds native word size. (e.g. __int64 argument should be 8byte aligned on some 32bit platforms) 
           


.. py:data:: ABI_STACK_LDBL

   long double arguments are passed on stack


.. py:data:: ABI_STACK_VARARGS

   varargs are always passed on stack (even when there are free registers)


.. py:data:: ABI_HARD_FLOAT

   use the floating-point register set


.. py:data:: ABI_SET_BY_USER

   compiler/abi were set by user flag and require SETCOMP_BY_USER flag to be changed


.. py:data:: ABI_GCC_LAYOUT

   use gcc layout for udts (used for mingw)


.. py:data:: ABI_MAP_STKARGS

   register arguments are mapped to stack area (and consume stack slots)


.. py:data:: ABI_HUGEARG_ALIGN

   use natural type alignment for an argument even if its alignment exceeds double native word size (the default is to use double word max). e.g. if this bit is set, __int128 has 16-byte alignment. this bit is not used by ida yet 
           


.. py:data:: INF_VERSION

.. py:data:: INF_PROCNAME

.. py:data:: INF_GENFLAGS

.. py:data:: INF_LFLAGS

.. py:data:: INF_DATABASE_CHANGE_COUNT

.. py:data:: INF_FILETYPE

.. py:data:: INF_OSTYPE

.. py:data:: INF_APPTYPE

.. py:data:: INF_ASMTYPE

.. py:data:: INF_SPECSEGS

.. py:data:: INF_AF

.. py:data:: INF_AF2

.. py:data:: INF_BASEADDR

.. py:data:: INF_START_SS

.. py:data:: INF_START_CS

.. py:data:: INF_START_IP

.. py:data:: INF_START_EA

.. py:data:: INF_START_SP

.. py:data:: INF_MAIN

.. py:data:: INF_MIN_EA

.. py:data:: INF_MAX_EA

.. py:data:: INF_OMIN_EA

.. py:data:: INF_OMAX_EA

.. py:data:: INF_LOWOFF

.. py:data:: INF_HIGHOFF

.. py:data:: INF_MAXREF

.. py:data:: INF_PRIVRANGE

.. py:data:: INF_PRIVRANGE_START_EA

.. py:data:: INF_PRIVRANGE_END_EA

.. py:data:: INF_NETDELTA

.. py:data:: INF_XREFNUM

.. py:data:: INF_TYPE_XREFNUM

.. py:data:: INF_REFCMTNUM

.. py:data:: INF_XREFFLAG

.. py:data:: INF_MAX_AUTONAME_LEN

.. py:data:: INF_NAMETYPE

.. py:data:: INF_SHORT_DEMNAMES

.. py:data:: INF_LONG_DEMNAMES

.. py:data:: INF_DEMNAMES

.. py:data:: INF_LISTNAMES

.. py:data:: INF_INDENT

.. py:data:: INF_CMT_INDENT

.. py:data:: INF_MARGIN

.. py:data:: INF_LENXREF

.. py:data:: INF_OUTFLAGS

.. py:data:: INF_CMTFLG

.. py:data:: INF_LIMITER

.. py:data:: INF_BIN_PREFIX_SIZE

.. py:data:: INF_PREFFLAG

.. py:data:: INF_STRLIT_FLAGS

.. py:data:: INF_STRLIT_BREAK

.. py:data:: INF_STRLIT_ZEROES

.. py:data:: INF_STRTYPE

.. py:data:: INF_STRLIT_PREF

.. py:data:: INF_STRLIT_SERNUM

.. py:data:: INF_DATATYPES

.. py:data:: INF_OBSOLETE_CC

.. py:data:: INF_CC_ID

.. py:data:: INF_CC_CM

.. py:data:: INF_CC_SIZE_I

.. py:data:: INF_CC_SIZE_B

.. py:data:: INF_CC_SIZE_E

.. py:data:: INF_CC_DEFALIGN

.. py:data:: INF_CC_SIZE_S

.. py:data:: INF_CC_SIZE_L

.. py:data:: INF_CC_SIZE_LL

.. py:data:: INF_CC_SIZE_LDBL

.. py:data:: INF_ABIBITS

.. py:data:: INF_APPCALL_OPTIONS

.. py:data:: INF_FILE_FORMAT_NAME

   file format name for loader modules


.. py:data:: INF_GROUPS

   segment group information (see init_groups())


.. py:data:: INF_H_PATH

   C header path.


.. py:data:: INF_C_MACROS

   C predefined macros.


.. py:data:: INF_INCLUDE

   assembler include file name


.. py:data:: INF_DUALOP_GRAPH

   Graph text representation options.


.. py:data:: INF_DUALOP_TEXT

   Text text representation options.


.. py:data:: INF_MD5

   MD5 of the input file.


.. py:data:: INF_IDA_VERSION

   version of ida which created the database


.. py:data:: INF_STR_ENCODINGS

   a list of encodings for the program strings


.. py:data:: INF_DBG_BINPATHS

   unused (20 indexes)


.. py:data:: INF_SHA256

   SHA256 of the input file.


.. py:data:: INF_ABINAME

   ABI name (processor specific)


.. py:data:: INF_ARCHIVE_PATH

   archive file path


.. py:data:: INF_PROBLEMS

   problem lists


.. py:data:: INF_SELECTORS

   2..63 are for selector_t blob (see init_selectors())


.. py:data:: INF_NOTEPAD

   notepad blob, occupies 1000 indexes (1MB of text)


.. py:data:: INF_SRCDBG_PATHS

   source debug paths, occupies 20 indexes


.. py:data:: INF_SRCDBG_UNDESIRED

   user-closed source files, occupies 20 indexes


.. py:data:: INF_INITIAL_VERSION

   initial version of database


.. py:data:: INF_CTIME

   database creation timestamp


.. py:data:: INF_ELAPSED

   seconds database stayed open


.. py:data:: INF_NOPENS

   how many times the database is opened


.. py:data:: INF_CRC32

   input file crc32


.. py:data:: INF_IMAGEBASE

   image base


.. py:data:: INF_IDSNODE

   ids modnode id (for import_module)


.. py:data:: INF_FSIZE

   input file size


.. py:data:: INF_OUTFILEENC

   output file encoding index


.. py:data:: INF_INPUT_FILE_PATH

.. py:data:: INF_COMPILER_INFO

.. py:data:: INF_CALLCNV

.. py:data:: INF_LAST

.. py:function:: getinf_str(tag: inftag_t) -> str

   Get program specific information (a non-scalar value) 
           
   :param tag: one of inftag_t constants
   :returns: number of bytes stored in the buffer (<0 - not defined)


.. py:function:: delinf(tag: inftag_t) -> bool

   Undefine a program specific information 
           
   :param tag: one of inftag_t constants
   :returns: success


.. py:function:: inf_get_version() -> ushort

.. py:function:: inf_set_version(_v: ushort) -> bool

.. py:function:: inf_get_genflags() -> ushort

.. py:function:: inf_set_genflags(_v: ushort) -> bool

.. py:function:: inf_is_auto_enabled() -> bool

.. py:function:: inf_set_auto_enabled(_v: bool = True) -> bool

.. py:function:: inf_use_allasm() -> bool

.. py:function:: inf_set_use_allasm(_v: bool = True) -> bool

.. py:function:: inf_loading_idc() -> bool

.. py:function:: inf_set_loading_idc(_v: bool = True) -> bool

.. py:function:: inf_no_store_user_info() -> bool

.. py:function:: inf_set_no_store_user_info(_v: bool = True) -> bool

.. py:function:: inf_readonly_idb() -> bool

.. py:function:: inf_set_readonly_idb(_v: bool = True) -> bool

.. py:function:: inf_check_manual_ops() -> bool

.. py:function:: inf_set_check_manual_ops(_v: bool = True) -> bool

.. py:function:: inf_allow_non_matched_ops() -> bool

.. py:function:: inf_set_allow_non_matched_ops(_v: bool = True) -> bool

.. py:function:: inf_is_graph_view() -> bool

.. py:function:: inf_set_graph_view(_v: bool = True) -> bool

.. py:function:: inf_get_lflags() -> int

.. py:function:: inf_set_lflags(_v: int) -> bool

.. py:function:: inf_decode_fpp() -> bool

.. py:function:: inf_set_decode_fpp(_v: bool = True) -> bool

.. py:function:: inf_is_32bit_or_higher() -> bool

.. py:function:: inf_is_32bit_exactly() -> bool

.. py:function:: inf_set_32bit(_v: bool = True) -> bool

.. py:function:: inf_is_16bit() -> bool

.. py:function:: inf_is_64bit() -> bool

.. py:function:: inf_set_64bit(_v: bool = True) -> bool

.. py:function:: inf_is_ilp32() -> bool

.. py:function:: inf_set_ilp32(_v: bool = True) -> bool

.. py:function:: inf_is_dll() -> bool

.. py:function:: inf_set_dll(_v: bool = True) -> bool

.. py:function:: inf_is_flat_off32() -> bool

.. py:function:: inf_set_flat_off32(_v: bool = True) -> bool

.. py:function:: inf_is_be() -> bool

.. py:function:: inf_set_be(_v: bool = True) -> bool

.. py:function:: inf_is_wide_high_byte_first() -> bool

.. py:function:: inf_set_wide_high_byte_first(_v: bool = True) -> bool

.. py:function:: inf_dbg_no_store_path() -> bool

.. py:function:: inf_set_dbg_no_store_path(_v: bool = True) -> bool

.. py:function:: inf_is_snapshot() -> bool

.. py:function:: inf_set_snapshot(_v: bool = True) -> bool

.. py:function:: inf_pack_idb() -> bool

.. py:function:: inf_set_pack_idb(_v: bool = True) -> bool

.. py:function:: inf_compress_idb() -> bool

.. py:function:: inf_set_compress_idb(_v: bool = True) -> bool

.. py:function:: inf_is_kernel_mode() -> bool

.. py:function:: inf_set_kernel_mode(_v: bool = True) -> bool

.. py:function:: inf_get_app_bitness() -> uint

.. py:function:: inf_set_app_bitness(bitness: uint) -> None

.. py:function:: inf_get_database_change_count() -> int

.. py:function:: inf_set_database_change_count(_v: int) -> bool

.. py:function:: inf_get_filetype() -> filetype_t

.. py:function:: inf_set_filetype(_v: filetype_t) -> bool

.. py:function:: inf_get_ostype() -> ushort

.. py:function:: inf_set_ostype(_v: ushort) -> bool

.. py:function:: inf_get_apptype() -> ushort

.. py:function:: inf_set_apptype(_v: ushort) -> bool

.. py:function:: inf_get_asmtype() -> uchar

.. py:function:: inf_set_asmtype(_v: uchar) -> bool

.. py:function:: inf_get_specsegs() -> uchar

.. py:function:: inf_set_specsegs(_v: uchar) -> bool

.. py:function:: inf_get_af() -> int

.. py:function:: inf_set_af(_v: int) -> bool

.. py:function:: inf_trace_flow() -> bool

.. py:function:: inf_set_trace_flow(_v: bool = True) -> bool

.. py:function:: inf_mark_code() -> bool

.. py:function:: inf_set_mark_code(_v: bool = True) -> bool

.. py:function:: inf_create_jump_tables() -> bool

.. py:function:: inf_set_create_jump_tables(_v: bool = True) -> bool

.. py:function:: inf_noflow_to_data() -> bool

.. py:function:: inf_set_noflow_to_data(_v: bool = True) -> bool

.. py:function:: inf_create_all_xrefs() -> bool

.. py:function:: inf_set_create_all_xrefs(_v: bool = True) -> bool

.. py:function:: inf_del_no_xref_insns() -> bool

.. py:function:: inf_set_del_no_xref_insns(_v: bool = True) -> bool

.. py:function:: inf_create_func_from_ptr() -> bool

.. py:function:: inf_set_create_func_from_ptr(_v: bool = True) -> bool

.. py:function:: inf_create_func_from_call() -> bool

.. py:function:: inf_set_create_func_from_call(_v: bool = True) -> bool

.. py:function:: inf_create_func_tails() -> bool

.. py:function:: inf_set_create_func_tails(_v: bool = True) -> bool

.. py:function:: inf_should_create_stkvars() -> bool

.. py:function:: inf_set_should_create_stkvars(_v: bool = True) -> bool

.. py:function:: inf_propagate_stkargs() -> bool

.. py:function:: inf_set_propagate_stkargs(_v: bool = True) -> bool

.. py:function:: inf_propagate_regargs() -> bool

.. py:function:: inf_set_propagate_regargs(_v: bool = True) -> bool

.. py:function:: inf_should_trace_sp() -> bool

.. py:function:: inf_set_should_trace_sp(_v: bool = True) -> bool

.. py:function:: inf_full_sp_ana() -> bool

.. py:function:: inf_set_full_sp_ana(_v: bool = True) -> bool

.. py:function:: inf_noret_ana() -> bool

.. py:function:: inf_set_noret_ana(_v: bool = True) -> bool

.. py:function:: inf_guess_func_type() -> bool

.. py:function:: inf_set_guess_func_type(_v: bool = True) -> bool

.. py:function:: inf_truncate_on_del() -> bool

.. py:function:: inf_set_truncate_on_del(_v: bool = True) -> bool

.. py:function:: inf_create_strlit_on_xref() -> bool

.. py:function:: inf_set_create_strlit_on_xref(_v: bool = True) -> bool

.. py:function:: inf_check_unicode_strlits() -> bool

.. py:function:: inf_set_check_unicode_strlits(_v: bool = True) -> bool

.. py:function:: inf_create_off_using_fixup() -> bool

.. py:function:: inf_set_create_off_using_fixup(_v: bool = True) -> bool

.. py:function:: inf_create_off_on_dref() -> bool

.. py:function:: inf_set_create_off_on_dref(_v: bool = True) -> bool

.. py:function:: inf_op_offset() -> bool

.. py:function:: inf_set_op_offset(_v: bool = True) -> bool

.. py:function:: inf_data_offset() -> bool

.. py:function:: inf_set_data_offset(_v: bool = True) -> bool

.. py:function:: inf_use_flirt() -> bool

.. py:function:: inf_set_use_flirt(_v: bool = True) -> bool

.. py:function:: inf_append_sigcmt() -> bool

.. py:function:: inf_set_append_sigcmt(_v: bool = True) -> bool

.. py:function:: inf_allow_sigmulti() -> bool

.. py:function:: inf_set_allow_sigmulti(_v: bool = True) -> bool

.. py:function:: inf_hide_libfuncs() -> bool

.. py:function:: inf_set_hide_libfuncs(_v: bool = True) -> bool

.. py:function:: inf_rename_jumpfunc() -> bool

.. py:function:: inf_set_rename_jumpfunc(_v: bool = True) -> bool

.. py:function:: inf_rename_nullsub() -> bool

.. py:function:: inf_set_rename_nullsub(_v: bool = True) -> bool

.. py:function:: inf_coagulate_data() -> bool

.. py:function:: inf_set_coagulate_data(_v: bool = True) -> bool

.. py:function:: inf_coagulate_code() -> bool

.. py:function:: inf_set_coagulate_code(_v: bool = True) -> bool

.. py:function:: inf_final_pass() -> bool

.. py:function:: inf_set_final_pass(_v: bool = True) -> bool

.. py:function:: inf_get_af2() -> int

.. py:function:: inf_set_af2(_v: int) -> bool

.. py:function:: inf_handle_eh() -> bool

.. py:function:: inf_set_handle_eh(_v: bool = True) -> bool

.. py:function:: inf_handle_rtti() -> bool

.. py:function:: inf_set_handle_rtti(_v: bool = True) -> bool

.. py:function:: inf_macros_enabled() -> bool

.. py:function:: inf_set_macros_enabled(_v: bool = True) -> bool

.. py:function:: inf_merge_strlits() -> bool

.. py:function:: inf_set_merge_strlits(_v: bool = True) -> bool

.. py:function:: inf_get_baseaddr() -> int

.. py:function:: inf_set_baseaddr(_v: int) -> bool

.. py:function:: inf_get_start_ss() -> sel_t

.. py:function:: inf_set_start_ss(_v: sel_t) -> bool

.. py:function:: inf_get_start_cs() -> sel_t

.. py:function:: inf_set_start_cs(_v: sel_t) -> bool

.. py:function:: inf_get_start_ip() -> ida_idaapi.ea_t

.. py:function:: inf_set_start_ip(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_start_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_start_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_start_sp() -> ida_idaapi.ea_t

.. py:function:: inf_set_start_sp(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_main() -> ida_idaapi.ea_t

.. py:function:: inf_set_main(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_min_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_min_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_max_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_max_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_omin_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_omin_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_omax_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_omax_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_lowoff() -> ida_idaapi.ea_t

.. py:function:: inf_set_lowoff(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_highoff() -> ida_idaapi.ea_t

.. py:function:: inf_set_highoff(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_maxref() -> int

.. py:function:: inf_set_maxref(_v: int) -> bool

.. py:function:: inf_get_netdelta() -> int

.. py:function:: inf_set_netdelta(_v: int) -> bool

.. py:function:: inf_get_xrefnum() -> uchar

.. py:function:: inf_set_xrefnum(_v: uchar) -> bool

.. py:function:: inf_get_type_xrefnum() -> uchar

.. py:function:: inf_set_type_xrefnum(_v: uchar) -> bool

.. py:function:: inf_get_refcmtnum() -> uchar

.. py:function:: inf_set_refcmtnum(_v: uchar) -> bool

.. py:function:: inf_get_xrefflag() -> uchar

.. py:function:: inf_set_xrefflag(_v: uchar) -> bool

.. py:function:: inf_show_xref_seg() -> bool

.. py:function:: inf_set_show_xref_seg(_v: bool = True) -> bool

.. py:function:: inf_show_xref_tmarks() -> bool

.. py:function:: inf_set_show_xref_tmarks(_v: bool = True) -> bool

.. py:function:: inf_show_xref_fncoff() -> bool

.. py:function:: inf_set_show_xref_fncoff(_v: bool = True) -> bool

.. py:function:: inf_show_xref_val() -> bool

.. py:function:: inf_set_show_xref_val(_v: bool = True) -> bool

.. py:function:: inf_get_max_autoname_len() -> ushort

.. py:function:: inf_set_max_autoname_len(_v: ushort) -> bool

.. py:function:: inf_get_nametype() -> char

.. py:function:: inf_set_nametype(_v: char) -> bool

.. py:function:: inf_get_short_demnames() -> int

.. py:function:: inf_set_short_demnames(_v: int) -> bool

.. py:function:: inf_get_long_demnames() -> int

.. py:function:: inf_set_long_demnames(_v: int) -> bool

.. py:function:: inf_get_demnames() -> uchar

.. py:function:: inf_set_demnames(_v: uchar) -> bool

.. py:function:: inf_get_listnames() -> uchar

.. py:function:: inf_set_listnames(_v: uchar) -> bool

.. py:function:: inf_get_indent() -> uchar

.. py:function:: inf_set_indent(_v: uchar) -> bool

.. py:function:: inf_get_cmt_indent() -> uchar

.. py:function:: inf_set_cmt_indent(_v: uchar) -> bool

.. py:function:: inf_get_margin() -> ushort

.. py:function:: inf_set_margin(_v: ushort) -> bool

.. py:function:: inf_get_lenxref() -> ushort

.. py:function:: inf_set_lenxref(_v: ushort) -> bool

.. py:function:: inf_get_outflags() -> int

.. py:function:: inf_set_outflags(_v: int) -> bool

.. py:function:: inf_show_void() -> bool

.. py:function:: inf_set_show_void(_v: bool = True) -> bool

.. py:function:: inf_show_auto() -> bool

.. py:function:: inf_set_show_auto(_v: bool = True) -> bool

.. py:function:: inf_gen_null() -> bool

.. py:function:: inf_set_gen_null(_v: bool = True) -> bool

.. py:function:: inf_show_line_pref() -> bool

.. py:function:: inf_set_show_line_pref(_v: bool = True) -> bool

.. py:function:: inf_line_pref_with_seg() -> bool

.. py:function:: inf_set_line_pref_with_seg(_v: bool = True) -> bool

.. py:function:: inf_gen_lzero() -> bool

.. py:function:: inf_set_gen_lzero(_v: bool = True) -> bool

.. py:function:: inf_gen_org() -> bool

.. py:function:: inf_set_gen_org(_v: bool = True) -> bool

.. py:function:: inf_gen_assume() -> bool

.. py:function:: inf_set_gen_assume(_v: bool = True) -> bool

.. py:function:: inf_gen_tryblks() -> bool

.. py:function:: inf_set_gen_tryblks(_v: bool = True) -> bool

.. py:function:: inf_get_cmtflg() -> uchar

.. py:function:: inf_set_cmtflg(_v: uchar) -> bool

.. py:function:: inf_show_repeatables() -> bool

.. py:function:: inf_set_show_repeatables(_v: bool = True) -> bool

.. py:function:: inf_show_all_comments() -> bool

.. py:function:: inf_set_show_all_comments(_v: bool = True) -> bool

.. py:function:: inf_hide_comments() -> bool

.. py:function:: inf_set_hide_comments(_v: bool = True) -> bool

.. py:function:: inf_show_src_linnum() -> bool

.. py:function:: inf_set_show_src_linnum(_v: bool = True) -> bool

.. py:function:: inf_test_mode() -> bool

.. py:function:: inf_show_hidden_insns() -> bool

.. py:function:: inf_set_show_hidden_insns(_v: bool = True) -> bool

.. py:function:: inf_show_hidden_funcs() -> bool

.. py:function:: inf_set_show_hidden_funcs(_v: bool = True) -> bool

.. py:function:: inf_show_hidden_segms() -> bool

.. py:function:: inf_set_show_hidden_segms(_v: bool = True) -> bool

.. py:function:: inf_get_limiter() -> uchar

.. py:function:: inf_set_limiter(_v: uchar) -> bool

.. py:function:: inf_is_limiter_thin() -> bool

.. py:function:: inf_set_limiter_thin(_v: bool = True) -> bool

.. py:function:: inf_is_limiter_thick() -> bool

.. py:function:: inf_set_limiter_thick(_v: bool = True) -> bool

.. py:function:: inf_is_limiter_empty() -> bool

.. py:function:: inf_set_limiter_empty(_v: bool = True) -> bool

.. py:function:: inf_get_bin_prefix_size() -> short

.. py:function:: inf_set_bin_prefix_size(_v: short) -> bool

.. py:function:: inf_get_prefflag() -> uchar

.. py:function:: inf_set_prefflag(_v: uchar) -> bool

.. py:function:: inf_prefix_show_segaddr() -> bool

.. py:function:: inf_set_prefix_show_segaddr(_v: bool = True) -> bool

.. py:function:: inf_prefix_show_funcoff() -> bool

.. py:function:: inf_set_prefix_show_funcoff(_v: bool = True) -> bool

.. py:function:: inf_prefix_show_stack() -> bool

.. py:function:: inf_set_prefix_show_stack(_v: bool = True) -> bool

.. py:function:: inf_prefix_truncate_opcode_bytes() -> bool

.. py:function:: inf_set_prefix_truncate_opcode_bytes(_v: bool = True) -> bool

.. py:function:: inf_get_strlit_flags() -> uchar

.. py:function:: inf_set_strlit_flags(_v: uchar) -> bool

.. py:function:: inf_strlit_names() -> bool

.. py:function:: inf_set_strlit_names(_v: bool = True) -> bool

.. py:function:: inf_strlit_name_bit() -> bool

.. py:function:: inf_set_strlit_name_bit(_v: bool = True) -> bool

.. py:function:: inf_strlit_serial_names() -> bool

.. py:function:: inf_set_strlit_serial_names(_v: bool = True) -> bool

.. py:function:: inf_unicode_strlits() -> bool

.. py:function:: inf_set_unicode_strlits(_v: bool = True) -> bool

.. py:function:: inf_strlit_autocmt() -> bool

.. py:function:: inf_set_strlit_autocmt(_v: bool = True) -> bool

.. py:function:: inf_strlit_savecase() -> bool

.. py:function:: inf_set_strlit_savecase(_v: bool = True) -> bool

.. py:function:: inf_get_strlit_break() -> uchar

.. py:function:: inf_set_strlit_break(_v: uchar) -> bool

.. py:function:: inf_get_strlit_zeroes() -> char

.. py:function:: inf_set_strlit_zeroes(_v: char) -> bool

.. py:function:: inf_get_strtype() -> int

.. py:function:: inf_set_strtype(_v: int) -> bool

.. py:function:: inf_get_strlit_sernum() -> int

.. py:function:: inf_set_strlit_sernum(_v: int) -> bool

.. py:function:: inf_get_datatypes() -> int

.. py:function:: inf_set_datatypes(_v: int) -> bool

.. py:function:: inf_get_abibits() -> int

.. py:function:: inf_set_abibits(_v: int) -> bool

.. py:function:: inf_is_mem_aligned4() -> bool

.. py:function:: inf_set_mem_aligned4(_v: bool = True) -> bool

.. py:function:: inf_pack_stkargs(*args) -> bool

.. py:function:: inf_set_pack_stkargs(_v: bool = True) -> bool

.. py:function:: inf_big_arg_align(*args) -> bool

.. py:function:: inf_set_big_arg_align(_v: bool = True) -> bool

.. py:function:: inf_stack_ldbl() -> bool

.. py:function:: inf_set_stack_ldbl(_v: bool = True) -> bool

.. py:function:: inf_stack_varargs() -> bool

.. py:function:: inf_set_stack_varargs(_v: bool = True) -> bool

.. py:function:: inf_is_hard_float() -> bool

.. py:function:: inf_set_hard_float(_v: bool = True) -> bool

.. py:function:: inf_abi_set_by_user() -> bool

.. py:function:: inf_set_abi_set_by_user(_v: bool = True) -> bool

.. py:function:: inf_use_gcc_layout() -> bool

.. py:function:: inf_set_use_gcc_layout(_v: bool = True) -> bool

.. py:function:: inf_map_stkargs() -> bool

.. py:function:: inf_set_map_stkargs(_v: bool = True) -> bool

.. py:function:: inf_huge_arg_align(*args) -> bool

.. py:function:: inf_set_huge_arg_align(_v: bool = True) -> bool

.. py:function:: inf_get_appcall_options() -> int

.. py:function:: inf_set_appcall_options(_v: int) -> bool

.. py:function:: inf_get_privrange_start_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_privrange_start_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_privrange_end_ea() -> ida_idaapi.ea_t

.. py:function:: inf_set_privrange_end_ea(_v: ida_idaapi.ea_t) -> bool

.. py:function:: inf_get_cc_id() -> comp_t

.. py:function:: inf_set_cc_id(_v: comp_t) -> bool

.. py:function:: inf_get_cc_cm() -> cm_t

.. py:function:: inf_set_cc_cm(_v: cm_t) -> bool

.. py:function:: inf_get_callcnv() -> callcnv_t

.. py:function:: inf_set_callcnv(_v: callcnv_t) -> bool

.. py:function:: inf_get_cc_size_i() -> uchar

.. py:function:: inf_set_cc_size_i(_v: uchar) -> bool

.. py:function:: inf_get_cc_size_b() -> uchar

.. py:function:: inf_set_cc_size_b(_v: uchar) -> bool

.. py:function:: inf_get_cc_size_e() -> uchar

.. py:function:: inf_set_cc_size_e(_v: uchar) -> bool

.. py:function:: inf_get_cc_defalign() -> uchar

.. py:function:: inf_set_cc_defalign(_v: uchar) -> bool

.. py:function:: inf_get_cc_size_s() -> uchar

.. py:function:: inf_set_cc_size_s(_v: uchar) -> bool

.. py:function:: inf_get_cc_size_l() -> uchar

.. py:function:: inf_set_cc_size_l(_v: uchar) -> bool

.. py:function:: inf_get_cc_size_ll() -> uchar

.. py:function:: inf_set_cc_size_ll(_v: uchar) -> bool

.. py:function:: inf_get_cc_size_ldbl() -> uchar

.. py:function:: inf_set_cc_size_ldbl(_v: uchar) -> bool

.. py:function:: inf_get_procname() -> str

.. py:function:: inf_set_procname(*args) -> bool

.. py:function:: inf_get_strlit_pref() -> str

.. py:function:: inf_set_strlit_pref(*args) -> bool

.. py:function:: inf_get_cc(out: compiler_info_t) -> bool

.. py:function:: inf_set_cc(_v: compiler_info_t) -> bool

.. py:function:: inf_set_privrange(_v: range_t) -> bool

.. py:function:: inf_get_privrange(*args) -> range_t

   This function has the following signatures:

       0. inf_get_privrange(out: range_t *) -> bool
       1. inf_get_privrange() -> range_t

   # 0: inf_get_privrange(out: range_t *) -> bool


   # 1: inf_get_privrange() -> range_t


.. py:function:: inf_get_af_low() -> ushort

   Get/set low/high 16bit halves of inf.af.


.. py:function:: inf_set_af_low(saf: ushort) -> None

.. py:function:: inf_get_af_high() -> ushort

.. py:function:: inf_set_af_high(saf2: ushort) -> None

.. py:function:: inf_get_af2_low() -> ushort

   Get/set low 16bit half of inf.af2.


.. py:function:: inf_set_af2_low(saf: ushort) -> None

.. py:function:: inf_get_pack_mode() -> int

.. py:function:: inf_set_pack_mode(pack_mode: int) -> int

.. py:function:: inf_inc_database_change_count(cnt: int = 1) -> None

.. py:function:: inf_get_demname_form() -> uchar

   Get DEMNAM_MASK bits of #demnames.


.. py:function:: inf_postinc_strlit_sernum(cnt: int = 1) -> int

.. py:function:: inf_like_binary() -> bool

.. py:data:: UA_MAXOP

   max number of operands allowed for an instruction


.. py:function:: calc_default_idaplace_flags() -> int

   Get default disassembly line options.


.. py:function:: to_ea(reg_cs: sel_t, reg_ip: int) -> ida_idaapi.ea_t

   Convert (sel,off) value to a linear address.


.. py:data:: IDB_EXT32

.. py:data:: IDB_EXT64

.. py:data:: IDB_EXT

.. py:function:: get_dbctx_id() -> ssize_t

   Get the current database context ID 
           
   :returns: the database context ID, or -1 if no current database


.. py:function:: get_dbctx_qty() -> size_t

   Get number of database contexts 
           
   :returns: number of database contexts


.. py:function:: switch_dbctx(idx: size_t) -> dbctx_t *

   Switch to the database with the provided context ID 
           
   :param idx: the index of the database to switch to
   :returns: the current dbctx_t instance or nullptr


.. py:function:: is_database_busy() -> bool

   Check if the database is busy (e.g. performing some critical operations and cannot be safely accessed) 
           


.. py:function:: validate_idb(vld_flags: int = 0) -> size_t

   Validate the database 
           
   :param vld_flags: combination of VLD_.. constants
   :returns: number of corrupted/fixed records


.. py:data:: VLD_AUTO_REPAIR

   automatically repair the database


.. py:data:: VLD_DIALOG

   ask user to repair (this bit is mutually exclusive with VLD_AUTO_REPAIR)


.. py:data:: VLD_SILENT

   no messages to the output window


.. py:function:: move_privrange(new_privrange_start: ida_idaapi.ea_t) -> bool

   Move privrange to the specified address 
           
   :param new_privrange_start: new start address of the privrange
   :returns: success


.. py:class:: idbattr_valmap_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: value
      :type:  uint64


   .. py:attribute:: valname
      :type:  str


.. py:class:: idbattr_info_t(name: str, offset: uintptr_t, width: size_t, bitmask: uint64 = 0, tag: uchar = 0, idi_flags: uint = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      human-readable name. if null, then the field will not be merged as part of INF. 
              



   .. py:attribute:: offset
      :type:  uintptr_t

      field position: offset within a structure (IDI_STRUCFLD) altval or supval index (IDI_NODEVAL) hashval name (IDI_ALTVAL/IDI_SUPVAL+IDI_HASH) 
              



   .. py:attribute:: width
      :type:  size_t

      field width in bytes



   .. py:attribute:: bitmask
      :type:  uint64

      mask for bitfields (0-not bitfield)



   .. py:attribute:: tag
      :type:  uchar

      tag of node value (if IDI_NODEVAL is set)



   .. py:attribute:: vmap
      :type:  idbattr_valmap_t const *

      array value=>name (terminated by empty element)



   .. py:attribute:: individual_node
      :type:  str

      individual node name (nullptr - use default)



   .. py:attribute:: idi_flags
      :type:  uint


   .. py:attribute:: maxsize
      :type:  int

      max bytes reserved for storage in netnode



   .. py:method:: is_node_altval() -> bool


   .. py:method:: is_node_supval() -> bool


   .. py:method:: is_node_valobj() -> bool


   .. py:method:: is_node_blob() -> bool


   .. py:method:: is_node_var() -> bool


   .. py:method:: is_struc_field() -> bool


   .. py:method:: is_cstr() -> bool


   .. py:method:: is_qstring() -> bool


   .. py:method:: is_bytearray() -> bool


   .. py:method:: is_buf_var() -> bool


   .. py:method:: is_decimal() -> bool


   .. py:method:: is_hexadecimal() -> bool


   .. py:method:: is_readonly_var() -> bool


   .. py:method:: is_incremented() -> bool


   .. py:method:: is_val_mapped() -> bool


   .. py:method:: is_hash() -> bool


   .. py:method:: use_hlpstruc() -> bool


   .. py:method:: is_bitmap() -> bool


   .. py:method:: is_onoff() -> bool


   .. py:method:: is_scalar_var() -> bool


   .. py:method:: is_bitfield() -> bool


   .. py:method:: is_boolean() -> bool


   .. py:method:: has_individual_node() -> bool


   .. py:method:: str_true() -> str


   .. py:method:: str_false() -> str


   .. py:method:: ridx() -> size_t


   .. py:method:: hashname() -> str


.. py:data:: IDI_STRUCFLD

   structure field (opposite to IDI_NODEVAL)


.. py:data:: IDI_ALTVAL

   netnode: altval


.. py:data:: IDI_SUPVAL

   netnode: supval


.. py:data:: IDI_VALOBJ

   netnode: valobj


.. py:data:: IDI_BLOB

   netnode: blob


.. py:data:: IDI_SCALAR

   scalar value (default)


.. py:data:: IDI_CSTR

   string


.. py:data:: IDI_QSTRING

   qstring


.. py:data:: IDI_BYTEARRAY

   byte array: binary representation


.. py:data:: IDI_EA_HEX

   default representation: hex or "BADADDR"


.. py:data:: IDI_DEC

   show as decimal


.. py:data:: IDI_HEX

   show as hexadecimal


.. py:data:: IDI_INC

   stored value is incremented (scalars only)


.. py:data:: IDI_MAP_VAL

   apply ea2node() to value


.. py:data:: IDI_HASH

   hashed node field, hash name in offset


.. py:data:: IDI_HLPSTRUC

   call helper for pointer to structure


.. py:data:: IDI_READONLY

   read-only field (cannot be modified)


.. py:data:: IDI_BITMAP

   bitmap field: interpret bitmask as bit number


.. py:data:: IDI_ONOFF

   show boolean as on/off (not true/false)


.. py:data:: IDI_NOMERGE

   field should not be merged as part of INF


.. py:data:: IDI_NODEVAL

.. py:data:: IDI_BUFVAR

.. py:data:: idainfo_big_arg_align

.. py:data:: idainfo_gen_null

.. py:data:: idainfo_set_gen_null

.. py:data:: idainfo_gen_lzero

.. py:data:: idainfo_set_gen_lzero

.. py:data:: idainfo_gen_tryblks

.. py:data:: idainfo_set_gen_tryblks

.. py:data:: idainfo_get_demname_form

.. py:data:: idainfo_get_pack_mode

.. py:data:: idainfo_set_pack_mode

.. py:function:: idainfo_is_32bit()

.. py:data:: idainfo_is_64bit

.. py:data:: idainfo_set_64bit

.. py:data:: idainfo_is_auto_enabled

.. py:data:: idainfo_set_auto_enabled

.. py:data:: idainfo_is_be

.. py:data:: idainfo_set_be

.. py:data:: idainfo_is_dll

.. py:data:: idainfo_is_flat_off32

.. py:data:: idainfo_is_graph_view

.. py:data:: idainfo_set_graph_view

.. py:data:: idainfo_is_hard_float

.. py:data:: idainfo_is_kernel_mode

.. py:data:: idainfo_is_mem_aligned4

.. py:data:: idainfo_is_snapshot

.. py:data:: idainfo_is_wide_high_byte_first

.. py:data:: idainfo_set_wide_high_byte_first

.. py:data:: idainfo_like_binary

.. py:data:: idainfo_line_pref_with_seg

.. py:data:: idainfo_set_line_pref_with_seg

.. py:data:: idainfo_show_auto

.. py:data:: idainfo_set_show_auto

.. py:data:: idainfo_show_line_pref

.. py:data:: idainfo_set_show_line_pref

.. py:data:: idainfo_show_void

.. py:data:: idainfo_set_show_void

.. py:data:: idainfo_loading_idc

.. py:data:: idainfo_map_stkargs

.. py:data:: idainfo_pack_stkargs

.. py:data:: idainfo_readonly_idb

.. py:data:: idainfo_set_store_user_info

.. py:data:: idainfo_stack_ldbl

.. py:data:: idainfo_stack_varargs

.. py:data:: idainfo_use_allasm

.. py:data:: idainfo_use_gcc_layout

.. py:data:: macros_enabled

.. py:data:: should_create_stkvars

.. py:data:: should_trace_sp

.. py:data:: show_all_comments

.. py:data:: show_comments

.. py:data:: show_repeatables

.. py:data:: inf_get_comment

.. py:data:: inf_set_comment

.. py:data:: idainfo_comment_get

.. py:data:: idainfo_comment_set


```

`skills/idapython/docs/ida_idaapi.md`:

```md
# ida_idaapi

Core IDAPython infrastructure - plugin system, type definitions, and Python integration utilities.

## Key Constants

### Address Types
- `ea_t` - Effective address type (int)
- `BADADDR` - Invalid address sentinel
- `BADADDR32` - 32-bit invalid address (0xFFFFFFFF)
- `BADADDR64` - 64-bit invalid address (0xFFFFFFFFFFFFFFFF)

### Plugin Return Codes
- `PLUGIN_SKIP` - Plugin init failed, unload
- `PLUGIN_OK` - Plugin loaded successfully
- `PLUGIN_KEEP` - Keep plugin loaded

## Key Functions

- `require(modulename, package=None)` - Load or reload module (forces reload for development)
- `notify_when(when, callback)` - Register event callbacks (NW_OPENIDB, NW_CLOSEIDB, etc.)
- `as_cstr(s)` - Convert to C string
- `as_uint32(v)`, `as_int32(v)`, `as_signed(v)` - Type conversions
- `IDAPython_ExecScript(path)` - Execute Python script
- `set_script_timeout(seconds)`, `disable_script_timeout()` - Script execution limits

## Key Classes

### plugin_t
Base class for IDA plugins.
- Override `init()`, `run()`, `term()` methods
- Set `flags`, `comment`, `help`, `wanted_name`, `wanted_hotkey`

### plugmod_t
Modern plugin module interface (IDA 7.2+).
- Override `run(arg)` method
- Supports multiple plugin instances

## See Also
Full docs: skill/docs/ida_idaapi.rst

```

`skills/idapython/docs/ida_idaapi.rst`:

```rst
ida_idaapi
==========

.. py:module:: ida_idaapi


Attributes
----------

.. autoapisummary::

   ida_idaapi.BADADDR
   ida_idaapi.BADADDR32
   ida_idaapi.BADADDR64
   ida_idaapi.BADSEL
   ida_idaapi.SIZE_MAX
   ida_idaapi.ea_t
   ida_idaapi.integer_types
   ida_idaapi.SEEK_SET
   ida_idaapi.SEEK_CUR
   ida_idaapi.SEEK_END
   ida_idaapi.PLUGIN_MOD
   ida_idaapi.PLUGIN_DRAW
   ida_idaapi.PLUGIN_SEG
   ida_idaapi.PLUGIN_UNL
   ida_idaapi.PLUGIN_HIDE
   ida_idaapi.PLUGIN_DBG
   ida_idaapi.PLUGIN_PROC
   ida_idaapi.PLUGIN_FIX
   ida_idaapi.PLUGIN_MULTI
   ida_idaapi.PLUGIN_SKIP
   ida_idaapi.PLUGIN_OK
   ida_idaapi.PLUGIN_KEEP
   ida_idaapi.PY_ICID_INT64
   ida_idaapi.PY_ICID_BYREF
   ida_idaapi.PY_ICID_OPAQUE
   ida_idaapi.ST_OVER_DEBUG_SEG
   ida_idaapi.ST_OVER_LIB_FUNC
   ida_idaapi.as_unicode
   ida_idaapi.IDAPython_Completion
   ida_idaapi.NW_OPENIDB
   ida_idaapi.NW_CLOSEIDB
   ida_idaapi.NW_INITIDA
   ida_idaapi.NW_TERMIDA
   ida_idaapi.NW_REMOVE
   ida_idaapi.HBF_CALL_WITH_NEW_EXEC
   ida_idaapi.HBF_VOLATILE_METHOD_SET


Classes
-------

.. autoapisummary::

   ida_idaapi.pyidc_opaque_object_t
   ida_idaapi.py_clinked_object_t
   ida_idaapi.object_t
   ida_idaapi.plugin_t
   ida_idaapi.plugmod_t
   ida_idaapi.pyidc_cvt_helper__
   ida_idaapi.PyIdc_cvt_int64__
   ida_idaapi.PyIdc_cvt_refclass__
   ida_idaapi.IDAPython_displayhook
   ida_idaapi.loader_input_t


Functions
---------

.. autoapisummary::

   ida_idaapi.require
   ida_idaapi.replfun
   ida_idaapi.as_cstr
   ida_idaapi.as_UTF16
   ida_idaapi.as_uint32
   ida_idaapi.as_int32
   ida_idaapi.as_signed
   ida_idaapi.TRUNC
   ida_idaapi.copy_bits
   ida_idaapi.struct_unpack
   ida_idaapi.IDAPython_ExecSystem
   ida_idaapi.IDAPython_FormatExc
   ida_idaapi.IDAPython_ExecScript
   ida_idaapi.IDAPython_LoadProcMod
   ida_idaapi.IDAPython_UnLoadProcMod
   ida_idaapi.IDAPython_GetDocstrings
   ida_idaapi.notify_when
   ida_idaapi.parse_command_line3
   ida_idaapi.set_script_timeout
   ida_idaapi.disable_script_timeout
   ida_idaapi.enable_extlang_python
   ida_idaapi.enable_python_cli
   ida_idaapi.format_basestring
   ida_idaapi.pygc_refresh
   ida_idaapi.pygc_create_groups
   ida_idaapi.pygc_delete_groups
   ida_idaapi.pygc_set_groups_visibility
   ida_idaapi.pycim_get_widget
   ida_idaapi.pycim_view_close


Module Contents
---------------

.. py:data:: BADADDR

.. py:data:: BADADDR32

.. py:data:: BADADDR64

.. py:data:: BADSEL

.. py:data:: SIZE_MAX

.. py:data:: ea_t

.. py:data:: integer_types

.. py:function:: require(modulename, package=None)

   Load, or reload a module.

   When under heavy development, a user's tool might consist of multiple
   modules. If those are imported using the standard 'import' mechanism,
   there is no guarantee that the Python implementation will re-read
   and re-evaluate the module's Python code. In fact, it usually doesn't.
   What should be done instead is 'reload()'-ing that module.

   This is a simple helper function that will do just that: In case the
   module doesn't exist, it 'import's it, and if it does exist,
   'reload()'s it.

   The importing module (i.e., the module calling require()) will have
   the loaded module bound to its globals(), under the name 'modulename'.
   (If require() is called from the command line, the importing module
   will be '__main__'.)

   For more information, see: <http://www.hexblog.com/?p=749>.


.. py:function:: replfun(func)

.. py:data:: SEEK_SET
   :value: 0


.. py:data:: SEEK_CUR
   :value: 1


.. py:data:: SEEK_END
   :value: 2


.. py:data:: PLUGIN_MOD
   :value: 1


.. py:data:: PLUGIN_DRAW
   :value: 2


.. py:data:: PLUGIN_SEG
   :value: 4


.. py:data:: PLUGIN_UNL
   :value: 8


.. py:data:: PLUGIN_HIDE
   :value: 16


.. py:data:: PLUGIN_DBG
   :value: 32


.. py:data:: PLUGIN_PROC
   :value: 64


.. py:data:: PLUGIN_FIX
   :value: 128


.. py:data:: PLUGIN_MULTI
   :value: 256


.. py:data:: PLUGIN_SKIP
   :value: 0


.. py:data:: PLUGIN_OK
   :value: 1


.. py:data:: PLUGIN_KEEP
   :value: 2


.. py:data:: PY_ICID_INT64
   :value: 0


   int64 object


.. py:data:: PY_ICID_BYREF
   :value: 1


   byref object


.. py:data:: PY_ICID_OPAQUE
   :value: 2


   opaque object


.. py:data:: ST_OVER_DEBUG_SEG
   :value: 1


   step tracing will be disabled when IP is in a debugger segment


.. py:data:: ST_OVER_LIB_FUNC
   :value: 2


   step tracing will be disabled when IP is in a library function


.. py:class:: pyidc_opaque_object_t

   Bases: :py:obj:`object`


   This is the base class for all Python<->IDC opaque objects


.. py:class:: py_clinked_object_t(lnk=None)

   Bases: :py:obj:`pyidc_opaque_object_t`


   This is a utility and base class for C linked objects


   .. py:method:: copy()

      Returns a new copy of this class



   .. py:method:: assign(other)

      Overwrite me.
      This method allows you to assign an instance contents to anothers
      :returns: Boolean



   .. py:attribute:: clink

      Returns the C link as a PyObject



   .. py:attribute:: clink_ptr

      Returns the C link pointer as a number



.. py:class:: object_t(**kwds)

   Bases: :py:obj:`object`


   Helper class used to initialize empty objects


.. py:class:: plugin_t

   Bases: :py:obj:`pyidc_opaque_object_t`


   Base class for all scripted plugins.


   .. py:method:: run(arg)


   .. py:method:: term()


.. py:class:: plugmod_t

   Bases: :py:obj:`pyidc_opaque_object_t`


   Base class for all scripted multi-plugins.


.. py:class:: pyidc_cvt_helper__(cvt_id, value)

   Bases: :py:obj:`object`


   This is a special helper object that helps detect which kind
   of object is this python object wrapping and how to convert it
   back and from IDC.
   This object is characterized by its special attribute and its value


   .. py:attribute:: value


.. py:class:: PyIdc_cvt_int64__(v)

   Bases: :py:obj:`pyidc_cvt_helper__`


   Helper class for explicitly representing VT_INT64 values


.. py:class:: PyIdc_cvt_refclass__(v)

   Bases: :py:obj:`pyidc_cvt_helper__`


   Helper class for representing references to immutable objects


   .. py:method:: cstr()

      Returns the string as a C string (up to the zero termination)



.. py:function:: as_cstr(val)

   Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
   It scans for the first \x00 and returns the string value up to that point.


.. py:function:: as_UTF16(s)

   Convenience function to convert a string into appropriate unicode format


.. py:data:: as_unicode

.. py:function:: as_uint32(v)

   Returns a number as an unsigned int32 number


.. py:function:: as_int32(v)

   Returns a number as a signed int32 number


.. py:function:: as_signed(v, nbits=32)

   Returns a number as signed. The number of bits are specified by the user.
   The MSB holds the sign.


.. py:function:: TRUNC(ea)

   Truncate EA for the current application bitness


.. py:function:: copy_bits(v, s, e=-1)

   Copy bits from a value
   :param v: the value
   :param s: starting bit (0-based)
   :param e: ending bit


.. py:function:: struct_unpack(buffer, signed=False, offs=0)

   Unpack a buffer given its length and offset using struct.unpack_from().
   This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
   If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.


.. py:function:: IDAPython_ExecSystem(cmd)

   Executes a command with popen().


.. py:function:: IDAPython_FormatExc(etype, value=None, tb=None, limit=None)

   This function is used to format an exception given the
   values returned by a PyErr_Fetch()


.. py:function:: IDAPython_ExecScript(path, g, print_error=True)

   Run the specified script.

   This function is used by the low-level plugin code.


.. py:function:: IDAPython_LoadProcMod(path, g, print_error=True)

   Load processor module.


.. py:function:: IDAPython_UnLoadProcMod(script, g, print_error=True)

   Unload processor module.


.. py:function:: IDAPython_GetDocstrings(obj)

.. py:data:: IDAPython_Completion

.. py:data:: NW_OPENIDB
   :value: 1


   Notify when the database is opened. Its callback is of the form: def notify_when_callback(nw_code, is_old_database)


.. py:data:: NW_CLOSEIDB
   :value: 2


   Notify when the database is closed. Its callback is of the form: def notify_when_callback(nw_code)


.. py:data:: NW_INITIDA
   :value: 4


   Notify when the IDA starts. Its callback is of the form: def notify_when_callback(nw_code)


.. py:data:: NW_TERMIDA
   :value: 8


   Notify when the IDA terminates. Its callback is of the form: def notify_when_callback(nw_code)


.. py:data:: NW_REMOVE
   :value: 16


   Use this flag with other flags to uninstall a notifywhen callback


.. py:function:: notify_when(when, callback)

   Register a callback that will be called when an event happens.
   :param when: one of NW_XXXX constants
   :param callback: This callback prototype varies depending on the 'when' parameter:
                    The general callback format:
                        def notify_when_callback(nw_code)
                    In the case of NW_OPENIDB:
                        def notify_when_callback(nw_code, is_old_database)
   :returns: Boolean


.. py:class:: IDAPython_displayhook

   .. py:attribute:: orig_displayhook


   .. py:method:: format_seq(num_printer, storage, item, opn, cls)


   .. py:method:: format_item(num_printer, storage, item)


   .. py:method:: displayhook_format(item)


   .. py:method:: displayhook(item)


.. py:data:: HBF_CALL_WITH_NEW_EXEC

.. py:data:: HBF_VOLATILE_METHOD_SET

.. py:function:: parse_command_line3(cmdline: str) -> PyObject *

.. py:function:: set_script_timeout(timeout)

   Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
   See also L{disable_script_timeout}.

   :param timeout: This value is in seconds.
                   If this value is set to zero then the script will never timeout.
   :returns: Returns the old timeout value


.. py:function:: disable_script_timeout()

   Disables the script timeout and hides the script wait box.
   Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again

   :returns: None


.. py:function:: enable_extlang_python(enable)

   Enables or disables Python extlang.
   When enabled, all expressions will be evaluated by Python.

   :param enable: Set to True to enable, False otherwise


.. py:function:: enable_python_cli(enable: bool) -> None

.. py:function:: format_basestring(_in: PyObject *) -> str

.. py:function:: pygc_refresh(_self: PyObject *) -> None

.. py:function:: pygc_create_groups(_self: PyObject *, groups_infos: PyObject *) -> PyObject *

.. py:function:: pygc_delete_groups(_self: PyObject *, groups: PyObject *, new_current: PyObject *) -> PyObject *

.. py:function:: pygc_set_groups_visibility(_self: PyObject *, groups: PyObject *, expand: PyObject *, new_current: PyObject *) -> PyObject *

.. py:function:: pycim_get_widget(_self: PyObject *) -> TWidget *

.. py:function:: pycim_view_close(_self: PyObject *) -> None

.. py:class:: loader_input_t(pycapsule=None)

   Bases: :py:obj:`object`


   A helper class to work with linput_t related functions.
   This class is also used by file loaders scripts.


   .. py:attribute:: thisown


   .. py:method:: close()

      Closes the file



   .. py:method:: open(filename, remote=False)

      Opens a file (or a remote file)

      :param filename: the file name
      :param remote: whether the file is local, or remote
      :returns: Boolean



   .. py:method:: set_linput(linput)

      Links the current loader_input_t instance to a linput_t instance

      :param linput: the linput_t to link to



   .. py:method:: from_linput(linput: linput_t *) -> loader_input_t *
      :staticmethod:



   .. py:method:: from_capsule(pycapsule: PyObject *) -> loader_input_t *
      :staticmethod:



   .. py:method:: from_fp(fp)
      :staticmethod:


      A static method to construct an instance from a FILE*

      :param fp: a FILE pointer
      :returns: a new instance, or None



   .. py:method:: get_linput() -> linput_t *


   .. py:method:: open_memory(start: ea_t, size: int)

      Create a linput for process memory (By internally calling idaapi.create_memory_linput())
      This linput will use dbg->read_memory() to read data

      :param start: starting address of the input
      :param size: size of the memory range to represent as linput
                  if unknown, may be passed as 0



   .. py:method:: seek(offset: int, whence=SEEK_SET)

      Set input source position

      :param offset: the seek offset
      :param whence: the position to seek from
      :returns: the new position (not 0 as fseek!)



   .. py:method:: tell()

      Returns the current position



   .. py:method:: getz(size: int, fpos: int = -1)

      Returns a zero terminated string at the given position

      :param size: maximum size of the string
      :param fpos: if != -1 then seek will be performed before reading
      :returns: The string or None on failure.



   .. py:method:: gets(len: int)

      Reads a line from the input file. Returns the read line or None

      :param len: the maximum line length
      :returns: a str, or None



   .. py:method:: read(size: int = -1)

      Read up to size bytes (all data if size is negative). Return an empty bytes object on EOF.

      :param size: the maximum number of bytes to read
      :returns: a bytes object



   .. py:method:: opened()

      Checks if the file is opened or not



   .. py:method:: readbytes(size: int, big_endian: bool)

      Similar to read() but it respect the endianness

      :param size: the maximum number of bytes to read
      :param big_endian: endianness
      :returns: a str, or None



   .. py:method:: file2base(pos: int, ea1: ea_t, ea2: ea_t, patchable: bool)

      Load portion of file into the database
      This function will include (ea1..ea2) into the addressing space of the
      program (make it enabled)

      :param li: pointer ot input source
      :param pos: position in the file
      :param ea1: start of range of destination linear addresses
      :param ea2: end of range of destination linear addresses
      :param patchable: should the kernel remember correspondance of
                        file offsets to linear addresses.
      :returns: 1-ok,0-read error, a warning is displayed



   .. py:method:: size() -> int64


   .. py:method:: filename() -> PyObject *


   .. py:method:: get_byte()

      Reads a single byte from the file. Returns None if EOF or the read byte




```

`skills/idapython/docs/ida_idc.md`:

```md
# ida_idc

Marked positions (bookmarks) in IDA database - low priority module with limited scope.

## Key Functions

- `mark_position(ea, lnnum, x, y, slot, comment)` - Create bookmark at address in slot (0-1023)
- `get_marked_pos(slot)` - Get address of bookmark in slot
- `get_mark_comment(slot)` - Get comment for bookmark in slot

## See Also
Full docs: skill/docs/ida_idc.rst

```

`skills/idapython/docs/ida_idc.rst`:

```rst
ida_idc
=======

.. py:module:: ida_idc


Functions
---------

.. autoapisummary::

   ida_idc.mark_position
   ida_idc.get_marked_pos
   ida_idc.get_mark_comment


Module Contents
---------------

.. py:function:: mark_position(ea: ida_idaapi.ea_t, lnnum: int, x: short, y: short, slot: int, comment: str) -> None

.. py:function:: get_marked_pos(slot: int) -> ida_idaapi.ea_t

.. py:function:: get_mark_comment(slot: int) -> PyObject *


```

`skills/idapython/docs/ida_idd.md`:

```md
# ida_idd

Interface to debugger modules - defines structures for target processor debugging and API.

## Key Classes/Functions

### debug_event_t
Debug event information container
- `eid()` - get event type (PROCESS_STARTED, BREAKPOINT, EXCEPTION, etc.)
- `modinfo()` - module info for PROCESS_STARTED/LIB_LOADED
- `exc()` - exception details for EXCEPTION events
- `bpt()` - breakpoint addresses

### debugger_t
Debugger module interface
- `get_debug_event(event, timeout_ms)` - wait for debug event
- `resume(event)` - continue execution
- `read_registers(tid, clsmask, values)` - read thread registers
- `write_register(tid, regidx, value)` - write thread register
- `read_memory(nbytes, ea, buffer, size)` - read process memory
- `write_memory(nbytes, ea, buffer, size)` - write process memory
- `update_bpts(nbpts, bpts, nadd, ndel)` - add/delete breakpoints

### regval_t
Register value container
- `set_int(x)` - set integer value
- `set_float(v)` - set floating point
- `pyval(dtype)` - get Python value

### Python Helpers
- `dbg_read_memory(ea, sz)` - read debuggee memory, returns bytes or None
- `dbg_write_memory(ea, buffer)` - write bytes to debuggee
- `dbg_get_registers()` - get register definitions
- `dbg_get_memory_info()` - get memory layout

## Event Types
- PROCESS_STARTED, PROCESS_EXITED, PROCESS_ATTACHED, PROCESS_DETACHED
- THREAD_STARTED, THREAD_EXITED
- BREAKPOINT, STEP, EXCEPTION
- LIB_LOADED, LIB_UNLOADED

## See Also
Full docs: skill/docs/ida_idd.rst

```

`skills/idapython/docs/ida_idd.rst`:

```rst
ida_idd
=======

.. py:module:: ida_idd

.. autoapi-nested-parse::

   Contains definition of the interface to IDD modules.

   The interface consists of structures describing the target debugged processor and a debugging API. 
       



Attributes
----------

.. autoapisummary::

   ida_idd.IDD_INTERFACE_VERSION
   ida_idd.NO_THREAD
   ida_idd.DEF_ADDRSIZE
   ida_idd.REGISTER_READONLY
   ida_idd.REGISTER_IP
   ida_idd.REGISTER_SP
   ida_idd.REGISTER_FP
   ida_idd.REGISTER_ADDRESS
   ida_idd.REGISTER_CS
   ida_idd.REGISTER_SS
   ida_idd.REGISTER_NOLF
   ida_idd.REGISTER_CUSTFMT
   ida_idd.NO_EVENT
   ida_idd.PROCESS_STARTED
   ida_idd.PROCESS_EXITED
   ida_idd.THREAD_STARTED
   ida_idd.THREAD_EXITED
   ida_idd.BREAKPOINT
   ida_idd.STEP
   ida_idd.EXCEPTION
   ida_idd.LIB_LOADED
   ida_idd.LIB_UNLOADED
   ida_idd.INFORMATION
   ida_idd.PROCESS_ATTACHED
   ida_idd.PROCESS_DETACHED
   ida_idd.PROCESS_SUSPENDED
   ida_idd.TRACE_FULL
   ida_idd.STATUS_MASK
   ida_idd.BITNESS_CHANGED
   ida_idd.cvar
   ida_idd.BPT_WRITE
   ida_idd.BPT_READ
   ida_idd.BPT_RDWR
   ida_idd.BPT_SOFT
   ida_idd.BPT_EXEC
   ida_idd.BPT_DEFAULT
   ida_idd.EXC_BREAK
   ida_idd.EXC_HANDLE
   ida_idd.EXC_MSG
   ida_idd.EXC_SILENT
   ida_idd.RVT_FLOAT
   ida_idd.RVT_INT
   ida_idd.RVT_UNAVAILABLE
   ida_idd.RESMOD_NONE
   ida_idd.RESMOD_INTO
   ida_idd.RESMOD_OVER
   ida_idd.RESMOD_OUT
   ida_idd.RESMOD_SRCINTO
   ida_idd.RESMOD_SRCOVER
   ida_idd.RESMOD_SRCOUT
   ida_idd.RESMOD_USER
   ida_idd.RESMOD_HANDLE
   ida_idd.RESMOD_BACKINTO
   ida_idd.RESMOD_MAX
   ida_idd.STEP_TRACE
   ida_idd.INSN_TRACE
   ida_idd.FUNC_TRACE
   ida_idd.BBLK_TRACE
   ida_idd.DRC_EVENTS
   ida_idd.DRC_CRC
   ida_idd.DRC_OK
   ida_idd.DRC_NONE
   ida_idd.DRC_FAILED
   ida_idd.DRC_NETERR
   ida_idd.DRC_NOFILE
   ida_idd.DRC_IDBSEG
   ida_idd.DRC_NOPROC
   ida_idd.DRC_NOCHG
   ida_idd.DRC_ERROR
   ida_idd.DEBUGGER_ID_X86_IA32_WIN32_USER
   ida_idd.DEBUGGER_ID_X86_IA32_LINUX_USER
   ida_idd.DEBUGGER_ID_X86_IA32_MACOSX_USER
   ida_idd.DEBUGGER_ID_ARM_IPHONE_USER
   ida_idd.DEBUGGER_ID_X86_IA32_BOCHS
   ida_idd.DEBUGGER_ID_6811_EMULATOR
   ida_idd.DEBUGGER_ID_GDB_USER
   ida_idd.DEBUGGER_ID_WINDBG
   ida_idd.DEBUGGER_ID_X86_DOSBOX_EMULATOR
   ida_idd.DEBUGGER_ID_ARM_LINUX_USER
   ida_idd.DEBUGGER_ID_TRACE_REPLAYER
   ida_idd.DEBUGGER_ID_X86_PIN_TRACER
   ida_idd.DEBUGGER_ID_DALVIK_USER
   ida_idd.DEBUGGER_ID_XNU_USER
   ida_idd.DEBUGGER_ID_ARM_MACOS_USER
   ida_idd.DBG_FLAG_REMOTE
   ida_idd.DBG_FLAG_NOHOST
   ida_idd.DBG_FLAG_FAKE_ATTACH
   ida_idd.DBG_FLAG_HWDATBPT_ONE
   ida_idd.DBG_FLAG_CAN_CONT_BPT
   ida_idd.DBG_FLAG_NEEDPORT
   ida_idd.DBG_FLAG_DONT_DISTURB
   ida_idd.DBG_FLAG_SAFE
   ida_idd.DBG_FLAG_CLEAN_EXIT
   ida_idd.DBG_FLAG_USE_SREGS
   ida_idd.DBG_FLAG_NOSTARTDIR
   ida_idd.DBG_FLAG_NOPARAMETERS
   ida_idd.DBG_FLAG_NOPASSWORD
   ida_idd.DBG_FLAG_CONNSTRING
   ida_idd.DBG_FLAG_SMALLBLKS
   ida_idd.DBG_FLAG_MANMEMINFO
   ida_idd.DBG_FLAG_EXITSHOTOK
   ida_idd.DBG_FLAG_VIRTHREADS
   ida_idd.DBG_FLAG_LOWCNDS
   ida_idd.DBG_FLAG_DEBTHREAD
   ida_idd.DBG_FLAG_DEBUG_DLL
   ida_idd.DBG_FLAG_FAKE_MEMORY
   ida_idd.DBG_FLAG_ANYSIZE_HWBPT
   ida_idd.DBG_FLAG_TRACER_MODULE
   ida_idd.DBG_FLAG_PREFER_SWBPTS
   ida_idd.DBG_FLAG_LAZY_WATCHPTS
   ida_idd.DBG_FLAG_FAST_STEP
   ida_idd.DBG_FLAG_ADD_ENVS
   ida_idd.DBG_FLAG_MERGE_ENVS
   ida_idd.DBG_FLAG_DISABLE_ASLR
   ida_idd.DBG_FLAG_TTD
   ida_idd.DBG_FLAG_FULL_INSTR_BPT
   ida_idd.DBG_HAS_GET_PROCESSES
   ida_idd.DBG_HAS_ATTACH_PROCESS
   ida_idd.DBG_HAS_DETACH_PROCESS
   ida_idd.DBG_HAS_REQUEST_PAUSE
   ida_idd.DBG_HAS_SET_EXCEPTION_INFO
   ida_idd.DBG_HAS_THREAD_SUSPEND
   ida_idd.DBG_HAS_THREAD_CONTINUE
   ida_idd.DBG_HAS_SET_RESUME_MODE
   ida_idd.DBG_HAS_THREAD_GET_SREG_BASE
   ida_idd.DBG_HAS_CHECK_BPT
   ida_idd.DBG_HAS_OPEN_FILE
   ida_idd.DBG_HAS_UPDATE_CALL_STACK
   ida_idd.DBG_HAS_APPCALL
   ida_idd.DBG_HAS_REXEC
   ida_idd.DBG_HAS_MAP_ADDRESS
   ida_idd.DBG_RESMOD_STEP_INTO
   ida_idd.DBG_RESMOD_STEP_OVER
   ida_idd.DBG_RESMOD_STEP_OUT
   ida_idd.DBG_RESMOD_STEP_SRCINTO
   ida_idd.DBG_RESMOD_STEP_SRCOVER
   ida_idd.DBG_RESMOD_STEP_SRCOUT
   ida_idd.DBG_RESMOD_STEP_USER
   ida_idd.DBG_RESMOD_STEP_HANDLE
   ida_idd.DBG_RESMOD_STEP_BACKINTO
   ida_idd.DBG_PROC_IS_DLL
   ida_idd.DBG_PROC_IS_GUI
   ida_idd.DBG_PROC_32BIT
   ida_idd.DBG_PROC_64BIT
   ida_idd.DBG_NO_TRACE
   ida_idd.DBG_HIDE_WINDOW
   ida_idd.DBG_SUSPENDED
   ida_idd.DBG_NO_ASLR
   ida_idd.BPT_OK
   ida_idd.BPT_INTERNAL_ERR
   ida_idd.BPT_BAD_TYPE
   ida_idd.BPT_BAD_ALIGN
   ida_idd.BPT_BAD_ADDR
   ida_idd.BPT_BAD_LEN
   ida_idd.BPT_TOO_MANY
   ida_idd.BPT_READ_ERROR
   ida_idd.BPT_WRITE_ERROR
   ida_idd.BPT_SKIP
   ida_idd.BPT_PAGE_OK
   ida_idd.APPCALL_MANUAL
   ida_idd.APPCALL_DEBEV
   ida_idd.APPCALL_TIMEOUT
   ida_idd.RQ_MASKING
   ida_idd.RQ_SUSPEND
   ida_idd.RQ_NOSUSP
   ida_idd.RQ_IGNWERR
   ida_idd.RQ_SILENT
   ida_idd.RQ_VERBOSE
   ida_idd.RQ_SWSCREEN
   ida_idd.RQ__NOTHRRF
   ida_idd.RQ_PROCEXIT
   ida_idd.RQ_IDAIDLE
   ida_idd.RQ_SUSPRUN
   ida_idd.RQ_RESUME
   ida_idd.RQ_RESMOD
   ida_idd.RQ_RESMOD_SHIFT
   ida_idd.NO_PROCESS
   ida_idd.NO_THREAD
   ida_idd.dbg_can_query
   ida_idd.Appcall


Classes
-------

.. autoapisummary::

   ida_idd.excvec_t
   ida_idd.procinfo_vec_t
   ida_idd.call_stack_info_vec_t
   ida_idd.meminfo_vec_template_t
   ida_idd.regvals_t
   ida_idd.process_info_t
   ida_idd.debapp_attrs_t
   ida_idd.register_info_t
   ida_idd.memory_info_t
   ida_idd.meminfo_vec_t
   ida_idd.scattered_segm_t
   ida_idd.launch_env_t
   ida_idd.modinfo_t
   ida_idd.bptaddr_t
   ida_idd.excinfo_t
   ida_idd.debug_event_t
   ida_idd.exception_info_t
   ida_idd.regval_t
   ida_idd.call_stack_info_t
   ida_idd.call_stack_t
   ida_idd.thread_name_t
   ida_idd.debugger_t
   ida_idd.dyn_register_info_array
   ida_idd.Appcall_array__
   ida_idd.Appcall_callable__
   ida_idd.Appcall_consts__
   ida_idd.Appcall__


Functions
---------

.. autoapisummary::

   ida_idd.set_debug_event_code
   ida_idd.get_debug_event_name
   ida_idd.dbg_appcall
   ida_idd.cleanup_appcall
   ida_idd.cpu2ieee
   ida_idd.ieee2cpu
   ida_idd.get_dbg
   ida_idd.dbg_get_registers
   ida_idd.dbg_get_thread_sreg_base
   ida_idd.dbg_read_memory
   ida_idd.dbg_write_memory
   ida_idd.dbg_get_name
   ida_idd.dbg_get_memory_info
   ida_idd.appcall
   ida_idd.get_event_module_name
   ida_idd.get_event_module_base
   ida_idd.get_event_module_size
   ida_idd.get_event_exc_info
   ida_idd.get_event_info
   ida_idd.get_event_bpt_hea
   ida_idd.get_event_exc_code
   ida_idd.get_event_exc_ea
   ida_idd.can_exc_continue


Module Contents
---------------

.. py:class:: excvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> exception_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> exception_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: excvec_t) -> None


   .. py:method:: extract() -> exception_info_t *


   .. py:method:: inject(s: exception_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< exception_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< exception_info_t >::const_iterator


   .. py:method:: insert(it: exception_info_t, x: exception_info_t) -> qvector< exception_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< exception_info_t >::iterator


   .. py:method:: append(x: exception_info_t) -> None


   .. py:method:: extend(x: excvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: procinfo_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> process_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> process_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: procinfo_vec_t) -> None


   .. py:method:: extract() -> process_info_t *


   .. py:method:: inject(s: process_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< process_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< process_info_t >::const_iterator


   .. py:method:: insert(it: process_info_t, x: process_info_t) -> qvector< process_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< process_info_t >::iterator


   .. py:method:: append(x: process_info_t) -> None


   .. py:method:: extend(x: procinfo_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: call_stack_info_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> call_stack_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> call_stack_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: call_stack_info_vec_t) -> None


   .. py:method:: extract() -> call_stack_info_t *


   .. py:method:: inject(s: call_stack_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< call_stack_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< call_stack_info_t >::const_iterator


   .. py:method:: insert(it: call_stack_info_t, x: call_stack_info_t) -> qvector< call_stack_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< call_stack_info_t >::iterator


   .. py:method:: find(*args) -> qvector< call_stack_info_t >::const_iterator


   .. py:method:: has(x: call_stack_info_t) -> bool


   .. py:method:: add_unique(x: call_stack_info_t) -> bool


   .. py:method:: append(x: call_stack_info_t) -> None


   .. py:method:: extend(x: call_stack_info_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: meminfo_vec_template_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> memory_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> memory_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: meminfo_vec_template_t) -> None


   .. py:method:: extract() -> memory_info_t *


   .. py:method:: inject(s: memory_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< memory_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< memory_info_t >::const_iterator


   .. py:method:: insert(it: memory_info_t, x: memory_info_t) -> qvector< memory_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< memory_info_t >::iterator


   .. py:method:: find(*args) -> qvector< memory_info_t >::const_iterator


   .. py:method:: has(x: memory_info_t) -> bool


   .. py:method:: add_unique(x: memory_info_t) -> bool


   .. py:method:: append(x: memory_info_t) -> None


   .. py:method:: extend(x: meminfo_vec_template_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: regvals_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> regval_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> regval_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: regvals_t) -> None


   .. py:method:: extract() -> regval_t *


   .. py:method:: inject(s: regval_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< regval_t >::const_iterator


   .. py:method:: end(*args) -> qvector< regval_t >::const_iterator


   .. py:method:: insert(it: regval_t, x: regval_t) -> qvector< regval_t >::iterator


   .. py:method:: erase(*args) -> qvector< regval_t >::iterator


   .. py:method:: find(*args) -> qvector< regval_t >::const_iterator


   .. py:method:: has(x: regval_t) -> bool


   .. py:method:: add_unique(x: regval_t) -> bool


   .. py:method:: append(x: regval_t) -> None


   .. py:method:: extend(x: regvals_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: IDD_INTERFACE_VERSION

   The IDD interface version number.


.. py:data:: NO_THREAD

   No thread. in PROCESS_STARTED this value can be used to specify that the main thread has not been created. It will be initialized later by a THREAD_STARTED event. 
           


.. py:class:: process_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: pid
      :type:  pid_t

      process id



   .. py:attribute:: name
      :type:  str

      process name



.. py:class:: debapp_attrs_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cbsize
      :type:  int

      control field: size of this structure



   .. py:attribute:: addrsize
      :type:  int

      address size of the process. Since 64-bit debuggers usually can debug 32-bit applications, we cannot rely on sizeof(ea_t) to detect the current address size. The following variable should be used instead. It is initialized with 8 for 64-bit debuggers but they should adjust it as soon as they learn that a 32-bit application is being debugged. For 32-bit debuggers it is initialized with 4. 
              



   .. py:attribute:: platform
      :type:  str

      platform name process is running/debugging under. (is used as a key value in exceptions.cfg) 
              



   .. py:attribute:: is_be
      :type:  int


.. py:data:: DEF_ADDRSIZE

.. py:class:: register_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      Register name.



   .. py:attribute:: flags
      :type:  int

      Register info attribute flags 
              



   .. py:attribute:: register_class_mask
      :type:  uchar

      mask of register classes



   .. py:attribute:: dtype
      :type:  op_dtype_t

      Register size (see Operand value types)



   .. py:attribute:: default_bit_strings_mask
      :type:  int

      mask of default bits



   .. py:attribute:: bit_strings

      strings corresponding to each bit of the register. (nullptr = no bit, same name = multi-bits mask) 
              



   .. py:attribute:: register_class


.. py:data:: REGISTER_READONLY

   the user can't modify the current value of this register


.. py:data:: REGISTER_IP

   instruction pointer


.. py:data:: REGISTER_SP

   stack pointer


.. py:data:: REGISTER_FP

   frame pointer


.. py:data:: REGISTER_ADDRESS

   may contain an address


.. py:data:: REGISTER_CS

   code segment


.. py:data:: REGISTER_SS

   stack segment


.. py:data:: REGISTER_NOLF

   displays this register without returning to the next line, allowing the next register to be displayed to its right (on the same line) 
           


.. py:data:: REGISTER_CUSTFMT

   register should be displayed using a custom data format. the format name is in bit_strings[0]; the corresponding regval_t will use bytevec_t 
           


.. py:class:: memory_info_t

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      Memory range name.



   .. py:attribute:: sclass
      :type:  str

      Memory range class name.



   .. py:attribute:: sbase
      :type:  ida_idaapi.ea_t

      Segment base (meaningful only for segmented architectures, e.g. 16-bit x86) The base is specified in paragraphs (i.e. shifted to the right by 4) 
              



   .. py:attribute:: bitness
      :type:  uchar

      Number of bits in segment addresses (0-16bit, 1-32bit, 2-64bit)



   .. py:attribute:: perm
      :type:  uchar

      Memory range permissions (0-no information): see segment.hpp.



.. py:class:: meminfo_vec_t

   Bases: :py:obj:`meminfo_vec_template_t`


   .. py:attribute:: thisown


.. py:class:: scattered_segm_t

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      name of the segment



.. py:class:: launch_env_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: merge
      :type:  bool


   .. py:method:: set(envvar: str, value: str) -> None


   .. py:method:: envs() -> PyObject *


.. py:data:: NO_EVENT

   Not an interesting event. This event can be used if the debugger module needs to return an event but there are no valid events. 
             


.. py:data:: PROCESS_STARTED

   New process has been started.


.. py:data:: PROCESS_EXITED

   Process has been stopped.


.. py:data:: THREAD_STARTED

   New thread has been started.


.. py:data:: THREAD_EXITED

   Thread has been stopped.


.. py:data:: BREAKPOINT

   Breakpoint has been reached. IDA will complain about unknown breakpoints, they should be reported as exceptions. 
             


.. py:data:: STEP

   One instruction has been executed. Spurious events of this kind are silently ignored by IDA. 
             


.. py:data:: EXCEPTION

   Exception.


.. py:data:: LIB_LOADED

   New library has been loaded.


.. py:data:: LIB_UNLOADED

   Library has been unloaded.


.. py:data:: INFORMATION

   User-defined information. This event can be used to return empty information This will cause IDA to call get_debug_event() immediately once more. 
             


.. py:data:: PROCESS_ATTACHED

   Successfully attached to running process.


.. py:data:: PROCESS_DETACHED

   Successfully detached from process.


.. py:data:: PROCESS_SUSPENDED

   Process has been suspended. This event can be used by the debugger module to signal if the process spontaneously gets suspended (not because of an exception, breakpoint, or single step). IDA will silently switch to the 'suspended process' mode without displaying any messages. 
             


.. py:data:: TRACE_FULL

   The trace buffer of the tracer module is full and IDA needs to read it before continuing 
             


.. py:data:: STATUS_MASK

   additional info about process state


.. py:data:: BITNESS_CHANGED

   Debugger detected the process bitness changing.


.. py:function:: set_debug_event_code(ev: debug_event_t, id: event_id_t) -> None

.. py:class:: modinfo_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      full name of the module



   .. py:attribute:: base
      :type:  ida_idaapi.ea_t

      module base address. if unknown pass BADADDR



   .. py:attribute:: size
      :type:  asize_t

      module size. if unknown pass 0



   .. py:attribute:: rebase_to
      :type:  ida_idaapi.ea_t

      if not BADADDR, then rebase the program to the specified address



.. py:class:: bptaddr_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: hea
      :type:  ida_idaapi.ea_t

      Possible address referenced by hardware breakpoints.



   .. py:attribute:: kea
      :type:  ida_idaapi.ea_t

      Address of the triggered bpt from the kernel's point of view. (for some systems with special memory mappings, the triggered ea might be different from event ea). Use to BADADDR for flat memory model. 
              



.. py:class:: excinfo_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: code
      :type:  int

      Exception code.



   .. py:attribute:: can_cont
      :type:  bool

      Execution of the process can continue after this exception?



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      Possible address referenced by the exception.



   .. py:attribute:: info
      :type:  str

      Exception message.



.. py:class:: debug_event_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: pid
      :type:  pid_t

      Process where the event occurred.



   .. py:attribute:: tid
      :type:  thid_t

      Thread where the event occurred.



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      Address where the event occurred.



   .. py:attribute:: handled
      :type:  bool

      Is event handled by the debugger?. (from the system's point of view) Meaningful for EXCEPTION events 
              



   .. py:method:: copy(r: debug_event_t) -> debug_event_t &


   .. py:method:: clear() -> None

      clear the dependent information (see below), set event code to NO_EVENT



   .. py:method:: clear_all() -> None


   .. py:method:: eid() -> event_id_t

      Event code.



   .. py:method:: set_eid(id: event_id_t) -> None

      Set event code. If the new event code is compatible with the old one then the dependent information (see below) will be preserved. Otherwise the event will be cleared and the new event code will be set. 
              



   .. py:method:: is_bitness_changed() -> bool

      process bitness



   .. py:method:: set_bitness_changed(on: bool = True) -> None


   .. py:method:: modinfo() -> modinfo_t &

      Information that depends on the event code:

      < PROCESS_STARTED, PROCESS_ATTACHED, LIB_LOADED PROCESS_EXITED, THREAD_EXITED 
              



   .. py:method:: info() -> str

      BREAKPOINT



   .. py:method:: bpt() -> bptaddr_t &

      EXCEPTION



   .. py:method:: exc() -> excinfo_t &


   .. py:method:: exit_code() -> int const &

      THREAD_STARTED (thread name) LIB_UNLOADED (unloaded library name) INFORMATION (will be displayed in the output window if not empty) 
              



   .. py:method:: set_modinfo(id: event_id_t) -> modinfo_t &


   .. py:method:: set_exit_code(id: event_id_t, code: int) -> None


   .. py:method:: set_info(id: event_id_t) -> str


   .. py:method:: set_bpt() -> bptaddr_t &


   .. py:method:: set_exception() -> excinfo_t &


   .. py:method:: bpt_ea() -> ida_idaapi.ea_t

      On some systems with special memory mappings the triggered ea might be different from the actual ea. Calculate the address to use. 
              



.. py:function:: get_debug_event_name(dev: debug_event_t) -> str

   get debug event name


.. py:class:: exception_info_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: code
      :type:  uint

      exception code



   .. py:attribute:: flags
      :type:  int

      Exception info flags 
              



   .. py:method:: break_on() -> bool

      Should we break on the exception?



   .. py:method:: handle() -> bool

      Should we handle the exception?



   .. py:attribute:: name
      :type:  str

      Exception standard name.



   .. py:attribute:: desc
      :type:  str

      Long message used to display info about the exception.



.. py:data:: cvar

.. py:data:: BPT_WRITE

   Write access.


.. py:data:: BPT_READ

   Read access.


.. py:data:: BPT_RDWR

   Read/write access.


.. py:data:: BPT_SOFT

   Software breakpoint.


.. py:data:: BPT_EXEC

   Execute instruction.


.. py:data:: BPT_DEFAULT

   Choose bpt type automatically.


.. py:data:: EXC_BREAK

   break on the exception


.. py:data:: EXC_HANDLE

   should be handled by the debugger?


.. py:data:: EXC_MSG

   instead of a warning, log the exception to the output window


.. py:data:: EXC_SILENT

   do not warn or log to the output window


.. py:class:: regval_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: rvtype
      :type:  int

      one of Register value types



   .. py:attribute:: ival
      :type:  uint64

      RVT_INT.



   .. py:method:: use_bytevec() -> bool


   .. py:method:: clear() -> None

      Clear register value.



   .. py:method:: swap(r: regval_t) -> None

      Set this = r and r = this.



   .. py:method:: set_int(x: uint64) -> None


   .. py:method:: set_float(v: bytevec_t const &) -> None


   .. py:method:: set_bytes(*args) -> bytevec_t &


   .. py:method:: set_unavailable() -> None


   .. py:method:: bytes(*args) -> bytevec_t const &


   .. py:method:: get_data(*args) -> void const *


   .. py:method:: get_data_size() -> size_t


   .. py:method:: set_pyval(o: PyObject *, dtype: op_dtype_t) -> bool


   .. py:method:: pyval(dtype: op_dtype_t) -> PyObject *


.. py:data:: RVT_FLOAT

   floating point


.. py:data:: RVT_INT

   integer


.. py:data:: RVT_UNAVAILABLE

   unavailable; other values mean custom data type 
           


.. py:class:: call_stack_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: callea
      :type:  ida_idaapi.ea_t

      the address of the call instruction. for the 0th frame this is usually just the current value of EIP. 
              



   .. py:attribute:: funcea
      :type:  ida_idaapi.ea_t

      the address of the called function



   .. py:attribute:: fp
      :type:  ida_idaapi.ea_t

      the value of the frame pointer of the called function



   .. py:attribute:: funcok
      :type:  bool

      is the function present?



.. py:class:: call_stack_t

   Bases: :py:obj:`call_stack_info_vec_t`


   .. py:attribute:: thisown


.. py:function:: dbg_appcall(retval: idc_value_t *, func_ea: ida_idaapi.ea_t, tid: thid_t, ptif: tinfo_t, argv: idc_value_t *, argnum: size_t) -> error_t

   Call a function from the debugged application. 
           
   :param retval: function return value
   * for APPCALL_MANUAL, r will hold the new stack point value
   * for APPCALL_DEBEV, r will hold the exception information upon failure and the return code will be eExecThrow
   :param func_ea: address to call
   :param tid: thread to use. NO_THREAD means to use the current thread
   :param ptif: pointer to type of the function to call
   :param argv: array of arguments
   :param argnum: number of actual arguments
   :returns: eOk if successful, otherwise an error code


.. py:function:: cleanup_appcall(tid: thid_t) -> error_t

   Cleanup after manual appcall. 
           
   :param tid: thread to use. NO_THREAD means to use the current thread The application state is restored as it was before calling the last appcall(). Nested appcalls are supported.
   :returns: eOk if successful, otherwise an error code


.. py:class:: thread_name_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: tid
      :type:  thid_t

      thread



   .. py:attribute:: name
      :type:  str

      new thread name



.. py:data:: RESMOD_NONE

   no stepping, run freely


.. py:data:: RESMOD_INTO

   step into call (the most typical single stepping)


.. py:data:: RESMOD_OVER

   step over call


.. py:data:: RESMOD_OUT

   step out of the current function (run until return)


.. py:data:: RESMOD_SRCINTO

   until control reaches a different source line


.. py:data:: RESMOD_SRCOVER

   next source line in the current stack frame


.. py:data:: RESMOD_SRCOUT

   next source line in the previous stack frame


.. py:data:: RESMOD_USER

   step out to the user code


.. py:data:: RESMOD_HANDLE

   step into the exception handler


.. py:data:: RESMOD_BACKINTO

   step backwards into call (in time-travel debugging)


.. py:data:: RESMOD_MAX

.. py:data:: STEP_TRACE

   lowest level trace. trace buffers are not maintained


.. py:data:: INSN_TRACE

   instruction tracing


.. py:data:: FUNC_TRACE

   function tracing


.. py:data:: BBLK_TRACE

   basic block tracing


.. py:data:: DRC_EVENTS

   success, there are pending events


.. py:data:: DRC_CRC

   success, but the input file crc does not match


.. py:data:: DRC_OK

   success


.. py:data:: DRC_NONE

   reaction to the event not implemented


.. py:data:: DRC_FAILED

   failed or false


.. py:data:: DRC_NETERR

   network error


.. py:data:: DRC_NOFILE

   file not found


.. py:data:: DRC_IDBSEG

   use idb segmentation


.. py:data:: DRC_NOPROC

   the process does not exist anymore


.. py:data:: DRC_NOCHG

   no changes


.. py:data:: DRC_ERROR

   unclassified error, may be complemented by errbuf


.. py:class:: debugger_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: version
      :type:  int

      Expected kernel version, should be IDD_INTERFACE_VERSION 
              



   .. py:attribute:: name
      :type:  str

      Short debugger name like win32 or linux.



   .. py:attribute:: id
      :type:  int

      one of Debugger API module id



   .. py:attribute:: processor
      :type:  str

      Required processor name. Used for instant debugging to load the correct processor module 
              



   .. py:attribute:: flags
      :type:  uint64


   .. py:method:: is_remote() -> bool


   .. py:method:: must_have_hostname() -> bool


   .. py:method:: can_continue_from_bpt() -> bool


   .. py:method:: may_disturb() -> bool


   .. py:method:: is_safe() -> bool


   .. py:method:: use_sregs() -> bool


   .. py:method:: cache_block_size() -> size_t


   .. py:method:: use_memregs() -> bool


   .. py:method:: may_take_exit_snapshot() -> bool


   .. py:method:: virtual_threads() -> bool


   .. py:method:: supports_lowcnds() -> bool


   .. py:method:: supports_debthread() -> bool


   .. py:method:: can_debug_standalone_dlls() -> bool


   .. py:method:: fake_memory() -> bool


   .. py:method:: is_ttd() -> bool


   .. py:method:: has_get_processes() -> bool


   .. py:method:: has_attach_process() -> bool


   .. py:method:: has_detach_process() -> bool


   .. py:method:: has_request_pause() -> bool


   .. py:method:: has_set_exception_info() -> bool


   .. py:method:: has_thread_suspend() -> bool


   .. py:method:: has_thread_continue() -> bool


   .. py:method:: has_set_resume_mode() -> bool


   .. py:method:: has_thread_get_sreg_base() -> bool


   .. py:method:: has_check_bpt() -> bool


   .. py:method:: has_open_file() -> bool


   .. py:method:: has_update_call_stack() -> bool


   .. py:method:: has_appcall() -> bool


   .. py:method:: has_rexec() -> bool


   .. py:method:: has_map_address() -> bool


   .. py:method:: has_soft_bpt() -> bool


   .. py:attribute:: default_regclasses
      :type:  int

      Mask of default printed register classes.



   .. py:method:: regs(idx: int) -> register_info_t &


   .. py:attribute:: memory_page_size
      :type:  int

      Size of a memory page. Usually 4K.



   .. py:attribute:: bpt_size
      :type:  uchar

      Size of the software breakpoint instruction in bytes.



   .. py:attribute:: filetype
      :type:  uchar

      Input file type for the instant debugger. This value will be used after attaching to a new process. 
              



   .. py:attribute:: resume_modes
      :type:  ushort

      Resume modes 
              



   .. py:method:: is_resmod_avail(resmod: int) -> bool


   .. py:attribute:: ev_init_debugger

      Initialize debugger. This event is generated in the main thread. 
                



   .. py:attribute:: ev_term_debugger

      Terminate debugger. This event is generated in the main thread. 
                



   .. py:attribute:: ev_get_processes

      Return information about the running processes. This event is generated in the main thread. Available if DBG_HAS_GET_PROCESSES is set 
                



   .. py:attribute:: ev_start_process

      Start an executable to debug. This event is generated in debthread. Must be implemented. 
                



   .. py:attribute:: ev_attach_process

      Attach to an existing running process. event_id should be equal to -1 if not attaching to a crashed process. This event is generated in debthread. Available if DBG_HAS_ATTACH_PROCESS is set 
                



   .. py:attribute:: ev_detach_process

      Detach from the debugged process. May be generated while the process is running or suspended. Must detach from the process in any case. The kernel will repeatedly call get_debug_event() until PROCESS_DETACHED is received. In this mode, all other events will be automatically handled and process will be resumed. This event is generated from debthread. Available if DBG_HAS_DETACH_PROCESS is set 
                



   .. py:attribute:: ev_get_debapp_attrs

      Retrieve process- and debugger-specific runtime attributes. This event is generated in the main thread. 
                



   .. py:attribute:: ev_rebase_if_required_to

      Rebase database if the debugged program has been rebased by the system. This event is generated in the main thread. 
                



   .. py:attribute:: ev_request_pause

      Prepare to pause the process. Normally the next get_debug_event() will pause the process If the process is sleeping, then the pause will not occur until the process wakes up. If the debugger module does not react to this event, then it will be impossible to pause the program. This event is generated in debthread. Available if DBG_HAS_REQUEST_PAUSE is set 
                



   .. py:attribute:: ev_exit_process

      Stop the process. May be generated while the process is running or suspended. Must terminate the process in any case. The kernel will repeatedly call get_debug_event() until PROCESS_EXITED is received. In this mode, all other events will be automatically handled and process will be resumed. This event is generated in debthread. Must be implemented. 
                



   .. py:attribute:: ev_get_debug_event

      Get a pending debug event and suspend the process. This event will be generated regularly by IDA. This event is generated in debthread. IMPORTANT: the BREAKPOINT/EXCEPTION/STEP events must be reported only after reporting other pending events for a thread. Must be implemented. 
                



   .. py:attribute:: ev_resume

      Continue after handling the event. This event is generated in debthread. Must be implemented. 
                



   .. py:attribute:: ev_set_backwards

      Set whether the debugger should continue backwards or forwards. This event is generated in debthread. Available if DBG_FLAG_TTD is set 
                



   .. py:attribute:: ev_set_exception_info

      Set exception handling. This event is generated in debthread or the main thread. Available if DBG_HAS_SET_EXCEPTION_INFO is set 
                



   .. py:attribute:: ev_suspended

      This event will be generated by the kernel each time it has suspended the debuggee process and refreshed the database. The debugger module may add information to the database if necessary.
      The reason for introducing this event is that when an event like LOAD_DLL happens, the database does not reflect the memory state yet and therefore we can't add information about the dll into the database in the get_debug_event() function. Only when the kernel has adjusted the database we can do it. Example: for loaded PE DLLs we can add the exported function names to the list of debug names (see set_debug_names()).
      This event is generated in the main thread. 
                



   .. py:attribute:: ev_thread_suspend

      Suspend a running thread Available if DBG_HAS_THREAD_SUSPEND is set 
                



   .. py:attribute:: ev_thread_continue

      Resume a suspended thread Available if DBG_HAS_THREAD_CONTINUE is set 
                



   .. py:attribute:: ev_set_resume_mode

      Specify resume action Available if DBG_HAS_SET_RESUME_MODE is set 
                



   .. py:attribute:: ev_read_registers

      Read thread registers. This event is generated in debthread. Must be implemented. 
                



   .. py:attribute:: ev_write_register

      Write one thread register. This event is generated in debthread. Must be implemented. 
                



   .. py:attribute:: ev_thread_get_sreg_base

      Get information about the base of a segment register. Currently used by the IBM PC module to resolve references like fs:0. This event is generated in debthread. Available if DBG_HAS_THREAD_GET_SREG_BASE is set 
                



   .. py:attribute:: ev_get_memory_info

      Get information on the memory ranges. The debugger module fills 'ranges'. The returned vector must be sorted. This event is generated in debthread. Must be implemented. 
                



   .. py:attribute:: ev_read_memory

      Read process memory. This event is generated in debthread. 
                



   .. py:attribute:: ev_write_memory

      Write process memory. This event is generated in debthread. 
                



   .. py:attribute:: ev_check_bpt

      Is it possible to set breakpoint? This event is generated in debthread or in the main thread if debthread is not running yet. It is generated to verify hardware breakpoints. Available if DBG_HAS_CHECK_BPT is set 
                



   .. py:attribute:: ev_update_bpts

      Add/del breakpoints. bpts array contains nadd bpts to add, followed by ndel bpts to del. This event is generated in debthread. 
                



   .. py:attribute:: ev_update_lowcnds

      Update low-level (server side) breakpoint conditions. This event is generated in debthread. 
                



   .. py:attribute:: ev_open_file


   .. py:attribute:: ev_close_file


   .. py:attribute:: ev_read_file


   .. py:attribute:: ev_write_file


   .. py:attribute:: ev_map_address

      Map process address. The debugger module may ignore this event. This event is generated in debthread. IDA will generate this event only if DBG_HAS_MAP_ADDRESS is set. 
                



   .. py:attribute:: ev_get_debmod_extensions

      Get pointer to debugger specific events. This event returns a pointer to a structure that holds pointers to debugger module specific events. For information on the structure layout, please check the corresponding debugger module. Most debugger modules return nullptr because they do not have any extensions. Available extensions may be generated from plugins. This event is generated in the main thread. 
                



   .. py:attribute:: ev_update_call_stack

      Calculate the call stack trace for the given thread. This event is generated when the process is suspended and should fill the 'trace' object with the information about the current call stack. If this event returns DRC_NONE, IDA will try to invoke a processor-specific mechanism (see processor_t::ev_update_call_stack). If the current processor module does not implement stack tracing, then IDA will fall back to a generic algorithm (based on the frame pointer chain) to calculate the trace. This event is ideal if the debugging targets manage stack frames in a peculiar way, requiring special analysis. This event is generated in the main thread. Available if DBG_HAS_UPDATE_CALL_STACK is set 
                



   .. py:attribute:: ev_appcall

      Call application function. This event calls a function from the debugged application. This event is generated in debthread Available if HAS_APPCALL is set 
                



   .. py:attribute:: ev_cleanup_appcall

      Cleanup after appcall(). The debugger module must keep the stack blob in the memory until this event is generated. It will be generated by the kernel for each successful appcall(). There is an exception: if APPCALL_MANUAL, IDA may not call cleanup_appcall. If the user selects to terminate a manual appcall, then cleanup_appcall will be generated. Otherwise, the debugger module should terminate the appcall when the generated event returns. This event is generated in debthread. Available if HAS_APPCALL is set 
                



   .. py:attribute:: ev_eval_lowcnd

      Evaluate a low level breakpoint condition at 'ea'. Other evaluation errors are displayed in a dialog box. This call is used by IDA when the process has already been temporarily suspended for some reason and IDA has to decide whether the process should be resumed or definitely suspended because of a breakpoint with a low level condition. This event is generated in debthread. 
                



   .. py:attribute:: ev_send_ioctl

      Perform a debugger-specific event. This event is generated in debthread 
                



   .. py:attribute:: ev_dbg_enable_trace

      Enable/Disable tracing. The kernel will generated this event if the debugger plugin set DBG_FLAG_TRACER_MODULE. TRACE_FLAGS can be a set of STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE. This event is generated in the main thread. 
                



   .. py:attribute:: ev_is_tracing_enabled

      Is tracing enabled? The kernel will generated this event if the debugger plugin set DBG_FLAG_TRACER_MODULE. TRACE_BIT can be one of the following: STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE 
                



   .. py:attribute:: ev_rexec

      Execute a command on the remote computer. Available if DBG_HAS_REXEC is set 
                



   .. py:attribute:: ev_get_srcinfo_path

      Get the path to a file containing source debug info for the given module. This allows srcinfo providers to call into the debugger when looking for debug info. It is useful in certain cases like the iOS debugger, which is a remote debugger but the remote debugserver does not provide dwarf info. So, we allow the debugger client to decide where to look for debug info locally. 
                



   .. py:attribute:: ev_bin_search

      Search for a binary pattern in the program. 
                



   .. py:attribute:: ev_get_dynamic_register_set

      Ask debuger to send dynamic register set 
                



   .. py:attribute:: ev_set_dbg_options

      Set debugger options (parameters that are specific to the debugger module). 
                



   .. py:method:: init_debugger(hostname: str, portnum: int, password: str) -> bool


   .. py:method:: term_debugger() -> bool


   .. py:method:: get_processes(procs: procinfo_vec_t) -> drc_t


   .. py:method:: start_process(path: str, args: str, envs: launch_env_t, startdir: str, dbg_proc_flags: int, input_path: str, input_file_crc32: int) -> drc_t


   .. py:method:: attach_process(pid: pid_t, event_id: int, dbg_proc_flags: int) -> drc_t


   .. py:method:: detach_process() -> drc_t


   .. py:method:: get_debapp_attrs(out_pattrs: debapp_attrs_t) -> bool


   .. py:method:: rebase_if_required_to(new_base: ida_idaapi.ea_t) -> None


   .. py:method:: request_pause() -> drc_t


   .. py:method:: exit_process() -> drc_t


   .. py:method:: get_debug_event(event: debug_event_t, timeout_ms: int) -> gdecode_t


   .. py:method:: resume(event: debug_event_t) -> drc_t


   .. py:method:: set_backwards(backwards: bool) -> drc_t


   .. py:method:: set_exception_info(info: exception_info_t, qty: int) -> None


   .. py:method:: suspended(dlls_added: bool, thr_names: thread_name_vec_t * = None) -> None


   .. py:method:: thread_suspend(tid: thid_t) -> drc_t


   .. py:method:: thread_continue(tid: thid_t) -> drc_t


   .. py:method:: set_resume_mode(tid: thid_t, resmod: resume_mode_t) -> drc_t


   .. py:method:: read_registers(tid: thid_t, clsmask: int, values: regval_t) -> drc_t


   .. py:method:: write_register(tid: thid_t, regidx: int, value: regval_t) -> drc_t


   .. py:method:: thread_get_sreg_base(answer: ea_t *, tid: thid_t, sreg_value: int) -> drc_t


   .. py:method:: get_memory_info(ranges: meminfo_vec_t) -> drc_t


   .. py:method:: read_memory(nbytes: size_t *, ea: ida_idaapi.ea_t, buffer: void *, size: size_t) -> drc_t


   .. py:method:: write_memory(nbytes: size_t *, ea: ida_idaapi.ea_t, buffer: void const *, size: size_t) -> drc_t


   .. py:method:: check_bpt(bptvc: int *, type: bpttype_t, ea: ida_idaapi.ea_t, len: int) -> drc_t


   .. py:method:: update_bpts(nbpts: int *, bpts: update_bpt_info_t *, nadd: int, ndel: int) -> drc_t


   .. py:method:: update_lowcnds(nupdated: int *, lowcnds: lowcnd_t const *, nlowcnds: int) -> drc_t


   .. py:method:: open_file(file: str, fsize: uint64 *, readonly: bool) -> int


   .. py:method:: close_file(fn: int) -> None


   .. py:method:: read_file(fn: int, off: qoff64_t, buf: void *, size: size_t) -> ssize_t


   .. py:method:: write_file(fn: int, off: qoff64_t, buf: void const *) -> ssize_t


   .. py:method:: map_address(off: ida_idaapi.ea_t, regs: regval_t, regnum: int) -> ida_idaapi.ea_t


   .. py:method:: get_debmod_extensions() -> void const *


   .. py:method:: update_call_stack(tid: thid_t, trace: call_stack_t) -> drc_t


   .. py:method:: cleanup_appcall(tid: thid_t) -> drc_t


   .. py:method:: eval_lowcnd(tid: thid_t, ea: ida_idaapi.ea_t) -> drc_t


   .. py:method:: send_ioctl(fn: int, buf: void const *, poutbuf: void **, poutsize: ssize_t *) -> drc_t


   .. py:method:: dbg_enable_trace(tid: thid_t, enable: bool, trace_flags: int) -> bool


   .. py:method:: is_tracing_enabled(tid: thid_t, tracebit: int) -> bool


   .. py:method:: rexec(cmdline: str) -> int


   .. py:method:: get_srcinfo_path(path: str, base: ida_idaapi.ea_t) -> bool


   .. py:method:: bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t const &, srch_flags: int) -> drc_t


   .. py:method:: get_dynamic_register_set(regset: dynamic_register_set_t *) -> bool


   .. py:method:: have_set_options() -> bool


   .. py:attribute:: registers

      Array of registers. Use regs() to access it.



   .. py:attribute:: nregisters

      Number of registers.



   .. py:attribute:: regclasses

      Array of register class names.



   .. py:attribute:: bpt_bytes

      A software breakpoint instruction.



.. py:data:: DEBUGGER_ID_X86_IA32_WIN32_USER

   Userland win32 processes (win32 debugging APIs)


.. py:data:: DEBUGGER_ID_X86_IA32_LINUX_USER

   Userland linux processes (ptrace())


.. py:data:: DEBUGGER_ID_X86_IA32_MACOSX_USER

   Userland MAC OS X processes.


.. py:data:: DEBUGGER_ID_ARM_IPHONE_USER

   iPhone 1.x


.. py:data:: DEBUGGER_ID_X86_IA32_BOCHS

   BochsDbg.exe 32.


.. py:data:: DEBUGGER_ID_6811_EMULATOR

   MC6812 emulator (beta)


.. py:data:: DEBUGGER_ID_GDB_USER

   GDB remote.


.. py:data:: DEBUGGER_ID_WINDBG

   WinDBG using Microsoft Debug engine.


.. py:data:: DEBUGGER_ID_X86_DOSBOX_EMULATOR

   Dosbox MS-DOS emulator.


.. py:data:: DEBUGGER_ID_ARM_LINUX_USER

   Userland arm linux.


.. py:data:: DEBUGGER_ID_TRACE_REPLAYER

   Fake debugger to replay recorded traces.


.. py:data:: DEBUGGER_ID_X86_PIN_TRACER

   PIN Tracer module.


.. py:data:: DEBUGGER_ID_DALVIK_USER

   Dalvik.


.. py:data:: DEBUGGER_ID_XNU_USER

   XNU Kernel.


.. py:data:: DEBUGGER_ID_ARM_MACOS_USER

   Userland arm MAC OS.


.. py:data:: DBG_FLAG_REMOTE

   Remote debugger (requires remote host name unless DBG_FLAG_NOHOST)


.. py:data:: DBG_FLAG_NOHOST

   Remote debugger with does not require network params (host/port/pass). (a unique device connected to the machine) 
           


.. py:data:: DBG_FLAG_FAKE_ATTACH

   PROCESS_ATTACHED is a fake event and does not suspend the execution 
           


.. py:data:: DBG_FLAG_HWDATBPT_ONE

   Hardware data breakpoints are one byte size by default 
           


.. py:data:: DBG_FLAG_CAN_CONT_BPT

   Debugger knows to continue from a bpt. This flag also means that the debugger module hides breakpoints from ida upon read_memory 
           


.. py:data:: DBG_FLAG_NEEDPORT

   Remote debugger requires port number (to be used with DBG_FLAG_NOHOST)


.. py:data:: DBG_FLAG_DONT_DISTURB

   Debugger can handle only get_debug_event(), request_pause(), exit_process() when the debugged process is running. The kernel may also call service functions (file I/O, map_address, etc) 
           


.. py:data:: DBG_FLAG_SAFE

   The debugger is safe (probably because it just emulates the application without really running it) 
           


.. py:data:: DBG_FLAG_CLEAN_EXIT

   IDA must suspend the application and remove all breakpoints before terminating the application. Usually this is not required because the application memory disappears upon termination. 
           


.. py:data:: DBG_FLAG_USE_SREGS

   Take segment register values into account (non flat memory)


.. py:data:: DBG_FLAG_NOSTARTDIR

   Debugger module doesn't use startup directory.


.. py:data:: DBG_FLAG_NOPARAMETERS

   Debugger module doesn't use commandline parameters.


.. py:data:: DBG_FLAG_NOPASSWORD

   Remote debugger doesn't use password.


.. py:data:: DBG_FLAG_CONNSTRING

   Display "Connection string" instead of "Hostname" and hide the "Port" field.


.. py:data:: DBG_FLAG_SMALLBLKS

   If set, IDA uses 256-byte blocks for caching memory contents. Otherwise, 1024-byte blocks are used 
           


.. py:data:: DBG_FLAG_MANMEMINFO

   If set, manual memory region manipulation commands will be available. Use this bit for debugger modules that cannot return memory layout information 
           


.. py:data:: DBG_FLAG_EXITSHOTOK

   IDA may take a memory snapshot at PROCESS_EXITED event.


.. py:data:: DBG_FLAG_VIRTHREADS

   Thread IDs may be shuffled after each debug event. (to be used for virtual threads that represent cpus for windbg kmode) 
           


.. py:data:: DBG_FLAG_LOWCNDS

   Low level breakpoint conditions are supported.


.. py:data:: DBG_FLAG_DEBTHREAD

   Supports creation of a separate thread in ida for the debugger (the debthread). Most debugger functions will be called from debthread (exceptions are marked below) The debugger module may directly call only THREAD_SAFE functions. To call other functions please use execute_sync(). The debthread significantly increases debugging speed, especially if debug events occur frequently. 
           


.. py:data:: DBG_FLAG_DEBUG_DLL

   Can debug standalone DLLs. For example, Bochs debugger can debug any snippet of code 
           


.. py:data:: DBG_FLAG_FAKE_MEMORY

   get_memory_info()/read_memory()/write_memory() work with the idb. (there is no real process to read from, as for the replayer module) the kernel will not call these functions if this flag is set. however, third party plugins may call them, they must be implemented. 
           


.. py:data:: DBG_FLAG_ANYSIZE_HWBPT

   The debugger supports arbitrary size hardware breakpoints.


.. py:data:: DBG_FLAG_TRACER_MODULE

   The module is a tracer, not a full featured debugger module.


.. py:data:: DBG_FLAG_PREFER_SWBPTS

   Prefer to use software breakpoints.


.. py:data:: DBG_FLAG_LAZY_WATCHPTS

   Watchpoints are triggered before the offending instruction is executed. The debugger must temporarily disable the watchpoint and single-step before resuming. 
           


.. py:data:: DBG_FLAG_FAST_STEP

   Do not refresh memory layout info after single stepping.


.. py:data:: DBG_FLAG_ADD_ENVS

   The debugger supports launching processes with environment variables.


.. py:data:: DBG_FLAG_MERGE_ENVS

   The debugger supports merge or replace setting for environment variables (only makes sense if DBG_FLAG_ADD_ENVS is set) 
           


.. py:data:: DBG_FLAG_DISABLE_ASLR

   The debugger support ASLR disabling (Address space layout randomization) 
           


.. py:data:: DBG_FLAG_TTD

   The debugger is a time travel debugger and supports continuing backwards.


.. py:data:: DBG_FLAG_FULL_INSTR_BPT

   Setting a breakpoint in the middle of an instruction will also break.


.. py:data:: DBG_HAS_GET_PROCESSES

   supports ev_get_processes


.. py:data:: DBG_HAS_ATTACH_PROCESS

   supports ev_attach_process


.. py:data:: DBG_HAS_DETACH_PROCESS

   supports ev_detach_process


.. py:data:: DBG_HAS_REQUEST_PAUSE

   supports ev_request_pause


.. py:data:: DBG_HAS_SET_EXCEPTION_INFO

   supports ev_set_exception_info


.. py:data:: DBG_HAS_THREAD_SUSPEND

   supports ev_thread_suspend


.. py:data:: DBG_HAS_THREAD_CONTINUE

   supports ev_thread_continue


.. py:data:: DBG_HAS_SET_RESUME_MODE

   supports ev_set_resume_mode. Cannot be set inside the debugger_t::init_debugger() 
           


.. py:data:: DBG_HAS_THREAD_GET_SREG_BASE

   supports ev_thread_get_sreg_base


.. py:data:: DBG_HAS_CHECK_BPT

   supports ev_check_bpt


.. py:data:: DBG_HAS_OPEN_FILE

   supports ev_open_file, ev_close_file, ev_read_file, ev_write_file


.. py:data:: DBG_HAS_UPDATE_CALL_STACK

   supports ev_update_call_stack


.. py:data:: DBG_HAS_APPCALL

   supports ev_appcall, ev_cleanup_appcall


.. py:data:: DBG_HAS_REXEC

   supports ev_rexec


.. py:data:: DBG_HAS_MAP_ADDRESS

   supports ev_map_address. Avoid using this bit, especially together with DBG_FLAG_DEBTHREAD because it may cause big slow downs 
           


.. py:data:: DBG_RESMOD_STEP_INTO

   RESMOD_INTO is available


.. py:data:: DBG_RESMOD_STEP_OVER

   RESMOD_OVER is available


.. py:data:: DBG_RESMOD_STEP_OUT

   RESMOD_OUT is available


.. py:data:: DBG_RESMOD_STEP_SRCINTO

   RESMOD_SRCINTO is available


.. py:data:: DBG_RESMOD_STEP_SRCOVER

   RESMOD_SRCOVER is available


.. py:data:: DBG_RESMOD_STEP_SRCOUT

   RESMOD_SRCOUT is available


.. py:data:: DBG_RESMOD_STEP_USER

   RESMOD_USER is available


.. py:data:: DBG_RESMOD_STEP_HANDLE

   RESMOD_HANDLE is available


.. py:data:: DBG_RESMOD_STEP_BACKINTO

   RESMOD_BACKINTO is available


.. py:data:: DBG_PROC_IS_DLL

   database contains a dll (not exe)


.. py:data:: DBG_PROC_IS_GUI

   using gui version of ida


.. py:data:: DBG_PROC_32BIT

   application is 32-bit


.. py:data:: DBG_PROC_64BIT

   application is 64-bit


.. py:data:: DBG_NO_TRACE

   do not trace the application (mac/linux)


.. py:data:: DBG_HIDE_WINDOW

   application should be hidden on startup (windows)


.. py:data:: DBG_SUSPENDED

   application should be suspended on startup (mac)


.. py:data:: DBG_NO_ASLR

   disable ASLR (linux)


.. py:data:: BPT_OK

   breakpoint can be set


.. py:data:: BPT_INTERNAL_ERR

   interr occurred when verifying breakpoint


.. py:data:: BPT_BAD_TYPE

   bpt type is not supported


.. py:data:: BPT_BAD_ALIGN

   alignment is invalid


.. py:data:: BPT_BAD_ADDR

   ea is invalid


.. py:data:: BPT_BAD_LEN

   bpt len is invalid


.. py:data:: BPT_TOO_MANY

   reached max number of supported breakpoints


.. py:data:: BPT_READ_ERROR

   failed to read memory at bpt ea


.. py:data:: BPT_WRITE_ERROR

   failed to write memory at bpt ea


.. py:data:: BPT_SKIP

   update_bpts(): do not process bpt


.. py:data:: BPT_PAGE_OK

   update_bpts(): ok, added a page bpt


.. py:data:: APPCALL_MANUAL

   Only set up the appcall, do not run. debugger_t::cleanup_appcall will not be generated by ida! 
           


.. py:data:: APPCALL_DEBEV

   Return debug event information.


.. py:data:: APPCALL_TIMEOUT

   Appcall with timeout. If timed out, errbuf will contain "timeout". See SET_APPCALL_TIMEOUT and GET_APPCALL_TIMEOUT 
           


.. py:data:: RQ_MASKING

   masking step handler: unless errors, tmpbpt handlers won't be generated should be used only with request_internal_step() 
           


.. py:data:: RQ_SUSPEND

   suspending step handler: suspends the app handle_debug_event: suspends the app 
           


.. py:data:: RQ_NOSUSP

   running step handler: continues the app


.. py:data:: RQ_IGNWERR

   ignore breakpoint write failures


.. py:data:: RQ_SILENT

   all: no dialog boxes


.. py:data:: RQ_VERBOSE

   all: display dialog boxes


.. py:data:: RQ_SWSCREEN

   handle_debug_event: switch screens


.. py:data:: RQ__NOTHRRF

   handle_debug_event: do not refresh threads


.. py:data:: RQ_PROCEXIT

   snapshots: the process is exiting


.. py:data:: RQ_IDAIDLE

   handle_debug_event: ida is idle


.. py:data:: RQ_SUSPRUN

   handle_debug_event: suspend at PROCESS_STARTED


.. py:data:: RQ_RESUME

   handle_debug_event: resume application


.. py:data:: RQ_RESMOD

   resume_mode_t


.. py:data:: RQ_RESMOD_SHIFT

.. py:function:: cpu2ieee(ieee_out: fpvalue_t *, cpu_fpval: void const *, size: int) -> int

   Convert a floating point number in CPU native format to IDA's internal format. 
           
   :param ieee_out: output buffer
   :param cpu_fpval: floating point number in CPU native format
   :param size: size of cpu_fpval in bytes (size of the input buffer)
   :returns: Floating point/IEEE Conversion codes


.. py:function:: ieee2cpu(cpu_fpval_out: void *, ieee: fpvalue_t const &, size: int) -> int

   Convert a floating point number in IDA's internal format to CPU native format. 
           
   :param cpu_fpval_out: output buffer
   :param ieee: floating point number of IDA's internal format
   :param size: size of cpu_fpval in bytes (size of the output buffer)
   :returns: Floating point/IEEE Conversion codes


.. py:class:: dyn_register_info_array(_data: register_info_t, _count: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  register_info_t *


   .. py:attribute:: count
      :type:  size_t


.. py:function:: get_dbg() -> debugger_t *

.. py:function:: dbg_get_registers()

   This function returns the register definition from the currently loaded debugger.
   Basically, it returns an array of structure similar to to idd.hpp / register_info_t

   :returns: None if no debugger is loaded
   :returns: tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
             The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)


.. py:function:: dbg_get_thread_sreg_base(tid, sreg_value)

   Returns the segment register base value

   :param tid: thread id
   :param sreg_value: segment register (selector) value
   :returns: The base as an 'ea', or None on failure


.. py:function:: dbg_read_memory(ea, sz)

   Reads from the debugee's memory at the specified ea

   :param ea: the debuggee's memory address
   :param sz: the amount of data to read
   :returns: The read buffer (as bytes), or None on failure


.. py:function:: dbg_write_memory(ea, buffer)

   Writes a buffer to the debugee's memory

   :param ea: the debuggee's memory address
   :param buf: a bytes object to write
   :returns: Boolean


.. py:function:: dbg_get_name()

   This function returns the current debugger's name.

   :returns: Debugger name or None if no debugger is active


.. py:function:: dbg_get_memory_info()

   This function returns the memory configuration of a debugged process.

   :returns: tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm), or None if no debugger is active


.. py:function:: appcall(func_ea: ida_idaapi.ea_t, tid: thid_t, _type_or_none: bytevec_t const &, _fields: bytevec_t const &, arg_list: PyObject *) -> PyObject *

.. py:function:: get_event_module_name(ev: debug_event_t) -> str

.. py:function:: get_event_module_base(ev: debug_event_t) -> ida_idaapi.ea_t

.. py:function:: get_event_module_size(ev: debug_event_t) -> asize_t

.. py:function:: get_event_exc_info(ev: debug_event_t) -> str

.. py:function:: get_event_info(ev: debug_event_t) -> str

.. py:function:: get_event_bpt_hea(ev: debug_event_t) -> ida_idaapi.ea_t

.. py:function:: get_event_exc_code(ev: debug_event_t) -> uint

.. py:function:: get_event_exc_ea(ev: debug_event_t) -> ida_idaapi.ea_t

.. py:function:: can_exc_continue(ev: debug_event_t) -> bool

.. py:data:: NO_PROCESS
   :value: 4294967295


   No process.


.. py:data:: NO_THREAD
   :value: 0


   No thread. in PROCESS_STARTED this value can be used to specify that the main thread has not been created. It will be initialized later by a THREAD_STARTED event. 
           


.. py:data:: dbg_can_query

.. py:class:: Appcall_array__(tp)

   Bases: :py:obj:`object`


   This class is used with Appcall.array() method


   .. py:method:: pack(L)

      Packs a list or tuple into a byref buffer



   .. py:method:: try_to_convert_to_list(obj)

      Is this object a list? We check for the existance of attribute zero and attribute self.size-1



   .. py:method:: unpack(buf, as_list=True)

      Unpacks an array back into a list or an object



.. py:class:: Appcall_callable__(ea, tinfo_or_typestr=None, fields=None)

   Bases: :py:obj:`object`


   Helper class to issue appcalls using a natural syntax:
     appcall.FunctionNameInTheDatabase(arguments, ....)
   or
     appcall["Function@8"](arguments, ...)
   or
     f8 = appcall["Function@8"]
     f8(arg1, arg2, ...)
   or
     o = appcall.obj()
     i = byref(5)
     appcall.funcname(arg1, i, "hello", o)


   .. py:attribute:: timeout

      An Appcall instance can change its timeout value with this attribute



   .. py:attribute:: options

      Sets the Appcall options locally to this Appcall instance



   .. py:attribute:: ea

      Returns or sets the EA associated with this object



   .. py:attribute:: tif

      Returns the tinfo_t object



   .. py:attribute:: size

      Returns the size of the type



   .. py:attribute:: type

      Returns the typestring



   .. py:attribute:: fields

      Returns the field names



   .. py:method:: retrieve(src=None, flags=0)

      Unpacks a typed object from the database if an ea is given or from a string if a string was passed
      :param src: the address of the object or a string
      :returns: Returns a tuple of boolean and object or error number (Bool, Error | Object).



   .. py:method:: store(obj, dest_ea=None, base_ea=0, flags=0)

      Packs an object into a given ea if provided or into a string if no address was passed.
      :param obj: The object to pack
      :param dest_ea: If packing to idb this will be the store location
      :param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers

      :returns: Tuple(Boolean, packed_string or error code) if packing to a string
      :returns: a return code is returned (0 indicating success) if packing to the database



.. py:class:: Appcall_consts__(default=None)

   Bases: :py:obj:`object`


   Helper class used by Appcall.Consts attribute
   It is used to retrieve constants via attribute access


.. py:class:: Appcall__

   Bases: :py:obj:`object`


   .. py:attribute:: APPCALL_MANUAL
      :value: 1


      Only set up the appcall, do not run. debugger_t::cleanup_appcall will not be generated by ida! 
              



   .. py:attribute:: APPCALL_DEBEV
      :value: 2


      Return debug event information.



   .. py:attribute:: APPCALL_TIMEOUT
      :value: 4


      Appcall with timeout. If timed out, errbuf will contain "timeout". See SET_APPCALL_TIMEOUT and GET_APPCALL_TIMEOUT 
              



   .. py:attribute:: Consts

      Use Appcall.Consts.CONST_NAME to access constants



   .. py:method:: proto(name_or_ea, proto_or_tinfo, flags=None)
      :staticmethod:


      Allows you to instantiate an appcall (callable object) with the desired prototype
      :param name_or_ea: The name of the function (will be resolved with LocByName())
      :param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
      :returns: a callbable Appcall instance with the given prototypes and flags, or
                an exception if the prototype could not be parsed or the address is not resolvable.



   .. py:method:: valueof(name, default=0)
      :staticmethod:


      If the name could not be resolved then the default value will be returned

      :returns: the numeric value of a given name string.



   .. py:method:: int64(v)
      :staticmethod:


      Whenever a 64bit number is needed use this method to construct an object



   .. py:method:: byref(val)
      :staticmethod:


      Method to create references to immutable objects
      Currently we support references to int/strings
      Objects need not be passed by reference (this will be done automatically)



   .. py:method:: buffer(str=None, size=0, fill='\x00')
      :staticmethod:


      Creates a string buffer. The returned value (r) will be a byref object.
      Use r.value to get the contents and r.size to get the buffer's size



   .. py:method:: obj(**kwds)
      :staticmethod:


      Returns an empty object or objects with attributes as passed via its keywords arguments



   .. py:method:: cstr(val)
      :staticmethod:



   .. py:method:: UTF16(s)
      :staticmethod:



   .. py:attribute:: unicode


   .. py:method:: array(type_name)
      :staticmethod:


      Defines an array type. Later you need to pack() / unpack()



   .. py:method:: typedobj(typedecl_or_tinfo, ea=None)
      :staticmethod:


      Returns an appcall object for a type (can be given as tinfo_t object or
      as a string declaration)
      One can then use retrieve() member method
      :param ea: Optional parameter that later can be used to retrieve the type
      :returns: Appcall object or raises ValueError exception



   .. py:method:: set_appcall_options(opt)
      :staticmethod:


      Method to change the Appcall options globally (not per Appcall)



   .. py:method:: get_appcall_options()
      :staticmethod:


      Return the global Appcall options



   .. py:method:: cleanup_appcall(tid=0)
      :staticmethod:


      Cleanup after manual appcall. 
              
      :param tid: thread to use. NO_THREAD means to use the current thread The application state is restored as it was before calling the last appcall(). Nested appcalls are supported.
      :returns: eOk if successful, otherwise an error code



.. py:data:: Appcall


```

`skills/idapython/docs/ida_idp.md`:

```md
# ida_idp

Interface to processor modules - defines target assembler and processor features.

## Key Classes/Functions

### Instruction Analysis
- `is_call_insn(insn)` - is instruction a call?
- `is_ret_insn(insn, flags)` - is instruction a return?
- `is_indirect_jump_insn(insn)` - is instruction an indirect jump?
- `is_basic_block_end(insn, call_stops_block)` - does instruction end a basic block?
- `has_cf_chg(feature, opnum)` - does instruction modify operand?
- `has_cf_use(feature, opnum)` - does instruction use operand value?

### Processor Info
- `get_ph()` - get processor_t structure
- `get_ash()` - get assembler asm_t structure
- `set_processor_type(processor_name, level)` - change processor module
- `get_idp_name()` - get current processor name
- `str2reg(regname)` - convert register name to index
- `get_reg_name(regidx, width)` - get register name

### processor_t
Global processor structure (accessed via `ph`)
- `ph.id` - processor ID (PLFM_386, PLFM_ARM, PLFM_MIPS, etc.)
- `ph.flag` - processor flags (PR_SEGS, PR_USE32, PR_USE64, etc.)
- `ph.cnbits` / `ph.dnbits` - code/data address bits
- `ph_get_instruc()` - get instruction names

### Instruction Features (CF_*)
- CF_STOP - doesn't continue execution
- CF_CALL - call instruction
- CF_CHG1..CF_CHG8 - modifies operand 1-8
- CF_USE1..CF_USE8 - uses operand 1-8
- CF_JUMP - indirect jump/call

## See Also
Full docs: skill/docs/ida_idp.rst

```

`skills/idapython/docs/ida_idp.rst`:

```rst
ida_idp
=======

.. py:module:: ida_idp

.. autoapi-nested-parse::

   Contains definition of the interface to IDP modules.

   The interface consists of two structures:
   * definition of target assembler: ::ash
   * definition of current processor: ::ph


   These structures contain information about target processor and assembler features.
   It also defines two groups of kernel events:
   * processor_t::event_t processor related events
   * idb_event:event_code_t database related events


   The processor related events are used to communicate with the processor module. The database related events are used to inform any interested parties, like plugins or processor modules, about the changes in the database. 
       



Attributes
----------

.. autoapisummary::

   ida_idp.IDP_INTERFACE_VERSION
   ida_idp.CF_STOP
   ida_idp.CF_CALL
   ida_idp.CF_CHG1
   ida_idp.CF_CHG2
   ida_idp.CF_CHG3
   ida_idp.CF_CHG4
   ida_idp.CF_CHG5
   ida_idp.CF_CHG6
   ida_idp.CF_USE1
   ida_idp.CF_USE2
   ida_idp.CF_USE3
   ida_idp.CF_USE4
   ida_idp.CF_USE5
   ida_idp.CF_USE6
   ida_idp.CF_JUMP
   ida_idp.CF_SHFT
   ida_idp.CF_HLL
   ida_idp.CF_CHG7
   ida_idp.CF_CHG8
   ida_idp.CF_USE7
   ida_idp.CF_USE8
   ida_idp.IRI_EXTENDED
   ida_idp.IRI_RET_LITERALLY
   ida_idp.IRI_SKIP_RETTARGET
   ida_idp.IRI_STRICT
   ida_idp.AS_OFFST
   ida_idp.AS_COLON
   ida_idp.AS_UDATA
   ida_idp.AS_2CHRE
   ida_idp.AS_NCHRE
   ida_idp.AS_N2CHR
   ida_idp.AS_1TEXT
   ida_idp.AS_NHIAS
   ida_idp.AS_NCMAS
   ida_idp.AS_HEXFM
   ida_idp.ASH_HEXF0
   ida_idp.ASH_HEXF1
   ida_idp.ASH_HEXF2
   ida_idp.ASH_HEXF3
   ida_idp.ASH_HEXF4
   ida_idp.ASH_HEXF5
   ida_idp.AS_DECFM
   ida_idp.ASD_DECF0
   ida_idp.ASD_DECF1
   ida_idp.ASD_DECF2
   ida_idp.ASD_DECF3
   ida_idp.AS_OCTFM
   ida_idp.ASO_OCTF0
   ida_idp.ASO_OCTF1
   ida_idp.ASO_OCTF2
   ida_idp.ASO_OCTF3
   ida_idp.ASO_OCTF4
   ida_idp.ASO_OCTF5
   ida_idp.ASO_OCTF6
   ida_idp.ASO_OCTF7
   ida_idp.AS_BINFM
   ida_idp.ASB_BINF0
   ida_idp.ASB_BINF1
   ida_idp.ASB_BINF2
   ida_idp.ASB_BINF3
   ida_idp.ASB_BINF4
   ida_idp.ASB_BINF5
   ida_idp.AS_UNEQU
   ida_idp.AS_ONEDUP
   ida_idp.AS_NOXRF
   ida_idp.AS_XTRNTYPE
   ida_idp.AS_RELSUP
   ida_idp.AS_LALIGN
   ida_idp.AS_NOCODECLN
   ida_idp.AS_NOSPACE
   ida_idp.AS_ALIGN2
   ida_idp.AS_ASCIIC
   ida_idp.AS_ASCIIZ
   ida_idp.AS2_BRACE
   ida_idp.AS2_STRINV
   ida_idp.AS2_BYTE1CHAR
   ida_idp.AS2_IDEALDSCR
   ida_idp.AS2_TERSESTR
   ida_idp.AS2_COLONSUF
   ida_idp.AS2_YWORD
   ida_idp.AS2_ZWORD
   ida_idp.HKCB_GLOBAL
   ida_idp.PLFM_386
   ida_idp.PLFM_Z80
   ida_idp.PLFM_I860
   ida_idp.PLFM_8051
   ida_idp.PLFM_TMS
   ida_idp.PLFM_6502
   ida_idp.PLFM_PDP
   ida_idp.PLFM_68K
   ida_idp.PLFM_JAVA
   ida_idp.PLFM_6800
   ida_idp.PLFM_ST7
   ida_idp.PLFM_MC6812
   ida_idp.PLFM_MIPS
   ida_idp.PLFM_ARM
   ida_idp.PLFM_TMSC6
   ida_idp.PLFM_PPC
   ida_idp.PLFM_80196
   ida_idp.PLFM_Z8
   ida_idp.PLFM_SH
   ida_idp.PLFM_NET
   ida_idp.PLFM_AVR
   ida_idp.PLFM_H8
   ida_idp.PLFM_PIC
   ida_idp.PLFM_SPARC
   ida_idp.PLFM_ALPHA
   ida_idp.PLFM_HPPA
   ida_idp.PLFM_H8500
   ida_idp.PLFM_TRICORE
   ida_idp.PLFM_DSP56K
   ida_idp.PLFM_C166
   ida_idp.PLFM_ST20
   ida_idp.PLFM_IA64
   ida_idp.PLFM_I960
   ida_idp.PLFM_F2MC
   ida_idp.PLFM_TMS320C54
   ida_idp.PLFM_TMS320C55
   ida_idp.PLFM_TRIMEDIA
   ida_idp.PLFM_M32R
   ida_idp.PLFM_NEC_78K0
   ida_idp.PLFM_NEC_78K0S
   ida_idp.PLFM_M740
   ida_idp.PLFM_M7700
   ida_idp.PLFM_ST9
   ida_idp.PLFM_FR
   ida_idp.PLFM_MC6816
   ida_idp.PLFM_M7900
   ida_idp.PLFM_TMS320C3
   ida_idp.PLFM_KR1878
   ida_idp.PLFM_AD218X
   ida_idp.PLFM_OAKDSP
   ida_idp.PLFM_TLCS900
   ida_idp.PLFM_C39
   ida_idp.PLFM_CR16
   ida_idp.PLFM_MN102L00
   ida_idp.PLFM_TMS320C1X
   ida_idp.PLFM_NEC_V850X
   ida_idp.PLFM_SCR_ADPT
   ida_idp.PLFM_EBC
   ida_idp.PLFM_MSP430
   ida_idp.PLFM_SPU
   ida_idp.PLFM_DALVIK
   ida_idp.PLFM_65C816
   ida_idp.PLFM_M16C
   ida_idp.PLFM_ARC
   ida_idp.PLFM_UNSP
   ida_idp.PLFM_TMS320C28
   ida_idp.PLFM_DSP96K
   ida_idp.PLFM_SPC700
   ida_idp.PLFM_AD2106X
   ida_idp.PLFM_PIC16
   ida_idp.PLFM_S390
   ida_idp.PLFM_XTENSA
   ida_idp.PLFM_RISCV
   ida_idp.PLFM_RL78
   ida_idp.PLFM_RX
   ida_idp.PLFM_WASM
   ida_idp.PR_SEGS
   ida_idp.PR_USE32
   ida_idp.PR_DEFSEG32
   ida_idp.PR_RNAMESOK
   ida_idp.PR_ADJSEGS
   ida_idp.PR_DEFNUM
   ida_idp.PRN_HEX
   ida_idp.PRN_OCT
   ida_idp.PRN_DEC
   ida_idp.PRN_BIN
   ida_idp.PR_WORD_INS
   ida_idp.PR_NOCHANGE
   ida_idp.PR_ASSEMBLE
   ida_idp.PR_ALIGN
   ida_idp.PR_TYPEINFO
   ida_idp.PR_USE64
   ida_idp.PR_SGROTHER
   ida_idp.PR_STACK_UP
   ida_idp.PR_BINMEM
   ida_idp.PR_SEGTRANS
   ida_idp.PR_CHK_XREF
   ida_idp.PR_NO_SEGMOVE
   ida_idp.PR_USE_ARG_TYPES
   ida_idp.PR_SCALE_STKVARS
   ida_idp.PR_DELAYED
   ida_idp.PR_ALIGN_INSN
   ida_idp.PR_PURGING
   ida_idp.PR_CNDINSNS
   ida_idp.PR_USE_TBYTE
   ida_idp.PR_DEFSEG64
   ida_idp.PR_OUTER
   ida_idp.PR2_MAPPINGS
   ida_idp.PR2_IDP_OPTS
   ida_idp.PR2_CODE16_BIT
   ida_idp.PR2_MACRO
   ida_idp.PR2_USE_CALCREL
   ida_idp.PR2_REL_BITS
   ida_idp.PR2_FORCE_16BIT
   ida_idp.OP_FP_BASED
   ida_idp.OP_SP_BASED
   ida_idp.OP_SP_ADD
   ida_idp.OP_SP_SUB
   ida_idp.CUSTOM_INSN_ITYPE
   ida_idp.REG_SPOIL
   ida_idp.NO_ACCESS
   ida_idp.WRITE_ACCESS
   ida_idp.READ_ACCESS
   ida_idp.RW_ACCESS
   ida_idp.SETPROC_IDB
   ida_idp.SETPROC_LOADER
   ida_idp.SETPROC_LOADER_NON_FATAL
   ida_idp.SETPROC_USER
   ida_idp.LTC_NONE
   ida_idp.LTC_ADDED
   ida_idp.LTC_DELETED
   ida_idp.LTC_EDITED
   ida_idp.LTC_ALIASED
   ida_idp.LTC_COMPILER
   ida_idp.LTC_TIL_LOADED
   ida_idp.LTC_TIL_UNLOADED
   ida_idp.LTC_TIL_COMPACTED
   ida_idp.closebase
   ida_idp.savebase
   ida_idp.upgraded
   ida_idp.auto_empty
   ida_idp.auto_empty_finally
   ida_idp.determined_main
   ida_idp.extlang_changed
   ida_idp.idasgn_loaded
   ida_idp.kernel_config_loaded
   ida_idp.loader_finished
   ida_idp.flow_chart_created
   ida_idp.compiler_changed
   ida_idp.changing_ti
   ida_idp.ti_changed
   ida_idp.changing_op_ti
   ida_idp.op_ti_changed
   ida_idp.changing_op_type
   ida_idp.op_type_changed
   ida_idp.segm_added
   ida_idp.deleting_segm
   ida_idp.segm_deleted
   ida_idp.changing_segm_start
   ida_idp.segm_start_changed
   ida_idp.changing_segm_end
   ida_idp.segm_end_changed
   ida_idp.changing_segm_name
   ida_idp.segm_name_changed
   ida_idp.changing_segm_class
   ida_idp.segm_class_changed
   ida_idp.segm_attrs_updated
   ida_idp.segm_moved
   ida_idp.allsegs_moved
   ida_idp.func_added
   ida_idp.func_updated
   ida_idp.set_func_start
   ida_idp.set_func_end
   ida_idp.deleting_func
   ida_idp.frame_deleted
   ida_idp.thunk_func_created
   ida_idp.func_tail_appended
   ida_idp.deleting_func_tail
   ida_idp.func_tail_deleted
   ida_idp.tail_owner_changed
   ida_idp.func_noret_changed
   ida_idp.stkpnts_changed
   ida_idp.updating_tryblks
   ida_idp.tryblks_updated
   ida_idp.deleting_tryblks
   ida_idp.sgr_changed
   ida_idp.make_code
   ida_idp.make_data
   ida_idp.destroyed_items
   ida_idp.renamed
   ida_idp.byte_patched
   ida_idp.changing_cmt
   ida_idp.cmt_changed
   ida_idp.changing_range_cmt
   ida_idp.range_cmt_changed
   ida_idp.extra_cmt_changed
   ida_idp.item_color_changed
   ida_idp.callee_addr_changed
   ida_idp.bookmark_changed
   ida_idp.sgr_deleted
   ida_idp.adding_segm
   ida_idp.func_deleted
   ida_idp.dirtree_mkdir
   ida_idp.dirtree_rmdir
   ida_idp.dirtree_link
   ida_idp.dirtree_move
   ida_idp.dirtree_rank
   ida_idp.dirtree_rminode
   ida_idp.dirtree_segm_moved
   ida_idp.local_types_changed
   ida_idp.lt_udm_created
   ida_idp.lt_udm_deleted
   ida_idp.lt_udm_renamed
   ida_idp.lt_udm_changed
   ida_idp.lt_udt_expanded
   ida_idp.frame_created
   ida_idp.frame_udm_created
   ida_idp.frame_udm_deleted
   ida_idp.frame_udm_renamed
   ida_idp.frame_udm_changed
   ida_idp.frame_expanded
   ida_idp.idasgn_matched_ea
   ida_idp.lt_edm_created
   ida_idp.lt_edm_deleted
   ida_idp.lt_edm_renamed
   ida_idp.lt_edm_changed
   ida_idp.local_type_renamed
   ida_idp.IDPOPT_CST
   ida_idp.IDPOPT_JVL
   ida_idp.IDPOPT_PRI_DEFAULT
   ida_idp.IDPOPT_PRI_HIGH
   ida_idp.IDPOPT_NUM_INT
   ida_idp.IDPOPT_NUM_CHAR
   ida_idp.IDPOPT_NUM_SHORT
   ida_idp.IDPOPT_NUM_RANGE
   ida_idp.IDPOPT_NUM_UNS
   ida_idp.IDPOPT_BIT_UINT
   ida_idp.IDPOPT_BIT_UCHAR
   ida_idp.IDPOPT_BIT_USHORT
   ida_idp.IDPOPT_BIT_BOOL
   ida_idp.IDPOPT_STR_QSTRING
   ida_idp.IDPOPT_STR_LONG
   ida_idp.IDPOPT_I64_RANGE
   ida_idp.IDPOPT_I64_UNS
   ida_idp.IDPOPT_CST_PARAMS
   ida_idp.IDPOPT_MBROFF
   ida_idp.cik_string
   ida_idp.cik_filename
   ida_idp.cik_path
   ida_idp.REAL_ERROR_FORMAT
   ida_idp.REAL_ERROR_RANGE
   ida_idp.REAL_ERROR_BADDATA
   ida_idp.IDPOPT_STR
   ida_idp.IDPOPT_NUM
   ida_idp.IDPOPT_BIT
   ida_idp.IDPOPT_FLT
   ida_idp.IDPOPT_I64
   ida_idp.IDPOPT_OK
   ida_idp.IDPOPT_BADKEY
   ida_idp.IDPOPT_BADTYPE
   ida_idp.IDPOPT_BADVALUE
   ida_idp.ph


Classes
-------

.. autoapisummary::

   ida_idp.reg_access_vec_t
   ida_idp.asm_t
   ida_idp.reg_info_t
   ida_idp.reg_access_t
   ida_idp.reg_accesses_t
   ida_idp.num_range_t
   ida_idp.params_t
   ida_idp.IDP_Hooks
   ida_idp.processor_t
   ida_idp.IDB_Hooks


Functions
---------

.. autoapisummary::

   ida_idp.has_cf_chg
   ida_idp.has_cf_use
   ida_idp.has_insn_feature
   ida_idp.is_call_insn
   ida_idp.is_ret_insn
   ida_idp.is_indirect_jump_insn
   ida_idp.is_basic_block_end
   ida_idp.get_ph
   ida_idp.get_ash
   ida_idp.str2reg
   ida_idp.is_align_insn
   ida_idp.get_reg_name
   ida_idp.parse_reg_name
   ida_idp.set_processor_type
   ida_idp.get_idp_name
   ida_idp.set_target_assembler
   ida_idp.gen_idb_event
   ida_idp.register_cfgopts
   ida_idp.get_config_value
   ida_idp.cfg_get_cc_parm
   ida_idp.cfg_get_cc_header_path
   ida_idp.cfg_get_cc_predefined_macros
   ida_idp.process_config_directive
   ida_idp.AssembleLine
   ida_idp.assemble
   ida_idp.ph_get_id
   ida_idp.ph_get_version
   ida_idp.ph_get_flag
   ida_idp.ph_get_cnbits
   ida_idp.ph_get_dnbits
   ida_idp.ph_get_reg_first_sreg
   ida_idp.ph_get_reg_last_sreg
   ida_idp.ph_get_segreg_size
   ida_idp.ph_get_reg_code_sreg
   ida_idp.ph_get_reg_data_sreg
   ida_idp.ph_get_icode_return
   ida_idp.ph_get_instruc_start
   ida_idp.ph_get_instruc_end
   ida_idp.ph_get_tbyte_size
   ida_idp.ph_get_instruc
   ida_idp.ph_get_regnames
   ida_idp.ph_get_operand_info
   ida_idp.ph_calcrel
   ida_idp.ph_find_reg_value
   ida_idp.ph_find_op_value
   ida_idp.ph_get_reg_accesses
   ida_idp.ph_get_abi_info
   ida_idp.get_idp_notifier_addr
   ida_idp.get_idp_notifier_ud_addr
   ida_idp.delay_slot_insn
   ida_idp.get_reg_info
   ida_idp.sizeof_ldbl
   ida_idp.str2sreg
   ida_idp.get_idb_notifier_addr
   ida_idp.get_idb_notifier_ud_addr


Module Contents
---------------

.. py:class:: reg_access_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> reg_access_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> reg_access_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: reg_access_vec_t) -> None


   .. py:method:: extract() -> reg_access_t *


   .. py:method:: inject(s: reg_access_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< reg_access_t >::const_iterator


   .. py:method:: end(*args) -> qvector< reg_access_t >::const_iterator


   .. py:method:: insert(it: reg_access_t, x: reg_access_t) -> qvector< reg_access_t >::iterator


   .. py:method:: erase(*args) -> qvector< reg_access_t >::iterator


   .. py:method:: find(*args) -> qvector< reg_access_t >::const_iterator


   .. py:method:: has(x: reg_access_t) -> bool


   .. py:method:: add_unique(x: reg_access_t) -> bool


   .. py:method:: append(x: reg_access_t) -> None


   .. py:method:: extend(x: reg_access_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: IDP_INTERFACE_VERSION

   The interface version number. 
           


.. py:data:: CF_STOP

   Instruction doesn't pass execution to the next instruction 
           


.. py:data:: CF_CALL

   CALL instruction (should make a procedure here)


.. py:data:: CF_CHG1

   The instruction modifies the first operand.


.. py:data:: CF_CHG2

   The instruction modifies the second operand.


.. py:data:: CF_CHG3

   The instruction modifies the third operand.


.. py:data:: CF_CHG4

   The instruction modifies the fourth operand.


.. py:data:: CF_CHG5

   The instruction modifies the fifth operand.


.. py:data:: CF_CHG6

   The instruction modifies the sixth operand.


.. py:data:: CF_USE1

   The instruction uses value of the first operand.


.. py:data:: CF_USE2

   The instruction uses value of the second operand.


.. py:data:: CF_USE3

   The instruction uses value of the third operand.


.. py:data:: CF_USE4

   The instruction uses value of the fourth operand.


.. py:data:: CF_USE5

   The instruction uses value of the fifth operand.


.. py:data:: CF_USE6

   The instruction uses value of the sixth operand.


.. py:data:: CF_JUMP

   The instruction passes execution using indirect jump or call (thus needs additional analysis) 
           


.. py:data:: CF_SHFT

   Bit-shift instruction (shl,shr...)


.. py:data:: CF_HLL

   Instruction may be present in a high level language function 
           


.. py:data:: CF_CHG7

   The instruction modifies the seventh operand.


.. py:data:: CF_CHG8

   The instruction modifies the eighth operand.


.. py:data:: CF_USE7

   The instruction uses value of the seventh operand.


.. py:data:: CF_USE8

   The instruction uses value of the eighth operand.


.. py:function:: has_cf_chg(feature: int, opnum: uint) -> bool

   Does an instruction with the specified feature modify the i-th operand?


.. py:function:: has_cf_use(feature: int, opnum: uint) -> bool

   Does an instruction with the specified feature use a value of the i-th operand?


.. py:function:: has_insn_feature(icode: uint16, bit: int) -> bool

   Does the specified instruction have the specified feature?


.. py:function:: is_call_insn(insn: insn_t const &) -> bool

   Is the instruction a "call"?


.. py:data:: IRI_EXTENDED

   Is the instruction a "return"?

   include instructions like "leave" that begin the function epilog 
           


.. py:data:: IRI_RET_LITERALLY

   report only 'ret' instructions


.. py:data:: IRI_SKIP_RETTARGET

   exclude 'ret' instructions that have special targets (see set_ret_target in PC) 
           


.. py:data:: IRI_STRICT

.. py:function:: is_ret_insn(*args) -> bool

.. py:function:: is_indirect_jump_insn(insn: insn_t const &) -> bool

   Is the instruction an indirect jump?


.. py:function:: is_basic_block_end(insn: insn_t const &, call_insn_stops_block: bool) -> bool

   Is the instruction the end of a basic block?


.. py:class:: asm_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flag
      :type:  int

      Assembler feature bits 
              



   .. py:attribute:: uflag
      :type:  uint16

      user defined flags (local only for IDP) you may define and use your own bits 
              



   .. py:attribute:: name
      :type:  str

      Assembler name (displayed in menus)



   .. py:attribute:: help
      :type:  help_t

      Help screen number, 0 - no help.



   .. py:attribute:: header
      :type:  char const *const *

      array of automatically generated header lines they appear at the start of disassembled text 
              



   .. py:attribute:: origin
      :type:  str

      org directive



   .. py:attribute:: end
      :type:  str

      end directive



   .. py:attribute:: cmnt
      :type:  str

      comment string (see also cmnt2)



   .. py:attribute:: ascsep
      :type:  char

      string literal delimiter



   .. py:attribute:: accsep
      :type:  char

      char constant delimiter



   .. py:attribute:: esccodes
      :type:  str

      special chars that cannot appear as is in string and char literals 
              



   .. py:attribute:: a_ascii
      :type:  str

      string literal directive



   .. py:attribute:: a_byte
      :type:  str

      byte directive



   .. py:attribute:: a_word
      :type:  str

      word directive



   .. py:attribute:: a_dword
      :type:  str

      nullptr if not allowed



   .. py:attribute:: a_qword
      :type:  str

      nullptr if not allowed



   .. py:attribute:: a_oword
      :type:  str

      nullptr if not allowed



   .. py:attribute:: a_float
      :type:  str

      float; 4bytes; nullptr if not allowed



   .. py:attribute:: a_double
      :type:  str

      double; 8bytes; nullptr if not allowed



   .. py:attribute:: a_tbyte
      :type:  str

      long double; nullptr if not allowed



   .. py:attribute:: a_packreal
      :type:  str

      packed decimal real nullptr if not allowed



   .. py:attribute:: a_dups
      :type:  str

      array keyword. the following sequences may appear:
      * #h header
      * #d size
      * #v value
      * #s(b,w,l,q,f,d,o) size specifiers for byte,word, dword,qword, float,double,oword 


              



   .. py:attribute:: a_bss
      :type:  str

      uninitialized data directive should include 's' for the size of data 
              



   .. py:attribute:: a_equ
      :type:  str

      'equ' Used if AS_UNEQU is set



   .. py:attribute:: a_seg
      :type:  str

      'seg ' prefix (example: push seg seg001)



   .. py:attribute:: a_curip
      :type:  str

      current IP (instruction pointer) symbol in assembler



   .. py:attribute:: a_public
      :type:  str

      "public" name keyword. nullptr-use default, ""-do not generate



   .. py:attribute:: a_weak
      :type:  str

      "weak" name keyword. nullptr-use default, ""-do not generate



   .. py:attribute:: a_extrn
      :type:  str

      "extern" name keyword



   .. py:attribute:: a_comdef
      :type:  str

      "comm" (communal variable)



   .. py:attribute:: a_align
      :type:  str

      "align" keyword



   .. py:attribute:: lbrace
      :type:  char

      left brace used in complex expressions



   .. py:attribute:: rbrace
      :type:  char

      right brace used in complex expressions



   .. py:attribute:: a_mod
      :type:  str

      % mod assembler time operation



   .. py:attribute:: a_band
      :type:  str

      & bit and assembler time operation



   .. py:attribute:: a_bor
      :type:  str

      | bit or assembler time operation



   .. py:attribute:: a_xor
      :type:  str

      ^ bit xor assembler time operation



   .. py:attribute:: a_bnot
      :type:  str

      ~ bit not assembler time operation



   .. py:attribute:: a_shl
      :type:  str

      << shift left assembler time operation



   .. py:attribute:: a_shr
      :type:  str

      >> shift right assembler time operation



   .. py:attribute:: a_sizeof_fmt
      :type:  str

      size of type (format string)



   .. py:attribute:: flag2
      :type:  int

      Secondary assembler feature bits 
              



   .. py:attribute:: cmnt2
      :type:  str

      comment close string (usually nullptr) this is used to denote a string which closes comments, for example, if the comments are represented with (* ... *) then cmnt = "(*" and cmnt2 = "*)" 
              



   .. py:attribute:: low8
      :type:  str

      low8 operation, should contain s for the operand



   .. py:attribute:: high8
      :type:  str

      high8



   .. py:attribute:: low16
      :type:  str

      low16



   .. py:attribute:: high16
      :type:  str

      high16



   .. py:attribute:: a_include_fmt
      :type:  str

      the include directive (format string)



   .. py:attribute:: a_vstruc_fmt
      :type:  str

      if a named item is a structure and displayed in the verbose (multiline) form then display the name as printf(a_strucname_fmt, typename) (for asms with type checking, e.g. tasm ideal) 
              



   .. py:attribute:: a_rva
      :type:  str

      'rva' keyword for image based offsets (see REFINFO_RVAOFF) 
              



   .. py:attribute:: a_yword
      :type:  str

      32-byte (256-bit) data; nullptr if not allowed requires AS2_YWORD 
              



   .. py:attribute:: a_zword
      :type:  str

      64-byte (512-bit) data; nullptr if not allowed requires AS2_ZWORD 
              



.. py:data:: AS_OFFST

   offsets are 'offset xxx' ?


.. py:data:: AS_COLON

   create colons after data names ?


.. py:data:: AS_UDATA

   can use '?' in data directives


.. py:data:: AS_2CHRE

   double char constants are: "xy


.. py:data:: AS_NCHRE

   char constants are: 'x


.. py:data:: AS_N2CHR

   can't have 2 byte char consts


.. py:data:: AS_1TEXT

   1 text per line, no bytes


.. py:data:: AS_NHIAS

   no characters with high bit


.. py:data:: AS_NCMAS

   no commas in ascii directives


.. py:data:: AS_HEXFM

   mask - hex number format


.. py:data:: ASH_HEXF0

   34h


.. py:data:: ASH_HEXF1

   h'34


.. py:data:: ASH_HEXF2

   34


.. py:data:: ASH_HEXF3

   0x34


.. py:data:: ASH_HEXF4

   $34


.. py:data:: ASH_HEXF5

   <^R > (radix)


.. py:data:: AS_DECFM

   mask - decimal number format


.. py:data:: ASD_DECF0

   34


.. py:data:: ASD_DECF1

   #34


.. py:data:: ASD_DECF2

   34.


.. py:data:: ASD_DECF3

   .34


.. py:data:: AS_OCTFM

   mask - octal number format


.. py:data:: ASO_OCTF0

   123o


.. py:data:: ASO_OCTF1

   0123


.. py:data:: ASO_OCTF2

   123


.. py:data:: ASO_OCTF3

   @123


.. py:data:: ASO_OCTF4

   o'123


.. py:data:: ASO_OCTF5

   123q


.. py:data:: ASO_OCTF6

   ~123


.. py:data:: ASO_OCTF7

   q'123


.. py:data:: AS_BINFM

   mask - binary number format


.. py:data:: ASB_BINF0

   010101b


.. py:data:: ASB_BINF1

   ^B010101


.. py:data:: ASB_BINF2

   %010101


.. py:data:: ASB_BINF3

   0b1010101


.. py:data:: ASB_BINF4

   b'1010101


.. py:data:: ASB_BINF5

   b'1010101'


.. py:data:: AS_UNEQU

   replace undefined data items with EQU (for ANTA's A80)


.. py:data:: AS_ONEDUP

   One array definition per line.


.. py:data:: AS_NOXRF

   Disable xrefs during the output file generation.


.. py:data:: AS_XTRNTYPE

   Assembler understands type of extern symbols as ":type" suffix.


.. py:data:: AS_RELSUP

   Checkarg: 'and','or','xor' operations with addresses are possible.


.. py:data:: AS_LALIGN

   Labels at "align" keyword are supported.


.. py:data:: AS_NOCODECLN

   don't create colons after code names


.. py:data:: AS_NOSPACE

   No spaces in expressions.


.. py:data:: AS_ALIGN2

   .align directive expects an exponent rather than a power of 2 (.align 5 means to align at 32byte boundary) 
           


.. py:data:: AS_ASCIIC

   ascii directive accepts C-like escape sequences (\n,\x01 and similar) 
           


.. py:data:: AS_ASCIIZ

   ascii directive inserts implicit zero byte at the end


.. py:data:: AS2_BRACE

   Use braces for all expressions.


.. py:data:: AS2_STRINV

   Invert meaning of idainfo::wide_high_byte_first for text strings (for processors with bytes bigger than 8 bits) 
           


.. py:data:: AS2_BYTE1CHAR

   One symbol per processor byte. Meaningful only for wide byte processors 
           


.. py:data:: AS2_IDEALDSCR

   Description of struc/union is in the 'reverse' form (keyword before name), the same as in borland tasm ideal 
           


.. py:data:: AS2_TERSESTR

   'terse' structure initialization form; NAME<fld,fld,...> is supported 
           


.. py:data:: AS2_COLONSUF

   addresses may have ":xx" suffix; this suffix must be ignored when extracting the address under the cursor 
           


.. py:data:: AS2_YWORD

   a_yword field is present and valid


.. py:data:: AS2_ZWORD

   a_zword field is present and valid


.. py:data:: HKCB_GLOBAL

   is global event listener? if true, the listener will survive database closing and opening. it will stay in the memory until explicitly unhooked. otherwise the kernel will delete it as soon as the owner is unloaded. should be used only with PLUGIN_FIX plugins. 
           


.. py:data:: PLFM_386

   Intel 80x86.


.. py:data:: PLFM_Z80

   8085, Z80


.. py:data:: PLFM_I860

   Intel 860.


.. py:data:: PLFM_8051

   8051


.. py:data:: PLFM_TMS

   Texas Instruments TMS320C5x.


.. py:data:: PLFM_6502

   6502


.. py:data:: PLFM_PDP

   PDP11.


.. py:data:: PLFM_68K

   Motorola 680x0.


.. py:data:: PLFM_JAVA

   Java.


.. py:data:: PLFM_6800

   Motorola 68xx.


.. py:data:: PLFM_ST7

   SGS-Thomson ST7.


.. py:data:: PLFM_MC6812

   Motorola 68HC12.


.. py:data:: PLFM_MIPS

   MIPS.


.. py:data:: PLFM_ARM

   Advanced RISC Machines.


.. py:data:: PLFM_TMSC6

   Texas Instruments TMS320C6x.


.. py:data:: PLFM_PPC

   PowerPC.


.. py:data:: PLFM_80196

   Intel 80196.


.. py:data:: PLFM_Z8

   Z8.


.. py:data:: PLFM_SH

   Renesas (formerly Hitachi) SuperH.


.. py:data:: PLFM_NET

   Microsoft Visual Studio.Net.


.. py:data:: PLFM_AVR

   Atmel 8-bit RISC processor(s)


.. py:data:: PLFM_H8

   Hitachi H8/300, H8/2000.


.. py:data:: PLFM_PIC

   Microchip's PIC.


.. py:data:: PLFM_SPARC

   SPARC.


.. py:data:: PLFM_ALPHA

   DEC Alpha.


.. py:data:: PLFM_HPPA

   Hewlett-Packard PA-RISC.


.. py:data:: PLFM_H8500

   Hitachi H8/500.


.. py:data:: PLFM_TRICORE

   Tasking Tricore.


.. py:data:: PLFM_DSP56K

   Motorola DSP5600x.


.. py:data:: PLFM_C166

   Siemens C166 family.


.. py:data:: PLFM_ST20

   SGS-Thomson ST20.


.. py:data:: PLFM_IA64

   Intel Itanium IA64.


.. py:data:: PLFM_I960

   Intel 960.


.. py:data:: PLFM_F2MC

   Fujistu F2MC-16.


.. py:data:: PLFM_TMS320C54

   Texas Instruments TMS320C54xx.


.. py:data:: PLFM_TMS320C55

   Texas Instruments TMS320C55xx.


.. py:data:: PLFM_TRIMEDIA

   Trimedia.


.. py:data:: PLFM_M32R

   Mitsubishi 32bit RISC.


.. py:data:: PLFM_NEC_78K0

   NEC 78K0.


.. py:data:: PLFM_NEC_78K0S

   NEC 78K0S.


.. py:data:: PLFM_M740

   Mitsubishi 8bit.


.. py:data:: PLFM_M7700

   Mitsubishi 16bit.


.. py:data:: PLFM_ST9

   ST9+.


.. py:data:: PLFM_FR

   Fujitsu FR Family.


.. py:data:: PLFM_MC6816

   Motorola 68HC16.


.. py:data:: PLFM_M7900

   Mitsubishi 7900.


.. py:data:: PLFM_TMS320C3

   Texas Instruments TMS320C3.


.. py:data:: PLFM_KR1878

   Angstrem KR1878.


.. py:data:: PLFM_AD218X

   Analog Devices ADSP 218X.


.. py:data:: PLFM_OAKDSP

   Atmel OAK DSP.


.. py:data:: PLFM_TLCS900

   Toshiba TLCS-900.


.. py:data:: PLFM_C39

   Rockwell C39.


.. py:data:: PLFM_CR16

   NSC CR16.


.. py:data:: PLFM_MN102L00

   Panasonic MN10200.


.. py:data:: PLFM_TMS320C1X

   Texas Instruments TMS320C1x.


.. py:data:: PLFM_NEC_V850X

   NEC V850 and V850ES/E1/E2.


.. py:data:: PLFM_SCR_ADPT

   Processor module adapter for processor modules written in scripting languages.


.. py:data:: PLFM_EBC

   EFI Bytecode.


.. py:data:: PLFM_MSP430

   Texas Instruments MSP430.


.. py:data:: PLFM_SPU

   Cell Broadband Engine Synergistic Processor Unit.


.. py:data:: PLFM_DALVIK

   Android Dalvik Virtual Machine.


.. py:data:: PLFM_65C816

   65802/65816


.. py:data:: PLFM_M16C

   Renesas M16C.


.. py:data:: PLFM_ARC

   Argonaut RISC Core.


.. py:data:: PLFM_UNSP

   SunPlus unSP.


.. py:data:: PLFM_TMS320C28

   Texas Instruments TMS320C28x.


.. py:data:: PLFM_DSP96K

   Motorola DSP96000.


.. py:data:: PLFM_SPC700

   Sony SPC700.


.. py:data:: PLFM_AD2106X

   Analog Devices ADSP 2106X.


.. py:data:: PLFM_PIC16

   Microchip's 16-bit PIC.


.. py:data:: PLFM_S390

   IBM's S390.


.. py:data:: PLFM_XTENSA

   Tensilica Xtensa.


.. py:data:: PLFM_RISCV

   RISC-V.


.. py:data:: PLFM_RL78

   Renesas RL78.


.. py:data:: PLFM_RX

   Renesas RX.


.. py:data:: PLFM_WASM

   WASM.


.. py:data:: PR_SEGS

   has segment registers?


.. py:data:: PR_USE32

   supports 32-bit addressing?


.. py:data:: PR_DEFSEG32

   segments are 32-bit by default


.. py:data:: PR_RNAMESOK

   allow user register names for location names


.. py:data:: PR_ADJSEGS

   IDA may adjust segments' starting/ending addresses.


.. py:data:: PR_DEFNUM

   mask - default number representation


.. py:data:: PRN_HEX

   hex


.. py:data:: PRN_OCT

   octal


.. py:data:: PRN_DEC

   decimal


.. py:data:: PRN_BIN

   binary


.. py:data:: PR_WORD_INS

   instruction codes are grouped 2bytes in binary line prefix


.. py:data:: PR_NOCHANGE

   The user can't change segments and code/data attributes (display only) 
           


.. py:data:: PR_ASSEMBLE

   Module has a built-in assembler and will react to ev_assemble.


.. py:data:: PR_ALIGN

   All data items should be aligned properly.


.. py:data:: PR_TYPEINFO

   the processor module fully supports type information callbacks; without full support, function argument locations and other things will probably be wrong. 
           


.. py:data:: PR_USE64

   supports 64-bit addressing?


.. py:data:: PR_SGROTHER

   the segment registers don't contain the segment selectors.


.. py:data:: PR_STACK_UP

   the stack grows up


.. py:data:: PR_BINMEM

   the processor module provides correct segmentation for binary files (i.e. it creates additional segments). The kernel will not ask the user to specify the RAM/ROM sizes 
           


.. py:data:: PR_SEGTRANS

   the processor module supports the segment translation feature (meaning it calculates the code addresses using the map_code_ea() function) 
           


.. py:data:: PR_CHK_XREF

   don't allow near xrefs between segments with different bases


.. py:data:: PR_NO_SEGMOVE

   the processor module doesn't support move_segm() (i.e. the user can't move segments) 
           


.. py:data:: PR_USE_ARG_TYPES

   use processor_t::use_arg_types callback


.. py:data:: PR_SCALE_STKVARS

   use processor_t::get_stkvar_scale callback


.. py:data:: PR_DELAYED

   has delayed jumps and calls. If this flag is set, processor_t::is_basic_block_end, processor_t::delay_slot_insn should be implemented 
           


.. py:data:: PR_ALIGN_INSN

   allow ida to create alignment instructions arbitrarily. Since these instructions might lead to other wrong instructions and spoil the listing, IDA does not create them by default anymore 
           


.. py:data:: PR_PURGING

   there are calling conventions which may purge bytes from the stack


.. py:data:: PR_CNDINSNS

   has conditional instructions


.. py:data:: PR_USE_TBYTE

   BTMT_SPECFLT means _TBYTE type


.. py:data:: PR_DEFSEG64

   segments are 64-bit by default


.. py:data:: PR_OUTER

   has outer operands (currently only mc68k)


.. py:data:: PR2_MAPPINGS

   the processor module uses memory mapping


.. py:data:: PR2_IDP_OPTS

   the module has processor-specific configuration options


.. py:data:: PR2_CODE16_BIT

   low bit of code addresses has special meaning e.g. ARM Thumb, MIPS16 
           


.. py:data:: PR2_MACRO

   processor supports macro instructions


.. py:data:: PR2_USE_CALCREL

   (Lumina) the module supports calcrel info


.. py:data:: PR2_REL_BITS

   (Lumina) calcrel info has bits granularity, not bytes - construction flag only


.. py:data:: PR2_FORCE_16BIT

   use 16-bit basic types despite of 32-bit segments (used by c166)


.. py:data:: OP_FP_BASED

   operand is FP based


.. py:data:: OP_SP_BASED

   operand is SP based


.. py:data:: OP_SP_ADD

   operand value is added to the pointer


.. py:data:: OP_SP_SUB

   operand value is subtracted from the pointer


.. py:data:: CUSTOM_INSN_ITYPE

   Custom instruction codes defined by processor extension plugins must be greater than or equal to this 
           


.. py:data:: REG_SPOIL

   processor_t::use_regarg_type uses this bit in the return value to indicate that the register value has been spoiled 
           


.. py:function:: get_ph() -> processor_t *

.. py:function:: get_ash() -> asm_t *

.. py:function:: str2reg(p: str) -> int

   Get any register number (-1 on error)


.. py:function:: is_align_insn(ea: ida_idaapi.ea_t) -> int

   If the instruction at 'ea' looks like an alignment instruction, return its length in bytes. Otherwise return 0. 
           


.. py:function:: get_reg_name(reg: int, width: size_t, reghi: int = -1) -> str

   Get text representation of a register. For most processors this function will just return processor_t::reg_names[reg]. If the processor module has implemented processor_t::get_reg_name, it will be used instead 
           
   :param reg: internal register number as defined in the processor module
   :param width: register width in bytes
   :param reghi: if specified, then this function will return the register pair
   :returns: length of register name in bytes or -1 if failure


.. py:class:: reg_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: reg
      :type:  int

      register number



   .. py:attribute:: size
      :type:  int

      register size



   .. py:method:: compare(r: reg_info_t) -> int


.. py:function:: parse_reg_name(ri: reg_info_t, regname: str) -> bool

   Get register info by name. 
           
   :param ri: result
   :param regname: name of register
   :returns: success


.. py:data:: NO_ACCESS

.. py:data:: WRITE_ACCESS

.. py:data:: READ_ACCESS

.. py:data:: RW_ACCESS

.. py:class:: reg_access_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: regnum
      :type:  int

      register number (only entire registers)



   .. py:attribute:: range
      :type:  bitrange_t

      bitrange inside the register



   .. py:attribute:: access_type
      :type:  access_type_t


   .. py:attribute:: opnum
      :type:  uchar

      operand number



   .. py:method:: have_common_bits(r: reg_access_t) -> bool


.. py:class:: reg_accesses_t

   Bases: :py:obj:`reg_access_vec_t`


   .. py:attribute:: thisown


.. py:data:: SETPROC_IDB

   set processor type for old idb


.. py:data:: SETPROC_LOADER

   set processor type for new idb; if the user has specified a compatible processor, return success without changing it. if failure, call loader_failure() 
             


.. py:data:: SETPROC_LOADER_NON_FATAL

   the same as SETPROC_LOADER but non-fatal failures.


.. py:data:: SETPROC_USER

   set user-specified processor used for -p and manual processor change at later time 
             


.. py:function:: set_processor_type(procname: str, level: setproc_level_t) -> bool

   Set target processor type. Once a processor module is loaded, it cannot be replaced until we close the idb. 
           
   :param procname: name of processor type (one of names present in processor_t::psnames)
   :param level: SETPROC_
   :returns: success


.. py:function:: get_idp_name() -> str

   Get name of the current processor module. The name is derived from the file name. For example, for IBM PC the module is named "pc.w32" (windows version), then the module name is "PC" (uppercase). If no processor module is loaded, this function will return nullptr 
           


.. py:function:: set_target_assembler(asmnum: int) -> bool

   Set target assembler. 
           
   :param asmnum: number of assembler in the current processor module
   :returns: success


.. py:data:: LTC_NONE

   no event (internal use)


.. py:data:: LTC_ADDED

   added a local type


.. py:data:: LTC_DELETED

   deleted a local type


.. py:data:: LTC_EDITED

   edited a local type


.. py:data:: LTC_ALIASED

   added a type alias


.. py:data:: LTC_COMPILER

   changed the compiler and calling convention


.. py:data:: LTC_TIL_LOADED

   loaded a til file


.. py:data:: LTC_TIL_UNLOADED

   unloaded a til file


.. py:data:: LTC_TIL_COMPACTED

   numbered types have been compacted compact_numbered_types()


.. py:data:: closebase

.. py:data:: savebase

.. py:data:: upgraded

.. py:data:: auto_empty

.. py:data:: auto_empty_finally

.. py:data:: determined_main

.. py:data:: extlang_changed

.. py:data:: idasgn_loaded

.. py:data:: kernel_config_loaded

.. py:data:: loader_finished

.. py:data:: flow_chart_created

.. py:data:: compiler_changed

.. py:data:: changing_ti

.. py:data:: ti_changed

.. py:data:: changing_op_ti

.. py:data:: op_ti_changed

.. py:data:: changing_op_type

.. py:data:: op_type_changed

.. py:data:: segm_added

.. py:data:: deleting_segm

.. py:data:: segm_deleted

.. py:data:: changing_segm_start

.. py:data:: segm_start_changed

.. py:data:: changing_segm_end

.. py:data:: segm_end_changed

.. py:data:: changing_segm_name

.. py:data:: segm_name_changed

.. py:data:: changing_segm_class

.. py:data:: segm_class_changed

.. py:data:: segm_attrs_updated

.. py:data:: segm_moved

.. py:data:: allsegs_moved

.. py:data:: func_added

.. py:data:: func_updated

.. py:data:: set_func_start

.. py:data:: set_func_end

.. py:data:: deleting_func

.. py:data:: frame_deleted

.. py:data:: thunk_func_created

.. py:data:: func_tail_appended

.. py:data:: deleting_func_tail

.. py:data:: func_tail_deleted

.. py:data:: tail_owner_changed

.. py:data:: func_noret_changed

.. py:data:: stkpnts_changed

.. py:data:: updating_tryblks

.. py:data:: tryblks_updated

.. py:data:: deleting_tryblks

.. py:data:: sgr_changed

.. py:data:: make_code

.. py:data:: make_data

.. py:data:: destroyed_items

.. py:data:: renamed

.. py:data:: byte_patched

.. py:data:: changing_cmt

.. py:data:: cmt_changed

.. py:data:: changing_range_cmt

.. py:data:: range_cmt_changed

.. py:data:: extra_cmt_changed

.. py:data:: item_color_changed

.. py:data:: callee_addr_changed

.. py:data:: bookmark_changed

.. py:data:: sgr_deleted

.. py:data:: adding_segm

.. py:data:: func_deleted

.. py:data:: dirtree_mkdir

.. py:data:: dirtree_rmdir

.. py:data:: dirtree_link

.. py:data:: dirtree_move

.. py:data:: dirtree_rank

.. py:data:: dirtree_rminode

.. py:data:: dirtree_segm_moved

.. py:data:: local_types_changed

.. py:data:: lt_udm_created

.. py:data:: lt_udm_deleted

.. py:data:: lt_udm_renamed

.. py:data:: lt_udm_changed

.. py:data:: lt_udt_expanded

.. py:data:: frame_created

.. py:data:: frame_udm_created

.. py:data:: frame_udm_deleted

.. py:data:: frame_udm_renamed

.. py:data:: frame_udm_changed

.. py:data:: frame_expanded

.. py:data:: idasgn_matched_ea

.. py:data:: lt_edm_created

.. py:data:: lt_edm_deleted

.. py:data:: lt_edm_renamed

.. py:data:: lt_edm_changed

.. py:data:: local_type_renamed

.. py:function:: gen_idb_event(*args) -> None

   the kernel will use this function to generate idb_events


.. py:data:: IDPOPT_CST

.. py:data:: IDPOPT_JVL

.. py:data:: IDPOPT_PRI_DEFAULT

.. py:data:: IDPOPT_PRI_HIGH

.. py:data:: IDPOPT_NUM_INT

.. py:data:: IDPOPT_NUM_CHAR

.. py:data:: IDPOPT_NUM_SHORT

.. py:data:: IDPOPT_NUM_RANGE

.. py:data:: IDPOPT_NUM_UNS

.. py:data:: IDPOPT_BIT_UINT

.. py:data:: IDPOPT_BIT_UCHAR

.. py:data:: IDPOPT_BIT_USHORT

.. py:data:: IDPOPT_BIT_BOOL

.. py:data:: IDPOPT_STR_QSTRING

.. py:data:: IDPOPT_STR_LONG

.. py:data:: IDPOPT_I64_RANGE

.. py:data:: IDPOPT_I64_UNS

.. py:data:: IDPOPT_CST_PARAMS

.. py:data:: IDPOPT_MBROFF

.. py:class:: num_range_t(_min: int64, _max: int64)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: minval
      :type:  int64


   .. py:attribute:: maxval
      :type:  int64


.. py:class:: params_t(_p1: int64, _p2: int64)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: p1
      :type:  int64


   .. py:attribute:: p2
      :type:  int64


.. py:data:: cik_string

.. py:data:: cik_filename

.. py:data:: cik_path

.. py:function:: register_cfgopts(opts: cfgopt_t const [], nopts: size_t, cb: config_changed_cb_t * = None, obj: void * = None) -> bool

.. py:function:: get_config_value(key: str) -> jvalue_t *

.. py:function:: cfg_get_cc_parm(compid: comp_t, name: str) -> str

.. py:function:: cfg_get_cc_header_path(compid: comp_t) -> str

.. py:function:: cfg_get_cc_predefined_macros(compid: comp_t) -> str

.. py:function:: process_config_directive(directive: str, priority: int = 2) -> None

.. py:function:: AssembleLine(ea, cs, ip, use32, line)

   Assemble an instruction to a string (display a warning if an error is found)

   :param ea: linear address of instruction
   :param cs:  cs of instruction
   :param ip:  ip of instruction
   :param use32: is 32bit segment
   :param line: line to assemble
   :returns: a string containing the assembled instruction, or None on failure


.. py:function:: assemble(ea, cs, ip, use32, line)

   Assemble an instruction into the database (display a warning if an error is found)

   :param ea: linear address of instruction
   :param cs: cs of instruction
   :param ip: ip of instruction
   :param use32: is 32bit segment?
   :param line: line to assemble

   :returns: Boolean. True on success.


.. py:function:: ph_get_id()

   Returns the 'ph.id' field


.. py:function:: ph_get_version()

   Returns the 'ph.version'


.. py:function:: ph_get_flag()

   Returns the 'ph.flag'


.. py:function:: ph_get_cnbits()

   Returns the 'ph.cnbits'


.. py:function:: ph_get_dnbits()

   Returns the 'ph.dnbits'


.. py:function:: ph_get_reg_first_sreg()

   Returns the 'ph.reg_first_sreg'


.. py:function:: ph_get_reg_last_sreg()

   Returns the 'ph.reg_last_sreg'


.. py:function:: ph_get_segreg_size()

   Returns the 'ph.segreg_size'


.. py:function:: ph_get_reg_code_sreg()

   Returns the 'ph.reg_code_sreg'


.. py:function:: ph_get_reg_data_sreg()

   Returns the 'ph.reg_data_sreg'


.. py:function:: ph_get_icode_return()

   Returns the 'ph.icode_return'


.. py:function:: ph_get_instruc_start()

   Returns the 'ph.instruc_start'


.. py:function:: ph_get_instruc_end()

   Returns the 'ph.instruc_end'


.. py:function:: ph_get_tbyte_size()

   Returns the 'ph.tbyte_size' field as defined in he processor module


.. py:function:: ph_get_instruc()

   Returns a list of tuples (instruction_name, instruction_feature) containing the
   instructions list as defined in he processor module


.. py:function:: ph_get_regnames()

   Returns the list of register names as defined in the processor module


.. py:function:: ph_get_operand_info(ea: ida_idaapi.ea_t, n: int) -> Union[Tuple[int, ida_idaapi.ea_t, int, int, int], None]

   Returns the operand information given an ea and operand number.

   :param ea: address
   :param n: operand number

   :returns: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.


.. py:function:: ph_calcrel(ea: ida_idaapi.ea_t) -> bytevec_t *, size_t *

.. py:function:: ph_find_reg_value(insn: insn_t const &, reg: int) -> uint64 *

.. py:function:: ph_find_op_value(insn: insn_t const &, op: int) -> uint64 *

.. py:function:: ph_get_reg_accesses(accvec: reg_accesses_t, insn: insn_t const &, flags: int) -> ssize_t

.. py:function:: ph_get_abi_info(comp: comp_t) -> qstrvec_t *, qstrvec_t *

.. py:class:: IDP_Hooks(_flags: int = 0, _hkcb_flags: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: hook() -> bool


   .. py:method:: unhook() -> bool


   .. py:method:: ev_init(idp_modname: str) -> int

      The IDP module is just loaded. 
                
      :param idp_modname: (const char *) processor module name
      :returns: <0: on failure



   .. py:method:: ev_term() -> int

      The IDP module is being unloaded.



   .. py:method:: ev_newprc(pnum: int, keep_cfg: bool) -> int

      Before changing processor type. 
                
      :param pnum: (int) processor number in the array of processor names
      :param keep_cfg: (bool) true: do not modify kernel configuration
      :returns: 1: ok
      :returns: <0: prohibit



   .. py:method:: ev_newasm(asmnum: int) -> int

      Before setting a new assembler. 
                
      :param asmnum: (int) See also ev_asm_installed



   .. py:method:: ev_newfile(fname: char *) -> int

      A new file has been loaded. 
                
      :param fname: (char *) input file name



   .. py:method:: ev_oldfile(fname: char *) -> int

      An old file has been loaded. 
                
      :param fname: (char *) input file name



   .. py:method:: ev_newbinary(filename: char *, fileoff: qoff64_t, basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: uint64) -> int

      IDA is about to load a binary file. 
                
      :param filename: (char *) binary file name
      :param fileoff: (qoff64_t) offset in the file
      :param basepara: (::ea_t) base loading paragraph
      :param binoff: (::ea_t) loader offset
      :param nbytes: (::uint64) number of bytes to load



   .. py:method:: ev_endbinary(ok: bool) -> int

      IDA has loaded a binary file. 
                
      :param ok: (bool) file loaded successfully?



   .. py:method:: ev_set_idp_options(keyword: str, value_type: int, value: void const *, idb_loaded: bool) -> int

      Set IDP-specific configuration option Also see set_options_t in config.hpp 
                
      :param keyword: (const char *)
      :param value_type: (int)
      :param value: (const void *)
      :param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been generated
      :returns: 1: ok
      :returns: 0: not implemented
      :returns: -1: error (and message in errbuf)



   .. py:method:: ev_set_proc_options(options: str, confidence: int) -> int

      Called if the user specified an option string in the command line: -p<processor name>:<options>. Can be used for setting a processor subtype. Also called if option string is passed to set_processor_type() and IDC's SetProcessorType(). 
                
      :param options: (const char *)
      :param confidence: (int) 0: loader's suggestion 1: user's decision
      :returns: <0: if bad option string



   .. py:method:: ev_ana_insn(out: insn_t *) -> bool

      Analyze one instruction and fill 'out' structure. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. insn_t::ea contains address of instruction to analyze. 
                
      :param out: (insn_t *)
      :returns: length of the instruction in bytes, 0 if instruction can't be decoded.
      :returns: 0: if instruction can't be decoded.



   .. py:method:: ev_emu_insn(insn: insn_t const *) -> bool

      Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. Upon entrance to this function, all information about the instruction is in 'insn' structure. 
                
      :param insn: (const insn_t *)
      :returns: 1: ok
      :returns: -1: the kernel will delete the instruction



   .. py:method:: ev_out_header(outctx: outctx_t *) -> int

      Function to produce start of disassembled text 
                
      :param outctx: (outctx_t *)
      :returns: void: 



   .. py:method:: ev_out_footer(outctx: outctx_t *) -> int

      Function to produce end of disassembled text 
                
      :param outctx: (outctx_t *)
      :returns: void: 



   .. py:method:: ev_out_segstart(outctx: outctx_t *, seg: segment_t *) -> int

      Function to produce start of segment 
                
      :param outctx: (outctx_t *)
      :param seg: (segment_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_segend(outctx: outctx_t *, seg: segment_t *) -> int

      Function to produce end of segment 
                
      :param outctx: (outctx_t *)
      :param seg: (segment_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_assumes(outctx: outctx_t *) -> int

      Function to produce assume directives when segment register value changes. 
                
      :param outctx: (outctx_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_insn(outctx: outctx_t *) -> bool

      Generate text representation of an instruction in 'ctx.insn' outctx_t provides functions to output the generated text. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. 
                
      :param outctx: (outctx_t *)
      :returns: void: 



   .. py:method:: ev_out_mnem(outctx: outctx_t *) -> int

      Generate instruction mnemonics. This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. 
                
      :param outctx: (outctx_t *)
      :returns: 1: if appended the mnemonics
      :returns: 0: not implemented



   .. py:method:: ev_out_operand(outctx: outctx_t *, op: op_t const *) -> bool

      Generate text representation of an instruction operand outctx_t provides functions to output the generated text. All these actions should be performed only by emu_insn() function. 
                
      :param outctx: (outctx_t *)
      :param op: (const op_t *)
      :returns: 1: ok
      :returns: -1: operand is hidden



   .. py:method:: ev_out_data(outctx: outctx_t *, analyze_only: bool) -> int

      Generate text representation of data items This function may change the database and create cross-references if analyze_only is set 
                
      :param outctx: (outctx_t *)
      :param analyze_only: (bool)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_label(outctx: outctx_t *, colored_name: str) -> int

      The kernel is going to generate an instruction label line or a function header. 
                
      :param outctx: (outctx_t *)
      :param colored_name: (const char *)
      :returns: <0: if the kernel should not generate the label
      :returns: 0: not implemented or continue



   .. py:method:: ev_out_special_item(outctx: outctx_t *, segtype: uchar) -> int

      Generate text representation of an item in a special segment i.e. absolute symbols, externs, communal definitions etc 
                
      :param outctx: (outctx_t *)
      :param segtype: (uchar)
      :returns: 1: ok
      :returns: 0: not implemented
      :returns: -1: overflow



   .. py:method:: ev_gen_regvar_def(outctx: outctx_t *, v: regvar_t *) -> int

      Generate register variable definition line. 
                
      :param outctx: (outctx_t *)
      :param v: (regvar_t *)
      :returns: >0: ok, generated the definition text
      :returns: 0: not implemented



   .. py:method:: ev_gen_src_file_lnnum(outctx: outctx_t *, file: str, lnnum: size_t) -> int

      Callback: generate analog of: 
           #line  123
          


                
      :param outctx: (outctx_t *) output context
      :param file: (const char *) source file (may be nullptr)
      :param lnnum: (size_t) line number
      :returns: 1: directive has been generated
      :returns: 0: not implemented



   .. py:method:: ev_creating_segm(seg: segment_t *) -> int

      A new segment is about to be created. 
                
      :param seg: (segment_t *)
      :returns: 1: ok
      :returns: <0: segment should not be created



   .. py:method:: ev_moving_segm(seg: segment_t *, to: ida_idaapi.ea_t, flags: int) -> int

      May the kernel move the segment? 
                
      :param seg: (segment_t *) segment to move
      :param to: (::ea_t) new segment start address
      :param flags: (int) combination of Move segment flags
      :returns: 0: yes
      :returns: <0: the kernel should stop



   .. py:method:: ev_coagulate(start_ea: ida_idaapi.ea_t) -> int

      Try to define some unexplored bytes. This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. 
                
      :param start_ea: (::ea_t)
      :returns: number of converted bytes



   .. py:method:: ev_undefine(ea: ida_idaapi.ea_t) -> int

      An item in the database (insn or data) is being deleted. 
                
      :param ea: (ea_t)
      :returns: 1: do not delete srranges at the item end
      :returns: 0: srranges can be deleted



   .. py:method:: ev_treat_hindering_item(hindering_item_ea: ida_idaapi.ea_t, new_item_flags: flags64_t, new_item_ea: ida_idaapi.ea_t, new_item_length: asize_t) -> int

      An item hinders creation of another item. 
                
      :param hindering_item_ea: (::ea_t)
      :param new_item_flags: (flags64_t) (0 for code)
      :param new_item_ea: (::ea_t)
      :param new_item_length: (::asize_t)
      :returns: 0: no reaction
      :returns: !=0: the kernel may delete the hindering item



   .. py:method:: ev_rename(ea: ida_idaapi.ea_t, new_name: str) -> int

      The kernel is going to rename a byte. 
                
      :param ea: (::ea_t)
      :param new_name: (const char *)
      :returns: <0: if the kernel should not rename it.
      :returns: 2: to inhibit the notification. I.e., the kernel should not rename, but 'set_name()' should return 'true'. also see renamed the return value is ignored when kernel is going to delete name



   .. py:method:: ev_is_far_jump(icode: int) -> int

      is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types 
                
      :param icode: (int)
      :returns: 0: not implemented
      :returns: 1: yes
      :returns: -1: no



   .. py:method:: ev_is_sane_insn(insn: insn_t const *, no_crefs: int) -> int

      Is the instruction sane for the current file type?. 
                
      :param insn: (const insn_t*) the instruction
      :param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason.
      :returns: >=0: ok
      :returns: <0: no, the instruction isn't likely to appear in the program



   .. py:method:: ev_is_cond_insn(insn: insn_t const *) -> int

      Is conditional instruction? 
                
      :param insn: (const insn_t *) instruction address
      :returns: 1: yes
      :returns: -1: no
      :returns: 0: not implemented or not instruction



   .. py:method:: ev_is_call_insn(insn: insn_t const *) -> int

      Is the instruction a "call"? 
                
      :param insn: (const insn_t *) instruction
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_is_ret_insn(insn: insn_t const *, flags: uchar) -> int

      Is the instruction a "return"? 
                
      :param insn: (const insn_t *) instruction
      :param flags: (uchar), combination of IRI_... flags (see above)
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_may_be_func(insn: insn_t const *, state: int) -> int

      Can a function start here? 
                
      :param insn: (const insn_t*) the instruction
      :param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
      :returns: probability 1..100



   .. py:method:: ev_is_basic_block_end(insn: insn_t const *, call_insn_stops_block: bool) -> int

      Is the current instruction end of a basic block?. This function should be defined for processors with delayed jump slots. 
                
      :param insn: (const insn_t*) the instruction
      :param call_insn_stops_block: (bool)
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_is_indirect_jump(insn: insn_t const *) -> int

      Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all jump types jumps, please define this callback. 
                
      :param insn: (const insn_t*) the instruction
      :returns: 0: use CF_JUMP
      :returns: 1: no
      :returns: 2: yes



   .. py:method:: ev_is_insn_table_jump() -> int

      Reserved.



   .. py:method:: ev_is_switch(si: switch_info_t, insn: insn_t const *) -> int

      Find 'switch' idiom or override processor module's decision. It will be called for instructions marked with CF_JUMP. 
                
      :param si: (switch_info_t *), out
      :param insn: (const insn_t *) instruction possibly belonging to a switch
      :returns: 1: switch is found, 'si' is filled. IDA will create the switch using the filled 'si'
      :returns: -1: no switch found. This value forbids switch creation by the processor module
      :returns: 0: not implemented



   .. py:method:: ev_calc_switch_cases(casevec: casevec_t *, targets: eavec_t *, insn_ea: ida_idaapi.ea_t, si: switch_info_t) -> int

      Calculate case values and targets for a custom jump table. 
                
      :param casevec: (::casevec_t *) vector of case values (may be nullptr)
      :param targets: (eavec_t *) corresponding target addresses (my be nullptr)
      :param insn_ea: (::ea_t) address of the 'indirect jump' instruction
      :param si: (switch_info_t *) switch information
      :returns: 1: ok
      :returns: <=0: failed



   .. py:method:: ev_create_switch_xrefs(jumpea: ida_idaapi.ea_t, si: switch_info_t) -> int

      Create xrefs for a custom jump table. 
                
      :param jumpea: (::ea_t) address of the jump insn
      :param si: (const switch_info_t *) switch information
      :returns: must return 1 Must be implemented if module uses custom jump tables, SWI_CUSTOM



   .. py:method:: ev_is_align_insn(ea: ida_idaapi.ea_t) -> int

      Is the instruction created only for alignment purposes?. Do not directly call this function, use is_align_insn() 
                
      :param ea: (ea_t) - instruction address
      :returns: number: of bytes in the instruction



   .. py:method:: ev_is_alloca_probe(ea: ida_idaapi.ea_t) -> int

      Does the function at 'ea' behave as __alloca_probe? 
                
      :param ea: (::ea_t)
      :returns: 1: yes
      :returns: 0: no



   .. py:method:: ev_delay_slot_insn(ea: ida_idaapi.ea_t, bexec: bool, fexec: bool) -> PyObject *

      Get delay slot instruction 
                
      :param ea: (::ea_t *) in: instruction address in question, out: (if the answer is positive) if the delay slot contains valid insn: the address of the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
      :param bexec: (bool *) execute slot if jumping, initially set to 'true'
      :param fexec: (bool *) execute slot if not jumping, initally set to 'true'
      :returns: 1: positive answer
      :returns: <=0: ordinary insn



   .. py:method:: ev_is_sp_based(mode: int *, insn: insn_t const *, op: op_t const *) -> int

      Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. Implement this event only if some stack references use frame pointer instead of stack pointer. 
                
      :param mode: (int *) out, combination of SP/FP operand flags
      :param insn: (const insn_t *)
      :param op: (const op_t *)
      :returns: 0: not implemented
      :returns: 1: ok



   .. py:method:: ev_can_have_type(op: op_t const *) -> int

      Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. see bytes.hpp for information about types and flags) 
                
      :param op: (const op_t *)
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_cmp_operands(op1: op_t const *, op2: op_t const *) -> int

      Compare instruction operands 
                
      :param op1: (const op_t*)
      :param op2: (const op_t*)
      :returns: 1: equal
      :returns: -1: not equal
      :returns: 0: not implemented



   .. py:method:: ev_adjust_refinfo(ri: refinfo_t, ea: ida_idaapi.ea_t, n: int, fd: fixup_data_t const *) -> int

      Called from apply_fixup before converting operand to reference. Can be used for changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some references) 
                
      :param ri: (refinfo_t *)
      :param ea: (::ea_t) instruction address
      :param n: (int) operand number
      :param fd: (const fixup_data_t *)
      :returns: <0: do not create an offset
      :returns: 0: not implemented or refinfo adjusted



   .. py:method:: ev_get_operand_string(insn: insn_t const *, opnum: int) -> PyObject *

      Request text string for operand (cli, java, ...). 
                
      :param insn: (const insn_t*) the instruction
      :param opnum: (int) operand number, -1 means any string operand
      :returns: 0: no string (or empty string)
      :returns: >0: original string length without terminating zero



   .. py:method:: ev_get_reg_name(reg: int, width: size_t, reghi: int) -> PyObject *

      Generate text representation of a register. Most processor modules do not need to implement this callback. It is useful only if processor_t::reg_names[reg] does not provide the correct register name. 
                
      :param reg: (int) internal register number as defined in the processor module
      :param width: (size_t) register width in bytes
      :param reghi: (int) if not -1 then this function will return the register pair
      :returns: -1: if error
      :returns: strlen(buf): if success



   .. py:method:: ev_str2reg(regname: str) -> int

      Convert a register name to a register number. The register number is the register index in the processor_t::reg_names array Most processor modules do not need to implement this callback It is useful only if processor_t::reg_names[reg] does not provide the correct register names 
                
      :param regname: (const char *)
      :returns: register: number + 1
      :returns: 0: not implemented or could not be decoded



   .. py:method:: ev_get_autocmt(insn: insn_t const *) -> PyObject *

      Callback: get dynamic auto comment. Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. 
                
      :param insn: (const insn_t*) the instruction
      :returns: 1: new comment has been generated
      :returns: 0: callback has not been handled. the buffer must not be changed in this case



   .. py:method:: ev_get_bg_color(color: bgcolor_t *, ea: ida_idaapi.ea_t) -> int

      Get item background color. Plugins can hook this callback to color disassembly lines dynamically 
                
      :param color: (bgcolor_t *), out
      :param ea: (::ea_t)
      :returns: 0: not implemented
      :returns: 1: color set



   .. py:method:: ev_is_jump_func(pfn: func_t *, jump_target: ea_t *, func_pointer: ea_t *) -> int

      Is the function a trivial "jump" function?. 
                
      :param pfn: (func_t *)
      :param jump_target: (::ea_t *)
      :param func_pointer: (::ea_t *)
      :returns: <0: no
      :returns: 0: don't know
      :returns: 1: yes, see 'jump_target' and 'func_pointer'



   .. py:method:: ev_func_bounds(possible_return_code: int *, pfn: func_t *, max_func_end_ea: ida_idaapi.ea_t) -> int

      find_func_bounds() finished its work. The module may fine tune the function bounds 
                
      :param possible_return_code: (int *), in/out
      :param pfn: (func_t *)
      :param max_func_end_ea: (::ea_t) (from the kernel's point of view)
      :returns: void: 



   .. py:method:: ev_verify_sp(pfn: func_t *) -> int

      All function instructions have been analyzed. Now the processor module can analyze the stack pointer for the whole function 
                
      :param pfn: (func_t *)
      :returns: 0: ok
      :returns: <0: bad stack pointer



   .. py:method:: ev_verify_noreturn(pfn: func_t *) -> int

      The kernel wants to set 'noreturn' flags for a function. 
                
      :param pfn: (func_t *)
      :returns: 0: ok. any other value: do not set 'noreturn' flag



   .. py:method:: ev_create_func_frame(pfn: func_t *) -> int

      Create a function frame for a newly created function Set up frame size, its attributes etc 
                
      :param pfn: (func_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_get_frame_retsize(frsize: int *, pfn: func_t const *) -> int

      Get size of function return address in bytes If this event is not implemented, the kernel will assume
      * 8 bytes for 64-bit function
      * 4 bytes for 32-bit function
      * 2 bytes otherwise



      :param frsize: (int *) frame size (out)
      :param pfn: (const func_t *), can't be nullptr
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_get_stkvar_scale_factor() -> int

      Should stack variable references be multiplied by a coefficient before being used in the stack frame?. Currently used by TMS320C55 because the references into the stack should be multiplied by 2 
                
      :returns: scaling factor
      :returns: 0: not implemented



   .. py:method:: ev_demangle_name(name: str, disable_mask: int, demreq: int) -> PyObject *

      Demangle a C++ (or another language) name into a user-readable string. This event is called by demangle_name() 
                
      :param name: (const char *) mangled name
      :param disable_mask: (uint32) flags to inhibit parts of output or compiler info/other (see MNG_)
      :param demreq: (demreq_type_t) operation to perform
      :returns: 1: if success
      :returns: 0: not implemented



   .. py:method:: ev_add_cref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: cref_t) -> int

      A code reference is being created. 
                
      :param to: (::ea_t)
      :param type: (cref_t)
      :returns: <0: cancel cref creation
      :returns: 0: not implemented or continue



   .. py:method:: ev_add_dref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: dref_t) -> int

      A data reference is being created. 
                
      :param to: (::ea_t)
      :param type: (dref_t)
      :returns: <0: cancel dref creation
      :returns: 0: not implemented or continue



   .. py:method:: ev_del_cref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> int

      A code reference is being deleted. 
                
      :param to: (::ea_t)
      :param expand: (bool)
      :returns: <0: cancel cref deletion
      :returns: 0: not implemented or continue



   .. py:method:: ev_del_dref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> int

      A data reference is being deleted. 
                
      :param to: (::ea_t)
      :returns: <0: cancel dref deletion
      :returns: 0: not implemented or continue



   .. py:method:: ev_coagulate_dref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, may_define: bool, code_ea: ea_t *) -> int

      Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) 
                
      :param to: (::ea_t)
      :param may_define: (bool)
      :param code_ea: (::ea_t *)
      :returns: <0: failed dref analysis, >0 done dref analysis
      :returns: 0: not implemented or continue



   .. py:method:: ev_may_show_sreg(current_ea: ida_idaapi.ea_t) -> int

      The kernel wants to display the segment registers in the messages window. 
                
      :param current_ea: (::ea_t)
      :returns: <0: if the kernel should not show the segment registers. (assuming that the module has done it)
      :returns: 0: not implemented



   .. py:method:: ev_auto_queue_empty(type: atype_t) -> int

      One analysis queue is empty. 
                
      :param type: (atype_t)
      :returns: void: see also idb_event::auto_empty_finally



   .. py:method:: ev_validate_flirt_func(start_ea: ida_idaapi.ea_t, funcname: str) -> int

      Flirt has recognized a library function. This callback can be used by a plugin or proc module to intercept it and validate such a function. 
                
      :param start_ea: (::ea_t)
      :param funcname: (const char *)
      :returns: -1: do not create a function,
      :returns: 0: function is validated



   .. py:method:: ev_adjust_libfunc_ea(sig: idasgn_t const *, libfun: libfunc_t const *, ea: ea_t *) -> int

      Called when a signature module has been matched against bytes in the database. This is used to compute the offset at which a particular module's libfunc should be applied. 
                
      :param sig: (const idasgn_t *)
      :param libfun: (const libfunc_t *)
      :param ea: (::ea_t *)
      :returns: 1: the ea_t pointed to by the third argument was modified.
      :returns: <=0: not modified. use default algorithm.



   .. py:method:: ev_assemble(ea: ida_idaapi.ea_t, cs: ida_idaapi.ea_t, ip: ida_idaapi.ea_t, use32: bool, line: str) -> PyObject *

      Assemble an instruction. (display a warning if an error is found). 
                
      :param ea: (::ea_t) linear address of instruction
      :param cs: (::ea_t) cs of instruction
      :param ip: (::ea_t) ip of instruction
      :param use32: (bool) is 32bit segment?
      :param line: (const char *) line to assemble
      :returns: size of the instruction in bytes



   .. py:method:: ev_extract_address(out_ea: ea_t *, screen_ea: ida_idaapi.ea_t, string: str, position: size_t) -> int

      Extract address from a string. 
                
      :param out_ea: (ea_t *), out
      :param screen_ea: (ea_t)
      :param string: (const char *)
      :param position: (size_t)
      :returns: 1: ok
      :returns: 0: kernel should use the standard algorithm
      :returns: -1: error



   .. py:method:: ev_realcvt(m: void *, e: fpvalue_t *, swt: uint16) -> int

      Floating point -> IEEE conversion 
                
      :param m: (void *) ptr to processor-specific floating point value
      :param e: (fpvalue_t *) IDA representation of a floating point value
      :param swt: (uint16) operation (see realcvt() in ieee.h)
      :returns: 0: not implemented



   .. py:method:: ev_gen_asm_or_lst(starting: bool, fp: FILE *, is_asm: bool, flags: int, outline: html_line_cb_t **) -> int

      Callback: generating asm or lst file. The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output 
                
      :param starting: (bool) beginning listing generation
      :param fp: (FILE *) output file
      :param is_asm: (bool) true:assembler, false:listing
      :param flags: (int) flags passed to gen_file()
      :param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines
      :returns: void: 



   .. py:method:: ev_gen_map_file(nlines: int *, fp: FILE *) -> int

      Generate map file. If not implemented the kernel itself will create the map file. 
                
      :param nlines: (int *) number of lines in map file (-1 means write error)
      :param fp: (FILE *) output file
      :returns: 0: not implemented
      :returns: 1: ok
      :returns: -1: write error



   .. py:method:: ev_create_flat_group(image_base: ida_idaapi.ea_t, bitness: int, dataseg_sel: sel_t) -> int

      Create special segment representing the flat group. 
                
      :param image_base: (::ea_t)
      :param bitness: (int)
      :param dataseg_sel: (::sel_t) return value is ignored



   .. py:method:: ev_getreg(regval: uval_t *, regnum: int) -> int

      IBM PC only internal request, should never be used for other purpose Get register value by internal index 
                
      :param regval: (uval_t *), out
      :param regnum: (int)
      :returns: 1: ok
      :returns: 0: not implemented
      :returns: -1: failed (undefined value or bad regnum)



   .. py:method:: ev_analyze_prolog(ea: ida_idaapi.ea_t) -> int

      Analyzes function prolog, epilog, and updates purge, and function attributes 
                
      :param ea: (::ea_t) start of function
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_calc_spdelta(spdelta: sval_t *, insn: insn_t const *) -> int

      Calculate amount of change to sp for the given insn. This event is required to decompile code snippets. 
                
      :param spdelta: (sval_t *)
      :param insn: (const insn_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_calcrel() -> int

      Reserved.



   .. py:method:: ev_find_reg_value(pinsn: insn_t const *, reg: int) -> PyObject *

      Find register value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
                
      :param pinsn: (const insn_t *) instruction
      :param reg: (int) register index
      :returns: 1: if implemented, and value was found
      :returns: 0: not implemented, -1 decoding failed, or no value found



   .. py:method:: ev_find_op_value(pinsn: insn_t const *, opn: int) -> PyObject *

      Find operand value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
                
      :param pinsn: (const insn_t *) instruction
      :param opn: (int) operand index
      :returns: 1: if implemented, and value was found
      :returns: 0: not implemented, -1 decoding failed, or no value found



   .. py:method:: ev_replaying_undo(action_name: str, vec: undo_records_t const *, is_undo: bool) -> int

      Replaying an undo/redo buffer 
                
      :param action_name: (const char *) action that we perform undo/redo for. may be nullptr for intermediary buffers.
      :param vec: (const undo_records_t *)
      :param is_undo: (bool) true if performing undo, false if performing redo This event may be generated multiple times per undo/redo



   .. py:method:: ev_ending_undo(action_name: str, is_undo: bool) -> int

      Ended undoing/redoing an action 
                
      :param action_name: (const char *) action that we finished undoing/redoing. is not nullptr.
      :param is_undo: (bool) true if performing undo, false if performing redo



   .. py:method:: ev_set_code16_mode(ea: ida_idaapi.ea_t, code16: bool) -> int

      Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set ISA 16-bit mode 
                
      :param ea: (ea_t) address to set new ISA mode
      :param code16: (bool) true for 16-bit mode, false for 32-bit mode



   .. py:method:: ev_get_code16_mode(ea: ida_idaapi.ea_t) -> int

      Get ISA 16-bit mode 
                
      :param ea: (ea_t) address to get the ISA mode
      :returns: 1: 16-bit mode
      :returns: 0: not implemented or 32-bit mode



   .. py:method:: ev_get_procmod() -> int

      Get pointer to the processor module object. All processor modules must implement this. The pointer is returned as size_t. 
                



   .. py:method:: ev_asm_installed(asmnum: int) -> int

      After setting a new assembler 
                
      :param asmnum: (int) See also ev_newasm



   .. py:method:: ev_get_reg_accesses(accvec: reg_accesses_t, insn: insn_t const *, flags: int) -> int

      Get info about the registers that are used/changed by an instruction. 
                
      :param accvec: (reg_accesses_t*) out: info about accessed registers
      :param insn: (const insn_t *) instruction in question
      :param flags: (int) reserved, must be 0
      :returns: -1: if accvec is nullptr
      :returns: 1: found the requested access (and filled accvec)
      :returns: 0: not implemented



   .. py:method:: ev_is_control_flow_guard(p_reg: int *, insn: insn_t const *) -> int

      Detect if an instruction is a "thunk call" to a flow guard function (equivalent to call reg/return/nop) 
                
      :param p_reg: (int *) indirect register number, may be -1
      :param insn: (const insn_t *) call/jump instruction
      :returns: -1: no thunk detected
      :returns: 1: indirect call
      :returns: 2: security check routine call (NOP)
      :returns: 3: return thunk
      :returns: 0: not implemented



   .. py:method:: ev_create_merge_handlers(md: merge_data_t *) -> int

      Create merge handlers, if needed 
                
      :param md: (merge_data_t *) This event is generated immediately after opening idbs.
      :returns: must be 0



   .. py:method:: ev_privrange_changed(old_privrange: range_t, delta: adiff_t) -> int

      Privrange interval has been moved to a new location. Most common actions to be done by module in this case: fix indices of netnodes used by module 
                
      :param old_privrange: (const range_t *) - old privrange interval
      :param delta: (::adiff_t)
      :returns: 0: Ok
      :returns: -1: error (and message in errbuf)



   .. py:method:: ev_cvt64_supval(node: nodeidx_t, tag: uchar, idx: nodeidx_t, data: uchar const *) -> int

      perform 32-64 conversion for a netnode array element 
                
      :param node: (::nodeidx_t)
      :param tag: (uchar)
      :param idx: (::nodeidx_t)
      :param data: (const uchar *)
      :returns: 0: nothing was done
      :returns: 1: converted successfully
      :returns: -1: error (and message in errbuf)



   .. py:method:: ev_cvt64_hashval(node: nodeidx_t, tag: uchar, name: str, data: uchar const *) -> int

      perform 32-64 conversion for a hash value 
                
      :param node: (::nodeidx_t)
      :param tag: (uchar)
      :param name: (const ::char *)
      :param data: (const uchar *)
      :returns: 0: nothing was done
      :returns: 1: converted successfully
      :returns: -1: error (and message in errbuf)



   .. py:method:: ev_gen_stkvar_def(outctx: outctx_t *, stkvar: udm_t, v: int, tid: tid_t) -> int

      Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte 
                
      :param outctx: (outctx_t *)
      :param stkvar: (const udm_t *)
      :param v: (sval_t)
      :param tid: (tid_t) stkvar TID
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_is_addr_insn(type: int *, insn: insn_t const *) -> int

      Does the instruction calculate some address using an immediate operand? e.g. in PC such operand may be o_displ: 'lea eax, [esi+4]' 
                
      :param type: (int *) pointer to the returned instruction type:
      * 0 the "add" instruction (the immediate operand is a relative value)
      * 1 the "move" instruction (the immediate operand is an absolute value)
      * 2 the "sub" instruction (the immediate operand is a relative value)
      :param insn: (const insn_t *) instruction
      :returns: >0 the operand number+1
      :returns: 0: not implemented



   .. py:method:: ev_next_exec_insn(target: ea_t *, ea: ida_idaapi.ea_t, tid: int, getreg: processor_t::regval_getter_t *, regvalues: regval_t) -> int

      Get next address to be executed This function must return the next address to be executed. If the instruction following the current one is executed, then it must return BADADDR Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. 
                
      :param target: (::ea_t *), out: pointer to the answer
      :param ea: (::ea_t) instruction address
      :param tid: (int) current therad id
      :param getreg: (::processor_t::regval_getter_t *) function to get register values
      :param regvalues: (const regval_t *) register values array
      :returns: 0: unimplemented
      :returns: 1: implemented



   .. py:method:: ev_calc_step_over(target: ea_t *, ip: ida_idaapi.ea_t) -> int

      Calculate the address of the instruction which will be executed after "step over". The kernel will put a breakpoint there. If the step over is equal to step into or we cannot calculate the address, return BADADDR. 
                
      :param target: (::ea_t *) pointer to the answer
      :param ip: (::ea_t) instruction address
      :returns: 0: unimplemented
      :returns: 1: implemented



   .. py:method:: ev_calc_next_eas(res: eavec_t *, insn: insn_t const *, over: bool) -> int

      Calculate list of addresses the instruction in 'insn' may pass control to. This callback is required for source level debugging. 
                
      :param res: (eavec_t *), out: array for the results.
      :param insn: (const insn_t*) the instruction
      :param over: (bool) calculate for step over (ignore call targets)
      :returns: <0: incalculable (indirect jumps, for example)
      :returns: >=0: number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true)



   .. py:method:: ev_get_macro_insn_head(head: ea_t *, ip: ida_idaapi.ea_t) -> int

      Calculate the start of a macro instruction. This notification is called if IP points to the middle of an instruction 
                
      :param head: (::ea_t *), out: answer, BADADDR means normal instruction
      :param ip: (::ea_t) instruction address
      :returns: 0: unimplemented
      :returns: 1: implemented



   .. py:method:: ev_get_dbr_opnum(opnum: int *, insn: insn_t const *) -> int

      Get the number of the operand to be displayed in the debugger reference view (text mode). 
                
      :param opnum: (int *) operand number (out, -1 means no such operand)
      :param insn: (const insn_t*) the instruction
      :returns: 0: unimplemented
      :returns: 1: implemented



   .. py:method:: ev_insn_reads_tbit(insn: insn_t const *, getreg: processor_t::regval_getter_t *, regvalues: regval_t) -> int

      Check if insn will read the TF bit. 
                
      :param insn: (const insn_t*) the instruction
      :param getreg: (::processor_t::regval_getter_t *) function to get register values
      :param regvalues: (const regval_t *) register values array
      :returns: 2: yes, will generate 'step' exception
      :returns: 1: yes, will store the TF bit in memory
      :returns: 0: no



   .. py:method:: ev_clean_tbit(ea: ida_idaapi.ea_t, getreg: processor_t::regval_getter_t *, regvalues: regval_t) -> int

      Clear the TF bit after an insn like pushf stored it in memory. 
                
      :param ea: (::ea_t) instruction address
      :param getreg: (::processor_t::regval_getter_t *) function to get register values
      :param regvalues: (const regval_t *) register values array
      :returns: 1: ok
      :returns: 0: failed



   .. py:method:: ev_get_reg_info(main_regname: char const **, bitrange: bitrange_t, regname: str) -> int

      Get register information by its name. example: "ah" returns:
      * main_regname="eax"
      * bitrange_t = { offset==8, nbits==8 }


      This callback may be unimplemented if the register names are all present in processor_t::reg_names and they all have the same size 
                
      :param main_regname: (const char **), out
      :param bitrange: (bitrange_t *), out: position and size of the value within 'main_regname' (empty bitrange == whole register)
      :param regname: (const char *)
      :returns: 1: ok
      :returns: -1: failed (not found)
      :returns: 0: unimplemented



   .. py:method:: ev_update_call_stack(stack: call_stack_t, tid: int, getreg: processor_t::regval_getter_t *, regvalues: regval_t) -> int

      Calculate the call stack trace for the given thread. This callback is invoked when the process is suspended and should fill the 'trace' object with the information about the current call stack. Note that this callback is NOT invoked if the current debugger backend implements stack tracing via debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes priority. Implementing this callback in the processor module is useful when multiple debugging platforms follow similar patterns, and thus the same processor-specific algorithm can be used for different platforms. 
                
      :param stack: (call_stack_t *) result
      :param tid: (int) thread id
      :param getreg: (::processor_t::regval_getter_t *) function to get register values
      :param regvalues: (const regval_t *) register values array
      :returns: 1: ok
      :returns: -1: failed
      :returns: 0: unimplemented



   .. py:method:: ev_setup_til() -> int

      Setup default type libraries. (called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. 
                
      :returns: void: 



   .. py:method:: ev_get_abi_info(comp: comp_t) -> int

      Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore 
                
      :param comp: (comp_t) - compiler ID
      :returns: 0: not implemented
      :returns: 1: ok



   .. py:method:: ev_max_ptr_size() -> int

      Get maximal size of a pointer in bytes. 
                
      :returns: max possible size of a pointer



   .. py:method:: ev_get_default_enum_size() -> int

      Get default enum size. Not generated anymore. inf_get_cc_size_e() is used instead 
                



   .. py:method:: ev_get_cc_regs(regs: callregs_t, cc: callcnv_t) -> int

      Get register allocation convention for given calling convention 
                
      :param regs: (callregs_t *), out
      :param cc: (::callcnv_t)
      :returns: 1: 
      :returns: 0: not implemented



   .. py:method:: ev_get_simd_types(out: simd_info_vec_t *, simd_attrs: simd_info_t, argloc: argloc_t, create_tifs: bool) -> int

      Get SIMD-related types according to given attributes ant/or argument location 
                
      :param out: (::simd_info_vec_t *)
      :param simd_attrs: (const simd_info_t *), may be nullptr
      :param argloc: (const argloc_t *), may be nullptr
      :param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
      :returns: number: of found types
      :returns: -1: error If name==nullptr, initialize all SIMD types



   .. py:method:: ev_calc_cdecl_purged_bytes(ea: ida_idaapi.ea_t) -> int

      Calculate number of purged bytes after call. 
                
      :param ea: (::ea_t) address of the call instruction
      :returns: number of purged bytes (usually add sp, N)



   .. py:method:: ev_calc_purged_bytes(p_purged_bytes: int *, fti: func_type_data_t) -> int

      Calculate number of purged bytes by the given function type. 
                
      :param p_purged_bytes: (int *) ptr to output
      :param fti: (const func_type_data_t *) func type details
      :returns: 1: 
      :returns: 0: not implemented



   .. py:method:: ev_calc_retloc(retloc: argloc_t, rettype: tinfo_t, cc: callcnv_t) -> int

      Calculate return value location. 
                
      :param retloc: (argloc_t *)
      :param rettype: (const tinfo_t *)
      :param cc: (::callcnv_t)
      :returns: 0: not implemented
      :returns: 1: ok,
      :returns: -1: error



   .. py:method:: ev_calc_arglocs(fti: func_type_data_t) -> int

      Calculate function argument locations. This callback should fill retloc, all arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions. 
                
      :param fti: (func_type_data_t *) points to the func type info
      :returns: 0: not implemented
      :returns: 1: ok
      :returns: -1: error



   .. py:method:: ev_calc_varglocs(ftd: func_type_data_t, aux_regs: regobjs_t, aux_stkargs: relobj_t, nfixed: int) -> int

      Calculate locations of the arguments that correspond to '...'. 
                
      :param ftd: (func_type_data_t *), inout: info about all arguments (including varargs)
      :param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be nullptr
      :param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be nullptr
      :param nfixed: (int) number of fixed arguments
      :returns: 0: not implemented
      :returns: 1: ok
      :returns: -1: error On some platforms variadic calls require passing additional information: for example, number of floating variadic arguments must be passed in rax on gcc-x64. The locations and values that constitute this additional information are returned in the buffers pointed by aux_regs and aux_stkargs



   .. py:method:: ev_adjust_argloc(argloc: argloc_t, optional_type: tinfo_t, size: int) -> int

      Adjust argloc according to its type/size and platform endianess 
                
      :param argloc: (argloc_t *), inout
      :param size: (int) 'size' makes no sense if type != nullptr (type->get_size() should be used instead)
      :returns: 0: not implemented
      :returns: 1: ok
      :returns: -1: error



   .. py:method:: ev_lower_func_type(argnums: intvec_t *, fti: func_type_data_t) -> int

      Get function arguments which should be converted to pointers when lowering function prototype. The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. 
                
      :param argnums: (intvec_t *), out - numbers of arguments to be converted to pointers in acsending order
      :param fti: (func_type_data_t *), inout func type details
      :returns: 0: not implemented
      :returns: 1: argnums was filled
      :returns: 2: argnums was filled and made substantial changes to fti argnums[0] can contain a special negative value indicating that the return value should be passed as a hidden 'retstr' argument: -1 this argument is passed as the first one and the function returns a pointer to the argument, -2 this argument is passed as the last one and the function returns a pointer to the argument, -3 this argument is passed as the first one and the function returns 'void'.



   .. py:method:: ev_equal_reglocs(a1: argloc_t, a2: argloc_t) -> int

      Are 2 register arglocs the same?. We need this callback for the pc module. 
                
      :param a1: (argloc_t *)
      :param a2: (argloc_t *)
      :returns: 1: yes
      :returns: -1: no
      :returns: 0: not implemented



   .. py:method:: ev_use_stkarg_type(ea: ida_idaapi.ea_t, arg: funcarg_t) -> int

      Use information about a stack argument. 
                
      :param ea: (::ea_t) address of the push instruction which pushes the function argument into the stack
      :param arg: (const funcarg_t *) argument info
      :returns: 1: ok
      :returns: <=0: failed, the kernel will create a comment with the argument name or type for the instruction



   .. py:method:: ev_use_regarg_type(ea: ida_idaapi.ea_t, rargs: funcargvec_t const *) -> PyObject *

      Use information about register argument. 
                
      :param ea: (::ea_t) address of the instruction
      :param rargs: (const funcargvec_t *) vector of register arguments (including regs extracted from scattered arguments)
      :returns: 1: 
      :returns: 0: not implemented



   .. py:method:: ev_use_arg_types(ea: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t *) -> int

      Use information about callee arguments. 
                
      :param ea: (::ea_t) address of the call instruction
      :param fti: (func_type_data_t *) info about function type
      :param rargs: (funcargvec_t *) array of register arguments
      :returns: 1: (and removes handled arguments from fti and rargs)
      :returns: 0: not implemented



   .. py:method:: ev_arg_addrs_ready(caller: ida_idaapi.ea_t, n: int, tif: tinfo_t, addrs: ea_t *) -> int

      Argument address info is ready. 
                
      :param caller: (::ea_t)
      :param n: (int) number of formal arguments
      :param tif: (tinfo_t *) call prototype
      :param addrs: (::ea_t *) argument intilization addresses
      :returns: <0: do not save into idb; other values mean "ok to save"



   .. py:method:: ev_decorate_name(name: str, mangle: bool, cc: int, optional_type: tinfo_t) -> PyObject *

      Decorate/undecorate a C symbol name. 
                
      :param name: (const char *) name of symbol
      :param mangle: (bool) true-mangle, false-unmangle
      :param cc: (::callcnv_t) calling convention
      :returns: 1: if success
      :returns: 0: not implemented or failed



   .. py:method:: ev_arch_changed() -> int

      The loader is done parsing arch-related information, which the processor module might want to use to finish its initialization. 
                
      :returns: 1: if success
      :returns: 0: not implemented or failed



   .. py:method:: ev_get_stkarg_area_info(out: stkarg_area_info_t, cc: callcnv_t) -> int

      Get some metrics of the stack argument area. 
                
      :param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
      :param cc: (::callcnv_t) calling convention
      :returns: 1: if success
      :returns: 0: not implemented



   .. py:method:: ev_last_cb_before_loader() -> int


   .. py:method:: ev_loader() -> int

      This code and higher ones are reserved for the loaders. The arguments and the return values are defined by the loaders 
                



.. py:function:: get_idp_notifier_addr(arg1: PyObject *) -> PyObject *

.. py:function:: get_idp_notifier_ud_addr(hooks: IDP_Hooks) -> PyObject *

.. py:function:: delay_slot_insn(ea: ea_t *, bexec: bool *, fexec: bool *) -> bool

.. py:function:: get_reg_info(regname: str, bitrange: bitrange_t) -> str

.. py:function:: sizeof_ldbl() -> size_t

.. py:data:: REAL_ERROR_FORMAT
   :value: -1


.. py:data:: REAL_ERROR_RANGE
   :value: -2


.. py:data:: REAL_ERROR_BADDATA
   :value: -3


.. py:data:: IDPOPT_STR
   :value: 1


.. py:data:: IDPOPT_NUM
   :value: 2


.. py:data:: IDPOPT_BIT
   :value: 3


.. py:data:: IDPOPT_FLT
   :value: 4


.. py:data:: IDPOPT_I64
   :value: 5


.. py:data:: IDPOPT_OK
   :value: 0


.. py:data:: IDPOPT_BADKEY
   :value: 1


.. py:data:: IDPOPT_BADTYPE
   :value: 2


.. py:data:: IDPOPT_BADVALUE
   :value: 3


.. py:class:: processor_t

   Bases: :py:obj:`IDP_Hooks`


   .. py:attribute:: idb_hooks


   .. py:method:: get_idpdesc()

      This function must be present and should return the list of
      short processor names similar to the one in ph.psnames.
      This method can be overridden to return to the kernel a different IDP description.



   .. py:method:: get_auxpref(insn)

      This function returns insn.auxpref value



   .. py:method:: ev_newprc(*args)

      Before changing processor type. 
                
      :param pnum: (int) processor number in the array of processor names
      :param keep_cfg: (bool) true: do not modify kernel configuration
      :returns: 1: ok
      :returns: <0: prohibit



   .. py:method:: ev_newfile(*args)

      A new file has been loaded. 
                
      :param fname: (char *) input file name



   .. py:method:: ev_oldfile(*args)

      An old file has been loaded. 
                
      :param fname: (char *) input file name



   .. py:method:: ev_newbinary(*args)

      IDA is about to load a binary file. 
                
      :param filename: (char *) binary file name
      :param fileoff: (qoff64_t) offset in the file
      :param basepara: (::ea_t) base loading paragraph
      :param binoff: (::ea_t) loader offset
      :param nbytes: (::uint64) number of bytes to load



   .. py:method:: ev_endbinary(*args)

      IDA has loaded a binary file. 
                
      :param ok: (bool) file loaded successfully?



   .. py:method:: ev_set_idp_options(keyword, value_type, value, idb_loaded)

      Set IDP-specific configuration option Also see set_options_t in config.hpp 
                
      :param keyword: (const char *)
      :param value_type: (int)
      :param value: (const void *)
      :param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been generated
      :returns: 1: ok
      :returns: 0: not implemented
      :returns: -1: error (and message in errbuf)



   .. py:method:: ev_set_proc_options(*args)

      Called if the user specified an option string in the command line: -p<processor name>:<options>. Can be used for setting a processor subtype. Also called if option string is passed to set_processor_type() and IDC's SetProcessorType(). 
                
      :param options: (const char *)
      :param confidence: (int) 0: loader's suggestion 1: user's decision
      :returns: <0: if bad option string



   .. py:method:: ev_ana_insn(*args)

      Analyze one instruction and fill 'out' structure. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. insn_t::ea contains address of instruction to analyze. 
                
      :param out: (insn_t *)
      :returns: length of the instruction in bytes, 0 if instruction can't be decoded.
      :returns: 0: if instruction can't be decoded.



   .. py:method:: ev_emu_insn(*args)

      Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. Upon entrance to this function, all information about the instruction is in 'insn' structure. 
                
      :param insn: (const insn_t *)
      :returns: 1: ok
      :returns: -1: the kernel will delete the instruction



   .. py:method:: ev_out_header(*args)

      Function to produce start of disassembled text 
                
      :param outctx: (outctx_t *)
      :returns: void: 



   .. py:method:: ev_out_footer(*args)

      Function to produce end of disassembled text 
                
      :param outctx: (outctx_t *)
      :returns: void: 



   .. py:method:: ev_out_segstart(ctx, s)

      Function to produce start of segment 
                
      :param outctx: (outctx_t *)
      :param seg: (segment_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_segend(ctx, s)

      Function to produce end of segment 
                
      :param outctx: (outctx_t *)
      :param seg: (segment_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_assumes(*args)

      Function to produce assume directives when segment register value changes. 
                
      :param outctx: (outctx_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_insn(*args)

      Generate text representation of an instruction in 'ctx.insn' outctx_t provides functions to output the generated text. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. 
                
      :param outctx: (outctx_t *)
      :returns: void: 



   .. py:method:: ev_out_mnem(*args)

      Generate instruction mnemonics. This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. 
                
      :param outctx: (outctx_t *)
      :returns: 1: if appended the mnemonics
      :returns: 0: not implemented



   .. py:method:: ev_out_operand(*args)

      Generate text representation of an instruction operand outctx_t provides functions to output the generated text. All these actions should be performed only by emu_insn() function. 
                
      :param outctx: (outctx_t *)
      :param op: (const op_t *)
      :returns: 1: ok
      :returns: -1: operand is hidden



   .. py:method:: ev_out_data(*args)

      Generate text representation of data items This function may change the database and create cross-references if analyze_only is set 
                
      :param outctx: (outctx_t *)
      :param analyze_only: (bool)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_out_label(*args)

      The kernel is going to generate an instruction label line or a function header. 
                
      :param outctx: (outctx_t *)
      :param colored_name: (const char *)
      :returns: <0: if the kernel should not generate the label
      :returns: 0: not implemented or continue



   .. py:method:: ev_out_special_item(*args)

      Generate text representation of an item in a special segment i.e. absolute symbols, externs, communal definitions etc 
                
      :param outctx: (outctx_t *)
      :param segtype: (uchar)
      :returns: 1: ok
      :returns: 0: not implemented
      :returns: -1: overflow



   .. py:method:: ev_gen_regvar_def(ctx, v)

      Generate register variable definition line. 
                
      :param outctx: (outctx_t *)
      :param v: (regvar_t *)
      :returns: >0: ok, generated the definition text
      :returns: 0: not implemented



   .. py:method:: ev_gen_src_file_lnnum(*args)

      Callback: generate analog of: 
           #line  123
          


                
      :param outctx: (outctx_t *) output context
      :param file: (const char *) source file (may be nullptr)
      :param lnnum: (size_t) line number
      :returns: 1: directive has been generated
      :returns: 0: not implemented



   .. py:method:: ev_creating_segm(s)

      A new segment is about to be created. 
                
      :param seg: (segment_t *)
      :returns: 1: ok
      :returns: <0: segment should not be created



   .. py:method:: ev_moving_segm(s, to_ea, flags)

      May the kernel move the segment? 
                
      :param seg: (segment_t *) segment to move
      :param to: (::ea_t) new segment start address
      :param flags: (int) combination of Move segment flags
      :returns: 0: yes
      :returns: <0: the kernel should stop



   .. py:method:: ev_coagulate(*args)

      Try to define some unexplored bytes. This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. 
                
      :param start_ea: (::ea_t)
      :returns: number of converted bytes



   .. py:method:: ev_undefine(*args)

      An item in the database (insn or data) is being deleted. 
                
      :param ea: (ea_t)
      :returns: 1: do not delete srranges at the item end
      :returns: 0: srranges can be deleted



   .. py:method:: ev_treat_hindering_item(*args)

      An item hinders creation of another item. 
                
      :param hindering_item_ea: (::ea_t)
      :param new_item_flags: (flags64_t) (0 for code)
      :param new_item_ea: (::ea_t)
      :param new_item_length: (::asize_t)
      :returns: 0: no reaction
      :returns: !=0: the kernel may delete the hindering item



   .. py:method:: ev_rename(*args)

      The kernel is going to rename a byte. 
                
      :param ea: (::ea_t)
      :param new_name: (const char *)
      :returns: <0: if the kernel should not rename it.
      :returns: 2: to inhibit the notification. I.e., the kernel should not rename, but 'set_name()' should return 'true'. also see renamed the return value is ignored when kernel is going to delete name



   .. py:method:: ev_is_far_jump(*args)

      is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types 
                
      :param icode: (int)
      :returns: 0: not implemented
      :returns: 1: yes
      :returns: -1: no



   .. py:method:: ev_is_sane_insn(*args)

      Is the instruction sane for the current file type?. 
                
      :param insn: (const insn_t*) the instruction
      :param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason.
      :returns: >=0: ok
      :returns: <0: no, the instruction isn't likely to appear in the program



   .. py:method:: ev_is_call_insn(*args)

      Is the instruction a "call"? 
                
      :param insn: (const insn_t *) instruction
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_is_ret_insn(*args)

      Is the instruction a "return"? 
                
      :param insn: (const insn_t *) instruction
      :param flags: (uchar), combination of IRI_... flags (see above)
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_may_be_func(*args)

      Can a function start here? 
                
      :param insn: (const insn_t*) the instruction
      :param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
      :returns: probability 1..100



   .. py:method:: ev_is_basic_block_end(*args)

      Is the current instruction end of a basic block?. This function should be defined for processors with delayed jump slots. 
                
      :param insn: (const insn_t*) the instruction
      :param call_insn_stops_block: (bool)
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_is_indirect_jump(*args)

      Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all jump types jumps, please define this callback. 
                
      :param insn: (const insn_t*) the instruction
      :returns: 0: use CF_JUMP
      :returns: 1: no
      :returns: 2: yes



   .. py:method:: ev_is_insn_table_jump(*args)

      Reserved.



   .. py:method:: ev_is_switch(*args)

      Find 'switch' idiom or override processor module's decision. It will be called for instructions marked with CF_JUMP. 
                
      :param si: (switch_info_t *), out
      :param insn: (const insn_t *) instruction possibly belonging to a switch
      :returns: 1: switch is found, 'si' is filled. IDA will create the switch using the filled 'si'
      :returns: -1: no switch found. This value forbids switch creation by the processor module
      :returns: 0: not implemented



   .. py:method:: ev_create_switch_xrefs(*args)

      Create xrefs for a custom jump table. 
                
      :param jumpea: (::ea_t) address of the jump insn
      :param si: (const switch_info_t *) switch information
      :returns: must return 1 Must be implemented if module uses custom jump tables, SWI_CUSTOM



   .. py:method:: ev_is_align_insn(*args)

      Is the instruction created only for alignment purposes?. Do not directly call this function, use is_align_insn() 
                
      :param ea: (ea_t) - instruction address
      :returns: number: of bytes in the instruction



   .. py:method:: ev_is_alloca_probe(*args)

      Does the function at 'ea' behave as __alloca_probe? 
                
      :param ea: (::ea_t)
      :returns: 1: yes
      :returns: 0: no



   .. py:method:: ev_is_sp_based(mode, insn, op)

      Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. Implement this event only if some stack references use frame pointer instead of stack pointer. 
                
      :param mode: (int *) out, combination of SP/FP operand flags
      :param insn: (const insn_t *)
      :param op: (const op_t *)
      :returns: 0: not implemented
      :returns: 1: ok



   .. py:method:: ev_can_have_type(*args)

      Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. see bytes.hpp for information about types and flags) 
                
      :param op: (const op_t *)
      :returns: 0: unknown
      :returns: <0: no
      :returns: 1: yes



   .. py:method:: ev_cmp_operands(*args)

      Compare instruction operands 
                
      :param op1: (const op_t*)
      :param op2: (const op_t*)
      :returns: 1: equal
      :returns: -1: not equal
      :returns: 0: not implemented



   .. py:method:: ev_get_operand_string(buf, insn, opnum)

      Request text string for operand (cli, java, ...). 
                
      :param insn: (const insn_t*) the instruction
      :param opnum: (int) operand number, -1 means any string operand
      :returns: 0: no string (or empty string)
      :returns: >0: original string length without terminating zero



   .. py:method:: ev_str2reg(*args)

      Convert a register name to a register number. The register number is the register index in the processor_t::reg_names array Most processor modules do not need to implement this callback It is useful only if processor_t::reg_names[reg] does not provide the correct register names 
                
      :param regname: (const char *)
      :returns: register: number + 1
      :returns: 0: not implemented or could not be decoded



   .. py:method:: ev_get_autocmt(*args)

      Callback: get dynamic auto comment. Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. 
                
      :param insn: (const insn_t*) the instruction
      :returns: 1: new comment has been generated
      :returns: 0: callback has not been handled. the buffer must not be changed in this case



   .. py:method:: ev_func_bounds(_possible_return_code, pfn, max_func_end_ea)

      find_func_bounds() finished its work. The module may fine tune the function bounds 
                
      :param possible_return_code: (int *), in/out
      :param pfn: (func_t *)
      :param max_func_end_ea: (::ea_t) (from the kernel's point of view)
      :returns: void: 



   .. py:method:: ev_verify_sp(pfn)

      All function instructions have been analyzed. Now the processor module can analyze the stack pointer for the whole function 
                
      :param pfn: (func_t *)
      :returns: 0: ok
      :returns: <0: bad stack pointer



   .. py:method:: ev_verify_noreturn(pfn)

      The kernel wants to set 'noreturn' flags for a function. 
                
      :param pfn: (func_t *)
      :returns: 0: ok. any other value: do not set 'noreturn' flag



   .. py:method:: ev_create_func_frame(pfn)

      Create a function frame for a newly created function Set up frame size, its attributes etc 
                
      :param pfn: (func_t *)
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_get_frame_retsize(frsize, pfn)

      Get size of function return address in bytes If this event is not implemented, the kernel will assume
      * 8 bytes for 64-bit function
      * 4 bytes for 32-bit function
      * 2 bytes otherwise



      :param frsize: (int *) frame size (out)
      :param pfn: (const func_t *), can't be nullptr
      :returns: 1: ok
      :returns: 0: not implemented



   .. py:method:: ev_coagulate_dref(from_ea, to_ea, may_define, _code_ea)

      Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) 
                
      :param to: (::ea_t)
      :param may_define: (bool)
      :param code_ea: (::ea_t *)
      :returns: <0: failed dref analysis, >0 done dref analysis
      :returns: 0: not implemented or continue



   .. py:method:: ev_may_show_sreg(*args)

      The kernel wants to display the segment registers in the messages window. 
                
      :param current_ea: (::ea_t)
      :returns: <0: if the kernel should not show the segment registers. (assuming that the module has done it)
      :returns: 0: not implemented



   .. py:method:: ev_auto_queue_empty(*args)

      One analysis queue is empty. 
                
      :param type: (atype_t)
      :returns: void: see also idb_event::auto_empty_finally



   .. py:method:: ev_validate_flirt_func(*args)

      Flirt has recognized a library function. This callback can be used by a plugin or proc module to intercept it and validate such a function. 
                
      :param start_ea: (::ea_t)
      :param funcname: (const char *)
      :returns: -1: do not create a function,
      :returns: 0: function is validated



   .. py:method:: ev_assemble(*args)

      Assemble an instruction. (display a warning if an error is found). 
                
      :param ea: (::ea_t) linear address of instruction
      :param cs: (::ea_t) cs of instruction
      :param ip: (::ea_t) ip of instruction
      :param use32: (bool) is 32bit segment?
      :param line: (const char *) line to assemble
      :returns: size of the instruction in bytes



   .. py:method:: ev_gen_map_file(nlines, fp)

      Generate map file. If not implemented the kernel itself will create the map file. 
                
      :param nlines: (int *) number of lines in map file (-1 means write error)
      :param fp: (FILE *) output file
      :returns: 0: not implemented
      :returns: 1: ok
      :returns: -1: write error



   .. py:method:: ev_calc_step_over(target, ip)

      Calculate the address of the instruction which will be executed after "step over". The kernel will put a breakpoint there. If the step over is equal to step into or we cannot calculate the address, return BADADDR. 
                
      :param target: (::ea_t *) pointer to the answer
      :param ip: (::ea_t) instruction address
      :returns: 0: unimplemented
      :returns: 1: implemented



   .. py:method:: closebase(*args)


   .. py:method:: savebase(*args)


   .. py:method:: auto_empty(*args)


   .. py:method:: auto_empty_finally(*args)


   .. py:method:: determined_main(*args)


   .. py:method:: idasgn_loaded(*args)


   .. py:method:: kernel_config_loaded(*args)


   .. py:method:: compiler_changed(*args)


   .. py:method:: segm_moved(from_ea, to_ea, size, changed_netmap)


   .. py:method:: func_added(pfn)


   .. py:method:: set_func_start(*args)


   .. py:method:: set_func_end(*args)


   .. py:method:: deleting_func(pfn)


   .. py:method:: sgr_changed(*args)


   .. py:method:: make_code(*args)


   .. py:method:: make_data(*args)


   .. py:method:: renamed(*args)


.. py:function:: str2sreg(name: str)

   get segment register number from its name or -1


.. py:data:: ph

.. py:class:: IDB_Hooks(_flags: int = 0, _hkcb_flags: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: hook() -> bool


   .. py:method:: unhook() -> bool


   .. py:method:: closebase() -> None

      The database will be closed now.



   .. py:method:: savebase() -> None

      The database is being saved.



   .. py:method:: upgraded(_from: int) -> None

      The database has been upgraded and the receiver can upgrade its info as well 
                



   .. py:method:: auto_empty() -> None

      Info: all analysis queues are empty. This callback is called once when the initial analysis is finished. If the queue is not empty upon the return from this callback, it will be called later again. 
                



   .. py:method:: auto_empty_finally() -> None

      Info: all analysis queues are empty definitively. This callback is called only once. 
                



   .. py:method:: determined_main(main: ida_idaapi.ea_t) -> None

      The main() function has been determined. 
                
      :param main: (::ea_t) address of the main() function



   .. py:method:: extlang_changed(kind: int, el: extlang_t *, idx: int) -> None

      The list of extlangs or the default extlang was changed. 
                
      :param kind: (int) 0: extlang installed 1: extlang removed 2: default extlang changed
      :param el: (extlang_t *) pointer to the extlang affected
      :param idx: (int) extlang index



   .. py:method:: idasgn_loaded(short_sig_name: str) -> None

      FLIRT signature has been loaded for normal processing (not for recognition of startup sequences). 
                
      :param short_sig_name: (const char *)



   .. py:method:: kernel_config_loaded(pass_number: int) -> None

      This event is issued when ida.cfg is parsed. 
                
      :param pass_number: (int)



   .. py:method:: loader_finished(li: linput_t *, neflags: uint16, filetypename: str) -> None

      External file loader finished its work. Use this event to augment the existing loader functionality. 
                
      :param li: (linput_t *)
      :param neflags: (uint16) Load file flags
      :param filetypename: (const char *)



   .. py:method:: flow_chart_created(fc: qflow_chart_t) -> None

      Gui has retrieved a function flow chart. Plugins may modify the flow chart in this callback. 
                
      :param fc: (qflow_chart_t *)



   .. py:method:: compiler_changed(adjust_inf_fields: bool) -> None

      The kernel has changed the compiler information. ( idainfo::cc structure; get_abi_name) 
                
      :param adjust_inf_fields: (::bool) may change inf fields?



   .. py:method:: changing_ti(ea: ida_idaapi.ea_t, new_type: type_t const *, new_fnames: p_list const *) -> None

      An item typestring (c/c++ prototype) is to be changed. 
                
      :param ea: (::ea_t)
      :param new_type: (const type_t *)
      :param new_fnames: (const p_list *)



   .. py:method:: ti_changed(ea: ida_idaapi.ea_t, type: type_t const *, fnames: p_list const *) -> None

      An item typestring (c/c++ prototype) has been changed. 
                
      :param ea: (::ea_t)
      :param type: (const type_t *)
      :param fnames: (const p_list *)



   .. py:method:: changing_op_ti(ea: ida_idaapi.ea_t, n: int, new_type: type_t const *, new_fnames: p_list const *) -> None

      An operand typestring (c/c++ prototype) is to be changed. 
                
      :param ea: (::ea_t)
      :param n: (int)
      :param new_type: (const type_t *)
      :param new_fnames: (const p_list *)



   .. py:method:: op_ti_changed(ea: ida_idaapi.ea_t, n: int, type: type_t const *, fnames: p_list const *) -> None

      An operand typestring (c/c++ prototype) has been changed. 
                
      :param ea: (::ea_t)
      :param n: (int)
      :param type: (const type_t *)
      :param fnames: (const p_list *)



   .. py:method:: changing_op_type(ea: ida_idaapi.ea_t, n: int, opinfo: opinfo_t) -> None

      An operand type (offset, hex, etc...) is to be changed. 
                
      :param ea: (::ea_t)
      :param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
      :param opinfo: (const opinfo_t *) additional operand info



   .. py:method:: op_type_changed(ea: ida_idaapi.ea_t, n: int) -> None

      An operand type (offset, hex, etc...) has been set or deleted. 
                
      :param ea: (::ea_t)
      :param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL



   .. py:method:: segm_added(s: segment_t *) -> None

      A new segment has been created. 
                
      :param s: (segment_t *) See also adding_segm



   .. py:method:: deleting_segm(start_ea: ida_idaapi.ea_t) -> None

      A segment is to be deleted. 
                
      :param start_ea: (::ea_t)



   .. py:method:: segm_deleted(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, flags: int) -> None

      A segment has been deleted. 
                
      :param start_ea: (::ea_t)
      :param end_ea: (::ea_t)
      :param flags: (int)



   .. py:method:: changing_segm_start(s: segment_t *, new_start: ida_idaapi.ea_t, segmod_flags: int) -> None

      Segment start address is to be changed. 
                
      :param s: (segment_t *)
      :param new_start: (::ea_t)
      :param segmod_flags: (int)



   .. py:method:: segm_start_changed(s: segment_t *, oldstart: ida_idaapi.ea_t) -> None

      Segment start address has been changed. 
                
      :param s: (segment_t *)
      :param oldstart: (::ea_t)



   .. py:method:: changing_segm_end(s: segment_t *, new_end: ida_idaapi.ea_t, segmod_flags: int) -> None

      Segment end address is to be changed. 
                
      :param s: (segment_t *)
      :param new_end: (::ea_t)
      :param segmod_flags: (int)



   .. py:method:: segm_end_changed(s: segment_t *, oldend: ida_idaapi.ea_t) -> None

      Segment end address has been changed. 
                
      :param s: (segment_t *)
      :param oldend: (::ea_t)



   .. py:method:: changing_segm_name(s: segment_t *, oldname: str) -> None

      Segment name is being changed. 
                
      :param s: (segment_t *)
      :param oldname: (const char *)



   .. py:method:: segm_name_changed(s: segment_t *, name: str) -> None

      Segment name has been changed. 
                
      :param s: (segment_t *)
      :param name: (const char *)



   .. py:method:: changing_segm_class(s: segment_t *) -> None

      Segment class is being changed. 
                
      :param s: (segment_t *)



   .. py:method:: segm_class_changed(s: segment_t *, sclass: str) -> None

      Segment class has been changed. 
                
      :param s: (segment_t *)
      :param sclass: (const char *)



   .. py:method:: segm_attrs_updated(s: segment_t *) -> None

      Segment attributes has been changed. 
                
      :param s: (segment_t *) This event is generated for secondary segment attributes (examples: color, permissions, etc)



   .. py:method:: segm_moved(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: asize_t, changed_netmap: bool) -> None

      Segment has been moved. 
                
      :param to: (::ea_t)
      :param size: (::asize_t)
      :param changed_netmap: (bool) See also idb_event::allsegs_moved



   .. py:method:: allsegs_moved(info: segm_move_infos_t *) -> None

      Program rebasing is complete. This event is generated after series of segm_moved events 
                
      :param info: (segm_move_infos_t *)



   .. py:method:: func_added(pfn: func_t *) -> None

      The kernel has added a function. 
                
      :param pfn: (func_t *)



   .. py:method:: func_updated(pfn: func_t *) -> None

      The kernel has updated a function. 
                
      :param pfn: (func_t *)



   .. py:method:: set_func_start(pfn: func_t *, new_start: ida_idaapi.ea_t) -> None

      Function chunk start address will be changed. 
                
      :param pfn: (func_t *)
      :param new_start: (::ea_t)



   .. py:method:: set_func_end(pfn: func_t *, new_end: ida_idaapi.ea_t) -> None

      Function chunk end address will be changed. 
                
      :param pfn: (func_t *)
      :param new_end: (::ea_t)



   .. py:method:: deleting_func(pfn: func_t *) -> None

      The kernel is about to delete a function. 
                
      :param pfn: (func_t *)



   .. py:method:: frame_deleted(pfn: func_t *) -> None

      The kernel has deleted a function frame. 
                
      :param pfn: (func_t *) idb_event::frame_created



   .. py:method:: thunk_func_created(pfn: func_t *) -> None

      A thunk bit has been set for a function. 
                
      :param pfn: (func_t *)



   .. py:method:: func_tail_appended(pfn: func_t *, tail: func_t *) -> None

      A function tail chunk has been appended. 
                
      :param pfn: (func_t *)
      :param tail: (func_t *)



   .. py:method:: deleting_func_tail(pfn: func_t *, tail: range_t) -> None

      A function tail chunk is to be removed. 
                
      :param pfn: (func_t *)
      :param tail: (const range_t *)



   .. py:method:: func_tail_deleted(pfn: func_t *, tail_ea: ida_idaapi.ea_t) -> None

      A function tail chunk has been removed. 
                
      :param pfn: (func_t *)
      :param tail_ea: (::ea_t)



   .. py:method:: tail_owner_changed(tail: func_t *, owner_func: ida_idaapi.ea_t, old_owner: ida_idaapi.ea_t) -> None

      A tail chunk owner has been changed. 
                
      :param tail: (func_t *)
      :param owner_func: (::ea_t)
      :param old_owner: (::ea_t)



   .. py:method:: func_noret_changed(pfn: func_t *) -> None

      FUNC_NORET bit has been changed. 
                
      :param pfn: (func_t *)



   .. py:method:: stkpnts_changed(pfn: func_t *) -> None

      Stack change points have been modified. 
                
      :param pfn: (func_t *)



   .. py:method:: updating_tryblks(tbv: tryblks_t const *) -> None

      About to update tryblk information 
                
      :param tbv: (const ::tryblks_t *)



   .. py:method:: tryblks_updated(tbv: tryblks_t const *) -> None

      Updated tryblk information 
                
      :param tbv: (const ::tryblks_t *)



   .. py:method:: deleting_tryblks(range: range_t) -> None

      About to delete tryblk information in given range 
                
      :param range: (const range_t *)



   .. py:method:: sgr_changed(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regnum: int, value: sel_t, old_value: sel_t, tag: uchar) -> None

      The kernel has changed a segment register value. 
                
      :param start_ea: (::ea_t)
      :param end_ea: (::ea_t)
      :param regnum: (int)
      :param value: (::sel_t)
      :param old_value: (::sel_t)
      :param tag: (uchar) Segment register range tags



   .. py:method:: make_code(insn: insn_t const *) -> None

      An instruction is being created. 
                
      :param insn: (const insn_t*)



   .. py:method:: make_data(ea: ida_idaapi.ea_t, flags: flags64_t, tid: tid_t, len: asize_t) -> None

      A data item is being created. 
                
      :param ea: (::ea_t)
      :param flags: (flags64_t)
      :param tid: (tid_t)
      :param len: (::asize_t)



   .. py:method:: destroyed_items(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, will_disable_range: bool) -> None

      Instructions/data have been destroyed in [ea1,ea2). 
                
      :param ea1: (::ea_t)
      :param ea2: (::ea_t)
      :param will_disable_range: (bool)



   .. py:method:: renamed(ea: ida_idaapi.ea_t, new_name: str, local_name: bool, old_name: str) -> None

      The kernel has renamed a byte. See also the rename event 
                
      :param ea: (::ea_t)
      :param new_name: (const char *) can be nullptr
      :param local_name: (bool)
      :param old_name: (const char *) can be nullptr



   .. py:method:: byte_patched(ea: ida_idaapi.ea_t, old_value: int) -> None

      A byte has been patched. 
                
      :param ea: (::ea_t)
      :param old_value: (uint32)



   .. py:method:: changing_cmt(ea: ida_idaapi.ea_t, repeatable_cmt: bool, newcmt: str) -> None

      An item comment is to be changed. 
                
      :param ea: (::ea_t)
      :param repeatable_cmt: (bool)
      :param newcmt: (const char *)



   .. py:method:: cmt_changed(ea: ida_idaapi.ea_t, repeatable_cmt: bool) -> None

      An item comment has been changed. 
                
      :param ea: (::ea_t)
      :param repeatable_cmt: (bool)



   .. py:method:: changing_range_cmt(kind: range_kind_t, a: range_t, cmt: str, repeatable: bool) -> None

      Range comment is to be changed. 
                
      :param kind: (range_kind_t)
      :param a: (const range_t *)
      :param cmt: (const char *)
      :param repeatable: (bool)



   .. py:method:: range_cmt_changed(kind: range_kind_t, a: range_t, cmt: str, repeatable: bool) -> None

      Range comment has been changed. 
                
      :param kind: (range_kind_t)
      :param a: (const range_t *)
      :param cmt: (const char *)
      :param repeatable: (bool)



   .. py:method:: extra_cmt_changed(ea: ida_idaapi.ea_t, line_idx: int, cmt: str) -> None

      An extra comment has been changed. 
                
      :param ea: (::ea_t)
      :param line_idx: (int)
      :param cmt: (const char *)



   .. py:method:: item_color_changed(ea: ida_idaapi.ea_t, color: bgcolor_t) -> None

      An item color has been changed. 
                
      :param ea: (::ea_t)
      :param color: (bgcolor_t) if color==DEFCOLOR, the the color is deleted.



   .. py:method:: callee_addr_changed(ea: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None

      Callee address has been updated by the user. 
                
      :param ea: (::ea_t)
      :param callee: (::ea_t)



   .. py:method:: bookmark_changed(index: int, pos: lochist_entry_t const *, desc: str, operation: int) -> None

      Boomarked position changed. 
                
      :param index: (uint32)
      :param pos: (::const lochist_entry_t *)
      :param desc: (::const char *)
      :param operation: (int) 0-added, 1-updated, 2-deleted if desc==nullptr, then the bookmark was deleted.



   .. py:method:: sgr_deleted(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regnum: int) -> None

      The kernel has deleted a segment register value. 
                
      :param start_ea: (::ea_t)
      :param end_ea: (::ea_t)
      :param regnum: (int)



   .. py:method:: adding_segm(s: segment_t *) -> None

      A segment is being created. 
                
      :param s: (segment_t *)



   .. py:method:: func_deleted(func_ea: ida_idaapi.ea_t) -> None

      A function has been deleted. 
                
      :param func_ea: (::ea_t)



   .. py:method:: dirtree_mkdir(dt: dirtree_t *, path: str) -> None

      Dirtree: a directory has been created. 
                
      :param dt: (dirtree_t *)
      :param path: (::const char *)



   .. py:method:: dirtree_rmdir(dt: dirtree_t *, path: str) -> None

      Dirtree: a directory has been deleted. 
                
      :param dt: (dirtree_t *)
      :param path: (::const char *)



   .. py:method:: dirtree_link(dt: dirtree_t *, path: str, link: bool) -> None

      Dirtree: an item has been linked/unlinked. 
                
      :param dt: (dirtree_t *)
      :param path: (::const char *)
      :param link: (::bool)



   .. py:method:: dirtree_move(dt: dirtree_t *, _from: str, to: str) -> None

      Dirtree: a directory or item has been moved. 
                
      :param dt: (dirtree_t *)
      :param to: (::const char *)



   .. py:method:: dirtree_rank(dt: dirtree_t *, path: str, rank: size_t) -> None

      Dirtree: a directory or item rank has been changed. 
                
      :param dt: (dirtree_t *)
      :param path: (::const char *)
      :param rank: (::size_t)



   .. py:method:: dirtree_rminode(dt: dirtree_t *, inode: inode_t) -> None

      Dirtree: an inode became unavailable. 
                
      :param dt: (dirtree_t *)
      :param inode: (inode_t)



   .. py:method:: dirtree_segm_moved(dt: dirtree_t *) -> None

      Dirtree: inodes were changed due to a segment movement or a program rebasing 
                
      :param dt: (dirtree_t *)



   .. py:method:: local_types_changed(ltc: local_type_change_t, ordinal: int, name: str) -> None

      Local types have been changed 
                
      :param ltc: (local_type_change_t)
      :param ordinal: (uint32) 0 means ordinal is unknown
      :param name: (const char *) nullptr means name is unknown



   .. py:method:: lt_udm_created(udtname: str, udm: udm_t) -> None

      local type udt member has been added 
                
      :param udtname: (::const char *)
      :param udm: (::const udm_t *)



   .. py:method:: lt_udm_deleted(udtname: str, udm_tid: tid_t, udm: udm_t) -> None

      local type udt member has been deleted 
                
      :param udtname: (::const char *)
      :param udm_tid: (tid_t)
      :param udm: (::const udm_t *)



   .. py:method:: lt_udm_renamed(udtname: str, udm: udm_t, oldname: str) -> None

      local type udt member has been renamed 
                
      :param udtname: (::const char *)
      :param udm: (::const udm_t *)
      :param oldname: (::const char *)



   .. py:method:: lt_udm_changed(udtname: str, udm_tid: tid_t, udmold: udm_t, udmnew: udm_t) -> None

      local type udt member has been changed 
                
      :param udtname: (::const char *)
      :param udm_tid: (tid_t)
      :param udmold: (::const udm_t *)
      :param udmnew: (::const udm_t *)



   .. py:method:: lt_udt_expanded(udtname: str, udm_tid: tid_t, delta: adiff_t) -> None

      A structure type has been expanded/shrank. 
                
      :param udtname: (::const char *)
      :param udm_tid: (tid_t) the gap was added/removed before this member
      :param delta: (::adiff_t) number of added/removed bytes



   .. py:method:: frame_created(func_ea: ida_idaapi.ea_t) -> None

      A function frame has been created. 
                
      :param func_ea: (::ea_t) idb_event::frame_deleted



   .. py:method:: frame_udm_created(func_ea: ida_idaapi.ea_t, udm: udm_t) -> None

      Frame member has been added. 
                
      :param func_ea: (::ea_t)
      :param udm: (::const udm_t *)



   .. py:method:: frame_udm_deleted(func_ea: ida_idaapi.ea_t, udm_tid: tid_t, udm: udm_t) -> None

      Frame member has been deleted. 
                
      :param func_ea: (::ea_t)
      :param udm_tid: (tid_t)
      :param udm: (::const udm_t *)



   .. py:method:: frame_udm_renamed(func_ea: ida_idaapi.ea_t, udm: udm_t, oldname: str) -> None

      Frame member has been renamed. 
                
      :param func_ea: (::ea_t)
      :param udm: (::const udm_t *)
      :param oldname: (::const char *)



   .. py:method:: frame_udm_changed(func_ea: ida_idaapi.ea_t, udm_tid: tid_t, udmold: udm_t, udmnew: udm_t) -> None

      Frame member has been changed. 
                
      :param func_ea: (::ea_t)
      :param udm_tid: (tid_t)
      :param udmold: (::const udm_t *)
      :param udmnew: (::const udm_t *)



   .. py:method:: frame_expanded(func_ea: ida_idaapi.ea_t, udm_tid: tid_t, delta: adiff_t) -> None

      A frame type has been expanded/shrank. 
                
      :param func_ea: (::ea_t)
      :param udm_tid: (tid_t) the gap was added/removed before this member
      :param delta: (::adiff_t) number of added/removed bytes



   .. py:method:: idasgn_matched_ea(ea: ida_idaapi.ea_t, name: str, lib_name: str) -> None

      A FLIRT match has been found 
                
      :param ea: (::ea_t) the matching address
      :param name: (::const char *) the matched name
      :param lib_name: (::const char *) library name extracted from signature file



   .. py:method:: lt_edm_created(enumname: str, edm: edm_t) -> None

      local type enum member has been added 
                
      :param enumname: (::const char *)
      :param edm: (::const edm_t *)



   .. py:method:: lt_edm_deleted(enumname: str, edm_tid: tid_t, edm: edm_t) -> None

      local type enum member has been deleted 
                
      :param enumname: (::const char *)
      :param edm_tid: (tid_t)
      :param edm: (::const edm_t *)



   .. py:method:: lt_edm_renamed(enumname: str, edm: edm_t, oldname: str) -> None

      local type enum member has been renamed 
                
      :param enumname: (::const char *)
      :param edm: (::const edm_t *)
      :param oldname: (::const char *)



   .. py:method:: lt_edm_changed(enumname: str, edm_tid: tid_t, edmold: edm_t, edmnew: edm_t) -> None

      local type enum member has been changed 
                
      :param enumname: (::const char *)
      :param edm_tid: (tid_t)
      :param edmold: (::const edm_t *)
      :param edmnew: (::const edm_t *)



   .. py:method:: local_type_renamed(ordinal: int, oldname: str, newname: str) -> None

      Local type has been renamed 
                
      :param ordinal: (uint32) 0 means ordinal is unknown
      :param oldname: (const char *) nullptr means name is unknown
      :param newname: (const char *) nullptr means name is unknown



.. py:function:: get_idb_notifier_addr(arg1: PyObject *) -> PyObject *

.. py:function:: get_idb_notifier_ud_addr(hooks: IDB_Hooks) -> PyObject *


```

`skills/idapython/docs/ida_ieee.md`:

```md
# ida_ieee

IEEE floating point conversion utilities.

## Key Classes/Functions

### fpvalue_t
IEEE floating point value representation (internal format)
- `from_str(p)` - parse from string
- `to_str(buf, bufsize, mode)` - convert to string
- `from_sval(x)` / `to_sval(round)` - convert to/from signed integer
- `from_int64(x)` / `to_int64(round)` - convert to/from 64-bit int
- `from_uint64(x)` / `to_uint64(round)` - convert to/from unsigned 64-bit
- `from_10bytes(fpval)` / `to_10bytes(fpval)` - 10-byte float conversions
- `from_12bytes(fpval)` / `to_12bytes(fpval)` - 12-byte float conversions
- `fadd(y)`, `fsub(y)`, `fmul(y)`, `fdiv(y)` - arithmetic operations
- `eabs()`, `negate()` - absolute value and negation
- `is_negative()` - check sign
- `get_kind()` - get value kind (FPV_NORM, FPV_NAN, FPV_PINF, FPV_NINF)

## Error Codes
- REAL_ERROR_OK, REAL_ERROR_FORMAT, REAL_ERROR_RANGE
- REAL_ERROR_BADDATA, REAL_ERROR_FPOVER, REAL_ERROR_BADSTR
- REAL_ERROR_ZERODIV, REAL_ERROR_INTOVER

## See Also
Full docs: skill/docs/ida_ieee.rst

```

`skills/idapython/docs/ida_ieee.rst`:

```rst
ida_ieee
========

.. py:module:: ida_ieee

.. autoapi-nested-parse::

   IEEE floating point functions.



Attributes
----------

.. autoapisummary::

   ida_ieee.FPVAL_NWORDS
   ida_ieee.FPV_BADARG
   ida_ieee.FPV_NORM
   ida_ieee.FPV_NAN
   ida_ieee.FPV_PINF
   ida_ieee.FPV_NINF
   ida_ieee.REAL_ERROR_OK
   ida_ieee.REAL_ERROR_FORMAT
   ida_ieee.REAL_ERROR_RANGE
   ida_ieee.REAL_ERROR_BADDATA
   ida_ieee.REAL_ERROR_FPOVER
   ida_ieee.REAL_ERROR_BADSTR
   ida_ieee.REAL_ERROR_ZERODIV
   ida_ieee.REAL_ERROR_INTOVER
   ida_ieee.cvar
   ida_ieee.MAXEXP_FLOAT
   ida_ieee.MAXEXP_DOUBLE
   ida_ieee.MAXEXP_LNGDBL
   ida_ieee.IEEE_EXONE
   ida_ieee.E_SPECIAL_EXP
   ida_ieee.IEEE_NI
   ida_ieee.IEEE_E
   ida_ieee.IEEE_M
   ida_ieee.EZERO
   ida_ieee.EONE
   ida_ieee.ETWO


Classes
-------

.. autoapisummary::

   ida_ieee.fpvalue_shorts_array_t
   ida_ieee.fpvalue_t


Functions
---------

.. autoapisummary::

   ida_ieee.ecleaz


Module Contents
---------------

.. py:class:: fpvalue_shorts_array_t(data: unsigned short (&)[FPVAL_NWORDS])

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  unsigned short (&)[FPVAL_NWORDS]


   .. py:attribute:: bytes


.. py:data:: FPVAL_NWORDS

   number of words in fpvalue_t


.. py:data:: FPV_BADARG

   wrong value of max_exp


.. py:data:: FPV_NORM

   regular value


.. py:data:: FPV_NAN

   NaN.


.. py:data:: FPV_PINF

   positive infinity


.. py:data:: FPV_NINF

   negative infinity


.. py:data:: REAL_ERROR_OK

   no error


.. py:data:: REAL_ERROR_FORMAT

   realcvt: not supported format for current .idp


.. py:data:: REAL_ERROR_RANGE

   realcvt: number too big (small) for store (mem NOT modified)


.. py:data:: REAL_ERROR_BADDATA

   realcvt: illegal real data for load (IEEE data not filled)


.. py:data:: REAL_ERROR_FPOVER

   floating overflow or underflow


.. py:data:: REAL_ERROR_BADSTR

   asctoreal: illegal input string


.. py:data:: REAL_ERROR_ZERODIV

   ediv: divide by 0


.. py:data:: REAL_ERROR_INTOVER

   eetol*: integer overflow


.. py:class:: fpvalue_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: w
      :type:  uint16 [8]


   .. py:method:: clear() -> None


   .. py:method:: compare(r: fpvalue_t) -> int


   .. py:method:: from_10bytes(fpval: void const *) -> fpvalue_error_t

      Conversions for 10-byte floating point values.



   .. py:method:: to_10bytes(fpval: void *) -> fpvalue_error_t


   .. py:method:: from_12bytes(fpval: void const *) -> fpvalue_error_t

      Conversions for 12-byte floating point values.



   .. py:method:: to_12bytes(fpval: void *) -> fpvalue_error_t


   .. py:method:: to_str(*args) -> None

      Convert IEEE to string. 
              
      :param buf: the output buffer
      :param bufsize: the size of the output buffer
      :param mode: broken down into:
      * low byte: number of digits after '.'
      * second byte: FPNUM_LENGTH
      * third byte: FPNUM_DIGITS



   .. py:method:: from_sval(x: int) -> None

      Convert integer to IEEE.



   .. py:method:: from_int64(x: int64) -> None


   .. py:method:: from_uint64(x: uint64) -> None


   .. py:method:: to_sval(round: bool = False) -> fpvalue_error_t

      Convert IEEE to integer (+-0.5 if round)



   .. py:method:: to_int64(round: bool = False) -> fpvalue_error_t


   .. py:method:: to_uint64(round: bool = False) -> fpvalue_error_t


   .. py:method:: fadd(y: fpvalue_t) -> fpvalue_error_t

      Arithmetic operations.



   .. py:method:: fsub(y: fpvalue_t) -> fpvalue_error_t


   .. py:method:: fmul(y: fpvalue_t) -> fpvalue_error_t


   .. py:method:: fdiv(y: fpvalue_t) -> fpvalue_error_t


   .. py:method:: mul_pow2(power_of_2: int) -> fpvalue_error_t

      Multiply by a power of 2.



   .. py:method:: eabs() -> None

      Calculate absolute value.



   .. py:method:: is_negative() -> bool

      Is negative value?



   .. py:method:: negate() -> None

      Negate.



   .. py:method:: get_kind() -> fpvalue_kind_t

      Get value kind.



   .. py:method:: copy() -> fpvalue_t


   .. py:method:: new_from_str(p: str) -> fpvalue_t
      :staticmethod:



   .. py:method:: from_str(p: str) -> fpvalue_error_t

      Convert string to IEEE. 
              



   .. py:method:: assign(r: fpvalue_t) -> None


   .. py:attribute:: bytes


   .. py:attribute:: shorts


   .. py:attribute:: float


   .. py:property:: sval


   .. py:property:: int64


   .. py:property:: uint64


.. py:data:: cvar

.. py:data:: MAXEXP_FLOAT

.. py:data:: MAXEXP_DOUBLE

.. py:data:: MAXEXP_LNGDBL

.. py:data:: IEEE_EXONE

   The exponent of 1.0.


.. py:data:: E_SPECIAL_EXP

   Exponent in fpvalue_t for NaN and Inf.


.. py:data:: IEEE_NI

   Number of 16 bit words in eNI.


.. py:data:: IEEE_E

   Array offset to exponent.


.. py:data:: IEEE_M

   Array offset to high guard word 
           


.. py:function:: ecleaz(x: eNI) -> None

.. py:data:: EZERO
   :value: b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'


.. py:data:: EONE
   :value: b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\xff?'


.. py:data:: ETWO
   :value: b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00@'



```

`skills/idapython/docs/ida_kernwin.md`:

```md
# ida_kernwin

Interface between kernel and UI - dialogs, menus, choosers, custom viewers, and UI utilities.

## Key Functions

### User Interaction
- `msg(fmt, ...)` - print to output window
- `warning(fmt, ...)` / `error(fmt, ...)` - show warning/error dialog
- `ask_yn(defval, fmt, ...)` - yes/no question
- `ask_str(defval, hist, fmt, ...)` - string input
- `ask_long(defval, fmt, ...)` - integer input
- `ask_addr(defval, fmt, ...)` - address input
- `ask_file(forsave, defval, fmt, ...)` - file chooser

### Navigation
- `jumpto(ea, opnum=-1, uijmp_flags=0)` - jump to address
- `get_screen_ea()` - current cursor address
- `read_selection()` - get selected address range
- `choose_func(title)` - let user choose a function
- `choose_name(ea, title)` - let user choose a name

### UI Elements
- `find_widget(title)` - find widget by title
- `activate_widget(widget, take_focus)` - activate widget
- `close_widget(widget, flags)` - close widget
- `open_*_window(ea)` - open disasm/hex/exports/imports/etc window

### Actions
- `register_action(desc)` - register menu action
- `unregister_action(name)` - unregister action
- `attach_action_to_menu(path, name, flags)` - add action to menu
- `attach_action_to_toolbar(toolbar, name)` - add to toolbar
- `update_action_*()` - update action state/label/icon/etc

### Choosers (Lists)
- `Choose` class - create custom list windows
- `choose_refresh()` - refresh chooser
- `get_chooser_obj(title)` - get chooser Python object

### Custom Viewers
- `create_empty_widget(title)` - empty widget
- `create_code_viewer(widget, custviewer, flags)` - code viewer
- `simplecustviewer_t` - simple text viewer

### Misc
- `execute_sync(func, reqf)` - execute in UI thread
- `refresh_idaview()` / `refresh_idaview_anyway()` - refresh disassembly
- `beep(type)` - system beep
- `get_highlight(viewer)` - get highlighted identifier
- `set_highlight(viewer, text, flags)` - set highlight

## Widget Types (BWN_*)
DISASM, HEXVIEW, OUTPUT, FUNCS, NAMES, STRINGS, SEGS, IMPORTS, EXPORTS, PSEUDOCODE, etc.

## See Also
Full docs: skill/docs/ida_kernwin.rst

```

`skills/idapython/docs/ida_kernwin.rst`:

```rst
ida_kernwin
===========

.. py:module:: ida_kernwin

.. autoapi-nested-parse::

   Defines the interface between the kernel and the UI.

   It contains:
   * the UI dispatcher notification codes (ui_notification_t)
   * convenience functions for UI services
   * structures which hold information about the lines (disassembly, structures, enums) generated by the kernel
   * functions to interact with the user (dialog boxes)
   * some string and conversion functions. 


       



Attributes
----------

.. autoapisummary::

   ida_kernwin.MAX_SPACES_ADDED
   ida_kernwin.mbox_internal
   ida_kernwin.mbox_info
   ida_kernwin.mbox_warning
   ida_kernwin.mbox_error
   ida_kernwin.mbox_nomem
   ida_kernwin.mbox_feedback
   ida_kernwin.mbox_readerror
   ida_kernwin.mbox_writeerror
   ida_kernwin.mbox_filestruct
   ida_kernwin.mbox_wait
   ida_kernwin.mbox_hide
   ida_kernwin.mbox_replace
   ida_kernwin.chtype_generic
   ida_kernwin.chtype_idasgn
   ida_kernwin.chtype_entry
   ida_kernwin.chtype_name
   ida_kernwin.chtype_stkvar_xref
   ida_kernwin.chtype_xref
   ida_kernwin.chtype_func
   ida_kernwin.chtype_segm
   ida_kernwin.chtype_strpath
   ida_kernwin.chtype_idatil
   ida_kernwin.chtype_srcp
   ida_kernwin.chtype_struct
   ida_kernwin.chtype_enum
   ida_kernwin.chtype_enum_by_value_and_size
   ida_kernwin.beep_default
   ida_kernwin.TCCRT_INVALID
   ida_kernwin.TCCRT_FLAT
   ida_kernwin.TCCRT_GRAPH
   ida_kernwin.TCCRT_PROXIMITY
   ida_kernwin.TCCPT_INVALID
   ida_kernwin.TCCPT_PLACE
   ida_kernwin.TCCPT_SIMPLELINE_PLACE
   ida_kernwin.TCCPT_IDAPLACE
   ida_kernwin.TCCPT_TIPLACE
   ida_kernwin.VME_UNKNOWN
   ida_kernwin.VME_LEFT_BUTTON
   ida_kernwin.VME_RIGHT_BUTTON
   ida_kernwin.VME_MID_BUTTON
   ida_kernwin.SETMENU_POSMASK
   ida_kernwin.SETMENU_INS
   ida_kernwin.SETMENU_APP
   ida_kernwin.SETMENU_FIRST
   ida_kernwin.SETMENU_ENSURE_SEP
   ida_kernwin.CREATETB_ADV
   ida_kernwin.HIF_IDENTIFIER
   ida_kernwin.HIF_REGISTER
   ida_kernwin.HIF_LOCKED
   ida_kernwin.HIF_NOCASE
   ida_kernwin.HIF_USE_SLOT
   ida_kernwin.HIF_SLOT_SHIFT
   ida_kernwin.HIF_SLOT_0
   ida_kernwin.HIF_SLOT_1
   ida_kernwin.HIF_SLOT_2
   ida_kernwin.HIF_SLOT_3
   ida_kernwin.HIF_SLOT_4
   ida_kernwin.HIF_SLOT_5
   ida_kernwin.HIF_SLOT_6
   ida_kernwin.HIF_SLOT_7
   ida_kernwin.REG_HINTS_MARKER
   ida_kernwin.REG_HINTS_MARKER_LEN
   ida_kernwin.SRCDBG_HINTS_MARKER
   ida_kernwin.SRCDBG_HINTS_MARKER_LEN
   ida_kernwin.CDVF_NOLINES
   ida_kernwin.CDVF_LINEICONS
   ida_kernwin.CDVF_STATUSBAR
   ida_kernwin.IDCHK_OK
   ida_kernwin.IDCHK_ARG
   ida_kernwin.IDCHK_KEY
   ida_kernwin.IDCHK_MAX
   ida_kernwin.WCLS_SAVE
   ida_kernwin.WCLS_NO_CONTEXT
   ida_kernwin.WCLS_DONT_SAVE_SIZE
   ida_kernwin.WCLS_DELETE_LATER
   ida_kernwin.WCLS_CLOSE_LATER
   ida_kernwin.DP_LEFT
   ida_kernwin.DP_TOP
   ida_kernwin.DP_RIGHT
   ida_kernwin.DP_BOTTOM
   ida_kernwin.DP_INSIDE
   ida_kernwin.DP_TAB
   ida_kernwin.DP_BEFORE
   ida_kernwin.DP_FLOATING
   ida_kernwin.DP_SZHINT
   ida_kernwin.SVF_COPY_LINES
   ida_kernwin.SVF_LINES_BYPTR
   ida_kernwin.CVNF_LAZY
   ida_kernwin.CVNF_JUMP
   ida_kernwin.CVNF_ACT
   ida_kernwin.WOPN_RESTORE
   ida_kernwin.WOPN_PERSIST
   ida_kernwin.WOPN_CLOSED_BY_ESC
   ida_kernwin.WOPN_NOT_CLOSED_BY_ESC
   ida_kernwin.WOPN_DP_MASK
   ida_kernwin.WOPN_DP_SHIFT
   ida_kernwin.WOPN_DP_LEFT
   ida_kernwin.WOPN_DP_TOP
   ida_kernwin.WOPN_DP_RIGHT
   ida_kernwin.WOPN_DP_BOTTOM
   ida_kernwin.WOPN_DP_INSIDE
   ida_kernwin.WOPN_DP_TAB
   ida_kernwin.WOPN_DP_BEFORE
   ida_kernwin.WOPN_DP_FLOATING
   ida_kernwin.WOPN_DP_SZHINT
   ida_kernwin.WOPN_DP_INSIDE_BEFORE
   ida_kernwin.WOPN_DP_TAB_BEFORE
   ida_kernwin.RENADDR_IDA
   ida_kernwin.RENADDR_HR
   ida_kernwin.CVLF_USE_MOUSE
   ida_kernwin.cvar
   ida_kernwin.IDALIB_API_MAGIC
   ida_kernwin.DEFAULT_PLACE_LNNUM
   ida_kernwin.PCF_EA_CAPABLE
   ida_kernwin.PCF_MAKEPLACE_ALLOCATES
   ida_kernwin.LECVT_CANCELED
   ida_kernwin.LECVT_ERROR
   ida_kernwin.LECVT_OK
   ida_kernwin.LECVT_WITHIN_LISTING
   ida_kernwin.CK_TRACE
   ida_kernwin.CK_TRACE_OVL
   ida_kernwin.CK_EXTRA1
   ida_kernwin.CK_EXTRA2
   ida_kernwin.CK_EXTRA3
   ida_kernwin.CK_EXTRA4
   ida_kernwin.CK_EXTRA5
   ida_kernwin.CK_EXTRA6
   ida_kernwin.CK_EXTRA7
   ida_kernwin.CK_EXTRA8
   ida_kernwin.CK_EXTRA9
   ida_kernwin.CK_EXTRA10
   ida_kernwin.CK_EXTRA11
   ida_kernwin.CK_EXTRA12
   ida_kernwin.CK_EXTRA13
   ida_kernwin.CK_EXTRA14
   ida_kernwin.CK_EXTRA15
   ida_kernwin.CK_EXTRA16
   ida_kernwin.LROEF_MASK
   ida_kernwin.LROEF_FULL_LINE
   ida_kernwin.LROEF_CPS_RANGE
   ida_kernwin.BWN_UNKNOWN
   ida_kernwin.BWN_EXPORTS
   ida_kernwin.BWN_IMPORTS
   ida_kernwin.BWN_NAMES
   ida_kernwin.BWN_FUNCS
   ida_kernwin.BWN_STRINGS
   ida_kernwin.BWN_SEGS
   ida_kernwin.BWN_SEGREGS
   ida_kernwin.BWN_SELS
   ida_kernwin.BWN_SIGNS
   ida_kernwin.BWN_TILS
   ida_kernwin.BWN_TICSR
   ida_kernwin.BWN_CALLS
   ida_kernwin.BWN_PROBS
   ida_kernwin.BWN_BPTS
   ida_kernwin.BWN_THREADS
   ida_kernwin.BWN_MODULES
   ida_kernwin.BWN_TRACE
   ida_kernwin.BWN_CALL_STACK
   ida_kernwin.BWN_XREFS
   ida_kernwin.BWN_SEARCH
   ida_kernwin.BWN_FRAME
   ida_kernwin.BWN_NAVBAND
   ida_kernwin.BWN_DISASM
   ida_kernwin.BWN_HEXVIEW
   ida_kernwin.BWN_NOTEPAD
   ida_kernwin.BWN_OUTPUT
   ida_kernwin.BWN_CLI
   ida_kernwin.BWN_WATCH
   ida_kernwin.BWN_LOCALS
   ida_kernwin.BWN_STKVIEW
   ida_kernwin.BWN_CHOOSER
   ida_kernwin.BWN_SHORTCUTCSR
   ida_kernwin.BWN_SHORTCUTWIN
   ida_kernwin.BWN_CPUREGS
   ida_kernwin.BWN_SO_STRUCTS
   ida_kernwin.BWN_SO_OFFSETS
   ida_kernwin.BWN_CMDPALCSR
   ida_kernwin.BWN_CMDPALWIN
   ida_kernwin.BWN_SNIPPETS
   ida_kernwin.BWN_CUSTVIEW
   ida_kernwin.BWN_ADDRWATCH
   ida_kernwin.BWN_PSEUDOCODE
   ida_kernwin.BWN_CALLS_CALLERS
   ida_kernwin.BWN_CALLS_CALLEES
   ida_kernwin.BWN_MDVIEWCSR
   ida_kernwin.BWN_DISASM_ARROWS
   ida_kernwin.BWN_CV_LINE_INFOS
   ida_kernwin.BWN_SRCPTHMAP_CSR
   ida_kernwin.BWN_SRCPTHUND_CSR
   ida_kernwin.BWN_UNDOHIST
   ida_kernwin.BWN_SNIPPETS_CSR
   ida_kernwin.BWN_SCRIPTS_CSR
   ida_kernwin.BWN_BOOKMARKS
   ida_kernwin.BWN_TILIST
   ida_kernwin.BWN_TIL_VIEW
   ida_kernwin.BWN_TYPE_EDITOR
   ida_kernwin.BWN_MICROCODE
   ida_kernwin.BWN_XREF_TREE
   ida_kernwin.IWID_EXPORTS
   ida_kernwin.IWID_IMPORTS
   ida_kernwin.IWID_NAMES
   ida_kernwin.IWID_FUNCS
   ida_kernwin.IWID_STRINGS
   ida_kernwin.IWID_SEGS
   ida_kernwin.IWID_SEGREGS
   ida_kernwin.IWID_SELS
   ida_kernwin.IWID_SIGNS
   ida_kernwin.IWID_TILS
   ida_kernwin.IWID_TICSR
   ida_kernwin.IWID_CALLS
   ida_kernwin.IWID_PROBS
   ida_kernwin.IWID_BPTS
   ida_kernwin.IWID_THREADS
   ida_kernwin.IWID_MODULES
   ida_kernwin.IWID_TRACE
   ida_kernwin.IWID_CALL_STACK
   ida_kernwin.IWID_XREFS
   ida_kernwin.IWID_SEARCH
   ida_kernwin.IWID_FRAME
   ida_kernwin.IWID_NAVBAND
   ida_kernwin.IWID_DISASM
   ida_kernwin.IWID_HEXVIEW
   ida_kernwin.IWID_NOTEPAD
   ida_kernwin.IWID_OUTPUT
   ida_kernwin.IWID_CLI
   ida_kernwin.IWID_WATCH
   ida_kernwin.IWID_LOCALS
   ida_kernwin.IWID_STKVIEW
   ida_kernwin.IWID_CHOOSER
   ida_kernwin.IWID_SHORTCUTCSR
   ida_kernwin.IWID_SHORTCUTWIN
   ida_kernwin.IWID_CPUREGS
   ida_kernwin.IWID_SO_STRUCTS
   ida_kernwin.IWID_SO_OFFSETS
   ida_kernwin.IWID_CMDPALCSR
   ida_kernwin.IWID_CMDPALWIN
   ida_kernwin.IWID_SNIPPETS
   ida_kernwin.IWID_CUSTVIEW
   ida_kernwin.IWID_ADDRWATCH
   ida_kernwin.IWID_PSEUDOCODE
   ida_kernwin.IWID_CALLS_CALLERS
   ida_kernwin.IWID_CALLS_CALLEES
   ida_kernwin.IWID_MDVIEWCSR
   ida_kernwin.IWID_DISASM_ARROWS
   ida_kernwin.IWID_CV_LINE_INFOS
   ida_kernwin.IWID_SRCPTHMAP_CSR
   ida_kernwin.IWID_SRCPTHUND_CSR
   ida_kernwin.IWID_UNDOHIST
   ida_kernwin.IWID_SNIPPETS_CSR
   ida_kernwin.IWID_SCRIPTS_CSR
   ida_kernwin.IWID_BOOKMARKS
   ida_kernwin.IWID_TILIST
   ida_kernwin.IWID_TIL_VIEW
   ida_kernwin.IWID_TYPE_EDITOR
   ida_kernwin.IWID_XREF_TREE
   ida_kernwin.IWID_ANY_LISTING
   ida_kernwin.IWID_EA_LISTING
   ida_kernwin.IWID_ALL
   ida_kernwin.IDA_DEBUG_DREFS
   ida_kernwin.IDA_DEBUG_OFFSET
   ida_kernwin.IDA_DEBUG_FLIRT
   ida_kernwin.IDA_DEBUG_IDP
   ida_kernwin.IDA_DEBUG_LDR
   ida_kernwin.IDA_DEBUG_PLUGIN
   ida_kernwin.IDA_DEBUG_IDS
   ida_kernwin.IDA_DEBUG_CONFIG
   ida_kernwin.IDA_DEBUG_CHECKMEM
   ida_kernwin.IDA_DEBUG_LICENSE
   ida_kernwin.IDA_DEBUG_DEMANGLE
   ida_kernwin.IDA_DEBUG_QUEUE
   ida_kernwin.IDA_DEBUG_ROLLBACK
   ida_kernwin.IDA_DEBUG_ALREADY
   ida_kernwin.IDA_DEBUG_TIL
   ida_kernwin.IDA_DEBUG_NOTIFY
   ida_kernwin.IDA_DEBUG_DEBUGGER
   ida_kernwin.IDA_DEBUG_APPCALL
   ida_kernwin.IDA_DEBUG_SRCDBG
   ida_kernwin.IDA_DEBUG_ACCESSIBILITY
   ida_kernwin.IDA_DEBUG_NETWORK
   ida_kernwin.IDA_DEBUG_INTERNET
   ida_kernwin.IDA_DEBUG_SIMPLEX
   ida_kernwin.IDA_DEBUG_DBGINFO
   ida_kernwin.IDA_DEBUG_LUMINA
   ida_kernwin.IDA_DEBUG_THEMES
   ida_kernwin.IDA_DEBUG_REGEX
   ida_kernwin.IDA_DEBUG_SUBPROC
   ida_kernwin.IDA_DEBUG_RANGECB
   ida_kernwin.IDA_DEBUG_ALWAYS
   ida_kernwin.AST_ENABLE_ALWAYS
   ida_kernwin.AST_ENABLE_FOR_IDB
   ida_kernwin.AST_ENABLE_FOR_WIDGET
   ida_kernwin.AST_ENABLE
   ida_kernwin.AST_DISABLE_ALWAYS
   ida_kernwin.AST_DISABLE_FOR_IDB
   ida_kernwin.AST_DISABLE_FOR_WIDGET
   ida_kernwin.AST_DISABLE
   ida_kernwin.CH_MODAL
   ida_kernwin.CH_KEEP
   ida_kernwin.CH_MULTI
   ida_kernwin.CH_MULTI_EDIT
   ida_kernwin.CH_NOBTNS
   ida_kernwin.CH_ATTRS
   ida_kernwin.CH_UNUSED
   ida_kernwin.CH_FORCE_DEFAULT
   ida_kernwin.CH_CAN_INS
   ida_kernwin.CH_CAN_DEL
   ida_kernwin.CH_CAN_EDIT
   ida_kernwin.CH_CAN_REFRESH
   ida_kernwin.CH_QFLT
   ida_kernwin.CH_QFTYP_SHIFT
   ida_kernwin.CH_QFTYP_DEFAULT
   ida_kernwin.CH_QFTYP_NORMAL
   ida_kernwin.CH_QFTYP_WHOLE_WORDS
   ida_kernwin.CH_QFTYP_REGEX
   ida_kernwin.CH_QFTYP_FUZZY
   ida_kernwin.CH_QFTYP_MASK
   ida_kernwin.CH_NO_STATUS_BAR
   ida_kernwin.CH_RESTORE
   ida_kernwin.CH_RENAME_IS_EDIT
   ida_kernwin.CH_BUILTIN_SHIFT
   ida_kernwin.CH_BUILTIN_MASK
   ida_kernwin.CH_HAS_DIRTREE
   ida_kernwin.CH_TM_NO_TREE
   ida_kernwin.CH_TM_FOLDERS_ONLY
   ida_kernwin.CH_TM_FULL_TREE
   ida_kernwin.CH_TM_SHIFT
   ida_kernwin.CH_TM_MASK
   ida_kernwin.CH_HAS_DIFF
   ida_kernwin.CH_NO_SORT
   ida_kernwin.CH_NO_FILTER
   ida_kernwin.CH_NON_PERSISTED_TREE
   ida_kernwin.CH2_LAZY_LOADED
   ida_kernwin.CH2_HAS_INODE2INDEX
   ida_kernwin.CHCOL_PLAIN
   ida_kernwin.CHCOL_PATH
   ida_kernwin.CHCOL_HEX
   ida_kernwin.CHCOL_DEC
   ida_kernwin.CHCOL_EA
   ida_kernwin.CHCOL_FNAME
   ida_kernwin.CHCOL_FORMAT
   ida_kernwin.CHCOL_DEFHIDDEN
   ida_kernwin.CHCOL_DRAGHINT
   ida_kernwin.CHCOL_INODENAME
   ida_kernwin.CHITEM_BOLD
   ida_kernwin.CHITEM_ITALIC
   ida_kernwin.CHITEM_UNDER
   ida_kernwin.CHITEM_STRIKE
   ida_kernwin.CHITEM_GRAY
   ida_kernwin.CHOOSER_NOMAINMENU
   ida_kernwin.CHOOSER_NOSTATUSBAR
   ida_kernwin.GCRF_HIGH_BIT
   ida_kernwin.GCRF_HEADER
   ida_kernwin.GCRF_SELECTION
   ida_kernwin.GCRF_CURRENT
   ida_kernwin.GCRF_ALL
   ida_kernwin.nat_lib
   ida_kernwin.nat_fun
   ida_kernwin.nat_cod
   ida_kernwin.nat_dat
   ida_kernwin.nat_und
   ida_kernwin.nat_ext
   ida_kernwin.nat_err
   ida_kernwin.nat_gap
   ida_kernwin.nat_cur
   ida_kernwin.nat_auto
   ida_kernwin.nat_lum
   ida_kernwin.nat_hlo
   ida_kernwin.nat_last
   ida_kernwin.CVH_USERDATA
   ida_kernwin.CVH_KEYDOWN
   ida_kernwin.CVH_POPUP
   ida_kernwin.CVH_DBLCLICK
   ida_kernwin.CVH_CURPOS
   ida_kernwin.CVH_CLOSE
   ida_kernwin.CVH_CLICK
   ida_kernwin.CVH_QT_AWARE
   ida_kernwin.CVH_HELP
   ida_kernwin.CVH_MOUSEMOVE
   ida_kernwin.CDVH_USERDATA
   ida_kernwin.CDVH_SRCVIEW
   ida_kernwin.CDVH_LINES_CLICK
   ida_kernwin.CDVH_LINES_DBLCLICK
   ida_kernwin.CDVH_LINES_POPUP
   ida_kernwin.CDVH_LINES_DRAWICON
   ida_kernwin.CDVH_LINES_LINENUM
   ida_kernwin.CDVH_LINES_ICONMARGIN
   ida_kernwin.CDVH_LINES_RADIX
   ida_kernwin.CDVH_LINES_ALIGNMENT
   ida_kernwin.VES_SHIFT
   ida_kernwin.VES_ALT
   ida_kernwin.VES_CTRL
   ida_kernwin.VES_MOUSE_LEFT
   ida_kernwin.VES_MOUSE_RIGHT
   ida_kernwin.VES_MOUSE_MIDDLE
   ida_kernwin.VES_META
   ida_kernwin.msg_activated
   ida_kernwin.msg_deactivated
   ida_kernwin.msg_click
   ida_kernwin.msg_dblclick
   ida_kernwin.msg_closed
   ida_kernwin.msg_keydown
   ida_kernwin.view_activated
   ida_kernwin.view_deactivated
   ida_kernwin.view_keydown
   ida_kernwin.view_click
   ida_kernwin.view_dblclick
   ida_kernwin.view_curpos
   ida_kernwin.view_created
   ida_kernwin.view_close
   ida_kernwin.view_switched
   ida_kernwin.view_mouse_over
   ida_kernwin.view_loc_changed
   ida_kernwin.view_mouse_moved
   ida_kernwin.iek_unknown
   ida_kernwin.iek_shortcut
   ida_kernwin.iek_key_press
   ida_kernwin.iek_key_release
   ida_kernwin.iek_mouse_button_press
   ida_kernwin.iek_mouse_button_release
   ida_kernwin.iek_mouse_wheel
   ida_kernwin.MFF_FAST
   ida_kernwin.MFF_READ
   ida_kernwin.MFF_WRITE
   ida_kernwin.MFF_NOWAIT
   ida_kernwin.UIJMP_ACTIVATE
   ida_kernwin.UIJMP_DONTPUSH
   ida_kernwin.UIJMP_VIEWMASK
   ida_kernwin.UIJMP_ANYVIEW
   ida_kernwin.UIJMP_IDAVIEW
   ida_kernwin.UIJMP_IDAVIEW_NEW
   ida_kernwin.ACF_HAS_SELECTION
   ida_kernwin.ACF_XTRN_EA
   ida_kernwin.ACF_HAS_FIELD_DIRTREE_SELECTION
   ida_kernwin.ACF_HAS_SOURCE
   ida_kernwin.ACF_HAS_TYPE_REF
   ida_kernwin.AHF_VERSION
   ida_kernwin.AHF_VERSION_MASK
   ida_kernwin.ADF_OWN_HANDLER
   ida_kernwin.ADF_NO_UNDO
   ida_kernwin.ADF_OT_MASK
   ida_kernwin.ADF_OT_PLUGIN
   ida_kernwin.ADF_OT_PLUGMOD
   ida_kernwin.ADF_OT_PROCMOD
   ida_kernwin.ADF_GLOBAL
   ida_kernwin.ADF_NO_HIGHLIGHT
   ida_kernwin.ADF_CHECKABLE
   ida_kernwin.ADF_CHECKED
   ida_kernwin.AA_NONE
   ida_kernwin.AA_LABEL
   ida_kernwin.AA_SHORTCUT
   ida_kernwin.AA_TOOLTIP
   ida_kernwin.AA_ICON
   ida_kernwin.AA_STATE
   ida_kernwin.AA_CHECKABLE
   ida_kernwin.AA_CHECKED
   ida_kernwin.AA_VISIBILITY
   ida_kernwin.ASKBTN_YES
   ida_kernwin.ASKBTN_NO
   ida_kernwin.ASKBTN_CANCEL
   ida_kernwin.ASKBTN_BTN1
   ida_kernwin.ASKBTN_BTN2
   ida_kernwin.ASKBTN_BTN3
   ida_kernwin.HIST_SEG
   ida_kernwin.HIST_CMT
   ida_kernwin.HIST_SRCH
   ida_kernwin.HIST_IDENT
   ida_kernwin.HIST_FILE
   ida_kernwin.HIST_TYPE
   ida_kernwin.HIST_CMD
   ida_kernwin.HIST_DIR
   ida_kernwin.HIST_IDENT2
   ida_kernwin.CLNL_RTRIM
   ida_kernwin.CLNL_LTRIM
   ida_kernwin.CLNL_FINDCMT
   ida_kernwin.CLNL_TRIM
   ida_kernwin.S2EAOPT_NOCALC
   ida_kernwin.IK_CANCEL
   ida_kernwin.IK_BACK
   ida_kernwin.IK_TAB
   ida_kernwin.IK_CLEAR
   ida_kernwin.IK_RETURN
   ida_kernwin.IK_SHIFT
   ida_kernwin.IK_CONTROL
   ida_kernwin.IK_MENU
   ida_kernwin.IK_PAUSE
   ida_kernwin.IK_CAPITAL
   ida_kernwin.IK_KANA
   ida_kernwin.IK_ESCAPE
   ida_kernwin.IK_MODECHANGE
   ida_kernwin.IK_SPACE
   ida_kernwin.IK_PRIOR
   ida_kernwin.IK_NEXT
   ida_kernwin.IK_END
   ida_kernwin.IK_HOME
   ida_kernwin.IK_LEFT
   ida_kernwin.IK_UP
   ida_kernwin.IK_RIGHT
   ida_kernwin.IK_DOWN
   ida_kernwin.IK_SELECT
   ida_kernwin.IK_PRINT
   ida_kernwin.IK_EXECUTE
   ida_kernwin.IK_SNAPSHOT
   ida_kernwin.IK_INSERT
   ida_kernwin.IK_DELETE
   ida_kernwin.IK_HELP
   ida_kernwin.IK_LWIN
   ida_kernwin.IK_RWIN
   ida_kernwin.IK_APPS
   ida_kernwin.IK_SLEEP
   ida_kernwin.IK_NUMPAD0
   ida_kernwin.IK_NUMPAD1
   ida_kernwin.IK_NUMPAD2
   ida_kernwin.IK_NUMPAD3
   ida_kernwin.IK_NUMPAD4
   ida_kernwin.IK_NUMPAD5
   ida_kernwin.IK_NUMPAD6
   ida_kernwin.IK_NUMPAD7
   ida_kernwin.IK_NUMPAD8
   ida_kernwin.IK_NUMPAD9
   ida_kernwin.IK_MULTIPLY
   ida_kernwin.IK_ADD
   ida_kernwin.IK_SEPARATOR
   ida_kernwin.IK_SUBTRACT
   ida_kernwin.IK_DECIMAL
   ida_kernwin.IK_DIVIDE
   ida_kernwin.IK_F1
   ida_kernwin.IK_F2
   ida_kernwin.IK_F3
   ida_kernwin.IK_F4
   ida_kernwin.IK_F5
   ida_kernwin.IK_F6
   ida_kernwin.IK_F7
   ida_kernwin.IK_F8
   ida_kernwin.IK_F9
   ida_kernwin.IK_F10
   ida_kernwin.IK_F11
   ida_kernwin.IK_F12
   ida_kernwin.IK_F13
   ida_kernwin.IK_F14
   ida_kernwin.IK_F15
   ida_kernwin.IK_F16
   ida_kernwin.IK_F17
   ida_kernwin.IK_F18
   ida_kernwin.IK_F19
   ida_kernwin.IK_F20
   ida_kernwin.IK_F21
   ida_kernwin.IK_F22
   ida_kernwin.IK_F23
   ida_kernwin.IK_F24
   ida_kernwin.IK_NUMLOCK
   ida_kernwin.IK_SCROLL
   ida_kernwin.IK_OEM_FJ_MASSHOU
   ida_kernwin.IK_OEM_FJ_TOUROKU
   ida_kernwin.IK_LSHIFT
   ida_kernwin.IK_RSHIFT
   ida_kernwin.IK_LCONTROL
   ida_kernwin.IK_RCONTROL
   ida_kernwin.IK_LMENU
   ida_kernwin.IK_RMENU
   ida_kernwin.IK_BROWSER_BACK
   ida_kernwin.IK_BROWSER_FORWARD
   ida_kernwin.IK_BROWSER_REFRESH
   ida_kernwin.IK_BROWSER_STOP
   ida_kernwin.IK_BROWSER_SEARCH
   ida_kernwin.IK_BROWSER_FAVORITES
   ida_kernwin.IK_BROWSER_HOME
   ida_kernwin.IK_VOLUME_MUTE
   ida_kernwin.IK_VOLUME_DOWN
   ida_kernwin.IK_VOLUME_UP
   ida_kernwin.IK_MEDIA_NEXT_TRACK
   ida_kernwin.IK_MEDIA_PREV_TRACK
   ida_kernwin.IK_MEDIA_STOP
   ida_kernwin.IK_MEDIA_PLAY_PAUSE
   ida_kernwin.IK_LAUNCH_MAIL
   ida_kernwin.IK_LAUNCH_MEDIA_SELECT
   ida_kernwin.IK_LAUNCH_APP1
   ida_kernwin.IK_LAUNCH_APP2
   ida_kernwin.IK_OEM_1
   ida_kernwin.IK_OEM_PLUS
   ida_kernwin.IK_OEM_COMMA
   ida_kernwin.IK_OEM_MINUS
   ida_kernwin.IK_OEM_PERIOD
   ida_kernwin.IK_OEM_2
   ida_kernwin.IK_OEM_3
   ida_kernwin.IK_OEM_4
   ida_kernwin.IK_OEM_5
   ida_kernwin.IK_OEM_6
   ida_kernwin.IK_OEM_7
   ida_kernwin.IK_OEM_102
   ida_kernwin.IK_PLAY
   ida_kernwin.IK_ZOOM
   ida_kernwin.IK_OEM_CLEAR
   ida_kernwin.CB_INIT
   ida_kernwin.CB_YES
   ida_kernwin.CB_CLOSE
   ida_kernwin.CB_INVISIBLE
   ida_kernwin.CB_DESTROYING
   ida_kernwin.CB_NO
   ida_kernwin.CB_CANCEL
   ida_kernwin.SETMENU_IF_ENABLED
   ida_kernwin.CH_NOIDB
   ida_kernwin.BWN_TILVIEW
   ida_kernwin.IWID_TILVIEW
   ida_kernwin.BWN_LOCTYPS
   ida_kernwin.IWID_LOCTYPS
   ida_kernwin.BWN_DISASMS
   ida_kernwin.IWID_DISASMS
   ida_kernwin.CHOOSER_NO_SELECTION
   ida_kernwin.CHOOSER_MULTI_SELECTION
   ida_kernwin.CHOOSER_POPUP_MENU
   ida_kernwin.CHOOSER_MENU_EDIT
   ida_kernwin.CHOOSER_MENU_JUMP
   ida_kernwin.CHOOSER_MENU_SEARCH
   ida_kernwin.CH_NOIDB
   ida_kernwin.place_t_as_idaplace_t
   ida_kernwin.place_t_as_simpleline_place_t
   ida_kernwin.place_t_as_tiplace_t


Classes
-------

.. autoapisummary::

   ida_kernwin.chooser_row_info_vec_t
   ida_kernwin.tagged_line_section_vec_t
   ida_kernwin.jobj_wrapper_t
   ida_kernwin.UI_Hooks
   ida_kernwin.disasm_line_t
   ida_kernwin.line_rendering_output_entries_refs_t
   ida_kernwin.section_lines_refs_t
   ida_kernwin.sections_lines_refs_t
   ida_kernwin.text_t
   ida_kernwin.sync_source_vec_t
   ida_kernwin.place_t
   ida_kernwin.simpleline_t
   ida_kernwin.simpleline_place_t
   ida_kernwin.idaplace_t
   ida_kernwin.tiplace_t
   ida_kernwin.sync_source_t
   ida_kernwin.synced_group_t
   ida_kernwin.twinpos_t
   ida_kernwin.twinline_t
   ida_kernwin.linearray_t
   ida_kernwin.lines_rendering_input_t
   ida_kernwin.line_rendering_output_entry_t
   ida_kernwin.lines_rendering_output_t
   ida_kernwin.line_section_t
   ida_kernwin.tagged_line_section_t
   ida_kernwin.tagged_line_sections_t
   ida_kernwin.listing_location_t
   ida_kernwin.chooser_item_attrs_t
   ida_kernwin.chooser_row_info_t
   ida_kernwin.chooser_stdact_desc_t
   ida_kernwin.chooser_base_t
   ida_kernwin.renderer_pos_info_t
   ida_kernwin.view_mouse_event_location_t
   ida_kernwin.view_mouse_event_t
   ida_kernwin.input_event_t
   ida_kernwin.input_event_shortcut_data_t
   ida_kernwin.input_event_keyboard_data_t
   ida_kernwin.input_event_mouse_data_t
   ida_kernwin.ui_requests_t
   ida_kernwin.action_ctx_base_cur_sel_t
   ida_kernwin.action_ctx_base_t
   ida_kernwin.action_desc_t
   ida_kernwin.addon_info_t
   ida_kernwin.strarray_t
   ida_kernwin.disasm_text_t
   ida_kernwin.action_handler_t
   ida_kernwin.quick_widget_commands_t
   ida_kernwin.disabled_script_timeout_t
   ida_kernwin.Choose
   ida_kernwin.textctrl_info_t
   ida_kernwin.Form
   ida_kernwin.cli_t
   ida_kernwin.View_Hooks
   ida_kernwin.CustomIDAMemo
   ida_kernwin.IDAViewWrapper
   ida_kernwin.simplecustviewer_t
   ida_kernwin.PluginForm


Functions
---------

.. autoapisummary::

   ida_kernwin.refresh_choosers
   ida_kernwin.textctrl_info_t_create
   ida_kernwin.textctrl_info_t_destroy
   ida_kernwin.textctrl_info_t_get_clink
   ida_kernwin.textctrl_info_t_get_clink_ptr
   ida_kernwin.register_timer
   ida_kernwin.unregister_timer
   ida_kernwin.choose_idasgn
   ida_kernwin.get_highlight
   ida_kernwin.py_load_custom_icon_fn
   ida_kernwin.py_load_custom_icon_data
   ida_kernwin.msg
   ida_kernwin.warning
   ida_kernwin.error
   ida_kernwin.ask_text
   ida_kernwin.ask_str
   ida_kernwin.process_ui_action
   ida_kernwin.del_hotkey
   ida_kernwin.add_hotkey
   ida_kernwin.take_database_snapshot
   ida_kernwin.restore_database_snapshot
   ida_kernwin.execute_sync
   ida_kernwin.execute_ui_requests
   ida_kernwin.register_action
   ida_kernwin.get_registered_actions
   ida_kernwin.attach_dynamic_action_to_popup
   ida_kernwin.py_chooser_base_t_get_row
   ida_kernwin.gen_disasm_text
   ida_kernwin.set_nav_colorizer
   ida_kernwin.call_nav_colorizer
   ida_kernwin.msg_get_lines
   ida_kernwin.TWidget__from_ptrval__
   ida_kernwin.add_spaces
   ida_kernwin.show_wait_box
   ida_kernwin.hide_wait_box
   ida_kernwin.get_kernel_version
   ida_kernwin.is_ida_library
   ida_kernwin.l_compare2
   ida_kernwin.l_equals
   ida_kernwin.is_tif_cursor_header
   ida_kernwin.is_tif_cursor_footer
   ida_kernwin.is_tif_cursor_index
   ida_kernwin.internal_register_place_class
   ida_kernwin.get_place_class
   ida_kernwin.get_place_class_template
   ida_kernwin.is_place_class_ea_capable
   ida_kernwin.get_place_class_id
   ida_kernwin.request_refresh
   ida_kernwin.clear_refresh_request
   ida_kernwin.is_refresh_requested
   ida_kernwin.is_chooser_widget
   ida_kernwin.is_action_enabled
   ida_kernwin.cancel_exec_request
   ida_kernwin.cancel_thread_exec_requests
   ida_kernwin.set_execute_sync_availability
   ida_kernwin.get_synced_group
   ida_kernwin.banner
   ida_kernwin.is_msg_inited
   ida_kernwin.refresh_idaview
   ida_kernwin.refresh_idaview_anyway
   ida_kernwin.analyzer_options
   ida_kernwin.get_screen_ea
   ida_kernwin.get_opnum
   ida_kernwin.get_cursor
   ida_kernwin.get_output_cursor
   ida_kernwin.get_curline
   ida_kernwin.open_url
   ida_kernwin.get_hexdump_ea
   ida_kernwin.get_key_code
   ida_kernwin.lookup_key_code
   ida_kernwin.refresh_navband
   ida_kernwin.refresh_chooser
   ida_kernwin.close_chooser
   ida_kernwin.set_dock_pos
   ida_kernwin.get_icon_id_by_name
   ida_kernwin.free_custom_icon
   ida_kernwin.unregister_action
   ida_kernwin.create_toolbar
   ida_kernwin.delete_toolbar
   ida_kernwin.create_menu
   ida_kernwin.delete_menu
   ida_kernwin.attach_action_to_menu
   ida_kernwin.detach_action_from_menu
   ida_kernwin.attach_action_to_toolbar
   ida_kernwin.detach_action_from_toolbar
   ida_kernwin.register_and_attach_to_menu
   ida_kernwin.display_widget
   ida_kernwin.close_widget
   ida_kernwin.activate_widget
   ida_kernwin.find_widget
   ida_kernwin.get_current_widget
   ida_kernwin.get_widget_type
   ida_kernwin.get_widget_title
   ida_kernwin.custom_viewer_jump
   ida_kernwin.ea_viewer_history_push_and_jump
   ida_kernwin.get_ea_viewer_history_info
   ida_kernwin.refresh_custom_viewer
   ida_kernwin.repaint_custom_viewer
   ida_kernwin.jumpto
   ida_kernwin.get_custom_viewer_place
   ida_kernwin.get_custom_viewer_location
   ida_kernwin.is_idaq
   ida_kernwin.attach_action_to_popup
   ida_kernwin.detach_action_from_popup
   ida_kernwin.update_action_label
   ida_kernwin.update_action_shortcut
   ida_kernwin.update_action_tooltip
   ida_kernwin.update_action_icon
   ida_kernwin.update_action_state
   ida_kernwin.update_action_checkable
   ida_kernwin.update_action_checked
   ida_kernwin.update_action_visibility
   ida_kernwin.get_action_label
   ida_kernwin.get_action_shortcut
   ida_kernwin.get_action_tooltip
   ida_kernwin.get_action_icon
   ida_kernwin.get_action_state
   ida_kernwin.get_action_checkable
   ida_kernwin.get_action_checked
   ida_kernwin.get_action_visibility
   ida_kernwin.set_custom_viewer_qt_aware
   ida_kernwin.get_custom_viewer_curline
   ida_kernwin.get_custom_viewer_place_xcoord
   ida_kernwin.get_user_input_event
   ida_kernwin.get_output_curline
   ida_kernwin.get_output_selected_text
   ida_kernwin.get_current_viewer
   ida_kernwin.get_last_widget
   ida_kernwin.prompt_function_prototype
   ida_kernwin.parse_tagged_line_sections
   ida_kernwin.get_view_renderer_type
   ida_kernwin.set_view_renderer_type
   ida_kernwin.create_empty_widget
   ida_kernwin.msg_clear
   ida_kernwin.msg_save
   ida_kernwin.get_active_modal_widget
   ida_kernwin.get_navband_pixel
   ida_kernwin.get_navband_ea
   ida_kernwin.get_window_id
   ida_kernwin.is_idaview
   ida_kernwin.read_selection
   ida_kernwin.read_range_selection
   ida_kernwin.unmark_selection
   ida_kernwin.create_code_viewer
   ida_kernwin.set_code_viewer_handler
   ida_kernwin.set_code_viewer_user_data
   ida_kernwin.get_viewer_user_data
   ida_kernwin.get_viewer_place_type
   ida_kernwin.set_code_viewer_line_handlers
   ida_kernwin.set_code_viewer_lines_icon_margin
   ida_kernwin.set_code_viewer_lines_alignment
   ida_kernwin.set_code_viewer_lines_radix
   ida_kernwin.set_code_viewer_is_source
   ida_kernwin.get_tab_size
   ida_kernwin.clr_cancelled
   ida_kernwin.set_cancelled
   ida_kernwin.user_cancelled
   ida_kernwin.ui_load_new_file
   ida_kernwin.ui_run_debugger
   ida_kernwin.load_dbg_dbginfo
   ida_kernwin.add_idc_hotkey
   ida_kernwin.set_highlight
   ida_kernwin.open_exports_window
   ida_kernwin.open_imports_window
   ida_kernwin.open_names_window
   ida_kernwin.open_funcs_window
   ida_kernwin.open_strings_window
   ida_kernwin.open_segments_window
   ida_kernwin.open_segregs_window
   ida_kernwin.open_selectors_window
   ida_kernwin.open_signatures_window
   ida_kernwin.open_tils_window
   ida_kernwin.open_loctypes_window
   ida_kernwin.open_til_view_window
   ida_kernwin.open_calls_window
   ida_kernwin.open_problems_window
   ida_kernwin.open_bpts_window
   ida_kernwin.open_threads_window
   ida_kernwin.open_modules_window
   ida_kernwin.open_trace_window
   ida_kernwin.open_stack_window
   ida_kernwin.open_xrefs_window
   ida_kernwin.open_frame_window
   ida_kernwin.open_navband_window
   ida_kernwin.open_disasm_window
   ida_kernwin.open_hexdump_window
   ida_kernwin.open_notepad_window
   ida_kernwin.open_bookmarks_window
   ida_kernwin.sync_sources
   ida_kernwin.choose_til
   ida_kernwin.choose_entry
   ida_kernwin.choose_name
   ida_kernwin.choose_stkvar_xref
   ida_kernwin.choose_xref
   ida_kernwin.choose_enum
   ida_kernwin.choose_enum_by_value
   ida_kernwin.choose_func
   ida_kernwin.choose_segm
   ida_kernwin.choose_struct
   ida_kernwin.choose_srcp
   ida_kernwin.get_chooser_obj
   ida_kernwin.get_chooser_rows
   ida_kernwin.enable_chooser_item_attrs
   ida_kernwin.replace_wait_box
   ida_kernwin.beep
   ida_kernwin.display_copyright_warning
   ida_kernwin.ask_for_feedback
   ida_kernwin.info
   ida_kernwin.nomem
   ida_kernwin.ask_yn
   ida_kernwin.ask_buttons
   ida_kernwin.ask_ident2
   ida_kernwin.ask_file
   ida_kernwin.register_addon
   ida_kernwin.addon_count
   ida_kernwin.get_addon_info
   ida_kernwin.get_addon_info_idx
   ida_kernwin.qcleanline
   ida_kernwin.strarray
   ida_kernwin.ea2str
   ida_kernwin.str2ea
   ida_kernwin.str2ea_ex
   ida_kernwin.atoea
   ida_kernwin.get_user_strlist_options
   ida_kernwin.del_idc_hotkey
   ida_kernwin.load_custom_icon
   ida_kernwin.ask_long
   ida_kernwin.ask_addr
   ida_kernwin.ask_seg
   ida_kernwin.ask_ident
   ida_kernwin.choose_find
   ida_kernwin.choose_refresh
   ida_kernwin.choose_close
   ida_kernwin.choose_get_widget
   ida_kernwin.choose_choose
   ida_kernwin.choose_activate
   ida_kernwin.choose_create_embedded_chobj
   ida_kernwin.get_chooser_data
   ida_kernwin.textctrl_info_t_assign
   ida_kernwin.textctrl_info_t_set_text
   ida_kernwin.textctrl_info_t_get_text
   ida_kernwin.textctrl_info_t_set_flags
   ida_kernwin.textctrl_info_t_get_flags
   ida_kernwin.textctrl_info_t_set_tabsize
   ida_kernwin.textctrl_info_t_get_tabsize
   ida_kernwin.formchgcbfa_enable_field
   ida_kernwin.formchgcbfa_show_field
   ida_kernwin.formchgcbfa_move_field
   ida_kernwin.formchgcbfa_get_focused_field
   ida_kernwin.formchgcbfa_set_focused_field
   ida_kernwin.formchgcbfa_refresh_field
   ida_kernwin.formchgcbfa_close
   ida_kernwin.formchgcbfa_get_field_value
   ida_kernwin.formchgcbfa_set_field_value
   ida_kernwin.py_get_ask_form
   ida_kernwin.py_get_open_form
   ida_kernwin.py_register_compiled_form
   ida_kernwin.py_unregister_compiled_form
   ida_kernwin.ask_form
   ida_kernwin.open_form
   ida_kernwin.install_command_interpreter
   ida_kernwin.remove_command_interpreter
   ida_kernwin.pyidag_bind
   ida_kernwin.pyidag_unbind
   ida_kernwin.pyscv_init
   ida_kernwin.pyscv_refresh
   ida_kernwin.pyscv_get_current_line
   ida_kernwin.pyscv_is_focused
   ida_kernwin.pyscv_count
   ida_kernwin.pyscv_show
   ida_kernwin.pyscv_close
   ida_kernwin.pyscv_jumpto
   ida_kernwin.pyscv_get_line
   ida_kernwin.pyscv_get_pos
   ida_kernwin.pyscv_clear_lines
   ida_kernwin.pyscv_add_line
   ida_kernwin.pyscv_insert_line
   ida_kernwin.pyscv_patch_line
   ida_kernwin.pyscv_del_line
   ida_kernwin.pyscv_get_selection
   ida_kernwin.pyscv_get_current_word
   ida_kernwin.pyscv_edit_line
   ida_kernwin.pyscv_get_widget
   ida_kernwin.plgform_new
   ida_kernwin.plgform_show
   ida_kernwin.plgform_close
   ida_kernwin.plgform_get_widget


Module Contents
---------------

.. py:class:: chooser_row_info_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> chooser_row_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> chooser_row_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: chooser_row_info_vec_t) -> None


   .. py:method:: extract() -> chooser_row_info_t *


   .. py:method:: inject(s: chooser_row_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< chooser_row_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< chooser_row_info_t >::const_iterator


   .. py:method:: insert(it: chooser_row_info_t, x: chooser_row_info_t) -> qvector< chooser_row_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< chooser_row_info_t >::iterator


   .. py:method:: find(*args) -> qvector< chooser_row_info_t >::const_iterator


   .. py:method:: has(x: chooser_row_info_t) -> bool


   .. py:method:: add_unique(x: chooser_row_info_t) -> bool


   .. py:method:: append(x: chooser_row_info_t) -> None


   .. py:method:: extend(x: chooser_row_info_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: tagged_line_section_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> tagged_line_section_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> tagged_line_section_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: tagged_line_section_vec_t) -> None


   .. py:method:: extract() -> tagged_line_section_t *


   .. py:method:: inject(s: tagged_line_section_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< tagged_line_section_t >::const_iterator


   .. py:method:: end(*args) -> qvector< tagged_line_section_t >::const_iterator


   .. py:method:: insert(it: tagged_line_section_t, x: tagged_line_section_t) -> qvector< tagged_line_section_t >::iterator


   .. py:method:: erase(*args) -> qvector< tagged_line_section_t >::iterator


   .. py:method:: find(*args) -> qvector< tagged_line_section_t >::const_iterator


   .. py:method:: has(x: tagged_line_section_t) -> bool


   .. py:method:: add_unique(x: tagged_line_section_t) -> bool


   .. py:method:: append(x: tagged_line_section_t) -> None


   .. py:method:: extend(x: tagged_line_section_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: refresh_choosers() -> None

.. py:function:: textctrl_info_t_create() -> PyObject *

.. py:function:: textctrl_info_t_destroy(py_obj: PyObject *) -> bool

.. py:function:: textctrl_info_t_get_clink(_self: PyObject *) -> textctrl_info_t *

.. py:function:: textctrl_info_t_get_clink_ptr(_self: PyObject *) -> PyObject *

.. py:function:: register_timer(interval, callback)

   Register a timer

   :param interval: Interval in milliseconds
   :param callback: A Python callable that takes no parameters and returns an integer.
                    The callback may return:
                    -1   : to unregister the timer
                    >= 0 : the new or same timer interval
   :returns: None or a timer object


.. py:function:: unregister_timer(timer_obj)

   Unregister a timer

   NOTE: After the timer has been deleted, the timer_obj will become invalid.

   :param timer_obj: a timer object previously returned by a register_timer()
   :returns: Boolean


.. py:function:: choose_idasgn()

   Opens the signature chooser

   :returns: None or the selected signature name


.. py:function:: get_highlight(v, flags=0)

   Returns the currently highlighted identifier and flags

   :param v: The UI widget to operate on
   :param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
   :returns: a tuple (text, flags), or None if nothing
            is highlighted or in case of error.


.. py:function:: py_load_custom_icon_fn(filename: str) -> int

.. py:function:: py_load_custom_icon_data(data: PyObject *, format: str) -> int

.. py:function:: msg(message)

   Display a message in the message window

   :param message: message to print


.. py:function:: warning(message)

   Display a message in a warning message box

   :param message: message to print


.. py:function:: error(message)

   Display a fatal message in a message box and quit IDA

   :param format: message to print


.. py:function:: ask_text(max_size: int, defval: str, prompt: str) -> Union[str, None]

   Asks for a long text

   :param max_size: Maximum text length, 0 for unlimited
   :param defval: The default value
   :param prompt: The prompt value
   :returns: None or the entered string


.. py:function:: ask_str(defval, hist, prompt)

   Asks for a long text

   :param defval: The default value
   :param hist:   history id
   :param prompt: The prompt value
   :returns: None or the entered string


.. py:function:: process_ui_action(name: str, flags: int = 0)

   Invokes an IDA UI action by name

   :param name:  action name
   :param flags: reserved
   :returns: Boolean


.. py:function:: del_hotkey(ctx)

   Deletes a previously registered function hotkey

   :param ctx: Hotkey context previously returned by add_hotkey()

   :returns: Boolean.


.. py:function:: add_hotkey(hotkey, callable)

   Associates a function call with a hotkey.
   Callable 'callable' will be called each time the hotkey is pressed

   :param hotkey: The hotkey
   :param callable: Callable

   :returns: Context object on success or None on failure.


.. py:function:: take_database_snapshot(snapshot) -> Tuple[bool, str]

   Take a database snapshot.

   :param snapshot: the snapshot object
   :returns: a tuple (success, error-message)


.. py:function:: restore_database_snapshot(snapshot, callback, userdata) -> bool

   Restore a database snapshot.

   Note: This call is asynchronous. When it is completed, the callback will be triggered.

   :param snapshot: the snapshot object
   :param callback: a callback function
   :param userdata: payload to pass to the callback
   :returns: success


.. py:function:: execute_sync(callable, reqf)

   Executes a function in the context of the main thread.
   If the current thread not the main thread, then the call is queued and
   executed afterwards.

   :param callable: A python callable object, must return an integer value
   :param reqf: one of MFF_ flags
   :returns: -1 or the return value of the callable


.. py:function:: execute_ui_requests(callable_list)

   Inserts a list of callables into the UI message processing queue.
   When the UI is ready it will call one callable.
   A callable can request to be called more than once if it returns True.

   NOTE: A callable should return True if it wants to be called more than once.

   :param callable_list: A list of python callable objects.
   :returns: Boolean. False if the list contains a non callable item


.. py:class:: jobj_wrapper_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: get_dict() -> dict

      Retrieve the contents of this object, as a dict

      :returns: a dict containing all kvp's in this object



.. py:class:: UI_Hooks(_flags: int = 0, _hkcb_flags: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: hook() -> bool


   .. py:method:: unhook() -> bool


   .. py:method:: range() -> None

      The disassembly range has been changed ( idainfo::min_ea ... idainfo::max_ea). UI should redraw the scrollbars. See also: ui_lock_range_refresh 
                
      :returns: void



   .. py:method:: idcstart() -> None

      Start of IDC engine work. 
                
      :returns: void



   .. py:method:: idcstop() -> None

      Stop of IDC engine work. 
                
      :returns: void



   .. py:method:: suspend() -> None

      Suspend graphical interface. Only the text version. Interface should respond to it. 
                
      :returns: void



   .. py:method:: resume() -> None

      Resume the suspended graphical interface. Only the text version. Interface should respond to it 
                
      :returns: void



   .. py:method:: saving() -> None

      The kernel is flushing its buffers to the disk. The user interface should save its state. Parameters: none Returns: none 
                



   .. py:method:: saved(path: str) -> None

      The kernel has saved the database. This callback just informs the interface. Note that at the time this notification is sent, the internal paths are not updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path. 
                
      :param path: (const char *) the database path
      :returns: void



   .. py:method:: database_closed() -> None

      The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
                
      :returns: void



   .. py:method:: debugger_menu_change(enable: bool) -> None

      debugger menu modification detected 
                
      :param enable: (bool) true: debugger menu has been added, or a different debugger has been selected false: debugger menu will be removed (user switched to "No debugger")
      :returns: void



   .. py:method:: widget_visible(widget: TWidget *) -> None

      TWidget is displayed on the screen. Use this event to populate the window with controls 
                
      :param widget: (TWidget *)
      :returns: void



   .. py:method:: widget_closing(widget: TWidget *) -> None

      TWidget is about to close. This event precedes ui_widget_invisible. Use this to perform some possible actions relevant to the lifecycle of this widget 
                
      :param widget: (TWidget *)
      :returns: void



   .. py:method:: widget_invisible(widget: TWidget *) -> None

      TWidget is being closed. Use this event to destroy the window controls 
                
      :param widget: (TWidget *)
      :returns: void



   .. py:method:: get_ea_hint(ea: ida_idaapi.ea_t) -> PyObject *

      ui wants to display a simple hint for an address. Use this event to generate a custom hint See also more generic ui_get_item_hint 
                
      :param ea: (::ea_t)
      :returns: true if generated a hint



   .. py:method:: get_item_hint(ea: ida_idaapi.ea_t, max_lines: int) -> PyObject *

      ui wants to display multiline hint for an item. See also more generic ui_get_custom_viewer_hint 
                
      :param ea: (ea_t) or item id like a structure or enum member
      :param max_lines: (int) maximal number of lines
      :returns: true if generated a hint



   .. py:method:: get_custom_viewer_hint(viewer: TWidget *, place: place_t) -> PyObject *

      ui wants to display a hint for a viewer (idaview or custom). Every subscriber is supposed to append the hint lines to HINT and increment IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT is possible but not recommended. If the REG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the source-level debugger-generated hints. The following keywords might appear at the beginning of the returned hints: HIGHLIGHT text
       where text will be highlighted CAPTION caption
       caption for the hint widget 
                
      :param viewer: (TWidget*) viewer
      :param place: (place_t *) current position in the viewer
      :returns: 0: continue collecting hints with other subscribers
      :returns: 1: stop collecting hints



   .. py:method:: database_inited(is_new_database: int, idc_script: str) -> None

      database initialization has completed. the kernel is about to run idc scripts 
                
      :param is_new_database: (int)
      :param idc_script: (const char *) - may be nullptr
      :returns: void See also ui_initing_database. This event is called for both new and old databases.



   .. py:method:: ready_to_run() -> None

      all UI elements have been initialized. Automatic plugins may hook to this event to perform their tasks. 
                
      :returns: void



   .. py:method:: preprocess_action(name: str) -> int

      ida ui is about to handle a user action. 
                
      :param name: (const char *) ui action name. these names can be looked up in ida[tg]ui.cfg
      :returns: 0: ok
      :returns: nonzero: a plugin has handled the command



   .. py:method:: postprocess_action() -> None

      an ida ui action has been handled



   .. py:method:: get_chooser_item_attrs(chooser: chooser_base_t, n: size_t, attrs: chooser_item_attrs_t) -> None

      get item-specific attributes for a chooser. This callback is generated only after enable_chooser_attrs() 
                
      :param chooser: (const chooser_base_t *)
      :param n: (::size_t)
      :param attrs: (chooser_item_attrs_t *)
      :returns: void



   .. py:method:: updating_actions(ctx: action_ctx_base_t) -> None

      IDA is about to update all actions. If your plugin needs to perform expensive operations more than once (e.g., once per action it registers), you should do them only once, right away. 
                
      :param ctx: (action_update_ctx_t *)
      :returns: void



   .. py:method:: updated_actions() -> None

      IDA is done updating actions. 
                
      :returns: void



   .. py:method:: populating_widget_popup(widget: TWidget *, popup_handle: TPopupMenu *, ctx: action_ctx_base_t = None) -> None

      IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
      Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)

      :param widget: (TWidget *)
      :param popup_handle: (TPopupMenu *)
      :param ctx: (const action_activation_ctx_t *)
      :returns: void



   .. py:method:: finish_populating_widget_popup(widget: TWidget *, popup_handle: TPopupMenu *, ctx: action_ctx_base_t = None) -> None

      IDA is about to be done populating the context menu for a widget. This is your chance to attach_action_to_popup().

      :param widget: (TWidget *)
      :param popup_handle: (TPopupMenu *)
      :param ctx: (const action_activation_ctx_t *)
      :returns: void



   .. py:method:: plugin_loaded(plugin_info: plugin_info_t const *) -> None

      The plugin was loaded in memory. 
                
      :param plugin_info: (const plugin_info_t *)



   .. py:method:: plugin_unloading(plugin_info: plugin_info_t const *) -> None

      The plugin is about to be unloaded 
                
      :param plugin_info: (const plugin_info_t *)



   .. py:method:: current_widget_changed(widget: TWidget *, prev_widget: TWidget *) -> None

      The currently-active TWidget changed. 
                
      :param widget: (TWidget *)
      :param prev_widget: (TWidget *)
      :returns: void



   .. py:method:: screen_ea_changed(ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t) -> None

      The "current address" changed 
                
      :param ea: (ea_t)
      :param prev_ea: (ea_t)
      :returns: void



   .. py:method:: create_desktop_widget(title: str, cfg: jobj_wrapper_t) -> PyObject *

      create a widget, to be placed in the widget tree (at desktop-creation time.) 
                
      :param title: (const char *)
      :param cfg: (const jobj_t *)
      :returns: TWidget * the created widget, or null



   .. py:method:: get_lines_rendering_info(out: lines_rendering_output_t, widget: TWidget const *, info: lines_rendering_input_t) -> None

      get lines rendering information 
                
      :param out: (lines_rendering_output_t *)
      :param widget: (const TWidget *)
      :param info: (const lines_rendering_input_t *)
      :returns: void



   .. py:method:: get_widget_config(widget: TWidget const *, cfg: jobj_t *) -> PyObject *

      retrieve the widget configuration (it will be passed back at ui_create_desktop_widget-, and ui_set_widget_config-time) 
                
      :param widget: (const TWidget *)
      :param cfg: (jobj_t *)
      :returns: void



   .. py:method:: set_widget_config(widget: TWidget const *, cfg: jobj_wrapper_t) -> None

      set the widget configuration 
                
      :param widget: (const TWidget *)
      :param cfg: (const jobj_t *)
      :returns: void



   .. py:method:: initing_database() -> None

      database initialization has started. 
                
      :returns: void See also ui_database_inited. This event is called for both new and old databases.



   .. py:method:: destroying_procmod(procmod: procmod_t) -> None

      The processor module is about to be destroyed 
                
      :param procmod: (const procmod_t *)



   .. py:method:: destroying_plugmod(plugmod: plugmod_t, entry: plugin_t const *) -> None

      The plugin object is about to be destroyed 
                
      :param plugmod: (const plugmod_t *)
      :param entry: (const plugin_t *)



   .. py:method:: desktop_applied(name: str, from_idb: bool, type: int) -> None

      a desktop has been applied 
                
      :param name: (const char *) the desktop name
      :param from_idb: (bool) the desktop was stored in the IDB (false if it comes from the registry)
      :param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)



.. py:function:: register_action(desc: action_desc_t) -> bool

   Create a new action (ui_register_action). After an action has been created, it is possible to attach it to menu items (attach_action_to_menu()), or to popup menus (attach_action_to_popup()).
   Because the actions will need to call the handler's activate() and update() methods at any time, you shouldn't build your action handler on the stack.
   Please see the SDK's "ht_view" plugin for an example how to register actions. 
           
   :param desc: action to register
   :returns: success


.. py:function:: get_registered_actions() -> List[str]

   Get a list with the names of all currently-registered actions.

   :returns: the list of action names


.. py:function:: attach_dynamic_action_to_popup(unused, popup_handle, desc, popuppath=None, flags=0)

   Create & insert an action into the widget's popup menu
   (::ui_attach_dynamic_action_to_popup).
   Note: The action description in the 'desc' parameter is modified by
         this call so you should prepare a new description for each call.
   For example:
       desc = ida_kernwin.action_desc_t(None, 'Dynamic popup action', Handler())
       ida_kernwin.attach_dynamic_action_to_popup(form, popup, desc)

   :param unused:       deprecated; should be None
   :param popup_handle: target popup
   :param desc:         action description of type action_desc_t
   :param popuppath:    can be None
   :param flags:        a combination of SETMENU_ constants
   :returns: success


.. py:class:: disasm_line_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: at
      :type:  place_t *


   .. py:attribute:: line
      :type:  str


   .. py:attribute:: prefix_color
      :type:  color_t


   .. py:attribute:: bg_color
      :type:  bgcolor_t


   .. py:attribute:: is_default
      :type:  bool


.. py:function:: py_chooser_base_t_get_row(chobj: chooser_base_t, n: size_t) -> PyObject *

.. py:function:: gen_disasm_text(text: disasm_text_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, truncate_lines: bool) -> None

   Generate disassembly text for a range. 
           
   :param text: result
   :param ea1: start address
   :param ea2: end address
   :param truncate_lines: (on idainfo::margin)


.. py:function:: set_nav_colorizer(callback)

   Set a new colorizer for the navigation band.

   The 'callback' is a function of 2 arguments:
      - ea (the EA to colorize for)
      - nbytes (the number of bytes at that EA)
   and must return a 'long' value.

   The previous colorizer is returned, allowing
   the new 'callback' to use 'call_nav_colorizer'
   with it.

   Note that the previous colorizer is returned
   only the first time set_nav_colorizer() is called:
   due to the way the colorizers API is defined in C,
   it is impossible to chain more than 2 colorizers
   in IDAPython: the original, IDA-provided colorizer,
   and a user-provided one.

   Example: colorizer inverting the color provided by the IDA colorizer:
       def my_colorizer(ea, nbytes):
           global ida_colorizer
           orig = ida_kernwin.call_nav_colorizer(ida_colorizer, ea, nbytes)
           return long(~orig)

       ida_colorizer = ida_kernwin.set_nav_colorizer(my_colorizer)

   :param callback: the new colorizer


.. py:function:: call_nav_colorizer(colorizer, ea: ida_idaapi.ea_t, nbytes: int)

   To be used with the IDA-provided colorizer, that is
   returned as result of the first call to set_nav_colorizer().

   :param colorizer: the Python colorizer to call
   :param ea: the address to colorize
   :param nbytes: the size of the range to colorize


.. py:function:: msg_get_lines(count: int = -1) -> PyObject *

   Retrieve the last 'count' lines from the output window, in reverse order (from most recent, to least recent) 
           
   :param count: The number of lines to retrieve. -1 means: all


.. py:function:: TWidget__from_ptrval__(ptrval: size_t) -> TWidget *

.. py:data:: MAX_SPACES_ADDED

.. py:function:: add_spaces(s: str, len: size_t) -> str

   Add space characters to the colored string so that its length will be at least 'len' characters. Don't trim the string if it is longer than 'len'. 
           
   :param len: the desired length of the string
   :returns: pointer to the end of input string


.. py:function:: show_wait_box(message: str) -> None

   Display a dialog box with "Please wait...". The behavior of the dialog box can be configured with well-known 
   tokens, that should be placed at the start of the format string: 
    "NODELAY\n": the dialog will show immediately, instead of 
    appearing after usual grace threshold 
    "HIDECANCEL\n": the cancel button won't be added to the dialog box 
    and user_cancelled() will always return false (but 
    can be called to refresh UI) 
    Using "HIDECANCEL" implies "NODELAY" 
   Plugins must call hide_wait_box() to close the dialog box, otherwise 
   the user interface will remain disabled. 
    Note that, if the wait dialog is already visible, show_wait_box() will 
    1) push the currently-displayed text on a stack 
    2) display the new text 
   Then, when hide_wait_box() is called, if that stack isn't empty its top 
   label will be popped and restored in the wait dialog. 
   This implies that a plugin should call hide_wait_box() exactly as many 
   times as it called show_wait_box(), or the wait dialog might remain 
   visible and block the UI. 
   Also, in case the plugin knows the wait dialog is currently displayed, 
   alternatively it can call replace_wait_box(), to replace the text of the
   dialog without pushing the currently-displayed text on the stack. 
           


.. py:function:: hide_wait_box() -> None

   Hide the "Please wait dialog box".


.. py:class:: line_rendering_output_entries_refs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> line_rendering_output_entry_t *&


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> line_rendering_output_entry_t *const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: line_rendering_output_entries_refs_t) -> None


   .. py:method:: extract() -> line_rendering_output_entry_t **


   .. py:method:: inject(s: line_rendering_output_entry_t **, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< line_rendering_output_entry_t * >::const_iterator


   .. py:method:: end(*args) -> qvector< line_rendering_output_entry_t * >::const_iterator


   .. py:method:: insert(it: qvector< line_rendering_output_entry_t * >::iterator, x: line_rendering_output_entry_t) -> qvector< line_rendering_output_entry_t * >::iterator


   .. py:method:: erase(*args) -> qvector< line_rendering_output_entry_t * >::iterator


   .. py:method:: find(*args) -> qvector< line_rendering_output_entry_t * >::const_iterator


   .. py:method:: has(x: line_rendering_output_entry_t) -> bool


   .. py:method:: add_unique(x: line_rendering_output_entry_t) -> bool


   .. py:method:: append(x: line_rendering_output_entry_t) -> None


   .. py:method:: extend(x: line_rendering_output_entries_refs_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: section_lines_refs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> twinline_t const *&


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> twinline_t const *const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: section_lines_refs_t) -> None


   .. py:method:: extract() -> twinline_t const **


   .. py:method:: inject(s: twinline_t const **, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< twinline_t const * >::const_iterator


   .. py:method:: end(*args) -> qvector< twinline_t const * >::const_iterator


   .. py:method:: insert(it: qvector< twinline_t const * >::iterator, x: twinline_t) -> qvector< twinline_t const * >::iterator


   .. py:method:: erase(*args) -> qvector< twinline_t const * >::iterator


   .. py:method:: find(*args) -> qvector< twinline_t const * >::const_iterator


   .. py:method:: has(x: twinline_t) -> bool


   .. py:method:: add_unique(x: twinline_t) -> bool


   .. py:method:: append(x: twinline_t) -> None


   .. py:method:: extend(x: section_lines_refs_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: sections_lines_refs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> section_lines_refs_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> section_lines_refs_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: sections_lines_refs_t) -> None


   .. py:method:: extract() -> section_lines_refs_t *


   .. py:method:: inject(s: section_lines_refs_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< section_lines_refs_t >::const_iterator


   .. py:method:: end(*args) -> qvector< section_lines_refs_t >::const_iterator


   .. py:method:: insert(it: qvector< section_lines_refs_t >::iterator, x: section_lines_refs_t) -> qvector< section_lines_refs_t >::iterator


   .. py:method:: erase(*args) -> qvector< section_lines_refs_t >::iterator


   .. py:method:: find(*args) -> qvector< section_lines_refs_t >::const_iterator


   .. py:method:: has(x: section_lines_refs_t) -> bool


   .. py:method:: add_unique(x: section_lines_refs_t) -> bool


   .. py:method:: append(x: section_lines_refs_t) -> None


   .. py:method:: extend(x: sections_lines_refs_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: text_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> twinline_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> twinline_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: text_t) -> None


   .. py:method:: extract() -> twinline_t *


   .. py:method:: inject(s: twinline_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< twinline_t >::const_iterator


   .. py:method:: end(*args) -> qvector< twinline_t >::const_iterator


   .. py:method:: insert(it: twinline_t, x: twinline_t) -> qvector< twinline_t >::iterator


   .. py:method:: erase(*args) -> qvector< twinline_t >::iterator


   .. py:method:: append(x: twinline_t) -> None


   .. py:method:: extend(x: text_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: sync_source_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(x: sync_source_t) -> None


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> sync_source_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: sync_source_vec_t) -> None


   .. py:method:: extract() -> sync_source_t *


   .. py:method:: inject(s: sync_source_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< sync_source_t >::const_iterator


   .. py:method:: end(*args) -> qvector< sync_source_t >::const_iterator


   .. py:method:: insert(it: sync_source_t, x: sync_source_t) -> qvector< sync_source_t >::iterator


   .. py:method:: erase(*args) -> qvector< sync_source_t >::iterator


   .. py:method:: find(*args) -> qvector< sync_source_t >::const_iterator


   .. py:method:: has(x: sync_source_t) -> bool


   .. py:method:: add_unique(x: sync_source_t) -> bool


   .. py:method:: append(x: sync_source_t) -> None


   .. py:method:: extend(x: sync_source_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: mbox_internal

   internal error


.. py:data:: mbox_info

.. py:data:: mbox_warning

.. py:data:: mbox_error

.. py:data:: mbox_nomem

.. py:data:: mbox_feedback

.. py:data:: mbox_readerror

.. py:data:: mbox_writeerror

.. py:data:: mbox_filestruct

.. py:data:: mbox_wait

.. py:data:: mbox_hide

.. py:data:: mbox_replace

.. py:data:: chtype_generic

   the generic choose() function


.. py:data:: chtype_idasgn

   see choose_idasgn()


.. py:data:: chtype_entry

   see choose_entry()


.. py:data:: chtype_name

   see choose_name()


.. py:data:: chtype_stkvar_xref

   see choose_stkvar_xref()


.. py:data:: chtype_xref

   see choose_xref()


.. py:data:: chtype_func

   see choose_func()


.. py:data:: chtype_segm

   see choose_segm()


.. py:data:: chtype_strpath

   see choose_struc_path()


.. py:data:: chtype_idatil

   see choose_til()


.. py:data:: chtype_srcp

   see choose_srcp()


.. py:data:: chtype_struct

   see choose_struct()


.. py:data:: chtype_enum

   see choose_enum()


.. py:data:: chtype_enum_by_value_and_size

   see choose_enum_by_value()


.. py:data:: beep_default

.. py:data:: TCCRT_INVALID

   invalid


.. py:data:: TCCRT_FLAT

   flat view


.. py:data:: TCCRT_GRAPH

   graph view


.. py:data:: TCCRT_PROXIMITY

   proximity view


.. py:data:: TCCPT_INVALID

   invalid


.. py:data:: TCCPT_PLACE

   place_t


.. py:data:: TCCPT_SIMPLELINE_PLACE

   simpleline_place_t


.. py:data:: TCCPT_IDAPLACE

   idaplace_t


.. py:data:: TCCPT_TIPLACE

   tiplace_t


.. py:data:: VME_UNKNOWN

   unknown mouse button


.. py:data:: VME_LEFT_BUTTON

   left mouse button


.. py:data:: VME_RIGHT_BUTTON

   right mouse button


.. py:data:: VME_MID_BUTTON

   middle mouse button


.. py:data:: SETMENU_POSMASK

.. py:data:: SETMENU_INS

   add menu item before the specified path (default)


.. py:data:: SETMENU_APP

   add menu item after the specified path


.. py:data:: SETMENU_FIRST

   add item to the beginning of menu


.. py:data:: SETMENU_ENSURE_SEP

   make sure there is a separator before the action


.. py:data:: CREATETB_ADV

   toolbar is for 'advanced mode' only


.. py:data:: HIF_IDENTIFIER

   text is an identifier (i.e., when searching for the current highlight, SEARCH_IDENT will be used)


.. py:data:: HIF_REGISTER

   text represents a register (aliases/subregisters will be highlit as well)


.. py:data:: HIF_LOCKED

   locked; clicking/moving the cursor around doesn't change the highlight


.. py:data:: HIF_NOCASE

   case insensitive


.. py:data:: HIF_USE_SLOT

   use the given number, or just use the "floating" highlight


.. py:data:: HIF_SLOT_SHIFT

   position of the 3 top bits specifying which highlight to use


.. py:data:: HIF_SLOT_0

   operate on slot 0


.. py:data:: HIF_SLOT_1

   operate on slot 1


.. py:data:: HIF_SLOT_2

   operate on slot 2


.. py:data:: HIF_SLOT_3

   operate on slot 3


.. py:data:: HIF_SLOT_4

   operate on slot 4


.. py:data:: HIF_SLOT_5

   operate on slot 5


.. py:data:: HIF_SLOT_6

   operate on slot 6


.. py:data:: HIF_SLOT_7

   operate on slot 7


.. py:data:: REG_HINTS_MARKER

.. py:data:: REG_HINTS_MARKER_LEN

.. py:data:: SRCDBG_HINTS_MARKER

.. py:data:: SRCDBG_HINTS_MARKER_LEN

.. py:data:: CDVF_NOLINES

   don't show line numbers


.. py:data:: CDVF_LINEICONS

   icons can be drawn over the line control


.. py:data:: CDVF_STATUSBAR

   keep the status bar in the custom viewer


.. py:data:: IDCHK_OK

   ok


.. py:data:: IDCHK_ARG

   bad argument(s)


.. py:data:: IDCHK_KEY

   bad hotkey name


.. py:data:: IDCHK_MAX

   too many IDC hotkeys


.. py:data:: WCLS_SAVE

   save state in desktop config


.. py:data:: WCLS_NO_CONTEXT

   don't change the current context (useful for toolbars)


.. py:data:: WCLS_DONT_SAVE_SIZE

   don't save size of the window


.. py:data:: WCLS_DELETE_LATER

   assign the deletion of the widget to the UI loop ///<


.. py:data:: WCLS_CLOSE_LATER

.. py:data:: DP_LEFT

   Dock src_form to the left of dest_form.


.. py:data:: DP_TOP

   Dock src_form above dest_form.


.. py:data:: DP_RIGHT

   Dock src_form to the right of dest_form.


.. py:data:: DP_BOTTOM

   Dock src_form below dest_form.


.. py:data:: DP_INSIDE

   Create a new tab bar with both src_form and dest_form.


.. py:data:: DP_TAB

   Place src_form into a tab next to dest_form, if dest_form is in a tab bar (otherwise the same as DP_INSIDE) 
           


.. py:data:: DP_BEFORE

   Place src_form before dst_form in the tab bar instead of after; used with DP_INSIDE or DP_TAB. 
           


.. py:data:: DP_FLOATING

   Make src_form floating.


.. py:data:: DP_SZHINT

   When floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
           


.. py:data:: SVF_COPY_LINES

   keep a local copy of '*lines'


.. py:data:: SVF_LINES_BYPTR

   remember the 'lines' ptr. do not make a copy of '*lines'


.. py:data:: CVNF_LAZY

   try and move the cursor to a line displaying the place_t if possible. This might disregard the Y position in case of success 
           


.. py:data:: CVNF_JUMP

   push the current position in this viewer's lochist_t before going to the new location 
           


.. py:data:: CVNF_ACT

   activate (i.e., switch to) the viewer. Activation is performed before the new lochist_entry_t instance is actually copied to the viewer's lochist_t (otherwise, if the viewer was invisible its on_location_changed() handler wouldn't be called.) 
           


.. py:data:: WOPN_RESTORE

   if the widget was the only widget in a floating area the last time it was closed, it will be restored as floating, with the same position+size as before 
           


.. py:data:: WOPN_PERSIST

   widget will remain available when starting or stopping debugger sessions


.. py:data:: WOPN_CLOSED_BY_ESC

   override idagui.cfg:CLOSED_BY_ESC: esc will close


.. py:data:: WOPN_NOT_CLOSED_BY_ESC

   override idagui.cfg:CLOSED_BY_ESC: esc will not close


.. py:data:: WOPN_DP_MASK

.. py:data:: WOPN_DP_SHIFT

.. py:data:: WOPN_DP_LEFT

   Dock widget to the left of dest_ctrl.


.. py:data:: WOPN_DP_TOP

   Dock widget above dest_ctrl.


.. py:data:: WOPN_DP_RIGHT

   Dock widget to the right of dest_ctrl.


.. py:data:: WOPN_DP_BOTTOM

   Dock widget below dest_ctrl.


.. py:data:: WOPN_DP_INSIDE

   Create a new tab bar with both widget and dest_ctrl.


.. py:data:: WOPN_DP_TAB

   Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar (otherwise the same as WOPN_DP_INSIDE) 
           


.. py:data:: WOPN_DP_BEFORE

   Place widget before dst_form in the tab bar instead of after; used with WOPN_DP_INSIDE and WOPN_DP_TAB 
           


.. py:data:: WOPN_DP_FLOATING

   Make widget floating.


.. py:data:: WOPN_DP_SZHINT

   when floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
           


.. py:data:: WOPN_DP_INSIDE_BEFORE

.. py:data:: WOPN_DP_TAB_BEFORE

.. py:data:: RENADDR_IDA

   dialog for "IDA View"


.. py:data:: RENADDR_HR

   dialog for "Pseudocode"; additional flags:
   * 0x01 Library function
   * 0x02 Mark as decompiled 


           


.. py:data:: CVLF_USE_MOUSE

   Fetch the location from the mouse, instead of caret in the listing.


.. py:function:: get_kernel_version() -> str

   Get IDA kernel version (in a string like "5.1").


.. py:function:: is_ida_library(path: char * = None, pathsize: size_t = 0, handle: void ** = None) -> bool

.. py:class:: place_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: lnnum
      :type:  int

      Number of line within the current object.



   .. py:method:: touval(ud: void *) -> int

      Map the location to a number. This mapping is used to draw the vertical scrollbar. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t



   .. py:method:: clone() -> place_t *

      Clone the location. 
              
      :returns: a pointer to a copy of the current location in dynamic memory



   .. py:method:: copyfrom(_from: place_t) -> None

      Copy the specified location object to the current object.



   .. py:method:: makeplace(ud: void *, x: int, lnnum: int) -> place_t *

      Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :param x: number to map
      :param lnnum: line number to initialize 'lnnum'
      :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES



   .. py:method:: compare(t2: place_t) -> int

      Deprecated. Please consider compare2(const place_t *, void *) instead.



   .. py:method:: adjust(ud: void *) -> None

      Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t



   .. py:method:: prev(ud: void *) -> bool

      Move to the previous displayable location. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :returns: success



   .. py:method:: next(ud: void *) -> bool

      Move to the next displayable location. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :returns: success



   .. py:method:: beginning(ud: void *) -> bool

      Are we at the first displayable object?. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :returns: true if the current location points to the first displayable object



   .. py:method:: ending(ud: void *) -> bool

      Are we at the last displayable object?. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :returns: true if the current location points to the last displayable object



   .. py:method:: serialize() -> None

      Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
              



   .. py:method:: id() -> int

      Get the place's ID (i.e., the value returned by register_place_class()) 
              
      :returns: the id



   .. py:method:: name() -> str

      Get this place type name. All instances of a given class must return the same string. 
              
      :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".



   .. py:method:: toea() -> ida_idaapi.ea_t

      Map the location to an ea_t. 
              
      :returns: the corresponding ea_t, or BADADDR;



   .. py:method:: rebase(arg2: segm_move_infos_t const &) -> bool

      Rebase the place instance 
              
      :returns: true if place was rebased, false otherwise



   .. py:method:: enter(arg2: uint32 *) -> place_t *

      Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
              
      :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.



   .. py:method:: leave(arg2: int) -> None

      Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
              



   .. py:method:: compare2(t2: place_t, arg3: void *) -> int

      Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
              
      :param t2: the place to compare this one to.
      :returns: -1: if the current location is less than 't2'
      :returns: 0: if the current location is equal to than 't2'
      :returns: 1: if the current location is greater than 't2'



   .. py:method:: equals(t2: place_t, ud: void *) -> bool

      Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.

      :returns: true if the two places match / are equal.



   .. py:method:: deserialize(_in: bytevec_t const &) -> bool

      De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
              
      :returns: whether de-serialization was successful



   .. py:method:: as_idaplace_t(p: place_t) -> idaplace_t *
      :staticmethod:



   .. py:method:: as_simpleline_place_t(p: place_t) -> simpleline_place_t *
      :staticmethod:



   .. py:method:: as_tiplace_t(p: place_t) -> tiplace_t *
      :staticmethod:



   .. py:method:: generate(ud, maxsize: int) -> Tuple[List[str], int, int, int]

      Generate text lines for the current location.

      :param ud: The user data object
      :param maxsize: The maximum number of lines to generate
      :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)



.. py:data:: cvar

.. py:data:: IDALIB_API_MAGIC

.. py:data:: DEFAULT_PLACE_LNNUM

.. py:function:: l_compare2(t1: place_t, t2: place_t, ud: void *) -> int

.. py:function:: l_equals(t1: place_t, t2: place_t, ud: void *) -> bool

.. py:class:: simpleline_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: line
      :type:  str

      line text



   .. py:attribute:: color
      :type:  color_t

      line prefix color



   .. py:attribute:: bgcolor
      :type:  bgcolor_t

      line background color



.. py:class:: simpleline_place_t(*args, **kwargs)

   Bases: :py:obj:`place_t`


   .. py:attribute:: thisown


   .. py:attribute:: n
      :type:  int

      line number



.. py:class:: idaplace_t(*args, **kwargs)

   Bases: :py:obj:`place_t`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      address



.. py:function:: is_tif_cursor_header(c: tif_cursor_t) -> bool

.. py:function:: is_tif_cursor_footer(c: tif_cursor_t) -> bool

.. py:function:: is_tif_cursor_index(c: tif_cursor_t) -> bool

.. py:class:: tiplace_t(*args, **kwargs)

   Bases: :py:obj:`place_t`


   .. py:attribute:: thisown


   .. py:attribute:: ordinal
      :type:  int


   .. py:attribute:: cursor
      :type:  tif_cursor_t


   .. py:method:: valid_ord() -> bool


   .. py:method:: reset() -> None


   .. py:method:: is_header() -> bool


   .. py:method:: is_footer() -> bool


   .. py:method:: is_index() -> bool


   .. py:method:: set_header() -> None


   .. py:method:: set_footer() -> None


   .. py:method:: calc_udm_offset(ud: void const *, p_udmidx: ssize_t * = None, p_bitoff: int * = None) -> uint64

      for structs: calculate the offset that corresponds to the tiplace. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :param p_udmidx: place to return the index of the current udt member, if any. if there is no member at the current offset, return -1
      :param p_bitoff: place to return the bit offset of the item from the beginning of the bit bucket if there no bitfields, return -1
      :returns: the current offset or uint64(-1)



   .. py:method:: set_index_by_offset(ud: void *, offset: uint64) -> None

      for structs: calculate the index that corresponds to the offset and set it. 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :param offset: offset of udt member



   .. py:method:: get_kind(ud: void const *) -> type_t

      get the kind of type this place represents 
              
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :returns: one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM or BT_UNK



   .. py:method:: fill_type_ref(out: til_type_ref_t, ud: void const *) -> bool

      fill the type information for use in actions 
              
      :param out: pointer to storage
      :param ud: pointer to user-defined context data. Is supplied by linearray_t
      :returns: success



.. py:data:: PCF_EA_CAPABLE

   toea() implementation returns meaningful data


.. py:data:: PCF_MAKEPLACE_ALLOCATES

   makeplace() returns a freshly allocated (i.e., non-static) instance. All new code should pass that flag to register_place_class(), and the corresponding makeplace() class implementation should return new instances. 
           


.. py:function:: internal_register_place_class(tmplate: place_t, flags: int, owner: plugin_t const *, sdk_version: int) -> int

.. py:function:: get_place_class(out_flags: int *, out_sdk_version: int *, id: int) -> place_t const *

   Get information about a previously-registered place_t class. See also register_place_class(). 
           
   :param out_flags: output flags (can be nullptr)
   :param out_sdk_version: sdk version the place was created with (can be nullptr)
   :param id: place class ID
   :returns: the place_t template, or nullptr if not found


.. py:function:: get_place_class_template(id: int) -> place_t const *

   See get_place_class()


.. py:function:: is_place_class_ea_capable(id: int) -> bool

   See get_place_class()


.. py:function:: get_place_class_id(name: str) -> int

   Get the place class ID for the place that has been registered as 'name'. 
           
   :param name: the class name
   :returns: the place class ID, or -1 if not found


.. py:class:: sync_source_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: is_register() -> bool


   .. py:method:: is_widget() -> bool


   .. py:method:: get_widget() -> TWidget const *


   .. py:method:: get_register() -> str


.. py:class:: synced_group_t

   Bases: :py:obj:`sync_source_vec_t`


   .. py:attribute:: thisown


   .. py:method:: has_widget(v: TWidget const *) -> bool


   .. py:method:: has_register(r: str) -> bool


   .. py:method:: has(ss: sync_source_t) -> bool


.. py:data:: LECVT_CANCELED

.. py:data:: LECVT_ERROR

.. py:data:: LECVT_OK

.. py:data:: LECVT_WITHIN_LISTING

.. py:class:: twinpos_t(t: place_t = None, x0: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: at
      :type:  place_t *

      location in view



   .. py:attribute:: x
      :type:  int

      cursor x



   .. py:method:: place_as_idaplace_t()


   .. py:method:: place_as_simpleline_place_t()


   .. py:method:: place_as_tiplace_t()


   .. py:method:: place(view)


.. py:class:: twinline_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: at
      :type:  place_t *

      location in view



   .. py:attribute:: line
      :type:  str

      line contents



   .. py:attribute:: prefix_color
      :type:  color_t

      line prefix color



   .. py:attribute:: bg_color
      :type:  bgcolor_t

      line background color



   .. py:attribute:: is_default
      :type:  bool

      is this the default line of the current location?



.. py:class:: linearray_t(_ud: void *)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: set_place(new_at: place_t) -> int

      Position the array. This function must be called before calling any other member functions. 
              
      :param new_at: new position of the array. linearray will make a clone of this object.
      :returns: the delta of lines that the linearray_t had to adjust the place by. 
      For example, if the place_t has a lnnum of 5, but it turns out, upon generating lines, 
      that the number of lines for that particular place is only 2, then 3 will be returned.



   .. py:method:: copy_from(src: linearray_t) -> None

      Copy information from one linearray to another. Only linearray objects with compatible 'ud' fields can be copied. 
              



   .. py:method:: get_place() -> place_t *

      Get the current place. If called before down(), then returns place of line which will be returned by down(). If called after up(), then returns place if line returned by up(). 
              



   .. py:method:: get_bg_color() -> bgcolor_t

      Get current background color. (the same behavior as with get_place(): good before down() and after up()) 
              



   .. py:method:: get_pfx_color() -> bgcolor_t

      Get current prefix color. (the same behavior as with get_place(): good before down() and after up()) 
              



   .. py:method:: get_dlnnum() -> int

      Get default line number. (the same behavior as with get_place(): good before down() and after up()) 
              



   .. py:method:: get_linecnt() -> int

      Get number of lines for the current place. (the same behavior as with get_place(): good before down() and after up()) 
              



   .. py:method:: userdata() -> void *

      Get pointer to user data.



   .. py:method:: set_userdata(userd: void *) -> None

      Change the user data.



   .. py:method:: beginning() -> bool

      Are we at the beginning?



   .. py:method:: ending() -> bool


   .. py:method:: down() -> str

      Get the next line going downwards. 'at' for the retrieved line is correct BEFORE calling this function. 
              



   .. py:method:: up() -> str

      Get the next line going upwards. 'at' for the retrieved line is correct AFTER calling this function. 
              



   .. py:method:: set_max_lines(n: int) -> None

      Set max number of lines to generate for a place. 0 means to use the default value, MAX_ITEM_LINES from ida.cfg 
              



.. py:class:: lines_rendering_input_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  int


   .. py:attribute:: sections_lines
      :type:  sections_lines_refs_t

      references to the lines that are used for rendering 
              



   .. py:attribute:: sync_group
      :type:  synced_group_t const *

      the 'synced' group 'widget' (see ui_get_lines_rendering_info) belongs to, or nullptr 
              



.. py:data:: CK_TRACE

   traced address


.. py:data:: CK_TRACE_OVL

   overlay trace address


.. py:data:: CK_EXTRA1

   extra background overlay #1


.. py:data:: CK_EXTRA2

   extra background overlay #2


.. py:data:: CK_EXTRA3

   extra background overlay #3


.. py:data:: CK_EXTRA4

   extra background overlay #4


.. py:data:: CK_EXTRA5

   extra background overlay #5


.. py:data:: CK_EXTRA6

   extra background overlay #6


.. py:data:: CK_EXTRA7

   extra background overlay #7


.. py:data:: CK_EXTRA8

   extra background overlay #8


.. py:data:: CK_EXTRA9

   extra background overlay #9


.. py:data:: CK_EXTRA10

   extra background overlay #10


.. py:data:: CK_EXTRA11

   extra background overlay #11


.. py:data:: CK_EXTRA12

   extra background overlay #12


.. py:data:: CK_EXTRA13

   extra background overlay #13


.. py:data:: CK_EXTRA14

   extra background overlay #14


.. py:data:: CK_EXTRA15

   extra background overlay #15


.. py:data:: CK_EXTRA16

   extra background overlay #16


.. py:data:: LROEF_MASK

.. py:data:: LROEF_FULL_LINE

   full line background


.. py:data:: LROEF_CPS_RANGE

   background for range of chars


.. py:class:: line_rendering_output_entry_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: line
      :type:  twinline_t const *


   .. py:attribute:: flags
      :type:  int

      line_rendering_output_entry_t flags



   .. py:attribute:: bg_color
      :type:  bgcolor_t


   .. py:attribute:: cpx
      :type:  int

      number of char to start from, valid if LROEF_CPS_RANGE



   .. py:attribute:: nchars
      :type:  int

      chars count, valid if LROEF_CPS_RANGE



   .. py:method:: is_bg_color_empty() -> bool


   .. py:method:: is_bg_color_key() -> bool


   .. py:method:: is_bg_color_direct() -> bool


.. py:class:: lines_rendering_output_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: entries
      :type:  line_rendering_output_entries_refs_t


   .. py:attribute:: flags
      :type:  int


   .. py:method:: clear() -> None


   .. py:method:: swap(r: lines_rendering_output_t) -> None


.. py:class:: line_section_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: start
      :type:  cpidx_t


   .. py:attribute:: length
      :type:  cplen_t


   .. py:method:: contains(x: cpidx_t) -> bool


   .. py:method:: is_open() -> bool


   .. py:method:: is_closed() -> bool


   .. py:method:: valid() -> bool


.. py:class:: tagged_line_section_t

   Bases: :py:obj:`line_section_t`


   .. py:attribute:: thisown


   .. py:attribute:: tag
      :type:  color_t


   .. py:method:: valid() -> bool


   .. py:method:: valid_in(_in: str) -> bool


   .. py:method:: substr(_in: str, end: tagged_line_section_t = None) -> bool


.. py:class:: tagged_line_sections_t

   Bases: :py:obj:`tagged_line_section_vec_t`


   .. py:attribute:: thisown


   .. py:method:: first(tag: color_t) -> tagged_line_section_t const *


   .. py:method:: sections_at(out: tagged_line_sections_t, x: cpidx_t, tag: color_t = 0) -> None


   .. py:method:: nearest_at(x: cpidx_t, tag: color_t = 0) -> tagged_line_section_t const *


   .. py:method:: nearest_before(range: tagged_line_section_t, start: cpidx_t, tag: color_t = 0) -> tagged_line_section_t const *


   .. py:method:: nearest_after(range: tagged_line_section_t, start: cpidx_t, tag: color_t = 0) -> tagged_line_section_t const *


.. py:class:: listing_location_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  int


   .. py:attribute:: loc
      :type:  lochist_entry_t const *


   .. py:attribute:: text
      :type:  str


   .. py:attribute:: tagged_sections
      :type:  tagged_line_sections_t const *


.. py:function:: request_refresh(mask: uint64, cnd: bool = True) -> None

   Request a refresh of a builtin window. 
           
   :param mask: Window refresh flags
   :param cnd: set if true or clear flag otherwise


.. py:function:: clear_refresh_request(mask: uint64) -> None

.. py:function:: is_refresh_requested(mask: uint64) -> bool

   Get a refresh request state 
           
   :param mask: Window refresh flags
   :returns: the state (set or cleared)


.. py:data:: BWN_UNKNOWN

   unknown window


.. py:data:: BWN_EXPORTS

   exports


.. py:data:: BWN_IMPORTS

   imports


.. py:data:: BWN_NAMES

   names


.. py:data:: BWN_FUNCS

   functions


.. py:data:: BWN_STRINGS

   strings


.. py:data:: BWN_SEGS

   segments


.. py:data:: BWN_SEGREGS

   segment registers


.. py:data:: BWN_SELS

   selectors


.. py:data:: BWN_SIGNS

   signatures


.. py:data:: BWN_TILS

   type libraries


.. py:data:: BWN_TICSR

   type library widget's (e.g., "Local types") chooser


.. py:data:: BWN_CALLS

   function calls


.. py:data:: BWN_PROBS

   problems


.. py:data:: BWN_BPTS

   breakpoints


.. py:data:: BWN_THREADS

   threads


.. py:data:: BWN_MODULES

   modules


.. py:data:: BWN_TRACE

   tracing view


.. py:data:: BWN_CALL_STACK

   call stack


.. py:data:: BWN_XREFS

   xrefs


.. py:data:: BWN_SEARCH

   search results


.. py:data:: BWN_FRAME

   function frame


.. py:data:: BWN_NAVBAND

   navigation band


.. py:data:: BWN_DISASM

   disassembly views


.. py:data:: BWN_HEXVIEW

   hex view


.. py:data:: BWN_NOTEPAD

   notepad


.. py:data:: BWN_OUTPUT

   the text area, in the output window


.. py:data:: BWN_CLI

   the command-line, in the output window


.. py:data:: BWN_WATCH

   the 'watches' debugger window


.. py:data:: BWN_LOCALS

   the 'locals' debugger window


.. py:data:: BWN_STKVIEW

   the 'Stack view' debugger window


.. py:data:: BWN_CHOOSER

   a non-builtin chooser


.. py:data:: BWN_SHORTCUTCSR

   the shortcuts chooser (Qt version only)


.. py:data:: BWN_SHORTCUTWIN

   the shortcuts window (Qt version only)


.. py:data:: BWN_CPUREGS

   one of the 'General registers', 'FPU register', ... debugger windows


.. py:data:: BWN_SO_STRUCTS

   the 'Structure offsets' dialog's 'Structures and Unions' panel


.. py:data:: BWN_SO_OFFSETS

   the 'Structure offsets' dialog's offset panel


.. py:data:: BWN_CMDPALCSR

   the command palette chooser (Qt version only)


.. py:data:: BWN_CMDPALWIN

   the command palette window (Qt version only)


.. py:data:: BWN_SNIPPETS

   the 'Execute script' window


.. py:data:: BWN_CUSTVIEW

   custom viewers


.. py:data:: BWN_ADDRWATCH

   the 'Watch List' window


.. py:data:: BWN_PSEUDOCODE

   hexrays decompiler views


.. py:data:: BWN_CALLS_CALLERS

   function calls, callers


.. py:data:: BWN_CALLS_CALLEES

   function calls, callees


.. py:data:: BWN_MDVIEWCSR

   lumina metadata view chooser


.. py:data:: BWN_DISASM_ARROWS

   disassembly arrows widget


.. py:data:: BWN_CV_LINE_INFOS

   custom viewers' lineinfo widget


.. py:data:: BWN_SRCPTHMAP_CSR

   "Source paths..."'s path mappings chooser


.. py:data:: BWN_SRCPTHUND_CSR

   "Source paths..."'s undesired paths chooser


.. py:data:: BWN_UNDOHIST

   Undo history.


.. py:data:: BWN_SNIPPETS_CSR

   the list of snippets in the 'Execute script' window


.. py:data:: BWN_SCRIPTS_CSR

   the "Recent scripts" chooser


.. py:data:: BWN_BOOKMARKS

   a persistent 'Bookmarks' widget


.. py:data:: BWN_TILIST

   a type listing widget


.. py:data:: BWN_TIL_VIEW

   a type library's toplevel widget


.. py:data:: BWN_TYPE_EDITOR

   a type editor


.. py:data:: BWN_MICROCODE

   microcode view (part of hexrays decompiler)


.. py:data:: BWN_XREF_TREE

   xref tree widget


.. py:data:: IWID_EXPORTS

   exports


.. py:data:: IWID_IMPORTS

   imports


.. py:data:: IWID_NAMES

   names


.. py:data:: IWID_FUNCS

   functions


.. py:data:: IWID_STRINGS

   strings


.. py:data:: IWID_SEGS

   segments


.. py:data:: IWID_SEGREGS

   segment registers


.. py:data:: IWID_SELS

   selectors


.. py:data:: IWID_SIGNS

   signatures


.. py:data:: IWID_TILS

   type libraries


.. py:data:: IWID_TICSR

   type library widget's (e.g., "Local types") chooser


.. py:data:: IWID_CALLS

   function calls


.. py:data:: IWID_PROBS

   problems


.. py:data:: IWID_BPTS

   breakpoints


.. py:data:: IWID_THREADS

   threads


.. py:data:: IWID_MODULES

   modules


.. py:data:: IWID_TRACE

   tracing view


.. py:data:: IWID_CALL_STACK

   call stack


.. py:data:: IWID_XREFS

   xrefs


.. py:data:: IWID_SEARCH

   search results


.. py:data:: IWID_FRAME

   function frame


.. py:data:: IWID_NAVBAND

   navigation band


.. py:data:: IWID_DISASM

   disassembly views


.. py:data:: IWID_HEXVIEW

   hex views


.. py:data:: IWID_NOTEPAD

   notepad


.. py:data:: IWID_OUTPUT

   output


.. py:data:: IWID_CLI

   input line


.. py:data:: IWID_WATCH

   watches


.. py:data:: IWID_LOCALS

   locals


.. py:data:: IWID_STKVIEW

   stack view


.. py:data:: IWID_CHOOSER

   chooser


.. py:data:: IWID_SHORTCUTCSR

   shortcuts chooser


.. py:data:: IWID_SHORTCUTWIN

   shortcuts window


.. py:data:: IWID_CPUREGS

   registers


.. py:data:: IWID_SO_STRUCTS

   stroff


.. py:data:: IWID_SO_OFFSETS

   stroff


.. py:data:: IWID_CMDPALCSR

   command palette


.. py:data:: IWID_CMDPALWIN

   command palette


.. py:data:: IWID_SNIPPETS

   snippets


.. py:data:: IWID_CUSTVIEW

   custom viewers


.. py:data:: IWID_ADDRWATCH

   address watches


.. py:data:: IWID_PSEUDOCODE

   decompiler


.. py:data:: IWID_CALLS_CALLERS

   funcalls, callers


.. py:data:: IWID_CALLS_CALLEES

   funcalls, callees


.. py:data:: IWID_MDVIEWCSR

   lumina md view


.. py:data:: IWID_DISASM_ARROWS

   arrows widget


.. py:data:: IWID_CV_LINE_INFOS

   lineinfo widget


.. py:data:: IWID_SRCPTHMAP_CSR

   mappings chooser


.. py:data:: IWID_SRCPTHUND_CSR

   undesired chooser


.. py:data:: IWID_UNDOHIST

   Undo history.


.. py:data:: IWID_SNIPPETS_CSR

   snippets chooser


.. py:data:: IWID_SCRIPTS_CSR

   recent scripts


.. py:data:: IWID_BOOKMARKS

   bookmarks list


.. py:data:: IWID_TILIST

   type listing


.. py:data:: IWID_TIL_VIEW

   type library's toplevel widget


.. py:data:: IWID_TYPE_EDITOR

   a type editor


.. py:data:: IWID_XREF_TREE

   xref tree widget


.. py:data:: IWID_ANY_LISTING

   anything that uses a listing widget


.. py:data:: IWID_EA_LISTING

   anything that can be used to represent data/code at an address


.. py:data:: IWID_ALL

   mask


.. py:function:: is_chooser_widget(t: twidget_type_t) -> bool

   Does the given widget type specify a chooser widget?


.. py:data:: IDA_DEBUG_DREFS

   drefs


.. py:data:: IDA_DEBUG_OFFSET

   offsets


.. py:data:: IDA_DEBUG_FLIRT

   flirt


.. py:data:: IDA_DEBUG_IDP

   idp module


.. py:data:: IDA_DEBUG_LDR

   ldr module


.. py:data:: IDA_DEBUG_PLUGIN

   plugin module


.. py:data:: IDA_DEBUG_IDS

   ids files


.. py:data:: IDA_DEBUG_CONFIG

   config file


.. py:data:: IDA_DEBUG_CHECKMEM

   check heap consistency


.. py:data:: IDA_DEBUG_LICENSE

   licensing


.. py:data:: IDA_DEBUG_DEMANGLE

   demangler


.. py:data:: IDA_DEBUG_QUEUE

   queue


.. py:data:: IDA_DEBUG_ROLLBACK

   rollback


.. py:data:: IDA_DEBUG_ALREADY

   already data or code


.. py:data:: IDA_DEBUG_TIL

   type system


.. py:data:: IDA_DEBUG_NOTIFY

   show all notifications


.. py:data:: IDA_DEBUG_DEBUGGER

   debugger


.. py:data:: IDA_DEBUG_APPCALL

   appcall


.. py:data:: IDA_DEBUG_SRCDBG

   source debugging


.. py:data:: IDA_DEBUG_ACCESSIBILITY

   accessibility


.. py:data:: IDA_DEBUG_NETWORK

   network


.. py:data:: IDA_DEBUG_INTERNET

   internet connection (for API backward compatibility)


.. py:data:: IDA_DEBUG_SIMPLEX

   full stack analysis


.. py:data:: IDA_DEBUG_DBGINFO

   handling of debug info (e.g. pdb, dwarf)


.. py:data:: IDA_DEBUG_LUMINA

   lumina related


.. py:data:: IDA_DEBUG_THEMES

   themes


.. py:data:: IDA_DEBUG_REGEX

   regular expression


.. py:data:: IDA_DEBUG_SUBPROC

   sub process


.. py:data:: IDA_DEBUG_RANGECB

   range-based entities like segments, functions and so on


.. py:data:: IDA_DEBUG_ALWAYS

   everything


.. py:data:: AST_ENABLE_ALWAYS

   enable action and do not call action_handler_t::update() anymore


.. py:data:: AST_ENABLE_FOR_IDB

   enable action for the current idb. call action_handler_t::update() when a database is opened/closed 
             


.. py:data:: AST_ENABLE_FOR_WIDGET

   enable action for the current widget. call action_handler_t::update() when a widget gets/loses focus 
             


.. py:data:: AST_ENABLE

   enable action - call action_handler_t::update() when anything changes


.. py:data:: AST_DISABLE_ALWAYS

   disable action and do not call action_handler_t::action() anymore


.. py:data:: AST_DISABLE_FOR_IDB

   analog of AST_ENABLE_FOR_IDB


.. py:data:: AST_DISABLE_FOR_WIDGET

   analog of AST_ENABLE_FOR_WIDGET


.. py:data:: AST_DISABLE

   analog of AST_ENABLE


.. py:function:: is_action_enabled(s: action_state_t) -> bool

   Check if the given action state is one of AST_ENABLE*.


.. py:data:: CH_MODAL

   Modal chooser.


.. py:data:: CH_KEEP

   The chooser instance's lifecycle is not tied to the lifecycle of the widget showing its contents. Closing the widget will not destroy the chooser structure. This allows for, e.g., static global chooser instances that don't need to be allocated on the heap. Also stack-allocated chooser instances must set this bit. 
           


.. py:data:: CH_MULTI

   The chooser will allow multi-selection (only for GUI choosers). This bit is set when using the chooser_multi_t structure. 
           


.. py:data:: CH_MULTI_EDIT

   Obsolete.


.. py:data:: CH_NOBTNS

   do not display ok/cancel/help/search buttons. Meaningful only for gui modal windows because non-modal windows do not have any buttons anyway. Text mode does not have them neither. 
           


.. py:data:: CH_ATTRS

   generate ui_get_chooser_item_attrs (gui only)


.. py:data:: CH_UNUSED

.. py:data:: CH_FORCE_DEFAULT

   if a non-modal chooser was already open, change selection to the default one 
           


.. py:data:: CH_CAN_INS

   allow to insert new items


.. py:data:: CH_CAN_DEL

   allow to delete existing item(s)


.. py:data:: CH_CAN_EDIT

   allow to edit existing item(s)


.. py:data:: CH_CAN_REFRESH

   allow to refresh chooser


.. py:data:: CH_QFLT

   open with quick filter enabled and focused


.. py:data:: CH_QFTYP_SHIFT

.. py:data:: CH_QFTYP_DEFAULT

   set quick filtering type to the possible existing default for this chooser


.. py:data:: CH_QFTYP_NORMAL

   normal (i.e., lexicographical) quick filter type


.. py:data:: CH_QFTYP_WHOLE_WORDS

   whole words quick filter type


.. py:data:: CH_QFTYP_REGEX

   regex quick filter type


.. py:data:: CH_QFTYP_FUZZY

   fuzzy search quick filter type


.. py:data:: CH_QFTYP_MASK

.. py:data:: CH_NO_STATUS_BAR

   don't show a status bar


.. py:data:: CH_RESTORE

   restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)


.. py:data:: CH_RENAME_IS_EDIT

   triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit() callback for the corresponding row. 
           


.. py:data:: CH_BUILTIN_SHIFT

.. py:data:: CH_BUILTIN_MASK

   Mask for builtin chooser numbers. Plugins should not use them.


.. py:data:: CH_HAS_DIRTREE

   The chooser can provide a dirtree_t, meaning a tree-like structure can be provided to the user (instead of a flat table) 
           


.. py:data:: CH_TM_NO_TREE

   chooser will show in no-tree mode


.. py:data:: CH_TM_FOLDERS_ONLY

   chooser will show in folders-only mode


.. py:data:: CH_TM_FULL_TREE

   chooser will show in full-tree mode


.. py:data:: CH_TM_SHIFT

.. py:data:: CH_TM_MASK

.. py:data:: CH_HAS_DIFF

   The chooser can be used in a diffing/merging workflow.


.. py:data:: CH_NO_SORT

   The chooser will not have sorting abilities.


.. py:data:: CH_NO_FILTER

   The chooser will not have filtering abilities.


.. py:data:: CH_NON_PERSISTED_TREE

   the chooser tree is not persisted (it is not loaded on startup and is not saved on exit) 
           


.. py:data:: CH2_LAZY_LOADED

   The chooser is lazy-loaded; it receives the callback do_lazy_load_dir() (only meaningful when CH_HAS_DIRTREE is set) 
           


.. py:data:: CH2_HAS_INODE2INDEX

.. py:data:: CHCOL_PLAIN

   plain string


.. py:data:: CHCOL_PATH

   file path. TUI IDA will truncate excessive cell lengths starting at their beginning, and prepending the resulting text with "..." order to leave the filename visible 
           


.. py:data:: CHCOL_HEX

   hexadecimal number


.. py:data:: CHCOL_DEC

   decimal number


.. py:data:: CHCOL_EA

   address


.. py:data:: CHCOL_FNAME

   function name. If a chooser column has this flag set and implements chooser_base_t::get_ea(), rows background colors will be automatically set to match the navigator's "Library function", "Lumina function" and "External symbol" colors 
           


.. py:data:: CHCOL_FORMAT

   column format mask


.. py:data:: CHCOL_DEFHIDDEN

   column should be hidden by default


.. py:data:: CHCOL_DRAGHINT

   the column number that will be used to build hints for the dragging undo label. This should be provided for at most one column for any given chooser. 
           


.. py:data:: CHCOL_INODENAME

   if CH_HAS_DIRTREE has been specified, this instructs the chooser that this column shows the inode name. This should be provided for at most one column for any given chooser. 
           


.. py:data:: CHITEM_BOLD

   display the item in bold


.. py:data:: CHITEM_ITALIC

   display the item in italic


.. py:data:: CHITEM_UNDER

   underline the item


.. py:data:: CHITEM_STRIKE

   strikeout the item


.. py:data:: CHITEM_GRAY

   gray out the item


.. py:data:: CHOOSER_NOMAINMENU

   do not display main menu


.. py:data:: CHOOSER_NOSTATUSBAR

   do not display status bar (obsolete. Use CH_NO_STATUS_BAR instead)


.. py:class:: chooser_item_attrs_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int

      Chooser item property bits



   .. py:attribute:: color
      :type:  bgcolor_t

      item color



   .. py:method:: reset() -> None


.. py:class:: chooser_row_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: texts
      :type:  qstrvec_t

      texts, one per chooser column



   .. py:attribute:: attrs
      :type:  chooser_item_attrs_t

      styling attributes



   .. py:attribute:: icon
      :type:  int

      icon number



.. py:data:: GCRF_HIGH_BIT

.. py:data:: GCRF_HEADER

   Return header texts.


.. py:data:: GCRF_SELECTION

   Return selected rows.


.. py:data:: GCRF_CURRENT

   Return the current row.


.. py:data:: GCRF_ALL

   Return all rows.


.. py:class:: chooser_stdact_desc_t(_label: str = None, _tooltip: str = None, _icon: int = -1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: version
      :type:  int

      to support the backward compatibility



   .. py:attribute:: label
      :type:  str

      see action_desc_t



   .. py:attribute:: tooltip
      :type:  str


   .. py:attribute:: icon
      :type:  int


   .. py:method:: ucb(arg0: action_ctx_base_t) -> action_state_t

      the update callback, see action_handler_t::update() When the update callback is called from the chooser UI engine, it can be sure that ctx.source.chooser is a valid pointer to chooser_base_t and that there are selected items for the Delete and Edit actions. 
              



.. py:class:: chooser_base_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x0
      :type:  int

      screen position, Functions: generic list choosers



   .. py:attribute:: y0
      :type:  int


   .. py:attribute:: x1
      :type:  int


   .. py:attribute:: y1
      :type:  int


   .. py:attribute:: width
      :type:  int

      (in chars)



   .. py:attribute:: height
      :type:  int

      (in chars)



   .. py:attribute:: title
      :type:  str

      menu title (includes ptr to help). May have chooser title prefixes (see "Chooser
      title" above). 
             



   .. py:attribute:: columns
      :type:  int

      number of columns



   .. py:attribute:: widths
      :type:  int const *

      column widths
      * low 16 bits of each value hold the column width
      * high 16 bits are flags (see Chooser column flags) 


              



   .. py:attribute:: header
      :type:  char const *const *

      header line; contains the tooltips, and column name for each of 'columns' columns. When tooltips need to be provided, the syntax should be: "#tooltip#column-name". (Otherwise, the syntax is simply "column-name".) 
              



   .. py:attribute:: icon
      :type:  int

      default icon



   .. py:attribute:: POPUP_INS


   .. py:attribute:: POPUP_DEL


   .. py:attribute:: POPUP_EDIT


   .. py:attribute:: POPUP_REFRESH


   .. py:attribute:: NSTDPOPUPS


   .. py:attribute:: popup_names
      :type:  qstring [chooser_base_t::NSTDPOPUPS]

      array of custom labels of the standard actions. Used to replace labels for these actions. 
      An empty name means that the default name will be used. 
              



   .. py:attribute:: deflt_col
      :type:  int

      Column that will have focus.



   .. py:method:: is_same(other: chooser_base_t) -> bool

      do the current and the given objects hold the same data?



   .. py:method:: can_ins() -> bool

      is an operation allowed?



   .. py:method:: can_del() -> bool


   .. py:method:: can_edit() -> bool


   .. py:method:: can_refresh() -> bool


   .. py:method:: popup_allowed(stdact_idx: int) -> bool

      is a standard action allowed?



   .. py:method:: is_status_bar_hidden() -> bool


   .. py:method:: should_restore_geometry() -> bool


   .. py:method:: is_modal() -> bool

      is choose modal?



   .. py:method:: has_widget_lifecycle() -> bool

      should chooser object be deleted when the widget gets destroyed?



   .. py:method:: is_multi() -> bool

      is multi-selection allowed?



   .. py:method:: ask_item_attrs() -> bool

      should chooser generate ui_get_chooser_item_attrs events?



   .. py:method:: is_force_default() -> bool

      should selection of the already opened non-modal chooser be changed?



   .. py:method:: get_builtin_number() -> uint

      get number of the built-in chooser



   .. py:method:: is_quick_filter_visible_initially() -> bool


   .. py:method:: get_quick_filter_initial_mode() -> int


   .. py:method:: has_dirtree() -> bool


   .. py:method:: has_diff_capability() -> bool


   .. py:method:: can_sort() -> bool


   .. py:method:: can_filter() -> bool


   .. py:method:: should_rename_trigger_edit() -> bool


   .. py:method:: is_dirtree_persisted() -> bool


   .. py:method:: is_lazy_loaded() -> bool


   .. py:method:: has_inode_to_index() -> bool


   .. py:method:: get_count() -> size_t

      get the number of elements in the chooser



   .. py:method:: get_ea(arg2: size_t) -> ida_idaapi.ea_t

      get the address of an element. When this function returns valid addresses: * If any column has the `CHCOL_FNAME` flag, rows will be colored according to the attributes of the functions who own those addresses (extern, library function, Lumina, ... - similar to what the "Functions" widget does) * When a selection is present and the user presses `<Enter>` (`<Shift+Enter>` if the chooser is modal), IDA will jump to that address (through jumpto()) 
              
      :returns: the effective address, BADADDR if the element has no address



   .. py:method:: get_row(n: int) -> Tuple[List[str], int, chooser_item_attrs_t]

      Get data & attributes for a row in a chooser.

      :param n: The row number
      :returns: a tuple (list-of-strings, icon-id, row-attributes)



.. py:data:: nat_lib

.. py:data:: nat_fun

.. py:data:: nat_cod

.. py:data:: nat_dat

.. py:data:: nat_und

.. py:data:: nat_ext

.. py:data:: nat_err

.. py:data:: nat_gap

.. py:data:: nat_cur

.. py:data:: nat_auto

.. py:data:: nat_lum

.. py:data:: nat_hlo

.. py:data:: nat_last

.. py:data:: CVH_USERDATA

.. py:data:: CVH_KEYDOWN

   see custom_viewer_keydown_t


.. py:data:: CVH_POPUP

   see custom_viewer_popup_t


.. py:data:: CVH_DBLCLICK

   see custom_viewer_dblclick_t


.. py:data:: CVH_CURPOS

   see custom_viewer_curpos_t


.. py:data:: CVH_CLOSE

   see custom_viewer_close_t


.. py:data:: CVH_CLICK

   see custom_viewer_click_t


.. py:data:: CVH_QT_AWARE

   see set_custom_viewer_qt_aware()


.. py:data:: CVH_HELP

   see custom_viewer_help_t


.. py:data:: CVH_MOUSEMOVE

   see custom_viewer_mouse_moved_t


.. py:data:: CDVH_USERDATA

   see set_code_viewer_user_data()


.. py:data:: CDVH_SRCVIEW

   see set_code_viewer_is_source()


.. py:data:: CDVH_LINES_CLICK

   see code_viewer_lines_click_t


.. py:data:: CDVH_LINES_DBLCLICK

   see code_viewer_lines_click_t


.. py:data:: CDVH_LINES_POPUP

   see code_viewer_lines_click_t


.. py:data:: CDVH_LINES_DRAWICON

   see code_viewer_lines_icon_t


.. py:data:: CDVH_LINES_LINENUM

   see code_viewer_lines_linenum_t


.. py:data:: CDVH_LINES_ICONMARGIN

   see set_code_viewer_lines_icon_margin()


.. py:data:: CDVH_LINES_RADIX

   see set_code_viewer_lines_radix()


.. py:data:: CDVH_LINES_ALIGNMENT

   see set_code_viewer_lines_alignment()


.. py:data:: VES_SHIFT

   state & 1 => Shift is pressed 
   state & 2 => Alt is pressed 
   state & 4 => Ctrl is pressed 
   state & 8 => Mouse left button is pressed 
   state & 16 => Mouse right button is pressed 
   state & 32 => Mouse middle button is pressed 
   state & 128 => Meta is pressed (OSX only) 
           


.. py:data:: VES_ALT

.. py:data:: VES_CTRL

.. py:data:: VES_MOUSE_LEFT

.. py:data:: VES_MOUSE_RIGHT

.. py:data:: VES_MOUSE_MIDDLE

.. py:data:: VES_META

.. py:data:: msg_activated

   The message window is activated. 
             


.. py:data:: msg_deactivated

   The message window is deactivated. 
             


.. py:data:: msg_click

   Click event. 
             


.. py:data:: msg_dblclick

   Double click event. 
             


.. py:data:: msg_closed

   View closed. 
             


.. py:data:: msg_keydown

   Key down event. 
             


.. py:class:: renderer_pos_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: node
      :type:  int

      the node, or -1 if the current renderer is not a graph renderer. 
              



   .. py:attribute:: cx
      :type:  short

      the X coords of the character in the current line. When in graph mode: X coords of the character in 'node'. 
      When in flat mode: X coords of the character in the line, w/o 
      taking scrolling into consideration. 
              



   .. py:attribute:: cy
      :type:  short

      the Y coords of the character. When in graph mode: Y coords of the character in 'node'. 
      When in flat mode: Line number, starting from the top. 
              



   .. py:attribute:: sx
      :type:  short

      the number of chars that are scrolled (flat mode only)



.. py:class:: view_mouse_event_location_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      flat view (rtype == TCCRT_FLAT)



   .. py:attribute:: item
      :type:  selection_item_t const *

      graph views (rtype != TCCRT_FLAT). nullptr if mouse is not currently over an item. 
              



.. py:class:: view_mouse_event_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: rtype
      :type:  tcc_renderer_type_t

      type of renderer that received the event



   .. py:attribute:: x
      :type:  int

      screen x coordinate



   .. py:attribute:: y
      :type:  int

      screen y coordinate



   .. py:attribute:: location
      :type:  view_mouse_event_t::location_t

      location where event was generated



   .. py:attribute:: state
      :type:  view_event_state_t

      contains information about what buttons are CURRENTLY pressed on the keyboard and mouse. view_mouse_event_t instances created in functions like mouseReleaseEvent() won't contain any information about the mouse, because it has been released. 
              



   .. py:attribute:: button
      :type:  vme_button_t

      represents which mouse button was responsible for generating the event. This field does not care about the current state of the mouse. 
              



   .. py:attribute:: renderer_pos
      :type:  renderer_pos_info_t

      position where event was generated, relative to the renderer



.. py:data:: view_activated

   A view is activated 
             


.. py:data:: view_deactivated

   A view is deactivated 
             


.. py:data:: view_keydown

   Key down event 
             


.. py:data:: view_click

   Click event 
             


.. py:data:: view_dblclick

   Double click event 
             


.. py:data:: view_curpos

   Cursor position changed 
             


.. py:data:: view_created

   A view is being created. 
             


.. py:data:: view_close

   View closed 
             


.. py:data:: view_switched

   A view's renderer has changed. 
             


.. py:data:: view_mouse_over

   The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
             


.. py:data:: view_loc_changed

   The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
             


.. py:data:: view_mouse_moved

   The mouse moved on the view 
             


.. py:data:: iek_unknown

.. py:data:: iek_shortcut

.. py:data:: iek_key_press

.. py:data:: iek_key_release

.. py:data:: iek_mouse_button_press

.. py:data:: iek_mouse_button_release

.. py:data:: iek_mouse_wheel

.. py:class:: input_event_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  int

      size marker



   .. py:attribute:: kind
      :type:  input_event_kind_t

      the kind of event



   .. py:attribute:: modifiers
      :type:  input_event_modifiers_t

      current keyboard (and mouse) modifiers



   .. py:attribute:: target
      :type:  TWidget *

      the target widget



   .. py:attribute:: source
      :type:  void *

      the source event, should it be required for detailed inform (e.g., a QEvent in the GUI version of IDA)



   .. py:attribute:: shortcut
      :type:  input_event_t::input_event_shortcut_data_t


   .. py:attribute:: keyboard
      :type:  input_event_t::input_event_keyboard_data_t


   .. py:attribute:: mouse
      :type:  input_event_t::input_event_mouse_data_t


   .. py:method:: get_source_QEvent()


   .. py:method:: get_target_QWidget()


.. py:class:: input_event_shortcut_data_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: action_name
      :type:  str


.. py:class:: input_event_keyboard_data_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: key
      :type:  int


   .. py:attribute:: text
      :type:  char [8]


.. py:class:: input_event_mouse_data_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: x
      :type:  int


   .. py:attribute:: y
      :type:  int


   .. py:attribute:: button
      :type:  vme_button_t


.. py:data:: MFF_FAST

   Execute code as soon as possible. this mode is ok for calling ui related functions that do not query the database. 
           


.. py:data:: MFF_READ

   Execute code only when ida is idle and it is safe to query the database. This mode is recommended only for code that does not modify the database. (nb: ida may be in the middle of executing another user request, for example it may be waiting for him to enter values into a modal dialog box) 
           


.. py:data:: MFF_WRITE

   Execute code only when ida is idle and it is safe to modify the database. in particular, this flag will suspend execution if there is a modal dialog box on the screen. this mode can be used to call any ida api function. MFF_WRITE implies MFF_READ 
           


.. py:data:: MFF_NOWAIT

   Do not wait for the request to be executed. the caller should ensure that the request is not destroyed until the execution completes. if not, the request will be ignored. the request must be created using the 'new' operator to use it with this flag. it can be used in cancel_exec_request(). This flag can be used to delay the code execution until the next UI loop run even from the main thread. 
           


.. py:class:: ui_requests_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:data:: UIJMP_ACTIVATE

   activate the new window


.. py:data:: UIJMP_DONTPUSH

   do not remember the current address in the navigation history 
           


.. py:data:: UIJMP_VIEWMASK

.. py:data:: UIJMP_ANYVIEW

   jump in any ea_t-capable view


.. py:data:: UIJMP_IDAVIEW

   jump in idaview


.. py:data:: UIJMP_IDAVIEW_NEW

   jump in new idaview


.. py:class:: action_ctx_base_cur_sel_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: to
      :type:  twinpos_t

      end of selection



   .. py:method:: reset() -> None


.. py:class:: action_ctx_base_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: reset() -> None

      Invalidate all context info.



   .. py:attribute:: widget
      :type:  TWidget *


   .. py:attribute:: widget_type
      :type:  twidget_type_t

      type of current widget



   .. py:attribute:: widget_title
      :type:  str

      title of current widget



   .. py:attribute:: chooser
      :type:  chooser_base_t *

      the underlying chooser_base_t (if 'widget' is a chooser widget)



   .. py:attribute:: chooser_selection
      :type:  sizevec_t

      current chooser selection (0-based)



   .. py:attribute:: action
      :type:  str

      action name



   .. py:attribute:: cur_flags
      :type:  int

      Current address information. see Action context property bits.



   .. py:method:: has_flag(flag: int) -> bool

      Check if the given flag is set.



   .. py:attribute:: cur_ea
      :type:  ida_idaapi.ea_t

      the current EA of the position in the view



   .. py:attribute:: cur_value
      :type:  int

      the possible address, or value the cursor is positioned on



   .. py:attribute:: cur_func
      :type:  func_t *

      the current function



   .. py:attribute:: cur_fchunk
      :type:  func_t *

      the current function chunk



   .. py:attribute:: cur_seg
      :type:  segment_t *

      the current segment



   .. py:attribute:: cur_sel
      :type:  action_ctx_base_cur_sel_t

      the currently selected range. also see ACF_HAS_SELECTION



   .. py:attribute:: regname
      :type:  str

      register name (if widget_type == BWN_CPUREGS and context menu opened on register)



   .. py:attribute:: focus
      :type:  TWidget *

      The focused widget in case it is not the 'form' itself (e.g., the 'quick filter' input in choosers.)



   .. py:attribute:: graph
      :type:  interactive_graph_t *

      the current graph (if in a graph view)



   .. py:attribute:: graph_selection
      :type:  screen_graph_selection_t *

      the current graph selection (if in a graph view)



   .. py:attribute:: hovered
      :type:  selection_item_t const *

      the current item being hovered (if in a graph view)



   .. py:attribute:: dirtree_selection
      :type:  dirtree_selection_t *

      the current dirtree_t selection (if applicable)



   .. py:attribute:: type_ref
      :type:  til_type_ref_t *

      a reference to the current type (if 'widget' is a type listing widget; nullptr otherwise)



   .. py:attribute:: cur_extracted_ea


   .. py:attribute:: form


   .. py:attribute:: form_type


   .. py:attribute:: form_title


.. py:data:: ACF_HAS_SELECTION

   there is currently a valid selection


.. py:data:: ACF_XTRN_EA

   cur_ea is in 'externs' segment


.. py:data:: ACF_HAS_FIELD_DIRTREE_SELECTION

   'dirtree_selection' field is present


.. py:data:: ACF_HAS_SOURCE

   'source' field is present


.. py:data:: ACF_HAS_TYPE_REF

   'type_ref' field is present


.. py:data:: AHF_VERSION

   action handler version (used by action_handler_t::flags)


.. py:data:: AHF_VERSION_MASK

   mask for action_handler_t::flags


.. py:class:: action_desc_t(name: str, label: str, handler: PyObject *, shortcut: str = None, tooltip: str = None, icon: int = -1, flags: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  int

      size of this structure



   .. py:attribute:: name
      :type:  str

      the internal name of the action; must be unique. a way to reduce possible conflicts is to prefix it with some specific prefix. E.g., "myplugin:doSthg". 
              



   .. py:attribute:: label
      :type:  str

      the label of the action, possibly with an accelerator key definition (e.g., "~J~ump to operand") 
              



   .. py:attribute:: owner
      :type:  void const *

      either the plugin_t, or plugmod_t responsible for registering the action. Can be nullptr Please see ACTION_DESC_LITERAL_PLUGMOD 
              



   .. py:attribute:: shortcut
      :type:  str

      an optional shortcut definition. E.g., "Ctrl+Enter"



   .. py:attribute:: tooltip
      :type:  str

      an optional tooltip for the action



   .. py:attribute:: icon
      :type:  int

      an optional icon ID to use



   .. py:attribute:: flags
      :type:  int

      See Action flags.



.. py:data:: ADF_OWN_HANDLER

   handler is owned by the action; it'll be destroyed when the action is unregistered. Use DYNACTION_DESC_LITERAL to set this bit. 
           


.. py:data:: ADF_NO_UNDO

   the action does not create an undo point. useful for actions that do not modify the database. 
           


.. py:data:: ADF_OT_MASK

   Owner type mask.


.. py:data:: ADF_OT_PLUGIN

   Owner is a plugin_t.


.. py:data:: ADF_OT_PLUGMOD

   Owner is a plugmod_t.


.. py:data:: ADF_OT_PROCMOD

   Owner is a procmod_t.


.. py:data:: ADF_GLOBAL

   Register the action globally, so that it's available even if no IDB is present 
           


.. py:data:: ADF_NO_HIGHLIGHT

   After activating, do not update the highlight according to what's under the cursor (listings only.) 
           


.. py:data:: ADF_CHECKABLE

   action is checkable


.. py:data:: ADF_CHECKED

   starts in a checked state (requires ADF_CHECKABLE)


.. py:data:: AA_NONE

   no effect


.. py:data:: AA_LABEL

   see update_action_label()


.. py:data:: AA_SHORTCUT

   see update_action_shortcut()


.. py:data:: AA_TOOLTIP

   see update_action_tooltip()


.. py:data:: AA_ICON

   see update_action_icon()


.. py:data:: AA_STATE

   see update_action_state()


.. py:data:: AA_CHECKABLE

   see update_action_checkable()


.. py:data:: AA_CHECKED

   see update_action_checked()


.. py:data:: AA_VISIBILITY

   see update_action_visibility()


.. py:function:: cancel_exec_request(req_id: int) -> bool

   Try to cancel an asynchronous exec request (::ui_cancel_exec_request). 
           
   :param req_id: request id
   :returns: true: successfully canceled
   :returns: false: request has already been processed.


.. py:function:: cancel_thread_exec_requests(tid: __qthread_t) -> int

   Try to cancel asynchronous exec requests created by the specified thread. 
           
   :param tid: thread id
   :returns: number of the canceled requests.


.. py:function:: set_execute_sync_availability(tid: __qthread_t, availability: execute_sync_availability_t) -> execute_sync_availability_t

   Set the availability of the execute_sync functionality for the given thread
   Setting it to `esa_unavailable` will cause the existing requests for this thread to be cancelled. Setting it to `esa_release` will clear the status for this thread, and should be issued right before a call to `qthread_free` is issued.

   :param tid: thread id
   :param availability: the availability
   :returns: the previous availability


.. py:function:: get_synced_group(w: TWidget const *) -> synced_group_t const *

   Get the group of widgets/registers this view is synchronized with 
           
   :param w: the widget
   :returns: the group of widgets/registers, or nullptr


.. py:function:: banner(wait: int) -> bool

   Show a banner dialog box (ui_banner). 
           
   :param wait: time to wait before closing
   :returns: 1: ok
   :returns: 0: esc was pressed


.. py:function:: is_msg_inited() -> bool

   Can we use msg() functions?


.. py:function:: refresh_idaview() -> None

   Refresh marked windows (ui_refreshmarked)


.. py:function:: refresh_idaview_anyway() -> None

   Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please consider request_refresh() instead 
           


.. py:function:: analyzer_options() -> None

   Allow the user to set analyzer options. (show a dialog box) (ui_analyzer_options)


.. py:function:: get_screen_ea() -> ida_idaapi.ea_t

   Get the address at the screen cursor (ui_screenea)


.. py:function:: get_opnum() -> int

   Get current operand number, -1 means no operand (ui_get_opnum)


.. py:function:: get_cursor() -> int *, int *

   Get the cursor position on the screen (ui_get_cursor). 
           
   :returns: true: pointers are filled
   :returns: false: no disassembly window open


.. py:function:: get_output_cursor() -> int *, int *

   Get coordinates of the output window's cursor (ui_get_output_cursor). 
           
   :returns: false: the output window has been destroyed.
   :returns: true: pointers are filled


.. py:function:: get_curline() -> str

   Get current line from the disassemble window (ui_get_curline). 
           
   :returns: cptr current line with the color codes (use tag_remove() to remove the color codes)


.. py:function:: open_url(url: str) -> None

   Open the given url (ui_open_url)


.. py:function:: get_hexdump_ea(hexdump_num: int) -> ida_idaapi.ea_t

   Get the current address in a hex view. 
           
   :param hexdump_num: number of hexview window


.. py:function:: get_key_code(keyname: str) -> ushort

   Get keyboard key code by its name (ui_get_key_code)


.. py:function:: lookup_key_code(key: int, shift: int, is_qt: bool) -> ushort

   Get shortcut code previously created by ui_get_key_code. 
           
   :param key: key constant
   :param shift: modifiers
   :param is_qt: are we using gui version?


.. py:function:: refresh_navband(force: bool) -> None

   Refresh navigation band if changed (ui_refresh_navband). 
           
   :param force: refresh regardless


.. py:function:: refresh_chooser(title: str) -> bool

   Mark a non-modal custom chooser for a refresh (ui_refresh_chooser). 
           
   :param title: title of chooser
   :returns: success


.. py:function:: close_chooser(title: str) -> bool

   Close a non-modal chooser (ui_close_chooser). 
           
   :param title: window title of chooser to close
   :returns: success


.. py:function:: set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0)

   Sets the dock orientation of a window relatively to another window.

   Use the left, top, right, bottom parameters if DP_FLOATING is used,
   or if you want to specify the width of docked windows.

   :param src_ctrl: Source docking control
   :param dest_ctrl: Destination docking control
   :param orient: One of DP_XXXX constants
   :returns: Boolean

   Example:
       set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window


.. py:function:: get_icon_id_by_name(icon_name: str) -> int

   Retrieve the id of the icon by name (ui_get_icon_id_by_name). 
           
   :param icon_name: full name of the icon
   :returns: icon id


.. py:function:: free_custom_icon(icon_id)

   Frees an icon loaded with load_custom_icon()

   :param icon_id: The ID of the icon to free


.. py:function:: unregister_action(name: str) -> bool

   Delete a previously-registered action (ui_unregister_action). 
           
   :param name: name of action
   :returns: success


.. py:function:: create_toolbar(name: str, label: str, before: str = None, flags: int = 0) -> bool

   Create a toolbar with the given name, label and optional position 
           
   :param name: name of toolbar (must be unique)
   :param label: label of toolbar
   :param before: if non-nullptr, the toolbar before which the new toolbar will be inserted
   :param flags: a combination of create toolbar flags, to determine toolbar position
   :returns: success


.. py:function:: delete_toolbar(name: str) -> bool

   Delete an existing toolbar 
           
   :param name: name of toolbar
   :returns: success


.. py:function:: create_menu(name: str, label: str, menupath: str = None) -> bool

   Create a menu with the given name, label and optional position, either in the menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information about where the menu should be positioned. First, IDA will try and resolve the corresponding menu by its name. If such an existing menu is found and is present in the menubar, then the new menu will be inserted in the menubar before it. Otherwise, IDA will try to resolve 'menupath' as it would for attach_action_to_menu() and, if found, add the new menu like so: 
        The new 'My menu' submenu will appear in the 'Comments' submenu
        before the 'Enter comment..." command
        "My menu", "Edit/Comments/Enter comment...");


        The new 'My menu' submenu will appear at the end of the
        'Comments' submenu.
        "My menu", "Edit/Comments/");


           
   :param name: name of menu (must be unique)
   :param label: label of menu
   :param menupath: where should the menu be inserted
   :returns: success


.. py:function:: delete_menu(name: str) -> bool

   Delete an existing menu 
           
   :param name: name of menu
   :returns: success


.. py:function:: attach_action_to_menu(menupath: str, name: str, flags: int = 0) -> bool

   Attach a previously-registered action to the menu (ui_attach_action_to_menu). 
           
   :param menupath: path to the menu item after or before which the insertion will take place. 

   * Example: Debug/StartProcess
   * Whitespace, punctuation are ignored.
   * It is allowed to specify only the prefix of the menu item.
   * Comparison is case insensitive.
   * menupath may start with the following prefixes:
   * [S] - modify the main menu of the structure window
   * [E] - modify the main menu of the enum window
   :param name: the action name
   :param flags: a combination of Set menu flags, to determine menu item position
   :returns: success


.. py:function:: detach_action_from_menu(menupath: str, name: str) -> bool

   Detach an action from the menu (ui_detach_action_from_menu). 
           
   :param menupath: path to the menu item
   :param name: the action name
   :returns: success


.. py:function:: attach_action_to_toolbar(toolbar_name: str, name: str) -> bool

   Attach an action to an existing toolbar (ui_attach_action_to_toolbar). 
           
   :param toolbar_name: the name of the toolbar
   :param name: the action name
   :returns: success


.. py:function:: detach_action_from_toolbar(toolbar_name: str, name: str) -> bool

   Detach an action from the toolbar (ui_detach_action_from_toolbar). 
           
   :param toolbar_name: the name of the toolbar
   :param name: the action name
   :returns: success


.. py:function:: register_and_attach_to_menu(menupath: str, name: str, label: str, shortcut: str, flags: int, handler: action_handler_t *, owner: void *, action_desc_t_flags: int) -> bool

   Helper.
   You are not encouraged to use this, as it mixes flags for both register_action(), and attach_action_to_menu().
   The only reason for its existence is to make it simpler to port existing plugins to the new actions API. 
           


.. py:function:: display_widget(widget: TWidget *, options: int, dest_ctrl: str = None) -> None

   Display a widget, dock it if not done before 
           
   :param widget: widget to display
   :param options: Widget open flags
   :param dest_ctrl: where to dock: if nullptr or invalid then use the active docker if there is not create a new tab relative to current active tab


.. py:function:: close_widget(widget: TWidget *, options: int) -> None

   Close widget (ui_close_widget, only gui version). 
           
   :param widget: pointer to the widget to close
   :param options: Form close flags


.. py:function:: activate_widget(widget: TWidget *, take_focus: bool) -> None

   Activate widget (only gui version) (ui_activate_widget). 
           
   :param widget: existing widget to display
   :param take_focus: give focus to given widget


.. py:function:: find_widget(caption: str) -> TWidget *

   Find widget with the specified caption (only gui version) (ui_find_widget). NB: this callback works only with the tabbed widgets! 
           
   :param caption: title of tab, or window title if widget is not tabbed
   :returns: pointer to the TWidget, nullptr if none is found


.. py:function:: get_current_widget() -> TWidget *

   Get a pointer to the current widget (ui_get_current_widget).


.. py:function:: get_widget_type(widget: TWidget *) -> twidget_type_t

   Get the type of the TWidget * (ui_get_widget_type).


.. py:function:: get_widget_title(widget: TWidget *) -> str

   Get the TWidget's title (ui_get_widget_title).


.. py:function:: custom_viewer_jump(v: TWidget *, loc: lochist_entry_t const &, flags: int = 0) -> bool

   Append 'loc' to the viewer's history, and cause the viewer to display it. 
           
   :param v: (TWidget *)
   :param loc: (const lochist_entry_t &)
   :param flags: (uint32) or'ed combination of CVNF_* values
   :returns: success


.. py:function:: ea_viewer_history_push_and_jump(v: TWidget *, ea: ida_idaapi.ea_t, x: int, y: int, lnnum: int) -> bool

   Push current location in the history and jump to the given location (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and also in other synchronized views. 
           
   :param v: ea viewer
   :param ea: jump destination
   :param x: coords on screen
   :param y: coords on screen
   :param lnnum: desired line number of given address


.. py:function:: get_ea_viewer_history_info(nback: int *, nfwd: int *, v: TWidget *) -> bool

   Get information about what's in the history (ui_ea_viewer_history_info). 
           
   :param nback: number of available back steps
   :param nfwd: number of available forward steps
   :param v: ea viewer
   :returns: false: if the given ea viewer does not exist
   :returns: true: otherwise


.. py:function:: refresh_custom_viewer(custom_viewer: TWidget *) -> None

   Refresh custom ida viewer (ui_refresh_custom_viewer)


.. py:function:: repaint_custom_viewer(custom_viewer: TWidget *) -> None

   Repaint the given widget immediately (ui_repaint_qwidget)


.. py:function:: jumpto(*args) -> bool

   This function has the following signatures:

       0. jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
       1. jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool

   # 0: jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool

   Jump to the specified address (ui_jumpto). 
           
   :returns: success

   # 1: jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool

   Set cursor position in custom ida viewer. 
           
   :returns: success


.. py:function:: get_custom_viewer_place(custom_viewer: TWidget *, mouse: bool) -> int *, int *

   Get current place in a custom viewer (ui_get_curplace).
   See also the more complete get_custom_viewer_location()

   :param custom_viewer: view
   :param mouse: mouse position (otherwise cursor position)


.. py:function:: get_custom_viewer_location(*args) -> bool

   Get information about the current location in a listing

   This function has the following signatures:

       1. get_custom_viewer_location(out_entry: ida_moves.lochist_entry_t, widget: TWidget, mouse: bool=False) -> bool
       2. get_custom_viewer_location(out_entry: ida_kernwin.listing_location_t, widget: TWidget, flags: int=0) -> bool

   The 2nd form is a superset of the 1st, and retrieves
   the text (and tags) of the text.


.. py:function:: is_idaq()

   Returns True or False depending if IDAPython is hosted by IDAQ


.. py:function:: attach_action_to_popup(widget: TWidget *, popup_handle: TPopupMenu *, name: str, popuppath: str = None, flags: int = 0) -> bool

   Insert a previously-registered action into the widget's popup menu (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and 'permanent'. 
           
   :param widget: target widget
   :param popup_handle: target popup menu
   * if non-nullptr, the action is added to this popup menu invocation (i.e., 'single-shot')
   * if nullptr, the action is added to a list of actions that should always be present in context menus for this widget (i.e., 'permanent'.)
   :param name: action name
   :param popuppath: can be nullptr
   :param flags: a combination of SETMENU_ flags (see Set menu flags)
   :returns: success


.. py:function:: detach_action_from_popup(widget: TWidget *, name: str) -> bool

   Remove a previously-registered action, from the list of 'permanent' context menu actions for this widget (ui_detach_action_from_popup). This only makes sense if the action has been added to 'widget's list of permanent popup actions by calling attach_action_to_popup in 'permanent' mode. 
           
   :param widget: target widget
   :param name: action name


.. py:function:: update_action_label(name: str, label: str) -> bool

   Update an action's label (ui_update_action_attr). 
           
   :param name: action name
   :param label: new label
   :returns: success


.. py:function:: update_action_shortcut(name: str, shortcut: str) -> bool

   Update an action's shortcut (ui_update_action_attr). 
           
   :param name: action name
   :param shortcut: new shortcut
   :returns: success


.. py:function:: update_action_tooltip(name: str, tooltip: str) -> bool

   Update an action's tooltip (ui_update_action_attr). 
           
   :param name: action name
   :param tooltip: new tooltip
   :returns: success


.. py:function:: update_action_icon(name: str, icon: int) -> bool

   Update an action's icon (ui_update_action_attr). 
           
   :param name: action name
   :param icon: new icon id
   :returns: success


.. py:function:: update_action_state(name: str, state: action_state_t) -> bool

   Update an action's state (ui_update_action_attr). 
           
   :param name: action name
   :param state: new state
   :returns: success


.. py:function:: update_action_checkable(name: str, checkable: bool) -> bool

   Update an action's checkability (ui_update_action_attr). 
           
   :param name: action name
   :param checkable: new checkability
   :returns: success


.. py:function:: update_action_checked(name: str, checked: bool) -> bool

   Update an action's checked state (ui_update_action_attr). 
           
   :param name: action name
   :param checked: new checked state
   :returns: success


.. py:function:: update_action_visibility(name: str, visible: bool) -> bool

   Update an action's visibility (ui_update_action_attr). 
           
   :param name: action name
   :param visible: new visibility
   :returns: success


.. py:function:: get_action_label(name: str) -> str

   Get an action's label (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_shortcut(name: str) -> str

   Get an action's shortcut (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_tooltip(name: str) -> str

   Get an action's tooltip (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_icon(name: str) -> int *

   Get an action's icon (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_state(name: str) -> action_state_t *

   Get an action's state (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_checkable(name: str) -> bool *

   Get an action's checkability (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_checked(name: str) -> bool *

   Get an action's checked state (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: get_action_visibility(name: str) -> bool *

   Get an action's visibility (ui_get_action_attr). 
           
   :param name: the action name
   :returns: success


.. py:function:: set_custom_viewer_qt_aware(custom_viewer: TWidget *) -> bool

   Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)


.. py:function:: get_custom_viewer_curline(custom_viewer: TWidget *, mouse: bool) -> str

   Get current line of custom viewer (ui_get_custom_viewer_curline). The returned line contains color codes
   See also the more powerful get_custom_viewer_location()

   :param custom_viewer: view
   :param mouse: mouse position (otherwise cursor position)
   :returns: pointer to contents of current line


.. py:function:: get_custom_viewer_place_xcoord(custom_viewer: TWidget *, pline: place_t, pitem: place_t) -> int

   Get the X position of the item, in the line 
           
   :param custom_viewer: the widget
   :param pline: a place corresponding to the line
   :param pitem: a place corresponding to the item
   :returns: -1: if 'pitem' is not included in the line
   :returns: -2: if 'pitem' points at the entire line
   :returns: >=: 0 for the X coordinate within the pline, where pitem points


.. py:function:: get_user_input_event(out: input_event_t) -> bool

   Get the current user input event (mouse button press, key press, ...) It is sometimes desirable to be able to tell when a certain situation happens (e.g., 'view_curpos' gets triggered); this function exists to provide that context (GUI version only) 
           
   :param out: the input event data
   :returns: false if we are not currently processing a user input event


.. py:function:: get_output_curline(mouse: bool) -> str

   Get current line of output window (ui_get_output_curline). 
           
   :param mouse: current for mouse pointer?
   :returns: false if output contains no text


.. py:function:: get_output_selected_text() -> str

   Returns selected text from output window (ui_get_output_selected_text). 
           
   :returns: true if there is a selection


.. py:function:: get_current_viewer() -> TWidget *

   Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)


.. py:function:: get_last_widget(*args) -> TWidget *

   Get last ida viewer (idaview or custom viewer) (ui_get_last_widget) 
           
   :param mask: an OR'ed set of IWID_* to limit the search to
   :returns: the viewer, if found


.. py:function:: prompt_function_prototype(out_tif: tinfo_t, pfn: func_t *, tif: tinfo_t, name: str) -> str

   Open function prototype editor to edit function type and create new type. Allows to change the function prototype either in the "old" one-liner mode or in the new multi-line editor, which supports shortcuts, etc. Note: changes will not apply! It is the caller's job to apply the resulting out_tif. Parameters: 
           
   :param out_tif: - (tinfo_t *) tif for created type
   :param pfn: - (func_t *) editing function
   :param tif: - (tinfo_t *) current function type
   :param name: - (const char *) function name
   :returns: true if new type created successfully


.. py:function:: parse_tagged_line_sections(out: tagged_line_sections_t, line: str) -> bool

   Collect tagged sections in a color-tagged line (produced by `place_t::generate`)

   :param out: sections storage
   :param line: input line
   :returns: success


.. py:function:: get_view_renderer_type(v: TWidget *) -> tcc_renderer_type_t

   Get the type of renderer currently in use in the given view (ui_get_renderer_type)


.. py:function:: set_view_renderer_type(v: TWidget *, rt: tcc_renderer_type_t) -> None

   Set the type of renderer to use in a view (ui_set_renderer_type)


.. py:function:: create_empty_widget(title: str, icon: int = -1) -> TWidget *

   Create an empty widget, serving as a container for custom user widgets 
           


.. py:function:: msg_clear() -> None

   Clear the "Output" window.


.. py:function:: msg_save(path: str) -> bool

   Save the "Output" window contents into a file 
           
   :param path: The path of the file to save the contents into. An empty path means that the user will be prompted for the destination and, if the file already exists, the user will be asked to confirm before overriding its contents. Upon return, 'path' will contain the path that the user chose.
   :returns: success


.. py:function:: get_active_modal_widget() -> TWidget *

   Get the current, active modal TWidget instance. Note that in this context, the "wait dialog" is not considered: this function will return nullptr even if it is currently shown. 
           
   :returns: TWidget * the active modal widget, or nullptr


.. py:function:: get_navband_pixel(ea)

   Maps an address, onto a pixel coordinate within the navigation band

   :param ea: The address to map
   :returns: a list [pixel, is_vertical]


.. py:function:: get_navband_ea(pixel: int) -> ida_idaapi.ea_t

   Translate the pixel position on the navigation band, into an address.


.. py:function:: get_window_id(name: str = None) -> void *

   Get the system-specific window ID (GUI version only) 
           
   :param name: name of the window (nullptr means the main IDA window)
   :returns: the low-level window ID


.. py:function:: is_idaview(v: TWidget *) -> bool

   Is the given custom view an idaview? (ui_is_idaview)


.. py:function:: read_selection(v, p1, p2)

   Read the user selection, and store its information in p1 (from) and p2 (to).

   This can be used as follows:


   >>> p1 = ida_kernwin.twinpos_t()
   p2 = ida_kernwin.twinpos_t()
   view = ida_kernwin.get_current_viewer()
   ida_kernwin.read_selection(view, p1, p2)


   At that point, p1 and p2 hold information for the selection.
   But, the 'at' property of p1 and p2 is not properly typed.
   To specialize it, call #place() on it, passing it the view
   they were retrieved from. Like so:


   >>> place0 = p1.place(view)
   place1 = p2.place(view)


   This will effectively "cast" the place into a specialized type,
   holding proper information, depending on the view type (e.g.,
   disassembly, structures, enums, ...)

   :param v: The view to retrieve the selection for.
   :param p1: Storage for the "from" part of the selection.
   :param p2: Storage for the "to" part of the selection.
   :returns: a bool value indicating success.


.. py:function:: read_range_selection(v: TWidget *) -> ea_t *, ea_t *

   Get the address range for the selected range boundaries, this is the convenient function for read_selection() 
           
   :param v: view, nullptr means the last active window containing addresses
   :returns: 0: no range is selected
   :returns: 1: ok, start ea and end ea are filled


.. py:function:: unmark_selection() -> None

   Unmark selection (ui_unmarksel)


.. py:function:: create_code_viewer(custview: TWidget *, flags: int = 0, parent: TWidget * = None) -> TWidget *

   Create a code viewer (ui_create_code_viewer). A code viewer contains on the left side a widget representing the line numbers, and on the right side, the child widget passed as parameter. It will inherit its title from the child widget.

   :param custview: the custom view to be added
   :param flags: Code viewer flags
   :param parent: widget to contain the new code viewer


.. py:function:: set_code_viewer_handler(code_viewer: TWidget *, handler_id: custom_viewer_handler_id_t, handler_or_data: void *) -> void *

   Set a handler for a code viewer event (ui_set_custom_viewer_handler). 
           
   :param code_viewer: the code viewer
   :param handler_id: one of CDVH_ in custom_viewer_handler_id_t
   :param handler_or_data: can be a handler or data. see examples in Functions: custom viewer handlers
   :returns: old value of the handler or data


.. py:function:: set_code_viewer_user_data(code_viewer: TWidget *, ud: void *) -> bool

   Set the user data on a code viewer (ui_set_custom_viewer_handler).


.. py:function:: get_viewer_user_data(viewer: TWidget *) -> void *

   Get the user data from a custom viewer (ui_get_viewer_user_data)


.. py:function:: get_viewer_place_type(viewer: TWidget *) -> tcc_place_type_t

   Get the type of place_t instances a viewer uses & creates (ui_get_viewer_place_type).


.. py:function:: set_code_viewer_line_handlers(code_viewer: TWidget *, click_handler: code_viewer_lines_click_t *, popup_handler: code_viewer_lines_click_t *, dblclick_handler: code_viewer_lines_click_t *, drawicon_handler: code_viewer_lines_icon_t *, linenum_handler: code_viewer_lines_linenum_t *) -> None

   Set handlers for code viewer line events. Any of these handlers may be nullptr 
           


.. py:function:: set_code_viewer_lines_icon_margin(code_viewer: TWidget *, margin: int) -> bool

   Set space allowed for icons in the margin of a code viewer (ui_set_custom_viewer_handler).


.. py:function:: set_code_viewer_lines_alignment(code_viewer: TWidget *, align: int) -> bool

   Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).


.. py:function:: set_code_viewer_lines_radix(code_viewer: TWidget *, radix: int) -> bool

   Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).


.. py:function:: set_code_viewer_is_source(code_viewer: TWidget *) -> bool

   Specify that the given code viewer is used to display source code (ui_set_custom_viewer_handler).


.. py:function:: get_tab_size(path: str) -> int

   Get the size of a tab in spaces (ui_get_tab_size). 
           
   :param path: the path of the source view for which the tab size is requested.
   * if nullptr, the default size is returned.


.. py:function:: clr_cancelled() -> None

   Clear "Cancelled" flag (ui_clr_cancelled)


.. py:function:: set_cancelled() -> None

   Set "Cancelled" flag (ui_set_cancelled)


.. py:function:: user_cancelled() -> bool

   Test the cancellation flag (ui_test_cancelled). 
           
   :returns: true: Cancelled, a message is displayed
   :returns: false: Not cancelled


.. py:function:: ui_load_new_file(temp_file: str, filename: str, pli: linput_t **, neflags: ushort, ploaders: load_info_t **) -> bool

   Display a load file dialog and load file (ui_load_file). 
           
   :param temp_file: name of the file with the extracted archive member.
   :param filename: the name of input file as is, library or archive name
   :param pli: loader input source, may be changed to point to temp_file
   :param neflags: combination of NEF_... bits (see Load file flags)
   :param ploaders: list of loaders which accept file, may be changed for loaders of temp_file
   :returns: true: file was successfully loaded
   :returns: false: otherwise


.. py:function:: ui_run_debugger(dbgopts: str, exename: str, argc: int, argv: char const *const *) -> bool

   Load a debugger plugin and run the specified program (ui_run_dbg). 
           
   :param dbgopts: value of the -r command line switch
   :param exename: name of the file to run
   :param argc: number of arguments for the executable
   :param argv: argument vector
   :returns: success


.. py:function:: load_dbg_dbginfo(*args) -> bool

   Load debugging information from a file. 
           
   :param path: path to file
   :param li: loader input. if nullptr, check DBG_NAME_KEY
   :param base: loading address
   :param verbose: dump status to message window


.. py:function:: add_idc_hotkey(hotkey: str, idcfunc: str) -> int

   Add hotkey for IDC function (ui_add_idckey). 
           
   :param hotkey: hotkey name
   :param idcfunc: IDC function name
   :returns: IDC hotkey error codes


.. py:function:: set_highlight(viewer: TWidget *, str: set_highlight.str, flags: int) -> bool

   Set the highlighted identifier in the viewer (ui_set_highlight). 
           
   :param viewer: the viewer
   :param str: the text to match, or nullptr to remove current
   :param flags: combination of HIF_... bits (see set_highlight flags)
   :returns: false if an error occurred


.. py:function:: open_exports_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the exports window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_imports_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the exports window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_names_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the names window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_funcs_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the 'Functions' window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_strings_window(*args) -> TWidget *

   Open the 'Strings' window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :param selstart: only display strings that occur within this range
   :param selend: only display strings that occur within this range
   :returns: pointer to resulting window


.. py:function:: open_segments_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the segments window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_segregs_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the segment registers window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_selectors_window() -> TWidget *

   Open the selectors window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_signatures_window() -> TWidget *

   Open the signatures window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_tils_window() -> TWidget *

   Open the type libraries window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_loctypes_window(ordinal: int, cursor: tif_cursor_t const * = None) -> TWidget *

   Open the local types window (ui_open_builtin2). 
           
   :param ordinal: ordinal of type to select by default
   :param cursor: cursor to the type member
   :returns: pointer to resulting window


.. py:function:: open_til_view_window(tif: tinfo_t, cursor: tif_cursor_t const * = None) -> TWidget *

   Open the sub-til window (ui_open_builtin2). 
           
   :param tif: tif to open
   :param cursor: cursor to the type member
   :returns: pointer to resulting window


.. py:function:: open_calls_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the function calls window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_problems_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the problems window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_bpts_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the breakpoints window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_threads_window() -> TWidget *

   Open the threads window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_modules_window() -> TWidget *

   Open the modules window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_trace_window() -> TWidget *

   Open the tracing window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_stack_window() -> TWidget *

   Open the call stack window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_xrefs_window(ea: ida_idaapi.ea_t) -> TWidget *

   Open the cross references window (ui_open_builtin). 
           
   :param ea: index of entry to select by default
   :returns: pointer to resulting window


.. py:function:: open_frame_window(pfn: func_t *, offset: int) -> TWidget *

   Open the frame window for the given function (ui_open_builtin). 
           
   :param pfn: function to analyze
   :param offset: offset where the cursor is placed
   :returns: pointer to resulting window if 'pfn' is a valid function and the window was displayed, 
    nullptr otherwise


.. py:function:: open_navband_window(ea: ida_idaapi.ea_t, zoom: int) -> TWidget *

   Open the navigation band window (ui_open_builtin). 
           
   :param ea: sets the address of the navband arrow
   :param zoom: sets the navband zoom level
   :returns: pointer to resulting window


.. py:function:: open_disasm_window(window_title: str, ranges: rangevec_t = None) -> TWidget *

   Open a disassembly view (ui_open_builtin). 
           
   :param window_title: title of view to open
   :param ranges: if != nullptr, then display a flow chart with the specified ranges
   :returns: pointer to resulting window


.. py:function:: open_hexdump_window(window_title: str) -> TWidget *

   Open a hexdump view (ui_open_builtin). 
           
   :param window_title: title of view to open
   :returns: pointer to resulting window


.. py:function:: open_notepad_window() -> TWidget *

   Open the notepad window (ui_open_builtin). 
           
   :returns: pointer to resulting window


.. py:function:: open_bookmarks_window(w: TWidget *) -> TWidget *

   Open the bookmarks window (ui_open_builtin). 
           
   :param w: The widget for which the bookmarks will open. For example, this can be an IDAView, or Enums view, etc.
   :returns: pointer to resulting window


.. py:function:: sync_sources(what: sync_source_t, _with: sync_source_t, sync: bool) -> bool

   [Un]synchronize sources 
           
   :returns: success


.. py:function:: choose_til() -> str

   Choose a type library (ui_choose, chtype_idatil). 
           
   :returns: true: 'buf' was filled with the name of the selected til
   :returns: false: otherwise


.. py:function:: choose_entry(title: str) -> ida_idaapi.ea_t

   Choose an entry point (ui_choose, chtype_entry). 
           
   :param title: chooser title
   :returns: ea of selected entry point, BADADDR if none selected


.. py:function:: choose_name(title: str) -> ida_idaapi.ea_t

   Choose a name (ui_choose, chtype_name). 
           
   :param title: chooser title
   :returns: ea of selected name, BADADDR if none selected


.. py:function:: choose_stkvar_xref(pfn: func_t *, srkvar_tid: tid_t) -> ida_idaapi.ea_t

   Choose an xref to a stack variable (ui_choose, chtype_name). 
           
   :param pfn: function
   :param srkvar_tid: frame variable TID
   :returns: ea of the selected xref, BADADDR if none selected


.. py:function:: choose_xref(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Choose an xref to an address (ui_choose, chtype_xref). 
           
   :param to: referenced address
   :returns: ea of selected xref, BADADDR if none selected


.. py:function:: choose_enum(out: tinfo_t, title: str, default_ord: int) -> bool

   Choose an enum (ui_choose, chtype_enum). 
           
   :param out: the selected enum type
   :param title: chooser title
   :param default_ord: ordinal of enum to select by default
   :returns: true: the selected type is in OUT
   :returns: false: nothing was selected


.. py:function:: choose_enum_by_value(out: tinfo_t, title: str, default_ord: int, value: uint64, nbytes: int) -> uchar *

   Choose an enum, restricted by value & size (ui_choose, chtype_enum_by_value_and_size). If the given value cannot be found initially, this function will ask if the user would like to import a standard enum. 
           
   :param out: the selected enum type
   :param title: chooser title
   :param default_ord: ordinal of enum to select by default
   :param value: value to search for
   :param nbytes: size of value
   :returns: true: the selected type is in OUT
   :returns: false: nothing was selected


.. py:function:: choose_func(title: str, default_ea: ida_idaapi.ea_t) -> func_t *

   Choose a function (ui_choose, chtype_func). 
           
   :param title: chooser title
   :param default_ea: ea of function to select by default
   :returns: pointer to function that was selected, nullptr if none selected


.. py:function:: choose_segm(title: str, default_ea: ida_idaapi.ea_t) -> segment_t *

   Choose a segment (ui_choose, chtype_segm). 
           
   :param title: chooser title
   :param default_ea: ea of segment to select by default
   :returns: pointer to segment that was selected, nullptr if none selected


.. py:function:: choose_struct(out: tinfo_t, title: str) -> bool

   Choose a structure (ui_choose, chtype_struct). 
           
   :param out: the selected structure type
   :param title: chooser title
   :returns: true: the selected type is in OUT
   :returns: false: nothing was selected


.. py:function:: choose_srcp(title: str) -> sreg_range_t *

   Choose a segment register change point (ui_choose, chtype_srcp). 
           
   :param title: chooser title
   :returns: pointer to segment register range of selected change point, nullptr if none selected


.. py:function:: get_chooser_obj(chooser_caption: str) -> void *

   Get the underlying object of the specified chooser (ui_get_chooser_obj).
   This attemps to find the choser by its title and, if found, returns the result of calling its chooser_base_t::get_chooser_obj() method.

   :returns: the object that was used to create the chooser


.. py:function:: get_chooser_rows(out: chooser_row_info_vec_t, chooser_caption: str, what: size_t) -> bool

   Get the chooser contents corresponding to the rows indicated by "what". 
           
   :param out: A vector of chooser_row_info_t, one entry per returned row.
   :param chooser_caption: The caption that identifies the desired chooser.
   :param what: Either one of the GCRF_ flags, or a row index.
   :returns: Success.


.. py:function:: enable_chooser_item_attrs(chooser_caption: str, enable: bool) -> bool

   Enable item-specific attributes for chooser items (ui_enable_chooser_item_attrs). For example: color list items differently depending on a criterium. 
   If enabled, the chooser will generate ui_get_chooser_item_attrs 
   events that can be intercepted by a plugin to modify the item attributes. 
   This event is generated only in the GUI version of IDA. 
   Specifying CH_ATTRS bit at the chooser creation time has the same effect. 
           
   :returns: success


.. py:function:: replace_wait_box(*args) -> None

   Replace the label of "Please wait dialog box".


.. py:function:: beep(beep_type: beep_t = beep_default) -> None

   Issue a beeping sound (ui_beep). 
           
   :param beep_type: beep_t


.. py:function:: display_copyright_warning() -> bool

   Display copyright warning (ui_copywarn). 
           
   :returns: yes/no


.. py:function:: ask_for_feedback(*args) -> None

   Show a message box asking to send the input file to [support@hex-rays.com](mailto:support@hex-rays.com). 
           
   :param format: the reason why the input file is bad


.. py:function:: info(*args) -> ssize_t

.. py:function:: nomem(*args) -> None

.. py:data:: ASKBTN_YES

   Yes button.


.. py:data:: ASKBTN_NO

   No button.


.. py:data:: ASKBTN_CANCEL

   Cancel button.


.. py:data:: ASKBTN_BTN1

   First (Yes) button.


.. py:data:: ASKBTN_BTN2

   Second (No) button.


.. py:data:: ASKBTN_BTN3

   Third (Cancel) button.


.. py:function:: ask_yn(*args) -> int

   Display a dialog box and get choice from "Yes", "No", "Cancel". 
           
   :param deflt: default choice: one of Button IDs
   :param format: The question in printf() style format
   :returns: the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.


.. py:function:: ask_buttons(*args) -> int

   Display a dialog box and get choice from maximum three possibilities (ui_ask_buttons). 
           
   :param Yes: text for the first button
   :param No: text for the second button
   :param Cancel: text for the third button
   :param deflt: default choice: one of Button IDs
   :param format: printf-style format string for question. It may have some prefixes, see below.
   :returns: one of Button IDs specifying the selected button (Esc key returns Cancel/3rd button value)


.. py:data:: HIST_SEG

   segment names


.. py:data:: HIST_CMT

   comments


.. py:data:: HIST_SRCH

   search substrings


.. py:data:: HIST_IDENT

   identifiers. usually CPU register names are forbidden


.. py:data:: HIST_FILE

   file names


.. py:data:: HIST_TYPE

   type declarations


.. py:data:: HIST_CMD

   commands


.. py:data:: HIST_DIR

   directory names (text version only)


.. py:data:: HIST_IDENT2

   identifiers, including CPU register names


.. py:function:: ask_ident2(*args) -> bool

   Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are permitted. 
           
   :param str: qstring to fill. Can contain the default value. Cannot be nullptr.
   :param format: printf() style format string with the question
   :returns: false if the user cancelled the dialog, otherwise returns true.


.. py:function:: ask_file(*args) -> char *

.. py:class:: addon_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  size_t


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: producer
      :type:  str


   .. py:attribute:: version
      :type:  str


   .. py:attribute:: url
      :type:  str


   .. py:attribute:: freeform
      :type:  str


   .. py:attribute:: custom_data
      :type:  void const *


   .. py:attribute:: custom_size
      :type:  size_t


.. py:function:: register_addon(info: addon_info_t) -> int

   Register an add-on. Show its info in the About box. For plugins, should be called from init() function (repeated calls with the same product code overwrite previous entries) returns: index of the add-on in the list, or -1 on error 
           


.. py:function:: addon_count() -> int

   Get number of installed addons.


.. py:function:: get_addon_info(id: str, info: addon_info_t) -> bool

   Get info about a registered addon with a given product code. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
           
   :returns: false if not found


.. py:function:: get_addon_info_idx(index: int, info: addon_info_t) -> bool

   Get info about a registered addon with specific index. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
           
   :returns: false if index is out of range


.. py:class:: strarray_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: code
      :type:  int


   .. py:attribute:: text
      :type:  str


.. py:data:: CLNL_RTRIM

   Remove trailing space characters.


.. py:data:: CLNL_LTRIM

   Remove leading space characters.


.. py:data:: CLNL_FINDCMT

   Search for the comment symbol everywhere in the line, not only at the beginning.


.. py:data:: CLNL_TRIM

.. py:function:: qcleanline(*args) -> str

   Performs some cleanup operations to a line. 
           
   :param buf: string to modify
   :param cmt_char: character that denotes the start of a comment:
   * the entire text is removed if the line begins with this character (ignoring leading spaces)
   * all text after (and including) this character is removed if flag CLNL_FINDCMT is set
   :param flags: a combination of line cleanup flags. defaults to CLNL_TRIM
   :returns: length of line


.. py:function:: strarray(array: strarray_t, array_size: size_t, code: int) -> str

   Find a line with the specified code in the strarray_t array. If the last element of the array has code==0 then it is considered as the default entry. 
   If no default entry exists and the code is not found, strarray() returns "". 
           


.. py:function:: ea2str(ea: ida_idaapi.ea_t) -> str

   Convert linear address to UTF-8 string.


.. py:function:: str2ea(*args) -> uint64 *

   Convert string to linear address. Tries to interpret the string as: 
   1) "current IP" keyword if supported by assembler (e.g. "$" in x86) 
   2) segment:offset expression, where "segment" may be a name or a fixed segment register (e.g. cs, ds) 
   3) just segment name/register (translated to segment's start address) 
   4) a name in the database (or debug name during debugging) 
   5) hexadecimal value without prefix or suffix 
   6) +delta or -delta, where numerical 'delta' is added to or subtracted from 'screen_ea' 
   7) register name (only during debugging) 
   8) if all else fails, try to evaluate 'str' as an IDC expression

   :param str: string to parse
   :param screen_ea: the current address in the disassembly/pseudocode view
   :returns: success


.. py:function:: str2ea_ex(*args) -> uint64 *

   Same as str2ea() but possibly with some steps skipped. 
           
   :param out: the buffer to put the result
   :param str: string to parse
   :param screen_ea: the current address in the disassembly/pseudocode view
   :param flags: see String to address conversion flags
   :returns: success


.. py:data:: S2EAOPT_NOCALC

   don't try to interpret string as IDC (or current extlang) expression


.. py:function:: atoea(str: atoea.str) -> uint64 *

   Convert a number in C notation to an address. decimal: 1234 
   octal: 0123 
   hexadecimal: 0xabcd 
   binary: 0b00101010 
           
   :param str: the string to parse


.. py:data:: IK_CANCEL

.. py:data:: IK_BACK

.. py:data:: IK_TAB

.. py:data:: IK_CLEAR

.. py:data:: IK_RETURN

.. py:data:: IK_SHIFT

.. py:data:: IK_CONTROL

.. py:data:: IK_MENU

.. py:data:: IK_PAUSE

.. py:data:: IK_CAPITAL

.. py:data:: IK_KANA

.. py:data:: IK_ESCAPE

.. py:data:: IK_MODECHANGE

.. py:data:: IK_SPACE

.. py:data:: IK_PRIOR

.. py:data:: IK_NEXT

.. py:data:: IK_END

.. py:data:: IK_HOME

.. py:data:: IK_LEFT

.. py:data:: IK_UP

.. py:data:: IK_RIGHT

.. py:data:: IK_DOWN

.. py:data:: IK_SELECT

.. py:data:: IK_PRINT

.. py:data:: IK_EXECUTE

.. py:data:: IK_SNAPSHOT

.. py:data:: IK_INSERT

.. py:data:: IK_DELETE

.. py:data:: IK_HELP

.. py:data:: IK_LWIN

.. py:data:: IK_RWIN

.. py:data:: IK_APPS

.. py:data:: IK_SLEEP

.. py:data:: IK_NUMPAD0

.. py:data:: IK_NUMPAD1

.. py:data:: IK_NUMPAD2

.. py:data:: IK_NUMPAD3

.. py:data:: IK_NUMPAD4

.. py:data:: IK_NUMPAD5

.. py:data:: IK_NUMPAD6

.. py:data:: IK_NUMPAD7

.. py:data:: IK_NUMPAD8

.. py:data:: IK_NUMPAD9

.. py:data:: IK_MULTIPLY

.. py:data:: IK_ADD

.. py:data:: IK_SEPARATOR

.. py:data:: IK_SUBTRACT

.. py:data:: IK_DECIMAL

.. py:data:: IK_DIVIDE

.. py:data:: IK_F1

.. py:data:: IK_F2

.. py:data:: IK_F3

.. py:data:: IK_F4

.. py:data:: IK_F5

.. py:data:: IK_F6

.. py:data:: IK_F7

.. py:data:: IK_F8

.. py:data:: IK_F9

.. py:data:: IK_F10

.. py:data:: IK_F11

.. py:data:: IK_F12

.. py:data:: IK_F13

.. py:data:: IK_F14

.. py:data:: IK_F15

.. py:data:: IK_F16

.. py:data:: IK_F17

.. py:data:: IK_F18

.. py:data:: IK_F19

.. py:data:: IK_F20

.. py:data:: IK_F21

.. py:data:: IK_F22

.. py:data:: IK_F23

.. py:data:: IK_F24

.. py:data:: IK_NUMLOCK

.. py:data:: IK_SCROLL

.. py:data:: IK_OEM_FJ_MASSHOU

.. py:data:: IK_OEM_FJ_TOUROKU

.. py:data:: IK_LSHIFT

.. py:data:: IK_RSHIFT

.. py:data:: IK_LCONTROL

.. py:data:: IK_RCONTROL

.. py:data:: IK_LMENU

.. py:data:: IK_RMENU

.. py:data:: IK_BROWSER_BACK

.. py:data:: IK_BROWSER_FORWARD

.. py:data:: IK_BROWSER_REFRESH

.. py:data:: IK_BROWSER_STOP

.. py:data:: IK_BROWSER_SEARCH

.. py:data:: IK_BROWSER_FAVORITES

.. py:data:: IK_BROWSER_HOME

.. py:data:: IK_VOLUME_MUTE

.. py:data:: IK_VOLUME_DOWN

.. py:data:: IK_VOLUME_UP

.. py:data:: IK_MEDIA_NEXT_TRACK

.. py:data:: IK_MEDIA_PREV_TRACK

.. py:data:: IK_MEDIA_STOP

.. py:data:: IK_MEDIA_PLAY_PAUSE

.. py:data:: IK_LAUNCH_MAIL

.. py:data:: IK_LAUNCH_MEDIA_SELECT

.. py:data:: IK_LAUNCH_APP1

.. py:data:: IK_LAUNCH_APP2

.. py:data:: IK_OEM_1

.. py:data:: IK_OEM_PLUS

.. py:data:: IK_OEM_COMMA

.. py:data:: IK_OEM_MINUS

.. py:data:: IK_OEM_PERIOD

.. py:data:: IK_OEM_2

.. py:data:: IK_OEM_3

.. py:data:: IK_OEM_4

.. py:data:: IK_OEM_5

.. py:data:: IK_OEM_6

.. py:data:: IK_OEM_7

.. py:data:: IK_OEM_102

.. py:data:: IK_PLAY

.. py:data:: IK_ZOOM

.. py:data:: IK_OEM_CLEAR

.. py:data:: CB_INIT

.. py:data:: CB_YES

.. py:data:: CB_CLOSE

.. py:data:: CB_INVISIBLE

.. py:data:: CB_DESTROYING

.. py:data:: CB_NO

.. py:data:: CB_CANCEL

.. py:function:: get_user_strlist_options(out: strwinsetup_t *) -> None

.. py:function:: del_idc_hotkey(hotkey: str) -> bool

.. py:class:: disasm_text_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> disasm_line_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> disasm_line_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: disasm_text_t) -> None


   .. py:method:: extract() -> disasm_line_t *


   .. py:method:: inject(s: disasm_line_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< disasm_line_t >::const_iterator


   .. py:method:: end(*args) -> qvector< disasm_line_t >::const_iterator


   .. py:method:: insert(it: disasm_line_t, x: disasm_line_t) -> qvector< disasm_line_t >::iterator


   .. py:method:: erase(*args) -> qvector< disasm_line_t >::iterator


   .. py:method:: append(x: disasm_line_t) -> None


   .. py:method:: extend(x: disasm_text_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: load_custom_icon(file_name=None, data=None, format=None)

   Load an icon from a file (ui_load_custom_icon_file). Also see load_custom_icon(const void *, unsigned int, const char *) 
           
   :param file_name: path to file
   :returns: icon id


.. py:function:: ask_long(defval: int, prompt: str) -> Union[int, None]

   Display a dialog box and wait for the user to input a number

   :param defval: The placeholder value
   :param prompt: The prompt to show
   :returns: the number entered by the user, or None if the dialog was canceled


.. py:function:: ask_addr(defval: ida_idaapi.ea_t, prompt: str) -> Union[ida_idaapi.ea_t, None]

   Display a dialog box and wait for the user to input an address

   :param defval: The placeholder value
   :param prompt: The prompt to show
   :returns: the address entered by the user, or None if the dialog was canceled


.. py:function:: ask_seg(defval: int, prompt: str) -> Union[int, None]

   Display a dialog box and wait for the user to input an segment name.
   This function allows to enter segment register names, segment base
   paragraphs, segment names to denote a segment.

   :param defval: The placeholder value
   :param prompt: The prompt to show
   :returns: the selector of the segment entered by the user, or None if the dialog was canceled


.. py:function:: ask_ident(defval: str, prompt: str) -> bool

   Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are usually forbidden. 
           
   :returns: false if the user cancelled the dialog, otherwise returns true.


.. py:class:: action_handler_t

   Bases: :py:obj:`object`


   .. py:method:: activate(ctx)

      Activate an action. This function implements the core behavior of an action. It is called when the action is triggered, from a menu, from a popup menu, from the toolbar, or programmatically. 
              
      :returns: non-zero: all IDA windows will be refreshed



   .. py:method:: update(ctx)

      Update an action. This is called when the context of the UI changed, and we need to let the action update some of its properties if needed (label, icon, ...)
      In addition, this lets IDA know whether the action is enabled, and when it should be queried for availability again.
      Note: This callback is not meant to change anything in the application's state, except by calling one (or many) of the "update_action_*()" functions on this very action. 
              



.. py:class:: quick_widget_commands_t(callback)

   .. py:attribute:: callback


   .. py:attribute:: cmds
      :value: []



   .. py:method:: add(caption, flags, menu_index, icon, emb, shortcut)


   .. py:method:: populate_popup(widget, popup)


.. py:class:: disabled_script_timeout_t

   Bases: :py:obj:`object`


.. py:data:: SETMENU_IF_ENABLED
   :value: 4


.. py:data:: CH_NOIDB

.. py:data:: BWN_TILVIEW

.. py:data:: IWID_TILVIEW

.. py:data:: BWN_LOCTYPS

.. py:data:: IWID_LOCTYPS

.. py:data:: BWN_DISASMS

.. py:data:: IWID_DISASMS

.. py:data:: CHOOSER_NO_SELECTION

.. py:data:: CHOOSER_MULTI_SELECTION

.. py:data:: CHOOSER_POPUP_MENU

.. py:data:: CHOOSER_MENU_EDIT

.. py:data:: CHOOSER_MENU_JUMP

.. py:data:: CHOOSER_MENU_SEARCH

.. py:function:: choose_find(title: str) -> Union[object, None]

   Retrieve the chooser object by title

   :param title: the chooser title
   :returns: the chooser, or None


.. py:function:: choose_refresh(_self: PyObject *) -> None

.. py:function:: choose_close(_self: PyObject *) -> None

.. py:function:: choose_get_widget(_self: PyObject *) -> TWidget *

.. py:function:: choose_choose(_self: PyObject *) -> PyObject *

.. py:function:: choose_activate(_self: PyObject *) -> None

.. py:function:: choose_create_embedded_chobj(_self: PyObject *) -> PyObject *

.. py:function:: get_chooser_data(title: str, n: int) -> List[str]

   Get the text corresponding to the index N in the chooser data.
   Use -1 to get the header.

   :param title: The chooser title
   :returns: a list of strings, or None


.. py:data:: CH_NOIDB

.. py:class:: Choose(title, cols, flags=0, popup_names=None, icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=None, embedded=False, width=None, height=None, forbidden_cb=0, flags2=0)

   Bases: :py:obj:`object`


   Chooser wrapper class.

   Some constants are defined in this class.
   Please refer to kernwin.hpp for more information.


   .. py:attribute:: CH_MODAL

      Modal chooser.



   .. py:attribute:: CH_MULTI

      The chooser will allow multi-selection (only for GUI choosers). This bit is set when using the chooser_multi_t structure. 
              



   .. py:attribute:: CH_NOBTNS

      do not display ok/cancel/help/search buttons. Meaningful only for gui modal windows because non-modal windows do not have any buttons anyway. Text mode does not have them neither. 
              



   .. py:attribute:: CH_ATTRS

      generate ui_get_chooser_item_attrs (gui only)



   .. py:attribute:: CH_NOIDB

      use the chooser even without an open database, same as x0=-2



   .. py:attribute:: CH_FORCE_DEFAULT

      if a non-modal chooser was already open, change selection to the default one 
              



   .. py:attribute:: CH_CAN_INS

      allow to insert new items



   .. py:attribute:: CH_CAN_DEL

      allow to delete existing item(s)



   .. py:attribute:: CH_CAN_EDIT

      allow to edit existing item(s)



   .. py:attribute:: CH_CAN_REFRESH

      allow to refresh chooser



   .. py:attribute:: CH_QFLT

      open with quick filter enabled and focused



   .. py:attribute:: CH_QFTYP_SHIFT


   .. py:attribute:: CH_QFTYP_DEFAULT

      set quick filtering type to the possible existing default for this chooser



   .. py:attribute:: CH_QFTYP_NORMAL

      normal (i.e., lexicographical) quick filter type



   .. py:attribute:: CH_QFTYP_WHOLE_WORDS

      whole words quick filter type



   .. py:attribute:: CH_QFTYP_REGEX

      regex quick filter type



   .. py:attribute:: CH_QFTYP_FUZZY

      fuzzy search quick filter type



   .. py:attribute:: CH_QFTYP_MASK


   .. py:attribute:: CH_NO_STATUS_BAR

      don't show a status bar



   .. py:attribute:: CH_RESTORE

      restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)



   .. py:attribute:: CH_RENAME_IS_EDIT

      triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit() callback for the corresponding row. 
              



   .. py:attribute:: CH_BUILTIN_SHIFT


   .. py:attribute:: CH_BUILTIN_MASK

      Mask for builtin chooser numbers. Plugins should not use them.



   .. py:attribute:: CH_HAS_DIRTREE

      The chooser can provide a dirtree_t, meaning a tree-like structure can be provided to the user (instead of a flat table) 
              



   .. py:attribute:: CH_HAS_DIFF

      The chooser can be used in a diffing/merging workflow.



   .. py:attribute:: CHCOL_PLAIN

      plain string



   .. py:attribute:: CHCOL_PATH

      file path. TUI IDA will truncate excessive cell lengths starting at their beginning, and prepending the resulting text with "..." order to leave the filename visible 
              



   .. py:attribute:: CHCOL_HEX

      hexadecimal number



   .. py:attribute:: CHCOL_DEC

      decimal number



   .. py:attribute:: CHCOL_EA

      address



   .. py:attribute:: CHCOL_FNAME

      function name. If a chooser column has this flag set and implements chooser_base_t::get_ea(), rows background colors will be automatically set to match the navigator's "Library function", "Lumina function" and "External symbol" colors 
              



   .. py:attribute:: CHCOL_FORMAT

      column format mask



   .. py:attribute:: CHCOL_DEFHIDDEN

      column should be hidden by default



   .. py:attribute:: CHCOL_DRAGHINT

      the column number that will be used to build hints for the dragging undo label. This should be provided for at most one column for any given chooser. 
              



   .. py:attribute:: CHCOL_INODENAME

      if CH_HAS_DIRTREE has been specified, this instructs the chooser that this column shows the inode name. This should be provided for at most one column for any given chooser. 
              



   .. py:attribute:: NO_SELECTION
      :value: -1


      there is no selected item



   .. py:attribute:: EMPTY_CHOOSER
      :value: -2


      the chooser is initialized



   .. py:attribute:: ALREADY_EXISTS
      :value: -3


      the non-modal chooser with the same data is already open



   .. py:attribute:: NO_ATTR
      :value: -4


      some mandatory attribute is missing



   .. py:attribute:: NOTHING_CHANGED
      :value: 0



   .. py:attribute:: ALL_CHANGED
      :value: 1



   .. py:attribute:: SELECTION_CHANGED
      :value: 2



   .. py:class:: UI_Hooks_Trampoline(v)

      Bases: :py:obj:`UI_Hooks`


      .. py:attribute:: v


      .. py:method:: populating_widget_popup(widget, popup_handle)

         IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
         Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)

         :param widget: (TWidget *)
         :param popup_handle: (TPopupMenu *)
         :param ctx: (const action_activation_ctx_t *)
         :returns: void




   .. py:attribute:: title


   .. py:attribute:: flags
      :value: 0



   .. py:attribute:: flags2
      :value: 0



   .. py:attribute:: cols


   .. py:attribute:: deflt
      :value: None



   .. py:attribute:: popup_names
      :value: None



   .. py:attribute:: icon
      :value: -1



   .. py:attribute:: x1
      :value: -1



   .. py:attribute:: y1
      :value: -1



   .. py:attribute:: x2
      :value: -1



   .. py:attribute:: y2
      :value: -1



   .. py:attribute:: embedded
      :value: False



   .. py:attribute:: width
      :value: None



   .. py:attribute:: height
      :value: None



   .. py:attribute:: forbidden_cb
      :value: 0



   .. py:attribute:: ui_hooks_trampoline
      :value: None



   .. py:method:: Embedded(create_chobj=False)

      Creates an embedded chooser (as opposed to Show())
      :returns: Returns 0 on success or NO_ATTR



   .. py:method:: GetEmbSelection()

      Deprecated. For embedded choosers, the selection is
      available through 'Form.EmbeddedChooserControl.selection'



   .. py:method:: Show(modal=False)

      Activates or creates a chooser window
      :param modal: Display as modal dialog
      :returns: For all choosers it will return NO_ATTR if some mandatory
               attribute is missing. The mandatory attributes are: flags,
               title, cols, OnGetSize(), OnGetLine();
               For modal choosers it will return the selected item index (0-based),
               or NO_SELECTION if no selection,
               or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
               For non-modal choosers it will return 0
               or ALREADY_EXISTS if the chooser was already open and is active now;



   .. py:method:: Activate()

      Activates a visible chooser



   .. py:method:: Refresh()

      Causes the refresh callback to trigger



   .. py:method:: Close()

      Closes the chooser



   .. py:method:: GetWidget()

      Return the TWidget underlying this view.

      :returns: The TWidget underlying this view, or None.



   .. py:method:: adjust_last_item(n)

      Helper for OnDeleteLine() and OnRefresh() callbacks.
      They can be finished by the following line:
      return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
      :param n: line number of the remaining select item
      :returns: list of selected lines numbers (one element or empty)



   .. py:method:: AddCommand(caption, flags=_ida_kernwin.CHOOSER_POPUP_MENU, menu_index=-1, icon=-1, emb=None, shortcut=None)


   .. py:method:: OnPopup(widget, popup_handle)


   .. py:method:: OnInit()

      Initialize the chooser and populate it.

      This callback is optional



   .. py:method:: OnGetSize()

      Get the number of elements in the chooser.

      This callback is mandatory

      :returns: the number of elements



   .. py:method:: OnGetLine(n)

      Get data for an element

      This callback is mandatory

      :param n: the index to fetch data for
      :returns: a list of strings



   .. py:method:: OnGetIcon(n)

      Get an icon to associate with the first cell of an element

      :param n: index of the element
      :returns: an icon ID



   .. py:method:: OnGetLineAttr(n)

      Get attributes for an element

      :param n: index of the element
      :returns: a tuple (color, flags)



   .. py:method:: OnInsertLine(sel)

      User asked to insert an element

      :param sel: the current selection
      :returns: a tuple (changed, selection)



   .. py:method:: OnDeleteLine(sel)

      User deleted an element

      :param sel: the current selection
      :returns: a tuple (changed, selection)



   .. py:method:: OnEditLine(sel)

      User asked to edit an element.

      :param sel: the current selection
      :returns: a tuple (changed, selection)



   .. py:method:: OnSelectLine(sel)

      User pressed the enter key, or double-clicked a selection

      :param sel: the current selection
      :returns: a tuple (changed, selection)



   .. py:method:: OnSelectionChange(sel)

      Selection changed

      :param sel: the new selection



   .. py:method:: OnRefresh(sel)

      The chooser needs to be refreshed.
      It returns the new positions of the selected items.

      :param sel: the current selection
      :returns: a tuple (changed, selection)



   .. py:method:: OnClose()

      The chooser window is closed.



   .. py:method:: OnGetEA(n)

      Get the address of an element

      When this function returns valid addresses:
        * If any column has the `CHCOL_FNAME` flag, rows will
          be colored according to the attributes of the functions
          who own those addresses (extern, library function,
          Lumina, ... - similar to what the "Functions" widget does)
        * When a selection is present and the user presses `<Enter>`
          (`<Shift+Enter>` if the chooser is modal), IDA will jump
          to that address (through jumpto())
      :param n: element number (0-based)
      :returns: the effective address, ida_idaapi.BADADDR if the element has no address



   .. py:method:: OnGetDirTree()

      Get the dirtree_t that will be used to present a tree-like
      structure to the user (see CH_HAS_DIRTREE)

      :returns: the dirtree_t, or None



   .. py:method:: OnIndexToInode(n)

      Map an element index to a dirtree_t inode

      This callback is mandatory if CH_HAS_DIRTREE is specified

      :param n: index of the element
      :returns: the inode number



   .. py:method:: OnIndexToDiffpos(n)

      Map an element index to a diffpos_t

      This callback is mandatory if CH_HAS_DIFF is specified

      :param n: index of the element
      :returns: the diffpos



   .. py:method:: OnLazyLoadDir(path)

      Callback for lazy-loaded, dirtree-based choosers;
      the function will be called when a folder is expanded and it has
      not been loaded before. The implementation should use the
      given dirtree's link() or mkdir() methods to add the folder contents.

      :param path: an absolute dirtree path to the directory that is being expanded
      :returns: success



.. py:function:: textctrl_info_t_assign(_self: PyObject *, other: PyObject *) -> bool

.. py:function:: textctrl_info_t_set_text(_self: PyObject *, s: str) -> bool

.. py:function:: textctrl_info_t_get_text(_self: PyObject *) -> str

.. py:function:: textctrl_info_t_set_flags(_self: PyObject *, flags: unsigned int) -> bool

.. py:function:: textctrl_info_t_get_flags(_self: PyObject *) -> unsigned int

.. py:function:: textctrl_info_t_set_tabsize(_self: PyObject *, tabsize: unsigned int) -> bool

.. py:function:: textctrl_info_t_get_tabsize(_self: PyObject *) -> unsigned int

.. py:function:: formchgcbfa_enable_field(p_fa: size_t, fid: int, enable: bool) -> bool

.. py:function:: formchgcbfa_show_field(p_fa: size_t, fid: int, show: bool) -> bool

.. py:function:: formchgcbfa_move_field(p_fa: size_t, fid: int, x: int, y: int, w: int, h: int) -> bool

.. py:function:: formchgcbfa_get_focused_field(p_fa: size_t) -> int

.. py:function:: formchgcbfa_set_focused_field(p_fa: size_t, fid: int) -> bool

.. py:function:: formchgcbfa_refresh_field(p_fa: size_t, fid: int) -> None

.. py:function:: formchgcbfa_close(p_fa: size_t, close_normally: int) -> None

.. py:function:: formchgcbfa_get_field_value(p_fa: size_t, fid: int, ft: int, sz: size_t) -> PyObject *

.. py:function:: formchgcbfa_set_field_value(p_fa: size_t, fid: int, ft: int, py_val: PyObject *) -> bool

.. py:function:: py_get_ask_form() -> size_t

.. py:function:: py_get_open_form() -> size_t

.. py:function:: py_register_compiled_form(py_form: PyObject *) -> None

.. py:function:: py_unregister_compiled_form(py_form: PyObject *) -> None

.. py:class:: textctrl_info_t(text='', flags=0, tabsize=0)

   Bases: :py:obj:`ida_idaapi.py_clinked_object_t`


   Class representing textctrl_info_t


   .. py:attribute:: TXTF_AUTOINDENT
      :value: 1


      Auto-indent on new line



   .. py:attribute:: TXTF_ACCEPTTABS
      :value: 2


      Tab key inserts 'tabsize' spaces



   .. py:attribute:: TXTF_READONLY
      :value: 4


      Text cannot be edited (but can be selected and copied)



   .. py:attribute:: TXTF_SELECTED
      :value: 8


      Shows the field with its text selected



   .. py:attribute:: TXTF_MODIFIED
      :value: 16


      Gets/sets the modified status



   .. py:attribute:: TXTF_FIXEDFONT
      :value: 32


      The control uses IDA's fixed font



   .. py:method:: assign(other)

      Copies the contents of 'other' to 'self'



   .. py:attribute:: value

      Alias for the text property



   .. py:attribute:: text

      in, out: text control value



   .. py:attribute:: flags

      Text control property bits 
              



   .. py:attribute:: tabsize

      how many spaces a single tab will indent



.. py:class:: Form(form, controls)

   Bases: :py:obj:`object`


   .. py:attribute:: FT_ASCII
      :value: 'A'


      Ascii string - char *



   .. py:attribute:: FT_SEG
      :value: 'S'


      Segment - sel_t *



   .. py:attribute:: FT_HEX
      :value: 'N'


      Hex number - uval_t *



   .. py:attribute:: FT_SHEX
      :value: 'n'


      Signed hex number - sval_t *



   .. py:attribute:: FT_COLOR
      :value: 'K'


      Color button - bgcolor_t *



   .. py:attribute:: FT_ADDR
      :value: '$'


      Address - ea_t *



   .. py:attribute:: FT_UINT64
      :value: 'L'


      default base uint64 - uint64



   .. py:attribute:: FT_INT64
      :value: 'l'


      default base int64 - int64



   .. py:attribute:: FT_RAWHEX
      :value: 'M'


      Hex number, no 0x prefix - uval_t *



   .. py:attribute:: FT_FILE
      :value: 'f'


      File browse - char * at least QMAXPATH



   .. py:attribute:: FT_DEC
      :value: 'D'


      Decimal number - sval_t *



   .. py:attribute:: FT_OCT
      :value: 'O'


      Octal number, C notation - sval_t *



   .. py:attribute:: FT_BIN
      :value: 'Y'


      Binary number, 0b prefix - sval_t *



   .. py:attribute:: FT_CHAR
      :value: 'H'


      Char value -- sval_t *



   .. py:attribute:: FT_IDENT
      :value: 'I'


      Identifier - char * at least MAXNAMELEN



   .. py:attribute:: FT_BUTTON
      :value: 'B'


      Button - def handler(code)



   .. py:attribute:: FT_DIR
      :value: 'F'


      Path to directory - char * at least QMAXPATH



   .. py:attribute:: FT_TYPE
      :value: 'T'


      Type declaration - char * at least MAXSTR



   .. py:attribute:: FT_FORMCHG
      :value: '%/'


      Form change callback - formchgcb_t



   .. py:attribute:: FT_ECHOOSER
      :value: 'E'


      Embedded chooser - idaapi.Choose



   .. py:attribute:: FT_MULTI_LINE_TEXT
      :value: 't'


      Multi text control - textctrl_info_t



   .. py:attribute:: FT_DROPDOWN_LIST
      :value: 'b'


      Dropdown list control - Form.DropdownControl



   .. py:attribute:: FT_HTML_LABEL
      :value: 'h'


      HTML label to display (only for GUI version, and for dynamic labels; no input)



   .. py:attribute:: FT_CHKGRP
      :value: 'C'



   .. py:attribute:: FT_CHKGRP2
      :value: 'c'



   .. py:attribute:: FT_RADGRP
      :value: 'R'



   .. py:attribute:: FT_RADGRP2
      :value: 'r'



   .. py:method:: create_string_buffer(value, size=None)
      :staticmethod:



   .. py:method:: fieldtype_to_ctype(tp, i64=False)
      :staticmethod:


      Factory method returning a ctype class corresponding to the field type string



   .. py:class:: NumericArgument(tp, value, i64=None)

      Bases: :py:obj:`object`


      Argument representing various integer arguments (ushort, uint32, uint64, etc...)
      :param tp: One of Form.FT_XXX


      .. py:attribute:: DefI64
         :value: False



      .. py:attribute:: arg


      .. py:attribute:: value



   .. py:class:: StringArgument(size=None, value=None)

      Bases: :py:obj:`object`


      Argument representing a character buffer


      .. py:attribute:: size
         :value: None



      .. py:attribute:: arg


      .. py:attribute:: value



   .. py:class:: Control

      Bases: :py:obj:`object`


      .. py:attribute:: id
         :value: 0


         Automatically assigned control ID



      .. py:attribute:: input_field_index
         :value: None


         If this control is an input field, once Compile() returns this will hold its index. This is used only to compute the possible STARTITEM index



      .. py:attribute:: arg
         :value: None


         Control argument value. This could be one element or a list/tuple (for multiple args per control)



      .. py:attribute:: form
         :value: None


         Reference to the parent form. It is filled by Form.Add()



      .. py:attribute:: form_hasattr
         :value: False



      .. py:method:: get_tag()

         Control tag character. One of Form.FT_XXXX.
         The form class will expand the {} notation and replace them with the tags



      .. py:method:: get_arg()

         Control returns the parameter to be pushed on the stack
         (Of ask_form())



      .. py:method:: free()

         Free the control



      .. py:method:: is_input_field()

         Return True if this field acts as an input




   .. py:class:: LabelControl(tp)

      Bases: :py:obj:`Control`


      Base class for static label control


      .. py:attribute:: tp


      .. py:method:: get_tag()

         Control tag character. One of Form.FT_XXXX.
         The form class will expand the {} notation and replace them with the tags




   .. py:class:: StringLabel(value, tp=None, size=ida_pro.MAXSTR)

      Bases: :py:obj:`LabelControl`


      String label control


      .. py:attribute:: size


      .. py:attribute:: arg

         Control argument value. This could be one element or a list/tuple (for multiple args per control)




   .. py:class:: NumericLabel(value, tp=None)

      Bases: :py:obj:`LabelControl`, :py:obj:`NumericArgument`


      Numeric label control



   .. py:class:: GroupItemControl(tag, parent)

      Bases: :py:obj:`Control`


      Base class for group control items


      .. py:attribute:: tag


      .. py:attribute:: parent


      .. py:attribute:: pos
         :value: 0



      .. py:method:: assign_pos()


      .. py:method:: get_tag()

         Control tag character. One of Form.FT_XXXX.
         The form class will expand the {} notation and replace them with the tags



      .. py:method:: is_input_field()

         Return True if this field acts as an input




   .. py:class:: ChkGroupItemControl(tag, parent)

      Bases: :py:obj:`GroupItemControl`


      Checkbox group item control


      .. py:attribute:: checked

         Get/Sets checkbox item check status




   .. py:class:: RadGroupItemControl(tag, parent)

      Bases: :py:obj:`GroupItemControl`


      Radiobox group item control


      .. py:attribute:: selected

         Get/Sets radiobox item selection status




   .. py:class:: GroupControl(children_names, tag, value=0)

      Bases: :py:obj:`Control`, :py:obj:`NumericArgument`


      Base class for group controls


      .. py:attribute:: children_names


      .. py:attribute:: tag


      .. py:method:: next_child_pos()


      .. py:method:: get_tag()

         Control tag character. One of Form.FT_XXXX.
         The form class will expand the {} notation and replace them with the tags




   .. py:class:: ChkGroupControl(children_names, value=0, secondary=False)

      Bases: :py:obj:`GroupControl`


      Checkbox group control class.
      It holds a set of checkbox controls


      .. py:attribute:: ItemClass
         :value: None


         Group control item factory class instance
         We need this because later we won't be treating ChkGroupControl or RadGroupControl
         individually, instead we will be working with GroupControl in general.




   .. py:class:: RadGroupControl(children_names, value=0, secondary=False)

      Bases: :py:obj:`GroupControl`


      Radiobox group control class.
      It holds a set of radiobox controls


      .. py:attribute:: ItemClass
         :value: None




   .. py:class:: InputControl(tp, width, swidth, hlp=None, is_relative_offset=False)

      Bases: :py:obj:`Control`


      Generic form input control.
      It could be numeric control, string control, directory/file browsing, etc...


      .. py:attribute:: tp


      .. py:attribute:: width


      .. py:attribute:: swidth


      .. py:attribute:: hlp
         :value: None



      .. py:attribute:: is_relative_offset
         :value: False



      .. py:method:: get_tag()

         Control tag character. One of Form.FT_XXXX.
         The form class will expand the {} notation and replace them with the tags



      .. py:method:: is_input_field()

         Return True if this field acts as an input




   .. py:class:: NumericInput(tp=None, value=0, width=50, swidth=10, hlp=None, is_relative_offset=False, i64=None)

      Bases: :py:obj:`InputControl`, :py:obj:`NumericArgument`


      A composite class serving as a base numeric input control class



   .. py:class:: ColorInput(value=0)

      Bases: :py:obj:`NumericInput`


      Color button input control



   .. py:class:: StringInput(tp=None, width=ida_pro.MAXSTR, swidth=40, hlp=None, value=None, size=None)

      Bases: :py:obj:`InputControl`, :py:obj:`StringArgument`


      Base string input control class.
      This class also constructs a StringArgument



   .. py:class:: FileInput(width=512, swidth=80, save=False, open=False, hlp=None, value=None)

      Bases: :py:obj:`StringInput`


      File Open/Save input control



   .. py:class:: DirInput(width=512, swidth=80, hlp=None, value=None)

      Bases: :py:obj:`StringInput`


      Directory browsing control



   .. py:class:: ButtonInput(handler, code='', swidth='', hlp=None)

      Bases: :py:obj:`InputControl`


      Button control.
      A handler along with a 'code' (numeric value) can be associated with the button.
      This way one handler can handle many buttons based on the button code (or in other terms id or tag)


      .. py:attribute:: handler


      .. py:attribute:: arg

         Control argument value. This could be one element or a list/tuple (for multiple args per control)



      .. py:method:: helper_cb(button_code, p_fa)


      .. py:method:: is_input_field()

         Return True if this field acts as an input




   .. py:class:: FormChangeCb(handler)

      Bases: :py:obj:`Control`


      Form change handler.
      This can be thought of like a dialog procedure.
      Everytime a form action occurs, this handler will be called along with the control id.
      The programmer can then call various form actions accordingly:
        - EnableField
        - ShowField
        - MoveField
        - GetFieldValue
        - etc...

      Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)



      .. py:attribute:: handler


      .. py:attribute:: arg

         Control argument value. This could be one element or a list/tuple (for multiple args per control)



      .. py:method:: helper_cb(fid, p_fa)


      .. py:method:: get_tag()

         Control tag character. One of Form.FT_XXXX.
         The form class will expand the {} notation and replace them with the tags



      .. py:method:: free()

         Free the control




   .. py:class:: EmbeddedChooserControl(chooser=None, swidth=40, hlp=None)

      Bases: :py:obj:`InputControl`


      Embedded chooser control.
      This control links to a Chooser2 control created with the 'embedded=True'


      .. py:attribute:: selobj


      .. py:attribute:: arg

         Control argument value. This could be one element or a list/tuple (for multiple args per control)



      .. py:attribute:: chooser
         :value: None



      .. py:attribute:: size
         :value: 0



      .. py:attribute:: value

         Returns the embedded chooser instance



      .. py:attribute:: selection

         Returns the selection



      .. py:method:: free()

         Frees the embedded chooser data




   .. py:class:: DropdownListControl(items=[], readonly=True, selval=0, width=50, swidth=50, hlp=None)

      Bases: :py:obj:`InputControl`, :py:obj:`ida_pro._qstrvec_t`


      Dropdown control
      This control allows manipulating a dropdown control


      .. py:attribute:: readonly
         :value: True



      .. py:attribute:: arg

         Control argument value. This could be one element or a list/tuple (for multiple args per control)



      .. py:attribute:: value


      .. py:attribute:: selval

         Read/write the selection value.
         The value is used as an item index in readonly mode or text value in editable mode
         This value can be used only after the form has been closed.



      .. py:method:: free()

         Free the control



      .. py:method:: set_items(items)

         Sets the dropdown list items




   .. py:class:: MultiLineTextControl(text='', flags=0, tabsize=0, width=50, swidth=50, hlp=None)

      Bases: :py:obj:`InputControl`, :py:obj:`textctrl_info_t`


      Multi line text control.
      This class inherits from textctrl_info_t. Thus the attributes are also inherited
      This control allows manipulating a multilinetext control


      .. py:attribute:: arg

         Control argument value. This could be one element or a list/tuple (for multiple args per control)



      .. py:method:: free()

         Free the control




   .. py:attribute:: form

      Form string



   .. py:attribute:: controls

      Dictionary of controls



   .. py:attribute:: title
      :value: None


      The Form title. It will be filled when the form is compiled



   .. py:attribute:: modal
      :value: True


      By default, forms are modal



   .. py:attribute:: openform_flags
      :value: 0


      If non-modal, these flags will be passed to open_form.
      This is an OR'ed combination of the PluginForm.FORM_* values.



   .. py:method:: Free()

      Frees all resources associated with a compiled form.
      Make sure you call this function when you finish using the form.



   .. py:method:: Add(name, ctrl, mkattr=True)

      Low level function. Prefer AddControls() to this function.
      This function adds one control to the form.

      :param name: Control name
      :param ctrl: Control object
      :param mkattr: Create control name / control object as a form attribute



   .. py:method:: FindControlById(id)

      Finds a control instance given its id



   .. py:method:: AddControls(controls, mkattr=True)

      Adds controls from a dictionary.
      The dictionary key is the control name and the value is a Form.Control object
      :param controls: The control dictionary



   .. py:method:: CompileEx(form)

      Low level function.
      Compiles (parses the form syntax and adds the control) the form string and
      returns the argument list to be passed the argument list to ask_form().

      The form controls are wrapped inside curly braces: {ControlName}.

      A special operator can be used to return the index of a given control by its name: {id:ControlName}.
      This is useful when you use the STARTITEM form keyword to set the initially focused control.
      (note that, technically, the index is not the same as the ID; that's because STARTITEM
      uses raw, 0-based indexes rather than control IDs to determine the focused widget.)

      :param form: Compiles the form and returns the arguments needed to be passed to ask_form()



   .. py:method:: Compile()

      Compiles a form and returns the form object (self) and the argument list.
      The form object will contain object names corresponding to the form elements

      :returns: It will raise an exception on failure. Otherwise the return value is ignored



   .. py:method:: Compiled()

      Checks if the form has already been compiled

      :returns: Boolean



   .. py:method:: Execute()

      Displays a modal dialog containing the compiled form.
      :returns: 1 - ok ; 0 - cancel



   .. py:method:: Open()

      Opens a widget containing the compiled form.



   .. py:method:: EnableField(ctrl, enable)

      Enable or disable an input field
      :returns: False - no such control



   .. py:method:: ShowField(ctrl, show)

      Show or hide an input field
      :returns: False - no such control



   .. py:method:: MoveField(ctrl, x, y, w, h)

      Move/resize an input field

      :returns: False - no such fiel



   .. py:method:: GetFocusedField()

      Get currently focused input field.
      :returns: None if no field is selected otherwise the control ID



   .. py:method:: SetFocusedField(ctrl)

      Set currently focused input field
      :returns: False - no such control



   .. py:method:: RefreshField(ctrl)

      Refresh a field
      :returns: False - no such control



   .. py:method:: Close(close_normally)

      Close the form
      :param close_normally: 1: form is closed normally as if the user pressed Enter. 0: form is closed abnormally as if the user pressed Esc
      :returns: None



   .. py:method:: GetControlValue(ctrl)

      Returns the control's value depending on its type
      :param ctrl: Form control instance
      :returns: color button, radio controls: integer
      :returns: file/dir input, string input and string label: string
      :returns: embedded chooser control (0-based indices of selected items): integer list
      :returns: for multilinetext control: textctrl_info_t
      :returns: dropdown list controls: string (when editable) or index (when readonly)
      :returns: None: on failure



   .. py:method:: SetControlValue(ctrl, value)

      Set the control's value depending on its type
      :param ctrl: Form control instance
      :param value: embedded chooser: a 0-base indices list to select embedded chooser items
      :param value: multilinetext: a textctrl_info_t
      :param value: dropdown list: an integer designating the selection index if readonly
                                   a string designating the edit control value if not readonly
      :returns: Boolean true on success



   .. py:method:: ControlToFieldTypeIdAndSize(ctrl)
      :staticmethod:


      Converts a control object to a tuple containing the field id
      and the associated buffer size



.. py:function:: ask_form(*args)

   Display a dialog box and wait for the user. If the form contains the "BUTTON NO <title>" keyword, then the return values are the same as in the ask_yn() function (Button IDs) 
           
   :param form: dialog box as a string. see ask_form()/open_form()
   :returns: 0: no memory to display or form syntax error (a warning is displayed in this case). the user pressed the 'No' button (if the form has it) or the user cancelled the dialog otherwise. all variables retain their original values.
   :returns: 1: ok, all input fields are filled and validated.
   :returns: -1: the form has the 'No' button and the user cancelled the dialog


.. py:function:: open_form(*args)

   Display a dockable modeless dialog box and return a handle to it. The modeless form can be closed in the following ways:
   * by pressing the small 'x' in the window title
   * by calling form_actions_t::close() from the form callback (form_actions_t)



   :param form: dialog box as a string. see ask_form()/open_form()
   :param flags: Widget open flags
   :returns: handle to the form or nullptr. the handle can be used with TWidget functions: close_widget()/activate_widget()/etc


.. py:function:: install_command_interpreter(py_obj: PyObject *) -> int

   Install command line interpreter (ui_install_cli)


.. py:function:: remove_command_interpreter(cli_idx: int) -> None

   Remove command line interpreter (ui_install_cli)


.. py:class:: cli_t

   Bases: :py:obj:`ida_idaapi.pyidc_opaque_object_t`


   cli_t wrapper class.

   This class allows you to implement your own command line interface handlers.


   .. py:method:: register(flags=0, sname=None, lname=None, hint=None)

      Registers the CLI.

      :param flags: Feature bits. No bits are defined yet, must be 0
      :param sname: Short name (displayed on the button)
      :param lname: Long name (displayed in the menu)
      :param hint:  Hint for the input line

      :returns: Boolean: True-Success, False-Failed



   .. py:method:: unregister()

      Unregisters the CLI (if it was registered)



   .. py:method:: OnExecuteLine(line)

      The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.

      This callback is mandatory.

      :param line: typed line(s)
      :returns: Boolean: True-executed line, False-ask for more lines



   .. py:method:: OnKeydown(line, x, sellen, vkey, shift)

      A keyboard key has been pressed
      This is a generic callback and the CLI is free to do whatever it wants.

      This callback is optional.

      :param line: current input line
      :param x: current x coordinate of the cursor
      :param sellen: current selection length (usually 0)
      :param vkey: virtual key code. if the key has been handled, it should be returned as zero
      :param shift: shift state

      :returns: None - Nothing was changed
      :returns: tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
      :returns: It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)



   .. py:method:: OnFindCompletions(line, x)

      The user pressed Tab. Return a list of completions

      This callback is optional.

      :param line: the current line (string)
      :param x: the index where the cursor is (int)

      :returns: None if no completion could be generated, otherwise a tuple:
          (completions : Sequence[str], hints : Sequence[str], docs: Sequence[str],
            match_start: int, match_end: int)



.. py:class:: View_Hooks(_flags: int = 0, _hkcb_flags: int = 1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: hook() -> bool


   .. py:method:: unhook() -> bool


   .. py:method:: view_activated(view: TWidget *) -> None

      A view is activated 
                
      :param view: (TWidget *)



   .. py:method:: view_deactivated(view: TWidget *) -> None

      A view is deactivated 
                
      :param view: (TWidget *)



   .. py:method:: view_keydown(view: TWidget *, key: int, state: view_event_state_t) -> None

      Key down event 
                
      :param view: (TWidget *)
      :param key: (int)
      :param state: (::view_event_state_t)



   .. py:method:: view_click(view: TWidget *, event: view_mouse_event_t) -> None

      Click event 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: view_dblclick(view: TWidget *, event: view_mouse_event_t) -> None

      Double click event 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: view_curpos(view: TWidget *) -> None

      Cursor position changed 
                
      :param view: (TWidget *)



   .. py:method:: view_created(view: TWidget *) -> None

      A view is being created. 
                
      :param view: (TWidget *)



   .. py:method:: view_close(view: TWidget *) -> None

      View closed 
                
      :param view: (TWidget *)



   .. py:method:: view_switched(view: TWidget *, rt: tcc_renderer_type_t) -> None

      A view's renderer has changed. 
                
      :param view: (TWidget *)
      :param rt: (tcc_renderer_type_t)



   .. py:method:: view_mouse_over(view: TWidget *, event: view_mouse_event_t) -> None

      The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: view_loc_changed(view: TWidget *, now: lochist_entry_t const *, was: lochist_entry_t const *) -> None

      The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
                
      :param view: (TWidget *)
      :param now: (const lochist_entry_t *)
      :param was: (const lochist_entry_t *)



   .. py:method:: view_mouse_moved(view: TWidget *, event: view_mouse_event_t) -> None

      The mouse moved on the view 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



.. py:class:: CustomIDAMemo

   Bases: :py:obj:`View_Hooks`


   .. py:method:: view_activated(view)

      A view is activated 
                
      :param view: (TWidget *)



   .. py:method:: view_deactivated(view)

      A view is deactivated 
                
      :param view: (TWidget *)



   .. py:method:: view_keydown(view, key, state)

      Key down event 
                
      :param view: (TWidget *)
      :param key: (int)
      :param state: (::view_event_state_t)



   .. py:method:: view_click(view, ve)

      Click event 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: view_dblclick(view, ve)

      Double click event 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: view_curpos(view, *args)

      Cursor position changed 
                
      :param view: (TWidget *)



   .. py:method:: view_close(view, *args)

      View closed 
                
      :param view: (TWidget *)



   .. py:method:: view_switched(view, rt)

      A view's renderer has changed. 
                
      :param view: (TWidget *)
      :param rt: (tcc_renderer_type_t)



   .. py:method:: view_mouse_over(view, ve)

      The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: view_loc_changed(view, now, was)

      The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
                
      :param view: (TWidget *)
      :param now: (const lochist_entry_t *)
      :param was: (const lochist_entry_t *)



   .. py:method:: view_mouse_moved(view, ve)

      The mouse moved on the view 
                
      :param view: (TWidget *)
      :param event: (const view_mouse_event_t *)



   .. py:method:: Refresh()

      Refreshes the view. This causes the OnRefresh() to be called



   .. py:method:: GetCurrentRendererType()


   .. py:method:: SetCurrentRendererType(rtype)

      Set the current view's renderer.

      :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.



   .. py:method:: SetNodeInfo(node_index, node_info, flags)

      Set the properties for the given node.

      Example usage (set second nodes's bg color to red):
        inst = ...
        p = idaapi.node_info_t()
        p.bg_color = 0x00ff0000
        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)

      :param node_index: The node index.
      :param node_info: An idaapi.node_info_t instance.
      :param flags: An OR'ed value of NIF_* values.



   .. py:method:: SetNodesInfos(values)

      Set the properties for the given nodes.

      Example usage (set first three nodes's bg color to purple):
        inst = ...
        p = idaapi.node_info_t()
        p.bg_color = 0x00ff00ff
        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})

      :param values: A dictionary of 'int -> node_info_t' objects.



   .. py:method:: GetNodeInfo(*args)

      Get the properties for the given node.

      :param ni: A node_info_t instance
      :param node: The index of the node.
      :returns: success



   .. py:method:: DelNodesInfos(*nodes)

      Delete the properties for the given node(s).

      :param nodes: A list of node IDs



   .. py:method:: CreateGroups(groups_infos)

      Send a request to modify the graph by creating a
      (set of) group(s), and perform an animation.

      Each object in the 'groups_infos' list must be of the format:
      {
        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
        "text" : <string>                    # The synthetic text for that group
      }

      :param groups_infos: A list of objects that describe those groups.
      :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).



   .. py:method:: DeleteGroups(groups, new_current=-1)

      Send a request to delete the specified groups in the graph,
      and perform an animation.

      :param groups: A list of group node numbers.
      :param new_current: A node to focus on after the groups have been deleted
      :returns: True on success, False otherwise.



   .. py:method:: SetGroupsVisibility(groups, expand, new_current=-1)

      Send a request to expand/collapse the specified groups in the graph,
      and perform an animation.

      :param groups: A list of group node numbers.
      :param expand: True to expand the group, False otherwise.
      :param new_current: A node to focus on after the groups have been expanded/collapsed.
      :returns: True on success, False otherwise.



   .. py:method:: GetWidget()

      Return the TWidget underlying this view.

      :returns: The TWidget underlying this view, or None.



   .. py:method:: GetWidgetAsGraphViewer()

      Return the graph_viewer_t underlying this view.

      :returns: The graph_viewer_t underlying this view, or None.



.. py:function:: pyidag_bind(_self: PyObject *) -> bool

.. py:function:: pyidag_unbind(_self: PyObject *) -> bool

.. py:class:: IDAViewWrapper(title)

   Bases: :py:obj:`CustomIDAMemo`


   Deprecated. Use View_Hooks instead.

   Because the lifecycle of an IDAView is not trivial to track (e.g., a user
   might close, then re-open the same disassembly view), this wrapper doesn't
   bring anything superior to the View_Hooks: quite the contrary, as the
   latter is much more generic (and better maps IDA's internal model.)


   .. py:method:: Bind()


   .. py:method:: Unbind()


.. py:function:: pyscv_init(py_link: PyObject *, title: str) -> PyObject *

.. py:function:: pyscv_refresh(py_this: PyObject *) -> bool

.. py:function:: pyscv_get_current_line(py_this: PyObject *, mouse: bool, notags: bool) -> PyObject *

.. py:function:: pyscv_is_focused(py_this: PyObject *) -> bool

.. py:function:: pyscv_count(py_this: PyObject *) -> size_t

.. py:function:: pyscv_show(py_this: PyObject *) -> bool

.. py:function:: pyscv_close(py_this: PyObject *) -> None

.. py:function:: pyscv_jumpto(py_this: PyObject *, ln: size_t, x: int, y: int) -> bool

.. py:function:: pyscv_get_line(py_this: PyObject *, nline: size_t) -> PyObject *

.. py:function:: pyscv_get_pos(py_this: PyObject *, mouse: bool) -> PyObject *

.. py:function:: pyscv_clear_lines(py_this: PyObject *) -> PyObject *

.. py:function:: pyscv_add_line(py_this: PyObject *, py_sl: PyObject *) -> bool

.. py:function:: pyscv_insert_line(py_this: PyObject *, nline: size_t, py_sl: PyObject *) -> bool

.. py:function:: pyscv_patch_line(py_this: PyObject *, nline: size_t, offs: size_t, value: int) -> bool

.. py:function:: pyscv_del_line(py_this: PyObject *, nline: size_t) -> bool

.. py:function:: pyscv_get_selection(py_this: PyObject *) -> PyObject *

.. py:function:: pyscv_get_current_word(py_this: PyObject *, mouse: bool) -> PyObject *

.. py:function:: pyscv_edit_line(py_this: PyObject *, nline: size_t, py_sl: PyObject *) -> bool

.. py:function:: pyscv_get_widget(py_this: PyObject *) -> TWidget *

.. py:class:: simplecustviewer_t

   Bases: :py:obj:`object`


   The base class for implementing simple custom viewers


   .. py:class:: UI_Hooks_Trampoline(v)

      Bases: :py:obj:`UI_Hooks`


      .. py:attribute:: v


      .. py:method:: populating_widget_popup(form, popup_handle)

         IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
         Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)

         :param widget: (TWidget *)
         :param popup_handle: (TPopupMenu *)
         :param ctx: (const action_activation_ctx_t *)
         :returns: void




   .. py:attribute:: ui_hooks_trampoline


   .. py:method:: OnPopup(form, popup_handle)

      Context menu popup is about to be shown. Create items dynamically if you wish
      :returns: Boolean. True if you handled the event



   .. py:method:: Create(title)

      Creates the custom view. This should be the first method called after instantiation

      :param title: The title of the view
      :returns: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
               In this case better close existing windows



   .. py:method:: Close()

      Destroys the view.
      One has to call Create() afterwards.
      Show() can be called and it will call Create() internally.
      :returns: Boolean



   .. py:method:: Show()

      Shows an already created view. It the view was closed, then it will call Create() for you
      :returns: Boolean



   .. py:method:: Refresh()


   .. py:method:: RefreshCurrent()

      Refreshes the current line only



   .. py:method:: Count()

      Returns the number of lines in the view



   .. py:method:: GetSelection()

      Returns the selected range or None
      :returns: tuple(x1, y1, x2, y2), or None if no selection



   .. py:method:: ClearLines()

      Clears all the lines



   .. py:method:: AddLine(line, fgcolor=None, bgcolor=None)

      Adds a colored line to the view
      :returns: Boolean



   .. py:method:: InsertLine(lineno, line, fgcolor=None, bgcolor=None)

      Inserts a line in the given position
      :returns: Boolean



   .. py:method:: EditLine(lineno, line, fgcolor=None, bgcolor=None)

      Edits an existing line.
      :returns: Boolean



   .. py:method:: PatchLine(lineno, offs, value)

      Patches an existing line character at the given offset. This is a low level function. You must know what you're doing



   .. py:method:: DelLine(lineno)

      Deletes an existing line
      :returns: Boolean



   .. py:method:: GetLine(lineno)

      Returns a line
      :param lineno: The line number
      :returns: a tuple (colored_line, fgcolor, bgcolor), or None



   .. py:method:: GetCurrentWord(mouse=0)

      Returns the current word
      :param mouse: Use mouse position or cursor position
      :returns: None if failed or a String containing the current word at mouse or cursor



   .. py:method:: GetCurrentLine(mouse=0, notags=0)

      Returns the current line.
      :param mouse: Current line at mouse pos
      :param notags: If True then tag_remove() will be called before returning the line
      :returns: Returns the current line (colored or uncolored) or None on failure



   .. py:method:: GetPos(mouse=0)

      Returns the current cursor or mouse position.
      :param mouse: return mouse position
      :returns: Returns a tuple (lineno, x, y)



   .. py:method:: GetLineNo(mouse=0)

      Calls GetPos() and returns the current line number or -1 on failure



   .. py:method:: Jump(lineno, x=0, y=0)


   .. py:method:: IsFocused()

      Returns True if the current view is the focused view



   .. py:method:: GetWidget()

      Return the TWidget underlying this view.

      :returns: The TWidget underlying this view, or None.



.. py:function:: plgform_new() -> PyObject *

.. py:function:: plgform_show(*args) -> bool

.. py:function:: plgform_close(py_link: PyObject *, options: int) -> None

.. py:function:: plgform_get_widget(py_link: PyObject *) -> TWidget *

.. py:class:: PluginForm

   Bases: :py:obj:`object`


   PluginForm class.

   This form can be used to host additional controls. Please check the PyQt example.


   .. py:attribute:: WOPN_MDI
      :value: 1



   .. py:attribute:: WOPN_TAB
      :value: 2



   .. py:attribute:: WOPN_RESTORE

      if the widget was the only widget in a floating area the last time it was closed, it will be restored as floating, with the same position+size as before 
              



   .. py:attribute:: WOPN_ONTOP
      :value: 8



   .. py:attribute:: WOPN_MENU
      :value: 16



   .. py:attribute:: WOPN_CENTERED
      :value: 32



   .. py:attribute:: WOPN_PERSIST

      widget will remain available when starting or stopping debugger sessions



   .. py:attribute:: WOPN_DP_LEFT

      Dock widget to the left of dest_ctrl.



   .. py:attribute:: WOPN_DP_TOP

      Dock widget above dest_ctrl.



   .. py:attribute:: WOPN_DP_RIGHT

      Dock widget to the right of dest_ctrl.



   .. py:attribute:: WOPN_DP_BOTTOM

      Dock widget below dest_ctrl.



   .. py:attribute:: WOPN_DP_INSIDE

      Create a new tab bar with both widget and dest_ctrl.



   .. py:attribute:: WOPN_DP_TAB

      Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar (otherwise the same as WOPN_DP_INSIDE) 
              



   .. py:attribute:: WOPN_DP_BEFORE

      Place widget before dst_form in the tab bar instead of after; used with WOPN_DP_INSIDE and WOPN_DP_TAB 
              



   .. py:attribute:: WOPN_DP_FLOATING

      Make widget floating.



   .. py:attribute:: WOPN_DP_SZHINT

      when floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
              



   .. py:attribute:: WOPN_DP_INSIDE_BEFORE


   .. py:attribute:: WOPN_DP_TAB_BEFORE


   .. py:attribute:: WOPN_CREATE_ONLY


   .. py:method:: Show(caption, options=0)

      Creates the form if not was not created or brings to front if it was already created

      :param caption: The form caption
      :param options: One of PluginForm.WOPN_ constants



   .. py:attribute:: VALID_CAPSULE_NAME
      :value: b'$valid$'



   .. py:method:: TWidgetToQtPythonWidget(tw, ctx=sys.modules['__main__'])
      :staticmethod:


      Convert a TWidget* to a QWidget to be used by the Qt Python bindings



   .. py:attribute:: TWidgetToPyQtWidget


   .. py:attribute:: FormToPyQtWidget


   .. py:method:: QtWidgetToTWidget(w, ctx=sys.modules['__main__'])
      :staticmethod:


      Convert a QWidget to a TWidget* to be used by IDA

      :param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules



   .. py:method:: TWidgetToPySideWidget(tw, ctx=sys.modules['__main__'])
      :staticmethod:


      Use this method to convert a TWidget* to a QWidget to be used by PySide

      :param ctx: Context. Reference to a module that already imported QtWidgets module



   .. py:attribute:: FormToPySideWidget


   .. py:method:: OnCreate(form)

      This event is called when the plugin form is created.
      The programmer should populate the form when this event is triggered.

      :returns: None



   .. py:method:: OnClose(form)

      Called when the plugin form is closed

      :returns: None



   .. py:method:: Close(options)

      Closes the form.

      :param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)

      :returns: None



   .. py:method:: GetWidget()

      Return the TWidget underlying this view.

      :returns: The TWidget underlying this view, or None.



   .. py:attribute:: WCLS_SAVE

      save state in desktop config



   .. py:attribute:: WCLS_NO_CONTEXT

      don't change the current context (useful for toolbars)



   .. py:attribute:: WCLS_DONT_SAVE_SIZE

      don't save size of the window



   .. py:attribute:: WCLS_DELETE_LATER

      assign the deletion of the widget to the UI loop ///<



   .. py:attribute:: WCLS_CLOSE_LATER


.. py:data:: place_t_as_idaplace_t

.. py:data:: place_t_as_simpleline_place_t

.. py:data:: place_t_as_tiplace_t


```

`skills/idapython/docs/ida_libfuncs.md`:

```md
# ida_libfuncs

FLIRT signature library metadata and access.

## Key Functions

- `get_idasgn_header_by_short_name(out_header, name)` - get signature header by short name
- `get_idasgn_path_by_short_name(name)` - get full path to signature file

## idasgn_header_t

Signature file header structure
- `processor_id` - target processor
- `file_formats` - supported file formats
- `ostype` - OS type (OSTYPE_MSDOS, OSTYPE_WIN, OSTYPE_UNIX, etc.)
- `apptype` - application type (APPT_CONSOLE, APPT_GRAPHIC, APPT_LIBRARY, APPT_DRIVER, etc.)
- `libname_length` - library name length
- `number_of_modules` - module count
- `ctype_name` - compiler type name

## Constants

### OS Types
OSTYPE_MSDOS, OSTYPE_WIN, OSTYPE_OS2, OSTYPE_NETW, OSTYPE_UNIX, OSTYPE_OTHER

### Application Types
- APPT_CONSOLE, APPT_GRAPHIC, APPT_PROGRAM, APPT_LIBRARY, APPT_DRIVER
- APPT_1THREAD, APPT_MTHREAD
- APPT_16BIT, APPT_32BIT, APPT_64BIT

## See Also
Full docs: skill/docs/ida_libfuncs.rst

```

`skills/idapython/docs/ida_libfuncs.rst`:

```rst
ida_libfuncs
============

.. py:module:: ida_libfuncs


Attributes
----------

.. autoapisummary::

   ida_libfuncs.SIGN_HEADER_MAGIC
   ida_libfuncs.SIGN_HEADER_VERSION
   ida_libfuncs.OSTYPE_MSDOS
   ida_libfuncs.OSTYPE_WIN
   ida_libfuncs.OSTYPE_OS2
   ida_libfuncs.OSTYPE_NETW
   ida_libfuncs.OSTYPE_UNIX
   ida_libfuncs.OSTYPE_OTHER
   ida_libfuncs.APPT_CONSOLE
   ida_libfuncs.APPT_GRAPHIC
   ida_libfuncs.APPT_PROGRAM
   ida_libfuncs.APPT_LIBRARY
   ida_libfuncs.APPT_DRIVER
   ida_libfuncs.APPT_1THREAD
   ida_libfuncs.APPT_MTHREAD
   ida_libfuncs.APPT_16BIT
   ida_libfuncs.APPT_32BIT
   ida_libfuncs.APPT_64BIT
   ida_libfuncs.LS_STARTUP
   ida_libfuncs.LS_CTYPE
   ida_libfuncs.LS_CTYPE2
   ida_libfuncs.LS_CTYPE_ALT
   ida_libfuncs.LS_ZIP
   ida_libfuncs.LS_CTYPE_3V


Classes
-------

.. autoapisummary::

   ida_libfuncs.idasgn_header_t


Functions
---------

.. autoapisummary::

   ida_libfuncs.get_idasgn_header_by_short_name
   ida_libfuncs.get_idasgn_path_by_short_name


Module Contents
---------------

.. py:class:: idasgn_header_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: magic
      :type:  char [6]


   .. py:attribute:: version
      :type:  uchar


   .. py:attribute:: processor_id
      :type:  uchar


   .. py:attribute:: file_formats
      :type:  int


   .. py:attribute:: ostype
      :type:  uint16


   .. py:attribute:: apptype
      :type:  uint16


   .. py:attribute:: flags
      :type:  uint16


   .. py:attribute:: number_of_modules_v5
      :type:  uint16


   .. py:attribute:: ctype_crc
      :type:  uint16


   .. py:attribute:: ctype_name
      :type:  char [12]


   .. py:attribute:: libname_length
      :type:  uchar


   .. py:attribute:: ctype_crc_alt
      :type:  uint16


   .. py:attribute:: number_of_modules
      :type:  int


   .. py:attribute:: pattern_length
      :type:  uint16


   .. py:attribute:: ctype_crc_3v
      :type:  uint16


.. py:data:: SIGN_HEADER_MAGIC

.. py:data:: SIGN_HEADER_VERSION

.. py:data:: OSTYPE_MSDOS

.. py:data:: OSTYPE_WIN

.. py:data:: OSTYPE_OS2

.. py:data:: OSTYPE_NETW

.. py:data:: OSTYPE_UNIX

.. py:data:: OSTYPE_OTHER

.. py:data:: APPT_CONSOLE

.. py:data:: APPT_GRAPHIC

.. py:data:: APPT_PROGRAM

.. py:data:: APPT_LIBRARY

.. py:data:: APPT_DRIVER

.. py:data:: APPT_1THREAD

.. py:data:: APPT_MTHREAD

.. py:data:: APPT_16BIT

.. py:data:: APPT_32BIT

.. py:data:: APPT_64BIT

.. py:data:: LS_STARTUP

.. py:data:: LS_CTYPE

.. py:data:: LS_CTYPE2

.. py:data:: LS_CTYPE_ALT

.. py:data:: LS_ZIP

.. py:data:: LS_CTYPE_3V

.. py:function:: get_idasgn_header_by_short_name(out_header: idasgn_header_t, name: str) -> str

   Get idasgn header by a short signature name. 
           
   :param out_header: buffer for the signature file header
   :param name: short name of a signature
   :returns: true in case of success


.. py:function:: get_idasgn_path_by_short_name(name: str) -> str

   Get idasgn full path by a short signature name. 
           
   :param name: short name of a signature
   :returns: true in case of success



```

`skills/idapython/docs/ida_lines.md`:

```md
# ida_lines

Line rendering and text generation for disassembly output.

## Key Functions

### Line Generation
- `generate_disasm_line(ea, flags)` - generate disassembly line at ea
- `generate_many_lines(ea, flags)` - generate multiple lines (includes function header, etc.)
- `tag_remove(tagged_line)` - remove color tags from line
- `tag_skipcode(p)` - skip color tag at position
- `tag_advance(p, cnt)` - advance by cnt printable characters

### Color Tags
- `SCOLOR_*` constants - color tag markers (instructions, registers, comments, etc.)
- Lines contain embedded color codes (e.g., `\x01` for instruction color)

### Line Prefix/Suffix
- `gl_comm` / `set_gl_comm(start, end)` - comment delimiters
- `inf_get_indent()` - get indentation amount

## Common Use Cases

Generate colored disassembly:
```python
line = ida_lines.generate_disasm_line(ea, 0)
plain = ida_lines.tag_remove(line)
```

## Low Priority

This module is mostly for display formatting. Core analysis uses ida_ua (instruction decoding) and ida_bytes (data access) instead.

## See Also
Full docs: skill/docs/ida_lines.rst

```

`skills/idapython/docs/ida_lines.rst`:

```rst
ida_lines
=========

.. py:module:: ida_lines

.. autoapi-nested-parse::

   High level functions that deal with the generation of the disassembled text lines.

   This file also contains definitions for the syntax highlighting.
   Finally there are functions that deal with anterior/posterior user-defined lines. 
       



Attributes
----------

.. autoapisummary::

   ida_lines.COLOR_ON
   ida_lines.COLOR_OFF
   ida_lines.COLOR_ESC
   ida_lines.COLOR_INV
   ida_lines.SCOLOR_ON
   ida_lines.SCOLOR_OFF
   ida_lines.SCOLOR_ESC
   ida_lines.SCOLOR_INV
   ida_lines.SCOLOR_DEFAULT
   ida_lines.SCOLOR_REGCMT
   ida_lines.SCOLOR_RPTCMT
   ida_lines.SCOLOR_AUTOCMT
   ida_lines.SCOLOR_INSN
   ida_lines.SCOLOR_DATNAME
   ida_lines.SCOLOR_DNAME
   ida_lines.SCOLOR_DEMNAME
   ida_lines.SCOLOR_SYMBOL
   ida_lines.SCOLOR_CHAR
   ida_lines.SCOLOR_STRING
   ida_lines.SCOLOR_NUMBER
   ida_lines.SCOLOR_VOIDOP
   ida_lines.SCOLOR_CREF
   ida_lines.SCOLOR_DREF
   ida_lines.SCOLOR_CREFTAIL
   ida_lines.SCOLOR_DREFTAIL
   ida_lines.SCOLOR_ERROR
   ida_lines.SCOLOR_PREFIX
   ida_lines.SCOLOR_BINPREF
   ida_lines.SCOLOR_EXTRA
   ida_lines.SCOLOR_ALTOP
   ida_lines.SCOLOR_HIDNAME
   ida_lines.SCOLOR_LIBNAME
   ida_lines.SCOLOR_LOCNAME
   ida_lines.SCOLOR_CODNAME
   ida_lines.SCOLOR_ASMDIR
   ida_lines.SCOLOR_MACRO
   ida_lines.SCOLOR_DSTR
   ida_lines.SCOLOR_DCHAR
   ida_lines.SCOLOR_DNUM
   ida_lines.SCOLOR_KEYWORD
   ida_lines.SCOLOR_REG
   ida_lines.SCOLOR_IMPNAME
   ida_lines.SCOLOR_SEGNAME
   ida_lines.SCOLOR_UNKNAME
   ida_lines.SCOLOR_CNAME
   ida_lines.SCOLOR_UNAME
   ida_lines.SCOLOR_COLLAPSED
   ida_lines.SCOLOR_ADDR
   ida_lines.COLOR_SELECTED
   ida_lines.COLOR_LIBFUNC
   ida_lines.COLOR_REGFUNC
   ida_lines.COLOR_CODE
   ida_lines.COLOR_DATA
   ida_lines.COLOR_UNKNOWN
   ida_lines.COLOR_EXTERN
   ida_lines.COLOR_CURITEM
   ida_lines.COLOR_CURLINE
   ida_lines.COLOR_HIDLINE
   ida_lines.COLOR_LUMFUNC
   ida_lines.COLOR_BG_MAX
   ida_lines.cvar
   ida_lines.COLOR_DEFAULT
   ida_lines.COLOR_REGCMT
   ida_lines.COLOR_RPTCMT
   ida_lines.COLOR_AUTOCMT
   ida_lines.COLOR_INSN
   ida_lines.COLOR_DATNAME
   ida_lines.COLOR_DNAME
   ida_lines.COLOR_DEMNAME
   ida_lines.COLOR_SYMBOL
   ida_lines.COLOR_CHAR
   ida_lines.COLOR_STRING
   ida_lines.COLOR_NUMBER
   ida_lines.COLOR_VOIDOP
   ida_lines.COLOR_CREF
   ida_lines.COLOR_DREF
   ida_lines.COLOR_CREFTAIL
   ida_lines.COLOR_DREFTAIL
   ida_lines.COLOR_ERROR
   ida_lines.COLOR_PREFIX
   ida_lines.COLOR_BINPREF
   ida_lines.COLOR_EXTRA
   ida_lines.COLOR_ALTOP
   ida_lines.COLOR_HIDNAME
   ida_lines.COLOR_LIBNAME
   ida_lines.COLOR_LOCNAME
   ida_lines.COLOR_CODNAME
   ida_lines.COLOR_ASMDIR
   ida_lines.COLOR_MACRO
   ida_lines.COLOR_DSTR
   ida_lines.COLOR_DCHAR
   ida_lines.COLOR_DNUM
   ida_lines.COLOR_KEYWORD
   ida_lines.COLOR_REG
   ida_lines.COLOR_IMPNAME
   ida_lines.COLOR_SEGNAME
   ida_lines.COLOR_UNKNAME
   ida_lines.COLOR_CNAME
   ida_lines.COLOR_UNAME
   ida_lines.COLOR_COLLAPSED
   ida_lines.COLOR_FG_MAX
   ida_lines.COLOR_ADDR
   ida_lines.COLOR_OPND1
   ida_lines.COLOR_OPND2
   ida_lines.COLOR_OPND3
   ida_lines.COLOR_OPND4
   ida_lines.COLOR_OPND5
   ida_lines.COLOR_OPND6
   ida_lines.COLOR_OPND7
   ida_lines.COLOR_OPND8
   ida_lines.COLOR_RESERVED1
   ida_lines.COLOR_LUMINA
   ida_lines.VEL_POST
   ida_lines.VEL_CMT
   ida_lines.GDISMF_AS_STACK
   ida_lines.GDISMF_ADDR_TAG
   ida_lines.GDISMF_REMOVE_TAGS
   ida_lines.GDISMF_UNHIDE
   ida_lines.GENDSM_FORCE_CODE
   ida_lines.GENDSM_MULTI_LINE
   ida_lines.GENDSM_REMOVE_TAGS
   ida_lines.GENDSM_UNHIDE
   ida_lines.COLOR_ADDR_SIZE
   ida_lines.SCOLOR_FG_MAX
   ida_lines.cvar
   ida_lines.SCOLOR_OPND1
   ida_lines.SCOLOR_OPND2
   ida_lines.SCOLOR_OPND3
   ida_lines.SCOLOR_OPND4
   ida_lines.SCOLOR_OPND5
   ida_lines.SCOLOR_OPND6
   ida_lines.SCOLOR_UTF8
   ida_lines.PALETTE_SIZE
   ida_lines.E_PREV
   ida_lines.E_NEXT


Classes
-------

.. autoapisummary::

   ida_lines.user_defined_prefix_t


Functions
---------

.. autoapisummary::

   ida_lines.tag_strlen
   ida_lines.calc_prefix_color
   ida_lines.calc_bg_color
   ida_lines.add_sourcefile
   ida_lines.get_sourcefile
   ida_lines.del_sourcefile
   ida_lines.install_user_defined_prefix
   ida_lines.add_extra_line
   ida_lines.add_extra_cmt
   ida_lines.add_pgm_cmt
   ida_lines.generate_disasm_line
   ida_lines.get_first_free_extra_cmtidx
   ida_lines.update_extra_cmt
   ida_lines.del_extra_cmt
   ida_lines.get_extra_cmt
   ida_lines.delete_extra_cmts
   ida_lines.create_encoding_helper
   ida_lines.tag_remove
   ida_lines.tag_addr
   ida_lines.tag_skipcode
   ida_lines.tag_skipcodes
   ida_lines.tag_advance
   ida_lines.generate_disassembly
   ida_lines.requires_color_esc
   ida_lines.COLSTR


Module Contents
---------------

.. py:data:: COLOR_ON

   Escape character (ON). Followed by a color code (color_t). 
           


.. py:data:: COLOR_OFF

   Escape character (OFF). Followed by a color code (color_t). 
           


.. py:data:: COLOR_ESC

   Escape character (Quote next character). This is needed to output '\1' and '\2' characters. 
           


.. py:data:: COLOR_INV

   Escape character (Inverse foreground and background colors). This escape character has no corresponding COLOR_OFF. Its action continues until the next COLOR_INV or end of line. 
           


.. py:data:: SCOLOR_ON

   Escape character (ON)


.. py:data:: SCOLOR_OFF

   Escape character (OFF)


.. py:data:: SCOLOR_ESC

   Escape character (Quote next character)


.. py:data:: SCOLOR_INV

   Escape character (Inverse colors)


.. py:data:: SCOLOR_DEFAULT

   Default.


.. py:data:: SCOLOR_REGCMT

   Regular comment.


.. py:data:: SCOLOR_RPTCMT

   Repeatable comment (defined not here)


.. py:data:: SCOLOR_AUTOCMT

   Automatic comment.


.. py:data:: SCOLOR_INSN

   Instruction.


.. py:data:: SCOLOR_DATNAME

   Dummy Data Name.


.. py:data:: SCOLOR_DNAME

   Regular Data Name.


.. py:data:: SCOLOR_DEMNAME

   Demangled Name.


.. py:data:: SCOLOR_SYMBOL

   Punctuation.


.. py:data:: SCOLOR_CHAR

   Char constant in instruction.


.. py:data:: SCOLOR_STRING

   String constant in instruction.


.. py:data:: SCOLOR_NUMBER

   Numeric constant in instruction.


.. py:data:: SCOLOR_VOIDOP

   Void operand.


.. py:data:: SCOLOR_CREF

   Code reference.


.. py:data:: SCOLOR_DREF

   Data reference.


.. py:data:: SCOLOR_CREFTAIL

   Code reference to tail byte.


.. py:data:: SCOLOR_DREFTAIL

   Data reference to tail byte.


.. py:data:: SCOLOR_ERROR

   Error or problem.


.. py:data:: SCOLOR_PREFIX

   Line prefix.


.. py:data:: SCOLOR_BINPREF

   Binary line prefix bytes.


.. py:data:: SCOLOR_EXTRA

   Extra line.


.. py:data:: SCOLOR_ALTOP

   Alternative operand.


.. py:data:: SCOLOR_HIDNAME

   Hidden name.


.. py:data:: SCOLOR_LIBNAME

   Library function name.


.. py:data:: SCOLOR_LOCNAME

   Local variable name.


.. py:data:: SCOLOR_CODNAME

   Dummy code name.


.. py:data:: SCOLOR_ASMDIR

   Assembler directive.


.. py:data:: SCOLOR_MACRO

   Macro.


.. py:data:: SCOLOR_DSTR

   String constant in data directive.


.. py:data:: SCOLOR_DCHAR

   Char constant in data directive.


.. py:data:: SCOLOR_DNUM

   Numeric constant in data directive.


.. py:data:: SCOLOR_KEYWORD

   Keywords.


.. py:data:: SCOLOR_REG

   Register name.


.. py:data:: SCOLOR_IMPNAME

   Imported name.


.. py:data:: SCOLOR_SEGNAME

   Segment name.


.. py:data:: SCOLOR_UNKNAME

   Dummy unknown name.


.. py:data:: SCOLOR_CNAME

   Regular code name.


.. py:data:: SCOLOR_UNAME

   Regular unknown name.


.. py:data:: SCOLOR_COLLAPSED

   Collapsed line.


.. py:data:: SCOLOR_ADDR

   Hidden address mark.


.. py:data:: COLOR_SELECTED

   Selected.


.. py:data:: COLOR_LIBFUNC

   Library function.


.. py:data:: COLOR_REGFUNC

   Regular function.


.. py:data:: COLOR_CODE

   Single instruction.


.. py:data:: COLOR_DATA

   Data bytes.


.. py:data:: COLOR_UNKNOWN

   Unexplored byte.


.. py:data:: COLOR_EXTERN

   External name definition segment.


.. py:data:: COLOR_CURITEM

   Current item.


.. py:data:: COLOR_CURLINE

   Current line.


.. py:data:: COLOR_HIDLINE

   Hidden line.


.. py:data:: COLOR_LUMFUNC

   Lumina function.


.. py:data:: COLOR_BG_MAX

   Max color number.


.. py:function:: tag_strlen(line: str) -> ssize_t

   Calculate length of a colored string This function computes the length in unicode codepoints of a line 
           
   :returns: the number of codepoints in the line, or -1 on error


.. py:function:: calc_prefix_color(ea: ida_idaapi.ea_t) -> color_t

   Get prefix color for line at 'ea' 
           
   :returns: Line prefix colors


.. py:function:: calc_bg_color(ea: ida_idaapi.ea_t) -> bgcolor_t

   Get background color for line at 'ea' 
           
   :returns: RGB color


.. py:function:: add_sourcefile(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, filename: str) -> bool

.. py:function:: get_sourcefile(ea: ida_idaapi.ea_t, bounds: range_t = None) -> str

.. py:function:: del_sourcefile(ea: ida_idaapi.ea_t) -> bool

.. py:function:: install_user_defined_prefix(*args) -> bool

.. py:class:: user_defined_prefix_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: get_user_defined_prefix(ea: ida_idaapi.ea_t, insn: insn_t const &, lnnum: int, indent: int, line: str) -> None

      This callback must be overridden by the derived class. 
              
      :param ea: the current address
      :param insn: the current instruction. if the current item is not an instruction, then insn.itype is zero.
      :param lnnum: number of the current line (each address may have several listing lines for it). 0 means the very first line for the current address.
      :param indent: see explanations for gen_printf()
      :param line: the line to be generated. the line usually contains color tags. this argument can be examined to decide whether to generate the prefix.



.. py:data:: cvar

.. py:data:: COLOR_DEFAULT

   Default.


.. py:data:: COLOR_REGCMT

   Regular comment.


.. py:data:: COLOR_RPTCMT

   Repeatable comment (comment defined somewhere else)


.. py:data:: COLOR_AUTOCMT

   Automatic comment.


.. py:data:: COLOR_INSN

   Instruction.


.. py:data:: COLOR_DATNAME

   Dummy Data Name.


.. py:data:: COLOR_DNAME

   Regular Data Name.


.. py:data:: COLOR_DEMNAME

   Demangled Name.


.. py:data:: COLOR_SYMBOL

   Punctuation.


.. py:data:: COLOR_CHAR

   Char constant in instruction.


.. py:data:: COLOR_STRING

   String constant in instruction.


.. py:data:: COLOR_NUMBER

   Numeric constant in instruction.


.. py:data:: COLOR_VOIDOP

   Void operand.


.. py:data:: COLOR_CREF

   Code reference.


.. py:data:: COLOR_DREF

   Data reference.


.. py:data:: COLOR_CREFTAIL

   Code reference to tail byte.


.. py:data:: COLOR_DREFTAIL

   Data reference to tail byte.


.. py:data:: COLOR_ERROR

   Error or problem.


.. py:data:: COLOR_PREFIX

   Line prefix.


.. py:data:: COLOR_BINPREF

   Binary line prefix bytes.


.. py:data:: COLOR_EXTRA

   Extra line.


.. py:data:: COLOR_ALTOP

   Alternative operand.


.. py:data:: COLOR_HIDNAME

   Hidden name.


.. py:data:: COLOR_LIBNAME

   Library function name.


.. py:data:: COLOR_LOCNAME

   Local variable name.


.. py:data:: COLOR_CODNAME

   Dummy code name.


.. py:data:: COLOR_ASMDIR

   Assembler directive.


.. py:data:: COLOR_MACRO

   Macro.


.. py:data:: COLOR_DSTR

   String constant in data directive.


.. py:data:: COLOR_DCHAR

   Char constant in data directive.


.. py:data:: COLOR_DNUM

   Numeric constant in data directive.


.. py:data:: COLOR_KEYWORD

   Keywords.


.. py:data:: COLOR_REG

   Register name.


.. py:data:: COLOR_IMPNAME

   Imported name.


.. py:data:: COLOR_SEGNAME

   Segment name.


.. py:data:: COLOR_UNKNAME

   Dummy unknown name.


.. py:data:: COLOR_CNAME

   Regular code name.


.. py:data:: COLOR_UNAME

   Regular unknown name.


.. py:data:: COLOR_COLLAPSED

   Collapsed line.


.. py:data:: COLOR_FG_MAX

   Max color number.


.. py:data:: COLOR_ADDR

   Hidden address marks. the address is represented as 16-digit hex number: 01234567ABCDEF00. it doesn't have the COLOR_OFF pair. 
           


.. py:data:: COLOR_OPND1

   Instruction operand 1.


.. py:data:: COLOR_OPND2

   Instruction operand 2.


.. py:data:: COLOR_OPND3

   Instruction operand 3.


.. py:data:: COLOR_OPND4

   Instruction operand 4.


.. py:data:: COLOR_OPND5

   Instruction operand 5.


.. py:data:: COLOR_OPND6

   Instruction operand 6.


.. py:data:: COLOR_OPND7

   Instruction operand 7.


.. py:data:: COLOR_OPND8

   Instruction operand 8.


.. py:data:: COLOR_RESERVED1

   This tag is reserved for internal IDA use.


.. py:data:: COLOR_LUMINA

   Lumina-related, only for the navigation band.


.. py:data:: VEL_POST

   append posterior line


.. py:data:: VEL_CMT

   append comment line


.. py:function:: add_extra_line(*args) -> bool

.. py:function:: add_extra_cmt(*args) -> bool

.. py:function:: add_pgm_cmt(*args) -> bool

.. py:data:: GDISMF_AS_STACK

.. py:data:: GDISMF_ADDR_TAG

.. py:data:: GDISMF_REMOVE_TAGS

.. py:data:: GDISMF_UNHIDE

.. py:function:: generate_disasm_line(ea: ida_idaapi.ea_t, flags: int = 0) -> str

.. py:data:: GENDSM_FORCE_CODE

.. py:data:: GENDSM_MULTI_LINE

.. py:data:: GENDSM_REMOVE_TAGS

.. py:data:: GENDSM_UNHIDE

.. py:function:: get_first_free_extra_cmtidx(ea: ida_idaapi.ea_t, start: int) -> int

.. py:function:: update_extra_cmt(ea: ida_idaapi.ea_t, what: int, str: update_extra_cmt.str) -> bool

.. py:function:: del_extra_cmt(ea: ida_idaapi.ea_t, what: int) -> bool

.. py:function:: get_extra_cmt(ea: ida_idaapi.ea_t, what: int) -> int

.. py:function:: delete_extra_cmts(ea: ida_idaapi.ea_t, what: int) -> None

.. py:function:: create_encoding_helper(*args) -> encoder_t *

.. py:function:: tag_remove(nonnul_instr: str) -> str

   Remove color escape sequences from a string. 
           
   :returns: length of resulting string, -1 if error


.. py:function:: tag_addr(ea: ida_idaapi.ea_t) -> str

   Insert an address mark into a string. 
           
   :param ea: address to include


.. py:function:: tag_skipcode(line: str) -> int

   Skip one color code. This function should be used if you are interested in color codes and want to analyze all of them. Otherwise tag_skipcodes() function is better since it will skip all colors at once. This function will skip the current color code if there is one. If the current symbol is not a color code, it will return the input. 
           
   :returns: moved pointer


.. py:function:: tag_skipcodes(line: str) -> int

   Move the pointer past all color codes. 
           
   :param line: can't be nullptr
   :returns: moved pointer, can't be nullptr


.. py:function:: tag_advance(line: str, cnt: int) -> int

   Move pointer to a 'line' to 'cnt' positions right. Take into account escape sequences. 
           
   :param line: pointer to string
   :param cnt: number of positions to move right
   :returns: moved pointer


.. py:function:: generate_disassembly(ea, max_lines, as_stack, notag, include_hidden: Boolean = False)

   Generate disassembly lines (many lines) and put them into a buffer

   :param ea: address to generate disassembly for
   :param max_lines: how many lines max to generate
   :param as_stack: Display undefined items as 2/4/8 bytes
   :param notag: remove color tags
   :param include_hidden: automatically unhide hidden objects
   :returns: tuple(most_important_line_number, list(lines)) : Returns a tuple containing
             the most important line number and a list of generated lines
   :returns: None on failure


.. py:data:: COLOR_ADDR_SIZE
   :value: 16


   Size of a tagged address (see COLOR_ADDR)


.. py:data:: SCOLOR_FG_MAX
   :value: '('


.. py:data:: cvar

.. py:data:: SCOLOR_OPND1

.. py:data:: SCOLOR_OPND2

.. py:data:: SCOLOR_OPND3

.. py:data:: SCOLOR_OPND4

.. py:data:: SCOLOR_OPND5

.. py:data:: SCOLOR_OPND6

.. py:data:: SCOLOR_UTF8

.. py:data:: PALETTE_SIZE

.. py:function:: requires_color_esc(c)

   Is the given char a color escape character?


.. py:function:: COLSTR(str, tag)

   Utility function to create a colored line
   :param str: The string
   :param tag: Color tag constant. One of SCOLOR_XXXX


.. py:data:: E_PREV

.. py:data:: E_NEXT


```

`skills/idapython/docs/ida_loader.md`:

```md
# ida_loader

Loader and file operations - loading binaries, database management, file I/O, and plugin loading.

## Key Functions

### Database Operations
- `save_database(outfile=None, flags=-1, root=None, attr=None)` - Save database with optional new filename
- `flush_buffers()` - Flush buffers to disk
- `is_trusted_idb()` - Check if database is trusted
- `get_path(pt)` / `set_path(pt, path)` - Get/set file paths (PATH_TYPE_CMD, PATH_TYPE_IDB, PATH_TYPE_ID0)

### File Loading
- `load_binary_file(filename, li, neflags, fileoff, basepara, binoff, nbytes)` - Load binary into database
- `file2base(li, pos, ea1, ea2, patchable)` - Load file portion into address range
- `mem2base(mem, ea, fpos)` - Load from memory buffer
- `reload_file(file, is_remote)` - Reload input file bytes without losing analysis
- `base2file(fp, pos, ea1, ea2)` - Unload database to binary file

### File Type Detection
- `get_basic_file_type(li)` - Recognize file type (libraries, zip, etc.)
- `get_file_type_name()` - Get current file type name (from idainfo.filetype)

### Output Generation
- `gen_file(otype, fp, ea1, ea2, flags)` - Generate output files (MAP, EXE, IDC, LST, ASM, DIF)
- `gen_exe_file(fp)` - Generate executable file from database

### File/Memory Mapping
- `get_fileregion_offset(ea)` - Get file offset for linear address (returns -1 if unmapped)
- `get_fileregion_ea(offset)` - Get linear address for file offset (returns BADADDR if not found)

### Plugin Management
- `load_plugin(name)` - Load plugin by name or path
- `run_plugin(plg, arg)` - Run loaded plugin with argument
- `load_and_run_plugin(name, arg)` - Load and run plugin in one call
- `find_plugin(name, load_if_needed=False)` - Find plugin, optionally loading it
- `get_plugin_options(plugin)` - Get -Oplugin:options from command line

### Import/IDS
- `set_import_ordinal(modnode, ea, ord)` - Set ordinal import entry info
- `set_import_name(modnode, ea, name)` - Set named import entry info
- `load_ids_module(fname)` - Load and apply IDS file

### Archives
- `process_archive(temp_file, li, module_name, neflags, defmember, loader)` - Process archive file
- `extract_module_from_archive(fname, is_remote=False)` - Extract module from archive interactively

### Snapshots
- `build_snapshot_tree(root)` - Build snapshot tree structure

## Key Classes

### snapshot_t
Database snapshot representation.
- `id` - Snapshot ID (qtime64_t timestamp)
- `flags` - Snapshot flags (SSF_AUTOMATIC, etc.)
- `desc` - Description string (max 128 chars)
- `filename` - Snapshot filename
- `children` - Child snapshots

### plugin_info_t
Plugin metadata.
- `path` - Full plugin path
- `name` - Short name (appears in menu)
- `hotkey` - Current hotkey
- `flags` - Plugin flags
- `comment` - Plugin comment

### loader_t
Loader module interface (low-priority: advanced loader development only).

### idp_desc_t / idp_name_t
Processor module metadata (low-priority: processor module development).

## Key Flags

### Load Flags (NEF_*)
- `NEF_FIRST` - First file loaded into database
- `NEF_SEGS` - Create segments
- `NEF_CODE` - Load as code segment
- `NEF_RELOAD` - Reload at same place (don't recreate segments/fixups)
- `NEF_FLAT` - Autocreate FLAT group (PE)

### Database Flags (DBFL_*)
- `DBFL_KILL` - Delete unpacked database
- `DBFL_COMP` - Collect garbage
- `DBFL_BAK` - Create backup file
- `DBFL_TEMP` - Temporary database

### Output File Types (OFILE_*)
- `OFILE_MAP` - MAP file
- `OFILE_EXE` - Executable
- `OFILE_IDC` - IDC script
- `OFILE_LST` - Disassembly listing
- `OFILE_ASM` - Assembly
- `OFILE_DIF` - Difference

## See Also
Full docs: skill/docs/ida_loader.rst

```

`skills/idapython/docs/ida_loader.rst`:

```rst
ida_loader
==========

.. py:module:: ida_loader

.. autoapi-nested-parse::

   Definitions of IDP, LDR, PLUGIN module interfaces.

   This file also contains:

   * functions to load files into the database
   * functions to generate output files
   * high level functions to work with the database (open, save, close)


   The LDR interface consists of one structure: loader_t

   The IDP interface consists of one structure: processor_t

   The PLUGIN interface consists of one structure: plugin_t

   Modules can't use standard FILE* functions. They must use functions from <fpro.h>

   Modules can't use standard memory allocation functions. They must use functions 
   from <pro.h>

   The exported entry #1 in the module should point to the the appropriate 
   structure. (loader_t for LDR module, for example)

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For database operations, see :mod:`ida_domain.database`.



Attributes
----------

.. autoapisummary::

   ida_loader.LDRF_RELOAD
   ida_loader.LDRF_REQ_PROC
   ida_loader.ACCEPT_ARCHIVE
   ida_loader.ACCEPT_CONTINUE
   ida_loader.ACCEPT_FIRST
   ida_loader.NEF_SEGS
   ida_loader.NEF_RSCS
   ida_loader.NEF_NAME
   ida_loader.NEF_MAN
   ida_loader.NEF_FILL
   ida_loader.NEF_IMPS
   ida_loader.NEF_FIRST
   ida_loader.NEF_CODE
   ida_loader.NEF_RELOAD
   ida_loader.NEF_FLAT
   ida_loader.NEF_MINI
   ida_loader.NEF_LOPT
   ida_loader.NEF_LALL
   ida_loader.DLLEXT
   ida_loader.LOADER_DLL
   ida_loader.OFILE_MAP
   ida_loader.OFILE_EXE
   ida_loader.OFILE_IDC
   ida_loader.OFILE_LST
   ida_loader.OFILE_ASM
   ida_loader.OFILE_DIF
   ida_loader.GENFLG_MAPSEG
   ida_loader.GENFLG_MAPNAME
   ida_loader.GENFLG_MAPDMNG
   ida_loader.GENFLG_MAPLOC
   ida_loader.GENFLG_IDCTYPE
   ida_loader.GENFLG_ASMTYPE
   ida_loader.GENFLG_GENHTML
   ida_loader.GENFLG_ASMINC
   ida_loader.FILEREG_PATCHABLE
   ida_loader.FILEREG_NOTPATCHABLE
   ida_loader.PLUGIN_DLL
   ida_loader.MODULE_ENTRY_LOADER
   ida_loader.MODULE_ENTRY_PLUGIN
   ida_loader.MODULE_ENTRY_IDP
   ida_loader.IDP_DLL
   ida_loader.MAX_DATABASE_DESCRIPTION
   ida_loader.SSF_AUTOMATIC
   ida_loader.SSUF_DESC
   ida_loader.SSUF_PATH
   ida_loader.SSUF_FLAGS
   ida_loader.DBFL_KILL
   ida_loader.DBFL_COMP
   ida_loader.DBFL_BAK
   ida_loader.DBFL_TEMP
   ida_loader.PATH_TYPE_CMD
   ida_loader.PATH_TYPE_IDB
   ida_loader.PATH_TYPE_ID0


Classes
-------

.. autoapisummary::

   ida_loader.qvector_snapshotvec_t
   ida_loader.loader_t
   ida_loader.idp_name_t
   ida_loader.idp_desc_t
   ida_loader.plugin_info_t
   ida_loader.snapshot_t


Functions
---------

.. autoapisummary::

   ida_loader.load_binary_file
   ida_loader.process_archive
   ida_loader.gen_file
   ida_loader.file2base
   ida_loader.base2file
   ida_loader.get_basic_file_type
   ida_loader.get_file_type_name
   ida_loader.set_import_ordinal
   ida_loader.set_import_name
   ida_loader.load_ids_module
   ida_loader.get_plugin_options
   ida_loader.find_plugin
   ida_loader.get_fileregion_offset
   ida_loader.get_fileregion_ea
   ida_loader.gen_exe_file
   ida_loader.reload_file
   ida_loader.build_snapshot_tree
   ida_loader.flush_buffers
   ida_loader.is_trusted_idb
   ida_loader.save_database
   ida_loader.is_database_flag
   ida_loader.set_database_flag
   ida_loader.clr_database_flag
   ida_loader.get_path
   ida_loader.set_path
   ida_loader.get_elf_debug_file_directory
   ida_loader.mem2base
   ida_loader.load_plugin
   ida_loader.run_plugin
   ida_loader.load_and_run_plugin
   ida_loader.extract_module_from_archive


Module Contents
---------------

.. py:class:: qvector_snapshotvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> snapshot_t *&


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> snapshot_t *const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: qvector_snapshotvec_t) -> None


   .. py:method:: extract() -> snapshot_t **


   .. py:method:: inject(s: snapshot_t **, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< snapshot_t * >::const_iterator


   .. py:method:: end(*args) -> qvector< snapshot_t * >::const_iterator


   .. py:method:: insert(it: qvector< snapshot_t * >::iterator, x: snapshot_t) -> qvector< snapshot_t * >::iterator


   .. py:method:: erase(*args) -> qvector< snapshot_t * >::iterator


   .. py:method:: find(*args) -> qvector< snapshot_t * >::const_iterator


   .. py:method:: has(x: snapshot_t) -> bool


   .. py:method:: add_unique(x: snapshot_t) -> bool


   .. py:method:: append(x: snapshot_t) -> None


   .. py:method:: extend(x: qvector_snapshotvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: loader_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: version
      :type:  int

      api version, should be IDP_INTERFACE_VERSION



   .. py:attribute:: flags
      :type:  int

      Loader flags 
              



.. py:data:: LDRF_RELOAD

   loader recognizes NEF_RELOAD flag


.. py:data:: LDRF_REQ_PROC

   Requires a processor to be set. if this bit is not set, load_file() must call set_processor_type(..., SETPROC_LOADER) 
           


.. py:data:: ACCEPT_ARCHIVE

   Specify that a file format is served by archive loader See loader_t::accept_file 
           


.. py:data:: ACCEPT_CONTINUE

   Specify that the function must be called another time See loader_t::accept_file 
           


.. py:data:: ACCEPT_FIRST

   Specify that a file format should be place first in "load file" dialog box. See loader_t::accept_file 
           


.. py:data:: NEF_SEGS

   Create segments.


.. py:data:: NEF_RSCS

   Load resources.


.. py:data:: NEF_NAME

   Rename entries.


.. py:data:: NEF_MAN

   Manual load.


.. py:data:: NEF_FILL

   Fill segment gaps.


.. py:data:: NEF_IMPS

   Create import segment.


.. py:data:: NEF_FIRST

   This is the first file loaded into the database. 
           


.. py:data:: NEF_CODE

   for load_binary_file(): load as a code segment 
           


.. py:data:: NEF_RELOAD

   reload the file at the same place:
   * don't create segments
   * don't create fixup info
   * don't import segments
   * etc.


   Load only the bytes into the base. A loader should have the LDRF_RELOAD bit set. 
           


.. py:data:: NEF_FLAT

   Autocreate FLAT group (PE)


.. py:data:: NEF_MINI

   Create mini database (do not copy segment bytes from the input file; use only the file header metadata) 
           


.. py:data:: NEF_LOPT

   Display additional loader options dialog.


.. py:data:: NEF_LALL

   Load all segments without questions.


.. py:data:: DLLEXT

.. py:data:: LOADER_DLL

.. py:function:: load_binary_file(filename: str, li: linput_t *, _neflags: ushort, fileoff: qoff64_t, basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: uint64) -> bool

   Load a binary file into the database. This function usually is called from ui. 
           
   :param filename: the name of input file as is (if the input file is from library, then this is the name from the library)
   :param li: loader input source
   :param _neflags: Load file flags. For the first file, the flag NEF_FIRST must be set.
   :param fileoff: Offset in the input file
   :param basepara: Load address in paragraphs
   :param binoff: Load offset (load_address=(basepara<<4)+binoff)
   :param nbytes: Number of bytes to load from the file.
   * 0: up to the end of the file
   :returns: true: ok
   :returns: false: failed (couldn't open the file)


.. py:function:: process_archive(temp_file: str, li: linput_t *, module_name: str, neflags: ushort *, defmember: str, loader: load_info_t const *) -> str

   Calls loader_t::process_archive() For parameters and return value description look at loader_t::process_archive(). Additional parameter 'loader' is a pointer to load_info_t structure. 
           


.. py:data:: OFILE_MAP

   MAP file.


.. py:data:: OFILE_EXE

   Executable file.


.. py:data:: OFILE_IDC

   IDC file.


.. py:data:: OFILE_LST

   Disassembly listing.


.. py:data:: OFILE_ASM

   Assembly.


.. py:data:: OFILE_DIF

   Difference.


.. py:function:: gen_file(otype: ofile_type_t, fp: FILE *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, flags: int) -> int

   Generate an output file. OFILE_EXE: 
           
   :param otype: type of output file.
   :param fp: the output file handle
   :param ea1: start address. For some file types this argument is ignored
   :param ea2: end address. For some file types this argument is ignored as usual in ida, the end address of the range is not included
   :param flags: Generate file flags
   :returns: number of the generated lines. -1 if an error occurred
   :returns: 0: can't generate exe file
   :returns: 1: ok


.. py:data:: GENFLG_MAPSEG

   OFILE_MAP: generate map of segments


.. py:data:: GENFLG_MAPNAME

   OFILE_MAP: include dummy names


.. py:data:: GENFLG_MAPDMNG

   OFILE_MAP: demangle names


.. py:data:: GENFLG_MAPLOC

   OFILE_MAP: include local names


.. py:data:: GENFLG_IDCTYPE

   OFILE_IDC: gen only information about types


.. py:data:: GENFLG_ASMTYPE

   OFILE_ASM,OFILE_LST: gen information about types too


.. py:data:: GENFLG_GENHTML

   OFILE_ASM,OFILE_LST: generate html (ui_genfile_callback will be used)


.. py:data:: GENFLG_ASMINC

   OFILE_ASM,OFILE_LST: gen information only about types


.. py:function:: file2base(li: linput_t *, pos: qoff64_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, patchable: int) -> int

   Load portion of file into the database. This function will include (ea1..ea2) into the addressing space of the program (make it enabled). 
           
   :param li: pointer of input source
   :param pos: position in the file
   :param ea1: range of destination linear addresses
   :param ea2: range of destination linear addresses
   :param patchable: should the kernel remember correspondence of file offsets to linear addresses.
   :returns: 1: ok
   :returns: 0: read error, a warning is displayed


.. py:data:: FILEREG_PATCHABLE

   means that the input file may be patched (i.e. no compression, no iterated data, etc) 
           


.. py:data:: FILEREG_NOTPATCHABLE

   the data is kept in some encoded form in the file. 
           


.. py:function:: base2file(fp: FILE *, pos: qoff64_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> int

   Unload database to a binary file. This function works for wide byte processors too. 
           
   :param fp: pointer to file
   :param pos: position in the file
   :param ea1: range of source linear addresses
   :param ea2: range of source linear addresses
   :returns: 1-ok(always), write error leads to immediate exit


.. py:function:: get_basic_file_type(li: linput_t *) -> filetype_t

   Get the input file type. This function can recognize libraries and zip files. 
           


.. py:function:: get_file_type_name() -> str

   Get name of the current file type. The current file type is kept in idainfo::filetype. 
           
   :returns: size of answer, this function always succeeds


.. py:function:: set_import_ordinal(modnode: int, ea: ida_idaapi.ea_t, ord: int) -> None

   Set information about the ordinal import entry. This function performs 'modnode.altset(ord, ea2node(ea));' 
           
   :param modnode: node with information about imported entries
   :param ea: linear address of the entry
   :param ord: ordinal number of the entry


.. py:function:: set_import_name(modnode: int, ea: ida_idaapi.ea_t, name: str) -> None

   Set information about the named import entry. This function performs 'modnode.supset_ea(ea, name);' 
           
   :param modnode: node with information about imported entries
   :param ea: linear address of the entry
   :param name: name of the entry


.. py:function:: load_ids_module(fname: char *) -> int

   Load and apply IDS file. This function loads the specified IDS file and applies it to the database. If the program imports functions from a module with the same name as the name of the ids file being loaded, then only functions from this module will be affected. Otherwise (i.e. when the program does not import a module with this name) any function in the program may be affected. 
           
   :param fname: name of file to apply
   :returns: 1: ok
   :returns: 0: some error (a message is displayed). if the ids file does not exist, no message is displayed


.. py:function:: get_plugin_options(plugin: str) -> str

   Get plugin options from the command line. If the user has specified the options in the -Oplugin_name:options format, them this function will return the 'options' part of it The 'plugin' parameter should denote the plugin name Returns nullptr if there we no options specified 
           


.. py:data:: PLUGIN_DLL

   Pattern to find plugin files.


.. py:data:: MODULE_ENTRY_LOADER

.. py:data:: MODULE_ENTRY_PLUGIN

.. py:data:: MODULE_ENTRY_IDP

.. py:class:: idp_name_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: lname
      :type:  str

      long processor name



   .. py:attribute:: sname
      :type:  str

      short processor name



   .. py:attribute:: hidden
      :type:  bool

      is hidden



.. py:class:: idp_desc_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: path
      :type:  str

      module file name



   .. py:attribute:: mtime
      :type:  time_t

      time of last modification



   .. py:attribute:: family
      :type:  str

      processor's family



   .. py:attribute:: names
      :type:  idp_names_t

      processor names



   .. py:attribute:: is_script
      :type:  bool

      the processor module is a script



   .. py:attribute:: checked
      :type:  bool

      internal, for cache management



.. py:data:: IDP_DLL

.. py:class:: plugin_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: next
      :type:  plugin_info_t *

      next plugin information



   .. py:attribute:: path
      :type:  char *

      full path to the plugin



   .. py:attribute:: org_name
      :type:  char *

      original short name of the plugin



   .. py:attribute:: name
      :type:  char *

      short name of the plugin it will appear in the menu 
              



   .. py:attribute:: org_hotkey
      :type:  ushort

      original hotkey to run the plugin



   .. py:attribute:: hotkey
      :type:  ushort

      current hotkey to run the plugin



   .. py:attribute:: arg
      :type:  size_t

      argument used to call the plugin



   .. py:attribute:: entry
      :type:  plugin_t *

      pointer to the plugin if it is already loaded



   .. py:attribute:: dllmem
      :type:  idadll_t


   .. py:attribute:: flags
      :type:  int

      a copy of plugin_t::flags



   .. py:attribute:: comment
      :type:  char *

      a copy of plugin_t::comment



   .. py:attribute:: idaplg_name
      :type:  str

      "name" provided by ida-plugin.json or basename of path (without extension)



.. py:function:: find_plugin(name: str, load_if_needed: bool = False) -> plugin_t *

   Find a user-defined plugin and optionally load it. 
           
   :param name: short plugin name without path and extension, or absolute path to the file name
   :param load_if_needed: if the plugin is not present in the memory, try to load it
   :returns: pointer to plugin description block


.. py:function:: get_fileregion_offset(ea: ida_idaapi.ea_t) -> qoff64_t

   Get offset in the input file which corresponds to the given ea. If the specified ea can't be mapped into the input file offset, return -1. 
           


.. py:function:: get_fileregion_ea(offset: qoff64_t) -> ida_idaapi.ea_t

   Get linear address which corresponds to the specified input file offset. If can't be found, return BADADDR 
           


.. py:function:: gen_exe_file(fp: FILE *) -> int

   Generate an exe file (unload the database in binary form). 
           
   :returns: fp the output file handle. if fp == nullptr then return:
   * 1: can generate an executable file
   * 0: can't generate an executable file
   :returns: 1: ok
   :returns: 0: failed


.. py:function:: reload_file(file: str, is_remote: bool) -> bool

   Reload the input file. This function reloads the byte values from the input file. It doesn't modify the segmentation, names, comments, etc. 
           
   :param file: name of the input file. if file == nullptr then returns:
   * 1: can reload the input file
   * 0: can't reload the input file
   :param is_remote: is the file located on a remote computer with the debugger server?
   :returns: success


.. py:data:: MAX_DATABASE_DESCRIPTION

   Maximum database snapshot description length.


.. py:class:: snapshot_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: id
      :type:  qtime64_t

      snapshot ID. This value is computed using qgettimeofday()



   .. py:attribute:: flags
      :type:  uint16

      Snapshot flags 
              



   .. py:attribute:: desc
      :type:  char [128]

      snapshot description



   .. py:attribute:: filename
      :type:  char [QMAXPATH]

      snapshot file name



   .. py:attribute:: children
      :type:  snapshots_t

      snapshot children



   .. py:method:: clear() -> None


.. py:data:: SSF_AUTOMATIC

   automatic snapshot


.. py:function:: build_snapshot_tree(root: snapshot_t) -> bool

   Build the snapshot tree. 
           
   :param root: snapshot root that will contain the snapshot tree elements.
   :returns: success


.. py:data:: SSUF_DESC

   Update the description.


.. py:data:: SSUF_PATH

   Update the path.


.. py:data:: SSUF_FLAGS

   Update the flags.


.. py:function:: flush_buffers() -> int

   Flush buffers to the disk.


.. py:function:: is_trusted_idb() -> bool

   Is the database considered as trusted?


.. py:function:: save_database(outfile: str = None, flags: int = -1, root: snapshot_t = None, attr: snapshot_t = None) -> bool

   Save current database using a new file name. 
           
   :param outfile: output database file name; nullptr means the current path
   :param flags: Database flags; -1 means the current flags
   :param root: optional: snapshot tree root.
   :param attr: optional: snapshot attributes
   :returns: success


.. py:data:: DBFL_KILL

   delete unpacked database


.. py:data:: DBFL_COMP

   collect garbage


.. py:data:: DBFL_BAK

   create backup file (if !DBFL_KILL)


.. py:data:: DBFL_TEMP

   temporary database


.. py:function:: is_database_flag(dbfl: int) -> bool

   Get the current database flag 
           
   :param dbfl: flag Database flags
   :returns: the state of the flag (set or cleared)


.. py:function:: set_database_flag(dbfl: int, cnd: bool = True) -> None

   Set or clear database flag 
           
   :param dbfl: flag Database flags
   :param cnd: set if true or clear flag otherwise


.. py:function:: clr_database_flag(dbfl: int) -> None

.. py:data:: PATH_TYPE_CMD

   full path to the file specified in the command line


.. py:data:: PATH_TYPE_IDB

   full path of IDB file


.. py:data:: PATH_TYPE_ID0

   full path of ID0 file


.. py:function:: get_path(pt: path_type_t) -> str

   Get the file path 
           
   :param pt: file path type Types of the file pathes
   :returns: file path, never returns nullptr


.. py:function:: set_path(pt: path_type_t, path: str) -> None

   Set the file path 
           
   :param pt: file path type Types of the file pathes
   :param path: new file path, use nullptr or empty string to clear the file path


.. py:function:: get_elf_debug_file_directory() -> str

   Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive. 
           


.. py:function:: mem2base(mem, ea, fpos)

   Load database from the memory.

   :param mem: the buffer
   :param ea: start linear addresses
   :param fpos: position in the input file the data is taken from.
                if == -1, then no file position correspond to the data.
   :returns: 1, or 0 in case of failure


.. py:function:: load_plugin(name)

   Loads a plugin

   :param name: short plugin name without path and extension,
                or absolute path to the file name
   :returns: An opaque object representing the loaded plugin, or None if plugin could not be loaded


.. py:function:: run_plugin(plg, arg)

   Runs a plugin

   :param plg: A plugin object (returned by load_plugin())
   :param arg: the code to pass to the plugin's "run()" function
   :returns: Boolean


.. py:function:: load_and_run_plugin(name: str, arg: size_t) -> bool

   Load & run a plugin.


.. py:function:: extract_module_from_archive(fname: str, is_remote: bool = False) -> PyObject *

   Extract a module for an archive file. Parse an archive file, show the list of modules to the user, allow him to select a module, extract the selected module to a file (if the extract module is an archive, repeat the process). This function can handle ZIP, AR, AIXAR, OMFLIB files. The temporary file will be automatically deleted by IDA at the end. 
           
   :param is_remote: is the input file remote?
   :returns: true: ok
   :returns: false: something bad happened (error message has been displayed to the user)



```

`skills/idapython/docs/ida_merge.md`:

```md
# ida_merge

IDA Teams merge functionality - 3-way merging of IDB files (not available in IDA Pro).

## Overview

Low-priority module for IDA Teams only. Handles merging of base_idb, local_idb, and remote_idb databases with conflict resolution.

## Key Concepts

- **base_idb**: Common ancestor database (middle pane in UI)
- **local_idb**: Local database receiving merge result (left pane)
- **remote_idb**: Remote database merging into local (right pane)

## Merge Phases
Merges occur in phases: global settings, segmentation, bytes, names, functions, types, debugger settings, etc.

## Key Functions

- `is_diff_merge_mode()` - Check if in merge/diff mode
- `create_nodeval_merge_handler()` / `create_nodeval_merge_handlers()` - Create merge handlers for custom data
- `destroy_moddata_merge_handlers()` - Destroy module data merge handlers
- `get_ea_diffpos_name()` - Get name of EA difference position

## Key Classes

### merge_data_t
Merge operation data container.

### merge_handler_params_t
Parameters for creating merge handlers.

### merge_node_helper_t / merge_node_info_t
Helpers for merging netnode data.

## Merge Kinds (MERGE_KIND_*)
Extensive list including: NETNODE, INF, SEGMENTS, FUNC, FRAME, EXPORTS, IMPORTS, ENUMS, STRUCTS, TILS, TINFO, BYTEVAL, FLAGS, CREFS, DREFS, BPTS, DEBUGGER, etc.

## See Also
Full docs: skill/docs/ida_merge.rst

```

`skills/idapython/docs/ida_merge.rst`:

```rst
ida_merge
=========

.. py:module:: ida_merge

.. autoapi-nested-parse::

   Merge functionality.

   NOTE: this functionality is available in IDA Teams (not IDA Pro)
   There are 3 databases involved in merging: base_idb, local_db, and remote_idb.
   * base_idb: the common base ancestor of 'local_db' and 'remote_db'. in the UI this database is located in the middle.
   * local_idb: local database that will contain the result of the merging. in the UI this database is located on the left.
   * remote_idb: remote database that will merge into local_idb. It may reside locally on the current computer, despite its name. in the UI this database is located on the right. base_idb and remote_idb are opened for reading only. base_idb may be absent, in this case a 2-way merging is performed.


   Conflicts can be resolved automatically or interactively. The automatic resolving scores the conflicting blocks and takes the better one. The interactive resolving displays the full rendered contents side by side, and expects the user to select the better side for each conflict.
   Since IDB files contain various kinds of information, there are many merging phases. The entire list can be found in merge.cpp. Below are just some selected examples:
   * merge global database settings (inf and other global vars)
   * merge segmentation and changes to the database bytes
   * merge various lists: exports, imports, loaded tils, etc
   * merge names, functions, function frames
   * merge debugger settings, breakpoints
   * merge struct/enum views
   * merge local type libraries
   * merge the disassembly items (i.e. the segment contents) this includes operand types, code/data separation, etc
   * merge plugin specific info like decompiler types, dwarf mappings, etc


   To unify UI elements of each merge phase, we use merger views:
   * A view that consists of 2 or 3 panes: left (local_idb) and right (remote_idb). The common base is in the middle, if present.
   * Rendering of the panes depends on the phase, different phases show different contents.
   * The conflicts are highlighted by a colored background. Also, the detail pane can be consulted for additional info.
   * The user can select a conflict (or a bunch of conflicts) and say "use this block".
   * The user can browse the panes as he wishes. He will not be forced to handle conflicts in any particular order. However, once he finishes working with a merge handler and proceeds to the next one, he cannot go back.
   * Scrolling the left pane will synchronously scroll the right pane and vice versa.
   * There are the navigation commands like "go to the prev/next conflict"
   * The number of remaining conflicts to resolve is printed in the "Progress" chooser.
   * The user may manually modify local database inside the merger view. For that he may use the regular hotkeys. However, editing the database may lead to new conflicts, so we better restrict the available actions to some reasonable minimum. Currently, this is not implemented.


   IDA works in a new "merge" mode during merging. In this mode most events are not generated. We forbid them to reduce the risk that a rogue third-party plugin that is not aware of the "merge" mode would spoil something.
   For example, normally renaming a function causes a cascade of events and may lead to other database modifications. Some of them may be desired, some - not. Since there are some undesired events, it is better to stop generating them. However, some events are required to render the disassembly listing. For example, ev_ana_insn, av_out_insn. This is why some events are still generated in the "merge" mode.
   To let processor modules and plugins merge their data, we introduce a new event: ev_create_merge_handlers. It is generated immediately after opening all three idbs. The interested modules should react to this event by creating new merge handlers, if they need them.
   While the kernel can create arbitrary merge handlers, modules can create only the standard ones returned by:
   create_nodeval_merge_handler() create_nodeval_merge_handlers() create_std_modmerge_handlers()
   We do not document merge_handler_t because once a merge handler is created, it is used exclusively by the kernel.
   See mergemod.hpp for more information about the merge mode for modules. 
       



Attributes
----------

.. autoapisummary::

   ida_merge.MERGE_KIND_NETNODE
   ida_merge.MERGE_KIND_AUTOQ
   ida_merge.MERGE_KIND_INF
   ida_merge.MERGE_KIND_ENCODINGS
   ida_merge.MERGE_KIND_ENCODINGS2
   ida_merge.MERGE_KIND_SCRIPTS2
   ida_merge.MERGE_KIND_SCRIPTS
   ida_merge.MERGE_KIND_CUSTDATA
   ida_merge.MERGE_KIND_CUSTCNV
   ida_merge.MERGE_KIND_ENUMS
   ida_merge.MERGE_KIND_STRUCTS
   ida_merge.MERGE_KIND_TILS
   ida_merge.MERGE_KIND_TINFO
   ida_merge.MERGE_KIND_STRMEM
   ida_merge.MERGE_KIND_UDTMEM
   ida_merge.MERGE_KIND_GHSTRCMT
   ida_merge.MERGE_KIND_STRMEMCMT
   ida_merge.MERGE_KIND_SELECTORS
   ida_merge.MERGE_KIND_STT
   ida_merge.MERGE_KIND_SEGMENTS
   ida_merge.MERGE_KIND_SEGGRPS
   ida_merge.MERGE_KIND_SEGREGS
   ida_merge.MERGE_KIND_ORPHANS
   ida_merge.MERGE_KIND_BYTEVAL
   ida_merge.MERGE_KIND_FIXUPS
   ida_merge.MERGE_KIND_MAPPING
   ida_merge.MERGE_KIND_EXPORTS
   ida_merge.MERGE_KIND_IMPORTS
   ida_merge.MERGE_KIND_PATCHES
   ida_merge.MERGE_KIND_FLAGS
   ida_merge.MERGE_KIND_EXTRACMT
   ida_merge.MERGE_KIND_AFLAGS_EA
   ida_merge.MERGE_KIND_IGNOREMICRO
   ida_merge.MERGE_KIND_FILEREGIONS
   ida_merge.MERGE_KIND_HIDDENRANGES
   ida_merge.MERGE_KIND_SOURCEFILES
   ida_merge.MERGE_KIND_FUNC
   ida_merge.MERGE_KIND_FRAMEMGR
   ida_merge.MERGE_KIND_FRAME
   ida_merge.MERGE_KIND_STKPNTS
   ida_merge.MERGE_KIND_FLOWS
   ida_merge.MERGE_KIND_CREFS
   ida_merge.MERGE_KIND_DREFS
   ida_merge.MERGE_KIND_BPTS
   ida_merge.MERGE_KIND_WATCHPOINTS
   ida_merge.MERGE_KIND_BOOKMARKS
   ida_merge.MERGE_KIND_TRYBLKS
   ida_merge.MERGE_KIND_DIRTREE
   ida_merge.MERGE_KIND_VFTABLES
   ida_merge.MERGE_KIND_SIGNATURES
   ida_merge.MERGE_KIND_PROBLEMS
   ida_merge.MERGE_KIND_UI
   ida_merge.MERGE_KIND_DEKSTOPS
   ida_merge.MERGE_KIND_NOTEPAD
   ida_merge.MERGE_KIND_LOADER
   ida_merge.MERGE_KIND_DEBUGGER
   ida_merge.MERGE_KIND_DBG_MEMREGS
   ida_merge.MERGE_KIND_LUMINA
   ida_merge.MERGE_KIND_LAST
   ida_merge.MERGE_KIND_END
   ida_merge.MERGE_KIND_NONE
   ida_merge.MH_LISTEN
   ida_merge.MH_TERSE
   ida_merge.MH_UI_NODETAILS
   ida_merge.MH_UI_COMPLEX
   ida_merge.MH_UI_DP_NOLINEDIFF
   ida_merge.MH_UI_DP_SHORTNAME
   ida_merge.MH_UI_INDENT
   ida_merge.MH_UI_SPLITNAME
   ida_merge.MH_UI_CHAR_MASK
   ida_merge.MH_UI_COMMANAME
   ida_merge.MH_UI_COLONNAME
   ida_merge.NDS_IS_BOOL
   ida_merge.NDS_IS_EA
   ida_merge.NDS_IS_RELATIVE
   ida_merge.NDS_IS_STR
   ida_merge.NDS_SUPVAL
   ida_merge.NDS_BLOB
   ida_merge.NDS_EV_RANGE
   ida_merge.NDS_EV_FUNC
   ida_merge.NDS_MAP_IDX
   ida_merge.NDS_MAP_VAL
   ida_merge.NDS_VAL8
   ida_merge.NDS_INC
   ida_merge.NDS_UI_ND


Classes
-------

.. autoapisummary::

   ida_merge.merge_data_t
   ida_merge.item_block_locator_t
   ida_merge.merge_handler_params_t
   ida_merge.moddata_diff_helper_t
   ida_merge.merge_node_helper_t
   ida_merge.merge_node_info_t


Functions
---------

.. autoapisummary::

   ida_merge.is_diff_merge_mode
   ida_merge.create_nodeval_merge_handler
   ida_merge.create_nodeval_merge_handlers
   ida_merge.destroy_moddata_merge_handlers
   ida_merge.get_ea_diffpos_name


Module Contents
---------------

.. py:data:: MERGE_KIND_NETNODE

   netnode (no merging, to be used in idbunits)


.. py:data:: MERGE_KIND_AUTOQ

   auto queues


.. py:data:: MERGE_KIND_INF

   merge the inf variable (global settings)


.. py:data:: MERGE_KIND_ENCODINGS

   merge encodings


.. py:data:: MERGE_KIND_ENCODINGS2

   merge default encodings


.. py:data:: MERGE_KIND_SCRIPTS2

   merge scripts common info


.. py:data:: MERGE_KIND_SCRIPTS

   merge scripts


.. py:data:: MERGE_KIND_CUSTDATA

   merge custom data type and formats


.. py:data:: MERGE_KIND_CUSTCNV

   merge custom calling conventions


.. py:data:: MERGE_KIND_ENUMS

   merge enums


.. py:data:: MERGE_KIND_STRUCTS

   merge structs (globally: add/delete structs entirely)


.. py:data:: MERGE_KIND_TILS

   merge type libraries


.. py:data:: MERGE_KIND_TINFO

   merge tinfo


.. py:data:: MERGE_KIND_STRMEM

   merge struct members


.. py:data:: MERGE_KIND_UDTMEM

   merge UDT members (local types)


.. py:data:: MERGE_KIND_GHSTRCMT

   merge ghost structure comment


.. py:data:: MERGE_KIND_STRMEMCMT

   merge member comments for ghost struc


.. py:data:: MERGE_KIND_SELECTORS

   merge selectors


.. py:data:: MERGE_KIND_STT

   merge flag storage types


.. py:data:: MERGE_KIND_SEGMENTS

   merge segments


.. py:data:: MERGE_KIND_SEGGRPS

   merge segment groups


.. py:data:: MERGE_KIND_SEGREGS

   merge segment registers


.. py:data:: MERGE_KIND_ORPHANS

   merge orphan bytes


.. py:data:: MERGE_KIND_BYTEVAL

   merge byte values


.. py:data:: MERGE_KIND_FIXUPS

   merge fixups


.. py:data:: MERGE_KIND_MAPPING

   merge manual memory mapping


.. py:data:: MERGE_KIND_EXPORTS

   merge exports


.. py:data:: MERGE_KIND_IMPORTS

   merge imports


.. py:data:: MERGE_KIND_PATCHES

   merge patched bytes


.. py:data:: MERGE_KIND_FLAGS

   merge flags64_t


.. py:data:: MERGE_KIND_EXTRACMT

   merge extra next or prev lines


.. py:data:: MERGE_KIND_AFLAGS_EA

   merge aflags for mapped EA


.. py:data:: MERGE_KIND_IGNOREMICRO

   IM ("$ ignore micro") flags.


.. py:data:: MERGE_KIND_FILEREGIONS

   merge fileregions


.. py:data:: MERGE_KIND_HIDDENRANGES

   merge hidden ranges


.. py:data:: MERGE_KIND_SOURCEFILES

   merge source files ranges


.. py:data:: MERGE_KIND_FUNC

   merge func info


.. py:data:: MERGE_KIND_FRAMEMGR

   merge frames (globally: add/delete frames entirely)


.. py:data:: MERGE_KIND_FRAME

   merge function frame info (frame members)


.. py:data:: MERGE_KIND_STKPNTS

   merge SP change points


.. py:data:: MERGE_KIND_FLOWS

   merge flows


.. py:data:: MERGE_KIND_CREFS

   merge crefs


.. py:data:: MERGE_KIND_DREFS

   merge drefs


.. py:data:: MERGE_KIND_BPTS

   merge breakpoints


.. py:data:: MERGE_KIND_WATCHPOINTS

   merge watchpoints


.. py:data:: MERGE_KIND_BOOKMARKS

   merge bookmarks


.. py:data:: MERGE_KIND_TRYBLKS

   merge try blocks


.. py:data:: MERGE_KIND_DIRTREE

   merge std dirtrees


.. py:data:: MERGE_KIND_VFTABLES

   merge vftables


.. py:data:: MERGE_KIND_SIGNATURES

   signatures


.. py:data:: MERGE_KIND_PROBLEMS

   problems


.. py:data:: MERGE_KIND_UI

   UI.


.. py:data:: MERGE_KIND_DEKSTOPS

   dekstops


.. py:data:: MERGE_KIND_NOTEPAD

   notepad


.. py:data:: MERGE_KIND_LOADER

   loader data


.. py:data:: MERGE_KIND_DEBUGGER

   debugger data


.. py:data:: MERGE_KIND_DBG_MEMREGS

   manual memory regions (debugger)


.. py:data:: MERGE_KIND_LUMINA

   lumina function metadata


.. py:data:: MERGE_KIND_LAST

   last predefined merge handler type. please note that there can be more merge handler types, registered by plugins and processor modules. 
             


.. py:data:: MERGE_KIND_END

   insert to the end of handler list, valid for merge_handler_params_t::insert_after 
             


.. py:data:: MERGE_KIND_NONE

.. py:function:: is_diff_merge_mode() -> bool

   Return TRUE if IDA is running in diff mode (MERGE_POLICY_MDIFF/MERGE_POLICY_VDIFF)


.. py:class:: merge_data_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: dbctx_ids
      :type:  int [3]

      local, remote, base ids



   .. py:attribute:: nbases
      :type:  int

      number of database participating in merge process, maybe 2 or 3 
              



   .. py:attribute:: ev_handlers
      :type:  merge_handlers_t

      event handlers



   .. py:attribute:: item_block_locator
      :type:  merge_data_t::item_block_locator_t *


   .. py:attribute:: last_udt_related_merger
      :type:  merge_handler_t *


   .. py:method:: set_dbctx_ids(local: int, remote: int, base: int) -> None


   .. py:method:: local_id() -> int


   .. py:method:: remote_id() -> int


   .. py:method:: base_id() -> int


   .. py:method:: add_event_handler(handler: merge_handler_t *) -> None


   .. py:method:: remove_event_handler(handler: merge_handler_t *) -> None


   .. py:method:: get_block_head(idx: diff_source_idx_t, item_head: ida_idaapi.ea_t) -> ida_idaapi.ea_t


   .. py:method:: setup_blocks(dst_idx: diff_source_idx_t, src_idx: diff_source_idx_t, region: diff_range_t const &) -> bool


   .. py:method:: has_existing_node(nodename: str) -> bool

      check that node exists in any of databases



   .. py:method:: map_privrange_id(tid: tid_t *, ea: ida_idaapi.ea_t, _from: diff_source_idx_t, to: diff_source_idx_t, strict: bool = True) -> bool

      map IDs of structures, enumerations and their members 
              
      :param tid: item ID in TO database
      :param ea: item ID to find counterpart
      :param to: destination database index, diff_source_idx_t
      :param strict: raise interr if could not map
      :returns: success



   .. py:method:: map_tinfo(tif: tinfo_t, _from: diff_source_idx_t, to: diff_source_idx_t, strict: bool = True) -> bool

      migrate type, replaces type references into FROM database to references into TO database 
              
      :param tif: type to migrate, will be cleared in case of fail
      :param to: destination database index, diff_source_idx_t
      :param strict: raise interr if could not map
      :returns: success



   .. py:method:: compare_merging_tifs(tif1: tinfo_t, diffidx1: diff_source_idx_t, tif2: tinfo_t, diffidx2: diff_source_idx_t) -> int

      compare types from two databases 
              
      :param tif1: type
      :param diffidx1: database index, diff_source_idx_t
      :param tif2: type
      :param diffidx2: database index, diff_source_idx_t
      :returns: -1, 0, 1



.. py:class:: item_block_locator_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: get_block_head(md: merge_data_t, idx: diff_source_idx_t, item_head: ida_idaapi.ea_t) -> ida_idaapi.ea_t


   .. py:method:: setup_blocks(md: merge_data_t, _from: diff_source_idx_t, to: diff_source_idx_t, region: diff_range_t const &) -> bool


.. py:class:: merge_handler_params_t(_md: merge_data_t, _label: str, _kind: merge_kind_t, _insert_after: merge_kind_t, _mh_flags: int)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: md
      :type:  merge_data_t &


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: kind
      :type:  merge_kind_t

      merge handler kind merge_kind_t



   .. py:attribute:: insert_after
      :type:  merge_kind_t

      desired position inside 'handlers' merge_kind_t



   .. py:attribute:: mh_flags
      :type:  int


   .. py:method:: ui_has_details(*args) -> bool

      This function has the following signatures:

          0. ui_has_details() -> bool
          1. ui_has_details(_mh_flags: int) -> bool

      # 0: ui_has_details() -> bool


      # 1: ui_has_details(_mh_flags: int) -> bool

      Should IDA display the diffpos detail pane?



   .. py:method:: ui_complex_details(*args) -> bool

      This function has the following signatures:

          0. ui_complex_details() -> bool
          1. ui_complex_details(_mh_flags: int) -> bool

      # 0: ui_complex_details() -> bool


      # 1: ui_complex_details(_mh_flags: int) -> bool

      Do not display the diffpos details in the chooser. For example, the MERGE_KIND_SCRIPTS handler puts the script body as the diffpos detail. It would not be great to show them as part of the chooser. 
              



   .. py:method:: ui_complex_name(*args) -> bool

      This function has the following signatures:

          0. ui_complex_name() -> bool
          1. ui_complex_name(_mh_flags: int) -> bool

      # 0: ui_complex_name() -> bool


      # 1: ui_complex_name(_mh_flags: int) -> bool

      It customary to create long diffpos names having many components that are separated by any 7-bit ASCII character (besides of '\0'). In this case it is possible to instruct IDA to use this separator to create a multi-column chooser. For example the MERGE_KIND_ENUMS handler has the following diffpos name: enum_1,enum_2 If MH_UI_COMMANAME is specified, IDA will create 2 columns for these names. 
              



   .. py:method:: ui_split_char(*args) -> char

      This function has the following signatures:

          0. ui_split_char() -> char
          1. ui_split_char(_mh_flags: int) -> char

      # 0: ui_split_char() -> char


      # 1: ui_split_char(_mh_flags: int) -> char



   .. py:method:: ui_split_str(*args) -> str

      This function has the following signatures:

          0. ui_split_str() -> str
          1. ui_split_str(_mh_flags: int) -> str

      # 0: ui_split_str() -> str


      # 1: ui_split_str(_mh_flags: int) -> str



   .. py:method:: ui_dp_shortname(*args) -> bool

      This function has the following signatures:

          0. ui_dp_shortname() -> bool
          1. ui_dp_shortname(_mh_flags: int) -> bool

      # 0: ui_dp_shortname() -> bool


      # 1: ui_dp_shortname(_mh_flags: int) -> bool

      The detail pane shows the diffpos details for the current diffpos range as a tree-like view. In this pane the diffpos names are used as tree node names and the diffpos details as their children. Sometimes, for complex diffpos names, the first part of the name looks better than the entire name. For example, the MERGE_KIND_SEGMENTS handler has the following diffpos name: <range>,<segm1>,<segm2>,<segm3> if MH_UI_DP_SHORTNAME is specified, IDA will use <range> as a tree node name 
              



   .. py:method:: ui_linediff(*args) -> bool

      This function has the following signatures:

          0. ui_linediff() -> bool
          1. ui_linediff(_mh_flags: int) -> bool

      # 0: ui_linediff() -> bool


      # 1: ui_linediff(_mh_flags: int) -> bool

      In detail pane IDA shows difference between diffpos details. IDA marks added or deleted detail by color. In the modified detail the changes are marked. Use this UI hint if you do not want to show the differences inside detail. 
              



   .. py:method:: ui_indent(*args) -> bool

      This function has the following signatures:

          0. ui_indent() -> bool
          1. ui_indent(_mh_flags: int) -> bool

      # 0: ui_indent() -> bool


      # 1: ui_indent(_mh_flags: int) -> bool

      In the ordinary situation the spaces from the both sides of diffpos name are trimmed. Use this UI hint to preserve the leading spaces. 
              



.. py:data:: MH_LISTEN

   merge handler will receive merge events


.. py:data:: MH_TERSE

   do not display equal lines in the merge results table


.. py:data:: MH_UI_NODETAILS

   ida will not show the diffpos details


.. py:data:: MH_UI_COMPLEX

   diffpos details won't be displayed in the diffpos chooser


.. py:data:: MH_UI_DP_NOLINEDIFF

   Detail pane: do not show differences inside the line.


.. py:data:: MH_UI_DP_SHORTNAME

   Detail pane: use the first part of a complex diffpos name as the tree node name.


.. py:data:: MH_UI_INDENT

   preserve indent for diffpos name in diffpos chooser


.. py:data:: MH_UI_SPLITNAME

   ida will split the diffpos name by 7-bit ASCII char to create chooser columns 
           


.. py:data:: MH_UI_CHAR_MASK

   7-bit ASCII split character


.. py:data:: MH_UI_COMMANAME

   ida will split the diffpos name by ',' to create chooser columns


.. py:data:: MH_UI_COLONNAME

   ida will split the diffpos name by ':' to create chooser columns


.. py:class:: moddata_diff_helper_t(_module_name: str, _netnode_name: str, _fields: idbattr_info_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: module_name
      :type:  str

      will be used as a prefix for field desc



   .. py:attribute:: netnode_name
      :type:  str

      name of netnode with module data attributes



   .. py:attribute:: fields
      :type:  idbattr_info_t const *

      module data attribute descriptions



   .. py:attribute:: nfields
      :type:  size_t

      number of descriptions



   .. py:attribute:: additional_mh_flags
      :type:  int

      additional merge handler flags



   .. py:method:: merge_starting(arg0: diff_source_idx_t, arg1: void *) -> None


   .. py:method:: merge_ending(arg0: diff_source_idx_t, arg1: void *) -> None


   .. py:method:: get_struc_ptr(arg0: merge_data_t, arg1: diff_source_idx_t, arg2: idbattr_info_t) -> void *


   .. py:method:: print_diffpos_details(arg0: qstrvec_t *, arg1: idbattr_info_t) -> None


   .. py:method:: val2str(arg0: str, arg1: idbattr_info_t, arg2: uint64) -> bool


   .. py:method:: str2val(arg0: uint64 *, arg1: idbattr_info_t, arg2: str) -> bool


.. py:data:: NDS_IS_BOOL

   boolean value


.. py:data:: NDS_IS_EA

   EA value.


.. py:data:: NDS_IS_RELATIVE

   value is relative to index (stored as delta)


.. py:data:: NDS_IS_STR

   string value


.. py:data:: NDS_SUPVAL

   stored as netnode supvals (not scalar)


.. py:data:: NDS_BLOB

   stored as netnode blobs


.. py:data:: NDS_EV_RANGE

   enable default handling of mev_modified_ranges, mev_deleting_segm


.. py:data:: NDS_EV_FUNC

   enable default handling of mev_added_func/mev_deleting_func


.. py:data:: NDS_MAP_IDX

   apply ea2node() to index (==NETMAP_IDX)


.. py:data:: NDS_MAP_VAL

   apply ea2node() to value. Along with NDS_INC it gives effect of NETMAP_VAL, examples: altval_ea : NDS_MAP_IDX charval : NDS_VAL8 charval_ea: NDS_MAP_IDX|NDS_VAL8 eaget : NDS_MAP_IDX|NDS_MAP_VAL|NDS_INC 
             


.. py:data:: NDS_VAL8

   use 8-bit values (==NETMAP_V8)


.. py:data:: NDS_INC

   stored value is incremented (scalars only)


.. py:data:: NDS_UI_ND

   UI: no need to show diffpos detail pane, MH_UI_NODETAILS, make sense if merge_node_helper_t is used 
             


.. py:class:: merge_node_helper_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: print_entry_name(arg0: uchar, arg1: nodeidx_t, arg2: void *) -> str

      print the name of the specified entry (to be used in print_diffpos_name) 
              



   .. py:method:: print_entry_details(arg0: qstrvec_t *, arg1: uchar, arg2: nodeidx_t, arg3: void *) -> None

      print the details of the specified entry usually contains multiple lines, one for each attribute or detail. (to be used in print_diffpos_details) 
              



   .. py:method:: get_column_headers(arg0: qstrvec_t *, arg1: uchar, arg2: void *) -> None

      get column headers for chooser (to be used in linear_diff_source_t::get_column_headers) 
              



   .. py:method:: is_mergeable(arg0: uchar, arg1: nodeidx_t) -> bool

      filter: check if we should perform merging for given record



   .. py:method:: get_netnode() -> netnode

      return netnode to be used as source. If this function returns BADNODE netnode will be created using netnode name passed to create_nodeval_diff_source 
              



   .. py:method:: map_scalar(arg0: nodeidx_t *, arg1: void *, arg2: diff_source_idx_t, arg3: diff_source_idx_t) -> None

      map scalar/string/buffered value



   .. py:method:: map_string(arg0: str, arg1: void *, arg2: diff_source_idx_t, arg3: diff_source_idx_t) -> None


   .. py:method:: refresh(arg0: uchar, arg1: void *) -> None

      notify helper that some data was changed in the database and internal structures (e.g. caches) should be refreshed 
              



   .. py:method:: append_eavec(s: str, prefix: str, eas: eavec_t const &) -> None
      :staticmethod:


      can be used by derived classes



.. py:class:: merge_node_info_t(name: str, tag: uchar, nds_flags: int, node_helper: merge_node_helper_t = None)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      name of the array (label)



   .. py:attribute:: tag
      :type:  uchar

      a tag used to access values in the netnode



   .. py:attribute:: nds_flags
      :type:  int

      node value attributes (a combination of nds_flags_t)



   .. py:attribute:: node_helper
      :type:  merge_node_helper_t *


.. py:function:: create_nodeval_merge_handler(mhp: merge_handler_params_t, label: str, nodename: str, tag: uchar, nds_flags: int, node_helper: merge_node_helper_t = None, skip_empty_nodes: bool = True) -> merge_handler_t *

   Create a merge handler for netnode scalar/string values 
           
   :param mhp: merging parameters
   :param label: handler short name (to be be appended to mhp.label)
   :param nodename: netnode name
   :param tag: a tag used to access values in the netnode
   :param nds_flags: netnode value attributes (a combination of nds_flags_t)
   :param skip_empty_nodes: do not create handler in case of empty netnode
   :returns: diff source object (normally should be attahced to a merge handler)


.. py:function:: create_nodeval_merge_handlers(out: merge_handlers_t *, mhp: merge_handler_params_t, nodename: str, valdesc: merge_node_info_t, skip_empty_nodes: bool = True) -> None

   Create a serie of merge handlers for netnode scalar/string values (call create_nodeval_merge_handler() for each member of VALDESC) 
           
   :param out: [out] created handlers will be placed here
   :param mhp: merging parameters
   :param nodename: netnode name
   :param valdesc: array of handler descriptions
   :param skip_empty_nodes: do not create handlers for empty netnodes
   :returns: diff source object (normally should be attahced to a merge handler)


.. py:function:: destroy_moddata_merge_handlers(data_id: int) -> None

.. py:function:: get_ea_diffpos_name(ea: ida_idaapi.ea_t) -> str

   Get nice name for EA diffpos 
           
   :param ea: diffpos



```

`skills/idapython/docs/ida_mergemod.md`:

```md
# ida_mergemod

Helper functions for plugin/processor module merging in IDA Teams (not available in IDA Pro).

## Overview

Low-priority module for plugin/processor developers needing to merge custom module data. Used in response to `ev_create_merge_handlers` event.

## Key Function

- `create_std_modmerge_handlers(mhp, helper, merge_node_info=None)` - Create standard merge handlers for module data

## Merge Sources Supported
1. Data fields inside moddata (plugmod_t/procmod_t)
2. Values in module netnode
3. Values in arbitrary netnodes
4. Data fields in auxiliary structures
5. Indexed arrays in netnodes

## See Also
Full docs: skill/docs/ida_mergemod.rst
Examples: plugins/mex1, plugins/mex2, plugins/mex3, plugins/ex_merge_ldrdata

```

`skills/idapython/docs/ida_mergemod.rst`:

```rst
ida_mergemod
============

.. py:module:: ida_mergemod

.. autoapi-nested-parse::

   Merge functionality for modules.

   NOTE: this functionality is available in IDA Teams (not IDA Pro)
   This file contains helper classes and convenience functions for module (plugin or processor module) merging.
   Each module is responsible for merging the data it owns (the module data). At the very beginning, the merging engine generates the ev_create_merge_handlers event. Modules should hook to this event to create merge handlers (mergers) that are responsible for the module data.
   We assume that each module may have:

   * its data structure, derived from plugmod_t or procmod_t. we call this structure moddata.
   * a dedicated netnode (module node), modnode for short.


   Moddata is registered with the IDA kernel using the set_module_data() function, which returns an integer, moddata_id. moddata_id is used to access the module data structure during merging, so it is mandatory for all modules that support merging.
   The following sources of mergeable data are supported:
   1. Data fields inside moddata 2. Values (scalar or binary, including blobs) stored in the module node 3. Values (scalar or binary, including blobs) stored in arbitrary netnodes 4. Data fields inside an auxiliary structure (provided by a special helper) 5. Indexed arrays of data stored in netnodes
   Usually the sources #1-4 are handled by a single merger, which can be parameterized using the folowing information:

   * moddata_id
   * module name
   * module node name
   * array of field descriptors (idbattr_info_t idpopts_info[], see ida.hpp)


   See plugins/mex1 for an example of such a merger.
   These parameters are stored in a helper class (moddata_diff_helper_t or derived). The helper class can override the following virtual methods:
   merge_starting - prepare module data for merging (e.g. load data from idb) merge_ending - opposite to merge_starting (e.g. save merged data to idb) get_struc_ptr - get pointer to the auxiliary structure (to handle source #4); this method will be called only if the fields with the IDI_HLPSTRUC bit are present in the idpopts_info[] array
   For most plugins, the default implementation of moddata_diff_helper_t or the std_moddata_diff_helper_t helper (presented below) is sufficient. You can find examples of non-standard helpers in plugins/mex2.
   The source #5 is handled by a different set of mergers described by an array of merge_node_info_t entries: a merger per entry. A non-trivial example can be found in plugins/mex3 and plugins/ex_merge_ldrdata.
   A module can use the create_std_modmerge_handlers() function to create necessary merge handlers. Please pay attention to the following arguments:
   helper - a helper class responsible for access to the internal module data for the sources #1-4. It can be used to prepare a pointer to the internal module structure and load/save data before/after merging (example: plugins/mex2). Im most cases the default helper class moddata_diff_helper_t can be used. merge_node_info - array of descriptions for the source #5. Note that the same module node is used for all array elements. If you need this kind of mergers for other netnodes, you should add them manually using the create_nodeval_merge_handler() function (example: plugins/mex3)
   See also module/mergecmn.cpp for procmod-specific functions and macros.
   Glossary:
   modmerger = module merger moddata = module data moddata_id = module data id 
       



Functions
---------

.. autoapisummary::

   ida_mergemod.create_std_modmerge_handlers


Module Contents
---------------

.. py:function:: create_std_modmerge_handlers(mhp: merge_handler_params_t &, helper: moddata_diff_helper_t &, merge_node_info: merge_node_info2_t const * = None) -> None

   convinience function to create merge handlers for modules/plugins



```

`skills/idapython/docs/ida_moves.md`:

```md
# ida_moves

Navigation history, bookmarks, and location tracking in IDA views.

## Key Classes

### lochist_entry_t
Location history entry combining place and renderer info.
- `rinfo` - Renderer information (renderer_info_t)
- `plce` - Place pointer (place_t*)
- `place()` / `set_place(p)` - Get/set place
- `is_valid()` - Check if entry is valid
- `renderer_info()` - Get renderer info reference

### navstack_entry_t
Navigation stack entry extending lochist_entry_t.
- `widget_id` - Widget identifier
- `ud_str` - User-defined string
- Inherits all lochist_entry_t members

### navstack_t
Navigation history stack (back/forward navigation).
- `init(defpos, stream_name, flags)` - Initialize stack
- `set_current(e, in_charge)` / `get_current(out, widget_id)` - Set/get current position
- `stack_jump(try_to_unhide, e)` - Jump to entry
- `stack_back(out, cnt, try_to_unhide)` / `stack_forward(out, cnt, try_to_unhide)` - Navigate backward/forward
- `stack_nav(out, forward, cnt, try_to_unhide)` - Generic navigation
- `stack_index()` / `stack_size()` - Get current index/size
- `stack_clear(new_tip)` - Clear stack with new tip
- `get_stack_entry(out, index)` / `set_stack_entry(index, e)` - Get/set entry at index
- `is_history_enabled()` - Check if history is enabled

### bookmarks_t
Bookmark management (static methods).
- `mark(e, index, title, desc, ud)` - Create/update bookmark
- `get(out, index, ud)` - Get bookmark entry
- `get_desc(e, index, ud)` - Get bookmark description
- `find_index(e, ud)` - Find bookmark index
- `size(e, ud)` - Get bookmark count
- `erase(e, index, ud)` - Delete bookmark
- `get_dirtree_id(e, ud)` - Get dirtree ID for bookmark

### renderer_info_t
View renderer state (graph position, zoom, cursor).
- `rtype` - Renderer type (tcc_renderer_type_t)
- `gli` - Graph location info (graph_location_info_t)
- `pos` - Position info (renderer_info_pos_t)

### graph_location_info_t
Graph view location and zoom state.
- `zoom` - Zoom level
- `orgx` / `orgy` - Origin coordinates

### segm_move_info_t / segm_move_infos_t
Segment relocation tracking (for when segments move).
- `to` - Target address
- `size` - Size moved
- `find(ea)` - Find move info for address

## Constants

### Location State Flags (LSEF_*)
- `LSEF_PLACE` - Place component
- `LSEF_RINFO` - Renderer info component
- `LSEF_PTYPE` - Place type component
- `LSEF_ALL` - All components

### Unhide Flags (UNHID_*)
- `UNHID_SEGM` - Unhid segment at target
- `UNHID_FUNC` - Unhid function at target
- `UNHID_RANGE` - Unhid range at target

### Other Constants
- `MAX_MARK_SLOT` - Maximum bookmark slot number
- `LHF_HISTORY_DISABLED` - History disabled flag
- `DEFAULT_CURSOR_Y` / `DEFAULT_LNNUM` - Default cursor position

## See Also
Full docs: skill/docs/ida_moves.rst

```

`skills/idapython/docs/ida_moves.rst`:

```rst
ida_moves
=========

.. py:module:: ida_moves


Attributes
----------

.. autoapisummary::

   ida_moves.LSEF_PLACE
   ida_moves.LSEF_RINFO
   ida_moves.LSEF_PTYPE
   ida_moves.LSEF_ALL
   ida_moves.UNHID_SEGM
   ida_moves.UNHID_FUNC
   ida_moves.UNHID_RANGE
   ida_moves.DEFAULT_CURSOR_Y
   ida_moves.DEFAULT_LNNUM
   ida_moves.CURLOC_LIST
   ida_moves.MAX_MARK_SLOT
   ida_moves.LHF_HISTORY_DISABLED
   ida_moves.BOOKMARKS_PROMPT_WITH_HINT_PREFIX
   ida_moves.bookmarks_t_erase
   ida_moves.bookmarks_t_find_index
   ida_moves.bookmarks_t_get
   ida_moves.bookmarks_t_get_desc
   ida_moves.bookmarks_t_get_dirtree_id
   ida_moves.bookmarks_t_mark
   ida_moves.bookmarks_t_size


Classes
-------

.. autoapisummary::

   ida_moves.segm_move_info_vec_t
   ida_moves.graph_location_info_t
   ida_moves.segm_move_info_t
   ida_moves.segm_move_infos_t
   ida_moves.renderer_info_pos_t
   ida_moves.renderer_info_t
   ida_moves.lochist_entry_t
   ida_moves.navstack_entry_t
   ida_moves.navstack_t
   ida_moves.bookmarks_t


Module Contents
---------------

.. py:class:: segm_move_info_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> segm_move_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> segm_move_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: segm_move_info_vec_t) -> None


   .. py:method:: extract() -> segm_move_info_t *


   .. py:method:: inject(s: segm_move_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< segm_move_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< segm_move_info_t >::const_iterator


   .. py:method:: insert(it: segm_move_info_t, x: segm_move_info_t) -> qvector< segm_move_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< segm_move_info_t >::iterator


   .. py:method:: find(*args) -> qvector< segm_move_info_t >::const_iterator


   .. py:method:: has(x: segm_move_info_t) -> bool


   .. py:method:: add_unique(x: segm_move_info_t) -> bool


   .. py:method:: append(x: segm_move_info_t) -> None


   .. py:method:: extend(x: segm_move_info_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: graph_location_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: zoom
      :type:  double


   .. py:attribute:: orgx
      :type:  double


   .. py:attribute:: orgy
      :type:  double


.. py:class:: segm_move_info_t(_from: ida_idaapi.ea_t = 0, _to: ida_idaapi.ea_t = 0, _sz: size_t = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: to
      :type:  ida_idaapi.ea_t


   .. py:attribute:: size
      :type:  size_t


.. py:class:: segm_move_infos_t

   Bases: :py:obj:`segm_move_info_vec_t`


   .. py:attribute:: thisown


   .. py:method:: find(ea: ida_idaapi.ea_t) -> segm_move_info_t const *


.. py:class:: renderer_info_pos_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: node
      :type:  int


   .. py:attribute:: cx
      :type:  short


   .. py:attribute:: cy
      :type:  short


.. py:class:: renderer_info_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: gli
      :type:  graph_location_info_t


   .. py:attribute:: pos
      :type:  renderer_info_t::pos_t


   .. py:attribute:: rtype
      :type:  tcc_renderer_type_t


.. py:data:: LSEF_PLACE

.. py:data:: LSEF_RINFO

.. py:data:: LSEF_PTYPE

.. py:data:: LSEF_ALL

.. py:class:: lochist_entry_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: rinfo
      :type:  renderer_info_t


   .. py:attribute:: plce
      :type:  place_t *


   .. py:method:: renderer_info() -> renderer_info_t &


   .. py:method:: place() -> place_t *


   .. py:method:: set_place(p: place_t) -> None


   .. py:method:: is_valid() -> bool


   .. py:method:: acquire_place(in_p: place_t) -> None


.. py:class:: navstack_entry_t(*args)

   Bases: :py:obj:`lochist_entry_t`


   .. py:attribute:: thisown


   .. py:attribute:: widget_id
      :type:  str


   .. py:attribute:: ud_str
      :type:  str


.. py:data:: UNHID_SEGM

   unhid a segment at 'target'


.. py:data:: UNHID_FUNC

   unhid a function at 'target'


.. py:data:: UNHID_RANGE

   unhid an range at 'target'


.. py:data:: DEFAULT_CURSOR_Y

.. py:data:: DEFAULT_LNNUM

.. py:data:: CURLOC_LIST

.. py:data:: MAX_MARK_SLOT

.. py:class:: navstack_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int


   .. py:method:: is_history_enabled() -> bool


   .. py:method:: init(defpos: navstack_entry_t, stream_name: str, _flags: int) -> bool


   .. py:method:: perform_move(stream_name: str, source_stream_name: str, widget_id: str, move_stack: bool) -> bool
      :staticmethod:



   .. py:method:: netcode() -> nodeidx_t


   .. py:method:: set_current(e: navstack_entry_t, in_charge: bool) -> None


   .. py:method:: get_current(out: navstack_entry_t, widget_id: str) -> bool


   .. py:method:: get_all_current(out: navstack_entry_vec_t *) -> None


   .. py:method:: stack_jump(try_to_unhide: bool, e: navstack_entry_t) -> None


   .. py:method:: stack_index() -> int


   .. py:method:: stack_seek(out: navstack_entry_t, index: int, try_to_unhide: bool) -> bool


   .. py:method:: stack_forward(out: navstack_entry_t, cnt: int, try_to_unhide: bool) -> bool


   .. py:method:: stack_back(out: navstack_entry_t, cnt: int, try_to_unhide: bool) -> bool


   .. py:method:: stack_nav(out: navstack_entry_t, forward: bool, cnt: int, try_to_unhide: bool) -> bool


   .. py:method:: stack_clear(new_tip: navstack_entry_t) -> None


   .. py:method:: set_stack_entry(index: int, e: navstack_entry_t) -> None


   .. py:method:: get_stack_entry(out: navstack_entry_t, index: int) -> bool


   .. py:method:: get_current_stack_entry(out: navstack_entry_t) -> bool


   .. py:method:: stack_size() -> int


.. py:data:: LHF_HISTORY_DISABLED

.. py:class:: bookmarks_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: mark(e: lochist_entry_t, index: int, title: str, desc: str, ud: void *) -> int
      :staticmethod:



   .. py:method:: get_desc(e: lochist_entry_t, index: int, ud: void *) -> str
      :staticmethod:



   .. py:method:: find_index(e: lochist_entry_t, ud: void *) -> int
      :staticmethod:



   .. py:method:: size(e: lochist_entry_t, ud: void *) -> int
      :staticmethod:



   .. py:method:: erase(e: lochist_entry_t, index: int, ud: void *) -> bool
      :staticmethod:



   .. py:method:: get_dirtree_id(e: lochist_entry_t, ud: void *) -> dirtree_id_t
      :staticmethod:



   .. py:method:: get(out: lochist_entry_t, _index: int, ud: void *) -> PyObject *
      :staticmethod:



   .. py:attribute:: widget


   .. py:attribute:: userdata


   .. py:attribute:: template


.. py:data:: BOOKMARKS_PROMPT_WITH_HINT_PREFIX

.. py:data:: bookmarks_t_erase

.. py:data:: bookmarks_t_find_index

.. py:data:: bookmarks_t_get

.. py:data:: bookmarks_t_get_desc

.. py:data:: bookmarks_t_get_dirtree_id

.. py:data:: bookmarks_t_mark

.. py:data:: bookmarks_t_size


```

`skills/idapython/docs/ida_nalt.md`:

```md
# ida_nalt

Netnode-based storage for various analysis information - switch tables, references, types, strings, imports, metadata.

## Key Functions

### Netnode Access
- `ea2node(ea)` / `node2ea(node)` - Convert between addresses and netnodes
- `end_ea2node(ea, size)` - Get netnode for address range end
- `getnode(ea)` - Get netnode for address

### Address Flags (AFL_*)
Extensive flag system for tracking analysis state at addresses.

#### Query Flags
- `get_aflags(ea)` / `set_aflags(ea, flags)` / `del_aflags(ea)` - Get/set/delete flags
- `upd_abits(ea, set, clr)` / `set_abits(ea, bits)` / `clr_abits(ea, bits)` - Update address bits
- `is_hidden_item(ea)` / `hide_item(ea)` / `unhide_item(ea)` - Item visibility
- `is_hidden_border(ea)` / `hide_border(ea)` / `unhide_border(ea)` - Border visibility
- `is_colored_item(ea)` / `set_colored_item(ea)` / `clr_colored_item(ea)` - Colored items
- `is_usersp(ea)` / `set_usersp(ea)` / `clr_usersp(ea)` - User stack pointer
- `uses_modsp(ea)` / `set_usemodsp(ea)` / `clr_usemodsp(ea)` - Modified stack pointer
- `is_libitem(ea)` / `set_libitem(ea)` / `clr_libitem(ea)` - Library item
- `is_noret(ea)` / `set_noret(ea)` / `clr_noret(ea)` - No-return function
- `is_notcode(ea)` / `set_notcode(ea)` / `clr_notcode(ea)` - Not code
- `is_notproc(ea)` / `set_notproc(ea)` / `clr_notproc(ea)` - Not procedure
- `is_type_guessed_by_ida(ea)` / `set_type_guessed_by_ida(ea)` - IDA type guess
- `is_func_guessed_by_hexrays(ea)` / `set_func_guessed_by_hexrays(ea)` - Hex-Rays function guess
- `is_data_guessed_by_hexrays(ea)` / `set_data_guessed_by_hexrays(ea)` - Hex-Rays data guess
- `is_type_determined_by_hexrays(ea)` / `set_type_determined_by_hexrays(ea)` - Hex-Rays type determination

### Type Information
- `get_tinfo(tif, ea)` / `set_tinfo(ea, tif)` / `del_tinfo(ea)` - Address type info
- `get_op_tinfo(tif, ea, opnum)` / `set_op_tinfo(ea, opnum, tif)` / `del_op_tinfo(ea, opnum)` - Operand type info
- `has_ti(ea)` / `has_ti0(ea)` / `has_ti1(ea)` - Check if type info exists

### String Types
- `get_str_type(ea)` / `set_str_type(ea, strtype)` / `del_str_type(ea)` - String type at address
- `get_str_type_code(strtype)` - Get string type code
- `get_str_term1(strtype)` / `get_str_term2(strtype)` - String terminators
- `get_str_encoding_idx(ea)` / `set_str_encoding_idx(ea, idx)` - String encoding
- `make_str_type(base, lyt)` - Construct string type code
- `is_pascal(strtype)` - Check if Pascal string
- `get_str_type_prefix_length(strtype)` - Get prefix length

### References and Offsets
- `get_refinfo(ri, ea, opnum)` / `set_refinfo(ea, opnum, type, target, base, tdelta)` / `del_refinfo(ea, opnum)` - Reference info
- `set_refinfo_ex(ea, opnum, ri)` - Set reference info with refinfo_t
- `get_custom_refinfo(out, cfmt)` / `find_custom_refinfo(cfmt)` - Custom reference formats
- `get_reftype_by_size(size)` - Get reference type by size
- `is_reftype_target_optional(rt)` - Check if target is optional

### Switch Tables
- `get_switch_info(si, ea)` / `set_switch_info(ea, si)` / `del_switch_info(ea)` - Switch info
- `get_switch_parent(ea)` / `set_switch_parent(ea, parent)` / `del_switch_parent(ea)` - Switch parent

### Arrays
- `get_array_parameters(out, ea)` / `set_array_parameters(ea, params)` / `del_array_parameters(ea)` - Array display parameters

### Custom Data Types
- `get_custom_data_type_ids(out, ea)` / `set_custom_data_type_ids(ea, ids)` / `del_custom_data_type_ids(ea)` - Custom data types

### Colors and Alignment
- `get_item_color(ea)` / `set_item_color(ea, color)` / `del_item_color(ea)` - Item color
- `get_alignment(ea)` / `set_alignment(ea, align)` / `del_alignment(ea)` - Alignment

### Source Line Numbers
- `get_source_linnum(ea)` / `set_source_linnum(ea, lnnum)` / `del_source_linnum(ea)` - Source line mapping

### Absolute Base
- `get_absbase(ea)` / `set_absbase(ea, base)` / `del_absbase(ea)` - Absolute segment base

### File Metadata
- `get_root_filename()` / `set_root_filename(path)` - Input file root name
- `get_input_file_path()` - Input file full path
- `dbg_get_input_path()` - Debugger input path
- `retrieve_input_file_size()` - File size
- `retrieve_input_file_crc32()` / `retrieve_input_file_md5()` / `retrieve_input_file_sha256()` - File hashes
- `get_archive_path()` / `set_archive_path(path)` - Archive path
- `get_loader_format_name()` / `set_loader_format_name(name)` - Loader format

### IDB Version and Timing
- `get_initial_ida_version()` / `get_initial_idb_version()` - IDA/IDB versions
- `get_idb_ctime()` - IDB creation time
- `get_elapsed_secs()` - Analysis elapsed time
- `get_idb_nopens()` - IDB open count

### Image Base
- `get_imagebase()` / `set_imagebase(base)` - Image base address

### String Encodings
- `get_encoding_qty()` - Number of encodings
- `get_encoding_name(idx)` - Encoding name
- `add_encoding(name, bpu)` / `del_encoding(idx)` / `rename_encoding(idx, name)` - Manage encodings
- `get_encoding_bpu(idx)` / `get_encoding_bpu_by_name(name)` - Bytes per unit
- `get_strtype_bpu(strtype)` - String type bytes per unit
- `get_default_encoding_idx()` / `set_default_encoding_idx(idx)` - Default encoding
- `get_outfile_encoding_idx()` / `set_outfile_encoding_idx(idx)` - Output file encoding
- `encoding_from_strtype(strtype)` - Get encoding from string type

### Imports
- `get_import_module_qty()` - Number of import modules
- `get_import_module_name(idx)` - Import module name
- `enum_import_names(idx, callback)` - Enumerate imports
- `delete_imports()` - Delete all imports

### GOT/PLT
- `get_gotea()` / `set_gotea(ea)` - Global Offset Table address

### Notepad
- `get_ida_notepad_text()` / `set_ida_notepad_text(text)` - IDA notepad text

### Source Debug Paths
- `get_srcdbg_paths()` / `set_srcdbg_paths(paths)` - Source debug paths
- `get_srcdbg_undesired_paths()` / `set_srcdbg_undesired_paths(paths)` - Undesired debug paths

### Assembly Include
- `get_asm_inc_file()` / `set_asm_inc_file(file)` - Assembly include file

### IDS Modules
- `get_ids_modnode()` / `set_ids_modnode(node)` - IDS module netnode

### ABI
- `get_abi_name()` - ABI name

## Key Classes

### switch_info_t
Switch statement information.
- `flags` - Switch flags (SWI_*)
- `ncases` - Number of cases (excluding default)
- `jumps` - Jump table start address
- `values` - Values table address (if SWI_SPARSE)
- `lowcase` - Lowest case value
- `defjump` - Default jump address (BADADDR if none)
- `startea` - Start of switch idiom
- `jcases` - Jump table entries (if SWI_INDIRECT)
- `elbase` - Element base
- `regnum` / `regdtype` - Switch expression register
- `get_jtable_size()` / `set_jtable_size(size)` - Jump table size
- `get_jtable_element_size()` / `set_jtable_element_size(size)` - Element size
- `has_default()` / `is_sparse()` / `is_custom()` / `is_indirect()` / `is_subtract()` - Query flags

### refinfo_t
Reference/offset information.
- `target` - Reference target (BADADDR if none)
- `base` - Base of reference (may be BADADDR)
- `tdelta` - Offset from target
- `flags` - Reference flags (REFINFO_*)
- `type()` / `set_type(rt)` - Reference type (REF_OFF16, REF_OFF32, REF_OFF64, etc.)
- `is_target_optional()` / `no_base_xref()` / `is_pastend()` / `is_rvaoff()` / `is_custom()` / `is_subtract()` / `is_signed()` - Query flags
- `init()` - Initialize

### array_parameters_t
Array display parameters.
- `flags` - Array flags (AP_*)
- `lineitems` - Items per line
- `alignment` - Item alignment (-1=don't align, 0=auto, else width)
- `is_default()` - Check if default

### opinfo_t
Operand type information union (structure/enum/strpath/custom).

### strpath_t
Structure path for nested structure member offsets.

### enum_const_t
Enumeration constant reference.

## Key Constants

### String Types (STRTYPE_*)
- `STRTYPE_TERMCHR` / `STRTYPE_C` / `STRTYPE_C_16` / `STRTYPE_C_32` - C strings
- `STRTYPE_PASCAL` / `STRTYPE_PASCAL_16` / `STRTYPE_PASCAL_32` - Pascal strings
- `STRTYPE_LEN2` / `STRTYPE_LEN2_16` / `STRTYPE_LEN2_32` - 2-byte length prefix
- `STRTYPE_LEN4` / `STRTYPE_LEN4_16` / `STRTYPE_LEN4_32` - 4-byte length prefix

### String Layout (STRLYT_*)
- `STRLYT_TERMCHR` / `STRLYT_PASCAL1` / `STRLYT_PASCAL2` / `STRLYT_PASCAL4` - Layout types

### String Width (STRWIDTH_*)
- `STRWIDTH_1B` / `STRWIDTH_2B` / `STRWIDTH_4B` - Character width

### Reference Types (REF_*)
- `REF_OFF16` / `REF_OFF32` / `REF_OFF64` - Full offsets
- `REF_LOW8` / `REF_LOW16` / `REF_HIGH8` / `REF_HIGH16` - Partial offsets

### Reference Info Flags (REFINFO_*)
- `REFINFO_RVAOFF` - RVA offset
- `REFINFO_PASTEND` - Past end of segment
- `REFINFO_CUSTOM` - Custom format
- `REFINFO_NOBASE` - No base
- `REFINFO_SUBTRACT` - Subtract instead of add
- `REFINFO_SIGNEDOP` - Signed operand

### Switch Info Flags (SWI_*)
- `SWI_SPARSE` - Sparse switch (has values table)
- `SWI_V32` / `SWI_J32` - 32-bit values/jumps
- `SWI_USER` - User-defined
- `SWI_CUSTOM` - Custom switch
- `SWI_INDIRECT` - Indirect jump table

### Address Flags (AFL_*)
Extensive flag set including: AFL_LINNUM, AFL_USERSP, AFL_PUBNAM, AFL_WEAKNAM, AFL_HIDDEN, AFL_MANUAL, AFL_NOBRD, AFL_ZSTROFF, AFL_LIB, AFL_TI, AFL_COLORED, AFL_NORET, AFL_FIXEDSPD, AFL_ALIGNFLOW, AFL_USERTI, AFL_RETFP, AFL_USEMODSP, AFL_NOTCODE, AFL_NOTPROC, and type guessing flags.

### Root Info Indices (RIDX_*)
Database-level metadata keys: RIDX_FILE_FORMAT_NAME, RIDX_MD5, RIDX_SHA256, RIDX_IDA_VERSION, RIDX_STR_ENCODINGS, RIDX_SRCDBG_PATHS, RIDX_DBG_BINPATHS, RIDX_ABINAME, RIDX_ARCHIVE_PATH, RIDX_PROBLEMS, etc.

## See Also
Full docs: skill/docs/ida_nalt.rst

```

`skills/idapython/docs/ida_nalt.rst`:

```rst
ida_nalt
========

.. py:module:: ida_nalt

.. autoapi-nested-parse::

   Definitions of various information kept in netnodes.

   Each address in the program has a corresponding netnode: netnode(ea).
   If we have no information about an address, the corresponding netnode is not created. Otherwise we will create a netnode and save information in it. All variable length information (names, comments, offset information, etc) is stored in the netnode.
   Don't forget that some information is already stored in the flags (bytes.hpp)
   netnode. 
       



Attributes
----------

.. autoapisummary::

   ida_nalt.NALT_SWITCH
   ida_nalt.NALT_STRUCT
   ida_nalt.NALT_AFLAGS
   ida_nalt.NALT_LINNUM
   ida_nalt.NALT_ABSBASE
   ida_nalt.NALT_ENUM0
   ida_nalt.NALT_ENUM1
   ida_nalt.NALT_PURGE
   ida_nalt.NALT_STRTYPE
   ida_nalt.NALT_ALIGN
   ida_nalt.NALT_COLOR
   ida_nalt.NSUP_CMT
   ida_nalt.NSUP_REPCMT
   ida_nalt.NSUP_FOP1
   ida_nalt.NSUP_FOP2
   ida_nalt.NSUP_JINFO
   ida_nalt.NSUP_ARRAY
   ida_nalt.NSUP_OMFGRP
   ida_nalt.NSUP_FOP3
   ida_nalt.NSUP_SWITCH
   ida_nalt.NSUP_REF0
   ida_nalt.NSUP_REF1
   ida_nalt.NSUP_REF2
   ida_nalt.NSUP_OREF0
   ida_nalt.NSUP_OREF1
   ida_nalt.NSUP_OREF2
   ida_nalt.NSUP_STROFF0
   ida_nalt.NSUP_STROFF1
   ida_nalt.NSUP_SEGTRANS
   ida_nalt.NSUP_FOP4
   ida_nalt.NSUP_FOP5
   ida_nalt.NSUP_FOP6
   ida_nalt.NSUP_REF3
   ida_nalt.NSUP_REF4
   ida_nalt.NSUP_REF5
   ida_nalt.NSUP_OREF3
   ida_nalt.NSUP_OREF4
   ida_nalt.NSUP_OREF5
   ida_nalt.NSUP_XREFPOS
   ida_nalt.NSUP_CUSTDT
   ida_nalt.NSUP_GROUPS
   ida_nalt.NSUP_ARGEAS
   ida_nalt.NSUP_FOP7
   ida_nalt.NSUP_FOP8
   ida_nalt.NSUP_REF6
   ida_nalt.NSUP_REF7
   ida_nalt.NSUP_OREF6
   ida_nalt.NSUP_OREF7
   ida_nalt.NSUP_EX_FLAGS
   ida_nalt.NSUP_POINTS
   ida_nalt.NSUP_MANUAL
   ida_nalt.NSUP_TYPEINFO
   ida_nalt.NSUP_REGVAR
   ida_nalt.NSUP_LLABEL
   ida_nalt.NSUP_REGARG
   ida_nalt.NSUP_FTAILS
   ida_nalt.NSUP_GROUP
   ida_nalt.NSUP_OPTYPES
   ida_nalt.NSUP_ORIGFMD
   ida_nalt.NSUP_FRAME
   ida_nalt.NALT_CREF_TO
   ida_nalt.NALT_CREF_FROM
   ida_nalt.NALT_DREF_TO
   ida_nalt.NALT_DREF_FROM
   ida_nalt.NSUP_GR_INFO
   ida_nalt.NALT_GR_LAYX
   ida_nalt.NSUP_GR_LAYT
   ida_nalt.PATCH_TAG
   ida_nalt.IDB_DESKTOPS_NODE_NAME
   ida_nalt.IDB_DESKTOPS_TAG
   ida_nalt.AFL_LINNUM
   ida_nalt.AFL_USERSP
   ida_nalt.AFL_PUBNAM
   ida_nalt.AFL_WEAKNAM
   ida_nalt.AFL_HIDDEN
   ida_nalt.AFL_MANUAL
   ida_nalt.AFL_NOBRD
   ida_nalt.AFL_ZSTROFF
   ida_nalt.AFL_BNOT0
   ida_nalt.AFL_BNOT1
   ida_nalt.AFL_LIB
   ida_nalt.AFL_TI
   ida_nalt.AFL_TI0
   ida_nalt.AFL_TI1
   ida_nalt.AFL_LNAME
   ida_nalt.AFL_TILCMT
   ida_nalt.AFL_LZERO0
   ida_nalt.AFL_LZERO1
   ida_nalt.AFL_COLORED
   ida_nalt.AFL_TERSESTR
   ida_nalt.AFL_SIGN0
   ida_nalt.AFL_SIGN1
   ida_nalt.AFL_NORET
   ida_nalt.AFL_FIXEDSPD
   ida_nalt.AFL_ALIGNFLOW
   ida_nalt.AFL_USERTI
   ida_nalt.AFL_RETFP
   ida_nalt.AFL_USEMODSP
   ida_nalt.AFL_NOTCODE
   ida_nalt.AFL_NOTPROC
   ida_nalt.AFL_TYPE_GUESSED
   ida_nalt.AFL_IDA_GUESSED
   ida_nalt.AFL_HR_GUESSED_FUNC
   ida_nalt.AFL_HR_GUESSED_DATA
   ida_nalt.AFL_HR_DETERMINED
   ida_nalt.STRWIDTH_1B
   ida_nalt.STRWIDTH_2B
   ida_nalt.STRWIDTH_4B
   ida_nalt.STRWIDTH_MASK
   ida_nalt.STRLYT_TERMCHR
   ida_nalt.STRLYT_PASCAL1
   ida_nalt.STRLYT_PASCAL2
   ida_nalt.STRLYT_PASCAL4
   ida_nalt.STRLYT_MASK
   ida_nalt.STRLYT_SHIFT
   ida_nalt.STRTYPE_TERMCHR
   ida_nalt.STRTYPE_C
   ida_nalt.STRTYPE_C_16
   ida_nalt.STRTYPE_C_32
   ida_nalt.STRTYPE_PASCAL
   ida_nalt.STRTYPE_PASCAL_16
   ida_nalt.STRTYPE_PASCAL_32
   ida_nalt.STRTYPE_LEN2
   ida_nalt.STRTYPE_LEN2_16
   ida_nalt.STRTYPE_LEN2_32
   ida_nalt.STRTYPE_LEN4
   ida_nalt.STRTYPE_LEN4_16
   ida_nalt.STRTYPE_LEN4_32
   ida_nalt.STRENC_DEFAULT
   ida_nalt.STRENC_NONE
   ida_nalt.AP_ALLOWDUPS
   ida_nalt.AP_SIGNED
   ida_nalt.AP_INDEX
   ida_nalt.AP_ARRAY
   ida_nalt.AP_IDXBASEMASK
   ida_nalt.AP_IDXDEC
   ida_nalt.AP_IDXHEX
   ida_nalt.AP_IDXOCT
   ida_nalt.AP_IDXBIN
   ida_nalt.SWI_SPARSE
   ida_nalt.SWI_V32
   ida_nalt.SWI_J32
   ida_nalt.SWI_VSPLIT
   ida_nalt.SWI_USER
   ida_nalt.SWI_DEF_IN_TBL
   ida_nalt.SWI_JMP_INV
   ida_nalt.SWI_SHIFT_MASK
   ida_nalt.SWI_ELBASE
   ida_nalt.SWI_JSIZE
   ida_nalt.SWI_VSIZE
   ida_nalt.SWI_SEPARATE
   ida_nalt.SWI_SIGNED
   ida_nalt.SWI_CUSTOM
   ida_nalt.SWI_INDIRECT
   ida_nalt.SWI_SUBTRACT
   ida_nalt.SWI_HXNOLOWCASE
   ida_nalt.SWI_STDTBL
   ida_nalt.SWI_DEFRET
   ida_nalt.SWI_SELFREL
   ida_nalt.SWI_JMPINSN
   ida_nalt.SWI_VERSION
   ida_nalt.cvar
   ida_nalt.V695_REF_OFF8
   ida_nalt.REF_OFF16
   ida_nalt.REF_OFF32
   ida_nalt.REF_LOW8
   ida_nalt.REF_LOW16
   ida_nalt.REF_HIGH8
   ida_nalt.REF_HIGH16
   ida_nalt.V695_REF_VHIGH
   ida_nalt.V695_REF_VLOW
   ida_nalt.REF_OFF64
   ida_nalt.REF_OFF8
   ida_nalt.REF_LAST
   ida_nalt.REFINFO_TYPE
   ida_nalt.REFINFO_RVAOFF
   ida_nalt.REFINFO_PASTEND
   ida_nalt.REFINFO_CUSTOM
   ida_nalt.REFINFO_NOBASE
   ida_nalt.REFINFO_SUBTRACT
   ida_nalt.REFINFO_SIGNEDOP
   ida_nalt.REFINFO_NO_ZEROS
   ida_nalt.REFINFO_NO_ONES
   ida_nalt.REFINFO_SELFREF
   ida_nalt.MAXSTRUCPATH
   ida_nalt.POF_VALID_TI
   ida_nalt.POF_VALID_AFLAGS
   ida_nalt.POF_IS_F64
   ida_nalt.RIDX_FILE_FORMAT_NAME
   ida_nalt.RIDX_SELECTORS
   ida_nalt.RIDX_GROUPS
   ida_nalt.RIDX_H_PATH
   ida_nalt.RIDX_C_MACROS
   ida_nalt.RIDX_SMALL_IDC_OLD
   ida_nalt.RIDX_NOTEPAD
   ida_nalt.RIDX_INCLUDE
   ida_nalt.RIDX_SMALL_IDC
   ida_nalt.RIDX_DUALOP_GRAPH
   ida_nalt.RIDX_DUALOP_TEXT
   ida_nalt.RIDX_MD5
   ida_nalt.RIDX_IDA_VERSION
   ida_nalt.RIDX_STR_ENCODINGS
   ida_nalt.RIDX_SRCDBG_PATHS
   ida_nalt.RIDX_DBG_BINPATHS
   ida_nalt.RIDX_SHA256
   ida_nalt.RIDX_ABINAME
   ida_nalt.RIDX_ARCHIVE_PATH
   ida_nalt.RIDX_PROBLEMS
   ida_nalt.RIDX_SRCDBG_UNDESIRED
   ida_nalt.BPU_1B
   ida_nalt.BPU_2B
   ida_nalt.BPU_4B
   ida_nalt.GOTEA_NODE_NAME
   ida_nalt.GOTEA_NODE_IDX
   ida_nalt.get_initial_version


Classes
-------

.. autoapisummary::

   ida_nalt.custom_data_type_ids_fids_array
   ida_nalt.strpath_ids_array
   ida_nalt.array_parameters_t
   ida_nalt.switch_info_t
   ida_nalt.custom_data_type_ids_t
   ida_nalt.refinfo_t
   ida_nalt.strpath_t
   ida_nalt.enum_const_t
   ida_nalt.opinfo_t
   ida_nalt.printop_t


Functions
---------

.. autoapisummary::

   ida_nalt.ea2node
   ida_nalt.node2ea
   ida_nalt.end_ea2node
   ida_nalt.getnode
   ida_nalt.get_strid
   ida_nalt.set_aflags
   ida_nalt.upd_abits
   ida_nalt.set_abits
   ida_nalt.clr_abits
   ida_nalt.get_aflags
   ida_nalt.del_aflags
   ida_nalt.has_aflag_linnum
   ida_nalt.is_aflag_usersp
   ida_nalt.is_aflag_public_name
   ida_nalt.is_aflag_weak_name
   ida_nalt.is_aflag_hidden_item
   ida_nalt.is_aflag_manual_insn
   ida_nalt.is_aflag_hidden_border
   ida_nalt.is_aflag_zstroff
   ida_nalt.is_aflag__bnot0
   ida_nalt.is_aflag__bnot1
   ida_nalt.is_aflag_libitem
   ida_nalt.has_aflag_ti
   ida_nalt.has_aflag_ti0
   ida_nalt.has_aflag_ti1
   ida_nalt.has_aflag_lname
   ida_nalt.is_aflag_tilcmt
   ida_nalt.is_aflag_lzero0
   ida_nalt.is_aflag_lzero1
   ida_nalt.is_aflag_colored_item
   ida_nalt.is_aflag_terse_struc
   ida_nalt.is_aflag__invsign0
   ida_nalt.is_aflag__invsign1
   ida_nalt.is_aflag_noret
   ida_nalt.is_aflag_fixed_spd
   ida_nalt.is_aflag_align_flow
   ida_nalt.is_aflag_userti
   ida_nalt.is_aflag_retfp
   ida_nalt.uses_aflag_modsp
   ida_nalt.is_aflag_notcode
   ida_nalt.is_aflag_notproc
   ida_nalt.is_aflag_type_guessed_by_ida
   ida_nalt.is_aflag_func_guessed_by_hexrays
   ida_nalt.is_aflag_data_guessed_by_hexrays
   ida_nalt.is_aflag_type_determined_by_hexrays
   ida_nalt.is_aflag_type_guessed_by_hexrays
   ida_nalt.is_hidden_item
   ida_nalt.hide_item
   ida_nalt.unhide_item
   ida_nalt.is_hidden_border
   ida_nalt.hide_border
   ida_nalt.unhide_border
   ida_nalt.uses_modsp
   ida_nalt.set_usemodsp
   ida_nalt.clr_usemodsp
   ida_nalt.is_zstroff
   ida_nalt.set_zstroff
   ida_nalt.clr_zstroff
   ida_nalt.is__bnot0
   ida_nalt.set__bnot0
   ida_nalt.clr__bnot0
   ida_nalt.is__bnot1
   ida_nalt.set__bnot1
   ida_nalt.clr__bnot1
   ida_nalt.is_libitem
   ida_nalt.set_libitem
   ida_nalt.clr_libitem
   ida_nalt.has_ti
   ida_nalt.set_has_ti
   ida_nalt.clr_has_ti
   ida_nalt.has_ti0
   ida_nalt.set_has_ti0
   ida_nalt.clr_has_ti0
   ida_nalt.has_ti1
   ida_nalt.set_has_ti1
   ida_nalt.clr_has_ti1
   ida_nalt.has_lname
   ida_nalt.set_has_lname
   ida_nalt.clr_has_lname
   ida_nalt.is_tilcmt
   ida_nalt.set_tilcmt
   ida_nalt.clr_tilcmt
   ida_nalt.is_usersp
   ida_nalt.set_usersp
   ida_nalt.clr_usersp
   ida_nalt.is_lzero0
   ida_nalt.set_lzero0
   ida_nalt.clr_lzero0
   ida_nalt.is_lzero1
   ida_nalt.set_lzero1
   ida_nalt.clr_lzero1
   ida_nalt.is_colored_item
   ida_nalt.set_colored_item
   ida_nalt.clr_colored_item
   ida_nalt.is_terse_struc
   ida_nalt.set_terse_struc
   ida_nalt.clr_terse_struc
   ida_nalt.is__invsign0
   ida_nalt.set__invsign0
   ida_nalt.clr__invsign0
   ida_nalt.is__invsign1
   ida_nalt.set__invsign1
   ida_nalt.clr__invsign1
   ida_nalt.is_noret
   ida_nalt.set_noret
   ida_nalt.clr_noret
   ida_nalt.is_fixed_spd
   ida_nalt.set_fixed_spd
   ida_nalt.clr_fixed_spd
   ida_nalt.is_align_flow
   ida_nalt.set_align_flow
   ida_nalt.clr_align_flow
   ida_nalt.is_userti
   ida_nalt.set_userti
   ida_nalt.clr_userti
   ida_nalt.is_retfp
   ida_nalt.set_retfp
   ida_nalt.clr_retfp
   ida_nalt.is_notproc
   ida_nalt.set_notproc
   ida_nalt.clr_notproc
   ida_nalt.is_type_guessed_by_ida
   ida_nalt.is_func_guessed_by_hexrays
   ida_nalt.is_data_guessed_by_hexrays
   ida_nalt.is_type_determined_by_hexrays
   ida_nalt.is_type_guessed_by_hexrays
   ida_nalt.set_type_guessed_by_ida
   ida_nalt.set_func_guessed_by_hexrays
   ida_nalt.set_data_guessed_by_hexrays
   ida_nalt.set_type_determined_by_hexrays
   ida_nalt.set_notcode
   ida_nalt.clr_notcode
   ida_nalt.is_notcode
   ida_nalt.set_visible_item
   ida_nalt.is_visible_item
   ida_nalt.is_finally_visible_item
   ida_nalt.set_source_linnum
   ida_nalt.get_source_linnum
   ida_nalt.del_source_linnum
   ida_nalt.get_absbase
   ida_nalt.set_absbase
   ida_nalt.del_absbase
   ida_nalt.get_ind_purged
   ida_nalt.del_ind_purged
   ida_nalt.get_str_type
   ida_nalt.set_str_type
   ida_nalt.del_str_type
   ida_nalt.get_str_type_code
   ida_nalt.get_str_term1
   ida_nalt.get_str_term2
   ida_nalt.get_str_encoding_idx
   ida_nalt.set_str_encoding_idx
   ida_nalt.make_str_type
   ida_nalt.is_pascal
   ida_nalt.get_str_type_prefix_length
   ida_nalt.get_alignment
   ida_nalt.set_alignment
   ida_nalt.del_alignment
   ida_nalt.set_item_color
   ida_nalt.get_item_color
   ida_nalt.del_item_color
   ida_nalt.get_array_parameters
   ida_nalt.set_array_parameters
   ida_nalt.del_array_parameters
   ida_nalt.get_switch_info
   ida_nalt.set_switch_info
   ida_nalt.del_switch_info
   ida_nalt.get_switch_parent
   ida_nalt.set_switch_parent
   ida_nalt.del_switch_parent
   ida_nalt.get_custom_data_type_ids
   ida_nalt.set_custom_data_type_ids
   ida_nalt.del_custom_data_type_ids
   ida_nalt.is_reftype_target_optional
   ida_nalt.get_reftype_by_size
   ida_nalt.find_custom_refinfo
   ida_nalt.get_custom_refinfo
   ida_nalt.set_refinfo_ex
   ida_nalt.set_refinfo
   ida_nalt.get_refinfo
   ida_nalt.del_refinfo
   ida_nalt.get_tinfo
   ida_nalt.set_tinfo
   ida_nalt.del_tinfo
   ida_nalt.get_op_tinfo
   ida_nalt.set_op_tinfo
   ida_nalt.del_op_tinfo
   ida_nalt.get_root_filename
   ida_nalt.dbg_get_input_path
   ida_nalt.get_input_file_path
   ida_nalt.set_root_filename
   ida_nalt.retrieve_input_file_size
   ida_nalt.retrieve_input_file_crc32
   ida_nalt.retrieve_input_file_md5
   ida_nalt.retrieve_input_file_sha256
   ida_nalt.get_asm_inc_file
   ida_nalt.set_asm_inc_file
   ida_nalt.get_imagebase
   ida_nalt.set_imagebase
   ida_nalt.get_ids_modnode
   ida_nalt.set_ids_modnode
   ida_nalt.get_archive_path
   ida_nalt.set_archive_path
   ida_nalt.get_loader_format_name
   ida_nalt.set_loader_format_name
   ida_nalt.get_initial_ida_version
   ida_nalt.get_ida_notepad_text
   ida_nalt.set_ida_notepad_text
   ida_nalt.get_srcdbg_paths
   ida_nalt.set_srcdbg_paths
   ida_nalt.get_srcdbg_undesired_paths
   ida_nalt.set_srcdbg_undesired_paths
   ida_nalt.get_initial_idb_version
   ida_nalt.get_idb_ctime
   ida_nalt.get_elapsed_secs
   ida_nalt.get_idb_nopens
   ida_nalt.get_encoding_qty
   ida_nalt.get_encoding_name
   ida_nalt.add_encoding
   ida_nalt.del_encoding
   ida_nalt.rename_encoding
   ida_nalt.get_encoding_bpu
   ida_nalt.get_encoding_bpu_by_name
   ida_nalt.get_strtype_bpu
   ida_nalt.get_default_encoding_idx
   ida_nalt.set_default_encoding_idx
   ida_nalt.encoding_from_strtype
   ida_nalt.get_outfile_encoding_idx
   ida_nalt.set_outfile_encoding_idx
   ida_nalt.get_import_module_qty
   ida_nalt.delete_imports
   ida_nalt.set_gotea
   ida_nalt.get_gotea
   ida_nalt.get_import_module_name
   ida_nalt.enum_import_names
   ida_nalt.switch_info_t__from_ptrval__
   ida_nalt.get_switch_info
   ida_nalt.get_abi_name


Module Contents
---------------

.. py:class:: custom_data_type_ids_fids_array(data: short (&)[8])

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  short (&)[8]


   .. py:attribute:: bytes


.. py:class:: strpath_ids_array(data: unsigned long long (&)[32])

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  unsigned long long (&)[32]


   .. py:attribute:: bytes


.. py:data:: NALT_SWITCH

   switch idiom address (used at jump targets)


.. py:data:: NALT_STRUCT

   struct id


.. py:data:: NALT_AFLAGS

   additional flags for an item


.. py:data:: NALT_LINNUM

   source line number


.. py:data:: NALT_ABSBASE

   absolute segment location


.. py:data:: NALT_ENUM0

   enum id for the first operand


.. py:data:: NALT_ENUM1

   enum id for the second operand


.. py:data:: NALT_PURGE

   number of bytes purged from the stack when a function is called indirectly


.. py:data:: NALT_STRTYPE

   type of string item


.. py:data:: NALT_ALIGN

   alignment value if the item is FF_ALIGN (should by equal to power of 2) 
           


.. py:data:: NALT_COLOR

   instruction/data background color


.. py:data:: NSUP_CMT

   regular comment


.. py:data:: NSUP_REPCMT

   repeatable comment


.. py:data:: NSUP_FOP1

   forced operand 1


.. py:data:: NSUP_FOP2

   forced operand 2


.. py:data:: NSUP_JINFO

   jump table info


.. py:data:: NSUP_ARRAY

   array parameters


.. py:data:: NSUP_OMFGRP

   OMF: group of segments (not used anymore)


.. py:data:: NSUP_FOP3

   forced operand 3


.. py:data:: NSUP_SWITCH

   switch information


.. py:data:: NSUP_REF0

   complex reference information for operand 1


.. py:data:: NSUP_REF1

   complex reference information for operand 2


.. py:data:: NSUP_REF2

   complex reference information for operand 3


.. py:data:: NSUP_OREF0

   outer complex reference information for operand 1


.. py:data:: NSUP_OREF1

   outer complex reference information for operand 2


.. py:data:: NSUP_OREF2

   outer complex reference information for operand 3


.. py:data:: NSUP_STROFF0

   stroff: struct path for the first operand


.. py:data:: NSUP_STROFF1

   stroff: struct path for the second operand


.. py:data:: NSUP_SEGTRANS

   segment translations


.. py:data:: NSUP_FOP4

   forced operand 4


.. py:data:: NSUP_FOP5

   forced operand 5


.. py:data:: NSUP_FOP6

   forced operand 6


.. py:data:: NSUP_REF3

   complex reference information for operand 4


.. py:data:: NSUP_REF4

   complex reference information for operand 5


.. py:data:: NSUP_REF5

   complex reference information for operand 6


.. py:data:: NSUP_OREF3

   outer complex reference information for operand 4


.. py:data:: NSUP_OREF4

   outer complex reference information for operand 5


.. py:data:: NSUP_OREF5

   outer complex reference information for operand 6


.. py:data:: NSUP_XREFPOS

   saved xref address and type in the xrefs window


.. py:data:: NSUP_CUSTDT

   custom data type id


.. py:data:: NSUP_GROUPS

   SEG_GRP: pack_dd encoded list of selectors.


.. py:data:: NSUP_ARGEAS

   instructions that initialize call arguments


.. py:data:: NSUP_FOP7

   forced operand 7


.. py:data:: NSUP_FOP8

   forced operand 8


.. py:data:: NSUP_REF6

   complex reference information for operand 7


.. py:data:: NSUP_REF7

   complex reference information for operand 8


.. py:data:: NSUP_OREF6

   outer complex reference information for operand 7


.. py:data:: NSUP_OREF7

   outer complex reference information for operand 8


.. py:data:: NSUP_EX_FLAGS

   Extended flags.


.. py:data:: NSUP_POINTS

   SP change points blob (see funcs.cpp). values NSUP_POINTS..NSUP_POINTS+0x1000 are reserved 
           


.. py:data:: NSUP_MANUAL

   manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are reserved 
           


.. py:data:: NSUP_TYPEINFO

   type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are reserved 
           


.. py:data:: NSUP_REGVAR

   register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are reserved 
           


.. py:data:: NSUP_LLABEL

   local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved 
           


.. py:data:: NSUP_REGARG

   register argument type/name descriptions values NSUP_REGARG..NSUP_REGARG+0x1000 are reserved 
           


.. py:data:: NSUP_FTAILS

   function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000 are reserved 
           


.. py:data:: NSUP_GROUP

   graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are reserved 
           


.. py:data:: NSUP_OPTYPES

   operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000 are reserved 
           


.. py:data:: NSUP_ORIGFMD

   function metadata before lumina information was applied values NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved 
           


.. py:data:: NSUP_FRAME

   function frame type values NSUP_FRAME..NSUP_FRAME+0x10000 are reserved 
           


.. py:data:: NALT_CREF_TO

   code xref to, idx: target address


.. py:data:: NALT_CREF_FROM

   code xref from, idx: source address


.. py:data:: NALT_DREF_TO

   data xref to, idx: target address


.. py:data:: NALT_DREF_FROM

   data xref from, idx: source address


.. py:data:: NSUP_GR_INFO

   group node info: color, ea, text


.. py:data:: NALT_GR_LAYX

   group layout ptrs, hash: md5 of 'belongs'


.. py:data:: NSUP_GR_LAYT

   group layouts, idx: layout pointer


.. py:data:: PATCH_TAG

   Patch netnode tag.


.. py:data:: IDB_DESKTOPS_NODE_NAME

   hash indexed by desktop name with dekstop netnode


.. py:data:: IDB_DESKTOPS_TAG

   tag to store desktop blob & timestamp


.. py:function:: ea2node(ea: ida_idaapi.ea_t) -> nodeidx_t

   Get netnode for the specified address.


.. py:function:: node2ea(ndx: nodeidx_t) -> ida_idaapi.ea_t

.. py:function:: end_ea2node(ea: ida_idaapi.ea_t) -> nodeidx_t

.. py:function:: getnode(ea: ida_idaapi.ea_t) -> netnode

.. py:function:: get_strid(ea: ida_idaapi.ea_t) -> tid_t

.. py:data:: AFL_LINNUM

   has line number info


.. py:data:: AFL_USERSP

   user-defined SP value


.. py:data:: AFL_PUBNAM

   name is public (inter-file linkage)


.. py:data:: AFL_WEAKNAM

   name is weak


.. py:data:: AFL_HIDDEN

   the item is hidden completely


.. py:data:: AFL_MANUAL

   the instruction/data is specified by the user


.. py:data:: AFL_NOBRD

   the code/data border is hidden


.. py:data:: AFL_ZSTROFF

   display struct field name at 0 offset when displaying an offset. example: `offset somestruct.field_0 ` if this flag is clear, then `offset somestruct ` 
           


.. py:data:: AFL_BNOT0

   the 1st operand is bitwise negated


.. py:data:: AFL_BNOT1

   the 2nd operand is bitwise negated


.. py:data:: AFL_LIB

   item from the standard library. low level flag, is used to set FUNC_LIB of func_t 
           


.. py:data:: AFL_TI

   has typeinfo? (NSUP_TYPEINFO); used only for addresses, not for member_t


.. py:data:: AFL_TI0

   has typeinfo for operand 0? (NSUP_OPTYPES)


.. py:data:: AFL_TI1

   has typeinfo for operand 1? (NSUP_OPTYPES+1)


.. py:data:: AFL_LNAME

   has local name too (FF_NAME should be set)


.. py:data:: AFL_TILCMT

   has type comment? (such a comment may be changed by IDA)


.. py:data:: AFL_LZERO0

   toggle leading zeroes for the 1st operand


.. py:data:: AFL_LZERO1

   toggle leading zeroes for the 2nd operand


.. py:data:: AFL_COLORED

   has user defined instruction color?


.. py:data:: AFL_TERSESTR

   terse structure variable display?


.. py:data:: AFL_SIGN0

   code: toggle sign of the 1st operand


.. py:data:: AFL_SIGN1

   code: toggle sign of the 2nd operand


.. py:data:: AFL_NORET

   for imported function pointers: doesn't return. this flag can also be used for any instruction which halts or finishes the program execution 
           


.. py:data:: AFL_FIXEDSPD

   sp delta value is fixed by analysis. should not be modified by modules 
           


.. py:data:: AFL_ALIGNFLOW

   the previous insn was created for alignment purposes only


.. py:data:: AFL_USERTI

   the type information is definitive. (comes from the user or type library) if not set see AFL_TYPE_GUESSED 
           


.. py:data:: AFL_RETFP

   function returns a floating point value


.. py:data:: AFL_USEMODSP

   insn modifes SP and uses the modified value; example: pop [rsp+N] 
           


.. py:data:: AFL_NOTCODE

   autoanalysis should not create code here


.. py:data:: AFL_NOTPROC

   autoanalysis should not create proc here


.. py:data:: AFL_TYPE_GUESSED

   who guessed the type information?


.. py:data:: AFL_IDA_GUESSED

   the type is guessed by IDA


.. py:data:: AFL_HR_GUESSED_FUNC

   the function type is guessed by the decompiler


.. py:data:: AFL_HR_GUESSED_DATA

   the data type is guessed by the decompiler


.. py:data:: AFL_HR_DETERMINED

   the type is definitely guessed by the decompiler


.. py:function:: set_aflags(ea: ida_idaapi.ea_t, flags: aflags_t) -> None

.. py:function:: upd_abits(ea: ida_idaapi.ea_t, clr_bits: aflags_t, set_bits: aflags_t) -> None

.. py:function:: set_abits(ea: ida_idaapi.ea_t, bits: aflags_t) -> None

.. py:function:: clr_abits(ea: ida_idaapi.ea_t, bits: aflags_t) -> None

.. py:function:: get_aflags(ea: ida_idaapi.ea_t) -> aflags_t

.. py:function:: del_aflags(ea: ida_idaapi.ea_t) -> None

.. py:function:: has_aflag_linnum(flags: aflags_t) -> bool

.. py:function:: is_aflag_usersp(flags: aflags_t) -> bool

.. py:function:: is_aflag_public_name(flags: aflags_t) -> bool

.. py:function:: is_aflag_weak_name(flags: aflags_t) -> bool

.. py:function:: is_aflag_hidden_item(flags: aflags_t) -> bool

.. py:function:: is_aflag_manual_insn(flags: aflags_t) -> bool

.. py:function:: is_aflag_hidden_border(flags: aflags_t) -> bool

.. py:function:: is_aflag_zstroff(flags: aflags_t) -> bool

.. py:function:: is_aflag__bnot0(flags: aflags_t) -> bool

.. py:function:: is_aflag__bnot1(flags: aflags_t) -> bool

.. py:function:: is_aflag_libitem(flags: aflags_t) -> bool

.. py:function:: has_aflag_ti(flags: aflags_t) -> bool

.. py:function:: has_aflag_ti0(flags: aflags_t) -> bool

.. py:function:: has_aflag_ti1(flags: aflags_t) -> bool

.. py:function:: has_aflag_lname(flags: aflags_t) -> bool

.. py:function:: is_aflag_tilcmt(flags: aflags_t) -> bool

.. py:function:: is_aflag_lzero0(flags: aflags_t) -> bool

.. py:function:: is_aflag_lzero1(flags: aflags_t) -> bool

.. py:function:: is_aflag_colored_item(flags: aflags_t) -> bool

.. py:function:: is_aflag_terse_struc(flags: aflags_t) -> bool

.. py:function:: is_aflag__invsign0(flags: aflags_t) -> bool

.. py:function:: is_aflag__invsign1(flags: aflags_t) -> bool

.. py:function:: is_aflag_noret(flags: aflags_t) -> bool

.. py:function:: is_aflag_fixed_spd(flags: aflags_t) -> bool

.. py:function:: is_aflag_align_flow(flags: aflags_t) -> bool

.. py:function:: is_aflag_userti(flags: aflags_t) -> bool

.. py:function:: is_aflag_retfp(flags: aflags_t) -> bool

.. py:function:: uses_aflag_modsp(flags: aflags_t) -> bool

.. py:function:: is_aflag_notcode(flags: aflags_t) -> bool

.. py:function:: is_aflag_notproc(flags: aflags_t) -> bool

.. py:function:: is_aflag_type_guessed_by_ida(flags: aflags_t) -> bool

.. py:function:: is_aflag_func_guessed_by_hexrays(flags: aflags_t) -> bool

.. py:function:: is_aflag_data_guessed_by_hexrays(flags: aflags_t) -> bool

.. py:function:: is_aflag_type_determined_by_hexrays(flags: aflags_t) -> bool

.. py:function:: is_aflag_type_guessed_by_hexrays(flags: aflags_t) -> bool

.. py:function:: is_hidden_item(ea: ida_idaapi.ea_t) -> bool

.. py:function:: hide_item(ea: ida_idaapi.ea_t) -> None

.. py:function:: unhide_item(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_hidden_border(ea: ida_idaapi.ea_t) -> bool

.. py:function:: hide_border(ea: ida_idaapi.ea_t) -> None

.. py:function:: unhide_border(ea: ida_idaapi.ea_t) -> None

.. py:function:: uses_modsp(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_usemodsp(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_usemodsp(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_zstroff(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_zstroff(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_zstroff(ea: ida_idaapi.ea_t) -> None

.. py:function:: is__bnot0(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set__bnot0(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr__bnot0(ea: ida_idaapi.ea_t) -> None

.. py:function:: is__bnot1(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set__bnot1(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr__bnot1(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_libitem(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_libitem(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_libitem(ea: ida_idaapi.ea_t) -> None

.. py:function:: has_ti(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_has_ti(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_has_ti(ea: ida_idaapi.ea_t) -> None

.. py:function:: has_ti0(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_has_ti0(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_has_ti0(ea: ida_idaapi.ea_t) -> None

.. py:function:: has_ti1(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_has_ti1(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_has_ti1(ea: ida_idaapi.ea_t) -> None

.. py:function:: has_lname(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_has_lname(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_has_lname(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_tilcmt(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_tilcmt(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_tilcmt(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_usersp(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_usersp(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_usersp(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_lzero0(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_lzero0(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_lzero0(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_lzero1(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_lzero1(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_lzero1(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_colored_item(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_colored_item(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_colored_item(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_terse_struc(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_terse_struc(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_terse_struc(ea: ida_idaapi.ea_t) -> None

.. py:function:: is__invsign0(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set__invsign0(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr__invsign0(ea: ida_idaapi.ea_t) -> None

.. py:function:: is__invsign1(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set__invsign1(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr__invsign1(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_noret(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_noret(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_noret(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_fixed_spd(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_fixed_spd(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_fixed_spd(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_align_flow(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_align_flow(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_align_flow(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_userti(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_userti(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_userti(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_retfp(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_retfp(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_retfp(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_notproc(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_notproc(ea: ida_idaapi.ea_t) -> None

.. py:function:: clr_notproc(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_type_guessed_by_ida(ea: ida_idaapi.ea_t) -> bool

.. py:function:: is_func_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool

.. py:function:: is_data_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool

.. py:function:: is_type_determined_by_hexrays(ea: ida_idaapi.ea_t) -> bool

.. py:function:: is_type_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_type_guessed_by_ida(ea: ida_idaapi.ea_t) -> None

.. py:function:: set_func_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> None

.. py:function:: set_data_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> None

.. py:function:: set_type_determined_by_hexrays(ea: ida_idaapi.ea_t) -> None

.. py:function:: set_notcode(ea: ida_idaapi.ea_t) -> None

   Mark address so that it cannot be converted to instruction.


.. py:function:: clr_notcode(ea: ida_idaapi.ea_t) -> None

   Clear not-code mark.


.. py:function:: is_notcode(ea: ida_idaapi.ea_t) -> bool

   Is the address marked as not-code?


.. py:function:: set_visible_item(ea: ida_idaapi.ea_t, visible: bool) -> None

   Change visibility of item at given ea.


.. py:function:: is_visible_item(ea: ida_idaapi.ea_t) -> bool

   Test visibility of item at given ea.


.. py:function:: is_finally_visible_item(ea: ida_idaapi.ea_t) -> bool

   Is instruction visible?


.. py:function:: set_source_linnum(ea: ida_idaapi.ea_t, lnnum: int) -> None

.. py:function:: get_source_linnum(ea: ida_idaapi.ea_t) -> int

.. py:function:: del_source_linnum(ea: ida_idaapi.ea_t) -> None

.. py:function:: get_absbase(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: set_absbase(ea: ida_idaapi.ea_t, x: ida_idaapi.ea_t) -> None

.. py:function:: del_absbase(ea: ida_idaapi.ea_t) -> None

.. py:function:: get_ind_purged(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: del_ind_purged(ea: ida_idaapi.ea_t) -> None

.. py:function:: get_str_type(ea: ida_idaapi.ea_t) -> int

.. py:function:: set_str_type(ea: ida_idaapi.ea_t, x: int) -> None

.. py:function:: del_str_type(ea: ida_idaapi.ea_t) -> None

.. py:data:: STRWIDTH_1B

.. py:data:: STRWIDTH_2B

.. py:data:: STRWIDTH_4B

.. py:data:: STRWIDTH_MASK

.. py:data:: STRLYT_TERMCHR

.. py:data:: STRLYT_PASCAL1

.. py:data:: STRLYT_PASCAL2

.. py:data:: STRLYT_PASCAL4

.. py:data:: STRLYT_MASK

.. py:data:: STRLYT_SHIFT

.. py:data:: STRTYPE_TERMCHR

   C-style string.


.. py:data:: STRTYPE_C

   Zero-terminated 16bit chars.


.. py:data:: STRTYPE_C_16

   Zero-terminated 32bit chars.


.. py:data:: STRTYPE_C_32

   Pascal-style, one-byte length prefix.


.. py:data:: STRTYPE_PASCAL

   Pascal-style, 16bit chars, one-byte length prefix.


.. py:data:: STRTYPE_PASCAL_16

   Pascal-style, 32bit chars, one-byte length prefix.


.. py:data:: STRTYPE_PASCAL_32

   Pascal-style, two-byte length prefix.


.. py:data:: STRTYPE_LEN2

   Pascal-style, 16bit chars, two-byte length prefix.


.. py:data:: STRTYPE_LEN2_16

   Pascal-style, 32bit chars, two-byte length prefix.


.. py:data:: STRTYPE_LEN2_32

   Pascal-style, four-byte length prefix.


.. py:data:: STRTYPE_LEN4

   Pascal-style, 16bit chars, four-byte length prefix.


.. py:data:: STRTYPE_LEN4_16

   Pascal-style, 32bit chars, four-byte length prefix.


.. py:data:: STRTYPE_LEN4_32

.. py:function:: get_str_type_code(strtype: int) -> uchar

.. py:function:: get_str_term1(strtype: int) -> char

.. py:function:: get_str_term2(strtype: int) -> char

.. py:function:: get_str_encoding_idx(strtype: int) -> uchar

.. py:function:: set_str_encoding_idx(strtype: int, encoding_idx: int) -> int

.. py:function:: make_str_type(type_code: uchar, encoding_idx: int, term1: uchar = 0, term2: uchar = 0) -> int

.. py:function:: is_pascal(strtype: int) -> bool

.. py:function:: get_str_type_prefix_length(strtype: int) -> size_t

.. py:data:: STRENC_DEFAULT

   use default encoding for this type (see get_default_encoding_idx())


.. py:data:: STRENC_NONE

   force no-conversion encoding


.. py:function:: get_alignment(ea: ida_idaapi.ea_t) -> int

.. py:function:: set_alignment(ea: ida_idaapi.ea_t, x: int) -> None

.. py:function:: del_alignment(ea: ida_idaapi.ea_t) -> None

.. py:function:: set_item_color(ea: ida_idaapi.ea_t, color: bgcolor_t) -> None

.. py:function:: get_item_color(ea: ida_idaapi.ea_t) -> bgcolor_t

.. py:function:: del_item_color(ea: ida_idaapi.ea_t) -> bool

.. py:class:: array_parameters_t(_f: int = 1, _l: int = 0, _a: int = -1)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int


   .. py:attribute:: lineitems
      :type:  int

      number of items on a line



   .. py:attribute:: alignment
      :type:  int

      -1 - don't align. 0 - align automatically. else item width 
              



   .. py:method:: is_default() -> bool


.. py:data:: AP_ALLOWDUPS

   use 'dup' construct


.. py:data:: AP_SIGNED

   treats numbers as signed


.. py:data:: AP_INDEX

   display array element indexes as comments


.. py:data:: AP_ARRAY

   create as array (this flag is not stored in database)


.. py:data:: AP_IDXBASEMASK

   mask for number base of the indexes


.. py:data:: AP_IDXDEC

   display indexes in decimal


.. py:data:: AP_IDXHEX

   display indexes in hex


.. py:data:: AP_IDXOCT

   display indexes in octal


.. py:data:: AP_IDXBIN

   display indexes in binary


.. py:function:: get_array_parameters(out: array_parameters_t, ea: ida_idaapi.ea_t) -> ssize_t

.. py:function:: set_array_parameters(ea: ida_idaapi.ea_t, _in: array_parameters_t) -> None

.. py:function:: del_array_parameters(ea: ida_idaapi.ea_t) -> None

.. py:class:: switch_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int

      Switch info flags 
              



   .. py:method:: get_shift() -> int

      See SWI_SHIFT_MASK. possible answers: 0..3. 
              



   .. py:method:: set_shift(shift: int) -> None

      See SWI_SHIFT_MASK.



   .. py:method:: get_jtable_element_size() -> int


   .. py:method:: set_jtable_element_size(size: int) -> None


   .. py:method:: get_vtable_element_size() -> int


   .. py:method:: set_vtable_element_size(size: int) -> None


   .. py:method:: has_default() -> bool


   .. py:method:: has_elbase() -> bool


   .. py:method:: is_sparse() -> bool


   .. py:method:: is_custom() -> bool


   .. py:method:: is_indirect() -> bool


   .. py:method:: is_subtract() -> bool


   .. py:method:: is_nolowcase() -> bool


   .. py:method:: use_std_table() -> bool


   .. py:method:: is_user_defined() -> bool


   .. py:attribute:: ncases
      :type:  ushort

      number of cases (excluding default)



   .. py:attribute:: jumps
      :type:  ida_idaapi.ea_t

      jump table start address



   .. py:attribute:: values
      :type:  ida_idaapi.ea_t

      values table address (if SWI_SPARSE is set)



   .. py:attribute:: lowcase
      :type:  int

      the lowest value in cases



   .. py:attribute:: defjump
      :type:  ida_idaapi.ea_t

      default jump address (BADADDR if no default case)



   .. py:attribute:: startea
      :type:  ida_idaapi.ea_t

      start of the switch idiom



   .. py:attribute:: jcases
      :type:  int

      number of entries in the jump table (SWI_INDIRECT)



   .. py:attribute:: ind_lowcase
      :type:  int


   .. py:method:: get_lowcase() -> int


   .. py:attribute:: elbase
      :type:  ida_idaapi.ea_t

      element base



   .. py:attribute:: regnum
      :type:  int

      the switch expression as a value of the REGNUM register before the instruction at EXPR_EA. -1 means 'unknown' 
              



   .. py:attribute:: regdtype
      :type:  op_dtype_t

      size of the switch expression register as dtype



   .. py:method:: get_jtable_size() -> int


   .. py:method:: set_jtable_size(size: int) -> None


   .. py:method:: set_elbase(base: ida_idaapi.ea_t) -> None


   .. py:method:: set_expr(r: int, dt: op_dtype_t) -> None


   .. py:method:: get_jrange_vrange(jrange: range_t = None, vrange: range_t = None) -> bool

      get separate parts of the switch



   .. py:attribute:: custom
      :type:  int

      information for custom tables (filled and used by modules)



   .. py:attribute:: SWITCH_INFO_VERSION


   .. py:method:: get_version() -> int


   .. py:attribute:: expr_ea
      :type:  ida_idaapi.ea_t

      the address before that the switch expression is in REGNUM. If BADADDR, then the first insn marked as IM_SWITCH after STARTEA is used. 
              



   .. py:attribute:: marks
      :type:  eavec_t

      the insns marked as IM_SWITCH. They are used to delete the switch.



   .. py:method:: clear() -> None


   .. py:method:: assign(other: switch_info_t) -> None


.. py:data:: SWI_SPARSE

   sparse switch (value table present), otherwise lowcase present 
           


.. py:data:: SWI_V32

   32-bit values in table


.. py:data:: SWI_J32

   32-bit jump offsets


.. py:data:: SWI_VSPLIT

   value table is split (only for 32-bit values)


.. py:data:: SWI_USER

   user specified switch (starting from version 2)


.. py:data:: SWI_DEF_IN_TBL

   default case is an entry in the jump table. This flag is applicable in 2 cases:
   * The sparse indirect switch (i.e. a switch with a values table) {jump table size} == {value table size} + 1. The default case entry is the last one in the table (or the first one in the case of an inversed jump table).
   * The switch with insns in the jump table. The default case entry is before the first entry of the table. 
    See also the find_defjump_from_table() helper function. 


           


.. py:data:: SWI_JMP_INV

   jumptable is inversed. (last entry is for first entry in values table) 
           


.. py:data:: SWI_SHIFT_MASK

   use formula (element<<shift) + elbase to find jump targets


.. py:data:: SWI_ELBASE

   elbase is present (otherwise the base of the switch segment will be used) 
           


.. py:data:: SWI_JSIZE

   jump offset expansion bit


.. py:data:: SWI_VSIZE

   value table element size expansion bit


.. py:data:: SWI_SEPARATE

   create an array of individual elements (otherwise separate items)


.. py:data:: SWI_SIGNED

   jump table entries are signed


.. py:data:: SWI_CUSTOM

   custom jump table. processor_t::create_switch_xrefs will be called to create code xrefs for the table. Custom jump table must be created by the module (see also SWI_STDTBL) 
           


.. py:data:: SWI_INDIRECT

   value table elements are used as indexes into the jump table (for sparse switches) 
           


.. py:data:: SWI_SUBTRACT

   table values are subtracted from the elbase instead of being added


.. py:data:: SWI_HXNOLOWCASE

   lowcase value should not be used by the decompiler (internal flag)


.. py:data:: SWI_STDTBL

   custom jump table with standard table formatting. ATM IDA doesn't use SWI_CUSTOM for switches with standard table formatting. So this flag can be considered as obsolete. 
           


.. py:data:: SWI_DEFRET

   return in the default case (defjump==BADADDR)


.. py:data:: SWI_SELFREL

   jump address is relative to the element not to ELBASE


.. py:data:: SWI_JMPINSN

   jump table entries are insns. For such entries SHIFT has a different meaning. It denotes the number of insns in the entry. For example, 0 - the entry contains the jump to the case, 1 - the entry contains one insn like a 'mov' and jump to the end of case, and so on. 
           


.. py:data:: SWI_VERSION

   the structure contains the VERSION member


.. py:function:: get_switch_info(out: switch_info_t, ea: ida_idaapi.ea_t) -> ssize_t

.. py:function:: set_switch_info(ea: ida_idaapi.ea_t, _in: switch_info_t) -> None

.. py:function:: del_switch_info(ea: ida_idaapi.ea_t) -> None

.. py:function:: get_switch_parent(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: set_switch_parent(ea: ida_idaapi.ea_t, x: ida_idaapi.ea_t) -> None

.. py:function:: del_switch_parent(ea: ida_idaapi.ea_t) -> None

.. py:class:: custom_data_type_ids_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: dtid
      :type:  int16

      data type id



   .. py:attribute:: fids
      :type:  int16 [8]

      data format ids



   .. py:method:: set(tid: tid_t) -> None


   .. py:method:: get_dtid() -> tid_t


.. py:function:: get_custom_data_type_ids(cdis: custom_data_type_ids_t, ea: ida_idaapi.ea_t) -> int

.. py:function:: set_custom_data_type_ids(ea: ida_idaapi.ea_t, cdis: custom_data_type_ids_t) -> None

.. py:function:: del_custom_data_type_ids(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_reftype_target_optional(type: reftype_t) -> bool

   Can the target be calculated using operand value?


.. py:function:: get_reftype_by_size(size: size_t) -> reftype_t

   Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other sizes returns reftype_t(-1) 
           


.. py:class:: refinfo_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: target
      :type:  ida_idaapi.ea_t

      reference target (BADADDR-none)



   .. py:attribute:: base
      :type:  ida_idaapi.ea_t

      base of reference (may be BADADDR)



   .. py:attribute:: tdelta
      :type:  adiff_t

      offset from the target



   .. py:attribute:: flags
      :type:  int

      Reference info flags 
              



   .. py:method:: type() -> reftype_t


   .. py:method:: is_target_optional() -> bool

      < is_reftype_target_optional()



   .. py:method:: no_base_xref() -> bool


   .. py:method:: is_pastend() -> bool


   .. py:method:: is_rvaoff() -> bool


   .. py:method:: is_custom() -> bool


   .. py:method:: is_subtract() -> bool


   .. py:method:: is_signed() -> bool


   .. py:method:: is_no_zeros() -> bool


   .. py:method:: is_no_ones() -> bool


   .. py:method:: is_selfref() -> bool


   .. py:method:: set_type(rt: reftype_t) -> None


   .. py:method:: init(*args) -> None


.. py:data:: cvar

.. py:data:: V695_REF_OFF8

   reserved


.. py:data:: REF_OFF16

   16bit full offset


.. py:data:: REF_OFF32

   32bit full offset


.. py:data:: REF_LOW8

   low 8bits of 16bit offset


.. py:data:: REF_LOW16

   low 16bits of 32bit offset


.. py:data:: REF_HIGH8

   high 8bits of 16bit offset


.. py:data:: REF_HIGH16

   high 16bits of 32bit offset


.. py:data:: V695_REF_VHIGH

   obsolete


.. py:data:: V695_REF_VLOW

   obsolete


.. py:data:: REF_OFF64

   64bit full offset


.. py:data:: REF_OFF8

   8bit full offset


.. py:data:: REF_LAST

.. py:data:: REFINFO_TYPE

   reference type (reftype_t), or custom reference ID if REFINFO_CUSTOM set 
           


.. py:data:: REFINFO_RVAOFF

   based reference (rva); refinfo_t::base will be forced to get_imagebase(); such a reference is displayed with the asm_t::a_rva keyword 
           


.. py:data:: REFINFO_PASTEND

   reference past an item; it may point to an nonexistent address; do not destroy alignment dirs 
           


.. py:data:: REFINFO_CUSTOM

   a custom reference. see custom_refinfo_handler_t. the id of the custom refinfo is stored under the REFINFO_TYPE mask. 
           


.. py:data:: REFINFO_NOBASE

   don't create the base xref; implies that the base can be any value. nb: base xrefs are created only if the offset base points to the middle of a segment 
           


.. py:data:: REFINFO_SUBTRACT

   the reference value is subtracted from the base value instead of (as usual) being added to it


.. py:data:: REFINFO_SIGNEDOP

   the operand value is sign-extended (only supported for REF_OFF8/16/32/64)


.. py:data:: REFINFO_NO_ZEROS

   an opval of 0 will be considered invalid


.. py:data:: REFINFO_NO_ONES

   an opval of ~0 will be considered invalid


.. py:data:: REFINFO_SELFREF

   the self-based reference; refinfo_t::base will be forced to the reference address 
           


.. py:function:: find_custom_refinfo(name: str) -> int

   Get id of a custom refinfo type.


.. py:function:: get_custom_refinfo(crid: int) -> custom_refinfo_handler_t const *

   Get definition of a registered custom refinfo type.


.. py:data:: MAXSTRUCPATH

   maximal inclusion depth of unions


.. py:class:: strpath_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: len
      :type:  int


   .. py:attribute:: ids
      :type:  tid_t [32]


   .. py:attribute:: delta
      :type:  adiff_t


.. py:class:: enum_const_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: tid
      :type:  tid_t


   .. py:attribute:: serial
      :type:  uchar


.. py:class:: opinfo_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ri
      :type:  refinfo_t

      for offset members



   .. py:attribute:: tid
      :type:  tid_t

      for struct, etc. members



   .. py:attribute:: path
      :type:  strpath_t

      for stroff



   .. py:attribute:: strtype
      :type:  int

      for strings (String type codes)



   .. py:attribute:: ec
      :type:  enum_const_t

      for enums



   .. py:attribute:: cd
      :type:  custom_data_type_ids_t

      for custom data



.. py:class:: printop_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ti
      :type:  opinfo_t


   .. py:attribute:: features
      :type:  uchar


   .. py:attribute:: suspop
      :type:  int


   .. py:attribute:: aflags
      :type:  aflags_t


   .. py:attribute:: flags
      :type:  flags64_t


   .. py:method:: is_ti_initialized() -> bool


   .. py:method:: set_ti_initialized(v: bool = True) -> None


   .. py:method:: is_aflags_initialized() -> bool


   .. py:method:: set_aflags_initialized(v: bool = True) -> None


   .. py:method:: is_f64() -> bool


   .. py:method:: get_ti() -> opinfo_t const *


   .. py:attribute:: is_ti_valid


.. py:data:: POF_VALID_TI

.. py:data:: POF_VALID_AFLAGS

.. py:data:: POF_IS_F64

.. py:function:: set_refinfo_ex(ea: ida_idaapi.ea_t, n: int, ri: refinfo_t) -> bool

.. py:function:: set_refinfo(*args) -> bool

.. py:function:: get_refinfo(ri: refinfo_t, ea: ida_idaapi.ea_t, n: int) -> bool

.. py:function:: del_refinfo(ea: ida_idaapi.ea_t, n: int) -> bool

.. py:function:: get_tinfo(tif: tinfo_t, ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_tinfo(ea: ida_idaapi.ea_t, tif: tinfo_t) -> bool

.. py:function:: del_tinfo(ea: ida_idaapi.ea_t) -> None

.. py:function:: get_op_tinfo(tif: tinfo_t, ea: ida_idaapi.ea_t, n: int) -> bool

.. py:function:: set_op_tinfo(ea: ida_idaapi.ea_t, n: int, tif: tinfo_t) -> bool

.. py:function:: del_op_tinfo(ea: ida_idaapi.ea_t, n: int) -> None

.. py:data:: RIDX_FILE_FORMAT_NAME

   file format name for loader modules


.. py:data:: RIDX_SELECTORS

   2..63 are for selector_t blob (see init_selectors())


.. py:data:: RIDX_GROUPS

   segment group information (see init_groups())


.. py:data:: RIDX_H_PATH

   C header path.


.. py:data:: RIDX_C_MACROS

   C predefined macros.


.. py:data:: RIDX_SMALL_IDC_OLD

   Instant IDC statements (obsolete)


.. py:data:: RIDX_NOTEPAD

   notepad blob, occupies 1000 indexes (1MB of text)


.. py:data:: RIDX_INCLUDE

   assembler include file name


.. py:data:: RIDX_SMALL_IDC

   Instant IDC statements, blob.


.. py:data:: RIDX_DUALOP_GRAPH

   Graph text representation options.


.. py:data:: RIDX_DUALOP_TEXT

   Text text representation options.


.. py:data:: RIDX_MD5

   MD5 of the input file.


.. py:data:: RIDX_IDA_VERSION

   version of ida which created the database


.. py:data:: RIDX_STR_ENCODINGS

   a list of encodings for the program strings


.. py:data:: RIDX_SRCDBG_PATHS

   source debug paths, occupies 20 indexes


.. py:data:: RIDX_DBG_BINPATHS

   unused (20 indexes)


.. py:data:: RIDX_SHA256

   SHA256 of the input file.


.. py:data:: RIDX_ABINAME

   ABI name (processor specific)


.. py:data:: RIDX_ARCHIVE_PATH

   archive file path


.. py:data:: RIDX_PROBLEMS

   problem lists


.. py:data:: RIDX_SRCDBG_UNDESIRED

   user-closed source files, occupies 20 indexes


.. py:function:: get_root_filename() -> str

   Get file name only of the input file.


.. py:function:: dbg_get_input_path() -> str

   Get debugger input file name/path (see LFLG_DBG_NOPATH)


.. py:function:: get_input_file_path() -> str

   Get full path of the input file.


.. py:function:: set_root_filename(file: str) -> None

   Set full path of the input file.


.. py:function:: retrieve_input_file_size() -> size_t

   Get size of input file in bytes.


.. py:function:: retrieve_input_file_crc32() -> int

   Get input file crc32 stored in the database. it can be used to check that the input file has not been changed. 
           


.. py:function:: retrieve_input_file_md5() -> bytes

   Get input file md5.


.. py:function:: retrieve_input_file_sha256() -> bytes

   Get input file sha256.


.. py:function:: get_asm_inc_file() -> str

   Get name of the include file.


.. py:function:: set_asm_inc_file(file: str) -> bool

   Set name of the include file.


.. py:function:: get_imagebase() -> ida_idaapi.ea_t

   Get image base address.


.. py:function:: set_imagebase(base: ida_idaapi.ea_t) -> None

   Set image base address.


.. py:function:: get_ids_modnode() -> netnode

   Get ids modnode.


.. py:function:: set_ids_modnode(id: netnode) -> None

   Set ids modnode.


.. py:function:: get_archive_path() -> str

   Get archive file path from which input file was extracted.


.. py:function:: set_archive_path(file: str) -> bool

   Set archive file path from which input file was extracted.


.. py:function:: get_loader_format_name() -> str

   Get file format name for loader modules.


.. py:function:: set_loader_format_name(name: str) -> None

   Set file format name for loader modules.


.. py:function:: get_initial_ida_version() -> str

   Get version of ida which created the database (string format like "7.5")


.. py:function:: get_ida_notepad_text() -> str

   Get notepad text.


.. py:function:: set_ida_notepad_text(text: str, size: size_t = 0) -> None

   Set notepad text.


.. py:function:: get_srcdbg_paths() -> str

   Get source debug paths.


.. py:function:: set_srcdbg_paths(paths: str) -> None

   Set source debug paths.


.. py:function:: get_srcdbg_undesired_paths() -> str

   Get user-closed source files.


.. py:function:: set_srcdbg_undesired_paths(paths: str) -> None

   Set user-closed source files.


.. py:function:: get_initial_idb_version() -> ushort

   Get initial version of the database (numeric format like 700)


.. py:function:: get_idb_ctime() -> time_t

   Get database creation timestamp.


.. py:function:: get_elapsed_secs() -> size_t

   Get seconds database stayed open.


.. py:function:: get_idb_nopens() -> size_t

   Get number of times the database is opened.


.. py:function:: get_encoding_qty() -> int

.. py:function:: get_encoding_name(idx: int) -> str

.. py:function:: add_encoding(encname: str) -> int

.. py:function:: del_encoding(idx: int) -> bool

.. py:function:: rename_encoding(idx: int, encname: str) -> bool

.. py:data:: BPU_1B

.. py:data:: BPU_2B

.. py:data:: BPU_4B

.. py:function:: get_encoding_bpu(idx: int) -> int

.. py:function:: get_encoding_bpu_by_name(encname: str) -> int

.. py:function:: get_strtype_bpu(strtype: int) -> int

.. py:function:: get_default_encoding_idx(bpu: int) -> int

.. py:function:: set_default_encoding_idx(bpu: int, idx: int) -> bool

.. py:function:: encoding_from_strtype(strtype: int) -> str

.. py:function:: get_outfile_encoding_idx() -> int

.. py:function:: set_outfile_encoding_idx(idx: int) -> bool

.. py:function:: get_import_module_qty() -> uint

.. py:function:: delete_imports() -> None

.. py:data:: GOTEA_NODE_NAME

   node containing address of .got section


.. py:data:: GOTEA_NODE_IDX

.. py:function:: set_gotea(gotea: ida_idaapi.ea_t) -> None

.. py:function:: get_gotea() -> ida_idaapi.ea_t

.. py:function:: get_import_module_name(mod_index)

   Returns the name of an imported module given its index

   :param mod_index: the module index
   :returns: None or the module name


.. py:function:: enum_import_names(mod_index, callback)

   Enumerate imports from a specific module.
   Please refer to list_imports.py example.

   :param mod_index: The module index
   :param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
   :returns: 1-finished ok, -1 on error, otherwise callback return value (<=0)


.. py:function:: switch_info_t__from_ptrval__(ptrval: size_t) -> switch_info_t *

.. py:function:: get_switch_info(*args)

.. py:function:: get_abi_name()

.. py:data:: get_initial_version


```

`skills/idapython/docs/ida_name.md`:

```md
# ida_name

Name management - getting, setting, validating, and demangling names at addresses.

## Key Functions

### Getting Names
- `get_name(ea)` - Get name at address (simple form)
- `get_colored_name(ea)` - Get name with color tags
- `get_ea_name(ea, gtn_flags=0)` - Get name with flags (alias for get_name with flags)
- `get_visible_name(ea, gtn_flags=0)` - Get visible name (respects hidden status)
- `get_short_name(ea, gtn_flags=0)` - Get short form name
- `get_long_name(ea, gtn_flags=0)` - Get long form name
- `get_colored_short_name(ea, gtn_flags=0)` - Colored short name
- `get_colored_long_name(ea, gtn_flags=0)` - Colored long name

### Setting Names
- `set_name(ea, name, flags=0)` - Set or delete name at address
- `force_name(ea, name, flags=0)` - Force name (add suffix if needed)
- `del_global_name(ea)` - Delete global name
- `del_local_name(ea)` - Delete local name
- `set_dummy_name(from_ea, ea)` - Generate autogenerated dummy name (loc_, sub_, etc.)
- `make_name_auto(ea)` - Mark name as autogenerated
- `make_name_user(ea)` - Mark name as user-defined
- `make_name_public(ea)` - Make name public
- `make_name_non_public(ea)` - Make name non-public
- `make_name_weak(ea)` - Make name weak
- `make_name_non_weak(ea)` - Make name non-weak

### Name Lookup
- `get_name_ea(from_ea, name)` - Get address for name (search from address)
- `get_name_base_ea(from_ea, to_ea)` - Get base address for name
- `get_name_value(from_ea, name)` - Get name value

### Name Visibility
- `hide_name(ea)` - Hide name from display
- `show_name(ea)` - Show previously hidden name

### Name Validation
- `is_valid_cp(cp, kind, data=None)` - Check if codepoint is valid for name type
- `is_ident_cp(cp)` - Check if codepoint is valid identifier character
- `is_strlit_cp(cp, ranges=None)` - Check if valid in string literal
- `is_visible_cp(cp)` - Check if codepoint is visible
- `is_ident(name)` - Check if valid identifier
- `is_uname(name)` - Check if valid user name
- `is_valid_typename(name)` - Check if valid type name
- `validate_name(name, type, flags=1)` - Validate name for type with flags
- `cleanup_name(ea, name, flags=0)` - Clean up name (remove invalid chars)
- `extract_name(line, x)` - Extract name from line at position

### Name List
- `get_nlist_size()` - Get name list size
- `get_nlist_idx(ea)` - Get index in name list
- `is_in_nlist(ea)` - Check if address is in name list
- `get_nlist_ea(idx)` - Get address at name list index
- `get_nlist_name(idx)` - Get name at name list index
- `rebuild_nlist()` - Rebuild name list
- `reorder_dummy_names()` - Reorder dummy names

### Debug Names
- `set_debug_name(ea, name)` - Set debug name (from debug info)
- `get_debug_name(ea_ptr, how)` - Get debug name with transform
- `del_debug_names(ea1, ea2)` - Delete debug names in range
- `get_debug_name_ea(name)` - Get address for debug name
- `get_debug_names(...)` - Get all debug names
- `is_name_defined_locally(...)` - Check if name is locally defined

### Name Demangling
- `demangle_name(name, disable_mask, demreq=DQT_FULL)` - Demangle C++ name
- `get_demangled_name(ea, inhibitor, demform, gtn_flags=0)` - Get demangled name at address
- `get_mangled_name_type(name)` - Get mangled name type (CODE, DATA, UNKNOWN)

### Utility
- `calc_gtn_flags(fromaddr, ea)` - Calculate get name flags
- `set_cp_validity(...)` / `get_cp_validity(...)` - Set/get codepoint validity

## Key Flags

### Set Name Flags (SN_*)
- `SN_CHECK` - Fail if name contains invalid characters
- `SN_NOCHECK` - Replace invalid characters silently with '_'
- `SN_PUBLIC` / `SN_NON_PUBLIC` - Make public/non-public
- `SN_WEAK` / `SN_NON_WEAK` - Make weak/non-weak
- `SN_AUTO` / `SN_NON_AUTO` - Make autogenerated/non-autogenerated
- `SN_NOLIST` - Exclude from name list
- `SN_NOWARN` - Don't display warning if failed
- `SN_LOCAL` - Create local name (requires function context)
- `SN_IDBENC` - Name is in IDB encoding
- `SN_FORCE` - Add numerical suffix if name exists (_123)
- `SN_NODUMMY` - Prepend '_' if name begins with dummy suffix
- `SN_DELTAIL` - Delete hindering item if tail byte conflicts
- `SN_MULTI` - Add as alternative name comment if name exists
- `SN_MULTI_FORCE` - Replace name, move old to comment

### Get Name Flags (GN_*)
- `GN_VISIBLE` - Get visible name
- `GN_COLORED` - Include color tags
- `GN_DEMANGLED` - Get demangled name
- `GN_STRICT` - Strict name lookup
- `GN_SHORT` - Short form
- `GN_LONG` - Long form
- `GN_LOCAL` - Include local names
- `GN_ISRET` / `GN_NOT_ISRET` - Is/isn't return value
- `GN_NOT_DUMMY` - Exclude dummy names

### Get Name Ex Flags (GETN_*)
- `GETN_APPZERO` - Append zero to result
- `GETN_NOFIXUP` - Don't apply fixups
- `GETN_NODUMMY` - Don't return dummy names

### Get Near Comment Flags (GNCN_*)
- `GNCN_NOSEG` - Don't include segment name
- `GNCN_NOCOLOR` - No color tags
- `GNCN_NOLABEL` - Don't include label
- `GNCN_NOFUNC` - Don't include function name
- `GNCN_SEG_FUNC` - Include segment and function
- `GNCN_SEGNUM` - Include segment number
- `GNCN_REQFUNC` - Require function
- `GNCN_REQNAME` - Require name
- `GNCN_NODBGNM` - No debug names
- `GNCN_PREFDBG` - Prefer debug names

### Debug Name Flags (DEBNAME_*)
- `DEBNAME_EXACT` - Exact match
- `DEBNAME_LOWER` - Convert to lowercase
- `DEBNAME_UPPER` - Convert to uppercase
- `DEBNAME_NICE` - Nice formatting

### Demangling Flags (DQT_*)
- `DQT_FULL` - Full demangling
- `DQT_NAME_TYPE` - Name and type only
- `DQT_COMPILER` - Compiler-specific
- `DQT_NPURGED_2` / `DQT_NPURGED_4` / `DQT_NPURGED_8` - Number of purged bytes

### Name Types (NT_*)
- `NT_NONE` - No name
- `NT_BYTE` - Byte name
- `NT_LOCAL` - Local name
- `NT_STKVAR` - Stack variable
- `NT_ENUM` - Enum member
- `NT_ABS` - Absolute symbol
- `NT_SEG` - Segment
- `NT_STROFF` - Structure offset
- `NT_BMASK` - Bitmask
- `NT_REGVAR` - Register variable

### Validate Name Types (VNT_*)
- `VNT_IDENT` - Identifier
- `VNT_TYPE` - Type name
- `VNT_UDTMEM` - User-defined type member
- `VNT_STRLIT` - String literal
- `VNT_VISIBLE` - Visible name

### Cleanup Name Flags (CN_*)
- `CN_KEEP_TRAILING_DIGITS` - Keep trailing digits
- `CN_KEEP_UNDERSCORES` - Keep underscores

### Mangling Flags (MNG_*)
Extensive demangling control: MNG_NOTYPE, MNG_NORETTYPE, MNG_NOBASEDT, MNG_NOCALLC, MNG_NOTHROW, MNG_SHORT_FORM, MNG_LONG_FORM, etc.

### Calling Conventions (MT_*)
- `MT_CDECL` / `MT_PASCAL` / `MT_STDCALL` / `MT_FASTCALL` / `MT_THISCALL` / `MT_VECTORCALL` / `MT_REGCALL` - Calling conventions
- `MT_SYSCALL` / `MT_INTERRUPT` - Special conventions

### Compilers (MT_*)
- `MT_MSCOMP` - Microsoft compiler
- `MT_BORLAN` - Borland compiler
- `MT_WATCOM` - Watcom compiler
- `MT_GNU` / `MT_GCC3` - GNU/GCC compilers
- `MT_OTHER` - Other compiler

## Classes

### ea_name_t
Address-name pair.

### ea_name_vec_t
Vector of ea_name_t.

### NearestName
Nearest name helper class.

## Constants

- `MAXNAMELEN` - Maximum name length (including terminator)
- `FUNC_IMPORT_PREFIX` - Import function prefix
- `MANGLED_CODE` / `MANGLED_DATA` / `MANGLED_UNKNOWN` - Mangled name types
- Various ignore flags: `ignore_none`, `ignore_regvar`, `ignore_llabel`, `ignore_stkvar`, `ignore_glabel`

## See Also
Full docs: skill/docs/ida_name.rst

```

`skills/idapython/docs/ida_name.rst`:

```rst
ida_name
========

.. py:module:: ida_name

.. autoapi-nested-parse::

   Functions that deal with names.

   A non-tail address of the program may have a name. Tail addresses (i.e. the addresses in the middle of an instruction or data item) cannot have names. 

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For name and symbol operations, see :mod:`ida_domain.names`.



Attributes
----------

.. autoapisummary::

   ida_name.MAXNAMELEN
   ida_name.FUNC_IMPORT_PREFIX
   ida_name.SN_CHECK
   ida_name.SN_NOCHECK
   ida_name.SN_PUBLIC
   ida_name.SN_NON_PUBLIC
   ida_name.SN_WEAK
   ida_name.SN_NON_WEAK
   ida_name.SN_AUTO
   ida_name.SN_NON_AUTO
   ida_name.SN_NOLIST
   ida_name.SN_NOWARN
   ida_name.SN_LOCAL
   ida_name.SN_IDBENC
   ida_name.SN_FORCE
   ida_name.SN_NODUMMY
   ida_name.SN_DELTAIL
   ida_name.SN_MULTI
   ida_name.SN_MULTI_FORCE
   ida_name.UCDR_STRLIT
   ida_name.UCDR_NAME
   ida_name.UCDR_MANGLED
   ida_name.UCDR_TYPE
   ida_name.VNT_IDENT
   ida_name.VNT_TYPE
   ida_name.VNT_UDTMEM
   ida_name.VNT_STRLIT
   ida_name.VNT_VISIBLE
   ida_name.NT_NONE
   ida_name.NT_BYTE
   ida_name.NT_LOCAL
   ida_name.NT_STKVAR
   ida_name.NT_ENUM
   ida_name.NT_ABS
   ida_name.NT_SEG
   ida_name.NT_STROFF
   ida_name.NT_BMASK
   ida_name.NT_REGVAR
   ida_name.GN_VISIBLE
   ida_name.GN_COLORED
   ida_name.GN_DEMANGLED
   ida_name.GN_STRICT
   ida_name.GN_SHORT
   ida_name.GN_LONG
   ida_name.GN_LOCAL
   ida_name.GN_ISRET
   ida_name.GN_NOT_ISRET
   ida_name.GN_NOT_DUMMY
   ida_name.GETN_APPZERO
   ida_name.GETN_NOFIXUP
   ida_name.GETN_NODUMMY
   ida_name.GNCN_NOSEG
   ida_name.GNCN_NOCOLOR
   ida_name.GNCN_NOLABEL
   ida_name.GNCN_NOFUNC
   ida_name.GNCN_SEG_FUNC
   ida_name.GNCN_SEGNUM
   ida_name.GNCN_REQFUNC
   ida_name.GNCN_REQNAME
   ida_name.GNCN_NODBGNM
   ida_name.GNCN_PREFDBG
   ida_name.DEBNAME_EXACT
   ida_name.DEBNAME_LOWER
   ida_name.DEBNAME_UPPER
   ida_name.DEBNAME_NICE
   ida_name.DQT_NPURGED_8
   ida_name.DQT_NPURGED_4
   ida_name.DQT_NPURGED_2
   ida_name.DQT_COMPILER
   ida_name.DQT_NAME_TYPE
   ida_name.DQT_FULL
   ida_name.CN_KEEP_TRAILING_DIGITS
   ida_name.CN_KEEP_UNDERSCORES
   ida_name.ME_INTERR
   ida_name.ME_PARAMERR
   ida_name.ME_ILLSTR
   ida_name.ME_SMALLANS
   ida_name.ME_FRAME
   ida_name.ME_NOCOMP
   ida_name.ME_ERRAUTO
   ida_name.ME_NOHASHMEM
   ida_name.ME_NOSTRMEM
   ida_name.ME_NOERROR_LIMIT
   ida_name.M_PRCMSK
   ida_name.MT_DEFAULT
   ida_name.MT_CDECL
   ida_name.MT_PASCAL
   ida_name.MT_STDCALL
   ida_name.MT_FASTCALL
   ida_name.MT_THISCALL
   ida_name.MT_FORTRAN
   ida_name.MT_SYSCALL
   ida_name.MT_INTERRUPT
   ida_name.MT_MSFASTCALL
   ida_name.MT_CLRCALL
   ida_name.MT_DMDCALL
   ida_name.MT_VECTORCALL
   ida_name.MT_REGCALL
   ida_name.MT_LOCALNAME
   ida_name.M_SAVEREGS
   ida_name.M_CLASS
   ida_name.MT_PUBLIC
   ida_name.MT_PRIVATE
   ida_name.MT_PROTECT
   ida_name.MT_MEMBER
   ida_name.MT_VTABLE
   ida_name.MT_RTTI
   ida_name.M_PARMSK
   ida_name.MT_PARSHF
   ida_name.MT_PARMAX
   ida_name.M_ELLIPSIS
   ida_name.MT_VOIDARG
   ida_name.M_STATIC
   ida_name.M_VIRTUAL
   ida_name.M_AUTOCRT
   ida_name.M_TYPMASK
   ida_name.MT_OPERAT
   ida_name.MT_CONSTR
   ida_name.MT_DESTR
   ida_name.MT_CASTING
   ida_name.MT_CLRCDTOR
   ida_name.M_TRUNCATE
   ida_name.M_THUNK
   ida_name.M_ANONNSP
   ida_name.M_TMPLNAM
   ida_name.M_DBGNAME
   ida_name.M_COMPILER
   ida_name.MT_MSCOMP
   ida_name.MT_BORLAN
   ida_name.MT_WATCOM
   ida_name.MT_OTHER
   ida_name.MT_GNU
   ida_name.MT_GCC3
   ida_name.MT_VISAGE
   ida_name.MNG_PTRMSK
   ida_name.MNG_DEFNEAR
   ida_name.MNG_DEFNEARANY
   ida_name.MNG_DEFFAR
   ida_name.MNG_NOPTRTYP16
   ida_name.MNG_DEFHUGE
   ida_name.MNG_DEFPTR64
   ida_name.MNG_DEFNONE
   ida_name.MNG_NOPTRTYP
   ida_name.MNG_NODEFINIT
   ida_name.MNG_NOUNDERSCORE
   ida_name.MNG_NOTYPE
   ida_name.MNG_NORETTYPE
   ida_name.MNG_NOBASEDT
   ida_name.MNG_NOCALLC
   ida_name.MNG_NOPOSTFC
   ida_name.MNG_NOSCTYP
   ida_name.MNG_NOTHROW
   ida_name.MNG_NOSTVIR
   ida_name.MNG_NOECSU
   ida_name.MNG_NOCSVOL
   ida_name.MNG_NOCLOSUR
   ida_name.MNG_NOUNALG
   ida_name.MNG_NOMANAGE
   ida_name.MNG_NOMODULE
   ida_name.MNG_SHORT_S
   ida_name.MNG_SHORT_U
   ida_name.MNG_ZPT_SPACE
   ida_name.MNG_DROP_IMP
   ida_name.MNG_IGN_ANYWAY
   ida_name.MNG_IGN_JMP
   ida_name.MNG_MOVE_JMP
   ida_name.MNG_COMPILER_MSK
   ida_name.MNG_SHORT_FORM
   ida_name.MNG_LONG_FORM
   ida_name.MNG_CALC_VALID
   ida_name.cvar
   ida_name.ignore_none
   ida_name.ignore_regvar
   ida_name.ignore_llabel
   ida_name.ignore_stkvar
   ida_name.ignore_glabel
   ida_name.MANGLED_CODE
   ida_name.MANGLED_DATA
   ida_name.MANGLED_UNKNOWN


Classes
-------

.. autoapisummary::

   ida_name.ea_name_vec_t
   ida_name.ea_name_t
   ida_name.NearestName


Functions
---------

.. autoapisummary::

   ida_name.get_name
   ida_name.get_colored_name
   ida_name.set_name
   ida_name.force_name
   ida_name.del_global_name
   ida_name.del_local_name
   ida_name.set_dummy_name
   ida_name.make_name_auto
   ida_name.make_name_user
   ida_name.is_valid_cp
   ida_name.set_cp_validity
   ida_name.get_cp_validity
   ida_name.is_ident_cp
   ida_name.is_strlit_cp
   ida_name.is_visible_cp
   ida_name.is_ident
   ida_name.is_uname
   ida_name.is_valid_typename
   ida_name.extract_name
   ida_name.hide_name
   ida_name.show_name
   ida_name.get_name_ea
   ida_name.get_name_base_ea
   ida_name.get_name_value
   ida_name.get_visible_name
   ida_name.get_short_name
   ida_name.get_long_name
   ida_name.get_colored_short_name
   ida_name.get_colored_long_name
   ida_name.get_demangled_name
   ida_name.get_colored_demangled_name
   ida_name.get_name_color
   ida_name.get_name_expr
   ida_name.get_nice_colored_name
   ida_name.append_struct_fields
   ida_name.is_public_name
   ida_name.make_name_public
   ida_name.make_name_non_public
   ida_name.is_weak_name
   ida_name.make_name_weak
   ida_name.make_name_non_weak
   ida_name.get_nlist_size
   ida_name.get_nlist_idx
   ida_name.is_in_nlist
   ida_name.get_nlist_ea
   ida_name.get_nlist_name
   ida_name.rebuild_nlist
   ida_name.reorder_dummy_names
   ida_name.set_debug_name
   ida_name.get_debug_name
   ida_name.del_debug_names
   ida_name.get_debug_name_ea
   ida_name.demangle_name
   ida_name.is_name_defined_locally
   ida_name.cleanup_name
   ida_name.get_mangled_name_type
   ida_name.get_debug_names
   ida_name.get_ea_name
   ida_name.validate_name
   ida_name.calc_gtn_flags


Module Contents
---------------

.. py:class:: ea_name_vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> ea_name_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> ea_name_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: ea_name_vec_t) -> None


   .. py:method:: extract() -> ea_name_t *


   .. py:method:: inject(s: ea_name_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< ea_name_t >::const_iterator


   .. py:method:: end(*args) -> qvector< ea_name_t >::const_iterator


   .. py:method:: insert(it: ea_name_t, x: ea_name_t) -> qvector< ea_name_t >::iterator


   .. py:method:: erase(*args) -> qvector< ea_name_t >::iterator


   .. py:method:: append(x: ea_name_t) -> None


   .. py:method:: extend(x: ea_name_vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: get_name(ea: ida_idaapi.ea_t) -> str

.. py:function:: get_colored_name(ea: ida_idaapi.ea_t) -> str

.. py:data:: MAXNAMELEN

   Maximum length of a name in IDA (with the trailing zero)


.. py:data:: FUNC_IMPORT_PREFIX

   Name prefix used by IDA for the imported functions.


.. py:function:: set_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool

   Set or delete name of an item at the specified address. An item can be anything: instruction, function, data byte, word, string, structure, etc... Include name into the list of names. 
           
   :param ea: linear address. do nothing if ea is not valid (return 0). tail bytes can't have names.
   :param name: new name.
   * nullptr: do nothing (return 0).
   * "" : delete name.
   * otherwise this is a new name.
   :param flags: Set name flags. If a bit is not specified, then the corresponding action is not performed and the name will retain the same bits as before calling this function. For new names, default is: non-public, non-weak, non-auto.
   :returns: 1: ok, name is changed
   :returns: 0: failure, a warning is displayed


.. py:data:: SN_CHECK

   Fail if the name contains invalid characters.


.. py:data:: SN_NOCHECK

   Replace invalid characters silently. If this bit is set, all invalid chars (not in NameChars or MangleChars) will be replaced by '_' List of valid characters is defined in ida.cfg 
           


.. py:data:: SN_PUBLIC

   if set, make name public


.. py:data:: SN_NON_PUBLIC

   if set, make name non-public


.. py:data:: SN_WEAK

   if set, make name weak


.. py:data:: SN_NON_WEAK

   if set, make name non-weak


.. py:data:: SN_AUTO

   if set, make name autogenerated


.. py:data:: SN_NON_AUTO

   if set, make name non-autogenerated


.. py:data:: SN_NOLIST

   if set, exclude name from the list. if not set, then include the name into the list (however, if other bits are set, the name might be immediately excluded from the list). 
           


.. py:data:: SN_NOWARN

   don't display a warning if failed


.. py:data:: SN_LOCAL

   create local name. a function should exist. local names can't be public or weak. also they are not included into the list of names they can't have dummy prefixes. 
           


.. py:data:: SN_IDBENC

   the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly. Specifying SN_IDBENC also implies SN_NODUMMY 
           


.. py:data:: SN_FORCE

   if the specified name is already present in the database, try variations with a numerical suffix like "_123" 
           


.. py:data:: SN_NODUMMY

   automatically prepend the name with '_' if it begins with a dummy suffix such as 'sub_'. See also SN_IDBENC 
           


.. py:data:: SN_DELTAIL

   if name cannot be set because of a tail byte, delete the hindering item 
           


.. py:data:: SN_MULTI

   if the specified address already has a name, then add the new name as a regular comment "Alternative name is ...". Except when the new name is public and the old one is not or when the old name is weak and the new one is not. In these cases we act as if bit SN_MULTI_FORCE is specified. If the new name only slightly differs from the old one, for example, only by the initial underscore or the artificial suffix '_##', then we ignore it. 
           


.. py:data:: SN_MULTI_FORCE

   if the specified address already has a name, put this old name into a regular comment and set the specified name. This bit may be used only with SN_MULTI. 
           


.. py:function:: force_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool

.. py:function:: del_global_name(ea: ida_idaapi.ea_t) -> bool

.. py:function:: del_local_name(ea: ida_idaapi.ea_t) -> bool

.. py:function:: set_dummy_name(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> bool

   Give an autogenerated (dummy) name. Autogenerated names have special prefixes (loc_...). 
           
   :param ea: linear address
   :returns: 1: ok, dummy name is generated or the byte already had a name
   :returns: 0: failure, invalid address or tail byte


.. py:function:: make_name_auto(ea: ida_idaapi.ea_t) -> bool

.. py:function:: make_name_user(ea: ida_idaapi.ea_t) -> bool

.. py:data:: UCDR_STRLIT

   string literals


.. py:data:: UCDR_NAME

   regular (unmangled) names


.. py:data:: UCDR_MANGLED

   mangled names


.. py:data:: UCDR_TYPE

   type names


.. py:data:: VNT_IDENT

   identifier (e.g., function name)


.. py:data:: VNT_TYPE

   type name (can contain '<', '>', ...)


.. py:data:: VNT_UDTMEM

   UDT (structure, union, enum) member.


.. py:data:: VNT_STRLIT

   string literal


.. py:data:: VNT_VISIBLE

   visible cp (obsolete; will be deleted)


.. py:function:: is_valid_cp(cp: wchar32_t, kind: nametype_t, data: void * = None) -> bool

   Is the given codepoint acceptable in the given context?


.. py:function:: set_cp_validity(*args) -> None

   Mark the given codepoint (or range) as acceptable or unacceptable in the given context If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range 
           


.. py:function:: get_cp_validity(*args) -> bool

   Is the given codepoint (or range) acceptable in the given context? If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range 
           


.. py:function:: is_ident_cp(cp: wchar32_t) -> bool

   Can a character appear in a name? (present in ::NameChars or ::MangleChars)


.. py:function:: is_strlit_cp(cp: wchar32_t, specific_ranges: rangeset_crefvec_t const * = None) -> bool

   Can a character appear in a string literal (present in ::StrlitChars) If 'specific_ranges' are specified, those will be used instead of the ones corresponding to the current culture (only if ::StrlitChars is configured to use the current culture) 
           


.. py:function:: is_visible_cp(cp: wchar32_t) -> bool

   Can a character be displayed in a name? (present in ::NameChars)


.. py:function:: is_ident(name: str) -> bool

   Is a valid name? (including ::MangleChars)


.. py:function:: is_uname(name: str) -> bool

   Is valid user-specified name? (valid name & !dummy prefix). 
           
   :param name: name to test. may be nullptr.
   :returns: 1: yes
   :returns: 0: no


.. py:function:: is_valid_typename(name: str) -> bool

   Is valid type name? 
           
   :param name: name to test. may be nullptr.
   :returns: 1: yes
   :returns: 0: no


.. py:function:: extract_name(line: str, x: int) -> str

   Extract a name or address from the specified string. 
           
   :param line: input string
   :param x: x coordinate of cursor
   :returns: -1 if cannot extract. otherwise length of the name


.. py:function:: hide_name(ea: ida_idaapi.ea_t) -> None

   Remove name from the list of names 
           
   :param ea: address of the name


.. py:function:: show_name(ea: ida_idaapi.ea_t) -> None

   Insert name to the list of names.


.. py:function:: get_name_ea(_from: ida_idaapi.ea_t, name: str) -> ida_idaapi.ea_t

   Get the address of a name. This function resolves a name into an address. It can handle regular global and local names, as well as debugger names. 
           
   :param name: any name in the program or nullptr
   :returns: address of the name or BADADDR


.. py:function:: get_name_base_ea(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get address of the name used in the expression for the address 
           
   :param to: the referenced address
   :returns: address of the name used to represent the operand


.. py:function:: get_name_value(_from: ida_idaapi.ea_t, name: str) -> uval_t *

   Get value of the name. This function knows about: regular names, enums, special segments, etc. 
           
   :param name: any name in the program or nullptr
   :returns: Name value result codes


.. py:data:: NT_NONE

   name doesn't exist or has no value


.. py:data:: NT_BYTE

   name is byte name (regular name)


.. py:data:: NT_LOCAL

   name is local label


.. py:data:: NT_STKVAR

   name is stack variable name


.. py:data:: NT_ENUM

   name is symbolic constant


.. py:data:: NT_ABS

   name is absolute symbol (SEG_ABSSYM)


.. py:data:: NT_SEG

   name is segment or segment register name


.. py:data:: NT_STROFF

   name is structure member


.. py:data:: NT_BMASK

   name is a bit group mask name


.. py:data:: NT_REGVAR

   name is a renamed register (*value is idx into pfn->regvars)


.. py:data:: GN_VISIBLE

   replace forbidden characters by SUBSTCHAR


.. py:data:: GN_COLORED

   return colored name


.. py:data:: GN_DEMANGLED

   return demangled name


.. py:data:: GN_STRICT

   fail if cannot demangle


.. py:data:: GN_SHORT

   use short form of demangled name


.. py:data:: GN_LONG

   use long form of demangled name


.. py:data:: GN_LOCAL

   try to get local name first; if failed, get global


.. py:data:: GN_ISRET

   for dummy names: use retloc


.. py:data:: GN_NOT_ISRET

   for dummy names: do not use retloc


.. py:data:: GN_NOT_DUMMY

   do not return a dummy name


.. py:function:: get_visible_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

.. py:function:: get_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

.. py:function:: get_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

.. py:function:: get_colored_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

.. py:function:: get_colored_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

.. py:function:: get_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str

.. py:function:: get_colored_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str

.. py:function:: get_name_color(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> color_t

   Calculate flags for get_ea_name() function.

   Get name color. 
           
   :param ea: linear address


.. py:data:: GETN_APPZERO

   meaningful only if the name refers to a structure. append a struct field name if the field offset is zero? 
           


.. py:data:: GETN_NOFIXUP

   ignore the fixup information when producing the name


.. py:data:: GETN_NODUMMY

   do not create a new dummy name but pretend it exists


.. py:function:: get_name_expr(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, off: int, flags: int = 1) -> str

   Convert address to name expression (name with a displacement). This function takes into account fixup information and returns a colored name expression (in the form <name> +/- <offset>). It also knows about structure members and arrays. If the specified address doesn't have a name, a dummy name is generated. 
           
   :param n: number of referencing operand. for data items specify 0
   :param ea: address to convert to name expression
   :param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. 'off' may be equal to BADADDR but this is discouraged because it prohibits checks.
   :param flags: Name expression flags
   :returns: < 0 if address is not valid, no segment or other failure. otherwise the length of the name expression in characters.


.. py:function:: get_nice_colored_name(ea: ida_idaapi.ea_t, flags: int = 0) -> str

   Get a nice colored name at the specified address. Ex:
   * segment:sub+offset
   * segment:sub:local_label
   * segment:label
   * segment:address
   * segment:address+offset



   :param ea: linear address
   :param flags: Nice colored name flags
   :returns: the length of the generated name in bytes.


.. py:data:: GNCN_NOSEG

   ignore the segment prefix when producing the name


.. py:data:: GNCN_NOCOLOR

   generate an uncolored name


.. py:data:: GNCN_NOLABEL

   don't generate labels


.. py:data:: GNCN_NOFUNC

   don't generate funcname+... expressions


.. py:data:: GNCN_SEG_FUNC

   generate both segment and function names (default is to omit segment name if a function name is present)


.. py:data:: GNCN_SEGNUM

   segment part is displayed as a hex number


.. py:data:: GNCN_REQFUNC

   return 0 if the address does not belong to a function


.. py:data:: GNCN_REQNAME

   return 0 if the address can only be represented as a hex number


.. py:data:: GNCN_NODBGNM

   don't use debug names


.. py:data:: GNCN_PREFDBG

   if using debug names, prefer debug names over function names


.. py:function:: append_struct_fields(disp: adiff_t *, n: int, path: tid_t const *, flags: flags64_t, delta: adiff_t, appzero: bool) -> str

   Append names of struct fields to a name if the name is a struct name. 
           
   :param disp: displacement from the name
   :param n: operand number in which the name appears
   :param path: path in the struct. path is an array of id's. maximal length of array is MAXSTRUCPATH. the first element of the array is the structure id. consecutive elements are id's of used union members (if any).
   :param flags: the input flags. they will be returned if the struct cannot be found.
   :param delta: delta to add to displacement
   :param appzero: should append a struct field name if the displacement is zero?
   :returns: flags of the innermost struct member or the input flags


.. py:function:: is_public_name(ea: ida_idaapi.ea_t) -> bool

.. py:function:: make_name_public(ea: ida_idaapi.ea_t) -> None

.. py:function:: make_name_non_public(ea: ida_idaapi.ea_t) -> None

.. py:function:: is_weak_name(ea: ida_idaapi.ea_t) -> bool

.. py:function:: make_name_weak(ea: ida_idaapi.ea_t) -> None

.. py:function:: make_name_non_weak(ea: ida_idaapi.ea_t) -> None

.. py:function:: get_nlist_size() -> size_t

.. py:function:: get_nlist_idx(ea: ida_idaapi.ea_t) -> size_t

.. py:function:: is_in_nlist(ea: ida_idaapi.ea_t) -> bool

.. py:function:: get_nlist_ea(idx: size_t) -> ida_idaapi.ea_t

.. py:function:: get_nlist_name(idx: size_t) -> str

.. py:function:: rebuild_nlist() -> None

.. py:function:: reorder_dummy_names() -> None

   Renumber dummy names.


.. py:data:: DEBNAME_EXACT

   find a name at exactly the specified address


.. py:data:: DEBNAME_LOWER

   find a name with the address >= the specified address


.. py:data:: DEBNAME_UPPER

   find a name with the address > the specified address


.. py:data:: DEBNAME_NICE

   find a name with the address <= the specified address


.. py:class:: ea_name_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: name
      :type:  str


.. py:function:: set_debug_name(ea: ida_idaapi.ea_t, name: str) -> bool

.. py:function:: get_debug_name(ea_ptr: ea_t *, how: debug_name_how_t) -> str

.. py:function:: del_debug_names(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None

.. py:function:: get_debug_name_ea(name: str) -> ida_idaapi.ea_t

.. py:data:: DQT_NPURGED_8

   only calculate number of purged bytes (sizeof(arg)==8)


.. py:data:: DQT_NPURGED_4

   only calculate number of purged bytes (sizeof(arg)==4)


.. py:data:: DQT_NPURGED_2

   only calculate number of purged bytes (sizeof(arg)==2)


.. py:data:: DQT_COMPILER

   only detect compiler that generated the name


.. py:data:: DQT_NAME_TYPE

   only detect the name type (data/code)


.. py:data:: DQT_FULL

   really demangle


.. py:function:: demangle_name(name: str, disable_mask: int, demreq: demreq_type_t = DQT_FULL) -> str

   Demangle a name. 
           
   :param name: name to demangle
   :param disable_mask: bits to inhibit parts of demangled name (see MNG_). by the M_COMPILER bits a specific compiler can be selected (see MT_).
   :param demreq: the request type demreq_type_t
   :returns: ME_... or MT__ bitmasks from demangle.hpp


.. py:function:: is_name_defined_locally(*args) -> bool

   Is the name defined locally in the specified function? 
           
   :param pfn: pointer to function
   :param name: name to check
   :param ignore_name_def: which names to ignore when checking
   :param ea1: the starting address of the range inside the function (optional)
   :param ea2: the ending address of the range inside the function (optional)
   :returns: true if the name has been defined


.. py:function:: cleanup_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> str

.. py:data:: CN_KEEP_TRAILING_DIGITS

   do not remove "_\d+" at the end of name


.. py:data:: CN_KEEP_UNDERSCORES

   do not remove leading underscores. but it is ok to remove __imp_. 
           


.. py:data:: ME_INTERR

.. py:data:: ME_PARAMERR

.. py:data:: ME_ILLSTR

.. py:data:: ME_SMALLANS

.. py:data:: ME_FRAME

.. py:data:: ME_NOCOMP

.. py:data:: ME_ERRAUTO

.. py:data:: ME_NOHASHMEM

.. py:data:: ME_NOSTRMEM

.. py:data:: ME_NOERROR_LIMIT

.. py:data:: M_PRCMSK

.. py:data:: MT_DEFAULT

.. py:data:: MT_CDECL

.. py:data:: MT_PASCAL

.. py:data:: MT_STDCALL

.. py:data:: MT_FASTCALL

.. py:data:: MT_THISCALL

.. py:data:: MT_FORTRAN

.. py:data:: MT_SYSCALL

.. py:data:: MT_INTERRUPT

.. py:data:: MT_MSFASTCALL

.. py:data:: MT_CLRCALL

.. py:data:: MT_DMDCALL

.. py:data:: MT_VECTORCALL

.. py:data:: MT_REGCALL

.. py:data:: MT_LOCALNAME

.. py:data:: M_SAVEREGS

.. py:data:: M_CLASS

.. py:data:: MT_PUBLIC

.. py:data:: MT_PRIVATE

.. py:data:: MT_PROTECT

.. py:data:: MT_MEMBER

.. py:data:: MT_VTABLE

.. py:data:: MT_RTTI

.. py:data:: M_PARMSK

.. py:data:: MT_PARSHF

.. py:data:: MT_PARMAX

.. py:data:: M_ELLIPSIS

.. py:data:: MT_VOIDARG

.. py:data:: M_STATIC

.. py:data:: M_VIRTUAL

.. py:data:: M_AUTOCRT

.. py:data:: M_TYPMASK

.. py:data:: MT_OPERAT

.. py:data:: MT_CONSTR

.. py:data:: MT_DESTR

.. py:data:: MT_CASTING

.. py:data:: MT_CLRCDTOR

.. py:data:: M_TRUNCATE

.. py:data:: M_THUNK

.. py:data:: M_ANONNSP

.. py:data:: M_TMPLNAM

.. py:data:: M_DBGNAME

.. py:data:: M_COMPILER

.. py:data:: MT_MSCOMP

.. py:data:: MT_BORLAN

.. py:data:: MT_WATCOM

.. py:data:: MT_OTHER

.. py:data:: MT_GNU

.. py:data:: MT_GCC3

.. py:data:: MT_VISAGE

.. py:data:: MNG_PTRMSK

.. py:data:: MNG_DEFNEAR

.. py:data:: MNG_DEFNEARANY

.. py:data:: MNG_DEFFAR

.. py:data:: MNG_NOPTRTYP16

.. py:data:: MNG_DEFHUGE

.. py:data:: MNG_DEFPTR64

.. py:data:: MNG_DEFNONE

.. py:data:: MNG_NOPTRTYP

.. py:data:: MNG_NODEFINIT

.. py:data:: MNG_NOUNDERSCORE

.. py:data:: MNG_NOTYPE

.. py:data:: MNG_NORETTYPE

.. py:data:: MNG_NOBASEDT

.. py:data:: MNG_NOCALLC

.. py:data:: MNG_NOPOSTFC

.. py:data:: MNG_NOSCTYP

.. py:data:: MNG_NOTHROW

.. py:data:: MNG_NOSTVIR

.. py:data:: MNG_NOECSU

.. py:data:: MNG_NOCSVOL

.. py:data:: MNG_NOCLOSUR

.. py:data:: MNG_NOUNALG

.. py:data:: MNG_NOMANAGE

.. py:data:: MNG_NOMODULE

.. py:data:: MNG_SHORT_S

.. py:data:: MNG_SHORT_U

.. py:data:: MNG_ZPT_SPACE

.. py:data:: MNG_DROP_IMP

.. py:data:: MNG_IGN_ANYWAY

.. py:data:: MNG_IGN_JMP

.. py:data:: MNG_MOVE_JMP

.. py:data:: MNG_COMPILER_MSK

.. py:data:: MNG_SHORT_FORM

.. py:data:: MNG_LONG_FORM

.. py:data:: MNG_CALC_VALID

.. py:function:: get_mangled_name_type(name: str) -> mangled_name_type_t

.. py:function:: get_debug_names(*args) -> PyObject *

.. py:function:: get_ea_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

   Get name at the specified address. 
           
   :param ea: linear address
   :param gtn_flags: how exactly the name should be retrieved. combination of bits for get_ea_name() function. There is a convenience bits
   :returns: success


.. py:function:: validate_name(name: str, type: nametype_t, flags: int = 1) -> PyObject *

   Validate a name. If SN_NOCHECK is specified, this function replaces all invalid characters in the name with SUBSTCHAR. However, it will return false if name is valid but not allowed to be an identifier (is a register name).

   :param name: ptr to name. the name will be modified
   :param type: the type of name we want to validate
   :param flags: see SN_*
   :returns: success


.. py:class:: NearestName(ea_names)

   Bases: :py:obj:`object`


   Utility class to help find the nearest name in a given ea/name dictionary


   .. py:method:: update(ea_names)

      Updates the ea/names map



   .. py:method:: find(ea)

      Returns a tupple (ea, name, pos) that is the nearest to the passed ea
      If no name is matched then None is returned



.. py:function:: calc_gtn_flags(fromaddr, ea)

   Calculate flags for get_ea_name() function

   :param fromaddr: the referring address. May be BADADDR.
   :param ea: linear address

   :returns: flags


.. py:data:: cvar

.. py:data:: ignore_none

.. py:data:: ignore_regvar

.. py:data:: ignore_llabel

.. py:data:: ignore_stkvar

.. py:data:: ignore_glabel

.. py:data:: MANGLED_CODE

.. py:data:: MANGLED_DATA

.. py:data:: MANGLED_UNKNOWN


```

`skills/idapython/docs/ida_netnode.md`:

```md
# ida_netnode

Low-priority: Low-level database storage using B-tree structures. Most reverse engineering tasks use higher-level abstractions instead.

## Key Classes/Functions

### netnode
Persistent storage object in IDA database. Each netnode has unique ID and may have name, value, and multiple sparse arrays.

- `exist(name)` - check if named netnode exists
- `create()` - create new netnode
- `kill()` - delete netnode
- `get_name()` - retrieve netnode name
- `rename(newname)` - change netnode name
- `altval(idx, tag)` - read 32-bit value from altvals array
- `altset(idx, val, tag)` - write 32-bit value to altvals array
- `supval(idx, tag)` - read arbitrary-sized object from supvals array
- `supset(idx, value, tag)` - write arbitrary-sized object to supvals array
- `hashval(key, tag)` - read value from hash by string key
- `hashset(key, value, tag)` - write value to hash by string key
- `getblob(start, tag)` - read large object spanning multiple indexes
- `setblob(buf, start, tag)` - write large object

Arrays use tags to organize data: 'A' for altvals, 'S' for supvals, 'H' for hashvals.

## See Also
Full docs: skill/docs/ida_netnode.rst

```

`skills/idapython/docs/ida_netnode.rst`:

```rst
ida_netnode
===========

.. py:module:: ida_netnode

.. autoapi-nested-parse::

   Functions that provide the lowest level public interface to the database. Namely, we use Btree. To learn more about BTree:

   [https://en.wikipedia.org/wiki/B-tree](https://en.wikipedia.org/wiki/B-tree)
   We do not use Btree directly. Instead, we have another layer built on the top of Btree. Here is a brief explanation of this layer.
   An object called "netnode" is modeled on the top of Btree. Each netnode has a unique id: a 32-bit value (64-bit for ida64). Initially there is a trivial mapping of the linear addresses used in the program to netnodes (later this mapping may be modified using ea2node and node2ea functions; this is used for fast database rebasings). If we have additional information about an address (for example, a comment is attached to it), this information is stored in the corresponding netnode. See nalt.hpp to see how the kernel uses netnodes. Also, some netnodes have no corresponding linear address (however, they still have an id). They are used to store information not related to a particular address.
   Each netnode _may_ have the following attributes:

   * a name: an arbitrary non-empty string, up to 255KB-1 bytes
   * a value: arbitrary sized object, max size is MAXSPECSIZE
   * altvals: a sparse array of 32-bit values. indexes in this array may be 8-bit or 32-bit values
   * supvals: an array of arbitrary sized objects. (size of each object is limited by MAXSPECSIZE) indexes in this array may be 8-bit or 32-bit values
   * charvals: a sparse array of 8-bit values. indexes in this array may be 8-bit or 32-bit values
   * hashvals: a hash (an associative array). indexes in this array are strings values are arbitrary sized (max size is MAXSPECSIZE)


   Initially a new netnode contains no information at all so no disk space is used for it. As you add new information, the netnode grows.
   All arrays that are attached to the netnode behave in the same manner. Initially:
   * all members of altvals/charvals array are zeroes
   * all members of supvals/hashvals array are undefined


   If you need to store objects bigger that MAXSPECSIZE, please note that there are high-level functions to store arbitrary sized objects in supvals. See setblob/getblob and other blob-related functions.
   You may use netnodes to store additional information about the program. Limitations on the use of netnodes are the following:

   * use netnodes only if you could not find a kernel service to store your type of information
   * do not create netnodes with valid identifier names. Use the "$ " prefix (or any other prefix with characters not allowed in the identifiers for the names of your netnodes. Although you will probably not destroy anything by accident, using already defined names for the names of your netnodes is still discouraged.
   * you may create as many netnodes as you want (creation of an unnamed netnode does not increase the size of the database). however, since each netnode has a number, creating too many netnodes could lead to the exhaustion of the netnode numbers (the numbering starts at 0xFF000000)
   * remember that netnodes are automatically saved to the disk by the kernel.


   Advanced info:
   In fact a netnode may contain up to 256 arrays of arbitrary sized objects (not only the 4 listed above). Each array has an 8-bit tag. Usually tags are represented by character constants. For example, altvals and supvals are simply 2 of 256 arrays, with the tags 'A' and 'S' respectively. 
       



Attributes
----------

.. autoapisummary::

   ida_netnode.BADNODE
   ida_netnode.SIZEOF_nodeidx_t
   ida_netnode.cvar
   ida_netnode.MAXNAMESIZE
   ida_netnode.MAX_NODENAME_SIZE
   ida_netnode.MAXSPECSIZE
   ida_netnode.atag
   ida_netnode.stag
   ida_netnode.htag
   ida_netnode.vtag
   ida_netnode.ntag
   ida_netnode.ltag
   ida_netnode.NETMAP_IDX
   ida_netnode.NETMAP_VAL
   ida_netnode.NETMAP_STR
   ida_netnode.NETMAP_X8
   ida_netnode.NETMAP_V8
   ida_netnode.NETMAP_VAL_NDX
   ida_netnode.netnode_exist


Classes
-------

.. autoapisummary::

   ida_netnode.netnode


Functions
---------

.. autoapisummary::

   ida_netnode.exist


Module Contents
---------------

.. py:data:: BADNODE

   A number to represent a bad netnode reference.


.. py:data:: SIZEOF_nodeidx_t

.. py:class:: netnode(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: exist(_name: str) -> bool
      :staticmethod:


      Does the netnode with the specified name exist?



   .. py:method:: create(*args) -> bool


   .. py:method:: kill() -> None


   .. py:method:: get_name() -> ssize_t


   .. py:method:: rename(newname: str, namlen: size_t = 0) -> bool


   .. py:method:: valobj(*args) -> ssize_t


   .. py:method:: valstr() -> ssize_t


   .. py:method:: set(value: void const *) -> bool


   .. py:method:: delvalue() -> bool


   .. py:method:: set_long(x: nodeidx_t) -> bool


   .. py:method:: value_exists() -> bool


   .. py:method:: long_value() -> nodeidx_t


   .. py:method:: altval(*args) -> nodeidx_t


   .. py:method:: altval_ea(*args) -> nodeidx_t


   .. py:method:: altset(*args) -> bool


   .. py:method:: altset_ea(*args) -> bool


   .. py:method:: altdel_ea(*args) -> bool


   .. py:method:: easet(ea: ida_idaapi.ea_t, addr: ida_idaapi.ea_t, tag: uchar) -> bool


   .. py:method:: eaget(ea: ida_idaapi.ea_t, tag: uchar) -> ida_idaapi.ea_t


   .. py:method:: eadel(ea: ida_idaapi.ea_t, tag: uchar) -> bool


   .. py:method:: easet_idx(idx: nodeidx_t, addr: ida_idaapi.ea_t, tag: uchar) -> bool


   .. py:method:: eaget_idx(idx: nodeidx_t, tag: uchar) -> ida_idaapi.ea_t


   .. py:method:: easet_idx8(idx: uchar, addr: ida_idaapi.ea_t, tag: uchar) -> bool


   .. py:method:: eaget_idx8(idx: uchar, tag: uchar) -> ida_idaapi.ea_t


   .. py:method:: eadel_idx8(idx: uchar, tag: uchar) -> bool


   .. py:method:: altfirst(*args) -> nodeidx_t


   .. py:method:: altnext(*args) -> nodeidx_t


   .. py:method:: altlast(*args) -> nodeidx_t


   .. py:method:: altprev(*args) -> nodeidx_t


   .. py:method:: altshift(*args) -> size_t


   .. py:method:: charval(alt: nodeidx_t, tag: uchar) -> uchar


   .. py:method:: charset(alt: nodeidx_t, val: uchar, tag: uchar) -> bool


   .. py:method:: chardel(alt: nodeidx_t, tag: uchar) -> bool


   .. py:method:: charval_ea(ea: ida_idaapi.ea_t, tag: uchar) -> uchar


   .. py:method:: charset_ea(ea: ida_idaapi.ea_t, val: uchar, tag: uchar) -> bool


   .. py:method:: chardel_ea(ea: ida_idaapi.ea_t, tag: uchar) -> bool


   .. py:method:: charfirst(tag: uchar) -> nodeidx_t


   .. py:method:: charnext(cur: nodeidx_t, tag: uchar) -> nodeidx_t


   .. py:method:: charlast(tag: uchar) -> nodeidx_t


   .. py:method:: charprev(cur: nodeidx_t, tag: uchar) -> nodeidx_t


   .. py:method:: charshift(_from: nodeidx_t, to: nodeidx_t, size: nodeidx_t, tag: uchar) -> size_t


   .. py:method:: altval_idx8(alt: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: altset_idx8(alt: uchar, val: nodeidx_t, tag: uchar) -> bool


   .. py:method:: altdel_idx8(alt: uchar, tag: uchar) -> bool


   .. py:method:: altfirst_idx8(tag: uchar) -> nodeidx_t


   .. py:method:: altnext_idx8(cur: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: altlast_idx8(tag: uchar) -> nodeidx_t


   .. py:method:: altprev_idx8(cur: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: charval_idx8(alt: uchar, tag: uchar) -> uchar


   .. py:method:: charset_idx8(alt: uchar, val: uchar, tag: uchar) -> bool


   .. py:method:: chardel_idx8(alt: uchar, tag: uchar) -> bool


   .. py:method:: charfirst_idx8(tag: uchar) -> nodeidx_t


   .. py:method:: charnext_idx8(cur: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: charlast_idx8(tag: uchar) -> nodeidx_t


   .. py:method:: charprev_idx8(cur: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: altdel(*args) -> bool


   .. py:method:: altdel_all(*args) -> bool


   .. py:method:: supval(*args) -> ssize_t


   .. py:method:: supval_ea(*args) -> ssize_t


   .. py:method:: supstr(*args) -> ssize_t


   .. py:method:: supstr_ea(*args) -> ssize_t


   .. py:method:: supdel_ea(*args) -> bool


   .. py:method:: lower_bound(*args) -> nodeidx_t


   .. py:method:: lower_bound_ea(*args) -> nodeidx_t


   .. py:method:: supfirst(*args) -> nodeidx_t


   .. py:method:: supnext(*args) -> nodeidx_t


   .. py:method:: suplast(*args) -> nodeidx_t


   .. py:method:: supprev(*args) -> nodeidx_t


   .. py:method:: supshift(*args) -> size_t


   .. py:method:: supval_idx8(*args) -> ssize_t


   .. py:method:: supstr_idx8(alt: uchar, tag: uchar) -> ssize_t


   .. py:method:: supset_idx8(alt: uchar, value: void const *, tag: uchar) -> bool


   .. py:method:: supdel_idx8(alt: uchar, tag: uchar) -> bool


   .. py:method:: lower_bound_idx8(alt: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: supfirst_idx8(tag: uchar) -> nodeidx_t


   .. py:method:: supnext_idx8(alt: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: suplast_idx8(tag: uchar) -> nodeidx_t


   .. py:method:: supprev_idx8(alt: uchar, tag: uchar) -> nodeidx_t


   .. py:method:: supdel(*args) -> bool


   .. py:method:: supdel_all(tag: uchar) -> bool


   .. py:method:: supdel_range(idx1: nodeidx_t, idx2: nodeidx_t, tag: uchar) -> int


   .. py:method:: supdel_range_idx8(idx1: uchar, idx2: uchar, tag: uchar) -> int


   .. py:method:: hashval(*args) -> ssize_t


   .. py:method:: hashstr(*args) -> ssize_t


   .. py:method:: hashval_long(*args) -> nodeidx_t


   .. py:method:: hashset(*args) -> bool


   .. py:method:: hashset_idx(*args) -> bool


   .. py:method:: hashdel(*args) -> bool


   .. py:method:: hashfirst(*args) -> ssize_t


   .. py:method:: hashnext(*args) -> ssize_t


   .. py:method:: hashlast(*args) -> ssize_t


   .. py:method:: hashprev(*args) -> ssize_t


   .. py:method:: hashdel_all(*args) -> bool


   .. py:method:: blobsize(_start: nodeidx_t, tag: uchar) -> size_t


   .. py:method:: blobsize_ea(ea: ida_idaapi.ea_t, tag: uchar) -> size_t


   .. py:method:: setblob(buf: void const *, _start: nodeidx_t, tag: uchar) -> bool


   .. py:method:: setblob_ea(buf: void const *, ea: ida_idaapi.ea_t, tag: uchar) -> bool


   .. py:method:: delblob(_start: nodeidx_t, tag: uchar) -> int


   .. py:method:: delblob_ea(ea: ida_idaapi.ea_t, tag: uchar) -> int


   .. py:method:: blobshift(_from: nodeidx_t, to: nodeidx_t, size: nodeidx_t, tag: uchar) -> size_t


   .. py:method:: start() -> bool


   .. py:method:: end() -> bool


   .. py:method:: next() -> bool


   .. py:method:: prev() -> bool


   .. py:method:: copyto(destnode: netnode, count: nodeidx_t = 1) -> size_t


   .. py:method:: moveto(destnode: netnode, count: nodeidx_t = 1) -> size_t


   .. py:method:: index() -> nodeidx_t


   .. py:method:: getblob(start, tag) -> Union[bytes, None]

      Get a blob from a netnode.

      :param start: the index where the blob starts (it may span on multiple indexes)
      :param tag: the netnode tag
      :returns: a blob, or None



   .. py:method:: getclob(start, tag) -> Union[str, None]

      Get a large amount of text from a netnode.

      :param start: the index where the clob starts (it may span on multiple indexes)
      :param tag: the netnode tag
      :returns: a clob, or None



   .. py:method:: getblob_ea(ea: ida_idaapi.ea_t, tag: char) -> PyObject *


   .. py:method:: hashstr_buf(*args) -> PyObject *


   .. py:method:: hashset_buf(*args) -> bool


   .. py:method:: supset(*args) -> bool


   .. py:method:: supset_ea(*args) -> bool


.. py:data:: cvar

.. py:data:: MAXNAMESIZE

   Maximum length of a netnode name. WILL BE REMOVED IN THE FUTURE.


.. py:data:: MAX_NODENAME_SIZE

   Maximum length of a name. We permit names up to 32KB-1 bytes.


.. py:data:: MAXSPECSIZE

   Maximum length of strings or objects stored in a supval array element.


.. py:data:: atag

   Array of altvals.


.. py:data:: stag

   Array of supvals.


.. py:data:: htag

   Array of hashvals.


.. py:data:: vtag

   Value of netnode.


.. py:data:: ntag

   Name of netnode.


.. py:data:: ltag

   Links between netnodes.


.. py:data:: NETMAP_IDX

.. py:data:: NETMAP_VAL

.. py:data:: NETMAP_STR

.. py:data:: NETMAP_X8

.. py:data:: NETMAP_V8

.. py:data:: NETMAP_VAL_NDX

.. py:function:: exist(n: netnode) -> bool

.. py:data:: netnode_exist


```

`skills/idapython/docs/ida_offset.md`:

```md
# ida_offset

Medium-priority: Convert operands to offset references and calculate target addresses. Useful when analyzing code that references data structures or global variables.

## Key Functions

- `op_offset_ex(ea, n, ri)` - convert operand to reference using refinfo_t
- `op_offset(ea, n, ri)` - alias for op_offset_ex
- `op_plain_offset(ea, n, base)` - convert operand to reference with default type
- `get_offbase(ea, n)` - get offset base value for operand
- `get_offset_expression(ea, n, from, offset, flags)` - format offset as "name+displ" string
- `calc_offset_base(ea, n)` - calculate offset base from fixup/segment info
- `calc_target(from, ea, n, opval)` - calculate target address from offset reference
- `calc_basevalue(target, base)` - calculate reference base value
- `can_be_off32(ea)` - check if address contains valid OFF32, return target or BADADDR

Operand numbers may be ORed with OPND_OUTER for Motorola outer offsets.

## See Also
Full docs: skill/docs/ida_offset.rst

```

`skills/idapython/docs/ida_offset.rst`:

```rst
ida_offset
==========

.. py:module:: ida_offset

.. autoapi-nested-parse::

   Functions that deal with offsets.

   "Being an offset" is a characteristic of an operand. This means that operand or its part represent offset from some address in the program. This linear address is called "offset base". Some operands may have 2 offsets simultaneously. Generally, IDA doesn't handle this except for Motorola outer offsets. Thus there may be two offset values in an operand: simple offset and outer offset.
   Outer offsets are handled by specifying special operand number: it should be ORed with OPND_OUTER value.
   See bytes.hpp for further explanation of operand numbers. 
       



Functions
---------

.. autoapisummary::

   ida_offset.get_default_reftype
   ida_offset.op_offset_ex
   ida_offset.op_offset
   ida_offset.op_plain_offset
   ida_offset.get_offbase
   ida_offset.get_offset_expression
   ida_offset.get_offset_expr
   ida_offset.can_be_off32
   ida_offset.calc_offset_base
   ida_offset.calc_probable_base_by_value
   ida_offset.calc_reference_data
   ida_offset.add_refinfo_dref
   ida_offset.calc_target
   ida_offset.calc_basevalue


Module Contents
---------------

.. py:function:: get_default_reftype(ea: ida_idaapi.ea_t) -> reftype_t

   Get default reference type depending on the segment. 
           
   :returns: one of REF_OFF8, REF_OFF16, REF_OFF32, REF_OFF64


.. py:function:: op_offset_ex(ea: ida_idaapi.ea_t, n: int, ri: refinfo_t) -> bool

   Convert operand to a reference. To delete an offset, use clr_op_type() function. 
           
   :param ea: linear address. if 'ea' has unexplored bytes, try to convert them to
   * no segment: fail
   * 16bit segment: to 16bit word data
   * 32bit segment: to dword
   :param n: operand number (may be ORed with OPND_OUTER)
   * 0: first
   * 1: second
   * ...
   * 7: eighth operand


   * OPND_MASK: all operands
   :param ri: reference information
   :returns: success


.. py:function:: op_offset(*args) -> bool

   See op_offset_ex()


.. py:function:: op_plain_offset(ea: ida_idaapi.ea_t, n: int, base: ida_idaapi.ea_t) -> bool

   Convert operand to a reference with the default reference type.


.. py:function:: get_offbase(ea: ida_idaapi.ea_t, n: int) -> ida_idaapi.ea_t

   Get offset base value 
           
   :param ea: linear address
   :param n: 0..UA_MAXOP-1 operand number
   :returns: offset base or BADADDR


.. py:function:: get_offset_expression(ea: ida_idaapi.ea_t, n: int, _from: ida_idaapi.ea_t, offset: adiff_t, getn_flags: int = 0) -> str

   Get offset expression (in the form "offset name+displ"). This function uses offset translation function ( processor_t::translate) if your IDP module has such a function. Translation function is used to map linear addresses in the program (only for offsets).
   Example: suppose we have instruction at linear address 0x00011000: `mov     ax, [bx+7422h] ` and at ds:7422h: `array   dw      ... ` We want to represent the second operand with an offset expression, so then we call: `get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf);
                        |         |  |         |       |
                        |         |  |         |       +output buffer
                        |         |  |         +value of offset expression
                        |         |  +address offset value in the instruction
                        |         +the second operand
                        +address of instruction` and the function will return a colored string: `offset array ` 
           
   :param ea: start of instruction or data with the offset expression
   :param n: operand number (may be ORed with OPND_OUTER)
   * 0: first operand
   * 1: second operand
   * ...
   * 7: eighth operand
   :param offset: value of operand or its part. The function will return text representation of this value as offset expression.
   :param getn_flags: combination of:
   * GETN_APPZERO: meaningful only if the name refers to a structure. appends the struct field name if the field offset is zero
   * GETN_NODUMMY: do not generate dummy names for the expression but pretend they already exist (useful to verify that the offset expression can be represented)
   :returns: 0: can't convert to offset expression
   :returns: 1: ok, a simple offset expression
   :returns: 2: ok, a complex offset expression


.. py:function:: get_offset_expr(ea: ida_idaapi.ea_t, n: int, ri: refinfo_t, _from: ida_idaapi.ea_t, offset: adiff_t, getn_flags: int = 0) -> str

   See get_offset_expression()


.. py:function:: can_be_off32(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Does the specified address contain a valid OFF32 value?. For symbols in special segments the displacement is not taken into account. If yes, then the target address of OFF32 will be returned. If not, then BADADDR is returned. 
           


.. py:function:: calc_offset_base(ea: ida_idaapi.ea_t, n: int) -> ida_idaapi.ea_t

   Try to calculate the offset base This function takes into account the fixup information, current ds and cs values. 
           
   :param ea: the referencing instruction/data address
   :param n: operand number
   * 0: first operand
   * 1: second operand
   * ...
   * 7: eighth operand
   :returns: output base address or BADADDR


.. py:function:: calc_probable_base_by_value(ea: ida_idaapi.ea_t, off: int) -> ida_idaapi.ea_t

   Try to calculate the offset base. 2 bases are checked: current ds and cs. If fails, return BADADDR 
           


.. py:function:: calc_reference_data(target: ea_t *, base: ea_t *, _from: ida_idaapi.ea_t, ri: refinfo_t, opval: adiff_t) -> bool

   Calculate the target and base addresses of an offset expression. The calculated target and base addresses are returned in the locations pointed by 'base' and 'target'. In case 'ri.base' is BADADDR, the function calculates the offset base address from the referencing instruction/data address. The target address is copied from ri.target. If ri.target is BADADDR then the target is calculated using the base address and 'opval'. This function also checks if 'opval' matches the full value of the reference and takes in account the memory-mapping. 
           
   :param target: output target address
   :param base: output base address
   :param ri: reference info block from the database
   :param opval: operand value (usually op_t::value or op_t::addr)
   :returns: success


.. py:function:: add_refinfo_dref(insn: insn_t const &, _from: ida_idaapi.ea_t, ri: refinfo_t, opval: adiff_t, type: dref_t, opoff: int) -> ida_idaapi.ea_t

   Add xrefs for a reference from the given instruction ( insn_t::ea). This function creates a cross references to the target and the base. insn_t::add_off_drefs() calls this function to create xrefs for 'offset' operand. 
           
   :param insn: the referencing instruction
   :param ri: reference info block from the database
   :param opval: operand value (usually op_t::value or op_t::addr)
   :param type: type of xref
   :param opoff: offset of the operand from the start of instruction
   :returns: the target address of the reference


.. py:function:: calc_target(*args) -> ida_idaapi.ea_t

   This function has the following signatures:

       0. calc_target(from: ida_idaapi.ea_t, opval: adiff_t, ri: const refinfo_t &) -> ida_idaapi.ea_t
       1. calc_target(from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t, n: int, opval: adiff_t) -> ida_idaapi.ea_t

   # 0: calc_target(from: ida_idaapi.ea_t, opval: adiff_t, ri: const refinfo_t &) -> ida_idaapi.ea_t

   Calculate the target using the provided refinfo_t.


   # 1: calc_target(from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t, n: int, opval: adiff_t) -> ida_idaapi.ea_t

   Retrieve refinfo_t structure and calculate the target.


.. py:function:: calc_basevalue(target: ida_idaapi.ea_t, base: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Calculate the value of the reference base.



```

`skills/idapython/docs/ida_pro.md`:

```md
# ida_pro

Medium-priority: Core types, constants, and utility functions. Foundation module for platform detection and common operations.

## Key Constants

- `IDA_SDK_VERSION` - SDK version (9.2)
- `MAXSTR` - maximum string size
- `BADDIFF` - invalid diff value
- `FMT_EA` / `FMT_64` / `FMT_Z` - format string macros
- `CP_UTF8` / `CP_UTF16` - codepage constants
- `ENC_UTF8` / `ENC_UTF16LE` / `ENC_WIN1252` - encoding constants

## Key Vector Types

- `intvec_t` / `uintvec_t` - int/uint vectors
- `int64vec_t` / `uint64vec_t` - 64-bit int vectors
- `boolvec_t` - boolean vector
- `strvec_t` - string vector
- `eavec_t` - ea_t vector
- Standard methods: `push_back()`, `pop_back()`, `size()`, `at()`, `clear()`, `reserve()`, `find()`, `has()`, `add_unique()`

## Key Functions

- `qexit(code)` - shutdown IDA and exit
- `extend_sign(v, nbytes, sign_extend)` - sign/zero extend value to 64 bits
- `log2ceil(d64)` / `log2floor(d64)` - log2 calculations
- `bitcountr_zero(x)` - count trailing zero bits
- `is_main_thread()` - check if running on main thread
- `get_physical_core_count()` / `get_logical_core_count()` - CPU core info

## Platform Macros

Preprocessor defines: `__NT__` (Windows), `__LINUX__`, `__MAC__`, `__EA64__` (64-bit addresses), `__X64__` / `__X86__`, `__ARM__`, `__PPC__`

## See Also
Full docs: skill/docs/ida_pro.rst

```

`skills/idapython/docs/ida_pro.rst`:

```rst
ida_pro
=======

.. py:module:: ida_pro

.. autoapi-nested-parse::

   This is the first header included in the IDA project.

   It defines the most common types, functions and data. Also, it tries to make system dependent definitions.
   The following preprocessor macros are used in the project (the list may be incomplete)
   Platform must be specified as one of:
   __NT__ - MS Windows (all platforms) 
    __LINUX__ - Linux 
    __MAC__ - MAC OS X
   __EA64__ - 64-bit address size (sizeof(ea_t)==8) 
    __X86__ - 32-bit debug servers (sizeof(void*)==4) 
    __X64__ - x64 processor (sizeof(void*)==8) default 
    __PPC__ - PowerPC 
    __ARM__ - ARM 
       



Attributes
----------

.. autoapisummary::

   ida_pro.BADDIFF
   ida_pro.IDA_SDK_VERSION
   ida_pro.BADMEMSIZE
   ida_pro.MAXSTR
   ida_pro.FMT_64
   ida_pro.FMT_Z
   ida_pro.FMT_ZX
   ida_pro.FMT_ZS
   ida_pro.FMT_EA
   ida_pro.IDBDEC_ESCAPE
   ida_pro.CP_BOM
   ida_pro.UTF8_BOM
   ida_pro.UTF16LE_BOM
   ida_pro.UTF16BE_BOM
   ida_pro.UTF32LE_BOM
   ida_pro.UTF32BE_BOM
   ida_pro.CP_ELLIPSIS
   ida_pro.UTF8_ELLIPSIS
   ida_pro.CP_REPLCHAR
   ida_pro.UTF8_REPLCHAR
   ida_pro.MAX_UTF8_SEQ_LEN
   ida_pro.CEF_RETERR
   ida_pro.ENC_WIN1252
   ida_pro.ENC_UTF8
   ida_pro.ENC_MUTF8
   ida_pro.ENC_UTF16
   ida_pro.ENC_UTF16LE
   ida_pro.ENC_UTF16BE
   ida_pro.ENC_UTF32
   ida_pro.ENC_UTF32LE
   ida_pro.ENC_UTF32BE
   ida_pro.CP_UTF8
   ida_pro.CP_UTF16
   ida_pro.SUBSTCHAR
   ida_pro.IOREDIR_INPUT
   ida_pro.IOREDIR_OUTPUT
   ida_pro.IOREDIR_APPEND
   ida_pro.IOREDIR_QUOTED
   ida_pro.QWCONTINUED
   ida_pro.QWNOHANG
   ida_pro.TCT_UNKNOWN
   ida_pro.TCT_OWNER
   ida_pro.TCT_NOT_OWNER
   ida_pro.cvar
   ida_pro.NULL_PIPE_HANDLE
   ida_pro.longlongvec_t
   ida_pro.ulonglongvec_t
   ida_pro.svalvec_t
   ida_pro.eavec_t


Classes
-------

.. autoapisummary::

   ida_pro.qrefcnt_obj_t
   ida_pro.channel_redir_t
   ida_pro.plugin_options_t
   ida_pro.instant_dbgopts_t
   ida_pro.qmutex_locker_t
   ida_pro.intvec_t
   ida_pro.uintvec_t
   ida_pro.int64vec_t
   ida_pro.uint64vec_t
   ida_pro.boolvec_t
   ida_pro.strvec_t
   ida_pro.sizevec_t
   ida_pro.uchar_array
   ida_pro.tid_array
   ida_pro.ea_array
   ida_pro.sel_array
   ida_pro.uval_array
   ida_pro.uchar_pointer
   ida_pro.ushort_pointer
   ida_pro.uint_pointer
   ida_pro.sint8_pointer
   ida_pro.int8_pointer
   ida_pro.uint8_pointer
   ida_pro.int16_pointer
   ida_pro.uint16_pointer
   ida_pro.int32_pointer
   ida_pro.uint32_pointer
   ida_pro.int64_pointer
   ida_pro.uint64_pointer
   ida_pro.ssize_pointer
   ida_pro.bool_pointer
   ida_pro.char_pointer
   ida_pro.short_pointer
   ida_pro.int_pointer
   ida_pro.ea_pointer
   ida_pro.sel_pointer
   ida_pro.asize_pointer
   ida_pro.adiff_pointer
   ida_pro.uval_pointer
   ida_pro.sval_pointer
   ida_pro.ea32_pointer
   ida_pro.ea64_pointer
   ida_pro.flags_pointer
   ida_pro.flags64_pointer
   ida_pro.tid_pointer


Functions
---------

.. autoapisummary::

   ida_pro.qatoll
   ida_pro.qexit
   ida_pro.log2ceil
   ida_pro.log2floor
   ida_pro.bitcountr_zero
   ida_pro.extend_sign
   ida_pro.readbytes
   ida_pro.writebytes
   ida_pro.reloc_value
   ida_pro.qvector_reserve
   ida_pro.relocate_relobj
   ida_pro.is_cvt64
   ida_pro.quote_cmdline_arg
   ida_pro.parse_dbgopts
   ida_pro.check_process_exit
   ida_pro.is_control_tty
   ida_pro.qdetach_tty
   ida_pro.qcontrol_tty
   ida_pro.qthread_equal
   ida_pro.is_main_thread
   ida_pro.get_login_name
   ida_pro.get_physical_core_count
   ida_pro.get_logical_core_count
   ida_pro.get_available_core_count
   ida_pro.qstrvec_t_create
   ida_pro.qstrvec_t_destroy
   ida_pro.qstrvec_t_get_clink
   ida_pro.qstrvec_t_get_clink_ptr
   ida_pro.qstrvec_t_assign
   ida_pro.qstrvec_t_addressof
   ida_pro.qstrvec_t_set
   ida_pro.qstrvec_t_from_list
   ida_pro.qstrvec_t_size
   ida_pro.qstrvec_t_get
   ida_pro.qstrvec_t_add
   ida_pro.qstrvec_t_clear
   ida_pro.qstrvec_t_insert
   ida_pro.qstrvec_t_remove
   ida_pro.str2user


Module Contents
---------------

.. py:data:: BADDIFF

.. py:data:: IDA_SDK_VERSION

   IDA SDK v9.2.


.. py:data:: BADMEMSIZE

.. py:data:: MAXSTR

   maximum string size


.. py:function:: qatoll(nptr: str) -> int64

.. py:data:: FMT_64

.. py:data:: FMT_Z

.. py:data:: FMT_ZX

.. py:data:: FMT_ZS

.. py:data:: FMT_EA

.. py:function:: qexit(code: int) -> None

   Call qatexit functions, shut down UI and kernel, and exit. 
           
   :param code: exit code


.. py:function:: log2ceil(d64: uint64) -> int

   calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 == 0 
           


.. py:function:: log2floor(d64: uint64) -> int

.. py:function:: bitcountr_zero(x: uint64) -> int

   count the number of consecutive trailing zero bits (line C++20 std::countr_zero()) 
           


.. py:function:: extend_sign(v: uint64, nbytes: int, sign_extend: bool) -> uint64

   Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v' is considered to be of size 'nbytes'. 
           


.. py:function:: readbytes(h: int, res: uint32 *, size: int, mf: bool) -> int

   Read at most 4 bytes from file. 
           
   :param h: file handle
   :param res: value read from file
   :param size: size of value in bytes (1,2,4)
   :param mf: is MSB first?
   :returns: 0 on success, nonzero otherwise


.. py:function:: writebytes(h: int, l: int, size: int, mf: bool) -> int

   Write at most 4 bytes to file. 
           
   :param h: file handle
   :param l: value to write
   :param size: size of value in bytes (1,2,4)
   :param mf: is MSB first?
   :returns: 0 on success, nonzero otherwise


.. py:function:: reloc_value(value: void *, size: int, delta: adiff_t, mf: bool) -> None

.. py:function:: qvector_reserve(vec: void *, old: void *, cnt: size_t, elsize: size_t) -> void *

   Change capacity of given qvector. 
           
   :param vec: a pointer to a qvector
   :param old: a pointer to the qvector's array
   :param cnt: number of elements to reserve
   :param elsize: size of each element
   :returns: a pointer to the newly allocated array


.. py:class:: qrefcnt_obj_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: refcnt
      :type:  int

      counter 
              



   .. py:method:: release() -> None

      Call destructor. We use release() instead of operator delete() to maintain binary compatibility with all compilers (vc and gcc use different vtable layouts for operator delete) 
              



.. py:function:: relocate_relobj(_relobj: relobj_t *, ea: ida_idaapi.ea_t, mf: bool) -> bool

.. py:data:: IDBDEC_ESCAPE

   convert non-printable characters to C escapes (
   , \xNN, \uNNNN)


.. py:data:: CP_BOM

.. py:data:: UTF8_BOM

.. py:data:: UTF16LE_BOM

.. py:data:: UTF16BE_BOM

.. py:data:: UTF32LE_BOM

.. py:data:: UTF32BE_BOM

.. py:data:: CP_ELLIPSIS

.. py:data:: UTF8_ELLIPSIS

.. py:data:: CP_REPLCHAR

.. py:data:: UTF8_REPLCHAR

.. py:data:: MAX_UTF8_SEQ_LEN

.. py:function:: is_cvt64() -> bool

   is IDA converting IDB into I64?


.. py:data:: CEF_RETERR

.. py:data:: ENC_WIN1252

.. py:data:: ENC_UTF8

.. py:data:: ENC_MUTF8

.. py:data:: ENC_UTF16

.. py:data:: ENC_UTF16LE

.. py:data:: ENC_UTF16BE

.. py:data:: ENC_UTF32

.. py:data:: ENC_UTF32LE

.. py:data:: ENC_UTF32BE

.. py:data:: CP_UTF8

.. py:data:: CP_UTF16

   UTF-16 codepage.


.. py:data:: SUBSTCHAR

   default char, used if a char cannot be represented in a codepage


.. py:class:: channel_redir_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: fd
      :type:  int

      channel number



   .. py:attribute:: file
      :type:  str

      file name to redirect to/from. if empty, the channel must be closed. 
              



   .. py:attribute:: flags
      :type:  int

      i/o redirection flags 
              



   .. py:method:: is_input() -> bool


   .. py:method:: is_output() -> bool


   .. py:method:: is_append() -> bool


   .. py:method:: is_quoted() -> bool


   .. py:attribute:: start
      :type:  int

      begin of the redirection string in the command line



   .. py:attribute:: length
      :type:  int

      length of the redirection string in the command line



.. py:data:: IOREDIR_INPUT

   input redirection


.. py:data:: IOREDIR_OUTPUT

   output redirection


.. py:data:: IOREDIR_APPEND

   append, do not overwrite the output file


.. py:data:: IOREDIR_QUOTED

   the file name was quoted


.. py:function:: quote_cmdline_arg(arg: str) -> bool

   Quote a command line argument if it contains escape characters. For example, *.c will be converted into "*.c" because * may be inadvertently expanded by the shell 
           
   :returns: true: modified 'arg'


.. py:class:: plugin_options_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: find(name: str) -> plugin_option_t const *


   .. py:method:: erase(name: str) -> bool


.. py:class:: instant_dbgopts_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: debmod
      :type:  str

      name of debugger module



   .. py:attribute:: env
      :type:  str

      config variables for debmod. example: DEFAULT_CPU=13;MAXPACKETSIZE=-1



   .. py:attribute:: host
      :type:  str

      remote hostname (if remote debugging)



   .. py:attribute:: port
      :type:  int

      port number for the remote debugger server



   .. py:attribute:: pid
      :type:  int

      process to attach to (-1: ask the user)



   .. py:attribute:: event_id
      :type:  int

      event to trigger upon attaching



   .. py:attribute:: attach
      :type:  bool

      should attach to a process?



.. py:function:: parse_dbgopts(ido: instant_dbgopts_t, r_switch: str) -> bool

   Parse the -r command line switch (for instant debugging). r_switch points to the value of the -r switch. Example: win32@localhost+ 
           
   :returns: true-ok, false-parse error


.. py:data:: QWCONTINUED

.. py:data:: QWNOHANG

.. py:function:: check_process_exit(handle: void *, exit_code: int *, msecs: int = -1) -> int

   Check whether process has terminated or not. 
           
   :param handle: process handle to wait for
   :param exit_code: pointer to the buffer for the exit code
   :returns: 0: process has exited, and the exit code is available. if *exit_code < 0: the process was killed with a signal -*exit_code
   :returns: 1: process has not exited yet
   :returns: -1: error happened, see error code for winerr() in *exit_code


.. py:data:: TCT_UNKNOWN

.. py:data:: TCT_OWNER

.. py:data:: TCT_NOT_OWNER

.. py:function:: is_control_tty(fd: int) -> enum tty_control_t

   Check if the current process is the owner of the TTY specified by 'fd' (typically an opened descriptor to /dev/tty). 
           


.. py:function:: qdetach_tty() -> None

   If the current terminal is the controlling terminal of the calling process, give up this controlling terminal. 
           


.. py:function:: qcontrol_tty() -> None

   Make the current terminal the controlling terminal of the calling process. 
           


.. py:function:: qthread_equal(q1: __qthread_t, q2: __qthread_t) -> bool

   Are two threads equal?


.. py:function:: is_main_thread() -> bool

   Are we running in the main thread?


.. py:class:: qmutex_locker_t(_lock: __qmutex_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:function:: get_login_name() -> str

   Get the user name for the current desktop session 
           
   :returns: success


.. py:function:: get_physical_core_count() -> int

   Get the total CPU physical core count 
           
   :returns: the physical core count, or -1 on error


.. py:function:: get_logical_core_count() -> int

   Get the total CPU logical core count 
           
   :returns: the logical core count, or -1 on error


.. py:function:: get_available_core_count() -> int

   Get the number of logical CPU cores available to the current process if supported by the OS. 
           
   :returns: the logical core count available for the process, or -1 on error


.. py:class:: intvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> int &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> int const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: intvec_t) -> None


   .. py:method:: extract() -> int *


   .. py:method:: inject(s: int *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< int >::const_iterator


   .. py:method:: end(*args) -> qvector< int >::const_iterator


   .. py:method:: insert(it: qvector< int >::iterator, x: int const &) -> qvector< int >::iterator


   .. py:method:: erase(*args) -> qvector< int >::iterator


   .. py:method:: find(*args) -> qvector< int >::const_iterator


   .. py:method:: has(x: int const &) -> bool


   .. py:method:: add_unique(x: int const &) -> bool


   .. py:method:: append(x: int const &) -> None


   .. py:method:: extend(x: intvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: cvar

.. py:data:: NULL_PIPE_HANDLE

.. py:class:: uintvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> unsigned int &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> unsigned int const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: uintvec_t) -> None


   .. py:method:: extract() -> unsigned int *


   .. py:method:: inject(s: unsigned int *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< unsigned int >::const_iterator


   .. py:method:: end(*args) -> qvector< unsigned int >::const_iterator


   .. py:method:: insert(it: qvector< unsigned int >::iterator, x: unsigned int const &) -> qvector< unsigned int >::iterator


   .. py:method:: erase(*args) -> qvector< unsigned int >::iterator


   .. py:method:: find(*args) -> qvector< unsigned int >::const_iterator


   .. py:method:: has(x: unsigned int const &) -> bool


   .. py:method:: add_unique(x: unsigned int const &) -> bool


   .. py:method:: append(x: unsigned int const &) -> None


   .. py:method:: extend(x: uintvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: int64vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> long long &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> long long const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: int64vec_t) -> None


   .. py:method:: extract() -> long long *


   .. py:method:: inject(s: long long *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< long long >::const_iterator


   .. py:method:: end(*args) -> qvector< long long >::const_iterator


   .. py:method:: insert(it: qvector< long long >::iterator, x: long long const &) -> qvector< long long >::iterator


   .. py:method:: erase(*args) -> qvector< long long >::iterator


   .. py:method:: find(*args) -> qvector< long long >::const_iterator


   .. py:method:: has(x: long long const &) -> bool


   .. py:method:: add_unique(x: long long const &) -> bool


   .. py:method:: append(x: long long const &) -> None


   .. py:method:: extend(x: int64vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: uint64vec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> unsigned long long &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> unsigned long long const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: uint64vec_t) -> None


   .. py:method:: extract() -> unsigned long long *


   .. py:method:: inject(s: unsigned long long *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< unsigned long long >::const_iterator


   .. py:method:: end(*args) -> qvector< unsigned long long >::const_iterator


   .. py:method:: insert(it: qvector< unsigned long long >::iterator, x: unsigned long long const &) -> qvector< unsigned long long >::iterator


   .. py:method:: erase(*args) -> qvector< unsigned long long >::iterator


   .. py:method:: find(*args) -> qvector< unsigned long long >::const_iterator


   .. py:method:: has(x: unsigned long long const &) -> bool


   .. py:method:: add_unique(x: unsigned long long const &) -> bool


   .. py:method:: append(x: unsigned long long const &) -> None


   .. py:method:: extend(x: uint64vec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: boolvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> bool &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> bool const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: boolvec_t) -> None


   .. py:method:: extract() -> bool *


   .. py:method:: inject(s: bool *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< bool >::const_iterator


   .. py:method:: end(*args) -> qvector< bool >::const_iterator


   .. py:method:: insert(it: qvector< bool >::iterator, x: bool const &) -> qvector< bool >::iterator


   .. py:method:: erase(*args) -> qvector< bool >::iterator


   .. py:method:: find(*args) -> qvector< bool >::const_iterator


   .. py:method:: has(x: bool const &) -> bool


   .. py:method:: add_unique(x: bool const &) -> bool


   .. py:method:: append(x: bool const &) -> None


   .. py:method:: extend(x: boolvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: strvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> simpleline_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> simpleline_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: strvec_t) -> None


   .. py:method:: extract() -> simpleline_t *


   .. py:method:: inject(s: simpleline_t *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< simpleline_t >::const_iterator


   .. py:method:: end(*args) -> qvector< simpleline_t >::const_iterator


   .. py:method:: insert(it: qvector< simpleline_t >::iterator, x: simpleline_t const &) -> qvector< simpleline_t >::iterator


   .. py:method:: erase(*args) -> qvector< simpleline_t >::iterator


   .. py:method:: append(x: simpleline_t const &) -> None


   .. py:method:: extend(x: strvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: sizevec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> size_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> size_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: sizevec_t) -> None


   .. py:method:: extract() -> size_t *


   .. py:method:: inject(s: size_t *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< size_t >::const_iterator


   .. py:method:: end(*args) -> qvector< size_t >::const_iterator


   .. py:method:: insert(it: qvector< size_t >::iterator, x: size_t const &) -> qvector< size_t >::iterator


   .. py:method:: erase(*args) -> qvector< size_t >::iterator


   .. py:method:: find(*args) -> qvector< size_t >::const_iterator


   .. py:method:: has(x: size_t const &) -> bool


   .. py:method:: add_unique(x: size_t const &) -> bool


   .. py:method:: append(x: size_t const &) -> None


   .. py:method:: extend(x: sizevec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:function:: qstrvec_t_create() -> PyObject *

.. py:function:: qstrvec_t_destroy(py_obj: PyObject *) -> bool

.. py:function:: qstrvec_t_get_clink(_self: PyObject *) -> qstrvec_t *

.. py:function:: qstrvec_t_get_clink_ptr(_self: PyObject *) -> PyObject *

.. py:function:: qstrvec_t_assign(_self: PyObject *, other: PyObject *) -> bool

.. py:function:: qstrvec_t_addressof(_self: PyObject *, idx: size_t) -> PyObject *

.. py:function:: qstrvec_t_set(_self: PyObject *, idx: size_t, s: str) -> bool

.. py:function:: qstrvec_t_from_list(_self: PyObject *, py_list: PyObject *) -> bool

.. py:function:: qstrvec_t_size(_self: PyObject *) -> size_t

.. py:function:: qstrvec_t_get(_self: PyObject *, idx: size_t) -> PyObject *

.. py:function:: qstrvec_t_add(_self: PyObject *, s: str) -> bool

.. py:function:: qstrvec_t_clear(_self: PyObject *, qclear: bool) -> bool

.. py:function:: qstrvec_t_insert(_self: PyObject *, idx: size_t, s: str) -> bool

.. py:function:: qstrvec_t_remove(_self: PyObject *, idx: size_t) -> bool

.. py:function:: str2user(str)

   Insert C-style escape characters to string

   :param str: the input string
   :returns: new string with escape characters inserted, or None


.. py:class:: uchar_array(nelements: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: cast() -> uchar *


   .. py:method:: frompointer(t: uchar *) -> uchar_array *
      :staticmethod:



.. py:class:: tid_array(nelements: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: cast() -> tid_t *


   .. py:method:: frompointer(t: tid_t *) -> tid_array *
      :staticmethod:



.. py:class:: ea_array(nelements: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: cast() -> ea_t *


   .. py:method:: frompointer(t: ea_t *) -> ea_array *
      :staticmethod:



.. py:class:: sel_array(nelements: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: cast() -> sel_t *


   .. py:method:: frompointer(t: sel_t *) -> sel_array *
      :staticmethod:



.. py:class:: uval_array(nelements: size_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: cast() -> uval_t *


   .. py:method:: frompointer(t: uval_t *) -> uval_array *
      :staticmethod:



.. py:class:: uchar_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: uchar) -> None


   .. py:method:: value() -> uchar


   .. py:method:: cast() -> uchar *


   .. py:method:: frompointer(t: uchar *) -> uchar_pointer *
      :staticmethod:



.. py:class:: ushort_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: ushort) -> None


   .. py:method:: value() -> ushort


   .. py:method:: cast() -> ushort *


   .. py:method:: frompointer(t: ushort *) -> ushort_pointer *
      :staticmethod:



.. py:class:: uint_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: uint) -> None


   .. py:method:: value() -> uint


   .. py:method:: cast() -> uint *


   .. py:method:: frompointer(t: uint *) -> uint_pointer *
      :staticmethod:



.. py:class:: sint8_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: sint8) -> None


   .. py:method:: value() -> sint8


   .. py:method:: cast() -> sint8 *


   .. py:method:: frompointer(t: sint8 *) -> sint8_pointer *
      :staticmethod:



.. py:class:: int8_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int8) -> None


   .. py:method:: value() -> int8


   .. py:method:: cast() -> int8 *


   .. py:method:: frompointer(t: int8 *) -> int8_pointer *
      :staticmethod:



.. py:class:: uint8_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: uint8) -> None


   .. py:method:: value() -> uint8


   .. py:method:: cast() -> uint8 *


   .. py:method:: frompointer(t: uint8 *) -> uint8_pointer *
      :staticmethod:



.. py:class:: int16_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int16) -> None


   .. py:method:: value() -> int16


   .. py:method:: cast() -> int16 *


   .. py:method:: frompointer(t: int16 *) -> int16_pointer *
      :staticmethod:



.. py:class:: uint16_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: uint16) -> None


   .. py:method:: value() -> uint16


   .. py:method:: cast() -> uint16 *


   .. py:method:: frompointer(t: uint16 *) -> uint16_pointer *
      :staticmethod:



.. py:class:: int32_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int) -> None


   .. py:method:: value() -> int


   .. py:method:: cast() -> int32 *


   .. py:method:: frompointer(t: int32 *) -> int32_pointer *
      :staticmethod:



.. py:class:: uint32_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int) -> None


   .. py:method:: value() -> int


   .. py:method:: cast() -> uint32 *


   .. py:method:: frompointer(t: uint32 *) -> uint32_pointer *
      :staticmethod:



.. py:class:: int64_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int64) -> None


   .. py:method:: value() -> int64


   .. py:method:: cast() -> int64 *


   .. py:method:: frompointer(t: int64 *) -> int64_pointer *
      :staticmethod:



.. py:class:: uint64_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: uint64) -> None


   .. py:method:: value() -> uint64


   .. py:method:: cast() -> uint64 *


   .. py:method:: frompointer(t: uint64 *) -> uint64_pointer *
      :staticmethod:



.. py:class:: ssize_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: ssize_t) -> None


   .. py:method:: value() -> ssize_t


   .. py:method:: cast() -> ssize_t *


   .. py:method:: frompointer(t: ssize_t *) -> ssize_pointer *
      :staticmethod:



.. py:class:: bool_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: bool) -> None


   .. py:method:: value() -> bool


   .. py:method:: cast() -> bool *


   .. py:method:: frompointer(t: bool *) -> bool_pointer *
      :staticmethod:



.. py:class:: char_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: char) -> None


   .. py:method:: value() -> char


   .. py:method:: cast() -> char *


   .. py:method:: frompointer(t: char *) -> char_pointer *
      :staticmethod:



.. py:class:: short_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: short) -> None


   .. py:method:: value() -> short


   .. py:method:: cast() -> short *


   .. py:method:: frompointer(t: short *) -> short_pointer *
      :staticmethod:



.. py:class:: int_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int) -> None


   .. py:method:: value() -> int


   .. py:method:: cast() -> int *


   .. py:method:: frompointer(t: int *) -> int_pointer *
      :staticmethod:



.. py:class:: ea_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: ida_idaapi.ea_t) -> None


   .. py:method:: value() -> ida_idaapi.ea_t


   .. py:method:: cast() -> ea_t *


   .. py:method:: frompointer(t: ea_t *) -> ea_pointer *
      :staticmethod:



.. py:class:: sel_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: sel_t) -> None


   .. py:method:: value() -> sel_t


   .. py:method:: cast() -> sel_t *


   .. py:method:: frompointer(t: sel_t *) -> sel_pointer *
      :staticmethod:



.. py:class:: asize_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: asize_t) -> None


   .. py:method:: value() -> asize_t


   .. py:method:: cast() -> asize_t *


   .. py:method:: frompointer(t: asize_t *) -> asize_pointer *
      :staticmethod:



.. py:class:: adiff_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: adiff_t) -> None


   .. py:method:: value() -> adiff_t


   .. py:method:: cast() -> adiff_t *


   .. py:method:: frompointer(t: adiff_t *) -> adiff_pointer *
      :staticmethod:



.. py:class:: uval_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int) -> None


   .. py:method:: value() -> int


   .. py:method:: cast() -> uval_t *


   .. py:method:: frompointer(t: uval_t *) -> uval_pointer *
      :staticmethod:



.. py:class:: sval_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: int) -> None


   .. py:method:: value() -> int


   .. py:method:: cast() -> sval_t *


   .. py:method:: frompointer(t: sval_t *) -> sval_pointer *
      :staticmethod:



.. py:class:: ea32_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: ea32_t) -> None


   .. py:method:: value() -> ea32_t


   .. py:method:: cast() -> ea32_t *


   .. py:method:: frompointer(t: ea32_t *) -> ea32_pointer *
      :staticmethod:



.. py:class:: ea64_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: ea64_t) -> None


   .. py:method:: value() -> ea64_t


   .. py:method:: cast() -> ea64_t *


   .. py:method:: frompointer(t: ea64_t *) -> ea64_pointer *
      :staticmethod:



.. py:class:: flags_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: flags_t) -> None


   .. py:method:: value() -> flags_t


   .. py:method:: cast() -> flags_t *


   .. py:method:: frompointer(t: flags_t *) -> flags_pointer *
      :staticmethod:



.. py:class:: flags64_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: flags64_t) -> None


   .. py:method:: value() -> flags64_t


   .. py:method:: cast() -> flags64_t *


   .. py:method:: frompointer(t: flags64_t *) -> flags64_pointer *
      :staticmethod:



.. py:class:: tid_pointer

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: assign(value: tid_t) -> None


   .. py:method:: value() -> tid_t


   .. py:method:: cast() -> tid_t *


   .. py:method:: frompointer(t: tid_t *) -> tid_pointer *
      :staticmethod:



.. py:data:: longlongvec_t

.. py:data:: ulonglongvec_t

.. py:data:: svalvec_t

.. py:data:: eavec_t


```

`skills/idapython/docs/ida_problems.md`:

```md
# ida_problems

Low-priority: Manage problem lists for tracking analysis issues. IDA maintains these lists automatically; mainly used for debugging analysis failures.

## Key Functions

- `remember_problem(type, ea, msg)` - add address to problem list with optional message
- `get_problem(type, lowea)` - get next problem address >= lowea
- `forget_problem(type, ea)` - remove address from problem list
- `is_problem_present(type, ea)` - check if address is in problem list
- `get_problem_desc(type, ea)` - get human-readable problem description
- `get_problem_name(type, longname)` - get problem list name

## Problem List Types

- `PR_DISASM` - can't disassemble
- `PR_HEAD` - already head
- `PR_ILLADDR` - execution flows beyond limits
- `PR_BADSTACK` - failed to trace stack pointer
- `PR_NOXREFS` - can't find references
- `PR_NOBASE` - can't find offset base
- `PR_ATTN` - attention, probably erroneous
- `PR_FINAL` - IDA decision to convert to instruction/data
- `PR_ROLLED` - IDA decision was wrong and rolled back
- `PR_COLLISION` - FLAIR collision
- `PR_DECIMP` - FLAIR match indecision

View problems from View → Subviews → Problems menu.

## See Also
Full docs: skill/docs/ida_problems.rst

```

`skills/idapython/docs/ida_problems.rst`:

```rst
ida_problems
============

.. py:module:: ida_problems

.. autoapi-nested-parse::

   Functions that deal with the list of problems.

   There are several problem lists. An address may be inserted to any list. The kernel simply maintains these lists, no additional processing is done.
   The problem lists are accessible for the user from the View->Subviews->Problems menu item.
   Addresses in the lists are kept sorted. In general IDA just maintains these lists without using them during analysis (except PR_ROLLED). 
       



Attributes
----------

.. autoapisummary::

   ida_problems.cvar
   ida_problems.PR_NOBASE
   ida_problems.PR_NONAME
   ida_problems.PR_NOFOP
   ida_problems.PR_NOCMT
   ida_problems.PR_NOXREFS
   ida_problems.PR_JUMP
   ida_problems.PR_DISASM
   ida_problems.PR_HEAD
   ida_problems.PR_ILLADDR
   ida_problems.PR_MANYLINES
   ida_problems.PR_BADSTACK
   ida_problems.PR_ATTN
   ida_problems.PR_FINAL
   ida_problems.PR_ROLLED
   ida_problems.PR_COLLISION
   ida_problems.PR_DECIMP
   ida_problems.PR_END


Functions
---------

.. autoapisummary::

   ida_problems.get_problem_desc
   ida_problems.remember_problem
   ida_problems.get_problem
   ida_problems.forget_problem
   ida_problems.get_problem_name
   ida_problems.is_problem_present
   ida_problems.was_ida_decision


Module Contents
---------------

.. py:function:: get_problem_desc(t: problist_id_t, ea: ida_idaapi.ea_t) -> str

   Get the human-friendly description of the problem, if one was provided to remember_problem. 
           
   :param t: problem list type.
   :param ea: linear address.
   :returns: the message length or -1 if none


.. py:function:: remember_problem(type: problist_id_t, ea: ida_idaapi.ea_t, msg: str = None) -> None

   Insert an address to a list of problems. Display a message saying about the problem (except of PR_ATTN,PR_FINAL) PR_JUMP is temporarily ignored. 
           
   :param type: problem list type
   :param ea: linear address
   :param msg: a user-friendly message to be displayed instead of the default more generic one associated with the type of problem. Defaults to nullptr.


.. py:function:: get_problem(type: problist_id_t, lowea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get an address from the specified problem list. The address is not removed from the list. 
           
   :param type: problem list type
   :param lowea: the returned address will be higher or equal than the specified address
   :returns: linear address or BADADDR


.. py:function:: forget_problem(type: problist_id_t, ea: ida_idaapi.ea_t) -> bool

   Remove an address from a problem list 
           
   :param type: problem list type
   :param ea: linear address
   :returns: success


.. py:function:: get_problem_name(type: problist_id_t, longname: bool = True) -> str

   Get problem list description.


.. py:function:: is_problem_present(t: problist_id_t, ea: ida_idaapi.ea_t) -> bool

   Check if the specified address is present in the problem list.


.. py:function:: was_ida_decision(ea: ida_idaapi.ea_t) -> bool

.. py:data:: cvar

.. py:data:: PR_NOBASE

   Can't find offset base.


.. py:data:: PR_NONAME

   Can't find name.


.. py:data:: PR_NOFOP

   Can't find forced op (not used anymore)


.. py:data:: PR_NOCMT

   Can't find comment (not used anymore)


.. py:data:: PR_NOXREFS

   Can't find references.


.. py:data:: PR_JUMP

   Jump by table !!!! ignored.


.. py:data:: PR_DISASM

   Can't disasm.


.. py:data:: PR_HEAD

   Already head.


.. py:data:: PR_ILLADDR

   Exec flows beyond limits.


.. py:data:: PR_MANYLINES

   Too many lines.


.. py:data:: PR_BADSTACK

   Failed to trace the value of the stack pointer.


.. py:data:: PR_ATTN

   Attention! Probably erroneous situation.


.. py:data:: PR_FINAL

   Decision to convert to instruction/data is made by IDA.


.. py:data:: PR_ROLLED

   The decision made by IDA was wrong and rolled back.


.. py:data:: PR_COLLISION

   FLAIR collision: the function with the given name already exists.


.. py:data:: PR_DECIMP

   FLAIR match indecision: the patterns matched, but not the function(s) being referenced.


.. py:data:: PR_END

   Number of problem types.



```

`skills/idapython/docs/ida_range.md`:

```md
# ida_range

Medium-priority: Manage continuous address ranges and sets of ranges. Commonly used for working with functions, segments, and custom address groups.

## Key Classes

### range_t
Continuous address range [start_ea, end_ea), end excluded.

- `range_t(ea1, ea2)` - constructor
- `start_ea` / `end_ea` - range boundaries (end_ea excluded)
- `contains(ea)` / `contains(range)` - check if address/range is inside
- `overlaps(range)` - check if ranges have common addresses
- `size()` - return end_ea - start_ea
- `empty()` - check if size <= 0
- `intersect(range)` - set to intersection with another range
- `extend(ea)` - extend range to include address
- `clear()` - set both start_ea and end_ea to 0
- `compare(range)` - compare based on start_ea

### rangeset_t
Set of non-overlapping ranges, stored sorted.

- `add(range)` / `add(start, end)` / `add(rangeset)` - add range(s), merging overlaps
- `sub(range)` / `sub(ea)` / `sub(rangeset)` - subtract range(s), splitting as needed
- `contains(ea)` / `contains(rangeset)` - check membership
- `includes(range)` - check if every ea in range is in set
- `has_common(range)` / `has_common(rangeset)` - check overlap
- `intersect(rangeset)` - set to intersection
- `find_range(ea)` - get range containing ea, or nullptr
- `nranges()` - number of ranges in set
- `getrange(idx)` - get range by index
- `next_addr(ea)` / `prev_addr(ea)` - navigate within ranges
- `next_range(ea)` / `prev_range(ea)` - navigate between ranges
- `is_equal(rangeset)` / `is_subset_of(rangeset)` - set comparisons
- `clear()` / `empty()` - management

### rangevec_t
Vector of range_t (standard vector methods).

## Range Kind Constants

- `RANGE_KIND_FUNC` - function ranges
- `RANGE_KIND_SEGMENT` - segment ranges
- `RANGE_KIND_HIDDEN_RANGE` - hidden ranges
- `RANGE_KIND_UNKNOWN` - unknown type

## See Also
Full docs: skill/docs/ida_range.rst

```

`skills/idapython/docs/ida_range.rst`:

```rst
ida_range
=========

.. py:module:: ida_range

.. autoapi-nested-parse::

   Contains the definition of range_t.

   A range is a non-empty continuous range of addresses (specified by its start and end addresses, the end address is excluded from the range).
   Ranges are stored in the Btree part of the IDA database. To learn more about Btrees (Balanced Trees): [http://www.bluerwhite.org/btree/](http://www.bluerwhite.org/btree/) 
       



Attributes
----------

.. autoapisummary::

   ida_range.RANGE_KIND_UNKNOWN
   ida_range.RANGE_KIND_FUNC
   ida_range.RANGE_KIND_SEGMENT
   ida_range.RANGE_KIND_HIDDEN_RANGE


Classes
-------

.. autoapisummary::

   ida_range.rangevec_base_t
   ida_range.array_of_rangesets
   ida_range.range_t
   ida_range.rangevec_t
   ida_range.rangeset_t


Functions
---------

.. autoapisummary::

   ida_range.range_t_print


Module Contents
---------------

.. py:class:: rangevec_base_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> range_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> range_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: rangevec_base_t) -> None


   .. py:method:: extract() -> range_t *


   .. py:method:: inject(s: range_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< range_t >::const_iterator


   .. py:method:: end(*args) -> qvector< range_t >::const_iterator


   .. py:method:: insert(it: range_t, x: range_t) -> qvector< range_t >::iterator


   .. py:method:: erase(*args) -> qvector< range_t >::iterator


   .. py:method:: find(*args) -> qvector< range_t >::const_iterator


   .. py:method:: has(x: range_t) -> bool


   .. py:method:: add_unique(x: range_t) -> bool


   .. py:method:: append(x: range_t) -> None


   .. py:method:: extend(x: rangevec_base_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: array_of_rangesets(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> rangeset_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> rangeset_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: array_of_rangesets) -> None


   .. py:method:: extract() -> rangeset_t *


   .. py:method:: inject(s: rangeset_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< rangeset_t >::const_iterator


   .. py:method:: end(*args) -> qvector< rangeset_t >::const_iterator


   .. py:method:: insert(it: rangeset_t, x: rangeset_t) -> qvector< rangeset_t >::iterator


   .. py:method:: erase(*args) -> qvector< rangeset_t >::iterator


   .. py:method:: find(*args) -> qvector< rangeset_t >::const_iterator


   .. py:method:: has(x: rangeset_t) -> bool


   .. py:method:: add_unique(x: rangeset_t) -> bool


   .. py:method:: append(x: rangeset_t) -> None


   .. py:method:: extend(x: array_of_rangesets) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: range_t(ea1: ida_idaapi.ea_t = 0, ea2: ida_idaapi.ea_t = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: start_ea
      :type:  ida_idaapi.ea_t

      start_ea included



   .. py:attribute:: end_ea
      :type:  ida_idaapi.ea_t

      end_ea excluded



   .. py:method:: compare(r: range_t) -> int


   .. py:method:: contains(*args) -> bool

      This function has the following signatures:

          0. contains(ea: ida_idaapi.ea_t) -> bool
          1. contains(r: const range_t &) -> bool

      # 0: contains(ea: ida_idaapi.ea_t) -> bool

      Compare two range_t instances, based on the start_ea.

      Is 'ea' in the address range? 
              

      # 1: contains(r: const range_t &) -> bool

      Is every ea in 'r' also in this range_t?



   .. py:method:: overlaps(r: range_t) -> bool

      Is there an ea in 'r' that is also in this range_t?



   .. py:method:: clear() -> None

      Set start_ea, end_ea to 0.



   .. py:method:: empty() -> bool

      Is the size of the range_t <= 0?



   .. py:method:: size() -> asize_t

      Get end_ea - start_ea.



   .. py:method:: intersect(r: range_t) -> None

      Assign the range_t to the intersection between the range_t and 'r'.



   .. py:method:: extend(ea: ida_idaapi.ea_t) -> None

      Ensure that the range_t includes 'ea'.



.. py:function:: range_t_print(cb: range_t) -> str

   Helper function. Should not be called directly!


.. py:class:: rangevec_t

   Bases: :py:obj:`rangevec_base_t`


   .. py:attribute:: thisown


.. py:data:: RANGE_KIND_UNKNOWN

.. py:data:: RANGE_KIND_FUNC

   func_t


.. py:data:: RANGE_KIND_SEGMENT

   segment_t


.. py:data:: RANGE_KIND_HIDDEN_RANGE

   hidden_range_t


.. py:class:: rangeset_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: swap(r: rangeset_t) -> None

      Set this = 'r' and 'r' = this. See qvector::swap()



   .. py:method:: add(*args) -> bool

      This function has the following signatures:

          0. add(range: const range_t &) -> bool
          1. add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
          2. add(aset: const rangeset_t &) -> bool

      # 0: add(range: const range_t &) -> bool

      Add an address range to the set. If 'range' intersects an existing element e, then e is extended to include 'range', and any superfluous elements (subsets of e) are removed. 
              
      :returns: false if 'range' was not added (the set was unchanged)

      # 1: add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool

      Create a new range_t from 'start' and 'end' and add it to the set.


      # 2: add(aset: const rangeset_t &) -> bool

      Add each element of 'aset' to the set. 
              
      :returns: false if no elements were added (the set was unchanged)



   .. py:method:: sub(*args) -> bool

      This function has the following signatures:

          0. sub(range: const range_t &) -> bool
          1. sub(ea: ida_idaapi.ea_t) -> bool
          2. sub(aset: const rangeset_t &) -> bool

      # 0: sub(range: const range_t &) -> bool

      Subtract an address range from the set. All subsets of 'range' will be removed, and all elements that intersect 'range' will be truncated/split so they do not include 'range'. 
              
      :returns: false if 'range' was not subtracted (the set was unchanged)

      # 1: sub(ea: ida_idaapi.ea_t) -> bool

      Subtract an ea (an range of size 1) from the set. See sub(const range_t &)


      # 2: sub(aset: const rangeset_t &) -> bool

      Subtract each range in 'aset' from the set 
              
      :returns: false if nothing was subtracted (the set was unchanged)



   .. py:method:: includes(range: range_t) -> bool

      Is every ea in 'range' contained in the rangeset?



   .. py:method:: getrange(idx: int) -> range_t const &

      Get the range_t at index 'idx'.



   .. py:method:: lastrange() -> range_t const &

      Get the last range_t in the set.



   .. py:method:: nranges() -> size_t

      Get the number of range_t elements in the set.



   .. py:method:: empty() -> bool

      Does the set have zero elements.



   .. py:method:: clear() -> None

      Delete all elements from the set. See qvector::clear()



   .. py:method:: has_common(*args) -> bool

      This function has the following signatures:

          0. has_common(range: const range_t &) -> bool
          1. has_common(aset: const rangeset_t &) -> bool

      # 0: has_common(range: const range_t &) -> bool

      Is there an ea in 'range' that is also in the rangeset?


      # 1: has_common(aset: const rangeset_t &) -> bool

      Does any element of 'aset' overlap with an element in this rangeset?. See range_t::overlaps()



   .. py:method:: contains(*args) -> bool

      This function has the following signatures:

          0. contains(ea: ida_idaapi.ea_t) -> bool
          1. contains(aset: const rangeset_t &) -> bool

      # 0: contains(ea: ida_idaapi.ea_t) -> bool

      Does an element of the rangeset contain 'ea'? See range_t::contains(ea_t)


      # 1: contains(aset: const rangeset_t &) -> bool

      Is every element in 'aset' contained in an element of this rangeset?. See range_t::contains(range_t)



   .. py:method:: intersect(aset: rangeset_t) -> bool

      Set the rangeset to its intersection with 'aset'. 
              
      :returns: false if the set was unchanged



   .. py:method:: is_subset_of(aset: rangeset_t) -> bool

      Is every element in the rangeset contained in an element of 'aset'?



   .. py:method:: is_equal(aset: rangeset_t) -> bool

      Do this rangeset and 'aset' have identical elements?



   .. py:method:: begin() -> rangeset_t::iterator

      Get an iterator that points to the first element in the set.



   .. py:method:: end() -> rangeset_t::iterator

      Get an iterator that points to the end of the set. (This is NOT the last element)



   .. py:method:: find_range(ea: ida_idaapi.ea_t) -> range_t const *

      Get the element from the set that contains 'ea'. 
              
      :returns: nullptr if there is no such element



   .. py:method:: cached_range() -> range_t const *

      When searching the rangeset, we keep a cached element to help speed up searches. 
              
      :returns: a pointer to the cached element



   .. py:method:: next_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

      Get the smallest ea_t value greater than 'ea' contained in the rangeset.



   .. py:method:: prev_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

      Get the largest ea_t value less than 'ea' contained in the rangeset.



   .. py:method:: next_range(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

      Get the smallest ea_t value greater than 'ea' that is not in the same range as 'ea'.



   .. py:method:: prev_range(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

      Get the largest ea_t value less than 'ea' that is not in the same range as 'ea'.



   .. py:method:: as_rangevec() -> rangevec_t const &

      Return underlying rangevec_t object.




```

`skills/idapython/docs/ida_regfinder.md`:

```md
# ida_regfinder

High-priority: Track register values backwards through code execution. Critical for understanding function arguments, constants loaded into registers, and stack pointer calculations.

## Key Functions

- `find_reg_value(ea, reg)` - find constant value in register at address
- `find_sp_value(ea, reg)` - find stack pointer delta at address
- `find_reg_value_info(rvi, ea, reg, max_depth)` - find register value with detailed tracking info
- `find_nearest_rvi(rvi, ea, regs)` - find value of either of two registers
- `invalidate_regfinder_cache(from, to, cref)` - update cache after control flow change
- `invalidate_regfinder_xrefs_cache(to, dref)` - update cache after data reference change

Returns: 1 if value found, 0 if varying/insufficient depth, -1 if not supported.

## Key Classes

### reg_value_info_t
Detailed register value tracking result.

**State checks:**
- `is_num()` / `is_spd()` - value is constant / stack-pointer-relative
- `is_known()` - value is num or spd
- `is_unknown()` - value could not be determined
- `is_dead_end()` / `aborted()` - tracking stopped
- `is_unkloop()` / `is_unkxref()` / `is_unkvals()` / `is_unkmult()` - specific failure reasons
- `is_value_unique()` - single value vs multiple possibilities

**Value extraction:**
- `get_num()` - get constant value
- `get_spd()` - get SP delta
- `get_def_ea()` - where value was defined
- `get_def_itype()` - instruction type that defined value

**Arithmetic operations (all take insn parameter):**
- `add(r, insn)` / `sub(r, insn)` - arithmetic
- `bor(r, insn)` / `band(r, insn)` / `bxor(r, insn)` / `bandnot(r, insn)` - bitwise
- `sll(r, insn)` / `slr(r, insn)` / `sar(r, insn)` - shifts
- `neg(insn)` / `bnot(insn)` - unary
- `add_num(r)` / `shift_left(r)` / `shift_right(r)` - without changing def_ea

**Factory methods:**
- `make_num(val, insn/ea, flags)` - create constant value
- `make_initial_sp(func_ea)` - create initial stack pointer
- `make_unkloop(ea)` / `make_unkmult(ea)` / etc - create failure states

**Flags (for PC_BASED / LIKE_GOT annotations):**
- `is_all_vals_pc_based()` / `is_any_vals_pc_based()`
- `is_all_vals_like_got()` / `is_any_vals_like_got()`
- `set_all_vals_pc_based()` / `set_all_vals_got_based()`

### reg_value_def_t
Single value definition.

- `val` - the value (uint64)
- `def_ea` - instruction address where defined
- `def_itype` - instruction code (processor-specific)
- `flags` - SHORT_INSN, PC_BASED, LIKE_GOT
- `is_short_insn()` / `is_pc_based()` / `is_like_got()` - flag checks
- `dstr(how, pm)` - format as string (NOVAL/UVAL/SPVAL/ABORTED)

## Configuration

Uses ida.cfg values: `REGTRACK_MAX_DEPTH`, `REGTRACK_FUNC_MAX_DEPTH` for search limits.

## See Also
Full docs: skill/docs/ida_regfinder.rst

```

`skills/idapython/docs/ida_regfinder.rst`:

```rst
ida_regfinder
=============

.. py:module:: ida_regfinder


Attributes
----------

.. autoapisummary::

   ida_regfinder.cvar


Classes
-------

.. autoapisummary::

   ida_regfinder.reg_value_def_t
   ida_regfinder.reg_value_info_t


Functions
---------

.. autoapisummary::

   ida_regfinder.find_reg_value
   ida_regfinder.find_sp_value
   ida_regfinder.find_reg_value_info
   ida_regfinder.find_nearest_rvi
   ida_regfinder.invalidate_regfinder_cache
   ida_regfinder.invalidate_regfinder_xrefs_cache


Module Contents
---------------

.. py:class:: reg_value_def_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: val
      :type:  uint64

      the value



   .. py:attribute:: def_ea
      :type:  ida_idaapi.ea_t

      the instruction address



   .. py:attribute:: def_itype
      :type:  uint16

      the instruction code (processor specific)



   .. py:attribute:: flags
      :type:  uint16

      additional info about the value



   .. py:attribute:: SHORT_INSN

      like 'addi reg, imm'



   .. py:attribute:: PC_BASED

      the value depends on DEF_EA only for numbers 
              



   .. py:attribute:: LIKE_GOT

      the value is like GOT only for numbers 
              



   .. py:method:: is_short_insn(*args) -> bool

      This function has the following signatures:

          0. is_short_insn() -> bool
          1. is_short_insn(insn: const insn_t &) -> bool

      # 0: is_short_insn() -> bool


      # 1: is_short_insn(insn: const insn_t &) -> bool



   .. py:method:: is_pc_based() -> bool


   .. py:method:: is_like_got() -> bool


   .. py:attribute:: NOVAL

      without a value



   .. py:attribute:: UVAL

      as a number



   .. py:attribute:: SPVAL

      as a SP delta



   .. py:attribute:: ABORTED

      as an ABORTED value



   .. py:method:: dstr(how: reg_value_def_t::dstr_val_t, pm: procmod_t = None) -> str

      Return the string representation.



.. py:data:: cvar

.. py:class:: reg_value_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: clear() -> None

      Undefine the value.



   .. py:method:: empty() -> bool

      Return 'true' if we know nothing about a value.



   .. py:method:: swap(r: reg_value_info_t) -> None


   .. py:method:: make_dead_end(dead_end_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the undefined value because of a dead end. 
              



   .. py:method:: make_aborted(bblk_ea: ida_idaapi.ea_t, aborting_depth: int = -1) -> reg_value_info_t
      :staticmethod:


      Return the value after aborting. 
              



   .. py:method:: make_badinsn(insn_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the unknown value after a bad insn. 
              



   .. py:method:: make_unkinsn(insn: insn_t const &) -> reg_value_info_t
      :staticmethod:


      Return the unknown value after executing the insn. 
              



   .. py:method:: make_unkfunc(func_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the unknown value from the function start. 
              



   .. py:method:: make_unkloop(bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the unknown value if it changes in a loop. 
              



   .. py:method:: make_unkmult(bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the unknown value if the register has incompatible values. 
              



   .. py:method:: make_unkxref(bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the unknown value if there are too many xrefs. 
              



   .. py:method:: make_unkvals(bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the unknown value if the register has too many values. 
              



   .. py:method:: make_num(*args) -> reg_value_info_t
      :staticmethod:


      This function has the following signatures:

          0. make_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> reg_value_info_t
          1. make_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> reg_value_info_t

      # 0: make_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> reg_value_info_t

      Return the value that is the RVAL number. 
              

      # 1: make_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> reg_value_info_t

      Return the value that is the RVAL number. 
              



   .. py:method:: make_initial_sp(func_ea: ida_idaapi.ea_t) -> reg_value_info_t
      :staticmethod:


      Return the value that is the initial stack pointer. 
              



   .. py:method:: is_dead_end() -> bool

      Return 'true' if the value is undefined because of a dead end.



   .. py:method:: aborted() -> bool

      Return 'true' if the tracking process was aborted.



   .. py:method:: is_special() -> bool

      Return 'true' if the value requires special handling.



   .. py:method:: is_badinsn() -> bool

      Return 'true' if the value is unknown because of a bad insn.



   .. py:method:: is_unkinsn() -> bool

      Return 'true' if the value is unknown after executing the insn.



   .. py:method:: is_unkfunc() -> bool

      Return 'true' if the value is unknown from the function start.



   .. py:method:: is_unkloop() -> bool

      Return 'true' if the value is unknown because it changes in a loop.



   .. py:method:: is_unkmult() -> bool

      Return 'true' if the value is unknown because the register has incompatible values (a number and SP delta). 
              



   .. py:method:: is_unkxref() -> bool

      Return 'true' if the value is unknown because there are too many xrefs.



   .. py:method:: is_unkvals() -> bool

      Return 'true' if the value is unknown because the register has too many values. 
              



   .. py:method:: is_unknown() -> bool

      Return 'true' if the value is unknown.



   .. py:method:: is_num() -> bool

      Return 'true' if the value is a constant.



   .. py:method:: is_spd() -> bool

      Return 'true' if the value depends on the stack pointer.



   .. py:method:: is_known() -> bool

      Return 'true' if the value is known (i.e. it is a number or SP delta).



   .. py:method:: get_num() -> bool

      Return the number if the value is a constant. 
              



   .. py:method:: get_spd() -> bool

      Return the SP delta if the value depends on the stack pointer. 
              



   .. py:method:: get_def_ea() -> ida_idaapi.ea_t

      Return the defining address.



   .. py:method:: get_def_itype() -> uint16

      Return the defining instruction code (processor specific).



   .. py:method:: get_aborting_depth() -> int

      Return the aborting depth if the value is ABORTED.



   .. py:method:: is_value_unique() -> bool

      Check that the value is unique.



   .. py:method:: have_all_vals_flag(val_flags: uint16) -> bool

      Check the given flag for each value.



   .. py:method:: has_any_vals_flag(val_flags: uint16) -> bool


   .. py:method:: is_all_vals_pc_based() -> bool


   .. py:method:: is_any_vals_pc_based() -> bool


   .. py:method:: is_all_vals_like_got() -> bool


   .. py:method:: is_any_vals_like_got() -> bool


   .. py:method:: set_all_vals_flag(val_flags: uint16) -> None

      Set the given flag for each value.



   .. py:method:: set_all_vals_pc_based() -> None


   .. py:method:: set_all_vals_got_based() -> None


   .. py:method:: set_dead_end(dead_end_ea: ida_idaapi.ea_t) -> None

      Set the value to be undefined because of a dead end. 
              



   .. py:method:: set_badinsn(insn_ea: ida_idaapi.ea_t) -> None

      Set the value to be unknown after a bad insn. 
              



   .. py:method:: set_unkinsn(insn: insn_t const &) -> None

      Set the value to be unknown after executing the insn. 
              



   .. py:method:: set_unkfunc(func_ea: ida_idaapi.ea_t) -> None

      Set the value to be unknown from the function start. 
              



   .. py:method:: set_unkloop(bblk_ea: ida_idaapi.ea_t) -> None

      Set the value to be unknown because it changes in a loop. 
              



   .. py:method:: set_unkmult(bblk_ea: ida_idaapi.ea_t) -> None

      Set the value to be unknown because the register has incompatible values. 
              



   .. py:method:: set_unkxref(bblk_ea: ida_idaapi.ea_t) -> None

      Set the value to be unknown because there are too many xrefs. 
              



   .. py:method:: set_unkvals(bblk_ea: ida_idaapi.ea_t) -> None

      Set the value to be unknown because the register has too many values. 
              



   .. py:method:: set_aborted(bblk_ea: ida_idaapi.ea_t, aborting_depth: int = -1) -> None

      Set the value after aborting. 
              



   .. py:method:: set_num(*args) -> None

      This function has the following signatures:

          0. set_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> None
          1. set_num(rvals: uvalvec_t *, insn: const insn_t &) -> None
          2. set_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> None

      # 0: set_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> None

      Set the value to be a number after executing an insn. 
              

      # 1: set_num(rvals: uvalvec_t *, insn: const insn_t &) -> None

      Set the value to be numbers after executing an insn. 
              

      # 2: set_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> None

      Set the value to be a number before an address. 
              



   .. py:attribute:: EQUAL

      L==R.



   .. py:attribute:: CONTAINS

      L contains R (i.e. R\L is empty)



   .. py:attribute:: CONTAINED

      L is contained in R (i.e. L\R is empty)



   .. py:attribute:: NOT_COMPARABLE

      L\R is not empty and R\L is not empty.



   .. py:method:: vals_union(r: reg_value_info_t) -> reg_value_info_t::set_compare_res_t

      Add values from R into THIS ignoring duplicates. 
              
      :returns: EQUAL: THIS is not changed
      :returns: CONTAINS: THIS is not changed
      :returns: CONTAINED: THIS is a copy of R
      :returns: NOT_COMPARABLE: values from R are added to THIS



   .. py:method:: extend(pm: procmod_t, width: int, is_signed: bool) -> None

      Sign-, or zero-extend the number or SP delta value to full size. The initial value is considered to be of size WIDTH. 
              



   .. py:method:: trunc_uval(pm: procmod_t) -> None

      Truncate the number to the application bitness. 
              



   .. py:attribute:: ADD


   .. py:attribute:: SUB


   .. py:attribute:: OR


   .. py:attribute:: AND


   .. py:attribute:: XOR


   .. py:attribute:: AND_NOT


   .. py:attribute:: SLL


   .. py:attribute:: SLR


   .. py:attribute:: SAR


   .. py:attribute:: MOVT


   .. py:attribute:: NEG


   .. py:attribute:: NOT


   .. py:method:: add(r: reg_value_info_t, insn: insn_t const &) -> None

      Add R to the value, save INSN as a defining instruction. 
              



   .. py:method:: sub(r: reg_value_info_t, insn: insn_t const &) -> None

      Subtract R from the value, save INSN as a defining instruction. 
              



   .. py:method:: bor(r: reg_value_info_t, insn: insn_t const &) -> None

      Make bitwise OR of R to the value, save INSN as a defining instruction. 
              



   .. py:method:: band(r: reg_value_info_t, insn: insn_t const &) -> None

      Make bitwise AND of R to the value, save INSN as a defining instruction. 
              



   .. py:method:: bxor(r: reg_value_info_t, insn: insn_t const &) -> None

      Make bitwise eXclusive OR of R to the value, save INSN as a defining instruction. 
              



   .. py:method:: bandnot(r: reg_value_info_t, insn: insn_t const &) -> None

      Make bitwise AND of the inverse of R to the value, save INSN as a defining instruction. 
              



   .. py:method:: sll(r: reg_value_info_t, insn: insn_t const &) -> None

      Shift the value left by R, save INSN as a defining instruction. 
              



   .. py:method:: slr(r: reg_value_info_t, insn: insn_t const &) -> None

      Shift logically the value right by R, save INSN as a defining instruction. 
              



   .. py:method:: sar(r: reg_value_info_t, insn: insn_t const &) -> None

      Shift arithmetically the value right by R, save INSN as a defining instruction. 
              



   .. py:method:: movt(r: reg_value_info_t, insn: insn_t const &) -> None

      Replace the top 16 bits with bottom 16 bits of R, leaving the bottom 16 bits untouched, save INSN as a defining instruction. 
              



   .. py:method:: neg(insn: insn_t const &) -> None

      Negate the value, save INSN as a defining instruction.



   .. py:method:: bnot(insn: insn_t const &) -> None

      Make bitwise inverse of the value, save INSN as a defining instruction. 
              



   .. py:method:: add_num(*args) -> None

      This function has the following signatures:

          0. add_num(r: int, insn: const insn_t &) -> None
          1. add_num(r: int) -> None

      # 0: add_num(r: int, insn: const insn_t &) -> None

      Add R to the value, save INSN as a defining instruction. 
              

      # 1: add_num(r: int) -> None

      Add R to the value, do not change the defining instructions. 
              



   .. py:method:: shift_left(r: int) -> None

      Shift the value left by R, do not change the defining instructions. 
              



   .. py:method:: shift_right(r: int) -> None

      Shift the value right by R, do not change the defining instructions. 
              



.. py:function:: find_reg_value(ea: ida_idaapi.ea_t, reg: int) -> uint64 *

   Find register value using the register tracker. 
           
   :param ea: the address to find a value at
   :param reg: the register to find
   :returns: 0: no value (the value is varying or the find depth is not enough to find a value)
   :returns: 1: the found value is in VAL
   :returns: -1: the processor module does not support a register tracker


.. py:function:: find_sp_value(ea: ida_idaapi.ea_t, reg: int = -1) -> int64 *

   Find a value of the SP based register using the register tracker. 
           
   :param ea: the address to find a value at
   :param reg: the register to find. by default the SP register is used.
   :returns: 0: no value (the value is varying or the find depth is not enough to find a value)
   :returns: 1: the found value is in VAL
   :returns: -1: the processor module does not support a register tracker


.. py:function:: find_reg_value_info(rvi: reg_value_info_t, ea: ida_idaapi.ea_t, reg: int, max_depth: int = 0) -> bool

   Find register value using the register tracker. 
           
   :param rvi: the found value with additional attributes
   :param ea: the address to find a value at
   :param reg: the register to find
   :param max_depth: the number of basic blocks to look before aborting the search and returning the unknown value. 0 means the value of REGTRACK_MAX_DEPTH from ida.cfg for ordinal registers or REGTRACK_FUNC_MAX_DEPTH for the function-wide registers, -1 means the value of REGTRACK_FUNC_MAX_DEPTH from ida.cfg.
   :returns: 'false': the processor module does not support a register tracker
   :returns: 'true': the found value is in RVI


.. py:function:: find_nearest_rvi(rvi: reg_value_info_t, ea: ida_idaapi.ea_t, reg: int const [2]) -> int

   Find the value of any of the two registers using the register tracker. First, this function tries to find the registers in the basic block of EA, and if it could not do this, then it tries to find in the entire function. 
           
   :param rvi: the found value with additional attributes
   :param ea: the address to find a value at
   :param reg: the registers to find
   :returns: the index of the found register or -1


.. py:function:: invalidate_regfinder_cache(*args) -> None

   The control flow from FROM to TO has removed (CREF==fl_U) or added (CREF!=fl_U). Try to update the register tracker cache after this change. If TO == BADADDR then clear the entire cache. 
           


.. py:function:: invalidate_regfinder_xrefs_cache(*args) -> None

   The data reference to TO has added (DREF!=dr_O) or removed (DREF==dr_O). Update the regtracker xrefs cache after this change. If TO == BADADDR then clear the entire xrefs cache. 
           



```

`skills/idapython/docs/ida_registry.md`:

```md
# ida_registry

Registry-based persistent configuration storage (Windows registry or ~/.idapro/ida.reg on Unix).

## Key Functions

### Configuration Storage
- `reg_read_string(name, subkey=None, _def=None)` - Read string value
- `reg_write_string(name, utf8, subkey=None)` - Write string value
- `reg_read_int(name, defval, subkey=None)` - Read integer value
- `reg_write_int(name, value, subkey=None)` - Write integer value
- `reg_read_bool(name, defval, subkey=None)` - Read boolean value
- `reg_write_bool(name, value, subkey=None)` - Write boolean value
- `reg_read_binary(name, subkey=None)` - Read binary data
- `reg_write_binary(name, py_bytes, subkey=None)` - Write binary data

### List Operations
- `reg_read_strlist(subkey)` - Get all string values under key
- `reg_write_strlist(items, subkey)` - Write list of strings
- `reg_update_strlist(subkey, add, maxrecs, rem=None, ignorecase=False)` - Add/remove items with trimming
- `reg_update_filestrlist(subkey, add, maxrecs, rem=None)` - Update file list (OS-specific case sensitivity)

### Key/Value Management
- `reg_exists(name, subkey=None)` - Check if value exists
- `reg_subkey_exists(name)` - Check if key exists
- `reg_delete(name, subkey=None)` - Delete value
- `reg_delete_subkey(name)` - Delete key
- `reg_delete_tree(name)` - Delete subtree recursively
- `reg_subkey_subkeys(name)` - Get all subkey names
- `reg_subkey_values(name)` - Get all value names
- `reg_data_type(name, subkey=None)` - Get value type (reg_unknown/reg_sz/reg_binary/reg_dword)

## Constants

- `ROOT_KEY_NAME` - Default key for IDA settings
- `reg_sz` - UTF-8 string type
- `reg_binary` - Binary data type
- `reg_dword` - 32-bit number type

## See Also
Full docs: skill/docs/ida_registry.rst

```

`skills/idapython/docs/ida_registry.rst`:

```rst
ida_registry
============

.. py:module:: ida_registry

.. autoapi-nested-parse::

   Registry related functions.

   IDA uses the registry to store global configuration options that must persist after IDA has been closed.
   On Windows, IDA uses the Windows registry directly. On Unix systems, the registry is stored in a file (typically ~/.idapro/ida.reg).
   The root key for accessing IDA settings in the registry is defined by ROOT_KEY_NAME. 
       



Attributes
----------

.. autoapisummary::

   ida_registry.IDA_REGISTRY_NAME
   ida_registry.HVUI_REGISTRY_NAME
   ida_registry.ROOT_KEY_NAME
   ida_registry.reg_unknown
   ida_registry.reg_sz
   ida_registry.reg_binary
   ida_registry.reg_dword


Functions
---------

.. autoapisummary::

   ida_registry.reg_read_string
   ida_registry.reg_data_type
   ida_registry.reg_read_binary
   ida_registry.reg_write_binary
   ida_registry.reg_subkey_subkeys
   ida_registry.reg_subkey_values
   ida_registry.reg_delete_subkey
   ida_registry.reg_delete_tree
   ida_registry.reg_delete
   ida_registry.reg_subkey_exists
   ida_registry.reg_exists
   ida_registry.reg_read_strlist
   ida_registry.reg_write_strlist
   ida_registry.reg_update_strlist
   ida_registry.reg_write_string
   ida_registry.reg_read_int
   ida_registry.reg_write_int
   ida_registry.reg_read_bool
   ida_registry.reg_write_bool
   ida_registry.reg_update_filestrlist
   ida_registry.set_registry_name


Module Contents
---------------

.. py:function:: reg_read_string(name: str, subkey: str = None, _def: str = None) -> PyObject *

   Read a string from the registry. 
           
   :param name: value name
   :param subkey: key name
   :returns: success


.. py:function:: reg_data_type(name: str, subkey: str = None) -> regval_type_t

   Get data type of a given value. 
           
   :param name: value name
   :param subkey: key name
   :returns: false if the [key+]value doesn't exist


.. py:function:: reg_read_binary(name: str, subkey: str = None) -> PyObject *

   Read binary data from the registry. 
           
   :param name: value name
   :param subkey: key name
   :returns: false if 'data' is not large enough to hold all data present. in this case 'data' is left untouched.


.. py:function:: reg_write_binary(name: str, py_bytes: PyObject *, subkey: str = None) -> PyObject *

   Write binary data to the registry. 
           
   :param name: value name
   :param subkey: key name


.. py:function:: reg_subkey_subkeys(name: str) -> PyObject *

   Get all subkey names of given key.


.. py:function:: reg_subkey_values(name: str) -> PyObject *

   Get all value names under given key.


.. py:data:: IDA_REGISTRY_NAME

.. py:data:: HVUI_REGISTRY_NAME

.. py:data:: ROOT_KEY_NAME

   Default key used to store IDA settings in registry (Windows version). 
           


.. py:data:: reg_unknown

   unknown


.. py:data:: reg_sz

   utf8 string


.. py:data:: reg_binary

   binary data


.. py:data:: reg_dword

   32-bit number


.. py:function:: reg_delete_subkey(name: str) -> bool

   Delete a key from the registry.


.. py:function:: reg_delete_tree(name: str) -> bool

   Delete a subtree from the registry.


.. py:function:: reg_delete(name: str, subkey: str = None) -> bool

   Delete a value from the registry. 
           
   :param name: value name
   :param subkey: parent key
   :returns: success


.. py:function:: reg_subkey_exists(name: str) -> bool

   Is there already a key with the given name?


.. py:function:: reg_exists(name: str, subkey: str = None) -> bool

   Is there already a value with the given name? 
           
   :param name: value name
   :param subkey: parent key


.. py:function:: reg_read_strlist(subkey: str) -> List[str]

   Retrieve all string values associated with the given key.

   :param subkey: a key from which to read the list of items
   :returns: the list of items


.. py:function:: reg_write_strlist(items: List[str], subkey: str)

   Write string values associated with the given key.

   :param items: the list of items to write
   :param subkey: a key under which to write the list of items


.. py:function:: reg_update_strlist(subkey: str, add: Union[str, None], maxrecs: int, rem: Union[str, None] = None, ignorecase: bool = False)

   Add and/or remove items from the list, and possibly trim that list.

   :param subkey: the key under which the list is located
   :param add: an item to add to the list, or None
   :param maxrecs: the maximum number of items the list should hold
   :param rem: an item to remove from the list, or None
   :param ignorecase: ignore case for 'add' and 'rem'


.. py:function:: reg_write_string(name: str, utf8: str, subkey: str = None) -> None

   Write a string to the registry. 
           
   :param name: value name
   :param utf8: utf8-encoded string
   :param subkey: key name


.. py:function:: reg_read_int(name: str, defval: int, subkey: str = None) -> int

   Read integer value from the registry. 
           
   :param name: value name
   :param defval: default value
   :param subkey: key name
   :returns: the value read from the registry, or 'defval' if the read failed


.. py:function:: reg_write_int(name: str, value: int, subkey: str = None) -> None

   Write integer value to the registry. 
           
   :param name: value name
   :param value: value to write
   :param subkey: key name


.. py:function:: reg_read_bool(name: str, defval: bool, subkey: str = None) -> bool

   Read boolean value from the registry. 
           
   :param name: value name
   :param defval: default value
   :param subkey: key name
   :returns: boolean read from registry, or 'defval' if the read failed


.. py:function:: reg_write_bool(name: str, value: int, subkey: str = None) -> None

   Write boolean value to the registry. 
           
   :param name: value name
   :param value: boolean to write (nonzero = true)
   :param subkey: key name


.. py:function:: reg_update_filestrlist(subkey: str, add: str, maxrecs: size_t, rem: str = None) -> None

   Update registry with a file list. Case sensitivity will vary depending on the target OS. 
           


.. py:function:: set_registry_name(name: str) -> bool


```

`skills/idapython/docs/ida_search.md`:

```md
# ida_search

Middle-level search functions for finding specific byte patterns, instructions, and code/data.

## Key Functions

### Search Functions
- `find_unknown(ea, sflag)` - Find undefined bytes
- `find_defined(ea, sflag)` - Find defined bytes (code/data)
- `find_code(ea, sflag)` - Find code (instructions)
- `find_data(ea, sflag)` - Find data items
- `find_not_func(ea, sflag)` - Find bytes outside functions
- `find_imm(ea, sflag, search_value)` - Find immediate value in instructions
- `find_text(start_ea, y, x, ustr, sflag)` - Text search in disassembly/decompilation
- `find_reg_access(out, start_ea, end_ea, regname, sflag)` - Find register read/write

### Helper
- `search_down(sflag)` - Check if SEARCH_DOWN bit is set

## Search Flags

### Direction
- `SEARCH_UP` - Search towards lower addresses
- `SEARCH_DOWN` - Search towards higher addresses
- `SEARCH_NEXT` - Skip starting address

### Options
- `SEARCH_CASE` - Case-sensitive search
- `SEARCH_REGEX` - Regular expressions (text search only)
- `SEARCH_IDENT` - Search for identifier (bounded by non-visible chars)
- `SEARCH_NOBRK` - Don't test for user cancellation
- `SEARCH_NOSHOW` - Don't display progress
- `SEARCH_BRK` - Return BADADDR if cancelled
- `SEARCH_USESEL` - Limit search to UI selection

### Register Access
- `SEARCH_USE` - Find register reads
- `SEARCH_DEF` - Find register writes

## See Also
Full docs: skill/docs/ida_search.rst

```

`skills/idapython/docs/ida_search.rst`:

```rst
ida_search
==========

.. py:module:: ida_search

.. autoapi-nested-parse::

   Middle-level search functions.

   They all are controlled by Search flags 
       



Attributes
----------

.. autoapisummary::

   ida_search.SEARCH_UP
   ida_search.SEARCH_DOWN
   ida_search.SEARCH_NEXT
   ida_search.SEARCH_CASE
   ida_search.SEARCH_REGEX
   ida_search.SEARCH_NOBRK
   ida_search.SEARCH_NOSHOW
   ida_search.SEARCH_IDENT
   ida_search.SEARCH_BRK
   ida_search.SEARCH_USE
   ida_search.SEARCH_DEF
   ida_search.SEARCH_USESEL


Functions
---------

.. autoapisummary::

   ida_search.search_down
   ida_search.find_error
   ida_search.find_notype
   ida_search.find_unknown
   ida_search.find_defined
   ida_search.find_suspop
   ida_search.find_data
   ida_search.find_code
   ida_search.find_not_func
   ida_search.find_imm
   ida_search.find_text
   ida_search.find_reg_access


Module Contents
---------------

.. py:data:: SEARCH_UP

   search towards lower addresses


.. py:data:: SEARCH_DOWN

   search towards higher addresses


.. py:data:: SEARCH_NEXT

   skip the starting address when searching. this bit is useful only for search(), bin_search(), find_reg_access(). find_.. functions skip the starting address automatically. 
           


.. py:data:: SEARCH_CASE

   case-sensitive search (case-insensitive otherwise)


.. py:data:: SEARCH_REGEX

   regular expressions in search string (supported only for the text search)


.. py:data:: SEARCH_NOBRK

   do not test if the user clicked cancel to interrupt the search


.. py:data:: SEARCH_NOSHOW

   do not display the search progress/refresh screen


.. py:data:: SEARCH_IDENT

   search for an identifier (text search). it means that the characters before and after the match cannot be is_visible_char(). 
           


.. py:data:: SEARCH_BRK

   return BADADDR if the search was cancelled.


.. py:data:: SEARCH_USE

   find_reg_access: search for a use (read access)


.. py:data:: SEARCH_DEF

   find_reg_access: search for a definition (write access)


.. py:data:: SEARCH_USESEL

   query the UI for a possible current selection to limit the search to 
           


.. py:function:: search_down(sflag: int) -> bool

   Is the SEARCH_DOWN bit set?


.. py:function:: find_error(ea: ida_idaapi.ea_t, sflag: int) -> int *

.. py:function:: find_notype(ea: ida_idaapi.ea_t, sflag: int) -> int *

.. py:function:: find_unknown(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

.. py:function:: find_defined(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

.. py:function:: find_suspop(ea: ida_idaapi.ea_t, sflag: int) -> int *

.. py:function:: find_data(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

.. py:function:: find_code(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

.. py:function:: find_not_func(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

.. py:function:: find_imm(ea: ida_idaapi.ea_t, sflag: int, search_value: int) -> int *

.. py:function:: find_text(start_ea: ida_idaapi.ea_t, y: int, x: int, ustr: str, sflag: int) -> ida_idaapi.ea_t

.. py:function:: find_reg_access(out: reg_access_t, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regname: str, sflag: int) -> ida_idaapi.ea_t


```

`skills/idapython/docs/ida_segment.md`:

```md
# ida_segment

Segment management (memory regions with addressing modes, permissions, and types).

## Key Classes

### segment_t
Core segment structure (inherits from range_t).

**Address Range:**
- `start_ea` - Start address (included)
- `end_ea` - End address (excluded)

**Addressing:**
- `bitness` - 0=16-bit, 1=32-bit, 2=64-bit
- `is_16bit()`, `is_32bit()`, `is_64bit()` - Check addressing mode
- `abits()`, `abytes()` - Get address bits/bytes
- `set_segm_addressing(s, bitness)` - Change addressing (deletes instructions/data)

**Attributes:**
- `sel` - Segment selector (must be unique)
- `type` - Segment type (SEG_CODE/SEG_DATA/SEG_BSS/SEG_XTRN/etc)
- `perm` - Permissions (SEGPERM_READ/WRITE/EXEC)
- `align` - Alignment (saRelByte/saRelWord/saRelPara/etc)
- `comb` - Combination (scPriv/scPub/scStack/scCommon)
- `color` - Segment color
- `defsr[16]` - Default segment register values

**Methods:**
- `update()` - Commit segment changes to database

## Key Functions

### Segment Lookup
- `get_segm_qty()` - Get number of segments
- `getseg(ea)` - Get segment containing address
- `getnseg(n)` - Get segment by index (0..qty-1)
- `get_segm_num(ea)` - Get segment index by address
- `get_segm_by_name(name)` - Get segment by name
- `get_segm_by_sel(selector)` - Get segment by selector
- `get_first_seg()`, `get_last_seg()` - Get first/last segment
- `get_next_seg(ea)`, `get_prev_seg(ea)` - Get adjacent segments

### Creating/Deleting
- `add_segm(para, start, end, name, sclass, flags=0)` - Add segment (allocates selector)
- `add_segm_ex(s, name, sclass, flags)` - Add segment (selector pre-allocated)
- `del_segm(ea, flags)` - Delete segment

### Modifying Bounds
- `set_segm_start(ea, newstart, flags)` - Change start (trims previous)
- `set_segm_end(ea, newend, flags)` - Change end (trims next)
- `move_segm_start(ea, newstart, mode)` - Change start (may expand previous)
- `move_segm(s, to, flags=0)` - Move entire segment (fixes relocations)
- `rebase_program(delta, flags)` - Rebase all segments

### Properties
- `get_segm_name(s, flags=0)` - Get name
- `set_segm_name(s, name, flags=0)` - Set name
- `get_segm_class(s)`, `set_segm_class(s, sclass, flags=0)` - Get/set class
- `get_segment_cmt(s, repeatable)`, `set_segment_cmt(s, cmt, repeatable)` - Get/set comment
- `segtype(ea)` - Get segment type at address
- `get_segm_base(s)` - Get base linear address
- `get_segm_para(s)` - Get base paragraph
- `set_segm_base(s, newbase)` - Set base (internal)

### Selectors
- `setup_selector(segbase)` - Allocate selector if needed
- `allocate_selector(segbase)` - Unconditionally allocate selector
- `find_free_selector()` - Find unused selector (>=1)
- `set_selector(selector, paragraph)` - Map selector to paragraph
- `del_selector(selector)` - Delete selector mapping
- `sel2para(selector)`, `sel2ea(selector)` - Get selector mapping
- `find_selector(base)` - Find selector by paragraph

### Visibility/Locking
- `is_visible_segm(s)`, `set_visible_segm(s, visible)` - Hide/show segment
- `is_spec_segm(seg_type)`, `is_spec_ea(ea)` - Check special types
- `lock_segm(segm, lock)`, `is_segm_locked(segm)` - Lock pointer (prevents deletion/move)

### Debugger Integration
- `change_segment_status(s, is_deb_segm)` - Convert debugger/regular segment
- `take_memory_snapshot(type)` - Snapshot running process (SNAP_ALL_SEG/SNAP_LOAD_SEG/SNAP_CUR_SEG)
- `is_miniidb()` - Check if IDB is debugger-created

### Segment Groups (OMF)
- `set_group_selector(grp, sel)` - Create segment group
- `get_group_selector(grpsel)` - Get group's common selector

### Segment Translations
- `add_segment_translation(segstart, mappedseg)` - Add overlay mapping
- `del_segment_translations(segstart)` - Delete translation list
- `get_segment_translations(transmap, segstart)` - Get translation list
- `set_segment_translations(segstart, transmap)` - Set translation list

## Segment Types

- `SEG_NORM` - Normal segment (no assumptions)
- `SEG_CODE` - Code segment
- `SEG_DATA` - Data segment
- `SEG_BSS` - Uninitialized data
- `SEG_XTRN` - External definitions (no instructions)
- `SEG_GRP` - Segment group
- `SEG_NULL` - Zero-length segment
- `SEG_ABSSYM` - Absolute symbols
- `SEG_COMM` - Communal definitions
- `SEG_IMEM` - Internal processor memory/SFRs

## Add Segment Flags

- `ADDSEG_NOSREG` - Set default sregs to BADSEL
- `ADDSEG_OR_DIE` - qexit() on failure
- `ADDSEG_NOTRUNC` - Destroy/truncate old segments instead
- `ADDSEG_QUIET` - Silent mode
- `ADDSEG_FILLGAP` - Fill gap with previous segment
- `ADDSEG_SPARSE` - Use sparse storage
- `ADDSEG_NOAA` - Don't mark for auto-analysis
- `ADDSEG_IDBENC` - Name/class in IDB encoding

## Segment Modification Flags

- `SEGMOD_KILL` - Disable addresses when shrinking
- `SEGMOD_KEEP` - Keep code/data
- `SEGMOD_SILENT` - Silent mode
- `SEGMOD_KEEPSEL` - Don't delete unused selector
- `SEGMOD_NOMOVE` - Don't move info when changing start
- `SEGMOD_SPARSE` - Use sparse storage when extending

## See Also
Full docs: skill/docs/ida_segment.rst

```

`skills/idapython/docs/ida_segment.rst`:

```rst
ida_segment
===========

.. py:module:: ida_segment

.. autoapi-nested-parse::

   Functions that deal with segments.

   IDA requires that all program addresses belong to segments (each address must 
   belong to exactly one segment). The situation when an address doesn't belong to 
   any segment is allowed as a temporary situation only when the user changes 
   program segmentation. Bytes outside a segment can't be converted to instructions, 
   have names, comments, etc. Each segment has its start address, ending address 
   and represents a contiguous range of addresses. There might be unused holes 
   between segments.

   Each segment has its unique segment selector. This selector is used to 
   distinguish the segment from other segments. For 16-bit programs the selector 
   is equal to the segment base paragraph. For 32-bit programs there is special 
   array to translate the selectors to the segment base paragraphs. A selector is 
   a 32/64 bit value.

   The segment base paragraph determines the offsets in the segment. If the start 
   address of the segment == (base << 4) then the first offset in the segment will 
   be 0. The start address should be higher or equal to (base << 4). We will call 
   the offsets in the segment 'virtual addresses'. So, the virtual address of the 
   first byte of the segment is (start address of segment - segment base linear 
   address).

   For IBM PC, the virtual address corresponds to the offset part of the address. 
   For other processors (Z80, for example), virtual addresses correspond to Z80 
   addresses and linear addresses are used only internally. For MS Windows programs 
   the segment base paragraph is 0 and therefore the segment virtual addresses are 
   equal to linear addresses.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For segment operations, see :mod:`ida_domain.segments`.



Attributes
----------

.. autoapisummary::

   ida_segment.SREG_NUM
   ida_segment.saAbs
   ida_segment.saRelByte
   ida_segment.saRelWord
   ida_segment.saRelPara
   ida_segment.saRelPage
   ida_segment.saRelDble
   ida_segment.saRel4K
   ida_segment.saGroup
   ida_segment.saRel32Bytes
   ida_segment.saRel64Bytes
   ida_segment.saRelQword
   ida_segment.saRel128Bytes
   ida_segment.saRel512Bytes
   ida_segment.saRel1024Bytes
   ida_segment.saRel2048Bytes
   ida_segment.saRel_MAX_ALIGN_CODE
   ida_segment.scPriv
   ida_segment.scGroup
   ida_segment.scPub
   ida_segment.scPub2
   ida_segment.scStack
   ida_segment.scCommon
   ida_segment.scPub3
   ida_segment.sc_MAX_COMB_CODE
   ida_segment.SEGPERM_EXEC
   ida_segment.SEGPERM_WRITE
   ida_segment.SEGPERM_READ
   ida_segment.SEGPERM_MAXVAL
   ida_segment.SEG_MAX_BITNESS_CODE
   ida_segment.SFL_COMORG
   ida_segment.SFL_OBOK
   ida_segment.SFL_HIDDEN
   ida_segment.SFL_DEBUG
   ida_segment.SFL_LOADER
   ida_segment.SFL_HIDETYPE
   ida_segment.SFL_HEADER
   ida_segment.SEG_NORM
   ida_segment.SEG_XTRN
   ida_segment.SEG_CODE
   ida_segment.SEG_DATA
   ida_segment.SEG_IMP
   ida_segment.SEG_GRP
   ida_segment.SEG_NULL
   ida_segment.SEG_UNDF
   ida_segment.SEG_BSS
   ida_segment.SEG_ABSSYM
   ida_segment.SEG_COMM
   ida_segment.SEG_IMEM
   ida_segment.SEG_MAX_SEGTYPE_CODE
   ida_segment.ADDSEG_NOSREG
   ida_segment.ADDSEG_OR_DIE
   ida_segment.ADDSEG_NOTRUNC
   ida_segment.ADDSEG_QUIET
   ida_segment.ADDSEG_FILLGAP
   ida_segment.ADDSEG_SPARSE
   ida_segment.ADDSEG_NOAA
   ida_segment.ADDSEG_IDBENC
   ida_segment.SEGMOD_KILL
   ida_segment.SEGMOD_KEEP
   ida_segment.SEGMOD_SILENT
   ida_segment.SEGMOD_KEEP0
   ida_segment.SEGMOD_KEEPSEL
   ida_segment.SEGMOD_NOMOVE
   ida_segment.SEGMOD_SPARSE
   ida_segment.MOVE_SEGM_OK
   ida_segment.MOVE_SEGM_PARAM
   ida_segment.MOVE_SEGM_ROOM
   ida_segment.MOVE_SEGM_IDP
   ida_segment.MOVE_SEGM_CHUNK
   ida_segment.MOVE_SEGM_LOADER
   ida_segment.MOVE_SEGM_ODD
   ida_segment.MOVE_SEGM_ORPHAN
   ida_segment.MOVE_SEGM_DEBUG
   ida_segment.MOVE_SEGM_SOURCEFILES
   ida_segment.MOVE_SEGM_MAPPING
   ida_segment.MOVE_SEGM_INVAL
   ida_segment.MSF_SILENT
   ida_segment.MSF_NOFIX
   ida_segment.MSF_LDKEEP
   ida_segment.MSF_FIXONCE
   ida_segment.MSF_PRIORITY
   ida_segment.MSF_NETNODES
   ida_segment.CSS_OK
   ida_segment.CSS_NODBG
   ida_segment.CSS_NORANGE
   ida_segment.CSS_NOMEM
   ida_segment.CSS_BREAK
   ida_segment.SNAP_ALL_SEG
   ida_segment.SNAP_LOAD_SEG
   ida_segment.SNAP_CUR_SEG
   ida_segment.MAX_GROUPS
   ida_segment.MAX_SEGM_TRANSLATIONS


Classes
-------

.. autoapisummary::

   ida_segment.segment_defsr_array
   ida_segment.segment_t
   ida_segment.lock_segment


Functions
---------

.. autoapisummary::

   ida_segment.set_segment_translations
   ida_segment.is_visible_segm
   ida_segment.is_finally_visible_segm
   ida_segment.set_visible_segm
   ida_segment.is_spec_segm
   ida_segment.is_spec_ea
   ida_segment.lock_segm
   ida_segment.is_segm_locked
   ida_segment.getn_selector
   ida_segment.get_selector_qty
   ida_segment.setup_selector
   ida_segment.allocate_selector
   ida_segment.find_free_selector
   ida_segment.set_selector
   ida_segment.del_selector
   ida_segment.sel2para
   ida_segment.sel2ea
   ida_segment.find_selector
   ida_segment.get_segm_by_sel
   ida_segment.add_segm_ex
   ida_segment.add_segm
   ida_segment.del_segm
   ida_segment.get_segm_qty
   ida_segment.getseg
   ida_segment.getnseg
   ida_segment.get_segm_num
   ida_segment.get_next_seg
   ida_segment.get_prev_seg
   ida_segment.get_first_seg
   ida_segment.get_last_seg
   ida_segment.get_segm_by_name
   ida_segment.set_segm_end
   ida_segment.set_segm_start
   ida_segment.move_segm_start
   ida_segment.move_segm_strerror
   ida_segment.move_segm
   ida_segment.change_segment_status
   ida_segment.take_memory_snapshot
   ida_segment.is_miniidb
   ida_segment.set_segm_base
   ida_segment.set_group_selector
   ida_segment.get_group_selector
   ida_segment.add_segment_translation
   ida_segment.del_segment_translations
   ida_segment.get_segment_translations
   ida_segment.get_segment_cmt
   ida_segment.set_segment_cmt
   ida_segment.std_out_segm_footer
   ida_segment.set_segm_name
   ida_segment.get_segm_name
   ida_segment.get_visible_segm_name
   ida_segment.get_segm_class
   ida_segment.set_segm_class
   ida_segment.segtype
   ida_segment.get_segment_alignment
   ida_segment.get_segment_combination
   ida_segment.get_segm_para
   ida_segment.get_segm_base
   ida_segment.set_segm_addressing
   ida_segment.update_segm
   ida_segment.segm_adjust_diff
   ida_segment.segm_adjust_ea
   ida_segment.get_defsr
   ida_segment.set_defsr
   ida_segment.rebase_program


Module Contents
---------------

.. py:class:: segment_defsr_array(data: unsigned long long (&)[SREG_NUM])

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  unsigned long long (&)[SREG_NUM]


   .. py:attribute:: bytes


.. py:function:: set_segment_translations(segstart: ida_idaapi.ea_t, transmap: eavec_t const &) -> bool

   Set new translation list. 
           
   :param segstart: start address of the segment to add translation to
   :param transmap: vector of segment start addresses for the translation list. If transmap is empty, the translation list is deleted.
   :returns: 1: ok
   :returns: 0: too many translations or bad segstart


.. py:data:: SREG_NUM

   Maximum number of segment registers is 16 (see segregs.hpp)


.. py:class:: segment_t

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  int

      use get/set_segm_name() functions



   .. py:attribute:: sclass
      :type:  int

      use get/set_segm_class() functions



   .. py:attribute:: orgbase
      :type:  int

      this field is IDP dependent. you may keep your information about the segment here 
              



   .. py:attribute:: align
      :type:  uchar

      Segment alignment codes 
              



   .. py:attribute:: comb
      :type:  uchar

      Segment combination codes 
              



   .. py:attribute:: perm
      :type:  uchar

      Segment permissions (0 means no information) 
              



   .. py:attribute:: bitness
      :type:  uchar

      Number of bits in the segment addressing
      * 0: 16 bits
      * 1: 32 bits
      * 2: 64 bits 


              



   .. py:method:: is_16bit() -> bool

      Is a 16-bit segment?



   .. py:method:: is_32bit() -> bool

      Is a 32-bit segment?



   .. py:method:: is_64bit() -> bool

      Is a 64-bit segment?



   .. py:method:: abits() -> int

      Get number of address bits.



   .. py:method:: abytes() -> int

      Get number of address bytes.



   .. py:attribute:: flags
      :type:  ushort

      Segment flags



   .. py:method:: comorg() -> bool


   .. py:method:: set_comorg() -> None


   .. py:method:: clr_comorg() -> None


   .. py:method:: ob_ok() -> bool


   .. py:method:: set_ob_ok() -> None


   .. py:method:: clr_ob_ok() -> None


   .. py:method:: is_visible_segm() -> bool


   .. py:method:: set_visible_segm(visible: bool) -> None


   .. py:method:: set_debugger_segm(debseg: bool) -> None


   .. py:method:: is_loader_segm() -> bool


   .. py:method:: set_loader_segm(ldrseg: bool) -> None


   .. py:method:: is_hidden_segtype() -> bool


   .. py:method:: set_hidden_segtype(hide: bool) -> None


   .. py:method:: is_header_segm() -> bool


   .. py:method:: set_header_segm(on: bool) -> None


   .. py:attribute:: sel
      :type:  sel_t

      segment selector - should be unique. You can't change this field after creating the segment. Exception: 16bit OMF files may have several segments with the same selector, but this is not good (no way to denote a segment exactly) so it should be fixed in the future. 
              



   .. py:attribute:: defsr
      :type:  sel_t [16]

      default segment register values. first element of this array keeps information about value of processor_t::reg_first_sreg 
              



   .. py:attribute:: type
      :type:  uchar

      segment type (see Segment types). The kernel treats different segment types differently. Segments marked with '*' contain no instructions or data and are not declared as 'segments' in the disassembly. 
              



   .. py:attribute:: color
      :type:  bgcolor_t

      the segment color



   .. py:method:: update() -> bool

      Update segment information. You must call this function after modification of segment characteristics. Note that not all fields of segment structure may be modified directly, there are special functions to modify some fields. 
              
      :returns: success



   .. py:attribute:: start_ea
      :type:  ida_idaapi.ea_t

      start_ea included



   .. py:attribute:: end_ea
      :type:  ida_idaapi.ea_t

      end_ea excluded



   .. py:attribute:: use64


.. py:data:: saAbs

   Absolute segment.


.. py:data:: saRelByte

   Relocatable, byte aligned.


.. py:data:: saRelWord

   Relocatable, word (2-byte) aligned.


.. py:data:: saRelPara

   Relocatable, paragraph (16-byte) aligned.


.. py:data:: saRelPage

   Relocatable, aligned on 256-byte boundary.


.. py:data:: saRelDble

   Relocatable, aligned on a double word (4-byte) boundary. 
           


.. py:data:: saRel4K

   This value is used by the PharLap OMF for page (4K) alignment. It is not supported by LINK. 
           


.. py:data:: saGroup

   Segment group.


.. py:data:: saRel32Bytes

   32 bytes


.. py:data:: saRel64Bytes

   64 bytes


.. py:data:: saRelQword

   8 bytes


.. py:data:: saRel128Bytes

   128 bytes


.. py:data:: saRel512Bytes

   512 bytes


.. py:data:: saRel1024Bytes

   1024 bytes


.. py:data:: saRel2048Bytes

   2048 bytes


.. py:data:: saRel_MAX_ALIGN_CODE

.. py:data:: scPriv

   Private. Do not combine with any other program segment. 
           


.. py:data:: scGroup

   Segment group.


.. py:data:: scPub

   Public. Combine by appending at an offset that meets the alignment requirement. 
           


.. py:data:: scPub2

   As defined by Microsoft, same as C=2 (public).


.. py:data:: scStack

   Stack. Combine as for C=2. This combine type forces byte alignment. 
           


.. py:data:: scCommon

   Common. Combine by overlay using maximum size.


.. py:data:: scPub3

   As defined by Microsoft, same as C=2 (public).


.. py:data:: sc_MAX_COMB_CODE

.. py:data:: SEGPERM_EXEC

   Execute.


.. py:data:: SEGPERM_WRITE

   Write.


.. py:data:: SEGPERM_READ

   Read.


.. py:data:: SEGPERM_MAXVAL

   Execute + Write + Read.


.. py:data:: SEG_MAX_BITNESS_CODE

   Maximum segment bitness value.


.. py:data:: SFL_COMORG

   IDP dependent field (IBM PC: if set, ORG directive is not commented out) 
           


.. py:data:: SFL_OBOK

   Orgbase is present? (IDP dependent field) 
           


.. py:data:: SFL_HIDDEN

   Is the segment hidden? 
           


.. py:data:: SFL_DEBUG

   Is the segment created for the debugger?. Such segments are temporary and do not have permanent flags. 
           


.. py:data:: SFL_LOADER

   Is the segment created by the loader? 
           


.. py:data:: SFL_HIDETYPE

   Hide segment type (do not print it in the listing) 
           


.. py:data:: SFL_HEADER

   Header segment (do not create offsets to it in the disassembly) 
           


.. py:data:: SEG_NORM

   unknown type, no assumptions


.. py:data:: SEG_XTRN

   * segment with 'extern' definitions. no instructions are allowed 
           


.. py:data:: SEG_CODE

   code segment


.. py:data:: SEG_DATA

   data segment


.. py:data:: SEG_IMP

   java: implementation segment


.. py:data:: SEG_GRP

   * group of segments


.. py:data:: SEG_NULL

   zero-length segment


.. py:data:: SEG_UNDF

   undefined segment type (not used)


.. py:data:: SEG_BSS

   uninitialized segment


.. py:data:: SEG_ABSSYM

   * segment with definitions of absolute symbols


.. py:data:: SEG_COMM

   * segment with communal definitions


.. py:data:: SEG_IMEM

   internal processor memory & sfr (8051)


.. py:data:: SEG_MAX_SEGTYPE_CODE

   maximum value segment type can take


.. py:function:: is_visible_segm(s: segment_t) -> bool

   See SFL_HIDDEN.


.. py:function:: is_finally_visible_segm(s: segment_t) -> bool

   See SFL_HIDDEN, SCF_SHHID_SEGM.


.. py:function:: set_visible_segm(s: segment_t, visible: bool) -> None

   See SFL_HIDDEN.


.. py:function:: is_spec_segm(seg_type: uchar) -> bool

   Has segment a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM) 
           


.. py:function:: is_spec_ea(ea: ida_idaapi.ea_t) -> bool

   Does the address belong to a segment with a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM) 
           
   :param ea: linear address


.. py:function:: lock_segm(segm: segment_t, lock: bool) -> None

   Lock segment pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers cannot be deleted or moved. 
           


.. py:class:: lock_segment(_segm: segment_t)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:function:: is_segm_locked(segm: segment_t) -> bool

   Is a segment pointer locked?


.. py:function:: getn_selector(n: int) -> sel_t *, ea_t *

   Get description of selector (0..get_selector_qty()-1)


.. py:function:: get_selector_qty() -> size_t

   Get number of defined selectors.


.. py:function:: setup_selector(segbase: ida_idaapi.ea_t) -> sel_t

   Allocate a selector for a segment if necessary. You must call this function before calling add_segm_ex(). add_segm() calls this function itself, so you don't need to allocate a selector. This function will allocate a selector if 'segbase' requires more than 16 bits and the current processor is IBM PC. Otherwise it will return the segbase value. 
           
   :param segbase: a new segment base paragraph
   :returns: the allocated selector number


.. py:function:: allocate_selector(segbase: ida_idaapi.ea_t) -> sel_t

   Allocate a selector for a segment unconditionally. You must call this function before calling add_segm_ex(). add_segm() calls this function itself, so you don't need to allocate a selector. This function will allocate a new free selector and setup its mapping using find_free_selector() and set_selector() functions. 
           
   :param segbase: a new segment base paragraph
   :returns: the allocated selector number


.. py:function:: find_free_selector() -> sel_t

   Find first unused selector. 
           
   :returns: a number >= 1


.. py:function:: set_selector(selector: sel_t, paragraph: ida_idaapi.ea_t) -> int

   Set mapping of selector to a paragraph. You should call this function _before_ creating a segment which uses the selector, otherwise the creation of the segment will fail. 
           
   :param selector: number of selector to map
   * if selector == BADSEL, then return 0 (fail)
   * if the selector has had a mapping, old mapping is destroyed
   * if the selector number is equal to paragraph value, then the mapping is destroyed because we don't need to keep trivial mappings.
   :param paragraph: paragraph to map selector
   :returns: 1: ok
   :returns: 0: failure (bad selector or too many mappings)


.. py:function:: del_selector(selector: sel_t) -> None

   Delete mapping of a selector. Be wary of deleting selectors that are being used in the program, this can make a mess in the segments. 
           
   :param selector: number of selector to remove from the translation table


.. py:function:: sel2para(selector: sel_t) -> ida_idaapi.ea_t

   Get mapping of a selector. 
           
   :param selector: number of selector to translate
   :returns: paragraph the specified selector is mapped to. if there is no mapping, returns 'selector'.


.. py:function:: sel2ea(selector: sel_t) -> ida_idaapi.ea_t

   Get mapping of a selector as a linear address. 
           
   :param selector: number of selector to translate to linear address
   :returns: linear address the specified selector is mapped to. if there is no mapping, returns to_ea(selector,0);


.. py:function:: find_selector(base: ida_idaapi.ea_t) -> sel_t

   Find a selector that has mapping to the specified paragraph. 
           
   :param base: paragraph to search in the translation table
   :returns: selector value or base


.. py:function:: get_segm_by_sel(selector: sel_t) -> segment_t *

   Get pointer to segment structure. This function finds a segment by its selector. If there are several segments with the same selectors, the last one will be returned. 
           
   :param selector: a segment with the specified selector will be returned
   :returns: pointer to segment or nullptr


.. py:function:: add_segm_ex(NONNULL_s: segment_t, name: str, sclass: str, flags: int) -> bool

   Add a new segment. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. 
           
   :param name: name of new segment. may be nullptr. if specified, the segment is immediately renamed
   :param sclass: class of the segment. may be nullptr. if specified, the segment class is immediately changed
   :param flags: Add segment flags
   :returns: 1: ok
   :returns: 0: failed, a warning message is displayed


.. py:data:: ADDSEG_NOSREG

   set all default segment register values to BADSEL (undefine all default segment registers) 
           


.. py:data:: ADDSEG_OR_DIE

   qexit() if can't add a segment


.. py:data:: ADDSEG_NOTRUNC

   don't truncate the new segment at the beginning of the next segment if they overlap. destroy/truncate old segments instead. 
           


.. py:data:: ADDSEG_QUIET

   silent mode, no "Adding segment..." in the messages window


.. py:data:: ADDSEG_FILLGAP

   fill gap between new segment and previous one. i.e. if such a gap exists, and this gap is less than 64K, then fill the gap by extending the previous segment and adding .align directive to it. This way we avoid gaps between segments. too many gaps lead to a virtual array failure. it cannot hold more than ~1000 gaps. 
           


.. py:data:: ADDSEG_SPARSE

   use sparse storage method for the new ranges of the created segment. please note that the ranges that were already enabled before creating the segment will not change their storage type. 
           


.. py:data:: ADDSEG_NOAA

   do not mark new segment for auto-analysis


.. py:data:: ADDSEG_IDBENC

   'name' and 'sclass' are given in the IDB encoding; non-ASCII bytes will be decoded accordingly 
           


.. py:function:: add_segm(para: ida_idaapi.ea_t, start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, name: str, sclass: str, flags: int = 0) -> bool

   Add a new segment, second form. Segment alignment is set to saRelByte. Segment combination is "public" or "stack" (if segment class is "STACK"). Addressing mode of segment is taken as default (16bit or 32bit). Default segment registers are set to BADSEL. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. 
           
   :param para: segment base paragraph. if paragraph can't fit in 16bit, then a new selector is allocated and mapped to the paragraph.
   :param start: start address of the segment. if start==BADADDR then start <- to_ea(para,0).
   :param end: end address of the segment. end address should be higher than start address. For emulate empty segments, use SEG_NULL segment type. If the end address is lower than start address, then fail. If end==BADADDR, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created). If 'end' is too high and the new segment would overlap the next segment, 'end' is adjusted properly.
   :param name: name of new segment. may be nullptr
   :param sclass: class of the segment. may be nullptr. type of the new segment is modified if class is one of predefined names:
   * "CODE" -> SEG_CODE
   * "DATA" -> SEG_DATA
   * "CONST" -> SEG_DATA
   * "STACK" -> SEG_BSS
   * "BSS" -> SEG_BSS
   * "XTRN" -> SEG_XTRN
   * "COMM" -> SEG_COMM
   * "ABS" -> SEG_ABSSYM
   :param flags: Add segment flags
   :returns: 1: ok
   :returns: 0: failed, a warning message is displayed


.. py:function:: del_segm(ea: ida_idaapi.ea_t, flags: int) -> bool

   Delete a segment. 
           
   :param ea: any address belonging to the segment
   :param flags: Segment modification flags
   :returns: 1: ok
   :returns: 0: failed, no segment at 'ea'.


.. py:data:: SEGMOD_KILL

   disable addresses if segment gets shrinked or deleted


.. py:data:: SEGMOD_KEEP

   keep information (code & data, etc)


.. py:data:: SEGMOD_SILENT

   be silent


.. py:data:: SEGMOD_KEEP0

   flag for internal use, don't set


.. py:data:: SEGMOD_KEEPSEL

   do not try to delete unused selector


.. py:data:: SEGMOD_NOMOVE

   don't move info from the start of segment to the new start address (for set_segm_start()) 
           


.. py:data:: SEGMOD_SPARSE

   use sparse storage if extending the segment (for set_segm_start(), set_segm_end()) 
           


.. py:function:: get_segm_qty() -> int

   Get number of segments.


.. py:function:: getseg(ea: ida_idaapi.ea_t) -> segment_t *

   Get pointer to segment by linear address. 
           
   :param ea: linear address belonging to the segment
   :returns: nullptr or pointer to segment structure


.. py:function:: getnseg(n: int) -> segment_t *

   Get pointer to segment by its number. 
           
   :param n: segment number in the range (0..get_segm_qty()-1)
   :returns: nullptr or pointer to segment structure


.. py:function:: get_segm_num(ea: ida_idaapi.ea_t) -> int

   Get number of segment by address. 
           
   :param ea: linear address belonging to the segment
   :returns: -1 if no segment occupies the specified address. otherwise returns number of the specified segment (0..get_segm_qty()-1)


.. py:function:: get_next_seg(ea: ida_idaapi.ea_t) -> segment_t *

   Get pointer to the next segment.


.. py:function:: get_prev_seg(ea: ida_idaapi.ea_t) -> segment_t *

   Get pointer to the previous segment.


.. py:function:: get_first_seg() -> segment_t *

   Get pointer to the first segment.


.. py:function:: get_last_seg() -> segment_t *

   Get pointer to the last segment.


.. py:function:: get_segm_by_name(name: str) -> segment_t *

   Get pointer to segment by its name. If there are several segments with the same name, returns the first of them. 
           
   :param name: segment name. may be nullptr.
   :returns: nullptr or pointer to segment structure


.. py:function:: set_segm_end(ea: ida_idaapi.ea_t, newend: ida_idaapi.ea_t, flags: int) -> bool

   Set segment end address. The next segment is shrinked to allow expansion of the specified segment. The kernel might even delete the next segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. 
           
   :param ea: any address belonging to the segment
   :param newend: new end address of the segment
   :param flags: Segment modification flags
   :returns: 1: ok
   :returns: 0: failed, a warning message is displayed


.. py:function:: set_segm_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t, flags: int) -> bool

   Set segment start address. The previous segment is trimmed to allow expansion of the specified segment. The kernel might even delete the previous segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. 
           
   :param ea: any address belonging to the segment
   :param newstart: new start address of the segment note that segment start address should be higher than segment base linear address.
   :param flags: Segment modification flags
   :returns: 1: ok
   :returns: 0: failed, a warning message is displayed


.. py:function:: move_segm_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t, mode: int) -> bool

   Move segment start. The main difference between this function and set_segm_start() is that this function may expand the previous segment while set_segm_start() never does it. So, this function allows to change bounds of two segments simultaneously. If the previous segment and the specified segment have the same addressing mode and segment base, then instructions and data are not destroyed - they simply move from one segment to another. Otherwise all instructions/data which migrate from one segment to another are destroyed. 
           
   :param ea: any address belonging to the segment
   :param newstart: new start address of the segment note that segment start address should be higher than segment base linear address.
   :param mode: policy for destroying defined items
   * 0: if it is necessary to destroy defined items, display a dialog box and ask confirmation
   * 1: if it is necessary to destroy defined items, just destroy them without asking the user
   * -1: if it is necessary to destroy defined items, don't destroy them (i.e. function will fail)
   * -2: don't destroy defined items (function will succeed)
   :returns: 1: ok
   :returns: 0: failed, a warning message is displayed


.. py:data:: MOVE_SEGM_OK

   all ok


.. py:data:: MOVE_SEGM_PARAM

   The specified segment does not exist.


.. py:data:: MOVE_SEGM_ROOM

   Not enough free room at the target address.


.. py:data:: MOVE_SEGM_IDP

   IDP module forbids moving the segment.


.. py:data:: MOVE_SEGM_CHUNK

   Too many chunks are defined, can't move.


.. py:data:: MOVE_SEGM_LOADER

   The segment has been moved but the loader complained.


.. py:data:: MOVE_SEGM_ODD

   Cannot move segments by an odd number of bytes.


.. py:data:: MOVE_SEGM_ORPHAN

   Orphan bytes hinder segment movement.


.. py:data:: MOVE_SEGM_DEBUG

   Debugger segments cannot be moved.


.. py:data:: MOVE_SEGM_SOURCEFILES

   Source files ranges of addresses hinder segment movement.


.. py:data:: MOVE_SEGM_MAPPING

   Memory mapping ranges of addresses hinder segment movement.


.. py:data:: MOVE_SEGM_INVAL

   Invalid argument (delta/target does not fit the address space)


.. py:function:: move_segm_strerror(code: move_segm_code_t) -> str

   Return string describing error MOVE_SEGM_... code.


.. py:function:: move_segm(s: segment_t, to: ida_idaapi.ea_t, flags: int = 0) -> move_segm_code_t

   This function moves all information to the new address. It fixes up address sensitive information in the kernel. The total effect is equal to reloading the segment to the target address. For the file format dependent address sensitive information, loader_t::move_segm is called. Also IDB notification event idb_event::segm_moved is called. 
           
   :param s: segment to move
   :param to: new segment start address
   :param flags: Move segment flags
   :returns: Move segment result codes


.. py:data:: MSF_SILENT

   don't display a "please wait" box on the screen


.. py:data:: MSF_NOFIX

   don't call the loader to fix relocations


.. py:data:: MSF_LDKEEP

   keep the loader in the memory (optimization)


.. py:data:: MSF_FIXONCE

   call loader only once with the special calling method. valid for rebase_program(). see loader_t::move_segm. 
           


.. py:data:: MSF_PRIORITY

   loader segments will overwrite any existing debugger segments when moved. valid for move_segm() 
           


.. py:data:: MSF_NETNODES

   move netnodes instead of changing inf.netdelta (this is slower); valid for rebase_program() 
           


.. py:function:: change_segment_status(s: segment_t, is_deb_segm: bool) -> int

   Convert a debugger segment to a regular segment and vice versa. When converting debug->regular, the memory contents will be copied to the database. 
           
   :param s: segment to modify
   :param is_deb_segm: new status of the segment
   :returns: Change segment status result codes


.. py:data:: CSS_OK

   ok


.. py:data:: CSS_NODBG

   debugger is not running


.. py:data:: CSS_NORANGE

   could not find corresponding memory range


.. py:data:: CSS_NOMEM

   not enough memory (might be because the segment is too big) 
           


.. py:data:: CSS_BREAK

   memory reading process stopped by user


.. py:data:: SNAP_ALL_SEG

   Take a snapshot of all segments.


.. py:data:: SNAP_LOAD_SEG

   Take a snapshot of loader segments.


.. py:data:: SNAP_CUR_SEG

   Take a snapshot of current segment.


.. py:function:: take_memory_snapshot(type: int) -> bool

   Take a memory snapshot of the running process. 
           
   :param type: specifies which snapshot we want (see SNAP_ Snapshot types)
   :returns: success


.. py:function:: is_miniidb() -> bool

   Is the database a miniidb created by the debugger?. 
           
   :returns: true if the database contains no segments or only debugger segments


.. py:function:: set_segm_base(s: segment_t, newbase: ida_idaapi.ea_t) -> bool

   Internal function.


.. py:function:: set_group_selector(grp: sel_t, sel: sel_t) -> int

   Create a new group of segments (used OMF files). 
           
   :param grp: selector of group segment (segment type is SEG_GRP) You should create an 'empty' (1 byte) group segment It won't contain anything and will be used to redirect references to the group of segments to the common selector.
   :param sel: common selector of all segments belonging to the segment You should create all segments within the group with the same selector value.
   :returns: 1: ok
   :returns: 0: too many groups (see MAX_GROUPS)


.. py:data:: MAX_GROUPS

   max number of segment groups


.. py:function:: get_group_selector(grpsel: sel_t) -> sel_t

   Get common selector for a group of segments. 
           
   :param grpsel: selector of group segment
   :returns: common selector of the group or 'grpsel' if no such group is found


.. py:function:: add_segment_translation(segstart: ida_idaapi.ea_t, mappedseg: ida_idaapi.ea_t) -> bool

   Add segment translation. 
           
   :param segstart: start address of the segment to add translation to
   :param mappedseg: start address of the overlayed segment
   :returns: 1: ok
   :returns: 0: too many translations or bad segstart


.. py:data:: MAX_SEGM_TRANSLATIONS

   max number of segment translations


.. py:function:: del_segment_translations(segstart: ida_idaapi.ea_t) -> None

   Delete the translation list 
           
   :param segstart: start address of the segment to delete translation list


.. py:function:: get_segment_translations(transmap: eavec_t *, segstart: ida_idaapi.ea_t) -> ssize_t

   Get segment translation list. 
           
   :param transmap: vector of segment start addresses for the translation list
   :param segstart: start address of the segment to get information about
   :returns: -1 if no translation list or bad segstart. otherwise returns size of translation list.


.. py:function:: get_segment_cmt(s: segment_t, repeatable: bool) -> str

   Get segment comment. 
           
   :param s: pointer to segment structure
   :param repeatable: 0: get regular comment. 1: get repeatable comment.
   :returns: size of comment or -1


.. py:function:: set_segment_cmt(s: segment_t, cmt: str, repeatable: bool) -> None

   Set segment comment. 
           
   :param s: pointer to segment structure
   :param cmt: comment string, may be multiline (with '
   '). maximal size is 4096 bytes. Use empty str ("") to delete comment
   :param repeatable: 0: set regular comment. 1: set repeatable comment.


.. py:function:: std_out_segm_footer(ctx: outctx_t &, seg: segment_t) -> None

   Generate segment footer line as a comment line. This function may be used in IDP modules to generate segment footer if the target assembler doesn't have 'ends' directive. 
           


.. py:function:: set_segm_name(s: segment_t, name: str, flags: int = 0) -> int

   Rename segment. The new name is validated (see validate_name). A segment always has a name. If you hadn't specified a name, the kernel will assign it "seg###" name where ### is segment number. 
           
   :param s: pointer to segment (may be nullptr)
   :param name: new segment name
   :param flags: ADDSEG_IDBENC or 0
   :returns: 1: ok, name is good and segment is renamed
   :returns: 0: failure, name is bad or segment is nullptr


.. py:function:: get_segm_name(s: segment_t, flags: int = 0) -> str

   Get true segment name by pointer to segment. 
           
   :param s: pointer to segment
   :param flags: 0-return name as is; 1-substitute bad symbols with _ 1 corresponds to GN_VISIBLE
   :returns: size of segment name (-1 if s==nullptr)


.. py:function:: get_visible_segm_name(s: segment_t) -> str

   Get segment name by pointer to segment. 
           
   :param s: pointer to segment
   :returns: size of segment name (-1 if s==nullptr)


.. py:function:: get_segm_class(s: segment_t) -> str

   Get segment class. Segment class is arbitrary text (max 8 characters). 
           
   :param s: pointer to segment
   :returns: size of segment class (-1 if s==nullptr or bufsize<=0)


.. py:function:: set_segm_class(s: segment_t, sclass: str, flags: int = 0) -> int

   Set segment class. 
           
   :param s: pointer to segment (may be nullptr)
   :param sclass: segment class (may be nullptr). If segment type is SEG_NORM and segment class is one of predefined names, then segment type is changed to:
   * "CODE" -> SEG_CODE
   * "DATA" -> SEG_DATA
   * "STACK" -> SEG_BSS
   * "BSS" -> SEG_BSS
   * if "UNK" then segment type is reset to SEG_NORM.
   :param flags: Add segment flags
   :returns: 1: ok, name is good and segment is renamed
   :returns: 0: failure, name is nullptr or bad or segment is nullptr


.. py:function:: segtype(ea: ida_idaapi.ea_t) -> uchar

   Get segment type. 
           
   :param ea: any linear address within the segment
   :returns: Segment types, SEG_UNDF if no segment found at 'ea'


.. py:function:: get_segment_alignment(align: uchar) -> str

   Get text representation of segment alignment code. 
           
   :returns: text digestable by IBM PC assembler.


.. py:function:: get_segment_combination(comb: uchar) -> str

   Get text representation of segment combination code. 
           
   :returns: text digestable by IBM PC assembler.


.. py:function:: get_segm_para(s: segment_t) -> ida_idaapi.ea_t

   Get segment base paragraph. Segment base paragraph may be converted to segment base linear address using to_ea() function. In fact, to_ea(get_segm_para(s), 0) == get_segm_base(s). 
           
   :param s: pointer to segment
   :returns: 0 if s == nullptr, the segment base paragraph


.. py:function:: get_segm_base(s: segment_t) -> ida_idaapi.ea_t

   Get segment base linear address. Segment base linear address is used to calculate virtual addresses. The virtual address of the first byte of the segment will be (start address of segment - segment base linear address) 
           
   :param s: pointer to segment
   :returns: 0 if s == nullptr, otherwise segment base linear address


.. py:function:: set_segm_addressing(s: segment_t, bitness: size_t) -> bool

   Change segment addressing mode (16, 32, 64 bits). You must use this function to change segment addressing, never change the 'bitness' field directly. This function will delete all instructions, comments and names in the segment 
           
   :param s: pointer to segment
   :param bitness: new addressing mode of segment
   * 2: 64bit segment
   * 1: 32bit segment
   * 0: 16bit segment
   :returns: success


.. py:function:: update_segm(s: segment_t) -> bool

.. py:function:: segm_adjust_diff(s: segment_t, delta: adiff_t) -> adiff_t

   Truncate and sign extend a delta depending on the segment.


.. py:function:: segm_adjust_ea(s: segment_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Truncate an address depending on the segment.


.. py:function:: get_defsr(s, reg)

   Deprecated, use instead:
   value = s.defsr[reg]


.. py:function:: set_defsr(s, reg, value)

   Deprecated, use instead:
   s.defsr[reg] = value


.. py:function:: rebase_program(delta: PyObject *, flags: int) -> int

   Rebase the whole program by 'delta' bytes. 
           
   :param delta: number of bytes to move the program
   :param flags: Move segment flags it is recommended to use MSF_FIXONCE so that the loader takes care of global variables it stored in the database
   :returns: Move segment result codes



```

`skills/idapython/docs/ida_segregs.md`:

```md
# ida_segregs

Segment register management for architectures with segmented memory (x86/x86-64).

## Key Classes

### sreg_range_t
Segment register value range (inherits from range_t).
- `val` - Segment register value (sel_t)
- `tag` - Range tag (SR_inherit/SR_user/SR_auto/SR_autostart)

## Key Functions

### Reading Values
- `get_sreg(ea, rg)` - Get segment register value at address (uses ranges + segment defaults)

### Setting Values
- `split_sreg_range(ea, rg, v, tag, silent=False)` - Create new range at address
- `set_default_sreg_value(sg, rg, value)` - Set default for segment (or all segments if sg=None)
- `set_default_dataseg(ds_sel)` - Set DS default for all segments
- `set_sreg_at_next_code(ea1, ea2, rg, value)` - Set value at next instruction only

### Range Queries
- `get_sreg_range(out, ea, rg)` - Get range containing address
- `get_prev_sreg_range(out, ea, rg)` - Get previous range
- `get_sreg_ranges_qty(rg)` - Get number of ranges
- `getn_sreg_range(out, rg, n)` - Get range by index
- `get_sreg_range_num(ea, rg)` - Get range index by address

### Range Management
- `del_sreg_range(ea, rg)` - Delete range (extends previous, can't delete segment start)
- `copy_sreg_ranges(dst_rg, src_rg, map_selector=False)` - Duplicate ranges

## Segment Register Constants

### x86/x86-64 Registers
- `R_es` - Extra segment
- `R_cs` - Code segment
- `R_ss` - Stack segment
- `R_ds` - Data segment
- `R_fs` - FS segment
- `R_gs` - GS segment

### Range Tags
- `SR_inherit` - Value inherited from previous range
- `SR_user` - User-specified value
- `SR_auto` - IDA-determined value
- `SR_autostart` - Used as SR_auto at segment start

## Usage Notes

For non-segmented architectures, define two virtual segment registers (CS/DS) and set processor_t::reg_code_sreg and processor_t::reg_data_sreg.

## See Also
Full docs: skill/docs/ida_segregs.rst

```

`skills/idapython/docs/ida_segregs.rst`:

```rst
ida_segregs
===========

.. py:module:: ida_segregs

.. autoapi-nested-parse::

   Functions that deal with the segment registers.

   If your processor doesn't use segment registers, then these functions are of no use for you. However, you should define two virtual segment registers - CS and DS (for code segment and data segment) and specify their internal numbers in the LPH structure (processor_t::reg_code_sreg and processor_t::reg_data_sreg). 
       



Attributes
----------

.. autoapisummary::

   ida_segregs.R_es
   ida_segregs.R_cs
   ida_segregs.R_ss
   ida_segregs.R_ds
   ida_segregs.R_fs
   ida_segregs.R_gs
   ida_segregs.SR_inherit
   ida_segregs.SR_user
   ida_segregs.SR_auto
   ida_segregs.SR_autostart


Classes
-------

.. autoapisummary::

   ida_segregs.sreg_range_t


Functions
---------

.. autoapisummary::

   ida_segregs.get_sreg
   ida_segregs.split_sreg_range
   ida_segregs.set_default_sreg_value
   ida_segregs.set_sreg_at_next_code
   ida_segregs.get_sreg_range
   ida_segregs.get_prev_sreg_range
   ida_segregs.set_default_dataseg
   ida_segregs.get_sreg_ranges_qty
   ida_segregs.getn_sreg_range
   ida_segregs.get_sreg_range_num
   ida_segregs.del_sreg_range
   ida_segregs.copy_sreg_ranges


Module Contents
---------------

.. py:data:: R_es

.. py:data:: R_cs

.. py:data:: R_ss

.. py:data:: R_ds

.. py:data:: R_fs

.. py:data:: R_gs

.. py:class:: sreg_range_t

   Bases: :py:obj:`ida_range.range_t`


   .. py:attribute:: thisown


   .. py:attribute:: val
      :type:  sel_t

      segment register value



   .. py:attribute:: tag
      :type:  uchar

      Segment register range tags



.. py:data:: SR_inherit

   the value is inherited from the previous range


.. py:data:: SR_user

   the value is specified by the user


.. py:data:: SR_auto

   the value is determined by IDA


.. py:data:: SR_autostart

   used as SR_auto for segment starting address


.. py:function:: get_sreg(ea: ida_idaapi.ea_t, rg: int) -> sel_t

   Get value of a segment register. This function uses segment register range and default segment register values stored in the segment structure. 
           
   :param ea: linear address in the program
   :param rg: number of the segment register
   :returns: value of the segment register, BADSEL if value is unknown or rg is not a segment register.


.. py:function:: split_sreg_range(ea: ida_idaapi.ea_t, rg: int, v: sel_t, tag: uchar, silent: bool = False) -> bool

   Create a new segment register range. This function is used when the IDP emulator detects that a segment register changes its value. 
           
   :param ea: linear address where the segment register will have a new value. if ea==BADADDR, nothing to do.
   :param rg: the number of the segment register
   :param v: the new value of the segment register. If the value is unknown, you should specify BADSEL.
   :param tag: the register info tag. see Segment register range tags
   :param silent: if false, display a warning() in the case of failure
   :returns: success


.. py:function:: set_default_sreg_value(sg: segment_t *, rg: int, value: sel_t) -> bool

   Set default value of a segment register for a segment. 
           
   :param sg: pointer to segment structure if nullptr, then set the register for all segments
   :param rg: number of segment register
   :param value: its default value. this value will be used by get_sreg() if value of the register is unknown at the specified address.
   :returns: success


.. py:function:: set_sreg_at_next_code(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, rg: int, value: sel_t) -> None

   Set the segment register value at the next instruction. This function is designed to be called from idb_event::sgr_changed handler in order to contain the effect of changing a segment register value only until the next instruction.
   It is useful, for example, in the ARM module: the modification of the T register does not affect existing instructions later in the code. 
           
   :param ea1: address to start to search for an instruction
   :param ea2: the maximal address
   :param rg: the segment register number
   :param value: the segment register value


.. py:function:: get_sreg_range(out: sreg_range_t, ea: ida_idaapi.ea_t, rg: int) -> bool

   Get segment register range by linear address. 
           
   :param out: segment register range
   :param ea: any linear address in the program
   :param rg: the segment register number
   :returns: success


.. py:function:: get_prev_sreg_range(out: sreg_range_t, ea: ida_idaapi.ea_t, rg: int) -> bool

   Get segment register range previous to one with address. 
           
   :param out: segment register range
   :param ea: any linear address in the program
   :param rg: the segment register number
   :returns: success


.. py:function:: set_default_dataseg(ds_sel: sel_t) -> None

   Set default value of DS register for all segments.


.. py:function:: get_sreg_ranges_qty(rg: int) -> size_t

   Get number of segment register ranges. 
           
   :param rg: the segment register number


.. py:function:: getn_sreg_range(out: sreg_range_t, rg: int, n: int) -> bool

   Get segment register range by its number. 
           
   :param out: segment register range
   :param rg: the segment register number
   :param n: number of range (0..qty()-1)
   :returns: success


.. py:function:: get_sreg_range_num(ea: ida_idaapi.ea_t, rg: int) -> int

   Get number of segment register range by address. 
           
   :param ea: any address in the range
   :param rg: the segment register number
   :returns: -1 if no range occupies the specified address. otherwise returns number of the specified range (0..get_srranges_qty()-1)


.. py:function:: del_sreg_range(ea: ida_idaapi.ea_t, rg: int) -> bool

   Delete segment register range started at ea. When a segment register range is deleted, the previous range is extended to cover the empty space. The segment register range at the beginning of a segment cannot be deleted. 
           
   :param ea: start_ea of the deleted range
   :param rg: the segment register number
   :returns: success


.. py:function:: copy_sreg_ranges(dst_rg: int, src_rg: int, map_selector: bool = False) -> None

   Duplicate segment register ranges. 
           
   :param dst_rg: number of destination segment register
   :param src_rg: copy ranges from
   :param map_selector: map selectors to linear addresses using sel2ea()



```

`skills/idapython/docs/ida_srclang.md`:

```md
# ida_srclang

Third-party compiler support for parsing type declarations from C/C++/Objective-C source.

## Key Functions

### Parser Selection
- `select_parser_by_name(name)` - Set parser by name (None/"" for default)
- `select_parser_by_srclang(lang)` - Set parser supporting language(s)
- `get_selected_parser_name()` - Get current parser name

### Type Declaration Parsing
- `parse_decls_for_srclang(lang, til, input, is_path)` - Parse with language auto-detection
- `parse_decls_with_parser(parser_name, til, input, is_path)` - Parse with specific parser
- `parse_decls_with_parser_ext(parser_name, til, input, hti_flags)` - Parse with formatting flags

**Parameters:**
- `lang/parser_name` - Source language or parser name
- `til` - Type library to store parsed types
- `input` - File path or declaration string
- `is_path` - True if input is path, False if in-memory snippet

**Returns:**
- -1: No parser found
- -2: Operation not supported (set_parser_argv)
- >=0: Number of parse errors

### Parser Configuration
- `set_parser_argv(parser_name, argv)` - Set command-line arguments
- `get_parser_option(parser_name, option_name)` - Get parser option
- `set_parser_option(parser_name, option_name, option_value)` - Set parser option

## Source Languages

- `SRCLANG_C` - C
- `SRCLANG_CPP` - C++
- `SRCLANG_OBJC` - Objective-C
- `SRCLANG_SWIFT` - Swift (not supported yet)
- `SRCLANG_GO` - Golang (not supported yet)

## See Also
Full docs: skill/docs/ida_srclang.rst

```

`skills/idapython/docs/ida_srclang.rst`:

```rst
ida_srclang
===========

.. py:module:: ida_srclang

.. autoapi-nested-parse::

   Third-party compiler support.



Attributes
----------

.. autoapisummary::

   ida_srclang.SRCLANG_C
   ida_srclang.SRCLANG_CPP
   ida_srclang.SRCLANG_OBJC
   ida_srclang.SRCLANG_SWIFT
   ida_srclang.SRCLANG_GO


Functions
---------

.. autoapisummary::

   ida_srclang.select_parser_by_name
   ida_srclang.select_parser_by_srclang
   ida_srclang.get_selected_parser_name
   ida_srclang.set_parser_argv
   ida_srclang.parse_decls_for_srclang
   ida_srclang.parse_decls_with_parser_ext
   ida_srclang.get_parser_option
   ida_srclang.set_parser_option
   ida_srclang.parse_decls_with_parser


Module Contents
---------------

.. py:data:: SRCLANG_C

   C.


.. py:data:: SRCLANG_CPP

   C++.


.. py:data:: SRCLANG_OBJC

   Objective-C.


.. py:data:: SRCLANG_SWIFT

   Swift (not supported yet)


.. py:data:: SRCLANG_GO

   Golang (not supported yet)


.. py:function:: select_parser_by_name(name: str) -> bool

   Set the parser with the given name as the current parser. Pass nullptr or an empty string to select the default parser. 
           
   :returns: false if no parser was found with the given name


.. py:function:: select_parser_by_srclang(lang: srclang_t) -> bool

   Set the parser that supports the given language(s) as the current parser. The selected parser must support all languages specified by the given srclang_t. 
           
   :returns: false if no such parser was found


.. py:function:: get_selected_parser_name() -> str

   Get current parser name. 
           
   :returns: success


.. py:function:: set_parser_argv(parser_name: str, argv: str) -> int

   Set the command-line args to use for invocations of the parser with the given name 
           
   :param parser_name: name of the target parser
   :param argv: argument list
   :returns: -1: no parser was found with the given name
   :returns: -2: the operation is not supported by the given parser
   :returns: 0: success


.. py:function:: parse_decls_for_srclang(lang: srclang_t, til: til_t, input: str, is_path: bool) -> int

   Parse type declarations in the specified language 
           
   :param lang: the source language(s) expected in the input
   :param til: type library to store the types
   :param input: input source. can be a file path or decl string
   :param is_path: true if input parameter is a path to a source file, false if the input is an in-memory source snippet
   :returns: -1: no parser was found that supports the given source language(s)
   :returns: else: the number of errors encountered in the input source


.. py:function:: parse_decls_with_parser_ext(parser_name: str, til: til_t, input: str, hti_flags: int) -> int

   Parse type declarations using the parser with the specified name 
           
   :param parser_name: name of the target parser
   :param til: type library to store the types
   :param input: input source. can be a file path or decl string
   :param hti_flags: combination of Type formatting flags
   :returns: -1: no parser was found with the given name
   :returns: else: the number of errors encountered in the input source


.. py:function:: get_parser_option(parser_name: str, option_name: str) -> str

   Get option for the parser with the specified name 
           
   :param parser_name: name of the target parser
   :param option_name: parser option name
   :returns: success


.. py:function:: set_parser_option(parser_name: str, option_name: str, option_value: str) -> bool

   Set option for the parser with the specified name 
           
   :param parser_name: name of the target parser
   :param option_name: parser option name
   :param option_value: parser option value
   :returns: success


.. py:function:: parse_decls_with_parser(parser_name: str, til: til_t, input: str, is_path: bool) -> int

   Parse type declarations using the parser with the specified name 
           
   :param parser_name: name of the target parser
   :param til: type library to store the types
   :param input: input source. can be a file path or decl string
   :param is_path: true if input parameter is a path to a source file, false if the input is an in-memory source snippet
   :returns: -1: no parser was found with the given name
   :returns: else: the number of errors encountered in the input source



```

`skills/idapython/docs/ida_strlist.md`:

```md
# ida_strlist

String list management (cached view of all strings in the database).

## Key Classes

### string_info_t
String list entry.
- `ea` - String address
- `length` - String length
- `type` - String type

### strwinsetup_t
String list configuration.
- `minlen` - Minimum string length
- `display_only_existing_strings` - Only show defined strings
- `only_7bit` - ASCII-only strings
- `ignore_heads` - Include strings at non-head addresses
- `strtypes` - Enabled string types

## Key Functions

- `build_strlist()` - Rebuild string list (expensive, call when needed)
- `clear_strlist()` - Clear string list
- `get_strlist_qty()` - Get number of strings (loads from DB or builds)
- `get_strlist_item(si, n)` - Get nth string (0..qty-1)
- `get_strlist_options()` - Get static configuration

## Usage Notes

The kernel does NOT auto-update the string list (performance). Users must call build_strlist() for up-to-date results. If not cleared, the list persists in the database across sessions.

## See Also
Full docs: skill/docs/ida_strlist.rst

```

`skills/idapython/docs/ida_strlist.rst`:

```rst
ida_strlist
===========

.. py:module:: ida_strlist

.. autoapi-nested-parse::

   Functions that deal with the string list.

   While the kernel keeps the string list, it does not update it. The string list is not used by the kernel because keeping it up-to-date would slow down IDA without any benefit. If the string list is not cleared using clear_strlist(), the list will be saved to the database and restored on the next startup.
   The users of this list should call build_strlist() if they need an up-to-date version. 
       



Classes
-------

.. autoapisummary::

   ida_strlist.strwinsetup_t
   ida_strlist.string_info_t


Functions
---------

.. autoapisummary::

   ida_strlist.get_strlist_options
   ida_strlist.build_strlist
   ida_strlist.clear_strlist
   ida_strlist.get_strlist_qty
   ida_strlist.get_strlist_item


Module Contents
---------------

.. py:class:: strwinsetup_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: minlen
      :type:  int


   .. py:attribute:: display_only_existing_strings
      :type:  uchar


   .. py:attribute:: only_7bit
      :type:  uchar


   .. py:attribute:: ignore_heads
      :type:  uchar


   .. py:attribute:: strtypes


.. py:class:: string_info_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: length
      :type:  int


   .. py:attribute:: type
      :type:  int


.. py:function:: get_strlist_options() -> strwinsetup_t const *

   Get the static string list options.


.. py:function:: build_strlist() -> None

   Rebuild the string list.


.. py:function:: clear_strlist() -> None

   Clear the string list.


.. py:function:: get_strlist_qty() -> size_t

   Get number of elements in the string list. The list will be loaded from the database (if saved) or built from scratch. 
           


.. py:function:: get_strlist_item(si: string_info_t, n: size_t) -> bool

   Get nth element of the string list (n=0..get_strlist_qty()-1)



```

`skills/idapython/docs/ida_tryblks.md`:

```md
# ida_tryblks

Exception handling (try/catch/SEH) information for binary code analysis.

## Key Classes

### tryblk_t
Represents an exception try block with associated catch/finally handlers.
- `get_kind()` - Check if SEH or C++ try block
- `is_seh()` / `is_cpp()` - Identify exception handling type
- `seh()` - Get SEH handler info (filter + landing pad)
- `cpp()` - Get C++ catch handlers vector
- `level` - Nesting level (auto-calculated)

### catch_t / seh_t
Handler information for C++ catch blocks and SEH (Structured Exception Handling).
- `obj` - Exception object offset (C++)
- `type_id` - Caught exception type ID
- `filter` - SEH filter function range
- `seh_code` - SEH exception code address

## Key Functions

### get_tryblks(tbv, range)
Retrieve all try blocks in address range, sorted and with nesting calculated.

### add_tryblk(tb)
Add try block information. Returns error code (TBERR_OK = success).

### del_tryblks(range)
Delete all try block information in range.

### find_syseh(ea)
Find start address of system exception handler region containing address.

### is_ea_tryblks(ea, flags)
Check if address is part of try/catch/filter (use TBEA_TRY, TBEA_CATCH, TBEA_SEHTRY, etc flags).

## Error Codes

- `TBERR_OK` - Success
- `TBERR_START/END/ORDER` - Invalid address bounds
- `TBERR_INTERSECT` - Try block would intersect inner block
- `TBERR_NO_CATCHES` - No catch handlers defined

## See Also
Full docs: skill/docs/ida_tryblks.rst

```

`skills/idapython/docs/ida_tryblks.rst`:

```rst
ida_tryblks
===========

.. py:module:: ida_tryblks

.. autoapi-nested-parse::

   Architecture independent exception handling info.

   Try blocks have the following general properties:
   * A try block specifies a possibly fragmented guarded code region.
   * Each try block has always at least one catch/except block description
   * Each catch block contains its boundaries and a filter.
   * Additionally a catch block can hold sp adjustment and the offset to the exception object offset (C++).
   * Try blocks can be nested. Nesting is automatically calculated at the retrieval time.
   * There may be (nested) multiple try blocks starting at the same address.


   See examples in tests/input/src/eh_tests. 
       



Attributes
----------

.. autoapisummary::

   ida_tryblks.TBERR_OK
   ida_tryblks.TBERR_START
   ida_tryblks.TBERR_END
   ida_tryblks.TBERR_ORDER
   ida_tryblks.TBERR_EMPTY
   ida_tryblks.TBERR_KIND
   ida_tryblks.TBERR_NO_CATCHES
   ida_tryblks.TBERR_INTERSECT
   ida_tryblks.TBEA_TRY
   ida_tryblks.TBEA_CATCH
   ida_tryblks.TBEA_SEHTRY
   ida_tryblks.TBEA_SEHLPAD
   ida_tryblks.TBEA_SEHFILT
   ida_tryblks.TBEA_ANY
   ida_tryblks.TBEA_FALLTHRU


Classes
-------

.. autoapisummary::

   ida_tryblks.tryblks_t
   ida_tryblks.catchvec_t
   ida_tryblks.try_handler_t
   ida_tryblks.seh_t
   ida_tryblks.catch_t
   ida_tryblks.tryblk_t


Functions
---------

.. autoapisummary::

   ida_tryblks.get_tryblks
   ida_tryblks.del_tryblks
   ida_tryblks.add_tryblk
   ida_tryblks.find_syseh
   ida_tryblks.is_ea_tryblks


Module Contents
---------------

.. py:class:: tryblks_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> tryblk_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> tryblk_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: tryblks_t) -> None


   .. py:method:: extract() -> tryblk_t *


   .. py:method:: inject(s: tryblk_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< tryblk_t >::const_iterator


   .. py:method:: end(*args) -> qvector< tryblk_t >::const_iterator


   .. py:method:: insert(it: tryblk_t, x: tryblk_t) -> qvector< tryblk_t >::iterator


   .. py:method:: erase(*args) -> qvector< tryblk_t >::iterator


   .. py:method:: find(*args) -> qvector< tryblk_t >::const_iterator


   .. py:method:: has(x: tryblk_t) -> bool


   .. py:method:: add_unique(x: tryblk_t) -> bool


   .. py:method:: append(x: tryblk_t) -> None


   .. py:method:: extend(x: tryblks_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: catchvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> catch_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> catch_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: catchvec_t) -> None


   .. py:method:: extract() -> catch_t *


   .. py:method:: inject(s: catch_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< catch_t >::const_iterator


   .. py:method:: end(*args) -> qvector< catch_t >::const_iterator


   .. py:method:: insert(it: catch_t, x: catch_t) -> qvector< catch_t >::iterator


   .. py:method:: erase(*args) -> qvector< catch_t >::iterator


   .. py:method:: find(*args) -> qvector< catch_t >::const_iterator


   .. py:method:: has(x: catch_t) -> bool


   .. py:method:: add_unique(x: catch_t) -> bool


   .. py:method:: append(x: catch_t) -> None


   .. py:method:: extend(x: catchvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: try_handler_t

   Bases: :py:obj:`ida_range.rangevec_t`


   .. py:attribute:: thisown


   .. py:attribute:: disp
      :type:  int


   .. py:attribute:: fpreg
      :type:  int


   .. py:method:: clear() -> None


.. py:class:: seh_t

   Bases: :py:obj:`try_handler_t`


   .. py:attribute:: thisown


   .. py:attribute:: filter
      :type:  rangevec_t


   .. py:attribute:: seh_code
      :type:  ida_idaapi.ea_t


   .. py:method:: clear() -> None


.. py:class:: catch_t

   Bases: :py:obj:`try_handler_t`


   .. py:attribute:: thisown


   .. py:attribute:: obj
      :type:  int


   .. py:attribute:: type_id
      :type:  int


.. py:class:: tryblk_t(*args)

   Bases: :py:obj:`ida_range.rangevec_t`


   .. py:attribute:: thisown


   .. py:attribute:: level
      :type:  uchar


   .. py:method:: cpp() -> catchvec_t &


   .. py:method:: seh() -> seh_t &


   .. py:method:: get_kind() -> uchar


   .. py:method:: empty() -> bool


   .. py:method:: is_seh() -> bool


   .. py:method:: is_cpp() -> bool


   .. py:method:: clear() -> None


   .. py:method:: set_seh() -> seh_t &


   .. py:method:: set_cpp() -> catchvec_t &


.. py:function:: get_tryblks(tbv: tryblks_t, range: range_t) -> size_t

   ------------------------------------------------------------------------- Retrieve try block information from the specified address range. Try blocks are sorted by starting address and their nest levels calculated. 
           
   :param tbv: output buffer; may be nullptr
   :param range: address range to change
   :returns: number of found try blocks


.. py:function:: del_tryblks(range: range_t) -> None

   Delete try block information in the specified range. 
           
   :param range: the range to be cleared


.. py:function:: add_tryblk(tb: tryblk_t) -> int

   Add one try block information. 
           
   :param tb: try block to add.
   :returns: error code; 0 means good


.. py:data:: TBERR_OK

   ok


.. py:data:: TBERR_START

   bad start address


.. py:data:: TBERR_END

   bad end address


.. py:data:: TBERR_ORDER

   bad address order


.. py:data:: TBERR_EMPTY

   empty try block


.. py:data:: TBERR_KIND

   illegal try block kind


.. py:data:: TBERR_NO_CATCHES

   no catch blocks at all


.. py:data:: TBERR_INTERSECT

   range would intersect inner tryblk


.. py:function:: find_syseh(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Find the start address of the system eh region including the argument. 
           
   :param ea: search address
   :returns: start address of surrounding tryblk, otherwise BADADDR


.. py:data:: TBEA_TRY

   is EA within a c++ try block?


.. py:data:: TBEA_CATCH

   is EA the start of a c++ catch/cleanup block?


.. py:data:: TBEA_SEHTRY

   is EA within a seh try block


.. py:data:: TBEA_SEHLPAD

   is EA the start of a seh finally/except block?


.. py:data:: TBEA_SEHFILT

   is EA the start of a seh filter?


.. py:data:: TBEA_ANY

.. py:data:: TBEA_FALLTHRU

   is there a fall through into provided ea from an unwind region


.. py:function:: is_ea_tryblks(ea: ida_idaapi.ea_t, flags: int) -> bool

   Check if the given address ea is part of tryblks description. 
           
   :param ea: address to check
   :param flags: combination of flags for is_ea_tryblks()



```

`skills/idapython/docs/ida_typeinf.md`:

```md
# ida_typeinf

Type information manipulation in IDA - the foundation for working with structures, enums, function prototypes, and all type data.

## Core Concepts

**tinfo_t** objects represent types. They can be:
- **Detached**: Created without a type library, temporary
- **Attached**: Stored in a til_t (type info library), persistent

**Key terms**:
- **udt**: User-defined type (struct/union, not enum)
- **udm**: UDT member (struct/union field)
- **edm**: Enum member (enumerator)
- **til_t**: Type info library (serialized type storage)

## Essential Classes

### tinfo_t
The fundamental type representation object.

#### Creation
- `tinfo_t()` - Empty type
- `tinfo_t(BT_INT)` - Simple type from base type
- `tinfo_t("const char **")` - Parse C declaration
- `get_named_type(til, "struct_name")` - Load from library
- `create_func(func_type_data_t)` - Build function prototype
- `create_ptr(target_type)` - Build pointer type

#### Inspection
- `get_size()` - Type size in bytes
- `is_ptr()` / `is_func()` / `is_struct()` / `is_array()` - Type checks
- `is_const()` / `is_volatile()` - Qualifier checks
- `get_pointed_object()` - Dereference pointer
- `get_realtype()` - Resolve typedefs
- `print_tinfo(prefix, indent, flags)` - Format as C code

#### Decomposition
- `get_func_details(ftd)` - Extract function prototype to func_type_data_t
- `get_udt_details(udt)` - Extract struct/union to udt_type_data_t
- `get_enum_details(etd)` - Extract enum to enum_type_data_t
- `get_array_details(arr)` - Extract array to array_type_data_t
- `get_ptr_details(ptr)` - Extract pointer to ptr_type_data_t

#### Modification
- `create_typedef(til, name)` - Create typedef alias
- `add_udm(name, type_str)` - Add field to attached struct
- `set_numbered_type(til, ordinal, flags, name)` - Store in library

### func_type_data_t
Function prototype representation (return type + arguments).
- `rettype` - tinfo_t of return value
- `[i]` / `size()` - Access funcarg_t arguments by index
- `push_back(funcarg)` - Add parameter
- `cc` - Calling convention (CM_CC_CDECL, CM_CC_STDCALL, etc)
- `flags` - Function attributes (FTI_NORET, FTI_PURE, FTI_VIRTUAL, etc)

### funcarg_t
Function parameter representation.
- `name` - Parameter name
- `type` - tinfo_t of parameter type
- `argloc` - Physical location (register/stack)

### udt_type_data_t
Struct/union field collection (vector of udm_t).
- `[i]` / `size()` - Access udm_t members by index
- `push_back(udm)` - Add field
- `find_member(name)` - Locate field by name
- `get_best_fit_member(offset)` - Find field at offset
- `total_size` - Struct size in bytes
- `is_union` - True if union, false if struct
- `taudt_bits` - Alignment flags

### udm_t
Single struct/union field.
- `name` - Field name
- `type` - tinfo_t of field type
- `offset` - Byte offset (0 for unions)
- `size` - Field size in bytes
- `cmt` / `rptcmt` - Comments

### enum_type_data_t
Enumeration representation (vector of edm_t).
- `[i]` / `size()` - Access edm_t members by index
- `push_back(edm)` - Add enumerator
- `bte` - Storage size flags
- `taenum_bits` - Display format (hex/dec/oct/bin)

### edm_t
Single enum member.
- `name` - Enumerator name
- `value` - Numeric value

### til_t
Type info library (persistent storage).
- `get_named_type(name)` - Load type by name
- `get_numbered_type(ordinal)` - Load type by ordinal number
- `import_type(src)` - Import type from another til
- `named_types()` / `numbered_types()` - Iterate all types
- `cc` - Compiler info (calling conventions, sizes)

## Key Functions

### Type Library Management

#### get_idati()
Get the local type library (IDB's "Local Types").

#### add_til(name, flags)
Add base type library (e.g., "mssdk64_win7" for Windows types).

#### load_til(name, tildir)
Load til file without adding to IDB.

### Type Application

#### apply_tinfo(ea, tinfo, flags)
Apply type to address (function/data). Flags: TINFO_DEFINITE (override), TINFO_GUESSED (suggestion).

#### apply_cdecl(til, ea, decl)
Parse C declaration and apply to address.

#### guess_tinfo(ea)
Auto-analyze and infer type at address.

### Type Creation

#### parse_decl(til, decl, flags)
Parse C declaration string into tinfo_t. Returns (tinfo, name) tuple.

#### create_typedef(til, name)
Create typedef for existing type.

### Type Queries

#### get_tinfo(ea)
Retrieve type applied to address.

#### print_type(ea, flags)
Format type as C declaration string.

#### get_named_type(til, name)
Load type from library by name.

### Type Comparison

#### compare_tinfo(t1, t2, flags)
Check type compatibility. Flags: TCMP_EQUAL (exact), TCMP_MANCAST (manual cast allowed), etc.

## Base Type Constants

### Integers
- `BT_INT8` / `BT_INT16` / `BT_INT32` / `BT_INT64` / `BT_INT128`
- Combined with: `BTMT_SIGNED`, `BTMT_UNSIGNED`, `BTMT_CHAR`
- Shortcuts: `BTF_INT8`, `BTF_UINT8`, `BTF_CHAR`, `BTF_UCHAR`, etc.

### Floating Point
- `BT_FLOAT` - 4/8/10 byte float (use with BTMT_FLOAT/DOUBLE/LNGDBL)
- Shortcuts: `BTF_FLOAT`, `BTF_DOUBLE`, `BTF_LDOUBLE`, `BTF_TBYTE`

### Complex Types
- `BT_PTR` - Pointer (use with BTMT_NEAR/FAR/CLOSURE)
- `BT_ARRAY` - Array
- `BT_FUNC` - Function
- `BT_COMPLEX` - Struct/union/enum/typedef (use with BTMT_STRUCT/UNION/ENUM/TYPEDEF)
- `BT_BITFIELD` - Bitfield (struct member only)

### Special
- `BT_VOID` - void type
- `BT_BOOL` - bool type
- `BT_UNK` - Unknown type

## Type Modifiers

- `BTM_CONST` - const qualifier
- `BTM_VOLATILE` - volatile qualifier

## Calling Conventions

- `CM_CC_INVALID` / `CM_CC_UNKNOWN`
- `CM_CC_CDECL` - C declaration (caller cleans stack)
- `CM_CC_STDCALL` - Standard call (callee cleans)
- `CM_CC_FASTCALL` - Fast call (register args)
- `CM_CC_THISCALL` - C++ member (ecx/rcx = this)
- `CM_CC_PASCAL` - Pascal (right-to-left)
- `CM_CC_SWIFT` - Swift ABI
- `CM_CC_GOLANG` - Go ABI

## Flags

### Type Application (apply_tinfo)
- `TINFO_GUESSED` - Suggested type (user can override)
- `TINFO_DEFINITE` - Force type (overwrite existing)
- `TINFO_DELAYFUNC` - Delay function analysis

### Parsing (parse_decl)
- `PT_SIL` - Silent (no error messages)
- `PT_TYP` - Parse type only (no name)
- `PT_VAR` - Parse variable (type + name)
- `PT_REPLACE` - Replace existing type

### Printing (print_tinfo)
- `PRTYPE_1LINE` - Single line output
- `PRTYPE_MULTI` - Multiple lines
- `PRTYPE_TYPE` - Type only (no name)
- `PRTYPE_DEF` - Include typedef keyword

## Common Patterns

### Create Function Prototype
```python
# int func(const char *str, int count)
ftd = ida_typeinf.func_type_data_t()
ftd.rettype = ida_typeinf.tinfo_t(ida_typeinf.BTF_INT32)

arg1 = ida_typeinf.funcarg_t()
arg1.name = "str"
arg1.type = ida_typeinf.tinfo_t("const char *")
ftd.push_back(arg1)

arg2 = ida_typeinf.funcarg_t()
arg2.name = "count"
arg2.type = ida_typeinf.tinfo_t(ida_typeinf.BTF_INT32)
ftd.push_back(arg2)

tif = ida_typeinf.tinfo_t()
tif.create_func(ftd)
ida_typeinf.apply_tinfo(ea, tif, ida_typeinf.TINFO_DEFINITE)
```

### Create Structure
```python
udt = ida_typeinf.udt_type_data_t()
udt.is_union = False

# Add field: int x
m1 = ida_typeinf.udm_t()
m1.name = "x"
m1.type = ida_typeinf.tinfo_t(ida_typeinf.BTF_INT32)
m1.offset = 0
m1.size = 4
udt.push_back(m1)

tif = ida_typeinf.tinfo_t()
tif.create_udt(udt, ida_typeinf.BTF_STRUCT)
tif.set_numbered_type(ida_typeinf.get_idati(), 0,
    ida_typeinf.NTF_REPLACE, "MyStruct")
```

### Inspect Function Type
```python
tif = ida_typeinf.tinfo_t()
if ida_typeinf.get_tinfo(tif, ea):
    if tif.is_func():
        ftd = ida_typeinf.func_type_data_t()
        tif.get_func_details(ftd)
        print(f"Return: {ftd.rettype}")
        for i in range(ftd.size()):
            arg = ftd[i]
            print(f"Arg {i}: {arg.name} : {arg.type}")
```

## See Also
Full docs: skill/docs/ida_typeinf.rst
IDA Domain API: https://ida-domain.docs.hex-rays.com/ (simplified type operations)

```

`skills/idapython/docs/ida_typeinf.rst`:

```rst
ida_typeinf
===========

.. py:module:: ida_typeinf

.. autoapi-nested-parse::

   Type information in IDA.

   In IDA, types are represented by and manipulated through tinfo_t objects.

   A tinfo_t can represent a simple type (e.g., `int`, `float`), a complex type 
   (a structure, enum, union, typedef), or even an array, or a function prototype.

   The key types in this file are:

   * til_t - a type info library. Holds type information in serialized form.
   * tinfo_t - information about a type (simple, complex, ...)


   Glossary
   --------

   All throughout this file, there are certain terms that will keep appearing:

   * udt: "user-defined type": a structure or union - but not enums. See udt_type_data_t
   * udm: "udt member": i.e., a structure or union member. See udm_t
   * edm: "enum member": i.e., an enumeration member - i.e., an enumerator. See edm_t


   Under the hood
   --------------

   The tinfo_t type provides a lot of useful methods already, but it's possible to 
   achieve even more by retrieving its contents into the container classes:

   * udt_type_data_t - for structures & unions. See tinfo_t::get_udt_details. 
     Essentially, a vector of udm_t
   * enum_type_data_t - for enumerations. See tinfo_t::get_enum_details. 
     Essentially, a vector of edm_t
   * ptr_type_data_t - for pointers. See tinfo_t::get_ptr_details
   * array_type_data_t - for arrays. See tinfo_t::get_array_details
   * func_type_data_t - for function prototypes. See tinfo_t::get_func_details
   * bitfield_type_data_t - for bitfields. See tinfo_t::get_bitfield_details


   Attached & detached tinfo_t objects
   ------------------------------------

   tinfo_t objects can be attached to a til_t library, or can be created without 
   using any til_t.

   Here is an example, assigning a function prototype::

       func_type_data_t func_info;
       funcarg_t argc; 
       argc.name = "argc"; 
       argc.type = tinfo_t(BT_INT); 
       func_info.push_back(argc);
       funcarg_t argv; 
       argc.name = "argv"; 
       argc.type = tinfo_t("const char **"); 
       func_info.push_back(argv)
       tinfo_t tif; 
       if ( tif.create_func(func_info) ) { 
           ea_t ea = // get address of "main" 
           apply_tinfo(ea, tif, TINFO_DEFINITE); 
       }

   This code manipulates a "detached" tinfo_t object, which does not depend on any 
   til_t file. However, any complex type will require a til_t file. In IDA, there 
   is always a default til_t file for each idb file. This til_t file can be 
   specified by nullptr.

   On the other hand, the following code manipulates an "attached" tinfo_t object, 
   and any operation that modifies it, will also modify it in the hosting til_t::

       tinfo_t tif; 
       # Load type from the "Local Types" til_t. 
       # Note: we could have used `get_idati()` instead of nullptr 
       if ( tif.get_named_type(nullptr, "my_struct_t") ) 
           tif.add_udm("extra_field", "unsigned long long");

   You can check if a tinfo_t instance is attached to a type in a til_t file by 
   calling tinfo_t::is_typeref.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For type operations, see :mod:`ida_domain.types`.



Attributes
----------

.. autoapisummary::

   ida_typeinf.DEFMASK64
   ida_typeinf.RESERVED_BYTE
   ida_typeinf.TAH_BYTE
   ida_typeinf.FAH_BYTE
   ida_typeinf.MAX_DECL_ALIGN
   ida_typeinf.TAH_HASATTRS
   ida_typeinf.TAUDT_UNALIGNED
   ida_typeinf.TAUDT_MSSTRUCT
   ida_typeinf.TAUDT_CPPOBJ
   ida_typeinf.TAUDT_VFTABLE
   ida_typeinf.TAUDT_FIXED
   ida_typeinf.TAUDT_TUPLE
   ida_typeinf.TAFLD_BASECLASS
   ida_typeinf.TAFLD_UNALIGNED
   ida_typeinf.TAFLD_VIRTBASE
   ida_typeinf.TAFLD_VFTABLE
   ida_typeinf.TAFLD_METHOD
   ida_typeinf.TAFLD_GAP
   ida_typeinf.TAFLD_REGCMT
   ida_typeinf.TAFLD_FRAME_R
   ida_typeinf.TAFLD_FRAME_S
   ida_typeinf.TAFLD_BYTIL
   ida_typeinf.TAPTR_PTR32
   ida_typeinf.TAPTR_PTR64
   ida_typeinf.TAPTR_RESTRICT
   ida_typeinf.TAPTR_SHIFTED
   ida_typeinf.TAENUM_64BIT
   ida_typeinf.TAENUM_UNSIGNED
   ida_typeinf.TAENUM_SIGNED
   ida_typeinf.TAENUM_OCT
   ida_typeinf.TAENUM_BIN
   ida_typeinf.TAENUM_NUMSIGN
   ida_typeinf.TAENUM_LZERO
   ida_typeinf.TAH_ALL
   ida_typeinf.cvar
   ida_typeinf.TYPE_BASE_MASK
   ida_typeinf.TYPE_FLAGS_MASK
   ida_typeinf.TYPE_MODIF_MASK
   ida_typeinf.TYPE_FULL_MASK
   ida_typeinf.BT_UNK
   ida_typeinf.BT_VOID
   ida_typeinf.BTMT_SIZE0
   ida_typeinf.BTMT_SIZE12
   ida_typeinf.BTMT_SIZE48
   ida_typeinf.BTMT_SIZE128
   ida_typeinf.BT_INT8
   ida_typeinf.BT_INT16
   ida_typeinf.BT_INT32
   ida_typeinf.BT_INT64
   ida_typeinf.BT_INT128
   ida_typeinf.BT_INT
   ida_typeinf.BTMT_UNKSIGN
   ida_typeinf.BTMT_SIGNED
   ida_typeinf.BTMT_USIGNED
   ida_typeinf.BTMT_UNSIGNED
   ida_typeinf.BTMT_CHAR
   ida_typeinf.BT_BOOL
   ida_typeinf.BTMT_DEFBOOL
   ida_typeinf.BTMT_BOOL1
   ida_typeinf.BTMT_BOOL2
   ida_typeinf.BTMT_BOOL8
   ida_typeinf.BTMT_BOOL4
   ida_typeinf.BT_FLOAT
   ida_typeinf.BTMT_FLOAT
   ida_typeinf.BTMT_DOUBLE
   ida_typeinf.BTMT_LNGDBL
   ida_typeinf.BTMT_SPECFLT
   ida_typeinf.BT_PTR
   ida_typeinf.BTMT_DEFPTR
   ida_typeinf.BTMT_NEAR
   ida_typeinf.BTMT_FAR
   ida_typeinf.BTMT_CLOSURE
   ida_typeinf.BT_ARRAY
   ida_typeinf.BTMT_NONBASED
   ida_typeinf.BTMT_ARRESERV
   ida_typeinf.BT_FUNC
   ida_typeinf.BTMT_DEFCALL
   ida_typeinf.BTMT_NEARCALL
   ida_typeinf.BTMT_FARCALL
   ida_typeinf.BTMT_INTCALL
   ida_typeinf.BT_COMPLEX
   ida_typeinf.BTMT_STRUCT
   ida_typeinf.BTMT_UNION
   ida_typeinf.BTMT_ENUM
   ida_typeinf.BTMT_TYPEDEF
   ida_typeinf.BT_BITFIELD
   ida_typeinf.BTMT_BFLDI8
   ida_typeinf.BTMT_BFLDI16
   ida_typeinf.BTMT_BFLDI32
   ida_typeinf.BTMT_BFLDI64
   ida_typeinf.BT_RESERVED
   ida_typeinf.BTM_CONST
   ida_typeinf.BTM_VOLATILE
   ida_typeinf.BTE_SIZE_MASK
   ida_typeinf.BTE_RESERVED
   ida_typeinf.BTE_BITMASK
   ida_typeinf.BTE_OUT_MASK
   ida_typeinf.BTE_HEX
   ida_typeinf.BTE_CHAR
   ida_typeinf.BTE_SDEC
   ida_typeinf.BTE_UDEC
   ida_typeinf.BTE_ALWAYS
   ida_typeinf.BT_SEGREG
   ida_typeinf.BT_UNK_BYTE
   ida_typeinf.BT_UNK_WORD
   ida_typeinf.BT_UNK_DWORD
   ida_typeinf.BT_UNK_QWORD
   ida_typeinf.BT_UNK_OWORD
   ida_typeinf.BT_UNKNOWN
   ida_typeinf.BTF_BYTE
   ida_typeinf.BTF_UNK
   ida_typeinf.BTF_VOID
   ida_typeinf.BTF_INT8
   ida_typeinf.BTF_CHAR
   ida_typeinf.BTF_UCHAR
   ida_typeinf.BTF_UINT8
   ida_typeinf.BTF_INT16
   ida_typeinf.BTF_UINT16
   ida_typeinf.BTF_INT32
   ida_typeinf.BTF_UINT32
   ida_typeinf.BTF_INT64
   ida_typeinf.BTF_UINT64
   ida_typeinf.BTF_INT128
   ida_typeinf.BTF_UINT128
   ida_typeinf.BTF_INT
   ida_typeinf.BTF_UINT
   ida_typeinf.BTF_SINT
   ida_typeinf.BTF_BOOL
   ida_typeinf.BTF_FLOAT
   ida_typeinf.BTF_DOUBLE
   ida_typeinf.BTF_LDOUBLE
   ida_typeinf.BTF_TBYTE
   ida_typeinf.BTF_STRUCT
   ida_typeinf.BTF_UNION
   ida_typeinf.BTF_ENUM
   ida_typeinf.BTF_TYPEDEF
   ida_typeinf.TA_ORG_TYPEDEF
   ida_typeinf.TA_ORG_ARRDIM
   ida_typeinf.TA_FORMAT
   ida_typeinf.TA_VALUE_REPR
   ida_typeinf.no_sign
   ida_typeinf.type_signed
   ida_typeinf.type_unsigned
   ida_typeinf.TIL_ZIP
   ida_typeinf.TIL_MAC
   ida_typeinf.TIL_ESI
   ida_typeinf.TIL_UNI
   ida_typeinf.TIL_ORD
   ida_typeinf.TIL_ALI
   ida_typeinf.TIL_MOD
   ida_typeinf.TIL_STM
   ida_typeinf.TIL_SLD
   ida_typeinf.TIL_ECC
   ida_typeinf.TIL_ADD_FAILED
   ida_typeinf.TIL_ADD_OK
   ida_typeinf.TIL_ADD_ALREADY
   ida_typeinf.CM_MASK
   ida_typeinf.CM_UNKNOWN
   ida_typeinf.CM_N8_F16
   ida_typeinf.CM_N64
   ida_typeinf.CM_N16_F32
   ida_typeinf.CM_N32_F48
   ida_typeinf.CM_M_MASK
   ida_typeinf.CM_M_NN
   ida_typeinf.CM_M_FF
   ida_typeinf.CM_M_NF
   ida_typeinf.CM_M_FN
   ida_typeinf.CM_CC_MASK
   ida_typeinf.CM_CC_INVALID
   ida_typeinf.CM_CC_UNKNOWN
   ida_typeinf.CM_CC_VOIDARG
   ida_typeinf.CM_CC_CDECL
   ida_typeinf.CM_CC_ELLIPSIS
   ida_typeinf.CM_CC_STDCALL
   ida_typeinf.CM_CC_PASCAL
   ida_typeinf.CM_CC_FASTCALL
   ida_typeinf.CM_CC_THISCALL
   ida_typeinf.CM_CC_SWIFT
   ida_typeinf.CM_CC_SPOILED
   ida_typeinf.CM_CC_GOLANG
   ida_typeinf.CM_CC_RESERVE3
   ida_typeinf.CM_CC_SPECIALE
   ida_typeinf.CM_CC_SPECIALP
   ida_typeinf.CM_CC_SPECIAL
   ida_typeinf.CM_CC_LAST_USERCALL
   ida_typeinf.CM_CC_GOSTK
   ida_typeinf.CM_CC_FIRST_PLAIN_CUSTOM
   ida_typeinf.BFA_NORET
   ida_typeinf.BFA_PURE
   ida_typeinf.BFA_HIGH
   ida_typeinf.BFA_STATIC
   ida_typeinf.BFA_VIRTUAL
   ida_typeinf.BFA_FUNC_MARKER
   ida_typeinf.BFA_FUNC_EXT_FORMAT
   ida_typeinf.ALOC_NONE
   ida_typeinf.ALOC_STACK
   ida_typeinf.ALOC_DIST
   ida_typeinf.ALOC_REG1
   ida_typeinf.ALOC_REG2
   ida_typeinf.ALOC_RREL
   ida_typeinf.ALOC_STATIC
   ida_typeinf.ALOC_CUSTOM
   ida_typeinf.PRALOC_VERIFY
   ida_typeinf.PRALOC_STKOFF
   ida_typeinf.C_PC_TINY
   ida_typeinf.C_PC_SMALL
   ida_typeinf.C_PC_COMPACT
   ida_typeinf.C_PC_MEDIUM
   ida_typeinf.C_PC_LARGE
   ida_typeinf.C_PC_HUGE
   ida_typeinf.C_PC_FLAT
   ida_typeinf.CCI_VARARG
   ida_typeinf.CCI_PURGE
   ida_typeinf.CCI_USER
   ida_typeinf.ARGREGS_POLICY_UNDEFINED
   ida_typeinf.ARGREGS_GP_ONLY
   ida_typeinf.ARGREGS_INDEPENDENT
   ida_typeinf.ARGREGS_BY_SLOTS
   ida_typeinf.ARGREGS_FP_MASKS_GP
   ida_typeinf.ARGREGS_MIPS_O32
   ida_typeinf.ARGREGS_RISCV
   ida_typeinf.SETCOMP_OVERRIDE
   ida_typeinf.SETCOMP_ONLY_ID
   ida_typeinf.SETCOMP_ONLY_ABI
   ida_typeinf.SETCOMP_BY_USER
   ida_typeinf.MAX_FUNC_ARGS
   ida_typeinf.ABS_UNK
   ida_typeinf.ABS_NO
   ida_typeinf.ABS_YES
   ida_typeinf.SC_UNK
   ida_typeinf.SC_TYPE
   ida_typeinf.SC_EXT
   ida_typeinf.SC_STAT
   ida_typeinf.SC_REG
   ida_typeinf.SC_AUTO
   ida_typeinf.SC_FRIEND
   ida_typeinf.SC_VIRT
   ida_typeinf.HTI_CPP
   ida_typeinf.HTI_INT
   ida_typeinf.HTI_EXT
   ida_typeinf.HTI_LEX
   ida_typeinf.HTI_UNP
   ida_typeinf.HTI_TST
   ida_typeinf.HTI_FIL
   ida_typeinf.HTI_MAC
   ida_typeinf.HTI_NWR
   ida_typeinf.HTI_NER
   ida_typeinf.HTI_DCL
   ida_typeinf.HTI_NDC
   ida_typeinf.HTI_PAK
   ida_typeinf.HTI_PAK_SHIFT
   ida_typeinf.HTI_PAKDEF
   ida_typeinf.HTI_PAK1
   ida_typeinf.HTI_PAK2
   ida_typeinf.HTI_PAK4
   ida_typeinf.HTI_PAK8
   ida_typeinf.HTI_PAK16
   ida_typeinf.HTI_HIGH
   ida_typeinf.HTI_LOWER
   ida_typeinf.HTI_RAWARGS
   ida_typeinf.HTI_RELAXED
   ida_typeinf.HTI_NOBASE
   ida_typeinf.HTI_SEMICOLON
   ida_typeinf.HTI_STANDALONE
   ida_typeinf.PT_SIL
   ida_typeinf.PT_NDC
   ida_typeinf.PT_TYP
   ida_typeinf.PT_VAR
   ida_typeinf.PT_PACKMASK
   ida_typeinf.PT_HIGH
   ida_typeinf.PT_LOWER
   ida_typeinf.PT_REPLACE
   ida_typeinf.PT_RAWARGS
   ida_typeinf.PT_RELAXED
   ida_typeinf.PT_EMPTY
   ida_typeinf.PT_SEMICOLON
   ida_typeinf.PT_SYMBOL
   ida_typeinf.PRTYPE_1LINE
   ida_typeinf.PRTYPE_MULTI
   ida_typeinf.PRTYPE_TYPE
   ida_typeinf.PRTYPE_PRAGMA
   ida_typeinf.PRTYPE_SEMI
   ida_typeinf.PRTYPE_CPP
   ida_typeinf.PRTYPE_DEF
   ida_typeinf.PRTYPE_NOARGS
   ida_typeinf.PRTYPE_NOARRS
   ida_typeinf.PRTYPE_NORES
   ida_typeinf.PRTYPE_RESTORE
   ida_typeinf.PRTYPE_NOREGEX
   ida_typeinf.PRTYPE_COLORED
   ida_typeinf.PRTYPE_METHODS
   ida_typeinf.PRTYPE_1LINCMT
   ida_typeinf.PRTYPE_HEADER
   ida_typeinf.PRTYPE_OFFSETS
   ida_typeinf.PRTYPE_MAXSTR
   ida_typeinf.PRTYPE_TAIL
   ida_typeinf.PRTYPE_ARGLOCS
   ida_typeinf.NTF_TYPE
   ida_typeinf.NTF_SYMU
   ida_typeinf.NTF_SYMM
   ida_typeinf.NTF_NOBASE
   ida_typeinf.NTF_REPLACE
   ida_typeinf.NTF_UMANGLED
   ida_typeinf.NTF_NOCUR
   ida_typeinf.NTF_64BIT
   ida_typeinf.NTF_FIXNAME
   ida_typeinf.NTF_IDBENC
   ida_typeinf.NTF_CHKSYNC
   ida_typeinf.NTF_NO_NAMECHK
   ida_typeinf.NTF_COPY
   ida_typeinf.TERR_OK
   ida_typeinf.TERR_SAVE_ERROR
   ida_typeinf.TERR_SERIALIZE
   ida_typeinf.TERR_BAD_NAME
   ida_typeinf.TERR_BAD_ARG
   ida_typeinf.TERR_BAD_TYPE
   ida_typeinf.TERR_BAD_SIZE
   ida_typeinf.TERR_BAD_INDEX
   ida_typeinf.TERR_BAD_ARRAY
   ida_typeinf.TERR_BAD_BF
   ida_typeinf.TERR_BAD_OFFSET
   ida_typeinf.TERR_BAD_UNIVAR
   ida_typeinf.TERR_BAD_VARLAST
   ida_typeinf.TERR_OVERLAP
   ida_typeinf.TERR_BAD_SUBTYPE
   ida_typeinf.TERR_BAD_VALUE
   ida_typeinf.TERR_NO_BMASK
   ida_typeinf.TERR_BAD_BMASK
   ida_typeinf.TERR_BAD_MSKVAL
   ida_typeinf.TERR_BAD_REPR
   ida_typeinf.TERR_GRP_NOEMPTY
   ida_typeinf.TERR_DUPNAME
   ida_typeinf.TERR_UNION_BF
   ida_typeinf.TERR_BAD_TAH
   ida_typeinf.TERR_BAD_BASE
   ida_typeinf.TERR_BAD_GAP
   ida_typeinf.TERR_NESTED
   ida_typeinf.TERR_NOT_COMPAT
   ida_typeinf.TERR_BAD_LAYOUT
   ida_typeinf.TERR_BAD_GROUPS
   ida_typeinf.TERR_BAD_SERIAL
   ida_typeinf.TERR_ALIEN_NAME
   ida_typeinf.TERR_STOCK
   ida_typeinf.TERR_ENUM_SIZE
   ida_typeinf.TERR_NOT_IMPL
   ida_typeinf.TERR_TYPE_WORSE
   ida_typeinf.TERR_BAD_FX_SIZE
   ida_typeinf.TERR_STRUCT_SIZE
   ida_typeinf.TERR_NOT_FOUND
   ida_typeinf.TERR_COUNT
   ida_typeinf.CCN_C
   ida_typeinf.CCN_CPP
   ida_typeinf.ADDTIL_DEFAULT
   ida_typeinf.ADDTIL_INCOMP
   ida_typeinf.ADDTIL_SILENT
   ida_typeinf.ADDTIL_FAILED
   ida_typeinf.ADDTIL_OK
   ida_typeinf.ADDTIL_COMP
   ida_typeinf.ADDTIL_ABORTED
   ida_typeinf.TINFO_GUESSED
   ida_typeinf.TINFO_DEFINITE
   ida_typeinf.TINFO_DELAYFUNC
   ida_typeinf.TINFO_STRICT
   ida_typeinf.GUESS_FUNC_FAILED
   ida_typeinf.GUESS_FUNC_TRIVIAL
   ida_typeinf.GUESS_FUNC_OK
   ida_typeinf.STI_PCHAR
   ida_typeinf.STI_PUCHAR
   ida_typeinf.STI_PCCHAR
   ida_typeinf.STI_PCUCHAR
   ida_typeinf.STI_PBYTE
   ida_typeinf.STI_PINT
   ida_typeinf.STI_PUINT
   ida_typeinf.STI_PVOID
   ida_typeinf.STI_PPVOID
   ida_typeinf.STI_PCVOID
   ida_typeinf.STI_ACHAR
   ida_typeinf.STI_AUCHAR
   ida_typeinf.STI_ACCHAR
   ida_typeinf.STI_ACUCHAR
   ida_typeinf.STI_FPURGING
   ida_typeinf.STI_FDELOP
   ida_typeinf.STI_MSGSEND
   ida_typeinf.STI_AEABI_LCMP
   ida_typeinf.STI_AEABI_ULCMP
   ida_typeinf.STI_DONT_USE
   ida_typeinf.STI_SIZE_T
   ida_typeinf.STI_SSIZE_T
   ida_typeinf.STI_AEABI_MEMCPY
   ida_typeinf.STI_AEABI_MEMSET
   ida_typeinf.STI_AEABI_MEMCLR
   ida_typeinf.STI_RTC_CHECK_2
   ida_typeinf.STI_RTC_CHECK_4
   ida_typeinf.STI_RTC_CHECK_8
   ida_typeinf.STI_COMPLEX64
   ida_typeinf.STI_COMPLEX128
   ida_typeinf.STI_PUNKNOWN
   ida_typeinf.STI_LAST
   ida_typeinf.ETF_NO_SAVE
   ida_typeinf.ETF_NO_LAYOUT
   ida_typeinf.ETF_MAY_DESTROY
   ida_typeinf.ETF_COMPATIBLE
   ida_typeinf.ETF_FUNCARG
   ida_typeinf.ETF_FORCENAME
   ida_typeinf.ETF_AUTONAME
   ida_typeinf.ETF_BYTIL
   ida_typeinf.ETF_NO_ARRAY
   ida_typeinf.GTD_CALC_LAYOUT
   ida_typeinf.GTD_NO_LAYOUT
   ida_typeinf.GTD_DEL_BITFLDS
   ida_typeinf.GTD_CALC_ARGLOCS
   ida_typeinf.GTD_NO_ARGLOCS
   ida_typeinf.GTS_NESTED
   ida_typeinf.GTS_BASECLASS
   ida_typeinf.SUDT_SORT
   ida_typeinf.SUDT_ALIGN
   ida_typeinf.SUDT_GAPS
   ida_typeinf.SUDT_UNEX
   ida_typeinf.SUDT_FAST
   ida_typeinf.SUDT_CONST
   ida_typeinf.SUDT_VOLATILE
   ida_typeinf.SUDT_TRUNC
   ida_typeinf.SUDT_SERDEF
   ida_typeinf.COMP_MASK
   ida_typeinf.COMP_UNK
   ida_typeinf.COMP_MS
   ida_typeinf.COMP_BC
   ida_typeinf.COMP_WATCOM
   ida_typeinf.COMP_GNU
   ida_typeinf.COMP_VISAGE
   ida_typeinf.COMP_BP
   ida_typeinf.COMP_UNSURE
   ida_typeinf.BADSIZE
   ida_typeinf.FIRST_NONTRIVIAL_TYPID
   ida_typeinf.TYPID_ISREF
   ida_typeinf.TYPID_SHIFT
   ida_typeinf.STRMEM_MASK
   ida_typeinf.STRMEM_OFFSET
   ida_typeinf.STRMEM_INDEX
   ida_typeinf.STRMEM_AUTO
   ida_typeinf.STRMEM_NAME
   ida_typeinf.STRMEM_TYPE
   ida_typeinf.STRMEM_SIZE
   ida_typeinf.STRMEM_MINS
   ida_typeinf.STRMEM_MAXS
   ida_typeinf.STRMEM_LOWBND
   ida_typeinf.STRMEM_NEXT
   ida_typeinf.STRMEM_VFTABLE
   ida_typeinf.STRMEM_SKIP_EMPTY
   ida_typeinf.STRMEM_CASTABLE_TO
   ida_typeinf.STRMEM_ANON
   ida_typeinf.STRMEM_SKIP_GAPS
   ida_typeinf.TCMP_EQUAL
   ida_typeinf.TCMP_IGNMODS
   ida_typeinf.TCMP_AUTOCAST
   ida_typeinf.TCMP_MANCAST
   ida_typeinf.TCMP_CALL
   ida_typeinf.TCMP_DELPTR
   ida_typeinf.TCMP_DECL
   ida_typeinf.TCMP_ANYBASE
   ida_typeinf.TCMP_SKIPTHIS
   ida_typeinf.TCMP_DEEP_UDT
   ida_typeinf.FAI_HIDDEN
   ida_typeinf.FAI_RETPTR
   ida_typeinf.FAI_STRUCT
   ida_typeinf.FAI_ARRAY
   ida_typeinf.FAI_UNUSED
   ida_typeinf.FTI_SPOILED
   ida_typeinf.FTI_NORET
   ida_typeinf.FTI_PURE
   ida_typeinf.FTI_HIGH
   ida_typeinf.FTI_STATIC
   ida_typeinf.FTI_VIRTUAL
   ida_typeinf.FTI_CALLTYPE
   ida_typeinf.FTI_DEFCALL
   ida_typeinf.FTI_NEARCALL
   ida_typeinf.FTI_FARCALL
   ida_typeinf.FTI_INTCALL
   ida_typeinf.FTI_ARGLOCS
   ida_typeinf.FTI_EXPLOCS
   ida_typeinf.FTI_CONST
   ida_typeinf.FTI_CTOR
   ida_typeinf.FTI_DTOR
   ida_typeinf.FTI_ALL
   ida_typeinf.CC_CDECL_OK
   ida_typeinf.CC_ALLOW_ARGPERM
   ida_typeinf.CC_ALLOW_REGHOLES
   ida_typeinf.CC_HAS_ELLIPSIS
   ida_typeinf.CC_GOLANG_OK
   ida_typeinf.FMTFUNC_PRINTF
   ida_typeinf.FMTFUNC_SCANF
   ida_typeinf.FMTFUNC_STRFTIME
   ida_typeinf.FMTFUNC_STRFMON
   ida_typeinf.MAX_ENUM_SERIAL
   ida_typeinf.FRB_MASK
   ida_typeinf.FRB_UNK
   ida_typeinf.FRB_NUMB
   ida_typeinf.FRB_NUMO
   ida_typeinf.FRB_NUMH
   ida_typeinf.FRB_NUMD
   ida_typeinf.FRB_FLOAT
   ida_typeinf.FRB_CHAR
   ida_typeinf.FRB_SEG
   ida_typeinf.FRB_ENUM
   ida_typeinf.FRB_OFFSET
   ida_typeinf.FRB_STRLIT
   ida_typeinf.FRB_STROFF
   ida_typeinf.FRB_CUSTOM
   ida_typeinf.FRB_INVSIGN
   ida_typeinf.FRB_INVBITS
   ida_typeinf.FRB_SIGNED
   ida_typeinf.FRB_LZERO
   ida_typeinf.FRB_TABFORM
   ida_typeinf.STRUC_SEPARATOR
   ida_typeinf.VTBL_SUFFIX
   ida_typeinf.VTBL_MEMNAME
   ida_typeinf.TPOS_LNNUM
   ida_typeinf.TPOS_REGCMT
   ida_typeinf.TVIS_TYPE
   ida_typeinf.TVIS_NAME
   ida_typeinf.TVIS_CMT
   ida_typeinf.TVIS_RPTCMT
   ida_typeinf.TVST_PRUNE
   ida_typeinf.TVST_DEF
   ida_typeinf.TVST_LEVEL
   ida_typeinf.PIO_NOATTR_FAIL
   ida_typeinf.PIO_IGNORE_PTRS
   ida_typeinf.UTP_ENUM
   ida_typeinf.UTP_STRUCT
   ida_typeinf.VALSTR_OPEN
   ida_typeinf.PDF_INCL_DEPS
   ida_typeinf.PDF_DEF_FWD
   ida_typeinf.PDF_DEF_BASE
   ida_typeinf.PDF_HEADER_CMT
   ida_typeinf.PT_FILE
   ida_typeinf.PT_STANDALONE
   ida_typeinf.cvar
   ida_typeinf.sc_auto
   ida_typeinf.sc_ext
   ida_typeinf.sc_friend
   ida_typeinf.sc_reg
   ida_typeinf.sc_stat
   ida_typeinf.sc_type
   ida_typeinf.sc_unk
   ida_typeinf.sc_virt
   ida_typeinf.TERR_SAVE
   ida_typeinf.TERR_WRONGNAME
   ida_typeinf.BADORD
   ida_typeinf.enum_member_vec_t
   ida_typeinf.enum_member_t
   ida_typeinf.udt_member_t


Classes
-------

.. autoapisummary::

   ida_typeinf.funcargvec_t
   ida_typeinf.reginfovec_t
   ida_typeinf.edmvec_t
   ida_typeinf.argpartvec_t
   ida_typeinf.valstrvec_t
   ida_typeinf.regobjvec_t
   ida_typeinf.type_attrs_t
   ida_typeinf.udtmembervec_template_t
   ida_typeinf.type_attr_t
   ida_typeinf.til_t
   ida_typeinf.rrel_t
   ida_typeinf.argloc_t
   ida_typeinf.argpart_t
   ida_typeinf.scattered_aloc_t
   ida_typeinf.aloc_visitor_t
   ida_typeinf.const_aloc_visitor_t
   ida_typeinf.stkarg_area_info_t
   ida_typeinf.custom_callcnv_t
   ida_typeinf.callregs_t
   ida_typeinf.tinfo_t
   ida_typeinf.simd_info_t
   ida_typeinf.ptr_type_data_t
   ida_typeinf.array_type_data_t
   ida_typeinf.funcarg_t
   ida_typeinf.func_type_data_t
   ida_typeinf.edm_t
   ida_typeinf.enum_type_data_t
   ida_typeinf.typedef_type_data_t
   ida_typeinf.custom_data_type_info_t
   ida_typeinf.value_repr_t
   ida_typeinf.udm_t
   ida_typeinf.udtmembervec_t
   ida_typeinf.udt_type_data_t
   ida_typeinf.udm_visitor_t
   ida_typeinf.bitfield_type_data_t
   ida_typeinf.type_mods_t
   ida_typeinf.tinfo_visitor_t
   ida_typeinf.regobj_t
   ida_typeinf.regobjs_t
   ida_typeinf.argtinfo_helper_t
   ida_typeinf.lowertype_helper_t
   ida_typeinf.ida_lowertype_helper_t
   ida_typeinf.valstr_t
   ida_typeinf.valstrs_t
   ida_typeinf.text_sink_t
   ida_typeinf.til_symbol_t
   ida_typeinf.predicate_t
   ida_typeinf.til_type_ref_t


Functions
---------

.. autoapisummary::

   ida_typeinf.deserialize_tinfo
   ida_typeinf.is_type_const
   ida_typeinf.is_type_volatile
   ida_typeinf.get_base_type
   ida_typeinf.get_type_flags
   ida_typeinf.get_full_type
   ida_typeinf.is_typeid_last
   ida_typeinf.is_type_partial
   ida_typeinf.is_type_void
   ida_typeinf.is_type_unknown
   ida_typeinf.is_type_ptr
   ida_typeinf.is_type_complex
   ida_typeinf.is_type_func
   ida_typeinf.is_type_array
   ida_typeinf.is_type_typedef
   ida_typeinf.is_type_sue
   ida_typeinf.is_type_struct
   ida_typeinf.is_type_union
   ida_typeinf.is_type_struni
   ida_typeinf.is_type_enum
   ida_typeinf.is_type_bitfld
   ida_typeinf.is_type_int
   ida_typeinf.is_type_int128
   ida_typeinf.is_type_int64
   ida_typeinf.is_type_int32
   ida_typeinf.is_type_int16
   ida_typeinf.is_type_char
   ida_typeinf.is_type_paf
   ida_typeinf.is_type_ptr_or_array
   ida_typeinf.is_type_floating
   ida_typeinf.is_type_integral
   ida_typeinf.is_type_ext_integral
   ida_typeinf.is_type_arithmetic
   ida_typeinf.is_type_ext_arithmetic
   ida_typeinf.is_type_uint
   ida_typeinf.is_type_uchar
   ida_typeinf.is_type_uint16
   ida_typeinf.is_type_uint32
   ida_typeinf.is_type_uint64
   ida_typeinf.is_type_uint128
   ida_typeinf.is_type_ldouble
   ida_typeinf.is_type_double
   ida_typeinf.is_type_float
   ida_typeinf.is_type_tbyte
   ida_typeinf.is_type_bool
   ida_typeinf.is_tah_byte
   ida_typeinf.is_sdacl_byte
   ida_typeinf.append_argloc
   ida_typeinf.extract_argloc
   ida_typeinf.resolve_typedef
   ida_typeinf.is_restype_void
   ida_typeinf.is_restype_enum
   ida_typeinf.is_restype_struni
   ida_typeinf.is_restype_struct
   ida_typeinf.get_scalar_bt
   ida_typeinf.new_til
   ida_typeinf.load_til
   ida_typeinf.compact_til
   ida_typeinf.store_til
   ida_typeinf.free_til
   ida_typeinf.load_til_header
   ida_typeinf.is_code_far
   ida_typeinf.is_data_far
   ida_typeinf.verify_argloc
   ida_typeinf.optimize_argloc
   ida_typeinf.print_argloc
   ida_typeinf.for_all_arglocs
   ida_typeinf.for_all_const_arglocs
   ida_typeinf.is_user_cc
   ida_typeinf.is_vararg_cc
   ida_typeinf.is_purging_cc
   ida_typeinf.is_golang_cc
   ida_typeinf.is_custom_callcnv
   ida_typeinf.is_swift_cc
   ida_typeinf.get_stkarg_area_info
   ida_typeinf.get_custom_callcnv
   ida_typeinf.find_custom_callcnv
   ida_typeinf.get_custom_callcnvs
   ida_typeinf.get_comp
   ida_typeinf.get_compiler_name
   ida_typeinf.get_compiler_abbr
   ida_typeinf.get_compilers
   ida_typeinf.is_comp_unsure
   ida_typeinf.default_compiler
   ida_typeinf.is_gcc
   ida_typeinf.is_gcc32
   ida_typeinf.is_gcc64
   ida_typeinf.gcc_layout
   ida_typeinf.set_compiler
   ida_typeinf.set_compiler_id
   ida_typeinf.set_abi_name
   ida_typeinf.get_abi_name
   ida_typeinf.append_abi_opts
   ida_typeinf.remove_abi_opts
   ida_typeinf.set_compiler_string
   ida_typeinf.use_golang_cc
   ida_typeinf.switch_to_golang
   ida_typeinf.convert_pt_flags_to_hti
   ida_typeinf.parse_decl
   ida_typeinf.parse_decls
   ida_typeinf.print_type
   ida_typeinf.tinfo_errstr
   ida_typeinf.del_named_type
   ida_typeinf.first_named_type
   ida_typeinf.next_named_type
   ida_typeinf.copy_named_type
   ida_typeinf.decorate_name
   ida_typeinf.gen_decorate_name
   ida_typeinf.calc_c_cpp_name
   ida_typeinf.enable_numbered_types
   ida_typeinf.alloc_type_ordinals
   ida_typeinf.alloc_type_ordinal
   ida_typeinf.get_ordinal_limit
   ida_typeinf.get_ordinal_count
   ida_typeinf.del_numbered_type
   ida_typeinf.set_type_alias
   ida_typeinf.get_alias_target
   ida_typeinf.get_type_ordinal
   ida_typeinf.get_numbered_type_name
   ida_typeinf.create_numbered_type_name
   ida_typeinf.is_ordinal_name
   ida_typeinf.is_type_choosable
   ida_typeinf.set_type_choosable
   ida_typeinf.get_vftable_ea
   ida_typeinf.get_vftable_ordinal
   ida_typeinf.set_vftable_ea
   ida_typeinf.del_vftable_ea
   ida_typeinf.deref_ptr
   ida_typeinf.add_til
   ida_typeinf.del_til
   ida_typeinf.apply_named_type
   ida_typeinf.apply_tinfo
   ida_typeinf.apply_cdecl
   ida_typeinf.apply_callee_tinfo
   ida_typeinf.apply_once_tinfo_and_name
   ida_typeinf.guess_tinfo
   ida_typeinf.set_c_header_path
   ida_typeinf.get_c_header_path
   ida_typeinf.set_c_macros
   ida_typeinf.get_c_macros
   ida_typeinf.get_idati
   ida_typeinf.get_idainfo_by_type
   ida_typeinf.get_tinfo_by_flags
   ida_typeinf.copy_tinfo_t
   ida_typeinf.detach_tinfo_t
   ida_typeinf.clear_tinfo_t
   ida_typeinf.create_tinfo
   ida_typeinf.verify_tinfo
   ida_typeinf.get_tinfo_details
   ida_typeinf.get_tinfo_size
   ida_typeinf.get_tinfo_pdata
   ida_typeinf.get_tinfo_property
   ida_typeinf.get_tinfo_property4
   ida_typeinf.set_tinfo_property
   ida_typeinf.set_tinfo_property4
   ida_typeinf.serialize_tinfo
   ida_typeinf.find_tinfo_udt_member
   ida_typeinf.print_tinfo
   ida_typeinf.dstr_tinfo
   ida_typeinf.visit_subtypes
   ida_typeinf.compare_tinfo
   ida_typeinf.lexcompare_tinfo
   ida_typeinf.get_stock_tinfo
   ida_typeinf.read_tinfo_bitfield_value
   ida_typeinf.write_tinfo_bitfield_value
   ida_typeinf.get_tinfo_attr
   ida_typeinf.set_tinfo_attr
   ida_typeinf.del_tinfo_attr
   ida_typeinf.get_tinfo_attrs
   ida_typeinf.set_tinfo_attrs
   ida_typeinf.score_tinfo
   ida_typeinf.save_tinfo
   ida_typeinf.append_tinfo_covered
   ida_typeinf.calc_tinfo_gaps
   ida_typeinf.value_repr_t__from_opinfo
   ida_typeinf.value_repr_t__print_
   ida_typeinf.udt_type_data_t__find_member
   ida_typeinf.udt_type_data_t__get_best_fit_member
   ida_typeinf.get_tinfo_by_edm_name
   ida_typeinf.remove_pointer
   ida_typeinf.guess_func_cc
   ida_typeinf.dump_func_type_data
   ida_typeinf.calc_arglocs
   ida_typeinf.calc_varglocs
   ida_typeinf.stroff_as_size
   ida_typeinf.visit_stroff_udms
   ida_typeinf.is_one_bit_mask
   ida_typeinf.inf_pack_stkargs
   ida_typeinf.inf_big_arg_align
   ida_typeinf.inf_huge_arg_align
   ida_typeinf.unpack_idcobj_from_idb
   ida_typeinf.unpack_idcobj_from_bv
   ida_typeinf.pack_idcobj_to_idb
   ida_typeinf.pack_idcobj_to_bv
   ida_typeinf.apply_tinfo_to_stkarg
   ida_typeinf.gen_use_arg_tinfos
   ida_typeinf.func_has_stkframe_hole
   ida_typeinf.lower_type
   ida_typeinf.replace_ordinal_typerefs
   ida_typeinf.begin_type_updating
   ida_typeinf.end_type_updating
   ida_typeinf.get_named_type_tid
   ida_typeinf.get_tid_name
   ida_typeinf.get_tid_ordinal
   ida_typeinf.get_udm_by_fullname
   ida_typeinf.get_idainfo_by_udm
   ida_typeinf.create_enum_type
   ida_typeinf.calc_number_of_children
   ida_typeinf.get_enum_member_expr
   ida_typeinf.choose_named_type
   ida_typeinf.choose_local_tinfo
   ida_typeinf.choose_local_tinfo_and_delta
   ida_typeinf.calc_retloc
   ida_typeinf.register_custom_callcnv
   ida_typeinf.unregister_custom_callcnv
   ida_typeinf.idc_parse_decl
   ida_typeinf.calc_type_size
   ida_typeinf.apply_type
   ida_typeinf.get_arg_addrs
   ida_typeinf.unpack_object_from_idb
   ida_typeinf.unpack_object_from_bv
   ida_typeinf.pack_object_to_idb
   ida_typeinf.pack_object_to_bv
   ida_typeinf.idc_parse_types
   ida_typeinf.idc_get_type_raw
   ida_typeinf.idc_get_local_type_raw
   ida_typeinf.idc_guess_type
   ida_typeinf.idc_get_type
   ida_typeinf.idc_set_local_type
   ida_typeinf.idc_get_local_type
   ida_typeinf.idc_print_type
   ida_typeinf.idc_get_local_type_name
   ida_typeinf.get_named_type
   ida_typeinf.get_named_type64
   ida_typeinf.print_decls
   ida_typeinf.remove_tinfo_pointer
   ida_typeinf.get_numbered_type
   ida_typeinf.set_numbered_type


Module Contents
---------------

.. py:data:: DEFMASK64

   default bitmask 64bits


.. py:function:: deserialize_tinfo(tif: tinfo_t, til: til_t, ptype: type_t const **, pfields: p_list const **, pfldcmts: p_list const **, cmt: str = None) -> bool

.. py:class:: funcargvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> funcarg_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> funcarg_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: funcargvec_t) -> None


   .. py:method:: extract() -> funcarg_t *


   .. py:method:: inject(s: funcarg_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< funcarg_t >::const_iterator


   .. py:method:: end(*args) -> qvector< funcarg_t >::const_iterator


   .. py:method:: insert(it: funcarg_t, x: funcarg_t) -> qvector< funcarg_t >::iterator


   .. py:method:: erase(*args) -> qvector< funcarg_t >::iterator


   .. py:method:: find(*args) -> qvector< funcarg_t >::const_iterator


   .. py:method:: has(x: funcarg_t) -> bool


   .. py:method:: add_unique(x: funcarg_t) -> bool


   .. py:method:: append(x: funcarg_t) -> None


   .. py:method:: extend(x: funcargvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: reginfovec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> reg_info_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> reg_info_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: reginfovec_t) -> None


   .. py:method:: extract() -> reg_info_t *


   .. py:method:: inject(s: reg_info_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< reg_info_t >::const_iterator


   .. py:method:: end(*args) -> qvector< reg_info_t >::const_iterator


   .. py:method:: insert(it: reg_info_t, x: reg_info_t) -> qvector< reg_info_t >::iterator


   .. py:method:: erase(*args) -> qvector< reg_info_t >::iterator


   .. py:method:: find(*args) -> qvector< reg_info_t >::const_iterator


   .. py:method:: has(x: reg_info_t) -> bool


   .. py:method:: add_unique(x: reg_info_t) -> bool


   .. py:method:: append(x: reg_info_t) -> None


   .. py:method:: extend(x: reginfovec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: edmvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> edm_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> edm_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: edmvec_t) -> None


   .. py:method:: extract() -> edm_t *


   .. py:method:: inject(s: edm_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< edm_t >::const_iterator


   .. py:method:: end(*args) -> qvector< edm_t >::const_iterator


   .. py:method:: insert(it: edm_t, x: edm_t) -> qvector< edm_t >::iterator


   .. py:method:: erase(*args) -> qvector< edm_t >::iterator


   .. py:method:: find(*args) -> qvector< edm_t >::const_iterator


   .. py:method:: has(x: edm_t) -> bool


   .. py:method:: add_unique(x: edm_t) -> bool


   .. py:method:: append(x: edm_t) -> None


   .. py:method:: extend(x: edmvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: argpartvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> argpart_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> argpart_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: argpartvec_t) -> None


   .. py:method:: extract() -> argpart_t *


   .. py:method:: inject(s: argpart_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< argpart_t >::const_iterator


   .. py:method:: end(*args) -> qvector< argpart_t >::const_iterator


   .. py:method:: insert(it: argpart_t, x: argpart_t) -> qvector< argpart_t >::iterator


   .. py:method:: erase(*args) -> qvector< argpart_t >::iterator


   .. py:method:: find(*args) -> qvector< argpart_t >::const_iterator


   .. py:method:: has(x: argpart_t) -> bool


   .. py:method:: add_unique(x: argpart_t) -> bool


   .. py:method:: append(x: argpart_t) -> None


   .. py:method:: extend(x: argpartvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: valstrvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> valstr_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> valstr_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: valstrvec_t) -> None


   .. py:method:: extract() -> valstr_t *


   .. py:method:: inject(s: valstr_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< valstr_t >::const_iterator


   .. py:method:: end(*args) -> qvector< valstr_t >::const_iterator


   .. py:method:: insert(it: valstr_t, x: valstr_t) -> qvector< valstr_t >::iterator


   .. py:method:: erase(*args) -> qvector< valstr_t >::iterator


   .. py:method:: append(x: valstr_t) -> None


   .. py:method:: extend(x: valstrvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: regobjvec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> regobj_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> regobj_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: regobjvec_t) -> None


   .. py:method:: extract() -> regobj_t *


   .. py:method:: inject(s: regobj_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< regobj_t >::const_iterator


   .. py:method:: end(*args) -> qvector< regobj_t >::const_iterator


   .. py:method:: insert(it: regobj_t, x: regobj_t) -> qvector< regobj_t >::iterator


   .. py:method:: erase(*args) -> qvector< regobj_t >::iterator


   .. py:method:: append(x: regobj_t) -> None


   .. py:method:: extend(x: regobjvec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: type_attrs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> type_attr_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> type_attr_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: type_attrs_t) -> None


   .. py:method:: extract() -> type_attr_t *


   .. py:method:: inject(s: type_attr_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< type_attr_t >::const_iterator


   .. py:method:: end(*args) -> qvector< type_attr_t >::const_iterator


   .. py:method:: insert(it: type_attr_t, x: type_attr_t) -> qvector< type_attr_t >::iterator


   .. py:method:: erase(*args) -> qvector< type_attr_t >::iterator


   .. py:method:: append(x: type_attr_t) -> None


   .. py:method:: extend(x: type_attrs_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:class:: udtmembervec_template_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> udm_t &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> udm_t const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: udtmembervec_template_t) -> None


   .. py:method:: extract() -> udm_t *


   .. py:method:: inject(s: udm_t, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< udm_t >::const_iterator


   .. py:method:: end(*args) -> qvector< udm_t >::const_iterator


   .. py:method:: insert(it: udm_t, x: udm_t) -> qvector< udm_t >::iterator


   .. py:method:: erase(*args) -> qvector< udm_t >::iterator


   .. py:method:: find(*args) -> qvector< udm_t >::const_iterator


   .. py:method:: has(x: udm_t) -> bool


   .. py:method:: add_unique(x: udm_t) -> bool


   .. py:method:: append(x: udm_t) -> None


   .. py:method:: extend(x: udtmembervec_template_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: RESERVED_BYTE

   multifunctional purpose


.. py:function:: is_type_const(t: type_t) -> bool

   See BTM_CONST.


.. py:function:: is_type_volatile(t: type_t) -> bool

   See BTM_VOLATILE.


.. py:function:: get_base_type(t: type_t) -> type_t

   Get get basic type bits (TYPE_BASE_MASK)


.. py:function:: get_type_flags(t: type_t) -> type_t

   Get type flags (TYPE_FLAGS_MASK)


.. py:function:: get_full_type(t: type_t) -> type_t

   Get basic type bits + type flags (TYPE_FULL_MASK)


.. py:function:: is_typeid_last(t: type_t) -> bool

   Is the type_t the last byte of type declaration? (there are no additional bytes after a basic type, see _BT_LAST_BASIC) 
           


.. py:function:: is_type_partial(t: type_t) -> bool

   Identifies an unknown or void type with a known size (see Basic type: unknown & void)


.. py:function:: is_type_void(t: type_t) -> bool

   See BTF_VOID.


.. py:function:: is_type_unknown(t: type_t) -> bool

   See BT_UNKNOWN.


.. py:function:: is_type_ptr(t: type_t) -> bool

   See BT_PTR.


.. py:function:: is_type_complex(t: type_t) -> bool

   See BT_COMPLEX.


.. py:function:: is_type_func(t: type_t) -> bool

   See BT_FUNC.


.. py:function:: is_type_array(t: type_t) -> bool

   See BT_ARRAY.


.. py:function:: is_type_typedef(t: type_t) -> bool

   See BTF_TYPEDEF.


.. py:function:: is_type_sue(t: type_t) -> bool

   Is the type a struct/union/enum?


.. py:function:: is_type_struct(t: type_t) -> bool

   See BTF_STRUCT.


.. py:function:: is_type_union(t: type_t) -> bool

   See BTF_UNION.


.. py:function:: is_type_struni(t: type_t) -> bool

   Is the type a struct or union?


.. py:function:: is_type_enum(t: type_t) -> bool

   See BTF_ENUM.


.. py:function:: is_type_bitfld(t: type_t) -> bool

   See BT_BITFIELD.


.. py:function:: is_type_int(bt: type_t) -> bool

   Does the type_t specify one of the basic types in Basic type: integer?


.. py:function:: is_type_int128(t: type_t) -> bool

   Does the type specify a 128-bit value? (signed or unsigned, see Basic type: integer)


.. py:function:: is_type_int64(t: type_t) -> bool

   Does the type specify a 64-bit value? (signed or unsigned, see Basic type: integer)


.. py:function:: is_type_int32(t: type_t) -> bool

   Does the type specify a 32-bit value? (signed or unsigned, see Basic type: integer)


.. py:function:: is_type_int16(t: type_t) -> bool

   Does the type specify a 16-bit value? (signed or unsigned, see Basic type: integer)


.. py:function:: is_type_char(t: type_t) -> bool

   Does the type specify a char value? (signed or unsigned, see Basic type: integer)


.. py:function:: is_type_paf(t: type_t) -> bool

   Is the type a pointer, array, or function type?


.. py:function:: is_type_ptr_or_array(t: type_t) -> bool

   Is the type a pointer or array type?


.. py:function:: is_type_floating(t: type_t) -> bool

   Is the type a floating point type?


.. py:function:: is_type_integral(t: type_t) -> bool

   Is the type an integral type (char/short/int/long/bool)?


.. py:function:: is_type_ext_integral(t: type_t) -> bool

   Is the type an extended integral type? (integral or enum)


.. py:function:: is_type_arithmetic(t: type_t) -> bool

   Is the type an arithmetic type? (floating or integral)


.. py:function:: is_type_ext_arithmetic(t: type_t) -> bool

   Is the type an extended arithmetic type? (arithmetic or enum)


.. py:function:: is_type_uint(t: type_t) -> bool

   See BTF_UINT.


.. py:function:: is_type_uchar(t: type_t) -> bool

   See BTF_UCHAR.


.. py:function:: is_type_uint16(t: type_t) -> bool

   See BTF_UINT16.


.. py:function:: is_type_uint32(t: type_t) -> bool

   See BTF_UINT32.


.. py:function:: is_type_uint64(t: type_t) -> bool

   See BTF_UINT64.


.. py:function:: is_type_uint128(t: type_t) -> bool

   See BTF_UINT128.


.. py:function:: is_type_ldouble(t: type_t) -> bool

   See BTF_LDOUBLE.


.. py:function:: is_type_double(t: type_t) -> bool

   See BTF_DOUBLE.


.. py:function:: is_type_float(t: type_t) -> bool

   See BTF_FLOAT.


.. py:function:: is_type_tbyte(t: type_t) -> bool

   See BTF_FLOAT.


.. py:function:: is_type_bool(t: type_t) -> bool

   See BTF_BOOL.


.. py:data:: TAH_BYTE

   type attribute header byte


.. py:data:: FAH_BYTE

   function argument attribute header byte


.. py:data:: MAX_DECL_ALIGN

.. py:data:: TAH_HASATTRS

   has extended attributes


.. py:data:: TAUDT_UNALIGNED

   struct: unaligned struct


.. py:data:: TAUDT_MSSTRUCT

   struct: gcc msstruct attribute


.. py:data:: TAUDT_CPPOBJ

   struct: a c++ object, not simple pod type


.. py:data:: TAUDT_VFTABLE

   struct: is virtual function table


.. py:data:: TAUDT_FIXED

   struct: fixed field offsets, stored in serialized form; cannot be set for unions 
           


.. py:data:: TAUDT_TUPLE

   tuple: tuples are like structs but are returned differently from functions 
           


.. py:data:: TAFLD_BASECLASS

   field: do not include but inherit from the current field


.. py:data:: TAFLD_UNALIGNED

   field: unaligned field


.. py:data:: TAFLD_VIRTBASE

   field: virtual base (not supported yet)


.. py:data:: TAFLD_VFTABLE

   field: ptr to virtual function table


.. py:data:: TAFLD_METHOD

   denotes a udt member function


.. py:data:: TAFLD_GAP

   field: gap member (displayed as padding in type details)


.. py:data:: TAFLD_REGCMT

   field: the comment is regular (if not set, it is repeatable)


.. py:data:: TAFLD_FRAME_R

   frame: function return address frame slot


.. py:data:: TAFLD_FRAME_S

   frame: function saved registers frame slot


.. py:data:: TAFLD_BYTIL

   field: was the member created due to the type system


.. py:data:: TAPTR_PTR32

   ptr: __ptr32


.. py:data:: TAPTR_PTR64

   ptr: __ptr64


.. py:data:: TAPTR_RESTRICT

   ptr: __restrict


.. py:data:: TAPTR_SHIFTED

   ptr: __shifted(parent_struct, delta)


.. py:data:: TAENUM_64BIT

   enum: store 64-bit values


.. py:data:: TAENUM_UNSIGNED

   enum: unsigned


.. py:data:: TAENUM_SIGNED

   enum: signed


.. py:data:: TAENUM_OCT

   enum: octal representation, if BTE_HEX


.. py:data:: TAENUM_BIN

   enum: binary representation, if BTE_HEX only one of OCT/BIN bits can be set. they are meaningful only if BTE_HEX is used. 
           


.. py:data:: TAENUM_NUMSIGN

   enum: signed representation, if BTE_HEX


.. py:data:: TAENUM_LZERO

   enum: print numbers with leading zeroes (only for HEX/OCT/BIN)


.. py:data:: TAH_ALL

   all defined bits


.. py:function:: is_tah_byte(t: type_t) -> bool

   The TAH byte (type attribute header byte) denotes the start of type attributes. (see "tah-typeattrs" in the type bit definitions) 
           


.. py:function:: is_sdacl_byte(t: type_t) -> bool

   Identify an sdacl byte. The first sdacl byte has the following format: 11xx000x. The sdacl bytes are appended to udt fields. They indicate the start of type attributes (as the tah-bytes do). The sdacl bytes are used in the udt headers instead of the tah-byte. This is done for compatibility with old databases, they were already using sdacl bytes in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in the type bit definitions) 
           


.. py:class:: type_attr_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: key
      :type:  str

      one symbol keys are reserved to be used by the kernel the ones starting with an underscore are reserved too 
              



   .. py:attribute:: value
      :type:  bytevec_t

      attribute bytes



.. py:data:: cvar

.. py:data:: TYPE_BASE_MASK

   the low 4 bits define the basic type


.. py:data:: TYPE_FLAGS_MASK

   type flags - they have different meaning depending on the basic type 
           


.. py:data:: TYPE_MODIF_MASK

   modifiers.
   * for BT_ARRAY see Derived type: array
   * BT_VOID can have them ONLY in 'void *' 


           


.. py:data:: TYPE_FULL_MASK

   basic type with type flags


.. py:data:: BT_UNK

   unknown


.. py:data:: BT_VOID

   void


.. py:data:: BTMT_SIZE0

   BT_VOID - normal void; BT_UNK - don't use


.. py:data:: BTMT_SIZE12

   size = 1 byte if BT_VOID; 2 if BT_UNK


.. py:data:: BTMT_SIZE48

   size = 4 bytes if BT_VOID; 8 if BT_UNK


.. py:data:: BTMT_SIZE128

   size = 16 bytes if BT_VOID; unknown if BT_UNK (IN struct alignment - see below) 
           


.. py:data:: BT_INT8

   __int8


.. py:data:: BT_INT16

   __int16


.. py:data:: BT_INT32

   __int32


.. py:data:: BT_INT64

   __int64


.. py:data:: BT_INT128

   __int128 (for alpha & future use)


.. py:data:: BT_INT

   natural int. (size provided by idp module)


.. py:data:: BTMT_UNKSIGN

   unknown signedness


.. py:data:: BTMT_SIGNED

   signed


.. py:data:: BTMT_USIGNED

   unsigned


.. py:data:: BTMT_UNSIGNED

.. py:data:: BTMT_CHAR

   specify char or segment register
   * BT_INT8 - char
   * BT_INT - segment register
   * other BT_INT... - don't use 


           


.. py:data:: BT_BOOL

   bool


.. py:data:: BTMT_DEFBOOL

   size is model specific or unknown(?)


.. py:data:: BTMT_BOOL1

   size 1byte


.. py:data:: BTMT_BOOL2

   size 2bytes - !inf_is_64bit()


.. py:data:: BTMT_BOOL8

   size 8bytes - inf_is_64bit()


.. py:data:: BTMT_BOOL4

   size 4bytes


.. py:data:: BT_FLOAT

   float


.. py:data:: BTMT_FLOAT

   float (4 bytes)


.. py:data:: BTMT_DOUBLE

   double (8 bytes)


.. py:data:: BTMT_LNGDBL

   long double (compiler specific)


.. py:data:: BTMT_SPECFLT

   float (variable size). if processor_t::use_tbyte() then use processor_t::tbyte_size, otherwise 2 bytes 
           


.. py:data:: BT_PTR

   pointer. has the following format: [db sizeof(ptr)]; [tah-typeattrs]; type_t... 
           


.. py:data:: BTMT_DEFPTR

   default for model


.. py:data:: BTMT_NEAR

   near


.. py:data:: BTMT_FAR

   far


.. py:data:: BTMT_CLOSURE

   closure.
   * if ptr to BT_FUNC - __closure. in this case next byte MUST be RESERVED_BYTE, and after it BT_FUNC
   * else the next byte contains sizeof(ptr) allowed values are 1 - ph.max_ptr_size
   * if value is bigger than ph.max_ptr_size, based_ptr_name_and_size() is called to find out the typeinfo 


           


.. py:data:: BT_ARRAY

   array


.. py:data:: BTMT_NONBASED

   set
     array base==0
     format: dt num_elem; [tah-typeattrs]; type_t...
     if num_elem==0 then the array size is unknown

     format: da num_elem, base; [tah-typeattrs]; type_t... 


      


.. py:data:: BTMT_ARRESERV

   reserved bit


.. py:data:: BT_FUNC

   function. format: 
   optional: CM_CC_SPOILED | num_of_spoiled_regs
             if num_of_spoiled_reg == BFA_FUNC_MARKER:
               ::bfa_byte
               if (bfa_byte & BFA_FUNC_EXT_FORMAT) != 0
                ::fti_bits (only low bits: FTI_SPOILED,...,FTI_VIRTUAL)
                num_of_spoiled_reg times: spoiled reg info (see extract_spoiledreg)
               else
                 bfa_byte is function attribute byte (see Function attribute byte...)
             else:
               num_of_spoiled_reg times: spoiled reg info (see extract_spoiledreg)
   cm_t ... calling convention and memory model
   [tah-typeattrs];
   type_t ... return type;
   [serialized argloc_t of returned value (if CM_CC_SPECIAL{PE} && !return void);
   if !CM_CC_VOIDARG:
     dt N (N=number of parameters)
     if ( N == 0 )
     if CM_CC_ELLIPSIS or CM_CC_SPECIALE
         func(...)
       else
         parameters are unknown
     else
       N records:
         type_t ... (i.e. type of each parameter)
         [serialized argloc_t (if CM_CC_SPECIAL{PE})] (i.e. place of each parameter)
         [FAH_BYTE + de( funcarg_t::flags )]  
     


.. py:data:: BTMT_DEFCALL

   call method - default for model or unknown


.. py:data:: BTMT_NEARCALL

   function returns by retn


.. py:data:: BTMT_FARCALL

   function returns by retf


.. py:data:: BTMT_INTCALL

   function returns by iret in this case cc MUST be 'unknown' 
           


.. py:data:: BT_COMPLEX

   struct/union/enum/typedef. format: 
   [dt N (N=field count) if !BTMT_TYPEDEF]
   if N == 0:
     p_string name (unnamed types have names "anon_...")
     [sdacl-typeattrs];
   else, for struct & union:
     if N == 0x7FFE   // Support for high (i.e., > 4095) members count
       N = deserialize_de()
     ALPOW = N & 0x7
     MCNT = N >> 3
     if MCNT == 0
       empty struct
     if ALPOW == 0
       ALIGN = get_default_align()
     else
       ALIGN = (1 << (ALPOW - 1))
     [sdacl-typeattrs];
   else, for enums:
     if N == 0x7FFE   // Support for high enum entries count.
       N = deserialize_de()
     [tah-typeattrs];  
    


.. py:data:: BTMT_STRUCT

   struct: MCNT records: type_t; [sdacl-typeattrs]; 
           


.. py:data:: BTMT_UNION

   union: MCNT records: type_t... 
           


.. py:data:: BTMT_ENUM

   enum: next byte bte_t (see below) N records: de delta(s) OR blocks (see below) 
           


.. py:data:: BTMT_TYPEDEF

   named reference always p_string name 
           


.. py:data:: BT_BITFIELD

   bitfield (only in struct) ['bitmasked' enum see below] next byte is dt ((size in bits << 1) | (unsigned ? 1 : 0)) 
           


.. py:data:: BTMT_BFLDI8

   __int8


.. py:data:: BTMT_BFLDI16

   __int16


.. py:data:: BTMT_BFLDI32

   __int32


.. py:data:: BTMT_BFLDI64

   __int64


.. py:data:: BT_RESERVED

   RESERVED.


.. py:data:: BTM_CONST

   const


.. py:data:: BTM_VOLATILE

   volatile


.. py:data:: BTE_SIZE_MASK

   storage size.
   * if == 0 then inf_get_cc_size_e()
   * else 1 << (n -1) = 1,2,4,8
   * n == 5,6,7 are reserved 


           


.. py:data:: BTE_RESERVED

   must be 0, in order to distinguish from a tah-byte 
           


.. py:data:: BTE_BITMASK

   'subarrays'. In this case ANY record has the following format:
   * 'de' mask (has name)
   * 'dt' cnt
   * cnt records of 'de' values (cnt CAN be 0)



.. py:data:: BTE_OUT_MASK

   output style mask


.. py:data:: BTE_HEX

   hex


.. py:data:: BTE_CHAR

   char or hex


.. py:data:: BTE_SDEC

   signed decimal


.. py:data:: BTE_UDEC

   unsigned decimal


.. py:data:: BTE_ALWAYS

   this bit MUST be present


.. py:data:: BT_SEGREG

   segment register


.. py:data:: BT_UNK_BYTE

   1 byte


.. py:data:: BT_UNK_WORD

   2 bytes


.. py:data:: BT_UNK_DWORD

   4 bytes


.. py:data:: BT_UNK_QWORD

   8 bytes


.. py:data:: BT_UNK_OWORD

   16 bytes


.. py:data:: BT_UNKNOWN

   unknown size - for parameters


.. py:data:: BTF_BYTE

   byte


.. py:data:: BTF_UNK

   unknown


.. py:data:: BTF_VOID

   void


.. py:data:: BTF_INT8

   signed byte


.. py:data:: BTF_CHAR

   signed char


.. py:data:: BTF_UCHAR

   unsigned char


.. py:data:: BTF_UINT8

   unsigned byte


.. py:data:: BTF_INT16

   signed short


.. py:data:: BTF_UINT16

   unsigned short


.. py:data:: BTF_INT32

   signed int


.. py:data:: BTF_UINT32

   unsigned int


.. py:data:: BTF_INT64

   signed long


.. py:data:: BTF_UINT64

   unsigned long


.. py:data:: BTF_INT128

   signed 128-bit value


.. py:data:: BTF_UINT128

   unsigned 128-bit value


.. py:data:: BTF_INT

   int, unknown signedness


.. py:data:: BTF_UINT

   unsigned int


.. py:data:: BTF_SINT

   singed int


.. py:data:: BTF_BOOL

   boolean


.. py:data:: BTF_FLOAT

   float


.. py:data:: BTF_DOUBLE

   double


.. py:data:: BTF_LDOUBLE

   long double


.. py:data:: BTF_TBYTE

   see BTMT_SPECFLT


.. py:data:: BTF_STRUCT

   struct


.. py:data:: BTF_UNION

   union


.. py:data:: BTF_ENUM

   enum


.. py:data:: BTF_TYPEDEF

   typedef


.. py:data:: TA_ORG_TYPEDEF

   the original typedef name (simple string)


.. py:data:: TA_ORG_ARRDIM

   the original array dimension (pack_dd)


.. py:data:: TA_FORMAT

   info about the 'format' argument. 3 times pack_dd: format_functype_t, argument number of 'format', argument number of '...' 
           


.. py:data:: TA_VALUE_REPR

   serialized value_repr_t (used for scalars and arrays)


.. py:function:: append_argloc(out: qtype *, vloc: argloc_t) -> bool

   Serialize argument location 
           


.. py:function:: extract_argloc(vloc: argloc_t, ptype: type_t const **, forbid_stkoff: bool) -> bool

   Deserialize an argument location. Argument FORBID_STKOFF checks location type. It can be used, for example, to check the return location of a function that cannot return a value in the stack 
           


.. py:function:: resolve_typedef(til: til_t, type: type_t const *) -> type_t const *

.. py:function:: is_restype_void(til: til_t, type: type_t const *) -> bool

.. py:function:: is_restype_enum(til: til_t, type: type_t const *) -> bool

.. py:function:: is_restype_struni(til: til_t, type: type_t const *) -> bool

.. py:function:: is_restype_struct(til: til_t, type: type_t const *) -> bool

.. py:function:: get_scalar_bt(size: int) -> type_t

.. py:class:: til_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  char *

      short file name (without path and extension)



   .. py:attribute:: desc
      :type:  char *

      human readable til description



   .. py:attribute:: nbases
      :type:  int

      number of base tils



   .. py:attribute:: flags
      :type:  int

      Type info library property bits 
              



   .. py:method:: is_dirty() -> bool

      Has the til been modified? (TIL_MOD)



   .. py:method:: set_dirty() -> None

      Mark the til as modified (TIL_MOD)



   .. py:method:: find_base(n: str) -> til_t *

      Find the base til with the provided name 
              
      :param n: the base til name
      :returns: the found til_t, or nullptr



   .. py:attribute:: cc
      :type:  compiler_info_t

      information about the target compiler



   .. py:attribute:: nrefs
      :type:  int

      number of references to the til



   .. py:attribute:: nstreams
      :type:  int

      number of extra streams



   .. py:attribute:: streams
      :type:  til_stream_t **

      symbol stream storage



   .. py:method:: base(n: int) -> til_t *


   .. py:method:: import_type(src)

      Import a type (and all its dependencies) into this type info library.

      :param src: The type to import
      :returns: the imported copy, or None



   .. py:method:: named_types()

      Returns a generator over the named types contained in this
      type library.

      Every iteration returns a fresh new tinfo_t object

      :returns: a tinfo_t-producing generator



   .. py:method:: numbered_types()

      Returns a generator over the numbered types contained in this
      type library.

      Every iteration returns a fresh new tinfo_t object

      :returns: a tinfo_t-producing generator



   .. py:method:: get_named_type(name)

      Retrieves a tinfo_t representing the named type in this type library.

      :param name: a type name
      :returns: a new tinfo_t object, or None if not found



   .. py:method:: get_numbered_type(ordinal)

      Retrieves a tinfo_t representing the numbered type in this type library.

      :param ordinal: a type ordinal
      :returns: a new tinfo_t object, or None if not found



   .. py:method:: get_type_names()


   .. py:attribute:: type_names


.. py:data:: no_sign

   no sign, or unknown


.. py:data:: type_signed

   signed type


.. py:data:: type_unsigned

   unsigned type


.. py:data:: TIL_ZIP

   pack buckets using zip


.. py:data:: TIL_MAC

   til has macro table


.. py:data:: TIL_ESI

   extended sizeof info (short, long, longlong)


.. py:data:: TIL_UNI

   universal til for any compiler


.. py:data:: TIL_ORD

   type ordinal numbers are present


.. py:data:: TIL_ALI

   type aliases are present (this bit is used only on the disk)


.. py:data:: TIL_MOD

   til has been modified, should be saved


.. py:data:: TIL_STM

   til has extra streams


.. py:data:: TIL_SLD

   sizeof(long double)


.. py:data:: TIL_ECC

   extended callcnv_t


.. py:function:: new_til(name: str, desc: str) -> til_t *

   Initialize a til.


.. py:data:: TIL_ADD_FAILED

   see errbuf


.. py:data:: TIL_ADD_OK

   some tils were added


.. py:data:: TIL_ADD_ALREADY

   the base til was already added


.. py:function:: load_til(name: str, tildir: str = None) -> str

   Load til from a file without adding it to the database list (see also add_til). Failure to load base tils are reported into 'errbuf'. They do not prevent loading of the main til. 
           
   :param name: filename of the til. If it's an absolute path, tildir is ignored.
   * NB: the file extension is forced to .til
   :param tildir: directory where to load the til from. nullptr means default til subdirectories.
   :returns: pointer to resulting til, nullptr if failed and error message is in errbuf


.. py:function:: compact_til(ti: til_t) -> bool

   Collect garbage in til. Must be called before storing the til. 
           
   :returns: true if any memory was freed


.. py:function:: store_til(ti: til_t, tildir: str, name: str) -> bool

   Store til to a file. If the til contains garbage, it will be collected before storing the til. Your plugin should call compact_til() before calling store_til(). 
           
   :param ti: type library to store
   :param tildir: directory where to store the til. nullptr means current directory.
   :param name: filename of the til. If it's an absolute path, tildir is ignored.
   * NB: the file extension is forced to .til
   :returns: success


.. py:function:: free_til(ti: til_t) -> None

   Free memory allocated by til.


.. py:function:: load_til_header(tildir: str, name: str) -> str

   Get human-readable til description.


.. py:function:: is_code_far(cm: cm_t) -> bool

   Does the given model specify far code?.


.. py:function:: is_data_far(cm: cm_t) -> bool

   Does the given model specify far data?.


.. py:class:: rrel_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: off
      :type:  int

      displacement from the address pointed by the register



   .. py:attribute:: reg
      :type:  int

      register index (into ph.reg_names)



.. py:data:: CM_MASK

.. py:data:: CM_UNKNOWN

   unknown


.. py:data:: CM_N8_F16

   if sizeof(int)<=2: near 1 byte, far 2 bytes


.. py:data:: CM_N64

   if sizeof(int)>2: near 8 bytes, far 8 bytes


.. py:data:: CM_N16_F32

   near 2 bytes, far 4 bytes


.. py:data:: CM_N32_F48

   near 4 bytes, far 6 bytes


.. py:data:: CM_M_MASK

.. py:data:: CM_M_NN

   small: code=near, data=near (or unknown if CM_UNKNOWN)


.. py:data:: CM_M_FF

   large: code=far, data=far


.. py:data:: CM_M_NF

   compact: code=near, data=far


.. py:data:: CM_M_FN

   medium: code=far, data=near


.. py:data:: CM_CC_MASK

.. py:data:: CM_CC_INVALID

   this value is invalid


.. py:data:: CM_CC_UNKNOWN

   unknown calling convention


.. py:data:: CM_CC_VOIDARG

   function without arguments if has other cc and argnum == 0, represent as f() - unknown list 
           


.. py:data:: CM_CC_CDECL

   stack


.. py:data:: CM_CC_ELLIPSIS

   cdecl + ellipsis


.. py:data:: CM_CC_STDCALL

   stack, purged


.. py:data:: CM_CC_PASCAL

   stack, purged, reverse order of args


.. py:data:: CM_CC_FASTCALL

   stack, purged (x86), first args are in regs (compiler-dependent)


.. py:data:: CM_CC_THISCALL

   stack, purged (x86), first arg is in reg (compiler-dependent)


.. py:data:: CM_CC_SWIFT

   (Swift) arguments and return values in registers (compiler-dependent)


.. py:data:: CM_CC_SPOILED

   This is NOT a cc! Mark of __spoil record the low nibble is count and after n {spoilreg_t} present real cm_t byte. if n == BFA_FUNC_MARKER, the next byte is the function attribute byte. 
           


.. py:data:: CM_CC_GOLANG

   (Go) arguments and return value reg/stack depending on version


.. py:data:: CM_CC_RESERVE3

   reserved; used for internal needs


.. py:data:: CM_CC_SPECIALE

   CM_CC_SPECIAL with ellipsis


.. py:data:: CM_CC_SPECIALP

   Equal to CM_CC_SPECIAL, but with purged stack.


.. py:data:: CM_CC_SPECIAL

   usercall: locations of all arguments and the return value are explicitly specified 
           


.. py:data:: CM_CC_LAST_USERCALL

.. py:data:: CM_CC_GOSTK

   (Go) arguments and return value in stack


.. py:data:: CM_CC_FIRST_PLAIN_CUSTOM

.. py:data:: BFA_NORET

   __noreturn


.. py:data:: BFA_PURE

   __pure


.. py:data:: BFA_HIGH

   high level prototype (with possibly hidden args)


.. py:data:: BFA_STATIC

   static


.. py:data:: BFA_VIRTUAL

   virtual


.. py:data:: BFA_FUNC_MARKER

   This is NOT a cc! (used internally as a marker)


.. py:data:: BFA_FUNC_EXT_FORMAT

   This is NOT a real attribute (used internally as marker for extended format)


.. py:data:: ALOC_NONE

   none


.. py:data:: ALOC_STACK

   stack offset


.. py:data:: ALOC_DIST

   distributed (scattered)


.. py:data:: ALOC_REG1

   one register (and offset within it)


.. py:data:: ALOC_REG2

   register pair


.. py:data:: ALOC_RREL

   register relative


.. py:data:: ALOC_STATIC

   global address


.. py:data:: ALOC_CUSTOM

   custom argloc (7 or higher)


.. py:class:: argloc_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: swap(r: argloc_t) -> None

      Assign this == r and r == this.



   .. py:method:: atype() -> argloc_type_t

      Get type (Argument location types)



   .. py:method:: is_reg1() -> bool

      See ALOC_REG1.



   .. py:method:: is_reg2() -> bool

      See ALOC_REG2.



   .. py:method:: is_reg() -> bool

      is_reg1() || is_reg2()



   .. py:method:: is_rrel() -> bool

      See ALOC_RREL.



   .. py:method:: is_ea() -> bool

      See ALOC_STATIC.



   .. py:method:: is_stkoff() -> bool

      See ALOC_STACK.



   .. py:method:: is_scattered() -> bool

      See ALOC_DIST.



   .. py:method:: has_reg() -> bool

      TRUE if argloc has a register part.



   .. py:method:: has_stkoff() -> bool

      TRUE if argloc has a stack part.



   .. py:method:: is_mixed_scattered() -> bool

      mixed scattered: consists of register and stack parts



   .. py:method:: in_stack() -> bool

      TRUE if argloc is in stack entirely.



   .. py:method:: is_fragmented() -> bool

      is_scattered() || is_reg2()



   .. py:method:: is_custom() -> bool

      See ALOC_CUSTOM.



   .. py:method:: is_badloc() -> bool

      See ALOC_NONE.



   .. py:method:: reg1() -> int

      Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
              



   .. py:method:: regoff() -> int

      Get offset from the beginning of the register in bytes. Use when atype() == ALOC_REG1 
              



   .. py:method:: reg2() -> int

      Get info for the second register. Use when atype() == ALOC_REG2 
              



   .. py:method:: get_reginfo() -> int

      Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
              



   .. py:method:: stkoff() -> int

      Get the stack offset. Use if atype() == ALOC_STACK 
              



   .. py:method:: get_ea() -> ida_idaapi.ea_t

      Get the global address. Use when atype() == ALOC_STATIC 
              



   .. py:method:: scattered() -> scattered_aloc_t &

      Get scattered argument info. Use when atype() == ALOC_DIST 
              



   .. py:method:: get_rrel() -> rrel_t &

      Get register-relative info. Use when atype() == ALOC_RREL 
              



   .. py:method:: get_custom() -> void *

      Get custom argloc info. Use if atype() == ALOC_CUSTOM 
              



   .. py:method:: get_biggest() -> argloc_t::biggest_t

      Get largest element in internal union.



   .. py:method:: set_reg1(reg: int, off: int = 0) -> None

      Set register location.



   .. py:method:: set_reg2(_reg1: int, _reg2: int) -> None

      Set secondary register location.



   .. py:method:: set_stkoff(off: int) -> None

      Set stack offset location.



   .. py:method:: set_ea(_ea: ida_idaapi.ea_t) -> None

      Set static ea location.



   .. py:method:: consume_rrel(p: rrel_t) -> None

      Set register-relative location - can't be nullptr.



   .. py:method:: set_badloc() -> None

      Set to invalid location.



   .. py:method:: calc_offset() -> int

      Calculate offset that can be used to compare 2 similar arglocs.



   .. py:method:: advance(delta: int) -> bool

      Move the location to point 'delta' bytes further.



   .. py:method:: align_reg_high(size: size_t, _slotsize: size_t) -> None

      Set register offset to align it to the upper part of _SLOTSIZE.



   .. py:method:: align_stkoff_high(size: size_t, _slotsize: size_t) -> None

      Set stack offset to align to the upper part of _SLOTSIZE.



   .. py:method:: compare(r: argloc_t) -> int


   .. py:method:: consume_scattered(p: scattered_aloc_t) -> None

      Set distributed argument location.



.. py:class:: argpart_t(*args)

   Bases: :py:obj:`argloc_t`


   .. py:attribute:: thisown


   .. py:attribute:: off
      :type:  ushort

      offset from the beginning of the argument



   .. py:attribute:: size
      :type:  ushort

      the number of bytes



   .. py:method:: bad_offset() -> bool

      Does this argpart have a valid offset?



   .. py:method:: bad_size() -> bool

      Does this argpart have a valid size?



   .. py:method:: swap(r: argpart_t) -> None

      Assign this = r and r = this.



.. py:class:: scattered_aloc_t

   Bases: :py:obj:`argpartvec_t`


   .. py:attribute:: thisown


.. py:function:: verify_argloc(vloc: argloc_t, size: int, gaps: rangeset_t) -> int

   Verify argloc_t. 
           
   :param vloc: argloc to verify
   :param size: total size of the variable
   :param gaps: if not nullptr, specifies gaps in structure definition. these gaps should not map to any argloc, but everything else must be covered
   :returns: 0 if ok, otherwise an interr code.


.. py:function:: optimize_argloc(vloc: argloc_t, size: int, gaps: rangeset_t) -> bool

   Verify and optimize scattered argloc into simple form. All new arglocs must be processed by this function. 
           
   :returns: true: success
   :returns: false: the input argloc was illegal


.. py:function:: print_argloc(vloc: argloc_t, size: int = 0, vflags: int = 0) -> size_t

   Convert an argloc to human readable form.


.. py:data:: PRALOC_VERIFY

   interr if illegal argloc


.. py:data:: PRALOC_STKOFF

   print stack offsets


.. py:class:: aloc_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit_location(v: argloc_t, off: int, size: int) -> int


.. py:function:: for_all_arglocs(vv: aloc_visitor_t, vloc: argloc_t, size: int, off: int = 0) -> int

   Compress larger argloc types and initiate the aloc visitor.


.. py:class:: const_aloc_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit_location(v: argloc_t, off: int, size: int) -> int


.. py:function:: for_all_const_arglocs(vv: const_aloc_visitor_t, vloc: argloc_t, size: int, off: int = 0) -> int

   See for_all_arglocs()


.. py:function:: is_user_cc(cc: callcnv_t) -> bool

   Does the calling convention specify argument locations explicitly?


.. py:function:: is_vararg_cc(cc: callcnv_t) -> bool

   Does the calling convention use ellipsis?


.. py:function:: is_purging_cc(cc: callcnv_t) -> bool

   Does the calling convention clean the stack arguments upon return?. 
           


.. py:function:: is_golang_cc(cc: callcnv_t) -> bool

   GO language calling convention (return value in stack)?


.. py:function:: is_custom_callcnv(cc: callcnv_t) -> bool

   Is custom calling convention?


.. py:function:: is_swift_cc(cc: callcnv_t) -> bool

   Swift calling convention (arguments and return values in registers)?


.. py:function:: get_stkarg_area_info(out: stkarg_area_info_t, cc: callcnv_t) -> bool

   Some calling conventions foresee special areas on the stack for call arguments. This structure lists their sizes. 
           


.. py:class:: stkarg_area_info_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  size_t


   .. py:attribute:: stkarg_offset
      :type:  int

      Offset from the SP to the first stack argument (can include linkage area) examples: pc: 0, hppa: -0x34, ppc aix: 0x18 
              



   .. py:attribute:: shadow_size
      :type:  int

      Size of the shadow area. explanations at: [https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly](https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly) examples: x64 Visual Studio C++: 0x20, x64 gcc: 0, ppc aix: 0x20 
              



   .. py:attribute:: linkage_area
      :type:  int

      Size of the linkage area. explanations at: [https://www.ibm.com/docs/en/xl-fortran-aix/16.1.0?topic=conventions-linkage-area](https://www.ibm.com/docs/en/xl-fortran-aix/16.1.0?topic=conventions-linkage-area) examples: pc: 0, hppa: 0, ppc aix: 0x18 (equal to stkarg_offset) 
              



.. py:data:: C_PC_TINY

.. py:data:: C_PC_SMALL

.. py:data:: C_PC_COMPACT

.. py:data:: C_PC_MEDIUM

.. py:data:: C_PC_LARGE

.. py:data:: C_PC_HUGE

.. py:data:: C_PC_FLAT

.. py:class:: custom_callcnv_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  uint64


   .. py:attribute:: name
      :type:  str

      the name is used as a keyword in the function prototype



   .. py:attribute:: abibits
      :type:  int

      abibits to be used for the calling convention



   .. py:method:: is_vararg() -> bool


   .. py:method:: is_purging() -> bool


   .. py:method:: is_usercall() -> bool


   .. py:method:: validate_func(fti: func_type_data_t, reterr: str) -> bool

      Validate a function prototype. This function is used during parsing or deserializing a function prototype to verify semantic limitations of the prototype (for example, returning arrays is forbidden in C) 
              
      :param fti: function prototype
      :param reterr: buffer for error message



   .. py:method:: calc_retloc(fti: func_type_data_t) -> bool

      Calculate the location of the return value. This function must fill fti->retloc. 
              
      :param fti: function prototype
      :returns: success



   .. py:method:: calc_arglocs(fti: func_type_data_t) -> bool

      Calculate the argument locations. This function must fill all fti->at(i).argloc instances. It may be called for variadic functions too, in calc_varglocs fails. 
              
      :param fti: function prototype
      :returns: success



   .. py:method:: find_varargs(fti: func_type_data_t, call_ea: ida_idaapi.ea_t, blk: mblock_t *) -> ssize_t

      Discover variadic arguments. This function is called only for variadic functions. It is currently used by the decompiler. 
              
      :param fti: function prototype. find_varargs() should append the discovered variadic arguments to it.
      :param call_ea: address of the call instruction
      :param blk: microcode block with the call instruction
      :returns: >0 - total number of arguments after the call <0 - failure ==0 - means to use the standard algorithm to discover variadic args



   .. py:method:: calc_varglocs(fti: func_type_data_t, regs: regobjs_t, stkargs: relobj_t, nfixed: int) -> bool

      Calculate the argument locations for a variadic function. This function must fill all fti->at(i).argloc instances and provide more detailed info about registers and stkargs. 
              
      :param fti: function prototype
      :param regs: buffer for hidden register arguments, may be nullptr
      :param stkargs: buffer for hidden stack arguments, may be nullptr
      :param nfixed: number of fixed arguments
      :returns: success



   .. py:method:: get_cc_regs(out: callregs_t) -> bool

      Retrieve generic information about call registers.



   .. py:method:: get_stkarg_area_info(out: stkarg_area_info_t) -> bool

      Retrieve generic information about stack arguments.



   .. py:method:: calc_purged_bytes(*args) -> int

      Calculate the number of purged bytes 
              
      :param fti: function prototype
      :param call_ea: address of the call instruction (not used yet)



   .. py:method:: decorate_name(name: str, should_decorate: bool, cc: callcnv_t, type: tinfo_t) -> bool

      Function to be overloaded for custom calling conventions.

      Decorate a function name. Some compilers decorate names depending on the calling convention. This function provides the means to handle it for custom callcnvs. Please note that this is about name decoration (C), not name mangling (C++). 
              



   .. py:method:: lower_func_type(fti: func_type_data_t) -> int

      Lower a function type. See lower_type() for more explanations. 
              
      :param fti: function prototype
      :returns: <0-failure, >=0-ok, 2-made substantial changes



.. py:data:: CCI_VARARG

   is variadic?


.. py:data:: CCI_PURGE

   purges arguments?


.. py:data:: CCI_USER

   is usercall? not tested


.. py:function:: get_custom_callcnv(callcnv: callcnv_t) -> custom_callcnv_t const *

   Retrieve custom calling convention details.


.. py:function:: find_custom_callcnv(name: str) -> callcnv_t

   Find a calling convention by its name 
           
   :returns: CM_CC_INVALID is not found


.. py:function:: get_custom_callcnvs(names: qstrvec_t *, codes: callcnvs_t *) -> size_t

   Get all custom calling conventions 
           
   :param names: output buffer for the convention names
   :param codes: output buffer for the convention codes The two output buffers correspond to each other.
   :returns: number of the calling conventions added to the output buffers


.. py:data:: ARGREGS_POLICY_UNDEFINED

.. py:data:: ARGREGS_GP_ONLY

   GP registers used for all arguments.


.. py:data:: ARGREGS_INDEPENDENT

   FP/GP registers used separately (like gcc64)


.. py:data:: ARGREGS_BY_SLOTS

   fixed FP/GP register per each slot (like vc64)


.. py:data:: ARGREGS_FP_MASKS_GP

   FP register also consumes one or more GP regs but not vice versa (aix ppc ABI)


.. py:data:: ARGREGS_MIPS_O32

   MIPS ABI o32.


.. py:data:: ARGREGS_RISCV

   Risc-V API FP arguments are passed in GP registers if FP registers are exhausted and GP ones are not. Wide FP arguments are passed in GP registers. Variadic FP arguments are passed in GP registers. 
             


.. py:class:: callregs_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: policy
      :type:  argreg_policy_t

      argument policy



   .. py:attribute:: nregs
      :type:  int

      max number of registers that can be used in a call



   .. py:attribute:: gpregs
      :type:  intvec_t

      array of gp registers (general purpose)



   .. py:attribute:: fpregs
      :type:  intvec_t

      array of fp registers (floating point)



   .. py:method:: swap(r: callregs_t) -> None

      swap two instances



   .. py:method:: init_regs(cc: callcnv_t) -> bool

      Init policy & registers for given CC.



   .. py:method:: by_slots() -> bool


   .. py:method:: set(_policy: argreg_policy_t, gprs: int const *, fprs: int const *) -> None

      Init policy & registers (arrays are -1-terminated)



   .. py:attribute:: GPREGS


   .. py:attribute:: FPREGS


   .. py:method:: append_registers(kind: callregs_t::reg_kind_t, first_reg: int, last_reg: int) -> None


   .. py:method:: set_registers(kind: callregs_t::reg_kind_t, first_reg: int, last_reg: int) -> None


   .. py:method:: reset() -> None

      Set policy and registers to invalid values.



   .. py:method:: regcount(cc: callcnv_t) -> int
      :staticmethod:


      Get max number of registers may be used in a function call.



   .. py:method:: reginds(gp_ind: int *, fp_ind: int *, r: int) -> bool

      Get register indexes within GP/FP arrays. (-1 -> is not present in the corresponding array) 
              



.. py:function:: get_comp(comp: comp_t) -> comp_t

   Get compiler bits.


.. py:function:: get_compiler_name(id: comp_t) -> str

   Get full compiler name.


.. py:function:: get_compiler_abbr(id: comp_t) -> str

   Get abbreviated compiler name.


.. py:function:: get_compilers(ids: compvec_t *, names: qstrvec_t *, abbrs: qstrvec_t *) -> None

   Get names of all built-in compilers.


.. py:function:: is_comp_unsure(comp: comp_t) -> comp_t

   See COMP_UNSURE.


.. py:function:: default_compiler() -> comp_t

   Get compiler specified by inf.cc.


.. py:function:: is_gcc() -> bool

   Is the target compiler COMP_GNU?


.. py:function:: is_gcc32() -> bool

   Is the target compiler 32 bit gcc?


.. py:function:: is_gcc64() -> bool

   Is the target compiler 64 bit gcc?


.. py:function:: gcc_layout() -> bool

   Should use the struct/union layout as done by gcc?


.. py:function:: set_compiler(cc: compiler_info_t, flags: int, abiname: str = None) -> bool

   Change current compiler. 
           
   :param cc: compiler to switch to
   :param flags: Set compiler flags
   :param abiname: ABI name
   :returns: success


.. py:data:: SETCOMP_OVERRIDE

   may override old compiler info


.. py:data:: SETCOMP_ONLY_ID

   cc has only 'id' field; the rest will be set to defaults corresponding to the program bitness 
           


.. py:data:: SETCOMP_ONLY_ABI

   ignore cc field complete, use only abiname


.. py:data:: SETCOMP_BY_USER

   invoked by user, cannot be replaced by module/loader


.. py:function:: set_compiler_id(id: comp_t, abiname: str = None) -> bool

   Set the compiler id (see Compiler IDs)


.. py:function:: set_abi_name(abiname: str, user_level: bool = False) -> bool

   Set abi name (see Compiler IDs)


.. py:function:: get_abi_name() -> str

   Get ABI name. 
           
   :returns: length of the name (>=0)


.. py:function:: append_abi_opts(abi_opts: str, user_level: bool = False) -> bool

   Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-... or -opt1-opt2-... 
           
   :param abi_opts: - ABI options to add/remove in form opt1-opt2-...
   :param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
   :returns: success


.. py:function:: remove_abi_opts(abi_opts: str, user_level: bool = False) -> bool

.. py:function:: set_compiler_string(compstr: str, user_level: bool) -> bool

   :param compstr: - compiler description in form <abbr>:<abiname>
   :param user_level: - initiated by user if TRUE
   :returns: success


.. py:function:: use_golang_cc() -> bool

   is GOLANG calling convention used by default?


.. py:function:: switch_to_golang() -> None

   switch to GOLANG calling convention (to be used as default CC)


.. py:data:: MAX_FUNC_ARGS

   max number of function arguments


.. py:data:: ABS_UNK

.. py:data:: ABS_NO

.. py:data:: ABS_YES

.. py:data:: SC_UNK

   unknown


.. py:data:: SC_TYPE

   typedef


.. py:data:: SC_EXT

   extern


.. py:data:: SC_STAT

   static


.. py:data:: SC_REG

   register


.. py:data:: SC_AUTO

   auto


.. py:data:: SC_FRIEND

   friend


.. py:data:: SC_VIRT

   virtual


.. py:data:: HTI_CPP

   C++ mode (not implemented)


.. py:data:: HTI_INT

   debug: print internal representation of types


.. py:data:: HTI_EXT

   debug: print external representation of types


.. py:data:: HTI_LEX

   debug: print tokens


.. py:data:: HTI_UNP

   debug: check the result by unpacking it


.. py:data:: HTI_TST

   test mode: discard the result


.. py:data:: HTI_FIL

   "input" is file name, otherwise "input" contains a C declaration 
           


.. py:data:: HTI_MAC

   define macros from the base tils


.. py:data:: HTI_NWR

   no warning messages


.. py:data:: HTI_NER

   ignore all errors but display them


.. py:data:: HTI_DCL

   don't complain about redeclarations


.. py:data:: HTI_NDC

   don't decorate names


.. py:data:: HTI_PAK

   explicit structure pack value (#pragma pack)


.. py:data:: HTI_PAK_SHIFT

   shift for HTI_PAK. This field should be used if you want to remember an explicit pack value for each structure/union type. See HTI_PAK... definitions 
           


.. py:data:: HTI_PAKDEF

   default pack value


.. py:data:: HTI_PAK1

   #pragma pack(1)


.. py:data:: HTI_PAK2

   #pragma pack(2)


.. py:data:: HTI_PAK4

   #pragma pack(4)


.. py:data:: HTI_PAK8

   #pragma pack(8)


.. py:data:: HTI_PAK16

   #pragma pack(16)


.. py:data:: HTI_HIGH

   assume high level prototypes (with hidden args, etc) 
           


.. py:data:: HTI_LOWER

   lower the function prototypes


.. py:data:: HTI_RAWARGS

   leave argument names unchanged (do not remove underscores)


.. py:data:: HTI_RELAXED

   accept references to unknown namespaces


.. py:data:: HTI_NOBASE

   do not inspect base tils


.. py:data:: HTI_SEMICOLON

   do not complain if the terminating semicolon is absent


.. py:data:: HTI_STANDALONE

   should parse standalone declaration, it may contain qualified name and type names, strictly speaking it is not a valid C++ code, IDA Pro specific 
           


.. py:function:: convert_pt_flags_to_hti(pt_flags: int) -> int

   Convert Type parsing flags to Type formatting flags. Type parsing flags lesser than 0x10 don't have stable meaning and will be ignored (more on these flags can be seen in idc.idc) 
           


.. py:function:: parse_decl(out_tif: tinfo_t, til: til_t, decl: str, pt_flags: int) -> str

   Parse ONE declaration. If the input string contains more than one declaration, the first complete type declaration (PT_TYP) or the last variable declaration (PT_VAR) will be used. 
           
   :param out_tif: type info
   :param til: type library to use. may be nullptr
   :param decl: C declaration to parse
   :param pt_flags: combination of Type parsing flags bits
   :returns: true: ok
   :returns: false: declaration is bad, the error message is displayed if !PT_SIL


.. py:data:: PT_SIL

   silent, no messages


.. py:data:: PT_NDC

   don't decorate names


.. py:data:: PT_TYP

   return declared type information


.. py:data:: PT_VAR

   return declared object information


.. py:data:: PT_PACKMASK

   mask for pack alignment values


.. py:data:: PT_HIGH

   assume high level prototypes (with hidden args, etc) 
           


.. py:data:: PT_LOWER

   lower the function prototypes


.. py:data:: PT_REPLACE

   replace the old type (used in idc)


.. py:data:: PT_RAWARGS

   leave argument names unchanged (do not remove underscores)


.. py:data:: PT_RELAXED

   accept references to unknown namespaces


.. py:data:: PT_EMPTY

   accept empty decl


.. py:data:: PT_SEMICOLON

   append the terminating semicolon


.. py:data:: PT_SYMBOL

   accept a symbol name and return its type. e.g. "LoadLibrary" will return its prototype 
           


.. py:function:: parse_decls(til: til_t, input: str, printer: printer_t *, hti_flags: int) -> int

   Parse many declarations and store them in a til. If there are any errors, they will be printed using 'printer'. This function uses default include path and predefined macros from the database settings. It always uses the HTI_DCL bit. 
           
   :param til: type library to store the result
   :param input: input string or file name (see hti_flags)
   :param printer: function to output error messages (use msg or nullptr or your own callback)
   :param hti_flags: combination of Type formatting flags
   :returns: number of errors, 0 means ok.


.. py:function:: print_type(ea: ida_idaapi.ea_t, prtype_flags: int) -> str

   Get type declaration for the specified address. 
           
   :param ea: address
   :param prtype_flags: combination of Type printing flags
   :returns: success


.. py:data:: PRTYPE_1LINE

   print to one line


.. py:data:: PRTYPE_MULTI

   print to many lines


.. py:data:: PRTYPE_TYPE

   print type declaration (not variable declaration)


.. py:data:: PRTYPE_PRAGMA

   print pragmas for alignment


.. py:data:: PRTYPE_SEMI

   append ; to the end


.. py:data:: PRTYPE_CPP

   use c++ name (only for print_type())


.. py:data:: PRTYPE_DEF

   tinfo_t: print definition, if available


.. py:data:: PRTYPE_NOARGS

   tinfo_t: do not print function argument names


.. py:data:: PRTYPE_NOARRS

   tinfo_t: print arguments with FAI_ARRAY as pointers


.. py:data:: PRTYPE_NORES

   tinfo_t: never resolve types (meaningful with PRTYPE_DEF)


.. py:data:: PRTYPE_RESTORE

   tinfo_t: print restored types for FAI_ARRAY and FAI_STRUCT


.. py:data:: PRTYPE_NOREGEX

   do not apply regular expressions to beautify name


.. py:data:: PRTYPE_COLORED

   add color tag COLOR_SYMBOL for any parentheses, commas and colons


.. py:data:: PRTYPE_METHODS

   tinfo_t: print udt methods


.. py:data:: PRTYPE_1LINCMT

   print comments even in the one line mode


.. py:data:: PRTYPE_HEADER

   print only type header (only for definitions)


.. py:data:: PRTYPE_OFFSETS

   print udt member offsets


.. py:data:: PRTYPE_MAXSTR

   limit the output length to 1024 bytes (the output may be slightly longer)


.. py:data:: PRTYPE_TAIL

   print only the definition tail (only for definitions, exclusive with PRTYPE_HEADER)


.. py:data:: PRTYPE_ARGLOCS

   print function arglocs (not only for usercall)


.. py:data:: NTF_TYPE

   type name


.. py:data:: NTF_SYMU

   symbol, name is unmangled ('func')


.. py:data:: NTF_SYMM

   symbol, name is mangled ('_func'); only one of NTF_TYPE and NTF_SYMU, NTF_SYMM can be used 
           


.. py:data:: NTF_NOBASE

   don't inspect base tils (for get_named_type)


.. py:data:: NTF_REPLACE

   replace original type (for set_named_type)


.. py:data:: NTF_UMANGLED

   name is unmangled (don't use this flag)


.. py:data:: NTF_NOCUR

   don't inspect current til file (for get_named_type)


.. py:data:: NTF_64BIT

   value is 64bit


.. py:data:: NTF_FIXNAME

   force-validate the name of the type when setting (set_named_type, set_numbered_type only) 
           


.. py:data:: NTF_IDBENC

   the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly (set_named_type, set_numbered_type only) 
           


.. py:data:: NTF_CHKSYNC

   check that synchronization to IDB passed OK (set_numbered_type, set_named_type) 
           


.. py:data:: NTF_NO_NAMECHK

   do not validate type name (set_numbered_type, set_named_type) 
           


.. py:data:: NTF_COPY

   save a new type definition, not a typeref (tinfo_t::set_numbered_type, tinfo_t::set_named_type)


.. py:data:: TERR_OK

   ok


.. py:data:: TERR_SAVE_ERROR

   failed to save


.. py:data:: TERR_SERIALIZE

   failed to serialize


.. py:data:: TERR_BAD_NAME

   name s is not acceptable


.. py:data:: TERR_BAD_ARG

   bad argument


.. py:data:: TERR_BAD_TYPE

   bad type


.. py:data:: TERR_BAD_SIZE

   bad size d


.. py:data:: TERR_BAD_INDEX

   bad index d


.. py:data:: TERR_BAD_ARRAY

   arrays are forbidden as function arguments


.. py:data:: TERR_BAD_BF

   bitfields are forbidden as function arguments


.. py:data:: TERR_BAD_OFFSET

   bad member offset s


.. py:data:: TERR_BAD_UNIVAR

   unions cannot have variable sized members


.. py:data:: TERR_BAD_VARLAST

   variable sized member must be the last member in the structure


.. py:data:: TERR_OVERLAP

   the member overlaps with other members that cannot be deleted


.. py:data:: TERR_BAD_SUBTYPE

   recursive structure nesting is forbidden


.. py:data:: TERR_BAD_VALUE

   value 0xI64X is not acceptable


.. py:data:: TERR_NO_BMASK

   bitmask 0xI64X is not found


.. py:data:: TERR_BAD_BMASK

   Bad enum member mask 0xI64X. The specified mask should not intersect with any existing mask in the enum. Zero masks are prohibited too.


.. py:data:: TERR_BAD_MSKVAL

   bad bmask and value combination (value=0xI64X; bitmask 0xI64X)


.. py:data:: TERR_BAD_REPR

   bad or incompatible field representation


.. py:data:: TERR_GRP_NOEMPTY

   could not delete group mask for not empty group 0xI64X


.. py:data:: TERR_DUPNAME

   duplicate name s


.. py:data:: TERR_UNION_BF

   unions cannot have bitfields


.. py:data:: TERR_BAD_TAH

   bad bits in the type attributes (TAH bits)


.. py:data:: TERR_BAD_BASE

   bad base class


.. py:data:: TERR_BAD_GAP

   bad gap


.. py:data:: TERR_NESTED

   recursive structure nesting is forbidden


.. py:data:: TERR_NOT_COMPAT

   the new type is not compatible with the old type


.. py:data:: TERR_BAD_LAYOUT

   failed to calculate the structure/union layout


.. py:data:: TERR_BAD_GROUPS

   bad group sizes for bitmask enum


.. py:data:: TERR_BAD_SERIAL

   enum value has too many serials


.. py:data:: TERR_ALIEN_NAME

   enum member name is used in another enum


.. py:data:: TERR_STOCK

   stock type info cannot be modified


.. py:data:: TERR_ENUM_SIZE

   bad enum size


.. py:data:: TERR_NOT_IMPL

   not implemented


.. py:data:: TERR_TYPE_WORSE

   the new type is worse than the old type


.. py:data:: TERR_BAD_FX_SIZE

   cannot extend struct beyond fixed size


.. py:data:: TERR_STRUCT_SIZE

   bad fixed structure size


.. py:data:: TERR_NOT_FOUND

   member not found


.. py:data:: TERR_COUNT

.. py:function:: tinfo_errstr(code: tinfo_code_t) -> str

   Helper function to convert an error code into a printable string. Additional arguments are handled using the functions from err.h 
           


.. py:function:: del_named_type(ti: til_t, name: str, ntf_flags: int) -> bool

   Delete information about a symbol. 
           
   :param ti: type library
   :param name: name of symbol
   :param ntf_flags: combination of Flags for named types
   :returns: success


.. py:function:: first_named_type(ti: til_t, ntf_flags: int) -> str

   Enumerate types. 
           
   :param ti: type library. nullptr means the local type library for the current database.
   :param ntf_flags: combination of Flags for named types
   :returns: Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals.


.. py:function:: next_named_type(ti: til_t, name: str, ntf_flags: int) -> str

   Enumerate types. 
           
   :param ti: type library. nullptr means the local type library for the current database.
   :param name: the current name. the name that follows this one will be returned.
   :param ntf_flags: combination of Flags for named types
   :returns: Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals.


.. py:function:: copy_named_type(dsttil: til_t, srctil: til_t, name: str) -> int

   Copy a named type from one til to another. This function will copy the specified type and all dependent types from the source type library to the destination library. 
           
   :param dsttil: Destination til. It must have original types enabled
   :param srctil: Source til.
   :param name: name of the type to copy
   :returns: ordinal number of the copied type. 0 means error


.. py:function:: decorate_name(*args) -> str

   Decorate/undecorate a C symbol name. 
           
   :param out: output buffer
   :param name: name of symbol
   :param should_decorate: true-decorate name, false-undecorate
   :param cc: calling convention
   :param type: name type (nullptr-unknown)
   :returns: success


.. py:function:: gen_decorate_name(name: str, should_decorate: bool, cc: callcnv_t, type: tinfo_t) -> str

   Generic function for decorate_name() (may be used in IDP modules)


.. py:function:: calc_c_cpp_name(name: str, type: tinfo_t, ccn_flags: int) -> str

   Get C or C++ form of the name. 
           
   :param name: original (mangled or decorated) name
   :param type: name type if known, otherwise nullptr
   :param ccn_flags: one of C/C++ naming flags


.. py:data:: CCN_C

.. py:data:: CCN_CPP

.. py:function:: enable_numbered_types(ti: til_t, enable: bool) -> bool

   Enable the use of numbered types in til. Currently it is impossible to disable numbered types once they are enabled 
           


.. py:function:: alloc_type_ordinals(ti: til_t, qty: int) -> int

   Allocate a range of ordinal numbers for new types. 
           
   :param ti: type library
   :param qty: number of ordinals to allocate
   :returns: the first ordinal. 0 means failure.


.. py:function:: alloc_type_ordinal(ti: til_t) -> int

   alloc_type_ordinals(ti, 1)


.. py:function:: get_ordinal_limit(ti: til_t = None) -> int

   Get number of allocated ordinals + 1. If there are no allocated ordinals, return 0. To enumerate all ordinals, use: for ( uint32 i = 1; i < limit; ++i ) 
           
   :param ti: type library; nullptr means the local types for the current database.
   :returns: uint32(-1) if ordinals have not been enabled for the til. For local types (idati), ordinals are always enabled.


.. py:function:: get_ordinal_count(ti: til_t = None) -> int

   Get number of allocated ordinals. 
           
   :param ti: type library; nullptr means the local types for the current database.
   :returns: 0 if ordinals have not been enabled for the til.


.. py:function:: del_numbered_type(ti: til_t, ordinal: int) -> bool

   Delete a numbered type.


.. py:function:: set_type_alias(ti: til_t, src_ordinal: int, dst_ordinal: int) -> bool

   Create a type alias. Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all references to srctype by dsttype. 
           


.. py:function:: get_alias_target(ti: til_t, ordinal: int) -> int

   Find the final alias destination. If the ordinal has not been aliased, return the specified ordinal itself If failed, returns 0. 
           


.. py:function:: get_type_ordinal(ti: til_t, name: str) -> int

   Get type ordinal by its name.


.. py:function:: get_numbered_type_name(ti: til_t, ordinal: int) -> str

   Get type name (if exists) by its ordinal. If the type is anonymous, returns "". If failed, returns nullptr 
           


.. py:function:: create_numbered_type_name(ord: int) -> str

   Create anonymous name for numbered type. This name can be used to reference a numbered type by its ordinal Ordinal names have the following format: '#' + set_de(ord) Returns: -1 if error, otherwise the name length 
           


.. py:function:: is_ordinal_name(name: str, ord: uint32 * = None) -> bool

   Check if the name is an ordinal name. Ordinal names have the following format: '#' + set_de(ord) 
           


.. py:function:: is_type_choosable(ti: til_t, ordinal: int) -> bool

   Check if a struct/union type is choosable 
           
   :param ti: type library
   :param ordinal: ordinal number of a UDT type


.. py:function:: set_type_choosable(ti: til_t, ordinal: int, value: bool) -> None

   Enable/disable 'choosability' flag for a struct/union type 
           
   :param ti: type library
   :param ordinal: ordinal number of a UDT type
   :param value: flag value


.. py:function:: get_vftable_ea(ordinal: int) -> ida_idaapi.ea_t

   Get address of a virtual function table. 
           
   :param ordinal: ordinal number of a vftable type.
   :returns: address of the corresponding virtual function table in the current database.


.. py:function:: get_vftable_ordinal(vftable_ea: ida_idaapi.ea_t) -> int

   Get ordinal number of the virtual function table. 
           
   :param vftable_ea: address of a virtual function table.
   :returns: ordinal number of the corresponding vftable type. 0 - failure.


.. py:function:: set_vftable_ea(ordinal: int, vftable_ea: ida_idaapi.ea_t) -> bool

   Set the address of a vftable instance for a vftable type. 
           
   :param ordinal: ordinal number of the corresponding vftable type.
   :param vftable_ea: address of a virtual function table.
   :returns: success


.. py:function:: del_vftable_ea(ordinal: int) -> bool

   Delete the address of a vftable instance for a vftable type. 
           
   :param ordinal: ordinal number of a vftable type.
   :returns: success


.. py:function:: deref_ptr(ptr_ea: ea_t *, tif: tinfo_t, closure_obj: ea_t * = None) -> bool

   Dereference a pointer. 
           
   :param ptr_ea: in/out parameter
   * in: address of the pointer
   * out: the pointed address
   :param tif: type of the pointer
   :param closure_obj: closure object (not used yet)
   :returns: success


.. py:function:: add_til(name: str, flags: int) -> int

   Load a til file and add it the database type libraries list. IDA will also apply function prototypes for matching function names. 
           
   :param name: til name
   :param flags: combination of Load TIL flags
   :returns: one of Load TIL result codes


.. py:data:: ADDTIL_DEFAULT

   default behavior


.. py:data:: ADDTIL_INCOMP

   load incompatible tils


.. py:data:: ADDTIL_SILENT

   do not ask any questions


.. py:data:: ADDTIL_FAILED

   something bad, the warning is displayed


.. py:data:: ADDTIL_OK

   ok, til is loaded


.. py:data:: ADDTIL_COMP

   ok, but til is not compatible with the current compiler


.. py:data:: ADDTIL_ABORTED

   til was not loaded (incompatible til rejected by user)


.. py:function:: del_til(name: str) -> bool

   Unload a til file.


.. py:function:: apply_named_type(ea: ida_idaapi.ea_t, name: str) -> bool

   Apply the specified named type to the address. 
           
   :param ea: linear address
   :param name: the type name, e.g. "FILE"
   :returns: success


.. py:function:: apply_tinfo(ea: ida_idaapi.ea_t, tif: tinfo_t, flags: int) -> bool

   Apply the specified type to the specified address. This function sets the type and tries to convert the item at the specified address to conform the type. 
           
   :param ea: linear address
   :param tif: new type
   :param flags: combination of Apply tinfo flags
   :returns: success


.. py:data:: TINFO_GUESSED

   this is a guessed type


.. py:data:: TINFO_DEFINITE

   this is a definite type


.. py:data:: TINFO_DELAYFUNC

   if type is a function and no function exists at ea, schedule its creation and argument renaming to auto-analysis, otherwise try to create it immediately 
           


.. py:data:: TINFO_STRICT

   never convert given type to another one before applying


.. py:function:: apply_cdecl(til: til_t, ea: ida_idaapi.ea_t, decl: str, flags: int = 0) -> bool

   Apply the specified type to the address. This function parses the declaration and calls apply_tinfo() 
           
   :param til: type library
   :param ea: linear address
   :param decl: type declaration in C form
   :param flags: flags to pass to apply_tinfo (TINFO_DEFINITE is always passed)
   :returns: success


.. py:function:: apply_callee_tinfo(caller: ida_idaapi.ea_t, tif: tinfo_t) -> bool

   Apply the type of the called function to the calling instruction. This function will append parameter comments and rename the local variables of the calling function. It also stores information about the instructions that initialize call arguments in the database. Use get_arg_addrs() to retrieve it if necessary. Alternatively it is possible to hook to processor_t::arg_addrs_ready event. 
           
   :param caller: linear address of the calling instruction. must belong to a function.
   :param tif: type info
   :returns: success


.. py:function:: apply_once_tinfo_and_name(dea: ida_idaapi.ea_t, tif: tinfo_t, name: str) -> bool

   Apply the specified type and name to the address. This function checks if the address already has a type. If the old type 
   does not exist or the new type is 'better' than the old type, then the 
   new type will be applied. A type is considered better if it has more 
   information (e.g. BTMT_STRUCT is better than BT_INT). 
   The same logic is with the name: if the address already have a meaningful 
   name, it will be preserved. Only if the old name does not exist or it 
   is a dummy name like byte_123, it will be replaced by the new name. 
           
   :param dea: linear address
   :param tif: new type
   :param name: new name for the address
   :returns: success


.. py:function:: guess_tinfo(out: tinfo_t, id: tid_t) -> int

   Generate a type information about the id from the disassembly. id can be a structure/union/enum id or an address. 
           
   :returns: one of Guess tinfo codes


.. py:data:: GUESS_FUNC_FAILED

   couldn't guess the function type


.. py:data:: GUESS_FUNC_TRIVIAL

   the function type doesn't have interesting info


.. py:data:: GUESS_FUNC_OK

   ok, some non-trivial information is gathered


.. py:function:: set_c_header_path(incdir: str) -> None

   Set include directory path the target compiler.


.. py:function:: get_c_header_path() -> str

   Get the include directory path of the target compiler.


.. py:function:: set_c_macros(macros: str) -> None

   Set predefined macros for the target compiler.


.. py:function:: get_c_macros() -> str

   Get predefined macros for the target compiler.


.. py:function:: get_idati() -> til_t *

   Pointer to the local type library - this til is private for each IDB file Functions that accept til_t* default to `idati` when is nullptr provided. 
           


.. py:function:: get_idainfo_by_type(tif: tinfo_t) -> size_t *, flags64_t *, opinfo_t *, size_t *

   Extract information from a tinfo_t. 
           
   :param tif: the type to inspect


.. py:function:: get_tinfo_by_flags(out: tinfo_t, flags: flags64_t) -> bool

   Get tinfo object that corresponds to data flags 
           
   :param out: type info
   :param flags: simple flags (byte, word, ..., zword)


.. py:data:: STI_PCHAR

   char *


.. py:data:: STI_PUCHAR

   uint8 *


.. py:data:: STI_PCCHAR

   const char *


.. py:data:: STI_PCUCHAR

   const uint8 *


.. py:data:: STI_PBYTE

   _BYTE *


.. py:data:: STI_PINT

   int *


.. py:data:: STI_PUINT

   unsigned int *


.. py:data:: STI_PVOID

   void *


.. py:data:: STI_PPVOID

   void **


.. py:data:: STI_PCVOID

   const void *


.. py:data:: STI_ACHAR

   char[]


.. py:data:: STI_AUCHAR

   uint8[]


.. py:data:: STI_ACCHAR

   const char[]


.. py:data:: STI_ACUCHAR

   const uint8[]


.. py:data:: STI_FPURGING

   void __userpurge(int)


.. py:data:: STI_FDELOP

   void __cdecl(void *)


.. py:data:: STI_MSGSEND

   void *(void *, const char *, ...)


.. py:data:: STI_AEABI_LCMP

   int __fastcall __pure(int64 x, int64 y)


.. py:data:: STI_AEABI_ULCMP

   int __fastcall __pure(uint64 x, uint64 y)


.. py:data:: STI_DONT_USE

   unused stock type id; should not be used


.. py:data:: STI_SIZE_T

   size_t


.. py:data:: STI_SSIZE_T

   ssize_t


.. py:data:: STI_AEABI_MEMCPY

   void __fastcall(void *, const void *, size_t)


.. py:data:: STI_AEABI_MEMSET

   void __fastcall(void *, size_t, int)


.. py:data:: STI_AEABI_MEMCLR

   void __fastcall(void *, size_t)


.. py:data:: STI_RTC_CHECK_2

   int16 __fastcall(int16 x)


.. py:data:: STI_RTC_CHECK_4

   int32 __fastcall(int32 x)


.. py:data:: STI_RTC_CHECK_8

   int64 __fastcall(int64 x)


.. py:data:: STI_COMPLEX64

   struct complex64_t { float real, imag; }


.. py:data:: STI_COMPLEX128

   struct complex128_t { double real, imag; }


.. py:data:: STI_PUNKNOWN

   _UNKNOWN *


.. py:data:: STI_LAST

.. py:data:: ETF_NO_SAVE

   don't save to til (normally typerefs are saved to til) A call with ETF_NO_SAVE must be followed by a call without it. Otherwise there may be inconsistencies between the memory and the type library. 
             


.. py:data:: ETF_NO_LAYOUT

   don't calc type layout before editing


.. py:data:: ETF_MAY_DESTROY

   may destroy other members


.. py:data:: ETF_COMPATIBLE

   new type must be compatible with the old


.. py:data:: ETF_FUNCARG

   udm - member is a function argument (cannot create arrays)


.. py:data:: ETF_FORCENAME

   anyway use name, see below for more usage description


.. py:data:: ETF_AUTONAME

   udm - generate a member name if was not specified (add_udm, set_udm_type)


.. py:data:: ETF_BYTIL

   udm - new type was created by the type subsystem


.. py:data:: ETF_NO_ARRAY

   add_udm, set_udm_type - do not convert type to an array on the size mismatch


.. py:data:: GTD_CALC_LAYOUT

   calculate udt layout


.. py:data:: GTD_NO_LAYOUT

   don't calculate udt layout please note that udt layout may have been calculated earlier 
             


.. py:data:: GTD_DEL_BITFLDS

   delete udt bitfields


.. py:data:: GTD_CALC_ARGLOCS

   calculate func arg locations


.. py:data:: GTD_NO_ARGLOCS

   don't calculate func arg locations please note that the locations may have been calculated earlier 
             


.. py:data:: GTS_NESTED

   nested type (embedded into a udt)


.. py:data:: GTS_BASECLASS

   is baseclass of a udt


.. py:data:: SUDT_SORT

   fields are not sorted by offset, sort them first


.. py:data:: SUDT_ALIGN

   recalculate field alignments, struct packing, etc to match the offsets and size info 
           


.. py:data:: SUDT_GAPS

   allow to fill gaps with additional members (_BYTE[])


.. py:data:: SUDT_UNEX

   references to nonexistent member types are acceptable; in this case it is better to set the corresponding udm_t::fda field to the type alignment. If this field is not set, ida will try to guess the alignment. 
           


.. py:data:: SUDT_FAST

   serialize without verifying offsets and alignments


.. py:data:: SUDT_CONST

   only for serialize_udt: make type const


.. py:data:: SUDT_VOLATILE

   only for serialize_udt: make type volatile


.. py:data:: SUDT_TRUNC

   serialize: truncate useless strings from fields, fldcmts


.. py:data:: SUDT_SERDEF

   serialize: if a typeref, serialize its definition


.. py:function:: copy_tinfo_t(_this: tinfo_t, r: tinfo_t) -> None

.. py:function:: detach_tinfo_t(_this: tinfo_t) -> bool

.. py:function:: clear_tinfo_t(_this: tinfo_t) -> None

.. py:function:: create_tinfo(_this: tinfo_t, bt: type_t, bt2: type_t, ptr: void *) -> bool

.. py:function:: verify_tinfo(typid: typid_t) -> int

.. py:function:: get_tinfo_details(typid: typid_t, bt2: type_t, buf: void *) -> bool

.. py:function:: get_tinfo_size(p_effalign: uint32 *, typid: typid_t, gts_code: int) -> size_t

.. py:function:: get_tinfo_pdata(outptr: void *, typid: typid_t, what: int) -> size_t

.. py:function:: get_tinfo_property(typid: typid_t, gta_prop: int) -> size_t

.. py:function:: get_tinfo_property4(typid: typid_t, gta_prop: int, p1: size_t, p2: size_t, p3: size_t, p4: size_t) -> size_t

.. py:function:: set_tinfo_property(tif: tinfo_t, sta_prop: int, x: size_t) -> size_t

.. py:function:: set_tinfo_property4(tif: tinfo_t, sta_prop: int, p1: size_t, p2: size_t, p3: size_t, p4: size_t) -> size_t

.. py:function:: serialize_tinfo(type: qtype *, fields: qtype *, fldcmts: qtype *, tif: tinfo_t, sudt_flags: int) -> bool

.. py:function:: find_tinfo_udt_member(udm: udm_t, typid: typid_t, strmem_flags: int) -> int

.. py:function:: print_tinfo(prefix: str, indent: int, cmtindent: int, flags: int, tif: tinfo_t, name: str, cmt: str) -> str

.. py:function:: dstr_tinfo(tif: tinfo_t) -> str

.. py:function:: visit_subtypes(visitor: tinfo_visitor_t, out: type_mods_t, tif: tinfo_t, name: str, cmt: str) -> int

.. py:function:: compare_tinfo(t1: typid_t, t2: typid_t, tcflags: int) -> bool

.. py:function:: lexcompare_tinfo(t1: typid_t, t2: typid_t, arg3: int) -> int

.. py:function:: get_stock_tinfo(tif: tinfo_t, id: stock_type_id_t) -> bool

.. py:function:: read_tinfo_bitfield_value(typid: typid_t, v: uint64, bitoff: int) -> uint64

.. py:function:: write_tinfo_bitfield_value(typid: typid_t, dst: uint64, v: uint64, bitoff: int) -> uint64

.. py:function:: get_tinfo_attr(typid: typid_t, key: str, bv: bytevec_t *, all_attrs: bool) -> bool

.. py:function:: set_tinfo_attr(tif: tinfo_t, ta: type_attr_t, may_overwrite: bool) -> bool

.. py:function:: del_tinfo_attr(tif: tinfo_t, key: str, make_copy: bool) -> bool

.. py:function:: get_tinfo_attrs(typid: typid_t, tav: type_attrs_t, include_ref_attrs: bool) -> bool

.. py:function:: set_tinfo_attrs(tif: tinfo_t, ta: type_attrs_t) -> bool

.. py:function:: score_tinfo(tif: tinfo_t) -> int

.. py:function:: save_tinfo(tif: tinfo_t, til: til_t, ord: size_t, name: str, ntf_flags: int) -> tinfo_code_t

.. py:function:: append_tinfo_covered(out: rangeset_t, typid: typid_t, offset: uint64) -> bool

.. py:function:: calc_tinfo_gaps(out: rangeset_t, typid: typid_t) -> bool

.. py:function:: value_repr_t__from_opinfo(_this: value_repr_t, flags: flags64_t, afl: aflags_t, opinfo: opinfo_t, ap: array_parameters_t) -> bool

.. py:function:: value_repr_t__print_(_this: value_repr_t, colored: bool) -> str

.. py:function:: udt_type_data_t__find_member(_this: udt_type_data_t, udm: udm_t, strmem_flags: int) -> ssize_t

.. py:function:: udt_type_data_t__get_best_fit_member(_this: udt_type_data_t, disp: asize_t) -> ssize_t

.. py:function:: get_tinfo_by_edm_name(tif: tinfo_t, til: til_t, mname: str) -> ssize_t

.. py:class:: tinfo_t(*args, ordinal=None, name=None, tid=None, til=None)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: clear() -> None

      Clear contents of this tinfo, and remove from the type system.



   .. py:method:: swap(r: tinfo_t) -> None

      Assign this = r and r = this.



   .. py:method:: get_named_type(*args) -> bool

      This function has the following signatures:

          0. get_named_type(til: const til_t *, name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
          1. get_named_type(name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool

      # 0: get_named_type(til: const til_t *, name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool

      Create a tinfo_t object for an existing named type. 
              

      # 1: get_named_type(name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool



   .. py:method:: get_numbered_type(*args) -> bool

      This function has the following signatures:

          0. get_numbered_type(til: const til_t *, ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
          1. get_numbered_type(ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool

      # 0: get_numbered_type(til: const til_t *, ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool

      Create a tinfo_t object for an existing ordinal type. 
              

      # 1: get_numbered_type(ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool



   .. py:method:: detach() -> bool

      Detach tinfo_t from the underlying type. After calling this finction, tinfo_t will lose its link to the underlying named or numbered type (if any) and will become a reference to a unique type. After that, any modifications to tinfo_t will affect only its type. 
              



   .. py:method:: is_correct() -> bool

      Is the type object correct?. It is possible to create incorrect types. For example, we can define a function that returns an enum and then delete the enum type. If this function returns false, the type should not be used in disassembly. Please note that this function does not verify all involved types: for example, pointers to undefined types are permitted. 
              



   .. py:method:: get_realtype(full: bool = False) -> type_t

      Get the resolved base type. Deserialization options:
      * if full=true, the referenced type will be deserialized fully, this may not always be desirable (slows down things)
      * if full=false, we just return the base type, the referenced type will be resolved again later if necessary (this may lead to multiple resolvings of the same type) imho full=false is a better approach because it does not perform unnecessary actions just in case. however, in some cases the caller knows that it is very likely that full type info will be required. in those cases full=true makes sense 


              



   .. py:method:: get_decltype() -> type_t

      Get declared type (without resolving type references; they are returned as is). Obviously this is a very fast function and should be used instead of get_realtype() if possible. Please note that for typerefs this function will return BTF_TYPEDEF. To determine if a typeref is a typedef, use is_typedef() 
              



   .. py:method:: empty() -> bool

      Was tinfo_t initialized with some type info or not?



   .. py:method:: present() -> bool

      Is the type really present? (not a reference to a missing type, for example)



   .. py:method:: get_size(p_effalign: uint32 * = None, gts_code: int = 0) -> size_t

      Get the type size in bytes. 
              
      :param p_effalign: buffer for the alignment value
      :param gts_code: combination of GTS_... constants
      :returns: BADSIZE in case of problems



   .. py:method:: get_unpadded_size() -> size_t

      Get the type size in bytes without the final padding, in bytes. For some UDTs get_unpadded_size() != get_size() 
              



   .. py:method:: get_alignment() -> int

      Get type alignment This function returns the effective type alignment. Zero means error. 
              



   .. py:method:: get_sign() -> type_sign_t

      Get type sign.



   .. py:method:: is_signed() -> bool

      Is this a signed type?



   .. py:method:: is_unsigned() -> bool

      Is this an unsigned type?



   .. py:method:: get_declalign() -> uchar

      Get declared alignment of the type.



   .. py:method:: is_typeref() -> bool

      Is this type a type reference?.



   .. py:method:: has_details() -> bool

      Does this type refer to a nontrivial type?



   .. py:method:: get_type_name() -> bool

      Does a type refer to a name?. If yes, fill the provided buffer with the type name and return true. Names are returned for numbered types too: either a user-defined nice name or, if a user-provided name does not exist, an ordinal name (like #xx, see create_numbered_type_name()). 
              



   .. py:method:: get_nice_type_name() -> bool

      Get the beautified type name. Get the referenced name and apply regular expressions from goodname.cfg to beautify the name 
              



   .. py:method:: rename_type(name: str, ntf_flags: int = 0) -> tinfo_code_t

      Rename a type 
              
      :param name: new type name
      :param ntf_flags: Flags for named types



   .. py:method:: get_final_type_name() -> bool

      Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn). 
              
      :returns: the name of the last type in the chain (TYPEn). if there is no chain, returns TYPE1



   .. py:method:: get_next_type_name() -> bool

      Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn). 
              
      :returns: the name of the next type in the chain (TYPE2). if there is no chain, returns failure



   .. py:method:: get_tid() -> tid_t

      Get the type tid Each type in the local type library has a so-called `tid` associated with it. The tid is used to collect xrefs to the type. The tid is created when the type is created in the local type library and does not change afterwards. It can be passed to xref-related functions instead of the address. 
              
      :returns: tid or BADADDR



   .. py:method:: force_tid() -> tid_t

      Get the type tid. Create if it does not exist yet. If the type comes from a base til, the type will be copied to the local til and a new tid will be created for it. (if the type comes from a base til, it does not have a tid yet). If the type comes from the local til, this function is equivalent to get_tid() 
              
      :returns: tid or BADADDR



   .. py:method:: get_ordinal() -> int

      Get type ordinal (only if the type was created as a numbered type, 0 if none)



   .. py:method:: get_final_ordinal() -> int

      Get final type ordinal (0 if none)



   .. py:method:: get_til() -> til_t *

      Get the type library for tinfo_t.



   .. py:method:: is_from_subtil() -> bool

      Was the named type found in some base type library (not the top level type library)?. If yes, it usually means that the type comes from some loaded type library, not the local type library for the database 
              



   .. py:method:: is_forward_decl() -> bool

      Is this a forward declaration?. Forward declarations are placeholders: the type definition does not exist 
              



   .. py:method:: get_forward_type() -> type_t

      Get type of a forward declaration. For a forward declaration this function returns its base type. In other cases it returns BT_UNK 
              



   .. py:method:: is_forward_struct() -> bool


   .. py:method:: is_forward_union() -> bool


   .. py:method:: is_forward_enum() -> bool


   .. py:method:: is_typedef() -> bool

      Is this a typedef?. This function will return true for a reference to a local type that is declared as a typedef. 
              



   .. py:method:: get_type_cmt() -> int

      Get type comment 
              
      :returns: 0-failed, 1-returned regular comment, 2-returned repeatable comment



   .. py:method:: get_type_rptcmt() -> bool

      Get type comment only if it is repeatable.



   .. py:method:: is_decl_const() -> bool

      is_type_const(get_decltype())



   .. py:method:: is_decl_volatile() -> bool

      is_type_volatile(get_decltype())



   .. py:method:: is_decl_void() -> bool

      is_type_void(get_decltype())



   .. py:method:: is_decl_partial() -> bool

      is_type_partial(get_decltype())



   .. py:method:: is_decl_unknown() -> bool

      is_type_unknown(get_decltype())



   .. py:method:: is_decl_last() -> bool

      is_typeid_last(get_decltype())



   .. py:method:: is_decl_ptr() -> bool

      is_type_ptr(get_decltype())



   .. py:method:: is_decl_array() -> bool

      is_type_array(get_decltype())



   .. py:method:: is_decl_func() -> bool

      is_type_func(get_decltype())



   .. py:method:: is_decl_complex() -> bool

      is_type_complex(get_decltype())



   .. py:method:: is_decl_typedef() -> bool

      is_type_typedef(get_decltype())



   .. py:method:: is_decl_sue() -> bool

      is_type_sue(get_decltype())



   .. py:method:: is_decl_struct() -> bool

      is_type_struct(get_decltype())



   .. py:method:: is_decl_union() -> bool

      is_type_union(get_decltype())



   .. py:method:: is_decl_udt() -> bool

      is_type_struni(get_decltype())



   .. py:method:: is_decl_enum() -> bool

      is_type_enum(get_decltype())



   .. py:method:: is_decl_bitfield() -> bool

      is_type_bitfld(get_decltype())



   .. py:method:: is_decl_int128() -> bool

      is_type_int128(get_decltype())



   .. py:method:: is_decl_int64() -> bool

      is_type_int64(get_decltype())



   .. py:method:: is_decl_int32() -> bool

      is_type_int32(get_decltype())



   .. py:method:: is_decl_int16() -> bool

      is_type_int16(get_decltype())



   .. py:method:: is_decl_int() -> bool

      is_type_int(get_decltype())



   .. py:method:: is_decl_char() -> bool

      is_type_char(get_decltype())



   .. py:method:: is_decl_uint() -> bool

      is_type_uint(get_decltype())



   .. py:method:: is_decl_uchar() -> bool

      is_type_uchar(get_decltype())



   .. py:method:: is_decl_uint16() -> bool

      is_type_uint16(get_decltype())



   .. py:method:: is_decl_uint32() -> bool

      is_type_uint32(get_decltype())



   .. py:method:: is_decl_uint64() -> bool

      is_type_uint64(get_decltype())



   .. py:method:: is_decl_uint128() -> bool

      is_type_uint128(get_decltype())



   .. py:method:: is_decl_ldouble() -> bool

      is_type_ldouble(get_decltype())



   .. py:method:: is_decl_double() -> bool

      is_type_double(get_decltype())



   .. py:method:: is_decl_float() -> bool

      is_type_float(get_decltype())



   .. py:method:: is_decl_tbyte() -> bool

      is_type_tbyte(get_decltype())



   .. py:method:: is_decl_floating() -> bool

      is_type_floating(get_decltype())



   .. py:method:: is_decl_bool() -> bool

      is_type_bool(get_decltype())



   .. py:method:: is_decl_paf() -> bool

      is_type_paf(get_decltype())



   .. py:method:: is_well_defined() -> bool

      !(empty()) && !(is_decl_partial()) && !(is_punknown())



   .. py:method:: is_const() -> bool

      is_type_const(get_realtype())



   .. py:method:: is_volatile() -> bool

      is_type_volatile(get_realtype())



   .. py:method:: is_void() -> bool

      is_type_void(get_realtype())



   .. py:method:: is_partial() -> bool

      is_type_partial(get_realtype())



   .. py:method:: is_unknown() -> bool

      is_type_unknown(get_realtype())



   .. py:method:: is_ptr() -> bool

      is_type_ptr(get_realtype())



   .. py:method:: is_array() -> bool

      is_type_array(get_realtype())



   .. py:method:: is_func() -> bool

      is_type_func(get_realtype())



   .. py:method:: is_complex() -> bool

      is_type_complex(get_realtype())



   .. py:method:: is_struct() -> bool

      is_type_struct(get_realtype())



   .. py:method:: is_union() -> bool

      is_type_union(get_realtype())



   .. py:method:: is_udt() -> bool

      is_type_struni(get_realtype())



   .. py:method:: is_enum() -> bool

      is_type_enum(get_realtype())



   .. py:method:: is_sue() -> bool

      is_type_sue(get_realtype())



   .. py:method:: is_bitfield() -> bool

      is_type_bitfld(get_realtype())



   .. py:method:: is_int128() -> bool

      is_type_int128(get_realtype())



   .. py:method:: is_int64() -> bool

      is_type_int64(get_realtype())



   .. py:method:: is_int32() -> bool

      is_type_int32(get_realtype())



   .. py:method:: is_int16() -> bool

      is_type_int16(get_realtype())



   .. py:method:: is_int() -> bool

      is_type_int(get_realtype())



   .. py:method:: is_char() -> bool

      is_type_char(get_realtype())



   .. py:method:: is_uint() -> bool

      is_type_uint(get_realtype())



   .. py:method:: is_uchar() -> bool

      is_type_uchar(get_realtype())



   .. py:method:: is_uint16() -> bool

      is_type_uint16(get_realtype())



   .. py:method:: is_uint32() -> bool

      is_type_uint32(get_realtype())



   .. py:method:: is_uint64() -> bool

      is_type_uint64(get_realtype())



   .. py:method:: is_uint128() -> bool

      is_type_uint128(get_realtype())



   .. py:method:: is_ldouble() -> bool

      is_type_ldouble(get_realtype())



   .. py:method:: is_double() -> bool

      is_type_double(get_realtype())



   .. py:method:: is_float() -> bool

      is_type_float(get_realtype())



   .. py:method:: is_tbyte() -> bool

      is_type_tbyte(get_realtype())



   .. py:method:: is_bool() -> bool

      is_type_bool(get_realtype())



   .. py:method:: is_paf() -> bool

      is_type_paf(get_realtype())



   .. py:method:: is_ptr_or_array() -> bool

      is_type_ptr_or_array(get_realtype())



   .. py:method:: is_integral() -> bool

      is_type_integral(get_realtype())



   .. py:method:: is_ext_integral() -> bool

      is_type_ext_integral(get_realtype())



   .. py:method:: is_floating() -> bool

      is_type_floating(get_realtype())



   .. py:method:: is_arithmetic() -> bool

      is_type_arithmetic(get_realtype())



   .. py:method:: is_ext_arithmetic() -> bool

      is_type_ext_arithmetic(get_realtype()) 
              



   .. py:method:: is_scalar() -> bool

      Does the type represent a single number?



   .. py:method:: get_ptr_details(pi: ptr_type_data_t) -> bool

      Get the pointer info.



   .. py:method:: get_array_details(ai: array_type_data_t) -> bool

      Get the array specific info.



   .. py:method:: get_enum_details(ei: enum_type_data_t) -> bool

      Get the enum specific info.



   .. py:method:: get_bitfield_details(bi: bitfield_type_data_t) -> bool

      Get the bitfield specific info.



   .. py:method:: get_udt_details(udt: udt_type_data_t, gtd: gtd_udt_t = GTD_CALC_LAYOUT) -> bool

      Get the udt specific info.



   .. py:method:: get_func_details(fi: func_type_data_t, gtd: gtd_func_t = GTD_CALC_ARGLOCS) -> bool

      Get only the function specific info for this tinfo_t.



   .. py:method:: is_funcptr() -> bool

      Is this pointer to a function?



   .. py:method:: is_shifted_ptr() -> bool

      Is a shifted pointer?



   .. py:method:: is_varstruct() -> bool

      Is a variable-size structure?



   .. py:method:: is_varmember() -> bool

      Can the type be of a variable struct member? This function checks for: is_array() && array.nelems==0 Such a member can be only the very last member of a structure 
              



   .. py:method:: get_ptrarr_objsize() -> int

      BT_PTR & BT_ARRAY: get size of pointed object or array element. On error returns -1



   .. py:method:: get_ptrarr_object() -> tinfo_t

      BT_PTR & BT_ARRAY: get the pointed object or array element. If the current type is not a pointer or array, return empty type info. 
              



   .. py:method:: get_pointed_object() -> tinfo_t

      BT_PTR: get type of pointed object. If the current type is not a pointer, return empty type info. See also get_ptrarr_object() and remove_pointer() 
              



   .. py:method:: is_pvoid() -> bool

      Is "void *"?. This function does not check the pointer attributes and type modifiers.



   .. py:method:: is_punknown() -> bool

      Is "_UNKNOWN *"?. This function does not check the pointer attributes and type modifiers.



   .. py:method:: get_array_element() -> tinfo_t

      BT_ARRAY: get type of array element. See also get_ptrarr_object()



   .. py:method:: get_final_element() -> tinfo_t

      repeat recursively: if an array, return the type of its element; else return the type itself.



   .. py:method:: get_array_nelems() -> int

      BT_ARRAY: get number of elements (-1 means error)



   .. py:method:: get_nth_arg(n: int) -> tinfo_t

      BT_FUNC or BT_PTR BT_FUNC: Get type of n-th arg (-1 means return type, see get_rettype())



   .. py:method:: get_rettype() -> tinfo_t

      BT_FUNC or BT_PTR BT_FUNC: Get the function's return type



   .. py:method:: get_nargs() -> int

      BT_FUNC or BT_PTR BT_FUNC: Calculate number of arguments (-1 - error)



   .. py:method:: is_user_cc() -> bool

      is_user_cc(get_cc())



   .. py:method:: is_vararg_cc() -> bool

      is_vararg_cc(get_cc())



   .. py:method:: is_purging_cc() -> bool

      is_purging_cc(get_cc())



   .. py:method:: calc_purged_bytes() -> int

      BT_FUNC: Calculate number of purged bytes



   .. py:method:: is_high_func() -> bool

      BT_FUNC: Is high level type?



   .. py:method:: get_methods(methods: udtmembervec_t) -> bool

      BT_COMPLEX: get a list of member functions declared in this udt. 
              
      :returns: false if no member functions exist



   .. py:method:: get_bit_buckets(buckets: range64vec_t) -> bool

      ::BT_STRUCT: get bit buckets Bit buckets are used to layout bitfields 
              
      :returns: false if wrong type was passed



   .. py:method:: find_udm(*args) -> int

      This function has the following signatures:

          0. find_udm(udm: udm_t *, strmem_flags: int) -> int
          1. find_udm(offset: uint64, strmem_flags: int=0) -> int
          2. find_udm(name: str, strmem_flags: int=0) -> int

      # 0: find_udm(udm: udm_t *, strmem_flags: int) -> int

      BTF_STRUCT,BTF_UNION: Find a udt member.
      * at the specified offset (STRMEM_OFFSET)
      * with the specified index (STRMEM_INDEX)
      * with the specified type (STRMEM_TYPE)
      * with the specified name (STRMEM_NAME)



      :returns: the index of the found member or -1

      # 1: find_udm(offset: uint64, strmem_flags: int=0) -> int

      BTF_STRUCT,BTF_UNION: Find an udt member at the specified offset 
              
      :returns: the index of the found member or -1

      # 2: find_udm(name: str, strmem_flags: int=0) -> int

      BTF_STRUCT,BTF_UNION: Find an udt member by name 
              
      :returns: the index of the found member or -1



   .. py:method:: get_udm(*args) -> Union[Tuple[int, udm_t], Tuple[None, None]]

      Retrieve a structure/union member with either the specified name
      or the specified index, in the specified tinfo_t object.

      This function has the following signatures:

          1. get_udm(index: int)
          2. get_udm(name: str)

      :param index: a member index (1st form)
      :param name: a member name (2nd form)
      :returns: a tuple (int, udm_t), or (-1, None) if member not found



   .. py:method:: get_udm_by_offset(offset: int)

      Retrieve a structure/union member with the specified offset,
      in the specified tinfo_t object.

      :param offset: the member offset
      :returns: a tuple (int, udm_t), or (-1, None) if member not found



   .. py:method:: get_udt_nmembers() -> int

      Get number of udt members. -1-error.



   .. py:method:: is_empty_udt() -> bool

      Is an empty struct/union? (has no fields)



   .. py:method:: is_small_udt() -> bool

      Is a small udt? (can fit a register or a pair of registers)



   .. py:method:: get_udt_taudt_bits() -> int

      Get udt_type_data_t::taudt_bits.



   .. py:method:: is_unaligned_struct() -> bool

      Is an unaligned struct.



   .. py:method:: is_msstruct() -> bool

      Is gcc msstruct attribute applied.



   .. py:method:: is_cpp_struct() -> bool

      Is a c++ object, not simple pod type.



   .. py:method:: is_vftable() -> bool

      Is a vftable type?



   .. py:method:: is_fixed_struct() -> bool

      Is a structure with fixed offsets?



   .. py:method:: is_tuple() -> bool

      Is a tuple?



   .. py:method:: requires_qualifier(name: str, offset: uint64) -> bool

      Requires full qualifier? (name is not unique) 
              
      :param name: field name
      :param offset: field offset in bits
      :returns: if the name is not unique, returns true



   .. py:method:: append_covered(out: rangeset_t, offset: uint64 = 0) -> bool

      Calculate set of covered bytes for the type 
              
      :param out: pointer to the output buffer. covered bytes will be appended to it.
      :param offset: delta in bytes to add to all calculations. used internally during recurion.



   .. py:method:: calc_gaps(out: rangeset_t) -> bool

      Calculate set of padding bytes for the type 
              
      :param out: pointer to the output buffer; old buffer contents will be lost.



   .. py:method:: is_one_fpval() -> bool

      Floating value or an object consisting of one floating member entirely.



   .. py:method:: is_sse_type() -> bool

      Is a SSE vector type?



   .. py:method:: is_anonymous_udt() -> bool

      Is an anonymous struct/union? We assume that types with names are anonymous if the name starts with $ 
              



   .. py:method:: has_vftable() -> bool

      Has a vftable?



   .. py:method:: has_union() -> bool

      Has a member of type "union"?



   .. py:method:: get_enum_nmembers() -> size_t

      Get number of enum members. 
              
      :returns: BADSIZE if error



   .. py:method:: is_empty_enum() -> bool

      Is an empty enum? (has no constants)



   .. py:method:: get_enum_base_type() -> type_t

      Get enum base type (convert enum to integer type) Returns BT_UNK if failed to convert 
              



   .. py:method:: is_bitmask_enum() -> bool

      Is bitmask enum? 
              
      :returns: true for bitmask enum and false in other cases enum_type_data_t::is_bf()



   .. py:method:: get_enum_radix() -> int

      Get enum constant radix 
              
      :returns: radix or 1 for BTE_CHAR enum_type_data_t::get_enum_radix()



   .. py:method:: get_enum_repr(repr: value_repr_t) -> tinfo_code_t

      Set the representation of enum members. 
              
      :param repr: value_repr_t



   .. py:method:: get_enum_width() -> int

      Get enum width 
              
      :returns: width of enum base type in bytes, 0 - unspecified, or -1 enum_type_data_t::calc_nbytes()



   .. py:method:: calc_enum_mask() -> uint64


   .. py:method:: get_edm_by_value(value: int, bmask: int = DEFMASK64, serial: int = 0) -> Tuple[int, edm_t]

      Retrieve an enumerator with the specified value,
      in the specified tinfo_t object.

      :param value: the enumerator value
      :returns: a tuple (int, edm_t), or (-1, None) if member not found



   .. py:method:: get_edm_tid(idx: size_t) -> tid_t

      Get enum member TID 
              
      :param idx: enum member index
      :returns: tid or BADADDR The tid is used to collect xrefs to the member, it can be passed to xref-related functions instead of the address.



   .. py:method:: get_onemember_type() -> tinfo_t

      For objects consisting of one member entirely: return type of the member.



   .. py:method:: get_innermost_udm(bitoffset: uint64) -> tinfo_t

      Get the innermost member at the given offset 
              
      :param bitoffset: bit offset into the structure
      :returns: udt: with the innermost member
      :returns: empty: type if it is not a struct type or OFFSET could not be found



   .. py:method:: get_innermost_member_type(bitoffset: uint64) -> tinfo_t

      Get the innermost member type at the given offset 
              
      :param bitoffset: bit offset into the structure
      :returns: the: innermost member type



   .. py:method:: calc_score() -> int

      Calculate the type score (the higher - the nicer is the type)



   .. py:method:: dstr() -> str

      Function to facilitate debugging.



   .. py:method:: get_attrs(tav: type_attrs_t, all_attrs: bool = False) -> bool

      Get type attributes (all_attrs: include attributes of referenced types, if any)



   .. py:method:: set_attrs(tav: type_attrs_t) -> bool

      Set type attributes. If necessary, a new typid will be created. this function modifies tav! (returns old attributes, if any) 
              
      :returns: false: bad attributes



   .. py:method:: set_attr(ta: type_attr_t, may_overwrite: bool = True) -> bool

      Set a type attribute. If necessary, a new typid will be created.



   .. py:method:: del_attrs() -> None

      Del all type attributes. typerefs cannot be modified by this function.



   .. py:method:: del_attr(key: str, make_copy: bool = True) -> bool

      Del a type attribute. typerefs cannot be modified by this function.



   .. py:method:: create_simple_type(decl_type: type_t) -> bool


   .. py:method:: create_ptr(*args) -> bool


   .. py:method:: create_array(*args) -> bool


   .. py:method:: create_typedef(*args) -> None


   .. py:method:: create_bitfield(*args) -> bool


   .. py:method:: parse(decl: str, til: til_t = None, pt_flags: int = 0) -> bool

      Convenience function to parse a string with a type declaration 
              
      :param decl: a type declaration
      :param til: type library to use
      :param pt_flags: combination of Type parsing flags bits



   .. py:method:: create_udt(*args) -> bool

      Create an empty structure/union.



   .. py:method:: create_enum(*args) -> bool

      Create an empty enum.



   .. py:method:: create_func(*args) -> bool


   .. py:method:: get_udm_by_tid(udm: udm_t, tid: tid_t) -> ssize_t


   .. py:method:: get_edm_by_tid(edm: edm_t, tid: tid_t) -> ssize_t


   .. py:method:: get_type_by_tid(tid: tid_t) -> bool


   .. py:method:: get_by_edm_name(mname: str, til: til_t = None) -> ssize_t

      Retrieve enum tinfo using enum member name 
              
      :param mname: enum type member name
      :param til: type library
      :returns: member index, otherwise returns -1. If the function fails, THIS object becomes empty.



   .. py:method:: set_named_type(til: til_t, name: str, ntf_flags: int = 0) -> tinfo_code_t


   .. py:method:: set_symbol_type(til: til_t, name: str, ntf_flags: int = 0) -> tinfo_code_t


   .. py:method:: set_numbered_type(til: til_t, ord: int, ntf_flags: int = 0, name: str = None) -> tinfo_code_t


   .. py:method:: save_type(*args) -> tinfo_code_t


   .. py:method:: copy_type(*args) -> tinfo_code_t


   .. py:method:: create_forward_decl(til: til_t, decl_type: type_t, name: str, ntf_flags: int = 0) -> tinfo_code_t

      Create a forward declaration. decl_type: BTF_STRUCT, BTF_UNION, or BTF_ENUM 
              



   .. py:method:: get_stock(id: stock_type_id_t) -> tinfo_t
      :staticmethod:


      Get stock type information. This function can be used to get tinfo_t for some common types. The same tinfo_t will be returned for the same id, thus saving memory and increasing the speed Please note that retrieving the STI_SIZE_T or STI_SSIZE_T stock type, will also have the side-effect of adding that type to the 'idati' TIL, under the well-known name 'size_t' or 'ssize_t' (respectively). The same is valid for STI_COMPLEX64 and STI_COMPLEX64 stock types with names 'complex64_t' and 'complex128_t' (respectively). 
              



   .. py:method:: convert_array_to_ptr() -> bool

      Convert an array into a pointer. type[] => type * 
              



   .. py:method:: remove_ptr_or_array() -> bool

      Replace the current type with the ptr obj or array element. This function performs one of the following conversions:
      * type[] => type
      * type* => type If the conversion is performed successfully, return true 


              



   .. py:method:: read_bitfield_value(v: uint64, bitoff: int) -> uint64


   .. py:method:: write_bitfield_value(dst: uint64, v: uint64, bitoff: int) -> uint64


   .. py:method:: get_modifiers() -> type_t


   .. py:method:: set_modifiers(mod: type_t) -> None


   .. py:method:: set_const() -> None


   .. py:method:: set_volatile() -> None


   .. py:method:: clr_decl_const_volatile() -> None


   .. py:method:: clr_const() -> bool


   .. py:method:: clr_volatile() -> bool


   .. py:method:: clr_const_volatile() -> bool


   .. py:method:: set_type_alignment(declalign: uchar, etf_flags: uint = 0) -> tinfo_code_t

      Set type alignment.



   .. py:method:: set_declalign(declalign: uchar) -> bool


   .. py:method:: change_sign(sign: type_sign_t) -> bool

      Change the type sign. Works only for the types that may have sign.



   .. py:method:: calc_udt_aligns(sudt_flags: int = 4) -> bool

      Calculate the udt alignments using the field offsets/sizes and the total udt size This function does not work on typerefs 
              



   .. py:method:: set_methods(methods: udtmembervec_t) -> bool

      BT_COMPLEX: set the list of member functions. This function consumes 'methods' (makes it empty). 
              
      :returns: false if this type is not a udt, or if the given list is empty



   .. py:method:: set_type_cmt(cmt: str, is_regcmt: bool = False, etf_flags: uint = 0) -> tinfo_code_t

      Set type comment This function works only for non-trivial types 
              



   .. py:method:: get_alias_target() -> int

      Get type alias If the type has no alias, return 0. 
              



   .. py:method:: is_aliased() -> bool


   .. py:method:: set_type_alias(dest_ord: int) -> bool

      Set type alias Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all references to srctype by dsttype. 
              



   .. py:method:: set_udt_alignment(sda: int, etf_flags: uint = 0) -> tinfo_code_t

      Set declared structure alignment (sda) This alignment supersedes the alignment returned by get_declalign() and is really used when calculating the struct layout. However, the effective structure alignment may differ from `sda` because of packing. The type editing functions (they accept etf_flags) may overwrite this attribute. 
              



   .. py:method:: set_udt_pack(pack: int, etf_flags: uint = 0) -> tinfo_code_t

      Set structure packing. The value controls how little a structure member alignment can be. Example: if pack=1, then it is possible to align a double to a byte. __attribute__((aligned(1))) double x; However, if pack=3, a double will be aligned to 8 (2**3) even if requested to be aligned to a byte. pack==0 will have the same effect. The type editing functions (they accept etf_flags) may overwrite this attribute. 
              



   .. py:method:: get_udm_tid(idx: size_t) -> tid_t

      Get udt member TID 
              
      :param idx: the index of udt the member
      :returns: tid or BADADDR The tid is used to collect xrefs to the member, it can be passed to xref-related functions instead of the address.



   .. py:method:: add_udm(*args)

      Add a member to the current structure/union.

      When creating a new structure/union from scratch, you might
      want to first call `create_udt()`

      This method has the following signatures:

          1. add_udm(udm: udm_t, etf_flags: int = 0, times: int = 1, idx: int = -1)
          2. add_udm(name: str, type: type_t | tinfo_t | str, offset: int = 0, etf_flags: int = 0, times: int = 1, idx: int = -1)

      In the 2nd form, the 'type' descriptor, can be one of:

      * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
      * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
      * str: a C type declaration

      If an input argument is incorrect, the constructor may raise an exception

      :param udm:       The member, fully initialized (1st form)
      :param name:      Member name - must not be empty
      :param type:      Member type
      :param offset:    the member offset in bits. It is the caller's responsibility
                        to specify correct offsets.
      :param etf_flags: an OR'ed combination of ETF_ flags
      :param times:     how many times to add the new member
      :param idx:       the index in the udm array where the new udm should be placed.
                        If the specified index cannot be honored because it would spoil
                        the udm sorting order, it is silently ignored.



   .. py:method:: del_udm(index: size_t, etf_flags: uint = 0) -> tinfo_code_t

      Delete a structure/union member.



   .. py:method:: del_udms(idx1: size_t, idx2: size_t, etf_flags: uint = 0) -> tinfo_code_t

      Delete structure/union members in the range [idx1, idx2)



   .. py:method:: rename_udm(index: size_t, name: str, etf_flags: uint = 0) -> tinfo_code_t

      Rename a structure/union member. The new name must be unique. 
              



   .. py:method:: set_udm_type(index: size_t, tif: tinfo_t, etf_flags: uint = 0, repr: value_repr_t = None) -> tinfo_code_t

      Set type of a structure/union member. 
              
      :param index: member index in the udm array
      :param tif: new type for the member
      :param etf_flags: etf_flag_t
      :param repr: new representation for the member (optional)
      :returns: tinfo_code_t



   .. py:method:: set_udm_cmt(index: size_t, cmt: str, is_regcmt: bool = False, etf_flags: uint = 0) -> tinfo_code_t

      Set a comment for a structure/union member. A member may have just one comment, and it is either repeatable or regular. 
              



   .. py:method:: set_udm_repr(index: size_t, repr: value_repr_t, etf_flags: uint = 0) -> tinfo_code_t

      Set the representation of a structure/union member.



   .. py:method:: is_udm_by_til(idx: size_t) -> bool

      Was the member created due to the type system 
              
      :param idx: index of the member



   .. py:method:: set_udm_by_til(idx: size_t, on: bool = True, etf_flags: uint = 0) -> tinfo_code_t

      The member is created due to the type system 
              
      :param idx: index of the member
      :param etf_flags: etf_flag_t



   .. py:method:: set_fixed_struct(on: bool = True) -> tinfo_code_t

      Declare struct member offsets as fixed. For such structures, IDA will not recalculate the member offsets. If a member does not fit into its place anymore, it will be deleted. This function works only with structures (not unions). 
              



   .. py:method:: set_struct_size(new_size: size_t) -> tinfo_code_t

      Explicitly specify the struct size. This function works only with fixed structures. The new struct size can be equal or higher the unpadded struct size (IOW, all existing members should fit into the specified size). 
              
      :param new_size: new structure size in bytes



   .. py:method:: expand_udt(idx: size_t, delta: adiff_t, etf_flags: uint = 0) -> tinfo_code_t

      Expand/shrink a structure by adding/removing a gap before the specified member.
      For regular structures, either the gap can be accommodated by aligning the next member with an alignment directive, or an explicit "gap" member will be inserted. Also note that it is impossible to add a gap at the end of a regular structure.
      When it comes to fixed-layout structures, there is no need to either add new "gap" members or align existing members, since all members have a fixed offset. It is possible to add a gap at the end of a fixed-layout structure, by passing `-1` as index.

      :param idx: index of the member
      :param delta: number of bytes to add or remove
      :param etf_flags: etf_flag_t



   .. py:method:: set_tuple(on: bool = True) -> tinfo_code_t

      Declare struct as a tuple. Currently, tuples in IDA behave the same way as structures but they are returned in a different manner from functions. Also, 2 different tuples having the same members are considered to be equal. This function works only with structures (not unions). 
              



   .. py:method:: get_func_frame(pfn: func_t const *) -> bool

      Create a tinfo_t object for the function frame 
              
      :param pfn: function



   .. py:method:: is_frame() -> bool

      Is a function frame?



   .. py:method:: get_frame_func() -> ida_idaapi.ea_t

      Get function address for the frame.



   .. py:method:: set_enum_width(nbytes: int, etf_flags: uint = 0) -> tinfo_code_t

      Set the width of enum base type 
              
      :param nbytes: width of enum base type, allowed values: 0 (unspecified),1,2,4,8,16,32,64
      :param etf_flags: etf_flag_t



   .. py:method:: set_enum_sign(sign: type_sign_t, etf_flags: uint = 0) -> tinfo_code_t

      Set enum sign 
              
      :param sign: type_sign_t
      :param etf_flags: etf_flag_t



   .. py:attribute:: ENUMBM_OFF

      convert to ordinal enum



   .. py:attribute:: ENUMBM_ON

      convert to bitmask enum



   .. py:attribute:: ENUMBM_AUTO

      convert to bitmask if the outcome is nice and useful



   .. py:method:: set_enum_is_bitmask(*args) -> tinfo_code_t


   .. py:method:: set_enum_repr(repr: value_repr_t, etf_flags: uint = 0) -> tinfo_code_t

      Set the representation of enum members. 
              
      :param repr: value_repr_t
      :param etf_flags: etf_flag_t



   .. py:method:: set_enum_radix(radix: int, sign: bool, etf_flags: uint = 0) -> tinfo_code_t

      Set enum radix to display constants 
              
      :param radix: radix 2, 4, 8, 16, with the special case 1 to display as character
      :param sign: display as signed or unsigned
      :param etf_flags: etf_flag_t



   .. py:method:: add_edm(*args)

      Add an enumerator to the current enumeration.

      When creating a new enumeration from scratch, you might
      want to first call `create_enum()`

      This method has the following signatures:

          1. add_edm(edm: edm_t, bmask: int = -1, etf_flags: int = 0, idx: int = -1)
          2. add_edm(name: str, value: int, bmask: int = -1, etf_flags: int = 0, idx: int = -1)

      If an input argument is incorrect, the constructor may raise an exception

      :param edm:       The member, fully initialized (1st form)
      :param name:      Enumerator name - must not be empty
      :param value:     Enumerator value
      :param bmask:     A bitmask to which the enumerator belongs
      :param etf_flags: an OR'ed combination of ETF_ flags
      :param idx:       the index in the edm array where the new udm should be placed.
                        If the specified index cannot be honored because it would spoil
                        the edm sorting order, it is silently ignored.



   .. py:method:: del_edms(idx1: size_t, idx2: size_t, etf_flags: uint = 0) -> tinfo_code_t

      Delete enum members 
              
      :param idx1: index in edmvec_t
      :param idx2: index in edmvec_t or size_t(-1)
      :param etf_flags: etf_flag_t Delete enum members in [idx1, idx2)



   .. py:method:: del_edm(*args)

      Delete an enumerator with the specified name
      or the specified index, in the specified tinfo_t object.

      This method has the following signatures:

          1. del_edm(name: str) -> int
          2. del_edm(index: int) -> int

      :param name: an enumerator name (1st form)
      :param index: an enumerator index (2nd form)
      :returns: TERR_OK in case of success, or another TERR_* value in case of error



   .. py:method:: del_edm_by_value(value: int, etf_flags: int = 0, bmask: int = DEFMASK64, serial: int = 0)

      Delete an enumerator with the specified value,
      in the specified tinfo_t object.

      :param value: the enumerator value
      :returns: TERR_OK in case of success, or another TERR_* value in case of error



   .. py:method:: rename_edm(idx: size_t, name: str, etf_flags: uint = 0) -> tinfo_code_t

      Rename a enum member 
              
      :param idx: index in edmvec_t
      :param name: new name
      :param etf_flags: etf_flag_t ETF_FORCENAME may be used in case of TERR_ALIEN_NAME



   .. py:method:: set_edm_cmt(idx: size_t, cmt: str, etf_flags: uint = 0) -> tinfo_code_t

      Set a comment for an enum member. Such comments are always considered as repeatable. 
              
      :param idx: index in edmvec_t
      :param cmt: comment
      :param etf_flags: etf_flag_t



   .. py:method:: edit_edm(*args) -> tinfo_code_t

      Change constant value and/or bitmask 
              
      :param idx: index in edmvec_t
      :param value: old or new value
      :param bmask: old or new bitmask
      :param etf_flags: etf_flag_t



   .. py:method:: rename_funcarg(index: size_t, name: str, etf_flags: uint = 0) -> tinfo_code_t

      Rename a function argument. The new name must be unique. 
              
      :param index: argument index in the function array
      :param name: new name
      :param etf_flags: etf_flag_t



   .. py:method:: set_funcarg_type(index: size_t, tif: tinfo_t, etf_flags: uint = 0) -> tinfo_code_t

      Set type of a function argument. 
              
      :param index: argument index in the function array
      :param tif: new type for the argument
      :param etf_flags: etf_flag_t
      :returns: tinfo_code_t



   .. py:method:: set_func_rettype(tif: tinfo_t, etf_flags: uint = 0) -> tinfo_code_t

      Set function return type . 
              
      :param tif: new type for the return type
      :param etf_flags: etf_flag_t
      :returns: tinfo_code_t



   .. py:method:: del_funcargs(idx1: size_t, idx2: size_t, etf_flags: uint = 0) -> tinfo_code_t

      Delete function arguments 
              
      :param idx1: index in funcargvec_t
      :param idx2: index in funcargvec_t or size_t(-1)
      :param etf_flags: etf_flag_t Delete function arguments in [idx1, idx2)



   .. py:method:: del_funcarg(idx: size_t, etf_flags: uint = 0) -> tinfo_code_t


   .. py:method:: add_funcarg(farg: funcarg_t, etf_flags: uint = 0, idx: ssize_t = -1) -> tinfo_code_t

      Add a function argument. 
              
      :param farg: argument to add
      :param etf_flags: type changing flags flags
      :param idx: the index in the funcarg array where the new funcarg should be placed. if the specified index cannot be honored because it would spoil the funcarg sorting order, it is silently ignored.



   .. py:method:: set_func_cc(cc: callcnv_t, etf_flags: uint = 0) -> tinfo_code_t

      Set function calling convention.



   .. py:method:: set_funcarg_loc(index: size_t, argloc: argloc_t, etf_flags: uint = 0) -> tinfo_code_t

      Set location of a function argument. 
              
      :param index: argument index in the function array
      :param argloc: new location for the argument
      :param etf_flags: etf_flag_t
      :returns: tinfo_code_t



   .. py:method:: set_func_retloc(argloc: argloc_t, etf_flags: uint = 0) -> tinfo_code_t

      Set location of function return value. 
              
      :param argloc: new location for the return value
      :param etf_flags: etf_flag_t
      :returns: tinfo_code_t



   .. py:method:: compare(r: tinfo_t) -> int


   .. py:method:: compare_with(r: tinfo_t, tcflags: int = 0) -> bool

      Compare two types, based on given flags (see tinfo_t comparison flags)



   .. py:method:: equals_to(r: tinfo_t) -> bool


   .. py:method:: is_castable_to(target: tinfo_t) -> bool


   .. py:method:: is_manually_castable_to(target: tinfo_t) -> bool


   .. py:method:: serialize(*args) -> PyObject *

      Serialize tinfo_t object into a type string.



   .. py:method:: deserialize(*args) -> bool

      This function has the following signatures:

          0. deserialize(til: const til_t *, ptype: const type_t **, pfields: const p_list **=nullptr, pfldcmts: const p_list **=nullptr, cmt: str=nullptr) -> bool
          1. deserialize(til: const til_t *, ptype: const qtype *, pfields: const qtype *=nullptr, pfldcmts: const qtype *=nullptr, cmt: str=nullptr) -> bool

      # 0: deserialize(til: const til_t *, ptype: const type_t **, pfields: const p_list **=nullptr, pfldcmts: const p_list **=nullptr, cmt: str=nullptr) -> bool

      Deserialize a type string into a tinfo_t object.


      # 1: deserialize(til: const til_t *, ptype: const qtype *, pfields: const qtype *=nullptr, pfldcmts: const qtype *=nullptr, cmt: str=nullptr) -> bool

      Deserialize a type string into a tinfo_t object.



   .. py:method:: get_stkvar(insn: insn_t const &, x: op_t const, v: int) -> ssize_t

      Retrieve frame tinfo for a stack variable 
              
      :param insn: the instruction
      :param x: reference to instruction operand, may be nullptr
      :param v: immediate value in the operand (usually x.addr)
      :returns: returns the member index, otherwise returns -1. if the function fails, THIS object becomes empty.



   .. py:method:: copy() -> tinfo_t


   .. py:method:: get_attr(key: str, all_attrs: bool = True) -> PyObject *

      Get a type attribute.



   .. py:method:: get_edm(*args) -> Tuple[int, edm_t]

      Retrieve an enumerator with either the specified name
      or the specified index, in the specified tinfo_t object.

      This function has the following signatures:

          1. get_edm(index: int)
          2. get_edm(name: str)

      :param index: an enumerator index (1st form).
      :param name: an enumerator name (2nd form).
      :returns: a tuple (int, edm_t), or (-1, None) if member not found



   .. py:method:: find_edm(*args) -> ssize_t


   .. py:method:: iter_struct()

      Iterate on the members composing this structure.

      Example:

          til = ida_typeinf.get_idati()
          tif = til.get_named_type("my_struc")
          for udm in tif.iter_struct():
              print(f"{udm.name} at bit offset {udm.offset}")

      Will raise an exception if this type is not a structure.

      :returns: a udm_t-producing generator



   .. py:method:: iter_union()

      Iterate on the members composing this union.

      Example:

          til = ida_typeinf.get_idati()
          tif = til.get_named_type("my_union")
          for udm in tif.iter_union():
              print(f"{udm.name}, with type {udm.type}")

      Will raise an exception if this type is not a union.

      :returns: a udm_t-producing generator



   .. py:method:: iter_udt()

      Iterate on the members composing this structure, or union.

      Example:

          til = ida_typeinf.get_idati()
          tif = til.get_named_type("my_type")
          for udm in tif.iter_udt():
              print(f"{udm.name} at bit offset {udm.offset} with type {udm.type}")

      Will raise an exception if this type is not a structure, or union

      :returns: a udm_t-producing generator



   .. py:method:: iter_enum()

      Iterate on the members composing this enumeration.

      Example:

          til = ida_typeinf.get_idati()
          tif = til.get_named_type("my_enum")
          for edm in tif.iter_enum():
              print(f"{edm.name} = {edm.value}")

      Will raise an exception if this type is not an enumeration

      :returns: a edm_t-producing generator



   .. py:method:: iter_func()

      Iterate on the arguments contained in this function prototype

      Example:

          address = ...
          func = ida_funcs.get_func(address)
          func_type = func.prototype
          for arg in func_type.iter_func():
              print(f"{arg.name}, of type {arg.type}")

      Will raise an exception if this type is not a function

      :returns: a funcarg_t-producing generator



   .. py:attribute:: get_edm_by_name


.. py:data:: COMP_MASK

.. py:data:: COMP_UNK

   Unknown.


.. py:data:: COMP_MS

   Visual C++.


.. py:data:: COMP_BC

   Borland C++.


.. py:data:: COMP_WATCOM

   Watcom C++.


.. py:data:: COMP_GNU

   GNU C++.


.. py:data:: COMP_VISAGE

   Visual Age C++.


.. py:data:: COMP_BP

   Delphi.


.. py:data:: COMP_UNSURE

   uncertain compiler id


.. py:data:: BADSIZE

   bad type size


.. py:data:: FIRST_NONTRIVIAL_TYPID

   Denotes the first bit describing a nontrivial type.


.. py:data:: TYPID_ISREF

   Identifies that a type that is a typeref.


.. py:data:: TYPID_SHIFT

   First type detail bit.


.. py:function:: remove_pointer(tif: tinfo_t) -> tinfo_t

   BT_PTR: If the current type is a pointer, return the pointed object. If the current type is not a pointer, return the current type. See also get_ptrarr_object() and get_pointed_object() 
           


.. py:data:: STRMEM_MASK

.. py:data:: STRMEM_OFFSET

   get member by offset
   * in: udm->offset - is a member offset in bits 


           


.. py:data:: STRMEM_INDEX

   get member by number
   * in: udm->offset - is a member number 


           


.. py:data:: STRMEM_AUTO

   get member by offset if struct, or get member by index if union
   * nb: union: index is stored in the udm->offset field!
   * nb: struct: offset is in bytes (not in bits)! 


           


.. py:data:: STRMEM_NAME

   get member by name
   * in: udm->name - the desired member name. 


           


.. py:data:: STRMEM_TYPE

   get member by type.
   * in: udm->type - the desired member type. member types are compared with tinfo_t::equals_to() 


           


.. py:data:: STRMEM_SIZE

   get member by size.
   * in: udm->size - the desired member size. 


           


.. py:data:: STRMEM_MINS

   get smallest member by size.


.. py:data:: STRMEM_MAXS

   get biggest member by size.


.. py:data:: STRMEM_LOWBND

   get member by offset or the next member (lower bound)
   * in: udm->offset - is a member offset in bits 


           


.. py:data:: STRMEM_NEXT

   get next member after the offset
   * in: udm->offset - is a member offset in bits 


           


.. py:data:: STRMEM_VFTABLE

   can be combined with STRMEM_OFFSET, STRMEM_AUTO get vftable instead of the base class 
           


.. py:data:: STRMEM_SKIP_EMPTY

   can be combined with STRMEM_OFFSET, STRMEM_AUTO skip empty members (i.e. having zero size) only last empty member can be returned 
           


.. py:data:: STRMEM_CASTABLE_TO

   can be combined with STRMEM_TYPE: member type must be castable to the specified type 
           


.. py:data:: STRMEM_ANON

   can be combined with STRMEM_NAME: look inside anonymous members too. 
           


.. py:data:: STRMEM_SKIP_GAPS

   can be combined with STRMEM_OFFSET, STRMEM_LOWBND skip gap members 
           


.. py:data:: TCMP_EQUAL

   are types equal?


.. py:data:: TCMP_IGNMODS

   ignore const/volatile modifiers


.. py:data:: TCMP_AUTOCAST

   can t1 be cast into t2 automatically?


.. py:data:: TCMP_MANCAST

   can t1 be cast into t2 manually?


.. py:data:: TCMP_CALL

   can t1 be called with t2 type?


.. py:data:: TCMP_DELPTR

   remove pointer from types before comparing


.. py:data:: TCMP_DECL

   compare declarations without resolving them


.. py:data:: TCMP_ANYBASE

   accept any base class when casting


.. py:data:: TCMP_SKIPTHIS

   skip the first function argument in comparison


.. py:data:: TCMP_DEEP_UDT

   compare udt by member/attributes


.. py:class:: simd_info_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      name of SIMD type (nullptr-undefined)



   .. py:attribute:: tif
      :type:  tinfo_t

      SIMD type (empty-undefined)



   .. py:attribute:: size
      :type:  uint16

      SIMD type size in bytes (0-undefined)



   .. py:attribute:: memtype
      :type:  type_t

      member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32/64/128 BTF_INT - integrals of any size/sign BTF_FLOAT, BTF_DOUBLE BTF_TBYTE - floatings of any size BTF_UNION - union of integral and floating types BTF_UNK - undefined 
              



   .. py:method:: match_pattern(pattern: simd_info_t) -> bool


.. py:function:: guess_func_cc(fti: func_type_data_t, npurged: int, cc_flags: int) -> callcnv_t

   Use func_type_data_t::guess_cc()


.. py:function:: dump_func_type_data(fti: func_type_data_t, praloc_bits: int) -> str

   Use func_type_data_t::dump()


.. py:function:: calc_arglocs(fti: func_type_data_t) -> bool

.. py:function:: calc_varglocs(fti: func_type_data_t, regs: regobjs_t, stkargs: relobj_t, nfixed: int) -> bool

.. py:class:: ptr_type_data_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: obj_type
      :type:  tinfo_t

      pointed object type



   .. py:attribute:: closure
      :type:  tinfo_t

      cannot have both closure and based_ptr_size



   .. py:attribute:: parent
      :type:  tinfo_t

      Parent struct.



   .. py:attribute:: delta
      :type:  int

      Offset from the beginning of the parent struct.



   .. py:attribute:: based_ptr_size
      :type:  uchar


   .. py:attribute:: taptr_bits
      :type:  uchar

      TAH bits.



   .. py:method:: swap(r: ptr_type_data_t) -> None

      Set this = r and r = this.



   .. py:method:: is_code_ptr() -> bool

      Are we pointing to code?



   .. py:method:: is_shifted() -> bool


.. py:class:: array_type_data_t(b: size_t = 0, n: size_t = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: elem_type
      :type:  tinfo_t

      element type



   .. py:attribute:: base
      :type:  int

      array base



   .. py:attribute:: nelems
      :type:  int

      number of elements



   .. py:method:: swap(r: array_type_data_t) -> None

      set this = r and r = this



.. py:class:: funcarg_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: argloc
      :type:  argloc_t

      argument location



   .. py:attribute:: name
      :type:  str

      argument name (may be empty)



   .. py:attribute:: cmt
      :type:  str

      argument comment (may be empty)



   .. py:attribute:: type
      :type:  tinfo_t

      argument type



   .. py:attribute:: flags
      :type:  int

      Function argument property bits 
              



.. py:data:: FAI_HIDDEN

   hidden argument


.. py:data:: FAI_RETPTR

   pointer to return value. implies hidden


.. py:data:: FAI_STRUCT

   was initially a structure


.. py:data:: FAI_ARRAY

   was initially an array; see "__org_typedef" or "__org_arrdim" type attributes to determine the original type 
           


.. py:data:: FAI_UNUSED

   argument is not used by the function


.. py:class:: func_type_data_t

   Bases: :py:obj:`funcargvec_t`


   .. py:attribute:: thisown


   .. py:attribute:: flags
      :type:  int

      Function type data property bits 
              



   .. py:attribute:: rettype
      :type:  tinfo_t

      return type



   .. py:attribute:: retloc
      :type:  argloc_t

      return location



   .. py:attribute:: stkargs
      :type:  int

      size of stack arguments (not used in build_func_type)



   .. py:attribute:: spoiled
      :type:  reginfovec_t

      spoiled register information. if spoiled register info is present, it overrides the standard spoil info (eax, edx, ecx for x86) 
              



   .. py:method:: get_explicit_cc() -> callcnv_t


   .. py:method:: set_cc(cc: callcnv_t) -> None


   .. py:method:: swap(r: func_type_data_t) -> None


   .. py:method:: is_high() -> bool


   .. py:method:: is_noret() -> bool


   .. py:method:: is_pure() -> bool


   .. py:method:: is_static() -> bool


   .. py:method:: is_virtual() -> bool


   .. py:method:: is_const() -> bool


   .. py:method:: is_ctor() -> bool


   .. py:method:: is_dtor() -> bool


   .. py:method:: get_call_method() -> int


   .. py:method:: is_vararg_cc() -> bool


   .. py:method:: is_golang_cc() -> bool


   .. py:method:: is_swift_cc() -> bool


   .. py:method:: is_user_cc() -> bool


   .. py:method:: guess_cc(purged: int, cc_flags: int) -> callcnv_t

      Guess function calling convention use the following info: argument locations and 'stkargs' 
              



   .. py:method:: dump(praloc_bits: int = 2) -> bool

      Dump information that is not always visible in the function prototype. (argument locations, return location, total stkarg size) 
              



   .. py:method:: find_argument(*args) -> ssize_t

      find argument by name



.. py:data:: FTI_SPOILED

   information about spoiled registers is present


.. py:data:: FTI_NORET

   noreturn


.. py:data:: FTI_PURE

   __pure


.. py:data:: FTI_HIGH

   high level prototype (with possibly hidden args)


.. py:data:: FTI_STATIC

   static


.. py:data:: FTI_VIRTUAL

   virtual


.. py:data:: FTI_CALLTYPE

   mask for FTI_*CALL


.. py:data:: FTI_DEFCALL

   default call


.. py:data:: FTI_NEARCALL

   near call


.. py:data:: FTI_FARCALL

   far call


.. py:data:: FTI_INTCALL

   interrupt call


.. py:data:: FTI_ARGLOCS

   info about argument locations has been calculated (stkargs and retloc too) 
           


.. py:data:: FTI_EXPLOCS

   all arglocs are specified explicitly


.. py:data:: FTI_CONST

   const member function


.. py:data:: FTI_CTOR

   constructor


.. py:data:: FTI_DTOR

   destructor


.. py:data:: FTI_ALL

   all defined bits


.. py:data:: CC_CDECL_OK

   can use __cdecl calling convention?


.. py:data:: CC_ALLOW_ARGPERM

   disregard argument order?


.. py:data:: CC_ALLOW_REGHOLES

   allow holes in register argument list?


.. py:data:: CC_HAS_ELLIPSIS

   function has a variable list of arguments?


.. py:data:: CC_GOLANG_OK

   can use __golang calling convention 
           


.. py:data:: FMTFUNC_PRINTF

.. py:data:: FMTFUNC_SCANF

.. py:data:: FMTFUNC_STRFTIME

.. py:data:: FMTFUNC_STRFMON

.. py:class:: edm_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: cmt
      :type:  str


   .. py:attribute:: value
      :type:  uint64


   .. py:method:: empty() -> bool


   .. py:method:: swap(r: edm_t) -> None


   .. py:method:: get_tid() -> tid_t


.. py:class:: enum_type_data_t(*args)

   Bases: :py:obj:`edmvec_t`


   .. py:attribute:: thisown


   .. py:attribute:: group_sizes
      :type:  intvec_t

      if present, specifies bitmask group sizes each non-trivial group starts with a mask member 
              



   .. py:attribute:: taenum_bits
      :type:  int

      Type attributes for enums



   .. py:attribute:: bte
      :type:  bte_t

      enum member sizes (shift amount) and style. do not manually set BTE_BITMASK, use set_enum_is_bitmask() 
              



   .. py:method:: get_enum_radix() -> int

      Get enum constant radix 
              
      :returns: radix or 1 for BTE_CHAR



   .. py:method:: is_number_signed() -> bool


   .. py:method:: set_enum_radix(radix: int, sign: bool) -> None

      Set radix to display constants 
              
      :param radix: radix with the special case 1 to display as character



   .. py:method:: is_char() -> bool


   .. py:method:: is_dec() -> bool


   .. py:method:: is_hex() -> bool


   .. py:method:: is_oct() -> bool


   .. py:method:: is_bin() -> bool


   .. py:method:: is_udec() -> bool


   .. py:method:: is_shex() -> bool


   .. py:method:: is_soct() -> bool


   .. py:method:: is_sbin() -> bool


   .. py:method:: has_lzero() -> bool


   .. py:method:: set_lzero(on: bool) -> None


   .. py:method:: calc_mask() -> uint64


   .. py:method:: store_64bit_values() -> bool


   .. py:method:: is_bf() -> bool

      is bitmask or ordinary enum?



   .. py:method:: calc_nbytes() -> int

      get the width of enum in bytes



   .. py:method:: set_nbytes(nbytes: int) -> bool

      set enum width (nbytes)



   .. py:method:: is_group_mask_at(idx: size_t) -> bool

      is the enum member at IDX a non-trivial group mask? a trivial group consist of one bit and has just one member, which can be considered as a mask or a bitfield constant 
              
      :param idx: index
      :returns: success



   .. py:method:: is_valid_group_sizes() -> bool

      is valid group sizes



   .. py:method:: find_member(*args) -> ssize_t

      This function has the following signatures:

          0. find_member(name: str, from: size_t=0, to: size_t=size_t(-1)) -> ssize_t
          1. find_member(value: uint64, serial: uchar, from: size_t=0, to: size_t=size_t(-1), vmask: uint64=uint64(-1)) -> ssize_t

      # 0: find_member(name: str, from: size_t=0, to: size_t=size_t(-1)) -> ssize_t

      find member (constant or bmask) by name


      # 1: find_member(value: uint64, serial: uchar, from: size_t=0, to: size_t=size_t(-1), vmask: uint64=uint64(-1)) -> ssize_t

      find member (constant or bmask) by value



   .. py:method:: swap(r: enum_type_data_t) -> None

      swap two instances



   .. py:method:: add_constant(name: str, value: uint64, cmt: str = None) -> None

      add constant for regular enum



   .. py:method:: get_value_repr(repr: value_repr_t) -> tinfo_code_t

      get enum radix and other representation info 
              
      :param repr: value display info



   .. py:method:: set_value_repr(repr: value_repr_t) -> tinfo_code_t

      set enum radix and other representation info 
              
      :param repr: value display info



   .. py:method:: get_serial(index: size_t) -> uchar

      returns serial for the constant



   .. py:method:: get_max_serial(value: uint64) -> uchar

      return the maximum serial for the value



   .. py:method:: get_constant_group(*args) -> PyObject *

      get group parameters for the constant, valid for bitmask enum 
              
      :param group_start_index: index of the group mask
      :param group_size: group size (>=1)
      :param idx: constant index
      :returns: success



   .. py:method:: all_groups(skip_trivial=False)

      Generate tuples for bitmask enum groups.
      Each tupple is:
      [0] enum member index of group start
      [1] group size
      Tupples may include or not the group with 1 element.



   .. py:method:: all_constants()

      Generate tupples of all constants except of bitmasks.
      Each tupple is:
      [0] constant index
      [1] enum member index of group start
      [2] group size
      In case of regular enum the second element of tupple is 0 and the third element of tupple is the number of enum members.



.. py:class:: typedef_type_data_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: til
      :type:  til_t const *

      type library to use when resolving



   .. py:attribute:: name
      :type:  str

      is_ordref=false: target type name. we do not own this pointer!



   .. py:attribute:: ordinal
      :type:  int

      is_ordref=true: type ordinal number



   .. py:attribute:: is_ordref
      :type:  bool

      is reference by ordinal?



   .. py:attribute:: resolve
      :type:  bool

      should resolve immediately?



   .. py:method:: swap(r: typedef_type_data_t) -> None


.. py:data:: MAX_ENUM_SERIAL

   Max number of identical constants allowed for one enum type.


.. py:class:: custom_data_type_info_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: dtid
      :type:  int16

      data type id



   .. py:attribute:: fid
      :type:  int16

      data format ids



.. py:class:: value_repr_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: bits
      :type:  uint64


   .. py:attribute:: ri
      :type:  refinfo_t

      FRB_OFFSET.



   .. py:attribute:: strtype
      :type:  int

      FRB_STRLIT.



   .. py:attribute:: delta
      :type:  adiff_t

      FRB_STROFF.



   .. py:attribute:: type_ordinal
      :type:  int

      FRB_STROFF, FRB_ENUM.



   .. py:attribute:: cd
      :type:  custom_data_type_info_t

      FRB_CUSTOM.



   .. py:attribute:: ap
      :type:  array_parameters_t

      FRB_TABFORM, AP_SIGNED is ignored, use FRB_SIGNED instead 
              



   .. py:method:: swap(r: value_repr_t) -> None


   .. py:method:: clear() -> None


   .. py:method:: empty() -> bool


   .. py:method:: is_enum() -> bool


   .. py:method:: is_offset() -> bool


   .. py:method:: is_strlit() -> bool


   .. py:method:: is_custom() -> bool


   .. py:method:: is_stroff() -> bool


   .. py:method:: is_typref() -> bool


   .. py:method:: is_signed() -> bool


   .. py:method:: has_tabform() -> bool


   .. py:method:: has_lzeroes() -> bool


   .. py:method:: get_vtype() -> uint64


   .. py:method:: set_vtype(vt: uint64) -> None


   .. py:method:: set_signed(on: bool) -> None


   .. py:method:: set_tabform(on: bool) -> None


   .. py:method:: set_lzeroes(on: bool) -> None


   .. py:method:: set_ap(_ap: array_parameters_t) -> None


   .. py:method:: init_ap(_ap: array_parameters_t) -> None


   .. py:method:: from_opinfo(flags: flags64_t, afl: aflags_t, opinfo: opinfo_t, _ap: array_parameters_t) -> bool


   .. py:method:: parse_value_repr(*args) -> bool


.. py:data:: FRB_MASK

   Mask for the value type (* means requires additional info):


.. py:data:: FRB_UNK

   Unknown.


.. py:data:: FRB_NUMB

   Binary number.


.. py:data:: FRB_NUMO

   Octal number.


.. py:data:: FRB_NUMH

   Hexadecimal number.


.. py:data:: FRB_NUMD

   Decimal number.


.. py:data:: FRB_FLOAT

   Floating point number (for interpreting an integer type as a floating value) 
           


.. py:data:: FRB_CHAR

   Char.


.. py:data:: FRB_SEG

   Segment.


.. py:data:: FRB_ENUM

   *Enumeration


.. py:data:: FRB_OFFSET

   *Offset


.. py:data:: FRB_STRLIT

   *String literal (used for arrays)


.. py:data:: FRB_STROFF

   *Struct offset


.. py:data:: FRB_CUSTOM

   *Custom data type


.. py:data:: FRB_INVSIGN

   Invert sign (0x01 is represented as -0xFF)


.. py:data:: FRB_INVBITS

   Invert bits (0x01 is represented as ~0xFE)


.. py:data:: FRB_SIGNED

   Force signed representation.


.. py:data:: FRB_LZERO

   Toggle leading zeroes (used for integers)


.. py:data:: FRB_TABFORM

   has additional tabular parameters 
           


.. py:class:: udm_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: offset
      :type:  uint64

      member offset in bits



   .. py:attribute:: size
      :type:  uint64

      size in bits



   .. py:attribute:: name
      :type:  str

      member name



   .. py:attribute:: cmt
      :type:  str

      member comment



   .. py:attribute:: type
      :type:  tinfo_t

      member type



   .. py:attribute:: repr
      :type:  value_repr_t

      radix, refinfo, strpath, custom_id, strtype



   .. py:attribute:: effalign
      :type:  int

      effective field alignment (in bytes)



   .. py:attribute:: tafld_bits
      :type:  int

      TAH bits.



   .. py:attribute:: fda
      :type:  uchar

      field alignment (shift amount)



   .. py:method:: empty() -> bool


   .. py:method:: is_bitfield() -> bool


   .. py:method:: is_zero_bitfield() -> bool


   .. py:method:: is_unaligned() -> bool


   .. py:method:: is_baseclass() -> bool


   .. py:method:: is_virtbase() -> bool


   .. py:method:: is_vftable() -> bool


   .. py:method:: is_method() -> bool


   .. py:method:: is_gap() -> bool


   .. py:method:: is_regcmt() -> bool


   .. py:method:: is_retaddr() -> bool


   .. py:method:: is_savregs() -> bool


   .. py:method:: is_special_member() -> bool


   .. py:method:: is_by_til() -> bool


   .. py:method:: set_unaligned(on: bool = True) -> None


   .. py:method:: set_baseclass(on: bool = True) -> None


   .. py:method:: set_virtbase(on: bool = True) -> None


   .. py:method:: set_vftable(on: bool = True) -> None


   .. py:method:: set_method(on: bool = True) -> None


   .. py:method:: set_regcmt(on: bool = True) -> None


   .. py:method:: set_retaddr(on: bool = True) -> None


   .. py:method:: set_savregs(on: bool = True) -> None


   .. py:method:: set_by_til(on: bool = True) -> None


   .. py:method:: clr_unaligned() -> None


   .. py:method:: clr_baseclass() -> None


   .. py:method:: clr_virtbase() -> None


   .. py:method:: clr_vftable() -> None


   .. py:method:: clr_method() -> None


   .. py:method:: begin() -> uint64


   .. py:method:: end() -> uint64


   .. py:method:: compare_with(r: udm_t, tcflags: int) -> bool


   .. py:method:: swap(r: udm_t) -> None


   .. py:method:: is_anonymous_udm() -> bool


   .. py:method:: set_value_repr(r: value_repr_t) -> None


   .. py:method:: can_be_dtor() -> bool


   .. py:method:: can_rename() -> bool


.. py:class:: udtmembervec_t

   Bases: :py:obj:`udtmembervec_template_t`


   .. py:attribute:: thisown


.. py:class:: udt_type_data_t

   Bases: :py:obj:`udtmembervec_t`


   .. py:attribute:: thisown


   .. py:attribute:: total_size
      :type:  size_t

      total structure size in bytes



   .. py:attribute:: unpadded_size
      :type:  size_t

      unpadded structure size in bytes



   .. py:attribute:: effalign
      :type:  int

      effective structure alignment (in bytes)



   .. py:attribute:: taudt_bits
      :type:  int

      TA... and TAUDT... bits.



   .. py:attribute:: version
      :type:  uchar

      version of udt_type_data_t



   .. py:attribute:: sda
      :type:  uchar

      declared structure alignment (shift amount+1). 0 - unspecified



   .. py:attribute:: pack
      :type:  uchar

      #pragma pack() alignment (shift amount)



   .. py:attribute:: is_union
      :type:  bool

      is union or struct?



   .. py:method:: swap(r: udt_type_data_t) -> None


   .. py:method:: is_unaligned() -> bool


   .. py:method:: is_msstruct() -> bool


   .. py:method:: is_cppobj() -> bool


   .. py:method:: is_vftable() -> bool


   .. py:method:: is_fixed() -> bool


   .. py:method:: is_tuple() -> bool


   .. py:method:: set_vftable(on: bool = True) -> None


   .. py:method:: set_fixed(on: bool = True) -> None


   .. py:method:: set_tuple(on: bool = True) -> None


   .. py:method:: is_last_baseclass(idx: size_t) -> bool


   .. py:method:: add_member(_name: str, _type: tinfo_t, _offset: uint64 = 0) -> udm_t &

      Add a new member to a structure or union. This function just pushes a new member to the back of the structure/union member vector.

      :param _name: Member name. Must not be nullptr.
      :param _type: Member type. Must not be empty.
      :param _offset: Member offset in bits. It is the caller's responsibility to specify correct offsets.
      :returns: { Reference to the newly added member }



   .. py:method:: find_member(*args) -> ssize_t

      This function has the following signatures:

          0. find_member(pattern_udm: udm_t *, strmem_flags: int) -> ssize_t
          1. find_member(name: str) -> ssize_t
          2. find_member(bit_offset: uint64) -> ssize_t

      # 0: find_member(pattern_udm: udm_t *, strmem_flags: int) -> ssize_t

      tinfo_t::find_udm 
              
      :returns: the index of the found member or -1

      # 1: find_member(name: str) -> ssize_t


      # 2: find_member(bit_offset: uint64) -> ssize_t



   .. py:method:: get_best_fit_member(disp)

      Get the member that is most likely referenced by the specified offset.

      :param disp: the byte offset
      :returns: a tuple (int, udm_t), or (-1, None) if member not found



.. py:data:: STRUC_SEPARATOR

   structname.fieldname


.. py:data:: VTBL_SUFFIX

.. py:data:: VTBL_MEMNAME

.. py:function:: stroff_as_size(plen: int, tif: tinfo_t, value: asize_t) -> bool

   Should display a structure offset expression as the structure size?


.. py:class:: udm_visitor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: visit_udm(tid: tid_t, tif: tinfo_t, udt: udt_type_data_t, idx: ssize_t) -> int

      :param tid: udt tid
      :param tif: udt type info (may be nullptr for corrupted idbs)
      :param udt: udt type data (may be nullptr for corrupted idbs)
      :param idx: the index of udt the member (may be -1 if udm was not found)



.. py:function:: visit_stroff_udms(sfv: udm_visitor_t, path: tid_t const *, disp: adiff_t *, appzero: bool) -> adiff_t *

   Visit structure fields in a stroff expression or in a reference to a struct data variable. This function can be used to enumerate all components of an expression like 'a.b.c'. 
           
   :param sfv: visitor object
   :param path: struct path (path[0] contains the initial struct id)
   :param disp: offset into structure
   :param appzero: should visit field at offset zero?
   :returns: visitor result


.. py:class:: bitfield_type_data_t(_nbytes: uchar = 0, _width: uchar = 0, _is_unsigned: bool = False)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: nbytes
      :type:  uchar

      enclosing type size (1,2,4,8 bytes)



   .. py:attribute:: width
      :type:  uchar

      number of bits



   .. py:attribute:: is_unsigned
      :type:  bool

      is bitfield unsigned?



   .. py:method:: compare(r: bitfield_type_data_t) -> int


   .. py:method:: swap(r: bitfield_type_data_t) -> None


   .. py:method:: is_valid_bitfield() -> bool


.. py:data:: TPOS_LNNUM

.. py:data:: TPOS_REGCMT

.. py:function:: is_one_bit_mask(mask: int) -> bool

   Is bitmask one bit?


.. py:function:: inf_pack_stkargs(*args) -> bool

.. py:function:: inf_big_arg_align(*args) -> bool

.. py:function:: inf_huge_arg_align(*args) -> bool

.. py:class:: type_mods_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: type
      :type:  tinfo_t

      current type



   .. py:attribute:: name
      :type:  str

      current type name



   .. py:attribute:: cmt
      :type:  str

      comment for current type



   .. py:attribute:: flags
      :type:  int

      Type modification bits 
              



   .. py:method:: clear() -> None


   .. py:method:: set_new_type(t: tinfo_t) -> None

      The visit_type() function may optionally save the modified type info. Use the following functions for that. The new name and comment will be applied only if the current tinfo element has storage for them. 
              



   .. py:method:: set_new_name(n: str) -> None


   .. py:method:: set_new_cmt(c: str, rptcmt: bool) -> None


   .. py:method:: has_type() -> bool


   .. py:method:: has_name() -> bool


   .. py:method:: has_cmt() -> bool


   .. py:method:: is_rptcmt() -> bool


   .. py:method:: has_info() -> bool


.. py:data:: TVIS_TYPE

   new type info is present


.. py:data:: TVIS_NAME

   new name is present (only for funcargs and udt members)


.. py:data:: TVIS_CMT

   new comment is present (only for udt members)


.. py:data:: TVIS_RPTCMT

   the new comment is repeatable


.. py:class:: tinfo_visitor_t(s: int = 0)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: state
      :type:  int

      tinfo visitor states 
              



   .. py:method:: visit_type(out: type_mods_t, tif: tinfo_t, name: str, cmt: str) -> int

      Visit a subtype. this function must be implemented in the derived class. it may optionally fill out with the new type info. this can be used to modify types (in this case the 'out' argument of apply_to() may not be nullptr) return 0 to continue the traversal. return !=0 to stop the traversal. 
              



   .. py:method:: prune_now() -> None

      To refuse to visit children of the current type, use this:



   .. py:method:: apply_to(tif: tinfo_t, out: type_mods_t = None, name: str = None, cmt: str = None) -> int

      Call this function to initiate the traversal.



.. py:data:: TVST_PRUNE

   don't visit children of current type


.. py:data:: TVST_DEF

   visit type definition (meaningful for typerefs)


.. py:data:: TVST_LEVEL

.. py:class:: regobj_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: regidx
      :type:  int

      index into dbg->registers



   .. py:attribute:: relocate
      :type:  int

      0-plain num, 1-must relocate



   .. py:attribute:: value
      :type:  bytevec_t


   .. py:method:: size() -> size_t


.. py:class:: regobjs_t

   Bases: :py:obj:`regobjvec_t`


   .. py:attribute:: thisown


.. py:function:: unpack_idcobj_from_idb(obj: idc_value_t *, tif: tinfo_t, ea: ida_idaapi.ea_t, off0: bytevec_t const *, pio_flags: int = 0) -> error_t

   Collection of register objects.

   Read a typed idc object from the database 
           


.. py:data:: PIO_NOATTR_FAIL

   missing attributes are not ok


.. py:data:: PIO_IGNORE_PTRS

   do not follow pointers


.. py:function:: unpack_idcobj_from_bv(obj: idc_value_t *, tif: tinfo_t, bytes: bytevec_t const &, pio_flags: int = 0) -> error_t

   Read a typed idc object from the byte vector.


.. py:function:: pack_idcobj_to_idb(obj: idc_value_t const *, tif: tinfo_t, ea: ida_idaapi.ea_t, pio_flags: int = 0) -> error_t

   Write a typed idc object to the database.


.. py:function:: pack_idcobj_to_bv(obj: idc_value_t const *, tif: tinfo_t, bytes: relobj_t, objoff: void *, pio_flags: int = 0) -> error_t

   Write a typed idc object to the byte vector. Byte vector may be non-empty, this function will append data to it 
           


.. py:function:: apply_tinfo_to_stkarg(insn: insn_t const &, x: op_t const &, v: int, tif: tinfo_t, name: str) -> bool

   Helper function for the processor modules. to be called from processor_t::use_stkarg_type 
           


.. py:class:: argtinfo_helper_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: reserved
      :type:  size_t


   .. py:method:: set_op_tinfo(insn: insn_t const &, x: op_t const &, tif: tinfo_t, name: str) -> bool

      Set the operand type as specified.



   .. py:method:: is_stkarg_load(insn: insn_t const &, src: int *, dst: int *) -> bool

      Is the current insn a stkarg load?. if yes:
      * src: index of the source operand in insn_t::ops
      * dst: index of the destination operand in insn_t::ops insn_t::ops[dst].addr is expected to have the stack offset 


              



   .. py:method:: has_delay_slot(arg0: ida_idaapi.ea_t) -> bool

      The call instruction with a delay slot?.



   .. py:method:: use_arg_tinfos(caller: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t) -> None

      This function is to be called by the processor module in response to ev_use_arg_types. 
              



.. py:function:: gen_use_arg_tinfos(_this: argtinfo_helper_t, caller: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t) -> None

   Do not call this function directly, use argtinfo_helper_t.


.. py:function:: func_has_stkframe_hole(ea: ida_idaapi.ea_t, fti: func_type_data_t) -> bool

   Looks for a hole at the beginning of the stack arguments. Will make use of the IDB's func_t function at that place (if present) to help determine the presence of such a hole. 
           


.. py:class:: lowertype_helper_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: func_has_stkframe_hole(candidate: tinfo_t, candidate_data: func_type_data_t) -> bool


   .. py:method:: get_func_purged_bytes(candidate: tinfo_t, candidate_data: func_type_data_t) -> int


.. py:class:: ida_lowertype_helper_t(_tif: tinfo_t, _ea: ida_idaapi.ea_t, _pb: int)

   Bases: :py:obj:`lowertype_helper_t`


   .. py:attribute:: thisown


   .. py:method:: func_has_stkframe_hole(candidate: tinfo_t, candidate_data: func_type_data_t) -> bool


   .. py:method:: get_func_purged_bytes(candidate: tinfo_t, arg3: func_type_data_t) -> int


.. py:function:: lower_type(til: til_t, tif: tinfo_t, name: str = None, _helper: lowertype_helper_t = None) -> int

   Lower type. Inspect the type and lower all function subtypes using lower_func_type(). 
   We call the prototypes usually encountered in source files "high level" 
   They may have implicit arguments, array arguments, big structure retvals, etc 
   We introduce explicit arguments (i.e. 'this' pointer) and call the result 
   "low level prototype". See FTI_HIGH.
   In order to improve heuristics for recognition of big structure retvals, 
   it is recommended to pass a helper that will be used to make decisions. 
   That helper will be used only for lowering 'tif', and not for the children 
   types walked through by recursion. 
           
   :returns: 1: removed FTI_HIGH,
   :returns: 2: made substantial changes
   :returns: -1: failure


.. py:function:: replace_ordinal_typerefs(til: til_t, tif: tinfo_t) -> int

   Replace references to ordinal types by name references. This function 'unties' the type from the current local type library and makes it easier to export it. 
           
   :param til: type library to use. may be nullptr.
   :param tif: type to modify (in/out)
   :returns: number: of replaced subtypes, -1 on failure


.. py:data:: UTP_ENUM

.. py:data:: UTP_STRUCT

.. py:function:: begin_type_updating(utp: update_type_t) -> None

   Mark the beginning of a large update operation on the types. Can be used with add_enum_member(), add_struc_member, etc... Also see end_type_updating() 
           


.. py:function:: end_type_updating(utp: update_type_t) -> None

   Mark the end of a large update operation on the types (see begin_type_updating())


.. py:function:: get_named_type_tid(name: str) -> tid_t

   Get named local type TID 
           
   :param name: type name
   :returns: TID or BADADDR


.. py:function:: get_tid_name(tid: tid_t) -> str

   Get a type name for the specified TID 
           
   :param tid: type TID
   :returns: true if there is type with TID


.. py:function:: get_tid_ordinal(tid: tid_t) -> int

   Get type ordinal number for TID 
           
   :param tid: type/enum constant/udt member TID
   :returns: type ordinal number or 0


.. py:function:: get_udm_by_fullname(udm: udm_t, fullname: str) -> ssize_t

   Get udt member by full name 
           
   :param udm: member, can be NULL
   :param fullname: udt member name in format <udt name>.<member name>
   :returns: member index into udt_type_data_t or -1


.. py:function:: get_idainfo_by_udm(*args) -> bool

   Calculate IDA info from udt member 
           
   :param udm: udt member
   :param refinfo_ea: if specified will be used to adjust the refinfo_t data


.. py:function:: create_enum_type(enum_name: str, ei: enum_type_data_t, enum_width: int, sign: type_sign_t, convert_to_bitmask: bool, enum_cmt: str = None) -> tid_t

   Create type enum 
           
   :param enum_name: type name
   :param ei: enum type data
   :param enum_width: the width of an enum element allowed values: 0 (unspecified),1,2,4,8,16,32,64
   :param sign: enum sign
   :param convert_to_bitmask: try convert enum to bitmask enum
   :param enum_cmt: enum type comment
   :returns: enum TID


.. py:class:: valstr_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: oneline
      :type:  str

      result if printed on one line in UTF-8 encoding



   .. py:attribute:: length
      :type:  size_t

      length if printed on one line



   .. py:attribute:: members
      :type:  valstrs_t *

      strings for members, each member separately



   .. py:attribute:: info
      :type:  valinfo_t *

      additional info



   .. py:attribute:: props
      :type:  int

      temporary properties, used internally



.. py:data:: VALSTR_OPEN

   printed opening curly brace '{'


.. py:class:: valstrs_t

   Bases: :py:obj:`valstrvec_t`


   .. py:attribute:: thisown


.. py:class:: text_sink_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


.. py:data:: PDF_INCL_DEPS

   Include all type dependencies.


.. py:data:: PDF_DEF_FWD

   Allow forward declarations.


.. py:data:: PDF_DEF_BASE

   Include base types: __int8, __int16, etc..


.. py:data:: PDF_HEADER_CMT

   Prepend output with a descriptive comment.


.. py:function:: calc_number_of_children(loc: argloc_t, tif: tinfo_t, dont_deref_ptr: bool = False) -> int

   Calculate max number of lines of a formatted c data, when expanded (PTV_EXPAND). 
           
   :param loc: location of the data (ALOC_STATIC or ALOC_CUSTOM)
   :param tif: type info
   :param dont_deref_ptr: consider 'ea' as the ptr value
   :returns: 0: data is not expandable
   :returns: -1: error, see qerrno
   :returns: else: the max number of lines


.. py:function:: get_enum_member_expr(tif: tinfo_t, serial: int, value: uint64) -> str

   Return a C expression that can be used to represent an enum member. If the value does not correspond to any single enum member, this function tries to find a bitwise combination of enum members that correspond to it. If more than half of value bits do not match any enum members, it fails. 
           
   :param tif: enumeration type
   :param serial: which enumeration member to use (0 means the first with the given value)
   :param value: value to search in the enumeration type
   :returns: success


.. py:class:: til_symbol_t(n: str = None, t: til_t = None)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: name
      :type:  str

      symbol name



   .. py:attribute:: til
      :type:  til_t const *

      pointer to til



.. py:class:: predicate_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: should_display(til: til_t, name: str, type: type_t const *, fields: p_list const *) -> bool


.. py:function:: choose_named_type(out_sym: til_symbol_t, root_til: til_t, title: str, ntf_flags: int, predicate: predicate_t = None) -> bool

   Choose a type from a type library. 
           
   :param out_sym: pointer to be filled with the chosen type
   :param root_til: pointer to starting til (the function will inspect the base tils if allowed by flags)
   :param title: title of listbox to display
   :param ntf_flags: combination of Flags for named types
   :param predicate: predicate to select types to display (maybe nullptr)
   :returns: false if nothing is chosen, otherwise true


.. py:function:: choose_local_tinfo(ti: til_t, title: str, func: local_tinfo_predicate_t * = None, def_ord: int = 0, ud: void * = None) -> int

   Choose a type from the local type library. 
           
   :param ti: pointer to til
   :param title: title of listbox to display
   :param func: predicate to select types to display (maybe nullptr)
   :param def_ord: ordinal to position cursor before choose
   :param ud: user data
   :returns: == 0 means nothing is chosen, otherwise an ordinal number


.. py:function:: choose_local_tinfo_and_delta(delta: int32 *, ti: til_t, title: str, func: local_tinfo_predicate_t * = None, def_ord: int = 0, ud: void * = None) -> int

   Choose a type from the local type library and specify the pointer shift value. 
           
   :param delta: pointer shift value
   :param ti: pointer to til
   :param title: title of listbox to display
   :param func: predicate to select types to display (maybe nullptr)
   :param def_ord: ordinal to position cursor before choose
   :param ud: user data
   :returns: == 0 means nothing is chosen, otherwise an ordinal number


.. py:function:: calc_retloc(*args) -> bool

   This function has the following signatures:

       0. calc_retloc(fti: func_type_data_t *) -> bool
       1. calc_retloc(retloc: argloc_t *, rettype: const tinfo_t &, cc: callcnv_t) -> bool

   # 0: calc_retloc(fti: func_type_data_t *) -> bool


   # 1: calc_retloc(retloc: argloc_t *, rettype: const tinfo_t &, cc: callcnv_t) -> bool


.. py:class:: til_type_ref_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cb
      :type:  size_t


   .. py:attribute:: tif
      :type:  tinfo_t


   .. py:attribute:: cursor
      :type:  tif_cursor_t


   .. py:attribute:: ordinal
      :type:  int


   .. py:attribute:: is_writable
      :type:  bool


   .. py:attribute:: is_detached
      :type:  bool


   .. py:attribute:: is_forward
      :type:  bool


   .. py:attribute:: kind
      :type:  type_t


   .. py:attribute:: memidx
      :type:  ssize_t


   .. py:attribute:: nmembers
      :type:  size_t


   .. py:attribute:: udm
      :type:  udm_t

      BTF_STRUCT or BTF_UNION: the current member.



   .. py:attribute:: total_size
      :type:  size_t


   .. py:attribute:: unpadded_size
      :type:  size_t


   .. py:attribute:: last_udm_offset
      :type:  uint64


   .. py:attribute:: bucket_start
      :type:  uint64


   .. py:attribute:: bf_bitoff
      :type:  int


   .. py:attribute:: offset
      :type:  uint64


   .. py:attribute:: edm
      :type:  edm_t

      BTF_ENUM: the current enum member.



   .. py:attribute:: fa
      :type:  funcarg_t const *

      BT_FUNC: the current argument, nullptr - ellipsis.



   .. py:method:: clear() -> None


   .. py:method:: on_member() -> bool


   .. py:method:: is_typedef() -> bool


   .. py:method:: is_struct() -> bool


   .. py:method:: is_union() -> bool


   .. py:method:: is_enum() -> bool


   .. py:method:: is_func() -> bool


   .. py:method:: is_udt() -> bool


.. py:function:: register_custom_callcnv(cnv_incref: custom_callcnv_t) -> custom_callcnv_t *

   Register a calling convention 
           
   :returns: CM_CC_INVALID means failure:
   * bad ccinf.name
   * ccinf.name already exists
   * the calling convention is special (usercall, purging, vararg) and there are too many of them already


.. py:function:: unregister_custom_callcnv(cnv_decref: custom_callcnv_t) -> custom_callcnv_t *

   Unregister a calling convention 
           
   :returns: true if successfully unregistered the custom calling convention


.. py:function:: idc_parse_decl(til: til_t, decl: str, flags: int) -> Tuple[str, bytes, bytes]

.. py:function:: calc_type_size(til: til_t, type: bytes)

   Returns the size of a type
   :param til: Type info library. 'None' can be passed.
   :param type: serialized type byte string
   :returns: The size of the type (None on failure)


.. py:function:: apply_type(til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, flags: int) -> bool

   Apply the specified type to the address

   :param til: Type info library. 'None' can be used.
   :param type: type string
   :param fields: fields string (may be empty or None)
   :param ea: the address of the object
   :param flags: combination of TINFO_... constants or 0
   :returns: Boolean


.. py:function:: get_arg_addrs(caller: ida_idaapi.ea_t)

   Retrieve addresses of argument initialization instructions

   :param caller: the address of the call instruction
   :returns: list of instruction addresses


.. py:function:: unpack_object_from_idb(til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, pio_flags: int = 0)

   Unpacks from the database at 'ea' to an object.
   Please refer to unpack_object_from_bv()


.. py:function:: unpack_object_from_bv(til: til_t, type: unpack_object_from_bv.bytes, fields: unpack_object_from_bv.bytes, bytes, pio_flags: int = 0)

   Unpacks a buffer into an object.
   Returns the error_t returned by idaapi.pack_object_to_idb

   :param til: Type library. 'None' can be passed.
   :param type: type string
   :param fields: fields string (may be empty or None)
   :param bytes: the bytes to unpack
   :param pio_flags: flags used while unpacking
   :returns: tuple(1, obj) on success, or tuple(0, err) on failure


.. py:function:: pack_object_to_idb(obj, til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, pio_flags: int = 0)

   Write a typed object to the database.
   Raises an exception if wrong parameters were passed or conversion fails
   Returns the error_t returned by idaapi.pack_object_to_idb

   :param til: Type library. 'None' can be passed.
   :param type: type string
   :param fields: fields string (may be empty or None)
   :param ea: ea to be used while packing
   :param pio_flags: flags used while unpacking


.. py:function:: pack_object_to_bv(obj, til: til_t, type: bytes, fields: bytes, base_ea: ida_idaapi.ea_t, pio_flags: int = 0)

   Packs a typed object to a string

   :param til: Type library. 'None' can be passed.
   :param type: type string
   :param fields: fields string (may be empty or None)
   :param base_ea: base ea used to relocate the pointers in the packed object
   :param pio_flags: flags used while unpacking
   :returns: tuple(1, packed_buf) on success, or tuple(0, err_code) on failure


.. py:data:: PT_FILE

.. py:data:: PT_STANDALONE

.. py:function:: idc_parse_types(input: str, flags: int) -> int

.. py:function:: idc_get_type_raw(ea: ida_idaapi.ea_t) -> PyObject *

.. py:function:: idc_get_local_type_raw(ordinal) -> Tuple[bytes, bytes]

.. py:function:: idc_guess_type(ea: ida_idaapi.ea_t) -> str

.. py:function:: idc_get_type(ea: ida_idaapi.ea_t) -> str

.. py:function:: idc_set_local_type(ordinal: int, dcl: str, flags: int) -> int

.. py:function:: idc_get_local_type(ordinal: int, flags: int) -> str

.. py:function:: idc_print_type(type: bytes, fields: bytes, name: str, flags: int) -> str

.. py:function:: idc_get_local_type_name(ordinal: int) -> str

.. py:function:: get_named_type(til: til_t, name: str, ntf_flags: int)

   Get a type data by its name.

   :param til: Type library
   :param name: the type name
   :param ntf_flags: a combination of NTF_* constants
   :returns: tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success, or None on failure


.. py:function:: get_named_type64(til: til_t, name: str, ntf_flags: int = 0) -> Union[Tuple[int, bytes, bytes, str, str, int, int], None]

   Get a named type from a type library.

   Please use til_t.get_named_type instead.


.. py:function:: print_decls(printer: text_sink_t, til: til_t, ordinals: List[int], flags: int) -> int

   Print types (and possibly their dependencies) in a format suitable for using in
   a header file. This is the reverse parse_decls().

   :param printer: a handler for printing text
   :param til: the type library holding the ordinals
   :param ordinals: a list of ordinals corresponding to the types to print
   :param flags: a combination of PDF_ constants
   :returns:  >0: the number of types exported
   :returns:   0: an error occurred
   :returns:  <0: the negated number of types exported. There were minor errors and
                  the resulting output might not be compilable.


.. py:function:: remove_tinfo_pointer(tif: tinfo_t, name: str, til: til_t) -> Tuple[bool, str]

   Remove pointer of a type. (i.e. convert "char *" into "char"). Optionally remove
   the "lp" (or similar) prefix of the input name. If the input type is not a
   pointer, then fail.

   :param tif: the type info
   :param name: the name of the type to "unpointerify"
   :param til: the type library
   :returns: a tuple (success, new-name)


.. py:function:: get_numbered_type(til: til_t, ordinal: int) -> Union[Tuple[bytes, bytes, str, str, int], None]

   Get a type from a type library, by its ordinal

   Please use til_t.get_numbered_type instead.


.. py:function:: set_numbered_type(ti: til_t, ordinal: int, ntf_flags: int, name: str, type: type_t const *, fields: p_list const * = None, cmt: str = None, fldcmts: p_list const * = None, sclass: sclass_t const * = None) -> tinfo_code_t

.. py:data:: cvar

.. py:data:: sc_auto

.. py:data:: sc_ext

.. py:data:: sc_friend

.. py:data:: sc_reg

.. py:data:: sc_stat

.. py:data:: sc_type

.. py:data:: sc_unk

.. py:data:: sc_virt

.. py:data:: TERR_SAVE

.. py:data:: TERR_WRONGNAME

.. py:data:: BADORD
   :value: 4294967295


.. py:data:: enum_member_vec_t

.. py:data:: enum_member_t

.. py:data:: udt_member_t


```

`skills/idapython/docs/ida_ua.md`:

```md
# ida_ua

Instruction disassembly, operand decoding, and instruction analysis.

## Key Classes

### insn_t
Decoded instruction with full operand details.
- Access via: `idaapi.insn_t()` or `idautils.DecodeInstruction(ea)`
- Contains array of up to 8 `op_t` operands

### op_t
Single instruction operand representation.
- `type` - Operand type (o_reg, o_mem, o_imm, o_displ, etc)
- `dtype` - Data type (dt_byte, dt_word, dt_dword, dt_qword, etc)
- `reg` - Register number (for o_reg)
- `addr` - Memory address (for o_mem, o_displ, o_near, o_far)
- `value` - Immediate value (for o_imm) or displacement
- `phrase` - Register phrase number (for o_phrase, o_displ)
- `shown()` - Check if operand should be displayed
- `is_reg(r)` / `is_imm(v)` - Type checks

## Operand Types

- `o_void` - No operand
- `o_reg` - Register (al, rax, xmm0, etc)
- `o_mem` - Direct memory `[0x401000]`
- `o_phrase` - Register indirect `[rax]`, `[rsi+rdi*4]`
- `o_displ` - Register + displacement `[rbp+var_10]`
- `o_imm` - Immediate constant `42`, `0x1000`
- `o_near` / `o_far` - Code reference (branch/call target)
- `o_idpspec0-5` - Processor-specific types

## Data Types (dtype)

- `dt_byte` (8), `dt_word` (16), `dt_dword` (32), `dt_qword` (64)
- `dt_byte16` (128), `dt_byte32` (256), `dt_byte64` (512)
- `dt_float`, `dt_double`, `dt_ldbl`, `dt_tbyte`

## Key Functions

### create_insn(ea)
Analyze and create instruction at address (updates IDB).

### decode_insn(insn, ea)
Decode instruction into insn_t object (read-only, no IDB changes).

### decode_prev_insn(insn, ea)
Decode instruction before given address.

### print_insn_mnem(ea)
Get instruction mnemonic string.

### print_operand(ea, n)
Get operand text representation (operand index n).

### get_dtype_size(dtype)
Get size in bytes for data type.

### get_dtype_by_size(size)
Get appropriate dtype for byte size.

## Usage Pattern

```python
insn = idaapi.insn_t()
if idaapi.decode_insn(insn, ea) > 0:
    for op in insn.ops:
        if op.type == idaapi.o_void:
            break  # No more operands
        if op.type == idaapi.o_reg:
            print(f"Register: {op.reg}")
        elif op.type == idaapi.o_imm:
            print(f"Immediate: {op.value:#x}")
```

## See Also
Full docs: skill/docs/ida_ua.rst

```

`skills/idapython/docs/ida_ua.rst`:

```rst
ida_ua
======

.. py:module:: ida_ua

.. autoapi-nested-parse::

   Functions that deal with the disassembling of program instructions.

   There are 2 kinds of functions:

   * functions that are called from the kernel to disassemble an instruction. 
     These functions call IDP module for it.
   * functions that are called from IDP module to disassemble an instruction. 
     We will call them 'helper functions'.


   Disassembly of an instruction is made in three steps:

   0. analysis: ana.cpp
   1. emulation: emu.cpp
   2. conversion to text: out.cpp


   The kernel calls the IDP module to perform these steps. At first, the kernel 
   always calls the analysis. The analyzer must decode the instruction and fill 
   the insn_t instance that it receives through its callback. It must not change 
   anything in the database.

   The second step, the emulation, is called for each instruction. This step must 
   make necessary changes to the database, plan analysis of subsequent instructions, 
   track register values, memory contents, etc. Please keep in mind that the kernel 
   may call the emulation step for any address in the program - there is no ordering 
   of addresses. Usually, the emulation is called for consecutive addresses but 
   this is not guaranteed.

   The last step, conversion to text, is called each time an instruction is 
   displayed on the screen. The kernel will always call the analysis step before 
   calling the text conversion step. The emulation and the text conversion steps 
   should use the information stored in the insn_t instance they receive. They 
   should not access the bytes of the instruction and decode it again - this 
   should only be done in the analysis step.

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For instruction operations, see :mod:`ida_domain.instructions`.



Attributes
----------

.. autoapisummary::

   ida_ua.cvar
   ida_ua.o_void
   ida_ua.o_reg
   ida_ua.o_mem
   ida_ua.o_phrase
   ida_ua.o_displ
   ida_ua.o_imm
   ida_ua.o_far
   ida_ua.o_near
   ida_ua.o_idpspec0
   ida_ua.o_idpspec1
   ida_ua.o_idpspec2
   ida_ua.o_idpspec3
   ida_ua.o_idpspec4
   ida_ua.o_idpspec5
   ida_ua.OF_NO_BASE_DISP
   ida_ua.OF_OUTER_DISP
   ida_ua.PACK_FORM_DEF
   ida_ua.OF_NUMBER
   ida_ua.OF_SHOW
   ida_ua.dt_byte
   ida_ua.dt_word
   ida_ua.dt_dword
   ida_ua.dt_float
   ida_ua.dt_double
   ida_ua.dt_tbyte
   ida_ua.dt_packreal
   ida_ua.dt_qword
   ida_ua.dt_byte16
   ida_ua.dt_code
   ida_ua.dt_void
   ida_ua.dt_fword
   ida_ua.dt_bitfild
   ida_ua.dt_string
   ida_ua.dt_unicode
   ida_ua.dt_ldbl
   ida_ua.dt_byte32
   ida_ua.dt_byte64
   ida_ua.dt_half
   ida_ua.INSN_MACRO
   ida_ua.INSN_MODMAC
   ida_ua.INSN_64BIT
   ida_ua.STKVAR_VALID_SIZE
   ida_ua.STKVAR_KEEP_EXISTING
   ida_ua.CTXF_MAIN
   ida_ua.CTXF_MULTI
   ida_ua.CTXF_CODE
   ida_ua.CTXF_STACK
   ida_ua.CTXF_GEN_XREFS
   ida_ua.CTXF_XREF_STATE
   ida_ua.XREFSTATE_NONE
   ida_ua.XREFSTATE_GO
   ida_ua.XREFSTATE_DONE
   ida_ua.CTXF_GEN_CMT
   ida_ua.CTXF_CMT_STATE
   ida_ua.COMMSTATE_NONE
   ida_ua.COMMSTATE_GO
   ida_ua.COMMSTATE_DONE
   ida_ua.CTXF_VOIDS
   ida_ua.CTXF_NORMAL_LABEL
   ida_ua.CTXF_DEMANGLED_LABEL
   ida_ua.CTXF_LABEL_OK
   ida_ua.CTXF_DEMANGLED_OK
   ida_ua.CTXF_OVSTORE_PRNT
   ida_ua.CTXF_OUTCTX_T
   ida_ua.CTXF_DBLIND_OPND
   ida_ua.CTXF_BINOP_STATE
   ida_ua.BINOPSTATE_NONE
   ida_ua.BINOPSTATE_GO
   ida_ua.BINOPSTATE_DONE
   ida_ua.CTXF_HIDDEN_ADDR
   ida_ua.CTXF_BIT_PREFIX
   ida_ua.CTXF_UNHIDE
   ida_ua.OOF_SIGNMASK
   ida_ua.OOFS_IFSIGN
   ida_ua.OOFS_NOSIGN
   ida_ua.OOFS_NEEDSIGN
   ida_ua.OOF_SIGNED
   ida_ua.OOF_NUMBER
   ida_ua.OOF_WIDTHMASK
   ida_ua.OOFW_IMM
   ida_ua.OOFW_8
   ida_ua.OOFW_16
   ida_ua.OOFW_24
   ida_ua.OOFW_32
   ida_ua.OOFW_64
   ida_ua.OOF_ADDR
   ida_ua.OOF_OUTER
   ida_ua.OOF_ZSTROFF
   ida_ua.OOF_NOBNOT
   ida_ua.OOF_SPACES
   ida_ua.OOF_ANYSERIAL
   ida_ua.OOF_LZEROES
   ida_ua.OOF_NO_LZEROES
   ida_ua.DEFAULT_INDENT
   ida_ua.MAKELINE_NONE
   ida_ua.MAKELINE_BINPREF
   ida_ua.MAKELINE_VOID
   ida_ua.MAKELINE_STACK
   ida_ua.GH_PRINT_PROC
   ida_ua.GH_PRINT_ASM
   ida_ua.GH_PRINT_BYTESEX
   ida_ua.GH_PRINT_HEADER
   ida_ua.GH_BYTESEX_HAS_HIGHBYTE
   ida_ua.GH_PRINT_PROC_AND_ASM
   ida_ua.GH_PRINT_PROC_ASM_AND_BYTESEX
   ida_ua.GH_PRINT_ALL
   ida_ua.GH_PRINT_ALL_BUT_BYTESEX
   ida_ua.FCBF_CONT
   ida_ua.FCBF_ERR_REPL
   ida_ua.FCBF_FF_LIT
   ida_ua.FCBF_DELIM
   ida_ua.ua_mnem


Classes
-------

.. autoapisummary::

   ida_ua.operands_array
   ida_ua.op_t
   ida_ua.insn_t
   ida_ua.outctx_base_t
   ida_ua.outctx_t
   ida_ua.macro_constructor_t


Functions
---------

.. autoapisummary::

   ida_ua.insn_add_cref
   ida_ua.insn_add_dref
   ida_ua.insn_add_off_drefs
   ida_ua.insn_create_stkvar
   ida_ua.get_lookback
   ida_ua.calc_dataseg
   ida_ua.map_data_ea
   ida_ua.map_code_ea
   ida_ua.map_ea
   ida_ua.create_outctx
   ida_ua.print_insn_mnem
   ida_ua.get_dtype_flag
   ida_ua.get_dtype_size
   ida_ua.is_floating_dtype
   ida_ua.create_insn
   ida_ua.decode_insn
   ida_ua.can_decode
   ida_ua.print_operand
   ida_ua.decode_prev_insn
   ida_ua.decode_preceding_insn
   ida_ua.construct_macro
   ida_ua.get_dtype_by_size
   ida_ua.get_immvals
   ida_ua.get_printable_immvals
   ida_ua.insn_t__from_ptrval__
   ida_ua.op_t__from_ptrval__
   ida_ua.outctx_base_t__from_ptrval__
   ida_ua.outctx_t__from_ptrval__


Module Contents
---------------

.. py:class:: operands_array(data: op_t (&)[8])

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: data
      :type:  op_t (&)[8]


   .. py:attribute:: bytes


.. py:class:: op_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: n
      :type:  uchar

      Number of operand (0,1,2). Initialized once at the start of work. You have no right to change its value. 
              



   .. py:attribute:: type
      :type:  optype_t

      Type of operand (see Operand types)



   .. py:attribute:: offb
      :type:  char

      Offset of operand value from the instruction start (0 means unknown). Of course this field is meaningful only for certain types of operands. Leave it equal to zero if the operand has no offset. This offset should point to the 'interesting' part of operand. For example, it may point to the address of a function in `call func ` or it may point to bytes holding '5' in `mov  ax, [bx+5] ` Usually bytes pointed to this offset are relocated (have fixup information). 
              



   .. py:attribute:: offo
      :type:  char

      Same as offb (some operands have 2 numeric values used to form an operand). This field is used for the second part of operand if it exists. Currently this field is used only for outer offsets of Motorola processors. Leave it equal to zero if the operand has no offset. 
              



   .. py:attribute:: flags
      :type:  uchar

      Operand flags 
              



   .. py:method:: set_shown() -> None

      Set operand to be shown.



   .. py:method:: clr_shown() -> None

      Set operand to hidden.



   .. py:method:: shown() -> bool

      Is operand set to be shown?



   .. py:attribute:: dtype
      :type:  op_dtype_t

      Type of operand value (see Operand value types). This is the type of the operand itself, not the size of the addressing mode. for example, byte ptr [epb+32_bit_offset] will have the dt_byte type. 
              



   .. py:attribute:: reg
      :type:  uint16

      number of register (o_reg)



   .. py:attribute:: phrase
      :type:  uint16

      number of register phrase (o_phrase,o_displ). you yourself define numbers of phrases as you like 
              



   .. py:method:: is_reg(r: int) -> bool

      Is register operand?



   .. py:attribute:: value
      :type:  int

      operand value (o_imm) or outer displacement (o_displ+OF_OUTER_DISP). integer values should be in IDA's (little-endian) order. when using ieee_realcvt(), floating point values should be in the processor's native byte order. dt_double and dt_qword values take up 8 bytes (value and addr fields for 32-bit modules). NB: in case a dt_dword/dt_qword immediate is forced to float by user, the kernel converts it to processor's native order before calling FP conversion routines. 
              



   .. py:method:: is_imm(v: int) -> bool

      Is immediate operand?



   .. py:attribute:: addr
      :type:  ida_idaapi.ea_t

      virtual address pointed or used by the operand. (o_mem,o_displ,o_far,o_near) 
              



   .. py:attribute:: specval
      :type:  ida_idaapi.ea_t

      This field may be used as you want. 
              



   .. py:attribute:: specflag1
      :type:  char


   .. py:attribute:: specflag2
      :type:  char


   .. py:attribute:: specflag3
      :type:  char


   .. py:attribute:: specflag4
      :type:  char


   .. py:method:: assign(other: op_t) -> None


   .. py:method:: has_reg(r)

      Checks if the operand accesses the given processor register



   .. py:attribute:: value64


.. py:data:: cvar

.. py:data:: o_void

   No Operand.


.. py:data:: o_reg

   General Register (al,ax,es,ds...).

   The register number should be stored in op_t::reg. All processor registers, including special registers, can be represented by this operand type. 
           


.. py:data:: o_mem

   A direct memory reference to a data item. Use this operand type when the address can be calculated statically.
   A direct memory data reference whose target address is known at compilation time. The target virtual address is stored in op_t::addr and the full address is calculated as to_ea(  insn_t::cs, op_t::addr ). For the processors with complex memory organization the final address can be calculated using other segment registers. For flat memories, op_t::addr is the final address and insn_t::cs is usually equal to zero. In any case, the address within the segment should be stored in op_t::addr. 
           


.. py:data:: o_phrase

   An indirect memory reference that uses a register: [reg] There can be several registers but no displacement.
   A memory reference using register contents. Indexed, register based, and other addressing modes can be represented with the operand type. This addressing mode cannot contain immediate values (use o_displ instead). The phrase number should be stored in op_t::phrase. To denote the pre-increment and similar features please use additional operand fields like op_t::specflag... Usually op_t::phrase contains the register number and additional information is stored in op_t::specflags... Please note that this operand type cannot contain immediate values (except the scaling coefficients). 
           


.. py:data:: o_displ

   An indirect memory reference that uses a register and has an immediate constant added to it: [reg+N] There can be several registers.
   A memory reference using register contents with displacement. The displacement should be stored in the op_t::addr field. The rest of information is stored the same way as in o_phrase. 
           


.. py:data:: o_imm

   An immediate Value (constant).

   Any operand consisting of only a number is represented by this operand type. The value should be stored in op_t::value. You may sign extend short (1-2 byte) values. In any case don't forget to specify op_t::dtype (should be set for all operand types). 
           


.. py:data:: o_far

   An immediate far code reference (inter-segment)

   If the current processor has a special addressing mode for inter-segment references, then this operand type should be used instead of o_near. If you want, you may use PR_CHK_XREF in processor_t::flag to disable inter-segment calls if o_near operand type is used. Currently only IBM PC uses this flag. 
           


.. py:data:: o_near

   An immediate near code reference (intra-segment)

   A direct memory code reference whose target address is known at the compilation time. The target virtual address is stored in op_t::addr and the final address is always to_ea( insn_t::cs, op_t::addr). Usually this operand type is used for the branches and calls whose target address is known. If the current processor has 2 different types of references for inter-segment and intra-segment references, then this should be used only for intra-segment references.
   If the above operand types do not cover all possible addressing modes, then use o_idpspec... operand types. 
           


.. py:data:: o_idpspec0

   processor specific type.


.. py:data:: o_idpspec1

   processor specific type.


.. py:data:: o_idpspec2

   processor specific type.


.. py:data:: o_idpspec3

   processor specific type.


.. py:data:: o_idpspec4

   processor specific type.


.. py:data:: o_idpspec5

   processor specific type. (there can be more processor specific types) 
           


.. py:data:: OF_NO_BASE_DISP

   base displacement doesn't exist. meaningful only for o_displ type. if set, base displacement (op_t::addr) doesn't exist. 
           


.. py:data:: OF_OUTER_DISP

   outer displacement exists. meaningful only for o_displ type. if set, outer displacement (op_t::value) exists. 
           


.. py:data:: PACK_FORM_DEF

   packed factor defined. (!o_reg + dt_packreal) 
           


.. py:data:: OF_NUMBER

   the operand can be converted to a number only


.. py:data:: OF_SHOW

   should the operand be displayed?


.. py:data:: dt_byte

   8 bit integer


.. py:data:: dt_word

   16 bit integer


.. py:data:: dt_dword

   32 bit integer


.. py:data:: dt_float

   4 byte floating point


.. py:data:: dt_double

   8 byte floating point


.. py:data:: dt_tbyte

   variable size ( processor_t::tbyte_size) floating point


.. py:data:: dt_packreal

   packed real format for mc68040


.. py:data:: dt_qword

   64 bit integer


.. py:data:: dt_byte16

   128 bit integer


.. py:data:: dt_code

   ptr to code


.. py:data:: dt_void

   none


.. py:data:: dt_fword

   48 bit


.. py:data:: dt_bitfild

   bit field (mc680x0)


.. py:data:: dt_string

   pointer to asciiz string


.. py:data:: dt_unicode

   pointer to unicode string


.. py:data:: dt_ldbl

   long double (which may be different from tbyte)


.. py:data:: dt_byte32

   256 bit integer


.. py:data:: dt_byte64

   512 bit integer


.. py:data:: dt_half

   2-byte floating point


.. py:function:: insn_add_cref(insn: insn_t, to: ida_idaapi.ea_t, opoff: int, type: cref_t) -> None

.. py:function:: insn_add_dref(insn: insn_t, to: ida_idaapi.ea_t, opoff: int, type: dref_t) -> None

.. py:function:: insn_add_off_drefs(insn: insn_t, x: op_t, type: dref_t, outf: int) -> ida_idaapi.ea_t

.. py:function:: insn_create_stkvar(insn: insn_t, x: op_t, v: adiff_t, flags: int) -> bool

.. py:class:: insn_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cs
      :type:  ida_idaapi.ea_t

      Current segment base paragraph. Initialized by the kernel.



   .. py:attribute:: ip
      :type:  ida_idaapi.ea_t

      Virtual address of the instruction (address within the segment). Initialized by the kernel. 
              



   .. py:attribute:: ea
      :type:  ida_idaapi.ea_t

      Linear address of the instruction. Initialized by the kernel. 
              



   .. py:attribute:: itype
      :type:  uint16

      Internal code of instruction (only for canonical insns - not user defined!). IDP should define its own instruction codes. These codes are usually defined in ins.hpp. The array of instruction names and features (ins.cpp) is accessed using this code. 
              



   .. py:attribute:: size
      :type:  uint16

      Size of instruction in bytes. The analyzer should put here the actual size of the instruction. 
              



   .. py:attribute:: auxpref
      :type:  int

      processor dependent field



   .. py:attribute:: auxpref_u16
      :type:  uint16 [2]


   .. py:attribute:: auxpref_u8
      :type:  uint8 [4]


   .. py:attribute:: segpref
      :type:  char

      processor dependent field



   .. py:attribute:: insnpref
      :type:  char

      processor dependent field



   .. py:attribute:: flags
      :type:  int16

      Instruction flags



   .. py:attribute:: ops
      :type:  op_t [8]

      array of operands



   .. py:method:: is_macro() -> bool

      Is a macro instruction?



   .. py:method:: is_64bit() -> bool

      Belongs to a 64bit segment?



   .. py:method:: get_next_byte() -> uint8


   .. py:method:: get_next_word() -> uint16


   .. py:method:: get_next_dword() -> int


   .. py:method:: get_next_qword() -> uint64


   .. py:method:: create_op_data(*args) -> bool


   .. py:method:: create_stkvar(x: op_t, v: adiff_t, flags_: int) -> bool


   .. py:method:: add_cref(to: ida_idaapi.ea_t, opoff: int, type: cref_t) -> None

      Add a code cross-reference from the instruction. 
              
      :param to: target linear address
      :param opoff: offset of the operand from the start of instruction. if the offset is unknown, then 0.
      :param type: type of xref



   .. py:method:: add_dref(to: ida_idaapi.ea_t, opoff: int, type: dref_t) -> None

      Add a data cross-reference from the instruction. See add_off_drefs() - usually it can be used in most cases. 
              
      :param to: target linear address
      :param opoff: offset of the operand from the start of instruction if the offset is unknown, then 0
      :param type: type of xref



   .. py:method:: add_off_drefs(x: op_t, type: dref_t, outf: int) -> ida_idaapi.ea_t

      Add xrefs for an operand of the instruction. This function creates all cross references for 'enum', 'offset' and 'structure offset' operands. Use add_off_drefs() in the presence of negative offsets. 
              
      :param x: reference to operand
      :param type: type of xref
      :param outf: out_value() flags. These flags should match the flags used to output the operand
      :returns: if: is_off(): the reference target address (the same as calc_reference_data).
      :returns: if: is_stroff(): BADADDR because for stroffs the target address is unknown
      :returns: otherwise: BADADDR because enums do not represent addresses



   .. py:method:: assign(other: insn_t) -> None


   .. py:method:: is_canon_insn(*args) -> bool

      see processor_t::is_canon_insn()



   .. py:method:: get_canon_feature(*args) -> int

      see instruc_t::feature



   .. py:method:: get_canon_mnem(*args) -> str

      see instruc_t::name



   .. py:attribute:: Op1


   .. py:attribute:: Op2


   .. py:attribute:: Op3


   .. py:attribute:: Op4


   .. py:attribute:: Op5


   .. py:attribute:: Op6


   .. py:attribute:: Op7


   .. py:attribute:: Op8


.. py:data:: INSN_MACRO

   macro instruction


.. py:data:: INSN_MODMAC

   may modify the database to make room for the macro insn


.. py:data:: INSN_64BIT

   belongs to 64bit segment?


.. py:data:: STKVAR_VALID_SIZE

   x.dtype contains correct variable type (for insns like 'lea' this bit must be off). in general, dr_O references do not allow to determine the variable size 
           


.. py:data:: STKVAR_KEEP_EXISTING

   if a stack variable for this operand already exists then we do not create a new variable 
           


.. py:function:: get_lookback() -> int

   Number of instructions to look back. This variable is not used by the kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>. IDP may use it as you like it. (TMS module uses it) 
           


.. py:function:: calc_dataseg(insn: insn_t, n: int = -1, rgnum: int = -1) -> ida_idaapi.ea_t

.. py:function:: map_data_ea(*args) -> ida_idaapi.ea_t

.. py:function:: map_code_ea(*args) -> ida_idaapi.ea_t

.. py:function:: map_ea(*args) -> ida_idaapi.ea_t

.. py:class:: outctx_base_t(*args, **kwargs)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: insn_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: outbuf
      :type:  str

      buffer for the current output line once ready, it is moved to lnar 
              



   .. py:attribute:: F32
      :type:  flags_t

      please use outctx_t::F instead



   .. py:attribute:: default_lnnum
      :type:  int

      index of the most important line in lnar



   .. py:method:: only_main_line() -> bool


   .. py:method:: multiline() -> bool


   .. py:method:: force_code() -> bool


   .. py:method:: stack_view() -> bool


   .. py:method:: display_voids() -> bool


   .. py:method:: display_hidden() -> bool


   .. py:method:: set_gen_xrefs(on: bool = True) -> None


   .. py:method:: set_gen_cmt(on: bool = True) -> None


   .. py:method:: clr_gen_label() -> None


   .. py:method:: set_gen_label() -> None


   .. py:method:: set_gen_demangled_label() -> None


   .. py:method:: set_comment_addr(ea: ida_idaapi.ea_t) -> None


   .. py:method:: set_dlbind_opnd() -> None


   .. py:method:: print_label_now() -> bool


   .. py:method:: forbid_annotations() -> int


   .. py:method:: restore_ctxflags(saved_flags: int) -> None


   .. py:method:: out_printf(format: str) -> size_t

      ------------------------------------------------------------------------- Functions to append text to the current output buffer (outbuf) Append a formatted string to the output string. 
              
      :returns: the number of characters appended



   .. py:method:: out_value(x: op_t, outf: int = 0) -> flags64_t

      Output immediate value. Try to use this function to output all constants of instruction operands. This function outputs a number from x.addr or x.value in the form determined by F. It outputs colored text. 
              
      :param x: value to output
      :param outf: Output value flags
      :returns: flags of the output value, otherwise:
      :returns: -1: if printed a number with COLOR_ERROR
      :returns: 0: if printed a nice number or character or segment or enum



   .. py:method:: out_symbol(c: char) -> None

      Output a character with COLOR_SYMBOL color.



   .. py:method:: out_chars(c: char, n: int) -> None

      Append a character multiple times.



   .. py:method:: out_spaces(len: ssize_t) -> None

      Appends spaces to outbuf until its tag_strlen becomes 'len'.



   .. py:method:: out_line(str: outctx_base_t.out_line.str, color: color_t = 0) -> None

      Output a string with the specified color.



   .. py:method:: out_keyword(str: outctx_base_t.out_keyword.str) -> None

      Output a string with COLOR_KEYWORD color.



   .. py:method:: out_register(str: outctx_base_t.out_register.str) -> None

      Output a character with COLOR_REG color.



   .. py:method:: out_lvar(name: str, width: int = -1) -> None

      Output local variable name with COLOR_LOCNAME color.



   .. py:method:: out_tagon(tag: color_t) -> None

      Output "turn color on" escape sequence.



   .. py:method:: out_tagoff(tag: color_t) -> None

      Output "turn color off" escape sequence.



   .. py:method:: out_addr_tag(ea: ida_idaapi.ea_t) -> None

      Output "address" escape sequence.



   .. py:method:: out_colored_register_line(str: outctx_base_t.out_colored_register_line.str) -> None

      Output a colored line with register names in it. The register names will be substituted by user-defined names (regvar_t) Please note that out_tagoff tries to make substitutions too (when called with COLOR_REG) 
              



   .. py:method:: out_char(c: char) -> None

      Output one character. The character is output without color codes. see also out_symbol() 
              



   .. py:method:: out_btoa(Word: int, radix: char = 0) -> None

      Output a number with the specified base (binary, octal, decimal, hex) The number is output without color codes. see also out_long() 
              



   .. py:method:: out_long(v: int, radix: char) -> None

      Output a number with appropriate color. Low level function. Use out_value() if you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of COLOR_NUMBER. 'suspop' is initialized:
      * in out_one_operand()
      * in ..\ida\gl.cpp (before calling processor_t::d_out())



      :param v: value to output
      :param radix: base (2,8,10,16)



   .. py:method:: out_name_expr(*args) -> bool

      Output a name expression. 
              
      :param x: instruction operand referencing the name expression
      :param ea: address to convert to name expression
      :param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. You may pass BADADDR for this parameter but I discourage it because it prohibits checks.
      :returns: true if the name expression has been produced



   .. py:method:: close_comment() -> None


   .. py:method:: flush_outbuf(indent: int = -1) -> bool

      ------------------------------------------------------------------------- Functions to populate the output line array (lnar) Move the contents of the output buffer to the line array (outbuf->lnar) The kernel augments the outbuf contents with additional text like the line prefix, user-defined comments, xrefs, etc at this call. 
              



   .. py:method:: flush_buf(buf: str, indent: int = -1) -> bool

      Append contents of 'buf' to the line array. Behaves like flush_outbuf but accepts an arbitrary buffer 
              



   .. py:method:: term_outctx(prefix: str = None) -> int

      Finalize the output context. 
              
      :returns: the number of generated lines.



   .. py:method:: gen_printf(indent: int, format: str) -> bool

      printf-like function to add lines to the line array. 
              
      :param indent: indention of the line. if indent == -1, the kernel will indent the line at idainfo::indent. if indent < 0, -indent will be used for indention. The first line printed with indent < 0 is considered as the most important line at the current address. Usually it is the line with the instruction itself. This line will be displayed in the cross-reference lists and other places. If you need to output an additional line before the main line then pass DEFAULT_INDENT instead of -1. The kernel will know that your line is not the most important one.
      :param format: printf style colored line to generate
      :returns: overflow, lnar_maxsize has been reached



   .. py:method:: gen_empty_line() -> bool

      Generate empty line. This function does nothing if generation of empty lines is disabled. 
              
      :returns: overflow, lnar_maxsize has been reached



   .. py:method:: gen_border_line(solid: bool = False) -> bool

      Generate thin border line. This function does nothing if generation of border lines is disabled. 
              
      :param solid: generate solid border line (with =), otherwise with -
      :returns: overflow, lnar_maxsize has been reached



   .. py:method:: gen_cmt_line(format: str) -> bool

      Generate one non-indented comment line, colored with COLOR_AUTOCMT. 
              
      :param format: printf() style format line. The resulting comment line should not include comment character (;)
      :returns: overflow, lnar_maxsize has been reached



   .. py:method:: gen_collapsed_line(format: str) -> bool

      Generate one non-indented comment line, colored with COLOR_COLLAPSED. 
              
      :param format: printf() style format line. The resulting comment line should not include comment character (;)
      :returns: overflow, lnar_maxsize has been reached



   .. py:method:: gen_block_cmt(cmt: str, color: color_t) -> bool

      Generate big non-indented comment lines. 
              
      :param cmt: comment text. may contain \n characters to denote new lines. should not contain comment character (;)
      :param color: color of comment text (one of Color tags)
      :returns: overflow, lnar_maxsize has been reached



   .. py:method:: setup_outctx(prefix: str, makeline_flags: int) -> None

      Initialization; normally used only by the kernel.



   .. py:method:: retrieve_cmt() -> ssize_t


   .. py:method:: retrieve_name(arg2: str, arg3: color_t *) -> ssize_t


   .. py:method:: gen_xref_lines() -> bool


   .. py:method:: init_lines_array(answers: qstrvec_t *, maxsize: int) -> None


   .. py:method:: get_stkvar(x: op_t, v: int, vv: sval_t *, is_sp_based: int *, _frame: tinfo_t) -> ssize_t


   .. py:method:: gen_empty_line_without_annotations() -> None


   .. py:method:: getF() -> flags64_t


.. py:data:: CTXF_MAIN

   produce only the essential line(s)


.. py:data:: CTXF_MULTI

   enable multi-line essential lines


.. py:data:: CTXF_CODE

   display as code regardless of the database flags


.. py:data:: CTXF_STACK

   stack view (display undefined items as 2/4/8 bytes)


.. py:data:: CTXF_GEN_XREFS

   generate the xrefs along with the next line


.. py:data:: CTXF_XREF_STATE

   xref state:


.. py:data:: XREFSTATE_NONE

   not generated yet


.. py:data:: XREFSTATE_GO

   being generated


.. py:data:: XREFSTATE_DONE

   have been generated


.. py:data:: CTXF_GEN_CMT

   generate the comment along with the next line


.. py:data:: CTXF_CMT_STATE

   comment state:


.. py:data:: COMMSTATE_NONE

   not generated yet


.. py:data:: COMMSTATE_GO

   being generated


.. py:data:: COMMSTATE_DONE

   have been generated


.. py:data:: CTXF_VOIDS

   display void marks


.. py:data:: CTXF_NORMAL_LABEL

   generate plain label (+demangled label as cmt)


.. py:data:: CTXF_DEMANGLED_LABEL

   generate only demangled label as comment


.. py:data:: CTXF_LABEL_OK

   the label have been generated


.. py:data:: CTXF_DEMANGLED_OK

   the label has been demangled successfully


.. py:data:: CTXF_OVSTORE_PRNT

   out_value should store modified values


.. py:data:: CTXF_OUTCTX_T

   instance is, in fact, a outctx_t


.. py:data:: CTXF_DBLIND_OPND

   an operand was printed with double indirection (e.g. =var in arm)


.. py:data:: CTXF_BINOP_STATE

   opcode bytes state:


.. py:data:: BINOPSTATE_NONE

   not generated yet


.. py:data:: BINOPSTATE_GO

   being generated


.. py:data:: BINOPSTATE_DONE

   have been generated


.. py:data:: CTXF_HIDDEN_ADDR

   generate an hidden addr tag at the beginning of the line


.. py:data:: CTXF_BIT_PREFIX

   generate a line prefix with a bit offset, e.g.: 12345678.3


.. py:data:: CTXF_UNHIDE

   display hidden objects (segment, function, range)


.. py:data:: OOF_SIGNMASK

   sign symbol (+/-) output


.. py:data:: OOFS_IFSIGN

   output sign if needed


.. py:data:: OOFS_NOSIGN

   don't output sign, forbid the user to change the sign


.. py:data:: OOFS_NEEDSIGN

   always out sign (+-)


.. py:data:: OOF_SIGNED

   output as signed if < 0


.. py:data:: OOF_NUMBER

   always as a number


.. py:data:: OOF_WIDTHMASK

   width of value in bits


.. py:data:: OOFW_IMM

   take from x.dtype


.. py:data:: OOFW_8

   8 bit width


.. py:data:: OOFW_16

   16 bit width


.. py:data:: OOFW_24

   24 bit width


.. py:data:: OOFW_32

   32 bit width


.. py:data:: OOFW_64

   64 bit width


.. py:data:: OOF_ADDR

   output x.addr, otherwise x.value OOF_WIDTHMASK must be explicitly specified with it 
           


.. py:data:: OOF_OUTER

   output outer operand


.. py:data:: OOF_ZSTROFF

   meaningful only if is_stroff(F); append a struct field name if the field offset is zero? if AFL_ZSTROFF is set, then this flag is ignored. 
           


.. py:data:: OOF_NOBNOT

   prohibit use of binary not


.. py:data:: OOF_SPACES

   do not suppress leading spaces; currently works only for floating point numbers 
           


.. py:data:: OOF_ANYSERIAL

   if enum: select first available serial


.. py:data:: OOF_LZEROES

   print leading zeroes


.. py:data:: OOF_NO_LZEROES

   do not print leading zeroes; if none of OOF_LZEROES and OOF_NO_LZEROES was specified, is_lzero() is used 
           


.. py:data:: DEFAULT_INDENT

.. py:data:: MAKELINE_NONE

.. py:data:: MAKELINE_BINPREF

   allow display of binary prefix


.. py:data:: MAKELINE_VOID

   allow display of '<suspicious>' marks


.. py:data:: MAKELINE_STACK

   allow display of sp trace prefix


.. py:class:: outctx_t(*args, **kwargs)

   Bases: :py:obj:`outctx_base_t`


   .. py:attribute:: thisown


   .. py:attribute:: bin_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: bin_state
      :type:  char


   .. py:attribute:: gl_bpsize
      :type:  int


   .. py:attribute:: bin_width
      :type:  int


   .. py:attribute:: insn
      :type:  insn_t


   .. py:attribute:: curlabel
      :type:  str


   .. py:attribute:: wif
      :type:  printop_t const *


   .. py:attribute:: procmod
      :type:  procmod_t *


   .. py:attribute:: ph
      :type:  processor_t &


   .. py:attribute:: ash
      :type:  asm_t &


   .. py:attribute:: saved_immvals
      :type:  uval_t [8]


   .. py:attribute:: prefix_ea
      :type:  ida_idaapi.ea_t


   .. py:attribute:: next_line_ea
      :type:  ida_idaapi.ea_t


   .. py:method:: setup_outctx(prefix: str, flags: int) -> None

      Initialization; normally used only by the kernel.



   .. py:method:: term_outctx(prefix: str = None) -> int

      Finalize the output context. 
              
      :returns: the number of generated lines.



   .. py:method:: retrieve_cmt() -> ssize_t


   .. py:method:: retrieve_name(arg2: str, arg3: color_t *) -> ssize_t


   .. py:method:: gen_xref_lines() -> bool


   .. py:method:: out_btoa(Word: int, radix: char = 0) -> None

      Output a number with the specified base (binary, octal, decimal, hex) The number is output without color codes. see also out_long() 
              



   .. py:method:: set_bin_state(value: int) -> None


   .. py:method:: out_mnem(width: int = 8, postfix: str = None) -> None

      Output instruction mnemonic for 'insn' using information in 'ph.instruc' array. This function outputs colored text. It should be called from processor_t::ev_out_insn() or processor_t::ev_out_mnem() handler. It will output at least one space after the instruction. mnemonic even if the specified 'width' is not enough. 
              
      :param width: width of field with mnemonic. if < 0, then 'postfix' will be output before the mnemonic, i.e. as a prefix
      :param postfix: optional postfix added to the instruction mnemonic



   .. py:method:: out_custom_mnem(mnem: str, width: int = 8, postfix: str = None) -> None

      Output custom mnemonic for 'insn'. E.g. if it should differ from the one in 'ph.instruc'. This function outputs colored text. See out_mnem 
              
      :param mnem: custom mnemonic
      :param width: width of field with mnemonic. if < 0, then 'postfix' will be output before the mnemonic, i.e. as a prefix
      :param postfix: optional postfix added to 'mnem'



   .. py:method:: out_mnemonic() -> None

      Output instruction mnemonic using information in 'insn'. It should be called from processor_t::ev_out_insn() and it will call processor_t::ev_out_mnem() or out_mnem. This function outputs colored text. 
              



   .. py:method:: out_one_operand(n: int) -> bool

      Use this function to output an operand of an instruction. This function checks for the existence of a manually defined operand and will output it if it exists. It should be called from processor_t::ev_out_insn() and it will call processor_t::ev_out_operand(). This function outputs colored text. 
              
      :param n: 0..UA_MAXOP-1 operand number
      :returns: 1: operand is displayed
      :returns: 0: operand is hidden



   .. py:method:: out_immchar_cmts() -> None

      Print all operand values as commented character constants. This function is used to comment void operands with their representation in the form of character constants. This function outputs colored text. 
              



   .. py:method:: gen_func_header(pfn: func_t *) -> None


   .. py:method:: gen_func_footer(pfn: func_t const *) -> None


   .. py:method:: out_data(analyze_only: bool) -> None


   .. py:method:: out_specea(segtype: uchar) -> bool


   .. py:method:: gen_header_extra() -> None


   .. py:method:: gen_header(*args) -> None


   .. py:method:: out_fcref_names() -> None

      Print addresses referenced *from* the specified address as commented symbolic names. This function is used to show, for example, multiple callees of an indirect call. This function outputs colored text. 
              



.. py:data:: GH_PRINT_PROC

   processor name


.. py:data:: GH_PRINT_ASM

   selected assembler


.. py:data:: GH_PRINT_BYTESEX

   byte sex


.. py:data:: GH_PRINT_HEADER

   lines from ash.header


.. py:data:: GH_BYTESEX_HAS_HIGHBYTE

   describe inf.is_wide_high_byte_first()


.. py:data:: GH_PRINT_PROC_AND_ASM

.. py:data:: GH_PRINT_PROC_ASM_AND_BYTESEX

.. py:data:: GH_PRINT_ALL

.. py:data:: GH_PRINT_ALL_BUT_BYTESEX

.. py:function:: create_outctx(ea: ida_idaapi.ea_t, F: flags64_t = 0, suspop: int = 0) -> outctx_base_t *

   Create a new output context. To delete it, just use "delete pctx" 
           


.. py:function:: print_insn_mnem(ea: ida_idaapi.ea_t) -> str

   Print instruction mnemonics. 
           
   :param ea: linear address of the instruction
   :returns: success


.. py:data:: FCBF_CONT

   don't stop on decoding, or any other kind of error


.. py:data:: FCBF_ERR_REPL

   in case of an error, use a CP_REPLCHAR instead of a hex representation of the problematic byte 
           


.. py:data:: FCBF_FF_LIT

   in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER Y WITH DIAERESIS). If both this, and FCBF_REPL are specified, this will take precedence 
           


.. py:data:: FCBF_DELIM

   add the 'ash'-specified delimiters around the generated data. Note: if those are not defined and the INFFL_ALLASM is not set, format_charlit() will return an error 
           


.. py:function:: get_dtype_flag(dtype: op_dtype_t) -> flags64_t

   Get flags for op_t::dtype field.


.. py:function:: get_dtype_size(dtype: op_dtype_t) -> size_t

   Get size of opt_::dtype field.


.. py:function:: is_floating_dtype(dtype: op_dtype_t) -> bool

   Is a floating type operand?


.. py:function:: create_insn(ea: ida_idaapi.ea_t, out: insn_t = None) -> int

   Create an instruction at the specified address. This function checks if an instruction is present at the specified address and will try to create one if there is none. It will fail if there is a data item or other items hindering the creation of the new instruction. This function will also fill the 'out' structure. 
           
   :param ea: linear address
   :param out: the resulting instruction
   :returns: the length of the instruction or 0


.. py:function:: decode_insn(out: insn_t, ea: ida_idaapi.ea_t) -> int

   Analyze the specified address and fill 'out'. This function does not modify the database. It just tries to interpret the specified address as an instruction and fills the 'out' structure. 
           
   :param out: the resulting instruction
   :param ea: linear address
   :returns: the length of the (possible) instruction or 0


.. py:function:: can_decode(ea: ida_idaapi.ea_t) -> bool

   Can the bytes at address 'ea' be decoded as instruction? 
           
   :param ea: linear address
   :returns: whether or not the contents at that address could be a valid instruction


.. py:function:: print_operand(ea: ida_idaapi.ea_t, n: int, getn_flags: int = 0, newtype: printop_t = None) -> str

   Generate text representation for operand #n. This function will generate the text representation of the specified operand (includes color codes.) 
           
   :param ea: the item address (instruction or data)
   :param n: 0..UA_MAXOP-1 operand number, meaningful only for instructions
   :param getn_flags: Name expression flags Currently only GETN_NODUMMY is accepted.
   :param newtype: if specified, print the operand using the specified type
   :returns: success


.. py:function:: decode_prev_insn(out: insn_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Decode previous instruction if it exists, fill 'out'. 
           
   :param out: the resulting instruction
   :param ea: the address to decode the previous instruction from
   :returns: the previous instruction address (BADADDR-no such insn)


.. py:class:: macro_constructor_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: reserved
      :type:  size_t


   .. py:method:: construct_macro(insn: insn_t, enable: bool) -> bool

      Construct a macro instruction. This function may be called from ana() to generate a macro instruction.
      The real work is done by the 'build_macro()' virtual function. It must be defined by the processor module.
      construct_macro() modifies the database using the info provided by build_macro(). It verifies if the instruction can really be created (for example, that other items do not hinder), may plan to reanalyze the macro, etc. If the macro instructions are disabled by the user, construct_macro() will destroy the macro instruction. Note: if INSN_MODMAC is not set in insn.flags, the database will not be modified.

      :param insn: the instruction to modify into a macro
      :param enable: enable macro generation
      :returns: true: the macro instruction is generated in 'insn'
      :returns: false: did not create a macro



   .. py:method:: build_macro(insn: insn_t, may_go_forward: bool) -> bool

      Try to extend the instruction.
      This function may modify 'insn' and return false; these changes will be accepted by the kernel but the instruction will not be considered as a macro.

      :param insn: Instruction to modify, usually the first instruction of the macro
      :param may_go_forward: Is it ok to consider the next instruction for the macro? This argument may be false, for example, if there is a cross reference to the end of INSN. In this case creating a macro is not desired. However, it may still be useful to perform minor tweaks to the instruction using the information about the surrounding instructions.
      :returns: true if created an macro instruction.



.. py:function:: decode_preceding_insn(out: insn_t, ea: ida_idaapi.ea_t) -> Tuple[ida_idaapi.ea_t, bool]

   Decodes the preceding instruction.

   :param out: instruction storage
   :param ea: current ea
   :returns: tuple(preceeding_ea or BADADDR, farref = Boolean)


.. py:function:: construct_macro(*args)

   See ua.hpp's construct_macro().

   This function has the following signatures

       1. construct_macro(insn: insn_t, enable: bool, build_macro: callable) -> bool
       2. construct_macro(constuctor: macro_constructor_t, insn: insn_t, enable: bool) -> bool

   :param insn: the instruction to build the macro for
   :param enable: enable macro generation
   :param build_macro: a callable with 2 arguments: an insn_t, and
                       whether it is ok to consider the next instruction
                       for the macro
   :param constructor: a macro_constructor_t implementation
   :returns: success


.. py:function:: get_dtype_by_size(size: asize_t) -> int

   Get op_t::dtype from size.


.. py:function:: get_immvals(ea: ida_idaapi.ea_t, n: int, F: flags64_t = 0) -> PyObject *

   Get immediate values at the specified address. This function decodes instruction at the specified address or inspects the data item. It finds immediate values and copies them to 'out'. This function will store the original value of the operands in 'out', unless the last bits of 'F' are "...0 11111111", in which case the transformed values (as needed for printing) will be stored instead. 
           
   :param ea: address to analyze
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
   :param F: flags for the specified address
   :returns: number of immediate values (0..2*UA_MAXOP)


.. py:function:: get_printable_immvals(ea: ida_idaapi.ea_t, n: int, F: flags64_t = 0) -> PyObject *

   Get immediate ready-to-print values at the specified address 
           
   :param ea: address to analyze
   :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
   :param F: flags for the specified address
   :returns: number of immediate values (0..2*UA_MAXOP)


.. py:function:: insn_t__from_ptrval__(ptrval: size_t) -> insn_t *

.. py:function:: op_t__from_ptrval__(ptrval: size_t) -> op_t *

.. py:function:: outctx_base_t__from_ptrval__(ptrval: size_t) -> outctx_base_t *

.. py:function:: outctx_t__from_ptrval__(ptrval: size_t) -> outctx_t *

.. py:data:: ua_mnem


```

`skills/idapython/docs/ida_undo.md`:

```md
# ida_undo

Database undo/redo operations for IDA changes.

## Key Functions

### create_undo_point(bytes, size)
Create restore point. User can undo to this point later. Returns False if undo disabled.

### perform_undo()
Undo last action. Returns True on success.

### perform_redo()
Redo previously undone action. Returns True on success.

### get_undo_action_label()
Get description of action that will be undone (for UI display).

### get_redo_action_label()
Get description of action that will be redone (for UI display).

## Usage

Rarely needed in plugins - IDA automatically creates undo points for most operations. Use `create_undo_point()` only for custom atomic operations requiring explicit undo boundaries.

## See Also
Full docs: skill/docs/ida_undo.rst

```

`skills/idapython/docs/ida_undo.rst`:

```rst
ida_undo
========

.. py:module:: ida_undo


Functions
---------

.. autoapisummary::

   ida_undo.create_undo_point
   ida_undo.get_undo_action_label
   ida_undo.get_redo_action_label
   ida_undo.perform_undo
   ida_undo.perform_redo


Module Contents
---------------

.. py:function:: create_undo_point(*args) -> bool

   Create a new restore point. The user can undo to this point in the future. 
           
   :param bytes: body of the record for UNDO_ACTION_START
   :param size: size of the record for UNDO_ACTION_START
   :returns: success; fails if undo is disabled


.. py:function:: get_undo_action_label() -> str

   Get the label of the action that will be undone. This function returns the text that can be displayed in the undo menu 
           
   :returns: success


.. py:function:: get_redo_action_label() -> str

   Get the label of the action that will be redone. This function returns the text that can be displayed in the redo menu 
           
   :returns: success


.. py:function:: perform_undo() -> bool

   Perform undo. 
           
   :returns: success


.. py:function:: perform_redo() -> bool

   Perform redo. 
           
   :returns: success



```

`skills/idapython/docs/ida_xref.md`:

```md
# ida_xref

Cross-reference (xref) tracking between code and data locations.

## Key Classes

### xrefblk_t
Iterator for traversing cross-references efficiently.
- `first_from(ea, flags)` / `next_from()` - Iterate xrefs FROM address
- `first_to(ea, flags)` / `next_to()` - Iterate xrefs TO address
- `frm` / `to` - Source and target addresses
- `type` - Reference type (cref_t or dref_t)
- `iscode` - True if code reference, false if data
- `user` - User-defined (won't be deleted by IDA)

Iterator helpers:
- `crefs_from(ea)` / `crefs_to(ea)` - Code references including flow
- `fcrefs_from(ea)` / `fcrefs_to(ea)` - Code references (no flow)
- `drefs_from(ea)` / `drefs_to(ea)` - Data references

## Key Functions

### add_cref(frm, to, type) / add_dref(frm, to, type)
Create code or data cross-reference.

### del_cref(frm, to, expand) / del_dref(frm, to)
Delete cross-reference (expand=1 deletes target if no more refs).

### get_first_cref_from(frm) / get_next_cref_from(frm, current)
Legacy API for iterating code xrefs FROM address.

### get_first_dref_to(to) / get_next_dref_to(to, current)
Legacy API for iterating data xrefs TO address.

### has_external_refs(pfn, ea)
Check if address has references from outside function.

### create_switch_xrefs(ea, si)
Generate xrefs for switch jump table.

## Reference Types

### Code (cref_t)
- `fl_CF` / `fl_CN` - Call Far/Near (creates function)
- `fl_JF` / `fl_JN` - Jump Far/Near
- `fl_F` - Ordinary flow to next instruction

### Data (dref_t)
- `dr_R` / `dr_W` - Read/Write access
- `dr_O` - Offset reference
- `dr_T` - Text reference (forced operand)

## Flags

- `XREF_USER` - User-defined (persistent)
- `XREF_TAIL` - Reference to tail byte
- `XREF_PASTEND` - Preserve alignment directives
- `XREF_CODE` / `XREF_DATA` - Filter by type
- `XREF_FLOW` / `XREF_NOFLOW` - Include/skip ordinary flow

## See Also
Full docs: skill/docs/ida_xref.rst

```

`skills/idapython/docs/ida_xref.rst`:

```rst
ida_xref
========

.. py:module:: ida_xref

.. autoapi-nested-parse::

   Functions that deal with cross-references (xrefs).

   There are 2 groups of xrefs: CODE and DATA references. All xrefs are kept in the bTree except the ordinary execution flow to the next instruction. The ordinary execution flow to the next instruction is kept in flags (see bytes.hpp)

   The source address of an xref must be an item head (is_head) or a structure member id. Even if an xref is generated by an element in the middle of the item, the item head address must be used. There are some exceptions to the rule but they are not worth mentioning here.

   Xrefs are automatically sorted by addresses. However, the flow to the next instruction is always at the beginning of the list.

   Xrefs are usually created by the processor module, as a reaction to the ev_emu_insn event. Plugins may create xrefs too but please note that upon a reanalysis of an item, all its xrefs, except the ones marked with XREF_USER, are deleted by the kernel. 

   .. tip:: 
      The `IDA Domain API <https://ida-domain.docs.hex-rays.com/>`_ simplifies 
      common tasks and provides better type hints, while remaining fully compatible 
      with IDAPython for advanced use cases.
      
      For cross-reference operations, see :mod:`ida_domain.xrefs`.



Attributes
----------

.. autoapisummary::

   ida_xref.fl_U
   ida_xref.fl_CF
   ida_xref.fl_CN
   ida_xref.fl_JF
   ida_xref.fl_JN
   ida_xref.fl_USobsolete
   ida_xref.fl_F
   ida_xref.dr_U
   ida_xref.dr_O
   ida_xref.dr_W
   ida_xref.dr_R
   ida_xref.dr_T
   ida_xref.dr_I
   ida_xref.dr_S
   ida_xref.XREF_USER
   ida_xref.XREF_TAIL
   ida_xref.XREF_BASE
   ida_xref.XREF_MASK
   ida_xref.XREF_PASTEND
   ida_xref.XREF_FLOW
   ida_xref.XREF_NOFLOW
   ida_xref.XREF_DATA
   ida_xref.XREF_CODE
   ida_xref.XREF_EA
   ida_xref.XREF_TID
   ida_xref.XREF_ALL
   ida_xref.XREF_FAR
   ida_xref.XREF_ALL
   ida_xref.XREF_FAR


Classes
-------

.. autoapisummary::

   ida_xref.cases_and_targets_t
   ida_xref.xrefblk_t
   ida_xref.casevec_t


Functions
---------

.. autoapisummary::

   ida_xref.create_switch_xrefs
   ida_xref.calc_switch_cases
   ida_xref.create_switch_table
   ida_xref.xrefchar
   ida_xref.add_cref
   ida_xref.del_cref
   ida_xref.add_dref
   ida_xref.del_dref
   ida_xref.get_first_dref_from
   ida_xref.get_next_dref_from
   ida_xref.get_first_dref_to
   ida_xref.get_next_dref_to
   ida_xref.get_first_cref_from
   ida_xref.get_next_cref_from
   ida_xref.get_first_cref_to
   ida_xref.get_next_cref_to
   ida_xref.get_first_fcref_from
   ida_xref.get_next_fcref_from
   ida_xref.get_first_fcref_to
   ida_xref.get_next_fcref_to
   ida_xref.has_external_refs
   ida_xref.has_jump_or_flow_xref
   ida_xref.delete_switch_table


Module Contents
---------------

.. py:function:: create_switch_xrefs(ea, si)

   This function creates xrefs from the indirect jump.

   Usually there is no need to call this function directly because the kernel
   will call it for switch tables

   Note: Custom switch information are not supported yet.

   :param ea: address of the 'indirect jump' instruction
   :param si: switch information

   :returns: Boolean


.. py:class:: cases_and_targets_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: cases
      :type:  casevec_t


   .. py:attribute:: targets
      :type:  eavec_t


.. py:function:: calc_switch_cases(ea, si)

   Get information about a switch's cases.

   The returned information can be used as follows:

       for idx in range(len(results.cases)):
           cur_case = results.cases[idx]
           for cidx in range(len(cur_case)):
               print("case: %d" % cur_case[cidx])
           print("  goto 0x%x" % results.targets[idx])

   :param ea: address of the 'indirect jump' instruction
   :param si: switch information

   :returns: a structure with 2 members: 'cases', and 'targets'.


.. py:function:: create_switch_table(ea, si)

   Create switch table from the switch information

   :param ea: address of the 'indirect jump' instruction
   :param si: switch information

   :returns: Boolean


.. py:data:: fl_U

   unknown - for compatibility with old versions. Should not be used anymore. 
             


.. py:data:: fl_CF

   Call Far This xref creates a function at the referenced location 
             


.. py:data:: fl_CN

   Call Near This xref creates a function at the referenced location 
             


.. py:data:: fl_JF

   Jump Far.


.. py:data:: fl_JN

   Jump Near.


.. py:data:: fl_USobsolete

   User specified (obsolete)


.. py:data:: fl_F

   Ordinary flow: used to specify execution flow to the next instruction. 
             


.. py:data:: dr_U

   Unknown - for compatibility with old versions. Should not be used anymore. 
             


.. py:data:: dr_O

   Offset The reference uses 'offset' of data rather than its value OR The reference appeared because the "OFFSET" flag of instruction is set. The meaning of this type is IDP dependent. 
             


.. py:data:: dr_W

   Write access.


.. py:data:: dr_R

   Read access.


.. py:data:: dr_T

   Text (for forced operands only) Name of data is used in manual operand 
             


.. py:data:: dr_I

   Informational (a derived java class references its base class informationally) 
             


.. py:data:: dr_S

   Reference to enum member (symbolic constant)


.. py:data:: XREF_USER

   User specified xref. This xref will not be deleted by IDA. This bit should be combined with the existing xref types (cref_t & dref_t) Cannot be used for fl_F xrefs 
           


.. py:data:: XREF_TAIL

   Reference to tail byte in extrn symbols.


.. py:data:: XREF_BASE

   Reference to the base part of an offset.


.. py:data:: XREF_MASK

   Mask to get xref type.


.. py:data:: XREF_PASTEND

   Reference is past item. This bit may be passed to add_dref() functions but it won't be saved in the database. It will prevent the destruction of eventual alignment directives. 
           


.. py:function:: xrefchar(xrtype: char) -> char

   Get character describing the xref type. 
           
   :param xrtype: combination of Cross-Reference type flags and a cref_t of dref_t value


.. py:function:: add_cref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: cref_t) -> bool

   Create a code cross-reference. 
           
   :param to: linear address of referenced instruction
   :param type: cross-reference type
   :returns: success


.. py:function:: del_cref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> bool

   Delete a code cross-reference. 
           
   :param to: linear address of referenced instruction
   :param expand: policy to delete the referenced instruction
   * 1: plan to delete the referenced instruction if it has no more references.
   * 0: don't delete the referenced instruction even if no more cross-references point to it
   :returns: true: if the referenced instruction will be deleted


.. py:function:: add_dref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: dref_t) -> bool

   Create a data cross-reference. 
           
   :param to: linear address of referenced data
   :param type: cross-reference type
   :returns: success (may fail if user-defined xref exists from->to)


.. py:function:: del_dref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> None

   Delete a data cross-reference. 
           
   :param to: linear address of referenced data


.. py:class:: xrefblk_t

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:attribute:: frm
      :type:  ida_idaapi.ea_t


   .. py:attribute:: to
      :type:  ida_idaapi.ea_t

      the referenced address - filled by first_from(), next_from()



   .. py:attribute:: iscode
      :type:  bool

      is code reference (cref_t)? otherwise it is a data reference (dref_t) 
              



   .. py:attribute:: type
      :type:  uchar

      type of the last returned reference (cref_t & dref_t)



   .. py:attribute:: user
      :type:  bool

      is user defined xref? otherwise defined by ida



   .. py:method:: first_from(_from: ida_idaapi.ea_t, flags: int = 0) -> bool


   .. py:method:: first_to(_to: ida_idaapi.ea_t, flags: int = 0) -> bool


   .. py:method:: next_from(*args) -> bool


   .. py:method:: next_to(*args) -> bool


   .. py:method:: crefs_to(ea)

      Provide an iterator on code references to ea including flow references



   .. py:method:: fcrefs_to(ea)

      Provide an iterator on code references to ea



   .. py:method:: crefs_from(ea)

      Provide an iterator on code references from ea including flow references



   .. py:method:: fcrefs_from(ea)

      Provide an iterator on code references from ea



   .. py:method:: drefs_to(ea)

      Provide an iterator on data references to ea



   .. py:method:: drefs_from(ea)

      Provide an iterator on data references from ea



   .. py:method:: refs_from(ea, flag)

      Provide an iterator on from reference represented by flag



   .. py:method:: refs_to(ea, flag)

      Provide an iterator on to reference represented by flag



.. py:data:: XREF_FLOW

   return all references, including ordinary flow xrefs


.. py:data:: XREF_NOFLOW

   skip ordinary flow xrefs (code xrefs to the next insn) 
           


.. py:data:: XREF_DATA

   return only data references (dr_...)


.. py:data:: XREF_CODE

   return only code references (fl_...)


.. py:data:: XREF_EA

   return only program addresses


.. py:data:: XREF_TID

   return only type ids. XREF_EA and XREF_TID are exclusive, only one of them can be specified 
           


.. py:function:: get_first_dref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get first data referenced from the specified address. 
           
   :returns: linear address of first (lowest) data referenced from the specified address. Return BADADDR if the specified instruction/data doesn't reference to anything.


.. py:function:: get_next_dref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get next data referenced from the specified address. 
           
   :param current: linear address of current referenced data. This value is returned by get_first_dref_from() or previous call to get_next_dref_from() functions.
   :returns: linear address of next data or BADADDR.


.. py:function:: get_first_dref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get address of instruction/data referencing to the specified data. 
           
   :param to: linear address of referencing instruction or data
   :returns: BADADDR if nobody refers to the specified data.


.. py:function:: get_next_dref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get address of instruction/data referencing to the specified data 
           
   :param to: linear address of referencing instruction or data
   :param current: current linear address. This value is returned by get_first_dref_to() or previous call to get_next_dref_to() functions.
   :returns: BADADDR if nobody refers to the specified data.


.. py:function:: get_first_cref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get first instruction referenced from the specified instruction. If the specified instruction passes execution to the next instruction then the next instruction is returned. Otherwise the lowest referenced address is returned (remember that xrefs are kept sorted!). 
           
   :returns: first referenced address. If the specified instruction doesn't reference to other instructions then returns BADADDR.


.. py:function:: get_next_cref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get next instruction referenced from the specified instruction. 
           
   :param current: linear address of current referenced instruction This value is returned by get_first_cref_from() or previous call to get_next_cref_from() functions.
   :returns: next referenced address or BADADDR.


.. py:function:: get_first_cref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get first instruction referencing to the specified instruction. If the specified instruction may be executed immediately after its previous instruction then the previous instruction is returned. Otherwise the lowest referencing address is returned. (remember that xrefs are kept sorted!). 
           
   :param to: linear address of referenced instruction
   :returns: linear address of the first referencing instruction or BADADDR.


.. py:function:: get_next_cref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

   Get next instruction referencing to the specified instruction. 
           
   :param to: linear address of referenced instruction
   :param current: linear address of current referenced instruction This value is returned by get_first_cref_to() or previous call to get_next_cref_to() functions.
   :returns: linear address of the next referencing instruction or BADADDR.


.. py:function:: get_first_fcref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: get_next_fcref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: get_first_fcref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: get_next_fcref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

.. py:function:: has_external_refs(pfn: func_t *, ea: ida_idaapi.ea_t) -> bool

   Does 'ea' have references from outside of 'pfn'?


.. py:function:: has_jump_or_flow_xref(ea: ida_idaapi.ea_t) -> bool

   Are there jump or flow references to EA?


.. py:function:: delete_switch_table(jump_ea: ida_idaapi.ea_t, si: switch_info_t) -> None

.. py:data:: XREF_ALL

.. py:data:: XREF_FAR

.. py:class:: casevec_t(*args)

   Bases: :py:obj:`object`


   .. py:attribute:: thisown


   .. py:method:: push_back(*args) -> qvector< long long > &


   .. py:method:: pop_back() -> None


   .. py:method:: size() -> size_t


   .. py:method:: empty() -> bool


   .. py:method:: at(_idx: size_t) -> qvector< long long > const &


   .. py:method:: qclear() -> None


   .. py:method:: clear() -> None


   .. py:method:: resize(*args) -> None


   .. py:method:: grow(*args) -> None


   .. py:method:: capacity() -> size_t


   .. py:method:: reserve(cnt: size_t) -> None


   .. py:method:: truncate() -> None


   .. py:method:: swap(r: casevec_t) -> None


   .. py:method:: extract() -> qvector< long long > *


   .. py:method:: inject(s: qvector< long long > *, len: size_t) -> None


   .. py:method:: begin(*args) -> qvector< qvector< long long > >::const_iterator


   .. py:method:: end(*args) -> qvector< qvector< long long > >::const_iterator


   .. py:method:: insert(it: qvector< qvector< long long > >::iterator, x: qvector< long long > const &) -> qvector< qvector< long long > >::iterator


   .. py:method:: erase(*args) -> qvector< qvector< long long > >::iterator


   .. py:method:: find(*args) -> qvector< qvector< long long > >::const_iterator


   .. py:method:: has(x: qvector< long long > const &) -> bool


   .. py:method:: add_unique(x: qvector< long long > const &) -> bool


   .. py:method:: append(x: qvector< long long > const &) -> None


   .. py:method:: extend(x: casevec_t) -> None


   .. py:attribute:: front


   .. py:attribute:: back


.. py:data:: XREF_ALL

.. py:data:: XREF_FAR


```

`skills/idapython/docs/idaapi.md`:

```md
# idaapi

Low-level module exposing global C variables via `cvar` attribute.

## Key Attributes

### cvar
Global variable container - provides access to IDA's C-level global variables (e.g., `idaapi.cvar.inf` for binary info, `idaapi.cvar.database_flags` for IDB state).

## See Also
Full docs: skill/docs/idaapi.rst

```

`skills/idapython/docs/idaapi.rst`:

```rst
idaapi
======

.. py:module:: idaapi


Attributes
----------

.. autoapisummary::

   idaapi.cvar


Classes
-------

.. autoapisummary::

   idaapi.idaapi_Cvar


Module Contents
---------------

.. py:class:: idaapi_Cvar

   Bases: :py:obj:`object`


.. py:data:: cvar


```

`skills/idapython/docs/idadex.md`:

```md
# idadex

DEX (Dalvik Executable) file parsing utilities for Android reverse engineering.

## Key Classes

### Dex
Primary DEX file parser exposing methods/fields/strings/types from Android binaries.

**String Operations**:
- `get_string(from_ea, string_idx)` - retrieve string by index
- `as_string(s)` - convert DEX string to Python string

**Method Operations**:
- `get_method(from_ea, method_idx)` - retrieve method by index
- `get_method_name(from_ea, method_idx)` - get method name
- `get_short_method_name(method)` - short form (e.g., `onCreate`)
- `get_full_method_name(method)` - fully qualified (e.g., `android.app.Activity.onCreate`)
- `get_call_method_name(method)` - name for call sites

**Type Operations**:
- `get_type_string(from_ea, type_idx)` - get type descriptor
- `decorate_java_typename(desc)` - convert type descriptor to Java notation
- `is_wide_type(typechar)` - check if type is 64-bit

**Field Operations**:
- `get_field(from_ea, field_idx)` - retrieve field by index
- `get_field_name(from_ea, field_idx)` - get field name
- `get_full_field_name(field_idx, field, field_name)` - fully qualified field name

**Utility**:
- `access_string(flags)` - convert access flags to string (public/private/etc)
- `idx_to_ea(from_ea, idx, tag)` - convert DEX index to IDA address

### dex_method
`ctypes.LittleEndianStructure` representing DEX method metadata.
- `IS_LOCAL = 1` - flag for local method
- `HAS_CODE = 2` - flag indicating method has code
- `is_local()` - check if method is local

### dex_field
`ctypes.LittleEndianStructure` representing DEX field metadata.

## Key Functions

- `to_uint32(v)` - convert to unsigned 32-bit int
- `unpack_db(buf, off)` - unpack byte from buffer
- `unpack_dw(buf, off)` - unpack word from buffer
- `unpack_dd(buf, off)` - unpack dword from buffer
- `unpack_dq(buf, off)` - unpack qword from buffer
- `unpack_ea(buf, off)` - unpack effective address from buffer

## Global Object

### dex
Global `Dex` instance - use this to access DEX parsing functions.

## See Also
Full docs: skill/docs/idadex.rst

```

`skills/idapython/docs/idadex.rst`:

```rst
idadex
======

.. py:module:: idadex


Attributes
----------

.. autoapisummary::

   idadex.uint8
   idadex.char
   idadex.uint32
   idadex.uint64
   idadex.uint16
   idadex.ushort
   idadex.ea_t
   idadex.dex


Classes
-------

.. autoapisummary::

   idadex.dex_method
   idadex.dex_field
   idadex.longname_director_t
   idadex.Dex


Functions
---------

.. autoapisummary::

   idadex.to_uint32
   idadex.get_struct
   idadex.unpack_db
   idadex.get_dw
   idadex.unpack_dw
   idadex.unpack_dd
   idadex.unpack_dq
   idadex.unpack_ea
   idadex.unpack_eavec


Module Contents
---------------

.. py:data:: uint8

.. py:data:: char

.. py:data:: uint32

.. py:data:: uint64

.. py:data:: uint16

.. py:data:: ushort

.. py:data:: ea_t

.. py:function:: to_uint32(v)

.. py:function:: get_struct(str_, off, struct)

.. py:function:: unpack_db(buf, off)

.. py:function:: get_dw(buf, off)

.. py:function:: unpack_dw(buf, off)

.. py:function:: unpack_dd(buf, off)

.. py:function:: unpack_dq(buf, off)

.. py:function:: unpack_ea(buf, off)

.. py:function:: unpack_eavec(buf, base_ea)

.. py:class:: dex_method

   Bases: :py:obj:`ctypes.LittleEndianStructure`


   Structure base class


   .. py:attribute:: IS_LOCAL
      :value: 1



   .. py:attribute:: HAS_CODE
      :value: 2



   .. py:method:: is_local()


.. py:class:: dex_field

   Bases: :py:obj:`ctypes.LittleEndianStructure`


   Structure base class


.. py:class:: longname_director_t

   Bases: :py:obj:`ctypes.LittleEndianStructure`


   Structure base class


.. py:class:: Dex

   Bases: :py:obj:`object`


   .. py:attribute:: HASHVAL_MAGIC
      :value: 'version'



   .. py:attribute:: HASHVAL_OPTIMIZED
      :value: 'optimized'



   .. py:attribute:: HASHVAL_DEXVERSION
      :value: 'dex_version'



   .. py:attribute:: META_BASEADDRS
      :value: 1



   .. py:attribute:: DEXCMN_STRING_ID


   .. py:attribute:: DEXCMN_METHOD_ID


   .. py:attribute:: DEXCMN_TRY_TYPES


   .. py:attribute:: DEXCMN_TRY_IDS


   .. py:attribute:: DEXCMN_DEBINFO


   .. py:attribute:: DEXCMN_DEBSTR


   .. py:attribute:: DEXVAR_STRING_IDS


   .. py:attribute:: DEXVAR_TYPE_IDS


   .. py:attribute:: DEXVAR_TYPE_STR


   .. py:attribute:: DEXVAR_TYPE_STRO


   .. py:attribute:: DEXVAR_METHOD


   .. py:attribute:: DEXVAR_METH_STR


   .. py:attribute:: DEXVAR_METH_STRO


   .. py:attribute:: DEXVAR_FIELD


   .. py:attribute:: DEXVAR_TRYLIST


   .. py:attribute:: DEBINFO_LINEINFO
      :value: 1



   .. py:attribute:: nn_meta


   .. py:attribute:: nn_cmn


   .. py:attribute:: baseaddrs
      :value: []



   .. py:attribute:: nn_vars
      :value: []



   .. py:method:: get_dexnum(from_ea)


   .. py:method:: get_nn_var(from_ea)


   .. py:attribute:: ACCESS_FLAGS


   .. py:method:: access_string(flags)
      :staticmethod:



   .. py:method:: as_string(s)
      :staticmethod:



   .. py:method:: idx_to_ea(from_ea, idx, tag)


   .. py:method:: get_string(from_ea, string_idx)


   .. py:method:: get_method_idx(ea)


   .. py:method:: get_method(from_ea, method_idx)


   .. py:method:: get_string_by_index(node, idx, tag)
      :staticmethod:



   .. py:attribute:: PRIMITVE_TYPES


   .. py:method:: is_wide_type(typechar)
      :staticmethod:



   .. py:method:: decorate_java_typename(desc)
      :staticmethod:



   .. py:method:: get_type_string(from_ea, type_idx)


   .. py:method:: get_method_name(from_ea, method_idx)


   .. py:method:: get_parameter_name(from_ea, idx)


   .. py:method:: get_short_type_name(longname)
      :staticmethod:



   .. py:method:: get_full_type_name(longname)
      :staticmethod:



   .. py:method:: get_short_method_name(method)


   .. py:method:: get_full_method_name(method)


   .. py:method:: get_call_method_name(method)


   .. py:method:: get_field(from_ea, field_idx)


   .. py:method:: get_field_name(from_ea, field_idx)


   .. py:method:: get_full_field_name(field_idx, field, field_name)


   .. py:method:: get_short_field_name(field_idx, field, field_name)


.. py:data:: dex


```

`skills/idapython/docs/idautils.md`:

```md
# idautils

High-level utility functions for IDA - iteration, xrefs, decoding, assembly.

## Key Functions

### Cross-References
- `XrefsTo(ea, flags=0)` - iterate all xrefs to address (returns xref objects with `.frm`, `.to`, `.type`)
- `XrefsFrom(ea, flags=0)` - iterate all xrefs from address
- `CodeRefsTo(ea, flow)` - code references to address (list of EAs)
- `CodeRefsFrom(ea, flow)` - code references from address
- `DataRefsTo(ea)` - data references to address
- `DataRefsFrom(ea)` - data references from address
- `XrefTypeName(typecode)` - convert xref type code to readable name

### Iteration
- `Functions(start=None, end=None)` - iterate function entry points
- `FuncItems(start)` - iterate items (instructions/data) within function
- `Chunks(start)` - iterate function chunks (returns `(start_ea, end_ea)` tuples)
- `Heads(start=None, end=None)` - iterate all heads (instructions or data items)
- `Segments()` - iterate segment start addresses
- `Names()` - iterate all names (returns `(ea, name)` tuples)
- `Entries()` - iterate entry points/exports (returns `(index, ordinal, ea, name)` tuples)
- `Structs()` - iterate structures (returns `(ordinal, sid, name)` tuples)
- `StructMembers(sid)` - iterate structure members (returns `(offset, name, size)` tuples)

### Instruction Decoding
- `DecodeInstruction(ea)` - decode instruction at EA (returns `insn_t` instance or None)
- `DecodePreviousInstruction(ea)` - decode previous instruction
- `DecodePrecedingInstruction(ea)` - decode preceding instruction in execution flow (returns `(insn_t, farref)`)

### Assembly
- `Assemble(ea, line)` - assemble instruction(s) at address (returns `(success, result)`)

### Debugging
- `Threads()` - iterate thread IDs for current debuggee
- `Modules()` - iterate loaded modules (returns objects with `name`, `size`, `base`, `rebase_to`)

### Miscellaneous
- `GetIdbDir()` - get IDB directory path
- `GetRegisterList()` - get list of processor registers
- `GetInstructionList()` - get list of processor instructions
- `ProcessUiActions(actions, flags=0)` - execute UI actions programmatically
- `GetInputFileMD5` - MD5 hash of input file

## Key Classes

### Strings
Iterator for string list (also used by IDA's "Strings" window).

**Usage**:
```python
s = Strings()
for i in s:
    print(f"{i.ea:x}: len={i.length} type={i.strtype} -> '{i}'")
```

**Methods**:
- `setup(strtypes=[STRTYPE_C], minlen=5, only_7bit=True, ...)` - configure string search
- `refresh()` - refresh string list
- `clear_cache()` - clear string cache

**StringItem attributes**:
- `ea` - string address
- `strtype` - string type (STRTYPE_xxx)
- `length` - string length
- `is_1_byte_encoding()` - check encoding

### peutils_t
PE (Portable Executable) utility class for Windows binaries.

**Attributes**:
- `imagebase` - loading address (usually pe.imagebase)
- `header_offset` - offset of PE header
- `header` - complete PE header (`peheader_t` instance)

## Global Objects

### cpu
Register accessor - use as `cpu.Eax`, `cpu.Rsp`, etc. to read current register values during debugging.

### procregs
Processor register definitions - use to compare operands (e.g., `if x.Op1.reg == procregs.Esp`).

## See Also
Full docs: skill/docs/idautils.rst

```

`skills/idapython/docs/idautils.rst`:

```rst
idautils
========

.. py:module:: idautils

.. autoapi-nested-parse::

   idautils.py - High level utility functions for IDA



Attributes
----------

.. autoapisummary::

   idautils.GetInputFileMD5
   idautils.cpu
   idautils.procregs


Classes
-------

.. autoapisummary::

   idautils.Strings
   idautils.peutils_t


Functions
---------

.. autoapisummary::

   idautils.CodeRefsTo
   idautils.CodeRefsFrom
   idautils.DataRefsTo
   idautils.DataRefsFrom
   idautils.XrefTypeName
   idautils.XrefsFrom
   idautils.XrefsTo
   idautils.Threads
   idautils.Heads
   idautils.Functions
   idautils.Chunks
   idautils.Modules
   idautils.Names
   idautils.Segments
   idautils.Entries
   idautils.FuncItems
   idautils.Structs
   idautils.StructMembers
   idautils.DecodePrecedingInstruction
   idautils.DecodePreviousInstruction
   idautils.DecodeInstruction
   idautils.GetDataList
   idautils.PutDataList
   idautils.MapDataList
   idautils.GetIdbDir
   idautils.GetRegisterList
   idautils.GetInstructionList
   idautils.Assemble
   idautils.ProcessUiActions


Module Contents
---------------

.. py:function:: CodeRefsTo(ea, flow: bool)

   Get a list of code references to 'ea'

   :param ea:   Target address
   :param flow: Follow normal code flow or not

   :returns: list of references (may be empty list)

   Example::

       for ref in CodeRefsTo(get_screen_ea(), 1):
           print(ref)


.. py:function:: CodeRefsFrom(ea, flow: bool)

   Get a list of code references from 'ea'

   :param ea:   Target address
   :param flow: Follow normal code flow or not

   :returns: list of references (may be empty list)

   Example::

       for ref in CodeRefsFrom(get_screen_ea(), 1):
           print(ref)


.. py:function:: DataRefsTo(ea)

   Get a list of data references to 'ea'

   :param ea:   Target address

   :returns: list of references (may be empty list)

   Example::

       for ref in DataRefsTo(get_screen_ea()):
           print(ref)


.. py:function:: DataRefsFrom(ea)

   Get a list of data references from 'ea'

   :param ea:   Target address

   :returns: list of references (may be empty list)

   Example::

       for ref in DataRefsFrom(get_screen_ea()):
           print(ref)


.. py:function:: XrefTypeName(typecode)

   Convert cross-reference type codes to readable names

   :param typecode: cross-reference type code


.. py:function:: XrefsFrom(ea, flags=0)

   Return all references from address 'ea'

   :param ea: Reference address
   :param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA

   Example::
          for xref in XrefsFrom(here(), 0):
              print(xref.type, XrefTypeName(xref.type),                          'from', hex(xref.frm), 'to', hex(xref.to))


.. py:function:: XrefsTo(ea, flags=0)

   Return all references to address 'ea'

   :param ea: Reference address
   :param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA

   Example::
          for xref in XrefsTo(here(), 0):
              print(xref.type, XrefTypeName(xref.type),                          'from', hex(xref.frm), 'to', hex(xref.to))


.. py:function:: Threads()

   Returns all thread IDs for the current debugee


.. py:function:: Heads(start=None, end=None)

   Get a list of heads (instructions or data items)

   :param start: start address (default: inf.min_ea)
   :param end:   end address (default: inf.max_ea)

   :returns: list of heads between start and end


.. py:function:: Functions(start=None, end=None)

   Get a list of functions

   :param start: start address (default: inf.min_ea)
   :param end:   end address (default: inf.max_ea)

   :returns: list of function entrypoints between start and end

   NOTE: The last function that starts before 'end' is included even
   if it extends beyond 'end'. Any function that has its chunks scattered
   in multiple segments will be reported multiple times, once in each segment
   as they are listed.


.. py:function:: Chunks(start)

   Get a list of function chunks
   See also ida_funcs.func_tail_iterator_t

   :param start: address of the function

   :returns: list of function chunks (tuples of the form (start_ea, end_ea))
            belonging to the function


.. py:function:: Modules()

   Returns a list of module objects with name,size,base and the rebase_to attributes


.. py:function:: Names()

   Returns a list of names

   :returns: List of tuples (ea, name)


.. py:function:: Segments()

   Get list of segments (sections) in the binary image

   :returns: List of segment start addresses.


.. py:function:: Entries()

   Returns a list of entry points (exports)

   :returns: List of tuples (index, ordinal, ea, name)


.. py:function:: FuncItems(start)

   Get a list of function items (instruction or data items inside function boundaries)
   See also ida_funcs.func_item_iterator_t

   :param start: address of the function

   :returns: ea of each item in the function


.. py:function:: Structs()

   Get a list of structures

   :returns: List of tuples (ordinal, sid, name)


.. py:function:: StructMembers(sid)

   Get a list of structure members information (or stack vars if given a frame).

   :param sid: ID of the structure.

   :returns: List of tuples (offset_in_bytes, name, size_in_bytes)

   NOTE: If 'sid' does not refer to a valid structure, an exception will be raised.
   NOTE: This will not return 'holes' in structures/stack frames; it only returns defined structure members.


.. py:function:: DecodePrecedingInstruction(ea)

   Decode preceding instruction in the execution flow.

   :param ea: address to decode
   :returns: (None or the decode instruction, farref)
            farref will contain 'true' if followed an xref, false otherwise


.. py:function:: DecodePreviousInstruction(ea)

   Decodes the previous instruction and returns an insn_t like class

   :param ea: address to decode
   :returns: None or a new insn_t instance


.. py:function:: DecodeInstruction(ea)

   Decodes an instruction and returns an insn_t like class

   :param ea: address to decode
   :returns: None or a new insn_t instance


.. py:function:: GetDataList(ea, count, itemsize=1)

   Get data list - INTERNAL USE ONLY


.. py:function:: PutDataList(ea, datalist, itemsize=1)

   Put data list - INTERNAL USE ONLY


.. py:function:: MapDataList(ea, length, func, wordsize=1)

   Map through a list of data words in the database

   :param ea:       start address
   :param length:   number of words to map
   :param func:     mapping function
   :param wordsize: size of words to map [default: 1 byte]

   :returns: None


.. py:data:: GetInputFileMD5

.. py:class:: Strings(default_setup=False)

   Bases: :py:obj:`object`


   Allows iterating over the string list. The set of strings will not be
   modified, unless asked explicitly at setup()-time. This string list also
   is used by the "String window" so it may be changed when this window is
   updated.

   Example:
       s = Strings()

       for i in s:
           print("%x: len=%d type=%d -> '%s'" % (i.ea, i.length, i.strtype, str(i)))



   .. py:class:: StringItem(si)

      Bases: :py:obj:`object`


      Class representing each string item.


      .. py:attribute:: ea

         String ea



      .. py:attribute:: strtype

         string type (STRTYPE_xxxxx)



      .. py:attribute:: length

         string length



      .. py:method:: is_1_byte_encoding()



   .. py:method:: clear_cache()

      Clears the string list cache



   .. py:attribute:: size
      :value: 0



   .. py:method:: refresh()

      Refreshes the string list



   .. py:method:: setup(strtypes=[ida_nalt.STRTYPE_C], minlen=5, only_7bit=True, ignore_instructions=False, display_only_existing_strings=False)


.. py:function:: GetIdbDir()

   Get IDB directory

   This function returns directory path of the current IDB database


.. py:function:: GetRegisterList()

   Returns the register list


.. py:function:: GetInstructionList()

   Returns the instruction list of the current processor module


.. py:function:: Assemble(ea, line)

   Assembles one or more lines (does not display an message dialogs)
   If line is a list then this function will attempt to assemble all the lines
   This function will turn on batch mode temporarily so that no messages are displayed on the screen

   :param ea:       start address
   :returns: (False, "Error message") or (True, asm_buf) or (True, [asm_buf1, asm_buf2, asm_buf3])


.. py:function:: ProcessUiActions(actions, flags=0)

   :param actions: A string containing a list of actions separated by semicolon, a list or a tuple
   :param flags: flags to be passed to process_ui_action()
   :returns: Boolean. Returns False if the action list was empty or execute_ui_requests() failed.


.. py:class:: peutils_t

   Bases: :py:obj:`object`


   PE utility class. Retrieves PE information from the database.

   Constants from pe.h


   .. py:attribute:: PE_NODE
      :value: '$ PE header'



   .. py:attribute:: PE_ALT_DBG_FPOS


   .. py:attribute:: PE_ALT_IMAGEBASE


   .. py:attribute:: PE_ALT_PEHDR_OFF


   .. py:attribute:: PE_ALT_NEFLAGS


   .. py:attribute:: PE_ALT_TDS_LOADED


   .. py:attribute:: PE_ALT_PSXDLL


   .. py:attribute:: imagebase

      Loading address (usually pe.imagebase)



   .. py:attribute:: header_offset

      Offset of PE header



   .. py:attribute:: header

      Returns the complete PE header as an instance of peheader_t (defined in the SDK).



.. py:data:: cpu

   This is a special class instance used to access the registers as if they were attributes of this object.
   For example to access the EAX register:
       print("%x" % cpu.Eax)


.. py:data:: procregs

   This object is used to access the processor registers. It is useful when decoding instructions and you want to see which instruction is which.
   For example:
       x = idautils.DecodeInstruction(here())
       if x[0] == procregs.Esp:
           print("This operand is the register ESP)



```

`skills/idapython/docs/idc.md`:

```md
# idc

IDC compatibility module - legacy IDA scripting interface with 600+ functions for reverse engineering tasks.

## Core Constants
- `BADADDR` - invalid address constant (0xFFFFFFFFFFFFFFFF)
- `BADSEL` - invalid selector
- Flag constants: `FF_CODE`, `FF_DATA`, `FF_UNK`, `FF_TAIL`, etc.
- Data types: `FF_BYTE`, `FF_WORD`, `FF_DWORD`, `FF_QWORD`, `FF_STRLIT`, etc.

## Memory & Bytes

### Reading Memory
- `get_db_byte(ea)` - read byte from database
- `get_wide_byte(ea)` - read byte with segment translation
- `get_wide_word(ea)` - read 16-bit word
- `get_wide_dword(ea)` - read 32-bit dword
- `get_qword(ea)` - read 64-bit qword
- `get_bytes(ea, size)` - read byte array
- `get_original_byte(ea)` - get original file byte (before patching)

### Writing Memory
- `patch_byte(ea, value)` - patch byte in database
- `patch_word(ea, value)` - patch 16-bit word
- `patch_dword(ea, value)` - patch 32-bit dword
- `patch_qword(ea, value)` - patch 64-bit qword
- `patch_dbg_byte(ea, value)` - patch byte in debugger memory

### Debugger Memory
- `read_dbg_memory(ea, size)` - read from debugger memory
- `write_dbg_memory(ea, data)` - write to debugger memory
- `read_dbg_byte/word/dword/qword(ea)` - typed debugger reads

## Names & Addresses

### Name Operations
- `set_name(ea, name, flags=SN_CHECK)` - set name at address
- `get_name(ea, flags=0)` - get name at address
- `demangle_name(name, disable_mask)` - demangle C++ name
- `get_name_ea(from, name)` - find address by name
- `get_name_ea_simple(name)` - simple name lookup

### Address Navigation
- `get_screen_ea()` - current cursor address
- `jumpto(ea)` - jump to address in disassembly
- `next_addr(ea)` - next address
- `prev_addr(ea)` - previous address
- `next_head(ea, max_ea)` - next instruction/data head
- `prev_head(ea, min_ea)` - previous instruction/data head
- `next_not_tail(ea)` - skip tail bytes
- `prev_not_tail(ea)` - skip tail bytes backward
- `get_item_head(ea)` - start of item containing ea
- `get_item_end(ea)` - end of item containing ea
- `get_item_size(ea)` - size of item

## Instructions & Disassembly

### Instruction Creation
- `create_insn(ea)` - create instruction at address
- `del_items(ea, flags)` - delete instruction/data items

### Disassembly Text
- `generate_disasm_line(ea, flags)` - generate disassembly line
- `GetDisasm(ea)` - get disassembly text
- `print_insn_mnem(ea)` - get instruction mnemonic
- `print_operand(ea, n)` - get operand text

### Operand Analysis
- `get_operand_type(ea, n)` - operand type (o_reg, o_mem, o_imm, etc.)
- `get_operand_value(ea, n)` - operand numeric value

## Data Creation

### Create Data Items
- `create_byte(ea)` - create byte at address
- `create_word(ea)` - create word
- `create_dword(ea)` - create dword
- `create_qword(ea)` - create qword
- `create_oword(ea)` - create oword (16 bytes)
- `create_float(ea)` - create float
- `create_double(ea)` - create double
- `create_strlit(ea, endea)` - create string literal
- `create_struct(ea, size, strname)` - apply structure
- `make_array(ea, nitems)` - create array

### Data Type Checks (Flags)
- `is_byte/word/dword/qword/oword(flags)` - check data size
- `is_float/double/pack_real(flags)` - check floating types
- `is_strlit(flags)` - check if string literal
- `is_struct(flags)` - check if structure
- `is_code/data/tail/unknown/head(flags)` - check item type
- `get_full_flags(ea)` - get all flags for address

## Operand Formatting

### Set Display Format
- `op_hex(ea, n)` - display operand as hex
- `op_dec(ea, n)` - display as decimal
- `op_oct(ea, n)` - display as octal
- `op_bin(ea, n)` - display as binary
- `op_chr(ea, n)` - display as character
- `op_num(ea, n)` - display as number
- `op_offset(ea, n, base)` - display as offset
- `op_seg(ea, n)` - display as segment
- `op_enum(ea, n, enum_id, serial)` - display as enum member
- `op_stroff(ea, n, strid, delta)` - display as struct offset
- `op_stkvar(ea, n)` - display as stack variable
- `toggle_sign(ea, n)` - toggle signed/unsigned
- `toggle_bnot(ea, n)` - toggle bitwise NOT

## Comments

### Comment Operations
- `set_cmt(ea, comment, rptble)` - set comment (rptble: 0=regular, 1=repeatable)
- `get_cmt(ea, rptble)` - get comment
- `get_extra_cmt(ea, what)` - get anterior/posterior comment
- `update_extra_cmt(ea, what, text)` - update extra comment
- `del_extra_cmt(ea, what)` - delete extra comment

## Functions

### Function Management
- `add_func(start, end=BADADDR)` - create function
- `del_func(ea)` - delete function
- `set_func_end(ea, end)` - set function end
- `get_fchunk_referer(ea)` - get function chunk owner
- `func_contains(func_ea, ea)` - check if address in function

### Function Attributes (get_func_attr/set_func_attr)
- `FUNCATTR_START` - function start address
- `FUNCATTR_END` - function end address
- `FUNCATTR_FLAGS` - function flags (FUNC_NORET, FUNC_FAR, FUNC_LIB, etc.)
- `FUNCATTR_FRAME` - frame ID
- `FUNCATTR_FRSIZE` - frame size
- `FUNCATTR_ARGSIZE` - argument area size

## Segments

### Segment Navigation
- `get_first_seg()` - get first segment
- `get_next_seg(ea)` - get next segment
- `get_segm_start(ea)` - segment start address
- `get_segm_end(ea)` - segment end address
- `get_segm_name(ea)` - segment name
- `get_segm_by_sel(sel)` - find segment by selector

### Segment Creation/Modification
- `add_segm_ex(start, end, base, use32, align, comb, flags)` - add segment
- `del_segm(ea, flags)` - delete segment
- `set_segm_name(ea, name)` - rename segment
- `set_segm_class(ea, class)` - set segment class
- `set_segment_bounds(ea, start, end, flags)` - resize segment
- `rebase_program(delta, flags)` - rebase entire program

## Cross-References (Xrefs)

### Code Xrefs
- `add_cref(from, to, type)` - add code xref
- `del_cref(from, to, expand)` - delete code xref
- `get_first_cref_from(ea)` - first code xref from address
- `get_next_cref_from(ea, current)` - next code xref from
- `get_first_cref_to(ea)` - first code xref to address
- `get_next_cref_to(ea, current)` - next code xref to
- `get_first_fcref_from/to(ea)` - flow code xrefs only

### Data Xrefs
- `add_dref(from, to, type)` - add data xref (dr_O, dr_W, dr_R types)
- `del_dref(from, to)` - delete data xref
- `get_first_dref_from(ea)` - first data xref from
- `get_next_dref_from(ea, current)` - next data xref from
- `get_first_dref_to(ea)` - first data xref to
- `get_next_dref_to(ea, current)` - next data xref to

## Search Functions

### Pattern Search
- `find_bytes(ea, size, pattern, radix)` - find byte pattern
- `find_text(ea, flags, y, x, text)` - find text string
- `find_code(ea, flag)` - find next code byte
- `find_data(ea, flag)` - find next data byte
- `find_unknown(ea, flag)` - find next unknown byte
- `find_defined(ea, flag)` - find next defined byte
- `find_imm(ea, flag, value)` - find immediate value

## Database & Files

### Database Operations
- `save_database(idbname, flags)` - save IDB
- `get_idb_path()` - get IDB file path
- `get_root_filename()` - get input file name (no path)
- `get_input_file_path()` - get full input file path
- `set_root_filename(name)` - set root filename
- `retrieve_input_file_md5()` - get MD5 of input file

### IDB Info (get_inf_attr/set_inf_attr)
- `INF_MIN_EA` - minimum address
- `INF_MAX_EA` - maximum address
- `INF_START_EA` - entry point address
- `INF_PROCNAME` - processor name
- `INF_FILETYPE` - file type (FT_PE, FT_ELF, FT_MACHO, etc.)
- `INF_OSTYPE` - OS type
- `INF_COMPILER` - compiler ID

## Auto-Analysis

### Analysis Control
- `auto_wait()` - wait for auto-analysis to complete
- `plan_and_wait(start, end, final_pass)` - analyze range and wait
- `auto_mark_range(start, end, qtype)` - mark range for analysis
- `auto_unmark(start, end, qtype)` - unmark range
- Analysis types: `AU_UNK`, `AU_CODE`, `AU_PROC`, `AU_USED`, `AU_LIBF`, `AU_FINAL`

## Debugger (Unsafe)

### Process Control
- `load_debugger(dbg, use_remote)` - load debugger
- `start_process(path, args, sdir)` - start debugging
- `exit_process()` - terminate process
- `attach_process(pid, event_id)` - attach to process
- `detach_process()` - detach from process
- `suspend_process()` - suspend process
- `get_processes()` - list processes

### Execution Control
- `step_into()` - step into instruction
- `step_over()` - step over instruction
- `run_to(ea)` - run to address
- `step_until_ret()` - run until return
- `wait_for_next_event(wfne, timeout)` - wait for debug event

### Breakpoints
- `add_bpt(ea, size, type)` - add breakpoint
- `del_bpt(ea)` - delete breakpoint
- `enable_bpt(ea, enable)` - enable/disable breakpoint
- `check_bpt(ea)` - check breakpoint status
- `get_bpt_qty()` - get breakpoint count
- Breakpoint types: `BPT_SOFT`, `BPT_EXEC`, `BPT_WRITE`, `BPT_RDWR`

### Registers & Threads
- `get_reg_value(name)` - get register value
- `get_thread_qty()` - thread count
- `getn_thread(idx)` - get thread ID
- `get_current_thread()` - current thread ID
- `select_thread(tid)` - switch thread
- `suspend_thread(tid)` - suspend thread
- `resume_thread(tid)` - resume thread

## Entry Points
- `get_entry_qty()` - number of entry points
- `get_entry(ordinal)` - get entry point address
- `get_entry_ordinal(index)` - get ordinal by index
- `get_entry_name(ordinal)` - get entry point name
- `add_entry(ordinal, ea, name, makecode)` - add entry point
- `rename_entry(ordinal, name)` - rename entry point

## Utilities

### String Operations
- `strlen(s)` - string length
- `substr(s, x1, x2)` - substring
- `strstr(s1, s2)` - find substring
- `form(format, *args)` - formatted string (printf-style)

### Number Conversion
- `atol(s)` - string to long
- `ltoa(n, radix)` - long to string
- `atoa(ea)` - address to string
- `xtol(s)` - hex string to long
- `rotate_left/dword/word/byte(value, count)` - bitwise rotation

### UI Interaction
- `msg(format, *args)` - print to output window
- `warning(format, *args)` - show warning dialog
- `error(format, *args)` - show error dialog
- `ask_yn(default, format, *args)` - yes/no dialog
- `jumpto(ea)` - jump to address
- `refresh_idaview_anyway()` - force UI refresh

### Execution
- `eval_idc(expr)` - evaluate IDC expression
- `qsleep(milliseconds)` - sleep
- `call_system(command)` - execute system command
- `batch(enable)` - enable/disable batch mode
- `qexit(code)` - exit IDA
- `process_ui_action(name)` - trigger UI action

## Name Flags
- `SN_CHECK` - check name for validity
- `SN_NOCHECK` - don't check name
- `SN_PUBLIC` - public name
- `SN_NON_PUBLIC` - private name
- `SN_WEAK` - weak name
- `SN_AUTO` - auto-generated name
- `SN_LOCAL` - local name
- `SN_NOLIST` - don't show in names list
- `SN_NOWARN` - suppress warnings

## Get Name Flags (GN_* for get_name)
- `GN_VISIBLE` - return visible name
- `GN_COLORED` - include color tags
- `GN_DEMANGLED` - return demangled name
- `GN_STRICT` - fail if no name
- `GN_SHORT` - short form
- `GN_LONG` - long form
- `GN_LOCAL` - include local name part

## See Also
Full docs: skill/docs/idc.rst

Note: This is a legacy compatibility module. Modern Python scripts should prefer `idaapi`, `ida_bytes`, `ida_name`, `ida_funcs`, etc. modules over idc functions.

```

`skills/idapython/docs/idc.rst`:

```rst
idc
===

.. py:module:: idc

.. autoapi-nested-parse::

   IDC compatibility module

   This file contains IDA built-in function declarations and internal bit
   definitions.  Each byte of the program has 32-bit flags (low 8 bits keep
   the byte value). These 32 bits are used in get_full_flags/get_flags functions.

   This file is subject to change without any notice.
   Future versions of IDA may use other definitions.



Attributes
----------

.. autoapisummary::

   idc.WORDMASK
   idc.BADADDR
   idc.BADSEL
   idc.SIZE_MAX
   idc.MS_VAL
   idc.FF_IVL
   idc.MS_CLS
   idc.FF_CODE
   idc.FF_DATA
   idc.FF_TAIL
   idc.FF_UNK
   idc.MS_COMM
   idc.FF_COMM
   idc.FF_REF
   idc.FF_LINE
   idc.FF_NAME
   idc.FF_LABL
   idc.FF_FLOW
   idc.FF_ANYNAME
   idc.MS_0TYPE
   idc.FF_0VOID
   idc.FF_0NUMH
   idc.FF_0NUMD
   idc.FF_0CHAR
   idc.FF_0SEG
   idc.FF_0OFF
   idc.FF_0NUMB
   idc.FF_0NUMO
   idc.FF_0ENUM
   idc.FF_0FOP
   idc.FF_0STRO
   idc.FF_0STK
   idc.MS_1TYPE
   idc.FF_1VOID
   idc.FF_1NUMH
   idc.FF_1NUMD
   idc.FF_1CHAR
   idc.FF_1SEG
   idc.FF_1OFF
   idc.FF_1NUMB
   idc.FF_1NUMO
   idc.FF_1ENUM
   idc.FF_1FOP
   idc.FF_1STRO
   idc.FF_1STK
   idc.DT_TYPE
   idc.FF_BYTE
   idc.FF_WORD
   idc.FF_DWORD
   idc.FF_QWORD
   idc.FF_TBYTE
   idc.FF_STRLIT
   idc.FF_STRUCT
   idc.FF_OWORD
   idc.FF_FLOAT
   idc.FF_DOUBLE
   idc.FF_PACKREAL
   idc.FF_ALIGN
   idc.MS_CODE
   idc.FF_FUNC
   idc.FF_IMMD
   idc.FF_JUMP
   idc.NEF_SEGS
   idc.NEF_RSCS
   idc.NEF_NAME
   idc.NEF_MAN
   idc.NEF_FILL
   idc.NEF_IMPS
   idc.NEF_FIRST
   idc.NEF_CODE
   idc.NEF_RELOAD
   idc.NEF_FLAT
   idc.IDCHK_OK
   idc.IDCHK_ARG
   idc.IDCHK_KEY
   idc.IDCHK_MAX
   idc.add_idc_hotkey
   idc.del_idc_hotkey
   idc.jumpto
   idc.auto_wait
   idc.DBFL_BAK
   idc.qexit
   idc.load_and_run_plugin
   idc.plan_to_apply_idasgn
   idc.create_insn
   idc.SN_CHECK
   idc.SN_NOCHECK
   idc.SN_PUBLIC
   idc.SN_NON_PUBLIC
   idc.SN_WEAK
   idc.SN_NON_WEAK
   idc.SN_AUTO
   idc.SN_NON_AUTO
   idc.SN_NOLIST
   idc.SN_NOWARN
   idc.SN_LOCAL
   idc.set_cmt
   idc.create_data
   idc.create_custom_data
   idc.create_align
   idc.del_items
   idc.DELIT_SIMPLE
   idc.DELIT_EXPAND
   idc.DELIT_DELNAMES
   idc.AP_ALLOWDUPS
   idc.AP_SIGNED
   idc.AP_INDEX
   idc.AP_ARRAY
   idc.AP_IDXBASEMASK
   idc.AP_IDXDEC
   idc.AP_IDXHEX
   idc.AP_IDXOCT
   idc.AP_IDXBIN
   idc.op_bin
   idc.op_oct
   idc.op_dec
   idc.op_hex
   idc.op_chr
   idc.OPND_OUTER
   idc.op_offset
   idc.REF_OFF8
   idc.REF_OFF16
   idc.REF_OFF32
   idc.REF_LOW8
   idc.REF_LOW16
   idc.REF_HIGH8
   idc.REF_HIGH16
   idc.REF_OFF64
   idc.REFINFO_RVA
   idc.REFINFO_PASTEND
   idc.REFINFO_NOBASE
   idc.REFINFO_SUBTRACT
   idc.REFINFO_SIGNEDOP
   idc.op_seg
   idc.op_num
   idc.op_flt
   idc.op_man
   idc.toggle_sign
   idc.op_enum
   idc.op_stkvar
   idc.E_PREV
   idc.E_NEXT
   idc.get_extra_cmt
   idc.update_extra_cmt
   idc.del_extra_cmt
   idc.set_manual_insn
   idc.get_manual_insn
   idc.patch_dbg_byte
   idc.patch_byte
   idc.patch_word
   idc.patch_dword
   idc.patch_qword
   idc.SR_inherit
   idc.SR_user
   idc.SR_auto
   idc.SR_autostart
   idc.auto_mark_range
   idc.auto_unmark
   idc.AU_UNK
   idc.AU_CODE
   idc.AU_PROC
   idc.AU_USED
   idc.AU_LIBF
   idc.AU_FINAL
   idc.OFILE_MAP
   idc.OFILE_EXE
   idc.OFILE_IDC
   idc.OFILE_LST
   idc.OFILE_ASM
   idc.OFILE_DIF
   idc.GENFLG_MAPSEG
   idc.GENFLG_MAPNAME
   idc.GENFLG_MAPDMNG
   idc.GENFLG_MAPLOC
   idc.GENFLG_IDCTYPE
   idc.GENFLG_ASMTYPE
   idc.GENFLG_GENHTML
   idc.GENFLG_ASMINC
   idc.CHART_PRINT_NAMES
   idc.CHART_GEN_GDL
   idc.CHART_WINGRAPH
   idc.CHART_NOLIBFUNCS
   idc.get_root_filename
   idc.get_input_file_path
   idc.set_root_filename
   idc.retrieve_input_file_md5
   idc.get_full_flags
   idc.get_db_byte
   idc.get_wide_byte
   idc.read_dbg_memory
   idc.get_original_byte
   idc.get_wide_word
   idc.get_wide_dword
   idc.get_qword
   idc.get_name_ea
   idc.get_screen_ea
   idc.next_addr
   idc.prev_addr
   idc.next_not_tail
   idc.prev_not_tail
   idc.get_item_head
   idc.get_item_end
   idc.GN_VISIBLE
   idc.GN_COLORED
   idc.GN_DEMANGLED
   idc.GN_STRICT
   idc.GN_SHORT
   idc.GN_LONG
   idc.GN_LOCAL
   idc.GN_ISRET
   idc.GN_NOT_ISRET
   idc.calc_gtn_flags
   idc.GENDSM_FORCE_CODE
   idc.GENDSM_MULTI_LINE
   idc.o_void
   idc.o_reg
   idc.o_mem
   idc.o_phrase
   idc.o_displ
   idc.o_imm
   idc.o_far
   idc.o_near
   idc.o_idpspec0
   idc.o_idpspec1
   idc.o_idpspec2
   idc.o_idpspec3
   idc.o_idpspec4
   idc.o_idpspec5
   idc.o_trreg
   idc.o_dbreg
   idc.o_crreg
   idc.o_fpreg
   idc.o_mmxreg
   idc.o_xmmreg
   idc.o_reglist
   idc.o_creglist
   idc.o_creg
   idc.o_fpreglist
   idc.o_text
   idc.o_cond
   idc.o_spr
   idc.o_twofpr
   idc.o_shmbme
   idc.o_crf
   idc.o_crb
   idc.o_dcr
   idc.GetCommentEx
   idc.get_cmt
   idc.get_forced_operand
   idc.BPU_1B
   idc.BPU_2B
   idc.BPU_4B
   idc.STRWIDTH_1B
   idc.STRWIDTH_2B
   idc.STRWIDTH_4B
   idc.STRWIDTH_MASK
   idc.STRLYT_TERMCHR
   idc.STRLYT_PASCAL1
   idc.STRLYT_PASCAL2
   idc.STRLYT_PASCAL4
   idc.STRLYT_MASK
   idc.STRLYT_SHIFT
   idc.STRTYPE_TERMCHR
   idc.STRTYPE_C
   idc.STRTYPE_C_16
   idc.STRTYPE_C_32
   idc.STRTYPE_PASCAL
   idc.STRTYPE_PASCAL_16
   idc.STRTYPE_LEN2
   idc.STRTYPE_LEN2_16
   idc.STRTYPE_LEN4
   idc.STRTYPE_LEN4_16
   idc.STRTYPE_C16
   idc.find_suspop
   idc.find_code
   idc.find_data
   idc.find_unknown
   idc.find_defined
   idc.find_imm
   idc.find_text
   idc.find_bytes
   idc.INF_VERSION
   idc.INF_PROCNAME
   idc.INF_GENFLAGS
   idc.INF_LFLAGS
   idc.INF_DATABASE_CHANGE_COUNT
   idc.INF_CHANGE_COUNTER
   idc.INF_FILETYPE
   idc.FT_EXE_OLD
   idc.FT_COM_OLD
   idc.FT_BIN
   idc.FT_DRV
   idc.FT_WIN
   idc.FT_HEX
   idc.FT_MEX
   idc.FT_LX
   idc.FT_LE
   idc.FT_NLM
   idc.FT_COFF
   idc.FT_PE
   idc.FT_OMF
   idc.FT_SREC
   idc.FT_ZIP
   idc.FT_OMFLIB
   idc.FT_AR
   idc.FT_LOADER
   idc.FT_ELF
   idc.FT_W32RUN
   idc.FT_AOUT
   idc.FT_PRC
   idc.FT_EXE
   idc.FT_COM
   idc.FT_AIXAR
   idc.FT_MACHO
   idc.INF_OSTYPE
   idc.OSTYPE_MSDOS
   idc.OSTYPE_WIN
   idc.OSTYPE_OS2
   idc.OSTYPE_NETW
   idc.INF_APPTYPE
   idc.APPT_CONSOLE
   idc.APPT_GRAPHIC
   idc.APPT_PROGRAM
   idc.APPT_LIBRARY
   idc.APPT_DRIVER
   idc.APPT_1THREAD
   idc.APPT_MTHREAD
   idc.APPT_16BIT
   idc.APPT_32BIT
   idc.INF_ASMTYPE
   idc.INF_SPECSEGS
   idc.INF_AF
   idc.INF_AF2
   idc.INF_BASEADDR
   idc.INF_START_SS
   idc.INF_START_CS
   idc.INF_START_IP
   idc.INF_START_EA
   idc.INF_START_SP
   idc.INF_MAIN
   idc.INF_MIN_EA
   idc.INF_MAX_EA
   idc.INF_OMIN_EA
   idc.INF_OMAX_EA
   idc.INF_LOWOFF
   idc.INF_LOW_OFF
   idc.INF_HIGHOFF
   idc.INF_HIGH_OFF
   idc.INF_MAXREF
   idc.INF_PRIVRANGE_START_EA
   idc.INF_START_PRIVRANGE
   idc.INF_PRIVRANGE_END_EA
   idc.INF_END_PRIVRANGE
   idc.INF_NETDELTA
   idc.INF_XREFNUM
   idc.INF_TYPE_XREFNUM
   idc.INF_TYPE_XREFS
   idc.INF_REFCMTNUM
   idc.INF_REFCMTS
   idc.INF_XREFFLAG
   idc.INF_XREFS
   idc.INF_MAX_AUTONAME_LEN
   idc.INF_NAMETYPE
   idc.INF_SHORT_DEMNAMES
   idc.INF_SHORT_DN
   idc.INF_LONG_DEMNAMES
   idc.INF_LONG_DN
   idc.INF_DEMNAMES
   idc.INF_LISTNAMES
   idc.INF_INDENT
   idc.INF_CMT_INDENT
   idc.INF_COMMENT
   idc.INF_MARGIN
   idc.INF_LENXREF
   idc.INF_OUTFLAGS
   idc.INF_CMTFLG
   idc.INF_CMTFLAG
   idc.INF_LIMITER
   idc.INF_BORDER
   idc.INF_BIN_PREFIX_SIZE
   idc.INF_BINPREF
   idc.INF_PREFFLAG
   idc.INF_STRLIT_FLAGS
   idc.INF_STRLIT_BREAK
   idc.INF_STRLIT_ZEROES
   idc.INF_STRTYPE
   idc.INF_STRLIT_PREF
   idc.INF_STRLIT_SERNUM
   idc.INF_DATATYPES
   idc.INF_CC_ID
   idc.COMP_MASK
   idc.COMP_UNK
   idc.COMP_MS
   idc.COMP_BC
   idc.COMP_WATCOM
   idc.COMP_GNU
   idc.COMP_VISAGE
   idc.COMP_BP
   idc.INF_CC_CM
   idc.INF_CC_SIZE_I
   idc.INF_CC_SIZE_B
   idc.INF_CC_SIZE_E
   idc.INF_CC_DEFALIGN
   idc.INF_CC_SIZE_S
   idc.INF_CC_SIZE_L
   idc.INF_CC_SIZE_LL
   idc.INF_CC_SIZE_LDBL
   idc.INF_COMPILER
   idc.INF_MODEL
   idc.INF_SIZEOF_INT
   idc.INF_SIZEOF_BOOL
   idc.INF_SIZEOF_ENUM
   idc.INF_SIZEOF_ALGN
   idc.INF_SIZEOF_SHORT
   idc.INF_SIZEOF_LONG
   idc.INF_SIZEOF_LLONG
   idc.INF_SIZEOF_LDBL
   idc.INF_ABIBITS
   idc.INF_APPCALL_OPTIONS
   idc.set_processor_type
   idc.SETPROC_IDB
   idc.SETPROC_LOADER
   idc.SETPROC_LOADER_NON_FATAL
   idc.SETPROC_USER
   idc.set_target_assembler
   idc.ask_seg
   idc.ask_yn
   idc.msg
   idc.warning
   idc.error
   idc.set_ida_state
   idc.IDA_STATUS_READY
   idc.IDA_STATUS_THINKING
   idc.IDA_STATUS_WAITING
   idc.IDA_STATUS_WORK
   idc.refresh_idaview_anyway
   idc.refresh_lists
   idc.set_selector
   idc.del_selector
   idc.ADDSEG_NOSREG
   idc.ADDSEG_OR_DIE
   idc.ADDSEG_NOTRUNC
   idc.ADDSEG_QUIET
   idc.ADDSEG_FILLGAP
   idc.ADDSEG_SPARSE
   idc.del_segm
   idc.SEGMOD_KILL
   idc.SEGMOD_KEEP
   idc.SEGMOD_SILENT
   idc.saAbs
   idc.saRelByte
   idc.saRelWord
   idc.saRelPara
   idc.saRelPage
   idc.saRelDble
   idc.saRel4K
   idc.saGroup
   idc.saRel32Bytes
   idc.saRel64Bytes
   idc.saRelQword
   idc.scPriv
   idc.scPub
   idc.scPub2
   idc.scStack
   idc.scCommon
   idc.scPub3
   idc.SEG_NORM
   idc.SEG_XTRN
   idc.SEG_CODE
   idc.SEG_DATA
   idc.SEG_IMP
   idc.SEG_GRP
   idc.SEG_NULL
   idc.SEG_UNDF
   idc.SEG_BSS
   idc.SEG_ABSSYM
   idc.SEG_COMM
   idc.SEG_IMEM
   idc.SEGATTR_START
   idc.SEGATTR_END
   idc.SEGATTR_ORGBASE
   idc.SEGATTR_ALIGN
   idc.SEGATTR_COMB
   idc.SEGATTR_PERM
   idc.SEGATTR_BITNESS
   idc.SEGATTR_FLAGS
   idc.SEGATTR_SEL
   idc.SEGATTR_ES
   idc.SEGATTR_CS
   idc.SEGATTR_SS
   idc.SEGATTR_DS
   idc.SEGATTR_FS
   idc.SEGATTR_GS
   idc.SEGATTR_TYPE
   idc.SEGATTR_COLOR
   idc.SEGATTR_START
   idc.SFL_COMORG
   idc.SFL_OBOK
   idc.SFL_HIDDEN
   idc.SFL_DEBUG
   idc.SFL_LOADER
   idc.SFL_HIDETYPE
   idc.MSF_SILENT
   idc.MSF_NOFIX
   idc.MSF_LDKEEP
   idc.MSF_FIXONCE
   idc.MOVE_SEGM_OK
   idc.MOVE_SEGM_PARAM
   idc.MOVE_SEGM_ROOM
   idc.MOVE_SEGM_IDP
   idc.MOVE_SEGM_CHUNK
   idc.MOVE_SEGM_LOADER
   idc.MOVE_SEGM_ODD
   idc.MOVE_SEGM_ORPHAN
   idc.MOVE_SEGM_DEBUG
   idc.MOVE_SEGM_SOURCEFILES
   idc.MOVE_SEGM_MAPPING
   idc.MOVE_SEGM_INVAL
   idc.rebase_program
   idc.set_storage_type
   idc.STT_VA
   idc.STT_MM
   idc.fl_CF
   idc.fl_CN
   idc.fl_JF
   idc.fl_JN
   idc.fl_F
   idc.XREF_USER
   idc.add_cref
   idc.del_cref
   idc.get_first_cref_from
   idc.get_next_cref_from
   idc.get_first_cref_to
   idc.get_next_cref_to
   idc.get_first_fcref_from
   idc.get_next_fcref_from
   idc.get_first_fcref_to
   idc.get_next_fcref_to
   idc.dr_O
   idc.dr_W
   idc.dr_R
   idc.dr_T
   idc.dr_I
   idc.add_dref
   idc.del_dref
   idc.get_first_dref_from
   idc.get_next_dref_from
   idc.get_first_dref_to
   idc.get_next_dref_to
   idc.add_func
   idc.del_func
   idc.set_func_end
   idc.FUNCATTR_START
   idc.FUNCATTR_END
   idc.FUNCATTR_FLAGS
   idc.FUNCATTR_FRAME
   idc.FUNCATTR_FRSIZE
   idc.FUNCATTR_FRREGS
   idc.FUNCATTR_ARGSIZE
   idc.FUNCATTR_FPD
   idc.FUNCATTR_COLOR
   idc.FUNCATTR_OWNER
   idc.FUNCATTR_REFQTY
   idc.FUNCATTR_START
   idc.FUNC_NORET
   idc.FUNC_FAR
   idc.FUNC_LIB
   idc.FUNC_STATIC
   idc.FUNC_FRAME
   idc.FUNC_USERFAR
   idc.FUNC_HIDDEN
   idc.FUNC_THUNK
   idc.FUNC_BOTTOMBP
   idc.FUNC_NORET_PENDING
   idc.FUNC_SP_READY
   idc.FUNC_PURGED_OK
   idc.FUNC_TAIL
   idc.FUNC_LUMINA
   idc.FUNC_OUTLINE
   idc.get_fchunk_referer
   idc.add_user_stkpnt
   idc.recalc_spd
   idc.get_entry_qty
   idc.add_entry
   idc.get_entry_ordinal
   idc.get_entry
   idc.get_entry_name
   idc.rename_entry
   idc.get_next_fixup_ea
   idc.get_prev_fixup_ea
   idc.FIXUP_OFF8
   idc.FIXUP_OFF16
   idc.FIXUP_SEG16
   idc.FIXUP_PTR32
   idc.FIXUP_OFF32
   idc.FIXUP_PTR48
   idc.FIXUP_HI8
   idc.FIXUP_HI16
   idc.FIXUP_LOW8
   idc.FIXUP_LOW16
   idc.FIXUP_OFF64
   idc.FIXUP_CUSTOM
   idc.FIXUPF_REL
   idc.FIXUPF_EXTDEF
   idc.FIXUPF_UNUSED
   idc.FIXUPF_CREATED
   idc.del_fixup
   idc.put_bookmark
   idc.get_bookmark
   idc.get_bookmark_desc
   idc.ENFL_REGEX
   idc.AR_LONG
   idc.AR_STR
   idc.add_sourcefile
   idc.get_sourcefile
   idc.del_sourcefile
   idc.set_source_linnum
   idc.get_source_linnum
   idc.del_source_linnum
   idc.SizeOf
   idc.TINFO_GUESSED
   idc.TINFO_DEFINITE
   idc.TINFO_DELAYFUNC
   idc.PT_SIL
   idc.PT_NDC
   idc.PT_TYP
   idc.PT_VAR
   idc.PT_PACKMASK
   idc.PT_HIGH
   idc.PT_LOWER
   idc.PT_REPLACE
   idc.PT_RAWARGS
   idc.PT_SILENT
   idc.PT_PAKDEF
   idc.PT_PAK1
   idc.PT_PAK2
   idc.PT_PAK4
   idc.PT_PAK8
   idc.PT_PAK16
   idc.PT_FILE
   idc.PT_STANDALONE
   idc.PDF_INCL_DEPS
   idc.PDF_DEF_FWD
   idc.PDF_DEF_BASE
   idc.PDF_HEADER_CMT
   idc.PRTYPE_1LINE
   idc.PRTYPE_MULTI
   idc.PRTYPE_TYPE
   idc.PRTYPE_PRAGMA
   idc.PRTYPE_SEMI
   idc.PRTYPE_CPP
   idc.PRTYPE_DEF
   idc.PRTYPE_NOARGS
   idc.PRTYPE_NOARRS
   idc.PRTYPE_NORES
   idc.PRTYPE_RESTORE
   idc.PRTYPE_NOREGEX
   idc.PRTYPE_COLORED
   idc.PRTYPE_METHODS
   idc.PRTYPE_1LINCMT
   idc.add_hidden_range
   idc.del_hidden_range
   idc.load_debugger
   idc.start_process
   idc.exit_process
   idc.suspend_process
   idc.get_processes
   idc.attach_process
   idc.detach_process
   idc.get_thread_qty
   idc.getn_thread
   idc.get_current_thread
   idc.getn_thread_name
   idc.select_thread
   idc.suspend_thread
   idc.resume_thread
   idc.step_into
   idc.step_over
   idc.run_to
   idc.step_until_ret
   idc.wait_for_next_event
   idc.WFNE_ANY
   idc.WFNE_SUSP
   idc.WFNE_SILENT
   idc.WFNE_CONT
   idc.WFNE_NOWAIT
   idc.NOTASK
   idc.DBG_ERROR
   idc.DBG_TIMEOUT
   idc.PROCESS_STARTED
   idc.PROCESS_EXITED
   idc.THREAD_STARTED
   idc.THREAD_EXITED
   idc.BREAKPOINT
   idc.STEP
   idc.EXCEPTION
   idc.LIB_LOADED
   idc.LIB_UNLOADED
   idc.INFORMATION
   idc.PROCESS_ATTACHED
   idc.PROCESS_DETACHED
   idc.PROCESS_SUSPENDED
   idc.refresh_debugger_memory
   idc.take_memory_snapshot
   idc.get_process_state
   idc.DSTATE_SUSP
   idc.DSTATE_NOTASK
   idc.DSTATE_RUN
   idc.DSTATE_RUN_WAIT_ATTACH
   idc.DSTATE_RUN_WAIT_END
   idc.set_debugger_options
   idc.DOPT_SEGM_MSGS
   idc.DOPT_START_BPT
   idc.DOPT_THREAD_MSGS
   idc.DOPT_THREAD_BPT
   idc.DOPT_BPT_MSGS
   idc.DOPT_LIB_MSGS
   idc.DOPT_LIB_BPT
   idc.DOPT_INFO_MSGS
   idc.DOPT_INFO_BPT
   idc.DOPT_REAL_MEMORY
   idc.DOPT_REDO_STACK
   idc.DOPT_ENTRY_BPT
   idc.DOPT_EXCDLG
   idc.EXCDLG_NEVER
   idc.EXCDLG_UNKNOWN
   idc.EXCDLG_ALWAYS
   idc.DOPT_LOAD_DINFO
   idc.get_debugger_event_cond
   idc.set_debugger_event_cond
   idc.set_remote_debugger
   idc.define_exception
   idc.EXC_BREAK
   idc.EXC_HANDLE
   idc.get_reg_value
   idc.get_bpt_qty
   idc.BPTATTR_EA
   idc.BPTATTR_SIZE
   idc.BPTATTR_TYPE
   idc.BPT_WRITE
   idc.BPT_RDWR
   idc.BPT_SOFT
   idc.BPT_EXEC
   idc.BPT_DEFAULT
   idc.BPTATTR_COUNT
   idc.BPTATTR_FLAGS
   idc.BPT_BRK
   idc.BPT_TRACE
   idc.BPT_UPDMEM
   idc.BPT_ENABLED
   idc.BPT_LOWCND
   idc.BPT_TRACEON
   idc.BPT_TRACE_INSN
   idc.BPT_TRACE_FUNC
   idc.BPT_TRACE_BBLK
   idc.BPTATTR_COND
   idc.BPTATTR_PID
   idc.BPTATTR_TID
   idc.BPLT_ABS
   idc.BPLT_REL
   idc.BPLT_SYM
   idc.add_bpt
   idc.del_bpt
   idc.enable_bpt
   idc.check_bpt
   idc.BPTCK_NONE
   idc.BPTCK_NO
   idc.BPTCK_YES
   idc.BPTCK_ACT
   idc.TRACE_STEP
   idc.TRACE_INSN
   idc.TRACE_FUNC
   idc.get_step_trace_options
   idc.set_step_trace_options
   idc.ST_OVER_DEBUG_SEG
   idc.ST_OVER_LIB_FUNC
   idc.ST_ALREADY_LOGGED
   idc.ST_SKIP_LOOPS
   idc.load_trace_file
   idc.save_trace_file
   idc.is_valid_trace_file
   idc.diff_trace_file
   idc.get_trace_file_desc
   idc.set_trace_file_desc
   idc.get_tev_qty
   idc.get_tev_ea
   idc.TEV_NONE
   idc.TEV_INSN
   idc.TEV_CALL
   idc.TEV_RET
   idc.TEV_BPT
   idc.TEV_MEM
   idc.TEV_EVENT
   idc.get_tev_type
   idc.get_tev_tid
   idc.get_tev_reg
   idc.get_tev_mem_qty
   idc.get_tev_mem
   idc.get_tev_mem_ea
   idc.get_call_tev_callee
   idc.get_ret_tev_return
   idc.get_bpt_tev_ea
   idc.CIC_ITEM
   idc.CIC_FUNC
   idc.CIC_SEGM
   idc.DEFCOLOR
   idc.ARGV


Exceptions
----------

.. autoapisummary::

   idc.DeprecatedIDCError


Functions
---------

.. autoapisummary::

   idc.has_value
   idc.byte_value
   idc.is_loaded
   idc.is_code
   idc.is_data
   idc.is_tail
   idc.is_unknown
   idc.is_head
   idc.is_flow
   idc.isExtra
   idc.isRef
   idc.hasName
   idc.hasUserName
   idc.is_defarg0
   idc.is_defarg1
   idc.isDec0
   idc.isDec1
   idc.isHex0
   idc.isHex1
   idc.isOct0
   idc.isOct1
   idc.isBin0
   idc.isBin1
   idc.is_off0
   idc.is_off1
   idc.is_char0
   idc.is_char1
   idc.is_seg0
   idc.is_seg1
   idc.is_enum0
   idc.is_enum1
   idc.is_manual0
   idc.is_manual1
   idc.is_stroff0
   idc.is_stroff1
   idc.is_stkvar0
   idc.is_stkvar1
   idc.is_byte
   idc.is_word
   idc.is_dword
   idc.is_qword
   idc.is_oword
   idc.is_tbyte
   idc.is_float
   idc.is_double
   idc.is_pack_real
   idc.is_strlit
   idc.is_struct
   idc.is_align
   idc.value_is_string
   idc.value_is_long
   idc.value_is_float
   idc.value_is_func
   idc.value_is_pvoid
   idc.value_is_int64
   idc.to_ea
   idc.form
   idc.substr
   idc.strstr
   idc.strlen
   idc.xtol
   idc.atoa
   idc.ltoa
   idc.atol
   idc.rotate_left
   idc.rotate_dword
   idc.rotate_word
   idc.rotate_byte
   idc.eval_idc
   idc.EVAL_FAILURE
   idc.save_database
   idc.validate_idb_names
   idc.call_system
   idc.qsleep
   idc.delete_all_segments
   idc.plan_and_wait
   idc.set_name
   idc.make_array
   idc.create_strlit
   idc.create_byte
   idc.create_word
   idc.create_dword
   idc.create_qword
   idc.create_oword
   idc.create_yword
   idc.create_float
   idc.create_double
   idc.create_pack_real
   idc.create_tbyte
   idc.create_struct
   idc.define_local_var
   idc.set_array_params
   idc.op_plain_offset
   idc.toggle_bnot
   idc.op_stroff
   idc.op_offset_high16
   idc.MakeVar
   idc.split_sreg_range
   idc.AutoMark
   idc.gen_file
   idc.gen_flow_graph
   idc.gen_simple_call_chart
   idc.idadir
   idc.get_idb_path
   idc.get_bytes
   idc.read_dbg_byte
   idc.read_dbg_word
   idc.read_dbg_dword
   idc.read_dbg_qword
   idc.write_dbg_memory
   idc.GetFloat
   idc.GetDouble
   idc.get_name_ea_simple
   idc.get_segm_by_sel
   idc.get_curline
   idc.read_selection_start
   idc.read_selection_end
   idc.get_sreg
   idc.next_head
   idc.prev_head
   idc.get_item_size
   idc.func_contains
   idc.get_name
   idc.demangle_name
   idc.generate_disasm_line
   idc.GetDisasm
   idc.print_insn_mnem
   idc.print_operand
   idc.get_operand_type
   idc.get_operand_value
   idc.get_strlit_contents
   idc.get_str_type
   idc.process_config_line
   idc.get_inf_attr
   idc.set_inf_attr
   idc.SetPrcsr
   idc.get_processor_name
   idc.batch
   idc.process_ui_action
   idc.sel2para
   idc.find_selector
   idc.get_first_seg
   idc.get_next_seg
   idc.get_segm_start
   idc.get_segm_end
   idc.get_segm_name
   idc.add_segm_ex
   idc.AddSeg
   idc.set_segment_bounds
   idc.set_segm_name
   idc.set_segm_class
   idc.set_segm_alignment
   idc.set_segm_combination
   idc.set_segm_addressing
   idc.selector_by_name
   idc.set_default_sreg_value
   idc.set_segm_type
   idc.get_segm_attr
   idc.set_segm_attr
   idc.move_segm
   idc.get_xref_type
   idc.fopen
   idc.fclose
   idc.filelength
   idc.fseek
   idc.ftell
   idc.LoadFile
   idc.loadfile
   idc.SaveFile
   idc.savefile
   idc.fgetc
   idc.fputc
   idc.fprintf
   idc.readshort
   idc.readlong
   idc.writeshort
   idc.writelong
   idc.readstr
   idc.writestr
   idc.get_next_func
   idc.get_prev_func
   idc.get_func_attr
   idc.set_func_attr
   idc.get_func_flags
   idc.set_func_flags
   idc.get_func_name
   idc.get_func_cmt
   idc.set_func_cmt
   idc.choose_func
   idc.get_func_off_str
   idc.find_func_end
   idc.get_frame_id
   idc.get_frame_lvar_size
   idc.get_frame_regs_size
   idc.get_frame_args_size
   idc.get_frame_size
   idc.set_frame_size
   idc.get_spd
   idc.get_sp_delta
   idc.get_fchunk_attr
   idc.set_fchunk_attr
   idc.get_next_fchunk
   idc.get_prev_fchunk
   idc.append_func_tail
   idc.remove_fchunk
   idc.set_tail_owner
   idc.first_func_chunk
   idc.next_func_chunk
   idc.add_auto_stkpnt
   idc.del_stkpnt
   idc.get_min_spd_ea
   idc.get_fixup_target_type
   idc.get_fixup_target_flags
   idc.get_fixup_target_sel
   idc.get_fixup_target_off
   idc.get_fixup_target_dis
   idc.set_fixup
   idc.get_struc_id
   idc.get_struc_name
   idc.get_struc_cmt
   idc.get_struc_size
   idc.get_member_qty
   idc.get_member_by_idx
   idc.is_member_id
   idc.get_member_id
   idc.get_member_offset
   idc.get_member_name
   idc.get_member_cmt
   idc.get_member_size
   idc.get_member_strid
   idc.is_union
   idc.add_struc
   idc.del_struc
   idc.set_struc_name
   idc.set_struc_cmt
   idc.add_struc_member
   idc.del_struc_member
   idc.set_member_name
   idc.set_member_type
   idc.set_member_cmt
   idc.expand_struc
   idc.get_enum
   idc.get_enum_name
   idc.get_enum_cmt
   idc.get_enum_size
   idc.get_enum_width
   idc.get_enum_flag
   idc.get_enum_member_by_name
   idc.get_enum_member_enum
   idc.get_enum_member
   idc.get_first_bmask
   idc.get_last_bmask
   idc.get_next_bmask
   idc.get_prev_bmask
   idc.get_bmask_name
   idc.get_bmask_cmt
   idc.set_bmask_name
   idc.set_bmask_cmt
   idc.get_first_enum_member
   idc.get_last_enum_member
   idc.get_next_enum_member
   idc.get_prev_enum_member
   idc.get_enum_member_name
   idc.get_enum_member_cmt
   idc.get_enum_member_value
   idc.get_enum_member_bmask
   idc.add_enum
   idc.del_enum
   idc.set_enum_name
   idc.set_enum_flag
   idc.set_enum_width
   idc.is_bf
   idc.set_enum_bf
   idc.set_enum_cmt
   idc.add_enum_member
   idc.del_enum_member
   idc.set_enum_member_name
   idc.set_enum_member_cmt
   idc.create_array
   idc.get_array_id
   idc.rename_array
   idc.delete_array
   idc.set_array_long
   idc.set_array_string
   idc.get_array_element
   idc.del_array_element
   idc.get_first_index
   idc.get_last_index
   idc.get_next_index
   idc.get_prev_index
   idc.set_hash_long
   idc.get_hash_long
   idc.set_hash_string
   idc.get_hash_string
   idc.del_hash_string
   idc.get_first_hash_key
   idc.get_last_hash_key
   idc.get_next_hash_key
   idc.get_prev_hash_key
   idc.add_default_til
   idc.import_type
   idc.get_type
   idc.sizeof
   idc.get_tinfo
   idc.get_local_tinfo
   idc.guess_type
   idc.apply_type
   idc.SetType
   idc.parse_decl
   idc.parse_decls
   idc.print_decls
   idc.get_ordinal_limit
   idc.set_local_type
   idc.GetLocalType
   idc.get_numbered_type_name
   idc.update_hidden_range
   idc.get_first_module
   idc.get_next_module
   idc.get_module_name
   idc.get_module_size
   idc.resume_process
   idc.send_dbg_command
   idc.get_event_id
   idc.get_event_pid
   idc.get_event_tid
   idc.get_event_ea
   idc.is_event_handled
   idc.get_event_module_name
   idc.get_event_module_base
   idc.get_event_module_size
   idc.get_event_exit_code
   idc.get_event_info
   idc.get_event_bpt_hea
   idc.get_event_exc_code
   idc.get_event_exc_ea
   idc.can_exc_continue
   idc.get_event_exc_info
   idc.set_reg_value
   idc.get_bpt_ea
   idc.get_bpt_attr
   idc.set_bpt_attr
   idc.set_bpt_cond
   idc.enable_tracing
   idc.clear_trace
   idc.get_color
   idc.set_color
   idc.force_bl_jump
   idc.force_bl_call
   idc.set_flag
   idc.here
   idc.is_mapped


Module Contents
---------------

.. py:data:: WORDMASK
   :value: 18446744073709551615


.. py:exception:: DeprecatedIDCError

   Bases: :py:obj:`Exception`


   Exception for deprecated function calls


.. py:data:: BADADDR

.. py:data:: BADSEL

.. py:data:: SIZE_MAX

.. py:data:: MS_VAL

.. py:data:: FF_IVL

.. py:function:: has_value(F)

.. py:function:: byte_value(F)

   Get byte value from flags
   Get value of byte provided that the byte is initialized.
   This macro works ok only for 8-bit byte machines.


.. py:function:: is_loaded(ea)

   Is the byte initialized?


.. py:data:: MS_CLS

.. py:data:: FF_CODE

.. py:data:: FF_DATA

.. py:data:: FF_TAIL

.. py:data:: FF_UNK

.. py:function:: is_code(F)

.. py:function:: is_data(F)

.. py:function:: is_tail(F)

.. py:function:: is_unknown(F)

.. py:function:: is_head(F)

.. py:data:: MS_COMM

.. py:data:: FF_COMM

.. py:data:: FF_REF

.. py:data:: FF_LINE

.. py:data:: FF_NAME

.. py:data:: FF_LABL

.. py:data:: FF_FLOW

.. py:data:: FF_ANYNAME

.. py:function:: is_flow(F)

.. py:function:: isExtra(F)

.. py:function:: isRef(F)

.. py:function:: hasName(F)

.. py:function:: hasUserName(F)

.. py:data:: MS_0TYPE

.. py:data:: FF_0VOID

.. py:data:: FF_0NUMH

.. py:data:: FF_0NUMD

.. py:data:: FF_0CHAR

.. py:data:: FF_0SEG

.. py:data:: FF_0OFF

.. py:data:: FF_0NUMB

.. py:data:: FF_0NUMO

.. py:data:: FF_0ENUM

.. py:data:: FF_0FOP

.. py:data:: FF_0STRO

.. py:data:: FF_0STK

.. py:data:: MS_1TYPE

.. py:data:: FF_1VOID

.. py:data:: FF_1NUMH

.. py:data:: FF_1NUMD

.. py:data:: FF_1CHAR

.. py:data:: FF_1SEG

.. py:data:: FF_1OFF

.. py:data:: FF_1NUMB

.. py:data:: FF_1NUMO

.. py:data:: FF_1ENUM

.. py:data:: FF_1FOP

.. py:data:: FF_1STRO

.. py:data:: FF_1STK

.. py:function:: is_defarg0(F)

.. py:function:: is_defarg1(F)

.. py:function:: isDec0(F)

.. py:function:: isDec1(F)

.. py:function:: isHex0(F)

.. py:function:: isHex1(F)

.. py:function:: isOct0(F)

.. py:function:: isOct1(F)

.. py:function:: isBin0(F)

.. py:function:: isBin1(F)

.. py:function:: is_off0(F)

.. py:function:: is_off1(F)

.. py:function:: is_char0(F)

.. py:function:: is_char1(F)

.. py:function:: is_seg0(F)

.. py:function:: is_seg1(F)

.. py:function:: is_enum0(F)

.. py:function:: is_enum1(F)

.. py:function:: is_manual0(F)

.. py:function:: is_manual1(F)

.. py:function:: is_stroff0(F)

.. py:function:: is_stroff1(F)

.. py:function:: is_stkvar0(F)

.. py:function:: is_stkvar1(F)

.. py:data:: DT_TYPE

.. py:data:: FF_BYTE

.. py:data:: FF_WORD

.. py:data:: FF_DWORD

.. py:data:: FF_QWORD

.. py:data:: FF_TBYTE

.. py:data:: FF_STRLIT

.. py:data:: FF_STRUCT

.. py:data:: FF_OWORD

.. py:data:: FF_FLOAT

.. py:data:: FF_DOUBLE

.. py:data:: FF_PACKREAL

.. py:data:: FF_ALIGN

.. py:function:: is_byte(F)

.. py:function:: is_word(F)

.. py:function:: is_dword(F)

.. py:function:: is_qword(F)

.. py:function:: is_oword(F)

.. py:function:: is_tbyte(F)

.. py:function:: is_float(F)

.. py:function:: is_double(F)

.. py:function:: is_pack_real(F)

.. py:function:: is_strlit(F)

.. py:function:: is_struct(F)

.. py:function:: is_align(F)

.. py:data:: MS_CODE

.. py:data:: FF_FUNC

.. py:data:: FF_IMMD

.. py:data:: FF_JUMP

.. py:data:: NEF_SEGS

.. py:data:: NEF_RSCS

.. py:data:: NEF_NAME

.. py:data:: NEF_MAN

.. py:data:: NEF_FILL

.. py:data:: NEF_IMPS

.. py:data:: NEF_FIRST

.. py:data:: NEF_CODE

.. py:data:: NEF_RELOAD

.. py:data:: NEF_FLAT

.. py:function:: value_is_string(var)

.. py:function:: value_is_long(var)

.. py:function:: value_is_float(var)

.. py:function:: value_is_func(var)

.. py:function:: value_is_pvoid(var)

.. py:function:: value_is_int64(var)

.. py:function:: to_ea(seg, off)

   Return value of expression: ((seg<<4) + off)


.. py:function:: form(format, *args)

.. py:function:: substr(s, x1, x2)

.. py:function:: strstr(s1, s2)

.. py:function:: strlen(s)

.. py:function:: xtol(s)

.. py:function:: atoa(ea)

   Convert address value to a string
   Return address in the form 'seg000:1234'
   (the same as in line prefixes)

   :param ea: address to format


.. py:function:: ltoa(n, radix)

.. py:function:: atol(s)

.. py:function:: rotate_left(value, count, nbits, offset)

   Rotate a value to the left (or right)

   :param value: value to rotate
   :param count: number of times to rotate. negative counter means
                 rotate to the right
   :param nbits: number of bits to rotate
   :param offset: offset of the first bit to rotate

   :returns: the value with the specified field rotated
            all other bits are not modified


.. py:function:: rotate_dword(x, count)

.. py:function:: rotate_word(x, count)

.. py:function:: rotate_byte(x, count)

.. py:data:: IDCHK_OK
   :value: 0


.. py:data:: IDCHK_ARG
   :value: -1


.. py:data:: IDCHK_KEY
   :value: -2


.. py:data:: IDCHK_MAX
   :value: -3


.. py:data:: add_idc_hotkey

.. py:data:: del_idc_hotkey

.. py:data:: jumpto

.. py:data:: auto_wait

.. py:function:: eval_idc(expr)

   Evaluate an IDC expression

   :param expr: an expression

   :returns: the expression value. If there are problems, the returned value will be "IDC_FAILURE: xxx"
            where xxx is the error description

   NOTE: Python implementation evaluates IDC only, while IDC can call other registered languages


.. py:function:: EVAL_FAILURE(code)

   Check the result of eval_idc() for evaluation failures

   :param code: result of eval_idc()

   :returns: True if there was an evaluation error


.. py:function:: save_database(idbname, flags=0)

   Save current database to the specified idb file

   :param idbname: name of the idb file. if empty, the current idb
                   file will be used.
   :param flags: combination of ida_loader.DBFL_... bits or 0


.. py:data:: DBFL_BAK

.. py:function:: validate_idb_names(do_repair=0)

   check consistency of IDB name records
   :param do_repair: try to repair netnode header it TRUE
   :returns: number of inconsistent name records


.. py:data:: qexit

.. py:function:: call_system(command)

   Execute an OS command.

   :param command: command line to execute

   :returns: error code from OS

   NOTE: IDA will wait for the started program to finish.
   In order to start the command in parallel, use OS methods.
   For example, you may start another program in parallel using
   "start" command.


.. py:function:: qsleep(milliseconds)

   qsleep the specified number of milliseconds
   This function suspends IDA for the specified amount of time

   :param milliseconds: time to sleep


.. py:data:: load_and_run_plugin

.. py:data:: plan_to_apply_idasgn

.. py:function:: delete_all_segments()

   Delete all segments, instructions, comments, i.e. everything
   except values of bytes.


.. py:data:: create_insn

.. py:function:: plan_and_wait(sEA, eEA, final_pass=True)

   Perform full analysis of the range

   :param sEA: starting linear address
   :param eEA: ending linear address (excluded)
   :param final_pass: make the final pass over the specified range

   :returns: 1-ok, 0-Ctrl-Break was pressed.


.. py:function:: set_name(ea, name, flags=ida_name.SN_CHECK)

   Rename an address

   :param ea: linear address
   :param name: new name of address. If name == "", then delete old name
   :param flags: combination of SN_... constants

   :returns: 1-ok, 0-failure


.. py:data:: SN_CHECK

.. py:data:: SN_NOCHECK

.. py:data:: SN_PUBLIC

.. py:data:: SN_NON_PUBLIC

.. py:data:: SN_WEAK

.. py:data:: SN_NON_WEAK

.. py:data:: SN_AUTO

.. py:data:: SN_NON_AUTO

.. py:data:: SN_NOLIST

.. py:data:: SN_NOWARN

.. py:data:: SN_LOCAL

.. py:data:: set_cmt

.. py:function:: make_array(ea, nitems)

   Create an array.

   :param ea: linear address
   :param nitems: size of array in items

   NOTE: This function will create an array of the items with the same type as
   the type of the item at 'ea'. If the byte at 'ea' is undefined, then
   this function will create an array of bytes.


.. py:function:: create_strlit(ea, endea)

   Create a string.

   This function creates a string (the string type is determined by the
   value of get_inf_attr(INF_STRTYPE))

   :param ea: linear address
   :param endea: ending address of the string (excluded)
       if endea == BADADDR, then length of string will be calculated
       by the kernel

   :returns: 1-ok, 0-failure

   NOTE: The type of an existing string is returned by get_str_type()


.. py:data:: create_data

.. py:function:: create_byte(ea)

   Convert the current item to a byte

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_word(ea)

   Convert the current item to a word (2 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_dword(ea)

   Convert the current item to a double word (4 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_qword(ea)

   Convert the current item to a quadro word (8 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_oword(ea)

   Convert the current item to an octa word (16 bytes/128 bits)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_yword(ea)

   Convert the current item to a ymm word (32 bytes/256 bits)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_float(ea)

   Convert the current item to a floating point (4 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_double(ea)

   Convert the current item to a double floating point (8 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_pack_real(ea)

   Convert the current item to a packed real (10 or 12 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_tbyte(ea)

   Convert the current item to a tbyte (10 or 12 bytes)

   :param ea: linear address

   :returns: 1-ok, 0-failure


.. py:function:: create_struct(ea, size, strname)

   Convert the current item to a structure instance

   :param ea: linear address
   :param size: structure size in bytes. -1 means that the size
       will be calculated automatically
   :param strname: name of a structure type

   :returns: 1-ok, 0-failure


.. py:data:: create_custom_data

.. py:data:: create_align

.. py:function:: define_local_var(start, end, location, name)

   Create a local variable

   :param start: start of address range for the local variable
   :param end: end of address range for the local variable
   :param location: the variable location in the "[bp+xx]" form where xx is
                    a number. The location can also be specified as a
                    register name.
   :param name: name of the local variable

   :returns: 1-ok, 0-failure

   NOTE: For the stack variables the end address is ignored.
         If there is no function at 'start' then this function will fail.


.. py:data:: del_items

.. py:data:: DELIT_SIMPLE

.. py:data:: DELIT_EXPAND

.. py:data:: DELIT_DELNAMES

.. py:function:: set_array_params(ea, flags, litems, align)

   Set array representation format

   :param ea: linear address
   :param flags: combination of AP_... constants or 0
   :param litems: number of items per line. 0 means auto
   :param align: element alignment
                 - -1: do not align
                 - 0:  automatic alignment
                 - other values: element width

   :returns: 1-ok, 0-failure


.. py:data:: AP_ALLOWDUPS
   :value: 1


.. py:data:: AP_SIGNED
   :value: 2


.. py:data:: AP_INDEX
   :value: 4


.. py:data:: AP_ARRAY
   :value: 8


.. py:data:: AP_IDXBASEMASK
   :value: 240


.. py:data:: AP_IDXDEC
   :value: 0


.. py:data:: AP_IDXHEX
   :value: 16


.. py:data:: AP_IDXOCT
   :value: 32


.. py:data:: AP_IDXBIN
   :value: 48


.. py:data:: op_bin

.. py:data:: op_oct

.. py:data:: op_dec

.. py:data:: op_hex

.. py:data:: op_chr

.. py:function:: op_plain_offset(ea, n, base)

   Convert operand to an offset
   (for the explanations of 'ea' and 'n' please see op_bin())

   Example:
   ========

       seg000:2000 dw      1234h

       and there is a segment at paragraph 0x1000 and there is a data item
       within the segment at 0x1234:

       seg000:1234 MyString        db 'Hello, world!',0

       Then you need to specify a linear address of the segment base to
       create a proper offset:

       op_plain_offset(["seg000",0x2000],0,0x10000);

       and you will have:

       seg000:2000 dw      offset MyString

   Motorola 680x0 processor have a concept of "outer offsets".
   If you want to create an outer offset, you need to combine number
   of the operand with the following bit:

   Please note that the outer offsets are meaningful only for
   Motorola 680x0.

   :param ea: linear address
   :param n: number of operand
       - 0 - the first operand
       - 1 - the second, third and all other operands
       - -1 - all operands
   :param base: base of the offset as a linear address
       If base == BADADDR then the current operand becomes non-offset


.. py:data:: OPND_OUTER

.. py:data:: op_offset

.. py:data:: REF_OFF8

.. py:data:: REF_OFF16

.. py:data:: REF_OFF32

.. py:data:: REF_LOW8

.. py:data:: REF_LOW16

.. py:data:: REF_HIGH8

.. py:data:: REF_HIGH16

.. py:data:: REF_OFF64

.. py:data:: REFINFO_RVA
   :value: 16


.. py:data:: REFINFO_PASTEND
   :value: 32


.. py:data:: REFINFO_NOBASE
   :value: 128


.. py:data:: REFINFO_SUBTRACT
   :value: 256


.. py:data:: REFINFO_SIGNEDOP
   :value: 512


.. py:data:: op_seg

.. py:data:: op_num

.. py:data:: op_flt

.. py:data:: op_man

.. py:data:: toggle_sign

.. py:function:: toggle_bnot(ea, n)

   Toggle the bitwise not operator for the operand

   :param ea: linear address
   :param n: number of operand
       - 0 - the first operand
       - 1 - the second, third and all other operands
       - -1 - all operands


.. py:data:: op_enum

.. py:function:: op_stroff(ea, n, strid, delta)

   Convert operand to an offset in a structure

   :param ea: linear address
   :param n: number of operand
       - 0 - the first operand
       - 1 - the second, third and all other operands
       - -1 - all operands
   :param strid: id of a structure type
   :param delta: struct offset delta. usually 0. denotes the difference
                   between the structure base and the pointer into the structure.



.. py:data:: op_stkvar

.. py:function:: op_offset_high16(ea, n, target)

   Convert operand to a high offset
   High offset is the upper 16bits of an offset.
   This type is used by TMS320C6 processors (and probably by other
   RISC processors too)

   :param ea: linear address
   :param n: number of operand
       - 0 - the first operand
       - 1 - the second, third and all other operands
       - -1 - all operands
   :param target: the full value (all 32bits) of the offset


.. py:function:: MakeVar(ea)

.. py:data:: E_PREV

.. py:data:: E_NEXT

.. py:data:: get_extra_cmt

.. py:data:: update_extra_cmt

.. py:data:: del_extra_cmt

.. py:data:: set_manual_insn

.. py:data:: get_manual_insn

.. py:data:: patch_dbg_byte

.. py:data:: patch_byte

.. py:data:: patch_word

.. py:data:: patch_dword

.. py:data:: patch_qword

.. py:data:: SR_inherit
   :value: 1


.. py:data:: SR_user
   :value: 2


.. py:data:: SR_auto
   :value: 3


.. py:data:: SR_autostart
   :value: 4


.. py:function:: split_sreg_range(ea, reg, value, tag=SR_user)

   Set value of a segment register.

   :param ea: linear address
   :param reg: name of a register, like "cs", "ds", "es", etc.
   :param value: new value of the segment register.
   :param tag: of SR_... constants

   NOTE: IDA keeps tracks of all the points where segment register change their
         values. This function allows you to specify the correct value of a segment
         register if IDA is not able to find the correct value.


.. py:data:: auto_mark_range

.. py:data:: auto_unmark

.. py:function:: AutoMark(ea, qtype)

   Plan to analyze an address


.. py:data:: AU_UNK

.. py:data:: AU_CODE

.. py:data:: AU_PROC

.. py:data:: AU_USED

.. py:data:: AU_LIBF

.. py:data:: AU_FINAL

.. py:function:: gen_file(filetype, path, ea1, ea2, flags)

   Generate an output file

   :param filetype:  type of output file. One of OFILE_... symbols. See below.
   :param path:  the output file path (will be overwritten!)
   :param ea1:   start address. For some file types this argument is ignored
   :param ea2:   end address. For some file types this argument is ignored
   :param flags: bit combination of GENFLG_...

   :returns: number of the generated lines.
               -1 if an error occurred
               OFILE_EXE: 0-can't generate exe file, 1-ok


.. py:data:: OFILE_MAP

.. py:data:: OFILE_EXE

.. py:data:: OFILE_IDC

.. py:data:: OFILE_LST

.. py:data:: OFILE_ASM

.. py:data:: OFILE_DIF

.. py:data:: GENFLG_MAPSEG

.. py:data:: GENFLG_MAPNAME

.. py:data:: GENFLG_MAPDMNG

.. py:data:: GENFLG_MAPLOC

.. py:data:: GENFLG_IDCTYPE

.. py:data:: GENFLG_ASMTYPE

.. py:data:: GENFLG_GENHTML

.. py:data:: GENFLG_ASMINC

.. py:function:: gen_flow_graph(outfile, title, ea1, ea2, flags)

   Generate a flow chart GDL file

   :param outfile: output file name. GDL extension will be used
   :param title: graph title
   :param ea1: beginning of the range to flow chart
   :param ea2: end of the range to flow chart.
   :param flags: combination of CHART_... constants

   NOTE: If ea2 == BADADDR then ea1 is treated as an address within a function.
          That function will be flow charted.


.. py:data:: CHART_PRINT_NAMES
   :value: 4096


.. py:data:: CHART_GEN_GDL
   :value: 16384


.. py:data:: CHART_WINGRAPH
   :value: 32768


.. py:data:: CHART_NOLIBFUNCS
   :value: 1024


.. py:function:: gen_simple_call_chart(outfile, title, flags)

   Generate a function call graph GDL file

   :param outfile: output file name. GDL extension will be used
   :param title:   graph title
   :param flags:   combination of CHART_GEN_GDL, CHART_WINGRAPH, CHART_NOLIBFUNCS


.. py:function:: idadir()

   Get IDA directory

   This function returns the directory where IDA.EXE resides


.. py:data:: get_root_filename

.. py:data:: get_input_file_path

.. py:data:: set_root_filename

.. py:function:: get_idb_path()

   Get IDB full path

   This function returns full path of the current IDB database


.. py:data:: retrieve_input_file_md5

.. py:data:: get_full_flags

.. py:data:: get_db_byte

.. py:function:: get_bytes(ea, size, use_dbg=False)

   Return the specified number of bytes of the program

   :param ea: linear address

   :param size: size of buffer in normal 8-bit bytes

   :param use_dbg: if True, use debugger memory, otherwise just the database

   :returns: None on failure
            otherwise a string containing the read bytes


.. py:data:: get_wide_byte

.. py:function:: read_dbg_byte(ea)

   Get value of program byte using the debugger memory

   :param ea: linear address
   :returns: The value or None on failure.


.. py:function:: read_dbg_word(ea)

   Get value of program word using the debugger memory

   :param ea: linear address
   :returns: The value or None on failure.


.. py:function:: read_dbg_dword(ea)

   Get value of program double-word using the debugger memory

   :param ea: linear address
   :returns: The value or None on failure.


.. py:function:: read_dbg_qword(ea)

   Get value of program quadro-word using the debugger memory

   :param ea: linear address
   :returns: The value or None on failure.


.. py:data:: read_dbg_memory

.. py:function:: write_dbg_memory(ea, data)

   Write to debugger memory.

   :param ea: linear address
   :param data: string to write
   :returns: number of written bytes (-1 - network/debugger error)

   Thread-safe function (may be called only from the main thread and debthread)


.. py:data:: get_original_byte

.. py:data:: get_wide_word

.. py:data:: get_wide_dword

.. py:data:: get_qword

.. py:function:: GetFloat(ea)

   Get value of a floating point number (4 bytes)
   This function assumes number stored using IEEE format
   and in the same endianness as integers.

   :param ea: linear address

   :returns: float


.. py:function:: GetDouble(ea)

   Get value of a floating point number (8 bytes)
   This function assumes number stored using IEEE format
   and in the same endianness as integers.

   :param ea: linear address

   :returns: double


.. py:function:: get_name_ea_simple(name)

   Get linear address of a name

   :param name: name of program byte

   :returns: address of the name
            BADADDR - No such name


.. py:data:: get_name_ea

.. py:function:: get_segm_by_sel(base)

   Get segment by segment base

   :param base: segment base paragraph or selector

   :returns: linear address of the start of the segment or BADADDR
            if no such segment


.. py:data:: get_screen_ea

.. py:function:: get_curline()

   Get the disassembly line at the cursor

   :returns: string


.. py:function:: read_selection_start()

   Get start address of the selected range
   returns BADADDR - the user has not selected an range


.. py:function:: read_selection_end()

   Get end address of the selected range

   :returns: BADADDR - the user has not selected an range


.. py:function:: get_sreg(ea, reg)

   Get value of segment register at the specified address

   :param ea: linear address
   :param reg: name of segment register

   :returns: the value of the segment register or -1 on error

   NOTE: The segment registers in 32bit program usually contain selectors,
          so to get paragraph pointed to by the segment register you need to
          call sel2para() function.


.. py:data:: next_addr

.. py:data:: prev_addr

.. py:function:: next_head(ea, maxea=BADADDR)

   Get next defined item (instruction or data) in the program

   :param ea: linear address to start search from
   :param maxea: the search will stop at the address
       maxea is not included in the search range

   :returns: BADADDR - no (more) defined items


.. py:function:: prev_head(ea, minea=0)

   Get previous defined item (instruction or data) in the program

   :param ea: linear address to start search from
   :param minea: the search will stop at the address
           minea is included in the search range

   :returns: BADADDR - no (more) defined items


.. py:data:: next_not_tail

.. py:data:: prev_not_tail

.. py:data:: get_item_head

.. py:data:: get_item_end

.. py:function:: get_item_size(ea)

   Get size of instruction or data item in bytes

   :param ea: linear address

   :returns: 1..n


.. py:function:: func_contains(func_ea, ea)

   Does the given function contain the given address?

   :param func_ea: any address belonging to the function
   :param ea: linear address

   :returns:  success


.. py:data:: GN_VISIBLE

.. py:data:: GN_COLORED

.. py:data:: GN_DEMANGLED

.. py:data:: GN_STRICT

.. py:data:: GN_SHORT

.. py:data:: GN_LONG

.. py:data:: GN_LOCAL

.. py:data:: GN_ISRET

.. py:data:: GN_NOT_ISRET

.. py:data:: calc_gtn_flags

.. py:function:: get_name(ea, gtn_flags=0)

   Get name at the specified address

   :param ea: linear address
   :param gtn_flags: how exactly the name should be retrieved.
                     combination of GN_ bits

   :returns: "" - byte has no name


.. py:function:: demangle_name(name, disable_mask)

   demangle_name a name

   :param name: name to demangle
   :param disable_mask: a mask that tells how to demangle the name
           it is a good idea to get this mask using
           get_inf_attr(INF_SHORT_DN) or get_inf_attr(INF_LONG_DN)

   :returns: a demangled name
       If the input name cannot be demangled, returns None


.. py:function:: generate_disasm_line(ea, flags)

   Get disassembly line

   :param ea: linear address of instruction

   :param flags: combination of the GENDSM_ flags, or 0

   :returns: "" - could not decode instruction at the specified location

   NOTE: this function may not return exactly the same mnemonics
          as you see on the screen.


.. py:data:: GENDSM_FORCE_CODE

.. py:data:: GENDSM_MULTI_LINE

.. py:function:: GetDisasm(ea)

   Get disassembly line

   :param ea: linear address of instruction

   :returns: "" - could not decode instruction at the specified location

   NOTE: this function may not return exactly the same mnemonics
          as you see on the screen.


.. py:function:: print_insn_mnem(ea)

   Get instruction mnemonics

   :param ea: linear address of instruction

   :returns: "" - no instruction at the specified location

   NOTE: this function may not return exactly the same mnemonics
   as you see on the screen.


.. py:function:: print_operand(ea, n)

   Get operand of an instruction or data

   :param ea: linear address of the item
   :param n: number of operand:
       0 - the first operand
       1 - the second operand

   :returns: the current text representation of operand or ""


.. py:function:: get_operand_type(ea, n)

   Get type of instruction operand

   :param ea: linear address of instruction
   :param n: number of operand:
       0 - the first operand
       1 - the second operand

   :returns: any of o_* constants or -1 on error


.. py:data:: o_void

.. py:data:: o_reg

.. py:data:: o_mem

.. py:data:: o_phrase

.. py:data:: o_displ

.. py:data:: o_imm

.. py:data:: o_far

.. py:data:: o_near

.. py:data:: o_idpspec0

.. py:data:: o_idpspec1

.. py:data:: o_idpspec2

.. py:data:: o_idpspec3

.. py:data:: o_idpspec4

.. py:data:: o_idpspec5

.. py:data:: o_trreg

.. py:data:: o_dbreg

.. py:data:: o_crreg

.. py:data:: o_fpreg

.. py:data:: o_mmxreg

.. py:data:: o_xmmreg

.. py:data:: o_reglist

.. py:data:: o_creglist

.. py:data:: o_creg

.. py:data:: o_fpreglist

.. py:data:: o_text

.. py:data:: o_cond

.. py:data:: o_spr

.. py:data:: o_twofpr

.. py:data:: o_shmbme

.. py:data:: o_crf

.. py:data:: o_crb

.. py:data:: o_dcr

.. py:function:: get_operand_value(ea, n)

   Get number used in the operand

   This function returns an immediate number used in the operand

   :param ea: linear address of instruction
   :param n: the operand number

   :returns: value
       operand is an immediate value  => immediate value
       operand has a displacement     => displacement
       operand is a direct memory ref => memory address
       operand is a register          => register number
       operand is a register phrase   => phrase number
       otherwise                      => -1


.. py:data:: GetCommentEx

.. py:data:: get_cmt

.. py:data:: get_forced_operand

.. py:data:: BPU_1B

.. py:data:: BPU_2B

.. py:data:: BPU_4B

.. py:data:: STRWIDTH_1B

.. py:data:: STRWIDTH_2B

.. py:data:: STRWIDTH_4B

.. py:data:: STRWIDTH_MASK

.. py:data:: STRLYT_TERMCHR

.. py:data:: STRLYT_PASCAL1

.. py:data:: STRLYT_PASCAL2

.. py:data:: STRLYT_PASCAL4

.. py:data:: STRLYT_MASK

.. py:data:: STRLYT_SHIFT

.. py:data:: STRTYPE_TERMCHR

.. py:data:: STRTYPE_C

.. py:data:: STRTYPE_C_16

.. py:data:: STRTYPE_C_32

.. py:data:: STRTYPE_PASCAL

.. py:data:: STRTYPE_PASCAL_16

.. py:data:: STRTYPE_LEN2

.. py:data:: STRTYPE_LEN2_16

.. py:data:: STRTYPE_LEN4

.. py:data:: STRTYPE_LEN4_16

.. py:data:: STRTYPE_C16

.. py:function:: get_strlit_contents(ea, length=-1, strtype=STRTYPE_C)

   Get string contents
   :param ea: linear address
   :param length: string length. -1 means to calculate the max string length
   :param strtype: the string type (one of STRTYPE_... constants)

   :returns: string contents or empty string


.. py:function:: get_str_type(ea)

   Get string type

   :param ea: linear address

   :returns: One of STRTYPE_... constants


.. py:data:: find_suspop

.. py:data:: find_code

.. py:data:: find_data

.. py:data:: find_unknown

.. py:data:: find_defined

.. py:data:: find_imm

.. py:data:: find_text

.. py:data:: find_bytes

.. py:function:: process_config_line(directive)

   Obsolete. Please use ida_idp.process_config_directive().


.. py:data:: INF_VERSION
   :value: 0


.. py:data:: INF_PROCNAME
   :value: 1


.. py:data:: INF_GENFLAGS
   :value: 2


.. py:data:: INF_LFLAGS
   :value: 3


.. py:data:: INF_DATABASE_CHANGE_COUNT
   :value: 4


.. py:data:: INF_CHANGE_COUNTER
   :value: 4


.. py:data:: INF_FILETYPE
   :value: 5


.. py:data:: FT_EXE_OLD
   :value: 0


.. py:data:: FT_COM_OLD
   :value: 1


.. py:data:: FT_BIN
   :value: 2


.. py:data:: FT_DRV
   :value: 3


.. py:data:: FT_WIN
   :value: 4


.. py:data:: FT_HEX
   :value: 5


.. py:data:: FT_MEX
   :value: 6


.. py:data:: FT_LX
   :value: 7


.. py:data:: FT_LE
   :value: 8


.. py:data:: FT_NLM
   :value: 9


.. py:data:: FT_COFF
   :value: 10


.. py:data:: FT_PE
   :value: 11


.. py:data:: FT_OMF
   :value: 12


.. py:data:: FT_SREC
   :value: 13


.. py:data:: FT_ZIP
   :value: 14


.. py:data:: FT_OMFLIB
   :value: 15


.. py:data:: FT_AR
   :value: 16


.. py:data:: FT_LOADER
   :value: 17


.. py:data:: FT_ELF
   :value: 18


.. py:data:: FT_W32RUN
   :value: 19


.. py:data:: FT_AOUT
   :value: 20


.. py:data:: FT_PRC
   :value: 21


.. py:data:: FT_EXE
   :value: 22


.. py:data:: FT_COM
   :value: 23


.. py:data:: FT_AIXAR
   :value: 24


.. py:data:: FT_MACHO
   :value: 25


.. py:data:: INF_OSTYPE
   :value: 6


.. py:data:: OSTYPE_MSDOS
   :value: 1


.. py:data:: OSTYPE_WIN
   :value: 2


.. py:data:: OSTYPE_OS2
   :value: 4


.. py:data:: OSTYPE_NETW
   :value: 8


.. py:data:: INF_APPTYPE
   :value: 7


.. py:data:: APPT_CONSOLE
   :value: 1


.. py:data:: APPT_GRAPHIC
   :value: 2


.. py:data:: APPT_PROGRAM
   :value: 4


.. py:data:: APPT_LIBRARY
   :value: 8


.. py:data:: APPT_DRIVER
   :value: 16


.. py:data:: APPT_1THREAD
   :value: 32


.. py:data:: APPT_MTHREAD
   :value: 64


.. py:data:: APPT_16BIT
   :value: 128


.. py:data:: APPT_32BIT
   :value: 256


.. py:data:: INF_ASMTYPE
   :value: 8


.. py:data:: INF_SPECSEGS
   :value: 9


.. py:data:: INF_AF
   :value: 10


.. py:data:: INF_AF2
   :value: 11


.. py:data:: INF_BASEADDR
   :value: 12


.. py:data:: INF_START_SS
   :value: 13


.. py:data:: INF_START_CS
   :value: 14


.. py:data:: INF_START_IP
   :value: 15


.. py:data:: INF_START_EA
   :value: 16


.. py:data:: INF_START_SP
   :value: 17


.. py:data:: INF_MAIN
   :value: 18


.. py:data:: INF_MIN_EA
   :value: 19


.. py:data:: INF_MAX_EA
   :value: 20


.. py:data:: INF_OMIN_EA
   :value: 21


.. py:data:: INF_OMAX_EA
   :value: 22


.. py:data:: INF_LOWOFF
   :value: 23


.. py:data:: INF_LOW_OFF
   :value: 23


.. py:data:: INF_HIGHOFF
   :value: 24


.. py:data:: INF_HIGH_OFF
   :value: 24


.. py:data:: INF_MAXREF
   :value: 25


.. py:data:: INF_PRIVRANGE_START_EA
   :value: 27


.. py:data:: INF_START_PRIVRANGE
   :value: 27


.. py:data:: INF_PRIVRANGE_END_EA
   :value: 28


.. py:data:: INF_END_PRIVRANGE
   :value: 28


.. py:data:: INF_NETDELTA
   :value: 29


.. py:data:: INF_XREFNUM
   :value: 30


.. py:data:: INF_TYPE_XREFNUM
   :value: 31


.. py:data:: INF_TYPE_XREFS
   :value: 31


.. py:data:: INF_REFCMTNUM
   :value: 32


.. py:data:: INF_REFCMTS
   :value: 32


.. py:data:: INF_XREFFLAG
   :value: 33


.. py:data:: INF_XREFS
   :value: 33


.. py:data:: INF_MAX_AUTONAME_LEN
   :value: 34


.. py:data:: INF_NAMETYPE
   :value: 35


.. py:data:: INF_SHORT_DEMNAMES
   :value: 36


.. py:data:: INF_SHORT_DN
   :value: 36


.. py:data:: INF_LONG_DEMNAMES
   :value: 37


.. py:data:: INF_LONG_DN
   :value: 37


.. py:data:: INF_DEMNAMES
   :value: 38


.. py:data:: INF_LISTNAMES
   :value: 39


.. py:data:: INF_INDENT
   :value: 40


.. py:data:: INF_CMT_INDENT
   :value: 41


.. py:data:: INF_COMMENT
   :value: 41


.. py:data:: INF_MARGIN
   :value: 42


.. py:data:: INF_LENXREF
   :value: 43


.. py:data:: INF_OUTFLAGS
   :value: 44


.. py:data:: INF_CMTFLG
   :value: 45


.. py:data:: INF_CMTFLAG
   :value: 45


.. py:data:: INF_LIMITER
   :value: 46


.. py:data:: INF_BORDER
   :value: 46


.. py:data:: INF_BIN_PREFIX_SIZE
   :value: 47


.. py:data:: INF_BINPREF
   :value: 47


.. py:data:: INF_PREFFLAG
   :value: 48


.. py:data:: INF_STRLIT_FLAGS
   :value: 49


.. py:data:: INF_STRLIT_BREAK
   :value: 50


.. py:data:: INF_STRLIT_ZEROES
   :value: 51


.. py:data:: INF_STRTYPE
   :value: 52


.. py:data:: INF_STRLIT_PREF
   :value: 53


.. py:data:: INF_STRLIT_SERNUM
   :value: 54


.. py:data:: INF_DATATYPES
   :value: 55


.. py:data:: INF_CC_ID
   :value: 57


.. py:data:: COMP_MASK
   :value: 15


.. py:data:: COMP_UNK
   :value: 0


.. py:data:: COMP_MS
   :value: 1


.. py:data:: COMP_BC
   :value: 2


.. py:data:: COMP_WATCOM
   :value: 3


.. py:data:: COMP_GNU
   :value: 6


.. py:data:: COMP_VISAGE
   :value: 7


.. py:data:: COMP_BP
   :value: 8


.. py:data:: INF_CC_CM
   :value: 58


.. py:data:: INF_CC_SIZE_I
   :value: 59


.. py:data:: INF_CC_SIZE_B
   :value: 60


.. py:data:: INF_CC_SIZE_E
   :value: 61


.. py:data:: INF_CC_DEFALIGN
   :value: 62


.. py:data:: INF_CC_SIZE_S
   :value: 63


.. py:data:: INF_CC_SIZE_L
   :value: 64


.. py:data:: INF_CC_SIZE_LL
   :value: 65


.. py:data:: INF_CC_SIZE_LDBL
   :value: 66


.. py:data:: INF_COMPILER
   :value: 57


.. py:data:: INF_MODEL
   :value: 58


.. py:data:: INF_SIZEOF_INT
   :value: 59


.. py:data:: INF_SIZEOF_BOOL
   :value: 60


.. py:data:: INF_SIZEOF_ENUM
   :value: 61


.. py:data:: INF_SIZEOF_ALGN
   :value: 62


.. py:data:: INF_SIZEOF_SHORT
   :value: 63


.. py:data:: INF_SIZEOF_LONG
   :value: 64


.. py:data:: INF_SIZEOF_LLONG
   :value: 65


.. py:data:: INF_SIZEOF_LDBL
   :value: 66


.. py:data:: INF_ABIBITS
   :value: 67


.. py:data:: INF_APPCALL_OPTIONS
   :value: 68


.. py:function:: get_inf_attr(attr)

   Deprecated. Please ida_ida.inf_get_* instead.


.. py:function:: set_inf_attr(attr, value)

   Deprecated. Please ida_ida.inf_set_* instead.


.. py:data:: set_processor_type

.. py:data:: SETPROC_IDB

.. py:data:: SETPROC_LOADER

.. py:data:: SETPROC_LOADER_NON_FATAL

.. py:data:: SETPROC_USER

.. py:function:: SetPrcsr(processor)

.. py:function:: get_processor_name()

   Get name of the current processor
   :returns: processor name


.. py:data:: set_target_assembler

.. py:function:: batch(batch)

   Enable/disable batch mode of operation

   :param batch: batch mode
           0 - ida will display dialog boxes and wait for the user input
           1 - ida will not display dialog boxes, warnings, etc.

   :returns: old balue of batch flag


.. py:function:: process_ui_action(name, flags=0)

   Invokes an IDA UI action by name

   :param name: Command name
   :param flags: Reserved. Must be zero
   :returns: Boolean


.. py:data:: ask_seg

.. py:data:: ask_yn

.. py:data:: msg

.. py:data:: warning

.. py:data:: error

.. py:data:: set_ida_state

.. py:data:: IDA_STATUS_READY
   :value: 0


.. py:data:: IDA_STATUS_THINKING
   :value: 1


.. py:data:: IDA_STATUS_WAITING
   :value: 2


.. py:data:: IDA_STATUS_WORK
   :value: 3


.. py:data:: refresh_idaview_anyway

.. py:data:: refresh_lists

.. py:function:: sel2para(sel)

   Get a selector value

   :param sel: the selector number

   :returns: selector value if found
            otherwise the input value (sel)

   NOTE: selector values are always in paragraphs


.. py:function:: find_selector(val)

   Find a selector which has the specified value

   :param val: value to search for

   :returns: the selector number if found,
            otherwise the input value (val & 0xFFFF)

   NOTE: selector values are always in paragraphs


.. py:data:: set_selector

.. py:data:: del_selector

.. py:function:: get_first_seg()

   Get first segment

   :returns: address of the start of the first segment
       BADADDR - no segments are defined


.. py:function:: get_next_seg(ea)

   Get next segment

   :param ea: linear address

   :returns: start of the next segment
            BADADDR - no next segment


.. py:function:: get_segm_start(ea)

   Get start address of a segment

   :param ea: any address in the segment

   :returns: start of segment
            BADADDR - the specified address doesn't belong to any segment


.. py:function:: get_segm_end(ea)

   Get end address of a segment

   :param ea: any address in the segment

   :returns: end of segment (an address past end of the segment)
            BADADDR - the specified address doesn't belong to any segment


.. py:function:: get_segm_name(ea)

   Get name of a segment

   :param ea: any address in the segment

   :returns: "" - no segment at the specified address


.. py:function:: add_segm_ex(startea, endea, base, use32, align, comb, flags)

   Create a new segment

   :param startea: linear address of the start of the segment
   :param endea: linear address of the end of the segment
              this address will not belong to the segment
              'endea' should be higher than 'startea'
   :param base: base paragraph or selector of the segment.
              a paragraph is 16byte memory chunk.
              If a selector value is specified, the selector should be
              already defined.
   :param use32: 0: 16bit segment, 1: 32bit segment, 2: 64bit segment
   :param align: segment alignment. see below for alignment values
   :param comb: segment combination. see below for combination values.
   :param flags: combination of ADDSEG_... bits

   :returns: 0-failed, 1-ok


.. py:data:: ADDSEG_NOSREG

.. py:data:: ADDSEG_OR_DIE

.. py:data:: ADDSEG_NOTRUNC

.. py:data:: ADDSEG_QUIET

.. py:data:: ADDSEG_FILLGAP

.. py:data:: ADDSEG_SPARSE

.. py:function:: AddSeg(startea, endea, base, use32, align, comb)

.. py:data:: del_segm

.. py:data:: SEGMOD_KILL

.. py:data:: SEGMOD_KEEP

.. py:data:: SEGMOD_SILENT

.. py:function:: set_segment_bounds(ea, startea, endea, flags)

   Change segment boundaries

   :param ea: any address in the segment
   :param startea: new start address of the segment
   :param endea: new end address of the segment
   :param flags: combination of SEGMOD_... flags

   :returns: boolean success


.. py:function:: set_segm_name(ea, name)

   Change name of the segment

   :param ea: any address in the segment
   :param name: new name of the segment

   :returns: success (boolean)


.. py:function:: set_segm_class(ea, segclass)

   Change class of the segment

   :param ea: any address in the segment
   :param segclass: new class of the segment

   :returns: success (boolean)


.. py:function:: set_segm_alignment(ea, alignment)

   Change alignment of the segment

   :param ea: any address in the segment
   :param alignment: new alignment of the segment (one of the sa... constants)

   :returns: success (boolean)


.. py:data:: saAbs

.. py:data:: saRelByte

.. py:data:: saRelWord

.. py:data:: saRelPara

.. py:data:: saRelPage

.. py:data:: saRelDble

.. py:data:: saRel4K

.. py:data:: saGroup

.. py:data:: saRel32Bytes

.. py:data:: saRel64Bytes

.. py:data:: saRelQword

.. py:function:: set_segm_combination(segea, comb)

   Change combination of the segment

   :param segea: any address in the segment
   :param comb: new combination of the segment (one of the sc... constants)

   :returns: success (boolean)


.. py:data:: scPriv

.. py:data:: scPub

.. py:data:: scPub2

.. py:data:: scStack

.. py:data:: scCommon

.. py:data:: scPub3

.. py:function:: set_segm_addressing(ea, bitness)

   Change segment addressing

   :param ea: any address in the segment
   :param bitness: 0: 16bit, 1: 32bit, 2: 64bit

   :returns: success (boolean)


.. py:function:: selector_by_name(segname)

   Get segment selector by name

   :param segname: name of segment

   :returns: segment selector or BADADDR


.. py:function:: set_default_sreg_value(ea, reg, value)

   Set default segment register value for a segment

   :param ea: any address in the segment
              if no segment is present at the specified address
              then all segments will be affected
   :param reg: name of segment register
   :param value: default value of the segment register. -1-undefined.


.. py:function:: set_segm_type(segea, segtype)

   Set segment type

   :param segea: any address within segment
   :param segtype: new segment type:

   :returns: !=0 - ok


.. py:data:: SEG_NORM

.. py:data:: SEG_XTRN

.. py:data:: SEG_CODE

.. py:data:: SEG_DATA

.. py:data:: SEG_IMP

.. py:data:: SEG_GRP

.. py:data:: SEG_NULL

.. py:data:: SEG_UNDF

.. py:data:: SEG_BSS

.. py:data:: SEG_ABSSYM

.. py:data:: SEG_COMM

.. py:data:: SEG_IMEM

.. py:function:: get_segm_attr(segea, attr)

   Get segment attribute

   :param segea: any address within segment
   :param attr: one of SEGATTR_... constants


.. py:function:: set_segm_attr(segea, attr, value)

   Set segment attribute

   :param segea: any address within segment
   :param attr: one of SEGATTR_... constants

   NOTE: Please note that not all segment attributes are modifiable.
          Also some of them should be modified using special functions
          like set_segm_addressing, etc.


.. py:data:: SEGATTR_START
   :value: 0


.. py:data:: SEGATTR_END
   :value: 4


.. py:data:: SEGATTR_ORGBASE
   :value: 16


.. py:data:: SEGATTR_ALIGN
   :value: 20


.. py:data:: SEGATTR_COMB
   :value: 21


.. py:data:: SEGATTR_PERM
   :value: 22


.. py:data:: SEGATTR_BITNESS
   :value: 23


.. py:data:: SEGATTR_FLAGS
   :value: 24


.. py:data:: SEGATTR_SEL
   :value: 28


.. py:data:: SEGATTR_ES
   :value: 32


.. py:data:: SEGATTR_CS
   :value: 36


.. py:data:: SEGATTR_SS
   :value: 40


.. py:data:: SEGATTR_DS
   :value: 44


.. py:data:: SEGATTR_FS
   :value: 48


.. py:data:: SEGATTR_GS
   :value: 52


.. py:data:: SEGATTR_TYPE
   :value: 96


.. py:data:: SEGATTR_COLOR
   :value: 100


.. py:data:: SEGATTR_START
   :value: 0


.. py:data:: SFL_COMORG
   :value: 1


.. py:data:: SFL_OBOK
   :value: 2


.. py:data:: SFL_HIDDEN
   :value: 4


.. py:data:: SFL_DEBUG
   :value: 8


.. py:data:: SFL_LOADER
   :value: 16


.. py:data:: SFL_HIDETYPE
   :value: 32


.. py:function:: move_segm(ea, to, flags)

   Move a segment to a new address
   This function moves all information to the new address
   It fixes up address sensitive information in the kernel
   The total effect is equal to reloading the segment to the target address

   :param ea: any address within the segment to move
   :param to: new segment start address
   :param flags: combination MFS_... constants

   :returns: MOVE_SEGM_... error code


.. py:data:: MSF_SILENT
   :value: 1


.. py:data:: MSF_NOFIX
   :value: 2


.. py:data:: MSF_LDKEEP
   :value: 4


.. py:data:: MSF_FIXONCE
   :value: 8


.. py:data:: MOVE_SEGM_OK
   :value: 0


.. py:data:: MOVE_SEGM_PARAM
   :value: -1


.. py:data:: MOVE_SEGM_ROOM
   :value: -2


.. py:data:: MOVE_SEGM_IDP
   :value: -3


.. py:data:: MOVE_SEGM_CHUNK
   :value: -4


.. py:data:: MOVE_SEGM_LOADER
   :value: -5


.. py:data:: MOVE_SEGM_ODD
   :value: -6


.. py:data:: MOVE_SEGM_ORPHAN

.. py:data:: MOVE_SEGM_DEBUG

.. py:data:: MOVE_SEGM_SOURCEFILES

.. py:data:: MOVE_SEGM_MAPPING

.. py:data:: MOVE_SEGM_INVAL

.. py:data:: rebase_program

.. py:data:: set_storage_type

.. py:data:: STT_VA
   :value: 0


.. py:data:: STT_MM
   :value: 1


.. py:data:: fl_CF
   :value: 16


.. py:data:: fl_CN
   :value: 17


.. py:data:: fl_JF
   :value: 18


.. py:data:: fl_JN
   :value: 19


.. py:data:: fl_F
   :value: 21


.. py:data:: XREF_USER
   :value: 32


.. py:data:: add_cref

.. py:data:: del_cref

.. py:data:: get_first_cref_from

.. py:data:: get_next_cref_from

.. py:data:: get_first_cref_to

.. py:data:: get_next_cref_to

.. py:data:: get_first_fcref_from

.. py:data:: get_next_fcref_from

.. py:data:: get_first_fcref_to

.. py:data:: get_next_fcref_to

.. py:data:: dr_O

.. py:data:: dr_W

.. py:data:: dr_R

.. py:data:: dr_T

.. py:data:: dr_I

.. py:data:: add_dref

.. py:data:: del_dref

.. py:data:: get_first_dref_from

.. py:data:: get_next_dref_from

.. py:data:: get_first_dref_to

.. py:data:: get_next_dref_to

.. py:function:: get_xref_type()

   Return type of the last xref obtained by
   [RD]first/next[B0] functions.

   :returns: constants fl_* or dr_*


.. py:function:: fopen(f, mode)

.. py:function:: fclose(handle)

.. py:function:: filelength(handle)

.. py:function:: fseek(handle, offset, origin)

.. py:function:: ftell(handle)

.. py:function:: LoadFile(filepath, pos, ea, size)

   Load file into IDA database

   :param filepath: path to input file
   :param pos: position in the file
   :param ea: linear address to load
   :param size: number of bytes to load

   :returns: 0 - error, 1 - ok


.. py:function:: loadfile(filepath, pos, ea, size)

.. py:function:: SaveFile(filepath, pos, ea, size)

   Save from IDA database to file

   :param filepath: path to output file
   :param pos: position in the file
   :param ea: linear address to save from
   :param size: number of bytes to save

   :returns: 0 - error, 1 - ok


.. py:function:: savefile(filepath, pos, ea, size)

.. py:function:: fgetc(handle)

.. py:function:: fputc(byte, handle)

.. py:function:: fprintf(handle, format, *args)

.. py:function:: readshort(handle, mostfirst)

.. py:function:: readlong(handle, mostfirst)

.. py:function:: writeshort(handle, word, mostfirst)

.. py:function:: writelong(handle, dword, mostfirst)

.. py:function:: readstr(handle)

.. py:function:: writestr(handle, s)

.. py:data:: add_func

.. py:data:: del_func

.. py:data:: set_func_end

.. py:function:: get_next_func(ea)

   Find next function

   :param ea: any address belonging to the function

   :returns:        BADADDR - no more functions
           otherwise returns the next function start address


.. py:function:: get_prev_func(ea)

   Find previous function

   :param ea: any address belonging to the function

   :returns: BADADDR - no more functions
           otherwise returns the previous function start address


.. py:function:: get_func_attr(ea, attr)

   Get a function attribute

   :param ea: any address belonging to the function
   :param attr: one of FUNCATTR_... constants

   :returns: BADADDR - error otherwise returns the attribute value


.. py:function:: set_func_attr(ea, attr, value)

   Set a function attribute

   :param ea: any address belonging to the function
   :param attr: one of FUNCATTR_... constants
   :param value: new value of the attribute

   :returns: 1-ok, 0-failed


.. py:data:: FUNCATTR_START
   :value: 0


.. py:data:: FUNCATTR_END
   :value: 4


.. py:data:: FUNCATTR_FLAGS
   :value: 8


.. py:data:: FUNCATTR_FRAME
   :value: 16


.. py:data:: FUNCATTR_FRSIZE
   :value: 20


.. py:data:: FUNCATTR_FRREGS
   :value: 24


.. py:data:: FUNCATTR_ARGSIZE
   :value: 28


.. py:data:: FUNCATTR_FPD
   :value: 32


.. py:data:: FUNCATTR_COLOR
   :value: 36


.. py:data:: FUNCATTR_OWNER
   :value: 16


.. py:data:: FUNCATTR_REFQTY
   :value: 20


.. py:data:: FUNCATTR_START
   :value: 0


.. py:function:: get_func_flags(ea)

   Retrieve function flags

   :param ea: any address belonging to the function

   :returns: -1 - function doesn't exist otherwise returns the flags


.. py:data:: FUNC_NORET

.. py:data:: FUNC_FAR

.. py:data:: FUNC_LIB

.. py:data:: FUNC_STATIC

.. py:data:: FUNC_FRAME

.. py:data:: FUNC_USERFAR

.. py:data:: FUNC_HIDDEN

.. py:data:: FUNC_THUNK

.. py:data:: FUNC_BOTTOMBP

.. py:data:: FUNC_NORET_PENDING

.. py:data:: FUNC_SP_READY

.. py:data:: FUNC_PURGED_OK

.. py:data:: FUNC_TAIL

.. py:data:: FUNC_LUMINA

.. py:data:: FUNC_OUTLINE

.. py:function:: set_func_flags(ea, flags)

   Change function flags

   :param ea: any address belonging to the function
   :param flags: see get_func_flags() for explanations

   :returns: !=0 - ok


.. py:function:: get_func_name(ea)

   Retrieve function name

   :param ea: any address belonging to the function

   :returns: null string - function doesn't exist
           otherwise returns function name


.. py:function:: get_func_cmt(ea, repeatable)

   Retrieve function comment

   :param ea: any address belonging to the function
   :param repeatable: 1: get repeatable comment
           0: get regular comment

   :returns: function comment string


.. py:function:: set_func_cmt(ea, cmt, repeatable)

   Set function comment

   :param ea: any address belonging to the function
   :param cmt: a function comment line
   :param repeatable: 1: get repeatable comment
           0: get regular comment


.. py:function:: choose_func(title)

   Ask the user to select a function

   Arguments:

   :param title: title of the dialog box

   :returns: -1 - user refused to select a function
            otherwise returns the selected function start address


.. py:function:: get_func_off_str(ea)

   Convert address to 'funcname+offset' string

   :param ea: address to convert

   :returns: if the address belongs to a function then return a string
            formed as 'name+offset' where 'name' is a function name
            'offset' is offset within the function else return null string


.. py:function:: find_func_end(ea)

   Determine a new function boundaries

   :param ea: starting address of a new function

   :returns: if a function already exists, then return its end address.
           If a function end cannot be determined, the return BADADDR
           otherwise return the end address of the new function


.. py:function:: get_frame_id(ea)

   Get ID of function frame structure

   :param ea: any address belonging to the function

   :returns: ID of function frame or None In order to access stack variables
            you need to use structure member manipulaion functions with the
            obtained ID.


.. py:function:: get_frame_lvar_size(ea)

   Get size of local variables in function frame

   :param ea: any address belonging to the function

   :returns: Size of local variables in bytes.
            If the function doesn't have a frame, return 0
            If the function doesn't exist, return None


.. py:function:: get_frame_regs_size(ea)

   Get size of saved registers in function frame

   :param ea: any address belonging to the function

   :returns: Size of saved registers in bytes.
            If the function doesn't have a frame, return 0
            This value is used as offset for BP (if FUNC_FRAME is set)
            If the function doesn't exist, return None


.. py:function:: get_frame_args_size(ea)

   Get size of arguments in function frame which are purged upon return

   :param ea: any address belonging to the function

   :returns: Size of function arguments in bytes.
            If the function doesn't have a frame, return 0
            If the function doesn't exist, return -1


.. py:function:: get_frame_size(ea)

   Get full size of function frame

   :param ea: any address belonging to the function
   :returns: Size of function frame in bytes.
               This function takes into account size of local
               variables + size of saved registers + size of
               return address + size of function arguments
               If the function doesn't have a frame, return size of
               function return address in the stack.
               If the function doesn't exist, return 0


.. py:function:: set_frame_size(ea, lvsize, frregs, argsize)

   Make function frame

   :param ea: any address belonging to the function
   :param lvsize: size of function local variables
   :param frregs: size of saved registers
   :param argsize: size of function arguments

   :returns: ID of function frame or -1
            If the function did not have a frame, the frame
            will be created. Otherwise the frame will be modified


.. py:function:: get_spd(ea)

   Get current delta for the stack pointer

   :param ea: end address of the instruction
              i.e.the last address of the instruction+1

   :returns: The difference between the original SP upon
            entering the function and SP for the specified address


.. py:function:: get_sp_delta(ea)

   Get modification of SP made by the instruction

   :param ea: end address of the instruction
              i.e.the last address of the instruction+1

   :returns: Get modification of SP made at the specified location
            If the specified location doesn't contain a SP change point, return 0
            Otherwise return delta of SP modification


.. py:function:: get_fchunk_attr(ea, attr)

   Get a function chunk attribute

   :param ea: any address in the chunk
   :param attr: one of: FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER, FUNCATTR_REFQTY

   :returns: desired attribute or -1


.. py:function:: set_fchunk_attr(ea, attr, value)

   Set a function chunk attribute

   :param ea: any address in the chunk
   :param attr: only FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER
   :param value: desired value

   :returns: 0 if failed, 1 if success


.. py:data:: get_fchunk_referer

.. py:function:: get_next_fchunk(ea)

   Get next function chunk

   :param ea: any address

   :returns:  the starting address of the next function chunk or BADADDR

   NOTE: This function enumerates all chunks of all functions in the database


.. py:function:: get_prev_fchunk(ea)

   Get previous function chunk

   :param ea: any address

   :returns: the starting address of the function chunk or BADADDR

   NOTE: This function enumerates all chunks of all functions in the database


.. py:function:: append_func_tail(funcea, ea1, ea2)

   Append a function chunk to the function

   :param funcea: any address in the function
   :param ea1: start of function tail
   :param ea2: end of function tail
   :returns: 0 if failed, 1 if success

   NOTE: If a chunk exists at the specified addresses, it must have exactly
          the specified boundaries


.. py:function:: remove_fchunk(funcea, tailea)

   Remove a function chunk from the function

   :param funcea: any address in the function
   :param tailea: any address in the function chunk to remove

   :returns: 0 if failed, 1 if success


.. py:function:: set_tail_owner(tailea, funcea)

   Change the function chunk owner

   :param tailea: any address in the function chunk
   :param funcea: the starting address of the new owner

   :returns: False if failed, True if success

   NOTE: The new owner must already have the chunk appended before the call


.. py:function:: first_func_chunk(funcea)

   Get the first function chunk of the specified function

   :param funcea: any address in the function

   :returns: the function entry point or BADADDR

   NOTE: This function returns the first (main) chunk of the specified function


.. py:function:: next_func_chunk(funcea, tailea)

   Get the next function chunk of the specified function

   :param funcea: any address in the function
   :param tailea: any address in the current chunk

   :returns: the starting address of the next function chunk or BADADDR

   NOTE: This function returns the next chunk of the specified function


.. py:function:: add_auto_stkpnt(func_ea, ea, delta)

   Add automatic SP register change point
   :param func_ea: function start
   :param ea: linear address where SP changes
              usually this is the end of the instruction which
              modifies the stack pointer (insn.ea+insn.size)
   :param delta: difference between old and new values of SP
   :returns: 1-ok, 0-failed


.. py:data:: add_user_stkpnt

.. py:function:: del_stkpnt(func_ea, ea)

   Delete SP register change point

   :param func_ea: function start
   :param ea: linear address
   :returns: 1-ok, 0-failed


.. py:function:: get_min_spd_ea(func_ea)

   Return the address with the minimal spd (stack pointer delta)
   If there are no SP change points, then return BADADDR.

   :param func_ea: function start
   :returns: BADDADDR - no such function


.. py:data:: recalc_spd

.. py:data:: get_entry_qty

.. py:data:: add_entry

.. py:data:: get_entry_ordinal

.. py:data:: get_entry

.. py:data:: get_entry_name

.. py:data:: rename_entry

.. py:data:: get_next_fixup_ea

.. py:data:: get_prev_fixup_ea

.. py:function:: get_fixup_target_type(ea)

   Get fixup target type

   :param ea: address to get information about

   :returns: 0 - no fixup at the specified address
                otherwise returns fixup type


.. py:data:: FIXUP_OFF8
   :value: 13


.. py:data:: FIXUP_OFF16
   :value: 1


.. py:data:: FIXUP_SEG16
   :value: 2


.. py:data:: FIXUP_PTR32
   :value: 3


.. py:data:: FIXUP_OFF32
   :value: 4


.. py:data:: FIXUP_PTR48
   :value: 5


.. py:data:: FIXUP_HI8
   :value: 6


.. py:data:: FIXUP_HI16
   :value: 7


.. py:data:: FIXUP_LOW8
   :value: 8


.. py:data:: FIXUP_LOW16
   :value: 9


.. py:data:: FIXUP_OFF64
   :value: 12


.. py:data:: FIXUP_CUSTOM
   :value: 32768


.. py:function:: get_fixup_target_flags(ea)

   Get fixup target flags

   :param ea: address to get information about

   :returns: 0 - no fixup at the specified address
                otherwise returns fixup target flags


.. py:data:: FIXUPF_REL
   :value: 1


.. py:data:: FIXUPF_EXTDEF
   :value: 2


.. py:data:: FIXUPF_UNUSED
   :value: 4


.. py:data:: FIXUPF_CREATED
   :value: 8


.. py:function:: get_fixup_target_sel(ea)

   Get fixup target selector

   :param ea: address to get information about

   :returns: BADSEL - no fixup at the specified address
                     otherwise returns fixup target selector


.. py:function:: get_fixup_target_off(ea)

   Get fixup target offset

   :param ea: address to get information about

   :returns: BADADDR - no fixup at the specified address
                      otherwise returns fixup target offset


.. py:function:: get_fixup_target_dis(ea)

   Get fixup target displacement

   :param ea: address to get information about

   :returns: 0 - no fixup at the specified address
                otherwise returns fixup target displacement


.. py:function:: set_fixup(ea, fixuptype, fixupflags, targetsel, targetoff, displ)

   Set fixup information

   :param ea: address to set fixup information about
   :param fixuptype:  fixup type. see get_fixup_target_type()
                      for possible fixup types.
   :param fixupflags: fixup flags. see get_fixup_target_flags()
                      for possible fixup types.
   :param targetsel:  target selector
   :param targetoff:  target offset
   :param displ:      displacement

   :returns:        none


.. py:data:: del_fixup

.. py:data:: put_bookmark

.. py:data:: get_bookmark

.. py:data:: get_bookmark_desc

.. py:function:: get_struc_id(name)

.. py:function:: get_struc_name(tid)

.. py:function:: get_struc_cmt(tid)

.. py:function:: get_struc_size(tid)

.. py:function:: get_member_qty(sid)

   Get number of members of a structure

   :param sid: structure type ID

   :returns: -1 if bad structure type ID is passed otherwise
            returns number of members.


.. py:function:: get_member_by_idx(sid, idx)

   Get member ID by member ordinal number

   :param sid: structure type ID
   :param idx: member ordinal number

   :returns: -1 if bad structure type ID is passed or there is
            no member with the specified index
            otherwise returns the member ID.


.. py:function:: is_member_id(sid)

   Is a member id?

   :param sid: structure type ID

   :returns: True there is structure member with the specified ID
            False otherwise


.. py:function:: get_member_id(sid, member_offset)

   :param sid: structure type ID
   :param member_offset:. The offset can be
   any offset in the member. For example,
   is a member is 4 bytes long and starts
   at offset 2, then 2,3,4,5 denote
   the same structure member.

   :returns: -1 if bad structure type ID is passed or there is
   no member at the specified offset.
   otherwise returns the member id.


.. py:function:: get_member_offset(sid, member_name)

   Get offset of a member of a structure by the member name

   :param sid: structure type ID
   :param member_name: name of structure member

   :returns: -1 if bad structure type ID is passed
            or no such member in the structure
            otherwise returns offset of the specified member.

   NOTE: Union members are, in IDA's internals, located
          at subsequent byte offsets: member 0 -> offset 0x0,
          member 1 -> offset 0x1, etc...


.. py:function:: get_member_name(sid, member_offset)

   Get name of a member of a structure

   :param sid: structure type ID
   :param member_offset: member offset. The offset can be
                         any offset in the member. For example,
                         is a member is 4 bytes long and starts
                         at offset 2, then 2,3,4,5 denote
                         the same structure member.

   :returns: None if bad structure type ID is passed
            or no such member in the structure
            otherwise returns name of the specified member.


.. py:function:: get_member_cmt(sid, member_offset, repeatable=True)

   Get comment of a member

   :param sid: structure type ID
   :param member_offset: member offset. The offset can be
                         any offset in the member. For example,
                         is a member is 4 bytes long and starts
                         at offset 2, then 2,3,4,5 denote
                         the same structure member.
   :param repeatable: is not used anymore

   :returns: None if bad structure type ID is passed
            or no such member in the structure
            otherwise returns comment of the specified member.


.. py:function:: get_member_size(sid, member_offset)

   Get size of a member

   :param sid: structure type ID
   :param member_offset: member offset. The offset can be
                         any offset in the member. For example,
                         is a member is 4 bytes long and starts
                         at offset 2, then 2,3,4,5 denote
                         the same structure member.

   :returns: None if bad structure type ID is passed,
            or no such member in the structure
            otherwise returns size of the specified
            member in bytes.


.. py:function:: get_member_strid(sid, member_offset)

   Get structure id of a member

   :param sid: structure type ID
   :param member_offset: member offset. The offset can be
                         any offset in the member. For example,
                         is a member is 4 bytes long and starts
                         at offset 2, then 2,3,4,5 denote
                         the same structure member.
   :returns: -1 if bad structure type ID is passed
            or no such member in the structure
            otherwise returns structure id of the member.
            If the current member is not a structure, returns -1.


.. py:function:: is_union(sid)

   Is a structure a union?

   :param sid: structure type ID

   :returns: True: yes, this is a union id
            False: no

   NOTE: Unions are a special kind of structures


.. py:function:: add_struc(index, name, is_union)

   Define a new structure type

   :param index: -1
   :param name: name of the new structure type.
   :param is_union: 0: structure
                    1: union

   :returns: -1 if can't define structure type because of
            bad structure name: the name is ill-formed or is
            already used in the program.
            otherwise returns ID of the new structure type


.. py:function:: del_struc(sid)

   Delete a structure type

   :param sid: structure type ID

   :returns: 0 if bad structure type ID is passed
            1 otherwise the structure type is deleted. All data
            and other structure types referencing to the
            deleted structure type will be displayed as array
            of bytes.


.. py:function:: set_struc_name(sid, name)

.. py:function:: set_struc_cmt(sid, cmt, repeatable=True)

.. py:function:: add_struc_member(sid, name, offset, flag, typeid, nbytes, target=-1, tdelta=0, reftype=REF_OFF32)

   Add structure member

   :param sid: structure type ID
   :param name: name of the new member
   :param offset: offset of the new member
                  -1 means to add at the end of the structure
   :param flag: type of the new member. Should be one of
                FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
   :param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                  if is_off0(flag) then typeid specifies the offset base.
                  if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                  if is_stroff(flag) then typeid specifies the structure id
                  if is_enum(flag) then typeid specifies the enum id
                  if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                  Otherwise typeid should be -1.
   :param nbytes: number of bytes in the new member

   :param target: target address of the offset expr. You may specify it as
                  -1, ida will calculate it itself
   :param tdelta: offset target delta. usually 0
   :param reftype: see REF_... definitions

   NOTE: The remaining arguments are allowed only if is_off0(flag) and you want
          to specify a complex offset expression

   :returns: 0 - ok, otherwise error code (one of typeinf.TERR_*)



.. py:function:: del_struc_member(sid, member_offset)

   Delete structure member

   :param sid: structure type ID
   :param member_offset: offset of the member

   :returns: != 0 - ok.

   NOTE: IDA allows 'holes' between members of a
          structure. It treats these 'holes'
          as unnamed arrays of bytes.


.. py:function:: set_member_name(sid, member_offset, name)

   Change structure member name

   :param sid: structure type ID
   :param member_offset: offset of the member
   :param name: new name of the member

   :returns: != 0 - ok.


.. py:function:: set_member_type(sid, member_offset, flag, typeid, nitems, target=-1, tdelta=0, reftype=REF_OFF32)

   Change structure member type

   :param sid: structure type ID
   :param member_offset: offset of the member
   :param flag: new type of the member. Should be one of
                FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
   :param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                  if is_off0(flag) then typeid specifies the offset base.
                  if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                  if is_stroff(flag) then typeid specifies the structure id
                  if is_enum(flag) then typeid specifies the enum id
                  if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                  Otherwise typeid should be -1.
   :param nitems: number of items in the member

   :param target: target address of the offset expr. You may specify it as
                  -1, ida will calculate it itself
   :param tdelta: offset target delta. usually 0
   :param reftype: see REF_... definitions

   NOTE: The remaining arguments are allowed only if is_off0(flag) and you want
          to specify a complex offset expression

   :returns: !=0 - ok.


.. py:function:: set_member_cmt(sid, member_offset, comment, repeatable)

   Change structure member comment

   :param sid: structure type ID
   :param member_offset: offset of the member
   :param comment: new comment of the structure member
   :param repeatable: 1: change repeatable comment
                      0: change regular comment

   :returns: != 0 - ok


.. py:function:: expand_struc(sid, offset, delta, recalc=True)

   Expand or shrink a structure type
   :param id: structure type ID
   :param offset: offset in the structure
   :param delta: how many bytes to add or remove
   :param recalc: is not used anymore
   :returns: True if ok, False on error


.. py:data:: ENFL_REGEX
   :value: 1


.. py:function:: get_enum(name)

   Get enum by name

   :param name: enum type name

   :returns: enum type TID or BADADDR


.. py:function:: get_enum_name(enum_id, flags=0)

   Get name of enum

   :param enum_id: enum TID
   :param flags: use ENFL_REGEX to beautify the name

   :returns: enum name or None


.. py:function:: get_enum_cmt(enum_id)

   Get enum comment

   :param enum_id: enum TID

   :returns: enum comment


.. py:function:: get_enum_size(enum_id)

   Get the number of the members of the enum

   :param enum_id: enum TID

   :returns: number of members


.. py:function:: get_enum_width(enum_id)

   Get the width of a enum element
   allowed values: 0 (unspecified),1,2,4,8,16,32,64

   :param enum_id: enum TID

   :returns: enum width or -1 in case of error


.. py:function:: get_enum_flag(enum_id)

   Get flags determining the representation of the enum.
   (currently they define the numeric base: octal, decimal, hex, bin) and signness.

   :param enum_id: enum TID

   :returns: flag of 0


.. py:function:: get_enum_member_by_name(name)

   Get a reference to an enum member by its name

   :param name: enum member name

   :returns: enum member TID or BADADDR


.. py:function:: get_enum_member_enum(const_id)

   Get the parent enum of an enum member

   :param const_id: id of const

   :returns: enum TID or BADADDR


.. py:function:: get_enum_member(enum_id, value, serial, bmask)

   Get id of constant

   :param enum_id: id of enum
   :param value: value of constant
   :param serial: serial number of the constant in the
             enumeration. See op_enum() for details.
   :param bmask: bitmask of the constant
             ordinary enums accept only -1 as a bitmask

   :returns: id of constant or -1 if error


.. py:function:: get_first_bmask(enum_id)

   Get first bitmask in the enum

   :param enum_id: id of enum

   :returns: id of constant or -1 if error


.. py:function:: get_last_bmask(enum_id)

   Get last bitmask in the enum

   :param enum_id: id of enum

   :returns: id of constant or -1 if error


.. py:function:: get_next_bmask(enum_id, bmask)

   Get next bitmask in the enum

   :param enum_id: id of enum
   :param bmask

   :returns: id of constant or -1 if error


.. py:function:: get_prev_bmask(enum_id, bmask)

   Get prev bitmask in the enum

   :param enum_id: id of enum
   :param bmask

   :returns: id of constant or -1 if error


.. py:function:: get_bmask_name(enum_id, bmask)

   Get bitmask name (only for bitfields)

   :param enum_id: id of enum
   :param bmask: bitmask of the constant

   :returns: name of bitmask or None


.. py:function:: get_bmask_cmt(enum_id, bmask, repeatable)

   Get bitmask comment (only for bitfields)

   :param enum_id: id of enum
   :param bmask: bitmask of the constant
   :param repeatable: type of comment, 0-regular, 1-repeatable

   :returns: comment attached to bitmask or None


.. py:function:: set_bmask_name(enum_id, bmask, name)

   Set bitmask name (only for bitfields)

   :param enum_id: id of enum
   :param bmask: bitmask of the constant
   :param name: name of bitmask

   :returns: True-ok, False-failed


.. py:function:: set_bmask_cmt(enum_id, bmask, cmt, repeatable)

   Set bitmask comment (only for bitfields)

   :param enum_id: id of enum
   :param bmask: bitmask of the constant
   :param cmt: comment
   repeatable - is not used anymore

   :returns: 1-ok, 0-failed


.. py:function:: get_first_enum_member(enum_id, bmask=-1)

   Get first constant in the enum

   :param enum_id: id of enum
   :param bmask: bitmask of the constant (ordinary enums accept only -1 as a bitmask)

   :returns: value of constant or -1 if no constants are defined
            All constants are sorted by their values as unsigned longs.


.. py:function:: get_last_enum_member(enum_id, bmask=-1)

   Get last constant in the enum

   :param enum_id: id of enum
   :param bmask: bitmask of the constant (ordinary enums accept only -1 as a bitmask)

   :returns: value of constant or -1 if no constants are defined
            All constants are sorted by their values
            as unsigned longs.


.. py:function:: get_next_enum_member(enum_id, value, bmask=-1)

   Get next constant in the enum

   :param enum_id: id of enum
   :param bmask: bitmask of the constant ordinary enums accept only -1 as a bitmask
   :param value: value of the current constant

   :returns: value of a constant with value higher than the specified
            value. -1 if no such constants exist.
            All constants are sorted by their values as unsigned longs.


.. py:function:: get_prev_enum_member(enum_id, value, bmask=-1)

   Get prev constant in the enum

   :param enum_id: id of enum
   :param bmask  : bitmask of the constant
             ordinary enums accept only -1 as a bitmask
   :param value: value of the current constant

   :returns: value of a constant with value lower than the specified
       value. -1 if no such constants exist.
       All constants are sorted by their values as unsigned longs.


.. py:function:: get_enum_member_name(const_id)

   Get name of a constant

   :param const_id: id of const

   Returns: name of constant


.. py:function:: get_enum_member_cmt(const_id, repeatable=True)

   Get comment of a constant

   :param const_id: id of const
   :param repeatable: not used anymore

   :returns: comment string


.. py:function:: get_enum_member_value(const_id)

   Get value of an enum member

   :param const_id: id of const

   :returns: member value or None


.. py:function:: get_enum_member_bmask(const_id)

   Get bitmask of an enum member

   :param const_id: id of const

   :returns: member value or None


.. py:function:: add_enum(idx, name, flag)

   Add a new enum type

   :param idx: is not used anymore
   :param name: name of the enum.
   :param flag: flags for representation of numeric constants
                in the definition of enum.

   :returns: id of new enum or BADADDR


.. py:function:: del_enum(enum_id)

   Delete an enum type

   :param enum_id: id of enum

   :returns: success


.. py:function:: set_enum_name(enum_id, name)

   Set name of enum type

   :param enum_id: id of enum
   :param name: new enum name

   :returns: 1-ok, 0-failed


.. py:function:: set_enum_flag(enum_id, flag)

   Set enum constant representation flags

   :param enum_id: enum TID
   :param flag

   :returns: success


.. py:function:: set_enum_width(enum_id, nbytes)

   Set the width of enum base type

   :param enum_id: enum TID
   :param nbytes: width of enum base type, allowed values: 0 (unspecified),1,2,4,8,16,32,64

   :returns: success


.. py:function:: is_bf(enum_id)

   Is enum a bitmask ?

   :param enum_id: enum TID

   :returns: if it is a bitmask enum return True, otherwise False


.. py:function:: set_enum_bf(enum_id, bf)

   Set or clear the 'bitmask' attribute of an enum

   :param enum_id: enum TID
   :param bf: bitmask enum or not

   :returns: success


.. py:function:: set_enum_cmt(enum_id, cmt, repeatable)

   Set comment for enum type

   :param enum_id: enum TID
   :param cmt: comment
   :param repeatable: is comment repeatable ?

   :returns: 1-ok, 0-failed


.. py:function:: add_enum_member(enum_id, name, value, bmask=-1)

   Add a member of enum - a symbolic constant

   :param enum_id: id of enum
   :param name: name of symbolic constant. Must be unique in the program.
   :param value: value of symbolic constant.
   :param bmask: bitmask of the constant
       ordinary enums accept only -1 as a bitmask
       all bits set in value should be set in bmask too

   :returns: 0-ok, otherwise error code (one of ENUM_MEMBER_ERROR_*)


.. py:function:: del_enum_member(enum_id, value, serial, bmask=-1)

   Delete a member of enum - a symbolic constant

   :param enum_id: id of enum
   :param value: value of symbolic constant.
   :param serial: serial number of the constant in the
       enumeration. See op_enum() for for details.
   :param bmask: bitmask of the constant ordinary enums accept
       only -1 as a bitmask

   :returns: 1-ok, 0-failed


.. py:function:: set_enum_member_name(const_id, name)

   Set name of enum member

   :param const_id: enum constant TID
   :param name: new member name

   :returns: 1-ok, 0-failed


.. py:function:: set_enum_member_cmt(const_id, cmt, repeatable=False)

   Set comment for enum member

   :param const_id: enum constant TID
   :param cmt: comment
   :param repeatable: is not used anymore

   :returns: 1-ok, 0-failed


.. py:data:: AR_LONG

   Array of longs


.. py:data:: AR_STR

   Array of strings


.. py:function:: create_array(name)

   Create array.

   :param name: The array name.

   :returns: -1 in case of failure, a valid array_id otherwise.


.. py:function:: get_array_id(name)

   Get array array_id, by name.

   :param name: The array name.

   :returns: -1 in case of failure (i.e., no array with that
            name exists), a valid array_id otherwise.


.. py:function:: rename_array(array_id, newname)

   Rename array, by its ID.

   :param id: The ID of the array to rename.
   :param newname: The new name of the array.

   :returns: 1 in case of success, 0 otherwise


.. py:function:: delete_array(array_id)

   Delete array, by its ID.

   :param array_id: The ID of the array to delete.


.. py:function:: set_array_long(array_id, idx, value)

   Sets the long value of an array element.

   :param array_id: The array ID.
   :param idx: Index of an element.
   :param value: 32bit or 64bit value to store in the array

   :returns: 1 in case of success, 0 otherwise


.. py:function:: set_array_string(array_id, idx, value)

   Sets the string value of an array element.

   :param array_id: The array ID.
   :param idx: Index of an element.
   :param value: String value to store in the array

   :returns: 1 in case of success, 0 otherwise


.. py:function:: get_array_element(tag, array_id, idx)

   Get value of array element.

   :param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
   :param array_id: The array ID.
   :param idx: Index of an element.

   :returns: Value of the specified array element. Note that
            this function may return char or long result. Unexistent
            array elements give zero as a result.


.. py:function:: del_array_element(tag, array_id, idx)

   Delete an array element.

   :param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
   :param array_id: The array ID.
   :param idx: Index of an element.

   :returns: 1 in case of success, 0 otherwise.


.. py:function:: get_first_index(tag, array_id)

   Get index of the first existing array element.

   :param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
   :param array_id: The array ID.

   :returns: -1 if the array is empty, otherwise index of first array
            element of given type.


.. py:function:: get_last_index(tag, array_id)

   Get index of last existing array element.

   :param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
   :param array_id: The array ID.

   :returns: -1 if the array is empty, otherwise index of first array
            element of given type.


.. py:function:: get_next_index(tag, array_id, idx)

   Get index of the next existing array element.

   :param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
   :param array_id: The array ID.
   :param idx: Index of the current element.

   :returns: -1 if no more elements, otherwise returns index of the
            next array element of given type.


.. py:function:: get_prev_index(tag, array_id, idx)

   Get index of the previous existing array element.

   :param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
   :param array_id: The array ID.
   :param idx: Index of the current element.

   :returns: -1 if no more elements, otherwise returns index of the
            previous array element of given type.


.. py:function:: set_hash_long(hash_id, key, value)

   Sets the long value of a hash element.

   :param hash_id: The hash ID.
   :param key: Key of an element.
   :param value: 32bit or 64bit value to store in the hash

   :returns: 1 in case of success, 0 otherwise


.. py:function:: get_hash_long(hash_id, key)

   Gets the long value of a hash element.

   :param hash_id: The hash ID.
   :param key: Key of an element.

   :returns: the 32bit or 64bit value of the element, or 0 if no such
            element.


.. py:function:: set_hash_string(hash_id, key, value)

   Sets the string value of a hash element.

   :param hash_id: The hash ID.
   :param key: Key of an element.
   :param value: string value to store in the hash

   :returns: 1 in case of success, 0 otherwise


.. py:function:: get_hash_string(hash_id, key)

   Gets the string value of a hash element.

   :param hash_id: The hash ID.
   :param key: Key of an element.

   :returns: the string value of the element, or None if no such
            element.


.. py:function:: del_hash_string(hash_id, key)

   Delete a hash element.

   :param hash_id: The hash ID.
   :param key: Key of an element

   :returns: 1 upon success, 0 otherwise.


.. py:function:: get_first_hash_key(hash_id)

   Get the first key in the hash.

   :param hash_id: The hash ID.

   :returns: the key, 0 otherwise.


.. py:function:: get_last_hash_key(hash_id)

   Get the last key in the hash.

   :param hash_id: The hash ID.

   :returns: the key, 0 otherwise.


.. py:function:: get_next_hash_key(hash_id, key)

   Get the next key in the hash.

   :param hash_id: The hash ID.
   :param key: The current key.

   :returns: the next key, 0 otherwise


.. py:function:: get_prev_hash_key(hash_id, key)

   Get the previous key in the hash.

   :param hash_id: The hash ID.
   :param key: The current key.

   :returns: the previous key, 0 otherwise


.. py:data:: add_sourcefile

.. py:data:: get_sourcefile

.. py:data:: del_sourcefile

.. py:data:: set_source_linnum

.. py:data:: get_source_linnum

.. py:data:: del_source_linnum

.. py:function:: add_default_til(name)

   Load a type library

   :param name: name of type library.
   :returns: 1-ok, 0-failed.


.. py:function:: import_type(idx, type_name)

   Copy information from type library to database
   Copy structure, union, or enum definition from the type library
   to the IDA database.

   :param idx: -1, ignored
   :param type_name: name of type to copy

   :returns: BADNODE-failed, otherwise the type id (structure id or enum id)


.. py:function:: get_type(ea)

   Get type of function/variable

   :param ea: the address of the object

   :returns: type string or None if failed


.. py:function:: sizeof(typestr)

   Returns the size of the type. It is equivalent to IDC's sizeof().
   :param typestr: can be specified as a typeinfo tuple (e.g. the result of get_tinfo()),
           serialized type byte string,
           or a string with C declaration (e.g. "int")
   :returns: -1 if typestring is not valid or has no size. otherwise size of the type


.. py:data:: SizeOf

.. py:function:: get_tinfo(ea)

   Get type information of function/variable as 'typeinfo' object

   :param ea: the address of the object
   :returns: None on failure, or (type, fields) tuple.


.. py:function:: get_local_tinfo(ordinal)

   Get local type information as 'typeinfo' object

   :param ordinal:  slot number (1...NumberOfLocalTypes)
   :returns: None on failure, or (type, fields) tuple.


.. py:function:: guess_type(ea)

   Guess type of function/variable

   :param ea: the address of the object, can be the structure member id too

   :returns: type string or None if failed


.. py:data:: TINFO_GUESSED
   :value: 0


.. py:data:: TINFO_DEFINITE
   :value: 1


.. py:data:: TINFO_DELAYFUNC
   :value: 2


.. py:function:: apply_type(ea, py_type, flags=TINFO_DEFINITE)

   Apply the specified type to the address

   :param ea: the address of the object
   :param py_type: typeinfo tuple (type, fields) as get_tinfo() returns
                or tuple (name, type, fields) as parse_decl() returns
                or None
               if specified as None, then the
               item associated with 'ea' will be deleted.
   :param flags: combination of TINFO_... constants or 0
   :returns: Boolean


.. py:data:: PT_SIL

.. py:data:: PT_NDC

.. py:data:: PT_TYP

.. py:data:: PT_VAR

.. py:data:: PT_PACKMASK

.. py:data:: PT_HIGH

.. py:data:: PT_LOWER

.. py:data:: PT_REPLACE

.. py:data:: PT_RAWARGS

.. py:data:: PT_SILENT

.. py:data:: PT_PAKDEF
   :value: 0


.. py:data:: PT_PAK1
   :value: 16


.. py:data:: PT_PAK2
   :value: 32


.. py:data:: PT_PAK4
   :value: 48


.. py:data:: PT_PAK8
   :value: 64


.. py:data:: PT_PAK16
   :value: 80


.. py:data:: PT_FILE
   :value: 65536


.. py:data:: PT_STANDALONE

.. py:function:: SetType(ea, newtype)

   Set type of function/variable

   :param ea: the address of the object
   :param newtype: the type string in C declaration form.
               Must contain the closing ';'
               if specified as an empty string, then the
               item associated with 'ea' will be deleted.

   :returns: 1-ok, 0-failed.


.. py:function:: parse_decl(inputtype, flags)

   Parse type declaration

   :param inputtype: file name or C declarations (depending on the flags)
   :param flags: combination of PT_... constants or 0

   :returns: None on failure or (name, type, fields) tuple


.. py:function:: parse_decls(inputtype, flags=0)

   Parse type declarations

   :param inputtype: file name or C declarations (depending on the flags)
   :param flags: combination of PT_... constants or 0

   :returns: number of parsing errors (0 no errors)


.. py:function:: print_decls(ordinals, flags)

   Print types in a format suitable for use in a header file

   :param ordinals: comma-separated list of type ordinals
   :param flags: combination of PDF_... constants or 0

   :returns: string containing the type definitions


.. py:data:: PDF_INCL_DEPS
   :value: 1


.. py:data:: PDF_DEF_FWD
   :value: 2


.. py:data:: PDF_DEF_BASE
   :value: 4


.. py:data:: PDF_HEADER_CMT
   :value: 8


.. py:function:: get_ordinal_limit()

   Get number of local types + 1

   :returns: value >= 1. 1 means that there are no local types.


.. py:function:: set_local_type(ordinal, input, flags)

   Parse one type declaration and store it in the specified slot

   :param ordinal:  slot number (1...NumberOfLocalTypes)
                    -1 means allocate new slot or reuse the slot
                    of the existing named type
   :param input:  C declaration. Empty input empties the slot
   :param flags:  combination of PT_... constants or 0

   :returns: slot number or 0 if error


.. py:function:: GetLocalType(ordinal, flags)

   Retrieve a local type declaration
   :param flags: any of PRTYPE_* constants
   :returns: local type as a C declaration or ""


.. py:data:: PRTYPE_1LINE
   :value: 0


.. py:data:: PRTYPE_MULTI
   :value: 1


.. py:data:: PRTYPE_TYPE
   :value: 2


.. py:data:: PRTYPE_PRAGMA
   :value: 4


.. py:data:: PRTYPE_SEMI
   :value: 8


.. py:data:: PRTYPE_CPP
   :value: 16


.. py:data:: PRTYPE_DEF
   :value: 32


.. py:data:: PRTYPE_NOARGS
   :value: 64


.. py:data:: PRTYPE_NOARRS
   :value: 128


.. py:data:: PRTYPE_NORES
   :value: 256


.. py:data:: PRTYPE_RESTORE
   :value: 512


.. py:data:: PRTYPE_NOREGEX
   :value: 1024


.. py:data:: PRTYPE_COLORED
   :value: 2048


.. py:data:: PRTYPE_METHODS
   :value: 4096


.. py:data:: PRTYPE_1LINCMT
   :value: 8192


.. py:function:: get_numbered_type_name(ordinal)

   Retrieve a local type name

   :param ordinal:  slot number (1...NumberOfLocalTypes)

   returns: local type name or None


.. py:data:: add_hidden_range

.. py:function:: update_hidden_range(ea, visible)

   Set hidden range state

   :param ea:      any address belonging to the hidden range
   :param visible: new state of the range

   :returns: != 0 - ok


.. py:data:: del_hidden_range

.. py:data:: load_debugger

.. py:data:: start_process

.. py:data:: exit_process

.. py:data:: suspend_process

.. py:data:: get_processes

.. py:data:: attach_process

.. py:data:: detach_process

.. py:data:: get_thread_qty

.. py:data:: getn_thread

.. py:data:: get_current_thread

.. py:data:: getn_thread_name

.. py:data:: select_thread

.. py:data:: suspend_thread

.. py:data:: resume_thread

.. py:function:: get_first_module()

   Enumerate process modules

   :returns: first module's base address or None on failure


.. py:function:: get_next_module(base)

   Enumerate process modules

   :param base: previous module's base address

   :returns: next module's base address or None on failure


.. py:function:: get_module_name(base)

   Get process module name

   :param base: the base address of the module

   :returns: required info or None


.. py:function:: get_module_size(base)

   Get process module size

   :param base: the base address of the module

   :returns: required info or -1


.. py:data:: step_into

.. py:data:: step_over

.. py:data:: run_to

.. py:data:: step_until_ret

.. py:data:: wait_for_next_event

.. py:function:: resume_process()

.. py:function:: send_dbg_command(cmd)

   Sends a command to the debugger module and returns the output string.
   An exception will be raised if the debugger is not running or the current debugger does not export
   the 'send_dbg_command' IDC command.


.. py:data:: WFNE_ANY
   :value: 1


.. py:data:: WFNE_SUSP
   :value: 2


.. py:data:: WFNE_SILENT
   :value: 4


.. py:data:: WFNE_CONT
   :value: 8


.. py:data:: WFNE_NOWAIT
   :value: 16


.. py:data:: NOTASK
   :value: -2


.. py:data:: DBG_ERROR
   :value: -1


.. py:data:: DBG_TIMEOUT
   :value: 0


.. py:data:: PROCESS_STARTED
   :value: 1


.. py:data:: PROCESS_EXITED
   :value: 2


.. py:data:: THREAD_STARTED
   :value: 4


.. py:data:: THREAD_EXITED
   :value: 8


.. py:data:: BREAKPOINT
   :value: 16


.. py:data:: STEP
   :value: 32


.. py:data:: EXCEPTION
   :value: 64


.. py:data:: LIB_LOADED
   :value: 128


.. py:data:: LIB_UNLOADED
   :value: 256


.. py:data:: INFORMATION
   :value: 512


.. py:data:: PROCESS_ATTACHED
   :value: 1024


.. py:data:: PROCESS_DETACHED
   :value: 2048


.. py:data:: PROCESS_SUSPENDED
   :value: 4096


.. py:data:: refresh_debugger_memory

.. py:data:: take_memory_snapshot

.. py:data:: get_process_state

.. py:data:: DSTATE_SUSP
   :value: -1


.. py:data:: DSTATE_NOTASK
   :value: 0


.. py:data:: DSTATE_RUN
   :value: 1


.. py:data:: DSTATE_RUN_WAIT_ATTACH
   :value: 2


.. py:data:: DSTATE_RUN_WAIT_END
   :value: 3


   Get various information about the current debug event
   These functions are valid only when the current event exists
   (the process is in the suspended state)


.. py:function:: get_event_id()

   Get ID of debug event

   :returns: event ID


.. py:function:: get_event_pid()

   Get process ID for debug event

   :returns: process ID


.. py:function:: get_event_tid()

   Get type ID for debug event

   :returns: type ID


.. py:function:: get_event_ea()

   Get ea for debug event

   :returns: ea


.. py:function:: is_event_handled()

   Is the debug event handled?

   :returns: boolean


.. py:function:: get_event_module_name()

   Get module name for debug event

   :returns: module name


.. py:function:: get_event_module_base()

   Get module base for debug event

   :returns: module base


.. py:function:: get_event_module_size()

   Get module size for debug event

   :returns: module size


.. py:function:: get_event_exit_code()

   Get exit code for debug event

   :returns: exit code for PROCESS_EXITED, THREAD_EXITED events


.. py:function:: get_event_info()

   Get debug event info

   :returns: event info: for THREAD_STARTED (thread name)
                        for LIB_UNLOADED (unloaded library name)
                        for INFORMATION (message to display)


.. py:function:: get_event_bpt_hea()

   Get hardware address for BREAKPOINT event

   :returns: hardware address


.. py:function:: get_event_exc_code()

   Get exception code for EXCEPTION event

   :returns: exception code


.. py:function:: get_event_exc_ea()

   Get address for EXCEPTION event

   :returns: adress of exception


.. py:function:: can_exc_continue()

   Can it continue after EXCEPTION event?

   :returns: boolean


.. py:function:: get_event_exc_info()

   Get info for EXCEPTION event

   :returns: info string


.. py:data:: set_debugger_options

.. py:data:: DOPT_SEGM_MSGS
   :value: 1


.. py:data:: DOPT_START_BPT
   :value: 2


.. py:data:: DOPT_THREAD_MSGS
   :value: 4


.. py:data:: DOPT_THREAD_BPT
   :value: 8


.. py:data:: DOPT_BPT_MSGS
   :value: 16


.. py:data:: DOPT_LIB_MSGS
   :value: 64


.. py:data:: DOPT_LIB_BPT
   :value: 128


.. py:data:: DOPT_INFO_MSGS
   :value: 256


.. py:data:: DOPT_INFO_BPT
   :value: 512


.. py:data:: DOPT_REAL_MEMORY
   :value: 1024


.. py:data:: DOPT_REDO_STACK
   :value: 2048


.. py:data:: DOPT_ENTRY_BPT
   :value: 4096


.. py:data:: DOPT_EXCDLG
   :value: 24576


.. py:data:: EXCDLG_NEVER
   :value: 0


.. py:data:: EXCDLG_UNKNOWN
   :value: 8192


.. py:data:: EXCDLG_ALWAYS
   :value: 24576


.. py:data:: DOPT_LOAD_DINFO
   :value: 32768


.. py:data:: get_debugger_event_cond

.. py:data:: set_debugger_event_cond

.. py:data:: set_remote_debugger

.. py:data:: define_exception

.. py:data:: EXC_BREAK
   :value: 1


.. py:data:: EXC_HANDLE
   :value: 2


.. py:data:: get_reg_value

.. py:function:: set_reg_value(value, name)

   Set register value

   :param name: the register name
   :param value: new register value

   NOTE: The debugger should be running
          It is not necessary to use this function to set register values.
          A register name in the left side of an assignment will do too.


.. py:data:: get_bpt_qty

.. py:function:: get_bpt_ea(n)

   Get breakpoint address

   :param n: number of breakpoint, is in range 0..get_bpt_qty()-1

   :returns: address of the breakpoint or BADADDR


.. py:function:: get_bpt_attr(ea, bptattr)

   Get the characteristics of a breakpoint

   :param ea: any address in the breakpoint range
   :param bptattr: the desired attribute code, one of BPTATTR_... constants

   :returns: the desired attribute value or -1


.. py:data:: BPTATTR_EA
   :value: 1


.. py:data:: BPTATTR_SIZE
   :value: 2


.. py:data:: BPTATTR_TYPE
   :value: 3


.. py:data:: BPT_WRITE
   :value: 1


.. py:data:: BPT_RDWR
   :value: 3


.. py:data:: BPT_SOFT
   :value: 4


.. py:data:: BPT_EXEC
   :value: 8


.. py:data:: BPT_DEFAULT
   :value: 12


.. py:data:: BPTATTR_COUNT
   :value: 4


.. py:data:: BPTATTR_FLAGS
   :value: 5


.. py:data:: BPT_BRK
   :value: 1


.. py:data:: BPT_TRACE
   :value: 2


.. py:data:: BPT_UPDMEM
   :value: 4


.. py:data:: BPT_ENABLED
   :value: 8


.. py:data:: BPT_LOWCND
   :value: 16


.. py:data:: BPT_TRACEON
   :value: 32


.. py:data:: BPT_TRACE_INSN
   :value: 64


.. py:data:: BPT_TRACE_FUNC
   :value: 128


.. py:data:: BPT_TRACE_BBLK
   :value: 256


.. py:data:: BPTATTR_COND
   :value: 6


.. py:data:: BPTATTR_PID
   :value: 7


.. py:data:: BPTATTR_TID
   :value: 8


.. py:data:: BPLT_ABS
   :value: 0


.. py:data:: BPLT_REL
   :value: 1


.. py:data:: BPLT_SYM
   :value: 2


.. py:function:: set_bpt_attr(address, bptattr, value)

       modifiable characteristics of a breakpoint

   :param address: any address in the breakpoint range
   :param bptattr: the attribute code, one of BPTATTR_* constants
                   BPTATTR_CND is not allowed, see set_bpt_cond()
   :param value: the attribute value

   :returns: success


.. py:function:: set_bpt_cond(ea, cnd, is_lowcnd=0)

   Set breakpoint condition

   :param ea: any address in the breakpoint range
   :param cnd: breakpoint condition
   :param is_lowcnd: 0 - regular condition, 1 - low level condition

   :returns: success


.. py:data:: add_bpt

.. py:data:: del_bpt

.. py:data:: enable_bpt

.. py:data:: check_bpt

.. py:data:: BPTCK_NONE
   :value: -1


.. py:data:: BPTCK_NO
   :value: 0


.. py:data:: BPTCK_YES
   :value: 1


.. py:data:: BPTCK_ACT
   :value: 2


.. py:function:: enable_tracing(trace_level, enable)

   Enable step tracing

   :param trace_level:  what kind of trace to modify
   :param enable: 0: turn off, 1: turn on

   :returns: success


.. py:data:: TRACE_STEP
   :value: 0


.. py:data:: TRACE_INSN
   :value: 1


.. py:data:: TRACE_FUNC
   :value: 2


.. py:data:: get_step_trace_options

.. py:data:: set_step_trace_options

.. py:data:: ST_OVER_DEBUG_SEG
   :value: 1


.. py:data:: ST_OVER_LIB_FUNC
   :value: 2


.. py:data:: ST_ALREADY_LOGGED
   :value: 4


.. py:data:: ST_SKIP_LOOPS
   :value: 8


.. py:data:: load_trace_file

.. py:data:: save_trace_file

.. py:data:: is_valid_trace_file

.. py:data:: diff_trace_file

.. py:function:: clear_trace(filename)

   Clear the current trace buffer


.. py:data:: get_trace_file_desc

.. py:data:: set_trace_file_desc

.. py:data:: get_tev_qty

.. py:data:: get_tev_ea

.. py:data:: TEV_NONE
   :value: 0


.. py:data:: TEV_INSN
   :value: 1


.. py:data:: TEV_CALL
   :value: 2


.. py:data:: TEV_RET
   :value: 3


.. py:data:: TEV_BPT
   :value: 4


.. py:data:: TEV_MEM
   :value: 5


.. py:data:: TEV_EVENT
   :value: 6


.. py:data:: get_tev_type

.. py:data:: get_tev_tid

.. py:data:: get_tev_reg

.. py:data:: get_tev_mem_qty

.. py:data:: get_tev_mem

.. py:data:: get_tev_mem_ea

.. py:data:: get_call_tev_callee

.. py:data:: get_ret_tev_return

.. py:data:: get_bpt_tev_ea

.. py:function:: get_color(ea, what)

   Get item color

   :param ea: address of the item
   :param what: type of the item (one of  CIC_* constants)

   :returns: color code in RGB (hex 0xBBGGRR)


.. py:data:: CIC_ITEM
   :value: 1


.. py:data:: CIC_FUNC
   :value: 2


.. py:data:: CIC_SEGM
   :value: 3


.. py:data:: DEFCOLOR
   :value: 4294967295


.. py:function:: set_color(ea, what, color)

   Set item color

   :param ea: address of the item
   :param what: type of the item (one of CIC_* constants)
   :param color: new color code in RGB (hex 0xBBGGRR)

   :returns: success (True or False)


.. py:function:: force_bl_jump(ea)

   Some ARM compilers in Thumb mode use BL (branch-and-link)
   instead of B (branch) for long jumps, since BL has more range.
   By default, IDA tries to determine if BL is a jump or a call.
   You can override IDA's decision using commands in Edit/Other menu
   (Force BL call/Force BL jump) or the following two functions.

   Force BL instruction to be a jump

   :param ea: address of the BL instruction

   :returns: 1-ok, 0-failed


.. py:function:: force_bl_call(ea)

   Force BL instruction to be a call

   :param ea: address of the BL instruction

   :returns: 1-ok, 0-failed


.. py:function:: set_flag(off, bit, value)

.. py:function:: here()

.. py:function:: is_mapped(ea)

.. py:data:: ARGV
   :value: []


   The command line arguments passed to IDA via the -S switch.



```

`skills/idapython/docs/init.md`:

```md
# init

IDAPython initialization and execution environment module.

## Key Classes/Functions

### IDAPythonStdOut
Dummy file-like class that receives stdout and stderr
- `write(text)` - writes text to IDA's output window
- `flush()` - flush output
- `isatty()` - returns False (not a TTY)

### runscript(script)
Executes a script file (deprecated, use `idaapi.IDAPython_ExecScript()` instead)
- `script` - path to script file
- Returns error string or None on success

### print_banner()
Prints IDAPython banner to output window

## Attributes
- `base` - Python installation base path
- `IDAPYTHON_DYNLOAD_BASE` - dynamic load base directory
- `help` - IDAPython help instance
- `userrc` - user RC file path

## See Also
Full docs: skill/docs/init.rst

```

`skills/idapython/docs/init.rst`:

```rst
init
====

.. py:module:: init


Attributes
----------

.. autoapisummary::

   init.base
   init.IDAPYTHON_DYNLOAD_BASE
   init.lib_dynload
   init.all_mods
   init.help
   init.idausr_python_list
   init.userrc


Classes
-------

.. autoapisummary::

   init.IDAPythonStdOut
   init.IDAPythonHelpPrompter
   init.IDAPythonHelp


Functions
---------

.. autoapisummary::

   init.runscript
   init.print_banner


Module Contents
---------------

.. py:data:: base
   :value: '/opt/homebrew/opt/python@3.13/Frameworks/Python.framework/Versions/3.13'


.. py:data:: IDAPYTHON_DYNLOAD_BASE
   :value: b'.'


.. py:data:: lib_dynload

.. py:data:: all_mods
   :value: 'idaapi,hexrays,allins,auto,bitrange,bytes,dbg,diskio,dirtree,entry,expr,fixup,fpro,frame,funcs,g...


.. py:class:: IDAPythonStdOut

   Dummy file-like class that receives stdout and stderr


   .. py:attribute:: encoding
      :value: 'UTF-8'



   .. py:method:: write(text)


   .. py:method:: flush()


   .. py:method:: isatty()


.. py:function:: runscript(script)

   Executes a script.
   This function is present for backward compatiblity. Please use idaapi.IDAPython_ExecScript() instead

   :param script: script path

   :returns: Error string or None on success


.. py:function:: print_banner()

.. py:class:: IDAPythonHelpPrompter

   Bases: :py:obj:`object`


   .. py:method:: readline()


.. py:class:: IDAPythonHelp

   Bases: :py:obj:`pydoc.Helper`


   .. py:method:: help(*args)


.. py:data:: help

.. py:data:: idausr_python_list

.. py:data:: userrc


```

`src/ida_pro_mcp/__main__.py`:

```py
import sys
from ida_pro_mcp.server import main

if __name__ == "__main__":
    sys.argv[0] = "ida_pro_mcp"
    main()

```

`src/ida_pro_mcp/ida_mcp.py`:

```py
"""IDA Pro MCP Plugin Loader

This file serves as the entry point for IDA Pro's plugin system.
It loads the actual implementation from the ida_mcp package.
"""

import sys
import idaapi
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from . import ida_mcp


def unload_package(package_name: str):
    """Remove every module that belongs to the package from sys.modules."""
    to_remove = [
        mod_name
        for mod_name in sys.modules
        if mod_name == package_name or mod_name.startswith(package_name + ".")
    ]
    for mod_name in to_remove:
        del sys.modules[mod_name]


class MCP(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = "MCP Plugin"
    help = "MCP"
    wanted_name = "MCP"
    wanted_hotkey = "Ctrl-Alt-M"

    # TODO: make these configurable
    HOST = "127.0.0.1"
    PORT = 13337

    def init(self):
        hotkey = MCP.wanted_hotkey.replace("-", "+")
        if __import__("sys").platform == "darwin":
            hotkey = hotkey.replace("Alt", "Option")

        print(
            f"[MCP] Plugin loaded, use Edit -> Plugins -> MCP ({hotkey}) to start the server"
        )
        self.mcp: "ida_mcp.rpc.McpServer | None" = None
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        if self.mcp:
            self.mcp.stop()
            self.mcp = None

        # HACK: ensure fresh load of ida_mcp package
        unload_package("ida_mcp")
        if TYPE_CHECKING:
            from .ida_mcp import MCP_SERVER, IdaMcpHttpRequestHandler, init_caches
        else:
            from ida_mcp import MCP_SERVER, IdaMcpHttpRequestHandler, init_caches

        try:
            init_caches()
        except Exception as e:
            print(f"[MCP] Cache init failed: {e}")

        try:
            MCP_SERVER.serve(
                self.HOST, self.PORT, request_handler=IdaMcpHttpRequestHandler
            )
            print(f"  Config: http://{self.HOST}:{self.PORT}/config.html")
            self.mcp = MCP_SERVER
        except OSError as e:
            if e.errno in (48, 98, 10048):  # Address already in use
                print(f"[MCP] Error: Port {self.PORT} is already in use")
            else:
                raise

    def term(self):
        if self.mcp:
            self.mcp.stop()


def PLUGIN_ENTRY():
    return MCP()


# IDA plugin flags
PLUGIN_FLAGS = idaapi.PLUGIN_HIDE | idaapi.PLUGIN_FIX

```

`src/ida_pro_mcp/ida_mcp/__init__.py`:

```py
"""IDA Pro MCP Plugin - Modular Package Version

This package provides MCP (Model Context Protocol) integration for IDA Pro,
enabling AI assistants to interact with IDA's disassembler and decompiler.

Architecture:
- rpc.py: JSON-RPC infrastructure and registry
- mcp.py: MCP protocol server (HTTP/SSE)
- sync.py: IDA synchronization decorator (@idasync)
- utils.py: Shared helpers and TypedDict definitions
- api_*.py: Modular API implementations (71 tools + 24 resources)
"""

# Import infrastructure modules
from . import rpc
from . import sync
from . import utils

# Import all API modules to register @tool functions and @resource functions
from . import api_core
from . import api_analysis
from . import api_memory
from . import api_types
from . import api_modify
from . import api_stack
from . import api_debug
from . import api_python
from . import api_resources

# Re-export key components for external use
from .sync import idasync, IDAError, IDASyncError, CancelledError
from .rpc import MCP_SERVER, MCP_UNSAFE, tool, unsafe, resource
from .http import IdaMcpHttpRequestHandler
from .api_core import init_caches

__all__ = [
    # Infrastructure modules
    "rpc",
    "sync",
    "utils",
    # API modules
    "api_core",
    "api_analysis",
    "api_memory",
    "api_types",
    "api_modify",
    "api_stack",
    "api_debug",
    "api_python",
    "api_resources",
    # Re-exported components
    "idasync",
    "IDAError",
    "IDASyncError",
    "CancelledError",
    "MCP_SERVER",
    "MCP_UNSAFE",
    "tool",
    "unsafe",
    "resource",
    "IdaMcpHttpRequestHandler",
    "init_caches",
]

```

`src/ida_pro_mcp/ida_mcp/api_analysis.py`:

```py
from itertools import islice
import struct
from typing import Annotated, Optional
import ida_lines
import ida_funcs
import idaapi
import idautils
import ida_typeinf
import ida_nalt
import ida_bytes
import ida_ida
import ida_idaapi
import ida_xref
import ida_ua
import ida_name
from .rpc import tool
from .sync import idasync, tool_timeout
from .utils import (
    parse_address,
    normalize_list_input,
    get_function,
    get_prototype,
    get_stack_frame_variables_internal,
    decompile_function_safe,
    get_assembly_lines,
    get_all_xrefs,
    get_all_comments,
    Function,
    Argument,
    DisassemblyFunction,
    Xref,
    BasicBlock,
    StructFieldQuery,
    InsnPattern,
)

# ============================================================================
# Instruction Helpers
# ============================================================================

_IMM_SCAN_BACK_MAX = 15


def _raw_bin_search(
    ea: int, max_ea: int, data: bytes, mask: bytes, flags: int = 0
) -> int:
    """Search for raw bytes with mask, compatible across IDA versions.

    Returns the match address, or idaapi.BADADDR if not found.
    """
    if hasattr(ida_bytes, "find_bytes"):
        # IDA 9.0+: high-level API accepting bytes + mask directly
        search_flags = flags or (
            ida_bytes.BIN_SEARCH_FORWARD | ida_bytes.BIN_SEARCH_NOSHOW
        )
        return ida_bytes.find_bytes(
            data, ea, range_end=max_ea, mask=mask, flags=search_flags
        )
    if hasattr(ida_bytes, "bin_search"):
        # Older IDA: low-level 6-param API
        search_flags = flags or (
            ida_bytes.BIN_SEARCH_FORWARD | ida_bytes.BIN_SEARCH_NOSHOW
        )
        return ida_bytes.bin_search(ea, max_ea, data, mask, len(data), search_flags)
    raise RuntimeError(
        "No binary search API available (tried ida_bytes.find_bytes, ida_bytes.bin_search)"
    )


def _decode_insn_at(ea: int) -> ida_ua.insn_t | None:
    insn = ida_ua.insn_t()
    if ida_ua.decode_insn(insn, ea) == 0:
        return None
    return insn


def _next_head(ea: int, end_ea: int) -> int:
    return ida_bytes.next_head(ea, end_ea)


def _operand_value(insn: ida_ua.insn_t, i: int) -> int | None:
    op = insn.ops[i]
    if op.type == ida_ua.o_void:
        return None
    if op.type in (ida_ua.o_mem, ida_ua.o_far, ida_ua.o_near):
        return op.addr
    return op.value


def _operand_type(insn: ida_ua.insn_t, i: int) -> int:
    return insn.ops[i].type


def _insn_mnem(insn: ida_ua.insn_t) -> str:
    try:
        return insn.get_canon_mnem().lower()
    except Exception:
        return ""


def _value_to_le_bytes(value: int) -> tuple[bytes, int, int] | None:
    if value < 0:
        if value >= -0x80000000:
            size = 4
            value &= 0xFFFFFFFF
        elif value >= -0x8000000000000000:
            size = 8
            value &= 0xFFFFFFFFFFFFFFFF
        else:
            return None
    else:
        if value <= 0xFFFFFFFF:
            size = 4
        elif value <= 0xFFFFFFFFFFFFFFFF:
            size = 8
        else:
            return None

    fmt = "<I" if size == 4 else "<Q"
    return struct.pack(fmt, value), size, value


def _value_candidates_for_immediate(value: int) -> list[tuple[int, int, bytes]]:
    candidates: list[tuple[int, int, bytes]] = []

    def add(size: int, signed_val: int):
        if size == 4:
            masked = signed_val & 0xFFFFFFFF
            if not (-0x80000000 <= signed_val <= 0x7FFFFFFF):
                return
            b = struct.pack("<I", masked)
        else:
            masked = signed_val & 0xFFFFFFFFFFFFFFFF
            if not (-0x8000000000000000 <= signed_val <= 0x7FFFFFFFFFFFFFFF):
                return
            b = struct.pack("<Q", masked)
        candidates.append((masked, size, b))

    add(4, value)
    add(8, value)
    return candidates


def _resolve_immediate_insn_start(
    match_ea: int,
    value: int,
    seg_start: int,
    alt_value: int | None = None,
) -> int | None:
    start_min = max(seg_start, match_ea - _IMM_SCAN_BACK_MAX)
    for start in range(match_ea, start_min - 1, -1):
        insn = _decode_insn_at(start)
        if insn is None:
            continue
        end_ea = start + insn.size
        if not (start <= match_ea < end_ea):
            continue
        for i in range(8):
            op_type = _operand_type(insn, i)
            if op_type == ida_ua.o_void:
                break
            if op_type != ida_ua.o_imm:
                continue
            op_val = _operand_value(insn, i)
            if op_val is None:
                continue
            if op_val == value or (alt_value is not None and op_val == alt_value):
                offb = getattr(insn.ops[i], "offb", 0)
                if offb and start + offb != match_ea:
                    continue
                return start
    return None


# ============================================================================
# Code Analysis & Decompilation
# ============================================================================


@tool
@idasync
@tool_timeout(90.0)
def decompile(
    addr: Annotated[str, "Function address to decompile"],
) -> dict:
    """Decompile function to pseudocode"""
    try:
        start = parse_address(addr)
        code = decompile_function_safe(start)
        if code is None:
            return {"addr": addr, "code": None, "error": "Decompilation failed"}
        return {"addr": addr, "code": code}
    except Exception as e:
        return {"addr": addr, "code": None, "error": str(e)}


@tool
@idasync
@tool_timeout(90.0)
def disasm(
    addr: Annotated[str, "Function address to disassemble"],
    max_instructions: Annotated[
        int, "Max instructions per function (default: 5000, max: 50000)"
    ] = 5000,
    offset: Annotated[int, "Skip first N instructions (default: 0)"] = 0,
    include_total: Annotated[
        bool, "Compute total instruction count (default: false)"
    ] = False,
) -> dict:
    """Disassemble function to assembly instructions"""

    # Enforce max limit
    if max_instructions <= 0 or max_instructions > 50000:
        max_instructions = 50000
    if offset < 0:
        offset = 0

    try:
        start = parse_address(addr)
        func = idaapi.get_func(start)

        # Get segment info
        seg = idaapi.getseg(start)
        if not seg:
            return {
                "addr": addr,
                "asm": None,
                "error": "No segment found",
                "cursor": {"done": True},
            }

        segment_name = idaapi.get_segm_name(seg) if seg else "UNKNOWN"

        if func:
            # Function exists: disassemble function items starting from requested address
            func_name: str = ida_funcs.get_func_name(func.start_ea) or "<unnamed>"
            header_addr = start  # Use requested address, not function start
        else:
            # No function: disassemble sequentially from start address
            func_name = "<no function>"
            header_addr = start

        lines = []
        seen = 0
        total_count = 0
        more = False

        def _maybe_add(ea: int) -> bool:
            nonlocal seen, total_count, more
            if include_total:
                total_count += 1
            if seen < offset:
                seen += 1
                return True
            if len(lines) < max_instructions:
                line = ida_lines.generate_disasm_line(ea, 0)
                instruction = ida_lines.tag_remove(line) if line else ""
                lines.append(f"{ea:x}  {instruction}")
                seen += 1
                return True
            more = True
            seen += 1
            return include_total

        if func:
            for ea in idautils.FuncItems(func.start_ea):
                if ea == idaapi.BADADDR:
                    continue
                if ea < start:
                    continue
                if not _maybe_add(ea):
                    break
        else:
            ea = start
            while ea < seg.end_ea:
                if ea == idaapi.BADADDR:
                    break
                if _decode_insn_at(ea) is None:
                    break
                if not _maybe_add(ea):
                    break
                ea = _next_head(ea, seg.end_ea)
                if ea == idaapi.BADADDR:
                    break

        if include_total and not more:
            more = total_count > offset + max_instructions

        lines_str = f"{func_name} ({segment_name} @ {hex(header_addr)}):"
        if lines:
            lines_str += "\n" + "\n".join(lines)

        rettype = None
        args: Optional[list[Argument]] = None
        stack_frame = None

        if func:
            tif = ida_typeinf.tinfo_t()
            if ida_nalt.get_tinfo(tif, func.start_ea) and tif.is_func():
                ftd = ida_typeinf.func_type_data_t()
                if tif.get_func_details(ftd):
                    rettype = str(ftd.rettype)
                    args = [
                        Argument(name=(a.name or f"arg{i}"), type=str(a.type))
                        for i, a in enumerate(ftd)
                    ]
            stack_frame = get_stack_frame_variables_internal(func.start_ea, False)

        out: DisassemblyFunction = {
            "name": func_name,
            "start_ea": hex(header_addr),
            "lines": lines_str,
        }
        if stack_frame:
            out["stack_frame"] = stack_frame
        if rettype:
            out["return_type"] = rettype
        if args is not None:
            out["arguments"] = args

        return {
            "addr": addr,
            "asm": out,
            "instruction_count": len(lines),
            "total_instructions": total_count if include_total else None,
            "cursor": ({"next": offset + max_instructions} if more else {"done": True}),
        }
    except Exception as e:
        return {
            "addr": addr,
            "asm": None,
            "error": str(e),
            "cursor": {"done": True},
        }


# ============================================================================
# Cross-Reference Analysis
# ============================================================================


@tool
@idasync
def xrefs_to(
    addrs: Annotated[list[str] | str, "Addresses to find cross-references to"],
    limit: Annotated[int, "Max xrefs per address (default: 100, max: 1000)"] = 100,
) -> list[dict]:
    """Get cross-references to specified addresses"""
    addrs = normalize_list_input(addrs)

    if limit <= 0 or limit > 1000:
        limit = 1000

    results = []

    for addr in addrs:
        try:
            xrefs = []
            more = False
            for xref in idautils.XrefsTo(parse_address(addr)):
                if len(xrefs) >= limit:
                    more = True
                    break
                xrefs.append(
                    Xref(
                        addr=hex(xref.frm),
                        type="code" if xref.iscode else "data",
                        fn=get_function(xref.frm, raise_error=False),
                    )
                )
            results.append({"addr": addr, "xrefs": xrefs, "more": more})
        except Exception as e:
            results.append({"addr": addr, "xrefs": None, "error": str(e)})

    return results


@tool
@idasync
def xrefs_to_field(queries: list[StructFieldQuery] | StructFieldQuery) -> list[dict]:
    """Get cross-references to structure fields"""
    if isinstance(queries, dict):
        queries = [queries]

    results = []
    til = ida_typeinf.get_idati()
    if not til:
        return [
            {
                "struct": q.get("struct"),
                "field": q.get("field"),
                "xrefs": [],
                "error": "Failed to retrieve type library",
            }
            for q in queries
        ]

    for query in queries:
        struct_name = query.get("struct", "")
        field_name = query.get("field", "")

        try:
            tif = ida_typeinf.tinfo_t()
            if not tif.get_named_type(
                til, struct_name, ida_typeinf.BTF_STRUCT, True, False
            ):
                results.append(
                    {
                        "struct": struct_name,
                        "field": field_name,
                        "xrefs": [],
                        "error": f"Struct '{struct_name}' not found",
                    }
                )
                continue

            idx = ida_typeinf.get_udm_by_fullname(None, struct_name + "." + field_name)
            if idx == -1:
                results.append(
                    {
                        "struct": struct_name,
                        "field": field_name,
                        "xrefs": [],
                        "error": f"Field '{field_name}' not found in '{struct_name}'",
                    }
                )
                continue

            tid = tif.get_udm_tid(idx)
            if tid == ida_idaapi.BADADDR:
                results.append(
                    {
                        "struct": struct_name,
                        "field": field_name,
                        "xrefs": [],
                        "error": "Unable to get tid",
                    }
                )
                continue

            xrefs = []
            xref: ida_xref.xrefblk_t
            for xref in idautils.XrefsTo(tid):
                xrefs += [
                    Xref(
                        addr=hex(xref.frm),
                        type="code" if xref.iscode else "data",
                        fn=get_function(xref.frm, raise_error=False),
                    )
                ]
            results.append({"struct": struct_name, "field": field_name, "xrefs": xrefs})
        except Exception as e:
            results.append(
                {
                    "struct": struct_name,
                    "field": field_name,
                    "xrefs": [],
                    "error": str(e),
                }
            )

    return results


# ============================================================================
# Call Graph Analysis
# ============================================================================


@tool
@idasync
def callees(
    addrs: Annotated[list[str] | str, "Function addresses to get callees for"],
    limit: Annotated[int, "Max callees per function (default: 200, max: 500)"] = 200,
) -> list[dict]:
    """Get functions called by the specified functions"""
    addrs = normalize_list_input(addrs)

    if limit <= 0 or limit > 500:
        limit = 500

    results = []

    for fn_addr in addrs:
        try:
            func_start = parse_address(fn_addr)
            func = idaapi.get_func(func_start)
            if not func:
                results.append(
                    {"addr": fn_addr, "callees": None, "error": "No function found"}
                )
                continue
            func_end = func.end_ea
            callees_dict = {}
            more = False
            current_ea = func_start
            while current_ea < func_end:
                if len(callees_dict) >= limit:
                    more = True
                    break
                insn = _decode_insn_at(current_ea)
                if insn is None:
                    next_ea = _next_head(current_ea, func_end)
                    if next_ea == idaapi.BADADDR:
                        break
                    current_ea = next_ea
                    continue
                if insn.itype in [idaapi.NN_call, idaapi.NN_callfi, idaapi.NN_callni]:
                    op0 = insn.ops[0]
                    if op0.type in (ida_ua.o_mem, ida_ua.o_near, ida_ua.o_far):
                        target = op0.addr
                    elif op0.type == ida_ua.o_imm:
                        target = op0.value
                    else:
                        target = None
                    if target is not None and target not in callees_dict:
                        func_type = (
                            "internal"
                            if idaapi.get_func(target) is not None
                            else "external"
                        )
                        func_name = ida_name.get_name(target)
                        if func_name is not None:
                            callees_dict[target] = {
                                "addr": hex(target),
                                "name": func_name,
                                "type": func_type,
                            }
                next_ea = _next_head(current_ea, func_end)
                if next_ea == idaapi.BADADDR:
                    break
                current_ea = next_ea

            results.append(
                {
                    "addr": fn_addr,
                    "callees": list(callees_dict.values()),
                    "more": more,
                }
            )
        except Exception as e:
            results.append({"addr": fn_addr, "callees": None, "error": str(e)})

    return results


# ============================================================================
# Pattern Matching & Signature Tools
# ============================================================================


@tool
@idasync
def find_bytes(
    patterns: Annotated[
        list[str] | str, "Byte patterns to search for (e.g. '48 8B ?? ??')"
    ],
    limit: Annotated[int, "Max matches per pattern (default: 1000, max: 10000)"] = 1000,
    offset: Annotated[int, "Skip first N matches (default: 0)"] = 0,
) -> list[dict]:
    """Search for byte patterns in the binary (supports wildcards with ??)"""
    patterns = normalize_list_input(patterns)

    # Enforce max limit
    if limit <= 0 or limit > 10000:
        limit = 10000

    # Build a reusable search closure based on available IDA API
    _use_find_bytes = hasattr(ida_bytes, "find_bytes")
    _use_bin_search = hasattr(ida_bytes, "bin_search")

    def _make_searcher(pattern: str):
        """Return a (searcher_fn, error_str|None) for the given pattern.

        searcher_fn(ea, max_ea) -> ea_t  (BADADDR if not found)
        """
        tokens = pattern.strip().split()
        if not tokens:
            return None, "Empty pattern"

        if _use_find_bytes:
            # IDA 9.0+ high-level API: accepts pattern string directly.
            # Normalize "??" to "?" (IDA uses single ? per wildcard byte).
            normalized = " ".join("?" if t in ("??", "?") else t for t in tokens)

            def _search(ea, max_ea):
                return ida_bytes.find_bytes(normalized, ea, range_end=max_ea)

            return _search, None

        if _use_bin_search:
            # Older IDA: manual parse into bytes + mask
            pat = bytearray()
            msk = bytearray()
            for t in tokens:
                if t in ("??", "?"):
                    pat.append(0)
                    msk.append(0)
                else:
                    pat.append(int(t, 16))
                    msk.append(0xFF)
            data = bytes(pat)
            mask = bytes(msk)
            flags = ida_bytes.BIN_SEARCH_FORWARD | ida_bytes.BIN_SEARCH_NOSHOW

            def _search(ea, max_ea):
                return ida_bytes.bin_search(ea, max_ea, data, mask, len(data), flags)

            return _search, None

        return (
            None,
            "No binary search API available (tried ida_bytes.find_bytes, ida_bytes.bin_search)",
        )

    results = []
    for pattern in patterns:
        matches = []
        skipped = 0
        more = False
        try:
            searcher, build_err = _make_searcher(pattern)
            if build_err is not None:
                results.append(
                    {
                        "pattern": pattern,
                        "matches": [],
                        "n": 0,
                        "cursor": {"done": True},
                        "error": build_err,
                    }
                )
                continue

            # Search with early exit
            ea = ida_ida.inf_get_min_ea()
            max_ea = ida_ida.inf_get_max_ea()
            while ea != idaapi.BADADDR:
                ea = searcher(ea, max_ea)
                if ea == idaapi.BADADDR:
                    break
                if skipped < offset:
                    skipped += 1
                else:
                    matches.append(hex(ea))
                    if len(matches) >= limit:
                        # Check if there's more
                        next_ea = searcher(ea + 1, max_ea)
                        more = next_ea != idaapi.BADADDR
                        break
                ea += 1
        except Exception as e:
            results.append(
                {
                    "pattern": pattern,
                    "matches": [],
                    "n": 0,
                    "cursor": {"done": True},
                    "error": str(e),
                }
            )
            continue

        results.append(
            {
                "pattern": pattern,
                "matches": matches,
                "n": len(matches),
                "cursor": {"next": offset + limit} if more else {"done": True},
            }
        )
    return results


# ============================================================================
# Control Flow Analysis
# ============================================================================


@tool
@idasync
def basic_blocks(
    addrs: Annotated[list[str] | str, "Function addresses to get basic blocks for"],
    max_blocks: Annotated[
        int, "Max basic blocks per function (default: 1000, max: 10000)"
    ] = 1000,
    offset: Annotated[int, "Skip first N blocks (default: 0)"] = 0,
) -> list[dict]:
    """Get control flow graph basic blocks for functions"""
    addrs = normalize_list_input(addrs)

    # Enforce max limit
    if max_blocks <= 0 or max_blocks > 10000:
        max_blocks = 10000

    results = []
    for fn_addr in addrs:
        try:
            ea = parse_address(fn_addr)
            func = idaapi.get_func(ea)
            if not func:
                results.append(
                    {
                        "addr": fn_addr,
                        "error": "Function not found",
                        "blocks": [],
                        "cursor": {"done": True},
                    }
                )
                continue

            flowchart = idaapi.FlowChart(func)
            all_blocks = []

            for block in flowchart:
                all_blocks.append(
                    BasicBlock(
                        start=hex(block.start_ea),
                        end=hex(block.end_ea),
                        size=block.end_ea - block.start_ea,
                        type=block.type,
                        successors=[hex(succ.start_ea) for succ in block.succs()],
                        predecessors=[hex(pred.start_ea) for pred in block.preds()],
                    )
                )

            # Apply pagination
            total_blocks = len(all_blocks)
            blocks = all_blocks[offset : offset + max_blocks]
            more = offset + max_blocks < total_blocks

            results.append(
                {
                    "addr": fn_addr,
                    "blocks": blocks,
                    "count": len(blocks),
                    "total_blocks": total_blocks,
                    "cursor": (
                        {"next": offset + max_blocks} if more else {"done": True}
                    ),
                    "error": None,
                }
            )
        except Exception as e:
            results.append(
                {
                    "addr": fn_addr,
                    "error": str(e),
                    "blocks": [],
                    "cursor": {"done": True},
                }
            )
    return results


# ============================================================================
# Search Operations
# ============================================================================


@tool
@idasync
def find(
    type: Annotated[
        str, "Search type: 'string', 'immediate', 'data_ref', or 'code_ref'"
    ],
    targets: Annotated[
        list[str | int] | str | int, "Search targets (strings, integers, or addresses)"
    ],
    limit: Annotated[int, "Max matches per target (default: 1000, max: 10000)"] = 1000,
    offset: Annotated[int, "Skip first N matches (default: 0)"] = 0,
) -> list[dict]:
    """Search for patterns in the binary (strings, immediate values, or references)"""
    if not isinstance(targets, list):
        targets = [targets]

    # Enforce max limit to prevent token overflow
    if limit <= 0 or limit > 10000:
        limit = 10000

    results = []

    if type == "string":
        # Raw byte search for UTF-8 substrings across the binary
        for pattern in targets:
            pattern_str = str(pattern)
            pattern_bytes = pattern_str.encode("utf-8")
            if not pattern_bytes:
                results.append(
                    {
                        "query": pattern_str,
                        "matches": [],
                        "count": 0,
                        "cursor": {"done": True},
                        "error": "Empty pattern",
                    }
                )
                continue

            matches = []
            skipped = 0
            more = False
            try:
                ea = ida_ida.inf_get_min_ea()
                max_ea = ida_ida.inf_get_max_ea()
                mask = b"\xff" * len(pattern_bytes)
                while ea != idaapi.BADADDR:
                    ea = _raw_bin_search(ea, max_ea, pattern_bytes, mask)
                    if ea != idaapi.BADADDR:
                        if skipped < offset:
                            skipped += 1
                        else:
                            matches.append(hex(ea))
                            if len(matches) >= limit:
                                next_ea = _raw_bin_search(
                                    ea + 1, max_ea, pattern_bytes, mask
                                )
                                more = next_ea != idaapi.BADADDR
                                break
                        ea += 1
            except Exception:
                pass

            results.append(
                {
                    "query": pattern_str,
                    "matches": matches,
                    "count": len(matches),
                    "cursor": {"next": offset + limit} if more else {"done": True},
                    "error": None,
                }
            )

    elif type == "immediate":
        # Search for immediate values
        for value in targets:
            if isinstance(value, str):
                try:
                    value = int(value, 0)
                except ValueError:
                    value = 0

            matches = []
            skipped = 0
            more = False
            try:
                candidates = _value_candidates_for_immediate(value)
                if not candidates:
                    results.append(
                        {
                            "query": value,
                            "matches": [],
                            "count": 0,
                            "cursor": {"done": True},
                            "error": "Immediate out of range",
                        }
                    )
                    continue

                seen_insn = set()
                for seg_ea in idautils.Segments():
                    seg = idaapi.getseg(seg_ea)
                    if not seg or not (seg.perm & idaapi.SEGPERM_EXEC):
                        continue
                    for normalized, size, pattern_bytes in candidates:
                        ea = seg.start_ea
                        while ea != idaapi.BADADDR and ea < seg.end_ea:
                            ea = _raw_bin_search(
                                ea, seg.end_ea, pattern_bytes, b"\xff" * size
                            )
                            if ea == idaapi.BADADDR:
                                break

                            insn_start = _resolve_immediate_insn_start(
                                ea, value, seg.start_ea, normalized
                            )
                            if insn_start is not None and insn_start not in seen_insn:
                                seen_insn.add(insn_start)
                                if skipped < offset:
                                    skipped += 1
                                else:
                                    matches.append(hex(insn_start))
                                    if len(matches) >= limit:
                                        more = True
                                        break

                            ea += 1

                        if more:
                            break
                    if more:
                        break
            except Exception:
                pass

            results.append(
                {
                    "query": value,
                    "matches": matches,
                    "count": len(matches),
                    "cursor": {"next": offset + limit} if more else {"done": True},
                    "error": None,
                }
            )

    elif type == "data_ref":
        # Find all data references to targets
        for target_str in targets:
            try:
                target = parse_address(str(target_str))
                gen = (hex(xref) for xref in idautils.DataRefsTo(target))
                # Skip offset items, take limit+1 to check more
                matches = list(islice(islice(gen, offset, None), limit + 1))
                more = len(matches) > limit
                if more:
                    matches = matches[:limit]

                results.append(
                    {
                        "query": str(target_str),
                        "matches": matches,
                        "count": len(matches),
                        "cursor": (
                            {"next": offset + limit} if more else {"done": True}
                        ),
                        "error": None,
                    }
                )
            except Exception as e:
                results.append(
                    {
                        "query": str(target_str),
                        "matches": [],
                        "count": 0,
                        "cursor": {"done": True},
                        "error": str(e),
                    }
                )

    elif type == "code_ref":
        # Find all code references to targets
        for target_str in targets:
            try:
                target = parse_address(str(target_str))
                gen = (hex(xref) for xref in idautils.CodeRefsTo(target, 0))
                # Skip offset items, take limit+1 to check more
                matches = list(islice(islice(gen, offset, None), limit + 1))
                more = len(matches) > limit
                if more:
                    matches = matches[:limit]

                results.append(
                    {
                        "query": str(target_str),
                        "matches": matches,
                        "count": len(matches),
                        "cursor": (
                            {"next": offset + limit} if more else {"done": True}
                        ),
                        "error": None,
                    }
                )
            except Exception as e:
                results.append(
                    {
                        "query": str(target_str),
                        "matches": [],
                        "count": 0,
                        "cursor": {"done": True},
                        "error": str(e),
                    }
                )

    else:
        results.append(
            {
                "query": None,
                "matches": [],
                "count": 0,
                "cursor": {"done": True},
                "error": f"Unknown search type: {type}",
            }
        )

    return results


def _resolve_insn_scan_ranges(
    pattern: dict, allow_broad: bool
) -> tuple[list[tuple[int, int]], str | None]:
    func_addr = pattern.get("func")
    segment_name = pattern.get("segment")
    start_s = pattern.get("start")
    end_s = pattern.get("end")

    exec_segments = []
    for seg_ea in idautils.Segments():
        seg = idaapi.getseg(seg_ea)
        if seg and (seg.perm & idaapi.SEGPERM_EXEC):
            exec_segments.append(seg)

    if func_addr is not None:
        try:
            ea = parse_address(func_addr)
            func = idaapi.get_func(ea)
            if not func:
                return [], f"Function not found at {func_addr}"
            return [(func.start_ea, func.end_ea)], None
        except Exception as e:
            return [], str(e)

    if segment_name is not None:
        for seg in exec_segments:
            if idaapi.get_segm_name(seg) == segment_name:
                return [(seg.start_ea, seg.end_ea)], None
        return [], f"Executable segment not found: {segment_name}"

    if start_s is not None or end_s is not None:
        if start_s is None:
            return [], "start is required when end is set"
        try:
            start_ea = parse_address(start_s)
            end_ea = parse_address(end_s) if end_s is not None else None
        except Exception as e:
            return [], str(e)

        if not exec_segments:
            return [], "No executable segments found"

        if end_ea is None:
            seg = idaapi.getseg(start_ea)
            if not seg or not (seg.perm & idaapi.SEGPERM_EXEC):
                return [], "start address not in executable segment"
            end_ea = seg.end_ea

        if end_ea <= start_ea:
            return [], "end must be greater than start"

        ranges = []
        for seg in exec_segments:
            seg_start = max(seg.start_ea, start_ea)
            seg_end = min(seg.end_ea, end_ea)
            if seg_end > seg_start:
                ranges.append((seg_start, seg_end))

        if not ranges:
            return [], "No executable ranges within start/end"

        return ranges, None

    if not allow_broad:
        return [], "Scope required: set func/segment/start/end or allow_broad=true"

    if not exec_segments:
        return [], "No executable segments found"

    return [(seg.start_ea, seg.end_ea) for seg in exec_segments], None


def _scan_insn_ranges(
    ranges: list[tuple[int, int]],
    mnem: str,
    op0_val: int | None,
    op1_val: int | None,
    op2_val: int | None,
    any_val: int | None,
    limit: int,
    offset: int,
    max_scan_insns: int,
) -> tuple[list[str], bool, int, bool, int | None]:
    matches: list[str] = []
    skipped = 0
    scanned = 0
    more = False
    truncated = False
    next_start: int | None = None

    for start_ea, end_ea in ranges:
        ea = start_ea
        while ea < end_ea:
            if scanned >= max_scan_insns:
                truncated = True
                next_start = ea
                break

            scanned += 1

            insn = _decode_insn_at(ea)
            if insn is None:
                ea = _next_head(ea, end_ea)
                if ea == idaapi.BADADDR:
                    break
                continue

            if mnem and _insn_mnem(insn) != mnem:
                ea = _next_head(ea, end_ea)
                if ea == idaapi.BADADDR:
                    break
                continue

            match = True
            if op0_val is not None and _operand_value(insn, 0) != op0_val:
                match = False
            if op1_val is not None and _operand_value(insn, 1) != op1_val:
                match = False
            if op2_val is not None and _operand_value(insn, 2) != op2_val:
                match = False

            if any_val is not None and match:
                found_any = False
                for i in range(8):
                    if _operand_type(insn, i) == ida_ua.o_void:
                        break
                    if _operand_value(insn, i) == any_val:
                        found_any = True
                        break
                if not found_any:
                    match = False

            if match:
                if skipped < offset:
                    skipped += 1
                else:
                    matches.append(hex(ea))
                    if len(matches) > limit:
                        more = True
                        matches = matches[:limit]
                        break

            ea = _next_head(ea, end_ea)
            if ea == idaapi.BADADDR:
                break

        if more or truncated:
            break

    return matches, more, scanned, truncated, next_start


# ============================================================================
# Export Operations
# ============================================================================


@tool
@idasync
def export_funcs(
    addrs: Annotated[list[str] | str, "Function addresses to export"],
    format: Annotated[
        str, "Export format: json (default), c_header, or prototypes"
    ] = "json",
) -> dict:
    """Export function data in various formats"""
    addrs = normalize_list_input(addrs)
    results = []

    for addr in addrs:
        try:
            ea = parse_address(addr)
            func = idaapi.get_func(ea)
            if not func:
                results.append({"addr": addr, "error": "Function not found"})
                continue

            func_data = {
                "addr": addr,
                "name": ida_funcs.get_func_name(func.start_ea),
                "prototype": get_prototype(func),
                "size": hex(func.end_ea - func.start_ea),
                "comments": get_all_comments(ea),
            }

            if format == "json":
                func_data["asm"] = get_assembly_lines(ea)
                func_data["code"] = decompile_function_safe(ea)
                func_data["xrefs"] = get_all_xrefs(ea)

            results.append(func_data)

        except Exception as e:
            results.append({"addr": addr, "error": str(e)})

    if format == "c_header":
        # Generate C header file
        lines = ["// Auto-generated by IDA Pro MCP", ""]
        for func in results:
            if "prototype" in func and func["prototype"]:
                lines.append(f"{func['prototype']};")
        return {"format": "c_header", "content": "\n".join(lines)}

    elif format == "prototypes":
        # Just prototypes
        prototypes = []
        for func in results:
            if "prototype" in func and func["prototype"]:
                prototypes.append(
                    {"name": func.get("name"), "prototype": func["prototype"]}
                )
        return {"format": "prototypes", "functions": prototypes}

    return {"format": "json", "functions": results}


# ============================================================================
# Graph Operations
# ============================================================================


@tool
@idasync
def callgraph(
    roots: Annotated[
        list[str] | str, "Root function addresses to start call graph traversal from"
    ],
    max_depth: Annotated[int, "Maximum depth for call graph traversal"] = 5,
    max_nodes: Annotated[
        int, "Max nodes across the graph (default: 1000, max: 100000)"
    ] = 1000,
    max_edges: Annotated[
        int, "Max edges across the graph (default: 5000, max: 200000)"
    ] = 5000,
    max_edges_per_func: Annotated[
        int, "Max edges per function (default: 200, max: 5000)"
    ] = 200,
) -> list[dict]:
    """Build call graph starting from root functions"""
    roots = normalize_list_input(roots)
    if max_depth < 0:
        max_depth = 0
    if max_nodes <= 0 or max_nodes > 100000:
        max_nodes = 100000
    if max_edges <= 0 or max_edges > 200000:
        max_edges = 200000
    if max_edges_per_func <= 0 or max_edges_per_func > 5000:
        max_edges_per_func = 5000
    results = []

    for root in roots:
        try:
            ea = parse_address(root)
            func = idaapi.get_func(ea)
            if not func:
                results.append(
                    {
                        "root": root,
                        "error": "Function not found",
                        "nodes": [],
                        "edges": [],
                    }
                )
                continue

            nodes = {}
            edges = []
            visited = set()
            truncated = False
            per_func_capped = False
            limit_reason = None

            def hit_limit(reason: str):
                nonlocal truncated, limit_reason
                truncated = True
                limit_reason = reason

            def traverse(addr, depth):
                nonlocal per_func_capped
                if truncated:
                    return
                if depth > max_depth or addr in visited:
                    return
                if len(nodes) >= max_nodes:
                    hit_limit("nodes")
                    return
                visited.add(addr)

                f = idaapi.get_func(addr)
                if not f:
                    return

                func_name = ida_funcs.get_func_name(f.start_ea)
                nodes[hex(addr)] = {
                    "addr": hex(addr),
                    "name": func_name,
                    "depth": depth,
                }

                # Get callees
                edges_added = 0
                for item_ea in idautils.FuncItems(f.start_ea):
                    if truncated:
                        break
                    for xref in idautils.CodeRefsFrom(item_ea, 0):
                        if truncated:
                            break
                        if edges_added >= max_edges_per_func:
                            per_func_capped = True
                            break
                        callee_func = idaapi.get_func(xref)
                        if callee_func:
                            if len(edges) >= max_edges:
                                hit_limit("edges")
                                break
                            edges.append(
                                {
                                    "from": hex(addr),
                                    "to": hex(callee_func.start_ea),
                                    "type": "call",
                                }
                            )
                            edges_added += 1
                            traverse(callee_func.start_ea, depth + 1)
                    if edges_added >= max_edges_per_func:
                        break

            traverse(ea, 0)

            results.append(
                {
                    "root": root,
                    "nodes": list(nodes.values()),
                    "edges": edges,
                    "max_depth": max_depth,
                    "truncated": truncated,
                    "limit_reason": limit_reason,
                    "max_nodes": max_nodes,
                    "max_edges": max_edges,
                    "max_edges_per_func": max_edges_per_func,
                    "per_func_capped": per_func_capped,
                    "error": None,
                }
            )

        except Exception as e:
            results.append({"root": root, "error": str(e), "nodes": [], "edges": []})

    return results

```

`src/ida_pro_mcp/ida_mcp/api_core.py`:

```py
"""Core API Functions - IDB metadata and basic queries"""

import re
import time
from typing import Annotated

import idaapi
import idautils
import ida_nalt

from .rpc import tool
from .sync import idasync

# Cached strings list: [(ea, text), ...]
_strings_cache: list[tuple[int, str]] | None = None


def _get_strings_cache() -> list[tuple[int, str]]:
    """Get cached strings, building cache on first access."""
    global _strings_cache
    if _strings_cache is None:
        _strings_cache = [(s.ea, str(s)) for s in idautils.Strings() if s is not None]
    return _strings_cache


def invalidate_strings_cache():
    """Clear the strings cache (call after IDB changes)."""
    global _strings_cache
    _strings_cache = None


def init_caches():
    """Build caches on plugin startup (called from Ctrl+M)."""
    t0 = time.perf_counter()
    strings = _get_strings_cache()
    t1 = time.perf_counter()
    print(f"[MCP] Cached {len(strings)} strings in {(t1 - t0) * 1000:.0f}ms")


from .utils import (
    Function,
    ConvertedNumber,
    Global,
    Import,
    Page,
    NumberConversion,
    ListQuery,
    normalize_list_input,
    normalize_dict_list,
    get_function,
    paginate,
    pattern_filter,
)


# ============================================================================
# Core API Functions
# ============================================================================


def _parse_func_query(query: str) -> int:
    """Fast path for common function query patterns. Returns ea or BADADDR."""
    q = query.strip()

    # 0x<hex> - direct address
    if q.startswith("0x") or q.startswith("0X"):
        try:
            return int(q, 16)
        except ValueError:
            pass

    # sub_<hex> - IDA auto-named function
    if q.startswith("sub_"):
        try:
            return int(q[4:], 16)
        except ValueError:
            pass

    return idaapi.BADADDR


@tool
@idasync
def lookup_funcs(
    queries: Annotated[list[str] | str, "Address(es) or name(s)"],
) -> list[dict]:
    """Get functions by address or name (auto-detects)"""
    queries = normalize_list_input(queries)

    # Treat empty/"*" as "all functions" - but add limit
    if not queries or (len(queries) == 1 and queries[0] in ("*", "")):
        all_funcs = []
        for addr in idautils.Functions():
            all_funcs.append(get_function(addr))
            if len(all_funcs) >= 1000:
                break
        return [{"query": "*", "fn": fn, "error": None} for fn in all_funcs]

    results = []
    for query in queries:
        try:
            # Fast path: 0x<ea> or sub_<ea>
            ea = _parse_func_query(query)

            # Slow path: name lookup
            if ea == idaapi.BADADDR:
                ea = idaapi.get_name_ea(idaapi.BADADDR, query)

            if ea != idaapi.BADADDR:
                func = get_function(ea, raise_error=False)
                if func:
                    results.append({"query": query, "fn": func, "error": None})
                else:
                    results.append(
                        {"query": query, "fn": None, "error": "Not a function"}
                    )
            else:
                results.append({"query": query, "fn": None, "error": "Not found"})
        except Exception as e:
            results.append({"query": query, "fn": None, "error": str(e)})

    return results


@tool
def int_convert(
    inputs: Annotated[
        list[NumberConversion] | NumberConversion,
        "Convert numbers to various formats (hex, decimal, binary, ascii)",
    ],
) -> list[dict]:
    """Convert numbers to different formats"""
    inputs = normalize_dict_list(inputs, lambda s: {"text": s, "size": 64})

    results = []
    for item in inputs:
        text = item.get("text", "")
        size = item.get("size")

        try:
            value = int(text, 0)
        except ValueError:
            results.append(
                {"input": text, "result": None, "error": f"Invalid number: {text}"}
            )
            continue

        if not size:
            size = 0
            n = abs(value)
            while n:
                size += 1
                n >>= 1
            size += 7
            size //= 8

        try:
            bytes_data = value.to_bytes(size, "little", signed=True)
        except OverflowError:
            results.append(
                {
                    "input": text,
                    "result": None,
                    "error": f"Number {text} is too big for {size} bytes",
                }
            )
            continue

        ascii_str = ""
        for byte in bytes_data.rstrip(b"\x00"):
            if byte >= 32 and byte <= 126:
                ascii_str += chr(byte)
            else:
                ascii_str = None
                break

        results.append(
            {
                "input": text,
                "result": ConvertedNumber(
                    decimal=str(value),
                    hexadecimal=hex(value),
                    bytes=bytes_data.hex(" "),
                    ascii=ascii_str,
                    binary=bin(value),
                ),
                "error": None,
            }
        )

    return results


@tool
@idasync
def list_funcs(
    queries: Annotated[
        list[ListQuery] | ListQuery | str,
        "List functions with optional filtering and pagination",
    ],
) -> list[Page[Function]]:
    """List functions"""
    queries = normalize_dict_list(
        queries, lambda s: {"offset": 0, "count": 50, "filter": s}
    )
    all_functions = [get_function(addr) for addr in idautils.Functions()]

    results = []
    for query in queries:
        offset = query.get("offset", 0)
        count = query.get("count", 100)
        filter_pattern = query.get("filter", "")

        # Treat empty/"*" filter as "all"
        if filter_pattern in ("", "*"):
            filter_pattern = ""

        filtered = pattern_filter(all_functions, filter_pattern, "name")
        results.append(paginate(filtered, offset, count))

    return results


@tool
@idasync
def list_globals(
    queries: Annotated[
        list[ListQuery] | ListQuery | str,
        "List global variables with optional filtering and pagination",
    ],
) -> list[Page[Global]]:
    """List globals"""
    queries = normalize_dict_list(
        queries, lambda s: {"offset": 0, "count": 50, "filter": s}
    )
    all_globals: list[Global] = []
    for addr, name in idautils.Names():
        if not idaapi.get_func(addr) and name is not None:
            all_globals.append(Global(addr=hex(addr), name=name))

    results = []
    for query in queries:
        offset = query.get("offset", 0)
        count = query.get("count", 100)
        filter_pattern = query.get("filter", "")

        # Treat empty/"*" filter as "all"
        if filter_pattern in ("", "*"):
            filter_pattern = ""

        filtered = pattern_filter(all_globals, filter_pattern, "name")
        results.append(paginate(filtered, offset, count))

    return results


@tool
@idasync
def imports(
    offset: Annotated[int, "Offset"],
    count: Annotated[int, "Count (0=all)"],
) -> Page[Import]:
    """List imports"""
    nimps = ida_nalt.get_import_module_qty()

    rv = []
    for i in range(nimps):
        module_name = ida_nalt.get_import_module_name(i)
        if not module_name:
            module_name = "<unnamed>"

        def imp_cb(ea, symbol_name, ordinal, acc):
            if not symbol_name:
                symbol_name = f"#{ordinal}"
            acc += [Import(addr=hex(ea), imported_name=symbol_name, module=module_name)]
            return True

        def imp_cb_w_context(ea, symbol_name, ordinal):
            return imp_cb(ea, symbol_name, ordinal, rv)

        ida_nalt.enum_import_names(i, imp_cb_w_context)

    return paginate(rv, offset, count)


@tool
@idasync
def find_regex(
    pattern: Annotated[str, "Regex pattern to search for in strings"],
    limit: Annotated[int, "Max matches (default: 30, max: 500)"] = 30,
    offset: Annotated[int, "Skip first N matches (default: 0)"] = 0,
) -> dict:
    """Search strings with case-insensitive regex patterns"""
    if limit <= 0:
        limit = 30
    if limit > 500:
        limit = 500

    matches = []
    regex = re.compile(pattern, re.IGNORECASE)
    strings = _get_strings_cache()

    skipped = 0
    more = False
    for ea, text in strings:
        if regex.search(text):
            if skipped < offset:
                skipped += 1
                continue
            if len(matches) >= limit:
                more = True
                break
            matches.append({"addr": hex(ea), "string": text})

    return {
        "n": len(matches),
        "matches": matches,
        "cursor": {"next": offset + limit} if more else {"done": True},
    }

```

`src/ida_pro_mcp/ida_mcp/api_debug.py`:

```py
"""Debugger operations for IDA Pro MCP.

This module provides comprehensive debugging functionality including:
- Debugger control (start, exit, continue, step, run_to)
- Breakpoint management (add, delete, enable/disable, list)
- Register inspection (all registers, GP registers, specific registers)
- Memory operations (read/write debugger memory)
- Call stack inspection
"""

import os
from typing import Annotated

import ida_dbg
import ida_entry
import ida_idd
import ida_idaapi
import ida_name
import idaapi

from .rpc import tool, unsafe, ext
from .sync import idasync, IDAError
from .utils import (
    RegisterValue,
    ThreadRegisters,
    Breakpoint,
    BreakpointOp,
    MemoryRead,
    MemoryPatch,
    normalize_list_input,
    normalize_dict_list,
    parse_address,
)


# ============================================================================
# Constants and Helper Functions
# ============================================================================

GENERAL_PURPOSE_REGISTERS = {
    "EAX",
    "EBX",
    "ECX",
    "EDX",
    "ESI",
    "EDI",
    "EBP",
    "ESP",
    "EIP",
    "RAX",
    "RBX",
    "RCX",
    "RDX",
    "RSI",
    "RDI",
    "RBP",
    "RSP",
    "RIP",
    "R8",
    "R9",
    "R10",
    "R11",
    "R12",
    "R13",
    "R14",
    "R15",
}


def dbg_ensure_running() -> "ida_idd.debugger_t":
    dbg = ida_idd.get_dbg()
    if not dbg:
        raise IDAError("Debugger not running")
    if ida_dbg.get_ip_val() is None:
        raise IDAError("Debugger not running")
    return dbg


def _get_registers_for_thread(dbg: "ida_idd.debugger_t", tid: int) -> ThreadRegisters:
    """Helper to get registers for a specific thread."""
    regs = []
    regvals: ida_idd.regvals_t = ida_dbg.get_reg_vals(tid)
    for reg_index, rv in enumerate(regvals):
        rv: ida_idd.regval_t
        reg_info = dbg.regs(reg_index)

        try:
            reg_value = rv.pyval(reg_info.dtype)
        except ValueError:
            reg_value = ida_idaapi.BADADDR

        if isinstance(reg_value, int):
            reg_value = hex(reg_value)
        if isinstance(reg_value, bytes):
            reg_value = reg_value.hex(" ")
        else:
            reg_value = str(reg_value)
        regs.append(
            RegisterValue(
                name=reg_info.name,
                value=reg_value,
            )
        )
    return ThreadRegisters(
        thread_id=tid,
        registers=regs,
    )


def _get_registers_general_for_thread(
    dbg: "ida_idd.debugger_t", tid: int
) -> ThreadRegisters:
    """Helper to get general-purpose registers for a specific thread."""
    all_registers = _get_registers_for_thread(dbg, tid)
    general_registers = [
        reg
        for reg in all_registers["registers"]
        if reg["name"] in GENERAL_PURPOSE_REGISTERS
    ]
    return ThreadRegisters(
        thread_id=tid,
        registers=general_registers,
    )


def _get_registers_specific_for_thread(
    dbg: "ida_idd.debugger_t", tid: int, register_names: list[str]
) -> ThreadRegisters:
    """Helper to get specific registers for a given thread."""
    all_registers = _get_registers_for_thread(dbg, tid)
    specific_registers = [
        reg for reg in all_registers["registers"] if reg["name"] in register_names
    ]
    return ThreadRegisters(
        thread_id=tid,
        registers=specific_registers,
    )


def list_breakpoints():
    breakpoints: list[Breakpoint] = []
    for i in range(ida_dbg.get_bpt_qty()):
        bpt = ida_dbg.bpt_t()
        if ida_dbg.getn_bpt(i, bpt):
            breakpoints.append(
                Breakpoint(
                    addr=hex(bpt.ea),
                    enabled=bpt.flags & ida_dbg.BPT_ENABLED,
                    condition=str(bpt.condition) if bpt.condition else None,
                )
            )
    return breakpoints


# ============================================================================
# Debugger Control Operations
# ============================================================================


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_start():
    """Start debugger"""
    if len(list_breakpoints()) == 0:
        for i in range(ida_entry.get_entry_qty()):
            ordinal = ida_entry.get_entry_ordinal(i)
            addr = ida_entry.get_entry(ordinal)
            if addr != ida_idaapi.BADADDR:
                ida_dbg.add_bpt(addr, 0, idaapi.BPT_SOFT)

    if idaapi.start_process("", "", "") == 1:
        ip = ida_dbg.get_ip_val()
        if ip is not None:
            return hex(ip)
    raise IDAError("Failed to start debugger")


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_exit():
    """Exit debugger"""
    dbg_ensure_running()
    if idaapi.exit_process():
        return
    raise IDAError("Failed to exit debugger")


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_continue() -> str:
    """Continue debugger"""
    dbg_ensure_running()
    if idaapi.continue_process():
        ip = ida_dbg.get_ip_val()
        if ip is not None:
            return hex(ip)
    raise IDAError("Failed to continue debugger")


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_run_to(
    addr: Annotated[str, "Address"],
):
    """Run to address"""
    dbg_ensure_running()
    ea = parse_address(addr)
    if idaapi.run_to(ea):
        ip = ida_dbg.get_ip_val()
        if ip is not None:
            return hex(ip)
    raise IDAError(f"Failed to run to address {hex(ea)}")


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_step_into():
    """Step into"""
    dbg_ensure_running()
    if idaapi.step_into():
        ip = ida_dbg.get_ip_val()
        if ip is not None:
            return hex(ip)
    raise IDAError("Failed to step into")


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_step_over():
    """Step over"""
    dbg_ensure_running()
    if idaapi.step_over():
        ip = ida_dbg.get_ip_val()
        if ip is not None:
            return hex(ip)
    raise IDAError("Failed to step over")


# ============================================================================
# Breakpoint Operations
# ============================================================================


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_bps():
    """List breakpoints"""
    return list_breakpoints()


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_add_bp(
    addrs: Annotated[list[str] | str, "Address(es) to add breakpoints at"],
) -> list[dict]:
    """Add breakpoints"""
    addrs = normalize_list_input(addrs)
    results = []

    for addr in addrs:
        try:
            ea = parse_address(addr)
            if idaapi.add_bpt(ea, 0, idaapi.BPT_SOFT):
                results.append({"addr": addr, "ok": True})
            else:
                breakpoints = list_breakpoints()
                for bpt in breakpoints:
                    if bpt["addr"] == hex(ea):
                        results.append({"addr": addr, "ok": True})
                        break
                else:
                    results.append({"addr": addr, "error": "Failed to set breakpoint"})
        except Exception as e:
            results.append({"addr": addr, "error": str(e)})

    return results


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_delete_bp(
    addrs: Annotated[list[str] | str, "Address(es) to delete breakpoints from"],
) -> list[dict]:
    """Delete breakpoints"""
    addrs = normalize_list_input(addrs)
    results = []

    for addr in addrs:
        try:
            ea = parse_address(addr)
            if idaapi.del_bpt(ea):
                results.append({"addr": addr, "ok": True})
            else:
                results.append({"addr": addr, "error": "Failed to delete breakpoint"})
        except Exception as e:
            results.append({"addr": addr, "error": str(e)})

    return results


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_toggle_bp(items: list[BreakpointOp] | BreakpointOp) -> list[dict]:
    """Enable/disable breakpoints"""

    items = normalize_dict_list(items)

    results = []
    for item in items:
        addr = item.get("addr", "")
        enable = item.get("enabled", True)

        try:
            ea = parse_address(addr)
            if idaapi.enable_bpt(ea, enable):
                results.append({"addr": addr, "ok": True})
            else:
                results.append(
                    {
                        "addr": addr,
                        "error": f"Failed to {'enable' if enable else 'disable'} breakpoint",
                    }
                )
        except Exception as e:
            results.append({"addr": addr, "error": str(e)})

    return results


# ============================================================================
# Register Operations
# ============================================================================


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_regs_all() -> list[ThreadRegisters]:
    """Get all registers"""
    result: list[ThreadRegisters] = []
    dbg = dbg_ensure_running()
    for thread_index in range(ida_dbg.get_thread_qty()):
        tid = ida_dbg.getn_thread(thread_index)
        result.append(_get_registers_for_thread(dbg, tid))
    return result


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_regs_remote(
    tids: Annotated[list[int] | int, "Thread ID(s) to get registers for"],
) -> list[dict]:
    """Get thread registers"""
    if isinstance(tids, int):
        tids = [tids]

    dbg = dbg_ensure_running()
    available_tids = [ida_dbg.getn_thread(i) for i in range(ida_dbg.get_thread_qty())]
    results = []

    for tid in tids:
        try:
            if tid not in available_tids:
                results.append(
                    {"tid": tid, "regs": None, "error": f"Thread {tid} not found"}
                )
                continue
            regs = _get_registers_for_thread(dbg, tid)
            results.append({"tid": tid, "regs": regs})
        except Exception as e:
            results.append({"tid": tid, "regs": None, "error": str(e)})

    return results


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_regs() -> ThreadRegisters:
    """Get current thread registers"""
    dbg = dbg_ensure_running()
    tid = ida_dbg.get_current_thread()
    return _get_registers_for_thread(dbg, tid)


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_gpregs_remote(
    tids: Annotated[list[int] | int, "Thread ID(s) to get GP registers for"],
) -> list[dict]:
    """Get GP registers for threads"""
    if isinstance(tids, int):
        tids = [tids]

    dbg = dbg_ensure_running()
    available_tids = [ida_dbg.getn_thread(i) for i in range(ida_dbg.get_thread_qty())]
    results = []

    for tid in tids:
        try:
            if tid not in available_tids:
                results.append(
                    {"tid": tid, "regs": None, "error": f"Thread {tid} not found"}
                )
                continue
            regs = _get_registers_general_for_thread(dbg, tid)
            results.append({"tid": tid, "regs": regs})
        except Exception as e:
            results.append({"tid": tid, "regs": None, "error": str(e)})

    return results


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_gpregs() -> ThreadRegisters:
    """Get current thread GP registers"""
    dbg = dbg_ensure_running()
    tid = ida_dbg.get_current_thread()
    return _get_registers_general_for_thread(dbg, tid)


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_regs_named_remote(
    thread_id: Annotated[int, "Thread ID"],
    register_names: Annotated[
        str, "Comma-separated register names (e.g., 'RAX, RBX, RCX')"
    ],
) -> ThreadRegisters:
    """Get specific thread registers"""
    dbg = dbg_ensure_running()
    if thread_id not in [
        ida_dbg.getn_thread(i) for i in range(ida_dbg.get_thread_qty())
    ]:
        raise IDAError(f"Thread with ID {thread_id} not found")
    names = [name.strip() for name in register_names.split(",")]
    return _get_registers_specific_for_thread(dbg, thread_id, names)


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_regs_named(
    register_names: Annotated[
        str, "Comma-separated register names (e.g., 'RAX, RBX, RCX')"
    ],
) -> ThreadRegisters:
    """Get specific current thread registers"""
    dbg = dbg_ensure_running()
    tid = ida_dbg.get_current_thread()
    names = [name.strip() for name in register_names.split(",")]
    return _get_registers_specific_for_thread(dbg, tid, names)


# ============================================================================
# Call Stack Operations
# ============================================================================


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_stacktrace() -> list[dict[str, str]]:
    """Get call stack"""
    callstack = []
    try:
        tid = ida_dbg.get_current_thread()
        trace = ida_idd.call_stack_t()

        if not ida_dbg.collect_stack_trace(tid, trace):
            return []
        for frame in trace:
            frame_info = {
                "addr": hex(frame.callea),
            }
            try:
                module_info = ida_idd.modinfo_t()
                if ida_dbg.get_module_info(frame.callea, module_info):
                    frame_info["module"] = os.path.basename(module_info.name)
                else:
                    frame_info["module"] = "<unknown>"

                name = (
                    ida_name.get_nice_colored_name(
                        frame.callea,
                        ida_name.GNCN_NOCOLOR
                        | ida_name.GNCN_NOLABEL
                        | ida_name.GNCN_NOSEG
                        | ida_name.GNCN_PREFDBG,
                    )
                    or "<unnamed>"
                )
                frame_info["symbol"] = name

            except Exception as e:
                frame_info["module"] = "<error>"
                frame_info["symbol"] = str(e)

            callstack.append(frame_info)

    except Exception:
        pass
    return callstack


# ============================================================================
# Debugger Memory Operations
# ============================================================================


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_read(regions: list[MemoryRead] | MemoryRead) -> list[dict]:
    """Read debug memory"""

    regions = normalize_dict_list(regions)
    dbg_ensure_running()
    results = []

    for region in regions:
        try:
            addr = parse_address(region["addr"])
            size = region["size"]

            data = idaapi.dbg_read_memory(addr, size)
            if data:
                results.append(
                    {
                        "addr": region["addr"],
                        "size": len(data),
                        "data": data.hex(),
                        "error": None,
                    }
                )
            else:
                results.append(
                    {
                        "addr": region["addr"],
                        "size": 0,
                        "data": None,
                        "error": "Failed to read memory",
                    }
                )

        except Exception as e:
            results.append(
                {"addr": region.get("addr"), "size": 0, "data": None, "error": str(e)}
            )

    return results


@ext("dbg")
@unsafe
@tool
@idasync
def dbg_write(regions: list[MemoryPatch] | MemoryPatch) -> list[dict]:
    """Write debug memory"""

    regions = normalize_dict_list(regions)
    dbg_ensure_running()
    results = []

    for region in regions:
        try:
            addr = parse_address(region["addr"])
            data = bytes.fromhex(region["data"])

            success = idaapi.dbg_write_memory(addr, data)
            results.append(
                {
                    "addr": region["addr"],
                    "size": len(data) if success else 0,
                    "ok": success,
                    "error": None if success else "Write failed",
                }
            )

        except Exception as e:
            results.append({"addr": region.get("addr"), "size": 0, "error": str(e)})

    return results

```

`src/ida_pro_mcp/ida_mcp/api_memory.py`:

```py
"""Memory reading and writing operations for IDA Pro MCP.

This module provides batch operations for reading and writing memory at various
granularities (bytes, integers, strings) and patching binary data.
"""

import re

from typing import Annotated
import ida_bytes
import idaapi

from .rpc import tool
from .sync import idasync
from .utils import (
    IntRead,
    IntWrite,
    MemoryPatch,
    MemoryRead,
    normalize_list_input,
    parse_address,
)


# ============================================================================
# Memory Reading Operations
# ============================================================================


@tool
@idasync
def get_bytes(regions: list[MemoryRead] | MemoryRead) -> list[dict]:
    """Read bytes from memory addresses"""
    if isinstance(regions, dict):
        regions = [regions]

    results = []
    for item in regions:
        addr = item.get("addr", "")
        size = item.get("size", 0)

        try:
            ea = parse_address(addr)
            data = " ".join(f"{x:#02x}" for x in ida_bytes.get_bytes(ea, size))
            results.append({"addr": addr, "data": data})
        except Exception as e:
            results.append({"addr": addr, "data": None, "error": str(e)})

    return results


_INT_CLASS_RE = re.compile(r"^(?P<sign>[iu])(?P<bits>8|16|32|64)(?P<endian>le|be)?$")


def _parse_int_class(text: str) -> tuple[int, bool, str, str]:
    if not text:
        raise ValueError("Missing integer class")

    cleaned = text.strip().lower()
    match = _INT_CLASS_RE.match(cleaned)
    if not match:
        raise ValueError(f"Invalid integer class: {text}")

    bits = int(match.group("bits"))
    signed = match.group("sign") == "i"
    endian = match.group("endian") or "le"
    byte_order = "little" if endian == "le" else "big"
    normalized = f"{'i' if signed else 'u'}{bits}{endian}"
    return bits, signed, byte_order, normalized


def _parse_int_value(text: str, signed: bool, bits: int) -> int:
    if text is None:
        raise ValueError("Missing integer value")

    value_text = str(text).strip()
    try:
        value = int(value_text, 0)
    except ValueError:
        raise ValueError(f"Invalid integer value: {text}")

    if not signed and value < 0:
        raise ValueError(f"Negative value not allowed for u{bits}")

    return value


@tool
@idasync
def get_int(
    queries: Annotated[
        list[IntRead] | IntRead,
        "Integer read requests (ty, addr). ty: i8/u64/i16le/i16be/etc",
    ],
) -> list[dict]:
    """Read integer values from memory addresses"""
    if isinstance(queries, dict):
        queries = [queries]

    results = []
    for item in queries:
        addr = item.get("addr", "")
        ty = item.get("ty", "")

        try:
            bits, signed, byte_order, normalized = _parse_int_class(ty)
            ea = parse_address(addr)
            size = bits // 8
            data = ida_bytes.get_bytes(ea, size)
            if not data or len(data) != size:
                raise ValueError(f"Failed to read {size} bytes at {addr}")

            value = int.from_bytes(data, byte_order, signed=signed)
            results.append(
                {"addr": addr, "ty": normalized, "value": value, "error": None}
            )
        except Exception as e:
            results.append({"addr": addr, "ty": ty, "value": None, "error": str(e)})

    return results


@tool
@idasync
def get_string(
    addrs: Annotated[list[str] | str, "Addresses to read strings from"],
) -> list[dict]:
    """Read strings from memory addresses"""
    addrs = normalize_list_input(addrs)
    results = []

    for addr in addrs:
        try:
            ea = parse_address(addr)
            raw = idaapi.get_strlit_contents(ea, -1, 0)
            if not raw:
                results.append(
                    {"addr": addr, "value": None, "error": "No string at address"}
                )
                continue
            value = raw.decode("utf-8", errors="replace")
            results.append({"addr": addr, "value": value})
        except Exception as e:
            results.append({"addr": addr, "value": None, "error": str(e)})

    return results


def get_global_variable_value_internal(ea: int) -> str:
    import ida_typeinf
    import ida_nalt
    import ida_bytes
    from .sync import IDAError

    tif = ida_typeinf.tinfo_t()
    if not ida_nalt.get_tinfo(tif, ea):
        if not ida_bytes.has_any_name(ea):
            raise IDAError(f"Failed to get type information for variable at {ea:#x}")

        size = ida_bytes.get_item_size(ea)
        if size == 0:
            raise IDAError(f"Failed to get type information for variable at {ea:#x}")
    else:
        size = tif.get_size()

    if size == 0 and tif.is_array() and tif.get_array_element().is_decl_char():
        raw = idaapi.get_strlit_contents(ea, -1, 0)
        if not raw:
            return '""'
        return_string = raw.decode("utf-8", errors="replace").strip()
        return f'"{return_string}"'
    elif size == 1:
        return hex(ida_bytes.get_byte(ea))
    elif size == 2:
        return hex(ida_bytes.get_word(ea))
    elif size == 4:
        return hex(ida_bytes.get_dword(ea))
    elif size == 8:
        return hex(ida_bytes.get_qword(ea))
    else:
        return " ".join(hex(x) for x in ida_bytes.get_bytes(ea, size))


@tool
@idasync
def get_global_value(
    queries: Annotated[
        list[str] | str, "Global variable addresses or names to read values from"
    ],
) -> list[dict]:
    """Read global variable values by address or name
    (auto-detects hex addresses vs names)"""
    from .utils import looks_like_address

    queries = normalize_list_input(queries)
    results = []

    for query in queries:
        try:
            ea = idaapi.BADADDR

            # Try as address first if it looks like one
            if looks_like_address(query):
                try:
                    ea = parse_address(query)
                except Exception:
                    ea = idaapi.BADADDR

            # Fall back to name lookup
            if ea == idaapi.BADADDR:
                ea = idaapi.get_name_ea(idaapi.BADADDR, query)

            if ea == idaapi.BADADDR:
                results.append({"query": query, "value": None, "error": "Not found"})
                continue

            value = get_global_variable_value_internal(ea)
            results.append({"query": query, "value": value, "error": None})
        except Exception as e:
            results.append({"query": query, "value": None, "error": str(e)})

    return results


# ============================================================================
# Batch Data Operations
# ============================================================================


@tool
@idasync
def patch(patches: list[MemoryPatch] | MemoryPatch) -> list[dict]:
    """Patch bytes at memory addresses with hex data"""
    if isinstance(patches, dict):
        patches = [patches]

    results = []

    for patch in patches:
        try:
            ea = parse_address(patch["addr"])
            data = bytes.fromhex(patch["data"])

            ida_bytes.patch_bytes(ea, data)
            results.append(
                {"addr": patch["addr"], "size": len(data), "ok": True, "error": None}
            )

        except Exception as e:
            results.append({"addr": patch.get("addr"), "size": 0, "error": str(e)})

    return results


@tool
@idasync
def put_int(
    items: Annotated[
        list[IntWrite] | IntWrite,
        "Integer write requests (ty, addr, value). value is a string; supports 0x.. and negatives",
    ],
) -> list[dict]:
    """Write integer values to memory addresses"""
    if isinstance(items, dict):
        items = [items]

    results = []
    for item in items:
        addr = item.get("addr", "")
        ty = item.get("ty", "")
        value_text = item.get("value")

        try:
            bits, signed, byte_order, normalized = _parse_int_class(ty)
            value = _parse_int_value(value_text, signed, bits)
            size = bits // 8
            try:
                data = value.to_bytes(size, byte_order, signed=signed)
            except OverflowError:
                raise ValueError(f"Value {value_text} does not fit in {normalized}")

            ea = parse_address(addr)
            ida_bytes.patch_bytes(ea, data)
            results.append(
                {
                    "addr": addr,
                    "ty": normalized,
                    "value": str(value_text),
                    "ok": True,
                    "error": None,
                }
            )
        except Exception as e:
            results.append(
                {
                    "addr": addr,
                    "ty": ty,
                    "value": str(value_text) if value_text is not None else None,
                    "ok": False,
                    "error": str(e),
                }
            )

    return results

```

`src/ida_pro_mcp/ida_mcp/api_modify.py`:

```py
import idaapi
import idautils
import idc
import ida_hexrays
import ida_bytes
import ida_typeinf
import ida_frame
import ida_dirtree
import ida_funcs
import ida_ua

from .rpc import tool
from .sync import idasync, IDAError
from .utils import (
    parse_address,
    decompile_checked,
    refresh_decompiler_ctext,
    CommentOp,
    AsmPatchOp,
    FunctionRename,
    GlobalRename,
    LocalRename,
    StackRename,
    RenameBatch,
    DefineOp,
    UndefineOp,
)


# ============================================================================
# Modification Operations
# ============================================================================


@tool
@idasync
def set_comments(items: list[CommentOp] | CommentOp):
    """Set comments at addresses (both disassembly and decompiler views)"""
    if isinstance(items, dict):
        items = [items]

    results = []
    for item in items:
        addr_str = item.get("addr", "")
        comment = item.get("comment", "")

        try:
            ea = parse_address(addr_str)

            if not idaapi.set_cmt(ea, comment, False):
                results.append(
                    {
                        "addr": addr_str,
                        "error": f"Failed to set disassembly comment at {hex(ea)}",
                    }
                )
                continue

            if not ida_hexrays.init_hexrays_plugin():
                results.append({"addr": addr_str, "ok": True})
                continue

            try:
                cfunc = decompile_checked(ea)
            except IDAError:
                results.append({"addr": addr_str, "ok": True})
                continue

            if ea == cfunc.entry_ea:
                idc.set_func_cmt(ea, comment, True)
                cfunc.refresh_func_ctext()
                results.append({"addr": addr_str, "ok": True})
                continue

            eamap = cfunc.get_eamap()
            if ea not in eamap:
                results.append(
                    {
                        "addr": addr_str,
                        "ok": True,
                        "error": f"Failed to set decompiler comment at {hex(ea)}",
                    }
                )
                continue
            nearest_ea = eamap[ea][0].ea

            if cfunc.has_orphan_cmts():
                cfunc.del_orphan_cmts()
                cfunc.save_user_cmts()

            tl = idaapi.treeloc_t()
            tl.ea = nearest_ea
            for itp in range(idaapi.ITP_SEMI, idaapi.ITP_COLON):
                tl.itp = itp
                cfunc.set_user_cmt(tl, comment)
                cfunc.save_user_cmts()
                cfunc.refresh_func_ctext()
                if not cfunc.has_orphan_cmts():
                    results.append({"addr": addr_str, "ok": True})
                    break
                cfunc.del_orphan_cmts()
                cfunc.save_user_cmts()
            else:
                results.append(
                    {
                        "addr": addr_str,
                        "ok": True,
                        "error": f"Failed to set decompiler comment at {hex(ea)}",
                    }
                )
        except Exception as e:
            results.append({"addr": addr_str, "error": str(e)})

    return results


@tool
@idasync
def patch_asm(items: list[AsmPatchOp] | AsmPatchOp) -> list[dict]:
    """Patch assembly instructions at addresses"""
    if isinstance(items, dict):
        items = [items]

    results = []
    for item in items:
        addr_str = item.get("addr", "")
        instructions = item.get("asm", "")

        try:
            ea = parse_address(addr_str)
            assembles = instructions.split(";")
            for assemble in assembles:
                assemble = assemble.strip()
                try:
                    (check_assemble, bytes_to_patch) = idautils.Assemble(ea, assemble)
                    if not check_assemble:
                        results.append(
                            {
                                "addr": addr_str,
                                "error": f"Failed to assemble: {assemble}",
                            }
                        )
                        break
                    ida_bytes.patch_bytes(ea, bytes_to_patch)
                    ea += len(bytes_to_patch)
                except Exception as e:
                    results.append(
                        {"addr": addr_str, "error": f"Failed at {hex(ea)}: {e}"}
                    )
                    break
            else:
                results.append({"addr": addr_str, "ok": True})
        except Exception as e:
            results.append({"addr": addr_str, "error": str(e)})

    return results


@tool
@idasync
def rename(batch: RenameBatch) -> dict:
    """Unified rename operation for functions, globals, locals, and stack variables"""

    def _normalize_items(items):
        """Convert single item or None to list"""
        if items is None:
            return []
        return [items] if isinstance(items, dict) else items

    def _has_user_name(ea: int) -> bool:
        flags = idaapi.get_flags(ea)
        checker = getattr(idaapi, "has_user_name", None)
        if checker is not None:
            return checker(flags)
        try:
            import ida_name

            checker = getattr(ida_name, "has_user_name", None)
            if checker is not None:
                return checker(flags)
        except Exception:
            pass
        return False

    def _place_func_in_vibe_dir(ea: int) -> tuple[bool, str | None]:
        tree = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)
        if tree is None:
            return False, "Function dirtree not available"

        if not tree.load():
            return False, "Failed to load function dirtree"

        vibe_path = "/vibe/"
        if not tree.isdir(vibe_path):
            err = tree.mkdir(vibe_path)
            if err not in (ida_dirtree.DTE_OK, ida_dirtree.DTE_ALREADY_EXISTS):
                return False, f"mkdir failed: {err}"

        old_cwd = tree.getcwd()
        try:
            if tree.chdir(vibe_path) != ida_dirtree.DTE_OK:
                return False, "Failed to chdir to vibe"
            err = tree.link(ea)
            if err not in (ida_dirtree.DTE_OK, ida_dirtree.DTE_ALREADY_EXISTS):
                return False, f"link failed: {err}"
            if not tree.save():
                return False, "Failed to save function dirtree"
        finally:
            if old_cwd:
                tree.chdir(old_cwd)

        return True, None

    def _rename_funcs(items: list[FunctionRename]) -> list[dict]:
        results = []
        for item in items:
            try:
                ea = parse_address(item["addr"])
                had_user_name = _has_user_name(ea)
                success = idaapi.set_name(ea, item["name"], idaapi.SN_CHECK)
                if success:
                    func = idaapi.get_func(ea)
                    if func:
                        refresh_decompiler_ctext(func.start_ea)
                    if not had_user_name and func:
                        placed, place_error = _place_func_in_vibe_dir(func.start_ea)
                    else:
                        placed, place_error = None, None
                results.append(
                    {
                        "addr": item["addr"],
                        "name": item["name"],
                        "ok": success,
                        "error": None if success else "Rename failed",
                        "dir": "vibe" if success and placed else None,
                        "dir_error": place_error if success else None,
                    }
                )
            except Exception as e:
                results.append({"addr": item.get("addr"), "error": str(e)})
        return results

    def _rename_globals(items: list[GlobalRename]) -> list[dict]:
        results = []
        for item in items:
            try:
                ea = idaapi.get_name_ea(idaapi.BADADDR, item["old"])
                if ea == idaapi.BADADDR:
                    results.append(
                        {
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": f"Global '{item['old']}' not found",
                        }
                    )
                    continue
                success = idaapi.set_name(ea, item["new"], idaapi.SN_CHECK)
                results.append(
                    {
                        "old": item["old"],
                        "new": item["new"],
                        "ok": success,
                        "error": None if success else "Rename failed",
                    }
                )
            except Exception as e:
                results.append({"old": item.get("old"), "error": str(e)})
        return results

    def _rename_locals(items: list[LocalRename]) -> list[dict]:
        results = []
        for item in items:
            try:
                func = idaapi.get_func(parse_address(item["func_addr"]))
                if not func:
                    results.append(
                        {
                            "func_addr": item["func_addr"],
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": "No function found",
                        }
                    )
                    continue
                success = ida_hexrays.rename_lvar(
                    func.start_ea, item["old"], item["new"]
                )
                if success:
                    refresh_decompiler_ctext(func.start_ea)
                results.append(
                    {
                        "func_addr": item["func_addr"],
                        "old": item["old"],
                        "new": item["new"],
                        "ok": success,
                        "error": None if success else "Rename failed",
                    }
                )
            except Exception as e:
                results.append({"func_addr": item.get("func_addr"), "error": str(e)})
        return results

    def _rename_stack(items: list[StackRename]) -> list[dict]:
        results = []
        for item in items:
            try:
                func = idaapi.get_func(parse_address(item["func_addr"]))
                if not func:
                    results.append(
                        {
                            "func_addr": item["func_addr"],
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": "No function found",
                        }
                    )
                    continue

                frame_tif = ida_typeinf.tinfo_t()
                if not ida_frame.get_func_frame(frame_tif, func):
                    results.append(
                        {
                            "func_addr": item["func_addr"],
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": "No frame",
                        }
                    )
                    continue

                idx, udm = frame_tif.get_udm(item["old"])
                if not udm:
                    results.append(
                        {
                            "func_addr": item["func_addr"],
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": f"'{item['old']}' not found",
                        }
                    )
                    continue

                tid = frame_tif.get_udm_tid(idx)
                if ida_frame.is_special_frame_member(tid):
                    results.append(
                        {
                            "func_addr": item["func_addr"],
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": "Special frame member",
                        }
                    )
                    continue

                udm = ida_typeinf.udm_t()
                frame_tif.get_udm_by_tid(udm, tid)
                offset = udm.offset // 8
                if ida_frame.is_funcarg_off(func, offset):
                    results.append(
                        {
                            "func_addr": item["func_addr"],
                            "old": item["old"],
                            "new": item["new"],
                            "ok": False,
                            "error": "Argument member",
                        }
                    )
                    continue

                sval = ida_frame.soff_to_fpoff(func, offset)
                success = ida_frame.define_stkvar(func, item["new"], sval, udm.type)
                results.append(
                    {
                        "func_addr": item["func_addr"],
                        "old": item["old"],
                        "new": item["new"],
                        "ok": success,
                        "error": None if success else "Rename failed",
                    }
                )
            except Exception as e:
                results.append({"func_addr": item.get("func_addr"), "error": str(e)})
        return results

    # Process each category
    result = {}
    if "func" in batch:
        result["func"] = _rename_funcs(_normalize_items(batch["func"]))
    if "data" in batch:
        result["data"] = _rename_globals(_normalize_items(batch["data"]))
    if "local" in batch:
        result["local"] = _rename_locals(_normalize_items(batch["local"]))
    if "stack" in batch:
        result["stack"] = _rename_stack(_normalize_items(batch["stack"]))

    return result


@tool
@idasync
def define_func(items: list[DefineOp] | DefineOp) -> list[dict]:
    """Define function(s) at address(es). IDA auto-determines bounds unless end address specified."""
    if isinstance(items, dict):
        items = [items]

    results = []
    for item in items:
        addr_str = item.get("addr", "")
        end_str = item.get("end", "")

        try:
            start_ea = parse_address(addr_str)
            end_ea = parse_address(end_str) if end_str else idaapi.BADADDR

            # Check if already a function
            existing = idaapi.get_func(start_ea)
            if existing and existing.start_ea == start_ea:
                results.append(
                    {
                        "addr": addr_str,
                        "start": hex(start_ea),
                        "error": "Function already exists at this address",
                    }
                )
                continue

            success = ida_funcs.add_func(start_ea, end_ea)
            if success:
                func = idaapi.get_func(start_ea)
                results.append(
                    {
                        "addr": addr_str,
                        "start": hex(func.start_ea),
                        "end": hex(func.end_ea),
                        "ok": True,
                    }
                )
            else:
                results.append(
                    {
                        "addr": addr_str,
                        "start": hex(start_ea),
                        "error": "define_func failed",
                    }
                )
        except Exception as e:
            results.append({"addr": addr_str, "error": str(e)})

    return results


@tool
@idasync
def define_code(items: list[DefineOp] | DefineOp) -> list[dict]:
    """Convert bytes to code instruction(s) at address(es)."""
    if isinstance(items, dict):
        items = [items]

    results = []
    for item in items:
        addr_str = item.get("addr", "")

        try:
            ea = parse_address(addr_str)
            length = ida_ua.create_insn(ea)
            if length > 0:
                results.append(
                    {"addr": addr_str, "ea": hex(ea), "length": length, "ok": True}
                )
            else:
                results.append(
                    {
                        "addr": addr_str,
                        "ea": hex(ea),
                        "error": "Failed to create instruction",
                    }
                )
        except Exception as e:
            results.append({"addr": addr_str, "error": str(e)})

    return results


@tool
@idasync
def undefine(items: list[UndefineOp] | UndefineOp) -> list[dict]:
    """Undefine item(s) at address(es), converting back to raw bytes."""
    if isinstance(items, dict):
        items = [items]

    results = []
    for item in items:
        addr_str = item.get("addr", "")
        end_str = item.get("end", "")
        size = item.get("size", 0)

        try:
            start_ea = parse_address(addr_str)

            # Determine size from end address or explicit size
            if end_str:
                end_ea = parse_address(end_str)
                nbytes = end_ea - start_ea
            elif size:
                nbytes = size
            else:
                # Default: undefine single item
                nbytes = 1

            success = ida_bytes.del_items(start_ea, ida_bytes.DELIT_EXPAND, nbytes)
            if success:
                results.append(
                    {
                        "addr": addr_str,
                        "start": hex(start_ea),
                        "size": nbytes,
                        "ok": True,
                    }
                )
            else:
                results.append(
                    {
                        "addr": addr_str,
                        "start": hex(start_ea),
                        "error": "undefine failed",
                    }
                )
        except Exception as e:
            results.append({"addr": addr_str, "error": str(e)})

    return results

```

`src/ida_pro_mcp/ida_mcp/api_python.py`:

```py
from typing import Annotated
import ast
import io
import sys
import idaapi
import idc
import ida_bytes
import ida_dbg
import ida_entry
import ida_frame
import ida_funcs
import ida_hexrays
import ida_ida
import ida_kernwin
import ida_lines
import ida_nalt
import ida_name
import ida_segment
import ida_typeinf
import ida_xref

from .rpc import tool, unsafe
from .sync import idasync
from .utils import parse_address, get_function

# ============================================================================
# Python Evaluation
# ============================================================================


@tool
@idasync
@unsafe
def py_eval(
    code: Annotated[str, "Python code"],
) -> dict:
    """Execute Python code in IDA context.
    Returns dict with result/stdout/stderr.
    Has access to all IDA API modules.
    Supports Jupyter-style evaluation."""
    # Capture stdout/stderr
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    old_stdout = sys.stdout
    old_stderr = sys.stderr

    try:
        sys.stdout = stdout_capture
        sys.stderr = stderr_capture

        # Create execution context with IDA modules (lazy import to avoid errors)
        def lazy_import(module_name):
            try:
                return __import__(module_name)
            except Exception:
                return None

        exec_globals = {
            "__builtins__": __builtins__,
            "idaapi": idaapi,
            "idc": idc,
            "idautils": lazy_import("idautils"),
            "ida_allins": lazy_import("ida_allins"),
            "ida_auto": lazy_import("ida_auto"),
            "ida_bitrange": lazy_import("ida_bitrange"),
            "ida_bytes": ida_bytes,
            "ida_dbg": ida_dbg,
            "ida_dirtree": lazy_import("ida_dirtree"),
            "ida_diskio": lazy_import("ida_diskio"),
            "ida_entry": ida_entry,
            "ida_expr": lazy_import("ida_expr"),
            "ida_fixup": lazy_import("ida_fixup"),
            "ida_fpro": lazy_import("ida_fpro"),
            "ida_frame": ida_frame,
            "ida_funcs": ida_funcs,
            "ida_gdl": lazy_import("ida_gdl"),
            "ida_graph": lazy_import("ida_graph"),
            "ida_hexrays": ida_hexrays,
            "ida_ida": ida_ida,
            "ida_idd": lazy_import("ida_idd"),
            "ida_idp": lazy_import("ida_idp"),
            "ida_ieee": lazy_import("ida_ieee"),
            "ida_kernwin": ida_kernwin,
            "ida_libfuncs": lazy_import("ida_libfuncs"),
            "ida_lines": ida_lines,
            "ida_loader": lazy_import("ida_loader"),
            "ida_merge": lazy_import("ida_merge"),
            "ida_mergemod": lazy_import("ida_mergemod"),
            "ida_moves": lazy_import("ida_moves"),
            "ida_nalt": ida_nalt,
            "ida_name": ida_name,
            "ida_netnode": lazy_import("ida_netnode"),
            "ida_offset": lazy_import("ida_offset"),
            "ida_pro": lazy_import("ida_pro"),
            "ida_problems": lazy_import("ida_problems"),
            "ida_range": lazy_import("ida_range"),
            "ida_regfinder": lazy_import("ida_regfinder"),
            "ida_registry": lazy_import("ida_registry"),
            "ida_search": lazy_import("ida_search"),
            "ida_segment": ida_segment,
            "ida_segregs": lazy_import("ida_segregs"),
            "ida_srclang": lazy_import("ida_srclang"),
            "ida_strlist": lazy_import("ida_strlist"),
            "ida_struct": lazy_import("ida_struct"),
            "ida_tryblks": lazy_import("ida_tryblks"),
            "ida_typeinf": ida_typeinf,
            "ida_ua": lazy_import("ida_ua"),
            "ida_undo": lazy_import("ida_undo"),
            "ida_xref": ida_xref,
            "ida_enum": lazy_import("ida_enum"),
            "parse_address": parse_address,
            "get_function": get_function,
        }

        result_value = None
        exec_locals = {}

        # Parse code with AST to properly handle execution
        try:
            tree = ast.parse(code)
        except SyntaxError:
            # If parsing fails, fall back to direct exec
            exec(code, exec_globals, exec_locals)
            exec_globals.update(exec_locals)
            if "result" in exec_locals:
                result_value = str(exec_locals["result"])
            elif exec_locals:
                last_key = list(exec_locals.keys())[-1]
                result_value = str(exec_locals[last_key])
        else:
            if not tree.body:
                # Empty code
                pass
            elif len(tree.body) == 1 and isinstance(tree.body[0], ast.Expr):
                # Single expression - use eval
                result_value = str(eval(code, exec_globals))
            elif isinstance(tree.body[-1], ast.Expr):
                # Multiple statements, last one is an expression (Jupyter-style)
                # Execute all statements except the last
                if len(tree.body) > 1:
                    exec_tree = ast.Module(body=tree.body[:-1], type_ignores=[])
                    exec(
                        compile(exec_tree, "<string>", "exec"),
                        exec_globals,
                        exec_locals,
                    )
                    exec_globals.update(exec_locals)
                # Eval only the last expression
                eval_tree = ast.Expression(body=tree.body[-1].value)
                result_value = str(
                    eval(compile(eval_tree, "<string>", "eval"), exec_globals)
                )
            else:
                # All statements (no trailing expression)
                exec(code, exec_globals, exec_locals)
                exec_globals.update(exec_locals)
                # Return 'result' variable if explicitly set
                if "result" in exec_locals:
                    result_value = str(exec_locals["result"])
                # Return last assigned variable
                elif exec_locals:
                    last_key = list(exec_locals.keys())[-1]
                    result_value = str(exec_locals[last_key])

        # Collect output
        stdout_text = stdout_capture.getvalue()
        stderr_text = stderr_capture.getvalue()

        return {
            "result": result_value or "",
            "stdout": stdout_text,
            "stderr": stderr_text,
        }

    except Exception:
        import traceback

        return {
            "result": "",
            "stdout": "",
            "stderr": traceback.format_exc(),
        }
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr

```

`src/ida_pro_mcp/ida_mcp/api_resources.py`:

```py
"""MCP Resources - browsable IDB state

Resources represent browsable state (read-only data) following MCP's philosophy.
Use tools for actions that modify state or perform expensive computations.
"""

from typing import Annotated

import ida_funcs
import ida_nalt
import ida_segment
import ida_typeinf
import idaapi
import idautils
import idc

from .rpc import resource
from .sync import idasync
from .utils import (
    Metadata,
    Segment,
    StructureDefinition,
    StructureMember,
    get_image_size,
    parse_address,
)


# ============================================================================
# Core IDB State
# ============================================================================


@resource("ida://idb/metadata")
@idasync
def idb_metadata_resource() -> Metadata:
    """Get IDB file metadata (path, arch, base address, size, hashes)"""
    import hashlib

    path = idc.get_idb_path()
    module = ida_nalt.get_root_filename()
    base = hex(idaapi.get_imagebase())
    size = hex(get_image_size())

    input_path = ida_nalt.get_input_file_path()
    try:
        with open(input_path, "rb") as f:
            data = f.read()
        md5 = hashlib.md5(data).hexdigest()
        sha256 = hashlib.sha256(data).hexdigest()
        import zlib

        crc32 = hex(zlib.crc32(data) & 0xFFFFFFFF)
        filesize = hex(len(data))
    except Exception:
        md5 = sha256 = crc32 = filesize = "unavailable"

    return Metadata(
        path=path,
        module=module,
        base=base,
        size=size,
        md5=md5,
        sha256=sha256,
        crc32=crc32,
        filesize=filesize,
    )


@resource("ida://idb/segments")
@idasync
def idb_segments_resource() -> list[Segment]:
    """Get all memory segments with permissions"""
    segments = []
    for seg_ea in idautils.Segments():
        seg = idaapi.getseg(seg_ea)
        if seg:
            perms = []
            if seg.perm & idaapi.SEGPERM_READ:
                perms.append("r")
            if seg.perm & idaapi.SEGPERM_WRITE:
                perms.append("w")
            if seg.perm & idaapi.SEGPERM_EXEC:
                perms.append("x")

            segments.append(
                Segment(
                    name=ida_segment.get_segm_name(seg),
                    start=hex(seg.start_ea),
                    end=hex(seg.end_ea),
                    size=hex(seg.size()),
                    permissions="".join(perms) if perms else "---",
                )
            )
    return segments


@resource("ida://idb/entrypoints")
@idasync
def idb_entrypoints_resource() -> list[dict]:
    """Get entry points (main, TLS callbacks, etc.)"""
    entrypoints = []
    entry_count = ida_nalt.get_entry_qty()
    for i in range(entry_count):
        ordinal = ida_nalt.get_entry_ordinal(i)
        ea = ida_nalt.get_entry(ordinal)
        name = ida_nalt.get_entry_name(ordinal)
        entrypoints.append({"addr": hex(ea), "name": name, "ordinal": ordinal})
    return entrypoints


# ============================================================================
# UI State
# ============================================================================


@resource("ida://cursor")
@idasync
def cursor_resource() -> dict:
    """Get current cursor position and function"""
    import ida_kernwin

    ea = ida_kernwin.get_screen_ea()
    func = idaapi.get_func(ea)

    result = {"addr": hex(ea)}
    if func:
        try:
            func_name = func.get_name()
        except AttributeError:
            func_name = ida_funcs.get_func_name(func.start_ea)

        result["function"] = {
            "addr": hex(func.start_ea),
            "name": func_name,
        }

    return result


@resource("ida://selection")
@idasync
def selection_resource() -> dict:
    """Get current selection range (if any)"""
    import ida_kernwin

    start = ida_kernwin.read_range_selection(None)
    if start:
        return {"start": hex(start[0]), "end": hex(start[1]) if start[1] else None}
    return {"selection": None}


# ============================================================================
# Type Information
# ============================================================================


@resource("ida://types")
@idasync
def types_resource() -> list[dict]:
    """Get all local types"""
    types = []
    for ordinal in range(1, ida_typeinf.get_ordinal_qty(None)):
        tif = ida_typeinf.tinfo_t()
        if tif.get_numbered_type(None, ordinal):
            name = tif.get_type_name()
            types.append({"ordinal": ordinal, "name": name, "type": str(tif)})
    return types


@resource("ida://structs")
@idasync
def structs_resource() -> list[dict]:
    """Get all structures/unions"""
    structs = []
    limit = ida_typeinf.get_ordinal_limit()
    for ordinal in range(1, limit):
        tif = ida_typeinf.tinfo_t()
        if tif.get_numbered_type(None, ordinal) and tif.is_udt():
            udt_data = ida_typeinf.udt_type_data_t()
            is_union = False
            if tif.get_udt_details(udt_data):
                is_union = udt_data.is_union
            structs.append(
                {
                    "name": tif.get_type_name(),
                    "size": hex(tif.get_size()),
                    "is_union": is_union,
                }
            )
    return structs


@resource("ida://struct/{name}")
@idasync
def struct_name_resource(name: Annotated[str, "Structure name"]) -> dict:
    """Get structure definition with fields"""
    tif = ida_typeinf.tinfo_t()
    if not tif.get_named_type(None, name):
        return {"error": f"Structure not found: {name}"}

    if not tif.is_udt():
        return {"error": f"'{name}' is not a structure/union"}

    udt_data = ida_typeinf.udt_type_data_t()
    if not tif.get_udt_details(udt_data):
        return {"error": f"Failed to get struct details for '{name}'"}

    members = []
    for member in udt_data:
        members.append(
            StructureMember(
                name=member.name,
                offset=hex(member.offset // 8),
                size=hex(member.size // 8),
                type=str(member.type),
            )
        )

    return StructureDefinition(name=name, size=hex(tif.get_size()), members=members)


# ============================================================================
# Import/Export Lookup by Name
# ============================================================================


@resource("ida://import/{name}")
@idasync
def import_name_resource(name: Annotated[str, "Import name"]) -> dict:
    """Get specific import details by name"""
    nimps = ida_nalt.get_import_module_qty()
    for i in range(nimps):
        module = ida_nalt.get_import_module_name(i)
        result = {}

        def callback(ea, imp_name, ordinal):
            if imp_name == name or f"ord_{ordinal}" == name:
                result.update(
                    {
                        "addr": hex(ea),
                        "name": imp_name or f"ord_{ordinal}",
                        "module": module,
                        "ordinal": ordinal,
                    }
                )
                return False  # Stop enumeration
            return True

        ida_nalt.enum_import_names(i, callback)
        if result:
            return result

    return {"error": f"Import not found: {name}"}


@resource("ida://export/{name}")
@idasync
def export_name_resource(name: Annotated[str, "Export name"]) -> dict:
    """Get specific export details by name"""
    entry_count = ida_nalt.get_entry_qty()
    for i in range(entry_count):
        ordinal = ida_nalt.get_entry_ordinal(i)
        ea = ida_nalt.get_entry(ordinal)
        entry_name = ida_nalt.get_entry_name(ordinal)

        if entry_name == name:
            return {
                "addr": hex(ea),
                "name": entry_name,
                "ordinal": ordinal,
            }

    return {"error": f"Export not found: {name}"}


# ============================================================================
# Cross-references
# ============================================================================


@resource("ida://xrefs/from/{addr}")
@idasync
def xrefs_from_resource(addr: Annotated[str, "Source address"]) -> list[dict]:
    """Get cross-references from address"""
    ea = parse_address(addr)
    xrefs = []
    for xref in idautils.XrefsFrom(ea, 0):
        xrefs.append(
            {
                "addr": hex(xref.to),
                "type": "code" if xref.iscode else "data",
            }
        )
    return xrefs

```

`src/ida_pro_mcp/ida_mcp/api_stack.py`:

```py
"""Stack frame operations for IDA Pro MCP.

This module provides batch operations for managing stack frame variables,
including reading, creating, and deleting stack variables in functions.
"""

from typing import Annotated
import ida_typeinf
import ida_frame
import idaapi

from .rpc import tool
from .sync import idasync
from .utils import (
    normalize_list_input,
    normalize_dict_list,
    parse_address,
    get_type_by_name,
    StackVarDecl,
    StackVarDelete,
    get_stack_frame_variables_internal,
)


# ============================================================================
# Stack Frame Operations
# ============================================================================


@tool
@idasync
def stack_frame(addrs: Annotated[list[str] | str, "Address(es)"]) -> list[dict]:
    """Get stack vars"""
    addrs = normalize_list_input(addrs)
    results = []

    for addr in addrs:
        try:
            ea = parse_address(addr)
            vars = get_stack_frame_variables_internal(ea, True)
            results.append({"addr": addr, "vars": vars})
        except Exception as e:
            results.append({"addr": addr, "vars": None, "error": str(e)})

    return results


@tool
@idasync
def declare_stack(
    items: list[StackVarDecl] | StackVarDecl,
):
    """Create stack vars"""
    items = normalize_dict_list(items)
    results = []
    for item in items:
        fn_addr = item.get("addr", "")
        offset = item.get("offset", "")
        var_name = item.get("name", "")
        type_name = item.get("ty", "")

        try:
            func = idaapi.get_func(parse_address(fn_addr))
            if not func:
                results.append(
                    {"addr": fn_addr, "name": var_name, "error": "No function found"}
                )
                continue

            ea = parse_address(offset)

            frame_tif = ida_typeinf.tinfo_t()
            if not ida_frame.get_func_frame(frame_tif, func):
                results.append(
                    {"addr": fn_addr, "name": var_name, "error": "No frame returned"}
                )
                continue

            tif = get_type_by_name(type_name)
            if not ida_frame.define_stkvar(func, var_name, ea, tif):
                results.append(
                    {"addr": fn_addr, "name": var_name, "error": "Failed to define"}
                )
                continue

            results.append({"addr": fn_addr, "name": var_name, "ok": True})
        except Exception as e:
            results.append({"addr": fn_addr, "name": var_name, "error": str(e)})

    return results


@tool
@idasync
def delete_stack(
    items: list[StackVarDelete] | StackVarDelete,
):
    """Delete stack vars"""

    items = normalize_dict_list(items)
    results = []
    for item in items:
        fn_addr = item.get("addr", "")
        var_name = item.get("name", "")

        try:
            func = idaapi.get_func(parse_address(fn_addr))
            if not func:
                results.append(
                    {"addr": fn_addr, "name": var_name, "error": "No function found"}
                )
                continue

            frame_tif = ida_typeinf.tinfo_t()
            if not ida_frame.get_func_frame(frame_tif, func):
                results.append(
                    {"addr": fn_addr, "name": var_name, "error": "No frame returned"}
                )
                continue

            idx, udm = frame_tif.get_udm(var_name)
            if not udm:
                results.append(
                    {
                        "addr": fn_addr,
                        "name": var_name,
                        "error": f"{var_name} not found",
                    }
                )
                continue

            tid = frame_tif.get_udm_tid(idx)
            if ida_frame.is_special_frame_member(tid):
                results.append(
                    {
                        "addr": fn_addr,
                        "name": var_name,
                        "error": f"{var_name} is special frame member",
                    }
                )
                continue

            udm = ida_typeinf.udm_t()
            frame_tif.get_udm_by_tid(udm, tid)
            offset = udm.offset // 8
            size = udm.size // 8
            if ida_frame.is_funcarg_off(func, offset):
                results.append(
                    {
                        "addr": fn_addr,
                        "name": var_name,
                        "error": f"{var_name} is argument member",
                    }
                )
                continue

            if not ida_frame.delete_frame_members(func, offset, offset + size):
                results.append(
                    {"addr": fn_addr, "name": var_name, "error": "Failed to delete"}
                )
                continue

            results.append({"addr": fn_addr, "name": var_name, "ok": True})
        except Exception as e:
            results.append({"addr": fn_addr, "name": var_name, "error": str(e)})

    return results

```

`src/ida_pro_mcp/ida_mcp/api_types.py`:

```py
from typing import Annotated

import ida_typeinf
import ida_hexrays
import ida_nalt
import ida_bytes
import ida_frame
import ida_ida
import idaapi

from .rpc import tool
from .sync import idasync, ida_major
from .utils import (
    normalize_list_input,
    normalize_dict_list,
    parse_address,
    get_type_by_name,
    parse_decls_ctypes,
    my_modifier_t,
    StructRead,
    TypeEdit,
)


# ============================================================================
# Type Declaration
# ============================================================================


@tool
@idasync
def declare_type(
    decls: Annotated[list[str] | str, "C type declarations"],
) -> list[dict]:
    """Declare types"""
    decls = normalize_list_input(decls)
    results = []

    for decl in decls:
        try:
            flags = ida_typeinf.PT_SIL | ida_typeinf.PT_EMPTY | ida_typeinf.PT_TYP
            errors, messages = parse_decls_ctypes(decl, flags)

            pretty_messages = "\n".join(messages)
            if errors > 0:
                results.append(
                    {"decl": decl, "error": f"Failed to parse:\n{pretty_messages}"}
                )
            else:
                results.append({"decl": decl, "ok": True})
        except Exception as e:
            results.append({"decl": decl, "error": str(e)})

    return results


# ============================================================================
# Structure Operations
# ============================================================================


@tool
@idasync
def read_struct(queries: list[StructRead] | StructRead) -> list[dict]:
    """Reads struct type definition and parses actual memory values at the
    given address as instances of that struct type.

    If struct name is not provided, attempts to auto-detect from address.
    Auto-detection only works if IDA already has type information applied
    at that address

    Returns struct layout with actual memory values for each field.
    """

    queries = normalize_dict_list(queries)

    results = []
    for query in queries:
        addr_str = query.get("addr", "")
        struct_name = query.get("struct", "")

        try:
            # Parse address - this is required
            if not addr_str:
                results.append(
                    {
                        "addr": None,
                        "struct": struct_name,
                        "members": None,
                        "error": "Address is required for reading struct fields",
                    }
                )
                continue

            # Try to parse as address, then try name resolution
            try:
                addr = parse_address(addr_str)
            except Exception:
                addr = idaapi.get_name_ea(idaapi.BADADDR, addr_str)
                if addr == idaapi.BADADDR:
                    results.append(
                        {
                            "addr": addr_str,
                            "struct": struct_name,
                            "members": None,
                            "error": f"Failed to resolve address: {addr_str}",
                        }
                    )
                    continue

            # Auto-detect struct type from address if not provided
            if not struct_name:
                tif_auto = ida_typeinf.tinfo_t()
                if ida_nalt.get_tinfo(tif_auto, addr) and tif_auto.is_udt():
                    struct_name = tif_auto.get_type_name()

            if not struct_name:
                results.append(
                    {
                        "addr": addr_str,
                        "struct": None,
                        "members": None,
                        "error": "No struct specified and could not auto-detect from address",
                    }
                )
                continue

            tif = ida_typeinf.tinfo_t()
            if not tif.get_named_type(None, struct_name):
                results.append(
                    {
                        "addr": addr_str,
                        "struct": struct_name,
                        "members": None,
                        "error": f"Struct '{struct_name}' not found",
                    }
                )
                continue

            udt_data = ida_typeinf.udt_type_data_t()
            if not tif.get_udt_details(udt_data):
                results.append(
                    {
                        "addr": addr_str,
                        "struct": struct_name,
                        "members": None,
                        "error": "Failed to get struct details",
                    }
                )
                continue

            members = []
            for member in udt_data:
                offset = member.begin() // 8
                member_type = member.type._print()
                member_name = member.name
                member_size = member.type.get_size()

                # Read memory value at member address
                member_addr = addr + offset
                try:
                    if member.type.is_ptr():
                        is_64bit = (
                            ida_ida.inf_is_64bit()
                            if ida_major >= 9
                            else idaapi.get_inf_structure().is_64bit()
                        )
                        if is_64bit:
                            value = idaapi.get_qword(member_addr)
                            value_str = f"0x{value:016X}"
                        else:
                            value = idaapi.get_dword(member_addr)
                            value_str = f"0x{value:08X}"
                    elif member_size == 1:
                        value = idaapi.get_byte(member_addr)
                        value_str = f"0x{value:02X} ({value})"
                    elif member_size == 2:
                        value = idaapi.get_word(member_addr)
                        value_str = f"0x{value:04X} ({value})"
                    elif member_size == 4:
                        value = idaapi.get_dword(member_addr)
                        value_str = f"0x{value:08X} ({value})"
                    elif member_size == 8:
                        value = idaapi.get_qword(member_addr)
                        value_str = f"0x{value:016X} ({value})"
                    else:
                        bytes_data = []
                        for i in range(min(member_size, 16)):
                            try:
                                bytes_data.append(
                                    f"{idaapi.get_byte(member_addr + i):02X}"
                                )
                            except Exception:
                                break
                        value_str = f"[{' '.join(bytes_data)}{'...' if member_size > 16 else ''}]"
                except Exception:
                    value_str = "<failed to read>"

                member_info = {
                    "offset": f"0x{offset:08X}",
                    "type": member_type,
                    "name": member_name,
                    "size": member_size,
                    "value": value_str,
                }

                members.append(member_info)

            results.append(
                {"addr": addr_str, "struct": struct_name, "members": members}
            )
        except Exception as e:
            results.append(
                {
                    "addr": addr_str,
                    "struct": struct_name,
                    "members": None,
                    "error": str(e),
                }
            )

    return results


@tool
@idasync
def search_structs(
    filter: Annotated[
        str, "Case-insensitive substring to search for in structure names"
    ],
) -> list[dict]:
    """Search structs"""
    results = []
    limit = ida_typeinf.get_ordinal_limit()

    for ordinal in range(1, limit):
        tif = ida_typeinf.tinfo_t()
        if tif.get_numbered_type(None, ordinal):
            type_name: str = tif.get_type_name()
            if type_name and filter.lower() in type_name.lower():
                if tif.is_udt():
                    udt_data = ida_typeinf.udt_type_data_t()
                    cardinality = 0
                    if tif.get_udt_details(udt_data):
                        cardinality = udt_data.size()

                    results.append(
                        {
                            "name": type_name,
                            "size": tif.get_size(),
                            "cardinality": cardinality,
                            "is_union": (
                                udt_data.is_union
                                if tif.get_udt_details(udt_data)
                                else False
                            ),
                            "ordinal": ordinal,
                        }
                    )

    return results


# ============================================================================
# Type Inference & Application
# ============================================================================


@tool
@idasync
def set_type(edits: list[TypeEdit] | TypeEdit) -> list[dict]:
    """Apply types (function/global/local/stack)"""

    def parse_addr_type(s: str) -> dict:
        # Support "addr:typename" format (auto-detects kind)
        if ":" in s:
            parts = s.split(":", 1)
            return {"addr": parts[0].strip(), "ty": parts[1].strip()}
        # Just typename without address (invalid)
        return {"ty": s.strip()}

    edits = normalize_dict_list(edits, parse_addr_type)
    results = []

    for edit in edits:
        try:
            # Auto-detect kind if not provided
            kind = edit.get("kind")
            if not kind:
                if "signature" in edit:
                    kind = "function"
                elif "variable" in edit:
                    kind = "local"
                elif "addr" in edit:
                    # Check if address points to a function
                    try:
                        addr = parse_address(edit["addr"])
                        func = idaapi.get_func(addr)
                        if func and "name" in edit and "ty" in edit:
                            kind = "stack"
                        else:
                            kind = "global"
                    except Exception:
                        kind = "global"
                else:
                    kind = "global"

            if kind == "function":
                func = idaapi.get_func(parse_address(edit["addr"]))
                if not func:
                    results.append({"edit": edit, "error": "Function not found"})
                    continue

                tif = ida_typeinf.tinfo_t(edit["signature"], None, ida_typeinf.PT_SIL)
                if not tif.is_func():
                    results.append({"edit": edit, "error": "Not a function type"})
                    continue

                success = ida_typeinf.apply_tinfo(
                    func.start_ea, tif, ida_typeinf.PT_SIL
                )
                results.append(
                    {
                        "edit": edit,
                        "ok": success,
                        "error": None if success else "Failed to apply type",
                    }
                )

            elif kind == "global":
                ea = idaapi.get_name_ea(idaapi.BADADDR, edit.get("name", ""))
                if ea == idaapi.BADADDR:
                    ea = parse_address(edit["addr"])

                tif = get_type_by_name(edit["ty"])
                success = ida_typeinf.apply_tinfo(ea, tif, ida_typeinf.PT_SIL)
                results.append(
                    {
                        "edit": edit,
                        "ok": success,
                        "error": None if success else "Failed to apply type",
                    }
                )

            elif kind == "local":
                func = idaapi.get_func(parse_address(edit["addr"]))
                if not func:
                    results.append({"edit": edit, "error": "Function not found"})
                    continue

                new_tif = ida_typeinf.tinfo_t(edit["ty"], None, ida_typeinf.PT_SIL)
                modifier = my_modifier_t(edit["variable"], new_tif)
                success = ida_hexrays.modify_user_lvars(func.start_ea, modifier)
                results.append(
                    {
                        "edit": edit,
                        "ok": success,
                        "error": None if success else "Failed to apply type",
                    }
                )

            elif kind == "stack":
                func = idaapi.get_func(parse_address(edit["addr"]))
                if not func:
                    results.append({"edit": edit, "error": "No function found"})
                    continue

                frame_tif = ida_typeinf.tinfo_t()
                if not ida_frame.get_func_frame(frame_tif, func):
                    results.append({"edit": edit, "error": "No frame"})
                    continue

                idx, udm = frame_tif.get_udm(edit["name"])
                if not udm:
                    results.append({"edit": edit, "error": f"{edit['name']} not found"})
                    continue

                tid = frame_tif.get_udm_tid(idx)
                udm = ida_typeinf.udm_t()
                frame_tif.get_udm_by_tid(udm, tid)
                offset = udm.offset // 8

                tif = get_type_by_name(edit["ty"])
                success = ida_frame.set_frame_member_type(func, offset, tif)
                results.append(
                    {
                        "edit": edit,
                        "ok": success,
                        "error": None if success else "Failed to set type",
                    }
                )

            else:
                results.append({"edit": edit, "error": f"Unknown kind: {kind}"})

        except Exception as e:
            results.append({"edit": edit, "error": str(e)})

    return results


@tool
@idasync
def infer_types(
    addrs: Annotated[list[str] | str, "Addresses to infer types for"],
) -> list[dict]:
    """Infer types"""
    addrs = normalize_list_input(addrs)
    results = []

    for addr in addrs:
        try:
            ea = parse_address(addr)
            tif = ida_typeinf.tinfo_t()

            # Try Hex-Rays inference
            if ida_hexrays.init_hexrays_plugin() and ida_hexrays.guess_tinfo(tif, ea):
                results.append(
                    {
                        "addr": addr,
                        "inferred_type": str(tif),
                        "method": "hexrays",
                        "confidence": "high",
                    }
                )
                continue

            # Try getting existing type info
            if ida_nalt.get_tinfo(tif, ea):
                results.append(
                    {
                        "addr": addr,
                        "inferred_type": str(tif),
                        "method": "existing",
                        "confidence": "high",
                    }
                )
                continue

            # Try to guess from size
            size = ida_bytes.get_item_size(ea)
            if size > 0:
                type_guess = {
                    1: "uint8_t",
                    2: "uint16_t",
                    4: "uint32_t",
                    8: "uint64_t",
                }.get(size, f"uint8_t[{size}]")

                results.append(
                    {
                        "addr": addr,
                        "inferred_type": type_guess,
                        "method": "size_based",
                        "confidence": "low",
                    }
                )
                continue

            results.append(
                {
                    "addr": addr,
                    "inferred_type": None,
                    "method": None,
                    "confidence": "none",
                }
            )

        except Exception as e:
            results.append(
                {
                    "addr": addr,
                    "inferred_type": None,
                    "method": None,
                    "confidence": "none",
                    "error": str(e),
                }
            )

    return results

```

`src/ida_pro_mcp/ida_mcp/framework.py`:

```py
"""IDA Pro MCP Test Framework

This module provides a custom test framework for testing IDA MCP tools.
Tests can be defined inline or in separate test files using the @test decorator.

Usage from IDA console:
    from ida_mcp.tests import run_tests
    run_tests()                    # Run all tests
    run_tests(category="api_core") # Run specific category
    run_tests(pattern="*meta*")    # Run tests matching pattern

Usage from command line:
    ida-mcp-test tests/crackme03.elf
    ida-mcp-test tests/crackme03.elf --category api_core
    ida-mcp-test tests/crackme03.elf --pattern "*meta*"
"""

import fnmatch
import time
import traceback
from dataclasses import dataclass, field
from typing import Any, Callable, Literal, Optional


# ============================================================================
# Test Registry
# ============================================================================


@dataclass
class TestInfo:
    """Information about a registered test."""

    func: Callable
    binary: str  # Specific binary this test applies to
    module: str  # Auto-extracted category: "api_core", "api_analysis", etc.
    skip: bool = False


# Global test registry: name -> TestInfo
TESTS: dict[str, TestInfo] = {}


def test(*, binary: str = "", skip: bool = False) -> Callable:
    """Decorator to register a test function.

    Args:
        binary: Name of the specific binary this test applies to
        skip: If True, test will be skipped

    Example:
        @test()
        def test_idb_meta():
            meta = idb_meta()
            assert_has_keys(meta, "path", "module")

        @test(skip=True)
        def test_broken_feature():
            # This test is skipped
            pass

        @test(binary="crackme03.elf")
        def test_crackme_specific():
            # Only runs for crackme03.elf
            pass
    """

    def decorator(func: Callable) -> Callable:
        # Extract module category from function's module name
        # Handles both inline tests (api_core) and separate test files (test_api_core)
        # e.g., "ida_pro_mcp.ida_mcp.api_core" -> "api_core"
        # e.g., "ida_pro_mcp.ida_mcp.tests.test_api_core" -> "api_core"
        module_name = func.__module__
        if "." in module_name:
            category = module_name.rsplit(".", 1)[-1]
        else:
            category = module_name

        # Remove "test_" prefix if present (for separate test files)
        if category.startswith("test_"):
            category = category[5:]

        # Register the test
        TESTS[func.__name__] = TestInfo(
            func=func,
            binary=binary,
            module=category,
            skip=skip,
        )
        return func

    return decorator


# ============================================================================
# Test Results
# ============================================================================


@dataclass
class TestResult:
    """Result of a single test execution."""

    name: str
    category: str
    status: Literal["passed", "failed", "skipped"]
    duration: float = 0.0
    error: Optional[str] = None
    traceback: Optional[str] = None


@dataclass
class TestResults:
    """Aggregate results of a test run."""

    passed: int = 0
    failed: int = 0
    skipped: int = 0
    total_time: float = 0.0
    results: list[TestResult] = field(default_factory=list)

    def add(self, result: TestResult) -> None:
        """Add a test result and update counts."""
        self.results.append(result)
        if result.status == "passed":
            self.passed += 1
        elif result.status == "failed":
            self.failed += 1
        elif result.status == "skipped":
            self.skipped += 1


# ============================================================================
# Assertion Helpers
# ============================================================================


def assert_valid_address(addr: str) -> None:
    """Assert addr is a valid hex string starting with 0x."""
    assert isinstance(addr, str), f"Expected string, got {type(addr).__name__}"
    assert addr.startswith("0x") or addr.startswith("-0x"), (
        f"Expected hex address, got {addr!r}"
    )
    # Verify it's a valid hex number
    try:
        int(addr, 16)
    except ValueError:
        raise AssertionError(f"Invalid hex address: {addr!r}")


def assert_has_keys(d: dict, *keys: str) -> None:
    """Assert dict has all specified keys."""
    assert isinstance(d, dict), f"Expected dict, got {type(d).__name__}"
    missing = [k for k in keys if k not in d]
    assert not missing, f"Missing keys: {missing}"


def assert_non_empty(value: Any) -> None:
    """Assert value is not None and not empty."""
    assert value is not None, "Value is None"
    if hasattr(value, "__len__"):
        assert len(value) > 0, f"Value is empty: {value!r}"


def assert_is_list(value: Any, min_length: int = 0) -> None:
    """Assert value is a list with at least min_length items."""
    assert isinstance(value, list), f"Expected list, got {type(value).__name__}"
    assert len(value) >= min_length, (
        f"Expected at least {min_length} items, got {len(value)}"
    )


def assert_all_have_keys(items: list[dict], *keys: str) -> None:
    """Assert all dicts in list have specified keys."""
    assert_is_list(items)
    for i, item in enumerate(items):
        assert isinstance(item, dict), f"Item {i} is not a dict: {type(item).__name__}"
        missing = [k for k in keys if k not in item]
        assert not missing, f"Item {i} missing keys: {missing}"


# ============================================================================
# Test Configuration
# ============================================================================

# Default sample size for deterministic sampling helpers
# Can be overridden by test runner via set_sample_size()
_sample_size: int = 5


def set_sample_size(n: int) -> None:
    """Set the sample size for deterministic sampling helpers.

    Called by test runner to configure how many items to sample.
    """
    global _sample_size
    _sample_size = max(1, n)


def get_sample_size() -> int:
    """Get the current sample size."""
    return _sample_size


# ============================================================================
# Test Data Helpers
# ============================================================================


def get_any_function() -> Optional[str]:
    """Returns address of first function, or None if no functions.

    Must be called from within IDA context.
    """
    import idautils

    for ea in idautils.Functions():
        return hex(ea)
    return None


def get_any_string() -> Optional[str]:
    """Returns address of first string, or None if no strings.

    Must be called from within IDA context.
    """
    import idaapi

    for i in range(idaapi.get_strlist_qty()):
        si = idaapi.string_info_t()
        if idaapi.get_strlist_item(si, i):
            return hex(si.ea)
    return None


def get_first_segment() -> Optional[tuple[str, str]]:
    """Returns (start_addr, end_addr) of first segment, or None.

    Must be called from within IDA context.
    """
    import idaapi
    import idautils

    for seg_ea in idautils.Segments():
        seg = idaapi.getseg(seg_ea)
        if seg:
            return (hex(seg.start_ea), hex(seg.end_ea))
    return None


def _deterministic_sample(items: list, n: int) -> list:
    """Select n items deterministically based on binary name.

    Uses hash of (binary_name, item_index) for reproducible but varied selection.
    """
    import hashlib

    if len(items) <= n:
        return items

    binary_name = get_current_binary_name()

    # Create (hash, item) pairs for sorting
    def item_hash(idx: int) -> int:
        key = f"{binary_name}:{idx}".encode()
        return int(hashlib.md5(key).hexdigest(), 16)

    indexed = [(item_hash(i), item) for i, item in enumerate(items)]
    indexed.sort(key=lambda x: x[0])

    return [item for _, item in indexed[:n]]


def get_n_functions(n: Optional[int] = None) -> list[str]:
    """Get N function addresses, deterministically selected.

    Selection is based on binary name for reproducibility across runs.
    Returns up to N addresses (fewer if binary has fewer functions).

    Args:
        n: Number of functions to return. Defaults to global sample_size.
    """
    import idautils

    if n is None:
        n = _sample_size

    all_funcs = [hex(ea) for ea in idautils.Functions()]
    return _deterministic_sample(all_funcs, n)


def get_n_strings(n: Optional[int] = None) -> list[str]:
    """Get N string addresses, deterministically selected.

    Args:
        n: Number of strings to return. Defaults to global sample_size.
    """
    import idaapi

    if n is None:
        n = _sample_size

    all_strings = []
    for i in range(idaapi.get_strlist_qty()):
        si = idaapi.string_info_t()
        if idaapi.get_strlist_item(si, i):
            all_strings.append(hex(si.ea))

    return _deterministic_sample(all_strings, n)


def get_data_address() -> Optional[str]:
    """Get an address in a data segment (not code).

    Useful for testing error paths when code address is expected.
    """
    import idaapi
    import idautils

    for seg_ea in idautils.Segments():
        seg = idaapi.getseg(seg_ea)
        if seg and not (seg.perm & idaapi.SEGPERM_EXEC):
            # Return first address in non-executable segment
            return hex(seg.start_ea)
    return None


def get_unmapped_address() -> str:
    """Get an address that is not mapped in the binary.

    Useful for testing error paths for invalid addresses.
    """
    return "0xDEADBEEFDEADBEEF"


def get_functions_with_calls() -> list[str]:
    """Get functions that contain call instructions (have callees).

    Useful for testing callees() on functions that actually call others.
    """
    import idaapi
    import idautils

    result = []
    for func_ea in idautils.Functions():
        func = idaapi.get_func(func_ea)
        if not func:
            continue

        # Check if function contains any call instructions
        has_call = False
        for head in idautils.Heads(func.start_ea, func.end_ea):
            insn = idaapi.insn_t()
            if idaapi.decode_insn(insn, head) > 0:
                if insn.itype in [idaapi.NN_call, idaapi.NN_callfi, idaapi.NN_callni]:
                    has_call = True
                    break

        if has_call:
            result.append(hex(func_ea))

    return _deterministic_sample(result, _sample_size)


def get_functions_with_callers() -> list[str]:
    """Get functions that are called by other functions (have callers).

    Useful for testing callers() on functions that are actually called.
    """
    import idaapi
    import idautils

    result = []
    for func_ea in idautils.Functions():
        # Check if this function has any code references to it
        has_caller = False
        for xref in idautils.XrefsTo(func_ea, 0):
            if xref.iscode:
                caller_func = idaapi.get_func(xref.frm)
                if caller_func and caller_func.start_ea != func_ea:
                    has_caller = True
                    break

        if has_caller:
            result.append(hex(func_ea))

    return _deterministic_sample(result, _sample_size)


# ============================================================================
# Test Runner
# ============================================================================


def get_current_binary_name() -> str:
    """Get the name of the currently loaded binary.

    Returns:
        The filename of the current IDB (e.g., "crackme03.elf")
    """
    import idaapi

    return idaapi.get_root_filename()


def run_tests(
    pattern: str = "*",
    category: str = "*",
    verbose: bool = True,
    stop_on_failure: bool = False,
) -> TestResults:
    """Run registered tests and return results.

    Args:
        pattern: Glob pattern to filter test names (e.g., "*meta*")
        category: Filter by module category (e.g., "api_core", "api_analysis")
        verbose: Print progress and results
        stop_on_failure: Stop at first failure

    Returns:
        TestResults with pass/fail counts and individual results
    """
    results = TestResults()
    start_time = time.time()

    # Get current binary name for filtering binary-specific tests
    current_binary = get_current_binary_name()

    # Group tests by category
    tests_by_category: dict[str, list[tuple[str, TestInfo]]] = {}
    for name, info in sorted(TESTS.items()):
        # Filter by pattern
        if not fnmatch.fnmatch(name, pattern):
            continue
        # Filter by category
        if category != "*" and info.module != category:
            continue
        # Filter by binary - skip tests for other binaries
        if info.binary and info.binary != current_binary:
            continue

        if info.module not in tests_by_category:
            tests_by_category[info.module] = []
        tests_by_category[info.module].append((name, info))

    if not tests_by_category:
        if verbose:
            print(f"No tests found matching pattern={pattern!r}, category={category!r}")
        return results

    # Print header
    if verbose:
        print("=" * 80)
        print("IDA Pro MCP Test Runner")
        print("=" * 80)
        print()

    # Run tests by category
    for cat_name in sorted(tests_by_category.keys()):
        tests = tests_by_category[cat_name]
        if verbose:
            print(f"[{cat_name}] Running {len(tests)} tests...")

        for name, info in tests:
            result = _run_single_test(name, info, verbose)
            results.add(result)

            if result.status == "failed" and stop_on_failure:
                if verbose:
                    print()
                    print("Stopping on first failure.")
                break

        if stop_on_failure and results.failed > 0:
            break

        if verbose:
            print()

    results.total_time = time.time() - start_time

    # Print summary
    if verbose:
        print("=" * 80)
        status_parts = []
        if results.passed:
            status_parts.append(f"{results.passed} passed")
        if results.failed:
            status_parts.append(f"{results.failed} failed")
        if results.skipped:
            status_parts.append(f"{results.skipped} skipped")
        print(f"Results: {', '.join(status_parts)} ({results.total_time:.2f}s)")
        print("=" * 80)

    return results


def _run_single_test(name: str, info: TestInfo, verbose: bool) -> TestResult:
    """Run a single test and return the result."""
    # Handle skipped tests
    if info.skip:
        if verbose:
            print(f"  - {name} (skipped)")
        return TestResult(
            name=name,
            category=info.module,
            status="skipped",
        )

    # Run the test
    start_time = time.time()
    try:
        info.func()
        duration = time.time() - start_time

        if verbose:
            print(f"  + {name} ({duration:.2f}s)")

        return TestResult(
            name=name,
            category=info.module,
            status="passed",
            duration=duration,
        )

    except Exception as e:
        duration = time.time() - start_time
        error_msg = str(e)
        tb = traceback.format_exc()

        if verbose:
            print(f"  x {name} ({duration:.2f}s)")
            print(f"    {type(e).__name__}: {error_msg}")
            print()
            # Indent traceback
            for line in tb.strip().split("\n"):
                print(f"    {line}")
            print()

        return TestResult(
            name=name,
            category=info.module,
            status="failed",
            duration=duration,
            error=f"{type(e).__name__}: {error_msg}",
            traceback=tb,
        )

```

`src/ida_pro_mcp/ida_mcp/http.py`:

```py
import html
import json
import re
import ida_netnode
from urllib.parse import urlparse, parse_qs
from typing import TypeVar, cast
from http.server import HTTPServer

from .sync import idasync
from .rpc import (
    McpRpcRegistry,
    McpHttpRequestHandler,
    MCP_SERVER,
    MCP_UNSAFE,
    get_cached_output,
)


T = TypeVar("T")


@idasync
def config_json_get(key: str, default: T) -> T:
    node = ida_netnode.netnode(f"$ ida_mcp.{key}")
    json_blob: bytes | None = node.getblob(0, "C")
    if json_blob is None:
        return default
    try:
        return json.loads(json_blob)
    except Exception as e:
        print(
            f"[WARNING] Invalid JSON stored in netnode '{key}': '{json_blob}' from netnode: {e}"
        )
        return default


@idasync
def config_json_set(key: str, value):
    node = ida_netnode.netnode(f"$ ida_mcp.{key}", 0, True)
    json_blob = json.dumps(value).encode("utf-8")
    node.setblob(json_blob, 0, "C")


def handle_enabled_tools(registry: McpRpcRegistry, config_key: str):
    """Changed to registry to enable configured tools, returns original tools."""
    original_tools = registry.methods.copy()
    enabled_tools = config_json_get(
        config_key, {name: True for name in original_tools.keys()}
    )
    new_tools = [name for name in original_tools if name not in enabled_tools]

    removed_tools = [name for name in enabled_tools if name not in original_tools]
    if removed_tools:
        for name in removed_tools:
            enabled_tools.pop(name)

    if new_tools:
        enabled_tools.update({name: True for name in new_tools})
        config_json_set(config_key, enabled_tools)

    registry.methods = {
        name: func for name, func in original_tools.items() if enabled_tools.get(name)
    }
    return original_tools


DEFAULT_CORS_POLICY = "local"


def get_cors_policy(port: int) -> str:
    """Retrieve the current CORS policy from configuration."""
    match config_json_get("cors_policy", DEFAULT_CORS_POLICY):
        case "unrestricted":
            return "*"
        case "local":
            return "127.0.0.1 localhost"
        case "direct":
            return f"http://127.0.0.1:{port} http://localhost:{port}"
        case _:
            return "*"


ORIGINAL_TOOLS = handle_enabled_tools(MCP_SERVER.tools, "enabled_tools")


class IdaMcpHttpRequestHandler(McpHttpRequestHandler):
    def __init__(self, request, client_address, server):
        super().__init__(request, client_address, server)
        self.update_cors_policy()

    def update_cors_policy(self):
        match config_json_get("cors_policy", DEFAULT_CORS_POLICY):
            case "unrestricted":
                self.mcp_server.cors_allowed_origins = "*"
            case "local":
                self.mcp_server.cors_allowed_origins = self.mcp_server.cors_localhost
            case "direct":
                self.mcp_server.cors_allowed_origins = None

    def do_POST(self):
        """Handles POST requests."""
        if urlparse(self.path).path == "/config":
            if not self._check_origin():
                return
            self._handle_config_post()
        else:
            super().do_POST()

    def do_GET(self):
        """Handles GET requests."""
        parsed = urlparse(self.path)
        path = parsed.path

        if path == "/config.html":
            if not self._check_host():
                return
            self._handle_config_get()
            return

        # Handle output download requests
        output_match = re.match(r"^/output/([a-f0-9-]+)\.(\w+)$", path)
        if output_match:
            self._handle_output_download(output_match.group(1), output_match.group(2))
            return

        super().do_GET()

    def _handle_output_download(self, output_id: str, extension: str):
        """Handle download of cached output data."""
        data = get_cached_output(output_id)
        if data is None:
            self.send_error(404, "Output not found or expired")
            return

        if extension == "json":
            content = json.dumps(data, indent=2)
        elif isinstance(data, dict) and "code" in data:
            content = str(data["code"])
        elif isinstance(data, list) and data and isinstance(data[0], dict):
            content = "\n\n".join(
                str(item.get("code", item.get("asm", item.get("lines", ""))))
                for item in data
            )
        else:
            content = json.dumps(data, indent=2)

        body = content.encode("utf-8")
        self.send_response(200)
        content_type = "application/json" if extension == "json" else "text/plain"
        self.send_header("Content-Type", f"{content_type}; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.send_header(
            "Content-Disposition", f'attachment; filename="{output_id}.{extension}"'
        )
        self.end_headers()
        self.wfile.write(body)

    @property
    def server_port(self) -> int:
        return cast(HTTPServer, self.server).server_port

    def _check_origin(self) -> bool:
        """
        Prevents CSRF and DNS rebinding attacks by ensuring POST requests
        originate from pages served by this server, not external websites.
        """
        origin = self.headers.get("Origin")
        port = self.server_port
        if origin not in (f"http://127.0.0.1:{port}", f"http://localhost:{port}"):
            self.send_error(403, "Invalid Origin")
            return False
        return True

    def _check_host(self) -> bool:
        """
        Prevents DNS rebinding attacks where an attacker's domain (e.g., evil.com)
        resolves to 127.0.0.1, allowing their page to read localhost resources.
        """
        host = self.headers.get("Host")
        port = self.server_port
        if host not in (f"127.0.0.1:{port}", f"localhost:{port}"):
            self.send_error(403, "Invalid Host")
            return False
        return True

    def _send_html(self, status: int, text: str):
        """
        Prevents clickjacking by blocking iframes (X-Frame-Options for older
        browsers, frame-ancestors for modern ones). Other CSP directives
        provide defense-in-depth against content injection attacks.
        """
        body = text.encode("utf-8")
        self.send_response(status)
        self.send_header("Content-Type", "text/html; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.send_header("X-Frame-Options", "DENY")
        self.send_header(
            "Content-Security-Policy",
            "; ".join(
                [
                    "frame-ancestors 'none'",
                    "script-src 'self' 'unsafe-inline'",
                    "style-src 'self' 'unsafe-inline'",
                    "default-src 'self'",
                    "form-action 'self'",
                ]
            ),
        )
        self.end_headers()
        self.wfile.write(body)

    def _handle_config_get(self):
        """Sends the configuration page with checkboxes."""
        cors_policy = config_json_get("cors_policy", DEFAULT_CORS_POLICY)

        body = """<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IDA Pro MCP Config</title>
  <style>
:root {
  --bg: #ffffff;
  --text: #1a1a1a;
  --border: #e0e0e0;
  --accent: #0066cc;
  --hover: #f5f5f5;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg: #1a1a1a;
    --text: #e0e0e0;
    --border: #333333;
    --accent: #4da6ff;
    --hover: #2a2a2a;
  }
}

* {
  box-sizing: border-box;
}

body {
  font-family: system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  max-width: 800px;
  margin: 2rem auto;
  padding: 1rem;
  line-height: 1.4;
}

h1 {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  border-bottom: 1px solid var(--border);
  padding-bottom: 0.5rem;
}

h2 {
  font-size: 1.1rem;
  margin-top: 1.5rem;
  margin-bottom: 0.5rem;
}

label {
  display: block;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  cursor: pointer;
}

label:hover {
  background: var(--hover);
}

input[type="checkbox"],
input[type="radio"] {
  margin-right: 0.5rem;
  accent-color: var(--accent);
}

input[type="submit"] {
  margin-top: 1rem;
  padding: 0.6rem 1.5rem;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
}

input[type="submit"]:hover {
  opacity: 0.9;
}

.tooltip {
  border-bottom: 1px dotted var(--text);
}
  </style>
  <script defer>
  function setTools(mode) {
    document.querySelectorAll('input[data-tool]').forEach(cb => {
        if (mode === 'all') cb.checked = true;
        else if (mode === 'none') cb.checked = false;
        else if (mode === 'disable-unsafe' && cb.hasAttribute('data-unsafe')) cb.checked = false;
    });
  }
  </script>
</head>
<body>
<h1>IDA Pro MCP Config</h1>

<form method="post" action="/config">

<h2>API Access</h2>
"""
        cors_options = [
            (
                "unrestricted",
                "⛔ Unrestricted",
                "Any website can make requests to this server. A malicious site you visit could access or modify your IDA database.",
            ),
            (
                "local",
                "🏠 Local apps only",
                "Only web apps running on localhost can connect. Remote websites are blocked, but local development tools work.",
            ),
            (
                "direct",
                "🔒 Direct connections only",
                "Browser-based requests are blocked. Only direct clients like curl, MCP tools, or Claude Desktop can connect.",
            ),
        ]
        for value, label, tooltip in cors_options:
            checked = "checked" if cors_policy == value else ""
            body += f'<label><input type="radio" name="cors_policy" value="{html.escape(value)}" {checked}><span class="tooltip" title="{html.escape(tooltip)}">{html.escape(label)}</span></label>'
        body += "<br><input type='submit' value='Save'>"

        quick_select = """<p style="font-size: 0.9rem; margin: 0.5rem 0;">
  Select:
  <a href="#" onclick="setTools('all'); return false;">All</a> ·
  <a href="#" onclick="setTools('none'); return false;">None</a> ·
  <a href="#" onclick="setTools('disable-unsafe'); return false;">Disable unsafe</a>
</p>"""

        body += "<h2>Enabled Tools</h2>"
        body += quick_select
        for name, func in ORIGINAL_TOOLS.items():
            description = (
                (func.__doc__ or "No description").strip().splitlines()[0].strip()
            )
            unsafe_prefix = "⚠️ " if name in MCP_UNSAFE else ""
            checked = " checked" if name in self.mcp_server.tools.methods else ""
            unsafe_attr = " data-unsafe" if name in MCP_UNSAFE else ""
            body += f"<label><input type='checkbox' name='{html.escape(name)}' value='{html.escape(name)}'{checked}{unsafe_attr} data-tool>{unsafe_prefix}{html.escape(name)}: {html.escape(description)}</label>"
        body += quick_select
        body += "<br><input type='submit' value='Save'>"
        body += "</form></body></html>"
        self._send_html(200, body)

    def _handle_config_post(self):
        """Handles the configuration form submission."""
        # Validate Content-Type
        content_type = self.headers.get("content-type", "").split(";")[0].strip()
        if content_type != "application/x-www-form-urlencoded":
            self.send_error(400, f"Unsupported Content-Type: {content_type}")
            return

        # Parse the form data
        length = int(self.headers.get("content-length", "0"))
        postvars = parse_qs(self.rfile.read(length).decode("utf-8"))

        # Update CORS policy
        cors_policy = postvars.get("cors_policy", [DEFAULT_CORS_POLICY])[0]
        config_json_set("cors_policy", cors_policy)
        self.update_cors_policy()

        # Update the server's tools
        enabled_tools = {name: name in postvars for name in ORIGINAL_TOOLS.keys()}
        self.mcp_server.tools.methods = {
            name: func
            for name, func in ORIGINAL_TOOLS.items()
            if enabled_tools.get(name)
        }
        config_json_set("enabled_tools", enabled_tools)

        # Redirect back to the config page
        self.send_response(302)
        self.send_header("Location", "/config.html")
        self.end_headers()

```

`src/ida_pro_mcp/ida_mcp/rpc.py`:

```py
import json
import os
from typing import Any, Optional
from .zeromcp import McpRpcRegistry, McpServer, McpToolError, McpHttpRequestHandler

MCP_UNSAFE: set[str] = set()
MCP_EXTENSIONS: dict[str, set[str]] = {}  # group -> set of function names
MCP_SERVER = McpServer("ida-pro-mcp", extensions=MCP_EXTENSIONS)

# ============================================================================
# Output Size Limiting
# ============================================================================

OUTPUT_LIMIT_MAX_CHARS = 50000
OUTPUT_CACHE_MAX_SIZE = 100
_output_cache: dict[str, Any] = {}
_download_base_url: str = os.environ.get("IDA_MCP_URL", "http://127.0.0.1:13337")


def set_download_base_url(url: str) -> None:
    global _download_base_url
    _download_base_url = url.rstrip("/")


def get_download_base_url() -> str:
    return _download_base_url


def _generate_output_id() -> str:
    import uuid

    return str(uuid.uuid4())


OUTPUT_LIMIT_PREVIEW_ITEMS = 10
OUTPUT_LIMIT_PREVIEW_STR_LEN = 1000


def _truncate_value(value: Any, depth: int = 0) -> Any:
    if depth > 5:
        return value

    if isinstance(value, str) and len(value) > OUTPUT_LIMIT_PREVIEW_STR_LEN:
        return value[:OUTPUT_LIMIT_PREVIEW_STR_LEN] + f"... [{len(value)} chars total]"

    if isinstance(value, list):
        truncated_list = [
            _truncate_value(item, depth + 1)
            for item in value[:OUTPUT_LIMIT_PREVIEW_ITEMS]
        ]
        if len(value) > OUTPUT_LIMIT_PREVIEW_ITEMS:
            truncated_list.append(
                {
                    "_truncated": f"... and {len(value) - OUTPUT_LIMIT_PREVIEW_ITEMS} more items"
                }
            )
        return truncated_list

    if isinstance(value, dict):
        return {k: _truncate_value(v, depth + 1) for k, v in value.items()}

    return value


def _add_download_info(result: Any, output_id: str, total_chars: int) -> Any:
    download_url = f"{_download_base_url}/output/{output_id}.json"
    info = {
        "_output_truncated": True,
        "_total_chars": total_chars,
        "_output_id": output_id,
        "_download_url": download_url,
        "_download_hint": f"Output truncated. Run: curl -o .ida-mcp/{output_id}.json {download_url}",
    }

    if isinstance(result, dict):
        return {**result, **info}

    if isinstance(result, list) and result:
        result = list(result)
        if isinstance(result[0], dict):
            result[0] = {**result[0], **info}
        else:
            result.insert(0, info)
        return result

    return {"_preview": result, **info}


def get_cached_output(output_id: str) -> Optional[Any]:
    return _output_cache.get(output_id)


def _cache_output(output_id: str, data: Any) -> None:
    if len(_output_cache) >= OUTPUT_CACHE_MAX_SIZE:
        oldest_key = next(iter(_output_cache))
        del _output_cache[oldest_key]
    _output_cache[output_id] = data


def _install_tools_call_patch() -> None:
    original = MCP_SERVER.registry.methods["tools/call"]

    def patched(
        name: str, arguments: Optional[dict] = None, _meta: Optional[dict] = None
    ) -> dict:
        response = original(name, arguments, _meta)

        if response.get("isError"):
            return response

        structured = response.get("structuredContent")
        if structured is None:
            return response

        serialized = json.dumps(structured)
        if len(serialized) <= OUTPUT_LIMIT_MAX_CHARS:
            return response

        output_id = _generate_output_id()
        _cache_output(output_id, structured)

        preview = _truncate_value(structured)
        preview = _add_download_info(preview, output_id, len(serialized))

        return {
            "structuredContent": preview,
            "content": response.get("content", []),
            "isError": False,
        }

    MCP_SERVER.registry.methods["tools/call"] = patched


# Install the output limiting patch
_install_tools_call_patch()


# ============================================================================
# Decorators
# ============================================================================


def tool(func):
    return MCP_SERVER.tool(func)


def resource(uri):
    return MCP_SERVER.resource(uri)


def unsafe(func):
    MCP_UNSAFE.add(func.__name__)
    return func


def ext(group: str):
    """Mark a tool as belonging to an extension group.

    Tools in extension groups are hidden by default. Enable via ?ext=group query param.
    Example: @ext("dbg") marks debugger tools that require ?ext=dbg to be visible.
    """

    def decorator(func):
        if group not in MCP_EXTENSIONS:
            MCP_EXTENSIONS[group] = set()
        MCP_EXTENSIONS[group].add(func.__name__)
        return func

    return decorator


__all__ = [
    "McpRpcRegistry",
    "McpServer",
    "McpToolError",
    "McpHttpRequestHandler",
    "MCP_SERVER",
    "MCP_UNSAFE",
    "MCP_EXTENSIONS",
    "tool",
    "unsafe",
    "ext",
    "resource",
    "get_cached_output",
    "set_download_base_url",
    "get_download_base_url",
]

```

`src/ida_pro_mcp/ida_mcp/sync.py`:

```py
import logging
import queue
import functools
import os
import sys
import time
import idaapi
import idc
from .rpc import McpToolError
from .zeromcp.jsonrpc import get_current_cancel_event, RequestCancelledError

# ============================================================================
# IDA Synchronization & Error Handling
# ============================================================================

ida_major, ida_minor = map(int, idaapi.get_kernel_version().split("."))


class IDAError(McpToolError):
    def __init__(self, message: str):
        super().__init__(message)

    @property
    def message(self) -> str:
        return self.args[0]


class IDASyncError(Exception):
    pass


class CancelledError(RequestCancelledError):
    """Raised when a request is cancelled via notifications/cancelled."""

    pass


logger = logging.getLogger(__name__)
_TOOL_TIMEOUT_ENV = "IDA_MCP_TOOL_TIMEOUT_SEC"
_DEFAULT_TOOL_TIMEOUT_SEC = 15.0


def _get_tool_timeout_seconds() -> float:
    value = os.getenv(_TOOL_TIMEOUT_ENV, "").strip()
    if value == "":
        return _DEFAULT_TOOL_TIMEOUT_SEC
    try:
        return float(value)
    except ValueError:
        return _DEFAULT_TOOL_TIMEOUT_SEC


call_stack = queue.LifoQueue()


def _sync_wrapper(ff):
    """Call a function ff with a specific IDA safety_mode."""

    res_container = queue.Queue()

    def runned():
        if not call_stack.empty():
            last_func_name = call_stack.get()
            error_str = f"Call stack is not empty while calling the function {ff.__name__} from {last_func_name}"
            raise IDASyncError(error_str)

        call_stack.put((ff.__name__))
        # Enable batch mode for all synchronized operations
        old_batch = idc.batch(1)
        try:
            res_container.put(ff())
        except Exception as x:
            res_container.put(x)
        finally:
            idc.batch(old_batch)
            call_stack.get()

    idaapi.execute_sync(runned, idaapi.MFF_WRITE)
    res = res_container.get()
    if isinstance(res, Exception):
        raise res
    return res


def _normalize_timeout(value: object) -> float | None:
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def sync_wrapper(ff, timeout_override: float | None = None):
    """Wrapper to enable timeout and cancellation during IDA synchronization.

    Note: Batch mode is now handled in _sync_wrapper to ensure it's always
    applied consistently for all synchronized operations.
    """
    # Capture cancel event from thread-local before execute_sync
    cancel_event = get_current_cancel_event()

    timeout = timeout_override
    if timeout is None:
        timeout = _get_tool_timeout_seconds()
    if timeout > 0 or cancel_event is not None:

        def timed_ff():
            # Calculate deadline when execution starts on IDA main thread,
            # not when the request was queued (avoids stale deadlines)
            deadline = time.monotonic() + timeout if timeout > 0 else None

            def profilefunc(frame, event, arg):
                # Check cancellation first (higher priority)
                if cancel_event is not None and cancel_event.is_set():
                    raise CancelledError("Request was cancelled")
                if deadline is not None and time.monotonic() >= deadline:
                    raise IDASyncError(f"Tool timed out after {timeout:.2f}s")

            old_profile = sys.getprofile()
            sys.setprofile(profilefunc)
            try:
                return ff()
            finally:
                sys.setprofile(old_profile)

        timed_ff.__name__ = ff.__name__
        return _sync_wrapper(timed_ff)
    return _sync_wrapper(ff)


def idasync(f):
    """Run the function on the IDA main thread in write mode.

    This is the unified decorator for all IDA synchronization.
    Previously there were separate @idaread and @idawrite decorators,
    but since read-only operations in IDA might actually require write
    access (e.g., decompilation), we now use a single decorator.
    """

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        ff = functools.partial(f, *args, **kwargs)
        ff.__name__ = f.__name__
        timeout_override = _normalize_timeout(
            getattr(f, "__ida_mcp_timeout_sec__", None)
        )
        return sync_wrapper(ff, timeout_override)

    return wrapper


def tool_timeout(seconds: float):
    """Decorator to override per-tool timeout (seconds).

    IMPORTANT: Must be applied BEFORE @idasync (i.e., listed AFTER it)
    so the attribute exists when it captures the function in closure.

    Correct order:
        @tool
        @idasync
        @tool_timeout(90.0)  # innermost
        def my_func(...):
    """

    def decorator(func):
        setattr(func, "__ida_mcp_timeout_sec__", seconds)
        return func

    return decorator


def is_window_active():
    """Returns whether IDA is currently active."""
    # Source: https://github.com/OALabs/hexcopy-ida/blob/8b0b2a3021d7dc9010c01821b65a80c47d491b61/hexcopy.py#L30
    using_pyside6 = (ida_major > 9) or (ida_major == 9 and ida_minor >= 2)

    if using_pyside6:
        from PySide6 import QtWidgets
    else:
        from PyQt5 import QtWidgets

    app = QtWidgets.QApplication.instance()
    if app is None:
        return False
    return app.activeWindow() is not None

```

`src/ida_pro_mcp/ida_mcp/tests/__init__.py`:

```py
"""IDA Pro MCP Test Package.

This package contains test modules for each API module.
Tests are registered via the @test decorator from the framework module.
"""

# Import all test modules to register tests when the package is imported
from . import test_api_core
from . import test_api_analysis
from . import test_api_memory
from . import test_api_modify
from . import test_api_types
from . import test_api_stack
from . import test_api_resources

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_analysis.py`:

```py
"""Tests for api_analysis API functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_has_keys,
    assert_is_list,
    get_any_function,
    get_n_functions,
    get_data_address,
    get_unmapped_address,
    get_functions_with_calls,
    get_functions_with_callers,
)

# Import functions under test
from ..api_analysis import (
    decompile,
    disasm,
    xrefs_to,
    xrefs_to_field,
    callees,
    find_bytes,
    basic_blocks,
    find,
    export_funcs,
    callgraph,
)

# Import sync module for IDAError


# ============================================================================
# Tests for decompile
# ============================================================================


@test()
def test_decompile_valid_function():
    """decompile returns code for a valid function"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = decompile(fn_addr)
    assert_is_list(result, min_length=1)
    # Should have code or error
    r = result[0]
    assert_has_keys(r, "addr")
    # Either has code or has an error
    assert r.get("code") is not None or r.get("error") is not None


@test()
def test_decompile_invalid_address():
    """decompile handles invalid address gracefully"""
    result = decompile(get_unmapped_address())
    assert_is_list(result, min_length=1)
    # Should have an error
    assert result[0].get("error") is not None or result[0].get("code") is None


@test()
def test_decompile_batch():
    """decompile can handle multiple addresses"""
    addrs = get_n_functions(3)
    if len(addrs) < 2:
        return

    result = decompile(addrs)
    assert len(result) == len(addrs)


# ============================================================================
# Tests for disasm
# ============================================================================


@test()
def test_disasm_valid_function():
    """disasm returns assembly for a valid function"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = disasm(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr")
    # Should have asm output or error
    assert r.get("asm") is not None or r.get("error") is not None


@test()
def test_disasm_pagination():
    """disasm respects count parameter"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = disasm(fn_addr, count=10)
    assert_is_list(result, min_length=1)


@test()
def test_disasm_unmapped_address():
    """disasm handles unmapped address"""
    result = disasm(get_unmapped_address())
    assert_is_list(result, min_length=1)
    # Should have error or empty asm
    r = result[0]
    assert r.get("error") is not None or r.get("asm") == "" or r.get("asm") is None


@test()
def test_disasm_data_segment():
    """disasm handles data segment addresses"""
    data_addr = get_data_address()
    if not data_addr:
        return

    result = disasm(data_addr)
    assert_is_list(result, min_length=1)


# ============================================================================
# Tests for xrefs_to
# ============================================================================


@test()
def test_xrefs_to():
    """xrefs_to returns cross-references for a function"""
    fn_addrs = get_functions_with_callers()
    if not fn_addrs:
        # Fallback to any function
        fn_addr = get_any_function()
        if not fn_addr:
            return
    else:
        fn_addr = fn_addrs[0]

    result = xrefs_to(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "xrefs", "error")


@test()
def test_xrefs_to_invalid():
    """xrefs_to handles invalid address"""
    result = xrefs_to(get_unmapped_address())
    assert_is_list(result, min_length=1)
    # Should return empty xrefs or error
    r = result[0]
    assert_has_keys(r, "addr")


# ============================================================================
# Tests for xrefs_to_field
# ============================================================================


@test()
def test_xrefs_to_field_nonexistent_struct():
    """xrefs_to_field handles non-existent struct"""
    result = xrefs_to_field({"struct": "NonExistentStruct", "field": "nonexistent"})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert r.get("error") is not None


@test()
def test_xrefs_to_field_batch():
    """xrefs_to_field handles batch queries"""
    result = xrefs_to_field(
        [
            {"struct": "Struct1", "field": "field1"},
            {"struct": "Struct2", "field": "field2"},
        ]
    )
    assert_is_list(result, min_length=2)


# ============================================================================
# Tests for callees
# ============================================================================


@test()
def test_callees():
    """callees returns functions called by a function"""
    fn_addrs = get_functions_with_calls()
    if not fn_addrs:
        fn_addr = get_any_function()
        if not fn_addr:
            return
    else:
        fn_addr = fn_addrs[0]

    result = callees(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "callees", "error")


@test()
def test_callees_multiple():
    """callees handles multiple addresses"""
    addrs = get_n_functions(3)
    if len(addrs) < 2:
        return

    result = callees(addrs)
    assert len(result) == len(addrs)


@test()
def test_callees_invalid_address():
    """callees handles invalid address"""
    result = callees(get_unmapped_address())
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr")


# ============================================================================
# Tests for find_bytes
# ============================================================================


@test()
def test_find_bytes():
    """find_bytes can search for byte patterns"""
    # Search for common bytes that should exist
    result = find_bytes("00 00")
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "query", "matches", "error")


# ============================================================================
# Tests for basic_blocks
# ============================================================================


@test()
def test_basic_blocks():
    """basic_blocks returns blocks for a function"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = basic_blocks(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "blocks", "error")


# ============================================================================
# Tests for find
# ============================================================================


@test()
def test_find_string():
    """find can search for strings"""
    # Most binaries have some strings
    result = find("string", query="*")
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "query", "matches", "error")


@test()
def test_find_invalid_type():
    """find handles invalid search type"""
    result = find("invalid_type", query="test")
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error for invalid type
    assert r.get("error") is not None


# ============================================================================
# Tests for export_funcs
# ============================================================================


@test()
def test_export_funcs_json():
    """export_funcs returns JSON format"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = export_funcs(fn_addr, fmt="json")
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr")


@test()
def test_export_funcs_c_header():
    """export_funcs returns C header format"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = export_funcs(fn_addr, fmt="c_header")
    assert_is_list(result, min_length=1)


@test()
def test_export_funcs_invalid_address():
    """export_funcs handles invalid address"""
    result = export_funcs(get_unmapped_address())
    assert_is_list(result, min_length=1)


# ============================================================================
# Tests for callgraph
# ============================================================================


@test()
def test_callgraph():
    """callgraph returns call graph data"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = callgraph(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr")

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_core.py`:

```py
"""Tests for api_core API functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_has_keys,
    assert_is_list,
    assert_all_have_keys,
    get_any_function,
    get_data_address,
)

# Import functions under test
from ..api_core import (
    lookup_funcs,
    int_convert,
    list_funcs,
    list_globals,
    imports,
    find_regex,
)

# Import sync module for IDAError


# ============================================================================
# Tests for lookup_funcs
# ============================================================================


@test()
def test_lookup_funcs_by_address():
    """lookup_funcs can find function by address"""
    fn_addr = get_any_function()
    if not fn_addr:
        return  # Skip if no functions

    result = lookup_funcs(fn_addr)
    assert_is_list(result, min_length=1)
    assert result[0]["fn"] is not None
    assert result[0]["error"] is None
    assert_has_keys(result[0]["fn"], "addr", "name", "size")


@test()
def test_lookup_funcs_invalid():
    """lookup_funcs returns error for invalid address"""
    # Use an address that's unlikely to be a valid function
    result = lookup_funcs("0xDEADBEEFDEADBEEF")
    assert_is_list(result, min_length=1)
    assert result[0]["fn"] is None
    assert result[0]["error"] is not None


@test()
def test_lookup_funcs_wildcard():
    """lookup_funcs with '*' returns all functions"""
    result = lookup_funcs("*")
    assert_is_list(result, min_length=1)
    # All results should have query="*" and a function
    for r in result:
        assert r["query"] == "*"
        assert r["fn"] is not None


@test()
def test_lookup_funcs_empty():
    """lookup_funcs with empty string returns all functions"""
    result = lookup_funcs("")
    assert_is_list(result, min_length=1)
    assert result[0]["query"] == "*"


@test()
def test_lookup_funcs_malformed_hex():
    """lookup_funcs handles malformed hex address"""
    # This looks like an address but isn't valid hex
    result = lookup_funcs("0xZZZZ")
    assert_is_list(result, min_length=1)
    # Should return error since it's not a valid address or name
    assert result[0]["error"] is not None


@test()
def test_lookup_funcs_data_address():
    """lookup_funcs with valid address but not a function"""
    data_addr = get_data_address()
    if not data_addr:
        return  # Skip if no data segments

    result = lookup_funcs(data_addr)
    assert_is_list(result, min_length=1)
    # Should return "Not a function" error
    assert result[0]["fn"] is None
    assert "Not a function" in str(result[0]["error"]) or "Not found" in str(
        result[0]["error"]
    )


# ============================================================================
# Tests for int_convert
# ============================================================================


@test()
def test_int_convert():
    """int_convert properly converts numbers"""
    result = int_convert({"text": "0x41"})
    assert_is_list(result, min_length=1)
    assert result[0]["error"] is None
    assert result[0]["result"] is not None
    conv = result[0]["result"]
    assert_has_keys(conv, "decimal", "hexadecimal", "bytes", "binary")
    assert conv["decimal"] == "65"
    assert conv["hexadecimal"] == "0x41"
    assert conv["ascii"] == "A"


@test()
def test_int_convert_invalid_text():
    """int_convert handles invalid number text"""
    result = int_convert({"text": "not_a_number"})
    assert_is_list(result, min_length=1)
    assert result[0]["result"] is None
    assert result[0]["error"] is not None
    assert "Invalid number" in result[0]["error"]


@test()
def test_int_convert_overflow():
    """int_convert handles overflow with small size"""
    # Try to fit a large number into 1 byte
    result = int_convert({"text": "0xFFFF", "size": 1})
    assert_is_list(result, min_length=1)
    assert result[0]["result"] is None
    assert result[0]["error"] is not None
    assert "too big" in result[0]["error"]


@test()
def test_int_convert_non_ascii():
    """int_convert handles non-ASCII bytes"""
    # 0x01 is not a printable ASCII character (control char)
    result = int_convert({"text": "0x01"})
    assert_is_list(result, min_length=1)
    assert result[0]["error"] is None
    # ascii should be None for non-printable bytes
    assert result[0]["result"]["ascii"] is None


# ============================================================================
# Tests for list_funcs
# ============================================================================


@test()
def test_list_funcs():
    """list_funcs returns functions with proper structure"""
    result = list_funcs({})
    assert_is_list(result, min_length=1)
    page = result[0]
    assert_has_keys(page, "data", "offset", "count", "total")
    if page["data"]:
        assert_all_have_keys(page["data"], "addr", "name", "size")


@test()
def test_list_funcs_pagination():
    """list_funcs respects pagination parameters"""
    result = list_funcs({"offset": 0, "count": 5})
    assert_is_list(result, min_length=1)
    page = result[0]
    assert page["offset"] == 0
    assert len(page["data"]) <= 5


# ============================================================================
# Tests for list_globals
# ============================================================================


@test()
def test_list_globals():
    """list_globals returns globals with proper structure"""
    result = list_globals({})
    assert_is_list(result, min_length=1)
    page = result[0]
    assert_has_keys(page, "data", "offset", "count", "total")


@test()
def test_list_globals_pagination():
    """list_globals respects pagination parameters"""
    result = list_globals({"offset": 0, "count": 5})
    assert_is_list(result, min_length=1)
    page = result[0]
    assert page["offset"] == 0
    assert len(page["data"]) <= 5


# ============================================================================
# Tests for imports
# ============================================================================


@test()
def test_imports():
    """imports returns import list with proper structure"""
    result = imports({})
    assert_is_list(result, min_length=1)
    page = result[0]
    assert_has_keys(page, "data", "offset", "count", "total")


@test()
def test_imports_pagination():
    """imports respects pagination parameters"""
    result = imports({"offset": 0, "count": 5})
    assert_is_list(result, min_length=1)
    page = result[0]
    assert page["offset"] == 0
    assert len(page["data"]) <= 5


# ============================================================================
# Tests for find_regex
# ============================================================================


@test()
def test_find_regex():
    """find_regex can search for patterns"""
    # Search for a common pattern that should exist in most binaries
    result = find_regex({"pattern": ".*"})
    assert_is_list(result, min_length=1)
    # Result structure should have matches
    assert_has_keys(result[0], "query", "matches", "error")

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_memory.py`:

```py
"""Tests for api_memory API functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_has_keys,
    assert_is_list,
    get_any_string,
    get_first_segment,
    get_data_address,
    get_unmapped_address,
)

# Import functions under test
from ..api_memory import (
    get_bytes,
    get_int,
    get_string,
    get_global_value,
    patch,
)

# Import sync module for IDAError


# ============================================================================
# Tests for get_bytes
# ============================================================================


@test()
def test_get_bytes():
    """get_bytes reads bytes from a valid address"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    result = get_bytes({"addr": start_addr, "size": 16})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "hex", "error")
    if r["error"] is None:
        assert r["hex"] is not None


@test()
def test_get_bytes_invalid():
    """get_bytes handles invalid address"""
    result = get_bytes({"addr": get_unmapped_address(), "size": 16})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error or empty data
    assert r.get("error") is not None or r.get("hex") == ""


# ============================================================================
# Tests for get_int
# ============================================================================


@test()
def test_get_int_u8():
    """get_int reads 8-bit unsigned integer"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    result = get_int({"addr": start_addr, "size": 1})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "value", "error")


@test()
def test_get_int_u16():
    """get_int reads 16-bit unsigned integer"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    result = get_int({"addr": start_addr, "size": 2})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "value", "error")


@test()
def test_get_int_u32():
    """get_int reads 32-bit unsigned integer"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    result = get_int({"addr": start_addr, "size": 4})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "value", "error")


@test()
def test_get_int_u64():
    """get_int reads 64-bit unsigned integer"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    result = get_int({"addr": start_addr, "size": 8})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "value", "error")


# ============================================================================
# Tests for get_string
# ============================================================================


@test()
def test_get_string():
    """get_string reads string from a valid address"""
    str_addr = get_any_string()
    if not str_addr:
        return

    result = get_string(str_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "value", "error")


# ============================================================================
# Tests for get_global_value
# ============================================================================


@test()
def test_get_global_value():
    """get_global_value retrieves global variable value"""
    # Try to get value at a data address
    data_addr = get_data_address()
    if not data_addr:
        seg = get_first_segment()
        if not seg:
            return
        data_addr = seg[0]

    result = get_global_value(data_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "error")


# ============================================================================
# Tests for patch
# ============================================================================


@test()
def test_patch_roundtrip():
    """patch writes bytes and restores original"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    # Read original bytes first
    original = get_bytes({"addr": start_addr, "size": 4})
    if not original or not original[0].get("hex"):
        return

    try:
        result = patch({"addr": start_addr, "hex": "90909090"})
        assert_is_list(result, min_length=1)
        r = result[0]
        assert_has_keys(r, "addr")
        assert r.get("ok") is True or r.get("error") is None
    finally:
        # Restore original bytes
        patch({"addr": start_addr, "hex": original[0]["hex"]})


@test()
def test_patch_invalid_address():
    """patch handles invalid address"""
    result = patch({"addr": get_unmapped_address(), "hex": "90"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error
    assert r.get("error") is not None


@test()
def test_patch_invalid_hex_data():
    """patch handles invalid hex data"""
    seg = get_first_segment()
    if not seg:
        return

    start_addr, _ = seg
    result = patch({"addr": start_addr, "hex": "ZZZZ"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error for invalid hex
    assert r.get("error") is not None

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_modify.py`:

```py
"""Tests for api_modify API functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_has_keys,
    assert_is_list,
    get_any_function,
    get_data_address,
)

# Import functions under test
from ..api_modify import (
    set_comments,
    patch_asm,
    rename,
    define_func,
    define_code,
    undefine,
)

# Import sync module for IDAError


# ============================================================================
# Tests for set_comments
# ============================================================================


@test()
def test_set_comment_roundtrip():
    """set_comments can add and remove comments"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Add a comment
    result = set_comments({"addr": fn_addr, "comment": "__TEST_COMMENT__"})
    assert_is_list(result, min_length=1)

    # Clear the comment
    result = set_comments({"addr": fn_addr, "comment": ""})
    assert_is_list(result, min_length=1)


# ============================================================================
# Tests for patch_asm
# ============================================================================


@test()
def test_patch_asm_roundtrip():
    """patch_asm can patch assembly and be restored"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Import memory functions for backup/restore
    from ..api_memory import get_bytes, patch

    # Read original bytes (enough for a nop instruction)
    original = get_bytes({"addr": fn_addr, "size": 16})
    assert_is_list(original, min_length=1)
    original_data = original[0].get("data")
    if not original_data:
        return

    try:
        # Patch with nop
        result = patch_asm({"addr": fn_addr, "asm": "nop"})
        assert_is_list(result, min_length=1)
        r = result[0]
        assert_has_keys(r, "addr")
    finally:
        # Restore original bytes
        patch({"addr": fn_addr, "data": original_data})


# ============================================================================
# Tests for rename
# ============================================================================


@test()
def test_rename_function_roundtrip():
    """rename function works and can be undone"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Import to get original name
    from ..api_core import lookup_funcs

    # Get original name
    lookup_result = lookup_funcs(fn_addr)
    if not lookup_result or not lookup_result[0].get("fn"):
        return

    original_name = lookup_result[0]["fn"]["name"]

    try:
        # Rename
        result = rename({"func": [{"addr": fn_addr, "name": "__test_rename__"}]})
        assert isinstance(result, dict)

        # Verify rename worked
        lookup_result = lookup_funcs(fn_addr)
        new_name = lookup_result[0]["fn"]["name"]
        assert new_name == "__test_rename__"
    finally:
        # Restore
        rename({"func": [{"addr": fn_addr, "name": original_name}]})


@test()
def test_rename_global_roundtrip():
    """rename global variable works"""
    data_addr = get_data_address()
    if not data_addr:
        return

    try:
        result = rename({"global": [{"addr": data_addr, "name": "__test_global__"}]})
        assert isinstance(result, dict)
    except Exception:
        pass  # May fail if no suitable global exists


@test()
def test_rename_local_error_handling():
    """rename local variable handles errors gracefully"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Try to rename a non-existent local variable - should return error, not crash
    result = rename(
        {
            "local": [
                {
                    "func": fn_addr,
                    "name": "__nonexistent_var__",
                    "new_name": "__test_local__",
                }
            ]
        }
    )
    assert isinstance(result, dict)
    # Should have local key with results
    assert "local" in result


# ============================================================================
# Tests for define_func / define_code / undefine
# ============================================================================


@test()
def test_define_undefine_func_roundtrip():
    """define_func and undefine work together - undefine existing func then redefine"""
    import ida_funcs
    import idaapi

    # Get an existing function to test with
    fn_addr = get_any_function()
    if not fn_addr:
        return

    fn_ea = int(fn_addr, 16)
    func = idaapi.get_func(fn_ea)
    if not func:
        return

    # Save function bounds for restoration
    start_ea = func.start_ea
    end_ea = func.end_ea

    try:
        # Undefine the function
        undef_result = undefine({"addr": fn_addr, "end": hex(end_ea)})
        assert_is_list(undef_result, min_length=1)

        # Verify function is gone
        assert idaapi.get_func(start_ea) is None

        # Re-define the function with explicit bounds
        result = define_func({"addr": hex(start_ea), "end": hex(end_ea)})
        assert_is_list(result, min_length=1)
        r = result[0]
        assert r.get("ok") is True or r.get("error") is None
    finally:
        # Ensure function is restored even if test fails
        if idaapi.get_func(start_ea) is None:
            ida_funcs.add_func(start_ea, end_ea)


@test()
def test_define_func_already_exists():
    """define_func returns error for existing function"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = define_func({"addr": fn_addr})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert r.get("error") is not None
    assert "already exists" in r["error"]


@test()
def test_define_func_batch():
    """define_func accepts batch input"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Both should fail (already exist), but tests batch handling
    result = define_func([{"addr": fn_addr}, {"addr": fn_addr}])
    assert_is_list(result, min_length=2)


@test()
def test_define_code_on_existing_code():
    """define_code handles already-defined code gracefully"""
    # Get an existing function address - it's already code
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Calling define_code on existing code should succeed (it's idempotent)
    # or return an appropriate response
    result = define_code({"addr": fn_addr})
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr")
    # Should either succeed or have a meaningful response
    assert (
        r.get("ok") is True or r.get("length") is not None or r.get("error") is not None
    )


@test()
def test_undefine_batch():
    """undefine accepts batch input"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Test that batch input is accepted (will likely fail on function, but tests parsing)
    result = undefine([{"addr": fn_addr}])
    assert_is_list(result, min_length=1)

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_resources.py`:

```py
"""Tests for api_resources MCP resource functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_valid_address,
    assert_has_keys,
    assert_non_empty,
    get_any_function,
)

# Import resource functions under test
from ..api_resources import (
    idb_metadata_resource,
    idb_segments_resource,
    idb_entrypoints_resource,
    cursor_resource,
    selection_resource,
    types_resource,
    structs_resource,
    struct_name_resource,
    import_name_resource,
    export_name_resource,
    xrefs_from_resource,
)

# Import sync module for IDAError
from ..sync import IDAError


# ============================================================================
# Tests for idb_metadata_resource
# ============================================================================


@test()
def test_resource_idb_metadata():
    """idb_metadata_resource returns IDB metadata"""
    result = idb_metadata_resource()
    assert isinstance(result, dict)
    assert_has_keys(result, "path", "module", "base", "size")
    assert_non_empty(result["path"])
    assert_valid_address(result["base"])


# ============================================================================
# Tests for idb_segments_resource
# ============================================================================


@test()
def test_resource_idb_segments():
    """idb_segments_resource returns segments list"""
    result = idb_segments_resource()
    assert isinstance(result, list)
    if result:
        assert_has_keys(result[0], "name", "start", "end")


# ============================================================================
# Tests for idb_entrypoints_resource
# ============================================================================


@test()
def test_resource_idb_entrypoints():
    """idb_entrypoints_resource returns entry points"""
    result = idb_entrypoints_resource()
    assert isinstance(result, list)


# ============================================================================
# Tests for cursor_resource
# ============================================================================


@test()
def test_resource_cursor():
    """cursor_resource returns cursor info"""
    try:
        result = cursor_resource()
        assert isinstance(result, dict)
        # Should have addr key
        assert_has_keys(result, "addr")
    except IDAError:
        pass  # May fail in headless mode


# ============================================================================
# Tests for selection_resource
# ============================================================================


@test()
def test_resource_selection():
    """selection_resource returns selection info"""
    try:
        result = selection_resource()
        assert isinstance(result, dict)
    except IDAError:
        pass  # May fail in headless mode


# ============================================================================
# Tests for types_resource
# ============================================================================


@test()
def test_resource_types():
    """types_resource returns local types"""
    result = types_resource()
    assert isinstance(result, list)


# ============================================================================
# Tests for structs_resource
# ============================================================================


@test()
def test_resource_structs():
    """structs_resource returns structures list"""
    result = structs_resource()
    assert isinstance(result, list)


# ============================================================================
# Tests for struct_name_resource
# ============================================================================


@test()
def test_resource_struct_name():
    """struct_name_resource returns structure info"""
    # Try to get a structure (may not exist)
    try:
        result = struct_name_resource("test")
        assert isinstance(result, dict)
    except IDAError:
        pass  # Structure may not exist


@test()
def test_resource_struct_name_not_found():
    """struct_name_resource handles non-existent structure"""
    try:
        result = struct_name_resource("NonExistentStruct12345")
        # Should return error or empty
    except IDAError:
        pass  # Expected for non-existent struct


# ============================================================================
# Tests for import_name_resource
# ============================================================================


@test()
def test_resource_import_name():
    """import_name_resource returns import info"""
    # Try to get an import (name depends on binary)
    try:
        result = import_name_resource("printf")
        assert isinstance(result, dict)
    except IDAError:
        pass  # Import may not exist in this binary


# ============================================================================
# Tests for export_name_resource
# ============================================================================


@test()
def test_resource_export_name():
    """export_name_resource returns export info"""
    # Try to get main
    try:
        result = export_name_resource("main")
        assert isinstance(result, dict)
    except IDAError:
        pass  # Export may not exist


# ============================================================================
# Tests for xrefs_from_resource
# ============================================================================


@test()
def test_resource_xrefs_from():
    """xrefs_from_resource returns cross-references"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = xrefs_from_resource(fn_addr)
    assert isinstance(result, list)

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_stack.py`:

```py
"""Tests for api_stack API functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_has_keys,
    assert_is_list,
    get_any_function,
    get_data_address,
)

# Import functions under test
from ..api_stack import (
    stack_frame,
    declare_stack,
    delete_stack,
)

# Import sync module for IDAError


# ============================================================================
# Tests for stack_frame
# ============================================================================


@test()
def test_stack_frame():
    """stack_frame returns stack frame info for a function"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = stack_frame(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "frame", "error")


@test()
def test_stack_frame_no_function():
    """stack_frame handles non-function address"""
    data_addr = get_data_address()
    if not data_addr:
        return

    result = stack_frame(data_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error or null frame
    assert r.get("error") is not None or r.get("frame") is None


# ============================================================================
# Tests for declare_stack / delete_stack
# ============================================================================


@test()
def test_declare_delete_stack_roundtrip():
    """declare_stack and delete_stack work together"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    try:
        # Try to declare a stack variable
        result = declare_stack(
            {"func": fn_addr, "name": "__test_var__", "offset": -8, "type": "int"}
        )
        assert_is_list(result, min_length=1)
        r = result[0]
        assert_has_keys(r, "func")
    finally:
        # Always try to clean up, even if declare failed
        delete_stack({"func": fn_addr, "name": "__test_var__"})

```

`src/ida_pro_mcp/ida_mcp/tests/test_api_types.py`:

```py
"""Tests for api_types API functions."""

# Import test framework from parent
from ..framework import (
    test,
    assert_has_keys,
    assert_is_list,
    get_any_function,
    get_first_segment,
    get_data_address,
    get_unmapped_address,
)

# Import functions under test
from ..api_types import (
    declare_type,
    read_struct,
    search_structs,
    set_type,
    infer_types,
)

# Import sync module for IDAError


# ============================================================================
# Test Helpers
# ============================================================================


def create_test_struct(name: str = "__TestStruct__") -> bool:
    """Helper to create a test struct in IDA's type library.

    This function is idempotent - if the struct already exists, it will return True.

    Args:
        name: Name of the struct to create

    Returns:
        True if struct exists or was created successfully, False otherwise
    """
    # First check if struct already exists
    search_result = search_structs(name)
    if search_result and any(s["name"] == name for s in search_result):
        return True  # Already exists

    # Struct doesn't exist, try to create it
    struct_def = f"""
        struct {name} {{
            int field1;
            char field2;
            void* field3;
        }};
    """
    result = declare_type(struct_def)
    if not result:
        return False

    # Check if declaration succeeded
    r = result[0]
    if r.get("ok"):
        return True

    # Check if it failed because it already exists
    if r.get("error"):
        # Search again to see if it exists despite the error
        search_result = search_structs(name)
        return search_result and any(s["name"] == name for s in search_result)

    return False


# ============================================================================
# Tests for declare_type
# ============================================================================


@test()
def test_declare_type():
    """declare_type can add a type declaration"""
    # Try to declare a simple struct
    result = declare_type("struct __test_struct__ { int x; };")
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "decl")
    # Should succeed without error
    assert r.get("ok") is not None or r.get("error") is None


# ============================================================================
# Tests for read_struct
# ============================================================================


@test()
def test_read_struct():
    """read_struct reads structure at address"""
    data_addr = get_data_address()
    if not data_addr:
        seg = get_first_segment()
        if not seg:
            return
        data_addr = seg[0]

    result = read_struct({"addr": data_addr, "struct": "test_struct"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have addr, struct, and either members or error
    assert_has_keys(r, "addr", "struct")
    assert r.get("members") is not None or r.get("error") is not None


@test()
def test_read_struct_not_found():
    """read_struct handles non-existent struct"""
    seg = get_first_segment()
    if not seg:
        return

    result = read_struct({"addr": seg[0], "struct": "NonExistentStruct12345"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error
    assert r.get("error") is not None


@test()
def test_read_struct_name_resolution():
    """read_struct can resolve named addresses (e.g., function names)"""
    # Create a test struct first
    if not create_test_struct("__NameResolutionTest__"):
        return

    fn_addr = get_any_function()
    if not fn_addr:
        return

    # Get the function name
    from ..api_core import lookup_funcs

    fn_info = lookup_funcs(fn_addr)
    if not fn_info or not fn_info[0].get("fn"):
        return

    fn_name = fn_info[0]["fn"]["name"]

    # Use the function name as address (should resolve via get_name_ea)
    result = read_struct({"addr": fn_name, "struct": "__NameResolutionTest__"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should either succeed with members or have a specific error
    # (not a "Failed to resolve address" error)
    if r.get("error"):
        # If there's an error, it should be about the struct, not address resolution
        assert "Failed to resolve address" not in r["error"]


@test()
def test_read_struct_invalid_address():
    """read_struct handles invalid address gracefully"""
    result = read_struct(
        {"addr": "InvalidAddressName123", "struct": "NonExistentStruct"}
    )
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have error about failed address resolution
    assert r.get("error") is not None
    assert "Failed to resolve address" in r["error"]


# ============================================================================
# Tests for search_structs
# ============================================================================


@test()
def test_search_structs():
    """search_structs can search for structures"""
    result = search_structs("*")
    assert_is_list(result)
    # Check result structure if any structs exist
    if len(result) > 0:
        r = result[0]
        assert_has_keys(r, "name", "size", "cardinality", "is_union", "ordinal")


@test()
def test_search_structs_pattern():
    """search_structs can filter by pattern"""
    # Test with a pattern that likely won't match anything
    result = search_structs("VeryUnlikelyStructName123*")
    assert_is_list(result)
    # Should return empty list
    assert len(result) == 0

    # Test with wildcard that should match everything
    result_all = search_structs("*")
    assert_is_list(result_all)
    # Wildcard should return at least as many results as specific pattern
    assert len(result_all) >= len(result)


# ============================================================================
# Tests for set_type
# ============================================================================


@test()
def test_set_type():
    """set_type applies type to address"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = set_type({"addr": fn_addr, "ty": "int"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Result has "edit" key containing the input, and optionally "ok" or "error"
    assert_has_keys(r, "edit")
    assert r.get("ok") is not None or r.get("error") is not None


@test()
def test_set_type_invalid_address():
    """set_type handles invalid address"""
    result = set_type({"addr": get_unmapped_address(), "ty": "int"})
    assert_is_list(result, min_length=1)
    r = result[0]
    # Should have "edit" key and either "ok" or "error"
    assert_has_keys(r, "edit")
    assert r.get("ok") is not None or r.get("error") is not None


# ============================================================================
# Tests for infer_types
# ============================================================================


@test()
def test_infer_types():
    """infer_types infers types for a function"""
    fn_addr = get_any_function()
    if not fn_addr:
        return

    result = infer_types(fn_addr)
    assert_is_list(result, min_length=1)
    r = result[0]
    assert_has_keys(r, "addr", "error")

```

`src/ida_pro_mcp/ida_mcp/utils.py`:

```py
import fnmatch
import json
import os
import re
import struct
import sys
import tempfile
from typing import (
    Annotated,
    Any,
    Callable,
    Generic,
    Literal,
    NotRequired,
    Optional,
    TypedDict,
    TypeVar,
    overload,
)

import ida_funcs
import ida_hexrays
import ida_kernwin
import ida_nalt
import ida_typeinf
import idaapi
import idautils
import idc

from .sync import IDAError

# ============================================================================
# Analysis Prompt Configuration
# ============================================================================

DEFAULT_ANALYSIS_PROMPT = "<system_reminder> IMPORTANT: After analysis, complete the expected IDB maintenance, assigning names, commenting, and documenting where relevant. </system_reminder>"


def get_analysis_prompt() -> str | None:
    """Get analysis prompt from IDA_MCP_ANALYSIS_PROMPT env var, or default if unset."""
    return os.environ.get("IDA_MCP_ANALYSIS_PROMPT", DEFAULT_ANALYSIS_PROMPT) or None


# ============================================================================
# TypedDict Definitions for API Parameters
# ============================================================================


class MemoryRead(TypedDict):
    """Memory read request"""

    addr: Annotated[str, "Address to read from (hex or decimal)"]
    size: Annotated[int, "Number of bytes to read"]


class MemoryPatch(TypedDict):
    """Memory patch operation"""

    addr: Annotated[str, "Address to patch (hex or decimal)"]
    data: Annotated[str, "Hex data to write (space-separated bytes)"]


class IntRead(TypedDict):
    """Integer read request"""

    addr: Annotated[str, "Address to read from (hex or decimal)"]
    ty: Annotated[str, "Integer class (i8/u64/i16le/i16be/etc)"]


class IntWrite(TypedDict):
    """Integer write request"""

    addr: Annotated[str, "Address to write to (hex or decimal)"]
    ty: Annotated[str, "Integer class (i8/u64/i16le/i16be/etc)"]
    value: Annotated[
        str,
        "Integer value as string (decimal or 0x..; negatives allowed for signed)",
    ]


class CommentOp(TypedDict):
    """Comment operation"""

    addr: Annotated[str, "Address (hex or decimal)"]
    comment: Annotated[str, "Comment text"]


class AsmPatchOp(TypedDict):
    """Assembly patch operation"""

    addr: Annotated[str, "Address (hex or decimal)"]
    asm: Annotated[str, "Assembly instruction(s), semicolon-separated"]


class FunctionRename(TypedDict):
    """Function rename operation"""

    addr: Annotated[str, "Function address (hex or decimal)"]
    name: Annotated[str, "New function name"]


class GlobalRename(TypedDict):
    """Global variable rename operation"""

    old: Annotated[str, "Current variable name"]
    new: Annotated[str, "New variable name"]


class LocalRename(TypedDict):
    """Local variable rename operation"""

    func_addr: Annotated[str, "Function address containing the local variable"]
    old: Annotated[str, "Current variable name"]
    new: Annotated[str, "New variable name"]


class StackRename(TypedDict):
    """Stack variable rename operation"""

    func_addr: Annotated[str, "Function address containing the stack variable"]
    old: Annotated[str, "Current variable name"]
    new: Annotated[str, "New variable name"]


class RenameBatch(TypedDict, total=False):
    """Batch rename operations across all entity types"""

    func: Annotated[
        list[FunctionRename] | FunctionRename | None, "Function rename operations"
    ]
    data: Annotated[
        list[GlobalRename] | GlobalRename | None,
        "Global/data variable rename operations",
    ]
    local: Annotated[
        list[LocalRename] | LocalRename | None, "Local variable rename operations"
    ]
    stack: Annotated[
        list[StackRename] | StackRename | None, "Stack variable rename operations"
    ]


class StructFieldQuery(TypedDict):
    """Struct field query for xrefs"""

    struct: Annotated[str, "Structure name"]
    field: Annotated[str, "Field name"]


class ListQuery(TypedDict, total=False):
    """Pagination query for listing operations"""

    filter: Annotated[str, "Optional glob pattern to filter results"]
    offset: Annotated[int, "Starting index (default: 0)"]
    count: Annotated[int, "Maximum number of results (default: 50, 0 for all)"]


class BreakpointOp(TypedDict):
    """Debugger breakpoint operation"""

    addr: Annotated[str, "Breakpoint address (hex or decimal)"]
    enabled: Annotated[bool, "Enable (true) or disable (false)"]


class InsnPattern(TypedDict, total=False):
    """Instruction pattern for operand search"""

    mnem: Annotated[str, "Instruction mnemonic to match"]
    op0: Annotated[int, "Value to match in first operand"]
    op1: Annotated[int, "Value to match in second operand"]
    op2: Annotated[int, "Value to match in third operand"]
    op_any: Annotated[int, "Value to match in any operand"]
    func: Annotated[str, "Function address to scope the scan"]
    segment: Annotated[str, "Segment name to scope the scan"]
    start: Annotated[str, "Start address (hex/dec) to scope the scan"]
    end: Annotated[str, "End address (hex/dec, exclusive) to scope the scan"]
    max_scan_insns: Annotated[
        int, "Max instructions to scan (default: 200000, max: 2000000)"
    ]
    allow_broad: Annotated[
        bool,
        "Allow scans without scope (default: false). Use with care on large binaries.",
    ]


class NumberConversion(TypedDict, total=False):
    """Number conversion request"""

    text: Annotated[str, "Number string to convert"]
    size: Annotated[int, "Byte size for conversion (omit for auto)"]


class StructRead(TypedDict, total=False):
    """Structure read request

    Address is required. Struct name is optional - if omitted, will attempt
    to auto-detect from type information already applied at the address.
    """

    addr: Annotated[str, "Memory address (hex or decimal)"]
    struct: Annotated[
        NotRequired[str], "Structure name (optional, auto-detect if omitted)"
    ]


class TypeEdit(TypedDict, total=False):
    """Type application operation"""

    addr: Annotated[str, "Memory address"]
    name: Annotated[str, "Variable/function name"]
    ty: Annotated[str, "Type name or declaration"]
    kind: Annotated[str, "Type of entity (auto-detected if omitted)"]
    signature: Annotated[str, "Function signature (for kind=function)"]
    variable: Annotated[str, "Local variable name (for kind=local)"]


class StackVarDecl(TypedDict):
    """Stack variable declaration"""

    addr: Annotated[str, "Function address"]
    offset: Annotated[str, "Stack offset"]
    name: Annotated[str, "Variable name"]
    ty: Annotated[str, "Type name"]


class StackVarDelete(TypedDict):
    """Stack variable deletion"""

    addr: Annotated[str, "Function address"]
    name: Annotated[str, "Variable name"]


class DefineOp(TypedDict, total=False):
    """Define function/code operation"""

    addr: Annotated[
        str, "Address to define (hex or decimal). Use 'start:end' for explicit bounds."
    ]
    end: Annotated[str, "Optional end address for explicit bounds"]


class UndefineOp(TypedDict, total=False):
    """Undefine operation"""

    addr: Annotated[str, "Address to undefine (hex or decimal)"]
    end: Annotated[str, "Optional end address"]
    size: Annotated[int, "Optional size in bytes"]


# ============================================================================
# TypedDict Definitions for Results
# ============================================================================


class Metadata(TypedDict):
    path: str
    module: str
    base: str
    size: str
    md5: str
    sha256: str
    crc32: str
    filesize: str


class Function(TypedDict):
    addr: str
    name: str
    size: str


class ConvertedNumber(TypedDict):
    decimal: str
    hexadecimal: str
    bytes: str
    ascii: Optional[str]
    binary: str


class Global(TypedDict):
    addr: str
    name: str


class Import(TypedDict):
    addr: str
    imported_name: str
    module: str


class String(TypedDict):
    addr: str
    length: int
    string: str


class Segment(TypedDict):
    name: str
    start: str
    end: str
    size: str
    permissions: str


class DisassemblyLine(TypedDict):
    segment: NotRequired[str]
    addr: str
    label: NotRequired[str]
    instruction: str
    comments: NotRequired[list[str]]


class Argument(TypedDict):
    name: str
    type: str


class StackFrameVariable(TypedDict):
    name: str
    offset: str
    size: str
    type: str


class DisassemblyFunction(TypedDict):
    name: str
    start_ea: str
    return_type: NotRequired[str]
    arguments: NotRequired[list[Argument]]
    stack_frame: list[StackFrameVariable]
    lines: list[DisassemblyLine]


class Xref(TypedDict):
    addr: str
    type: str
    fn: Optional[Function]


class StructureMember(TypedDict):
    name: str
    offset: str
    size: str
    type: str


class StructureDefinition(TypedDict):
    name: str
    size: str
    members: list[StructureMember]


class RegisterValue(TypedDict):
    name: str
    value: str


class ThreadRegisters(TypedDict):
    thread_id: int
    registers: list[RegisterValue]


class Breakpoint(TypedDict):
    addr: str
    enabled: bool
    condition: Optional[str]


class FunctionAnalysis(TypedDict):
    addr: str
    name: Optional[str]
    code: Optional[str]
    asm: Optional[str]
    xto: list[Xref]
    xfrom: list[Xref]
    callees: list[dict]
    callers: list[Function]
    strings: list[String]
    constants: list[dict]
    blocks: list[dict]
    error: Optional[str]
    prompt: Optional[str]


class PatternMatch(TypedDict):
    pattern: str
    matches: list[str]
    count: int


class CodePattern(TypedDict):
    mnemonic: str
    operands: NotRequired[list[str]]


class BasicBlock(TypedDict):
    start: str
    end: str
    size: int
    type: int
    successors: list[str]
    predecessors: list[str]


T = TypeVar("T")


class Page(TypedDict, Generic[T]):
    data: list[T]
    next_offset: Optional[int]


# ============================================================================
# Helper Functions
# ============================================================================


def get_image_size() -> int:
    try:
        info = idaapi.get_inf_structure()
        omin_ea = info.omin_ea
        omax_ea = info.omax_ea
    except AttributeError:
        import ida_ida

        omin_ea = ida_ida.inf_get_omin_ea()
        omax_ea = ida_ida.inf_get_omax_ea()
    image_size = omax_ea - omin_ea
    header = idautils.peutils_t().header()
    if header and header[:4] == b"PE\0\0":
        image_size = struct.unpack("<I", header[0x50:0x54])[0]
    return image_size


def parse_address(addr: str | int) -> int:
    if isinstance(addr, int):
        return addr
    try:
        return int(addr, 0)
    except ValueError:
        for ch in addr:
            if ch not in "0123456789abcdefABCDEF":
                raise IDAError(f"Failed to parse address: {addr}")
        raise IDAError(f"Failed to parse address (missing 0x prefix): {addr}")


def normalize_list_input(value: list | str) -> list:
    """Normalize input to list - accepts list or comma-separated string"""
    if isinstance(value, list):
        return value
    if isinstance(value, str):
        return [item.strip() for item in value.split(",") if item.strip()]
    return [value]


def normalize_dict_list(
    value: list[dict] | dict | str | list[str] | Any,
    string_parser: Optional[Callable[[str], dict]] = None,
) -> list[dict]:
    """Normalize input to list[dict] with optional string parsing

    Args:
        value: Input value (dict, list[dict], str, list[str], or any)
        string_parser: Optional function to convert string → dict
                      If None, strings → empty dict

    Flow:
        dict → [dict]
        str → split by ',' → list[str] → map(string_parser) → list[dict]
        list[str] → map(string_parser) → list[dict]
        list[dict] → list[dict]
        Any → [{}]
    """
    if isinstance(value, dict):
        return [value]
    elif isinstance(value, list):
        if not value:
            return [{}]
        # Check if list[str] or list[dict]
        if all(isinstance(item, dict) for item in value):
            return value
        elif all(isinstance(item, str) for item in value):
            # list[str] → map with parser
            if string_parser:
                return [string_parser(s.strip()) for s in value if s.strip()]
            return [{}]
        else:
            # Mixed types - filter dicts only
            return [item for item in value if isinstance(item, dict)] or [{}]
    elif isinstance(value, str):
        # Try JSON parse first
        try:
            parsed = json.loads(value)
            if isinstance(parsed, dict):
                return [parsed]
            elif isinstance(parsed, list):
                return parsed
        except (json.JSONDecodeError, ValueError):
            pass

        # Not JSON - split by comma and parse
        parts = [s.strip() for s in value.split(",") if s.strip()]
        if not parts:
            return [{}]

        if string_parser:
            return [string_parser(part) for part in parts]
        return [{}]
    else:
        # Any other type → empty dict
        return [{}]


def looks_like_address(s: str) -> bool:
    """Check if string looks like an address (0x prefix or all hex chars)"""
    if s.startswith("0x") or s.startswith("0X"):
        return True
    # All hex chars and at least 4 chars → likely address
    if len(s) >= 4 and all(c in "0123456789abcdefABCDEF" for c in s):
        return True
    return False


@overload
def get_function(addr: int, *, raise_error: Literal[True]) -> Function: ...


@overload
def get_function(addr: int) -> Function: ...


@overload
def get_function(addr: int, *, raise_error: Literal[False]) -> Optional[Function]: ...


def get_function(addr, *, raise_error=True):
    fn = idaapi.get_func(addr)
    if fn is None:
        if raise_error:
            raise IDAError(f"No function found at address {hex(addr)}")
        return None

    try:
        name = fn.get_name()
    except AttributeError:
        name = ida_funcs.get_func_name(fn.start_ea)

    return Function(addr=hex(addr), name=name, size=hex(fn.end_ea - fn.start_ea))


def get_prototype(fn: ida_funcs.func_t) -> Optional[str]:
    try:
        prototype: ida_typeinf.tinfo_t = fn.get_prototype()
        if prototype is not None:
            return str(prototype)
        else:
            return None
    except AttributeError:
        try:
            return idc.get_type(fn.start_ea)
        except Exception:
            tif = ida_typeinf.tinfo_t()
            if ida_nalt.get_tinfo(tif, fn.start_ea):
                return str(tif)
            return None
    except Exception as e:
        print(f"Error getting function prototype: {e}")
        return None


DEMANGLED_TO_EA = {}


def create_demangled_to_ea_map():
    for ea in idautils.Functions():
        demangled = idaapi.demangle_name(idc.get_name(ea, 0), idaapi.MNG_NODEFINIT)
        if demangled:
            DEMANGLED_TO_EA[demangled] = ea


def get_type_by_name(type_name: str) -> ida_typeinf.tinfo_t:
    # 8-bit integers
    if type_name in ("int8", "__int8", "int8_t", "char", "signed char"):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_INT8)
    elif type_name in ("uint8", "__uint8", "uint8_t", "unsigned char", "byte", "BYTE"):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT8)
    # 16-bit integers
    elif type_name in (
        "int16",
        "__int16",
        "int16_t",
        "short",
        "short int",
        "signed short",
        "signed short int",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_INT16)
    elif type_name in (
        "uint16",
        "__uint16",
        "uint16_t",
        "unsigned short",
        "unsigned short int",
        "word",
        "WORD",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT16)
    # 32-bit integers
    elif type_name in (
        "int32",
        "__int32",
        "int32_t",
        "int",
        "signed int",
        "long",
        "long int",
        "signed long",
        "signed long int",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_INT32)
    elif type_name in (
        "uint32",
        "__uint32",
        "uint32_t",
        "unsigned int",
        "unsigned long",
        "unsigned long int",
        "dword",
        "DWORD",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT32)
    # 64-bit integers
    elif type_name in (
        "int64",
        "__int64",
        "int64_t",
        "long long",
        "long long int",
        "signed long long",
        "signed long long int",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_INT64)
    elif type_name in (
        "uint64",
        "__uint64",
        "uint64_t",
        "unsigned int64",
        "unsigned long long",
        "unsigned long long int",
        "qword",
        "QWORD",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT64)
    # 128-bit integers
    elif type_name in ("int128", "__int128", "int128_t", "__int128_t"):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_INT128)
    elif type_name in (
        "uint128",
        "__uint128",
        "uint128_t",
        "__uint128_t",
        "unsigned int128",
    ):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_UINT128)
    # Floating point types
    elif type_name in ("float",):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_FLOAT)
    elif type_name in ("double",):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_DOUBLE)
    elif type_name in ("long double", "ldouble"):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_LDOUBLE)
    # Boolean type
    elif type_name in ("bool", "_Bool", "boolean"):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_BOOL)
    # Void type
    elif type_name in ("void",):
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_VOID)
    # Named types
    tif = ida_typeinf.tinfo_t()
    if tif.get_named_type(None, type_name, ida_typeinf.BTF_STRUCT):
        return tif
    if tif.get_named_type(None, type_name, ida_typeinf.BTF_TYPEDEF):
        return tif
    if tif.get_named_type(None, type_name, ida_typeinf.BTF_ENUM):
        return tif
    if tif.get_named_type(None, type_name, ida_typeinf.BTF_UNION):
        return tif
    if tif := ida_typeinf.tinfo_t(type_name):
        return tif

    raise IDAError(f"Unable to retrieve {type_name} type info object")


def paginate(data: list[T], offset: int, count: int) -> Page[T]:
    if count == 0:
        count = len(data)
    next_offset = offset + count
    if next_offset >= len(data):
        next_offset = None
    return {
        "data": data[offset : offset + count],
        "next_offset": next_offset,
    }


def pattern_filter(data: list[T], pattern: str, key: str) -> list[T]:
    if not pattern:
        return data

    regex = None
    use_glob = False

    # Regex pattern: /pattern/flags
    if pattern.startswith("/") and pattern.count("/") >= 2:
        last_slash = pattern.rfind("/")
        body = pattern[1:last_slash]
        flag_str = pattern[last_slash + 1 :]

        flags = 0
        for ch in flag_str:
            if ch == "i":
                flags |= re.IGNORECASE
            elif ch == "m":
                flags |= re.MULTILINE
            elif ch == "s":
                flags |= re.DOTALL

        try:
            regex = re.compile(body, flags or re.IGNORECASE)
        except re.error:
            regex = None
    # Glob pattern: contains * or ?
    elif "*" in pattern or "?" in pattern:
        use_glob = True

    def get_value(item) -> str:
        try:
            v = item[key]
        except Exception:
            v = getattr(item, key, "")
        return "" if v is None else str(v)

    def matches(item) -> bool:
        text = get_value(item)
        if regex is not None:
            return bool(regex.search(text))
        if use_glob:
            return fnmatch.fnmatch(text.lower(), pattern.lower())
        return pattern.lower() in text.lower()

    return [item for item in data if matches(item)]


def refresh_decompiler_widget():
    if not ida_hexrays.init_hexrays_plugin():
        return
    widget = ida_kernwin.get_current_widget()
    if widget is not None:
        vu = ida_hexrays.get_widget_vdui(widget)
        if vu is not None:
            vu.refresh_ctext()


def refresh_decompiler_ctext(fn_addr: int):
    if not ida_hexrays.init_hexrays_plugin():
        return
    error = ida_hexrays.hexrays_failure_t()
    cfunc: ida_hexrays.cfunc_t = ida_hexrays.decompile_func(
        fn_addr, error, ida_hexrays.DECOMP_WARNINGS
    )
    if cfunc:
        cfunc.refresh_func_ctext()


class my_modifier_t(ida_hexrays.user_lvar_modifier_t):
    def __init__(self, var_name: str, new_type: ida_typeinf.tinfo_t):
        ida_hexrays.user_lvar_modifier_t.__init__(self)
        self.var_name = var_name
        self.new_type = new_type

    def modify_lvars(self, lvinf):
        for lvar_saved in lvinf.lvvec:
            lvar_saved: ida_hexrays.lvar_saved_info_t
            if lvar_saved.name == self.var_name:
                lvar_saved.type = self.new_type
                return True
        return False


def parse_decls_ctypes(decls: str, hti_flags: int) -> tuple[int, list[str]]:
    if sys.platform == "win32":
        import ctypes

        assert isinstance(decls, str), "decls must be a string"
        assert isinstance(hti_flags, int), "hti_flags must be an int"
        c_decls = decls.encode("utf-8")
        c_til = None
        ida_dll = ctypes.CDLL("ida")
        ida_dll.parse_decls.argtypes = [
            ctypes.c_void_p,
            ctypes.c_char_p,
            ctypes.c_void_p,
            ctypes.c_int,
        ]
        ida_dll.parse_decls.restype = ctypes.c_int

        messages: list[str] = []

        @ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_char_p, ctypes.c_char_p)
        def magic_printer(fmt: bytes, arg1: bytes):
            if fmt.count(b"%") == 1 and b"%s" in fmt:
                formatted = fmt.replace(b"%s", arg1)
                messages.append(formatted.decode("utf-8"))
                return len(formatted) + 1
            else:
                messages.append(f"unsupported magic_printer fmt: {repr(fmt)}")
                return 0

        errors = ida_dll.parse_decls(c_til, c_decls, magic_printer, hti_flags)
    else:
        errors = ida_typeinf.parse_decls(None, decls, False, hti_flags)
        messages = []
    return errors, messages


def get_stack_frame_variables_internal(
    fn_addr: int, raise_error: bool
) -> list[StackFrameVariable]:
    from .sync import ida_major

    if ida_major < 9:
        return []

    func = idaapi.get_func(fn_addr)
    if not func:
        if raise_error:
            raise IDAError(f"No function found at address {fn_addr}")
        return []

    tif = ida_typeinf.tinfo_t()
    if not tif.get_type_by_tid(func.frame) or not tif.is_udt():
        return []

    members: list[StackFrameVariable] = []
    udt = ida_typeinf.udt_type_data_t()
    tif.get_udt_details(udt)
    for udm in udt:
        if not udm.is_gap():
            name = udm.name
            offset = udm.offset // 8
            size = udm.size // 8
            type = str(udm.type)
            members.append(
                StackFrameVariable(
                    name=name, offset=hex(offset), size=hex(size), type=type
                )
            )
    return members


def decompile_checked(addr: int):
    """Decompile a function and raise IDAError on failure (uses cache)"""
    if not ida_hexrays.init_hexrays_plugin():
        raise IDAError("Hex-Rays decompiler is not available")
    hf = ida_hexrays.hexrays_failure_t()
    cfunc = ida_hexrays.decompile(addr, hf)
    if not cfunc:
        if hf.code == ida_hexrays.MERR_LICENSE:
            raise IDAError(
                "Decompiler license is not available. Use `disassemble_function` to get the assembly code instead."
            )

        message = f"Decompilation failed at {hex(addr)}"
        if hf.str:
            message += f": {hf.str}"
        if hf.errea != idaapi.BADADDR:
            message += f" (address: {hex(hf.errea)})"
        raise IDAError(message)
    return cfunc


def decompile_function_safe(ea: int) -> Optional[str]:
    """Safely decompile a function, returning None on failure (uses cache)"""
    import ida_lines
    import ida_kernwin

    try:
        if not ida_hexrays.init_hexrays_plugin():
            return None
        cfunc = ida_hexrays.decompile(ea)
        if not cfunc:
            return None
        sv = cfunc.get_pseudocode()
        lines = []
        for sl in sv:
            sl: ida_kernwin.simpleline_t
            item = ida_hexrays.ctree_item_t()
            line_ea = None
            if cfunc.get_line_item(sl.line, 0, False, None, item, None):
                dstr: str | None = item.dstr()
                if dstr:
                    ds = dstr.split(": ")
                    if len(ds) == 2:
                        try:
                            line_ea = int(ds[0], 16)
                        except ValueError:
                            pass
            text = ida_lines.tag_remove(sl.line)
            if line_ea is not None:
                lines.append(f"{text} /*{line_ea:#x}*/")
            else:
                lines.append(text)
        return "\n".join(lines)
    except Exception:
        return None


def get_assembly_lines(ea: int) -> str:
    """Get assembly lines for a function in compact string format"""
    func = idaapi.get_func(ea)
    if not func:
        return ""

    func_name: str = ida_funcs.get_func_name(func.start_ea) or "<unnamed>"

    # Get segment from first instruction
    first_seg = idaapi.getseg(func.start_ea)
    segment_name = idaapi.get_segm_name(first_seg) if first_seg else "UNKNOWN"

    # Build compact string format
    lines_str = f"{func_name} ({segment_name} @ {hex(func.start_ea)}):"

    for item_ea in idautils.FuncItems(func.start_ea):
        mnem = idc.print_insn_mnem(item_ea) or ""
        ops = []
        for n in range(8):
            if idc.get_operand_type(item_ea, n) == idaapi.o_void:
                break
            ops.append(idc.print_operand(item_ea, n) or "")
        instruction = f"{mnem} {', '.join(ops)}".rstrip()
        lines_str += f"\n{item_ea:x}  {instruction}"

    return lines_str


def get_all_xrefs(ea: int) -> dict:
    """Get all xrefs to and from an address"""
    return {
        "to": [
            {"addr": hex(x.frm), "type": "code" if x.iscode else "data"}
            for x in idautils.XrefsTo(ea, 0)
        ],
        "from": [
            {"addr": hex(x.to), "type": "code" if x.iscode else "data"}
            for x in idautils.XrefsFrom(ea, 0)
        ],
    }


def get_all_comments(ea: int) -> dict:
    """Get all comments for an address"""
    func = idaapi.get_func(ea)
    if not func:
        return {}

    comments = {}
    for item_ea in idautils.FuncItems(func.start_ea):
        cmt = idaapi.get_cmt(item_ea, False)
        if cmt:
            comments[hex(item_ea)] = {"regular": cmt}
        cmt = idaapi.get_cmt(item_ea, True)
        if cmt:
            if hex(item_ea) not in comments:
                comments[hex(item_ea)] = {}
            comments[hex(item_ea)]["repeatable"] = cmt
    return comments


def get_callees(addr: str) -> list[dict]:
    """Get callees for a single function address"""
    try:
        func_start = parse_address(addr)
        func = idaapi.get_func(func_start)
        if not func:
            return []
        func_end = idc.find_func_end(func_start)
        callees: list[dict[str, str]] = []
        current_ea = func_start
        while current_ea < func_end:
            insn = idaapi.insn_t()
            idaapi.decode_insn(insn, current_ea)
            if insn.itype in [idaapi.NN_call, idaapi.NN_callfi, idaapi.NN_callni]:
                target = idc.get_operand_value(current_ea, 0)
                target_type = idc.get_operand_type(current_ea, 0)
                if target_type in [idaapi.o_mem, idaapi.o_near, idaapi.o_far]:
                    func_type = (
                        "internal"
                        if idaapi.get_func(target) is not None
                        else "external"
                    )
                    func_name = idc.get_name(target)
                    if func_name is not None:
                        callees.append(
                            {
                                "addr": hex(target),
                                "name": func_name,
                                "type": func_type,
                            }
                        )
            current_ea = idc.next_head(current_ea, func_end)

        unique_callee_tuples = {tuple(callee.items()) for callee in callees}
        unique_callees = [dict(callee) for callee in unique_callee_tuples]
        return unique_callees
    except Exception:
        return []


def get_callers(addr: str, limit: int = 50) -> list[Function]:
    """Get callers for a single function address"""
    try:
        callers = {}
        iterations = 0
        max_iterations = limit * 100
        for caller_addr in idautils.CodeRefsTo(parse_address(addr), 0):
            iterations += 1
            if len(callers) >= limit or iterations >= max_iterations:
                break
            func = get_function(caller_addr, raise_error=False)
            if not func:
                continue
            insn = idaapi.insn_t()
            idaapi.decode_insn(insn, caller_addr)
            if insn.itype not in [
                idaapi.NN_call,
                idaapi.NN_callfi,
                idaapi.NN_callni,
            ]:
                continue
            callers[func["addr"]] = func

        return list(callers.values())
    except Exception:
        return []


def get_xrefs_from_internal(ea: int) -> list[Xref]:
    """Get all xrefs from an address"""
    xrefs = []
    for xref in idautils.XrefsFrom(ea, 0):
        xrefs.append(
            Xref(
                addr=hex(xref.to),
                type="code" if xref.iscode else "data",
                fn=get_function(xref.to, raise_error=False),
            )
        )
    return xrefs


def extract_function_strings(ea: int) -> list[String]:
    """Extract string references from a function"""
    func = idaapi.get_func(ea)
    if not func:
        return []

    strings = []
    for item_ea in idautils.FuncItems(func.start_ea):
        for xref in idautils.XrefsFrom(item_ea, 0):
            if not xref.iscode:
                # Check if target is a string
                str_type = ida_nalt.get_str_type(xref.to)
                if str_type != ida_nalt.STRTYPE_C:
                    continue
                try:
                    str_content = idc.get_strlit_contents(xref.to)
                    if str_content:
                        strings.append(
                            String(
                                addr=hex(xref.to),
                                length=len(str_content),
                                string=str_content.decode("utf-8", errors="replace"),
                            )
                        )
                except Exception:
                    pass
    return strings


def extract_function_constants(ea: int) -> list[dict]:
    """Extract immediate constants from a function"""
    func = idaapi.get_func(ea)
    if not func:
        return []

    constants = []
    for item_ea in idautils.FuncItems(func.start_ea):
        insn = idaapi.insn_t()
        if idaapi.decode_insn(insn, item_ea) > 0:
            for op in insn.ops:
                if op.type == idaapi.o_imm:
                    constants.append(
                        {
                            "addr": hex(item_ea),
                            "value": hex(op.value),
                            "decimal": op.value,
                        }
                    )
    return constants


# ============================================================================
# Large Output Handling
# ============================================================================


def handle_large_output(result: Any, line_threshold: int = 3000) -> Any:
    """
    Handle potentially large outputs by writing to temp file if needed.

    Args:
        result: The result object to check
        line_threshold: Number of lines above which to write to file (default: 3000)

    Returns:
        Either the original result or a dict with file path if written to file
    """
    try:
        serialized = json.dumps(result, indent=2)
        line_count = serialized.count("\n") + 1

        if line_count > line_threshold:
            fd, temp_path = tempfile.mkstemp(
                suffix=".json", prefix="ida_mcp_", text=True
            )
            try:
                with os.fdopen(fd, "w") as f:
                    f.write(serialized)

                return {
                    "type": "file_reference",
                    "path": temp_path,
                    "line_count": line_count,
                    "message": f"Output too large ({line_count} lines), written to file",
                }
            except Exception:
                os.close(fd)
                raise

        return result

    except Exception:
        return result

```

`src/ida_pro_mcp/ida_mcp/zeromcp/__init__.py`:

```py
# NOTE: Vendored from zeromcp 1.3.0

from .mcp import McpRpcRegistry, McpToolError, McpServer, McpHttpRequestHandler

__all__ = ["McpRpcRegistry", "McpToolError", "McpServer", "McpHttpRequestHandler"]

```

`src/ida_pro_mcp/ida_mcp/zeromcp/jsonrpc.py`:

```py
import json
import inspect
import os
import threading
import time
import traceback
from typing import Any, Callable, get_type_hints, get_origin, get_args, Union, TypedDict, TypeAlias, NotRequired, is_typeddict
from types import UnionType

JsonRpcId: TypeAlias = str | int | float | None

# Thread-local storage for current request context (ID + cancel event)
_current_request = threading.local()

# Global pending requests for cancellation
_pending_requests_lock = threading.Lock()
_pending_requests: dict[int | str, threading.Event] = {}


def get_current_request_id() -> JsonRpcId:
    """Get the JSON-RPC request ID of the currently executing request."""
    return getattr(_current_request, "id", None)


def get_current_cancel_event() -> threading.Event | None:
    """Get the cancel event for the currently executing request."""
    return getattr(_current_request, "cancel_event", None)


def register_pending_request(request_id: int | str) -> threading.Event:
    """Register a request as pending and return its cancel event."""
    event = threading.Event()
    with _pending_requests_lock:
        _pending_requests[request_id] = event
    _current_request.cancel_event = event
    return event


def unregister_pending_request(request_id: int | str) -> None:
    """Unregister a pending request."""
    with _pending_requests_lock:
        _pending_requests.pop(request_id, None)
    _current_request.cancel_event = None


def cancel_request(request_id: int | str) -> bool:
    """Signal cancellation for a pending request. Returns True if request was found."""
    with _pending_requests_lock:
        event = _pending_requests.get(request_id)
        if event:
            event.set()
            return True
    return False


def _parse_bool_env(name: str, default: bool) -> bool:
    value = os.getenv(name)
    if value is None:
        return default
    value = value.strip().lower()
    if value in ("1", "true", "yes", "on"):
        return True
    if value in ("0", "false", "no", "off"):
        return False
    return default


_LOG_REQUESTS = _parse_bool_env("IDA_MCP_LOG_REQUESTS", True)
_LOG_SKIP_METHODS = {
    m.strip()
    for m in os.getenv("IDA_MCP_LOG_SKIP_METHODS", "tools/call").split(",")
    if m.strip()
}
JsonRpcParams: TypeAlias = dict[str, Any] | list[Any] | None

class JsonRpcRequest(TypedDict):
    jsonrpc: str
    method: str
    params: NotRequired[JsonRpcParams]
    id: NotRequired[JsonRpcId]

class JsonRpcError(TypedDict):
    code: int
    message: str
    data: NotRequired[Any]

class JsonRpcResponse(TypedDict):
    jsonrpc: str
    result: NotRequired[Any]
    error: NotRequired[JsonRpcError]
    id: JsonRpcId

class JsonRpcException(Exception):
    def __init__(self, code: int, message: str, data: Any = None):
        self.code = code
        self.message = message
        self.data = data


class RequestCancelledError(Exception):
    """Base class for request cancellation errors (LSP error code -32800)."""
    pass

class JsonRpcRegistry:
    def __init__(self):
        self.methods: dict[str, Callable] = {}
        self._cache: dict[Callable, tuple[inspect.Signature, dict, list[str]]] = {}
        self.redact_exceptions = False

    def method(self, func: Callable, name: str | None = None) -> Callable:
        self.methods[name or func.__name__] = func # type: ignore
        return func

    def dispatch(self, request: dict | str | bytes | bytearray) -> JsonRpcResponse | None:
        try:
            if not isinstance(request, dict):
                request = json.loads(request)
            if not isinstance(request, dict):
                return self._error(None, -32600, "Invalid request: must be a JSON object")
        except Exception as e:
            return self._error(None, -32700, "JSON parse error", str(e))

        if request.get("jsonrpc") != "2.0":
            return self._error(None, -32600, "Invalid request: 'jsonrpc' must be '2.0'")

        method = request.get("method")
        if method is None:
            return self._error(None, -32600, "Invalid request: 'method' is required")
        if not isinstance(method, str):
            return self._error(None, -32600, "Invalid request: 'method' must be a string")

        request_id: JsonRpcId = request.get("id")
        is_notification = "id" not in request
        params: JsonRpcParams = request.get("params")

        log_method = _LOG_REQUESTS and method not in _LOG_SKIP_METHODS
        if log_method:
            params_str = json.dumps(params, default=str)
            if len(params_str) > 200:
                params_str = params_str[:200] + "..."
            print(f"[MCP] >> {method}({params_str})")

        # Set current request ID in thread-local for cancellation tracking
        _current_request.id = request_id
        start_time = time.perf_counter()
        try:
            result = self._call(method, params)
            elapsed_ms = (time.perf_counter() - start_time) * 1000
            if log_method:
                result_str = json.dumps(result, default=str)
                if len(result_str) > 200:
                    result_str = result_str[:200] + "..."
                print(f"[MCP] << {method} ({elapsed_ms:.1f}ms) {result_str}")
            if is_notification:
                return None
            return {
                "jsonrpc": "2.0",
                "result": result,
                "id": request_id,
            }
        except JsonRpcException as e:
            elapsed_ms = (time.perf_counter() - start_time) * 1000
            if log_method:
                print(f"[MCP] << {method} ({elapsed_ms:.1f}ms) ERROR: {e.message}")
            if is_notification:
                return None
            return self._error(request_id, e.code, e.message, e.data)
        except RequestCancelledError as e:
            # LSP error code -32800: Request cancelled
            elapsed_ms = (time.perf_counter() - start_time) * 1000
            if log_method:
                print(f"[MCP] << {method} ({elapsed_ms:.1f}ms) CANCELLED")
            if is_notification:
                return None
            return self._error(request_id, -32800, str(e) or "Request cancelled")
        except Exception as e:
            elapsed_ms = (time.perf_counter() - start_time) * 1000
            if log_method:
                print(f"[MCP] << {method} ({elapsed_ms:.1f}ms) EXCEPTION: {e}")
            if is_notification:
                return None
            error = self.map_exception(e)
            return self._error(request_id, error["code"], error["message"], error.get("data"))
        finally:
            _current_request.id = None

    def map_exception(self, e: Exception) -> JsonRpcError:
        if self.redact_exceptions:
            return {
                "code": -32603,
                "message": f"Internal Error: {str(e)}",
            }
        return {
            "code": -32603,
            "message": "\n".join(traceback.format_exception(e)).strip() + "\n\nPlease report a bug!",
        }

    def _call(self, method: str, params: Any) -> Any:
        if method not in self.methods:
            raise JsonRpcException(-32601, f"Method '{method}' not found")

        func = self.methods[method]

        # Check for cached reflection data
        if func not in self._cache:
            sig = inspect.signature(func)
            hints = get_type_hints(func)
            hints.pop("return", None)

            # Determine required vs optional parameters
            required_params = []
            for param_name, param in sig.parameters.items():
                if param.default is inspect.Parameter.empty:
                    required_params.append(param_name)

            self._cache[func] = (sig, hints, required_params)

        sig, hints, required_params = self._cache[func]

        # Handle None params
        if params is None:
            if len(required_params) == 0:
                return func()
            else:
                raise JsonRpcException(-32602, "Missing required params")

        # Convert list params to dict by parameter names
        if isinstance(params, list):
            if len(params) < len(required_params):
                raise JsonRpcException(
                    -32602,
                    f"Invalid params: expected at least {len(required_params)} arguments, got {len(params)}"
                )
            if len(params) > len(sig.parameters):
                raise JsonRpcException(
                    -32602,
                    f"Invalid params: expected at most {len(sig.parameters)} arguments, got {len(params)}"
                )
            params = dict(zip(sig.parameters.keys(), params))

        # Validate dict params
        if isinstance(params, dict):
            # Check all required params are present
            missing = set(required_params) - set(params.keys())
            if missing:
                raise JsonRpcException(
                    -32602,
                    f"Invalid params: missing required parameters: {list(missing)}"
                )

            # Check no extra params
            extra = set(params.keys()) - set(sig.parameters.keys())
            if extra:
                raise JsonRpcException(
                    -32602,
                    f"Invalid params: unexpected parameters: {list(extra)}"
                )

            validated_params = {}
            for param_name, value in params.items():
                # If no type hint, pass through without validation
                if param_name not in hints:
                    validated_params[param_name] = value
                    continue

                # Has type hint, validate
                expected_type = hints[param_name]

                # Inline type validation
                origin = get_origin(expected_type)
                args = get_args(expected_type)

                # Handle None/null
                if value is None:
                    if expected_type is not type(None):
                        # Check if None is allowed in a Union
                        if not (origin in (Union, UnionType) and type(None) in args):
                            raise JsonRpcException(-32602, f"Invalid params: {param_name} cannot be null")
                    validated_params[param_name] = None
                    continue

                # Handle Union types (int | str, Optional[int], etc.)
                if origin in (Union, UnionType):
                    type_matched = False

                    # HACK: Try to parse str as JSON for non-str unions
                    # 
                    # When JSON schema says one field is "object", Claude Code
                    # (and maybe other MCP clients) can't (or won't) detect
                    # that the field is actually a dict/list. Instead, they
                    # treat the field as a string containing JSON object.
                    #
                    # To work around this, if the expected type is a Union
                    # that does not include str, and the provided value is
                    # a str, we try to parse it as JSON first.
                    if type(str) not in args and isinstance(value, str):
                        try:
                            value = json.loads(value)
                        except json.JSONDecodeError:
                            pass

                    for arg_type in args:
                        if arg_type is type(None):
                            continue

                        arg_origin = get_origin(arg_type)
                        check_type = arg_origin if arg_origin is not None else arg_type

                        # TypedDict cannot be used with isinstance - check for dict instead
                        if is_typeddict(arg_type):
                            check_type = dict

                        if isinstance(value, check_type):
                            type_matched = True
                            break

                    if not type_matched:
                        raise JsonRpcException(-32602, "Invalid params: expected {} for {}, got {}".format(
                            " | ".join(
                                t.__name__ if isinstance(t, type) else str(t)
                                for t in args
                            ),
                            param_name,
                            type(value).__name__
                        ))
                    validated_params[param_name] = value
                    continue

                # Handle generic types (list[X], dict[K,V])
                if origin is not None:
                    if not isinstance(value, origin):
                        raise JsonRpcException(
                            -32602,
                            f"Invalid params: {param_name} expected {origin.__name__}, got {type(value).__name__}"
                        )
                    validated_params[param_name] = value
                    continue

                # Handle TypedDict (must check before basic types)
                if is_typeddict(expected_type):
                    if not isinstance(value, dict):
                        raise JsonRpcException(
                            -32602,
                            f"Invalid params: {param_name} expected dict, got {type(value).__name__}"
                        )
                    validated_params[param_name] = value
                    continue

                # Handle Any
                if expected_type is Any:
                    validated_params[param_name] = value
                    continue

                # Handle basic types
                if isinstance(expected_type, type):
                    # Allow int -> float conversion
                    if expected_type is float and isinstance(value, int):
                        validated_params[param_name] = float(value)
                        continue
                    if not isinstance(value, expected_type):
                        raise JsonRpcException(
                            -32602,
                            f"Invalid params: {param_name} expected {expected_type.__name__}, got {type(value).__name__}"
                        )
                    validated_params[param_name] = value
                    continue

            return func(**validated_params)

        else:
            raise JsonRpcException(-32602, "Invalid params: must be array or object")

    def _error(self, request_id: JsonRpcId, code: int, message: str, data: Any = None) -> JsonRpcResponse | None:
        error: JsonRpcError = {
            "code": code,
            "message": message,
        }
        if data is not None:
            error["data"] = data
        return {
            "jsonrpc": "2.0",
            "error": error,
            "id": request_id,
        }

```

`src/ida_pro_mcp/ida_mcp/zeromcp/mcp.py`:

```py
import re
import sys
import time
import uuid
import json
import gzip
import zlib
import inspect
import threading
import traceback
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer, HTTPServer
from typing import Any, Callable, Union, Annotated, BinaryIO, NotRequired, get_origin, get_args, get_type_hints, is_typeddict
from types import UnionType
from urllib.parse import urlparse, parse_qs
from io import BufferedIOBase

from .jsonrpc import JsonRpcRegistry, JsonRpcError, JsonRpcException, get_current_request_id, register_pending_request, unregister_pending_request, cancel_request

class McpToolError(Exception):
    def __init__(self, message: str):
        super().__init__(message)

class McpRpcRegistry(JsonRpcRegistry):
    """JSON-RPC registry with custom error handling for MCP tools"""
    def map_exception(self, e: Exception) -> JsonRpcError:
        if isinstance(e, McpToolError):
            return {
                "code": -32000,
                "message": e.args[0] or "MCP Tool Error",
            }
        return super().map_exception(e)

class _McpSseConnection:
    """Manages a single SSE client connection"""
    def __init__(self, wfile):
        self.wfile: BufferedIOBase = wfile
        self.session_id = str(uuid.uuid4())
        self.alive = True

    def send_event(self, event_type: str, data):
        """Send an SSE event to the client

        Args:
            event_type: Type of event (e.g., "endpoint", "message", "ping")
            data: Event data - can be string (sent as-is) or dict (JSON-encoded)
        """
        if not self.alive:
            return False

        try:
            # SSE format: "event: type\ndata: content\n\n"
            if isinstance(data, str):
                data_str = f"data: {data}\n\n"
            else:
                data_str = f"data: {json.dumps(data)}\n\n"
            message = f"event: {event_type}\n{data_str}".encode("utf-8")
            self.wfile.write(message)
            self.wfile.flush()  # Ensure data is sent immediately
            return True
        except (BrokenPipeError, OSError):
            self.alive = False
            return False

class McpHttpRequestHandler(BaseHTTPRequestHandler):
    server_version = "zeromcp/1.3.0"
    error_message_format = "%(code)d - %(message)s"
    error_content_type = "text/plain"

    def __init__(self, request, client_address, server):
        self.mcp_server: "McpServer" = getattr(server, "mcp_server")
        super().__init__(request, client_address, server)

    def _parse_extensions(self, path: str) -> set[str]:
        """Parse ?ext=dbg,foo query param into set of enabled extensions"""
        query = parse_qs(urlparse(path).query)
        ext_param = query.get("ext", [""])[0]
        if not ext_param:
            return set()
        return {e.strip() for e in ext_param.split(",") if e.strip()}

    def log_message(self, format, *args):
        """Override to suppress default logging or customize"""
        pass

    def send_cors_headers(self, *, preflight = False):
        origin = self.headers.get("Origin", "")
        if not origin:
            return
        def is_allowed():
            allowed = self.mcp_server.cors_allowed_origins
            if allowed is None:
                return False
            if callable(allowed):
                return allowed(origin)
            if isinstance(allowed, str):
                allowed = [allowed]
            assert isinstance(allowed, list)
            return "*" in allowed or origin in allowed
        if not is_allowed():
            return
        self.send_header("Access-Control-Allow-Origin", origin)
        if preflight:
            self.send_header("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
            self.send_header("Access-Control-Allow-Headers", "Content-Type, Accept, X-Requested-With, Mcp-Session-Id, Mcp-Protocol-Version")
            if self.headers.get("Access-Control-Request-Private-Network") == "true":
                self.send_header("Access-Control-Allow-Private-Network", "true")

    def send_error(self, code, message=None, explain=None):
        self.send_response(code)
        self.send_header("Content-Type", "text/plain")
        self.send_cors_headers()
        self.end_headers()
        self.wfile.write(f"{message}\n".encode("utf-8"))

    def handle(self):
        """Override to add error handling for connection errors"""
        try:
            super().handle()
        except (ConnectionAbortedError, ConnectionResetError, BrokenPipeError):
            # Client disconnected - normal, suppress traceback
            pass

    def do_GET(self):
        match urlparse(self.path).path:
            case "/sse":
                self._handle_sse_get()
            case "/mcp":
                self.send_error(405, "Method Not Allowed")
            case _:
                self.send_error(404, "Not Found")

    def do_POST(self):
        body = self._read_body()
        if body is None:
            return

        match urlparse(self.path).path:
            case "/sse":
                self._handle_sse_post(body)
            case "/mcp":
                self._handle_mcp_post(body)
            case _:
                self.send_error(404, "Not Found")

    def do_OPTIONS(self):
        """Handle CORS preflight requests"""
        self.send_response(200)
        self.send_cors_headers(preflight=True)
        self.end_headers()

    def _read_body(self) -> bytes | None:
        if "chunked" in self.headers.get("Transfer-Encoding", "").lower():
            raw = self._read_chunked()
        else:
            content_length = int(self.headers.get("Content-Length", 0))
            if content_length > self.mcp_server.post_body_limit:
                self.send_error(413, f"Payload Too Large: exceeds {self.mcp_server.post_body_limit} bytes")
                return None
            raw = self.rfile.read(content_length) if content_length > 0 else b""

        if len(raw) > self.mcp_server.post_body_limit:
            self.send_error(413, f"Payload Too Large: exceeds {self.mcp_server.post_body_limit} bytes")
            return None

        return self._decompress_body(raw)

    def _read_chunked(self) -> bytes:
        body = b""
        while True:
            line = self.rfile.readline().split(b";")[0].strip()
            chunk_size = int(line, 16)
            if chunk_size == 0:
                # Consume trailer fields until blank line
                while self.rfile.readline().strip():
                    pass
                break
            body += self.rfile.read(chunk_size)
            self.rfile.readline()
        return body

    def _decompress_body(self, data: bytes) -> bytes:
        encoding = self.headers.get("Content-Encoding", "").lower().strip()
        if encoding in ("gzip", "x-gzip"):
            return gzip.decompress(data)
        elif encoding == "deflate":
            if data[:1] == b'\x78':
                return zlib.decompress(data)
            else:
                return zlib.decompress(data, -15)
        return data

    def _handle_sse_get(self):
        # Create SSE connection wrapper
        conn = _McpSseConnection(self.wfile)
        self.mcp_server._sse_connections[conn.session_id] = conn

        try:
            # Send SSE headers
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.send_cors_headers()
            self.end_headers()

            # Send endpoint event with session ID for routing
            conn.send_event("endpoint", f"/sse?session={conn.session_id}")

            # Keep connection alive with periodic pings
            last_ping = time.time()
            while conn.alive and self.mcp_server._running:
                now = time.time()
                if now - last_ping > 30:  # Ping every 30 seconds
                    if not conn.send_event("ping", {}):
                        break
                    last_ping = now
                time.sleep(1)

        finally:
            conn.alive = False
            if conn.session_id in self.mcp_server._sse_connections:
                del self.mcp_server._sse_connections[conn.session_id]

    def _handle_sse_post(self, body: bytes):
        query_params = parse_qs(urlparse(self.path).query)
        session_id = query_params.get("session", [None])[0]
        if session_id is None:
            self.send_error(400, "Missing ?session for SSE POST")
            return

        # Parse extensions from query params and store in thread-local
        extensions = self._parse_extensions(self.path)
        setattr(self.mcp_server._enabled_extensions, "data", extensions)

        # Dispatch to MCP registry
        setattr(self.mcp_server._protocol_version, "data", "2024-11-05")
        response = self.mcp_server.registry.dispatch(body)

        # Send SSE response if necessary
        if response is not None:
            sse_conn = self.mcp_server._sse_connections.get(session_id)
            if sse_conn is None or not sse_conn.alive:
                # No SSE connection found
                self.send_error(400, f"No active SSE connection found for session {session_id}")
                return

            # Send response via SSE event stream
            sse_conn.send_event("message", response)

        # Return 202 Accepted to acknowledge POST
        self.send_response(202)
        self.send_header("Content-Type", "application/json")
        self.send_header("Content-Length", str(len(body)))
        self.send_cors_headers()
        self.end_headers()
        self.wfile.write(body)

    def _handle_mcp_post(self, body: bytes):
        # Parse extensions from query params and store in thread-local
        extensions = self._parse_extensions(self.path)
        setattr(self.mcp_server._enabled_extensions, "data", extensions)

        # Dispatch to MCP registry
        setattr(self.mcp_server._protocol_version, "data", "2025-06-18")
        response = self.mcp_server.registry.dispatch(body)

        def send_response(status: int, body: bytes):
            self.send_response(status)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(body)))
            self.send_cors_headers()
            self.end_headers()
            self.wfile.write(body)

        # Check if notification (returns None)
        if response is None:
            send_response(202, b"Accepted")
        else:
            send_response(200, json.dumps(response).encode("utf-8"))

class McpServer:
    def __init__(self, name: str, version = "1.0.0", *, extensions: dict[str, set[str]] | None = None):
        self.name = name
        self.version = version
        self.cors_allowed_origins: Callable[[str], bool] | list[str] | str | None = self.cors_localhost
        self.post_body_limit = 10 * 1024 * 1024  # 10MB
        self.tools = McpRpcRegistry()
        self.resources = McpRpcRegistry()
        self.prompts = McpRpcRegistry()

        self._http_server: HTTPServer | None = None
        self._server_thread: threading.Thread | None = None
        self._running = False
        self._sse_connections: dict[str, _McpSseConnection] = {}
        self._protocol_version = threading.local()
        self._enabled_extensions = threading.local()  # set[str] per request
        self._extensions_registry = extensions if extensions is not None else {}  # group -> set of tool names

        # Register MCP protocol methods with correct names
        self.registry = JsonRpcRegistry()
        self.registry.methods["ping"] = self._mcp_ping
        self.registry.methods["initialize"] = self._mcp_initialize
        self.registry.methods["tools/list"] = self._mcp_tools_list
        self.registry.methods["tools/call"] = self._mcp_tools_call
        self.registry.methods["resources/list"] = self._mcp_resources_list
        self.registry.methods["resources/templates/list"] = self._mcp_resource_templates_list
        self.registry.methods["resources/read"] = self._mcp_resources_read
        self.registry.methods["prompts/list"] = self._mcp_prompts_list
        self.registry.methods["prompts/get"] = self._mcp_prompts_get
        self.registry.methods["notifications/cancelled"] = self._mcp_notifications_cancelled

    def tool(self, func: Callable) -> Callable:
        return self.tools.method(func)

    def resource(self, uri: str) -> Callable[[Callable], Callable]:
        def decorator(func: Callable) -> Callable:
            setattr(func, "__resource_uri__", uri)
            return self.resources.method(func)
        return decorator

    def prompt(self, func: Callable) -> Callable:
        return self.prompts.method(func)

    def serve(self, host: str, port: int, *, background = True, request_handler = McpHttpRequestHandler):
        if self._running:
            print("[MCP] Server is already running")
            return

        # Create server with deferred binding
        assert issubclass(request_handler, McpHttpRequestHandler)
        self._http_server = (ThreadingHTTPServer if background else HTTPServer)(
            (host, port),
            request_handler,
            bind_and_activate=False
        )
        self._http_server.allow_reuse_address = True
        if hasattr(self._http_server, "allow_reuse_port"):
            self._http_server.allow_reuse_port = True

        # Set the MCPServer instance on the handler class
        setattr(self._http_server, "mcp_server", self)

        try:
            # Bind and activate in main thread - errors propagate synchronously
            self._http_server.server_bind()
            self._http_server.server_activate()
        except OSError:
            # Cleanup on binding failure
            self._http_server.server_close()
            self._http_server = None
            raise

        # Only start thread after successful bind
        self._running = True

        print("[MCP] Server started:")
        print(f"  Streamable HTTP: http://{host}:{port}/mcp")
        print(f"  SSE: http://{host}:{port}/sse")

        def serve_forever():
            try:
                self._http_server.serve_forever() # type: ignore
            except Exception as e:
                print(f"[MCP] Server error: {e}")
                traceback.print_exc()
            finally:
                self._running = False

        if background:
            self._server_thread = threading.Thread(target=serve_forever, daemon=True)
            self._server_thread.start()
        else:
            serve_forever()

    def stop(self):
        if not self._running:
            return

        self._running = False

        # Close all SSE connections
        for conn in self._sse_connections.values():
            conn.alive = False
        self._sse_connections.clear()

        # Shutdown the HTTP server
        if self._http_server:
            # shutdown() must be called from a different thread
            # than the one running serve_forever()
            self._http_server.shutdown()
            self._http_server.server_close()
            self._http_server = None

        if self._server_thread:
            self._server_thread.join()
            self._server_thread = None

        print("[MCP] Server stopped")

    def stdio(self, stdin: BinaryIO | None = None, stdout: BinaryIO | None = None):
        stdin = stdin or sys.stdin.buffer
        stdout = stdout or sys.stdout.buffer
        while True:
            try:
                request = stdin.readline()
                if not request: # EOF
                    break

                # Strip whitespace (trailing newline) before parsing
                request = request.strip()
                if not request:
                    continue

                response = self.registry.dispatch(request)
                if response is not None:
                    stdout.write(json.dumps(response).encode("utf-8") + b"\n")
                    stdout.flush()
            except (BrokenPipeError, KeyboardInterrupt): # Client disconnected
                break

    def cors_localhost(self, origin: str) -> bool:
        """Allow CORS requests from localhost on ANY port."""
        return urlparse(origin).hostname in ("localhost", "127.0.0.1", "::1")

    def _mcp_ping(self, _meta: dict | None = None) -> dict:
        """MCP ping method"""
        return {}

    def _mcp_initialize(self, protocolVersion: str, capabilities: dict, clientInfo: dict, _meta: dict | None = None) -> dict:
        """MCP initialize method"""
        return {
            "protocolVersion": getattr(self._protocol_version, "data", protocolVersion),
            "capabilities": {
                "tools": {},
                "resources": {
                    "subscribe": False,
                    "listChanged": False,
                },
                "prompts": {},
            },
            "serverInfo": {
                "name": self.name,
                "version": self.version,
            },
        }

    def _mcp_tools_list(self, _meta: dict | None = None) -> dict:
        """MCP tools/list method"""
        enabled = getattr(self._enabled_extensions, "data", set())
        tools = []
        for func_name, func in self.tools.methods.items():
            # Check if tool belongs to an extension group
            tool_group = self._get_tool_extension(func_name)
            if tool_group and tool_group not in enabled:
                continue  # Skip tools from disabled extension groups
            tools.append(self._generate_tool_schema(func_name, func))
        return {"tools": tools}

    def _get_tool_extension(self, func_name: str) -> str | None:
        """Return extension group name if tool belongs to one, else None"""
        for group, tools in self._extensions_registry.items():
            if func_name in tools:
                return group
        return None

    def _mcp_tools_call(self, name: str, arguments: dict | None = None, _meta: dict | None = None) -> dict:
        """MCP tools/call method"""
        # Check if tool requires an extension that isn't enabled
        enabled = getattr(self._enabled_extensions, "data", set())
        tool_group = self._get_tool_extension(name)
        if tool_group and tool_group not in enabled:
            return {
                "content": [{"type": "text", "text": f"Tool '{name}' requires extension '{tool_group}'. Enable with ?ext={tool_group}"}],
                "isError": True,
            }

        # Register request for cancellation tracking
        request_id = get_current_request_id()
        if request_id is not None:
            register_pending_request(request_id)

        try:
            # Wrap tool call in JSON-RPC request
            tool_response = self.tools.dispatch({
                "jsonrpc": "2.0",
                "method": name,
                "params": arguments,
                "id": None,
            })

            # Check for error response
            if tool_response and "error" in tool_response:
                error = tool_response["error"]
                return {
                    "content": [{"type": "text", "text": error.get("message", "Unknown error")}],
                    "isError": True,
                }

            result = tool_response.get("result") if tool_response else None
            return {
                "content": [{"type": "text", "text": json.dumps(result, indent=2)}],
                "structuredContent": result if isinstance(result, dict) else {"result": result},
                "isError": False,
            }
        finally:
            if request_id is not None:
                unregister_pending_request(request_id)

    def _mcp_notifications_cancelled(self, requestId: int | str, reason: str | None = None) -> None:
        """MCP notifications/cancelled - cancel an in-flight request"""
        if cancel_request(requestId):
            print(f"[MCP] Cancelled request {requestId}: {reason or 'no reason'}")
        # Notifications don't return a response

    def _mcp_resources_list(self, _meta: dict | None = None) -> dict:
        """MCP resources/list method - returns static resources only (no URI parameters)"""
        resources = []
        for func_name, func in self.resources.methods.items():
            uri: str = getattr(func, "__resource_uri__")

            # Skip templates (resources with parameters like {addr})
            if "{" in uri:
                continue

            resources.append({
                "uri": uri,
                "name": func_name,
                "description": (func.__doc__ or f"Read {uri}").strip(),
                "mimeType": "application/json",
            })

        return {"resources": resources}

    def _mcp_resource_templates_list(self, _meta: dict | None = None) -> dict:
        """MCP resources/templates/list method - returns parameterized resource templates"""
        templates = []
        for func_name, func in self.resources.methods.items():
            uri: str = getattr(func, "__resource_uri__")

            # Only include templates (resources with parameters like {addr})
            if "{" not in uri:
                continue

            templates.append({
                "uriTemplate": uri,
                "name": func_name,
                "description": (func.__doc__ or f"Read {uri}").strip(),
                "mimeType": "application/json",
            })

        return {"resourceTemplates": templates}

    def _mcp_resources_read(self, uri: str, _meta: dict | None = None) -> dict:
        """MCP resources/read method"""

        # Try to match URI against all registered resource patterns
        for func_name, func in self.resources.methods.items():
            pattern: str = getattr(func, "__resource_uri__")

            # Convert pattern to regex, replacing {param} with named capture groups
            regex_pattern = re.sub(r"\{(\w+)\}", r"(?P<\1>[^/]+)", pattern)
            regex_pattern = f"^{regex_pattern}$"

            match = re.match(regex_pattern, uri)
            if match:
                # Found matching resource - call it via JSON-RPC
                params = list(match.groupdict().values())

                tool_response = self.resources.dispatch({
                    "jsonrpc": "2.0",
                    "method": func_name,
                    "params": params,
                    "id": None,
                })

                if tool_response and "error" in tool_response:
                    error = tool_response["error"]
                    return {
                        "contents": [{
                            "uri": uri,
                            "mimeType": "application/json",
                            "text": json.dumps({"error": error.get("message", "Unknown error")}, indent=2),
                        }],
                        "isError": True,
                    }

                result = tool_response.get("result") if tool_response else None
                return {
                    "contents": [{
                        "uri": uri,
                        "mimeType": "application/json",
                        "text": json.dumps(result, indent=2),
                    }]
                }

        # No matching resource found
        available: list[str] = [getattr(f, "__resource_uri__") for f in self.resources.methods.values()]
        return {
            "contents": [{
                "uri": uri,
                "mimeType": "application/json",
                "text": json.dumps({
                    "error": f"Resource not found: {uri}",
                    "available_patterns": available,
                }, indent=2),
            }],
            "isError": True,
        }

    def _mcp_prompts_list(self, _meta: dict | None = None) -> dict:
        """MCP prompts/list method"""
        return {
            "prompts": [
                self._generate_prompt_schema(func_name, func)
                for func_name, func in self.prompts.methods.items()
            ],
        }

    def _mcp_prompts_get(
        self, name: str, arguments: dict | None = None, _meta: dict | None = None
    ) -> dict:
        """MCP prompts/get method"""
        # Dispatch to prompts registry
        prompt_response = self.prompts.dispatch(
            {
                "jsonrpc": "2.0",
                "method": name,
                "params": arguments,
                "id": None,
            }
        )
        assert prompt_response is not None, "Only notification requests return None"

        # Check for error response
        if "error" in prompt_response:
            error = prompt_response["error"]
            raise JsonRpcException(error["code"], error["message"], error.get("data"))

        result = prompt_response.get("result")

        # Pass through list of messages directly
        if isinstance(result, list):
            return {"messages": result}

        # Convert non-string results to JSON
        if not isinstance(result, str):
            result = json.dumps(result, indent=2)
        return {
            "messages": [
                {
                    "role": "user",
                    "content": {"type": "text", "text": result},
                },
            ],
        }

    def _generate_prompt_schema(self, func_name: str, func: Callable) -> dict:
        """Generate MCP prompt schema from a function"""
        hints = get_type_hints(func, include_extras=True)
        hints.pop("return", None)
        sig = inspect.signature(func)

        # Build arguments list (PromptArgument format)
        arguments = []
        for param_name, param_type in hints.items():
            arg: dict[str, Any] = {"name": param_name}

            # Extract description from Annotated
            origin = get_origin(param_type)
            if origin is Annotated:
                args = get_args(param_type)
                arg["description"] = str(args[-1])

            # Check if required (no default value)
            param = sig.parameters.get(param_name)
            if not param or param.default is inspect.Parameter.empty:
                arg["required"] = True

            arguments.append(arg)

        schema: dict[str, Any] = {
            "name": func_name,
            "description": (func.__doc__ or f"Prompt {func_name}").strip(),
        }

        if arguments:
            schema["arguments"] = arguments

        return schema

    def _type_to_json_schema(self, py_type: Any) -> dict:
        """Convert Python type hint to JSON schema object"""
        origin = get_origin(py_type)
        # Annotated[T, "description"]
        if origin is Annotated:
            args = get_args(py_type)
            return {
                **self._type_to_json_schema(args[0]),
                "description": str(args[-1]),
            }

        # NotRequired[T]
        if origin is NotRequired:
            return self._type_to_json_schema(get_args(py_type)[0])

        # Union[Ts..], Optional[T] and T1 | T2
        if origin in (Union, UnionType):
            return {"anyOf": [self._type_to_json_schema(t) for t in get_args(py_type)]}

        # list[T]
        if origin is list:
            return {
                "type": "array",
                "items": self._type_to_json_schema(get_args(py_type)[0]),
            }

        # dict[str, T]
        if origin is dict:
            return {
                "type": "object",
                "additionalProperties": self._type_to_json_schema(get_args(py_type)[1]),
            }

        # TypedDict
        if is_typeddict(py_type):
            return self._typed_dict_to_schema(py_type)

        # Primitives
        return {
            "type": {
                int: "integer",
                float: "number",
                str: "string",
                bool: "boolean",
                list: "array",
                dict: "object",
                type(None): "null",
            }.get(py_type, "object"),
        }

    def _typed_dict_to_schema(self, typed_dict_class) -> dict:
        """Convert TypedDict to JSON schema"""
        hints = get_type_hints(typed_dict_class, include_extras=True)
        required_keys = getattr(typed_dict_class, '__required_keys__', set(hints.keys()))

        return {
            "type": "object",
            "properties": {
                field_name: self._type_to_json_schema(field_type)
                for field_name, field_type in hints.items()
            },
            "required": [key for key in hints.keys() if key in required_keys],
            "additionalProperties": False
        }

    def _generate_tool_schema(self, func_name: str, func: Callable) -> dict:
        """Generate MCP tool schema from a function"""
        hints = get_type_hints(func, include_extras=True)
        return_type = hints.pop("return", None)
        sig = inspect.signature(func)

        # Build parameter schema
        properties = {}
        required = []

        for param_name, param_type in hints.items():
            properties[param_name] = self._type_to_json_schema(param_type)

            # Add to required if no default value
            param = sig.parameters.get(param_name)
            if not param or param.default is inspect.Parameter.empty:
                required.append(param_name)

        schema: dict[str, Any] = {
            "name": func_name,
            "description": (func.__doc__ or f"Call {func_name}").strip(),
            "inputSchema": {
                "type": "object",
                "properties": properties,
                "required": required,
            }
        }

        # Add outputSchema if return type exists and is not None
        if return_type and return_type is not type(None):
            return_schema = self._type_to_json_schema(return_type)

            # Wrap non-object returns in a "result" property
            if return_schema.get("type") != "object":
                return_schema = {
                    "type": "object",
                    "properties": {"result": return_schema},
                    "required": ["result"],
                }

            schema["outputSchema"] = return_schema

        return schema

```

`src/ida_pro_mcp/idalib_server.py`:

```py
import sys
import signal
import logging
import argparse
from pathlib import Path

# idapro must go first to initialize idalib
import idapro

from ida_pro_mcp.ida_mcp import MCP_SERVER

"""IDALib-specific MCP tools for managing multiple binary sessions
"""
from typing import Annotated, Optional
from ida_pro_mcp.ida_mcp.rpc import tool
from ida_pro_mcp.idalib_session_manager import get_session_manager


@tool
def idalib_open(
    input_path: Annotated[str, "Path to the binary file to analyze"],
    run_auto_analysis: Annotated[bool, "Run automatic analysis on the binary"] = True,
    session_id: Annotated[
        Optional[str], "Custom session ID (auto-generated if not provided)"
    ] = None,
) -> dict:
    """Open a binary file and create a new IDA session (idalib mode only)

    Opens a binary file for analysis and creates a new session. The binary will be
    analyzed in IDA's headless mode. If the file is already open, returns the existing
    session ID.

    Args:
        input_path: Path to the binary file to analyze
        run_auto_analysis: Whether to run IDA's automatic analysis (default: True)
        session_id: Optional custom session ID (default: auto-generated)

    Returns:
        Dictionary with session information:
        - session_id: Unique identifier for this session
        - input_path: Path to the binary file
        - filename: Name of the binary file
        - created_at: Session creation timestamp
        - is_analyzing: Whether analysis is currently running

    Example:
        ```json
        {
            "session_id": "a3f4c8b2",
            "input_path": "/path/to/binary.exe",
            "filename": "binary.exe",
            "created_at": "2025-12-25T10:30:00",
            "is_analyzing": false
        }
        ```
    """

    try:
        manager = get_session_manager()
        session_id_result = manager.open_binary(
            Path(input_path), run_auto_analysis=run_auto_analysis, session_id=session_id
        )

        session = manager.get_session(session_id_result)
        if session is None:
            return {
                "error": f"Failed to retrieve session after opening: {session_id_result}"
            }

        return {
            "success": True,
            "session": session.to_dict(),
            "message": f"Binary opened successfully: {session.input_path.name}",
        }
    except FileNotFoundError as e:
        return {"error": str(e)}
    except RuntimeError as e:
        return {"error": f"Failed to open binary: {e}"}
    except Exception as e:
        return {"error": f"Unexpected error: {e}"}


@tool
def idalib_close(session_id: Annotated[str, "Session ID to close"]) -> dict:
    """Close an IDA session and its associated database (idalib mode only)

    Closes the specified session and releases all associated resources. If this is
    the currently active session, the database will be closed.

    Args:
        session_id: Unique identifier of the session to close

    Returns:
        Dictionary with operation result:
        - success: Whether the operation succeeded
        - message: Descriptive message

    Example:
        ```json
        {
            "success": true,
            "message": "Session closed: a3f4c8b2"
        }
        ```
    """

    try:
        manager = get_session_manager()

        if manager.close_session(session_id):
            return {"success": True, "message": f"Session closed: {session_id}"}
        else:
            return {"success": False, "error": f"Session not found: {session_id}"}
    except Exception as e:
        return {"error": f"Failed to close session: {e}"}


@tool
def idalib_switch(session_id: Annotated[str, "Session ID to switch to"]) -> dict:
    """Switch to a different IDA session (idalib mode only)

    Switches the active session to the specified session. This closes the current
    database and opens the target session's database. All subsequent MCP tool calls
    will operate on the switched session.

    Args:
        session_id: Unique identifier of the session to switch to

    Returns:
        Dictionary with session information after switching:
        - success: Whether the switch succeeded
        - session: Current session details
        - message: Descriptive message

    Example:
        ```json
        {
            "success": true,
            "session": {
                "session_id": "a3f4c8b2",
                "filename": "binary.exe",
                "is_current": true
            },
            "message": "Switched to session: a3f4c8b2"
        }
        ```
    """

    try:
        manager = get_session_manager()

        if manager.switch_session(session_id):
            session = manager.get_current_session()
            if session is None:
                return {"error": "Failed to retrieve current session after switching"}

            return {
                "success": True,
                "session": session.to_dict(),
                "message": f"Switched to session: {session_id} ({session.input_path.name})",
            }
    except ValueError as e:
        return {"error": str(e)}
    except RuntimeError as e:
        return {"error": f"Failed to switch session: {e}"}
    except Exception as e:
        return {"error": f"Unexpected error: {e}"}


@tool
def idalib_list() -> dict:
    """List all open IDA sessions (idalib mode only)

    Returns a list of all currently open sessions with their metadata. The current
    active session is marked with is_current=true.

    Returns:
        Dictionary with sessions list:
        - sessions: List of session dictionaries
        - count: Total number of sessions
        - current_session_id: ID of the currently active session

    Example:
        ```json
        {
            "sessions": [
                {
                    "session_id": "a3f4c8b2",
                    "filename": "binary1.exe",
                    "input_path": "/path/to/binary1.exe",
                    "created_at": "2025-12-25T10:30:00",
                    "last_accessed": "2025-12-25T10:35:00",
                    "is_current": true,
                    "is_analyzing": false
                },
                {
                    "session_id": "b7e2d9f1",
                    "filename": "binary2.dll",
                    "input_path": "/path/to/binary2.dll",
                    "created_at": "2025-12-25T10:31:00",
                    "last_accessed": "2025-12-25T10:31:00",
                    "is_current": false,
                    "is_analyzing": false
                }
            ],
            "count": 2,
            "current_session_id": "a3f4c8b2"
        }
        ```
    """

    try:
        manager = get_session_manager()
        sessions = manager.list_sessions()
        current_session = manager.get_current_session()

        return {
            "sessions": sessions,
            "count": len(sessions),
            "current_session_id": current_session.session_id
            if current_session
            else None,
        }
    except Exception as e:
        return {"error": f"Failed to list sessions: {e}"}


@tool
def idalib_current() -> dict:
    """Get information about the current active IDA session (idalib mode only)

    Returns detailed information about the currently active session, or an error
    if no session is active.

    Returns:
        Dictionary with current session information:
        - session_id: Unique identifier
        - filename: Binary file name
        - input_path: Full path to the binary
        - created_at: Session creation timestamp
        - last_accessed: Last access timestamp
        - is_analyzing: Whether analysis is running
        - metadata: Additional session metadata

    Example:
        ```json
        {
            "session_id": "a3f4c8b2",
            "filename": "binary.exe",
            "input_path": "/path/to/binary.exe",
            "created_at": "2025-12-25T10:30:00",
            "last_accessed": "2025-12-25T10:35:00",
            "is_analyzing": false,
            "metadata": {}
        }
        ```
    """

    try:
        manager = get_session_manager()
        session = manager.get_current_session()

        if session is None:
            return {
                "error": "No active session. Use idalib_open() to open a binary first."
            }

        return session.to_dict()
    except Exception as e:
        return {"error": f"Failed to get current session: {e}"}


logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(description="MCP server for IDA Pro via idalib")
    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Show debug messages"
    )
    parser.add_argument(
        "--host",
        type=str,
        default="127.0.0.1",
        help="Host to listen on, default: 127.0.0.1",
    )
    parser.add_argument(
        "--port", type=int, default=8745, help="Port to listen on, default: 8745"
    )
    parser.add_argument(
        "--unsafe", action="store_true", help="Enable unsafe functions (DANGEROUS)"
    )
    parser.add_argument(
        "input_path",
        type=Path,
        nargs="?",  # Make input_path optional
        help="Path to the input file to analyze (optional, can be loaded dynamically via MCP tools).",
    )
    args = parser.parse_args()

    if args.verbose:
        log_level = logging.DEBUG
        idapro.enable_console_messages(True)
    else:
        log_level = logging.INFO
        idapro.enable_console_messages(False)

    logging.basicConfig(level=log_level)

    # reset logging levels that might be initialized in idapythonrc.py
    # which is evaluated during import of idalib.
    logging.getLogger().setLevel(log_level)

    # Initialize session manager for dynamic binary loading
    from ida_pro_mcp.idalib_session_manager import get_session_manager

    session_manager = get_session_manager()

    # Open initial binary if provided
    if args.input_path is not None:
        if not args.input_path.exists():
            raise FileNotFoundError(f"Input file not found: {args.input_path}")

        logger.info("opening initial database: %s", args.input_path)
        session_id = session_manager.open_binary(
            args.input_path, run_auto_analysis=True
        )
        logger.info(f"Initial session created: {session_id}")
    else:
        logger.info(
            "No initial binary specified. Use idalib_open() to load binaries dynamically."
        )

    # Setup signal handlers to ensure IDA database is properly closed on shutdown.
    # When a signal arrives, our handlers execute first, allowing us to close the
    # IDA database cleanly before the process terminates.
    def cleanup_and_exit(signum, frame):
        logger.info("Shutting down...")
        logger.info("Closing all IDA sessions...")
        session_manager.close_all_sessions()
        logger.info("All sessions closed.")
        sys.exit(0)

    signal.signal(signal.SIGINT, cleanup_and_exit)
    signal.signal(signal.SIGTERM, cleanup_and_exit)

    # NOTE: npx -y @modelcontextprotocol/inspector for debugging
    # TODO: with background=True the main thread (this one) does not fake any
    # work from @idasync, so we deadlock.
    MCP_SERVER.serve(host=args.host, port=args.port, background=False)


if __name__ == "__main__":
    main()

```

`src/ida_pro_mcp/idalib_session_manager.py`:

```py
"""IDALib Session Manager - Multi-binary management for headless MCP server

This module provides session management for multiple IDA databases in idalib mode.
Each session represents an opened binary with its own IDA database instance.
"""

import uuid
import threading
import logging
from pathlib import Path
from typing import Dict, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime

import idapro
import ida_auto

logger = logging.getLogger(__name__)


@dataclass
class IDASession:
    """Represents a single IDA database session"""

    session_id: str
    input_path: Path
    created_at: datetime = field(default_factory=datetime.now)
    last_accessed: datetime = field(default_factory=datetime.now)
    is_analyzing: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert session to dictionary format"""
        return {
            "session_id": self.session_id,
            "input_path": str(self.input_path),
            "filename": self.input_path.name,
            "created_at": self.created_at.isoformat(),
            "last_accessed": self.last_accessed.isoformat(),
            "is_analyzing": self.is_analyzing,
            "metadata": self.metadata,
        }


class IDASessionManager:
    """Manages multiple IDA database sessions for idalib mode"""

    def __init__(self):
        self._sessions: Dict[str, IDASession] = {}
        self._current_session_id: Optional[str] = None
        self._lock = threading.RLock()
        logger.info("IDASessionManager initialized")

    def open_binary(
        self,
        input_path: Path | str,
        run_auto_analysis: bool = True,
        session_id: Optional[str] = None,
    ) -> str:
        """Open a binary file and create a new session

        Args:
            input_path: Path to the binary file
            run_auto_analysis: Whether to run auto-analysis
            session_id: Optional custom session ID (auto-generated if not provided)

        Returns:
            Session ID for the opened binary

        Raises:
            FileNotFoundError: If the input file doesn't exist
            RuntimeError: If failed to open the database
        """
        input_path = Path(input_path)

        if not input_path.exists():
            raise FileNotFoundError(f"Input file not found: {input_path}")

        with self._lock:
            # Check if this file is already open
            for sid, session in self._sessions.items():
                if session.input_path.resolve() == input_path.resolve():
                    logger.info(f"Binary already open in session: {sid}")
                    self._current_session_id = sid
                    session.last_accessed = datetime.now()
                    return sid

            # Close current database if any (Do we need to close the database first?)
            if self._current_session_id is not None:
                logger.debug("Closing current database before opening new one")
                idapro.close_database()

            # Generate session ID
            if session_id is None:
                session_id = str(uuid.uuid4())[:8]

            # Open the database
            logger.info(f"Opening database: {input_path} (session: {session_id})")

            if idapro.open_database(
                str(input_path), run_auto_analysis=run_auto_analysis
            ):
                raise RuntimeError(f"Failed to open database: {input_path}")

            # Create session object
            session = IDASession(
                session_id=session_id,
                input_path=input_path,
                is_analyzing=run_auto_analysis,
            )

            self._sessions[session_id] = session
            self._current_session_id = session_id

            # Wait for analysis if requested
            if run_auto_analysis:
                logger.debug(
                    f"Waiting for auto-analysis to complete (session: {session_id})"
                )
                ida_auto.auto_wait()
                session.is_analyzing = False
                logger.info(f"Auto-analysis completed (session: {session_id})")

            logger.info(f"Session created: {session_id} for {input_path.name}")
            return session_id

    def close_session(self, session_id: str) -> bool:
        """Close a specific session and its database

        Args:
            session_id: Session ID to close

        Returns:
            True if closed successfully, False if session not found
        """
        with self._lock:
            if session_id not in self._sessions:
                logger.warning(f"Session not found: {session_id}")
                return False

            session = self._sessions[session_id]
            logger.info(f"Closing session: {session_id} ({session.input_path.name})")

            # If this is the current session, close the database
            if self._current_session_id == session_id:
                idapro.close_database()
                self._current_session_id = None

            # Remove session
            del self._sessions[session_id]
            logger.info(f"Session closed: {session_id}")
            return True

    def switch_session(self, session_id: str) -> bool:
        """Switch to a different session

        Args:
            session_id: Session ID to switch to

        Returns:
            True if switched successfully

        Raises:
            ValueError: If session not found
        """
        with self._lock:
            if session_id not in self._sessions:
                raise ValueError(f"Session not found: {session_id}")

            if self._current_session_id == session_id:
                logger.debug(f"Already on session: {session_id}")
                return True

            session = self._sessions[session_id]

            # Close current database
            if self._current_session_id is not None:
                logger.debug(f"Closing current session: {self._current_session_id}")
                idapro.close_database()

            # Open the target session's database
            logger.info(
                f"Switching to session: {session_id} ({session.input_path.name})"
            )

            if idapro.open_database(str(session.input_path), run_auto_analysis=False):
                raise RuntimeError(f"Failed to switch to session: {session_id}")

            self._current_session_id = session_id
            session.last_accessed = datetime.now()

            logger.info(f"Switched to session: {session_id}")
            return True

    def get_current_session(self) -> Optional[IDASession]:
        """Get the current active session

        Returns:
            Current session or None if no active session
        """
        with self._lock:
            if self._current_session_id is None:
                return None
            return self._sessions.get(self._current_session_id)

    def list_sessions(self) -> list[dict]:
        """List all open sessions

        Returns:
            List of session dictionaries with metadata
        """
        with self._lock:
            return [
                {
                    **session.to_dict(),
                    "is_current": session.session_id == self._current_session_id,
                }
                for session in self._sessions.values()
            ]

    def get_session(self, session_id: str) -> Optional[IDASession]:
        """Get a specific session by ID

        Args:
            session_id: Session ID to retrieve

        Returns:
            Session object or None if not found
        """
        with self._lock:
            return self._sessions.get(session_id)

    def close_all_sessions(self):
        """Close all sessions and databases"""
        with self._lock:
            logger.info(f"Closing all {len(self._sessions)} sessions")

            if self._current_session_id is not None:
                idapro.close_database()
                self._current_session_id = None

            self._sessions.clear()
            logger.info("All sessions closed")


# Global session manager instance
_session_manager: Optional[IDASessionManager] = None


def get_session_manager() -> IDASessionManager:
    """Get the global session manager instance

    Returns:
        Global IDASessionManager instance
    """
    global _session_manager
    if _session_manager is None:
        _session_manager = IDASessionManager()
    return _session_manager

```

`src/ida_pro_mcp/server.py`:

```py
import os
import sys
import json
import shutil
import argparse
import http.client
import tempfile
import traceback
import tomllib
import tomli_w
from typing import TYPE_CHECKING
from urllib.parse import urlparse
import glob

if TYPE_CHECKING:
    from ida_pro_mcp.ida_mcp.zeromcp import McpServer
    from ida_pro_mcp.ida_mcp.zeromcp.jsonrpc import JsonRpcResponse, JsonRpcRequest
else:
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), "ida_mcp"))
    from zeromcp import McpServer
    from zeromcp.jsonrpc import JsonRpcResponse, JsonRpcRequest

    sys.path.pop(0)  # Clean up

IDA_HOST = "127.0.0.1"
IDA_PORT = 13337

mcp = McpServer("ida-pro-mcp")
dispatch_original = mcp.registry.dispatch


def dispatch_proxy(request: dict | str | bytes | bytearray) -> JsonRpcResponse | None:
    """Dispatch JSON-RPC requests to the MCP server registry"""
    if not isinstance(request, dict):
        request_obj: JsonRpcRequest = json.loads(request)
    else:
        request_obj: JsonRpcRequest = request  # type: ignore

    if request_obj["method"] == "initialize":
        return dispatch_original(request)
    elif request_obj["method"].startswith("notifications/"):
        return dispatch_original(request)

    conn = http.client.HTTPConnection(IDA_HOST, IDA_PORT, timeout=30)
    try:
        if isinstance(request, dict):
            request = json.dumps(request)
        elif isinstance(request, str):
            request = request.encode("utf-8")
        conn.request("POST", "/mcp", request, {"Content-Type": "application/json"})
        response = conn.getresponse()
        data = response.read().decode()
        return json.loads(data)
    except Exception as e:
        full_info = traceback.format_exc()
        id = request_obj.get("id")
        if id is None:
            return None  # Notification, no response needed

        if sys.platform == "darwin":
            shortcut = "Ctrl+Option+M"
        else:
            shortcut = "Ctrl+Alt+M"
        return JsonRpcResponse(
            {
                "jsonrpc": "2.0",
                "error": {
                    "code": -32000,
                    "message": f"Failed to connect to IDA Pro! Did you run Edit -> Plugins -> MCP ({shortcut}) to start the server?\n{full_info}",
                    "data": str(e),
                },
                "id": id,
            }
        )
    finally:
        conn.close()


mcp.registry.dispatch = dispatch_proxy


SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
IDA_PLUGIN_PKG = os.path.join(SCRIPT_DIR, "ida_mcp")
IDA_PLUGIN_LOADER = os.path.join(SCRIPT_DIR, "ida_mcp.py")

# NOTE: This is in the global scope on purpose
if not os.path.exists(IDA_PLUGIN_PKG):
    raise RuntimeError(
        f"IDA plugin package not found at {IDA_PLUGIN_PKG} (did you move it?)"
    )
if not os.path.exists(IDA_PLUGIN_LOADER):
    raise RuntimeError(
        f"IDA plugin loader not found at {IDA_PLUGIN_LOADER} (did you move it?)"
    )


def get_python_executable():
    """Get the path to the Python executable"""
    venv = os.environ.get("VIRTUAL_ENV")
    if venv:
        if sys.platform == "win32":
            python = os.path.join(venv, "Scripts", "python.exe")
        else:
            python = os.path.join(venv, "bin", "python3")
        if os.path.exists(python):
            return python

    for path in sys.path:
        if sys.platform == "win32":
            path = path.replace("/", "\\")

        split = path.split(os.sep)
        if split[-1].endswith(".zip"):
            path = os.path.dirname(path)
            if sys.platform == "win32":
                python_executable = os.path.join(path, "python.exe")
            else:
                python_executable = os.path.join(path, "..", "bin", "python3")
            python_executable = os.path.abspath(python_executable)

            if os.path.exists(python_executable):
                return python_executable
    return sys.executable


def copy_python_env(env: dict[str, str]):
    # Reference: https://docs.python.org/3/using/cmdline.html#environment-variables
    python_vars = [
        "PYTHONHOME",
        "PYTHONPATH",
        "PYTHONSAFEPATH",
        "PYTHONPLATLIBDIR",
        "PYTHONPYCACHEPREFIX",
        "PYTHONNOUSERSITE",
        "PYTHONUSERBASE",
    ]
    # MCP servers are run without inheriting the environment, so we need to forward
    # the environment variables that affect Python's dependency resolution by hand.
    # Issue: https://github.com/mrexodia/ida-pro-mcp/issues/111
    result = False
    for var in python_vars:
        value = os.environ.get(var)
        if value:
            result = True
            env[var] = value
    return result


def generate_mcp_config(*, stdio: bool):
    if stdio:
        mcp_config = {
            "command": get_python_executable(),
            "args": [
                __file__,
                "--ida-rpc",
                f"http://{IDA_HOST}:{IDA_PORT}",
            ],
        }
        env = {}
        if copy_python_env(env):
            print("[WARNING] Custom Python environment variables detected")
            mcp_config["env"] = env
        return mcp_config
    else:
        return {"type": "http", "url": f"http://{IDA_HOST}:{IDA_PORT}/mcp"}


def print_mcp_config():
    print("[HTTP MCP CONFIGURATION]")
    print(
        json.dumps(
            {"mcpServers": {mcp.name: generate_mcp_config(stdio=False)}}, indent=2
        )
    )
    print("\n[STDIO MCP CONFIGURATION]")
    print(
        json.dumps(
            {"mcpServers": {mcp.name: generate_mcp_config(stdio=True)}}, indent=2
        )
    )


def install_mcp_servers(*, stdio: bool = False, uninstall=False, quiet=False):
    # Map client names to their JSON key paths for clients that don't use "mcpServers"
    # Format: client_name -> (top_level_key, nested_key)
    # None means use default "mcpServers" at top level
    special_json_structures = {
        "VS Code": ("mcp", "servers"),
        "VS Code Insiders": ("mcp", "servers"),
        "Visual Studio 2022": (None, "servers"),  # servers at top level
    }

    if sys.platform == "win32":
        configs = {
            "Cline": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Kilo Code": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code",
                    "User",
                    "globalStorage",
                    "kilocode.kilo-code",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Claude": (
                os.path.join(os.getenv("APPDATA", ""), "Claude"),
                "claude_desktop_config.json",
            ),
            "Cursor": (os.path.join(os.path.expanduser("~"), ".cursor"), "mcp.json"),
            "Windsurf": (
                os.path.join(os.path.expanduser("~"), ".codeium", "windsurf"),
                "mcp_config.json",
            ),
            "Claude Code": (os.path.join(os.path.expanduser("~")), ".claude.json"),
            "LM Studio": (
                os.path.join(os.path.expanduser("~"), ".lmstudio"),
                "mcp.json",
            ),
            "Codex": (os.path.join(os.path.expanduser("~"), ".codex"), "config.toml"),
            "Zed": (
                os.path.join(os.getenv("APPDATA", ""), "Zed"),
                "settings.json",
            ),
            "Gemini CLI": (
                os.path.join(os.path.expanduser("~"), ".gemini"),
                "settings.json",
            ),
            "Qwen Coder": (
                os.path.join(os.path.expanduser("~"), ".qwen"),
                "settings.json",
            ),
            "Copilot CLI": (
                os.path.join(os.path.expanduser("~"), ".copilot"),
                "mcp-config.json",
            ),
            "Crush": (
                os.path.join(os.path.expanduser("~")),
                "crush.json",
            ),
            "Augment Code": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "Qodo Gen": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "Antigravity IDE": (
                os.path.join(os.path.expanduser("~"), ".gemini", "antigravity"),
                "mcp_config.json",
            ),
            "Warp": (
                os.path.join(os.path.expanduser("~"), ".warp"),
                "mcp_config.json",
            ),
            "Amazon Q": (
                os.path.join(os.path.expanduser("~"), ".aws", "amazonq"),
                "mcp_config.json",
            ),
            "Opencode": (
                os.path.join(os.path.expanduser("~"), ".opencode"),
                "mcp_config.json",
            ),
            "Kiro": (
                os.path.join(os.path.expanduser("~"), ".kiro"),
                "mcp_config.json",
            ),
            "Trae": (
                os.path.join(os.path.expanduser("~"), ".trae"),
                "mcp_config.json",
            ),
            "VS Code": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "VS Code Insiders": (
                os.path.join(
                    os.getenv("APPDATA", ""),
                    "Code - Insiders",
                    "User",
                ),
                "settings.json",
            ),
        }
    elif sys.platform == "darwin":
        configs = {
            "Cline": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Kilo Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "kilocode.kilo-code",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Claude": (
                os.path.join(
                    os.path.expanduser("~"), "Library", "Application Support", "Claude"
                ),
                "claude_desktop_config.json",
            ),
            "Cursor": (os.path.join(os.path.expanduser("~"), ".cursor"), "mcp.json"),
            "Windsurf": (
                os.path.join(os.path.expanduser("~"), ".codeium", "windsurf"),
                "mcp_config.json",
            ),
            "Claude Code": (os.path.join(os.path.expanduser("~")), ".claude.json"),
            "LM Studio": (
                os.path.join(os.path.expanduser("~"), ".lmstudio"),
                "mcp.json",
            ),
            "Codex": (os.path.join(os.path.expanduser("~"), ".codex"), "config.toml"),
            "Antigravity IDE": (
                os.path.join(os.path.expanduser("~"), ".gemini", "antigravity"),
                "mcp_config.json",
            ),
            "Zed": (
                os.path.join(
                    os.path.expanduser("~"), "Library", "Application Support", "Zed"
                ),
                "settings.json",
            ),
            "Gemini CLI": (
                os.path.join(os.path.expanduser("~"), ".gemini"),
                "settings.json",
            ),
            "Qwen Coder": (
                os.path.join(os.path.expanduser("~"), ".qwen"),
                "settings.json",
            ),
            "Copilot CLI": (
                os.path.join(os.path.expanduser("~"), ".copilot"),
                "mcp-config.json",
            ),
            "Crush": (
                os.path.join(os.path.expanduser("~")),
                "crush.json",
            ),
            "Augment Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "Qodo Gen": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "BoltAI": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "BoltAI",
                ),
                "config.json",
            ),
            "Perplexity": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Perplexity",
                ),
                "mcp_config.json",
            ),
            "Warp": (
                os.path.join(os.path.expanduser("~"), ".warp"),
                "mcp_config.json",
            ),
            "Amazon Q": (
                os.path.join(os.path.expanduser("~"), ".aws", "amazonq"),
                "mcp_config.json",
            ),
            "Opencode": (
                os.path.join(os.path.expanduser("~"), ".opencode"),
                "mcp_config.json",
            ),
            "Kiro": (
                os.path.join(os.path.expanduser("~"), ".kiro"),
                "mcp_config.json",
            ),
            "Trae": (
                os.path.join(os.path.expanduser("~"), ".trae"),
                "mcp_config.json",
            ),
            "VS Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "VS Code Insiders": (
                os.path.join(
                    os.path.expanduser("~"),
                    "Library",
                    "Application Support",
                    "Code - Insiders",
                    "User",
                ),
                "settings.json",
            ),
        }
    elif sys.platform == "linux":
        configs = {
            "Cline": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Kilo Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "kilocode.kilo-code",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            # Claude not supported on Linux
            "Cursor": (os.path.join(os.path.expanduser("~"), ".cursor"), "mcp.json"),
            "Windsurf": (
                os.path.join(os.path.expanduser("~"), ".codeium", "windsurf"),
                "mcp_config.json",
            ),
            "Claude Code": (os.path.join(os.path.expanduser("~")), ".claude.json"),
            "LM Studio": (
                os.path.join(os.path.expanduser("~"), ".lmstudio"),
                "mcp.json",
            ),
            "Codex": (os.path.join(os.path.expanduser("~"), ".codex"), "config.toml"),
            "Antigravity IDE": (
                os.path.join(os.path.expanduser("~"), ".gemini", "antigravity"),
                "mcp_config.json",
            ),
            "Zed": (
                os.path.join(os.path.expanduser("~"), ".config", "zed"),
                "settings.json",
            ),
            "Gemini CLI": (
                os.path.join(os.path.expanduser("~"), ".gemini"),
                "settings.json",
            ),
            "Qwen Coder": (
                os.path.join(os.path.expanduser("~"), ".qwen"),
                "settings.json",
            ),
            "Copilot CLI": (
                os.path.join(os.path.expanduser("~"), ".copilot"),
                "mcp-config.json",
            ),
            "Crush": (
                os.path.join(os.path.expanduser("~")),
                "crush.json",
            ),
            "Augment Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "Qodo Gen": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "Warp": (
                os.path.join(os.path.expanduser("~"), ".warp"),
                "mcp_config.json",
            ),
            "Amazon Q": (
                os.path.join(os.path.expanduser("~"), ".aws", "amazonq"),
                "mcp_config.json",
            ),
            "Opencode": (
                os.path.join(os.path.expanduser("~"), ".opencode"),
                "mcp_config.json",
            ),
            "Kiro": (
                os.path.join(os.path.expanduser("~"), ".kiro"),
                "mcp_config.json",
            ),
            "Trae": (
                os.path.join(os.path.expanduser("~"), ".trae"),
                "mcp_config.json",
            ),
            "VS Code": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code",
                    "User",
                ),
                "settings.json",
            ),
            "VS Code Insiders": (
                os.path.join(
                    os.path.expanduser("~"),
                    ".config",
                    "Code - Insiders",
                    "User",
                ),
                "settings.json",
            ),
        }
    else:
        print(f"Unsupported platform: {sys.platform}")
        return

    installed = 0
    for name, (config_dir, config_file) in configs.items():
        config_path = os.path.join(config_dir, config_file)
        is_toml = config_file.endswith(".toml")

        if not os.path.exists(config_dir):
            action = "uninstall" if uninstall else "installation"
            if not quiet:
                print(f"Skipping {name} {action}\n  Config: {config_path} (not found)")
            continue

        # Read existing config
        if not os.path.exists(config_path):
            config = {}
        else:
            with open(
                config_path,
                "rb" if is_toml else "r",
                encoding=None if is_toml else "utf-8",
            ) as f:
                if is_toml:
                    data = f.read()
                    if len(data) == 0:
                        config = {}
                    else:
                        try:
                            config = tomllib.loads(data.decode("utf-8"))
                        except tomllib.TOMLDecodeError:
                            if not quiet:
                                print(
                                    f"Skipping {name} uninstall\n  Config: {config_path} (invalid TOML)"
                                )
                            continue
                else:
                    data = f.read().strip()
                    if len(data) == 0:
                        config = {}
                    else:
                        try:
                            config = json.loads(data)
                        except json.decoder.JSONDecodeError:
                            if not quiet:
                                print(
                                    f"Skipping {name} uninstall\n  Config: {config_path} (invalid JSON)"
                                )
                            continue

        # Handle TOML vs JSON structure
        if is_toml:
            if "mcp_servers" not in config:
                config["mcp_servers"] = {}
            mcp_servers = config["mcp_servers"]
        else:
            # Check if this client uses a special JSON structure
            if name in special_json_structures:
                top_key, nested_key = special_json_structures[name]
                if top_key is None:
                    # servers at top level (e.g., Visual Studio 2022)
                    if nested_key not in config:
                        config[nested_key] = {}
                    mcp_servers = config[nested_key]
                else:
                    # nested structure (e.g., VS Code uses mcp.servers)
                    if top_key not in config:
                        config[top_key] = {}
                    if nested_key not in config[top_key]:
                        config[top_key][nested_key] = {}
                    mcp_servers = config[top_key][nested_key]
            else:
                # Default: mcpServers at top level
                if "mcpServers" not in config:
                    config["mcpServers"] = {}
                mcp_servers = config["mcpServers"]

        # Migrate old name
        old_name = "github.com/mrexodia/ida-pro-mcp"
        if old_name in mcp_servers:
            mcp_servers[mcp.name] = mcp_servers[old_name]
            del mcp_servers[old_name]

        if uninstall:
            if mcp.name not in mcp_servers:
                if not quiet:
                    print(
                        f"Skipping {name} uninstall\n  Config: {config_path} (not installed)"
                    )
                continue
            del mcp_servers[mcp.name]
        else:
            mcp_servers[mcp.name] = generate_mcp_config(stdio=stdio)

        # Atomic write: temp file + rename
        suffix = ".toml" if is_toml else ".json"
        fd, temp_path = tempfile.mkstemp(
            dir=config_dir, prefix=".tmp_", suffix=suffix, text=True
        )
        try:
            with os.fdopen(
                fd, "wb" if is_toml else "w", encoding=None if is_toml else "utf-8"
            ) as f:
                if is_toml:
                    f.write(tomli_w.dumps(config).encode("utf-8"))
                else:
                    json.dump(config, f, indent=2)
            os.replace(temp_path, config_path)
        except:
            os.unlink(temp_path)
            raise

        if not quiet:
            action = "Uninstalled" if uninstall else "Installed"
            print(
                f"{action} {name} MCP server (restart required)\n  Config: {config_path}"
            )
        installed += 1
    if not uninstall and installed == 0:
        print(
            "No MCP servers installed. For unsupported MCP clients, use the following config:\n"
        )
        print_mcp_config()


def install_ida_plugin(
    *, uninstall: bool = False, quiet: bool = False, allow_ida_free: bool = False
):
    if sys.platform == "win32":
        ida_folder = os.path.join(os.environ["APPDATA"], "Hex-Rays", "IDA Pro")
    else:
        ida_folder = os.path.join(os.path.expanduser("~"), ".idapro")
    if not allow_ida_free:
        free_licenses = glob.glob(os.path.join(ida_folder, "idafree_*.hexlic"))
        if len(free_licenses) > 0:
            print(
                "IDA Free does not support plugins and cannot be used. Purchase and install IDA Pro instead."
            )
            sys.exit(1)
    ida_plugin_folder = os.path.join(ida_folder, "plugins")

    # Install both the loader file and package directory
    loader_source = IDA_PLUGIN_LOADER
    loader_destination = os.path.join(ida_plugin_folder, "ida_mcp.py")

    pkg_source = IDA_PLUGIN_PKG
    pkg_destination = os.path.join(ida_plugin_folder, "ida_mcp")

    # Clean up old plugin if it exists
    old_plugin = os.path.join(ida_plugin_folder, "mcp-plugin.py")

    if uninstall:
        # Remove loader
        if os.path.lexists(loader_destination):
            os.remove(loader_destination)
            if not quiet:
                print(f"Uninstalled IDA plugin loader\n  Path: {loader_destination}")

        # Remove package
        if os.path.exists(pkg_destination):
            if os.path.isdir(pkg_destination) and not os.path.islink(pkg_destination):
                shutil.rmtree(pkg_destination)
            else:
                os.remove(pkg_destination)
            if not quiet:
                print(f"Uninstalled IDA plugin package\n  Path: {pkg_destination}")

        # Remove old plugin if it exists
        if os.path.lexists(old_plugin):
            os.remove(old_plugin)
            if not quiet:
                print(f"Removed old plugin\n  Path: {old_plugin}")
    else:
        # Create IDA plugins folder
        if not os.path.exists(ida_plugin_folder):
            os.makedirs(ida_plugin_folder)

        # Remove old plugin if it exists
        if os.path.lexists(old_plugin):
            os.remove(old_plugin)
            if not quiet:
                print(f"Removed old plugin file\n  Path: {old_plugin}")

        installed_items = []

        # Install loader file
        loader_realpath = (
            os.path.realpath(loader_destination)
            if os.path.lexists(loader_destination)
            else None
        )
        if loader_realpath != loader_source:
            if os.path.lexists(loader_destination):
                os.remove(loader_destination)

            try:
                os.symlink(loader_source, loader_destination)
                installed_items.append(f"loader: {loader_destination}")
            except OSError:
                shutil.copy(loader_source, loader_destination)
                installed_items.append(f"loader: {loader_destination}")

        # Install package directory
        pkg_realpath = (
            os.path.realpath(pkg_destination)
            if os.path.lexists(pkg_destination)
            else None
        )
        if pkg_realpath != pkg_source:
            if os.path.lexists(pkg_destination):
                if os.path.isdir(pkg_destination) and not os.path.islink(
                    pkg_destination
                ):
                    shutil.rmtree(pkg_destination)
                else:
                    os.remove(pkg_destination)

            try:
                os.symlink(pkg_source, pkg_destination)
                installed_items.append(f"package: {pkg_destination}")
            except OSError:
                shutil.copytree(pkg_source, pkg_destination)
                installed_items.append(f"package: {pkg_destination}")

        if not quiet:
            if installed_items:
                print("Installed IDA Pro plugin (IDA restart required)")
                for item in installed_items:
                    print(f"  {item}")
            else:
                print("Skipping IDA plugin installation (already up to date)")


def main():
    global IDA_HOST, IDA_PORT
    parser = argparse.ArgumentParser(description="IDA Pro MCP Server")
    parser.add_argument(
        "--install", action="store_true", help="Install the MCP Server and IDA plugin"
    )
    parser.add_argument(
        "--uninstall",
        action="store_true",
        help="Uninstall the MCP Server and IDA plugin",
    )
    parser.add_argument(
        "--allow-ida-free",
        action="store_true",
        help="Allow installation despite IDA Free being installed",
    )
    parser.add_argument(
        "--transport",
        type=str,
        default="stdio",
        help="MCP transport protocol to use (stdio or http://127.0.0.1:8744)",
    )
    parser.add_argument(
        "--ida-rpc",
        type=str,
        default=f"http://{IDA_HOST}:{IDA_PORT}",
        help=f"IDA RPC server to use (default: http://{IDA_HOST}:{IDA_PORT})",
    )
    parser.add_argument(
        "--config", action="store_true", help="Generate MCP config JSON"
    )
    args = parser.parse_args()

    # Parse IDA RPC server argument
    ida_rpc = urlparse(args.ida_rpc)
    if ida_rpc.hostname is None or ida_rpc.port is None:
        raise Exception(f"Invalid IDA RPC server: {args.ida_rpc}")
    IDA_HOST = ida_rpc.hostname
    IDA_PORT = ida_rpc.port

    if args.install and args.uninstall:
        print("Cannot install and uninstall at the same time")
        return

    if args.install:
        install_ida_plugin(allow_ida_free=args.allow_ida_free)
        install_mcp_servers(stdio=(args.transport == "stdio"))
        return

    if args.uninstall:
        install_ida_plugin(uninstall=True, allow_ida_free=args.allow_ida_free)
        install_mcp_servers(uninstall=True)
        return

    if args.config:
        print_mcp_config()
        return

    try:
        if args.transport == "stdio":
            mcp.stdio()
        else:
            url = urlparse(args.transport)
            if url.hostname is None or url.port is None:
                raise Exception(f"Invalid transport URL: {args.transport}")
            # NOTE: npx -y @modelcontextprotocol/inspector for debugging
            mcp.serve(url.hostname, url.port)
            input("Server is running, press Enter or Ctrl+C to stop.")
    except (KeyboardInterrupt, EOFError):
        pass


if __name__ == "__main__":
    main()

```

`src/ida_pro_mcp/test.py`:

```py
"""Standalone test runner for IDA Pro MCP using idalib.

Usage:
    ida-mcp-test tests/crackme03.elf
    ida-mcp-test tests/crackme03.elf --category api_core
    ida-mcp-test tests/crackme03.elf --pattern "*meta*"

With coverage:
    uv run coverage run -m ida_pro_mcp.test crackme03.elf
    uv run coverage report
    uv run coverage html
"""

import sys
import argparse
from pathlib import Path

# idapro must go first to initialize idalib
import idapro
import ida_auto


def main() -> int:
    """Entry point for ida-mcp-test command."""
    parser = argparse.ArgumentParser(
        description="Run IDA Pro MCP tests using idalib",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ida-mcp-test tests/crackme03.elf
  ida-mcp-test tests/crackme03.elf --category api_core
  ida-mcp-test tests/crackme03.elf --pattern "*meta*"
  ida-mcp-test tests/crackme03.elf --stop-on-failure

With coverage:
  uv run coverage run -m ida_pro_mcp.test crackme03.elf
  uv run coverage report --show-missing
  uv run coverage html && open htmlcov/index.html
        """,
    )
    parser.add_argument("binary", type=Path, help="Path to binary file to analyze")
    parser.add_argument(
        "--pattern",
        "-p",
        default="*",
        help="Glob pattern to filter test names (default: *)",
    )
    parser.add_argument(
        "--category",
        "-c",
        default="*",
        help="Filter by module category (default: *)",
    )
    parser.add_argument(
        "--stop-on-failure",
        "-x",
        action="store_true",
        help="Stop at first failure",
    )
    parser.add_argument(
        "--quiet",
        "-q",
        action="store_true",
        help="Quiet mode - only show summary",
    )
    parser.add_argument(
        "--list",
        "-l",
        action="store_true",
        help="List available tests without running them",
    )
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Show IDA console messages",
    )
    parser.add_argument(
        "--sample-size",
        "-n",
        type=int,
        default=5,
        help="Number of items for sampling-based tests (default: 5)",
    )

    args = parser.parse_args()

    # Check binary exists
    if not args.binary.exists():
        print(f"Error: Binary not found: {args.binary}", file=sys.stderr)
        return 1

    # Configure IDA console output
    if args.verbose:
        idapro.enable_console_messages(True)
    else:
        idapro.enable_console_messages(False)

    # Open database
    print(f"Opening database for: {args.binary}")
    if idapro.open_database(str(args.binary), run_auto_analysis=True):
        print("Error: Failed to open database", file=sys.stderr)
        return 1

    # Wait for auto-analysis
    print("Waiting for auto-analysis...")
    ida_auto.auto_wait()
    print()

    try:
        # Import test framework and API modules AFTER idalib is initialized
        # This triggers the @test decorators to register tests
        from ida_pro_mcp.ida_mcp.framework import run_tests, TESTS, set_sample_size

        # Import all test modules to register the tests

        # Configure sample size for deterministic sampling helpers
        set_sample_size(args.sample_size)

        # Handle --list
        if args.list:
            print("Available tests:")
            by_category: dict[str, list[str]] = {}
            for name, info in sorted(TESTS.items()):
                if info.module not in by_category:
                    by_category[info.module] = []
                by_category[info.module].append(name)

            for cat in sorted(by_category.keys()):
                print(f"\n[{cat}]")
                for name in by_category[cat]:
                    info = TESTS[name]
                    skip_marker = " (skip)" if info.skip else ""
                    print(f"  {name}{skip_marker}")
            return 0

        # Run tests
        results = run_tests(
            pattern=args.pattern,
            category=args.category,
            verbose=not args.quiet,
            stop_on_failure=args.stop_on_failure,
        )

        # In quiet mode, print summary
        if args.quiet:
            status_parts = []
            if results.passed:
                status_parts.append(f"{results.passed} passed")
            if results.failed:
                status_parts.append(f"{results.failed} failed")
            if results.skipped:
                status_parts.append(f"{results.skipped} skipped")
            print(f"Results: {', '.join(status_parts)} ({results.total_time:.2f}s)")

            if results.failed:
                print("\nFailed tests:")
                for r in results.results:
                    if r.status == "failed":
                        print(f"  {r.name}: {r.error}")

        return 1 if results.failed > 0 else 0

    finally:
        # Close database
        idapro.close_database()


if __name__ == "__main__":
    sys.exit(main())

```

`tests/binary_info.py`:

```py
#!/usr/bin/env python3
"""Binary Information Extraction Script

This script extracts comprehensive information from an IDA database for use in
writing binary-specific tests. It's designed to be used by LLMs to understand
the structure of a binary before writing targeted tests.

Usage:
    uv run python tests/binary_info.py <binary_path>

Example:
    uv run python tests/binary_info.py tests/crackme03.elf

The output includes:
- Metadata (filename, address range)
- Segments (name, range, size)
- Entry points
- Functions (with sizes)
- Strings (with content)
- Imports
- Globals
- Cross-references for key functions
- Basic blocks for main function
"""

import sys
import json
from pathlib import Path


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    binary_path = sys.argv[1]
    if not Path(binary_path).exists():
        print(f"Error: Binary not found: {binary_path}")
        sys.exit(1)

    # Import and open database
    import idapro

    idapro.open_database(binary_path, True)

    import idaapi
    import idautils
    import idc
    import ida_funcs
    import ida_name
    import ida_bytes
    import ida_entry

    info = {}

    # Metadata
    info["metadata"] = {
        "filename": idaapi.get_root_filename(),
        "min_ea": hex(idaapi.inf_get_min_ea()),
        "max_ea": hex(idaapi.inf_get_max_ea()),
    }

    # Segments
    info["segments"] = []
    for seg_ea in idautils.Segments():
        seg = idaapi.getseg(seg_ea)
        info["segments"].append(
            {
                "name": idaapi.get_segm_name(seg),
                "start": hex(seg.start_ea),
                "end": hex(seg.end_ea),
                "size": hex(seg.end_ea - seg.start_ea),
            }
        )

    # Entry points
    info["entrypoints"] = []
    entry_count = ida_entry.get_entry_qty()
    for i in range(entry_count):
        ordinal = ida_entry.get_entry_ordinal(i)
        ea = ida_entry.get_entry(ordinal)
        name = ida_entry.get_entry_name(ordinal)
        info["entrypoints"].append(
            {
                "name": name,
                "addr": hex(ea),
                "ordinal": ordinal,
            }
        )

    # Functions
    info["functions"] = []
    for ea in idautils.Functions():
        name = ida_funcs.get_func_name(ea)
        func = ida_funcs.get_func(ea)
        size = func.end_ea - func.start_ea if func else 0

        # Get callers
        callers = []
        for xref in idautils.XrefsTo(ea):
            if xref.type in [idaapi.fl_CN, idaapi.fl_CF]:
                caller_func = ida_funcs.get_func(xref.frm)
                if caller_func:
                    caller_name = ida_funcs.get_func_name(caller_func.start_ea)
                    if caller_name and caller_name not in callers:
                        callers.append(caller_name)

        # Get callees
        callees = []
        if func:
            for head in idautils.Heads(func.start_ea, func.end_ea):
                for xref in idautils.XrefsFrom(head):
                    if xref.type in [idaapi.fl_CN, idaapi.fl_CF]:
                        callee_name = ida_funcs.get_func_name(xref.to)
                        if callee_name and callee_name not in callees:
                            callees.append(callee_name)

        info["functions"].append(
            {
                "name": name,
                "addr": hex(ea),
                "end": hex(func.end_ea) if func else None,
                "size": size,
                "callers": callers,
                "callees": callees,
            }
        )

    # Strings
    info["strings"] = []
    str_count = idaapi.get_strlist_qty()
    for i in range(str_count):
        si = idaapi.string_info_t()
        if idaapi.get_strlist_item(si, i):
            content = idc.get_strlit_contents(si.ea, -1, 0)
            if content:
                try:
                    decoded = content.decode("utf-8", errors="replace")
                except Exception:
                    decoded = repr(content)
                info["strings"].append(
                    {
                        "addr": hex(si.ea),
                        "length": si.length,
                        "content": decoded,
                    }
                )

    # Imports
    info["imports"] = []

    def imp_cb(ea, name, ordinal):
        info["imports"].append(
            {
                "name": name,
                "addr": hex(ea),
            }
        )
        return True

    for idx in range(idaapi.get_import_module_qty()):
        idaapi.get_import_module_name(idx)
        idaapi.enum_import_names(idx, imp_cb)

    # Globals (named addresses that aren't functions)
    info["globals"] = []
    for ea, name in idautils.Names():
        if not ida_funcs.get_func(ea):
            # Get size if possible
            size = ida_bytes.get_item_size(ea)
            info["globals"].append(
                {
                    "name": name,
                    "addr": hex(ea),
                    "size": size,
                }
            )

    # Basic blocks for main (if exists)
    main_ea = ida_name.get_name_ea(idaapi.BADADDR, "main")
    if main_ea != idaapi.BADADDR:
        func = ida_funcs.get_func(main_ea)
        if func:
            info["main_basic_blocks"] = []
            fc = idaapi.FlowChart(func)
            for block in fc:
                succs = [hex(s.start_ea) for s in block.succs()]
                info["main_basic_blocks"].append(
                    {
                        "start": hex(block.start_ea),
                        "end": hex(block.end_ea),
                        "size": block.end_ea - block.start_ea,
                        "successors": succs,
                    }
                )

    idapro.close_database(False)

    # Output as formatted JSON
    print(json.dumps(info, indent=2))


if __name__ == "__main__":
    main()

```

`uv-package.sh`:

```sh
#!/bin/bash
uv run ida-pro-mcp --generate-docs
rm -rf dist
uv build
uv publish
```

`uv.lock`:

```lock
version = 1
revision = 2
requires-python = ">=3.11"

[[package]]
name = "ida-pro-mcp"
version = "2.0.0"
source = { editable = "." }
dependencies = [
    { name = "idapro" },
    { name = "tomli-w" },
]

[package.metadata]
requires-dist = [
    { name = "idapro", specifier = ">=0.0.7" },
    { name = "tomli-w", specifier = ">=1.0.0" },
]

[[package]]
name = "idapro"
version = "0.0.7"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/da/65/b49019b4713b852349b6516b786c8542930aca7701bb2552b18f4e4a4e25/idapro-0.0.7.tar.gz", hash = "sha256:0b2e184b19e4d8404ea48b1f17f39b21b054931315940ee9716ef8559144988f", size = 966886, upload-time = "2025-10-29T09:07:21.695Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fb/5d/6e6565d9a1d6ecf1b48a2bea326f0e3dbe4c3199adfc0a5456b83d235f99/idapro-0.0.7-py3-none-any.whl", hash = "sha256:3cb8d48ac21a19e6a0ef65eacd0005a1f9c40a264a7bcb675914eaa20c6e1371", size = 1999440, upload-time = "2025-10-29T09:07:19.998Z" },
]

[[package]]
name = "tomli-w"
version = "1.2.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/19/75/241269d1da26b624c0d5e110e8149093c759b7a286138f4efd61a60e75fe/tomli_w-1.2.0.tar.gz", hash = "sha256:2dd14fac5a47c27be9cd4c976af5a12d87fb1f0b4512f81d69cce3b35ae25021", size = 7184, upload-time = "2025-01-15T12:07:24.262Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c7/18/c86eb8e0202e32dd3df50d43d7ff9854f8e0603945ff398974c1d91ac1ef/tomli_w-1.2.0-py3-none-any.whl", hash = "sha256:188306098d013b691fcadc011abd66727d3c414c571bb01b1a174ba8c983cf90", size = 6675, upload-time = "2025-01-15T12:07:22.074Z" },
]

```