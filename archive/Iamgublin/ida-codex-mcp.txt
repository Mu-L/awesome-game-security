Project Path: arc_Iamgublin_ida-codex-mcp_wh301wpb

Source Tree:

```txt
arc_Iamgublin_ida-codex-mcp_wh301wpb
├── README.md
├── ida_bridge.py
├── img
│   └── demo.png
└── mcp_ida_server.py

```

`README.md`:

```md
# ida-codex-mcp

Local MCP (Model Context Protocol) server plus an IDA 9.2 plugin to expose common reverse engineering capabilities to MCP clients.

- `ida_bridge.py`: an IDA plugin that exposes core analysis features (function list, call graph, Hex-Rays pseudocode, disassembly, imports/exports, xrefs, strings, memory reads, navigation, naming/typing helpers, etc.) over a local TCP JSON interface (default `127.0.0.1:31337`).
- `mcp_ida_server.py`: a local MCP server that talks to the IDA plugin, then re-exposes features as MCP tools and resources over STDIN/STDOUT so MCP clients (e.g., Codex CLI) can use them directly.


## Features

- Functions and calls
  - List functions: `ida_list_functions`
  - Call graph: `ida_call_graph(name, max_depth)`
  - Analyze and optionally rename: `ida_analyze_function(name, max_depth, rename, rename_locals)`
- Decompile/Disassemble
  - Pseudocode (Hex-Rays): `ida_get_pseudocode(name|ea, offset, limit)`
  - Disassembly: `ida_get_disassembly(name|ea, offset, limit)`
  - Add pseudocode comment: `ida_add_pseudocode_comment(name|ea, line, comment, repeatable)`
  - Rename function: `ida_rename_function(old_name, new_name)`
- Program info
  - Imports: `ida_get_imports`
  - Exports: `ida_get_exports`
  - Cross-references: `ida_get_xrefs(target)` (name or address)
  - Globals: `ida_list_globals(offset, count)`
  - Memory read: `ida_read_memory(address, size)`
  - Strings: `ida_get_strings(min_length, offset, count)`
- Navigation & typing
  - Jump to address: `ida_jump_to_address(address)`
  - Set data type: `ida_set_data_type(address, data_type)` (byte/word/dword/qword/float/double/ascii/unicode)
  - Set function pointer type: `ida_set_function_pointer_type(address, function_signature)` (supports simplified signatures like `NTSTATUS __fastcall`)
  - Smart name: `ida_set_name(address, name)` (auto-detects function pointers and applies QWORD + function type)
  - Create function pointer: `ida_create_function_pointer(address, name, function_signature)` (jump + QWORD + function type + name; supports simplified signatures)
- MCP resources
  - `resources/list`: export top functions as resources (first 500)
  - `resources/read`: fetch pseudocode (or fallback to disassembly) via `ida://function/{ea}/{name}`
  - `resources/templates/list`: provide `ida_function` template


## Repository Layout

```
ida-codex-mcp/
├─ ida_bridge.py        # IDA plugin: local TCP JSON bridge
├─ mcp_ida_server.py    # MCP local process server: bridge MCP <-> IDA
└─ __pycache__/         # cache generated at runtime
```


## Requirements

- IDA Pro 9.2 (Hex-Rays recommended for pseudocode features)
- Python 3.9+
- Windows/Linux/macOS


## Installation & Startup

1) IDA side (plugin)

- Copy `ida_bridge.py` into IDA's `plugins` directory and restart IDA.
- When a target is open, the plugin spawns a local listener at `127.0.0.1:31337` (auto-increments port if taken).

2) MCP side (local process)

- From this repo folder, run:

```bash
python mcp_ida_server.py
```

- To override the IDA bridge address/port, set environment variables:

```bash
# Default: 127.0.0.1:31337
set IDA_HOST=127.0.0.1
set IDA_PORT=31337
```

- The process communicates over STDIN/STDOUT. Register it in your MCP client (e.g., Codex CLI) to use tools and resources.

## Codex CLI Integration (config.toml)

Add this server to Codex CLI's `config.toml` so the tools appear in the client. The exact location of the config file depends on your setup, for example:

- Windows: `%AppData%\\Codex\\config.toml`
- macOS: `~/Library/Application Support/Codex/config.toml`
- Linux: `~/.config/codex/config.toml`

Example configuration using stdio transport:

```toml
# Register an MCP server named "ida"
[mcp.servers.ida]
type = "stdio"
command = "python"
# Use an absolute path to the server script; single quotes are safe for Windows paths
args = ['D:\\Code\\ida-codex-mcp\\mcp_ida_server.py']

# Optional environment overrides (match your IDA bridge address/port)
env = { IDA_HOST = "127.0.0.1", IDA_PORT = "31337" }

# Optional stability knobs
enabled = true
restart_on_exit = true
timeout_ms = 15000
```

Unix-like path variant:

```toml
[mcp.servers.ida]
type = "stdio"
command = "python3"
args = ["/path/to/ida-codex-mcp/mcp_ida_server.py"]
env = { IDA_HOST = "127.0.0.1", IDA_PORT = "31337" }
enabled = true
restart_on_exit = true
timeout_ms = 15000
```

Verification steps:

- Ensure IDA is running with `ida_bridge.py` loaded and a database open.
- Restart Codex CLI so it picks up the new server.
- In Codex CLI, list tools and confirm `ida_*` tools (e.g., `ida_list_functions`, `ida_get_pseudocode`) are available.


## Quick Check (two ways)

Option A: Direct TCP to the IDA plugin (simple self-test)

```python
# quick_test.py
import json, socket

HOST, PORT = "127.0.0.1", 31337
req = {"method": "list_functions", "params": {}}

s = socket.create_connection((HOST, PORT), timeout=5)
s.sendall((json.dumps(req) + "\n").encode("utf-8"))
data = s.recv(65536)
print("IDA reply:", data.decode("utf-8", "ignore"))
```

```bash
python quick_test.py
```

Option B: Through MCP (recommended via an MCP client)

- Initialize:

```json
{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"protocolVersion":"2024-11-05"}}
```

- List tools:

```json
{"jsonrpc":"2.0","id":"2","method":"tools/list"}
```

- Call example (list functions):

```json
{"jsonrpc":"2.0","id":"3","method":"tools/call","params":{"name":"ida_list_functions","arguments":{}}}
```

Tip: Sending single JSON lines via a pipe is only for smoke tests—register this process in an MCP client for the best experience.


## FAQ

- If Hex-Rays is not installed, `ida_get_pseudocode` and `ida_add_pseudocode_comment` will error; use `ida_get_disassembly` instead.
- If port `31337` is occupied, the plugin increases the port number automatically; set `IDA_PORT` accordingly on the MCP side to match.
- Transport encoding is UTF-8; each request/response is a single JSON line ending with a newline.


## License

TBD. Contributions welcome—please mention license intentions in PRs.


## Demo

![IDA reverse engineering demo](img/demo.png)

```

`ida_bridge.py`:

```py
# ida_bridge.py -- IDA 9.2 plugin, expose analysis over TCP for MCP
#
# 放到 IDA 的 plugins 目录
# 启动 IDA 后会自动开一个线程监听 127.0.0.1:31337
# MCP 服务器通过这个端口发 JSON 请求

import socket
import threading
import json
import traceback

import ida_idaapi
import ida_kernwin
import ida_funcs
import ida_bytes
import idautils
import ida_name
import idaapi
import ida_lines
import idc
import ida_nalt
import ida_entry

# 尝试 Hex-Rays
try:
    import ida_hexrays
    HAS_HEXRAYS = ida_hexrays.init_hexrays_plugin()
except Exception:
    HAS_HEXRAYS = False

HOST = "127.0.0.1"
PORT = 31337


# ---------- 工具函数 ----------

def _normalize_function_signature(signature):
    """
    规范化函数签名，处理常见的格式问题
    """
    sig = signature.strip()
    
    # 常见的函数签名模板
    templates = {
        # Windows API 常见类型
        "NTSTATUS": "NTSTATUS (*func)(void*, void*, int, int, int);",
        "HANDLE": "HANDLE (*func)(void*, void*, int, int, int);",
        "BOOL": "BOOL (*func)(void*, void*, int, int, int);", 
        "DWORD": "DWORD (*func)(void*, void*, int, int, int);",
        "PVOID": "PVOID (*func)(void*, void*, int, int, int);",
        
        # 通用类型
        "int": "int (*func)(void*, void*, int, int, int);",
        "void": "void (*func)(void*, void*, int, int, int);",
        "void*": "void* (*func)(void*, void*, int, int, int);",
        "long": "long (*func)(void*, void*, int, int, int);",
        "uint64_t": "uint64_t (*func)(void*, void*, int, int, int);",
    }
    
    # 如果是简单的类型名，使用模板
    if sig in templates:
        return templates[sig]
    
    # 如果已经是完整的函数指针声明，直接返回
    if "(*" in sig or "(__" in sig:
        # 确保以分号结尾
        if not sig.endswith(';'):
            sig += ';'
        return sig
    
    # 尝试解析为返回类型 + 调用约定的形式
    # 例如: "NTSTATUS __fastcall" -> "NTSTATUS (__fastcall *func)(...)"
    parts = sig.split()
    if len(parts) >= 2:
        return_type = parts[0]
        calling_conv = parts[1]
        return f"{return_type} ({calling_conv} *func)(void*, void*, int, int, int);"
    
    # 默认情况：假设是返回类型
    return f"{sig} (*func)(void*, void*, int, int, int);"


def _is_call(ea):
    try:
        return idaapi.is_call_insn(ea)
    except Exception:
        return False


def _list_functions():
    funcs = []
    for ea in idautils.Functions():
        name = ida_funcs.get_func_name(ea)
        funcs.append({"ea": ea, "name": name})
    return funcs


def _build_callers_map():
    callers = {}
    for func_ea in idautils.Functions():
        f_name = ida_funcs.get_func_name(func_ea)
        for xref in idautils.XrefsTo(func_ea):
            caller = ida_funcs.get_func(xref.frm)
            if caller:
                callers.setdefault(f_name, set()).add(
                    ida_funcs.get_func_name(caller.start_ea)
                )
    return {k: list(v) for k, v in callers.items()}


def _build_call_graph(max_depth=2, root_name=None):
    """
    简单版调用图：基于指令层面发现 call，再按深度展开。
    用 _is_call(...) 来判断是否调用指令，兼容 9.2。
    """
    name_to_ea = {ida_funcs.get_func_name(ea): ea for ea in idautils.Functions()}
    if root_name and root_name not in name_to_ea:
        return {"error": f"function {root_name} not found"}

    def walk(ea, depth, seen):
        if depth > max_depth:
            return {}
        func = ida_funcs.get_func(ea)
        if not func:
            return {}
        this_name = ida_funcs.get_func_name(ea)
        if this_name in seen:
            return {}
        seen.add(this_name)
        callees = []

        for head in idautils.FuncItems(ea):
            if _is_call(head):
                # 找从这条 call 出去的引用
                for x in idautils.XrefsFrom(head, 0):
                    callee = ida_funcs.get_func(x.to)
                    if callee:
                        callee_name = ida_funcs.get_func_name(callee.start_ea)
                        callees.append(callee_name)

        node = {"name": this_name, "callees": []}
        for cname in callees:
            cea = name_to_ea.get(cname)
            if cea:
                child = walk(cea, depth + 1, seen)
                if child:
                    node["callees"].append(child)
                else:
                    node["callees"].append({"name": cname, "callees": []})
            else:
                node["callees"].append({"name": cname, "callees": []})
        return node

    if root_name:
        root_ea = name_to_ea[root_name]
        return walk(root_ea, 0, set())
    else:
        graph = {}
        for name, ea in name_to_ea.items():
            graph[name] = walk(ea, 0, set())
        return graph


def _guess_function_role(ea):
    """
    非常简单的启发式，后面你可以自己加规则
    """
    fn_name = ida_funcs.get_func_name(ea)
    callers_map = _build_callers_map()
    callers = callers_map.get(fn_name, [])
    role = []
    ln = fn_name.lower()
    if "init" in ln or "startup" in ln:
        role.append("init")
    elif len(callers) > 5:
        role.append("hotspot")
    else:
        role.append("normal")
    return {
        "name": fn_name,
        "ea": ea,
        "callers": callers,
        "role": role,
    }


def _find_function_ea(name):
    for f_ea in idautils.Functions():
        if ida_funcs.get_func_name(f_ea) == name:
            return f_ea
    return None


def _get_pseudocode(ea):
    if not HAS_HEXRAYS:
        return {"error": "Hex-Rays not available"}
    try:
        cfunc = ida_hexrays.decompile(ea)
    except Exception as exc:
        return {"error": f"decompile failed: {exc}"}
    if not cfunc:
        return {"error": "decompile returned no pseudocode"}
    pseudo = str(cfunc)
    return {
        "ea": ea,
        "name": ida_funcs.get_func_name(ea),
        "pseudocode": pseudo,
    }


def _set_pseudocode_comment(ea, line, comment, repeatable=False):
    if not HAS_HEXRAYS:
        return {"error": "Hex-Rays not available"}
    try:
        target_line = int(line)
    except Exception:
        return {"error": "line must be an integer"}
    if target_line <= 0:
        return {"error": "line must be positive"}
    try:
        cfunc = ida_hexrays.decompile(ea)
    except Exception as exc:
        return {"error": f"decompile failed: {exc}"}
    if not cfunc:
        return {"error": "decompile returned no pseudocode"}
    
    # Load existing user comments
    if hasattr(cfunc, "load_user_cmts"):
        try:
            cfunc.load_user_cmts()
        except Exception:
            pass
    
    # Find the tree location for the target line (1-based input)
    treeloc = None
    try:
        # Get pseudocode lines
        sv = cfunc.get_pseudocode()
        if not sv or target_line > len(sv):
            return {"error": f"line {target_line} out of range (function has {len(sv) if sv else 0} lines)"}
        
        # Get the pseudocode line (convert from 1-based to 0-based)
        pc_line = sv[target_line - 1]
        
        # Create treeloc from the pseudocode line's EA
        if hasattr(pc_line, 'ea') and pc_line.ea != idaapi.BADADDR:
            treeloc = ida_hexrays.treeloc_t()
            treeloc.ea = pc_line.ea
            treeloc.itp = ida_hexrays.ITP_SEMI
        else:
            # If no EA, try to find a nearby line with an EA
            for offset in range(1, min(5, len(sv) - target_line + 1)):
                check_line = target_line - 1 + offset
                if check_line < len(sv):
                    pc_line = sv[check_line]
                    if hasattr(pc_line, 'ea') and pc_line.ea != idaapi.BADADDR:
                        treeloc = ida_hexrays.treeloc_t()
                        treeloc.ea = pc_line.ea
                        treeloc.itp = ida_hexrays.ITP_SEMI
                        break
            
            # Try before the target line
            if not treeloc:
                for offset in range(1, min(5, target_line)):
                    check_line = target_line - 1 - offset
                    if check_line >= 0:
                        pc_line = sv[check_line]
                        if hasattr(pc_line, 'ea') and pc_line.ea != idaapi.BADADDR:
                            treeloc = ida_hexrays.treeloc_t()
                            treeloc.ea = pc_line.ea
                            treeloc.itp = ida_hexrays.ITP_SEMI
                            break
    except Exception as exc:
        return {"error": f"failed to find tree location: {exc}"}
    
    if not treeloc:
        return {"error": f"could not find tree location for line {target_line}"}
    
    # Set the comment using treeloc_t
    try:
        cfunc.set_user_cmt(treeloc, comment)
    except Exception as exc:
        return {"error": f"failed to set comment: {exc}"}
    
    # Save user comments
    try:
        cfunc.save_user_cmts()
    except Exception:
        pass
    
    # Refresh the view
    if hasattr(ida_hexrays, "refresh_hexrays_view"):
        try:
            ida_hexrays.refresh_hexrays_view()
        except Exception:
            pass
    
    return {
        "ea": ea,
        "line": target_line,
        "comment": comment,
        "ok": True,
    }


def _get_disassembly(ea):
    func = ida_funcs.get_func(ea)
    if not func:
        return {"error": "function not found"}
    lines = []
    for head in idautils.Heads(func.start_ea, func.end_ea):
        disasm = idc.generate_disasm_line(head, 0)
        if isinstance(disasm, tuple):
            line_text = disasm[0]
        else:
            line_text = disasm
        line_text = ida_lines.tag_remove(line_text)
        lines.append(f"{hex(head)}: {line_text}")
    return {
        "ea": ea,
        "name": ida_funcs.get_func_name(ea),
        "disassembly": "\n".join(lines),
    }


def _rename_function(ea, new_name):
    ida_name.set_name(ea, new_name, ida_name.SN_AUTO)


def _rename_locals(ea, names):
    if not HAS_HEXRAYS:
        return {"ok": False, "reason": "Hex-Rays not available"}
    try:
        cfunc = ida_hexrays.decompile(ea)
    except Exception as e:
        return {"ok": False, "reason": f"decompile failed: {e}"}
    lvars = cfunc.get_lvars()
    for i, lv in enumerate(lvars):
        if i < len(names):
            cfunc.set_lvar_name(lv, names[i])
    cfunc.save_user_cmts()
    return {"ok": True}


def _get_imports():
    """
    获取导入表信息
    """
    imports = []
    nimps = ida_nalt.get_import_module_qty()
    
    for i in range(nimps):
        dllname = ida_nalt.get_import_module_name(i)
        if not dllname:
            continue
            
        def imp_cb(ea, name, ordinal):
            if name:
                imports.append({
                    "ea": ea,
                    "name": name,
                    "ordinal": ordinal,
                    "module": dllname
                })
            return True
        
        ida_nalt.enum_import_names(i, imp_cb)
    
    return imports


def _get_exports():
    """
    获取导出表信息
    """
    exports = []
    
    for idx in range(ida_entry.get_entry_qty()):
        ordinal = ida_entry.get_entry_ordinal(idx)
        ea = ida_entry.get_entry(ordinal)
        name = ida_entry.get_entry_name(ordinal)
        
        exports.append({
            "ordinal": ordinal,
            "ea": ea,
            "name": name if name else f"ord_{ordinal}"
        })
    
    return exports


def _get_xrefs_to(target):
    """
    获取对某个地址或名称的所有引用
    target 可以是地址(int)或名称(str)
    """
    if isinstance(target, str):
        # 通过名称查找地址
        ea = ida_name.get_name_ea(idaapi.BADADDR, target)
        if ea == idaapi.BADADDR:
            # 尝试在所有段中搜索名称
            found = False
            for segea in idautils.Segments():
                seg = idaapi.getseg(segea)
                if seg:
                    for head in idautils.Heads(seg.start_ea, seg.end_ea):
                        name = ida_name.get_name(head)
                        if name and (name == target or name.startswith(target + "@@")):
                            ea = head
                            found = True
                            break
                    if found:
                        break
            
            if not found:
                return {"error": f"name '{target}' not found"}
    else:
        try:
            ea = int(target)
        except Exception:
            return {"error": "target must be an integer address or string name"}
    
    # 获取目标名称
    target_name = ida_name.get_name(ea) if isinstance(target, int) else target
    
    xrefs = []
    for xref in idautils.XrefsTo(ea):
        # 获取引用类型描述 (IDA 9.2 兼容)
        xref_type_map = {
            0: "Data_Unknown",
            1: "Data_Offset", 
            2: "Data_Write",
            3: "Data_Read",
            4: "Data_Text",
            5: "Data_Informational",
            16: "Code_Far_Call",
            17: "Code_Near_Call",
            18: "Code_Far_Jump",
            19: "Code_Near_Jump",
            20: "Code_User",
            21: "Ordinary_Flow"
        }
        xref_type = xref_type_map.get(xref.type, f"Unknown_{xref.type}")
        
        func = ida_funcs.get_func(xref.frm)
        func_name = ida_funcs.get_func_name(func.start_ea) if func else "<no_func>"
        
        # 获取引用处的反汇编
        disasm = idc.generate_disasm_line(xref.frm, 0)
        if isinstance(disasm, tuple):
            disasm_text = disasm[0]
        else:
            disasm_text = disasm
        disasm_text = ida_lines.tag_remove(disasm_text)
        
        xrefs.append({
            "from_ea": xref.frm,
            "to_ea": xref.to,
            "type": xref_type,
            "function": func_name,
            "disasm": disasm_text
        })
    
    return {
        "target": target,
        "target_name": target_name,
        "target_ea": ea,
        "xrefs": xrefs,
        "count": len(xrefs)
    }


def _list_globals(offset=0, count=100):
    """
    列出所有全局变量/数据(分页)
    """
    try:
        offset = int(offset)
        count = int(count)
    except Exception:
        return {"error": "offset and count must be integers"}
    
    if offset < 0:
        offset = 0
    if count <= 0 or count > 1000:
        count = 100
    
    globals_list = []
    
    # 遍历所有命名的地址
    all_names = []
    for segea in idautils.Segments():
        seg = idaapi.getseg(segea)
        if not seg:
            continue
        
        # 只处理数据段
        if seg.type == idaapi.SEG_DATA or seg.type == idaapi.SEG_BSS:
            for head in idautils.Heads(seg.start_ea, seg.end_ea):
                name = ida_name.get_name(head)
                if name:
                    # 过滤掉函数
                    if not ida_funcs.get_func(head):
                        # 获取数据类型和大小
                        flags = ida_bytes.get_flags(head)
                        size = ida_bytes.get_item_size(head)
                        
                        # 判断数据类型
                        if ida_bytes.is_byte(flags):
                            dtype = "byte"
                        elif ida_bytes.is_word(flags):
                            dtype = "word"
                        elif ida_bytes.is_dword(flags):
                            dtype = "dword"
                        elif ida_bytes.is_qword(flags):
                            dtype = "qword"
                        elif ida_bytes.is_strlit(flags):
                            dtype = "string"
                        else:
                            dtype = "unknown"
                        
                        all_names.append({
                            "ea": head,
                            "name": name,
                            "type": dtype,
                            "size": size,
                            "segment": idc.get_segm_name(head)
                        })
    
    # 分页
    total = len(all_names)
    paginated = all_names[offset:offset + count]
    
    return {
        "globals": paginated,
        "total": total,
        "offset": offset,
        "count": len(paginated),
        "has_more": offset + count < total
    }


def _read_memory_bytes(address, size):
    """
    读取指定地址的字节
    """
    try:
        ea = int(address)
        size = int(size)
    except Exception:
        return {"error": "address and size must be integers"}
    
    if size <= 0 or size > 65536:
        return {"error": "size must be between 1 and 65536"}
    
    # 检查地址是否有效
    if not idaapi.is_mapped(ea):
        return {"error": f"address {hex(ea)} is not mapped"}
    
    # 读取字节
    data = ida_bytes.get_bytes(ea, size)
    if data is None:
        return {"error": f"failed to read {size} bytes at {hex(ea)}"}
    
    # 转换为十六进制字符串和字节列表
    hex_str = data.hex()
    byte_list = list(data)
    
    # 尝试获取地址名称
    name = ida_name.get_name(ea)
    
    return {
        "address": ea,
        "size": len(data),
        "name": name if name else None,
        "hex": hex_str,
        "bytes": byte_list,
        "ascii": "".join(chr(b) if 32 <= b < 127 else "." for b in data)
    }


def _get_strings(min_length=4, offset=0, count=100):
    """
    获取程序中的所有字符串(分页)
    """
    try:
        min_length = int(min_length)
        offset = int(offset)
        count = int(count)
    except Exception:
        return {"error": "min_length, offset and count must be integers"}
    
    if min_length < 1:
        min_length = 4
    if offset < 0:
        offset = 0
    if count <= 0 or count > 1000:
        count = 100
    
    strings = []
    
    # 遍历所有字符串
    sc = idautils.Strings()
    sc.setup(minlen=min_length)
    
    all_strings = []
    for s in sc:
        try:
            # 获取字符串地址和内容
            ea = s.ea
            length = s.length
            strtype = s.strtype
            
            # 读取字符串内容
            content = idc.get_strlit_contents(ea, length, strtype)
            if content:
                # 转换为可读字符串
                if isinstance(content, bytes):
                    try:
                        text = content.decode('utf-8', errors='ignore')
                    except Exception:
                        text = str(content)
                else:
                    text = str(content)
                
                # 获取字符串类型描述
                strtype_map = {
                    0: "C",           # STRTYPE_C
                    1: "C_16",        # STRTYPE_C_16
                    2: "C_32",        # STRTYPE_C_32
                    32: "Pascal",     # STRTYPE_PASCAL
                    33: "Pascal_16",  # STRTYPE_PASCAL_16
                }
                type_name = strtype_map.get(strtype, f"Type_{strtype}")
                
                # 获取引用该字符串的位置
                xrefs = []
                for xref in idautils.XrefsTo(ea):
                    func = ida_funcs.get_func(xref.frm)
                    func_name = ida_funcs.get_func_name(func.start_ea) if func else "<no_func>"
                    xrefs.append({
                        "from": xref.frm,
                        "function": func_name
                    })
                
                all_strings.append({
                    "ea": ea,
                    "length": length,
                    "type": type_name,
                    "content": text,
                    "xrefs_count": len(xrefs),
                    "xrefs": xrefs[:5]  # 只保留前5个引用
                })
        except Exception:
            continue
    
    # 分页
    total = len(all_strings)
    paginated = all_strings[offset:offset + count]
    
    return {
        "strings": paginated,
        "total": total,
        "offset": offset,
        "count": len(paginated),
        "has_more": offset + count < total
    }


def _jump_to_address(address):
    """
    跳转到指定地址（类似按 g 键）
    """
    try:
        ea = int(address)
    except Exception:
        return {"error": "address must be an integer"}
    
    # 检查地址是否有效
    if not idaapi.is_mapped(ea):
        return {"error": f"address {hex(ea)} is not mapped"}
    
    # 跳转到地址
    idaapi.jumpto(ea)
    
    return {
        "address": ea,
        "hex_address": hex(ea),
        "ok": True
    }


def _set_data_type(address, data_type):
    """
    设置指定地址的数据类型
    """
    try:
        ea = int(address)
    except Exception:
        return {"error": "address must be an integer"}
    
    if not idaapi.is_mapped(ea):
        return {"error": f"address {hex(ea)} is not mapped"}
    
    # 先删除现有数据
    ida_bytes.del_items(ea, ida_bytes.DELIT_SIMPLE)
    
    # 根据类型设置数据
    success = False
    if data_type == "byte":
        success = ida_bytes.create_data(ea, ida_bytes.FF_BYTE, 1, idaapi.BADADDR)
    elif data_type == "word":
        success = ida_bytes.create_data(ea, ida_bytes.FF_WORD, 2, idaapi.BADADDR)
    elif data_type == "dword":
        success = ida_bytes.create_data(ea, ida_bytes.FF_DWORD, 4, idaapi.BADADDR)
    elif data_type == "qword":
        success = ida_bytes.create_data(ea, ida_bytes.FF_QWORD, 8, idaapi.BADADDR)
    elif data_type == "float":
        success = ida_bytes.create_data(ea, ida_bytes.FF_FLOAT, 4, idaapi.BADADDR)
    elif data_type == "double":
        success = ida_bytes.create_data(ea, ida_bytes.FF_DOUBLE, 8, idaapi.BADADDR)
    elif data_type == "ascii":
        success = ida_bytes.create_strlit(ea, 0, ida_nalt.STRTYPE_C)
    elif data_type == "unicode":
        success = ida_bytes.create_strlit(ea, 0, ida_nalt.STRTYPE_C_16)
    else:
        return {"error": f"unsupported data type: {data_type}"}
    
    if not success:
        return {"error": f"failed to set data type {data_type} at {hex(ea)}"}
    
    return {
        "address": ea,
        "hex_address": hex(ea),
        "data_type": data_type,
        "ok": True
    }


def _set_function_pointer_type(address, function_signature):
    """
    设置函数指针类型（类似按 Y 键）
    """
    try:
        ea = int(address)
    except Exception:
        return {"error": "address must be an integer"}
    
    if not idaapi.is_mapped(ea):
        return {"error": f"address {hex(ea)} is not mapped"}
    
    # 先设置为 QWORD 类型（函数指针通常是 8 字节）
    ida_bytes.del_items(ea, ida_bytes.DELIT_SIMPLE)
    if not ida_bytes.create_data(ea, ida_bytes.FF_QWORD, 8, idaapi.BADADDR):
        return {"error": f"failed to set qword data at {hex(ea)}"}
    
    # 设置类型信息
    try:
        tinfo = idaapi.tinfo_t()
        
        # 规范化函数签名
        sig = _normalize_function_signature(function_signature)
        if not sig:
            return {"error": "empty function signature"}
        
        # 尝试解析类型 - 使用正确的参数
        til = idaapi.get_idati()
        if idaapi.parse_decl(tinfo, til, sig, idaapi.PT_TYP | idaapi.PT_SIL):
            # 成功解析，设置类型信息
            if ida_nalt.set_tinfo(ea, tinfo):
                return {
                    "address": ea,
                    "hex_address": hex(ea),
                    "function_signature": function_signature,
                    "parsed_signature": sig,
                    "ok": True
                }
            else:
                return {"error": f"failed to set type info at {hex(ea)}"}
        else:
            # 解析失败，尝试一些通用的函数指针类型
            generic_sigs = [
                "void* (*func)();",
                "int (*func)();",
                "void (*func)();",
                "NTSTATUS (*func)();"
            ]
            
            for generic_sig in generic_sigs:
                if idaapi.parse_decl(tinfo, til, generic_sig, idaapi.PT_TYP | idaapi.PT_SIL):
                    if ida_nalt.set_tinfo(ea, tinfo):
                        return {
                            "address": ea,
                            "hex_address": hex(ea),
                            "function_signature": function_signature,
                            "fallback_signature": generic_sig,
                            "warning": f"Original signature failed, used fallback: {generic_sig}",
                            "ok": True
                        }
            
            return {"error": f"failed to parse function signature: {function_signature}"}
        
    except Exception as e:
        return {"error": f"failed to set function pointer type: {e}"}


def _create_segment(address, size=0x1000, name="created_seg", seg_class="DATA"):
    """
    创建一个新的 segment
    """
    try:
        ea = int(address)
        size = int(size)
    except Exception:
        return {"error": "address and size must be integers"}
    
    # 页对齐起始地址
    aligned_start = ea & ~0xFFF
    # 计算结束地址，确保包含目标地址
    end_ea = max(aligned_start + size, ea + 0x100)
    # 页对齐结束地址
    aligned_end = (end_ea + 0xFFF) & ~0xFFF
    
    try:
        # 创建 segment
        seg = idaapi.segment_t()
        seg.start_ea = aligned_start
        seg.end_ea = aligned_end
        seg.bitness = 1  # 64-bit
        seg.perm = idaapi.SEGPERM_READ | idaapi.SEGPERM_WRITE
        
        # 设置 segment 类型
        if seg_class.upper() == "CODE":
            seg.type = idaapi.SEG_CODE
            seg.perm |= idaapi.SEGPERM_EXEC
        else:
            seg.type = idaapi.SEG_DATA
        
        # 添加 segment
        if idaapi.add_segm_ex(seg, name, seg_class, idaapi.ADDSEG_SPARSE):
            return {
                "address": ea,
                "hex_address": hex(ea),
                "segment_start": aligned_start,
                "segment_end": aligned_end,
                "segment_name": name,
                "ok": True
            }
        else:
            return {"error": f"failed to create segment at {hex(aligned_start)}"}
    except Exception as e:
        return {"error": f"failed to create segment: {e}"}


def _set_name(address, name):
    """
    设置地址的名字（类似按 N 键）
    智能处理：如果地址处存储的是函数指针，自动设置为 QWORD 并应用函数指针类型
    如果函数指针指向的目标地址无效，先为目标地址创建 segment
    """
    try:
        ea = int(address)
    except Exception:
        return {"error": "address must be an integer"}
    
    if not idaapi.is_mapped(ea):
        return {"error": f"address {hex(ea)} is not mapped"}
    
    results = {}
    
    # 读取地址处的值，检查是否是函数指针
    try:
        # 尝试读取 8 字节（64位指针）
        ptr_value = ida_bytes.get_qword(ea)
        if ptr_value and ptr_value != idaapi.BADADDR:
            results["pointer_value"] = hex(ptr_value)
            
            # 检查目标地址是否已映射
            target_mapped = idaapi.is_mapped(ptr_value)
            if not target_mapped:
                # 目标地址未映射，尝试创建 segment
                results["target_not_mapped"] = f"target address {hex(ptr_value)} not mapped"
                
                segment_name = f"seg_{hex(ptr_value)[2:].upper()}"
                seg_result = _create_segment(ptr_value, size=0x10000, name=segment_name, seg_class="CODE")
                
                if "error" not in seg_result:
                    results["segment_created"] = {
                        "name": segment_name,
                        "start": hex(seg_result.get("segment_start", 0)),
                        "end": hex(seg_result.get("segment_end", 0))
                    }
                    # 重新检查是否映射成功
                    target_mapped = idaapi.is_mapped(ptr_value)
                else:
                    results["segment_creation_failed"] = seg_result["error"]
            
            # 检查该值是否指向一个函数（或在新创建的 segment 中）
            target_func = ida_funcs.get_func(ptr_value)
            if target_func:
                results["detected"] = f"function pointer to {hex(ptr_value)}"
                results["target_function"] = ida_funcs.get_func_name(target_func.start_ea)
            elif target_mapped:
                # 即使不是函数，但目标地址已映射，也当作函数指针处理
                results["detected"] = f"pointer to {hex(ptr_value)} (may be function)"
                
            # 如果检测到指针（不管目标是否是函数），都进行处理
            if "detected" in results or target_mapped:
                # 1. 设置为 QWORD 数据类型
                try:
                    ida_bytes.del_items(ea, ida_bytes.DELIT_SIMPLE)
                    if ida_bytes.create_data(ea, ida_bytes.FF_QWORD, 8, idaapi.BADADDR):
                        results["data_type"] = "qword"
                    else:
                        results["data_type"] = "failed to set qword"
                except Exception as e:
                    results["data_type"] = f"error: {e}"
                
                # 2. 尝试设置函数指针类型（使用通用签名）
                try:
                    tinfo = idaapi.tinfo_t()
                    til = idaapi.get_idati()
                    
                    # 尝试多种通用函数指针类型
                    generic_sigs = [
                        "void* (*func)();",
                        "NTSTATUS (*func)();",
                        "int (*func)();",
                        "long (*func)();",
                    ]
                    
                    type_set = False
                    for sig in generic_sigs:
                        if idaapi.parse_decl(tinfo, til, sig, idaapi.PT_TYP | idaapi.PT_SIL):
                            if ida_nalt.set_tinfo(ea, tinfo):
                                results["function_type"] = sig
                                type_set = True
                                break
                    
                    if not type_set:
                        results["function_type"] = "failed to set"
                except Exception as e:
                    results["function_type"] = f"error: {e}"
                
                # 3. 刷新视图
                try:
                    ida_kernwin.refresh_idaview_anyway()
                    if HAS_HEXRAYS:
                        ida_hexrays.refresh_hexrays_view()
                except Exception:
                    pass
            else:
                results["detected"] = f"not a function pointer (points to {hex(ptr_value)})"
    except Exception as e:
        results["detection_error"] = str(e)
    
    # 设置名字 - 处理名称冲突
    final_name = name
    name_set = False
    
    # 首先检查名称是否已存在
    existing_ea = ida_name.get_name_ea(idaapi.BADADDR, name)
    if existing_ea != idaapi.BADADDR and existing_ea != ea:
        # 名称已被使用在其他地址
        results["name_conflict"] = f"name '{name}' already used at {hex(existing_ea)}"
        
        # 尝试使用带后缀的名称
        for i in range(1, 100):
            candidate_name = f"{name}_{i}"
            test_ea = ida_name.get_name_ea(idaapi.BADADDR, candidate_name)
            if test_ea == idaapi.BADADDR or test_ea == ea:
                # 这个名称可用
                if ida_name.set_name(ea, candidate_name, ida_name.SN_AUTO):
                    final_name = candidate_name
                    name_set = True
                    results["name_resolution"] = f"used alternate name: {candidate_name}"
                    break
        
        if not name_set:
            # 如果所有后缀都失败，尝试使用 SN_NOWARN 强制设置
            if ida_name.set_name(ea, name, ida_name.SN_NOWARN | ida_name.SN_AUTO):
                name_set = True
                results["name_resolution"] = "forced name with SN_NOWARN"
            else:
                return {
                    "error": f"failed to set name '{name}' at {hex(ea)} - name already used at {hex(existing_ea)}",
                    "existing_address": hex(existing_ea),
                    "auto_processing": results
                }
    else:
        # 名称未被使用或已经是当前地址的名称
        if ida_name.set_name(ea, name, ida_name.SN_AUTO):
            name_set = True
        else:
            # 尝试使用 SN_NOWARN
            if ida_name.set_name(ea, name, ida_name.SN_NOWARN | ida_name.SN_AUTO):
                name_set = True
                results["name_resolution"] = "set with SN_NOWARN"
            else:
                return {"error": f"failed to set name '{name}' at {hex(ea)}"}
    
    return {
        "address": ea,
        "hex_address": hex(ea),
        "name": final_name,
        "auto_processing": results if results else "none (not a function pointer)",
        "ok": True
    }


def _create_function_pointer(address, name, function_signature):
    """
    完整的函数指针创建流程：跳转、设置 QWORD、设置类型、命名
    """
    try:
        ea = int(address)
    except Exception:
        return {"error": "address must be an integer"}
    
    if not idaapi.is_mapped(ea):
        return {"error": f"address {hex(ea)} is not mapped"}
    
    results = {}
    
    # 1. 跳转到地址
    try:
        idaapi.jumpto(ea)
        results["jump"] = True
    except Exception as e:
        results["jump"] = f"failed: {e}"
    
    # 2. 设置为 QWORD 数据类型
    try:
        ida_bytes.del_items(ea, ida_bytes.DELIT_SIMPLE)
        if ida_bytes.create_data(ea, ida_bytes.FF_QWORD, 8, idaapi.BADADDR):
            results["data_type"] = "qword set successfully"
        else:
            results["data_type"] = "failed to set qword"
    except Exception as e:
        results["data_type"] = f"failed: {e}"
    
    # 3. 设置函数指针类型
    try:
        tinfo = idaapi.tinfo_t()
        til = idaapi.get_idati()
        
        # 规范化函数签名
        sig = _normalize_function_signature(function_signature)
        
        if idaapi.parse_decl(tinfo, til, sig, idaapi.PT_TYP | idaapi.PT_SIL):
            if ida_nalt.set_tinfo(ea, tinfo):
                results["function_type"] = f"set successfully: {sig}"
            else:
                results["function_type"] = "parsed but failed to set"
        else:
            # 尝试通用类型
            generic_sigs = [
                "void* (*func)();",
                "int (*func)();", 
                "void (*func)();",
                "NTSTATUS (*func)();"
            ]
            
            success = False
            for generic_sig in generic_sigs:
                if idaapi.parse_decl(tinfo, til, generic_sig, idaapi.PT_TYP | idaapi.PT_SIL):
                    if ida_nalt.set_tinfo(ea, tinfo):
                        results["function_type"] = f"set generic type: {generic_sig} (original failed: {function_signature})"
                        success = True
                        break
            
            if not success:
                results["function_type"] = f"failed to parse: {function_signature}"
    except Exception as e:
        results["function_type"] = f"failed: {e}"
    
    # 4. 设置名字
    try:
        if ida_name.set_name(ea, name, ida_name.SN_AUTO):
            results["name"] = f"set to '{name}'"
        else:
            results["name"] = f"failed to set '{name}'"
    except Exception as e:
        results["name"] = f"failed: {e}"
    
    # 刷新显示
    try:
        # 刷新 IDA 视图
        ida_kernwin.refresh_idaview_anyway()
        
        # 如果有 Hex-Rays，也刷新反编译视图
        if HAS_HEXRAYS:
            try:
                ida_hexrays.refresh_hexrays_view()
            except Exception:
                pass  # 忽略 Hex-Rays 刷新失败
        
        results["refresh"] = "views refreshed"
    except Exception as e:
        results["refresh"] = f"refresh failed: {e}"
    
    return {
        "address": ea,
        "hex_address": hex(ea),
        "name": name,
        "function_signature": function_signature,
        "results": results,
        "ok": True
    }


def handle_one_request(req: dict):
    method = req.get("method")
    params = req.get("params", {}) or {}
    if method == "list_functions":
        return _list_functions()
    elif method == "call_graph":
        return _build_call_graph(
            max_depth=int(params.get("max_depth", 2)),
            root_name=params.get("root_name"),
        )
    elif method == "analyze_function":
        name = params.get("name")
        if not name:
            return {"error": "name required"}
        target_ea = _find_function_ea(name)
        if target_ea is None:
            return {"error": f"function {name} not found"}
        info = _guess_function_role(target_ea)
        info["call_tree"] = _build_call_graph(
            max_depth=int(params.get("max_depth", 2)),
            root_name=name,
        )
        return info
    elif method == "rename_function":
        ea = int(params["ea"])
        new_name = params["new_name"]
        _rename_function(ea, new_name)
        return {"ok": True}
    elif method == "rename_locals":
        ea = int(params["ea"])
        names = params.get("names", [])
        return _rename_locals(ea, names)
    elif method == "get_pseudocode":
        raw_ea = params.get("ea")
        target_name = params.get("name")
        if raw_ea is None:
            if not target_name:
                return {"error": "name or ea required"}
            target_ea = _find_function_ea(target_name)
            if target_ea is None:
                return {"error": f"function {target_name} not found"}
        else:
            try:
                target_ea = int(raw_ea)
            except Exception:
                return {"error": "ea must be an integer"}
        return _get_pseudocode(target_ea)
    elif method == "add_pseudocode_comment":
        comment = params.get("comment")
        line = params.get("line")
        if comment is None or line is None:
            return {"error": "comment and line required"}
        raw_ea = params.get("ea")
        target_name = params.get("name")
        if raw_ea is None:
            if not target_name:
                return {"error": "name or ea required"}
            target_ea = _find_function_ea(target_name)
            if target_ea is None:
                return {"error": f"function {target_name} not found"}
        else:
            try:
                target_ea = int(raw_ea)
            except Exception:
                return {"error": "ea must be an integer"}
        repeatable = bool(params.get("repeatable", False))
        return _set_pseudocode_comment(target_ea, line, comment, repeatable)
    elif method == "get_disassembly":
        raw_ea = params.get("ea")
        target_name = params.get("name")
        if raw_ea is None:
            if not target_name:
                return {"error": "name or ea required"}
            target_ea = _find_function_ea(target_name)
            if target_ea is None:
                return {"error": f"function {target_name} not found"}
        else:
            try:
                target_ea = int(raw_ea)
            except Exception:
                return {"error": "ea must be an integer"}
        return _get_disassembly(target_ea)
    elif method == "get_imports":
        return {"imports": _get_imports()}
    elif method == "get_exports":
        return {"exports": _get_exports()}
    elif method == "get_xrefs_to":
        target = params.get("target")
        if target is None:
            return {"error": "target required (address or name)"}
        return _get_xrefs_to(target)
    elif method == "list_globals":
        offset = int(params.get("offset", 0))
        count = int(params.get("count", 100))
        return _list_globals(offset, count)
    elif method == "read_memory_bytes":
        address = params.get("address")
        size = params.get("size")
        if address is None or size is None:
            return {"error": "address and size required"}
        return _read_memory_bytes(address, size)
    elif method == "get_strings":
        min_length = int(params.get("min_length", 4))
        offset = int(params.get("offset", 0))
        count = int(params.get("count", 100))
        return _get_strings(min_length, offset, count)
    elif method == "jump_to_address":
        address = params.get("address")
        if address is None:
            return {"error": "address required"}
        return _jump_to_address(address)
    elif method == "set_data_type":
        address = params.get("address")
        data_type = params.get("data_type")
        if address is None or data_type is None:
            return {"error": "address and data_type required"}
        return _set_data_type(address, data_type)
    elif method == "set_function_pointer_type":
        address = params.get("address")
        function_signature = params.get("function_signature")
        if address is None or function_signature is None:
            return {"error": "address and function_signature required"}
        return _set_function_pointer_type(address, function_signature)
    elif method == "set_name":
        address = params.get("address")
        name = params.get("name")
        if address is None or name is None:
            return {"error": "address and name required"}
        return _set_name(address, name)
    elif method == "create_function_pointer":
        address = params.get("address")
        name = params.get("name")
        function_signature = params.get("function_signature")
        if address is None or name is None or function_signature is None:
            return {"error": "address, name and function_signature required"}
        return _create_function_pointer(address, name, function_signature)
    elif method == "create_segment":
        address = params.get("address")
        if address is None:
            return {"error": "address required"}
        size = params.get("size", 0x1000)
        name = params.get("name", "created_seg")
        seg_class = params.get("class", "DATA")
        return _create_segment(address, size, name, seg_class)
    else:
        return {"error": f"unknown method {method}"}


def serve():
    global PORT
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        sock.bind((HOST, PORT))
    except OSError:
        PORT += 1
        sock.bind((HOST, PORT))
    sock.listen(5)
    print(f"[ida-bridge] listening on {HOST}:{PORT}")

    while True:
        conn, addr = sock.accept()
        data = b""
        while True:
            chunk = conn.recv(65536)
            if not chunk:
                break
            data += chunk
            if b"\n" in chunk:
                break
        try:
            req = json.loads(data.decode("utf-8").strip())

            def _do():
                try:
                    res = handle_one_request(req)
                except Exception:
                    res = {"error": traceback.format_exc()}
                conn.sendall((json.dumps(res) + "\n").encode("utf-8"))
                conn.close()

            ida_kernwin.execute_sync(_do, ida_kernwin.MFF_FAST)
        except Exception:
            traceback.print_exc()
            conn.close()


class ida_bridge_plugin_t(ida_idaapi.plugin_t):
    flags = ida_idaapi.PLUGIN_KEEP
    comment = "IDA bridge for MCP"
    help = "Expose IDA analysis via TCP for external MCP server"
    wanted_name = "ida_bridge"
    wanted_hotkey = ""

    def init(self):
        # 防止多次起线程
        if getattr(ida_idaapi, "_IDA_BRIDGE_STARTED", False):
            print("[ida-bridge] already started, skip")
            return ida_idaapi.PLUGIN_KEEP
        ida_idaapi._IDA_BRIDGE_STARTED = True

        t = threading.Thread(target=serve, daemon=True)
        t.start()
        print("[ida-bridge] server thread started")
        return ida_idaapi.PLUGIN_KEEP

    def run(self, arg):
        pass

    def term(self):
        pass


def PLUGIN_ENTRY():
    return ida_bridge_plugin_t()

```

`mcp_ida_server.py`:

```py
import sys
import os
import json
import socket
import traceback
import time
import re


LOG_FILE = r"C:\temp\ida_mcp.log"

IDA_HOST = os.getenv("IDA_HOST", "127.0.0.1")
IDA_PORT = int(os.getenv("IDA_PORT", "31337"))


# ---------- logging: force UTF-8 on stderr ----------
def log(msg: str):
    # stderr 给 codex：一定是 utf-8
    try:
        sys.stderr.buffer.write((msg + "\n").encode("utf-8"))
        sys.stderr.flush()
    except Exception:
        pass
    # 本地文件你自己看
    try:
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(msg + "\n")
    except Exception:
        pass


# ---------- talk to IDA bridge ----------
def ida_request(method: str, **params):
    log(f"[ida-mcp] -> IDA request: {method} {params}")
    try:
        s = socket.create_connection((IDA_HOST, IDA_PORT), timeout=5.0)
    except OSError as e:
        err = {"error": f"connect ida failed: {e}"}
        log(f"[ida-mcp] <- IDA error(connect): {err}")
        return err
    payload = json.dumps({"method": method, "params": params}, ensure_ascii=True) + "\n"
    s.sendall(payload.encode("utf-8"))
    data = b""
    while True:
        chunk = s.recv(65536)
        if not chunk:
            break
        data += chunk
        if b"\n" in chunk:
            break
    s.close()
    if not data:
        err = {"error": "empty reply from ida"}
        log(f"[ida-mcp] <- IDA error(empty): {err}")
        return err
    text = data.decode("utf-8", "ignore").strip()
    log(f"[ida-mcp] <- IDA raw: {text}")
    try:
        return json.loads(text)
    except Exception as e:
        err = {"error": f"bad json from ida: {e}", "raw": text}
        log(f"[ida-mcp] <- IDA error(json): {err}")
        return err


# ---------- safe send to stdout (must be ascii/utf-8) ----------
def safe_send(obj: dict):
    # Codex 这边最稳就是 ensure_ascii=True
    line = json.dumps(obj, ensure_ascii=True)
    log(f"[ida-mcp] -> MCP stdout: {line}")
    try:
        sys.stdout.buffer.write((line + "\n").encode("utf-8"))
        sys.stdout.flush()
    except BrokenPipeError:
        log("[ida-mcp] BrokenPipeError on send, exiting.")
        sys.exit(0)


# ---------- handlers ----------
def handle_initialize(req: dict):
    params = req.get("params") or {}
    client_proto = params.get("protocolVersion", "2024-11-05")
    log(f"[ida-mcp] initialize from client: {params}")
    resp = {
        "jsonrpc": "2.0",
        "id": req.get("id"),
        "result": {
            "protocolVersion": client_proto,
            "capabilities": {
                "tools": {},
                "resources": {},
            },
            "serverInfo": {
                "name": "ida-mcp",
                "version": "0.2.1",
            },
        },
    }
    safe_send(resp)


def handle_tools_list(req: dict):
    log("[ida-mcp] tools/list called")
    # 全部用英文描述，避免再出编码问题
    tools = [
        {
            "name": "ida_list_functions",
            "description": "List all functions from current IDA database",
            "inputSchema": {"type": "object", "properties": {}, "required": []},
        },
        {
            "name": "ida_call_graph",
            "description": "Get call graph from a function (depth-limited)",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "name": {"type": "string"},
                    "max_depth": {"type": "integer", "default": 2},
                },
                "required": ["name"],
            },
        },
        {
            "name": "ida_analyze_function",
            "description": "Analyze a function to guess its role based on called functions. Returns analysis results WITHOUT renaming by default. Use ida_list_functions to get valid function names. IMPORTANT: Only set rename=true when explicitly asked to rename the function.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Function name to analyze (e.g., 'DriverEntry', 'sub_118C0')"
                    },
                    "max_depth": {
                        "type": "integer",
                        "default": 2,
                        "description": "Maximum depth for call graph analysis (1-3 recommended)"
                    },
                    "rename": {
                        "type": "boolean",
                        "default": False,
                        "description": "CAUTION: Set to true ONLY when user explicitly requests renaming. Default false means analysis only, no modifications to IDA database."
                    },
                    "rename_locals": {
                        "type": "boolean",
                        "default": False,
                        "description": "CAUTION: Set to true ONLY when user explicitly requests renaming local variables. Requires rename=true."
                    },
                },
                "required": ["name"],
            },
        },
        {
            "name": "ida_get_pseudocode",
            "description": "Return Hex-Rays/F5 pseudocode for a function. IMPORTANT: Use function 'name' parameter (recommended), not 'ea'. Get function names from ida_list_functions first. Supports pagination for large content.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Function name (RECOMMENDED - e.g., 'DriverEntry', 'sub_118C0'). Use ida_list_functions to get valid names."
                    },
                    "ea": {
                        "type": "integer",
                        "description": "Function start address in decimal (AVOID if possible - must be > 0). Use 'name' instead."
                    },
                    "offset": {
                        "type": "integer",
                        "description": "Starting line number (0-based) for pagination. Default is 0 (from beginning).",
                        "default": 0
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of lines to return. If not specified, returns all lines. Use for pagination of large functions.",
                    },
                },
                "anyOf": [
                    {"required": ["name"]},
                    {"required": ["ea"]}
                ],
            },
        },
        {
            "name": "ida_get_disassembly",
            "description": "Return full disassembly for a function. IMPORTANT: Use function 'name' parameter (recommended), not 'ea'. Get function names from ida_list_functions first. Supports pagination for large content.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Function name (RECOMMENDED - e.g., 'DriverEntry', 'sub_118C0'). Use ida_list_functions to get valid names."
                    },
                    "ea": {
                        "type": "integer",
                        "description": "Function start address in decimal (AVOID if possible - must be > 0). Use 'name' instead."
                    },
                    "offset": {
                        "type": "integer",
                        "description": "Starting line number (0-based) for pagination. Default is 0 (from beginning).",
                        "default": 0
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of lines to return. If not specified, returns all lines. Use for pagination of large functions.",
                    },
                },
                "anyOf": [
                    {"required": ["name"]},
                    {"required": ["ea"]}
                ],
            },
        },
        {
            "name": "ida_add_pseudocode_comment",
            "description": "Add a comment inside Hex-Rays pseudocode at the given line number (line+comment plus name or ea required)",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "ea": {"type": "integer"},
                        "line": {"type": "integer"},
                        "comment": {"type": "string"},
                        "repeatable": {"type": "boolean", "default": False},
                    },
                    "required": ["name","line", "comment"],
                },
            },
        {
            "name": "ida_rename_function",
            "description": "Rename a function in IDA by old name",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "old_name": {"type": "string"},
                    "new_name": {"type": "string"},
                },
                "required": ["old_name", "new_name"],
            },
        },
        {
            "name": "ida_get_imports",
            "description": "Get all imports (imported functions from DLLs) from the IDA database",
            "inputSchema": {
                "type": "object",
                "properties": {},
                "required": [],
            },
        },
        {
            "name": "ida_get_exports",
            "description": "Get all exports (exported functions) from the IDA database",
            "inputSchema": {
                "type": "object",
                "properties": {},
                "required": [],
            },
        },
        {
            "name": "ida_get_xrefs",
            "description": "Get all cross-references (xrefs) to a variable, function, or address. Shows where the target is used/called in the code.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "target": {
                        "type": ["string", "integer"],
                        "description": "Target name (e.g., 'dword_5CE14', 'sub_12FA8') or address in decimal. Use ida_list_functions or ida_get_imports to find valid names."
                    },
                },
                "required": ["target"],
            },
        },
        {
            "name": "ida_list_globals",
            "description": "List all global variables/data in the IDA database (paginated). Returns named data symbols from data segments.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "offset": {
                        "type": "integer",
                        "default": 0,
                        "description": "Starting offset for pagination (0-based)"
                    },
                    "count": {
                        "type": "integer",
                        "default": 100,
                        "description": "Maximum number of globals to return (1-1000)"
                    },
                },
                "required": [],
            },
        },
        {
            "name": "ida_read_memory",
            "description": "Read raw bytes from a specific memory address in the IDA database. Returns hex dump and ASCII representation.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "integer",
                        "description": "Memory address to read from (in decimal)"
                    },
                    "size": {
                        "type": "integer",
                        "description": "Number of bytes to read (1-65536)"
                    },
                },
                "required": ["address", "size"],
            },
        },
        {
            "name": "ida_get_strings",
            "description": "List all strings found in the IDA database (paginated). Returns string content, location, type, and cross-references.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "min_length": {
                        "type": "integer",
                        "default": 4,
                        "description": "Minimum string length to include (1-255)"
                    },
                    "offset": {
                        "type": "integer",
                        "default": 0,
                        "description": "Starting offset for pagination (0-based)"
                    },
                    "count": {
                        "type": "integer",
                        "default": 100,
                        "description": "Maximum number of strings to return (1-1000)"
                    },
                },
                "required": [],
            },
        },
        {
            "name": "ida_jump_to_address",
            "description": "Jump to a specific address in IDA (similar to pressing 'g' and entering address). Useful for navigating to function pointers or data locations.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "integer",
                        "description": "Target address to jump to (in decimal)"
                    },
                },
                "required": ["address"],
            },
        },
        {
            "name": "ida_set_data_type",
            "description": "Set the data type at a specific address (byte, word, dword, qword, etc.). Similar to pressing 'D' then type key in IDA.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "integer",
                        "description": "Address to set data type for (in decimal)"
                    },
                    "data_type": {
                        "type": "string",
                        "enum": ["byte", "word", "dword", "qword", "float", "double", "ascii", "unicode"],
                        "description": "Data type to set (byte=1, word=2, dword=4, qword=8 bytes)"
                    },
                },
                "required": ["address", "data_type"],
            },
        },
        {
            "name": "ida_set_function_pointer_type",
            "description": "Set a function pointer type at a specific address (similar to pressing 'Y' in IDA). This helps Hex-Rays recognize function pointers and display proper function calls instead of MEMORY[address]. FIXED: Now supports simplified signatures.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "integer",
                        "description": "Address to set function pointer type for (in decimal)"
                    },
                    "function_signature": {
                        "type": "string",
                        "description": "Function signature. Supports simplified formats: 'NTSTATUS', 'NTSTATUS __fastcall', etc. Also accepts full signatures like 'NTSTATUS (__fastcall *)(void *a1, void *a2, int a3, int a4, int a5)'"
                    },
                },
                "required": ["address", "function_signature"],
            },
        },
        {
            "name": "ida_set_name",
            "description": "Set a name for an address (similar to pressing 'N' in IDA). INTELLIGENT: Automatically detects function pointers and sets proper QWORD data type + function pointer type, making Hex-Rays display function calls correctly instead of MEMORY[address]. Useful for naming function pointers, variables, or functions.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "integer",
                        "description": "Address to name (in decimal)"
                    },
                    "name": {
                        "type": "string",
                        "description": "New name for the address (e.g., 'MmIsAddressValid', 'ExAllocatePool', 'g_ApiPointer')"
                    },
                },
                "required": ["address", "name"],
            },
        },
        {
            "name": "ida_create_function_pointer",
            "description": "Complete workflow: convert MEMORY[address] calls to named function calls. This combines jump, set qword data type, set function pointer type, and naming in one operation. FIXED: Now supports simplified signatures like 'NTSTATUS __fastcall'.",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "integer",
                        "description": "Address of the function pointer (in decimal)"
                    },
                    "name": {
                        "type": "string",
                        "description": "Function name (e.g., 'PsLookupSomething')"
                    },
                    "function_signature": {
                        "type": "string",
                        "description": "Function signature. Supports simplified formats: 'NTSTATUS', 'NTSTATUS __fastcall', 'HANDLE', etc. Also accepts full signatures like 'NTSTATUS (__fastcall *)(void *, void *, int, int, int)'"
                    },
                },
                "required": ["address", "name", "function_signature"],
            },
        },
    ]
    resp = {
        "jsonrpc": "2.0",
        "id": req.get("id"),
        "result": {
            "tools": tools
        },
    }
    safe_send(resp)


def handle_tools_call(req: dict):
    params = req.get("params") or {}
    tool_name = params.get("name")
    args = params.get("arguments") or {}
    log(f"[ida-mcp] tools/call {tool_name} {args}")

    def ok(text: str, meta: dict = None):
        result = {
            "jsonrpc": "2.0",
            "id": req.get("id"),
            "result": {
                "content": [{"type": "text", "text": text}],
                "isError": False,
            },
        }
        if meta:
            result["result"]["_meta"] = meta
        safe_send(result)

    def err(text: str):
        safe_send({
            "jsonrpc": "2.0",
            "id": req.get("id"),
            "result": {
                "content": [{"type": "text", "text": text}],
                "isError": True,
            },
        })

    try:
        if tool_name == "ida_list_functions":
            data = ida_request("list_functions")
            ok(json.dumps(data, ensure_ascii=True, indent=2))

        elif tool_name == "ida_call_graph":
            name = args.get("name")
            max_depth = int(args.get("max_depth", 2))
            data = ida_request("call_graph", root_name=name, max_depth=max_depth)
            ok(json.dumps(data, ensure_ascii=True, indent=2))

        elif tool_name == "ida_analyze_function":
            name = args.get("name")
            max_depth = int(args.get("max_depth", 2))
            rename = bool(args.get("rename", False))
            rename_locals = bool(args.get("rename_locals", False))

            analysis = ida_request("analyze_function", name=name, max_depth=max_depth)
            if "error" in analysis:
                err("analyze failed: " + analysis["error"])
                return

            roles = analysis.get("role") or []
            role_slug = roles[0] if roles else "func"
            safe_role = role_slug.replace(" ", "_").replace("/", "_")
            new_name = f"{safe_role}_{name}"

            if rename:
                ea = analysis.get("ea")
                if ea is not None:
                    ida_request("rename_function", ea=int(ea), new_name=new_name)
                    if rename_locals:
                        ida_request("rename_locals", ea=int(ea), names=["ctx", "arg", "tmp", "ret"])

            # 这里也用 ASCII，避免再炸
            lines = []
            lines.append(f"function {name} roles: {', '.join(roles) if roles else 'unknown'}")
            lines.append(f"depth: {max_depth}")
            if rename:
                lines.append(f"renamed to: {new_name}")
            lines.append("call_tree:")
            lines.append(json.dumps(analysis.get("call_tree", {}), ensure_ascii=True, indent=2))

            ok("\n".join(lines), meta={"analysis": analysis})

        elif tool_name == "ida_get_pseudocode":
            name = args.get("name")
            ea_arg = args.get("ea")
            offset = int(args.get("offset", 0))
            limit = args.get("limit")
            
            # Validate and filter ea
            if ea_arg is not None and ea_arg == 0:
                # If name is also provided, just ignore the invalid ea and use name
                if name:
                    log(f"[ida-mcp] Ignoring invalid ea=0, using name={name}")
                    ea_arg = None
                else:
                    err("ea cannot be 0. Provide a valid function name instead (e.g., 'DriverEntry'). Use ida_list_functions to see available functions.")
                    return
            
            if not name and ea_arg is None:
                err("name or ea required. Provide a function name (recommended) or valid address. Use ida_list_functions to get valid function names.")
                return
            
            pseudo_params = {}
            if name:
                pseudo_params["name"] = name
            if ea_arg is not None:
                try:
                    pseudo_params["ea"] = int(ea_arg)
                except Exception:
                    err("ea must be an integer")
                    return
            pseudo = ida_request("get_pseudocode", **pseudo_params)
            if "error" in pseudo:
                err("pseudocode failed: " + pseudo["error"] + ". Try using the function name instead of EA, or verify the function exists with ida_list_functions.")
                return
            pseudo_text = pseudo.get("pseudocode")
            if not isinstance(pseudo_text, str):
                err("pseudocode not returned. The function may not be decompilable or Hex-Rays may not be available.")
                return
            
            # Apply pagination
            lines = pseudo_text.split('\n')
            total_lines = len(lines)
            
            if offset < 0:
                offset = 0
            
            # If offset is at or beyond total lines, return empty content with metadata
            if offset >= total_lines:
                paginated_lines = []
                paginated_text = ""
                end_line = offset
            else:
                if limit is not None:
                    try:
                        limit = int(limit)
                        end_line = min(offset + limit, total_lines)
                    except Exception:
                        err("limit must be an integer")
                        return
                else:
                    end_line = total_lines
                
                paginated_lines = lines[offset:end_line]
                paginated_text = '\n'.join(paginated_lines)
            
            func_name = pseudo.get("name") or name or "<unknown>"
            pseudo_ea = pseudo.get("ea") or pseudo_params.get("ea")
            header = f"function {func_name} pseudocode"
            if pseudo_ea is not None:
                header += f" (EA {hex(pseudo_ea)})"
            
            # Add pagination info to header
            if limit is not None or offset > 0:
                header += f" [lines {offset}-{end_line-1} of {total_lines}]"
            
            result_meta = {
                "pseudocode": pseudo_text,
                "analysis": pseudo,
                "pagination": {
                    "offset": offset,
                    "limit": limit,
                    "returned_lines": len(paginated_lines),
                    "total_lines": total_lines,
                    "has_more": end_line < total_lines
                }
            }
            
            ok("\n".join([header, paginated_text]), meta=result_meta)


        elif tool_name == "ida_get_disassembly":
            name = args.get("name")
            ea_arg = args.get("ea")
            offset = int(args.get("offset", 0))
            limit = args.get("limit")
            
            # Validate and filter ea
            if ea_arg is not None and ea_arg == 0:
                # If name is also provided, just ignore the invalid ea and use name
                if name:
                    log(f"[ida-mcp] Ignoring invalid ea=0, using name={name}")
                    ea_arg = None
                else:
                    err("ea cannot be 0. Provide a valid function name instead (e.g., 'DriverEntry'). Use ida_list_functions to see available functions.")
                    return
            
            if not name and ea_arg is None:
                err("name or ea required. Provide a function name (recommended) or valid address. Use ida_list_functions to get valid function names.")
                return
            
            disasm_params = {}
            if name:
                disasm_params["name"] = name
            if ea_arg is not None:
                try:
                    disasm_params["ea"] = int(ea_arg)
                except Exception:
                    err("ea must be an integer")
                    return
            disasm = ida_request("get_disassembly", **disasm_params)
            if "error" in disasm:
                err("disassembly failed: " + disasm["error"] + ". Try using the function name instead of EA, or verify the function exists with ida_list_functions.")
                return
            disasm_text = disasm.get("disassembly")
            if not isinstance(disasm_text, str):
                err("disassembly not returned. The function may not exist.")
                return
            
            # Apply pagination
            lines = disasm_text.split('\n')
            total_lines = len(lines)
            
            if offset < 0:
                offset = 0
            
            # If offset is at or beyond total lines, return empty content with metadata
            if offset >= total_lines:
                paginated_lines = []
                paginated_text = ""
                end_line = offset
            else:
                if limit is not None:
                    try:
                        limit = int(limit)
                        end_line = min(offset + limit, total_lines)
                    except Exception:
                        err("limit must be an integer")
                        return
                else:
                    end_line = total_lines
                
                paginated_lines = lines[offset:end_line]
                paginated_text = '\n'.join(paginated_lines)
            
            func_name = disasm.get("name") or name or "<unknown>"
            header = f"function {func_name} disassembly"
            
            # Add pagination info to header
            if limit is not None or offset > 0:
                header += f" [lines {offset}-{end_line-1} of {total_lines}]"
            
            result_meta = {
                "disassembly": disasm_text,
                "analysis": disasm,
                "pagination": {
                    "offset": offset,
                    "limit": limit,
                    "returned_lines": len(paginated_lines),
                    "total_lines": total_lines,
                    "has_more": end_line < total_lines
                }
            }
            
            ok("\n".join([header, paginated_text]), meta=result_meta)

        elif tool_name == "ida_add_pseudocode_comment":
            name = args.get("name")
            ea_arg = args.get("ea")
            line = args.get("line")
            comment = args.get("comment")
            repeatable = bool(args.get("repeatable", False))
            if comment is None or line is None:
                err("line and comment required")
                return
            try:
                line_number = int(line)
            except Exception:
                err("line must be an integer")
                return
            comment_params = {
                "line": line_number,
                "comment": comment,
                "repeatable": repeatable,
            }
            if ea_arg is not None:
                try:
                    comment_params["ea"] = int(ea_arg)
                except Exception:
                    err("ea must be an integer")
                    return
            elif name:
                comment_params["name"] = name
            else:
                err("name or ea required")
                return
            resp = ida_request("add_pseudocode_comment", **comment_params)
            if "error" in resp:
                err("add comment failed: " + resp["error"])
                return
            ok(f"pseudocode line {line_number} annotated", meta=resp)

        elif tool_name == "ida_rename_function":
            old_name = args.get("old_name")
            new_name = args.get("new_name")
            funcs = ida_request("list_functions")
            if isinstance(funcs, dict) and "error" in funcs:
                err("list_functions failed: " + funcs["error"])
                return
            target_ea = None
            for f in funcs:
                if f.get("name") == old_name:
                    target_ea = f.get("ea")
                    break
            if target_ea is None:
                err(f"function {old_name} not found")
                return
            ida_request("rename_function", ea=int(target_ea), new_name=new_name)
            ok(f"renamed {old_name} -> {new_name}")

        elif tool_name == "ida_get_imports":
            data = ida_request("get_imports")
            if "error" in data:
                err("get_imports failed: " + data["error"])
                return
            imports = data.get("imports", [])
            
            # 格式化输出
            lines = [f"Total imports: {len(imports)}", ""]
            
            # 按模块分组
            by_module = {}
            for imp in imports:
                module = imp.get("module", "unknown")
                if module not in by_module:
                    by_module[module] = []
                by_module[module].append(imp)
            
            for module in sorted(by_module.keys()):
                lines.append(f"Module: {module}")
                for imp in by_module[module]:
                    ea = imp.get("ea")
                    name = imp.get("name")
                    ordinal = imp.get("ordinal")
                    if ordinal:
                        lines.append(f"  {hex(ea) if ea else '?'}: {name} (ord {ordinal})")
                    else:
                        lines.append(f"  {hex(ea) if ea else '?'}: {name}")
                lines.append("")
            
            ok("\n".join(lines), meta=data)

        elif tool_name == "ida_get_exports":
            data = ida_request("get_exports")
            if "error" in data:
                err("get_exports failed: " + data["error"])
                return
            exports = data.get("exports", [])
            
            lines = [f"Total exports: {len(exports)}", ""]
            for exp in exports:
                ea = exp.get("ea")
                name = exp.get("name")
                ordinal = exp.get("ordinal")
                lines.append(f"{hex(ea) if ea else '?'}: {name} (ordinal {ordinal})")
            
            ok("\n".join(lines), meta=data)

        elif tool_name == "ida_get_xrefs":
            target = args.get("target")
            if not target:
                err("target required")
                return
            
            data = ida_request("get_xrefs_to", target=target)
            if "error" in data:
                err("get_xrefs failed: " + data["error"])
                return
            
            xrefs = data.get("xrefs", [])
            count = data.get("count", 0)
            target_ea = data.get("target_ea")
            target_name = data.get("target_name", str(target))
            
            lines = [
                f"Cross-references to: {target_name}",
                f"Target EA: {hex(target_ea) if target_ea else '?'}",
                f"Total references: {count}",
                ""
            ]
            
            if xrefs:
                for xref in xrefs:
                    from_ea = xref.get("from_ea")
                    ref_type = xref.get("type")
                    func = xref.get("function")
                    disasm = xref.get("disasm")
                    
                    lines.append(f"From: {hex(from_ea)} in {func}")
                    lines.append(f"  Type: {ref_type}")
                    lines.append(f"  Code: {disasm}")
                    lines.append("")
            else:
                lines.append("No references found.")
            
            ok("\n".join(lines), meta=data)

        elif tool_name == "ida_list_globals":
            offset = int(args.get("offset", 0))
            count = int(args.get("count", 100))
            
            data = ida_request("list_globals", offset=offset, count=count)
            if "error" in data:
                err("list_globals failed: " + data["error"])
                return
            
            globals_list = data.get("globals", [])
            total = data.get("total", 0)
            has_more = data.get("has_more", False)
            
            lines = [
                f"Global Variables (showing {len(globals_list)} of {total})",
                f"Offset: {offset}, Has more: {has_more}",
                ""
            ]
            
            for g in globals_list:
                ea = g.get("ea")
                name = g.get("name")
                dtype = g.get("type")
                size = g.get("size")
                segment = g.get("segment")
                
                lines.append(f"{hex(ea)}: {name}")
                lines.append(f"  Type: {dtype}, Size: {size}, Segment: {segment}")
            
            if has_more:
                lines.append("")
                lines.append(f"Use offset={offset + count} to get next page")
            
            ok("\n".join(lines), meta=data)

        elif tool_name == "ida_read_memory":
            address = args.get("address")
            size = args.get("size")
            
            if address is None or size is None:
                err("address and size required")
                return
            
            try:
                address = int(address)
                size = int(size)
            except Exception:
                err("address and size must be integers")
                return
            
            data = ida_request("read_memory_bytes", address=address, size=size)
            if "error" in data:
                err("read_memory failed: " + data["error"])
                return
            
            read_size = data.get("size", 0)
            hex_str = data.get("hex", "")
            ascii_str = data.get("ascii", "")
            name = data.get("name")
            
            lines = [
                f"Memory at {hex(address)}" + (f" ({name})" if name else ""),
                f"Size: {read_size} bytes",
                "",
                "Hex dump:"
            ]
            
            # 格式化十六进制输出 (16 字节一行)
            for i in range(0, len(hex_str), 32):  # 32 hex chars = 16 bytes
                chunk_hex = hex_str[i:i+32]
                # 添加空格分隔
                formatted_hex = " ".join(chunk_hex[j:j+2] for j in range(0, len(chunk_hex), 2))
                chunk_ascii = ascii_str[i//2:i//2+16]
                addr_offset = address + i//2
                lines.append(f"{hex(addr_offset)}: {formatted_hex:48s}  {chunk_ascii}")
            
            ok("\n".join(lines), meta=data)

        elif tool_name == "ida_get_strings":
            min_length = int(args.get("min_length", 4))
            offset = int(args.get("offset", 0))
            count = int(args.get("count", 100))
            
            data = ida_request("get_strings", min_length=min_length, offset=offset, count=count)
            if "error" in data:
                err("get_strings failed: " + data["error"])
                return
            
            strings_list = data.get("strings", [])
            total = data.get("total", 0)
            has_more = data.get("has_more", False)
            
            lines = [
                f"Strings found in database (showing {len(strings_list)} of {total})",
                f"Minimum length: {min_length}, Offset: {offset}, Has more: {has_more}",
                ""
            ]
            
            for s in strings_list:
                ea = s.get("ea")
                length = s.get("length")
                content = s.get("content", "")
                str_type = s.get("type")
                xrefs_count = s.get("xrefs_count", 0)
                xrefs = s.get("xrefs", [])
                
                # 限制显示长度,避免输出太长
                display_content = content if len(content) <= 80 else content[:77] + "..."
                
                lines.append(f"{hex(ea)}: \"{display_content}\"")
                lines.append(f"  Type: {str_type}, Length: {length}, Xrefs: {xrefs_count}")
                
                if xrefs:
                    lines.append(f"  Referenced by:")
                    for xref in xrefs:
                        xref_from = xref.get("from")
                        xref_func = xref.get("function")
                        lines.append(f"    {hex(xref_from)} in {xref_func}")
                lines.append("")
            
            if has_more:
                lines.append(f"Use offset={offset + count} to get next page")
            
            ok("\n".join(lines), meta=data)

        elif tool_name == "ida_jump_to_address":
            address = args.get("address")
            if address is None:
                err("address required")
                return
            
            try:
                address = int(address)
            except Exception:
                err("address must be an integer")
                return
            
            data = ida_request("jump_to_address", address=address)
            if "error" in data:
                err("jump_to_address failed: " + data["error"])
                return
            
            ok(f"Jumped to address {hex(address)}")

        elif tool_name == "ida_set_data_type":
            address = args.get("address")
            data_type = args.get("data_type")
            
            if address is None or data_type is None:
                err("address and data_type required")
                return
            
            try:
                address = int(address)
            except Exception:
                err("address must be an integer")
                return
            
            data = ida_request("set_data_type", address=address, data_type=data_type)
            if "error" in data:
                err("set_data_type failed: " + data["error"])
                return
            
            ok(f"Set data type '{data_type}' at address {hex(address)}")

        elif tool_name == "ida_set_function_pointer_type":
            address = args.get("address")
            function_signature = args.get("function_signature")
            
            if address is None or function_signature is None:
                err("address and function_signature required")
                return
            
            try:
                address = int(address)
            except Exception:
                err("address must be an integer")
                return
            
            data = ida_request("set_function_pointer_type", address=address, function_signature=function_signature)
            if "error" in data:
                err("set_function_pointer_type failed: " + data["error"])
                return
            
            ok(f"Set function pointer type at address {hex(address)}: {function_signature}")

        elif tool_name == "ida_set_name":
            address = args.get("address")
            name = args.get("name")
            
            if address is None or name is None:
                err("address and name required")
                return
            
            try:
                address = int(address)
            except Exception:
                err("address must be an integer")
                return
            
            data = ida_request("set_name", address=address, name=name)
            if "error" in data:
                error_msg = data["error"]
                # 如果是地址未映射的错误，尝试先创建 segment
                if "is not mapped" in error_msg:
                    log(f"[ida-mcp] Address not mapped, attempting to create segment at {hex(address)}")
                    
                    # 创建 segment
                    segment_name = f"seg_{hex(address)[2:].upper()}"
                    create_result = ida_request("create_segment", address=address, name=segment_name, size=0x10000)
                    
                    if "error" not in create_result:
                        log(f"[ida-mcp] Successfully created segment, retrying set_name")
                        # 重新尝试设置名称
                        retry_data = ida_request("set_name", address=address, name=name)
                        if "error" in retry_data:
                            err("set_name failed after creating segment: " + retry_data["error"])
                            return
                        else:
                            ok(f"Set name '{name}' at address {hex(address)} (created segment {segment_name})")
                            return
                    else:
                        log(f"[ida-mcp] Failed to create segment: {create_result['error']}")
                        err("set_name failed: " + error_msg + " (and failed to create segment: " + create_result["error"] + ")")
                        return
                else:
                    err("set_name failed: " + error_msg)
                    return
            
            # 构建响应消息
            final_name = data.get("name", name)
            response_lines = [f"Set name '{final_name}' at address {hex(address)}"]
            
            # 添加自动处理信息
            auto_proc = data.get("auto_processing")
            if auto_proc and isinstance(auto_proc, dict):
                # 显示名称冲突处理
                if "name_conflict" in auto_proc:
                    response_lines.append(f"\n⚠ {auto_proc['name_conflict']}")
                    if "name_resolution" in auto_proc:
                        response_lines.append(f"  → Resolution: {auto_proc['name_resolution']}")
                
                # 显示指针值
                if "pointer_value" in auto_proc:
                    response_lines.append(f"\nPointer value: {auto_proc['pointer_value']}")
                
                # 显示段创建信息
                if "segment_created" in auto_proc:
                    seg_info = auto_proc["segment_created"]
                    response_lines.append(f"\n✓ Created segment for target address:")
                    response_lines.append(f"  → Segment name: {seg_info['name']}")
                    response_lines.append(f"  → Range: {seg_info['start']} - {seg_info['end']}")
                
                # 显示检测结果
                detected = auto_proc.get("detected")
                if detected and "pointer" in detected:
                    response_lines.append(f"\n✓ Auto-detected: {detected}")
                    if "target_function" in auto_proc:
                        response_lines.append(f"  → Points to function: {auto_proc['target_function']}")
                    if "data_type" in auto_proc:
                        response_lines.append(f"  → Data type set to: {auto_proc['data_type']}")
                    if "function_type" in auto_proc:
                        response_lines.append(f"  → Function type applied: {auto_proc['function_type']}")
                    response_lines.append("\n✓ Hex-Rays should now display function calls using the name instead of MEMORY[address]")
            
            ok("\n".join(response_lines), meta=data)

        elif tool_name == "ida_create_function_pointer":
            address = args.get("address")
            name = args.get("name")
            function_signature = args.get("function_signature")
            
            if address is None or name is None or function_signature is None:
                err("address, name and function_signature required")
                return
            
            try:
                address = int(address)
            except Exception:
                err("address must be an integer")
                return
            
            data = ida_request("create_function_pointer", address=address, name=name, function_signature=function_signature)
            if "error" in data:
                err("create_function_pointer failed: " + data["error"])
                return
            
            lines = [
                f"Successfully created function pointer at {hex(address)}:",
                f"Name: {name}",
                f"Type: {function_signature}",
                "",
                "Operations performed:",
                "1. Jumped to address",
                "2. Set data type to QWORD",
                "3. Applied function pointer type",
                "4. Set name",
                "",
                "Hex-Rays should now display function calls using the name instead of MEMORY[address]."
            ]
            
            ok("\n".join(lines), meta=data)

        else:
            err(f"unknown tool: {tool_name}")

    except Exception:
        err("exception:\n" + traceback.format_exc())


def _sanitize_resource_id(name: str) -> str:
    return re.sub(r"[^0-9a-zA-Z_-]+", "_", name)


def handle_resources_list(req: dict):
    log("[ida-mcp] resources/list called")
    funcs = ida_request("list_functions")
    resources = []
    if isinstance(funcs, dict) and "error" in funcs:
        error_text = funcs["error"]
        log(f"[ida-mcp] resources/list error fetching functions: {error_text}")
        resources.append(
            {
                "uri": "ida://functions/error",
                "name": "IDA functions unavailable",
                "mimeType": "text/plain",
                "description": error_text,
            }
        )
    elif isinstance(funcs, list):
        limit = 500
        for func in funcs[:limit]:
            name = func.get("name") or "<unnamed>"
            ea = func.get("ea")
            resources.append(
                {
                    "uri": f"ida://function/{ea}/{name}",
                    "name": name,
                    "mimeType": "text/plain",
                    "description": f"IDA function at EA {hex(ea) if isinstance(ea, int) else ea}",
                }
            )
        if not resources:
            resources.append(
                {
                    "uri": "ida://functions/empty",
                    "name": "IDA functions list empty",
                    "mimeType": "text/plain",
                    "description": "IDA returned no functions yet",
                }
            )
    safe_send(
        {
            "jsonrpc": "2.0",
            "id": req.get("id"),
            "result": {"resources": resources},
        }
    )


def handle_resources_read(req: dict):
    log("[ida-mcp] resources/read called")
    params = req.get("params") or {}
    uri = params.get("uri")
    
    if not uri:
        safe_send({
            "jsonrpc": "2.0",
            "id": req.get("id"),
            "error": {
                "code": -32602,
                "message": "uri parameter required",
            },
        })
        return
    
    log(f"[ida-mcp] reading resource: {uri}")
    
    # Parse URI: ida://function/{ea}/{name}
    if uri.startswith("ida://function/"):
        parts = uri.replace("ida://function/", "").split("/", 1)
        if len(parts) >= 2:
            try:
                ea = int(parts[0])
                name = parts[1]
                log(f"[ida-mcp] parsed function: ea={ea}, name={name}")
                
                # Get pseudocode for this function
                pseudo = ida_request("get_pseudocode", name=name)
                
                if "error" in pseudo:
                    # If pseudocode fails, try disassembly
                    log(f"[ida-mcp] pseudocode failed, trying disassembly")
                    disasm = ida_request("get_disassembly", name=name)
                    if "error" in disasm:
                        safe_send({
                            "jsonrpc": "2.0",
                            "id": req.get("id"),
                            "error": {
                                "code": -32603,
                                "message": f"Failed to read function: {disasm.get('error', 'unknown error')}",
                            },
                        })
                        return
                    
                    content = disasm.get("disassembly", "")
                    content_type = "disassembly"
                else:
                    content = pseudo.get("pseudocode", "")
                    content_type = "pseudocode"
                
                # Return resource content
                safe_send({
                    "jsonrpc": "2.0",
                    "id": req.get("id"),
                    "result": {
                        "contents": [
                            {
                                "uri": uri,
                                "mimeType": "text/plain",
                                "text": f"Function: {name} (EA: {hex(ea)})\nType: {content_type}\n\n{content}",
                            }
                        ]
                    },
                })
                return
                
            except (ValueError, IndexError) as e:
                log(f"[ida-mcp] failed to parse URI: {e}")
    
    # Unknown URI format
    safe_send({
        "jsonrpc": "2.0",
        "id": req.get("id"),
        "error": {
            "code": -32602,
            "message": f"Invalid or unsupported URI format: {uri}",
        },
    })


def handle_resources_templates_list(req: dict):
    log("[ida-mcp] resources/templates/list called")
    templates = [
        {
            "id": "ida_function",
            "name": "IDA Function",
            "description": "Reference to a function exported by the IDA database",
            "schema": {
                "type": "object",
                "properties": {
                    "name": {"type": "string", "description": "Function name"},
                    "ea": {"type": "integer", "description": "Starting EA"},
                },
                "required": ["name", "ea"],
            },
        }
    ]
    safe_send(
        {
            "jsonrpc": "2.0",
            "id": req.get("id"),
            "result": {"resourceTemplates": templates},
        }
    )


def main():
    log("===== ida-mcp server started (ascii-safe) =====")
    while True:
        line = sys.stdin.readline()
        if not line:
            time.sleep(0.05)
            continue
        raw = line.rstrip("\n")
        log(f"[ida-mcp] <- MCP stdin raw: {raw}")

        try:
            req = json.loads(raw)
        except Exception:
            log("[ida-mcp] json parse error")
            continue

        method = req.get("method")
        req_id = req.get("id", None)

        # ignore notifications
        if method and method.startswith("notifications/"):
            log(f"[ida-mcp] ignore notification: {method}")
            continue

        try:
            if method == "initialize":
                handle_initialize(req)
            elif method == "tools/list":
                handle_tools_list(req)
            elif method == "tools/call":
                handle_tools_call(req)
            elif method == "resources/list":
                handle_resources_list(req)
            elif method == "resources/read":
                handle_resources_read(req)
            elif method == "resources/templates/list":
                handle_resources_templates_list(req)
            elif method == "ping":
                safe_send({"jsonrpc": "2.0", "id": req_id, "result": {}})
            else:
                # unknown method: only reply if it's a request (has id)
                log(f"[ida-mcp] unknown method: {method}")
                if req_id is not None:
                    safe_send({
                        "jsonrpc": "2.0",
                        "id": req_id,
                        "error": {
                            "code": -32601,
                            "message": f"Method not found: {method}",
                        },
                    })
        except Exception:
            log("[ida-mcp] handler exception:\n" + traceback.format_exc())
            continue


if __name__ == "__main__":
    main()

```