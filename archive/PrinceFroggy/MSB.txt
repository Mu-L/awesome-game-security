Project Path: arc_PrinceFroggy_MSB_txu4gx9g

Source Tree:

```txt
arc_PrinceFroggy_MSB_txu4gx9g
├── A cool launcher
│   ├── A cool launcher.csproj
│   ├── Methods
│   │   ├── Configuration.cs
│   │   ├── Inject.cs
│   │   └── Security.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── Resource.Designer.cs
│   ├── Resource.resx
│   ├── Resources
│   │   └── A cool trainer.dll
│   ├── Settings.Designer.cs
│   ├── Settings.settings
│   ├── app.config
│   └── icon.ico
├── A cool trainer
│   ├── A cool trainer.vcxproj
│   ├── A cool trainer.vcxproj.filters
│   ├── DLLAttach.cpp
│   ├── Form1.cpp
│   ├── Form1.h
│   ├── Form1.resx
│   ├── Form2.cpp
│   ├── Form2.h
│   ├── Form2.resx
│   ├── Form3.cpp
│   ├── Form3.h
│   ├── Form3.resx
│   ├── Hack.cpp
│   ├── Hack.h
│   ├── Macro.cpp
│   ├── Macro.h
│   ├── Packet.cpp
│   └── Packet.h
├── MSB.sln
└── README.md

```

`A cool launcher/A cool launcher.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{83324C8E-BD95-4D15-A725-71C905929C02}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>A_cool_launcher</RootNamespace>
    <AssemblyName>MSB</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>icon.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject />
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Methods\Configuration.cs" />
    <Compile Include="Methods\Inject.cs" />
    <Compile Include="Methods\Security.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Resource.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resource.resx</DependentUpon>
    </Compile>
    <Compile Include="Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Content Include="icon.ico" />
    <None Include="Resources\A cool trainer.dll" />
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
    <None Include="Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Resource.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resource.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`A cool launcher/Methods/Configuration.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;
using Microsoft.Win32;
using System.Windows.Forms;

#region Structures

public struct PROCESS_INFORMATION
{
    public IntPtr hProcess;
    public IntPtr hThread;
    public uint dwProcessId;
    public uint dwThreadId;
}

public struct STARTUPINFO
{
    public uint cb;
    public string lpReserved;
    public string lpDesktop;
    public string lpTitle;
    public uint dwX;
    public uint dwY;
    public uint dwXSize;
    public uint dwYSize;
    public uint dwXCountChars;
    public uint dwYCountChars;
    public uint dwFillAttribute;
    public uint dwFlags;
    public short wShowWindow;
    public short cbReserved2;
    public IntPtr lpReserved2;
    public IntPtr hStdInput;
    public IntPtr hStdOutput;
    public IntPtr hStdError;
}

public struct SECURITY_ATTRIBUTES
{
    public int length;
    public IntPtr lpSecurityDescriptor;
    public bool bInheritHandle;
}

#endregion

namespace A_cool_launcher.Methods
{
    class Configuration
    {
        #region Imports

        [DllImport("kernel32.dll")]
        static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("kernel32.dll")]
        static extern uint ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool TerminateProcess(IntPtr hProcess, uint uExitCode);

        #endregion

        #region Variables

        static RegistryKey MSkey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Wizet\\").OpenSubKey("MapleStory");

        static string MSpath;

        static string DIRname = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) + "\\" + "MSB" + "\\";

        static string DLLname;

        static STARTUPINFO StartupInfo;

        static PROCESS_INFORMATION ProcessInfo;

        #endregion

        public static bool RetrievePath()
        {
            try
            {
                if (MessageBox.Show("Would you like to automatically launch MapleStory?", "Launch", MessageBoxButtons.YesNo) == DialogResult.Yes)
                {
                    if (File.Exists(MSkey.GetValue("ExecPath").ToString() + @"\MapleStory.exe"))
                    {
                        MSpath = MSkey.GetValue("ExecPath").ToString() + @"\MapleStory.exe";

                        MSkey.Close();

                        return true;
                    }
                    else
                    {
                        if (File.Exists(MSkey.GetValue("Executable").ToString()))
                        {
                            MSpath = MSkey.GetValue("Executable").ToString();

                            MSkey.Close();

                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    OpenFileDialog dialog = new OpenFileDialog();

                    if (dialog.ShowDialog() == DialogResult.OK)
                    {
                        MSpath = dialog.FileName;

                        MSkey.Close();

                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
            catch
            {
                return false;
            }
        }

        public static bool CreateProcess()
        {
            try
            {
                StartupInfo = new STARTUPINFO();

                ProcessInfo = new PROCESS_INFORMATION();

                if (CreateProcess(MSpath, " WebStart", IntPtr.Zero, IntPtr.Zero, false, 4, IntPtr.Zero, null, ref StartupInfo, out ProcessInfo))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            catch
            {
                return false;
            }
        }

        public static bool CreateFile()
        {
            try
            {
                if (!Settings.Default.destroy)
                {
                    if (Directory.Exists(DIRname))
                    {
                        Directory.Delete(DIRname, true);

                        Settings.Default.destroy = true;
                        Settings.Default.Save();
                    }
                }

                if (!Directory.Exists(DIRname))
                {
                    Directory.CreateDirectory(DIRname);
                }

                if (File.Exists(Settings.Default.path))
                {
                    File.Delete(Settings.Default.path);
                }

                DLLname = DIRname + ProcessInfo.dwProcessId.ToString();

                File.WriteAllBytes(DLLname + ".dll", Resource.A_cool_trainer);

                Settings.Default.path = DLLname + ".dll";
                Settings.Default.Save();

                return true;
            }
            catch
            {
                TerminateProcess(ProcessInfo.hProcess, 0);

                return false;
            }
        }

        public static bool InjectDll()
        {
            try
            {
                int ProcessID = Convert.ToInt32(ProcessInfo.dwProcessId);

                IntPtr hProcess = (IntPtr)Methods.Inject.OpenProcess(0x1F0FFF, 1, ProcessID);

                if (hProcess != null)
                {
                    Methods.Inject.InjectDLL(hProcess, DLLname);

                    ResumeThread(ProcessInfo.hThread);
                    
                    return true;
                }
                else
                {
                    TerminateProcess(ProcessInfo.hProcess, 0);

                    return false;
                }
            }
            catch
            {
                TerminateProcess(ProcessInfo.hProcess, 0);

                return false;
            }
        }
    }
}
```

`A cool launcher/Methods/Inject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;

namespace A_cool_launcher.Methods
{
    class Inject
    {
        [DllImport("kernel32")]
        public static extern IntPtr CreateRemoteThread(
          IntPtr hProcess,
          IntPtr lpThreadAttributes,
          uint dwStackSize,
          UIntPtr lpStartAddress,
          IntPtr lpParameter,
          uint dwCreationFlags,
          out IntPtr lpThreadId
        );

        [DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(
            UInt32 dwDesiredAccess,
            Int32 bInheritHandle,
            Int32 dwProcessId
            );

        [DllImport("kernel32.dll")]
        public static extern Int32 CloseHandle(
        IntPtr hObject
        );

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern bool VirtualFreeEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            UIntPtr dwSize,
            uint dwFreeType
            );

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true)]
        public static extern UIntPtr GetProcAddress(
            IntPtr hModule,
            string procName
            );

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect
            );

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            string lpBuffer,
            UIntPtr nSize,
            out IntPtr lpNumberOfBytesWritten
        );

        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        public static extern IntPtr GetModuleHandle(
            string lpModuleName
            );

        [DllImport("kernel32", SetLastError = true, ExactSpelling = true)]
        internal static extern Int32 WaitForSingleObject(
            IntPtr handle,
            Int32 milliseconds
            );

        public static Int32 GetProcessId(String proc)
        {
            Process[] ProcList;
            ProcList = Process.GetProcessesByName(proc);
            return ProcList[0].Id;
        }

        private static byte[] CalcBytes(string sToConvert)
        {
            byte[] bRet = System.Text.Encoding.ASCII.GetBytes(sToConvert);
            return bRet;
        }

        public static void InjectDLL(IntPtr hProcess, String strDLLName)
        {
            IntPtr bytesout;
            Int32 LenWrite = strDLLName.Length + 1;
            IntPtr AllocMem = (IntPtr)VirtualAllocEx(hProcess, (IntPtr)null, (uint)LenWrite, 0x1000, 0x40);
            WriteProcessMemory(hProcess, AllocMem, strDLLName, (UIntPtr)LenWrite, out bytesout);
            UIntPtr Injector = (UIntPtr)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
            IntPtr hThread = (IntPtr)CreateRemoteThread(hProcess, (IntPtr)null, 0, Injector, AllocMem, 0, out bytesout);
            int Result = WaitForSingleObject(hThread, 1000);
            Thread.Sleep(1000);
            VirtualFreeEx(hProcess, AllocMem, (UIntPtr)0, 0x8000);
            if (hThread != null)
            {
                CloseHandle(hThread);
            }
            return;
        }
    }
}

```

`A cool launcher/Methods/Security.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Net;
using System.Windows.Forms;

namespace A_cool_launcher.Methods
{
    class Security
    {
        public static bool Version()
        {
            try
            {
                WebRequest request = WebRequest.Create("http://download.m-84.com/version/");
                
                WebResponse response = request.GetResponse();
                
                System.IO.StreamReader reader = new System.IO.StreamReader(response.GetResponseStream());

                string versionNumber = reader.ReadToEnd();

                if (versionNumber == "6\n")
                {
                    return false;
                }
                else
                {
                    MessageBox.Show("Update available at: download.m-84.com", "Update", MessageBoxButtons.OK);
                    
                    return true;
                }
            }
            catch
            {
                return false;
            }
        }

        public static bool Running()
        {
            try
            {
                foreach (Process clsProcess in Process.GetProcesses())
                {
                    if (clsProcess.ProcessName.Contains("MapleStory"))
                    {
                        return true;
                    }
                }
                return false;
            }
            catch
            {
                return false;
            }
        }
    }
}

```

`A cool launcher/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace A_cool_launcher
{
    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            if (!Methods.Security.Version())
                if (!Methods.Security.Running())
                    if (Methods.Configuration.RetrievePath())
                        if (Methods.Configuration.CreateProcess())
                            if (Methods.Configuration.CreateFile())
                                if (Methods.Configuration.InjectDll())
                                    return;
        }
    }
}
```

`A cool launcher/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("A cool launcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("A cool launcher")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2013")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d0a05178-7188-45df-992e-718d7e961bd4")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`A cool launcher/Resource.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace A_cool_launcher {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resource {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resource() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("A_cool_launcher.Resource", typeof(Resource).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] A_cool_trainer {
            get {
                object obj = ResourceManager.GetObject("A_cool_trainer", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

```

`A cool launcher/Resource.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="A_cool_trainer" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\A cool trainer.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`A cool launcher/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace A_cool_launcher {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("")]
        public string path {
            get {
                return ((string)(this["path"]));
            }
            set {
                this["path"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool destroy {
            get {
                return ((bool)(this["destroy"]));
            }
            set {
                this["destroy"] = value;
            }
        }
    }
}

```

`A cool launcher/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)" GeneratedClassNamespace="A_cool_launcher" GeneratedClassName="Settings">
  <Profiles />
  <Settings>
    <Setting Name="path" Type="System.String" Scope="User">
      <Value Profile="(Default)" />
    </Setting>
    <Setting Name="destroy" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">False</Value>
    </Setting>
  </Settings>
</SettingsFile>
```

`A cool launcher/app.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <configSections>
        <sectionGroup name="userSettings" type="System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
            <section name="A_cool_launcher.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false" />
        </sectionGroup>
    </configSections>
    <userSettings>
        <A_cool_launcher.Settings>
            <setting name="path" serializeAs="String">
                <value />
            </setting>
            <setting name="destroy" serializeAs="String">
                <value>False</value>
            </setting>
        </A_cool_launcher.Settings>
    </userSettings>
</configuration>
```

`A cool trainer/A cool trainer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D41B333F-6043-4159-879E-56D1E2297F62}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Acooltrainer</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
    <CLRSupport>false</CLRSupport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <CLRSupport>false</CLRSupport>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>C:\Users\Andrew\Documents\Visual Studio 2010\Installers\boost_1_47_0;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Users\Andrew\Documents\Visual Studio 2010\Installers\boost_1_47_0\stage\lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Users\Andrew\Documents\Visual Studio 2010\Installers\boost_1_47_0;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Users\Andrew\Documents\Visual Studio 2010\Installers\boost_1_47_0\stage\lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;ACOOLTRAINER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;ACOOLTRAINER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DLLAttach.cpp" />
    <ClCompile Include="Form1.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</MinimalRebuild>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Default</BasicRuntimeChecks>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">ProgramDatabase</DebugInformationFormat>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Async</ExceptionHandling>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</MinimalRebuild>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Default</BasicRuntimeChecks>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ProgramDatabase</DebugInformationFormat>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Async</ExceptionHandling>
    </ClCompile>
    <ClCompile Include="Form2.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</MinimalRebuild>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Default</BasicRuntimeChecks>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">ProgramDatabase</DebugInformationFormat>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Async</ExceptionHandling>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</MinimalRebuild>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Default</BasicRuntimeChecks>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ProgramDatabase</DebugInformationFormat>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Async</ExceptionHandling>
    </ClCompile>
    <ClCompile Include="Form3.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</MinimalRebuild>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Default</BasicRuntimeChecks>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">ProgramDatabase</DebugInformationFormat>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Async</ExceptionHandling>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</MinimalRebuild>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Default</BasicRuntimeChecks>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ProgramDatabase</DebugInformationFormat>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Async</ExceptionHandling>
    </ClCompile>
    <ClCompile Include="Hack.cpp" />
    <ClCompile Include="Macro.cpp" />
    <ClCompile Include="Packet.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Form1.h">
      <FileType>CppForm</FileType>
    </ClInclude>
    <ClInclude Include="Form2.h">
      <FileType>CppForm</FileType>
    </ClInclude>
    <ClInclude Include="Form3.h">
      <FileType>CppForm</FileType>
    </ClInclude>
    <ClInclude Include="Hack.h" />
    <ClInclude Include="Macro.h" />
    <ClInclude Include="Packet.h" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.h</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Form2.resx">
      <DependentUpon>Form2.h</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Form3.resx">
      <DependentUpon>Form3.h</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`A cool trainer/A cool trainer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Form1.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Packet.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Macro.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Form2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Form3.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Form1.resx">
      <Filter>Resource Files</Filter>
    </EmbeddedResource>
    <EmbeddedResource Include="Form2.resx">
      <Filter>Resource Files</Filter>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Form1.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DLLAttach.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Packet.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Macro.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Form2.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Form3.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`A cool trainer/DLLAttach.cpp`:

```cpp
#include <windows.h>

extern void Main();

BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
{
	if(fdwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hInstance);
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&Main, NULL, 0, NULL);
	}
	return TRUE;
}
```

`A cool trainer/Form1.cpp`:

```cpp
#include "Form1.h"
#include "Hack.h"
#include "Macro.h"
#include "Packet.h"

using namespace Acooltrainer;

void Main(void)		
{
	initializeKeys();

	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false);
	Application::Run(gcnew Form1);	
	Application::Exit();
}

#pragma region Variables

bool spamPacket = false;
bool buttonSwitch = false;
bool buttonBlock = false;
bool formSwitch = false;
bool packetSwitch = false;
bool packetOpen = false;
bool methodSwitch = false;

#pragma endregion

#pragma region Form Events

void Form1::tabControl1_Selecting(System::Object^  sender, System::Windows::Forms::TabControlCancelEventArgs^  e) 
{
	if (tabControl1->SelectedTab == tabPage1)
	{
		if (_Form2->Visible)
		{
			::MessageBox(0, "Please close the settings dialog.", "Failed to switch tabs.", MB_OK | MB_ICONERROR);

			e->Cancel = true;
		}
		else if (buttonBlock)
		{
			::MessageBox(0, "Please close the information dialog.", "Failed to switch tabs.", MB_OK | MB_ICONERROR);

			e->Cancel = true;
		}
		else
		{
			button2->Text = "Packets";

			toolTip1->SetToolTip(button2, "Open packets dialog.");

			packetSwitch = false;

			Form1::Height = 276;
		}
	}
	else if (tabControl1->SelectedTab == tabPage2)
	{
		if (_Form3->Visible)
		{
			::MessageBox(0, "Please close the packets dialog.", "Failed to switch tabs.", MB_OK | MB_ICONERROR);

			e->Cancel = true;
		}
		else if (buttonBlock)
		{
			::MessageBox(0, "Please close the information dialog.", "Failed to switch tabs.", MB_OK | MB_ICONERROR);

			e->Cancel = true;
		}
		else
		{
			button2->Text = "Settings";

			toolTip1->SetToolTip(button2, "Open settings dialog.");

			packetSwitch = true;

			buttonSwitch = false;

			Form1::Height = 276;
		}
	}
	else
	{
		if (_Form3->Visible)
		{
			::MessageBox(0, "Please close the packets dialog.", "Failed to switch tabs.", MB_OK | MB_ICONERROR);

			e->Cancel = true;
		}
		else if (_Form2->Visible)
		{
			::MessageBox(0, "Please close the settings dialog.", "Failed to switch tabs.", MB_OK | MB_ICONERROR);

			e->Cancel = true;
		}
		else
		{
			button2->Text = "Information";

			toolTip1->SetToolTip(button2, "Open information dialog.");

			packetSwitch = true;

			buttonSwitch = true;

			Form1::Height = 276;
		}
	}
}

void Form1::button2_Click(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = tabControl1->SelectedTab;

	if (!packetSwitch)
	{
		if (CheckSpam())
		{
			::MessageBox(0, "Please disable the packet spam.", "Failed to close packets dialog.", MB_OK | MB_ICONERROR);
		}
		else
		{
			if (packetOpen)
			{
				_Form3->Visible = false;

				toolTip1->SetToolTip(button2, "Open packets dialog.");

				packetOpen = false;
			}
			else
			{
				_Form3->Visible = true;

				toolTip1->SetToolTip(button2, "Close packets dialog.");

				packetOpen = true;
			}
		}
	}
	else
	{
		if (buttonSwitch)
		{
			buttonBlock = true;

			::MessageBox(0, "download.m-84.com", "Information", MB_OK | MB_ICONASTERISK);
		
			buttonBlock = false;
		}
		else
		{
			if (listView2->Items[0]->Checked || listView2->Items[1]->Checked || listView2->Items[2]->Checked || listView2->Items[3]->Checked || listView2->Items[4]->Checked || listView2->Items[5]->Checked)
			{
				::MessageBox(0, "Please disable the macro(s).", "Failed to initiate settings dialog.", MB_OK | MB_ICONERROR);
			}
			else
			{
				if (formSwitch)
				{
					_Form2->Visible = false;

					toolTip1->SetToolTip(button2, "Open settings dialog.");

					formSwitch = false;
				}
				else
				{
					_Form2->Visible = true;

					toolTip1->SetToolTip(button2, "Close settings dialog.");

					formSwitch = true;
				}
			}
		}
	}
}

void Form1::listView1_ItemCheck(System::Object^  sender, System::Windows::Forms::ItemCheckEventArgs^  e)
{
	if (e->CurrentValue == CheckState::Unchecked)
	{
		switch (e->Index)
		{
		case 0:
			ToggleKami(true);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

			ShowMessage("[MSB] Kami enabled.", Special_BlackWhite);
			break;

		case 1:
			ToggleGodmode(true);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

			ShowMessage("[MSB] Godmode enabled.", Special_BlackWhite);
			break;

		case 2:
			ToggleFusionAttack(true);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

			ShowMessage("[MSB] Fusion attack enabled.", Special_BlackWhite);
			break;

		case 3:
			ToggleItemFilter(true);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

			button1->Enabled = false;

			listView3->ContextMenuStrip = nullptr;

			ShowMessage("[MSB] Item filter enabled.", Special_BlackWhite);
			break;

		case 4:
			ToggleCPUHack(true);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

			ShowMessage("[MSB] Background filter enabled.", Special_BlackWhite);
			break;

		case 5:
			ToggleGND(true);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

			ShowMessage("[MSB] GND & Unlimited MP enabled.", Special_BlackWhite);
			break;
		}
	}
	else if (e->CurrentValue == CheckState::Checked)
	{
		switch (e->Index)
		{
		case 0:
			ToggleKami(false);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);

			ShowMessage("[MSB] Kami disabled.", Special_BlackWhite);
			break;

		case 1:
			ToggleGodmode(false);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);

			ShowMessage("[MSB] Godmode disabled.", Special_BlackWhite);
			break;

		case 2:
			ToggleFusionAttack(false);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);

			ShowMessage("[MSB] Fusion attack disabled.", Special_BlackWhite);
			break;

		case 3:
			ToggleItemFilter(false);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);

			button1->Enabled = true;

			listView3->ContextMenuStrip = contextMenuStrip1;

			ShowMessage("[MSB] Item filter disabled.", Special_BlackWhite);
			break;

		case 4:
			ToggleCPUHack(false);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);

			ShowMessage("[MSB] Background filter disabled.", Special_BlackWhite);
			break;

		case 5:
			ToggleGND(false);

			listView1->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);

			ShowMessage("[MSB] GND & Unlimited MP disabled.", Special_BlackWhite);
			break;
		}
	}
}

void Form1::listView2_ItemCheck(System::Object^  sender, System::Windows::Forms::ItemCheckEventArgs^  e)
{
	if (formSwitch)
	{
		::MessageBox(0, "Please close the settings dialog.", "Failed to initiate macro.", MB_OK | MB_ICONERROR);

		e->NewValue = CheckState::Unchecked;
	}
	else
	{
		if (CheckMethod(e->Index))
		{
			if (e->CurrentValue == CheckState::Unchecked)
			{
				switch (e->Index)
				{
				case 0:
					Attack(true);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);

					ShowMessage("[MSB] Automated attack enabled.", Blue);
					break;

				case 1:
					Loot(true);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);
			
					ShowMessage("[MSB] Automated loot enabled.", Blue);
					break;

				case 2:
					Health(true);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);
			
					ShowMessage("[MSB] Automated health enabled.", Blue);
					break;

				case 3:
					Mana(true);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);
			
					ShowMessage("[MSB] Automated mana enabled.", Blue);
					break;

				case 4:
					BlockRecv(true);

					Channel(true);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);
			
					ShowMessage("[MSB] Automated channel enabled.", Blue);
					break;

				case 5:
					Skill(true);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Bold);
			
					ShowMessage("[MSB] Automated skill enabled.", Blue);
					break;
				}
			}
			else if (e->CurrentValue == CheckState::Checked)
			{
				switch (e->Index)
				{
				case 0:
					Attack(false);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);
			
					ShowMessage("[MSB] Automated attack disabled.", Blue);
					break;

				case 1:
					Loot(false);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);
			
					ShowMessage("[MSB] Automated loot disabled.", Blue);
					break;

				case 2:
					Health(false);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);
			
					ShowMessage("[MSB] Automated health disabled.", Blue);
					break;

				case 3:
					Mana(false);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);
			
					ShowMessage("[MSB] Automated mana disabled.", Blue);
					break;

				case 4:
					BlockRecv(false);

					Channel(false);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);
			
					ShowMessage("[MSB] Automated channel disabled.", Blue);
					break;

				case 5:
					Skill(false);

					listView2->Items[e->Index]->SubItems[0]->Font = gcnew System::Drawing::Font("Consolas", 8, System::Drawing::FontStyle::Regular);
			
					ShowMessage("[MSB] Automated skill disabled.", Blue);
					break;
				}
			}
		}
		else
		{
			::MessageBox(0, "Please assign all the values to the macro.", "Failed to initiate macro.", MB_OK | MB_ICONERROR);

			e->NewValue = CheckState::Unchecked;
		}
	}
}

void Form1::button1_Click(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = tabControl1->SelectedTab;

	if (textBox1->Text->Length == 0)
	{
		::MessageBox(0, "Please enter a item.", "Failed to add item.", MB_OK | MB_ICONERROR);
	}
	else
	{
		ListViewItem^ item = gcnew ListViewItem();
		item->SubItems->Add(textBox1->Text);
		listView3->Items->Add(item);
		AddItemToBlacklist(Convert::ToUInt32(textBox1->Text, 10));

		listView3->Cursor = Cursors::Hand;
		listView3->ContextMenuStrip = contextMenuStrip1;
	}
}

void Form1::removeToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = tabControl1->SelectedTab;

	if (listView3->SelectedItems->Count == 0)
	{
		::MessageBox(0, "Please select data.", "Failed to remove data.", MB_OK | MB_ICONERROR);
	}
	else
	{
		for (int i = 0; i < listView3->Items->Count; i++ )
		{
			if (listView3->Items[i]->Selected)
			{
				RemoveItemFromBlacklist(i);
				listView3->Items[i]->Remove();
				--i;
			}
		}

		if (listView3->Items->Count == 0)
		{
			listView3->Cursor = Cursors::Default;
			listView3->ContextMenuStrip = nullptr;
		}
	}
}

void Form1::clearToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e) 
{
	ActiveControl = tabControl1->SelectedTab;

	if (listView3->Items->Count == 0)
	{
		::MessageBox(0, "Please insert data.", "Failed to clear data.", MB_OK | MB_ICONERROR);
	}
	else
	{
		ClearBlacklist();
		listView3->Items->Clear();
		listView3->Refresh();

		listView3->Cursor = Cursors::Default;
		listView3->ContextMenuStrip = nullptr;
	}
}

#pragma endregion
```

`A cool trainer/Form1.h`:

```h
#pragma once
#include "Form2.h"
#include "Form3.h"
#include <windows.h>
#include <commctrl.h>

namespace Acooltrainer {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	/// <summary>
	/// Summary for Form1
	/// </summary>
	public ref class Form1 : public System::Windows::Forms::Form
	{
	public:
		Form2^ _Form2;
		Form3^ _Form3;

		Form1(void)
		{
			InitializeComponent();
			
			_Form2 = gcnew Form2;
			_Form3 = gcnew Form3;

			ActiveControl = tabControl1->SelectedTab;

			SendMessage((HWND)textBox1->Handle.ToPointer(), EM_SETCUEBANNER, (WPARAM)FALSE, (LPARAM)L"Item...");

			button2->Text = "Packets";

			toolTip1->SetToolTip(button2, "Open packets dialog.");
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		virtual void WndProc(Message% m) override 
		{
			__super::WndProc(m);
			if (m.Msg == WM_NCHITTEST) 
			{
				switch ((int)m.Result) 
				{
				case HTLEFT: 
				case HTRIGHT: 
				case HTTOP: 
                case HTTOPLEFT: 
				case HTTOPRIGHT:
                case HTBOTTOMLEFT: 
				case HTBOTTOMRIGHT:
					m.Result = (IntPtr)HTCLIENT;
				}
			}
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~Form1()
		{
			if (components)
			{
				delete components;
			}
		}

	protected: 
	private: System::Windows::Forms::TabPage^  tabPage2;
	private: System::Windows::Forms::TabPage^  tabPage1;
	private: System::Windows::Forms::TabControl^  tabControl1;
	private: System::Windows::Forms::ListView^  listView1;
	private: System::Windows::Forms::ColumnHeader^  columnHeader1;
	private: System::Windows::Forms::ColumnHeader^  columnHeader2;





	private: System::Windows::Forms::TabPage^  tabPage3;
	private: System::Windows::Forms::ListView^  listView2;
	private: System::Windows::Forms::ColumnHeader^  columnHeader3;
	private: System::Windows::Forms::ColumnHeader^  columnHeader4;
	private: System::Windows::Forms::TextBox^  textBox1;

	private: System::Windows::Forms::ListView^  listView3;
	private: System::Windows::Forms::ColumnHeader^  columnHeader5;

	private: System::Windows::Forms::Button^  button1;

	private: System::Windows::Forms::ColumnHeader^  columnHeader6;
	private: System::Windows::Forms::ContextMenuStrip^  contextMenuStrip1;


	private: System::Windows::Forms::ToolStripMenuItem^  removeToolStripMenuItem;
	private: System::Windows::Forms::ToolStripMenuItem^  clearToolStripMenuItem;
	private: System::Windows::Forms::Button^  button2;


	private: System::Windows::Forms::ToolTip^  toolTip1;








	private: System::ComponentModel::IContainer^  components;



	protected: 






	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			this->components = (gcnew System::ComponentModel::Container());
			System::Windows::Forms::ListViewGroup^  listViewGroup1 = (gcnew System::Windows::Forms::ListViewGroup(L"General", System::Windows::Forms::HorizontalAlignment::Center));
			System::Windows::Forms::ListViewGroup^  listViewGroup2 = (gcnew System::Windows::Forms::ListViewGroup(L"Anti-Detection", System::Windows::Forms::HorizontalAlignment::Center));
			System::Windows::Forms::ListViewItem^  listViewItem1 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Automated attack"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem2 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Automated loot"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem3 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Automated health"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem4 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Automated mana"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem5 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Automated channel"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem6 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Automated skill"}, -1));
			System::Windows::Forms::ListViewGroup^  listViewGroup3 = (gcnew System::Windows::Forms::ListViewGroup(L"Monster", System::Windows::Forms::HorizontalAlignment::Center));
			System::Windows::Forms::ListViewGroup^  listViewGroup4 = (gcnew System::Windows::Forms::ListViewGroup(L"Player", System::Windows::Forms::HorizontalAlignment::Center));
			System::Windows::Forms::ListViewGroup^  listViewGroup5 = (gcnew System::Windows::Forms::ListViewGroup(L"Map", System::Windows::Forms::HorizontalAlignment::Center));
			System::Windows::Forms::ListViewItem^  listViewItem7 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Kami"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem8 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Godmode"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem9 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Fusion attack"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem10 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Item filter"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem11 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"Background filter"}, -1));
			System::Windows::Forms::ListViewItem^  listViewItem12 = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^  >(2) {L"", 
				L"GND & Unlimited MP"}, -1));
			System::ComponentModel::ComponentResourceManager^  resources = (gcnew System::ComponentModel::ComponentResourceManager(Form1::typeid));
			this->tabPage2 = (gcnew System::Windows::Forms::TabPage());
			this->listView2 = (gcnew System::Windows::Forms::ListView());
			this->columnHeader3 = (gcnew System::Windows::Forms::ColumnHeader());
			this->columnHeader4 = (gcnew System::Windows::Forms::ColumnHeader());
			this->tabPage1 = (gcnew System::Windows::Forms::TabPage());
			this->listView1 = (gcnew System::Windows::Forms::ListView());
			this->columnHeader1 = (gcnew System::Windows::Forms::ColumnHeader());
			this->columnHeader2 = (gcnew System::Windows::Forms::ColumnHeader());
			this->tabControl1 = (gcnew System::Windows::Forms::TabControl());
			this->tabPage3 = (gcnew System::Windows::Forms::TabPage());
			this->textBox1 = (gcnew System::Windows::Forms::TextBox());
			this->button1 = (gcnew System::Windows::Forms::Button());
			this->listView3 = (gcnew System::Windows::Forms::ListView());
			this->columnHeader5 = (gcnew System::Windows::Forms::ColumnHeader());
			this->columnHeader6 = (gcnew System::Windows::Forms::ColumnHeader());
			this->contextMenuStrip1 = (gcnew System::Windows::Forms::ContextMenuStrip(this->components));
			this->removeToolStripMenuItem = (gcnew System::Windows::Forms::ToolStripMenuItem());
			this->clearToolStripMenuItem = (gcnew System::Windows::Forms::ToolStripMenuItem());
			this->button2 = (gcnew System::Windows::Forms::Button());
			this->toolTip1 = (gcnew System::Windows::Forms::ToolTip(this->components));
			this->tabPage2->SuspendLayout();
			this->tabPage1->SuspendLayout();
			this->tabControl1->SuspendLayout();
			this->tabPage3->SuspendLayout();
			this->contextMenuStrip1->SuspendLayout();
			this->SuspendLayout();
			// 
			// tabPage2
			// 
			this->tabPage2->Controls->Add(this->listView2);
			this->tabPage2->Cursor = System::Windows::Forms::Cursors::Default;
			this->tabPage2->Location = System::Drawing::Point(4, 19);
			this->tabPage2->Name = L"tabPage2";
			this->tabPage2->Padding = System::Windows::Forms::Padding(3);
			this->tabPage2->Size = System::Drawing::Size(161, 201);
			this->tabPage2->TabIndex = 1;
			this->tabPage2->Text = L"Macro";
			this->tabPage2->UseVisualStyleBackColor = true;
			// 
			// listView2
			// 
			this->listView2->BorderStyle = System::Windows::Forms::BorderStyle::None;
			this->listView2->CheckBoxes = true;
			this->listView2->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(2) {this->columnHeader3, this->columnHeader4});
			this->listView2->Cursor = System::Windows::Forms::Cursors::Hand;
			listViewGroup1->Header = L"General";
			listViewGroup1->HeaderAlignment = System::Windows::Forms::HorizontalAlignment::Center;
			listViewGroup1->Name = L"listViewGroup1";
			listViewGroup2->Header = L"Anti-Detection";
			listViewGroup2->HeaderAlignment = System::Windows::Forms::HorizontalAlignment::Center;
			listViewGroup2->Name = L"listViewGroup2";
			this->listView2->Groups->AddRange(gcnew cli::array< System::Windows::Forms::ListViewGroup^  >(2) {listViewGroup1, listViewGroup2});
			this->listView2->HeaderStyle = System::Windows::Forms::ColumnHeaderStyle::None;
			listViewItem1->Group = listViewGroup1;
			listViewItem1->StateImageIndex = 0;
			listViewItem2->Group = listViewGroup1;
			listViewItem2->StateImageIndex = 0;
			listViewItem3->Group = listViewGroup1;
			listViewItem3->StateImageIndex = 0;
			listViewItem4->Group = listViewGroup1;
			listViewItem4->StateImageIndex = 0;
			listViewItem5->Group = listViewGroup2;
			listViewItem5->StateImageIndex = 0;
			listViewItem6->Group = listViewGroup1;
			listViewItem6->StateImageIndex = 0;
			this->listView2->Items->AddRange(gcnew cli::array< System::Windows::Forms::ListViewItem^  >(6) {listViewItem1, listViewItem2, 
				listViewItem3, listViewItem4, listViewItem5, listViewItem6});
			this->listView2->Location = System::Drawing::Point(6, 6);
			this->listView2->Name = L"listView2";
			this->listView2->Scrollable = false;
			this->listView2->Size = System::Drawing::Size(149, 179);
			this->listView2->TabIndex = 0;
			this->listView2->UseCompatibleStateImageBehavior = false;
			this->listView2->View = System::Windows::Forms::View::Details;
			this->listView2->ItemCheck += gcnew System::Windows::Forms::ItemCheckEventHandler(this, &Form1::listView2_ItemCheck);
			// 
			// columnHeader3
			// 
			this->columnHeader3->Width = 19;
			// 
			// columnHeader4
			// 
			this->columnHeader4->Width = 130;
			// 
			// tabPage1
			// 
			this->tabPage1->Controls->Add(this->listView1);
			this->tabPage1->Cursor = System::Windows::Forms::Cursors::Default;
			this->tabPage1->Location = System::Drawing::Point(4, 19);
			this->tabPage1->Name = L"tabPage1";
			this->tabPage1->Padding = System::Windows::Forms::Padding(3);
			this->tabPage1->Size = System::Drawing::Size(161, 191);
			this->tabPage1->TabIndex = 0;
			this->tabPage1->Text = L"Cheat";
			this->tabPage1->UseVisualStyleBackColor = true;
			// 
			// listView1
			// 
			this->listView1->BorderStyle = System::Windows::Forms::BorderStyle::None;
			this->listView1->CheckBoxes = true;
			this->listView1->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(2) {this->columnHeader1, this->columnHeader2});
			this->listView1->Cursor = System::Windows::Forms::Cursors::Hand;
			listViewGroup3->Header = L"Monster";
			listViewGroup3->HeaderAlignment = System::Windows::Forms::HorizontalAlignment::Center;
			listViewGroup3->Name = L"listViewGroup1";
			listViewGroup4->Header = L"Player";
			listViewGroup4->HeaderAlignment = System::Windows::Forms::HorizontalAlignment::Center;
			listViewGroup4->Name = L"listViewGroup2";
			listViewGroup5->Header = L"Map";
			listViewGroup5->HeaderAlignment = System::Windows::Forms::HorizontalAlignment::Center;
			listViewGroup5->Name = L"listViewGroup3";
			this->listView1->Groups->AddRange(gcnew cli::array< System::Windows::Forms::ListViewGroup^  >(3) {listViewGroup3, listViewGroup4, 
				listViewGroup5});
			this->listView1->HeaderStyle = System::Windows::Forms::ColumnHeaderStyle::None;
			listViewItem7->Group = listViewGroup3;
			listViewItem7->StateImageIndex = 0;
			listViewItem7->Tag = L"";
			listViewItem8->Group = listViewGroup4;
			listViewItem8->StateImageIndex = 0;
			listViewItem8->Tag = L"";
			listViewItem9->Group = listViewGroup4;
			listViewItem9->StateImageIndex = 0;
			listViewItem9->Tag = L"";
			listViewItem10->Group = listViewGroup5;
			listViewItem10->StateImageIndex = 0;
			listViewItem10->Tag = L"";
			listViewItem11->Group = listViewGroup5;
			listViewItem11->StateImageIndex = 0;
			listViewItem12->Group = listViewGroup4;
			listViewItem12->StateImageIndex = 0;
			this->listView1->Items->AddRange(gcnew cli::array< System::Windows::Forms::ListViewItem^  >(6) {listViewItem7, listViewItem8, 
				listViewItem9, listViewItem10, listViewItem11, listViewItem12});
			this->listView1->Location = System::Drawing::Point(6, 6);
			this->listView1->MultiSelect = false;
			this->listView1->Name = L"listView1";
			this->listView1->Scrollable = false;
			this->listView1->Size = System::Drawing::Size(149, 179);
			this->listView1->TabIndex = 0;
			this->listView1->TabStop = false;
			this->listView1->UseCompatibleStateImageBehavior = false;
			this->listView1->View = System::Windows::Forms::View::Details;
			this->listView1->ItemCheck += gcnew System::Windows::Forms::ItemCheckEventHandler(this, &Form1::listView1_ItemCheck);
			// 
			// columnHeader1
			// 
			this->columnHeader1->Width = 19;
			// 
			// columnHeader2
			// 
			this->columnHeader2->Width = 130;
			// 
			// tabControl1
			// 
			this->tabControl1->Controls->Add(this->tabPage1);
			this->tabControl1->Controls->Add(this->tabPage2);
			this->tabControl1->Controls->Add(this->tabPage3);
			this->tabControl1->Cursor = System::Windows::Forms::Cursors::Hand;
			this->tabControl1->ItemSize = System::Drawing::Size(55, 15);
			this->tabControl1->Location = System::Drawing::Point(12, 12);
			this->tabControl1->Name = L"tabControl1";
			this->tabControl1->Padding = System::Drawing::Point(9, 3);
			this->tabControl1->SelectedIndex = 0;
			this->tabControl1->Size = System::Drawing::Size(169, 214);
			this->tabControl1->SizeMode = System::Windows::Forms::TabSizeMode::Fixed;
			this->tabControl1->TabIndex = 0;
			this->tabControl1->TabStop = false;
			this->tabControl1->Selecting += gcnew System::Windows::Forms::TabControlCancelEventHandler(this, &Form1::tabControl1_Selecting);
			this->tabControl1->Enter += gcnew System::EventHandler(this, &Form1::tabControl1_Enter);
			this->tabControl1->MouseDown += gcnew System::Windows::Forms::MouseEventHandler(this, &Form1::tabControl1_MouseDown);
			// 
			// tabPage3
			// 
			this->tabPage3->Controls->Add(this->textBox1);
			this->tabPage3->Controls->Add(this->button1);
			this->tabPage3->Controls->Add(this->listView3);
			this->tabPage3->Location = System::Drawing::Point(4, 19);
			this->tabPage3->Name = L"tabPage3";
			this->tabPage3->Size = System::Drawing::Size(161, 201);
			this->tabPage3->TabIndex = 2;
			this->tabPage3->Text = L"Sift";
			this->tabPage3->UseVisualStyleBackColor = true;
			// 
			// textBox1
			// 
			this->textBox1->Location = System::Drawing::Point(10, 163);
			this->textBox1->Name = L"textBox1";
			this->textBox1->Size = System::Drawing::Size(120, 20);
			this->textBox1->TabIndex = 1;
			this->textBox1->TabStop = false;
			this->textBox1->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->toolTip1->SetToolTip(this->textBox1, L"Enter item here.");
			this->textBox1->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &Form1::textBox1_KeyPress);
			// 
			// button1
			// 
			this->button1->Image = (cli::safe_cast<System::Drawing::Image^  >(resources->GetObject(L"button1.Image")));
			this->button1->Location = System::Drawing::Point(136, 163);
			this->button1->Name = L"button1";
			this->button1->Size = System::Drawing::Size(20, 20);
			this->button1->TabIndex = 2;
			this->button1->TabStop = false;
			this->toolTip1->SetToolTip(this->button1, L"Add item.");
			this->button1->UseVisualStyleBackColor = true;
			this->button1->Click += gcnew System::EventHandler(this, &Form1::button1_Click);
			// 
			// listView3
			// 
			this->listView3->AutoArrange = false;
			this->listView3->BorderStyle = System::Windows::Forms::BorderStyle::None;
			this->listView3->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(2) {this->columnHeader5, this->columnHeader6});
			this->listView3->Cursor = System::Windows::Forms::Cursors::Default;
			this->listView3->FullRowSelect = true;
			this->listView3->GridLines = true;
			this->listView3->HeaderStyle = System::Windows::Forms::ColumnHeaderStyle::None;
			this->listView3->HideSelection = false;
			this->listView3->LabelWrap = false;
			this->listView3->Location = System::Drawing::Point(5, 7);
			this->listView3->Name = L"listView3";
			this->listView3->ShowGroups = false;
			this->listView3->Size = System::Drawing::Size(149, 150);
			this->listView3->TabIndex = 0;
			this->listView3->TabStop = false;
			this->toolTip1->SetToolTip(this->listView3, L"Item list.");
			this->listView3->UseCompatibleStateImageBehavior = false;
			this->listView3->View = System::Windows::Forms::View::Details;
			// 
			// columnHeader5
			// 
			this->columnHeader5->Width = 1;
			// 
			// columnHeader6
			// 
			this->columnHeader6->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->columnHeader6->Width = 129;
			// 
			// contextMenuStrip1
			// 
			this->contextMenuStrip1->Items->AddRange(gcnew cli::array< System::Windows::Forms::ToolStripItem^  >(2) {this->removeToolStripMenuItem, 
				this->clearToolStripMenuItem});
			this->contextMenuStrip1->Name = L"contextMenuStrip2";
			this->contextMenuStrip1->Size = System::Drawing::Size(118, 48);
			// 
			// removeToolStripMenuItem
			// 
			this->removeToolStripMenuItem->Name = L"removeToolStripMenuItem";
			this->removeToolStripMenuItem->Size = System::Drawing::Size(117, 22);
			this->removeToolStripMenuItem->Text = L"Remove";
			this->removeToolStripMenuItem->Click += gcnew System::EventHandler(this, &Form1::removeToolStripMenuItem_Click);
			// 
			// clearToolStripMenuItem
			// 
			this->clearToolStripMenuItem->Name = L"clearToolStripMenuItem";
			this->clearToolStripMenuItem->Size = System::Drawing::Size(117, 22);
			this->clearToolStripMenuItem->Text = L"Clear";
			this->clearToolStripMenuItem->Click += gcnew System::EventHandler(this, &Form1::clearToolStripMenuItem_Click);
			// 
			// button2
			// 
			this->button2->Cursor = System::Windows::Forms::Cursors::Hand;
			this->button2->Location = System::Drawing::Point(12, 241);
			this->button2->Name = L"button2";
			this->button2->Size = System::Drawing::Size(169, 20);
			this->button2->TabIndex = 2;
			this->button2->UseVisualStyleBackColor = true;
			this->button2->Click += gcnew System::EventHandler(this, &Form1::button2_Click);
			// 
			// Form1
			// 
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::None;
			this->ClientSize = System::Drawing::Size(193, 238);
			this->ControlBox = false;
			this->Controls->Add(this->button2);
			this->Controls->Add(this->tabControl1);
			this->Font = (gcnew System::Drawing::Font(L"Consolas", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point, 
				static_cast<System::Byte>(0)));
			this->MaximizeBox = false;
			this->MaximumSize = System::Drawing::Size(209, 314);
			this->MinimizeBox = false;
			this->MinimumSize = System::Drawing::Size(209, 276);
			this->Name = L"Form1";
			this->Opacity = 0.9;
			this->ShowIcon = false;
			this->ShowInTaskbar = false;
			this->StartPosition = System::Windows::Forms::FormStartPosition::CenterScreen;
			this->Text = L"MSB";
			this->tabPage2->ResumeLayout(false);
			this->tabPage1->ResumeLayout(false);
			this->tabControl1->ResumeLayout(false);
			this->tabPage3->ResumeLayout(false);
			this->tabPage3->PerformLayout();
			this->contextMenuStrip1->ResumeLayout(false);
			this->ResumeLayout(false);

		}
#pragma endregion
private: System::Void tabControl1_Selecting(System::Object^  sender, System::Windows::Forms::TabControlCancelEventArgs^  e);
private: System::Void tabControl1_MouseDown(System::Object^  sender, System::Windows::Forms::MouseEventArgs^  e)
		 {
			 ActiveControl = tabControl1->SelectedTab; 
		 }
private: System::Void tabControl1_Enter(System::Object^  sender, System::EventArgs^  e)
		 {
			 ActiveControl = tabControl1->SelectedTab;
		 }
private: System::Void listView1_ItemCheck(System::Object^  sender, System::Windows::Forms::ItemCheckEventArgs^  e);
private: System::Void listView2_ItemCheck(System::Object^  sender, System::Windows::Forms::ItemCheckEventArgs^  e);
private: System::Void button2_Click(System::Object^  sender, System::EventArgs^  e);
private: System::Void textBox1_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) 
		 {
			 if(!Char::IsDigit(e->KeyChar) && e->KeyChar != 0x08)
				 e->Handled = true;
		 }
private: System::Void button1_Click(System::Object^  sender, System::EventArgs^  e);
private: System::Void removeToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e);
private: System::Void clearToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e);
};
}

```

`A cool trainer/Form1.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="toolTip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>160, 18</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="button1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADrwAAA68AZW8ckkAAACaSURBVChTY2BAB+UM/xlAGC8oZvj///8ZMGYAsnGrzWP4
        H3/T/n8CEDPkY1OYARSE4qDz5v+DzpvB+WBxMEhEWOd0VPu/01EdMHYEYrgzgGoYGKIY/hvuVIBiRUz2
        LsX/IDUQU4OBDChWXCf2X3G9KJwPFscAvgz/hZfx/BdeyvOfAcjG7WsPhv9c89nAmMGdUFi6ABWAMBoA
        AEalaixzgQypAAAAAElFTkSuQmCC
</value>
  </data>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>11, 17</value>
  </metadata>
</root>
```

`A cool trainer/Form2.cpp`:

```cpp
#include "Form2.h"
#include "Macro.h"

using namespace Acooltrainer;

#pragma region Variables

int nTemp;
int nIndex;

#pragma endregion

#pragma region Functions

void GetKey()
{
	switch(nIndex)
	{
	case 0:
		nTemp = 0x30;
		break;
	case 1:
		nTemp = 0x31;
		break;
	case 2:
		nTemp = 0x32;
		break;
	case 3:
		nTemp = 0x33;
		break;
	case 4:
		nTemp = 0x34;
		break;
	case 5:
		nTemp = 0x35;
		break;
	case 6:
		nTemp = 0x36;
		break;
	case 7:
		nTemp = 0x37;
		break;
	case 8:
		nTemp = 0x38;
		break;
	case 9:
		nTemp = 0x39;
		break;
	case 10:
		nTemp = 0x41;
		break;
	case 11:
		nTemp = 0x42;
		break;
	case 12:
		nTemp = 0x43;
		break;
	case 13:
		nTemp = 0x44;
		break;
	case 14:
		nTemp = 0x45;
		break;
	case 15:
		nTemp = 0x46;
		break;
	case 16:
		nTemp = 0x47;
		break;
	case 17:
		nTemp = 0x48;
		break;
	case 18:
		nTemp = 0x49;
		break;
	case 19:
		nTemp = 0x4A;
		break;
	case 20:
		nTemp = 0x4B;
		break;
	case 21:
		nTemp = 0x4C;
		break;
	case 22:
		nTemp = 0x4D;
		break;
	case 23:
		nTemp = 0x4E;
		break;
	case 24:
		nTemp = 0x4F;
		break;
	case 25:
		nTemp = 0x50;
		break;
	case 26:
		nTemp = 0x51;
		break;
	case 27:
		nTemp = 0x52;
		break;
	case 28:
		nTemp = 0x53;
		break;
	case 29:
		nTemp = 0x54;
		break;
	case 30:
		nTemp = 0x55;
		break;
	case 31:
		nTemp = 0x56;
		break;
	case 32:
		nTemp = 0x57;
		break;
	case 33:
		nTemp = 0x58;
		break;
	case 34:
		nTemp = 0x59;
		break;
	case 35:
		nTemp = 0x5A;
		break;
	case 36:
		nTemp = 0x10;
		break;
	case 37:
		nTemp = 0x11;
		break;
	case 38:
		nTemp = 0x12;
		break;
	case 39:
		nTemp = 0x21;
		break;
	case 40:
		nTemp = 0x22;
		break;
	case 41:
		nTemp = 0x23;
		break;
	case 42:
		nTemp = 0x24;
		break;
	case 43:
		nTemp = 0x2D;
		break;
	case 44:
		nTemp = 0x2E;
	}
	KeyAvailable(nTemp);
}

#pragma endregion

#pragma region Form Events

void Form2::comboBox1_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = groupBox1;

	ClearKey(0);

	nIndex = comboBox1->SelectedIndex;
	
	GetKey();
	
	if (KeyAvailable(nTemp))
	{
		AssignKey(0, nTemp);
	}
	else
	{
		::MessageBox(0, "Key is already assigned.", "Failed to assign key.", MB_OK | MB_ICONERROR);

		comboBox1->SelectedIndexChanged -= gcnew System::EventHandler(this, &Form2::comboBox1_SelectedIndexChanged);

		comboBox1->SelectedIndex = -1;

		comboBox1->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox1_SelectedIndexChanged);
	}
}

void Form2::comboBox2_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = groupBox1;

	ClearKey(1);

	nIndex = comboBox2->SelectedIndex;
	
	GetKey();
	
	if (KeyAvailable(nTemp))
	{
		AssignKey(1, nTemp);
	}
	else
	{
		::MessageBox(0, "Key is already assigned.", "Failed to assign key.", MB_OK | MB_ICONERROR);

		comboBox2->SelectedIndexChanged -= gcnew System::EventHandler(this, &Form2::comboBox2_SelectedIndexChanged);

		comboBox2->SelectedIndex = -1;

		comboBox2->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox2_SelectedIndexChanged);
	}
}

void Form2::comboBox3_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = groupBox1;

	ClearKey(2);

	nIndex = comboBox3->SelectedIndex;
	
	GetKey();
	
	if (KeyAvailable(nTemp))
	{
		AssignKey(2, nTemp);
	}
	else
	{
		::MessageBox(0, "Key is already assigned.", "Failed to assign key.", MB_OK | MB_ICONERROR);

		comboBox3->SelectedIndexChanged -= gcnew System::EventHandler(this, &Form2::comboBox3_SelectedIndexChanged);

		comboBox3->SelectedIndex = -1;

		comboBox3->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox3_SelectedIndexChanged);
	}
}

void Form2::comboBox4_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = groupBox1;

	ClearKey(3);

	nIndex = comboBox4->SelectedIndex;
	
	GetKey();
	
	if (KeyAvailable(nTemp))
	{
		AssignKey(3, nTemp);
	}
	else
	{
		::MessageBox(0, "Key is already assigned.", "Failed to assign key.", MB_OK | MB_ICONERROR);

		comboBox4->SelectedIndexChanged -= gcnew System::EventHandler(this, &Form2::comboBox4_SelectedIndexChanged);

		comboBox4->SelectedIndex = -1;

		comboBox4->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox4_SelectedIndexChanged);
	}
}

void Form2::comboBox5_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = groupBox1;

	ClearKey(4);

	nIndex = comboBox5->SelectedIndex;
	
	GetKey();
	
	if (KeyAvailable(nTemp))
	{
		AssignKey(4, nTemp);
	}
	else
	{
		::MessageBox(0, "Key is already assigned.", "Failed to assign key.", MB_OK | MB_ICONERROR);

		comboBox5->SelectedIndexChanged -= gcnew System::EventHandler(this, &Form2::comboBox5_SelectedIndexChanged);

		comboBox5->SelectedIndex = -1;

		comboBox5->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox5_SelectedIndexChanged);
	}
}

void Form2::button1_Click(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = groupBox1;

	if (textBox1->Text != "")
	{
		AssignIntegers(0, Convert::ToInt32(textBox1->Text));
	}

	AssignKeyMethod(checkBox1->Checked);

	if (textBox2->Text != "")
	{
		AssignIntegers(1, Convert::ToInt32(textBox2->Text));
	}

	if (textBox3->Text != "")
	{
		AssignIntegers(2, Convert::ToInt32(textBox3->Text));
	}

	if (textBox4->Text != "")
	{
		AssignIntegers(3,  Convert::ToInt32(textBox4->Text) * 1000);
	}
}

#pragma endregion
```

`A cool trainer/Form2.h`:

```h
#pragma once
#include <windows.h>
#include <commctrl.h>

namespace Acooltrainer {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	/// <summary>
	/// Summary for Form2
	/// </summary>
	public ref class Form2 : public System::Windows::Forms::Form
	{
	public:
		Form2(void)
		{
			InitializeComponent();

			ActiveControl = groupBox1;

			ComboBox_SetCueBannerText((HWND)comboBox1->Handle.ToPointer(), (LPARAM)L"Key...");
			ComboBox_SetCueBannerText((HWND)comboBox2->Handle.ToPointer(), (LPARAM)L"Key...");
			ComboBox_SetCueBannerText((HWND)comboBox3->Handle.ToPointer(), (LPARAM)L"Key...");
			ComboBox_SetCueBannerText((HWND)comboBox4->Handle.ToPointer(), (LPARAM)L"Key...");
			ComboBox_SetCueBannerText((HWND)comboBox5->Handle.ToPointer(), (LPARAM)L"Key...");

			SendMessage((HWND)textBox1->Handle.ToPointer(), EM_SETCUEBANNER, (WPARAM)FALSE, (LPARAM)L"Delay...");
			SendMessage((HWND)textBox2->Handle.ToPointer(), EM_SETCUEBANNER, (WPARAM)FALSE, (LPARAM)L"Value...");
			SendMessage((HWND)textBox3->Handle.ToPointer(), EM_SETCUEBANNER, (WPARAM)FALSE, (LPARAM)L"Value...");
			SendMessage((HWND)textBox4->Handle.ToPointer(), EM_SETCUEBANNER, (WPARAM)FALSE, (LPARAM)L"Delay...");
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		virtual void WndProc(Message% m) override 
		{
			__super::WndProc(m);
			if (m.Msg == WM_NCHITTEST) 
			{
				switch ((int)m.Result) 
				{
				case HTLEFT: 
				case HTRIGHT: 
				case HTTOP: 
                case HTTOPLEFT: 
				case HTTOPRIGHT:
                case HTBOTTOMLEFT: 
				case HTBOTTOMRIGHT:
					m.Result = (IntPtr)HTCLIENT;
				}
			}
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~Form2()
		{
			if (components)
			{
				delete components;
			}
		}
	private: System::Windows::Forms::GroupBox^  groupBox1;
	protected: 

	private: System::Windows::Forms::ComboBox^  comboBox1;
	private: System::Windows::Forms::CheckBox^  checkBox1;
	private: System::Windows::Forms::TextBox^  textBox1;
	private: System::Windows::Forms::GroupBox^  groupBox2;


	private: System::Windows::Forms::ComboBox^  comboBox2;
	private: System::Windows::Forms::GroupBox^  groupBox3;
	private: System::Windows::Forms::TextBox^  textBox2;


	private: System::Windows::Forms::ComboBox^  comboBox3;
	private: System::Windows::Forms::GroupBox^  groupBox4;
	private: System::Windows::Forms::TextBox^  textBox3;


	private: System::Windows::Forms::ComboBox^  comboBox4;

	private: System::Windows::Forms::ToolTip^  toolTip1;
	private: System::Windows::Forms::Button^  button1;
	private: System::Windows::Forms::GroupBox^  groupBox5;
	private: System::Windows::Forms::TextBox^  textBox4;
	private: System::Windows::Forms::ComboBox^  comboBox5;
	private: System::ComponentModel::IContainer^  components;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			this->components = (gcnew System::ComponentModel::Container());
			this->groupBox1 = (gcnew System::Windows::Forms::GroupBox());
			this->checkBox1 = (gcnew System::Windows::Forms::CheckBox());
			this->textBox1 = (gcnew System::Windows::Forms::TextBox());
			this->comboBox1 = (gcnew System::Windows::Forms::ComboBox());
			this->groupBox2 = (gcnew System::Windows::Forms::GroupBox());
			this->comboBox2 = (gcnew System::Windows::Forms::ComboBox());
			this->groupBox3 = (gcnew System::Windows::Forms::GroupBox());
			this->textBox2 = (gcnew System::Windows::Forms::TextBox());
			this->comboBox3 = (gcnew System::Windows::Forms::ComboBox());
			this->groupBox4 = (gcnew System::Windows::Forms::GroupBox());
			this->textBox3 = (gcnew System::Windows::Forms::TextBox());
			this->comboBox4 = (gcnew System::Windows::Forms::ComboBox());
			this->toolTip1 = (gcnew System::Windows::Forms::ToolTip(this->components));
			this->button1 = (gcnew System::Windows::Forms::Button());
			this->textBox4 = (gcnew System::Windows::Forms::TextBox());
			this->groupBox5 = (gcnew System::Windows::Forms::GroupBox());
			this->comboBox5 = (gcnew System::Windows::Forms::ComboBox());
			this->groupBox1->SuspendLayout();
			this->groupBox2->SuspendLayout();
			this->groupBox3->SuspendLayout();
			this->groupBox4->SuspendLayout();
			this->groupBox5->SuspendLayout();
			this->SuspendLayout();
			// 
			// groupBox1
			// 
			this->groupBox1->Controls->Add(this->checkBox1);
			this->groupBox1->Controls->Add(this->textBox1);
			this->groupBox1->Controls->Add(this->comboBox1);
			this->groupBox1->Font = (gcnew System::Drawing::Font(L"Consolas", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point, 
				static_cast<System::Byte>(0)));
			this->groupBox1->Location = System::Drawing::Point(12, 12);
			this->groupBox1->Name = L"groupBox1";
			this->groupBox1->Size = System::Drawing::Size(144, 76);
			this->groupBox1->TabIndex = 0;
			this->groupBox1->TabStop = false;
			this->groupBox1->Text = L"Automated attack";
			// 
			// checkBox1
			// 
			this->checkBox1->AutoSize = true;
			this->checkBox1->Cursor = System::Windows::Forms::Cursors::Hand;
			this->checkBox1->Location = System::Drawing::Point(123, 49);
			this->checkBox1->Name = L"checkBox1";
			this->checkBox1->Size = System::Drawing::Size(15, 14);
			this->checkBox1->TabIndex = 1;
			this->toolTip1->SetToolTip(this->checkBox1, L"Check for hold method.");
			this->checkBox1->UseVisualStyleBackColor = true;
			// 
			// textBox1
			// 
			this->textBox1->Location = System::Drawing::Point(6, 46);
			this->textBox1->Name = L"textBox1";
			this->textBox1->Size = System::Drawing::Size(111, 20);
			this->textBox1->TabIndex = 1;
			this->toolTip1->SetToolTip(this->textBox1, L"Enter delay in miliseconds here.");
			this->textBox1->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &Form2::textBox1_KeyPress);
			// 
			// comboBox1
			// 
			this->comboBox1->Cursor = System::Windows::Forms::Cursors::Hand;
			this->comboBox1->FormattingEnabled = true;
			this->comboBox1->Items->AddRange(gcnew cli::array< System::Object^  >(45) {L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", 
				L"8", L"9", L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", L"N", L"O", L"P", L"Q", L"R", L"S", 
				L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", L"SHIFT", L"CTRL", L"ALT", L"PAGE UP", L"PAGE DOWN", L"END", L"HOME", L"INS", L"DEL"});
			this->comboBox1->Location = System::Drawing::Point(6, 19);
			this->comboBox1->Name = L"comboBox1";
			this->comboBox1->Size = System::Drawing::Size(132, 21);
			this->comboBox1->TabIndex = 0;
			this->toolTip1->SetToolTip(this->comboBox1, L"Select key.");
			this->comboBox1->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox1_SelectedIndexChanged);
			// 
			// groupBox2
			// 
			this->groupBox2->Controls->Add(this->comboBox2);
			this->groupBox2->Location = System::Drawing::Point(12, 94);
			this->groupBox2->Name = L"groupBox2";
			this->groupBox2->Size = System::Drawing::Size(144, 52);
			this->groupBox2->TabIndex = 1;
			this->groupBox2->TabStop = false;
			this->groupBox2->Text = L"Automated loot";
			// 
			// comboBox2
			// 
			this->comboBox2->Cursor = System::Windows::Forms::Cursors::Hand;
			this->comboBox2->FormattingEnabled = true;
			this->comboBox2->Items->AddRange(gcnew cli::array< System::Object^  >(45) {L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", 
				L"8", L"9", L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", L"N", L"O", L"P", L"Q", L"R", L"S", 
				L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", L"SHIFT", L"CTRL", L"ALT", L"PAGE UP", L"PAGE DOWN", L"END", L"HOME", L"INS", L"DEL"});
			this->comboBox2->Location = System::Drawing::Point(6, 19);
			this->comboBox2->Name = L"comboBox2";
			this->comboBox2->Size = System::Drawing::Size(132, 21);
			this->comboBox2->TabIndex = 0;
			this->toolTip1->SetToolTip(this->comboBox2, L"Select key.");
			this->comboBox2->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox2_SelectedIndexChanged);
			// 
			// groupBox3
			// 
			this->groupBox3->Controls->Add(this->textBox2);
			this->groupBox3->Controls->Add(this->comboBox3);
			this->groupBox3->Location = System::Drawing::Point(12, 152);
			this->groupBox3->Name = L"groupBox3";
			this->groupBox3->Size = System::Drawing::Size(144, 76);
			this->groupBox3->TabIndex = 2;
			this->groupBox3->TabStop = false;
			this->groupBox3->Text = L"Automated health";
			// 
			// textBox2
			// 
			this->textBox2->Location = System::Drawing::Point(6, 46);
			this->textBox2->Name = L"textBox2";
			this->textBox2->Size = System::Drawing::Size(132, 20);
			this->textBox2->TabIndex = 1;
			this->toolTip1->SetToolTip(this->textBox2, L"Enter value here.");
			this->textBox2->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &Form2::textBox2_KeyPress);
			// 
			// comboBox3
			// 
			this->comboBox3->Cursor = System::Windows::Forms::Cursors::Hand;
			this->comboBox3->FormattingEnabled = true;
			this->comboBox3->Items->AddRange(gcnew cli::array< System::Object^  >(45) {L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", 
				L"8", L"9", L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", L"N", L"O", L"P", L"Q", L"R", L"S", 
				L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", L"SHIFT", L"CTRL", L"ALT", L"PAGE UP", L"PAGE DOWN", L"END", L"HOME", L"INS", L"DEL"});
			this->comboBox3->Location = System::Drawing::Point(6, 19);
			this->comboBox3->Name = L"comboBox3";
			this->comboBox3->Size = System::Drawing::Size(132, 21);
			this->comboBox3->TabIndex = 0;
			this->toolTip1->SetToolTip(this->comboBox3, L"Select key.");
			this->comboBox3->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox3_SelectedIndexChanged);
			// 
			// groupBox4
			// 
			this->groupBox4->Controls->Add(this->textBox3);
			this->groupBox4->Controls->Add(this->comboBox4);
			this->groupBox4->Location = System::Drawing::Point(12, 234);
			this->groupBox4->Name = L"groupBox4";
			this->groupBox4->Size = System::Drawing::Size(144, 76);
			this->groupBox4->TabIndex = 3;
			this->groupBox4->TabStop = false;
			this->groupBox4->Text = L"Automated mana";
			// 
			// textBox3
			// 
			this->textBox3->Location = System::Drawing::Point(6, 46);
			this->textBox3->Name = L"textBox3";
			this->textBox3->Size = System::Drawing::Size(132, 20);
			this->textBox3->TabIndex = 1;
			this->toolTip1->SetToolTip(this->textBox3, L"Enter value here.");
			this->textBox3->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &Form2::textBox3_KeyPress);
			// 
			// comboBox4
			// 
			this->comboBox4->Cursor = System::Windows::Forms::Cursors::Hand;
			this->comboBox4->FormattingEnabled = true;
			this->comboBox4->Items->AddRange(gcnew cli::array< System::Object^  >(45) {L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", 
				L"8", L"9", L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", L"N", L"O", L"P", L"Q", L"R", L"S", 
				L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", L"SHIFT", L"CTRL", L"ALT", L"PAGE UP", L"PAGE DOWN", L"END", L"HOME", L"INS", L"DEL"});
			this->comboBox4->Location = System::Drawing::Point(6, 19);
			this->comboBox4->Name = L"comboBox4";
			this->comboBox4->Size = System::Drawing::Size(132, 21);
			this->comboBox4->TabIndex = 0;
			this->toolTip1->SetToolTip(this->comboBox4, L"Select key.");
			this->comboBox4->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox4_SelectedIndexChanged);
			// 
			// button1
			// 
			this->button1->Cursor = System::Windows::Forms::Cursors::Hand;
			this->button1->Location = System::Drawing::Point(12, 405);
			this->button1->Name = L"button1";
			this->button1->Size = System::Drawing::Size(144, 20);
			this->button1->TabIndex = 4;
			this->button1->Text = L"Assign keys";
			this->toolTip1->SetToolTip(this->button1, L"Save information.");
			this->button1->UseVisualStyleBackColor = true;
			this->button1->Click += gcnew System::EventHandler(this, &Form2::button1_Click);
			// 
			// textBox4
			// 
			this->textBox4->Location = System::Drawing::Point(6, 46);
			this->textBox4->Name = L"textBox4";
			this->textBox4->Size = System::Drawing::Size(132, 20);
			this->textBox4->TabIndex = 1;
			this->toolTip1->SetToolTip(this->textBox4, L"Enter delay in seconds here.");
			// 
			// groupBox5
			// 
			this->groupBox5->Controls->Add(this->textBox4);
			this->groupBox5->Controls->Add(this->comboBox5);
			this->groupBox5->Location = System::Drawing::Point(12, 316);
			this->groupBox5->Name = L"groupBox5";
			this->groupBox5->Size = System::Drawing::Size(144, 76);
			this->groupBox5->TabIndex = 5;
			this->groupBox5->TabStop = false;
			this->groupBox5->Text = L"Automated skill";
			// 
			// comboBox5
			// 
			this->comboBox5->Cursor = System::Windows::Forms::Cursors::Hand;
			this->comboBox5->FormattingEnabled = true;
			this->comboBox5->Items->AddRange(gcnew cli::array< System::Object^  >(45) {L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", 
				L"8", L"9", L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", L"N", L"O", L"P", L"Q", L"R", L"S", 
				L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", L"SHIFT", L"CTRL", L"ALT", L"PAGE UP", L"PAGE DOWN", L"END", L"HOME", L"INS", L"DEL"});
			this->comboBox5->Location = System::Drawing::Point(6, 19);
			this->comboBox5->Name = L"comboBox5";
			this->comboBox5->Size = System::Drawing::Size(132, 21);
			this->comboBox5->TabIndex = 0;
			this->comboBox5->SelectedIndexChanged += gcnew System::EventHandler(this, &Form2::comboBox5_SelectedIndexChanged);
			// 
			// Form2
			// 
			this->AutoScaleDimensions = System::Drawing::SizeF(6, 13);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->ClientSize = System::Drawing::Size(168, 404);
			this->ControlBox = false;
			this->Controls->Add(this->groupBox5);
			this->Controls->Add(this->button1);
			this->Controls->Add(this->groupBox4);
			this->Controls->Add(this->groupBox3);
			this->Controls->Add(this->groupBox2);
			this->Controls->Add(this->groupBox1);
			this->Font = (gcnew System::Drawing::Font(L"Consolas", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point, 
				static_cast<System::Byte>(0)));
			this->MaximizeBox = false;
			this->MaximumSize = System::Drawing::Size(184, 475);
			this->MinimizeBox = false;
			this->MinimumSize = System::Drawing::Size(184, 442);
			this->Name = L"Form2";
			this->Opacity = 0.9;
			this->ShowIcon = false;
			this->ShowInTaskbar = false;
			this->Text = L"Settings";
			this->groupBox1->ResumeLayout(false);
			this->groupBox1->PerformLayout();
			this->groupBox2->ResumeLayout(false);
			this->groupBox3->ResumeLayout(false);
			this->groupBox3->PerformLayout();
			this->groupBox4->ResumeLayout(false);
			this->groupBox4->PerformLayout();
			this->groupBox5->ResumeLayout(false);
			this->groupBox5->PerformLayout();
			this->ResumeLayout(false);

		}
#pragma endregion
private: System::Void comboBox1_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e);
private: System::Void textBox1_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) 
		 {
			 if(!Char::IsDigit(e->KeyChar) && e->KeyChar != 0x08)
				 e->Handled = true;
		 }
private: System::Void comboBox2_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e);
private: System::Void textBox2_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) 
		 {
			 if(!Char::IsDigit(e->KeyChar) && e->KeyChar != 0x08)
				 e->Handled = true;
		 }
private: System::Void comboBox3_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e);
private: System::Void textBox3_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) 
		 {
			 if(!Char::IsDigit(e->KeyChar) && e->KeyChar != 0x08)
				 e->Handled = true;
		 }
private: System::Void comboBox4_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e);
private: System::Void button1_Click(System::Object^  sender, System::EventArgs^  e);
private: System::Void comboBox5_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e);
};
}

```

`A cool trainer/Form2.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="toolTip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`A cool trainer/Form3.cpp`:

```cpp
#include "Form3.h"
#include "Packet.h"

using namespace Acooltrainer;

#pragma region Variables

std::string packet;

bool methodSwitch2 = false;
bool packetSwitch2 = false;

#pragma endregion

#pragma region Functions

void MarshalString(String ^ s,std::string& os)
{
	using namespace Runtime::InteropServices;

	const char* chars = (const char*)(Marshal::StringToHGlobalAnsi(s)).ToPointer();

	os = chars;

	Marshal::FreeHGlobal(IntPtr((void*)chars));
}

void ThreadSafeSendPacket()
{
	std::string error;

	if(!SendPacket(packet,error))
	{
		::MessageBox(0, error.c_str(), "Failed to inject packet.", MB_OK | MB_ICONERROR);
	}
}

void ThreadSafeRecvPacket()
{
	std::string error;

	if(!RecvPacket(packet,error))
	{
		::MessageBox(0, error.c_str(), "Failed to inject packet.", MB_OK | MB_ICONERROR);
	}
}

VOID PacketSpam()
{
	while (packetSwitch2)
	{
		if (methodSwitch2)
		{
			CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&ThreadSafeRecvPacket, NULL, 0, NULL);
		}
		else
		{
			CreateThread(0,0,(LPTHREAD_START_ROUTINE)&ThreadSafeSendPacket,0,0,0);
		}
		
		Sleep(1000);
	}
}

#pragma endregion

#pragma region Form events

void Form3::button1_Click(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = panel1;

	if (receiveToolStripMenuItem->Checked)
	{
		methodSwitch2 = true;

		MarshalString(textBox1->Text,packet);

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&ThreadSafeRecvPacket, NULL, 0, NULL);
	}
	else
	{
		methodSwitch2 = false;

		MarshalString(textBox1->Text,packet);

		CreateThread(0,0,(LPTHREAD_START_ROUTINE)&ThreadSafeSendPacket,0,0,0);
	}
}

void Form3::spamToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e)
{
	ActiveControl = panel1;

	if (spamToolStripMenuItem->Checked)
	{
		if (textBox1->Text != "")
		{
			MarshalString(textBox1->Text,packet);

			textBox1->ReadOnly = true;

			packetSwitch2 = true;

			CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&PacketSpam, NULL , 0, NULL );

			BlockSpam(true);
		}
		else
		{
			::MessageBox(0, "Please enter a packet.", "Failed to spam packet.", MB_OK | MB_ICONERROR);

			spamToolStripMenuItem->Checked = false;
		}
	}
	else
	{
		packetSwitch2 = false;

		textBox1->ReadOnly = false;

		BlockSpam(false);
	}
}

#pragma endregion
```

`A cool trainer/Form3.h`:

```h
#pragma once
#include <windows.h>
#include <commctrl.h>

namespace Acooltrainer {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	/// <summary>
	/// Summary for Form3
	/// </summary>
	public ref class Form3 : public System::Windows::Forms::Form
	{
	public:
		Form3(void)
		{
			InitializeComponent();

			ActiveControl = panel1;

			SendMessage((HWND)textBox1->Handle.ToPointer(), EM_SETCUEBANNER, (WPARAM)FALSE, (LPARAM)L"Enter unformatted packet to inject here...");
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		virtual void WndProc(Message% m) override 
		{
			__super::WndProc(m);
			if (m.Msg == WM_NCHITTEST) 
			{
				switch ((int)m.Result) 
				{
				case HTBOTTOM:
				case HTLEFT: 
				case HTRIGHT: 
				case HTTOP: 
                case HTTOPLEFT: 
				case HTTOPRIGHT:
                case HTBOTTOMLEFT: 
				case HTBOTTOMRIGHT:
					m.Result = (IntPtr)HTCLIENT;
				}
			}
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~Form3()
		{
			if (components)
			{
				delete components;
			}
		}

	protected: 


	private: System::Windows::Forms::TextBox^  textBox1;
	private: System::Windows::Forms::Button^  button1;
	private: System::Windows::Forms::ContextMenuStrip^  contextMenuStrip1;
	private: System::Windows::Forms::ToolStripMenuItem^  receiveToolStripMenuItem;
	private: System::Windows::Forms::ToolTip^  toolTip1;
	private: System::Windows::Forms::ToolStripMenuItem^  spamToolStripMenuItem;
	private: System::Windows::Forms::Panel^  panel1;
	private: System::ComponentModel::IContainer^  components;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			this->components = (gcnew System::ComponentModel::Container());
			System::ComponentModel::ComponentResourceManager^  resources = (gcnew System::ComponentModel::ComponentResourceManager(Form3::typeid));
			this->textBox1 = (gcnew System::Windows::Forms::TextBox());
			this->button1 = (gcnew System::Windows::Forms::Button());
			this->contextMenuStrip1 = (gcnew System::Windows::Forms::ContextMenuStrip(this->components));
			this->receiveToolStripMenuItem = (gcnew System::Windows::Forms::ToolStripMenuItem());
			this->spamToolStripMenuItem = (gcnew System::Windows::Forms::ToolStripMenuItem());
			this->toolTip1 = (gcnew System::Windows::Forms::ToolTip(this->components));
			this->panel1 = (gcnew System::Windows::Forms::Panel());
			this->contextMenuStrip1->SuspendLayout();
			this->SuspendLayout();
			// 
			// textBox1
			// 
			this->textBox1->Location = System::Drawing::Point(12, 12);
			this->textBox1->Name = L"textBox1";
			this->textBox1->Size = System::Drawing::Size(382, 20);
			this->textBox1->TabIndex = 1;
			this->toolTip1->SetToolTip(this->textBox1, L"Enter packet here.");
			// 
			// button1
			// 
			this->button1->ContextMenuStrip = this->contextMenuStrip1;
			this->button1->Cursor = System::Windows::Forms::Cursors::Hand;
			this->button1->Image = (cli::safe_cast<System::Drawing::Image^  >(resources->GetObject(L"button1.Image")));
			this->button1->Location = System::Drawing::Point(400, 12);
			this->button1->Name = L"button1";
			this->button1->Size = System::Drawing::Size(32, 20);
			this->button1->TabIndex = 2;
			this->toolTip1->SetToolTip(this->button1, L"Inject packet.");
			this->button1->UseVisualStyleBackColor = true;
			this->button1->Click += gcnew System::EventHandler(this, &Form3::button1_Click);
			// 
			// contextMenuStrip1
			// 
			this->contextMenuStrip1->Items->AddRange(gcnew cli::array< System::Windows::Forms::ToolStripItem^  >(2) {this->receiveToolStripMenuItem, 
				this->spamToolStripMenuItem});
			this->contextMenuStrip1->Name = L"contextMenuStrip1";
			this->contextMenuStrip1->Size = System::Drawing::Size(115, 48);
			// 
			// receiveToolStripMenuItem
			// 
			this->receiveToolStripMenuItem->CheckOnClick = true;
			this->receiveToolStripMenuItem->Name = L"receiveToolStripMenuItem";
			this->receiveToolStripMenuItem->Size = System::Drawing::Size(114, 22);
			this->receiveToolStripMenuItem->Text = L"Receive";
			this->receiveToolStripMenuItem->Click += gcnew System::EventHandler(this, &Form3::receiveToolStripMenuItem_Click);
			// 
			// spamToolStripMenuItem
			// 
			this->spamToolStripMenuItem->CheckOnClick = true;
			this->spamToolStripMenuItem->Name = L"spamToolStripMenuItem";
			this->spamToolStripMenuItem->Size = System::Drawing::Size(114, 22);
			this->spamToolStripMenuItem->Text = L"Spam";
			this->spamToolStripMenuItem->Click += gcnew System::EventHandler(this, &Form3::spamToolStripMenuItem_Click);
			// 
			// panel1
			// 
			this->panel1->Location = System::Drawing::Point(12, 12);
			this->panel1->Name = L"panel1";
			this->panel1->Size = System::Drawing::Size(420, 20);
			this->panel1->TabIndex = 3;
			// 
			// Form3
			// 
			this->AutoScaleDimensions = System::Drawing::SizeF(6, 13);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->ClientSize = System::Drawing::Size(444, 44);
			this->ControlBox = false;
			this->Controls->Add(this->button1);
			this->Controls->Add(this->textBox1);
			this->Controls->Add(this->panel1);
			this->Font = (gcnew System::Drawing::Font(L"Consolas", 8.25F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point, 
				static_cast<System::Byte>(0)));
			this->MaximizeBox = false;
			this->MaximumSize = System::Drawing::Size(460, 82);
			this->MinimizeBox = false;
			this->MinimumSize = System::Drawing::Size(460, 82);
			this->Name = L"Form3";
			this->Opacity = 0.9;
			this->ShowIcon = false;
			this->ShowInTaskbar = false;
			this->Text = L"Packets";
			this->contextMenuStrip1->ResumeLayout(false);
			this->ResumeLayout(false);
			this->PerformLayout();

		}
#pragma endregion
private: System::Void button1_Click(System::Object^  sender, System::EventArgs^  e);
private: System::Void spamToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e);
private: System::Void receiveToolStripMenuItem_Click(System::Object^  sender, System::EventArgs^  e) 
		 {
			 ActiveControl = panel1;
		 }
};
}

```

`A cool trainer/Form3.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="toolTip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>172, 17</value>
  </metadata>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="button1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABAAAAAFCAYAAABM6GxJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAADrwAAA68AZW8ckkAAABVSURBVChTY2DABP+BQoQww5kzZ2BqICZABUDM/92/HMCS
        yPR/KACJg9RmZ2dDDAAxkDFI0GcvxAXINEgTkq0IA2A+QHYBSKNFF8QAGI1sAIoLKA0DAFgDc3OgsAfw
        AAAAAElFTkSuQmCC
</value>
  </data>
</root>
```

`A cool trainer/Hack.cpp`:

```cpp
#include "Hack.h"
#include "Macro.h"
#include "Packet.h"

#pragma region MapleStory memory

static const DWORD msCHATLOG_ADD = 0x00491C90;
static const DWORD msSetData = 0x00502000;

static const DWORD msFMA = 0x007D6F19;

static const DWORD msGodmode = 0x007D64FC;

static const DWORD msSilence1 = 0x007CC225;
static const DWORD msSilence2 = 0x007CC24E;
static const DWORD msSilence3 = 0x007CC273;
static const DWORD msSilence4 = 0x007CC2A4;
static const DWORD msSilence5 = 0x007A83E2;
static const DWORD msSilence6 = 0x007D1971;
static const DWORD msSilence7 = 0x007CCB21;

static const DWORD msFusionAttack = 0x007D6F19;
static const DWORD msFusionAttackReturn1 = 0x007D6F1D;
static const DWORD msFusionAttackReturn2 = 0x007D6F33;

DWORD *const pdwItemFilterPointer = reinterpret_cast<DWORD *const>(0x12ED8A4);
const DWORD dwOriginal = 0x00970620;
const DWORD dwThing1 = 0x0040AFC0;
const DWORD dwThing2 = 0x0040B060;
const DWORD dwReturn = 0x005B883E;

DWORD *const pdwVariantInitPointer = reinterpret_cast<DWORD *const>(0x01010304);
const DWORD dwVariantInit = reinterpret_cast<DWORD>(GetProcAddress(LoadLibrary(TEXT("OLEAUT32.dll")), TEXT("VariantInit")));
const DWORD dwCall1 = reinterpret_cast<DWORD>(GetProcAddress(GetModuleHandle(NULL), TEXT("ZtlTaskMemFreeImp")));
const DWORD dwCall2 = reinterpret_cast<DWORD>(GetProcAddress(LoadLibrary(TEXT("OLEAUT32.dll")), TEXT("VariantClear")));
const DWORD dwReturn1 = 0x00779ECE;
const DWORD dwReturn2 = 0x00779EDA;

static const DWORD alertBase = 0x013017C4;
static const WORD alertHealth = 0x50;
static const WORD alertMana = 0x54;

static const DWORD serverBase = 0x012FCF80;
static const DWORD serverChannel = 0x20AC;

static const DWORD peopleBase = 0x013017C8;
static const WORD peopleDot = 0x18;

static const DWORD characterBase = 0x012FCF84;
static const DWORD characterX = 0x9074;
static const DWORD characterY = 0x9078;

static const DWORD teleportToggle = 0x7E6C;
static const DWORD teleportX = 0x7E90;
static const DWORD teleportY = 0x7E84;

static const DWORD guiBase = 0x013018A0;
static const DWORD guiHealth = 0x2200;
static const DWORD guiMana = 0x2204;

static const DWORD wallBase = 0x01301738;
static const WORD leftWall = 0x1C;
static const WORD topWall = 0x20; 
static const WORD rightWall = 0x24;
static const WORD bottomWall = 0x28;

static const DWORD monsterBase = 0x013017CC;
static const WORD monsterCount = 0x10;
static const WORD monster1 = 0x28;
static const BYTE monster2 = 0x4;
static const DWORD monster3 = 0x170;
static const WORD monster4 = 0x24;
static const WORD monsterX = 0x58;
static const WORD monsterY = 0x5C;
static const WORD monsterDeath = 0x568;

#pragma endregion

#pragma region Windows and Detour functions

BOOL SetHook ( __in BOOL bState, __inout PVOID* ppPointer, __in PVOID pDetour )
{
	if ( ! DetourTransactionBegin()
	  && ! DetourUpdateThread(GetCurrentThread())
	  && ! (bState ? DetourAttach : DetourDetach)(ppPointer, pDetour)
	  && ! DetourTransactionCommit() )
		return TRUE;

	return FALSE;
}

DWORD ReadPointer(DWORD dwBase, DWORD dwOffset)
{
	__try
	{
		return *(PDWORD)(*(PDWORD)dwBase + dwOffset);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return 0;
	}
}

bool WritePointer(DWORD dwBase, DWORD dwOffset, DWORD dwValue)
{
	__try
	{
		*(PDWORD)(*(PDWORD)dwBase + dwOffset) = dwValue;
		return true;
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return false;
	}
}

DWORD GetValue(DWORD dwBase, DWORD dwOffset)
{
	__try
	{
		return *(PDWORD)(dwBase + dwOffset);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return 0;
	}
}

#pragma endregion

#pragma region Structure

template <typename T>
struct ZXString
{
	T* _m_pStr;
};

#pragma endregion

#pragma region API

typedef void (__cdecl* CHATLOG_ADD_t)(ZXString<char> *sString, unsigned short nType);
CHATLOG_ADD_t CHATLOG_ADD = reinterpret_cast<CHATLOG_ADD_t>(msCHATLOG_ADD);

typedef BOOL ( WINAPI* LPFNINTERSECTRECT )( LPRECT, const RECT*, const RECT* );
LPFNINTERSECTRECT _fnIntersectRect;

typedef void (__fastcall* TSecType_long___SetData_t)(void* lpvEcx, void* lpvEdx, const int data);
TSecType_long___SetData_t _TSecType_long___SetData = reinterpret_cast<TSecType_long___SetData_t>(msSetData);

#pragma endregion

#pragma region Variables

std::vector<DWORD> vReturnAddresses;

bool bGodmodeEnabled = false;
bool bFMAEnabled = false;
bool bFusionAttackEnabled = false;
bool bHookedIntersectRect = false;
bool kamiSwitch = false;

std::vector<DWORD> vBlacklist(1, 0);

#pragma endregion

#pragma region Pointer Functions

int UpdateHealth()
{
	return (int)ReadPointer(guiBase, guiHealth);
}

int UpdateMana()
{
	return (int)ReadPointer(guiBase, guiMana);
}

bool UpdatePeople()
{
	return (int)ReadPointer(peopleBase, peopleDot) > 0;
}

int GetChannel()
{
	return (int)ReadPointer(serverBase, serverChannel);
}

bool leftWallLocation(int X)
{
    return ((int)ReadPointer(wallBase, leftWall) <= X);
}

bool topWallLocation(int Y)
{
    return ((int)ReadPointer(wallBase, topWall) <= Y);
}

bool rightWallLocation(int X)
{
    return ((int)ReadPointer(wallBase, rightWall) >= X);
}

bool bottomWallLocation(int Y)
{
    return ((int)ReadPointer(wallBase, bottomWall) >= Y);
}

int GetCharacterX()
{
	return (int)ReadPointer(characterBase, characterX); 
}

int GetCharacterY()
{
	return (int)ReadPointer(characterBase, characterY);
}

int GetMonsterX(DWORD dwMonster)
{
	return (int)ReadPointer(monsterBase, monsterX);
}

int GetMonsterY(DWORD dwMonster)
{
	return (int)ReadPointer(monsterBase, monsterY);
}

int GetMonsterCount()
{
	return (int)ReadPointer(monsterBase, monsterCount);
}

POINT GetMonsterLocation()
{
	POINT MobLoc;

	for(int iMonsterIndex = ReadPointer(monsterBase, monsterCount); iMonsterIndex > -1; --iMonsterIndex)
	{
		DWORD dwMobStruct = ReadPointer(monsterBase, monster1);
		if(iMonsterIndex > 0)
		{
			dwMobStruct = GetValue(dwMobStruct, -12);
			for (int i = 0; i < iMonsterIndex; ++i)
			{
				dwMobStruct = GetValue(dwMobStruct, 4);
			}
			dwMobStruct = GetValue(dwMobStruct, 0x14);
		}
		else { dwMobStruct = GetValue(dwMobStruct,monster2); }

		if(GetValue(dwMobStruct, monsterDeath))
		{
			dwMobStruct = GetValue(GetValue(dwMobStruct, monster3), monster4);
			int x = GetValue(dwMobStruct, monsterX);
			int y = GetValue(dwMobStruct, monsterY);

			if(x != 0 && y !=0)
			{
				MobLoc.x = x;	
				MobLoc.y = y;
				return MobLoc;
			}
		}
	}
	return MobLoc;
}

#pragma endregion

#pragma region Hacks and Threads

__declspec(naked) void FusionAttack()
{
	__asm
	{
		test eax, eax
		je Return1
		mov eax, dword ptr [esp+0x18]
		mov ecx, dword ptr [esp+0x60]
Thing:
		mov dword ptr [ecx+eax*4], ebp
		inc eax
		cmp eax, dword ptr [esp+0x64]
		jl Thing
		jmp dword ptr [msFusionAttackReturn2]
Return1:
		jmp dword ptr [msFusionAttackReturn1]
	}
}

__declspec(noinline) BOOL WINAPI IntersectRect_Hook(_Out_ PRECT prcDst, _In_ const RECT *prcSrc1, _In_ const RECT *prcSrc2)
{
	DWORD dwRetAddress;

	__asm
	{
		push eax
		mov eax, dword ptr [ebp+4]
		mov dword ptr [dwRetAddress], eax
		pop eax
	}

	if (bGodmodeEnabled && (dwRetAddress == msGodmode || dwRetAddress == msSilence1 || dwRetAddress == msSilence2 || dwRetAddress == msSilence3 || dwRetAddress == msSilence4 || dwRetAddress == msSilence5 || dwRetAddress == msSilence6 || dwRetAddress == msSilence7))
	{
		return FALSE;
	}
	else if (bFMAEnabled && dwRetAddress == msFMA)
	{
		return TRUE;
	}
	else if (bFusionAttackEnabled && dwRetAddress == msFusionAttack)
	{
		__asm
		{
			mov dword ptr [ebp+4], offset FusionAttack
		}
	}
	return _fnIntersectRect(prcDst, prcSrc1, prcSrc2);
}

BOOL HookIntersectRect(__in BOOL bState)
{
	bHookedIntersectRect = true;
	if (bState)
	{
		_fnIntersectRect = reinterpret_cast<LPFNINTERSECTRECT>(GetProcAddress(GetModuleHandle(TEXT("user32.dll")), TEXT("IntersectRect")));
	}
	return SetHook(bState, (PVOID *)&_fnIntersectRect, &IntersectRect_Hook);
}

__declspec(naked) void ItemFilter()
{
	__asm
	{
		cmp dword ptr [esp+0x58], 0x005B8809
		jne Return
		mov dword ptr [esp+0x58], offset PreItemFilter
Return:
		jmp dword ptr [dwOriginal]
PreItemFilter:
		mov eax, dword ptr [esp+0x64]
		mov esi, dword ptr [esp+0x70]
		mov byte ptr [esi+0x1C], al
		cmp eax, 1
		je JMP1
		cmp eax, 2
		je JMP1
		xor al, al
		jmp JMP2
JMP1:
		mov al, 1
JMP2:
		mov byte ptr [esi+0x1D], al
		mov ecx, ebx
		mov dword ptr [esi+0x20], edi
		call dword ptr [dwThing1]
		movzx ecx, al
		mov ecx, ebx
		mov dword ptr [esi+0x30], eax
		call dword ptr [dwThing2]
		mov ecx, dword ptr [vBlacklist]
ItemFilterLoop:
		cmp dword ptr [ecx], 0
		je Return2
		cmp eax, dword ptr [ecx]
		je Filter
		add ecx, 4
		jmp ItemFilterLoop
Filter:
		xor eax, eax
Return2:
		jmp dword ptr [dwReturn]
	}
}

__declspec(naked) void VariantInitHook()
{
	__asm
	{
		cmp dword ptr [esp+0x2C], 0x00779E6B
		jne Return
		mov dword ptr [esp+0x2C], offset Callback
Return:
		jmp dword ptr [dwVariantInit]
Callback:
		add esp, 0x08
		cmp word ptr [ebp-0x5C], 0x08
		mov ebx, eax
		mov byte ptr [ebp-0x04], 0x07
		jne offset JMP1
		xor eax, eax
		mov word ptr [ebp-0x5C], ax
		mov eax, dword ptr [ebp-0x54]
		test eax, eax
		je offset JMP2
		add eax, 0xFC
		push eax
		call dword ptr [dwCall1]
		jmp offset JMP2
JMP1:
		lea ecx, dword ptr [ebp-0x5C]
		push ecx
		call dword ptr [dwCall2]
JMP2:
		cmp ebx, 0x01
		jne offset JMP4
		cmp byte ptr [ebp-0x11], 0x00
		jne offset JMP5
JMP3:
		push 0x00
		push 0x00
		push 0x00
		push 0x00
		push 0x00
		push 0xFF
		push ecx
		mov eax, esp
		mov dword ptr [eax], esi
		mov ecx, dword ptr [esi]
		mov edx, dword ptr [ecx+0x04]
		mov dword ptr [ebp-0x24], esp
		push esi
		call edx
		mov ecx, dword ptr [ebp-0x28]
		jmp dword ptr [dwReturn1]
JMP4:
		cmp ebx, 0x02
		jne offset JMP3
		cmp byte ptr [ebp-0x11], 0x00
		jne offset JMP3
JMP5:
		mov edx, dword ptr [esi]
		mov eax, dword ptr [edx+0x08]
		push esi
		mov byte ptr [ebp-0x04], 0x03
		call eax
		jmp dword ptr [dwReturn2]
	}
}

static const DWORD dwGetTickCount = reinterpret_cast<DWORD>(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), TEXT("GetTickCount")));
static const DWORD dwGND = 0x01010114;
static const DWORD dwJMP3 = 0x00D0EFBD;
static const DWORD dwGNDCall1 = 0x00492C00;
static const DWORD dwJMP1 = 0x00D1B725;
static const DWORD dwGNDCall2 = 0x00CD2A40;
static const DWORD dwCall3 = 0x0045B480;
static const DWORD dwCall4 = 0x005DEFD0;
static const DWORD dwCall5 = 0x00CC2A20;
static const DWORD dwCall6 = 0x008B0000;
static const DWORD dwCall7 = 0x008AD310;
static const DWORD dwCall8 = 0x00406E90;
static const DWORD dwCall9 = 0x008B6460;
static const DWORD dwCall10 = 0x00406E90;
static const DWORD dwCall11 = 0x008B6460;
static const DWORD dwCall12 = 0x00431FF0;
static const DWORD dwCall13 = 0x00433DD0;
static const DWORD dwCall14 = 0x00432000;
static const DWORD dwCall15 = 0x00433A20;
static const DWORD dwCall16 = 0x00503600;
static const DWORD dwCall17 = 0x00975630;
static const DWORD dwCall18 = 0x004318C0;
static const DWORD dwCall19 = 0x00491C90;
static const DWORD dwCall20 = 0x004181D0;
static const DWORD dwCall21 = 0x0067F750;
static const DWORD dwCall22 = 0x0067F350;
static const DWORD dwCall23 = 0x0067F360;
static const DWORD dwCall24 = 0x0067F330;
static const DWORD dwCall25 = 0x0067F360;
static const DWORD dwCall26 = 0x0067F320;
static const DWORD dwCall27 = 0x0067F360;
static const DWORD dwCall28 = 0x0067F6F0;
static const DWORD dwCall29 = 0x0067F340;
static const DWORD dwCall30 = 0x0067F680;
static const DWORD dwCall31 = 0x004BD360;
static const DWORD dwCall32 = 0x005AB2E0;
static const DWORD dwCall33 = 0x004A8E40;
static const DWORD dwCall34 = 0x00492750;
static const DWORD dwCall35 = 0x008AF220;
static const DWORD dwCall36 = 0x00914F30;
static const DWORD dwJMP2 = 0x00D0EFB1;

__declspec(naked) void GetTickCountHook()
{
	__asm
	{
			cmp dword ptr [esp], 0x00D0EC25
			jne Return
			mov dword ptr [esp], offset Callback
Return:
			jmp dword ptr [dwGetTickCount]
Callback:
			mov ecx, dword ptr [ebp-0x00003038]
			mov dword ptr [ecx+0x00009068], eax
			mov ecx, dword ptr [ebp-0x00003038]
			add ecx, 0x90
			call dword ptr [dwGNDCall1]
			test eax, eax
			je JMP1
			xor eax, eax
			jmp dword ptr [dwJMP1]
JMP1:
			cmp dword ptr [ebp+0x08], 0
			je JMP2
			mov edx, dword ptr [ebp+0x08]
			mov eax, dword ptr [edx]
			mov dword ptr [ebp-0x0000303C], eax
			jmp JMP3
JMP2:
			mov dword ptr [ebp-0x0000303C], 0
JMP3:
			mov ecx, dword ptr [ebp-0x0000303C]
			mov dword ptr [ebp-0x000001D0], ecx
			mov edx, dword ptr [ebp-0x000001D0]
			push edx
			mov ecx, dword ptr [ebp-0x00003038]
			call dword ptr [dwGNDCall2]
			test eax, eax
			jne JMP4
			xor eax, eax
			jmp dword ptr [dwJMP1]
JMP4:
			call dword ptr [dwCall3]
			mov ecx, eax
			call dword ptr [dwCall4]
			test eax, eax
			jne JMP5
			mov ecx, dword ptr [ebp-0x00003038]
			call dword ptr [dwCall5]
			movzx eax, al
			test eax, eax
			je JMP6
JMP5:
			mov ecx, dword ptr [ebp-0x000001D0]
			push ecx
			call dword ptr [dwCall6]
			add esp, 04
			test eax, eax
			je JMP6
			xor eax, eax
			jmp dword ptr [dwJMP1]
JMP6:
			mov edx, dword ptr [ebp-0x000001D0]
			push edx
			call dword ptr [dwCall7]
			add esp, 4
			test eax, eax
			jne JMP7
			cmp dword ptr [ebp-0x000001D0], 0x0050DF27
			je JMP7
			cmp dword ptr [ebp-0x000001D0], 0x019DD253
			jne JMP8
JMP7:
			cmp dword ptr [ebp+0x20], 0
			jne JMP8
			xor eax, eax
			jmp dword ptr [dwJMP1]
JMP8:
			cmp dword ptr [ebp-0x000001D0], 0x0040684F
			jne JMP9
			mov eax, dword ptr [ebp-0x00003038]
			cmp dword ptr [eax+0x0000597C], 0
			je JMP9
			xor eax,eax
			jmp dword ptr [dwJMP1]
JMP9:
			push 0x000F462D
			call dword ptr [dwCall8]
			mov ecx, eax
			call dword ptr [dwCall9]
			mov dword ptr [ebp-0x14], eax
			push 0x00A7DCAB
			call dword ptr [dwCall10]
			mov ecx, eax
			call dword ptr [dwCall11]
			mov dword ptr [ebp-0x00000168], eax
			call dword ptr [dwCall12]
			mov dword ptr [ebp-0x30], eax
			lea ecx, dword ptr [ebp-0x00000F9C]
			push ecx
			mov ecx, dword ptr [ebp-0x30]
			call dword ptr [dwCall13]
			mov dword ptr [ebp-0x00003040], eax
			mov ecx, dword ptr [ebp-0x00003040]
			call dword ptr [dwCall14]
			mov dword ptr [ebp-0x60], eax
			lea ecx, dword ptr [ebp-0x00000F9C]
			call dword ptr [dwCall15]
			mov ecx, dword ptr [ebp-0x30]
			call dword ptr [dwCall16]
			test eax, eax
			je JMP10
			push 0x0000009D
			lea edx, dword ptr [ebp-0x00000FA0]
			push edx
			call dword ptr [dwCall17]
			mov ecx, eax
			call dword ptr [dwCall18]
			mov dword ptr [ebp-0x00003044], eax
			mov eax, dword ptr [ebp-0x00003044]
			mov dword ptr [ebp-0x00003048], eax
			mov dword ptr [ebp-0x04], 0
			push 0x0C
			mov ecx, dword ptr [ebp-0x00003048]
			push ecx
			call dword ptr [dwCall19]
			add esp, 8
			mov dword ptr [ebp-0x04], 0xFFFFFFFF
			lea ecx, dword ptr [ebp-0x00000FA0]
			call dword ptr [dwCall20]
			xor eax,eax
			jmp dword ptr [dwJMP1]
JMP10:
			lea edx, dword ptr [ebp-0x00000BD8]
			push edx
			mov ecx, dword ptr [ebp-0x00003038]
			call dword ptr [dwCall21]
			mov dword ptr [ebp-0x04], 1
			mov dword ptr [ebp-0x000001E8], 0
			lea ecx, dword ptr [ebp-0x00000BD8]
			call dword ptr [dwCall22]
			test eax,eax
			je JMP11
			lea ecx, dword ptr [ebp-0x00000BD8]
			call dword ptr [dwCall23]
			mov eax, dword ptr [eax+0x00000114]
			mov dword ptr [ebp-0x000001E8], eax
			lea ecx, dword ptr [ebp-0x00000BE0]
			call dword ptr [dwCall24]
			mov byte ptr [ebp-0x04], 2
			lea ecx, dword ptr [ebp-0x00000BD8]
			call dword ptr [dwCall25]
			add eax, 0x00000164
			mov ecx, eax
			call dword ptr [dwCall26]
			test eax, eax
			jne JMP12
			lea ecx, dword ptr [ebp-0x00000BE0]
			push ecx
			lea edx, dword ptr [ebp-0x000001D0]
			push edx
			lea ecx, dword ptr [ebp-0x00000BD8]
			call dword ptr [dwCall27]
			add eax, 0x00000164
			mov ecx, eax
			call dword ptr [dwCall28]
			test eax, eax
			je JMP12
			lea ecx, dword ptr [ebp-0x00000BE0]
			call dword ptr [dwCall29]
			mov ecx, dword ptr [ebp-0x000001E8]
			add ecx, dword ptr [eax+0x28]
			mov dword ptr [ebp-0x000001E8], ecx
JMP12:
			mov byte ptr [ebp-0x04], 1
			lea ecx, dword ptr [ebp-0x00000BE0]
			call dword ptr [dwCall30]
JMP11:
			mov edx, dword ptr [ebp-0x00003038]
			mov eax, dword ptr [edx]
			mov ecx, dword ptr [ebp-0x00003038]
			mov edx, dword ptr [eax+0x58]
			call edx
			push eax
			call dword ptr [dwCall31]
			add esp, 4
			test eax, eax
			je JMP13
			mov eax, dword ptr [ebp-0x000001D0]
			push eax
			mov ecx, dword ptr [ebp-0x60]
			call dword ptr [dwCall32]
			test eax, eax
			je JMP13
			mov dword ptr [ebp-0x0000304C], 1
			jmp JMP14
JMP13:
			mov dword ptr [ebp-0x0000304C], 0
JMP14:
			mov ecx, dword ptr [ebp-0x0000304C]
			mov [ebp-0x44], ecx
			cmp dword ptr [ebp+0x10], 0
			je JMP15
			mov edx, dword ptr [ebp+0x10]
			mov dword ptr [edx], 0x41
JMP15:
			mov eax, dword ptr [ebp-0x60]
			mov dword ptr [ebp-0x00000084], eax
			mov ecx, dword ptr [ebp-0x30]
			call dword ptr [dwCall33]
			mov dword ptr [ebp-0x00000BD0], eax
			mov ecx, dword ptr [ebp-0x30]
			call dword ptr [dwCall34]
			mov dword ptr [ebp-0x00000208], eax
			mov ecx, dword ptr [ebp-0x00000208]
			call dword ptr [dwCall35]
			neg eax
			sbb eax, eax
			neg eax
			mov dword ptr [ebp-0x000001E4], eax
			mov ecx, dword ptr [ebp-0x00000208]
			call dword ptr [dwCall36]
			test eax, eax
			je JMP16
			cmp dword ptr [ebp-0x000001D0], 0x00E6935E
			je JMP16
			mov dword ptr [ebp-0x00003050], 1
			jmp JMP17
JMP16:
			mov dword ptr [ebp-0x00003050], 0
JMP17:
			mov ecx, dword ptr [ebp-0x00003050]
			mov dword ptr [ebp-0x00000204], ecx
			cmp dword ptr [ebp-0x000001D0], 0
			je Other
			mov edx, dword ptr [ebp-0x00003038]
			mov eax, dword ptr [ebp-0x000001D0]
			cmp eax, dword ptr [edx+0x00007E04]
			je Other
			jmp dword ptr [dwJMP2]
Other:
			jmp dword ptr [dwJMP3]
	}
}

void Teleport(int X, int Y)
{
	if (leftWallLocation(X) && rightWallLocation(X) && topWallLocation(Y) && bottomWallLocation(Y))
	{
		void* base = *reinterpret_cast<void**>(characterBase);
		_TSecType_long___SetData(reinterpret_cast<unsigned char*>(base) + teleportX, NULL, X);
		_TSecType_long___SetData(reinterpret_cast<unsigned char*>(base) + teleportY, NULL, Y);
		_TSecType_long___SetData(reinterpret_cast<unsigned char*>(base) + teleportToggle, NULL, 1);
	}
}

void Kami()
{
	while (kamiSwitch)
	{
		if (GetMonsterCount() == 0)
		{
			continue;
		}

		POINT loc = GetMonsterLocation();

		int nDistanceX = loc.x - GetCharacterX();
		int nDistanceY = loc.y - GetCharacterY();

		if (nDistanceX < 0 || nDistanceX > 50 || nDistanceY < 0 || nDistanceY > 50)
		{
			Teleport(loc.x - 25, loc.y - 10);
		}

		Sleep(100);
	}
	return;
}

void ChangeChannel()
{
	byte iChannel;
	std::string strError;
	char buffer[26];

	do
	{
		iChannel = rand() % 10;
	} 
	while (iChannel == GetChannel());

	sprintf(buffer, "45 00 %02x ** ** ** **", iChannel);

	do
	{
		SendPacket((std::string)buffer, strError);
		Sleep(3000);
	} 
	while (GetChannel() != iChannel);

	MacroBlock(false);
}

#pragma endregion

#pragma region General Functions

void ToggleKami(bool bEnable)
{
	if (bEnable)
	{
		kamiSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&Kami, NULL , 0, NULL );
	}
	else
	{
		kamiSwitch = false;
	}
}

void ToggleGodmode(bool bEnable)
{
	if (!bHookedIntersectRect)
	{
		HookIntersectRect(TRUE);
	}
	bGodmodeEnabled = bEnable;
}

void ToggleFusionAttack(bool bEnable)
{
	if (!bHookedIntersectRect)
	{
		HookIntersectRect(TRUE);
	}
	bFusionAttackEnabled = bEnable;
}

static const DWORD dwKiFastSystemCall = reinterpret_cast<DWORD>(GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), TEXT("KiFastSystemCall")));

bool IsWow64()
{
	static bool bAlready = false;
	typedef BOOL (WINAPI *pfnIsWow64Process)(HANDLE, PBOOL);
	static const pfnIsWow64Process fnIsWow64Process = reinterpret_cast<pfnIsWow64Process>(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), TEXT("IsWow64Process")));
	static BOOL bIsX64 = FALSE;
	if (!bAlready)
	{
		bAlready = true;
		if (fnIsWow64Process != NULL)
		{
			fnIsWow64Process(GetCurrentProcess(), &bIsX64);
		}
	}
	return bIsX64;
}

__declspec(naked) NTSTATUS NTAPI NtProtectVirtualMemory(IN HANDLE hProcess, IN OUT PVOID pAddress, IN OUT DWORD *pdwNumberOfBytesToProtect, IN DWORD dwNewAccessProtection, OUT DWORD *pdwOldAccessProtection)
{
	__asm
	{
		mov eax, 0x000000D7
		call dword ptr [dwKiFastSystemCall]
		ret 0x0014
	}
}

bool ToggleGND(bool bEnable)
{
	DWORD dwOldProtect;
	DWORD dwNumberOfBytesToProtect = sizeof(DWORD);
	if (IsWow64())
	{
		if (VirtualProtect((PVOID)dwGND, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &dwOldProtect))
		{
			*reinterpret_cast<DWORD *>(dwGND) = bEnable ? (DWORD)GetTickCountHook : dwGetTickCount;
			VirtualProtect((PVOID)dwGND, sizeof(DWORD), dwOldProtect, &dwOldProtect);
			return true;
		}
	}
	else
	{
		if (NtProtectVirtualMemory(GetCurrentProcess(), (PVOID)dwGND, &dwNumberOfBytesToProtect, PAGE_EXECUTE_READWRITE, &dwOldProtect) == 0x00000000)
		{
			*reinterpret_cast<DWORD *>(dwGND) = bEnable ? (DWORD)GetTickCountHook : dwGetTickCount;
			NtProtectVirtualMemory(GetCurrentProcess(), (PVOID)dwGND, &dwNumberOfBytesToProtect, dwOldProtect, &dwOldProtect);
			return true;
		}
	}
	return false;
}

void ToggleFMA(bool bEnable)
{
	if (!bHookedIntersectRect)
	{
		HookIntersectRect(TRUE);
	}
	bFMAEnabled = bEnable;
}

void ToggleItemFilter(bool bEnable)
{
	*pdwItemFilterPointer = bEnable ? (DWORD)ItemFilter : dwOriginal;
}

bool ToggleCPUHack(bool bEnable)
{
    DWORD dwOldProtect = 0;
	DWORD dwNumberOfBytesToProtect = sizeof(DWORD);
	if (IsWow64())
	{
		if (VirtualProtect((PVOID)pdwVariantInitPointer, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &dwOldProtect))
		{
			*reinterpret_cast<DWORD *>(pdwVariantInitPointer) = bEnable ? (DWORD)VariantInitHook : dwVariantInit;
			VirtualProtect((PVOID)pdwVariantInitPointer, sizeof(DWORD), dwOldProtect, &dwOldProtect);
			return true;
		}
	}
	else
	{
		if (NtProtectVirtualMemory(GetCurrentProcess(), (PVOID)pdwVariantInitPointer, &dwNumberOfBytesToProtect, PAGE_EXECUTE_READWRITE, &dwOldProtect) == 0x00000000)
		{
			*reinterpret_cast<DWORD *>(pdwVariantInitPointer) = bEnable ? (DWORD)VariantInitHook : dwVariantInit;
			NtProtectVirtualMemory(GetCurrentProcess(), (PVOID)pdwVariantInitPointer, &dwNumberOfBytesToProtect, dwOldProtect, &dwOldProtect);
			return true;
		}
	}
	return false;
}

void ToggleAlert(bool bEnable)
{
	if (bEnable)
	{
		WritePointer(alertBase, alertHealth, 20);
		WritePointer(alertBase, alertMana, 20);
	}
	else
	{
		WritePointer(alertBase, alertHealth, 19);
		WritePointer(alertBase, alertMana, 19);
	}
}

void AddItemToBlacklist(DWORD dwItem)
{
	vBlacklist.insert(vBlacklist.begin(), dwItem);
}

void RemoveItemFromBlacklist(int index)
{
	vBlacklist.erase(vBlacklist.end() - index - 2);
}

void ClearBlacklist()
{
	vBlacklist.clear();
	vBlacklist.push_back(0);
}

void ShowMessage(std::string const& strMessage, MessageType nType)
{
	ZXString<char> str;
	str._m_pStr = const_cast<char*>(strMessage.c_str());
	CHATLOG_ADD(&str, static_cast<unsigned short>(nType));
}

#pragma endregion
```

`A cool trainer/Hack.h`:

```h
#ifndef HACK_H
#define HACK_H

#include <windows.h>
#include <string>
#include <detours.h>
#include <vector>

#pragma comment(lib, "detours.lib")

enum MessageType
{
        White = 0,
        Green = 1,
        Lightpurple = 2,
        Orange = 3,
        Purple = 4,
        Lightgreen = 5,
        Special_PurpleGrey = 6,
        Grey = 7,
        Yellow = 8,
        Lightyellow = 9,
        Blue = 10,
        Special_BlackWhite = 11,
        Red = 12
};

BOOL HookIntersectRect(__in BOOL bState);
void ToggleKami(bool bEnable);
void ToggleGodmode(bool bEnable);
void ToggleFusionAttack(bool bEnable);
bool ToggleGND(bool bEnable);
void ToggleItemFilter(bool bEnable);
bool ToggleCPUHack(bool bEnable);
void ToggleAlert(bool bEnable);
void AddItemToBlacklist(DWORD dwItem);
void RemoveItemFromBlacklist(int index);
void ClearBlacklist();
void ShowMessage(std::string const &strMessage, MessageType nType);
void ChangeChannel();

int UpdateHealth();
int UpdateMana();
bool UpdatePeople();
int GenerateHealthValue();
int GenerateManaValue();

#endif
```

`A cool trainer/Macro.cpp`:

```cpp
#include "Hack.h"
#include "Macro.h"

#pragma region Variables

#define AttackKey 0
#define LootKey 1
#define HealthKey 2
#define ManaKey 3
#define SkillKey 4

int nKeys [5];

static enum StringValue { evS1, evS2, evS3, evS4, evS5, evS6, evS7, evS8, evS9, evS10, evS11, evS12, evS13, evS14, evS15, evS16, evS17, evS18, evS19, evS20, evS21, evS22, evS23, evS24, evS25, evS26, evS27, evS28, evS29, evS30, evS31, evS32, evS33, evS34, evS35, evS36, evS37, evS38, evS39, evS40, evS41, evS42, evS43, evS44, evS45};

static std::map<std::string, StringValue> s_mapStringValues;

HWND maplestory;

int healthValue;
int manaValue;

int attackDelay;
int skillDelay;

bool attackSwitch = false;
bool attackMethod = false;
bool lootSwitch = false;
bool healthSwitch = false;
bool manaSwitch = false;
bool channelSwitch = false;
bool skillSwitch = false;

bool macroBlock = false;

#pragma endregion

#pragma region Functions

void initializeKeys()
{
	s_mapStringValues["0"] = evS1;
	s_mapStringValues["1"] = evS2;
	s_mapStringValues["2"] = evS3;
	s_mapStringValues["3"] = evS4;
	s_mapStringValues["4"] = evS5;
	s_mapStringValues["5"] = evS6;
	s_mapStringValues["6"] = evS7;
	s_mapStringValues["7"] = evS8;
	s_mapStringValues["8"] = evS9;
	s_mapStringValues["9"] = evS10;

	s_mapStringValues["A"] = evS11;
	s_mapStringValues["B"] = evS12;
	s_mapStringValues["C"] = evS13;
	s_mapStringValues["D"] = evS14;
	s_mapStringValues["E"] = evS15;
	s_mapStringValues["F"] = evS16;
	s_mapStringValues["G"] = evS17;
	s_mapStringValues["H"] = evS18;
	s_mapStringValues["I"] = evS19;
	s_mapStringValues["J"] = evS20;

	s_mapStringValues["K"] = evS21;
	s_mapStringValues["L"] = evS22;
	s_mapStringValues["M"] = evS23;
	s_mapStringValues["N"] = evS24;
	s_mapStringValues["O"] = evS25;
	s_mapStringValues["P"] = evS26;
	s_mapStringValues["Q"] = evS27;
	s_mapStringValues["R"] = evS28;
	s_mapStringValues["S"] = evS29;
	s_mapStringValues["T"] = evS30;

	s_mapStringValues["U"] = evS31;
	s_mapStringValues["V"] = evS32;
	s_mapStringValues["W"] = evS33;
	s_mapStringValues["X"] = evS34;
	s_mapStringValues["Y"] = evS35;
	s_mapStringValues["Z"] = evS36;

	s_mapStringValues["SHIFT"] = evS37;
	s_mapStringValues["CTRL"] = evS38;
	s_mapStringValues["ALT"] = evS39;
	s_mapStringValues["PAGE UP"] = evS40;
	s_mapStringValues["PAGE DOWN"] = evS41;
	s_mapStringValues["END"] = evS42;
	s_mapStringValues["HOME"] = evS43;
	s_mapStringValues["INS"] = evS44;
	s_mapStringValues["DEL"] = evS45;
}

BOOL CheckMethod(__in INT nKey)
{
	bool returnType = false;

	switch (nKey)
	{
	case 0:
		if (nKeys[AttackKey] != NULL && attackDelay != NULL)
		{
			returnType = true;
		}
		else
		{
			returnType = false;
		}
		break;
	case 1:
		if (nKeys[LootKey] != NULL)
		{
			returnType = true;
		}
		else
		{
			returnType = false;
		}
		break;
	case 2:
		if (nKeys[HealthKey] != NULL && healthValue != NULL)
		{
			returnType = true;
		}
		else
		{
			returnType = false;
		}
		break;
	case 3:
		if (nKeys[ManaKey] != NULL && manaValue != NULL)
		{
			returnType = true;
		}
		else
		{
			returnType = false;
		}
		break;
	case 4:
		returnType = true;
		break;
	case 5:
		if (nKeys[SkillKey] != NULL && skillDelay != NULL)
		{
			returnType = true;
		}
		else
		{
			returnType = false;
		}
		break;
	}
	return returnType;
}

BOOL KeyAvailable(__in INT nTemp)
{
	for (int i = 0; i < _countof(nKeys); i++)
	{
		if (nTemp == nKeys[i])
			return FALSE;
	}
	return TRUE;
}

void ClearKey(int keyValue)
{
	nKeys[keyValue] = NULL;
}

void AssignKey(int keyValue, int key)
{
	nKeys[keyValue] = key;
}

void AssignIntegers(int selection, int integer)
{
	switch (selection)
	{
	case 0:
		attackDelay = integer;
		break;
	case 1:
		healthValue = integer;
		break;
	case 2:
		manaValue = integer;
		break;
	case 3:
		skillDelay = integer;
		break;
	}
}

void AssignKeyMethod(bool bEnable)
{
	attackMethod = bEnable;
}

void maplestoryHandle()
{
	maplestory = FindWindowA("MapleStoryClass", NULL);
}

void PressKey(HWND hWnd, unsigned int key)
{
	LPARAM lparam = (MapVirtualKey(key, 0) << 16) + 1;
	PostMessage(hWnd, WM_KEYDOWN, key, lparam);
	PostMessage(hWnd, WM_KEYUP, key, NULL);
}

void HoldKey(HWND hWnd, unsigned int key)
{
	LPARAM lparam = (MapVirtualKey(key, 0) << 16) + 1;
	PostMessage(hWnd, WM_KEYDOWN, key, lparam);
}

#pragma endregion

#pragma region Threads

VOID autoAttack()
{
	while (attackSwitch)
	{
		if (!macroBlock)
		{
			if (attackMethod)
			{
				HoldKey(maplestory, nKeys[AttackKey]);
			
				Sleep(attackDelay);
			}
			else
			{
				PressKey(maplestory, nKeys[AttackKey]);
				Sleep(attackDelay);
			}
		}
	}
	return;
}

VOID autoLoot()
{
	while (lootSwitch)
	{
		if (!macroBlock)
		{
			HoldKey(maplestory, nKeys[LootKey]);
		
			Sleep(100);
		}
	}
	return;
}

VOID autoHealth()
{
	while (healthSwitch)
	{
		if (UpdateHealth() <= healthValue)
		{
			PressKey(maplestory, nKeys[HealthKey]);
		}
		Sleep(100);
	}
	return;
}

VOID autoMana()
{
	while (manaSwitch)
	{
		if (UpdateMana() <= manaValue)
		{
			PressKey(maplestory, nKeys[ManaKey]);
		}
		Sleep(100);
	}
	return;
}

VOID autoChannel()
{
	while (channelSwitch)
	{
		if (UpdatePeople())
		{
			MacroBlock(true);
			ChangeChannel();
		}
		Sleep(100);
	}
	return;
}

VOID autoSkill()
{
	while (skillSwitch)
	{
		if (!macroBlock)
		{
			MacroBlock(true);

			Sleep(1000);

			PressKey(maplestory, nKeys[SkillKey]);

			Sleep(5000);

			MacroBlock(false);
			
			Sleep(skillDelay);
		}
	}
	return;
}

#pragma endregion

#pragma region Thread Functions

void Attack(bool bEnable)
{
	if (bEnable)
	{
		maplestoryHandle();

		attackSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&autoAttack, NULL , 0, NULL );
	}
	else
	{
		attackSwitch = false;
	}
}

void Loot(bool bEnable)
{
	if (bEnable)
	{
		maplestoryHandle();

		lootSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&autoLoot, NULL , 0, NULL );
	}
	else
	{
		lootSwitch = false;
	}
}

void Health(bool bEnable)
{
	if (bEnable)
	{
		maplestoryHandle();

		ToggleAlert(true);

		healthSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&autoHealth, NULL , 0, NULL );
	}
	else
	{
		ToggleAlert(false);

		healthSwitch = false;
	}
}

void Mana(bool bEnable)
{
	if (bEnable)
	{
		maplestoryHandle();

		ToggleAlert(true);

		manaSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&autoMana, NULL , 0, NULL );
	}
	else
	{
		ToggleAlert(false);

		manaSwitch = false;
	}
}

void Channel(bool bEnable)
{
	if (bEnable)
	{
		channelSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&autoChannel, NULL , 0, NULL );
	}
	else
	{
		channelSwitch = false;
	}
}

void Skill(bool bEnable)
{
	if (bEnable)
	{
		maplestoryHandle();

		skillSwitch = true;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&autoSkill, NULL , 0, NULL );
	}
	else
	{
		skillSwitch = false;
	}
}

#pragma endregion

#pragma region General Functions

void MacroBlock(bool bEnable)
{
	macroBlock = bEnable;
}

#pragma endregion
```

`A cool trainer/Macro.h`:

```h
#ifndef MACROS_H
#define MACROS_H

#include <windows.h>
#include <map>
#include <string>

void initializeKeys();

BOOL CheckMethod(__in INT nKey);
BOOL KeyAvailable(__in INT nTemp);

void ClearKey(int keyValue);
void AssignKey(int keyValue, int key);
void AssignIntegers(int selection, int integer);
void AssignKeyMethod(bool bEnable);

void Attack(bool bEnable);
void Loot(bool bEnable);
void Health(bool bEnable);
void Mana(bool bEnable);
void Channel(bool bEnable);
void Skill(bool bEnable);

void MacroBlock(bool bEnable);

#endif
```

`A cool trainer/Packet.cpp`:

```cpp
#include "Packet.h"

#pragma region Maplestory memory

#define RECV_RETURN_ADDRESS 0x00507681

#pragma endregion

#pragma region Variables

std::vector<std::string> vBlockedPackets;

bool bSpam = false;

#pragma endregion

#pragma region API

typedef void (__fastcall *pfnFreePacket)(PVOID pPacket);
const PVOID *ppCClientSocket = reinterpret_cast<const PVOID*>(0x012FD054);
const pfnFreePacket FreePacket = reinterpret_cast<pfnFreePacket>(0x0043B820);

DWORD *const pdwInterlockedIncrement = reinterpret_cast<DWORD *>(0x01010094);
const DWORD dwInterlockedIncrement = reinterpret_cast<DWORD>(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), TEXT("InterlockedIncrement")));

#pragma endregion

#pragma region Functions

template <typename T>
struct HexTo
{
	T value;

	operator T() const
	{
		return value;
	}

	friend std::istream& operator>>(std::istream &in, HexTo &out)
	{
		in >> std::hex >> out.value;
		return in;
	}
};

void ParsePacket(std::string &strPacket, std::vector<BYTE> &vData)
{
	typedef boost::tokenizer<boost::char_separator<char>> Tokenizer;

	vData.clear();

	boost::trim(strPacket);

	static std::tr1::uniform_int<BYTE> gen(0, 15);
	static std::tr1::mt19937 engine;

	static const char szDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

	for (std::size_t index = 0; index < strPacket.length(); ++index)
	{
		if (strPacket[index] == '*')
		{
			strPacket[index] = szDigits[gen(engine)];
		}
	}

	Tokenizer Tokens(strPacket);

	for (Tokenizer::const_iterator iterate = Tokens.begin(), end = Tokens.end(); iterate != end; ++iterate)
	{
		vData.push_back(static_cast<BYTE>(boost::lexical_cast<HexTo<UINT>>(*iterate)));
	}
}

void BlockSpam(bool bEnable)
{
	bSpam = bEnable;
}

bool CheckSpam()
{
	return bSpam;
}

#pragma endregion

#pragma region Packet functions

bool SendPacket(std::string &strPacket, std::string &strError)
{
	strError.clear();
	boost::trim(strPacket);

	if (strPacket.empty())
	{
		strError = "Please enter a packet.";
		return false;
	}
	std::vector<BYTE> vData;
	try
	{
		ParsePacket(strPacket, vData);
	}
	catch (std::exception &exc)
	{
		strError = exc.what();
		return false;
	}
	catch (...)
	{
		strError = "Unknown error (send)!";
		return false;
	}

	COutPacket *pPacket = new COutPacket();
	SecureZeroMemory(pPacket, sizeof(COutPacket));
	pPacket->dwSize = vData.size();
	pPacket->pData = vData.data();

	try
	{
		InjectPacket(pPacket);
	}
	catch (...)
	{
		strError = "Internal error (send)!";
		return false;
	}
	return true;
}

bool SendPacket(std::vector<BYTE> vData)
{
	COutPacket *pPacket = new COutPacket();
	SecureZeroMemory(pPacket, sizeof(COutPacket));
	
	pPacket->dwSize = vData.size();
	pPacket->pData = vData.data();

	try
	{
		InjectPacket(pPacket);
	}
	catch (...)
	{
		return false;
	}
	return true;
}

bool RecvPacket(std::string &strPacket, std::string &strError)
{
	strError.clear();
	boost::trim(strPacket);

	if (strPacket.empty())
	{
		strError = "Please enter a packet.";
		return false;
	}
	std::vector<BYTE> vData;
	try
	{
		ParsePacket(strPacket, vData);
	}
	catch (std::exception &exc)
	{
		strError = exc.what();
		return false;
	}
	catch (...)
	{
		strError = "Unknown error (send)!";
		return false;
	}

	static std::tr1::uniform_int<DWORD> gen;
	static std::tr1::mt19937 engine;

	DWORD dwHeader = gen(engine);

	for (int i = 0; i < sizeof(DWORD); ++i)
	{
		vData.insert(vData.begin(), static_cast<BYTE>(dwHeader >> (i * 8)));
	}

	CInPacket *pPacket = new CInPacket();
	pPacket->fLoopback = 0;
	pPacket->iState = 2;
	pPacket->pData = vData.data();
	pPacket->dwTotalLength = vData.size();
	pPacket->dwUnknown = 0;
	pPacket->dwValidLength = pPacket->dwValidLength - 4;
	pPacket->uOffset = 4;

	try
	{
		InjectPacket(pPacket);
	}
	catch (...)
	{
		strError = "Internal error!";
		return false;
	}
	return true;
} 

bool RecvPacket(std::vector<BYTE> vData)
{
	static std::tr1::uniform_int<DWORD> gen;
	static std::tr1::mt19937 engine;

	DWORD dwHeader = gen(engine);

	for (int i = 0; i < sizeof(DWORD); ++i)
	{
		vData.insert(vData.begin(), static_cast<BYTE>(dwHeader >> (i * 8)));
	}

	CInPacket *pPacket = new CInPacket();
	pPacket->fLoopback = 0;
	pPacket->iState = 2;
	pPacket->pData = vData.data();
	pPacket->dwTotalLength = vData.size();
	pPacket->dwUnknown = 0;
	pPacket->dwValidLength = pPacket->dwValidLength - 4;
	pPacket->uOffset = 4;

	try
	{
		InjectPacket(pPacket);
	}
	catch (...)
	{
		return false;
	}
	return true;
}

bool IsBlueBoxPacket(BYTE *pbData)
{
	return pbData[4] == 0xF5 && pbData[5] == 0x00;
}

#pragma endregion

#pragma region Block functions

__declspec(noinline) void __stdcall RecvCallback(CInPacket *pPacket)
{
	/*
	// change later to block packets (match formatted packets in vBlockedPackets)
	// static const BYTE pHeader[] = {0xF5, 0x00, 0x05};
	BYTE *pbData = reinterpret_cast<BYTE *>(pPacket->pData);
	size_t nSize = pPacket->dwValidLength * 3 + 8;
	TCHAR *szBuffer = new TCHAR[nSize];
	_stprintf_s(szBuffer, pPacket->dwValidLength * 3 + 8, TEXT("Packet:"));
	for (size_t i = 0; i < pPacket->dwValidLength; ++i)
	{
		_stprintf_s(szBuffer, nSize, TEXT("%s %X"), szBuffer, pbData[i + 4]);
	}
	OutputDebugString(szBuffer);
	*/
	if (pPacket->dwValidLength >= 2)
	{
		BYTE *pbData = reinterpret_cast<BYTE *>(pPacket->pData);
		if (IsBlueBoxPacket(pbData))
		{
			OutputDebugString(TEXT("Attempting to block blue box."));
			pbData[4] = 0;
			pbData[5] = 0;
		}
	}
}

__declspec(naked) void RecvPacketHook()
{
	__asm
	{
		cmp dword ptr [esp], RECV_RETURN_ADDRESS
		jne offset Return
		mov dword ptr [esp], offset Hook
Return:
		push dword ptr [dwInterlockedIncrement]
		ret
Hook:
		push dword ptr [esp+0x2C]
		call offset RecvCallback
		push RECV_RETURN_ADDRESS
		ret
	}
}

bool BlockRecv(bool bEnable)
{
	bool bSuccess = false;
	DWORD dwOldProtect;
	if (VirtualProtect((PVOID)pdwInterlockedIncrement, 4, PAGE_EXECUTE_READWRITE, &dwOldProtect))
	{
		__try
		{
			*pdwInterlockedIncrement = bEnable ? (DWORD)RecvPacketHook : dwInterlockedIncrement;
		}
		__finally
		{
			bSuccess = true;
		}
		VirtualProtect((PVOID)pdwInterlockedIncrement, 4, dwOldProtect, &dwOldProtect);
	}
	return bSuccess;
}

void BlockRecvPacket(std::string strPacket)
{
	vBlockedPackets.push_back(strPacket);
}

#pragma endregion

#pragma region Inject functions

void InjectPacket(COutPacket *pPacket)
{
	typedef void (__fastcall *pfnSendPacket)(PVOID pCClientSocket, PVOID pEDX, COutPacket *pPacket);
	typedef DWORD (__fastcall *pfnDecryptData)(PVOID pData);

	static const pfnSendPacket SendPacket = reinterpret_cast<pfnSendPacket>(0x005062E0);
	static const PVOID pReturnAddress = reinterpret_cast<const PVOID>(0x0040CC18);
	static const pfnDecryptData DecryptData = reinterpret_cast<pfnDecryptData>(0x004944E0);
	static const PVOID pLastThreadId = reinterpret_cast<const PVOID>(0x01302060);
	static const DWORD dwRealThreadIdOffset = 0x000006B8;
	
	__writefsdword(dwRealThreadIdOffset, DecryptData(pLastThreadId));

	__asm
	{
		push Next
		push ecx
		mov ecx, dword ptr [ppCClientSocket]
		mov ecx, dword ptr [ecx]
		push dword ptr [pPacket]
		push dword ptr [pReturnAddress]
		jmp dword ptr [SendPacket]
Next:
	}
	FreePacket(reinterpret_cast<PVOID>(pPacket));
}

void InjectPacket(CInPacket *pPacket)
{
	typedef void (__fastcall *pfnRecvPacket)(PVOID pCClientSocket, PVOID pEDX, CInPacket *pPacket);
	typedef void (__fastcall *pfnFreePacket)(CInPacket *pPacket);

	static const pfnRecvPacket RecvPacket = reinterpret_cast<pfnRecvPacket>(0x00507640);

	RecvPacket(*ppCClientSocket, NULL, pPacket);
	FreePacket(reinterpret_cast<PVOID>(pPacket));
}

#pragma endregion
```

`A cool trainer/Packet.h`:

```h
#pragma once
#ifndef PACKET_H
#define PACKET_H

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <vector>
#include <cassert>
#include <random>
#include <boost/tokenizer.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/smart_ptr.hpp>
#pragma pack(push, 1)

struct COutPacket
{
	BOOL fLoopback;
	PVOID pData;
	DWORD dwSize;
	UINT uOffset;
	BOOL fEncrypted;
};

struct CInPacket
{
	BOOL fLoopback;
	int iState;
	PVOID pData;
	DWORD dwTotalLength;
	DWORD dwUnknown;
	DWORD dwValidLength;
	UINT uOffset;
};

void ParsePacket(std::string &strPacket, std::vector<BYTE> &vData);
bool SendPacket(std::string &strPacket, std::string &strError);
bool SendPacket(std::vector<BYTE> vData);
bool RecvPacket(std::string &strPacket, std::string &strError);
bool RecvPacket(std::vector<BYTE> vData);
void InjectPacket(COutPacket *pPacket);
void InjectPacket(CInPacket *pPacket);
bool BlockRecv(bool bEnable);
void BlockSpam(bool bEnable);
bool CheckSpam();

#endif
```

`MSB.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "A cool launcher", "A cool launcher\A cool launcher.csproj", "{83324C8E-BD95-4D15-A725-71C905929C02}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "A cool trainer", "A cool trainer\A cool trainer.vcxproj", "{D41B333F-6043-4159-879E-56D1E2297F62}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|Win32 = Debug|Win32
		Debug|x86 = Debug|x86
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|Win32 = Release|Win32
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{83324C8E-BD95-4D15-A725-71C905929C02}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Debug|Win32.ActiveCfg = Debug|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Debug|x86.ActiveCfg = Debug|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Debug|x86.Build.0 = Debug|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Release|Mixed Platforms.Build.0 = Release|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Release|Win32.ActiveCfg = Release|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Release|x86.ActiveCfg = Release|x86
		{83324C8E-BD95-4D15-A725-71C905929C02}.Release|x86.Build.0 = Release|x86
		{D41B333F-6043-4159-879E-56D1E2297F62}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Debug|Win32.ActiveCfg = Debug|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Debug|Win32.Build.0 = Debug|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Debug|x86.ActiveCfg = Debug|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Release|Mixed Platforms.Build.0 = Release|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Release|Win32.ActiveCfg = Release|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Release|Win32.Build.0 = Release|Win32
		{D41B333F-6043-4159-879E-56D1E2297F62}.Release|x86.ActiveCfg = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
![ScreenShot](https://hostr.co/file/CKKTLOR1K57x/MSB-P.png) MSB
===
![ScreenShot](https://hostr.co/file/2LYoC4gdEqc5/MSB-PIC.png)

A MapleStory trainer.

- This trainer dominated the Global MapleStory public hacking scene from versions 128 to 140.

References: http://maplestory.nexon.net/

===


```