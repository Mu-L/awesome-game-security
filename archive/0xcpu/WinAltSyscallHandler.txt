Project Path: arc_0xcpu_WinAltSyscallHandler_cue4cdrt

Source Tree:

```txt
arc_0xcpu_WinAltSyscallHandler_cue4cdrt
├── AltSyscallClient
│   ├── AltSyscallClient.c
│   ├── AltSyscallClient.sln
│   ├── AltSyscallClient.vcxproj
│   └── AltSyscallClient.vcxproj.filters
├── AltSyscallDriver
│   ├── AltSyscall.c
│   ├── AltSyscall.h
│   ├── AltSyscallDriver.inf
│   ├── AltSyscallDriver.sln
│   ├── AltSyscallDriver.vcxproj
│   └── AltSyscallDriver.vcxproj.filters
├── README.md
└── images
    ├── PspEnableAltSystemCallHandling.png
    ├── gsod.png
    └── poc.jpg

```

`AltSyscallClient/AltSyscallClient.c`:

```c
#include <Windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <AltSyscall.h>

#define ALTSYSCALL_SERVICE_NAMEW        L"AltSyscallSvc"
#define ALTSYSCALL_DEVICE_NAMEW         L"\\\\.\\AltSyscall"
#define ALTSYSCALL_SERVICE_INSTALL      0
#define ALTSYSCALL_SERVICE_UNINSTALL    1
#define ALTSYSCALL_MONITOR_IOCTL        IOCTL_ALT_SYSCALL_DRIVER


_Success_(return == TRUE)
BOOLEAN
InstallDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName,
    _In_	LPCTSTR		DriverPath
)
{
    SC_HANDLE   schService;
    DWORD       errCode;

    schService = CreateService(hSCManager,
                               ServiceName,
                               ServiceName,
                               SERVICE_ALL_ACCESS,
                               SERVICE_KERNEL_DRIVER,
                               SERVICE_DEMAND_START,
                               SERVICE_ERROR_NORMAL,
                               DriverPath,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
    if (NULL == schService) {
        errCode = GetLastError();

        if (ERROR_SERVICE_EXISTS == errCode) {
            fprintf(stderr, "[AltSyscallClient] Service already exists\n");

            return TRUE;
        } else {
            fprintf(stderr, "[AltSyscallClient] Failed creating service: %#x\n", errCode);

            return FALSE;
        }
    } else {
        CloseServiceHandle(schService);

        fprintf(stdout, "[AltSyscallClient] Service %S was successfully created\n", ServiceName);

        return TRUE;
    }
}

_Success_(return == TRUE)
BOOLEAN
UninstallDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName
)
{
    SC_HANDLE   schService;
    BOOLEAN     bRetStatus = FALSE;

    schService = OpenService(hSCManager,
                             ServiceName,
                             SERVICE_ALL_ACCESS);
    if (NULL == schService) {
        fprintf(stderr, "[AltSyscallClient] Failed opening the service: %#X\n", GetLastError());

        return bRetStatus;
    }

    if (DeleteService(schService)) {
        bRetStatus = TRUE;

        fprintf(stdout, "[AltSyscallClient] Service %S was successfully deleted\n", ServiceName);
    } else {
        fprintf(stderr, "[AltSyscallClient] Failed deleting the service: %#X\n", GetLastError());
    }

    CloseServiceHandle(schService);

    return bRetStatus;
}

_Success_(return == TRUE)
BOOLEAN
StartDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName
)
{
    SC_HANDLE   schService;
    DWORD       errCode;
    BOOLEAN     bRetStatus = FALSE;

    schService = OpenService(hSCManager,
                             ServiceName,
                             SERVICE_ALL_ACCESS);
    if (NULL == schService) {
        fprintf(stderr, "[AltSyscallClient] Failed opening the service: %#X\n", GetLastError());

        return bRetStatus;
    }

    if (!StartService(schService,
                      0,
                      NULL)) {
        errCode = GetLastError();

        if (ERROR_SERVICE_ALREADY_RUNNING == errCode) {
            bRetStatus = TRUE;

            fprintf(stdout, "[AltSyscallClient] Service %S already running\n", ServiceName);
        } else {
            fprintf(stderr, "[AltSyscallClient] Failed starting the service: %#X\n", errCode);
        }
    } else {
        bRetStatus = TRUE;

        fprintf(stdout, "[AltSyscallClient] Service %S was successfully started\n", ServiceName);
    }

    CloseServiceHandle(schService);

    return bRetStatus;
}

_Success_(return == TRUE)
BOOLEAN
StopDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName
)
{
    SC_HANDLE       schService;
    SERVICE_STATUS  serviceStatus;
    BOOLEAN         bRetStatus = FALSE;

    schService = OpenService(hSCManager,
                             ServiceName,
                             SERVICE_ALL_ACCESS);
    if (NULL == schService) {
        fprintf(stderr, "[AltSyscallClient] Failed opening the service: %#X\n", GetLastError());

        return bRetStatus;
    }

    if (ControlService(schService,
                       SERVICE_CONTROL_STOP,
                       &serviceStatus)) {
        bRetStatus = TRUE;

        fprintf(stdout, "[AltSyscallClient] Service %S was successfully stopped\n", ServiceName);
    } else {
        fprintf(stderr, "[AltSyscallClient] Failed stopping the service: %#X\n", GetLastError());
    }

    CloseServiceHandle(schService);

    return bRetStatus;
}

_Success_(return == TRUE)
BOOLEAN
ManageDriver(
    _In_    LPCTSTR		DriverPath,
    _In_    LPCTSTR		ServiceName,
    _In_    SIZE_T		Action
)
{
    SC_HANDLE	schSCManager;
    BOOLEAN		bRetVal = TRUE;

    if (NULL == DriverPath || NULL == ServiceName) {
        fprintf(stderr, "[AltSyscallClient] Invalid driver name or service name\n");

        return FALSE;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == schSCManager) {
        fprintf(stderr, "[AltSyscallClient] Failed opening a connection to SCM: %#X\n", GetLastError());

        return FALSE;
    }

    switch (Action) {
    case ALTSYSCALL_SERVICE_INSTALL:
        if (InstallDriver(schSCManager, ServiceName, DriverPath)) {
            bRetVal = StartDriver(schSCManager, ServiceName);
        } else {
            bRetVal = FALSE;
        }

        break;
    case ALTSYSCALL_SERVICE_UNINSTALL:
        if (StopDriver(schSCManager, ServiceName)) {
            bRetVal = UninstallDriver(schSCManager, ServiceName);
        } else {
            bRetVal = FALSE;
        }

        break;
    default:
        fprintf(stderr, "[AltSyscallClient] Unknown action: %zu\n", Action);

        bRetVal = FALSE;

        break;
    }

    if (CloseServiceHandle(schSCManager) == 0) {
        fprintf(stderr, "[AltSyscallClient] Failed closing SCM: %#X\n", GetLastError());
    }

    return bRetVal;
}

int __cdecl main(int argc, char *argv[])
{
    DWORD       retCode = EXIT_SUCCESS;
    DWORD       dwBufferLength = 0;
    DWORD       dwPid = 0;
    DWORD       dwBytesReturned;
    errno_t     intErrNo;
    LPWSTR      lpBuffer = NULL;
    LPCWSTR     lpDriverName = DRIVER_NAME;
    HANDLE      hDevice;
    BOOL        bRet;
    HANDLE      pid;

    if (argc > 1) {
        if (_strnicmp(argv[1], "load", strlen("load")) == 0) {
            dwBufferLength = GetCurrentDirectory(dwBufferLength, lpBuffer);
            if (!dwBufferLength) {
                retCode = GetLastError();
                fwprintf(stderr, L"Failed to query current directory length: %08X\n", retCode);

                return retCode;
            } else {
                lpBuffer = calloc(dwBufferLength + wcslen(lpDriverName) + 2, sizeof(WCHAR)); // + 2: 1 for \ and 1 for NULL
                if (NULL == lpBuffer) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"Failed allocating a buffer for current directory: %08X\n", retCode);

                    return retCode;
                }

                if (!GetCurrentDirectory(dwBufferLength, lpBuffer)) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"Failed to query current directory length: %08X\n", retCode);

                    free(lpBuffer);
                    lpBuffer = NULL;

                    return retCode;
                }

                wcsncat_s(lpBuffer, dwBufferLength + wcslen(lpDriverName) + 1, L"\\", wcslen(L"\\"));
                wcsncat_s(lpBuffer, dwBufferLength + wcslen(lpDriverName) + 1, lpDriverName, wcslen(lpDriverName));

                fwprintf(stdout, L"Absolute of the driver to load: %lS\n", lpBuffer);
            }

            ManageDriver(lpBuffer, ALTSYSCALL_SERVICE_NAMEW, ALTSYSCALL_SERVICE_INSTALL);

            free(lpBuffer);
            lpBuffer = NULL;
        } else if (_strnicmp(argv[1], "unload", strlen("unload")) == 0) {
            ManageDriver(L"", ALTSYSCALL_SERVICE_NAMEW, ALTSYSCALL_SERVICE_UNINSTALL);
        } else {
            dwPid = strtoul(argv[1], NULL, 10);
            if (0 == dwPid) {
                retCode = GetLastError();
                fwprintf(stderr, L"Failed to convert %hs to a number: %08X\n", argv[1], retCode);

                return retCode;
            } else if (ULONG_MAX == dwPid) {
                retCode = GetLastError();
                fwprintf(stderr, L"Failed to convert %hs to a number, overflow\n", argv[1]);

                return retCode;
            } else if (!_get_errno(&intErrNo) && (intErrNo == ERANGE)) {
                retCode = GetLastError();
                fwprintf(stderr, L"Failed to convert %hs to a number, errno out of range: %08X\n", argv[1], retCode);

                return retCode;
            } else {
                fwprintf(stdout, L"Monitor PID: %lu\n", dwPid);
                
                hDevice = CreateFile(ALTSYSCALL_DEVICE_NAMEW,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

                if (hDevice == INVALID_HANDLE_VALUE) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"Failed to open device : %08X\n", retCode);

                    return retCode;
                }

                pid = UlongToHandle(dwPid);
                bRet = DeviceIoControl(hDevice,
                                       ALTSYSCALL_MONITOR_IOCTL,
                                       &pid,
                                       sizeof(HANDLE),
                                       NULL,
                                       0,
                                       &dwBytesReturned,
                                       NULL
                );

                if (!bRet) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"Failed to send PID for monitoring: %08X\n", retCode);

                    return retCode;
                }
            }
        }
    } else {
        fwprintf(stdout, L"Usage: %hs <load | unload | pid>\n", argv[0]);
    }

    return retCode;
}
```

`AltSyscallClient/AltSyscallClient.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29409.12
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AltSyscallClient", "AltSyscallClient.vcxproj", "{4BF480D5-A4CF-411F-B2B6-317BC5526675}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4BF480D5-A4CF-411F-B2B6-317BC5526675}.Debug|x64.ActiveCfg = Debug|x64
		{4BF480D5-A4CF-411F-B2B6-317BC5526675}.Debug|x64.Build.0 = Debug|x64
		{4BF480D5-A4CF-411F-B2B6-317BC5526675}.Release|x64.ActiveCfg = Release|x64
		{4BF480D5-A4CF-411F-B2B6-317BC5526675}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5EB1E24E-880D-4DC8-AD36-EE03BE3C9013}
	EndGlobalSection
EndGlobal

```

`AltSyscallClient/AltSyscallClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AltSyscallClient.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4BF480D5-A4CF-411F-B2B6-317BC5526675}</ProjectGuid>
    <TemplateGuid>{504102d4-2172-473c-8adf-cd96e308f257}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>AltSyscallClient</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>..\AltSyscallDriver\;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);..\AltSyscallDriver\</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>C:\Program Files %28x86%29\Windows Kits\10\Include\10.0.18362.0\km;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);onecoreuap.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>C:\Program Files %28x86%29\Windows Kits\10\Include\10.0.18362.0\km;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);onecoreuap.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AltSyscallClient/AltSyscallClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AltSyscallClient.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`AltSyscallDriver/AltSyscall.c`:

```c
#include <ntifs.h>
#include <Basetsd.h>

#include "AltSyscall.h"


typedef
BOOLEAN
ALT_SYSCALL_HANDLER(
    _In_ PKTRAP_FRAME
);

typedef ALT_SYSCALL_HANDLER* PALT_SYSCALL_HANDLERD;
typedef NTSTATUS(*PsRegisterAltSystemCallHandler)(ALT_SYSCALL_HANDLER, int);

/* 
    Not in the WDK, we will obtain it dynamically. Second Parameter should be PROCESS_INFORMATION_CLASS, 
    for now we will hardcode the value to 0x64 which is the value necessary to enable SystemCall Handling in the process.
    We use Zw instead of Nt, because we need the PreviousMode to be KernelMode not UserMode
*/
typedef NTSTATUS (*ZwSetInformationProcess)(HANDLE, ULONG, PVOID, ULONG);

// Driver init and unload functions
DRIVER_INITIALIZE	DriverEntry;
DRIVER_UNLOAD		DriverUnload;

// Driver dispatch functions
_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CLOSE)
DRIVER_DISPATCH AltSyscallCreateClose;

_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH AltSyscallDeviceControl;

NTSTATUS
RegisterSyscallHandler(
    ALT_SYSCALL_HANDLER CallbackFunction
);
_Success_(return == TRUE)
ALT_SYSCALL_HANDLER SystemCallCallback;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#pragma alloc_text(PAGE, AltSyscallCreateClose)
#pragma alloc_text(PAGE, AltSyscallDeviceControl)
#pragma alloc_text(PAGE, RegisterSyscallHandler)
#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT   DriverObject,
    _In_ PUNICODE_STRING  RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    NTSTATUS        status;
    UNICODE_STRING  ntUnicodeString;
    UNICODE_STRING  ntWin32NameString;
    PDEVICE_OBJECT  deviceObject = NULL;

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Driver loading started\n");

    RtlInitUnicodeString(&ntUnicodeString, ALT_SYSCALL_NT_DEVICE_NAME);

    status = IoCreateDevice(
        DriverObject,
        0,
        &ntUnicodeString,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &deviceObject);                

    if (!NT_SUCCESS(status))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Failed to create device: %#X\n", status);
        return status;
    }

    DriverObject->DriverUnload = DriverUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = AltSyscallCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = AltSyscallCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AltSyscallDeviceControl;

    RtlInitUnicodeString(&ntWin32NameString, ALT_SYSCALL_DOS_DEVICE_NAME);

    status = IoCreateSymbolicLink(&ntWin32NameString, &ntUnicodeString);

    if (!NT_SUCCESS(status))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Failed to create symbolic link: %#X\n", status);
        IoDeleteDevice(deviceObject);
    }
    /*
        The handler can only be registered one time, that's why we are doing it on the DriverEntry. 
        If we call PsRegisterAltSystemCallHandler with a handler already register we will get a Bug Check 0x1E0
        Also we must find a way to check if this handler is alredy set and a way to clear it
    */
    status = RegisterSyscallHandler(SystemCallCallback);

    if (!NT_SUCCESS(status)) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Error trying to register the Syscall handler\n");
        IoDeleteDevice(deviceObject);
    }

    return status;
}

VOID
DriverUnload(
    _In_ PDRIVER_OBJECT   DriverObject
)
{

    PAGED_CODE();

    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    UNICODE_STRING uniWin32NameString;

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Driver unloading started\n");

    RtlInitUnicodeString(&uniWin32NameString, ALT_SYSCALL_DOS_DEVICE_NAME);
    IoDeleteSymbolicLink(&uniWin32NameString);
    if (deviceObject != NULL)
    {
        IoDeleteDevice(deviceObject);
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Driver unloading finished\n");
}

NTSTATUS
AltSyscallCreateClose(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
AltSyscallDeviceControl(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    PIO_STACK_LOCATION			pIoCurrStackLocation;
    NTSTATUS					status = STATUS_SUCCESS;
    ULONG						inBufLength;
    PHANDLE                     inBuf;
    HANDLE                      pHandle;
    CLIENT_ID					clientId;
    HANDLE                      processInfo;
    OBJECT_ATTRIBUTES           objectAttributes;
    UNICODE_STRING				funcName;
    ZwSetInformationProcess		pZwSetInformationProcess;

    pIoCurrStackLocation = IoGetCurrentIrpStackLocation(Irp);
    inBufLength = pIoCurrStackLocation->Parameters.DeviceIoControl.InputBufferLength;

    if (!inBufLength) {
        status = STATUS_INVALID_PARAMETER;
        goto End;
    }

    switch (pIoCurrStackLocation->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_ALT_SYSCALL_DRIVER:
        inBuf = (PHANDLE) Irp->AssociatedIrp.SystemBuffer;

        clientId.UniqueProcess = *inBuf;
        clientId.UniqueThread = 0;
        InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Monitor process PID: %zu\n", (ULONG64)clientId.UniqueProcess);

        status = ZwOpenProcess(&pHandle, PROCESS_ALL_ACCESS, &objectAttributes, &clientId);
        if (!NT_SUCCESS(status)) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Error getting HANDLE for process PID: %zu\n", (ULONG64)clientId.UniqueProcess);

            Irp->IoStatus.Information = 0;
            goto End;
        }

        RtlInitUnicodeString(&funcName, L"ZwSetInformationProcess");
        pZwSetInformationProcess = (ZwSetInformationProcess)MmGetSystemRoutineAddress(&funcName);
        if (NULL == pZwSetInformationProcess) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Failed obtaining address of ZwSetInformationProcess\n");

            ObCloseHandle(pHandle, KernelMode);
            Irp->IoStatus.Information = 0;
            goto End;
        }

        processInfo = (HANDLE)clientId.UniqueProcess;
        status = pZwSetInformationProcess(pHandle, 0x64, &processInfo, 1);
        if (!NT_SUCCESS(status)) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Error setting process information: %08X\n", status);

            ObCloseHandle(pHandle, KernelMode);
            Irp->IoStatus.Information = 0;
            goto End;
        }

        ObCloseHandle(pHandle, KernelMode);

        break;
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        break;
    }

End:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
RegisterSyscallHandler(
    ALT_SYSCALL_HANDLER CallbackFunction
)
{
        PAGED_CODE();

        NTSTATUS                        status;
        UNICODE_STRING                  funcName;
        PsRegisterAltSystemCallHandler  pPsRegisterAltSystemCallHandler;

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Registering Syscall handler\n");

        RtlInitUnicodeString(&funcName, L"PsRegisterAltSystemCallHandler");
        pPsRegisterAltSystemCallHandler = (PsRegisterAltSystemCallHandler)MmGetSystemRoutineAddress(&funcName);
        if (NULL == pPsRegisterAltSystemCallHandler) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Failed obtaining address of PsRegisterAltSystemCallHandler\n");

            return STATUS_PROCEDURE_NOT_FOUND;
        }
        status = pPsRegisterAltSystemCallHandler(&CallbackFunction, 1);

        if (!NT_SUCCESS(status)) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[AltSyscall] Error registering Syscall Handler\n");

            return STATUS_UNSUCCESSFUL;
        }

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Syscall handler registered successfully\n");

        return status;
}

BOOLEAN
SystemCallCallback(
    _In_ PKTRAP_FRAME    TrapFrame
)
{
    // Keeping the syscall number in a local variable, trying to print it directly from the trap frame crashes the process, that's weird, why!?
    ULONG64 SyscallNum = TrapFrame->Rax;
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "[AltSyscall] Syscall handler -> Syscall(%#04llx)\n", SyscallNum);

    return TRUE;
}
```

`AltSyscallDriver/AltSyscall.h`:

```h
#pragma once

#define ALT_SYSCALL_NT_DEVICE_NAME		L"\\Device\\AltSyscall"
#define ALT_SYSCALL_DOS_DEVICE_NAME		L"\\DosDevices\\AltSyscall"

#define IOCTL_ALT_SYSCALL_DRIVER\
    CTL_CODE( FILE_DEVICE_UNKNOWN, 0x993, METHOD_BUFFERED, FILE_ANY_ACCESS  )

#define DRIVER_NAME       L"AltSyscall.sys"

```

`AltSyscallDriver/AltSyscallDriver.inf`:

```inf
;
; AltSyscallDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=AltSyscallDriver.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="AltSyscallDriver Source Disk"

```

`AltSyscallDriver/AltSyscallDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29326.143
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AltSyscallDriver", "AltSyscallDriver.vcxproj", "{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Debug|x64.ActiveCfg = Debug|x64
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Debug|x64.Build.0 = Debug|x64
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Debug|x64.Deploy.0 = Debug|x64
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Debug|x86.ActiveCfg = Debug|Win32
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Debug|x86.Build.0 = Debug|Win32
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Debug|x86.Deploy.0 = Debug|Win32
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Release|x64.ActiveCfg = Release|x64
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Release|x64.Build.0 = Release|x64
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Release|x64.Deploy.0 = Release|x64
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Release|x86.ActiveCfg = Release|Win32
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Release|x86.Build.0 = Release|Win32
		{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0B7DEBF0-BC24-4465-B528-93FEED6A2759}
	EndGlobalSection
EndGlobal

```

`AltSyscallDriver/AltSyscallDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{65B9BD41-96AC-45E3-B7B5-C30EDE97ADB1}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>AltSyscallDriver</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>AltSyscall</TargetName>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="AltSyscallDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AltSyscall.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AltSyscall.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AltSyscallDriver/AltSyscallDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="AltSyscallDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AltSyscall.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AltSyscall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# WinAltSyscallHandler
Some research on AltSystemCallHandlers functionality in Windows 10 20H1 18999

----------------------------------------------------------------------------

`PsAltSystemCallHandlers` is an array of 2 members.
We cannot change the first member using `PsRegisterAltSystemCallHandler` because it checks for the index value. First member is reserved for `Pico` processes.
Also, if second member was already initialized, expect a bug check - 0x1e0. 

First member is initialized to `PsPicoAltSystemCallDispatch` in `IoInitSystemPreDrivers`.
The second member can be a pointer to a function, but also a value like 0 or 1.
The value 1 is present when initialized by `PsNotifyCoreDriversInitialized` and it will not be possible to enable system call handling because `PspEnableAltSystemCallHandling` will return `STATUS_UNSUCCESSFUL` and 0 is the default value.

In `PsAltSystemCallDispatch` the handler is called based on the value from `KeGetCurrentThread()->Header.DebugActive`. If it has the 3rd bit (`DebugActive.Minimal`) set to 1, then the first handler is called (`PsPicoAltSystemCallDispatch`).
Otherwise if the the 6th bit (`DebugActive.AltSyscall`) is set to 1, then the second handler is called (The one we can register with `PsRegisterAltSystemCallHandler`). In any other case the kernel will crash with bug check = 0x1e0.

`PsAltSystemCallDispatch` is called from `KiSystemCall64`. We determined that the argument to `PsAltSystemCallDispatch` is the `KTRAP_FRAME`, which later is passed as the only argument to our registered handler. Syscall number is on `rcx+30`, which is the offset pointing to `rax` in the [`KTRAP_FRAME`](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1903%2019H1%20(May%202019%20Update)/_KTRAP_FRAME)) obtained during the transition from ring 3 to ring 0 in `KiSystemCall64`.
[More info on the KTRAP_FRAME](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/ktrap_frame.htm)

`PspEnableAltSystemCallHandling` is called from `NtSetInformationProcess`. As can be seen on the following image:

![PspEnableAltSystemCallHandling](images/PspEnableAltSystemCallHandling.png)

`NtSetInformationProcess` must be called with `PreviousMode == KernelMode` if this is not the case it will return `STATUS_ACCESS_DENIED`, to achieve this we will use the call to `ZwSetInformationProcess` (More about [PreviousMode](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/previousmode)). The arguments `NtSetInformationProcess` have to be:
```
Argument 4(ProcessInformationLength): 1
Argument 3(ProcessInformation): self explanatory
Argument 2(ProcessInformationClass): 0x64
Argument 1(ProcessHandle): self explanatory
```
The value passed in `ProcessInformation` doesn't really matter, but it must not be `NULL`.

## DISCLAIMER

The tool is only for research purpose, this means it is not very well tested and we're NOT responsible for any possible damage. Feel free to open a pull request if you observe any bug(s) and/or have any improvements.

## FOUND ISSUES

- We observed that accessing directly the value in `Rax` member of `KTRAP_FRAME` was crashing the monitored process when logging it's value. So now we keep that value in a local variable. We're not sure why was that happening.

- `NtSetInformationProcess` sometimes returns `ERROR_INVALID_PARAMETER` when trying to enable monitoring. It's not clear to us why it was failing.

- ~~It looks like this feature is not "finished?"/functional because `PatchGuard` doesn't like if you modify `PsAltSystemCallHandlers` array.~~
![PatchGuard GSoD](images/gsod.png)

- ~~There's no simple way(one function) to unregister the syscall handler. That's going back to the observation that it's probably an unfinished feature.~~

## UPDATES

1) Thanks to [Yarden Shafir](https://twitter.com/yarden_shafir) for the info regarding the last two issues. Basically the problem is not that the feature is "incomplete" is rather a design issue. For now, this feature is only intended to be used by Windows Defender. So the Windows Defender driver runs as a core driver, which means that is loaded before PG is activated, so it can register a handler safely, and for this same reason there is no way to unregister the function, because only Windows Defender can register a handler there, so it doesn't need to unregister it.

    Having this in mind, until Microsoft decide to "open" this feature **the only way to use the tool would be starting the machine under a debugger (WinDbg) or using a tool like [EfiGuard](https://github.com/Mattiwatti/EfiGuard) to disable PatchGuard**

    Again big thanks to [Yarden Shafir](https://twitter.com/yarden_shafir) for sharing this info :)

2) In the near future we'll research the idea of detecting by *yourself*(an `user space` executable) the fact that your actions are monitored by an `AltSyscallHandler`. 


## CONCLUSION

Regarding the prototype of the handler, we're not sure about the returning value. It looks like `1`\\`TRUE` works fine but `PsPicoAltSystemCallDispatch` handler actually returns the syscall number but we are not experts on PICO processes, maybe for next research :)

We can't wait to see this feature in a stable version of Windows, we strongly believe AV products and researchers will be able to benefit a lot from this, (Going back to hooking syscalls! We don't know if this is good or bad thou) also we want to see how Microsoft will expose the API to use this feature.

![POC](images/poc.jpg)

- [@n4r1B](https://twitter.com/n4r1B)
- [@0xcpu](https://twitter.com/0xcpu)

```