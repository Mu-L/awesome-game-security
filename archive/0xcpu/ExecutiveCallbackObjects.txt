Project Path: arc_0xcpu_ExecutiveCallbackObjects_t3rn7xwn

Source Tree:

```txt
arc_0xcpu_ExecutiveCallbackObjects_t3rn7xwn
├── 542875F90F9B47F497B64BA219CACF69
│   ├── PGCbUtil
│   │   ├── PgCbUtil.c
│   │   ├── PgCbUtil.inf
│   │   ├── PgCbUtil.sln
│   │   ├── PgCbUtil.vcxproj
│   │   └── PgCbUtil.vcxproj.filters
│   ├── PgCtx.h
│   ├── README.md
│   ├── checksum_algo.md
│   ├── crypt_decrypt.md
│   ├── hash_algo.md
│   ├── images
│   │   ├── critical_msr.png
│   │   ├── exec_cb_obj.png
│   │   ├── func_int1.png
│   │   ├── gen_dataregion.png
│   │   ├── imp_table.png
│   │   ├── insert_apc.png
│   │   ├── invfunctab.png
│   │   ├── mistake1.png
│   │   ├── mistake1b.png
│   │   ├── objecttype.png
│   │   ├── page_hash_mismatch.png
│   │   ├── pg_init.png
│   │   ├── seckernelintcheck_fct.png
│   │   └── type_pool.png
│   └── pg_entry_dump.py
├── AfdTdxCallback
│   └── README.md
├── EnlightenmentState
│   ├── EnlightenmentState
│   │   ├── EnlightenmentState.c
│   │   ├── EnlightenmentState.inf
│   │   ├── EnlightenmentState.vcxproj
│   │   └── EnlightenmentState.vcxproj.filters
│   ├── EnlightenmentState.sln
│   └── README.md
├── IoExternalDmaUnblock
│   ├── README.md
│   ├── ida_run.py
│   └── ntpowerinfo.py
├── Loader
│   ├── Loader.c
│   ├── Loader.sln
│   ├── Loader.vcxproj
│   └── Loader.vcxproj.filters
├── Phase1InitComplete
│   ├── Phase1InitComplete
│   │   ├── Phase1InitComplete.c
│   │   ├── Phase1InitComplete.inf
│   │   ├── Phase1InitComplete.vcxproj
│   │   └── Phase1InitComplete.vcxproj.filters
│   ├── Phase1InitComplete.sln
│   ├── README.md
│   └── images
│       ├── CallExNotifyCallback.png
│       └── LoaderParamBlock.png
├── README.md
├── TcpConnectionCallbackTemp
│   ├── README.md
│   ├── TcpConnectionCallbackTemp
│   │   ├── TcpConnectionCallbackTemp.c
│   │   ├── TcpConnectionCallbackTemp.inf
│   │   ├── TcpConnectionCallbackTemp.vcxproj
│   │   └── TcpConnectionCallbackTemp.vcxproj.filters
│   └── TcpConnectionCallbackTemp.sln
├── WdEbNotificationCallback
│   ├── README.md
│   └── images
│       ├── CallExNotifyCallback.png
│       ├── MpEbUnload.png
│       └── WdFilterCopyData.png
├── WdNriNotificationCallback
│   ├── README.md
│   └── images
│       ├── callback.png
│       └── callback_notif.png
└── WdProcessNotificationCallback
    ├── README.md
    ├── WdProcessNotificationCallback
    │   ├── WdProcessNotificationCallback.c
    │   ├── WdProcessNotificationCallback.inf
    │   ├── WdProcessNotificationCallback.vcxproj
    │   └── WdProcessNotificationCallback.vcxproj.filters
    ├── WdProcessNotificationCallback.sln
    └── images
        ├── obj_creation.png
        ├── poc.png
        ├── proc_create_notif.png
        ├── proc_create_notif2.png
        ├── proc_create_stack.png
        ├── proc_termination.png
        ├── refresh_proc.png
        ├── set_trusted.png
        ├── set_untrusted.png
        ├── set_untrusted_check.png
        └── stack_frames.png

```

`542875F90F9B47F497B64BA219CACF69/PGCbUtil/PgCbUtil.c`:

```c
#include <ntifs.h>
#include <ntstrsafe.h>


#define PG_CTX_PTAG         'xcgP'
#define PG_CTX_SZ           0x3f024
#define PG_CTX_RVA          0xCFC388  // Adapt RVAs
#define PG_CB_RVA           0x38BDE0
#define NT_DDI_WIN10_20H1   0xA000008 // Adapt DDI version


DRIVER_INITIALIZE   DriverEntry;
DRIVER_UNLOAD       DriverUnload;

typedef struct _SEC_PROCESSOR_INFO
{
    KAFFINITY   ActiveLogicalProcessor;
    USHORT      GroupCounter;
} SEC_PROCESSOR_INFO, *PSEC_PROCESSOR_INFO;

typedef struct _SEC_USERPROBE_INFO
{
    ULONG64 UserProbeAddress;
    __int64 PtrSize;
} SEC_USERPROBE_INFO, *PSEC_USERPROBE_INFO;

typedef union _SEC_PG_INFO
{
    SEC_PROCESSOR_INFO    SecProcessorInfo;
    SEC_USERPROBE_INFO    SecUserProbeInfo;
} SEC_PG_INFO, *PSEC_PG_INFO;

typedef struct _MSSEC_PG_CB_ARG1
{
    DWORD64         SizeOfStruct;
    DWORD64         NtDdiVersion;
    DWORD           Reserved80000h;
    int             UsePgCtxSize;
    __int64         field_18;
    int             field_20;
    int             field_24;
    int             field_28;
    int             Unknown1;
    DWORD           Option;
    DWORD           Reserved10h;
    PSEC_PG_INFO    SecPgInfo;
} MSSEC_PG_CB_ARG1, *PMSSEC_PG_CB_ARG1;

typedef struct _MSSEC_PG_CB_ARG2
{
    int     field_0;
    int     field_4;
    __int64 field_8;
    __int64 field_10;
    __int64 field_18;
    __int64 field_20;
    __int64 field_28;
} MSSEC_PG_CB_ARG2, *PMSSEC_PG_CB_ARG2;

typedef NTSTATUS(*PGCALLBACK)(PMSSEC_PG_CB_ARG1, PMSSEC_PG_CB_ARG2);

NTKERNELAPI
PVOID
NTAPI
RtlPcToFileHeader(
    _In_    PVOID  PcValue,
    _Out_   PVOID *BaseOfImage
);


PVOID GetNtoskrnlBaseAddress(VOID)
{
    PVOID NtoskrnlBaseAddress;
    
    return RtlPcToFileHeader((PVOID)RtlPcToFileHeader, &NtoskrnlBaseAddress);
}

BOOLEAN DumpPgCtx(
    _In_    ULONG_PTR   NtosKrnlBaseAddress
)
{
    UNICODE_STRING      DumpFileName;
    LARGE_INTEGER       Delay = { .QuadPart = 1 << 20 };
    LARGE_INTEGER       Offset = { .QuadPart = 0 };
    PULONG_PTR          pPgCtxAddr = NULL;
    PUCHAR              PgCtx;
    IO_STATUS_BLOCK     IoStatusBlock = { 0 };
    OBJECT_ATTRIBUTES   ObjAttrib = { 0 };
    HANDLE              hPgCtxDump;
    NTSTATUS            ntStatus;
    BOOLEAN             bRet = FALSE;

    PgCtx = (PUCHAR)ExAllocatePoolWithTag(NonPagedPoolNx, PG_CTX_SZ, PG_CTX_PTAG);
    if (NULL == PgCtx) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ "[PgCtxDump] Failed to allocate PgCtx pool.\n");

        return FALSE;
    }

    pPgCtxAddr = (PULONG_PTR)(NtosKrnlBaseAddress + PG_CTX_RVA);

    for (size_t i = 0; i < (1 << 10); i++) {
        if ((PVOID)*pPgCtxAddr != NULL) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ "[PgCtxDump] PgCtx address: %08llx\n",
                       *pPgCtxAddr);

            RtlCopyMemory(PgCtx, (PVOID)*pPgCtxAddr, PG_CTX_SZ);

            bRet = TRUE;

            break;
        } else {
            KeDelayExecutionThread(KernelMode, TRUE, &Delay);
        }
    }
    
    if (!bRet) {
        goto epilogue;
    }

    //
    // Adapt the path to dump file, if needed
    //
    if (RtlUnicodeStringInit(&DumpFileName, L"\\Device\\HarddiskVolume4\\PgCtx.dmp") != STATUS_SUCCESS) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ "[PgCtxDump] Failed to initialize file name\n");

        bRet = FALSE;

        goto epilogue;
    }

    ObjAttrib.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttrib.RootDirectory = NULL;
    ObjAttrib.ObjectName = &DumpFileName;
    ObjAttrib.Attributes = OBJ_CASE_INSENSITIVE;
    ObjAttrib.SecurityDescriptor = NULL;
    ObjAttrib.SecurityQualityOfService = NULL;
    ntStatus = ZwCreateFile(&hPgCtxDump,
                            GENERIC_WRITE,
                            &ObjAttrib,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_WRITE,
                            FILE_OVERWRITE_IF,
                            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0);
    if (ntStatus != STATUS_SUCCESS) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ "[PgCtxDump] Failed to create dump file %08lX\n",
                   ntStatus);

        bRet = FALSE;
    } else {
        RtlSecureZeroMemory(&IoStatusBlock, sizeof(IO_STATUS_BLOCK));
        ntStatus = ZwWriteFile(hPgCtxDump,
                               NULL,
                               NULL,
                               NULL,
                               &IoStatusBlock,
                               PgCtx,
                               PG_CTX_SZ,
                               &Offset,
                               NULL);

        if (ntStatus != STATUS_SUCCESS || IoStatusBlock.Status != STATUS_SUCCESS) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ "[PgCtxDump] ntStatus: %08lX IO_STATUS_BLOCK.Status: %08lX\n",
                       ntStatus,
                       IoStatusBlock.Status);

            bRet = FALSE;
        } else {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ "[PgCtxDump] PgCtx was successfully writen to %wZ\n",
                       DumpFileName);
        }

        NtClose(hPgCtxDump);
    }

epilogue:

    ExFreePoolWithTag(PgCtx, PG_CTX_PTAG);
    PgCtx = NULL;

    return bRet;
}

NTSTATUS ExecutePgCallback(
    _In_    ULONG_PTR   NtosKrnlBaseAddress
)
{
    INT                 Trials = 5;
    SEC_PG_INFO         SecPgInfo = { 0 };
    MSSEC_PG_CB_ARG1    MsSecPgArg1 = { 0 };
    MSSEC_PG_CB_ARG2    MsSecPgArg2 = { 0 };
    NTSTATUS            ntStatus = STATUS_UNSUCCESSFUL;
    PGCALLBACK          PgCb = NULL;

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_INFO_LEVEL,
               __FUNCTION__ "[PgCtxDump] KdDebuggerNotPresent: %hhu\n", *KdDebuggerNotPresent);

    PgCb = (PGCALLBACK)(NtosKrnlBaseAddress + PG_CB_RVA);

    MsSecPgArg1.SizeOfStruct = 0x40;
    MsSecPgArg1.NtDdiVersion = NT_DDI_WIN10_20H1;
    MsSecPgArg1.Reserved80000h = 0x80000;
    MsSecPgArg1.Reserved10h = 0x10;
    MsSecPgArg1.Option = 0;
    if (0 == MsSecPgArg1.Option) {
        SecPgInfo.SecUserProbeInfo.UserProbeAddress = MmUserProbeAddress;
        SecPgInfo.SecUserProbeInfo.PtrSize = 8;
    } else {
        SecPgInfo.SecProcessorInfo.GroupCounter = 0;
        SecPgInfo.SecProcessorInfo.ActiveLogicalProcessor = KeQueryGroupAffinity(0);
    }
    MsSecPgArg1.SecPgInfo = &SecPgInfo;    

    while (Trials--) {
        ntStatus = PgCb(&MsSecPgArg1, &MsSecPgArg2);
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ "[PgCtxDump] NtStatus: %08lx\n", ntStatus);
        if (STATUS_SUCCESS == ntStatus) {
            break;
        }
    }

    return ntStatus;
}

VOID DriverUnload(
    _In_    PDRIVER_OBJECT  DriverObject
)
{
    UNREFERENCED_PARAMETER(DriverObject);
}

NTSTATUS
DriverEntry(
    _In_    PDRIVER_OBJECT  DriverObject,
    _In_    PUNICODE_STRING RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    ULONG_PTR   NtosKrnlBaseAddress = 0;

    DriverObject->DriverUnload = DriverUnload;

    NtosKrnlBaseAddress = (ULONG_PTR)GetNtoskrnlBaseAddress();
    if (0 == NtosKrnlBaseAddress) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ "[PgCtxDump] Failed to get Ntoskrnl base address\n");
    } else {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ "[PgCtxDump] Ntoskrnl base address: %08llx\n",
                   NtosKrnlBaseAddress);

        DumpPgCtx(NtosKrnlBaseAddress);
        ExecutePgCallback(NtosKrnlBaseAddress);   
    }

    return STATUS_SUCCESS;
}
```

`542875F90F9B47F497B64BA219CACF69/PGCbUtil/PgCbUtil.inf`:

```inf
;
; PgCbUtil.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=PgCbUtil.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
PgCbUtil_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
PgCbUtil.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%PgCbUtil.DeviceDesc%=PgCbUtil_Device, Root\PgCbUtil ; TODO: edit hw-id

[PgCbUtil_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
PgCbUtil.sys

;-------------- Service installation
[PgCbUtil_Device.NT.Services]
AddService = PgCbUtil,%SPSVCINST_ASSOCSERVICE%, PgCbUtil_Service_Inst

; -------------- PgCbUtil driver install sections
[PgCbUtil_Service_Inst]
DisplayName    = %PgCbUtil.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\PgCbUtil.sys

;
;--- PgCbUtil_Device Coinstaller installation ------
;

[PgCbUtil_Device.NT.CoInstallers]
AddReg=PgCbUtil_Device_CoInstaller_AddReg
CopyFiles=PgCbUtil_Device_CoInstaller_CopyFiles

[PgCbUtil_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[PgCbUtil_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[PgCbUtil_Device.NT.Wdf]
KmdfService =  PgCbUtil, PgCbUtil_wdfsect
[PgCbUtil_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "PgCbUtil Installation Disk"
PgCbUtil.DeviceDesc = "PgCbUtil Device"
PgCbUtil.SVCDESC = "PgCbUtil Service"

```

`542875F90F9B47F497B64BA219CACF69/PGCbUtil/PgCbUtil.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29424.173
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PgCbUtil", "PgCbUtil.vcxproj", "{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Debug|x64.ActiveCfg = Debug|x64
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Debug|x64.Build.0 = Debug|x64
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Debug|x64.Deploy.0 = Debug|x64
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Debug|x86.ActiveCfg = Debug|Win32
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Debug|x86.Build.0 = Debug|Win32
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Debug|x86.Deploy.0 = Debug|Win32
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Release|x64.ActiveCfg = Release|x64
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Release|x64.Build.0 = Release|x64
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Release|x64.Deploy.0 = Release|x64
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Release|x86.ActiveCfg = Release|Win32
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Release|x86.Build.0 = Release|Win32
		{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A0628267-3FDE-4209-9573-B0D48FED73C5}
	EndGlobalSection
EndGlobal

```

`542875F90F9B47F497B64BA219CACF69/PGCbUtil/PgCbUtil.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{648C4A97-5FB5-43B0-84EF-D1D8201BB3F6}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PgCbUtil</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="PgCbUtil.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PgCbUtil.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`542875F90F9B47F497B64BA219CACF69/PGCbUtil/PgCbUtil.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="PgCbUtil.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PgCbUtil.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`542875F90F9B47F497B64BA219CACF69/PgCtx.h`:

```h
typedef struct _PgCtx
{
  BYTE                      CmpAppendDllSection[196];
  DWORD                     ContextSizeInQwords;
  INT64                     field_C8;
  INT64                     field_D0;
  INT64                     field_D8;
  INT64                     field_E0;
  PVOID                     ExAcquireResourceSharedLite;
  PVOID                     ExAcquireResourceExclusiveLite;
  PVOID                     ExAllocatePoolWithTag;
  PVOID                     ExFreePoolWithTag;
  PVOID                     ExMapHandleToPointer;
  PVOID                     ExQueueWorkItem;
  PVOID                     ExReleaseResourceLite;
  PVOID                     ExUnlockHandleTableEntry;
  PVOID                     ExAcquirePushLockExclusiveEx;
  PVOID                     ExReleasePushLockExclusiveEx;
  PVOID                     ExAcquirePushLockSharedEx;
  PVOID                     ExReleasePushLockSharedEx;
  PVOID                     KeAcquireInStackQueuedSpinLockAtDpcLevel;
  PVOID                     ExAcquireSpinLockSharedAtDpcLevel;
  PVOID                     KeBugCheckEx;
  PVOID                     KeDelayExecutionThread;
  PVOID                     KeEnterCriticalRegionThread;
  PVOID                     KeLeaveCriticalRegion;
  PVOID                     KeEnterGuardedRegion;
  PVOID                     KeLeaveGuardedRegion;
  PVOID                     MiUnlockWorkingSetCoreExclusive;
  PVOID                     ExReleaseSpinLockSharedFromDpcLevel;
  PVOID                     KeRevertToUserGroupAffinityThread;
  PVOID                     KeProcessorGroupAffinity;
  PVOID                     KeInitializeEnumerationContext;
  PVOID                     KeEnumerateNextProcessor;
  PVOID                     KeCountSetBitsAffinityEx;
  PVOID                     KeQueryAffinityProcess;
  PVOID                     KeQueryAffinityThread;
  PVOID                     KeSetSystemGroupAffinityThread;
  PVOID                     KeSetCoalescableTimer;
  PVOID                     HalPutDmaAdapter;
  PVOID                     ObReferenceObjectByName;
  PVOID                     RtlImageDirectoryEntryToData;
  PVOID                     RtlImageNtHeader;
  PVOID                     RtlLookupFunctionTableEx;
  PVOID                     RtlPcToFileHeader;
  PVOID                     RtlSectionTableFromVirtualAddress;
  PVOID                     DbgPrint;
  PVOID                     MmAllocateIndependentPages;
  PVOID                     MmFreeIndependentPages;
  PVOID                     MmSetPageProtection;
  INT64                     field_238;
  INT64                     field_240;
  INT64                     field_248;
  INT64                     field_250;
  INT64                     field_258;
  PVOID                     RtlLookupFunctionEntry;
  PVOID                     KeAcquireSpinLockRaiseToDpc;
  PVOID                     KeReleaseSpinLock;
  PVOID                     MmGetSessionById;
  PVOID                     MmGetNextSession;
  PVOID                     MmQuitNextSession;
  PVOID                     MmAttachSession;
  PVOID                     MmDetachSession;
  PVOID                     MmGetSessionIdEx;
  PVOID                     MmIsSessionAddress;
  PVOID                     MmIsAddressValid;
  PVOID                     MmSessionGetWin32Callouts;
  PVOID                     KeInsertQueueApc;
  PVOID                     KeWaitForSingleObject;
  QWORD                     field_2D0;
  PVOID                     ExReferenceCallBackBlock;
  PVOID                     ExGetCallBackBlockRoutine;
  PVOID                     ExDereferenceCallBackBlock;
  PVOID                     sub_FFFFF8062958AB50;
  PVOID                     PspEnumerateCallback;
  PVOID                     CmpEnumerateCallback;
  PVOID                     DbgEnumerateCallback;
  PVOID                     ExpEnumerateCallback;
  PVOID                     ExpGetNextCallback;
  PVOID                     xHalTimerWatchdogStop;
  PVOID                     KiSchedulerApcTerminate;
  PVOID                     KiSchedulerApc;
  PVOID                     xHalTimerWatchdogStop_;
  PVOID                     sub_FFFFF8062958BBC0;
  PVOID                     MmAllocatePagesForMdlEx;
  PVOID                     MmAllocateMappingAddress;
  PVOID                     MmMapLockedPagesWithReservedMapping;
  PVOID                     MmUnmapReservedMapping;
  PVOID                     PgKCalloutUmapReservedMapping;
  PVOID                     sub_FFFFF80629598300;
  PVOID                     MmAcquireLoadLock;
  PVOID                     MmReleaseLoadLock;
  PVOID                     KeEnumerateQueueApc;
  PVOID                     KeIsApcRunningThread;
  PVOID                     KeQsort;
  PVOID                     PsAcquireProcessExitSynchronization;
  PVOID                     ObDereferenceProcessHandleTable;
  PVOID                     PsGetNextProcess;
  PVOID                     PsQuitNextProcessThread;
  PVOID                     PsGetNextProcessEx;
  PVOID                     MmIsSessionLeaderProcess;
  PVOID                     PsInvokeWin32Callout;
  PVOID                     MmEnumerateAddressSpaceAndReferenceImages;
  PVOID                     PsGetProcessProtection;
  PVOID                     PsGetProcessSignatureLevel;
  PVOID                     PsGetProcessSectionBaseAddress;
  PVOID                     SeCompareSigningLevels;
  PVOID                     KeComputeSha256;
  PVOID                     KeComputeParallelSha256;
  PVOID                     KeSetEvent;
  PVOID                     RtlpConvertFunctionEntry;
  PVOID                     RtlpLookupPrimaryFunctionEntry;
  PVOID                     RtlIsMultiSessionSku;
  PVOID                     KiEnumerateCallback;
  PVOID                     KeStackAttachProcess;
  PVOID                     KeUnstackDetachProcess;
  PVOID                     KeIpiGenericCall;
  PVOID                     InitProbeAndLockMdl;
  PVOID                     MmGetPhysicalAddress;
  PVOID                     MmUnlockPages;
  PVOID                     VslVerifyPage;
  PVOID                     KiGetInterruptObjectAddress;
  INT64                     field_478;
  PVOID                     PsLookupProcessByProcessId;
  PVOID                     PsGetProcessId;
  PVOID                     MmCheckProcessShadow;
  PVOID                     MmGetImageRetpolineCodePage;
  INT64                     field_4A0;
  INT64                     field_4A8;
  INT64                     field_4B0;
  INT64                     field_4B8;
  PVOID                     qword_FFFFF80629E0F0C0;
  PVOID                     qword_FFFFF80629E12DE8;
  PVOID                     qword_FFFFF80629E12DF0;
  PVOID                     qword_FFFFF80629E12DF8;
  QWORD                     SystemEProcess;
  QWORD                     KiWaitAlways;
  PVOID                     *KiEntropyTimingRoutine;
  PVOID                     KiProcessListHead;
  PVOID                     KiProcessListLock;
  QWORD                     ObjectTypeRelated;
  INT64                     IoDriverObjectType;
  INT64                     PsProcessType;
  PVOID                     PsActiveProcessHead;
  PVOID                     PsInvertedFunctionTable;
  PVOID                     PsLoadedModuleList;
  PVOID                     PsLoadedModuleResource;
  PVOID                     PsLoadedModuleSpinLock;
  PVOID                     PspActiveProcessLock;
  PVOID                     PspCidTable;
  PVOID                     ExpUuidLock;
  PVOID                     AlpcpPortListLock;
  PVOID                     KeServiceDescriptorTable;
  PVOID                     KeServiceDescriptorTableShadow;
  PVOID                     KeServiceDescriptorTableFilter;
  PVOID                     VfThunksExtended;
  PVOID                     PsWin32CallBack;
  PPgFault                  pPgFault;
  PVOID                     KiTableInformation;
  PVOID                     HandleTableListHead;
  PVOID                     HandleTableListLock;
  INT64                     ObpKernelHandleTable;
  INT64                     KUserSharedData;
  INT64                     KiWaitNever;
  PVOID                     SeProtectedMapping;
  PVOID                     KiInterruptThunk;
  PVOID                     KiStackProtectNotifyEvent;
  INT64                     MmPteBase;
  PVOID                     NtImageBase;
  QWORD                     HalImageBase;
  PVOID                     KeNumberProcessors_0;
  PVOID                     g_PgCtx;
  PVOID                     qword_FFFFF80629EFC390;
  PINVERTED_FUNCTION_TABLE  RtlpInvertedFunctionTable;
  PVOID                     KiIsrThunkShadow;
  INT64                     field_620;
  INT64                     field_628;
  INT64                     field_630;
  INT64                     PrcbDpcStackOffset;
  INT64                     PrcbDpcRoutineActiveOffset;
  INT64                     CurrentThreadOffset;
  INT64                     field_650;
  INT64                     field_658;
  INT64                     field_660;
  INT64                     field_668;
  INT64                     field_670;
  INT64                     KthreadInitialStackOffset;
  INT64                     SchedulerApc;
  INT64                     ApcStateOffset;
  INT64                     EthreadStartAddressOffset;
  INT64                     EthreadTerminationPortOffset;
  INT64                     EthreadWin32StartAddressOffset;
  INT64                     ApcStateProcessOffset;
  INT64                     ProcessListEntryOffset;
  INT64                     Pcb_Visited_Offset;
  INT64                     EProcessFlags;
  INT64                     EProcessObjectTable;
  INT64                     ActiveProcessLinksOffset;
  INT64                     ProcessFlagsMask;
  INT64                     field_6E0;
  INT64                     field_6E8;
  INT64                     ObjectTypeTypeInfoOffset;
  INT64                     ObjectTypeCallbackListOffset;
  INT64                     field_700;
  INT64                     field_708;
  INT64                     field_710;
  INT64                     field_718;
  INT64                     ObjectTypeTypeFlagsOffset;
  INT64                     ObjectTypeSupportsObjectCallbacks;
  INT64                     CidTableIndex;
  INT64                     QuotaProcessOffset;
  INT64                     HandleTableListOffset;
  INT64                     field_748;
  INT64                     KldrDataTableEntryDllBaseOffset;
  INT64                     field_758;
  INT64                     field_760;
  INT64                     NonPagedPoolNxSz;
  INT64                     field_770;
  INT64                     field_778;
  INT64                     field_780;
  INT64                     field_788;
  INT64                     field_790;
  INT64                     field_798;
  INT64                     field_7A0;
  INT64                     field_7A8;
  INT64                     field_7B0;
  INT64                     field_7B8;
  INT64                     field_7C0;
  PVOID                     KernelCalloutAllocPool;
  INT64                     field_7D0;
  INT64                     field_7D8;
  INT                       field_7E0;
  INT                       SizeofAllPgEntries;
  INT64                     field_7E8;
  INT                       field_7F0;
  INT                       OffsetIpiTargetCall;
  INT64                     field_7F8;
  INT64                     field_800;
  INT                       SizeOfPgCtx;
  DWORD                     LoopCounter;
  INT                       LoadedModuleTag;
  INT                       RotNum;
  INT64                     LoopInitValue;
  INT                       MsSecArg2IterCondDefault;
  INT                       MsSecArg2Field4;
  INT                       MsSecRes80000_SumPgDataSizes;
  INT                       Reserved140000h;
  INT                       TypeProcessRelatedFlag;
  INT                       field_834;
  INT                       field_838;
  INT                       field_83C;
  INT64                     ImgIntegrityCounter;
  _KIDTENTRY64              IdtEntryIdx1;
  _KIDTENTRY64              IdtEntryIdx2;
  _KIDTENTRY64              IdtEntryIdx18h;
  SHORT                     NewIdtDescriptor1;
  CHAR                      PgSyscallHook;
  CHAR                      FeaturesActiveFlags;
  BYTE                      SyscallOpcode1;
  BYTE                      SyscallOpcode2;
  INT64                     NewIdtDescriptor2;
  INT64                     field_886;
  INT                       field_88E;
  CHAR                      field_892;
  CHAR                      field_893;
  CHAR                      field_894;
  CHAR                      field_895;
  CHAR                      field_896;
  CHAR                      field_897;
  INT64                     field_898;
  INT64                     field_8A0;
  SHORT                     field_8A8;
  SHORT                     StackSegmentReg;
  DWORD                     KInterruptDispatchOffset;
  DWORD                     KServiceRoutineOffset;
  DWORD                     KiIstStackSize;
  PVOID                     HalpPerfInterrupt;
  INT64                     field_8C0;
  PVOID                     NtosImageBase;
  PVOID                     NtosImageEnd;
  PVOID                     NtosNtImageHeaders;
  INT64                     pNewIdt;
  INT64                     pSyscall;
  INT                       PrcbNumber;
  INT                       field_8F4;
  INT                       SomethingWentWrong;
  INT                       field_8FC;
  INT64                     EncodedPointerPgCtxLocal;
  INT64                     EncodedPointerPgCtxEntry;
  INT64                     PgEntryType;
  INT64                     PgEntryData;
  INT                       field_920;
  INT                       KernelCalloutAllocType;
  INT64                     LockTypeSwitchValue;
  INT64                     PAGEVRF_Str;
  INT64                     PAGESPEC_Str;
  INT64                     INIT_Str;
  INT64                     PAGEKD_Str;
  INT                       ProcessTypeShiftConst;
  DWORD                     Magic_0x7E80690F;
  INT                       Win32CalloutFlag;
  INT                       field_95C;
  INT64                     field_960;
  INT64                     field_968;
  INT                       SessionState;
  INT                       Win32CalloutBlockSize;
  INT64                     Win32CalloutBlockStart;
  INT64                     SessionObject;
  INT64                     ProcShadowPid;
  INT                       GeneralFlags;
  INT                       ChecksStatusFlags;
  INT64                     field_998;
  INT64                     field_9A0;
  INT64                     field_9A8;
  INT64                     field_9B0;
  INT64                     field_9B8;
  INT64                     field_9C0;
  INT64                     field_9C8;
  INT64                     field_9D0;
  INT64                     field_9D8;
  INT64                     field_9E0;
  PVOID                     KiDispatchCallout;
  PVOID                     xHalTimerWatchdogStop;
  INT64                     field_9F8;
  INT64                     Type3ProcPushLock;
  INT64                     field_A08;
  PDWORD                    LocalAPICRelated;
  INT                       KCalloutAllocFailuresCounter;
  INT                       MaxPgEntriesSizeRelated;
  INT64                     field_A20;
  INT                       field_A28;
  INT                       OffsetStartPgEntries;
  INT64                     XoredRAXRDX;
  INT64                     XoredRAXRDX2;
  INT64                     MinimalBarrier;
  INT64                     field_A48;
  INT64                     field_A50;
  INT64                     field_A58;
  INT64                     ImgIntegrityPgCheckEntry;
  INT64                     MdlStartVaPlusByteOffset;
  INT64                     field_A70;
  PPgCtx                    pGlobalPgCtx;
  PPgCheckTypeEntry         pPgEntry;
  INT64                     PageHashMismatchRelated;
  DWORD64                   NonPagedPoolNxSize;
  INT64                     field_A98;
} PgCtx, *PPgCtx;

typedef struct _PgFault
{
  PVOID Ptr1;
  PVOID Ptr2;
  INT   Id1;
  INT   Id2;
  DWORD XoredChecksum;
} PgFault, *PPgFault;
```

`542875F90F9B47F497B64BA219CACF69/README.md`:

```md
# 542875F90F9B47F497B64BA219CACF69

## Intro

This research is focused only on the functionality of the `PatchGuard` callback (`542875F90F9B47F497B64BA219CACF69`) and how it is triggered. As a side effect we also present some details that apply to other components of `PatchGuard`, because they are needed to understand the functionality of the callback, so don't expect to have all the details of how `PatchGuard` works, what are its components and how they interact.

We tried making everything precise, clear and verifiable but there may be some details that we had to assume/deduce only from static analysis. If you observe any error or have any suggestion, please don't hesitate to contact us (or just submit a pull request). `PatchGuard` is in constant evolution thus take into account that it can differ between kernel versions. We used `Insiders Preview build 19018.vb_release.191101-1402` (`ntoskrnl` SHA256: `08BC2B81D8CD2EF30B6931F6BC1B6CA9CEFE39A61C1C2890169476F43374185A`).

> Everything we present here has been done only for research purposes and understanding, we never intended to find a way to bypass PatchGuard or find vulnerabilities in it.

## Callback creation and Mssecflt.sys

The callback object is created inside `ntoskrnl.exe` - `KiFilterFiberContext` function. To understand how you get there we recommend reading (at least page 9 - 10) [Updated Analysis of PatchGuard on Microsoft Windows 10 RS4](https://blog.tetrane.com/downloads/Tetrane_PatchGuard_Analysis_RS4_v1.01.pdf). We would like to point out that there's, probably an unintended, mistake in page 13 and 14 (below images). The callback object name is part of a `_UNICODE_STRING` structure that is going to be used in `_OBJECT_ATTRIBUTES` definition later passed to `ExCreateCallback`. So the _TV_ string is actually _Length_ and _MaximumLength_ field values inside the `_UNICODE_STRING` structure, the correct name of the callback is `542875F90F9B47F497B64BA219CACF69`.
![mistake1](images/mistake1.png)
![mistake2](images/mistake1b.png)

Searching for references to this callback object we found that `mssecflt.sys` (SHA256: `CF08F7FB7422DC75D6EBD1883402C191F47D122519AF1059BFBCF7BA184B2083`) is the only one registering to be notified. The callback object in `mssecflt.sys` is referenced by `SecInitializeKernelIntegrityCheck` function, which registers a callback function named `SecKernelIntegrityCallback`.
```C
void __fastcall SecKernelIntegrityCallback(
    PVOID CallbackContext,
    NTSTATUS (__fastcall *Argument1)(PMSSEC_PG_CB_ARG1, PMSSEC_PG_CB_ARG2),
    PULONG_PTR Argument2
)
{
  g_pPatchGuardCb = Argument1;
  *Argument2 = (unsigned __int64)&SecProtectedRanges;
}
```
The `Argument1` contains a function pointer (let's abstract it under `g_pPatchGuardCb` as we did in the above snippet) received from `ntoskrnl.exe` and it has 2 call references inside `mssecflt.sys`, functions: `SecKernelIntegrityCheck` and `SecDeferredIntegrityCheck`. To reach `SecDeferredIntegrityCheck` (1) an `APC` is inserted to the current thread inside `SecKernelIntegrityImmediateCheck` as can be seen below.
![insert_apc](images/insert_apc.png)

`SecKernelIntegrityImmediateCheck` is called inside `SecDetPerformImmediateAssertionsImpl` which is an [ExpandedStackCall](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nc-ntddk-expand_stack_callout?redirectedfrom=MSDN) routine. The predecessor nodes of the last routine are:

- `SecDetPerformImmediateAssertions`
- `SecObHandleOpenProcessCallbacks`
- `SecGetProcessContextWithAssertions`

We don't walk further on the call tree as it becomes intricate and it's not the focus of this research.

There are 2 other important paths that can reach to `PatchGuard` callback. Both of them start from `DriverEntry` and through `SecCreateDeviceObject` a [DRIVER_DISPATCH](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_dispatch) routine is registered. The dispatch routine (`SecDeviceOpen`) will handle `IRP_MJ_CREATE`. The paths split inside `SecInitialization`, the first branch (3) ends in `SecDetInitialize` which [allocates a timer](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatetimer). Timer's callback routine - `SecDetTimerCallback` - [allocates a work item](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-ioallocateworkitem) and [enqueues](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-ioqueueworkitem) it to `BackgroundWorkQueue`. The `WorkerRoutine` is `SecDetTimerPerformDeferredAssertions` which in the end reaches `SecKernelIntegrityCheck`. Second branch (2) ends in `SecCreateCommPorts` which creates a communication port named `\\MicrosoftSecFilterControlPort`. `FltCreateCommunicationPort` registers `SecMessage` as the `MessageNotifyCallback` for this port. When the notification callback is triggered, the execution flow joins the same path as in previous branch - creating a timer, work item and ending in `SecKernelIntegrityCheck`. All this can be seen in a simplified way through this call tree:
![seckernelintcheck_fct](images/seckernelintcheck_fct.png)
1. `APC`
2. `SecInitialization` second branch
3. `SecInitialization` first branch

### Invoking the callback

In order to understand the `PatchGuard` callback let's first understand how it is invoked by `mssecflt.sys`. The callback receives 2 arguments that are pointers to 2 custom structures. The definition of the callback is:
```C
NTSTATUS (__fastcall *)(PMSSEC_PG_CB_ARG1, PMSSEC_PG_CB_ARG2);
```

Both structures are initialized by `mssecflt.sys` before calling the callback. Some of the fields remain unknown to us. The definitions of these structures look like this:

```C
typedef struct _MSSEC_PG_CB_ARG1
{
  DWORD64       SizeOfStruct;
  DWORD64       NtDdiVersion;
  DWORD         Reserved80000h;
  INT           UsePgCtxSize;
  INT64         field_18;
  INT           field_20;
  INT           field_24;
  INT           field_28;
  INT           field_2c;
  DWORD         Option;
  DWORD         Reserved10h;
  PSEC_PG_INFO  SecPgInfo;
} MSSEC_PG_CB_ARG1, *PMSSEC_PG_CB_ARG1;

typedef struct _MSSEC_PG_CB_ARG2
{
  INT   field_0;
  INT   field_4;
  INT64 Counter;
  INT64 field_10;
  INT64 field_18;
  INT64 field_20;
  INT64 field_28;
} MSSEC_PG_CB_ARG2, *PMSSEC_PG_CB_ARG2;

typedef struct _SEC_PROCESSOR_INFO
{
  KAFFINITY ActiveLogicalProcessor;
  USHORT    GroupCounter;
} SEC_PROCESSOR_INFO, *PSEC_PROCESSOR_INFO;

typedef struct _SEC_USERPROBE_INFO
{
  PVOID UserProbeAddress;
  INT64 PtrSize;
} SEC_USERPROBE_INFO, *PSEC_USERPROBE_INFO;

typedef union _SEC_PG_INFO
{
  SEC_PROCESSOR_INFO SecProcessorInfo;
  SEC_USERPROBE_INFO SecUserProbeInfo;
} SEC_PG_INFO, *PSEC_PG_INFO;
```

Here's an example snippet of how the callback is being invoked inside `SecKernelIntegrityCheck`:
```C
  Counter = 0;
  *(_OWORD *)&MsSecPgArg1.UsePgCtxSize = 0ui64;
  *(_OWORD *)&MsSecPgArg2.field_0 = 0i64;
  *(_OWORD *)&MsSecPgArg2.field_10 = 0i64;
  *(_QWORD *)&MsSecPgArg1.field_24 = 0i64;
  MsSecPgArg2.Unknown0 = 0i64;
  MsSecPgArg1.Unknown1 = 0;
  LOBYTE(ntStatus) = KeAreApcsDisabled();
  if ( (_BYTE)ntStatus != 1 )
  {
    MsSecPgArg1.SizeOfStruct = 0x40i64;
    MsSecPgArg1.NtDdiVersion = 0xA000008i64;
    MsSecPgArg1.field_0x80000 = 0x80000;
    MsSecPgArg1.Option = a1_Option;
    MsSecPgArg1.Reserved10h = 0x10;
    MsSecPgArg1.SecPgInfo = a2_SecPgInfo;
    if ( !a2_SecPgInfo )
      MsSecPgArg1.SecPgInfo = a3_SecPgInfo;
    while ( 1 )
    {
      ntStatus = g_pPatchGuardCb(&MsSecPgArg1, &MsSecPgArg2);
      if ( ntStatus != (unsigned int)STATUS_MORE_PROCESSING_REQUIRED )
        break;
      if ( ++Counter > 5 )
        goto call_sec_inc_check_failed_count;
    }
    if ( ntStatus >= 0 )
      return ntStatus;
call_sec_inc_check_failed_count:
    SecIncrementCheckFailedCount();
  }
```

## PatchGuard Callback

Before digging into the callback, it's appropriate to mention that it is one of the biggest functions in the kernel. It is easy to observe that many parts of the callback are inlined functions making the analysis harder and more time consuming, same local variables (memory aliasing) are used in different checks (thus bound to different semantics). A couple of anti-debugging checks are in place, making dynamic analysis harder.
The callback is dependant on other components of `PatchGuard`, mainly the initialization routine which you can easily find after sorting functions by size and picking the biggest (exemplified in the image, all 3 functions are related to `PatchGuard`).
![pg_init](images/pg_init.png)

Most of the conditional behavior in the callback is controlled by flags that are set inside `PgInit` (which we didn't analyze), therefore there are some branches that we don't know how they are going to be reached.

Getting into the actual code, execution starts by checking the values of the arguments, status of APCs (disabled or not) and allocate a `NonPagePoolNx` pool with tag `tnIK` and size at least `0xAF0` bytes. The pool is an important component of the callback because it will contain a local copy of what we call `PatchGuard` context structure. The later structure contains the main elements used by `PatchGuard` during checks and is initialized in `PgInit`, its size is `0xAA0` bytes. Some definitions of `PatchGuard` context have been presented by other researchers before, but for convenience we include our own definition (which may contain some newly renamed fields while many of them are still unknown) - [PgCtx](PgCtx.h).

Next two important steps are selecting a session (if [SessionState](PgCtx.h#L305) value is not `-1`) and setting thread affinity group, these are well explained on page 42 - `8 - Setting the Thread Affinity group` in Tetrane's paper, so we're not going to repeat ourselves.

### Types of checks

As already known, the main goal of `PatchGuard` and by extension of this callback is to check the integrity of different system structures/components. To accomplish this task, `PatchGuard` uses different structures whose values are going to be interpreted to determine if there has been any modification in one of the system structures/components. These entries, which we defined as `PgCheckTypeEntry`, can represent one of the types enumerated as [Parameter 4 on CRITICAL_STRUCTURE_CORRUPTION](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0x109---critical-structure-corruption). Here you can see a simplified definition of these entries:
```C
typedef struct _PgCheckTypeEntry
{
  _PG_VERIFY_TYPE   Type;
  PVOID             Data;
  DWORD             DataSize;
  DWORD             CheckSum;
  DWORD             EntryConst1;
  DWORD             EntryConst2;
  DWORD             EntryConst3;
  DWORD             EntryConst4;
  DWORD             EntryConst5;
  DWORD             EntryConst6;
} PgCheckTypeEntry, *PPgCheckTypeEntry;
```
It is simplified, because based on our research we found that the fields can be used in different ways, which naturally made us think that this structure is actually an union of different types of entries. Another thing to keep in mind is that some of these entries have additional data after the actual structure (consider it as a header), thus `PatchGuard` needs a way to determine the offset to the next entry in order to iterate all of them. An example of how the callback computes the offset to the next entry based on the entry type can be found in a simple [Python script](pg_entry_dump.py) we developed.
The first `PgCheckTypeEntry` is located in memory immediately after `PgCtx` (whose size is kept in [SizeOfPgCtx](PgCtx.h#L239)), in other words obtaining the first `PgCheckTypeEntry` is resumed to:
```C
PPgCheckTypeEntry pFirstEntry = (PBYTE)PgCtx + PgCtx->SizeOfPgCtx;
```

Next we'll shortly explained how the check for each type is done. 
> `PatchGuard`, for many of the entries, uses a not well-known checksum algorithm, at least we coundn't identify it. A pseudocode implementation of the checksum can be found [here](checksum_algo.md). **From now on we will reference to this as `checksum algorithm`, unless otherwise stated**.

> Also, in every case where there is some corruption found in the system, the code will save the `bugcheck parameters` in the next fields of `PgCtx`:
> - PgCtx->EncodedPointerPgCtxLocal = BugcheckParameter1;
> - PgCtx->EncodedPointerPgCtxEntry = BugcheckParameter2;
> - PgCtx->PgEntryType              = BugcheckParameter3;
> - PgCtx->PgEntryData              = BugcheckParameter4;
>
> **From now on we will reference to this as `bugcheck parameters`**.

> One last remark, is that in every entry after the `bugcheck parameters` have been set, there's a call to a function which is defined as `__b8` in the symbols. We renamed this function to [`__b8_EncryptDecryptEntries`](crypt_decrypt.md), as can be seen in the pseudocode this function depends on bit `0x1e` on the flags set by PgInit, in our research the condition was never met but we skimmed through it statically and we believe is some kind of function to encrypt/decrypt the entries.

#### GenericDataRegion & GenericDataRegion1 & GenericSessionDataRegion

**GenericDataRegion** check starts by computing a checksum over the data that is being pointed by `PgCheckTypeEntry.Data`. If the computed checksum doesn't match with the expected checksum inside `PgCheckTypeEntry.CheckSum` execution continues to check every page which contains the data for this entry and call `VslVerifyPage`. In case the return value from the call is successful (`>= 0`) for all pages the check for this type of entry is finished. Otherwise `PgCtx.pPgFault.XoredChecksum` is used to save the xor result between `PgCheckTypeEntry.CheckSum` and the computed checksum, the `bugcheck parameters` are saved and `encrypt-decrypt entries` routine is called.

**GenericDataRegion1** check is done in an auxilliary function that we named `NTSTATUS __fastcall PgCbHandleGenericDataRegion1(PPgCtx, PPgCheckTypeEntry)`. The first part of the check is identifical as for **GenericDataRegion**. But as an additional check in this function, an special hash of the data will be computed inside `VOID __fastcall ComputeHash(PPgCtx, PVOID, SIZE_T, PVOID)` ([pseudocode](hash_algo.md)) this function will return a 16 bytes buffer that originates from a SHA-256 of the data , which will be checked against the expected value starting at `PgCheckTypeEntry.EntryConst1`. In the following image you can see one **GenericDataRegion1** entry that is going to be checked.
![gen_dataregion](images/gen_dataregion.png)

**GenericSessionDataRegion** can be checked in two ways. One of them is using the `checksum algorithm` and the other one is performed when [ChecksStatusFlags](PgCtx.h#L311) `& 4 != 0`. In the later case the check consists of an interation calling `MmIsAddressValid` on each page spanning the data. The check is successful if none of the calls to `MmIsAddressValid` fails.

#### TypeProcessList

In this section we will summarize how all the **TypeProcessList** checks are done (From `Type1ProcessList` to `Type5ProcessList`). All of these checks are quite similar but they differ on which processes list is going to be used for the check. First we will explain how the code determines if there is a misconfiguration then we will mention which list is used for each check. To detect if there's something anomalous, the list of all processes referenced by [PsActiveProcessHead](PgCtx.h#L144) is going to be iterated and set the value of `_EPROCESS.Pcb.Visited` to a value between 1 and 0x80 (it depends on the configuration). [Pcb_Visited_Offset](PgCtx.h#L195) is the offset to the needed field in `_EPROCESS`, while the address of `_EPROCESS` object is obtained by subtracting [ActiveProcessLinksOffset](PgCtx.h#L198) from the list iterator. This first part is going to be used as a reference in order to compare that `_EPROCESS.Pcb.Visited` field contains the previously set value by walking another list that links processes. After each comparison the value of that field is cleared. The lists for each check are:
- Type1ProcessList => [KiProcessListHead](PgCtx.h#L139)
- Type2ProcessList => [PspCidTable](PgCtx.h#L150)
- Type3ProcessList => [HandleTableListHead](PgCtx.h#L160)
- Type4ProcessList => In this case first iteration is over [HandleTableListHead](PgCtx.h#L160) and the second over [PsActiveProcessHead](PgCtx.h#L144)
- Type5ProcessList => No comparisons, just iterate [PsActiveProcessHead](PgCtx.h#L144) and clear the `Visited` field.

We think that `_EPROCESS.Pcb.Visited` is only to be used by `PatchGuard` for these checks. 

#### TypePool

All pool type checks use the `checksum algorithm`. The important thing to note here is that the checksum value is 8 bytes long and it starts at field `PgCheckTypeEntry.EntryConst1`. `PgCheckTypeEntry.Checksum` is unused although it's value can be different than 0. `PgCheckTypeEntry.EntryConst3` is the offset added to `PgCtx` start in order to find the start address of the pool. `PgCheckTypeEntry.EntryConst4` is the size of the pool (in bytes).

Next we have an example of **Type1Pool** entry where the offset to the start of the pool is `0xAA0` (which in this case is `sizeof(PgCtx)`) and added to start of `PgCtx` will sum up to the address of first entry to be checked (as explained [here](README.md#types-of-checks)). The curios property here is `Size` (or `PgCheckTypeEntry.EntryConst4`) which is `0` meaning that nothing is going to be checked. However the checksums are going to match, because the starting value (for the computed checksum) used in `checksum algorithm` is taken from [LoopInitValue](PgCtx.h#L243) which has the same value as the expected checksum.
![type_pool](images/type_pool.png)

Other types use the same algorithm.

#### CriticalMSR

For this check, the code will first get the `_GROUP_AFFINITY` of the processor specified in the `PgCheckTypeEntry.EntryConst2` using the call to `KeProcessorGroupAffinity`, with this value they will change the thread to that `_GROUP_AFFINITY`. Once this is done, the code will iterate over the MSRs to be checked, the number of MSRs is defined by `PgCheckTypeEntry.EntryConst1`. In this type the data is after the entry and it contains the following structure for each MSR:
```C
typedef struct _CriticalMSR
{
    QWORD   MsrValueMask;
    QWORD   ExpectedMsrValue;
    DWORD   MsrNumber;
} CriticalMSR, *PCriticalMSR;
```
Having this structure is pretty easy to understand how the check is done. In the normal scenario the value of the MSR will be read with `__readmsr`, this value will be masked with the field `MsrValueMask` and compared against `ExpectedMsrValue` in case they don't match the `bugcheck parameters` will be saved.

An example:
![critical_msr](images/critical_msr.png)

#### ProcessShadow

First, current's process `_EPROCESS` object is obtained using `_KPRCB`, [CurrentThreadOffset](PgCtx.h#L181), [ApcStateProcessOffset](PgCtx.h#L193) and [ApcStateOffset](PgCtx.h#L189). Next `MmCheckProcessShadow` is called and if the return value isn't `0xFFFFFFFF` the `bugcheck parameters` are saved (then expect the bugcheck). An interesting fact is that the return value is also going to be saved to`PgCheckTypeEntry.EntryConst1`. Before saving the parameters, a copy of the current `PgCheckTypeEntry` can be saved to the address pointed by [pPgEntry](PgCtx.h#L343), but this operation depends on the result of [GeneralFlags](PgCtx.h#L310) `& 0x40000000` being true.
When first call to `MmCheckProcessShadow` returns the expected value, execution continues by verifying if [ProcShadowPid](PgCtx.h#L309) isn't 0 and using it in a call to `PsLookupProcessByProcessId`, otherwise using `PsGetNextProcessEx` to obtain a pointer to a new `_EPROCESS` object. Next, `PsAcquireProcessExitSynchronization`, `KeStackAttachProcess`, `MmCheckProcessShadow`, `KeUnstackDetachProcess` and `ObDereferenceProcessHandleTable` are called in a loop that terminates when the count of iterations is greater than `0x100` or the return value is not `0xFFFFFFFF` (expect trouble) or `PsGetNextProcessEx` returns a `NULL`.
Lastly, after successfull execution of the above steps, the return value from `PsGetProcessId` is saved to [ProcShadowPid](PgCtx.h#L309), which makes us think that this field's purpose is to keep state of the last checked process.

#### RetpolineCodePage

`PgCheckTypeEntry.DataSize` has to be non-zero, otherwise the check skips this check entry. Next, depending on the value in [ChecksStatusFlags](PgCtx.h#L311) one of the first 32 bits inside `System` process object is set to 1. The pseudocode explains it better:
```C
if ( PgCtx->ChecksStatusFlags & 0x4000 )
{
  SystemEprocess = PgCtx->SystemEProcess;
  while ( 1 )
  {
    _disable();
    if ( !_interlockedbittestandset(SystemEprocess, (PgCtx->GeneralFlags >> 10) & 0x1F) )
      break;
    _enable();
    _mm_pause();
  }
}
```
In our test environment the clause wasn't satisfied so we couldn't check exactly which bit is going to be set.

If `PgCheckEntryType.EntryConst1`'s least significant bit is 1, the `checksum algorithm` is used on `PgCheckEntryType.Data` with size in `PgCheckEntryType.DataSize` and compare the result to `PgCheckEntryType.Checksum`, as we already learned before.
When that bit isn't set and [SessionObject](PgCtx.h#L308) was initialized (not 0), there are 2 possibilities, already known to us:
- use `checksum algorithm`
- use `MmIsAddressValid`

Which branch/method is chosen is subject to the value in [ChecksStatusFlags](PgCtx.h#L311) and some arithmethic computations like:
```C
v1202 = PgCtx->ChecksStatusFlags
...
if ( !((v1202 ^ (v1202 >> 3)) & 4) )
```
Or 
```C
v1202 = v1203 = PgCtx->ChecksStatusFlags;
v1203 = v1202 ^ (v1202 ^ (8 * v1203)) & 0x20;
PgCtx->ChecksStatusFlags = v1203;
```
when the `MSSEC_PG_CB_ARG2.Field4` is 0.

#### ExecutiveCallbackObject

This check is composed of two phases. First is the familiar `checksum algorithm`. The second phase consists of an iteration over an array of structures. The number of structures to iterate is defined by this relation `PgCheckTypeEntry.DataSize \ 16` where the definition of the structure is:
```C
typedef struct _ExecutiveCbObj
{
  PCALLBACK_OBJECT  CallbackObject;
  PUNICODE_STRING   CallbackName;
} ExecutiveCbObj, *PExecutiveCbObj; 
```
Calling `ExpEnumerateCallback` with the first argument `ExecutiveCbObj.CallbackObject` returns the `CallbackFunction` from [callback registration handle](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exregistercallback). The returned pointer (`CallbackFunction`) is then used as an argument to `RtlPcToFileHeader` which allows to obtain the base address of the module where the callback resides. If the last mentioned call fails `PgCheckTypeEntry.EntryConst1` will be assigned the `CallbackFunction` and `PgCheckTypeEntry.EntryConst3` will be assigned the callback registration handle (pointer to the object) before saving the `bugcheck parameters`.

![exec_cb_obj.png](images/exec_cb_obj.png)

#### ProcessorControlRegister & ExtendedProcessorCR

For both checks first they will get the `_GROUP_AFFINITY` of processor that's specified by `EntryConst6` and set the thread to that group and affinity. At this point is when the checks split, in the case of the **ExtendedProcessorCR** the code will get the `Extended Control Register` using `xgetbv` the value of `XCR0` will be composed and masked with the `_QWORD` starting from `PgCheckTypeEntry.EntryConst1`, this value will be compared agains the expected `XCR0` that was saved in `PgCheckTypeEntry.EntryConst3`. For the case of **ProcessorControlRegister** the control register to check is based on the flag inside `PgCheckTypeEntry.EntryConst5`, if the flag is set then the check will be on CR4 (`__readcr4`) in case is not set the check will be done on CR0 (`__readcr0`), again the value will be masked with the `_QWORD` from `PgCheckTypeEntry.EntryConst1` and compared against the expected Control Register saved in `PgCheckTypeEntry.EntryConst3`. In any case if they expected value doesn't match the `bugcheck parameters` will be populated accordingly.

#### PsWin32Callout

First check if the [Win32CalloutFlag](PgCtx.h#L301) is equal to `0xB` (we didn't find the meaning of this flag/value), if it's equal then get the [Callback Block](https://doxygen.reactos.org/dc/d8d/struct__EX__CALLBACK__ROUTINE__BLOCK.html) object referenced by [PsWin32CallBack](PgCtx.h#L157) with the function `ExReferenceCallBackBlock`, if a `Callback Block` is returned, then the callback function is retrieved using `ExGetCallBackBlockRoutine`. After, if `PgCheckTypeEntry.EntryConst1` (in this case it is a pointer spanning `EntryConst1` and `EntryConst2`) contains the expected function that's referenced by the callback, then they'll be compared. In case `PgCheckTypeEntry.EntryConst1` is NULL, then the code will check that the obtained callback is inside the range defined by [Win32CalloutBlockStart](PgCtx.h#L307) plus [Win32CalloutBlockSize](PgCtx.h#L306), in case this is correct then the obtained callback function will be saved in `PgCheckTypeEntry.EntryConst1`. In any other case the system will bugcheck.

#### SessionConfig

The shortest check, if [ChecksStatusFlags](PgCtx.h#L311) second least significant bit is not set or the call to `RtlIsMultiSessionSku` returns a value different than 0 - expect a bugcheck.

#### ObjectType

For this case `PgCheckTypeEntry.EntryConst1` represents a `_OBJECT_TYPE *` and the high word in `PgCheckTypeEntry.EntryConst3` is the expected value for `ObjectTypeFlags` (here known as `ExpectedTypeFlags`).

The given object is used along with [ObjectTypeTypeInfoOffset](PgCtx.h#L202) and [ObjectTypeTypeFlags](PgCtx.h#L208) offsets to compare the `_OBJECT_TYPE.TypeInfo.ObjectTypeFlags` with the expected one from `ExpectedTypeFlags`. If they aren't equal the bugcheck follows.
Next step is to check if `_OBJECT_TYPE.TypeInfo.SupportsObjectCallbacks` is not set and the object `CallbackList.Flink` is not pointing to itself then it will fail (bugcheck).

This is not the end, `checksum algorithm` is used to check for checksum matching. It is important to mention that after the entry header there's more data to be used in the following check.
The low word of `PgCheckTypeEntry.EntryConst3` is `Length` and `MaximumLength` for a `UNICODE_STRING` structure and the data after the entry header is the `UNICODE_STRING.Buffer`. The initialized structure is going to be used in a call to [ObReferenceObjectByName](https://doxygen.reactos.org/db/d18/obref_8c.html#a727c1f0726c97a4d0f526d541cee1f6a) and the obtained `ObjectPtr` will be compared to `PgCheckTypeEntry.EntryConst1` (the currently checked object). If the comparison is unsatisfied - bugcheck.

![objecttype](images/objecttype.png)

#### SystemServiceFunction

In this case, the data is right after the entry header and this data is composed of an array of structures, the number of elements from the array is determined by `0x10 * PgCheckTypeEntry->NextEntryConst2`, and the definition of the structure is as it follows:
```C
typedef struct _SystemServiceFunction 
{
    DWORD   ExpectedChecksum;
    DWORD   DataSize;
    PVOID   Data;
} SystemServiceFunction, *PSystemServiceFunction;
```

With this information the check will iterate over the array and use the `checksum algorithm` this time using `SystemServiceFunction.Data` instead of the `PgCheckTypeEntry.Data`.

#### LoadedModuleList

This check will start by getting a reference to the [PsLoadedModuleList](PgCtx.h#L146), after this the code will get the [RtlpInvertedFunctionTable](PgCtx.h#L174) from which it will obtain the `_INVERTED_FUNCTION_TABLE.CurrentSize` and the pointer to the TableEntry (Array of `_INVERTED_FUNCTION_TABLE_ENTRY`). Then a pool with tag [LoadedModuleTag](PgCtx.h#L241)(`rwPD`) and size `CurrentSize * 8` plus a pseudorandom generated number will be allocated, in this pool they will write what looks like to be random data, except for a certain area where they will save the `DllBase` of the loaded modules by iterating over the `PsLoadedModuleList` (This `_LIST_ENTRY` is the head of the structure [_KLDR_DATA_TABLE_ENTRY](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1909%2019H2%20(November%202019%20Update)/_KLDR_DATA_TABLE_ENTRY)) and checking if the `DllBase` is a Session Addres (`MmIsSessionAddress` -> `MiGetSystemRegionType`). This area of the pool will then be sorted with quicksort algorithm (Using a function pointed by the `PgCtx` we called [KeQsort](PgCtx.h#L95)). Lastly to check if everything is fine in the system, the check will iterate over the entries of the inverted table, getting their `_INVERTED_FUNCTION_TABLE_ENTRY.ImageBase` and checking if the previoulsy saved DllBases match any of the ImageBase from the InvertedTable. In case a DllBase from `PsLoadedModuleList` doesn't match any of the ImageBase of the inverted table the system will bugcheck. Here is a little snippet of how this works (Is not complete and some things have been vastly simplified):
```C
while (PsLoadedModuleList != LoadedModules->Flink) {
    DllBase = *(LoadedModules) + DllBaseOffset;
    if (!MmIsSessionAddress(DllBase)) {
        AllocatedPool + i = DllBase;
        i++;
    }
    LoadedModules = LoadedModules->Flink;
}
KeQsort(AllocatedPool);
while (InvertedTableEntries < InvertedTableEntries[CurrentSize]) {
    ImageBase = InvertedTableEntries->ImageBase;
    counter = i - 1;
    while(counter) {
        if (ImageBase == AllocatedPool + j) {
            break;
        }
        counter--;
    }
    if (!counter) {
        KeBugCheck(0x109)
    }
}
```

#### ImportTable & SessionImportTable

First part of the **ImportTable** consists in using the `checksum algorithm` (as in most of the cases over `PgCheckTypeEntry.Data` and length `PgCheckTypeEntry.DataSize`). However there's a small nuance, if `PgCheckTypeEntry.EntryConst1`'s least significant bit is set and the value pointed by [VfThunksExtended](PgCtx.h#L156) is not 0, execution flows into the second phase, otherwise - bugcheck.

Second part of this check is articuled by the call to `VOID __fastcall ComputeHash(PPgCtx, PVOID, SIZE_T, PVOID)` (mentioned before in **GenericDataRegion1**). The output from this call is compared to the expected value hosted by `PgCheckTypeEntry.EntryConst2` (and `PgCheckTypeEntry.EntryConst3`). Here, same nuance applies. If
```C
if ( !(PgCheckTypeEntry->EntryConst1 & 1) || !*PgCtx->VfThunksExtended )
```
is not satisfied, `VslVerifyPage` is called on every page that `PgCheckTypeEntry.Data` extends over. If all of the calls to `VslVerifyPage` return a value `>= 0` the bugcheck is avoided.

An example of an entry:
![imp_table](images/imp_table.png)

**SessionImportTable** is not much different, only that it prefixes the above steps with additional checks, that hopefully are better understood in pseudocode than words:
```C
if ( PgCheckType == SessionImportTable )
{
  if ( !PgCtx->SessionObject )
    goto nosessionobject;
  StatusFlags = PgCtx->ChecksStatusFlags;
  if ((PgCtx->ChecksStatusFlags >> 2) & 1)
    goto nosessionobject;
  if ( PgCtx->MsSecArg2Field4 ) // Field4 from MsSecArg2
  {
    if ( (StatusFlags >> 5) & 1 )
      goto nosessionobject;
  }
  else
  {
    PgCtx->ChecksStatusFlags = StatusFlags ^ (StatusFlags ^ (8 * StatusFlags)) & 0x20;
  }
}
```

#### InvertedFunctionTable

The initial step on this check is to execute the already known `checksum algorithm`. On the second step, the [RtlpInvertedFunctionTable](PgCtx.h#L174) will be obtained, and with it the pointer to the TableEntry and the CurrentSize, with these values the inverted function table entries will be iterated comparing the structure against the one pointed by `PgCheckEntryType.Data`, if none of the inverted function table entries matches the one in the `PgCheckEntryType.Data` the system will bugcheck. Finally, another check will be done, this one will again iterate over the inverted function table entries but in this case the check will obtain the ImageBase of the entry and check:
- If the ImageBase is page aligned.
- If the ImageBase address is bigger than the ImageBase + SizeOfImage.
- If the ImageBase address is less than the previous entry ImageBase + SizeOfImage (Entries in the Inverted Function Table are fill when the module is loaded).
- If the ImageBase+SizeOfImage is the same as the previous entry ImageBase + SizeOfImage.

For the last two check the entry has in `PgCheckEntryType.EntryConst3` and `PgCheckEntryType.EntryConst5` the ImageBase and the SizeOfImage of the next entry in the inverted function table.

If any of these checks is not satisfied then the loop will stop and the system will bugcheck (As a side note, both checks are done with IRQL/CR8 == 0xF).

> We strongly recommend reading this [article](http://uninformed.org/index.cgi?v=8&a=2&p=20) to learn more on Inverted Tables. 

![invfunctab](images//invfunctab.png)

#### LoadConfigDirectory

Abstracting some details that aren't critical for understanding the core idea (but important to determine the code path) of this check, it can be sliced in two:
- Use `checksum algorithm` on `PgCheckTypeEntry.Data` and compare the result with `PgCheckTypeEntry.Checksum`
- Depending on the value of `PgCheckTypeEntry.EntryConst5` (third LSb is set), compare `IMAGE_LOAD_CONFIG_DIRECTORY64.GuardCFCheckFunctionPointer` (the pointer to `IMAGE_LOAD_CONFIG_DIRECTORY64` is given in `PgCheckTypeEntry.Data`) with `PgCheckTypeEntry.EntryConst1` ([expected VA where CFG check function pointer is stored](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#load-configuration-directory)). Next compare `IMAGE_LOAD_CONFIG_DIRECTORY64.GuardCFDispatchFunctionPointer` with `PgCheckTypeEntry.EntryConst3` ([expected VA where CFG dispatch-function pointer is stored](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#load-configuration-directory)). If compared values aren't matching the system bugchecks.

#### DriverObject

If `PgCheckTypeEntry.DataSize` is 0, which means that this entry contains useful data immediately after the entry header. An `UNICODE_STRING` structure is initialized, `PgCheckEntryType.EntryConst5` represents `UNICODE_STRING.Length` and `UNICODE_STRING.MaximumLength`. `UNICODE_STRING.Buffer` is initialized to the after the entry header (basically `PPgCheckTypeEntry + 1`). This structure is an argument (formal parameter ObjectPath) to `ObReferenceObjectByName` call (where [IoDriverObjectType](PgCtx.h#L142) stands for ObjectType).
Next, calling `RtlLookupFunctionTableEx` with `ObReferenceObjectByName` pointer as first argument and second argument a structure whose second member will the base address of the module containing the function (in this case `Ntoskrnl`). Having the base address of the module, `RtlImageNtHeader` is called to obtain a pointer to `IMAGE_NT_HEADERS` and read `IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage`.
Same steps are repeated but calling `RtlLookupFunctionTableEx` with the pointer from `PgCheckEntryType.EntryConst1`. The end result is `IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage` of the driver.

Next, every entry in the dispatch table of the driver (`DRIVER_OBJECT.MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1]`) is checked for membership, in other words if the entry point of the function is not inside `Ntoskrnl`'s address space (for the default case when set to `nt!IopInvalidDeviceRequest`) or not inside driver's address space then a hijack is detected and the system bugchecks (the address of the function that isn't satisfying the constraint is saved to `PgCheckEntryType.EntryConst3`).

Next part of this check is determined by the following check:
```C
if ( !(PgCtx->GeneralFlags & 0x40000000) )
```
If the negation of the conjuction is true, `checksum algorithm` is used on `PgCheckTypeEntry.Data` and the result is saved to `PgCheckTypeEntry.Checksum`. Then using the same algorithm a new checksum is computed on the data from `DRIVER_OBJECT.FastIoDispatch` and size `FAST_IO_DISPATCH.SizeOfFastIoDispatch`, the result is saved to `PgCheckTypeEntry.EntryConst6` (__fast_io_checksum__). No comparisons.
Otherwise, if negation ends as false, the first part (the one checking the address space membership) is performed on `DRIVER_OBJECT.FastIoDispatch` and if successful the above __fast_io_checksum__ computation ends the check. If the any of those `FastIoDispatch` entries failed the test - expect a bugcheck.

#### ProcessorIDT

`PgCheckTypeEntry.EntryConst5` is the processor index used as second argument to `KeProcessorGroupAffinity`, the group affinity is set using `KeSetSystemGroupAffinityThread`. Before proceeding further, the `IDTR` and `GDTR` are saved. At a high level this check is an iteration over contents of the `IDT`, specifically `_KIDTENTRY64` entries.

After entering the loop, the `IRQL` is raised to 0xF. From the current (first) `IDT` entry, the address of the current (first) `ISR` is formed (`_KIDTENTRY64.OffsetHigh << 32 | _KIDTENTRY64.OffsetMiddle << 16 | _KIDTENTRY64.OffsetLow`) - let's name it `IdtIsr`. The address of the `ISR` corresponding to the current iteration (starting from 0) is obtained in this manner `&`[KiIsrThunkShadow](PgCtx.h#L175)`[8 * i]` - let's name it `IsrThunk`. If the `IdtIsr` isn't equal to `IsrThunk` a couple of checks follow. If one of the checks isn't satisfied - the system bugchecks.
At this state a bugcheck can be avoided if these conditions are satisfied:
- [NtosImageBase](PgCtx.h#L279) `< IdtIsr <` [NtosImageEnd](PgCtx.h#L280).
- The call to `RtlSectionTableFromVirtualAddress` ([NtosNtImageHeaders](PgCtx.h#L281) are available to use as first argument) must not fail to return a `PIMAGE_SECTION_HEADER`.
- `PIMAGE_SECTION_HEADER.Characteristics & IMAGE_SCN_MEM_DISCARDABLE` must be 0.
- `_KIDTENTRY64.Selector` must be 0x10 (code segment), `_KIDTENTRY64.Type & 0x1F00` must be 0xE00 (Interrupt Gate) and `_KIDTENTRY64.Present` equal to 1.
- `PRUNTIME_FUNCTION.BeginAddress` (obtained from a call to `RtlLookupFunctionEntry(IdtIst, ..., ...)`) added to `Ntoskrnl` base address must be equal to `IdtIsr`. (*)

(*) An important thing to notice, is that when the last check mentioned above is satisfiable and the execution context/state doesn't have a `KINTERRUPT` initialized (it is 0/NULL), execution increments the loop counter and moves the iterator to next `IDT` entry.

In case there's a `KINTERRUPT` available (**) more checks follow:
- `_KIDTENTRY64.Dpl` must not be 3 (user mode).
- `KINTERRUPT.DispatchAddress` (obtained using [KInterruptDispatchOffset](PgCtx.h#L274)) must be equal to `PRUNTIME_FUNCTION.BeginAddress` (obtained from `RtlLookupFunctionEntry(DispatchAddress, ..., ...)`) added to `Ntoskrnl` base address.
- The call to `RtlSectionTableFromVirtualAddress` must not fail to return a `PIMAGE_SECTION_HEADER`.
- `PIMAGE_SECTION_HEADER.Characteristics & IMAGE_SCN_MEM_DISCARDABLE` must be 0.
- If loop counter is 254 then `KINTERRUPT.ServiceRoutine` (obtained using [KServiceRoutineOffset](PgCtx.h#L275)) must be equal to [HalpPerfInterrupt](PgCtx.h#L277)

Now, when `IdtIsr` is equal to `IsrThunk` first check is to make sure `_KIDTENTRY64.Dpl` is not be 3 (user mode). In order to obtain `KINTERRUPT` structure for the current `ISR`, function `KiGetInterruptObjectAddress` is called (which explains **). After obtaining `KINTERRUPT.DispatchAddress` the next check is if the loop counter is less than 48, and if it is then `IdtIsr` and `DispatchAddress` are saved to the address pointed by [PgFaultArea](PgCtx.h#L158), the bugcheck will follow but not until the iterator is greater that 255 (size of `IDT`).

We reached the end part. Here 2 checksums are calculated (using `checksum algorithm`). First _checksum1_ is calculated for the first 53 entries in the `IDT`. Second _checksum2_ is for entry 225.
If _checksum1_ is not equal to `PgCheckTypeEntry.Checksum` or _checksum2_ is not equal to `PgCheckTypeEntry.EntryConst1` or `IDTR.Size` (saved at the start) is not equal to `PgCheckTypeEntry.EntryConst6` - expect a bugcheck.

The cherry on the cake is summarized in the following snippet:
```C
if ( PgCtx->FeaturesActiveFlags & 1 )
{
  _disable();
  IA32MSR = 0xC0000082i64;      // IA32_LSTAR_MSR
  pKiSyscall64 = __readmsr(0xC0000082);
  __writemsr(0xC0000082, &PgCtx->PgSyscallHook); // 0xC3 -> ret
  if ( !(PgCtx->ChecksStatusFlags & 0x20000) ) // (1)
  {
    Prcb = KeGetCurrentPrcb();
    *PgCtx->qword_FFFFF80629E0F0C0 = &PgCtx + 0xA3A03F5891C8B4E8;
    *PgCtx->qword_FFFFF80629E12DE8 = Prcb;
    *PgCtx->qword_FFFFF80629E12DF0 = 0xC0000082i64;
    Temp = PgCtx->qword_FFFFF80629E12DF8;
    *Temp = 0x112i64;                          // (1)
  }
  KeGuardDispatchICall(&PgCtx->SyscallOpcode1); // 0F 05 -> syscall
  if ( !(PgCtx->ChecksStatusFlags & 0x20000) ) // (2)
  {
    *PgCtx->qword_FFFFF80629E0F0C0 = 0xA3A03F5891C8B4E8ui64;
    *PgCtx->qword_FFFFF80629E12DE8 = 0i64;
    *PgCtx->qword_FFFFF80629E12DF0 = 0i64;
    *PgCtx->qword_FFFFF80629E12DF8 = 0i64;     // (2)
  }
  __writemsr(0xC0000082, pKiSyscall64);
  _enable();
}
```

It is not clear what is the precise purpose of this code, besides the fact that the value of `IA32_LSTAR_MSR` is changed to an address ([PgSyscallHook](PgCtx.h#L257)) inside `PgCtx` that contains opcode `0xC3` and the instruction called is `syscall` ([SyscallOpcode1](PgCtx.h#L259)). We suppose that this can be an attempt to detect MSR syscall hooks, but we're not sure. The fields marked by _(1)_ and _(2)_ left us with the thought that it may be an auxilliary location to save bugcheck parameters in case the `syscall` causes a bugcheck.

#### ProcessorGDT

After setting processor group affinity and thread affinity group (with `KeProcessorGroupAffinity` and `KeSetSystemGroupAffinityThread`), the `IDTR` and `GDTR` are saved. If second LSb in [FeaturesActiveFlags](PgCtx.h#L258) is set, a new `IDT` is initialized for entries with indexes 1, 2 and 0x18. What happens next is way easier to summarize with pseudocode than with words. So...
```C
NewIDT[1] = PgCtx->IdtEntryIdx1;
NewIDT[2] = PgCtx->IdtEntryIdx2;
NewIDT[0x12] = PgCtx->IdtEntryIdx18h;
NewIdtr.Size = 303;
NewIdtr.Base = NewIDT;
NewIDT[1].OffsetLow = &PgCtx->NewIdtDescriptor1;
NewIDT[1].OffsetMiddle = &PgCtx->NewIdtDescriptor1 >> 16;
NewIDT[1].OffsetHigh = &PgCtx->NewIdtDescriptor1 >> 32;
_disable();
__sidt(OriginalIdt);
__lidt(&NewIdtr);
__writedr(7u, 0i64);
NewIDT[1].OffsetLow = &PgCtx->NewIdtDescriptor2;           // unclear why this is done again?
NewIDT[1].OffsetMiddle = &PgCtx->NewIdtDescriptor2 >> 16;
NewIDT[1].OffsetHigh = &PgCtx->NewIdtDescriptor2 >> 32;
if ( PgCtx->FeaturesActiveFlags & 0x20 )
{
  PgCtx->StackSegmentReg = KiGetSs();
  __writedr(0, &PgCtx->StackSegmentReg);
  __writedr(7u, 0x70001ui64);
  PgCtx->pSyscall = KiErrataSkx55Present(&PgCtx->StackSegmentReg);
  __writedr(7u, 0i64);
  __writedr(0, 0i64);
}
else
{
  PgCtx->pSyscall = KiErrata704Present();
}
PgCtx->PrcbNumber = KeGetPcr()->Prcb.Number;
__lidt(OriginalIdt);
_enable();
```

Unregarding of the above case, next important events are reading of `LDTR` and `TR`. Then `checksum algorithm` is used to obtain the checksum over `GDT` and compare it against `PgCheckTypeEntry.CheckSum`, `GDTR.Size` is compared against `PgCheckTypeEntry.EntryConst6`, `LDTR` is compared for equality to 0, `TR` is compared for equality against 64. If any of the above checks are not satisfied the system will bugcheck.

#### ProtectedProcess

This check will iterate over the processes by calling the undocumented function [PsGetNextProcess](PgCtx.h#L98), for each retrieved `_EPROCESS`. The check has different branches but all of the will use the following functions (function names are quite self-explanatory):
- PsGetProcessProtection
- PsGetProcessSignatureLevel
- PsGetProcessSectionBaseAddress

With the values returned from this functions the code will proceed to check the ProcessProtection ([`_PS_PROTECTION`](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1909%2019H2%20(November%202019%20Update)/_PS_PROTECTION)), it focuses on two protection levels: 0x72 (`PS_PROTECTED_SYSTEM`) and 0x61 (`PS_PROTECTED_WINTCB_LIGHT`), then if this condition is satisfied they will proceed to compose the SignatureLevel and the SectionSignatureLevel based on the ProcessProtection obtained with `PsGetProcessProtection` and check if this composed value matches the ones obtained from `PsGetProcessSignatureLevel`. In case the `_EPROCESS` is not from System, then the code will call `MmEnumerateAddressSpaceAndReferenceImages` which seems to return some kind of structure with VADs from the process (we are not sure 100% how this functions works, but it seems to iterate over the VadRoot and save values from it into an allocated structure), this returned structure will then be iterated and the SignatureLevel or SectionSignatureLevel (it chooses one or the other based on a check using the previously obtained SectionBaseAddress) will be compared with another computed value from this VAD structure by using `SeCompareSigningLevels`. If something is wrong, this structure will be saved in `PgCheckEntryType.EntryConst3` and the anomalous entry will be saved in `PgCheckEntryType.EntryConst1`.

Is important to mention that this check is only done in the following cases:
- PsGetNextProcess returns NULL, in this case the check is done using the [SystemEProcess](PgCtx.h#L136) and checking for protection level `PS_PROTECTED_SYSTEM`
- When the `_EPROCESS` from PsGetNextProcess is the same one returned by `PsInvokeWin32Callout` with first parameter `0x1A`
- If the returned `_EPROCESS` is a LeaderProcess, check done by `MmIsSessionLeaderProcess`, and is related to SILO processes. The protection level checked is `PS_PROTECTED_WINTCB_LIGHT`

#### ModulePadding

In this check there's two possible ways of checking the data based on how it was initialized. In case `PgCheckEntryType.EntryConst4 == 0` then the check will obtain the data from an array of structures saved just after the entry header, the structure can be defined as it follows:

```C
typedef struct _ModulePaddingData
{
    DWORD   StartOffset;
    DWORD   EndOffset;
    DWORD   Checksum;
} ModulePaddingData, *PModulePaddingData;
```

the pointer where the `StartOffset` is going to be added is contained in `PgCheckEntryType.EntryConst1` and with this data the `checksum algorithm` will be executed. In the other case, where `PgCheckEntryType.EntryConst4 != 0` the array of structures is going to be pointed by `PgCheckEntryType.Data` and the definition of this structure resembles `_IMAGE_RUNTIME_FUNCTION_ENTRY` definition.

The number of entries comes defined by the relation `PgCheckEntryType.EntryConst4 / 0xC` with this information the code will iterate over the entries and again using `PgCheckEntryType.EntryConst1` as the base to add the `StartOffset` it will compute using the `checksum algorithm` but this time just for a byte that will be compared against the expected value that in this case is right after the entry header. Using this latter case to check doesn't mean the first is not going to be done, but in this case to get to the `ModulePaddingData` array the code will compute the offset in the data by using what looks like a magic number division (`0x2AAAAAAAAAAAAAAB`)

#### ImageIntegrity

Execution of this check is dependant on the value of `PgCheckTypeEntry.EntryConst3`. When the second least significat bit of the value is set and [ChecksStatusFlags](PgCtx.h#L311) has the third least significant bit set, first part of the check is an iteration that calls `MmIsAddresValid` on each page containing the data pointed by `PgCheckTypeEntry.Data`. In case none of the previously mentioned bits are set, `checksum algorithm` is used and the target value is in `PgCheckTypeEntry.Checksum`. These are to be considered part one.

In order to continue into part two, LSb of `PgCheckTypeEntry.EntryConst3` must be set, otherwhise this check is done. In continuation, `PgCheckTypeEntry.EntryConst1` represents the base address of the image to check and `RtlImageNtHeader` function is used to obtain a pointer to `IMAGE_NT_HEADERS` to which `IMAGE_NT_HEADERS.SizeOfOptionalHeader` is added to reach the first `IMAGE_SECTION_HEADER`. Starting from first section header a couple of checks are done (by order of occurence):
- `(IMAGE_NT_HEADERS.VirtualAddress + max(IMAGE_NT_HEADERS.VirtualSize, IMAGE_NT_HEADERS.SizeOfRawData)) & 0xFFFFF000` is computed in order to get the next section virtual address (RVA), in case the computed virtual address is `<= 0x1000` (usual RVA of the first section ) section iterator is incremented (moved) top the next section. If the check was done on the last section then iteration stops (and the whole check is done).
- Sections with `IMAGE_NT_HEADERS.Characteristics` having `IMAGE_SCN_MEM_DISCARDABLE` are ignored.
- Sections with `IMAGE_NT_HEADERS.Name` in this list (`[INITKDBG, PAGEwx, PAGEww, PAGEwr, ERRATA, PAGEVRF, PAGESPEC, INIT, PAGEKD]`) are ignored. As a side note, last 4 members are pointed by [PAGEVRF](PgCtx.h#L295), [PAGESPEC](PgCtx.h#L296), [INIT](PgCtx.h#L297), [PAGEKD](PgCtx.h#L298).
- Sections with `IMAGE_NT_HEADERS.Characteristics` having `IMAGE_SCN_MEM_WRITE` or not having `IMAGE_SCN_MEM_EXECUTE` are ignored.

If execution passes all required checks, next steps are orchestrated by the third LSb in [FeaturesActiveFlags](PgCtx.h#L258). Let's dissect first part, when that bit is set.
![func_int1](images/func_int1.png)
All squares in the image are BBs (basic blocks). _BB1_ checks for the bit mentioned above. _BB2_ initializes _ECX_ to the value that signifies `XBEGIN_STARTED`, then `xbegin` is executed with the fallback address being the start of next BB. In _BB3_ if _EAX_ (which contains RTM status) is not equal to `XBEGIN_STARTED` this means that there was an RTM abort and execution will continue in _BB5_, otherwise to _BB4_ which fetches a byte from the section data and executes `xend`, in case the transaction fails execution will end in _BB3_ as it is memorized as the fallback address, otherwise it will continue to _BB6_ - an incrementation block. Inside _BB5_ depending on the result of the check a new attempt to access the section data is going to be performed using a different method (starting in _BB7_).
The different method branches, too. Second branch is taken when the base address of the image to verify is [NtImageBase](PgCtx.h#L169) or [HalImageBase](PgCtx.h#L170) and the section name is not starting with `.eda` or `EGAP` (is it a mistake? did they meant `PAGE`?). An [MDL](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls) is initialized and then [MmGetPhysicalAddress](PgCtx.h#L119) is called. First branch is taken in other cases, and it consists of a call to the function that we named [InitProbeAndLockMdl](PgCtx.h#L118).
The prototype of the function can be defined as:
```C
NTSTATUS __fastcall PgCb_InitProbeAndLockMdl(PMDL Mdl, PVOID ImgBaseAddress)
```
If the return status is `STATUS_ACCESS_VIOLATION` and `PgCheckTypeEntry.EntryConst3 & 4` is 0 then the system bugchecks. This last check involves an additional check (in case `EntryConst3 & 4` isn't 0) for section characteristics having `IMAGE_SCN_MEM_WRITE` that leads to the bucheck, too. (Clear thing the last sentence contradicts in one case with what we said above, but not to make our explanation "spaghetti" we leave this corner case unexplained).

After any of the above two branches (part of the second method) is executed, an _barrier_ is initialized with a call to `RtlInitMinimalBarrier(&`[MinimalBarrier](PgCtx.h#L335), *[KeNumberProcessors_0](PgCtx.h#L171)`)`. Next is a call to `KeIpiGenericCall(&PgCtx + `[OffsetIpiTargetCall](PgCtx.h#L236)`)`. We tried to get the code that is going to be executed, but the results were evidently wrong, probably the offset we had was wrong or we commited another mistake.

When all the sections are verified the check is done.

#### FunctionOrPdata & FunctionOrPdata1 & SessionFunctionOrPdata

We will analyze this three checks together since they are quite similar, first **SessionFunctionOrPdata** will check if there is a [SessionObject](PgCtx.h#L308) in case there is no the check will jump into the general check, if there is a session object, the page aligned data will be obtained from `PgCheckEntryType.Data` and passed as an argument to `MmIsAddressValid` in case this function fails the system will bugcheck, if it doesn't fail then the `checksum algorithm` will be applied with the `PgCheckEntryType.Data` and `PgCheckEntryType.DataSize`. 

For cases **FunctionOrPdata** and **FunctionOrPdata1**, both will start by first doing the already known `checksum algoritm` if everything is correct, then the paths will split. We will first focus on the **FunctionOrPdata** which is a bit more simple. For this check, the `PgCheckEntryType.Data` points to an array of `_IMAGE_RUNTIME_FUNCTION_ENTRY` structures:
```C
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY
{
    ULONG BeginAddress;
    ULONG EndAddress;
    union
    {
        ULONG UnwindInfoAddress;
        ULONG UnwindData;
    };
} IMAGE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_RUNTIME_FUNCTION_ENTRY;
```
with this structure and taking into account that the base address of the module where the function or data is located is in the field `PgCheckEntryType.EntryConst3`, the code will iterate each entry of the array and use the `checksum algorithm` to prove if the expected checksum is obtained, this expected checksums are saved in order after the entry header. 

For **FunctionOrPdata1**, the check will be mostly handled on an auxiliary function we called `int __fastcall PgCbHandleFunctionOrPdata1(PPgCtx PgCtx, PVOID FunctionOrData, unsigned int FunctionOrDataSize)`. This function, will first obtain a pointer to the `FunctionOrData - 0x6`. With this pointer the code will check if the 6 bytes before the `FunctionOrData` match the following pattern: `4C 87 00 98 C3 [90|F1]`. If the pattern doesn't match then they will use 0 as the key value to calculate the hash, in case the pattern condition is satisfied then the function will call `__int64 __fastcall KiAccessPage(__int64 (__fastcall *Pattern)(), PVOID pFunctionOrPdata, _QWORD FunctionOrPdata)` this function is quite small, and inlining the `Pattern` it will look something like this:

```asm
48 83 EC 28             sub    rsp, 0x28
48 8b C2                mov    rax, rdx
FF D1                   call   rcx
    4C 87 00                xchg qword ptr [rax], r8
    98                      cwde
    C3                      ret
    90                      nop
49 83 C9 FF             or     r9, 0xffffffffffffffff
48 92                   xchg   rdx, rax
98                      cwde
48 3B C2                cmp    rax, rdx
49 8B C1                mov    rax, r9
49 0F 44 C0             cmovz  rax, r8
48 83 C4 28             add    rsp, 0x28
C3                      ret
```

This snippet will basically return the first 8 bytes from the function or pdata, and in this case this value is the one that's going to be used as the key to calculate the checksum that will be returned from `PgCbHandleFunctionOrPdata1`. Before comparing this checksum agains the expected value (As in **FunctionOrPdata** the expected checksum is after the entry header) the check will again test if the `FunctionOrPdata - 0x6` match the pattern and in case it does it will compose a new idt decriptor for `INT 01`, modify the `IDTR`, write `0xF1` in the `FunctionOrPdata - 0x1` and call the function `KeDispatchCall(pFunctionOrPdataMinusOne)`. Since `OxF1 == icebp` which triggers an `INT 01`, the trap will be handled by the new `ISR`. This can be seen in the following pseudocode (similar to IDT and GDT case):

```C
NewIdtBase[1]  = PgCtx->IdtEntryIdx1;
NewIdtBase[2]  = PgCtx->IdtEntryIdx2;
NewIdtBase[18] = PgCtx->IdtEntryIdx18h;
NewIdtr.Size = 303;
NewIdtr.Base = NewIdtBase;
NewIdtBase[1].OffsetLow    = &PgCtx->IdtEntryIdx1Offset;
NewIdtBase[1].OffsetMiddle = &PgCtx->IdtEntryIdx1Offset >> 16;
NewIdtBase[1].OffsetHigh   = &PgCtx->IdtEntryIdx1Offset >> 32;
__sidt(Idtr);
__lidt(&NewIdtr);
*(ptrFuncOrPdata - 1) = 0xF1;
if ( !(PgCtx->ChecksStatusFlags & 0x20000) )
{
  Prcb = KeGetCurrentPrcb();
  *PgCtx->qword_FFFFF80629E0F0C0 = PgCtx + 0xA3A03F5891C8B4E8ui64:
  *PgCtx->qword_FFFFF80629E12DE8 = Prcb;
  *PgCtx->qword_FFFFF80629E12DF0 = ptrFuncOrPdata;
  *PgCtx->qword_FFFFF80629E12DF8 = 0x113i64;
}
KeGuardDispatchICall(ptrFuncOrPdata);
if ( !(PgCtx->ChecksStatusFlags & 0x20000) )
{
  *PgCtx->qword_FFFFF80629E0F0C0 = 0xA3A03F5891C8B4E8ui64;
  *PgCtx->qword_FFFFF80629E12DE8 = 0i64;
  *PgCtx->qword_FFFFF80629E12DF0 = 0i64;
  *PgCtx->qword_FFFFF80629E12DF8 = 0i64;
}
```

Finally, for both **FunctionOrPdata** and **FunctionOrPdata1** if everything went right until this point there's one last check this time using the `RtlpInvertedFunctionTable`. For this check, the inverted function table entries will be iterated comparing them with the value pointed by `PgCheckEntryType.EntryConst1`, if all of the entries of the inverted function table are check and no one matches then the system will bugcheck (Similar to the InvertedFunctionTable case).

#### LocalAPIC

`PgCheckTypeEntry.EntryConst5` is the processor index used as second argument to `KeProcessorGroupAffinity`, the group affinity is set using `KeSetSystemGroupAffinityThread`. If [LocalAPICRelated](PgCtx.h#L327) is available the value of `IA32_X2APIC_LVT_TIMER` MSR is read from [LocalAPICRelated](PgCtx.h#L327)`[200]` otherwise `__readmsr(0x832)` is in charge. As before is proceeded for `IA32_X2APIC_LVT_PMI`. Group affinity is restored by calling `KeRevertToUserGroupAffinityThread` and we're for the next part.

If [FeaturesActiveFlags](PgCtx.h#L258) has fifth LSb set, a new `IDT` is initialized for entries with indexes 1, 2 and 0x18. The original `IDTR` is saved then the new one is loaded. In between two conditional blocks a call to `KiErrata361Present()` is squeezed. As in other similar cases an example of pseudocode makes it easier to comprehend:
```C
_disable();
pNewIdt[1] = PgCtx->IdtEntryIdx1;
pNewIdt[2] = PgCtx->IdtEntryIdx2;
pNewIdt[0x12] = PgCtx->IdtEntryIdx18h;
NewIdtr.Size = 303;
NewIdtr.Base = pNewIdt;
pNewIdt[1].OffsetLow = &PgCtx->NewIdtDescriptor1;
pNewIdt[1].OffsetMiddle = &PgCtx->NewIdtDescriptor1 >> 16;
pNewIdt[1].OffsetHigh = &PgCtx->NewIdtDescriptor1 >> 32;
__sidt(OriginalIdtr);
__lidt(&NewIdtr);
if ( !(PgCtx->ChecksStatusFlags & 0x20000) )
{
  CurrentPcrb = KeGetCurrentPrcb();
  *PgCtx->qword_FFFFF80629E0F0C0 = &PgCtx + A3A03F5891C8B4E8h;
  *PgCtx->qword_FFFFF80629E12DE8 = CurrentPcrb;
  *PgCtx->qword_FFFFF80629E12DF0 = 0i64;
  *PgCtx->qword_FFFFF80629E12DF8 = 0x115i64;
}
KiErrata361Present();
if ( !(PgCtx->ChecksStatusFlags & 0x20000) )
{
  *PgCtx->qword_FFFFF80629E0F0C0 = 0xA3A03F5891C8B4E8ui64;
  *PgCtx->qword_FFFFF80629E12DE8 = 0i64;
  *PgCtx->qword_FFFFF80629E12DF0 = 0i64;
  *PgCtx->qword_FFFFF80629E12DF8 = 0i64;
}
__lidt(OriginalIdtr);
_enable();
```

The disassembled code located at [NewIdtDescriptor1](PgCtx.h#L256) is:
```asm
48 CF              iretq
```
And the code of `KiErrata361Present` is (left some pointers to a future us/me):
```asm
000 8C D0                   mov     eax, ss
000 9C                      pushfq
008 81 0C 24 00 01 00 00    or      dword ptr [rsp], 100h        // TF set
008 9D                      popfq
000 8E D0                   mov     ss, eax                      // read "Intel Manual: Interrupt 1 Debug Exception.Program State Change"
000 F1                      icebp                                // doesn't modify TF: http://www.rcollins.org/secrets/opcodes/ICEBP.html
000 9C                      pushfq
008 81 24 24 FF FE FF FF    and     dword ptr [rsp], 0FFFFFEFFh  // clear TF
008 9D                      popfq
000 C3                      retn
```

Next, if any of the following clauses aren't satisfied, the system bugchecks.
```C
ExpectedLapicValue = PgCheckTypeEntry->EntryConst1;
if ( (LapicLvtTimerValue & PgCheckTypeEntry->EntryConst2) != ExpectedLapicValue
  || !_bittest(&LapicLvtTimerValue, 0x10u) && LapicLvtTimerValue != 0xD1 && (LapicLvtTimerValue + 3) > i )
```
```C
ExpectedPmiValue = PgCheckTypeEntry->EntryConst3;
if ( (LapicPmiValue & PgCheckTypeEntry->EntryConst4) != ExpectedPmiValue
  || !_bittest(&LapicPmiValue, 0x10u) && LapicPmiValue != 0xD1 && (LapicPmiValue + 3) > i )
```

#### PageHashMismatch

For this check the callback will use another auxiliary function which we renamed as `VOID __fastcall PgCbHandlePageHasMismatch(PPgCtx PgCtx, PPgCheckTypeEntry PgCheckTypeEntry)`. This function will first obtain a pointer to data after the entry header which will contain an array of structures with the precomputed hashes, this structure has the following definition:

```C
typedef struct _PageHashMismatchEntry 
{
    BYTE    ModifiedSha256[0x10];
    DWORD   CrcHash;
} PageHashMismatchEntry, *PPageHashMismatchEntry
```
On the other hand, from `PgCheckEntryType.EntryConst3` the function will obtain the ImageBase of the module to check and from `PgCheckEntryType.EntryConst5` the size of it. With this information the check will proceed to compute a pseudorandom number which will act as the index for the array and also the offset that's going to be added to the ImageBase, with this it will execute the `checksum algorithm` and see if the one calculated from that offset in the ImageBase matches the corresponding with the `PageHashMismatchEntry.CrcHash` for that index. If the check succeed, then it will proceed to compute the Modified SHA256 with the function `ComputeHash`, passing as the data to hash the `ImageBase+Offset` and as the size one page (`0x1000`, the digest is going to be checked against `PageHashMismatchEntry.ModifiedSha256`.

If everything is fine then the function will proceed with another check, this next check is based on the inverted function table, and is very similar to the other cases where we explained this. From `PgCheckEntryType.EntryConst1` the function will obtain a `INVERTED_FUNCTION_TABLE_ENTRY`, and it will iterate over the entries in the `INVERTED_FUNCTION_TABLE RtlpInvertedFunctionTable`, if none of them matches the one from `PgCheckEntryType.EntryConst1` then the system will bugcheck.

There's one last case, which will proceed almost the same as the one explained above, with the CRC and the modified SHA256 but this time some data will be saved (PageBase, SizeOfPage, ModifiedSha256) in an array of structures which is pointed by [PageHashMismatchRelated](PgCtx.h#L344) also in this case the Modified Sha256 is calculated and saved in the structure in a function we named `PgComputeParallelSha256Derivation`

![page_hash_mismatch](images/page_hash_mismatch.png)

#### KernelNotificationCallout

This check logically can be split in two parts. The first part is basically in charge of checking different types of callbacks. Which type of callback is checked depends on the value coming from `MSSEC_PG_CB_ARG2.field4`. For example, when the value is _0_ - `CmpEnumerateCallback` is going to be verified. Every check can be grossly seen as an iteration over every entry (callback routine) and a call to [RtlPcToFileHeader](https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-rtlpctofileheader). The failing case of every check is when the return value from the call is `NULL` (as specified in the documentation), which means that the callback is not inside a module. 
Here's a short snippet of how a check is done:
```C
CallbackIterator = NULL;
CurrIrql = KeGetCurrentIrql();
__writecr8(0xC);
for (CallbackAddress = PgCtx->DbgEnumerateCallback(&CallbackIterator);
     CallbackAddress;
     CallbackAddress = PgCtx->DbgEnumerateCallback(&CallbackIterator))
{
  if (!PgCtx->RtlPcToFileHeader(CallbackAddress, &BaseAddress))
  {
    // copy entries of current PgCheckTypeEntry to PgCtx
    // encode pointers...
    ...
    PgCtx->SomethingWentWrong = 1;
    ...
  }
}
__writecr8(CurrIrql);
goto check_if_SomethingWentWrong_is_set;
```

Here is a list of all callbacks that we saw being checked:
- CmpEnumerateCallback
- DbgEnumerateCallback
- PspEnumerateCallback
- KiEnumerateCallback
- ExpGetNextCallback

An additional check is done before getting into the second part. When `PgCheckTypeEntry.EntryConst5` is not _0_, its value is compared to the value of [PgCtx->KiEntropyTimingRoutine](PgCtx.h#L138) (which is a pointer to a pointer to `cng!EntropyTimingCallback`). These values are expected to be the same.

Second part, consists of a series of `PgCheckTypeEntry` initializations. One important thing to mention here is that an auxilliary function is used for extending the `PgCtx` (along with every `PgCheckTypeEntry`) in order to store the new entry/entries that is/are going to be initialized. The contents of the previous pool are copied into the new one, and the previous is cleared. We're not going to dwelve into the internals of this function (we named `PgKCalloutAllocPool`)*, but for the curios ones it's located at (RVA) `+0x8BDB30` and it has the following prototype:
```C
PPgCtx __fastcall PgKCalloutAllocPool(
  PPgCtx PgCtx,
  ULONG NewSize,
  ULONG AllocationType
);
```

These are the types that can be initialized:
- LoadConfigDirectory
- ModulePadding
- GenericDataRegion, GenericSessionDataRegion
- ImageIntegrity
- RetpolineCodePage
- ImportTable, SessionImportTable
- PageHashMismatch, SessionPageHashMismatch
  > The initialization of this entries is done inside another function* that can be found at (RVA) `+0x8C69E4`.
- FunctionOrPdata, SessionFunctionOrPdata, FunctionOrPdata1
  > The initialization of this entries is done inside another function* that can be found at (RVA) `+0x8BD098`.

Our guess about why these entries can be initialized in this check is that all of them are _volatile_ / _dynamic_ entries. What we mean by this is the during the execution cycle the number of modules, import tables and so on may change.

\* All these functions can be called from other `PatchGuard` functions.

#### Rest of Type Checks

During the research we notice that some of the checks were always ending in the same piece of code, this code just check if something is wrong ([SomethingWentWrong](PgCtx.h#L286) `!= 0`) and if it's the case it Bugchecks. It seems that this types won't be checked on this callback (Probably they are verified on another `PatchGuard` verify routine). The list of types that end up here is the following:
- DebugRoutine
- ProcessorIVT
- DebugSwitchRoutine
- IRPAllocator
- DriverCallDispatcher
- IRPCompletionDispatcher
- IRPDeallocator
- CriticalFloatingPointCR
- SessionPageHashMismatch
- GeneralPool
- Win32k
- ProcessorMisconfiguration


### Ending notes

Did we explain everything? No! Of course some details were left over and some details may be incomplete (we hope not incorrect). Please keep in mind that only this callback is decompiled to more than 9k lines of pseudocode (which of course helps a lot), which are hard to debug or in some cases impossible (mostly because some entry types are missing).

Also, we are still missing one (quite long) check, KernelNotificationCallout. We will update the README with this check soon :)

We are open to discuss more, hear any suggestions or corrections. Please don't hesitate to contact us!

### Acknowledgements

- HexRays team for IDA Pro and its decompiler.
- Satoshi Tanda [Some Tips to Analyze PatchGuard](http://standa-note.blogspot.com/2015/10/some-tips-to-analyze-patchguard.html)
- Tetrane [Updated Analysis of PatchGuard on Microsoft Windows 10 RS4](https://blog.tetrane.com/2019/Analysis-Windows-PatchGuard.html)
- [ReactOS](https://doxygen.reactos.org/)
- [Vergilius Project](https://www.vergiliusproject.com/)
- Microsoft PatchGuard team for developing a nice piece of engineering.

With love from [@n4r1b](https://twitter.com/n4r1b) & [@0xcpu](https://twitter.com/0xcpu) .

```

`542875F90F9B47F497B64BA219CACF69/checksum_algo.md`:

```md
```C
PgEntryData = PgEntry->Data;
PgEntry_DataSize = PgEntry->DataSize;
PgEntryData_1 = PgEntryData;
PgCtx->MsSecRes80000_SumPgDataSizes += PgEntry_DataSize;
_RAX = PgEntryData;
NumRot = PgCtx->RotNum;
for (i = PgCtx->LoopInitValue; _RAX < PgEntryData + PgEntry_DataSize; _RAX += 64)
    __asm { prefetchnta byte ptr [rax]}
    LoopInitValue = PgCtx->LoopInitValue;
Iterations = PgEntry_DataSize >> 7;
if (PgEntry_DataSize >> 7)
{
    do
    {
        Iterations_1 = 8;
        do
        {
            Temp = PgEntryData_1[1] ^ __ROL8__(*PgEntryData_1 ^ LoopInitValue, NumRot);
            PgEntryData_1 += 2;
            LoopInitValue = __ROL8__(Temp, NumRot);
            --Iterations_1;
        } while (Iterations_1);
        *Temp = (__ROL8__(i ^ (PgEntryData_1 - PgEntryData_11), 17) ^ i ^ (PgEntryData_1 - PgEntryData)) * 0x7010008004002001;
        Temp2 = LOBYTE(Temp1[0]) ^ LOBYTE(Temp1[1]) ^ NumRot;
        LODWORD(Temp1[1]) = 1;
        NumRot = Temp2 & 0x3F;
        if (!NumRot)
            LOBYTE(NumRot) = 1;
        --Iterations;
    } while (Iterations);
}
j = PgEntry_DataSize & 0x7F;
if (j >= 8)
{
    Iterations_2 = j >> 3;
    do
    {
        LoopInitValue = __ROL8__(*PgEntryData_1 ^ LoopInitValue, NumRot);
        ++PgEntryData_1;
        j = j - 8;
        --Iterations_2;
    } while (Iterations_2);
}
for (; j; j = (j - 1))
{
    PgEntryData_Byte = *PgEntryData_1;
    PgEntryData_1 = (PgEntryData_1 + 1);
    LoopInitValue = __ROL8__(PgEntryData_Byte ^ LoopInitValue, NumRot);
}
for (k = LoopInitValue;; LODWORD(LoopInitValue) = k ^ LoopInitValue)
{
    k >>= 31;
    if (!k)
        break;
}
ComputedChecksum = LoopInitValue & 0x7FFFFFFF;
if (ComputedChecksum == PgEntry->CheckSum)
    goto checksum_match;
```
```

`542875F90F9B47F497B64BA219CACF69/crypt_decrypt.md`:

```md
```C
__int64 __fastcall EncryptDecryptEntries(PPgCtx PgCtx)
{
  int SomeFlags; // er11
  __int64 i; // r10
  int ChecksStatusFlags; // er9
  __int64 OffsetPgEntries; // rcx
  __int64 LoopInitValue_Xor; // rbp
  unsigned __int64 SizeIterations; // rdi
  char *pData; // rbx
  unsigned __int64 pDataEnd; // r14
  __int64 XoredRAXRDX_1; // r11
  __int64 i2; // rsi
  __int64 v13; // rdx
  _DWORD *pFaultRegion; // rax
  int v15; // ecx
  unsigned __int64 TimestampCtr; // rax
  __int64 XoredRAXRDX; // r11
  __int64 a1[2];

  SomeFlags = PgCtx->SomeFlags;
  if ( !_bittest(&SomeFlags, 30u) )
  {
    i = 0i64;
    while ( 1 )
    {
      ChecksStatusFlags = PgCtx->ChecksStatusFlags;
      a1[1] = (a1[0] & 0xffffffff) != 0;
      if ( a1 == ((PgCtx->ChecksStatusFlags >> 21) & 1) || !(SomeFlags & 2) )
        break;
      OffsetPgEntries = PgCtx->OffsetStartPgEntries;
      LoopInitValue_Xor = PgCtx->LoopInitValue;
      SizeIterations = (PgCtx->SizeofAllPgEntries - OffsetPgEntries) >> 3;
      pData = &PgCtx->CmpAppendDllSection[OffsetPgEntries];
      pDataEnd = PgCtx + 8 * SizeIterations + OffsetPgEntries;
      if ( a1[0] & 0xffffffff )
      {
        TimestampCtr = __rdtsc();
        a1 = (__ROR8__(TimestampCtr, 3) ^ TimestampCtr) * 0x7010008004002001ui64;
        XoredRAXRDX = a1[0] ^ a1[1];
        PgCtx->XoredRAXRDX = XoredRAXRDX;
        if ( pData > pDataEnd )
          SizeIterations = 0i64;
        if ( SizeIterations )
        {
          do
          {
            ++i;
            a1[0] = XoredRAXRDX ^ *pData;
            a1[1] = LoopInitValue_Xor ^ *pData;
            *pData = a1;
            XoredRAXRDX = (a[1] + __ROR8__(XoredRAXRDX, XoredRAXRDX & 0x3F)) ^ 0xEFFi64;
            pData += 8;
          }
          while ( i != SizeIterations );
          ChecksStatusFlags = PgCtx->ChecksStatusFlags;
        }
        PgCtx->XoredRAXRDX2 = XoredRAXRDX;
        PgCtx->ChecksStatusFlags = ChecksStatusFlags | 0x200000;
        return a1;
      }
      XoredRAXRDX_1 = PgCtx->XoredRAXRDX;
      i2 = 0i64;
      if ( pData > pDataEnd )
        SizeIterations = 0i64;
      if ( SizeIterations )
      {
        do
        {
          *pData ^= XoredRAXRDX_1;
          ++i2;
          v13 = *pData;
          pData += 8;
          XoredRAXRDX_1 = ((LoopInitValue_Xor ^ v13) + __ROR8__(XoredRAXRDX_1, XoredRAXRDX_1 & 0x3F)) ^ 0xEFF;
        }
        while ( i2 != SizeIterations );
        ChecksStatusFlags = PgCtx->ChecksStatusFlags;
      }
      PgCtx->ChecksStatusFlags = ChecksStatusFlags & 0xFFDFFFFF;
      if ( XoredRAXRDX_1 != PgCtx->XoredRAXRDX2 )
      {
        pPgFault = PgCtx->pPgFault;
        v15 = PgCtx->SizeofAllPgEntries;
        pPgFault->Ptr1 = PgCtx;
        pPgFault->Id1 = v15;
        if (!PgCtx->SomethingWentWrong;)
        {
          PgCtx->pPgFault->XoredChecksum = XoredRAXRDX_1 ^ PgCtx->XoredRAXRDX2;
          if (!PgCtx->SomethingWentWrong;)
          {
            PgCtx->EncodedPointerPgCtxEntry = 0i64;
            PgCtx->PgEntryType = 0x100i64;
            PgCtx->EncodedPointerPgCtxLocal = &PgCtx + 0A3A03F5891C8B4E8h;
            a1[0] = 0;
            PgCtx->PgEntryData = XoredRAXRDX_1;
            PgCtx->SomethingWentWrong = 1;
            SomeFlags = PgCtx->SomeFlags;
            if ( !_bittest(&SomeFlags, 0x1Eu) )
              continue;
          }
        }
      }
      return a1;
    }
  }
  return a1;
}
```
```

`542875F90F9B47F497B64BA219CACF69/hash_algo.md`:

```md
```C
void __fastcall ComputeHash(PPgCtx PgCtx, PVOID Data, SIZE_T Size, PVOID OutBuffer)
{
  INT64 i;
  BYTE v6;
  char j;
  int TempBuffer[8];

  KeGuardDispatchICall(PgCtx->KeComputeSha256, Data, Size, OutBuffer);
  for ( i = 0i64; i < 4; ++i )
    OutBuffer[i] = TempBuffer[i] ^ TempBuffer[i + 4];
  v6 = *(OutBuffer + 15);
  for ( j = *(OutBuffer + 15); ; j ^= v6 )
  {
    v6 >>= 7;
    if ( !v6 )
      break;
  }
  *(OutBuffer + 15) = j & 0x7F;
}
```
```

`542875F90F9B47F497B64BA219CACF69/pg_entry_dump.py`:

```py
import ctypes
import struct
import sys
import traceback
import abc


class PgEntry(abc.ABC):
    def __init__(self,
                 pg_type,
                 data_ptr,
                 data_size,
                 checksum,
                 const1,
                 const2,
                 const3,
                 const4,
                 const5,
                 const6):
        self._pg_type   = pg_type
        self._data_ptr  = ctypes.c_uint64(data_ptr) 
        self._data_size = ctypes.c_uint32(data_size)
        self._checksum  = ctypes.c_uint32(checksum)
        self._const1    = ctypes.c_uint32(const1)
        self._const2    = ctypes.c_uint32(const2)
        self._const3    = ctypes.c_uint32(const3)
        self._const4    = ctypes.c_uint32(const4)
        self._const5    = ctypes.c_uint32(const5)
        self._const6    = ctypes.c_uint32(const6)

        self.next_entry_off = ctypes.c_int64()

        super().__init__()


    def __str__(self):
        return "{0:<10s}: {1:08x}\n" \
            "{2:<10s}: {3:08x}\n"    \
            "{4:<10s}: {5:08x}\n"    \
            "{6:<10s}: {7:08x}\n"    \
            "{8:<10s}: {9:08x}\n"    \
            "{10:<10s}: {11:08x}\n"  \
            "{12:<10s}: {13:08x}\n"  \
            "{14:<10s}: {15:08x}\n"  \
            "{16:<10s}: {17:08x}\n"  \
            "{18:<10s}: {19:08x}\n".format(
                        "Type",     self.pg_type,
                        "DataPtr",  self.data_ptr.value,
                        "DataSize", self.data_size.value,
                        "Checksum", self.checksum.value,
                        "Const1",   self.const1.value,
                        "Const2",   self.const2.value,
                        "Const3",   self.const3.value,
                        "Const4",   self.const4.value,
                        "Const5",   self.const5.value,
                        "Const6",   self.const6.value)

    def __eq__(self, entry2) -> bool:
        if not isinstance(entry2, PgEntry):
            return False

        return \
            self.pg_type         == entry2.pg_type          and \
            self.data_ptr.value  == entry2.data_ptr.value   and \
            self.data_size.value == entry2.data_size.value  and \
            self.checksum.value  == entry2.checksum.value   and \
            self.const1.value    == entry2.const1.value     and \
            self.const2.value    == entry2.const2.value     and \
            self.const3.value    == entry2.const3.value     and \
            self.const4.value    == entry2.const4.value     and \
            self.const5.value    == entry2.const5.value     and \
            self.const6.value    == entry2.const6.value

    @property
    def pg_type(self) -> int:
        return self._pg_type
    
    @pg_type.setter
    def pg_type(self, pg_type: int) -> None:
        self._pg_type = pg_type

    @property
    def data_ptr(self) -> ctypes.POINTER:
        return self._data_ptr

    @data_ptr.setter
    def data_ptr(self, data_ptr: ctypes.POINTER) -> None:
        self._data_ptr = data_ptr

    @property
    def data_size(self) -> ctypes.c_uint32:
        return self._data_size

    @data_size.setter
    def data_size(self, value: ctypes.c_uint32) -> None:
        self._data_size = value

    @property
    def checksum(self) -> ctypes.c_uint32:
        return self._checksum

    @checksum.setter
    def checksum(self, checksum: ctypes.c_uint32) -> None:
        self._checksum = checksum

    @property
    def const1(self) -> ctypes.c_uint32:
        return self._const1

    @const1.setter
    def const1(self, value: ctypes.c_uint32) -> None:
        self._const1 = value

    @property
    def const2(self) -> ctypes.c_uint32:
        return self._const2

    @const2.setter
    def constw(self, value: ctypes.c_uint32) -> None:
        self._const2 = value

    @property
    def const3(self) -> ctypes.c_uint32:
        return self._const3

    @const3.setter
    def const3(self, value: ctypes.c_uint32) -> None:
        self._const3 = value

    @property
    def const4(self) -> ctypes.c_uint32:
        return self._const4

    @const4.setter
    def const4(self, value: ctypes.c_uint32) -> None:
        self._const4 = value

    @property
    def const5(self) -> ctypes.c_uint32:
        return self._const5

    @const5.setter
    def const5(self, value: ctypes.c_uint32) -> None:
        self._const5 = value

    @property
    def const6(self) -> ctypes.c_uint32:
        return self._const6

    @const6.setter
    def const6(self, value: ctypes.c_uint32) -> None:
        self._const6 = value

    @abc.abstractmethod
    def get_next_entry(self):
        pass


class PgEntryFunctionOrPdata(PgEntry):
    """Handles types FunctionOrPdata, SessionFunctionOrPdata and FunctionOrPdata1"""

    def get_next_entry(self) -> ctypes.c_int64:
        self.next_entry_off.value = 4 * (self.data_size.value // 0xc) + 0x30

        return self.next_entry_off


class PgEntryProcessorProc(PgEntry):
    """Handles types FFFFFFFF ProcessorIDT, ProcessorGDT, Type1ProcessList, Type2ProcessList, DebugRoutine, CriticalMSR"""

    def get_next_entry(self) -> ctypes.c_int64:
        if self.pg_type == 0x2:
            self.next_entry_off.value = 0x30
        else:
            self.next_entry_off.value = 0x18 * (self.const1.value + 2) #(2 * (self.const1.value + 2) + self.const1.value) << 3

        return self.next_entry_off


class PgEntryObjectType(PgEntry):
    """Handles type ObjectType"""

    def get_next_entry(self) -> ctypes.c_int64:
        self.next_entry_off.value = (self.const3.value & 0xffff) + 0x37 & 0xfffffff8

        return self.next_entry_off


class PgEntrySystemServiceFunction(PgEntry):
    """Handles type SystemServiceFunction"""

    def get_next_entry(self) -> ctypes.c_int64:
        self.next_entry_off.value = (self.const2.value + 3) * 0x10

        return self.next_entry_off


class PgEntryDriverObject(PgEntry):
    """Handles type DriverObject"""

    def get_next_entry(self) -> ctypes.c_int64:
        self.next_entry_off.value = (self.const5.value & 0xffff) + 0x37 & 0xfffffff8

        return self.next_entry_off


class PgEntryModulePadding(PgEntry):
    """Handles type ModulePadding"""

    def get_next_entry(self) -> ctypes.c_int64:
        temp = self.const4.value - 1 if self.const4.value > 0 else 0
        self.next_entry_off.value = ((temp // 0xc + 7) & 0xfffffff8) + 0x18 * ((self.const5.value & 0xffff) + 2)

        return self.next_entry_off


class PgEntryHashMismatch(PgEntry):
    """Handles types PageHashMismatch, SessionPageHashMismatch"""

    def get_next_entry(self) -> ctypes.c_int64:
        self.next_entry_off.value = 0x14 * (((self.const3.value & 0xfff) + self.const5.value + 0xfff) >> 12) + 0x30

        return self.next_entry_off


class PgEntryGenericType(PgEntry):
    """Handles other types not covered by other classes"""

    def get_next_entry(self) -> ctypes.c_int64:
        self.next_entry_off.value = 0x30

        return self.next_entry_off


class PgEntryFactory(object):
    def __init__(self):
        pass

    @classmethod
    def create(cls, entry):
        if entry[0] == 0x1 or entry[0] == 0xc or entry[0] == 0x2b:
            return PgEntryFunctionOrPdata(*entry)
        elif 2 <= entry[0] <= 7:
            return PgEntryProcessorProc(*entry)
        elif entry[0] == 0x8:
            return PgEntryObjectType(*entry)
        elif entry[0] == 0xa:
            return PgEntrySystemServiceFunction(*entry)
        elif entry[0] == 0x1c:
            return PgEntryDriverObject(*entry)
        elif entry[0] == 0x1e:
            return PgEntryModulePadding(*entry)
        elif 0x21 <= entry[0] <= 0x22:
            return PgEntryHashMismatch(*entry)
        else:
            return PgEntryGenericType(*entry)

    @classmethod
    def create_null(cls):
        return PgEntryGenericType(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)


assert(len(sys.argv) > 1)

struct_fmt = "=QQLLLLLLLL"
struct_sz = struct.calcsize(struct_fmt)
struct_unpack = struct.Struct(struct_fmt).unpack_from

PgEntriesOff = 0xaa0
with open(sys.argv[1], "rb") as f:
    null_entry = PgEntryFactory.create_null()
    while True:
        f.seek(PgEntriesOff)
        try:
            s = struct_unpack(f.read(struct_sz))
        except struct.error:
            traceback.print_exc()

            break

        pg_entry = PgEntryFactory.create(s)
        if pg_entry == null_entry:
            break
        
        print(pg_entry)

        PgEntriesOff += pg_entry.get_next_entry().value

```

`AfdTdxCallback/README.md`:

```md
## AfdTdxCallback

### Description

`Afd.sys` - `Ancillary Function Driver for WinSock`.

`Tdx.sys` - [TDI](https://en.wikipedia.org/wiki/Transport_Driver_Interface) `Translation Driver`.

---

Another _producer_ (`Tdx.sys`) - _consumer_ (`Afd.sys`) pattern (as in [TcpConnectionCallbackTemp](../TcpConnectionCallbackTemp)). Inside `Tdx.sys` callback object creation is governed by `TdxInitializeTransportAddressModule` function and all notifications (4 call references) on this object are triggered from `TdxActivateTransportAddress` function. `Afd.sys` registers a callback named `AfdTdxCallbackRoutine` inside `AfdTdxInitCallback` function. What is the consumer receiving as `Argument1` and `Argument2`(see [CallbackFunction](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exregistercallback)) when the callback object is notified?
- `Argument1` is of type `struct _ECP_LIST *`.
- `Argument2` is used as an output argument (communication channel), through which `Afd.sys` passes back data to `Tdx.sys`. Here we can see that the authors are abusing the definition of the [CallbackFunction](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exregistercallback) which in the documentation has `IN` SAL annotation, but here is used as an `OUT` parameter.

`Argument1` can be useful in a call to [FsRtlFindExtraCreateParameter](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-fsrtlfindextracreateparameter) (that's the use case in `afd.sys`), where the ECP context structure is obtained through using an appropriate `GUID` (like ones listed in [System-Defined ECPs](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/system-defined-ecps)). Last note, `afd.sys` uses the following `GUID`: `d37479c1-4502-a067-0e35-2e8cd59134f5`.

```

`EnlightenmentState/EnlightenmentState.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29411.108
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EnlightenmentState", "EnlightenmentState\EnlightenmentState.vcxproj", "{910F7BEE-8923-4801-B3EE-74114072FFD3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|ARM.ActiveCfg = Debug|ARM
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|ARM.Build.0 = Debug|ARM
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|ARM.Deploy.0 = Debug|ARM
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|ARM64.Build.0 = Debug|ARM64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|x64.ActiveCfg = Debug|x64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|x64.Build.0 = Debug|x64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|x64.Deploy.0 = Debug|x64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|x86.ActiveCfg = Debug|Win32
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|x86.Build.0 = Debug|Win32
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Debug|x86.Deploy.0 = Debug|Win32
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|ARM.ActiveCfg = Release|ARM
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|ARM.Build.0 = Release|ARM
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|ARM.Deploy.0 = Release|ARM
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|ARM64.ActiveCfg = Release|ARM64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|ARM64.Build.0 = Release|ARM64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|ARM64.Deploy.0 = Release|ARM64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|x64.ActiveCfg = Release|x64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|x64.Build.0 = Release|x64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|x64.Deploy.0 = Release|x64
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|x86.ActiveCfg = Release|Win32
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|x86.Build.0 = Release|Win32
		{910F7BEE-8923-4801-B3EE-74114072FFD3}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {39B3A25C-047A-4C61-B484-A5FF80E061A3}
	EndGlobalSection
EndGlobal

```

`EnlightenmentState/EnlightenmentState/EnlightenmentState.c`:

```c
#include <ntddk.h>

DRIVER_INITIALIZE   DriverEntry;
DRIVER_UNLOAD       DriverUnload;
CALLBACK_FUNCTION   EnlightenmentStateCallback;

PVOID g_EnlightenmentStateCb;

VOID
EnlightenmentStateCallback(
    _In_opt_    PVOID   CallbackContext,
    _In_opt_    PVOID   Argument1,
    _In_opt_    PVOID   Argument2
)
{

    PAGED_CODE();

    UNREFERENCED_PARAMETER(CallbackContext);
    UNREFERENCED_PARAMETER(Argument1);
    UNREFERENCED_PARAMETER(Argument2);

}

VOID
DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject
)
{

    PAGED_CODE();

    UNREFERENCED_PARAMETER(DriverObject);

    if (g_EnlightenmentStateCb != NULL) {
        ExUnregisterCallback(g_EnlightenmentStateCb);
    }

}

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{

    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING      EnlightenmentStateObjName;
    OBJECT_ATTRIBUTES   EnlightenmentStateAttr;
    PCALLBACK_OBJECT    pEnlightenmentState = NULL;

    DriverObject->DriverUnload = DriverUnload;

    RtlInitUnicodeString(&EnlightenmentStateObjName, L"\\Callback\\EnlightenmentState");

    InitializeObjectAttributes(&EnlightenmentStateAttr, &EnlightenmentStateObjName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!NT_SUCCESS(ExCreateCallback(&pEnlightenmentState, &EnlightenmentStateAttr, FALSE, FALSE))) {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, __FUNCTION__ ": Failed to obtain callback object!\n");

        return STATUS_NOT_FOUND;
    }

    g_EnlightenmentStateCb = ExRegisterCallback(pEnlightenmentState, EnlightenmentStateCallback, NULL);

    if (g_EnlightenmentStateCb != NULL) {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, __FUNCTION__ ": Seems ok!\n");

    }
    else {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, __FUNCTION__ ": Hmmm, something wrong!\n");

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;

}
```

`EnlightenmentState/EnlightenmentState/EnlightenmentState.inf`:

```inf
;
; EnlightenmentState.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=EnlightenmentState.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="EnlightenmentState Source Disk"

```

`EnlightenmentState/EnlightenmentState/EnlightenmentState.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{910F7BEE-8923-4801-B3EE-74114072FFD3}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>EnlightenmentState</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="EnlightenmentState.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EnlightenmentState.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EnlightenmentState/EnlightenmentState/EnlightenmentState.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="EnlightenmentState.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EnlightenmentState.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EnlightenmentState/README.md`:

```md
## EnlightenmentState

**[WIP]**

This callback is related to Hyper-V Enlightenments. It is notified in function `HvlPhase2Initialize` only if bit 0 of `HvlpRootFlags` is not set. We still need to trace down wich Enlightenment set or not this bit, it looks like this is done in function `HvlpDetermineEnlightenments` which comes from `HvlPhase0Initialize`.

This still needs a **lot** of investigation since we are not even near to understand how Hyper-V works internally.

```

`IoExternalDmaUnblock/README.md`:

```md
## IoExternalDmaUnblock

### Description

The callback object is created inside `ntoskrnl.exe`. The root of function tree that frames actions on this callback object is `PiCslInitialize` function, where `PipCslConsoleLockState` is initialized to 0 and `PipCslCreateCallback` is called in order to create the callback object (symbol `PipCslCallbackObject`). After the object is successfully created, the callback function `PipCslStateChangeCallback` is registered. The goal of this callback is to check if `PipCslInitialized` was initialized (not 0), otherwise the system bugchecks (code _0xCA_), then call `PipCslUpdateState` with argument value _1_ or _2_. The latter call compares the value of `PipCslConsoleLockState` with the argument value and if the values are different and the argument value is _1_ - `PipCslUnlockCallback` is called. An outline of what was mentioned:
```C
NTSTATUS __stdcall PiCslInitialize()
{
  NTSTATUS v0;

  PipCslConsoleLockState = 0;
  v0 = PipCslCreateCallback();
  if ( v0 >= 0 )
  {
    ExRegisterCallback((PCALLBACK_OBJECT)PipCslCallbackObject, (PCALLBACK_FUNCTION)PipCslStateChangeCallback, 0i64);
    PipCslInitialized = 1;
  }
  return v0;
}
```

What is `PipCslUnlockCallback` doing? Skimming the references we observe that the only write to this global function pointer is inside `PipDmgInitPhaseOne` function and the written value is the address of `PipDmgConsoleUnlockCallback` function. It is important to mention that the initialization happens only when `PipDmaGuardPolicy` is not _0_. As described on [Policy CSP - DmaGuard](https://docs.microsoft.com/en-us/windows/client-management/mdm/policy-csp-dmaguard), the value _0_ stands for _most restrictive_ policy, so the callback is going to be initialized in other cases, like when the policy is _1_ or _2_ (there are other undocumented values, like _3_). These primitives seem to be related to [Kernel DMA Protection](https://docs.microsoft.com/en-us/windows/security/information-protection/kernel-dma-protection-for-thunderbolt). In the end, `PipDmgConsoleUnlockCallback` is responsible for calling `PipDmgFlushQueueAndRestartDevices` function when `PipDmaGuardPolicy` is equal to _2_.

Callback object notifications are sent from `ntoskrnl`'s [NtPowerInformation](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-ntpowerinformation), when `InformationLevel` argument has value _0x5F_, through calling `PnpWinlogonExternalDmaNotification` function. `Argument1` parameter of `ExNotifyCallback` is `NtPowerInformation`'s second parameter named `InputBuffer` and `Argument2` is always set to _0_.

There's another callback function registered inside `pci.sys` by function `PciCreateConsoleLockCallback`. The callback function name is `PciConsoleLockCallback` which is a wrapper for `PciSetConsoleState`. Inside the wrapper, first argument value (parameter `Argument1`) is checked if _0_ / _NULL_ and if not then the argument to later call is value _1_ otherwise _2_. `PciSetConsoleState` goal is to iterate over every _bus_ in every _PCI segment_ and verify if the _bus_ is affected by console lock (a - `PciBusAffectedByConsoleLock` is called) and should be disabled (b - `PciBusShouldBeDisabledByConsoleLock` is called). If only (a) is satisfied then `IoInvalidateDeviceRelations` is called. It is important to note that all of the above actions are done only when `PciConsoleState` global variable value is different than the value of the argument passed to the function.

We were curios about any executables, libraries or drivers that make use of `NtPowerInformation` and call it with first argument being _0x5F_. For that we searched recursively inside `%SystemRoot%\System32` looking for files containing the string _NtPowerInformation_ (in different code pages like ANSI, UTF-8, UTF-16). Then using _HexRays decompiler plugin_ and [two scripts](ida_run.py) (watch out, unpolished code!) allowing to run _IDA Pro_ in batch mode we found 91 files calling `NtPowerInformation` at least once. And from those, the only one using _0x5F_ as an argument is inside a function (`NotifyUserPresenceOnDesktopForDMAProtection`) hosted by `winlogon.exe`. Here's the pseudocode:
```C
//
// When symbols are loaded the function prototype is:
// void __fastcall NotifyUserPresenceOnDesktopForDMAProtection(int, struct _WLSM_GLOBAL_CONTEXT *)
//
void **__fastcall sub_1400391B8(int a1, __int64 a2)
{
  __int64 v2; // rcx
  void **result; // rax
  NTSTATUS v4; // eax
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 v7; // r9
  const wchar_t *v8; // r9
  int v9; // [rsp+40h] [rbp+8h]
  char InputBuffer; // [rsp+48h] [rbp+10h]

  v9 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  InputBuffer = 0;
  if ( (unsigned int)sub_140027BB8(v2) ) // CSession::IsBoundToConsole
  {
    InputBuffer = v9;
    //
    // TraceApplicationPowerMessageEnd - 0x1F
    //
    v4 = NtPowerInformation(TraceApplicationPowerMessageEnd|0x40, &InputBuffer, 1u, 0i64, 0);
    v7 = (unsigned int)v4;
    ...
```

EOF

```

`IoExternalDmaUnblock/ida_run.py`:

```py
from sys import exit, argv
from subprocess import run
from os import scandir, chdir, getcwd

assert len(argv) > 1

script_file_name_path = getcwd() + "\\ntpowerinfo.py"
with scandir(argv[1]) as fd:
    chdir(argv[1])
    for e in fd:
        if any(e.name.endswith(ex) for ex in (".exe", ".dll", ".sys")):
            print("Process {}".format(e.name))
            p = run(["ida64.exe", "-c", "-A", "-S" + script_file_name_path, e.name])

```

`IoExternalDmaUnblock/ntpowerinfo.py`:

```py
import ida_ida
import ida_auto
import ida_loader
import ida_hexrays
import ida_idp
import ida_entry
import idautils
import ida_nalt
import ida_pro

from os.path import basename

def imp_cb(ea, name, ord):
    if "NtPowerInformation" in name:
        global nt_power_information
        nt_power_information = ea
        # False stops iteration over imports
        return False
    # Continue to iterate over imports
    return True


nimps = idaapi.get_import_module_qty()

nt_power_information = None
for i in range(0, nimps):
    name = idaapi.get_import_module_name(i)
    if not name:
        continue
    
    if "ntdll" in name:
        idaapi.enum_import_names(i, imp_cb)
        if nt_power_information is not None:
            break

output_filename = basename(ida_nalt.get_input_file_path()) \
                     + ida_nalt.get_root_filename() + ".dec"
if nt_power_information:
    ida_auto.auto_wait()

    if ida_loader.load_plugin("hexx64") and ida_hexrays.init_hexrays_plugin():
        code_xrefs = idautils.CodeRefsTo(nt_power_information, 1)
        for cx in code_xrefs:
            cf = ida_hexrays.decompile(cx)
            if cf:
                with open(output_filename, "a") as fd:
                    fd.write(str(cf) + '\n')
            else:
                with open(output_filename, "a") as fd:
                    fd.write("[!] Decompilation failed\n")
    else:
        with open(output_filename, "a") as fd:
            fd.write("[!] Decompiler loading failed\n")
else:
    with open(output_filename, "a") as fd:
        fd.write("[+] NtPowerInformation import was not found\n")

ida_pro.qexit(0)

```

`Loader/Loader.c`:

```c
#include <Windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define CALLBACKOBJ_SERVICE_NAMEW       L"ExCallbackObjectsSvc"
#define CALLBACKOBJ_SERVICE_INSTALL     0
#define CALLBACKOBJ_SERVICE_UNINSTALL   1


typedef struct _EX_CALLBACK_OBJ_TUPLE {
    PCWSTR  DriverName;
    DWORD   StartType;
} EX_CALLBACK_OBJ_TUPLE;

EX_CALLBACK_OBJ_TUPLE g_ExCallbackObjectDrivers[] = {
    { L"WdProcessNotificationCallback.sys", SERVICE_DEMAND_START },
    { L"Phase1InitComplete.sys", SERVICE_BOOT_START },
    { L"EnlightenmentState.sys", SERVICE_BOOT_START },
    { L"TcpConnectionCallbackTemp.sys", SERVICE_DEMAND_START }
};
DWORD g_NumCallbackObjectDrivers = sizeof(g_ExCallbackObjectDrivers) / sizeof(g_ExCallbackObjectDrivers[0]);

_Success_(return == TRUE)
BOOLEAN
InstallDriver(
    _In_    SC_HANDLE   hSCManager,
    _In_    LPCTSTR     ServiceName,
    _In_    LPCTSTR     DriverPath,
    _In_    DWORD       StartType
)
{
    SC_HANDLE   schService;
    DWORD       errCode;

    schService = CreateService(hSCManager,
                               ServiceName,
                               ServiceName,
                               SERVICE_ALL_ACCESS,
                               SERVICE_KERNEL_DRIVER,
                               StartType,
                               SERVICE_ERROR_NORMAL,
                               DriverPath,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
    if (NULL == schService) {
        errCode = GetLastError();

        if (ERROR_SERVICE_EXISTS == errCode) {
            fprintf(stderr, __FUNCTION__ " Service already exists\n");

            return TRUE;
        } else {
            fprintf(stderr, __FUNCTION__ " Failed creating service: %#x\n", errCode);

            return FALSE;
        }
    } else {
        CloseServiceHandle(schService);

        fprintf(stdout, __FUNCTION__ " Service %S was successfully created\n", ServiceName);

        return TRUE;
    }
}

_Success_(return == TRUE)
BOOLEAN
UninstallDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName
)
{
    SC_HANDLE   schService;
    BOOLEAN     bRetStatus = FALSE;

    schService = OpenService(hSCManager,
                             ServiceName,
                             SERVICE_ALL_ACCESS);
    if (NULL == schService) {
        fprintf(stderr, __FUNCTION__ " Failed opening the service: %#X\n", GetLastError());

        return bRetStatus;
    }

    if (DeleteService(schService)) {
        bRetStatus = TRUE;

        fprintf(stdout, __FUNCTION__ " Service %S was successfully deleted\n", ServiceName);
    } else {
        fprintf(stderr, __FUNCTION__ " Failed deleting the service: %#X\n", GetLastError());
    }

    CloseServiceHandle(schService);

    return bRetStatus;
}

_Success_(return == TRUE)
BOOLEAN
StartDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName
)
{
    SC_HANDLE   schService;
    DWORD       errCode;
    BOOLEAN     bRetStatus = FALSE;

    schService = OpenService(hSCManager,
                             ServiceName,
                             SERVICE_ALL_ACCESS);
    if (NULL == schService) {
        fprintf(stderr, __FUNCTION__ " Failed opening the service: %#X\n", GetLastError());

        return bRetStatus;
    }

    if (!StartService(schService,
                      0,
                      NULL)) {
        errCode = GetLastError();

        if (ERROR_SERVICE_ALREADY_RUNNING == errCode) {
            bRetStatus = TRUE;

            fprintf(stdout, __FUNCTION__ " Service %S already running\n", ServiceName);
        } else {
            fprintf(stderr, __FUNCTION__ " Failed starting the service: %#X\n", errCode);
        }
    } else {
        bRetStatus = TRUE;

        fprintf(stdout, __FUNCTION__ " Service %S was successfully started\n", ServiceName);
    }

    CloseServiceHandle(schService);

    return bRetStatus;
}

_Success_(return == TRUE)
BOOLEAN
StopDriver(
    _In_	SC_HANDLE	hSCManager,
    _In_	LPCTSTR		ServiceName
)
{
    SC_HANDLE       schService;
    SERVICE_STATUS  serviceStatus;
    BOOLEAN         bRetStatus = FALSE;

    schService = OpenService(hSCManager,
                             ServiceName,
                             SERVICE_ALL_ACCESS);
    if (NULL == schService) {
        fprintf(stderr, __FUNCTION__ " Failed opening the service: %#X\n", GetLastError());

        return bRetStatus;
    }

    if (ControlService(schService,
                       SERVICE_CONTROL_STOP,
                       &serviceStatus)) {
        bRetStatus = TRUE;

        fprintf(stdout, __FUNCTION__ " Service %S was successfully stopped\n", ServiceName);
    } else {
        fprintf(stderr, __FUNCTION__ " Failed stopping the service: %#X\n", GetLastError());
    }

    CloseServiceHandle(schService);

    return bRetStatus;
}

_Success_(return == TRUE)
BOOLEAN
ManageDriver(
    _In_    LPCTSTR DriverPath,
    _In_    LPCTSTR ServiceName,
    _In_    SIZE_T  Action,
    _In_    DWORD   StartType
)
{
    SC_HANDLE	schSCManager;
    BOOLEAN		bRetVal = TRUE;

    if (NULL == DriverPath || NULL == ServiceName) {
        fprintf(stderr, __FUNCTION__ " Invalid driver name or service name\n");

        return FALSE;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == schSCManager) {
        fprintf(stderr, __FUNCTION__ " Failed opening a connection to SCM: %#X\n", GetLastError());

        return FALSE;
    }

    switch (Action) {
    case CALLBACKOBJ_SERVICE_INSTALL:
        if (InstallDriver(schSCManager, ServiceName, DriverPath, StartType)) {
            if (StartType == SERVICE_DEMAND_START) {
                bRetVal = StartDriver(schSCManager, ServiceName);
            } else {
                fprintf(stderr, __FUNCTION__ " StartType isn't DEMAND_START, the service isn't started\n");

                bRetVal = TRUE;
            }
        } else {
            bRetVal = FALSE;
        }

        break;
    case CALLBACKOBJ_SERVICE_UNINSTALL:
        if (StopDriver(schSCManager, ServiceName)) {
            bRetVal = UninstallDriver(schSCManager, ServiceName);
        } else {
            bRetVal = FALSE;
        }

        break;
    default:
        fprintf(stderr, __FUNCTION__ " Unknown action: %zu\n", Action);

        bRetVal = FALSE;

        break;
    }

    if (CloseServiceHandle(schSCManager) == 0) {
        fprintf(stderr, __FUNCTION__ " Failed closing SCM: %#X\n", GetLastError());
    }

    return bRetVal;
}

DWORD chk_strtoul(PCSTR pStr, PBOOL bFail) {
    PCHAR pEndPtr;
    DWORD dwNum;

    *bFail = strchr(pStr, '-') != NULL;
    
    errno = 0;
    dwNum = strtoul(pStr, &pEndPtr, 10);
    if (errno || pEndPtr == pStr || *pEndPtr) {
        *bFail = 1;
    }

    return dwNum;
}

int __cdecl main(int argc, char* argv[])
{
    DWORD   retCode = EXIT_SUCCESS;
    DWORD   dwBufferLength = 0;
    DWORD   dwCallbackId = 0;
    BOOL    bFail = FALSE;
    LPWSTR  lpBuffer = NULL;
    LPCWSTR lpDriverName = NULL;

    if (argc > 2) {
        dwCallbackId = chk_strtoul(argv[2], &bFail);
        if (bFail) {
            fwprintf(stderr, L"Failed to parse callback id\n");

            return EXIT_FAILURE;;
        }
        if (dwCallbackId >= g_NumCallbackObjectDrivers) {
            fwprintf(stderr, L"Maximum id number is %lu\n", g_NumCallbackObjectDrivers - 1);

            retCode = EXIT_FAILURE;

            goto usage;
        }

        fprintf(stdout, "Selected callback object: %ls\n", g_ExCallbackObjectDrivers[dwCallbackId].DriverName);

        if (_strnicmp(argv[1], "load", strlen("load")) == 0) {
            lpDriverName = g_ExCallbackObjectDrivers[dwCallbackId].DriverName;

            if (g_ExCallbackObjectDrivers[dwCallbackId].StartType == SERVICE_BOOT_START) {
                // FIXME: User env variable expansion or read system drive letter instead of hardcoding.
                LPCWSTR lpSystem32W = L"C:\\Windows\\System32\\";
                lpBuffer = calloc(wcslen(lpSystem32W) + wcslen(lpDriverName) + 1, sizeof(WCHAR));
                if (NULL == lpBuffer) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"Failed allocating a buffer for System32: %08X\n", retCode);

                    goto free_buff;
                }
                if (wcsncpy_s(lpBuffer,
                              wcslen(lpSystem32W) + wcslen(lpDriverName) + 1,
                              lpSystem32W,
                              wcslen(lpSystem32W)) != 0) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"wcsncpy_s failed: %08X\n", retCode);

                    free(lpBuffer);
                    lpBuffer = NULL;

                    goto free_buff;
                }
                if (wcsncat_s(lpBuffer,
                              wcslen(lpSystem32W) + wcslen(lpDriverName) + 1,
                              lpDriverName,
                              wcslen(lpDriverName)) != 0) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"wcsncat_s failed: %08X\n", retCode);

                    free(lpBuffer);
                    lpBuffer = NULL;

                    goto free_buff;
                }

                if (!CopyFile(lpDriverName, lpBuffer, TRUE)) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"CopyFile failed: %08X\n", retCode);
                } else {
                    fwprintf(stdout, L"%lS was successfully copied\n", lpBuffer);
                }
            } else if (g_ExCallbackObjectDrivers[dwCallbackId].StartType == SERVICE_DEMAND_START) {
                dwBufferLength = GetCurrentDirectory(dwBufferLength, lpBuffer);
                if (!dwBufferLength) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"Failed to query current directory length: %08X\n", retCode);

                    return retCode;
                } else {
                    lpBuffer = calloc(dwBufferLength + wcslen(lpDriverName) + 2, sizeof(WCHAR)); // + 2: 1 for \ and 1 for NULL
                    if (NULL == lpBuffer) {
                        retCode = GetLastError();
                        fwprintf(stderr, L"Failed allocating a buffer for current directory: %08X\n", retCode);

                        return retCode;
                    }

                    if (!GetCurrentDirectory(dwBufferLength, lpBuffer)) {
                        retCode = GetLastError();
                        fwprintf(stderr, L"Failed to query current directory length: %08X\n", retCode);

                        goto free_buff;
                    }
                }

                if (wcsncat_s(lpBuffer,
                              dwBufferLength + wcslen(lpDriverName) + 1,
                              L"\\",
                              wcslen(L"\\")) != 0) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"wcsncat_s failed: %08X\n", retCode);

                    goto free_buff;
                }
                if (wcsncat_s(lpBuffer,
                              dwBufferLength + wcslen(lpDriverName) + 1,
                              lpDriverName,
                              wcslen(lpDriverName)) != 0) {
                    retCode = GetLastError();
                    fwprintf(stderr, L"wcsncat_s failed: %08X\n", retCode);

                    goto free_buff;
                }
            } else {
                fwprintf(stderr, L"Unknown service start option: %08X\n", g_ExCallbackObjectDrivers[dwCallbackId].StartType);

                return EXIT_FAILURE;
            }

            fwprintf(stdout, L"Absolute path of the driver to load: %lS\n", lpBuffer);

            ManageDriver(lpBuffer, CALLBACKOBJ_SERVICE_NAMEW, CALLBACKOBJ_SERVICE_INSTALL, g_ExCallbackObjectDrivers[dwCallbackId].StartType);

        free_buff:
            free(lpBuffer);
            lpBuffer = NULL;
        } else {
            goto usage;
        }
    } else if (argc > 1) {
        if (_strnicmp(argv[1], "unload", strlen("unload")) == 0) {
            ManageDriver(L"", CALLBACKOBJ_SERVICE_NAMEW, CALLBACKOBJ_SERVICE_UNINSTALL, ULONG_MAX);
        } else {
            goto usage;
        }
    } else {
usage:
        fwprintf(stdout, L"[*] Usage: %hs [ load <callback_id> | unload ]\n", argv[0]);
        fwprintf(stdout, L"[*] Available callback object drivers:\n");
        for (size_t i = 0; i < g_NumCallbackObjectDrivers; i++) {
            fwprintf(stdout, L"[+] %zu: %ls\n", i, g_ExCallbackObjectDrivers[i].DriverName);
        }
    }

    return retCode;
}
```

`Loader/Loader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29411.108
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Loader", "Loader.vcxproj", "{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Debug|x64.ActiveCfg = Debug|Win32
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Debug|x64.Build.0 = Debug|Win32
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Debug|x86.ActiveCfg = Debug|Win32
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Debug|x86.Build.0 = Debug|Win32
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Release|x64.ActiveCfg = Release|x64
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Release|x64.Build.0 = Release|x64
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Release|x86.ActiveCfg = Release|Win32
		{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EE6A6E9D-32D9-4A03-A3FA-EB79560F3CF0}
	EndGlobalSection
EndGlobal

```

`Loader/Loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Loader.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0B8757DD-22F0-4F9C-934D-79FE1E8CCB42}</ProjectGuid>
    <TemplateGuid>{504102d4-2172-473c-8adf-cd96e308f257}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Loader</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <ConfigurationType>Application</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);onecoreuap.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);onecoreuap.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);onecoreuap.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);onecoreuap.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Loader/Loader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Loader.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Phase1InitComplete/Phase1InitComplete.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29411.108
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Phase1InitComplete", "Phase1InitComplete\Phase1InitComplete.vcxproj", "{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Debug|x64.ActiveCfg = Debug|x64
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Debug|x64.Build.0 = Debug|x64
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Debug|x64.Deploy.0 = Debug|x64
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Debug|x86.ActiveCfg = Debug|Win32
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Debug|x86.Build.0 = Debug|Win32
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Debug|x86.Deploy.0 = Debug|Win32
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Release|x64.ActiveCfg = Release|x64
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Release|x64.Build.0 = Release|x64
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Release|x64.Deploy.0 = Release|x64
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Release|x86.ActiveCfg = Release|Win32
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Release|x86.Build.0 = Release|Win32
		{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F9E279BF-4CC9-45AD-9F95-214CE6711E88}
	EndGlobalSection
EndGlobal

```

`Phase1InitComplete/Phase1InitComplete/Phase1InitComplete.c`:

```c
#include <ntddk.h>
#include <intrin.h>

DRIVER_INITIALIZE   DriverEntry;
DRIVER_UNLOAD       DriverUnload;
CALLBACK_FUNCTION   Phase1Callback;

PVOID g_Phase1Callback;

VOID
Phase1Callback(
    _In_opt_    PVOID   CallbackContext,
    _In_opt_    PVOID   Argument1,
    _In_opt_    PVOID   Argument2
)
{

    PAGED_CODE();

    UNREFERENCED_PARAMETER(CallbackContext);

    PVOID pvAddressOfReturnAddress;
    PVOID pLoaderParamBlock;

    // Make sure we are getting notified by the kernel
    if (Argument1 != NULL && Argument2 != NULL) {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, __FUNCTION__ ": Wrong Arguments!!");

        return;
    }


    pvAddressOfReturnAddress = _AddressOfReturnAddress();
    
    /* In Windows 10 ver 1903 (OS Build 19002.1002) adding 0x68 to the return addres of this callback we get a pointer to the LOADER_PARAMETER_BLOCK. This is of course not reliable, just throwing out some ideas :)
    */
    pLoaderParamBlock = (PVOID)((char *)pvAddressOfReturnAddress + 0x68);

}

VOID
DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject
) 
{

    PAGED_CODE();

    UNREFERENCED_PARAMETER(DriverObject);

    if (g_Phase1Callback != NULL) {
        ExUnregisterCallback(g_Phase1Callback);
    }

}

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{

    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING      Phase1ObjName;
    OBJECT_ATTRIBUTES   Phase1ObjAttr;
    PCALLBACK_OBJECT    pPhase1InitComplete = NULL;

    DriverObject->DriverUnload = DriverUnload;

    RtlInitUnicodeString(&Phase1ObjName, L"\\Callback\\Phase1InitComplete");

    InitializeObjectAttributes(&Phase1ObjAttr, &Phase1ObjName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!NT_SUCCESS(ExCreateCallback(&pPhase1InitComplete, &Phase1ObjAttr, FALSE, FALSE))) {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, __FUNCTION__ ": Failed to obtain callback object!\n");

        return STATUS_NOT_FOUND;
    }
     
    g_Phase1Callback = ExRegisterCallback(pPhase1InitComplete, Phase1Callback, NULL);

    if (g_Phase1Callback != NULL) {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, __FUNCTION__ ": Seems ok!\n");

    } else {

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, __FUNCTION__ ": Hmmm, something wrong!\n");

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;

}
```

`Phase1InitComplete/Phase1InitComplete/Phase1InitComplete.inf`:

```inf
;
; Phase1InitComplete.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=Phase1InitComplete.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="Phase1InitComplete Source Disk"

```

`Phase1InitComplete/Phase1InitComplete/Phase1InitComplete.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FE59AFEB-AEC5-425E-A480-00E6D43ED87F}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Phase1InitComplete</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="Phase1InitComplete.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Phase1InitComplete.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Phase1InitComplete/Phase1InitComplete/Phase1InitComplete.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Phase1InitComplete.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Phase1InitComplete.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Phase1InitComplete/README.md`:

```md
## Phase1InitComplete

Initial investigation show that this callback is only notified one time (Phase1 only happens one time so this makes total sense). The function `ExNotifyCallback` for this callback object is called inside `Phase1InitializationIoReady`. As seen on the MSDN the prototype for [`ExNotifyCallback`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-exnotifycallback) is the following:

```C
void ExNotifyCallback(
  PVOID CallbackObject,
  PVOID Argument1,
  PVOID Argument2
);
```

With the help of IDA we can see that this function is called with the following parameters:

![ExNotifyCallback Phase1InitComple](images/CallExNotifyCallback.png)

The variable `ExCbPhase1InitComplete` holds the pointer to the `CALLBACK_OBJECT`. And the `Argument1` and `Argument2` are zero, this means that our callback won't receive any interesting arguments.

### Remarks
For this driver to work, it must be loaded at Boot time that means that the `StartType` of this services must be set to `SERVICE_BOOT_START`. Also, for the bootloader to load the driver this must be in the folder `%SYSTEMROOT%\System32\drivers\`

Having this in mind, the use case of this is quite small. But just for fun, we decided to add some code in the callback that allow us to retreive the address of the `LOADER_PARAMETER_BLOCK`. To do this, we basically obtain the address of the return address (Using the intrinsic [_AddressOfReturnAddress](https://docs.microsoft.com/en-us/cpp/intrinsics/addressofreturnaddress?view=vs-2019)) we checked using IDA and WinDbg how much we need to add to this value in order to obtain the pointer to the `LOADER_PARAMETER_BLOCK`. To make this short, the callback gets called from `ExNotifyWithProcessing` which substracts 0x30 to `rsp` (We add 0x8 for the retn addr from this function) this comes from `ExNotifyCallback` which substracts 0x28 (Again we add 0x8 for the retn addr) finally we found out the next value (At least on In Windows 10 ver 1903 (OS Build 19002.1002)) in the stack corresponds with the `LOADER_PARAMETER_BLOCK` (This is inside `Phase1InitializationIoReady`) so in the end would be:
`0x30 + 0x8 + 0x28 + 0x8 = 0x68`. In the following image it can be seen how the code is adding 0x68 to `rax` and then we can use this value (pointer) to dispay the type `LOADER_PARAMETER_BLOCK`:

![Obtaining LOADER_PARAMETER_BLOCK](images/LoaderParamBlock.png)

```

`README.md`:

```md
# ExecutiveCallbackObjects
Research on Windows Kernel Executive Callback Objects

OS Version: Windows 10 Pro Insiders Preview 20H1 19008 or later

# List of researched callback objects

## [542875F90F9B47F497B64BA219CACF69](542875F90F9B47F497B64BA219CACF69)

## [AfdTdxCallback](AfdTdxCallback)

## [EnlightenmentState](EnlightenmentState)

## [IoExternalDmaUnblock](IoExternalDmaUnblock)

## IoSessionNotifications

## LicensingData

## LLTDCallbackMapper

## LLTDCallbackRspndr

## NdisBindUnbind

## [Phase1InitComplete](Phase1InitComplete)

## PowerState

## ProcessorAdd

## SeImageVerificationDriverInfo

## SetSystemState

## SetSystemTime

## [TcpConnectionCallbackTemp](TcpConnectionCallbackTemp)

## TcpTimerStarvationCallbackTemp

## VidPhu

## [WdEbNotificationCallback](WdEbNotificationCallback)

## [WdNriNotificationCallback](WdNriNotificationCallback)

## [WdProcessNotificationCallback](WdProcessNotificationCallback)

# Disclaimer
This investigation is just being held for research purpose, we don't take part nor encourage any illegitimate use of what is explained in this repository. Also if you find any mistakes or different behaviours please feel free to contribute, we would gladly appreciate any contribution.

# Acknowledgments

[hFiref0x](https://twitter.com/hfiref0x) for [WinObjEx64](https://github.com/hfiref0x/WinObjEx64)

```

`TcpConnectionCallbackTemp/README.md`:

```md
## TcpConnectionCallbackTemp

### Description

**This is still work in progress!**

This callback object can be created in `tcpip.sys` or `rasacd.sys`. In both drivers the symbol for the object is `TcpCcbObject`.
A strong friendship relationship is observed in `tcpip.sys`, where _9_ references lead to `ExNotifyCallback`, while `rasacd.sys` has _1_ reference leading to `ExRegisterCallback`. So our understanding comes to a conclusion that we have a _producer_ - _consumer_ pattern between these _2_ drivers.

There seem to be 3 possible values for the `Argument1`, they are the following:
- 1: Default case
- 2: Seems to be related to `TCP_SYN_ATTACK_ENTRY`
- 3: Seems to be related to `TCP_SYN_ATTACK_EXIT`

For `Argument2`, only when `Argument1` is equal to `1`, we get a pointer to a structure:
```C
typedef struct _TCP_CB
{
    UINT16  Magic; // 2
    UINT16  Reserved;
    DWORD32 Unknown0; // observed values: 1, 3, 5, 6, 7, 10, 11
    DWORD64 NotificationType; // observed values: 1, 3, 4, 5
    PVOID   pSrcIpAddr;
    PVOID   pDstIpAddr;
    UINT16  pSrcPort;
    UINT16  pDstPort;
    DWORD32 Unknown1; // observed values: 0xe0000001
    DWORD32 Unknown2; // observed values: 0xe0000001
    DWORD32 Unknown3; // 0x21, 0x1
} TCP_CB, *PTCP_CB;
```

### POC

[TcpConnectionCallbackTemp](TcpConnectionCallbackTemp)

```

`TcpConnectionCallbackTemp/TcpConnectionCallbackTemp.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29411.108
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TcpConnectionCallbackTemp", "TcpConnectionCallbackTemp\TcpConnectionCallbackTemp.vcxproj", "{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}.Debug|x64.ActiveCfg = Debug|x64
		{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}.Debug|x64.Build.0 = Debug|x64
		{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}.Debug|x64.Deploy.0 = Debug|x64
		{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}.Release|x64.ActiveCfg = Release|x64
		{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}.Release|x64.Build.0 = Release|x64
		{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F6B6CF74-E51C-4A4B-8053-461D04B0F865}
	EndGlobalSection
EndGlobal

```

`TcpConnectionCallbackTemp/TcpConnectionCallbackTemp/TcpConnectionCallbackTemp.c`:

```c
#include <ntifs.h>

#define IPByte1(x) ((int)((x) & 0xff))
#define IPByte2(x) ((int)(((x) >> 8) & 0xff))
#define IPByte3(x) ((int)(((x) >> 16) & 0xff))
#define IPByte4(x) ((int)(((x) >> 24) & 0xff))

DRIVER_INITIALIZE   DriverEntry;
DRIVER_UNLOAD       DriverUnload;

PVOID               g_TcpConnRegisteredCallback;
CALLBACK_FUNCTION   TcpConnCallback;

typedef struct _TCP_CB
{
    UINT16  Magic;
    UINT16  Reserved;
    DWORD32 Unknown0; // observed values: 1, 3, 5, 6, 7, 10, 11
    DWORD64 NotificationType; // observed values: 1, 3, 4, 5
    PVOID   pSrcIpAddr;
    PVOID   pDstIpAddr;
    UINT16  pSrcPort;
    UINT16  pDstPort;
    DWORD32 Unknown1; // observed values: 0xe0000001
    DWORD32 Unknown2; // observed values: 0xe0000001
    DWORD32 Unknown3; // 0x21, 0x1
} TCP_CB, *PTCP_CB;

VOID
TcpConnCallback(
    _In_opt_    PVOID   CallbackContext,
    _In_opt_    PVOID   Argument1,
    _In_opt_    PVOID   Argument2
)
{
    UNREFERENCED_PARAMETER(CallbackContext);
    
    PTCP_CB pTcpCb = (PTCP_CB)Argument2;
    ULONG   IPv4Addr;

    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
               DPFLTR_INFO_LEVEL,
               __FUNCTION__ ": [+] Argument1: %#08llX\n", (DWORD64)Argument1);

    if (pTcpCb != NULL) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": [*] Magic: %#06x Reserved: %#06x\n",
                   pTcpCb->Magic,
                   pTcpCb->Reserved
        );

        switch (pTcpCb->NotificationType) {
        case 1:
            if (pTcpCb->Unknown0 == 11) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~1] Called from TcpShutdownTimeWaitTcb\n"
                );
            } else if (pTcpCb->Unknown0 == 10) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~1] Called from TcpTcbCarefulDatagram\n"
                );
            } else {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~1] Called from TcpShutdownTcb or TcpInvokeCcb. Unknown0: %#10lx\n",
                           pTcpCb->Unknown0
                );
            }

            break;
        case 3:
            if (pTcpCb->Unknown0 == 1) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~2] Called from TcpCreateAndConnectTcbRateLimitComplete\n"
                );
            } else {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~2] Called from ?\n"
                );
            }

            break;
        case 4:
            if (pTcpCb->Unknown0 == 1) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~3] Called from TcpCreateAndAcceptTcb\n"
                );
            } else {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~3] Called from ?\n"
                );
            }

            break;
        case 5:
            if (pTcpCb->Unknown0 == 3) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~4] Called from TcpCreateAndConnectTcbComplete\n"
                );
            } else {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [~4] Called from ?\n"
                );
            }

            break;
        default:
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ ": [~5] Called from InvokeCcb. NotificationType: %#10llx Unknown0: %#10lx\n",
                       pTcpCb->NotificationType,
                       pTcpCb->Unknown0
            );

            break;
        }


        if (pTcpCb->pSrcIpAddr && pTcpCb->pDstIpAddr) {
            IPv4Addr = *(PULONG)pTcpCb->pSrcIpAddr;
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ ": [<] Source IP: %d.%d.%d.%d Port: %u\n",
                       IPByte1(IPv4Addr),
                       IPByte2(IPv4Addr),
                       IPByte3(IPv4Addr),
                       IPByte4(IPv4Addr),
                       pTcpCb->pSrcPort
            );
            IPv4Addr = *(PULONG)pTcpCb->pDstIpAddr;
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ ": [>] Destination IP: %d.%d.%d.%d Port: %u\n",
                       IPByte1(IPv4Addr),
                       IPByte2(IPv4Addr),
                       IPByte3(IPv4Addr),
                       IPByte4(IPv4Addr),
                       pTcpCb->pDstPort
            );
        }

        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": [-] Unknown1: %#10x Unknown2: %#10x Unknown3: %#10x\n",
                   pTcpCb->Unknown1,
                   pTcpCb->Unknown1,
                   pTcpCb->Unknown3
        );
    } else {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ ": [!] Argument2 isn't available\n");
    }
}

VOID DriverUnload(
    _In_    PDRIVER_OBJECT  DriverObject
)
{
    UNREFERENCED_PARAMETER(DriverObject);

    if (g_TcpConnRegisteredCallback != NULL) {
        ExUnregisterCallback(g_TcpConnRegisteredCallback);
    }
}

NTSTATUS
DriverEntry(
    _In_    PDRIVER_OBJECT  DriverObject,
    _In_    PUNICODE_STRING RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    DriverObject->DriverUnload = DriverUnload;

    PCALLBACK_OBJECT    pTcpConnCb = NULL;
    UNICODE_STRING      TcpConnObjName = RTL_CONSTANT_STRING(L"\\Callback\\TcpConnectionCallbackTemp");
    OBJECT_ATTRIBUTES   TcpConnObjAttr;
    RtlSecureZeroMemory(&TcpConnObjAttr, sizeof(OBJECT_ATTRIBUTES));
    TcpConnObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    TcpConnObjAttr.ObjectName = &TcpConnObjName;
    TcpConnObjAttr.Attributes = 0x50;

    if (!NT_SUCCESS(ExCreateCallback(&pTcpConnCb, &TcpConnObjAttr, TRUE, TRUE))) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ ": Failed to obtain callback object!\n");

        return STATUS_NOT_FOUND;
    }

    g_TcpConnRegisteredCallback = ExRegisterCallback(pTcpConnCb, TcpConnCallback, NULL);
    if (g_TcpConnRegisteredCallback != NULL) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": Callback was successfully registered!\n");

    } else {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ ": Hmmm, something wrong!\n");

    }

    return STATUS_SUCCESS;
}
```

`TcpConnectionCallbackTemp/TcpConnectionCallbackTemp/TcpConnectionCallbackTemp.inf`:

```inf
;
; TcpConnectionCallbackTemp.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=TcpConnectionCallbackTemp.cat

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]


[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName=""
DiskName="TcpConnectionCallbackTemp Source Disk"

```

`TcpConnectionCallbackTemp/TcpConnectionCallbackTemp/TcpConnectionCallbackTemp.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0B8A304E-E1CA-4E1E-B369-84B109AFCD19}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TcpConnectionCallbackTemp</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemGroup>
    <Inf Include="TcpConnectionCallbackTemp.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="TcpConnectionCallbackTemp.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TcpConnectionCallbackTemp/TcpConnectionCallbackTemp/TcpConnectionCallbackTemp.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="TcpConnectionCallbackTemp.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="TcpConnectionCallbackTemp.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`WdEbNotificationCallback/README.md`:

```md
## WdEbNotificationCallback

The main function of this callback is to notify `WdFilter` when a `KnonwBadImage` has tried to be loaded. Of course, this callback is notified from within `WdBoot` (Windows Defender ELAM driver), more specifically from the [`BOOT_DRIVER_CALLBACK_FUNCTION`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nc-ntddk-boot_driver_callback_function) of this driver.

To trigger this callback the parameter [`BDCB_CALLBACK_TYPE`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ne-ntddk-_bdcb_callback_type) must be set to `BdCbStatusUpdate` (A status update provided by the system to a boot-start driver) and the structure [`_BDCB_IMAGE_INFORMATION`](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-_bdcb_image_information) must have the field Classification set to `BdCbClassificationKnownBadImage`.

![WdBoot ExNotifyCallback](images/CallExNotifyCallback.png)

In the previous image we can see the call that executes `WdBoot` to notify the callback routines. Argument1 is a pointer to MpEbGlobals.Magic and Argument2 is set to 0x28. The MpEbGlobals structure has the following definition
 
```c
// sizeof(MP_EP_GLOBALS) == 0xB0
struct __declspec(align(4)) MP_EP_GLOBALS
{
  UNICODE_STRING RegistryPath;
  PVOID pHandleRegistration;
  PVOID IoUnregisterBootDriverCallback;
  DWORD Magic; // Set to 0x28EB01
  DWORD SignaturesVersionMajor;
  DWORD SignaturesVersionMinor;
  DWORD Unk_Unused;
  LIST_ENTRY DriversListEntry;
  PSLIST_ENTRY pSlistEntry;
  PCALLBACK_OBJECT WdCallbackObject;
  LARGE_INTEGER Cookie;
  _QWORD Unk_Unused1;
  SLIST_HEADER SlistHeader;
  DWORD LoadedDriversCount;
  DWORD LoadedDriversArrayLen;
  PVOID LoadedDriversArray; 
  DWORD TotalModulesEntryLen;
  BYTE EntryPointWdFilter[32];
  BYTE FlagWdOrMp;
  BYTE FlagTestMode;
  BYTE FlagPersistElamInfo;
  BYTE Alignment;
  _QWORD Unk_Unused2;
};
```
> Sorry for the own advertisement 😆
> but if you want to learn more about `WdBoot`check this post https://n4r1b.netlify.com/en/posts/2019/11/understanding-wdboot-windows-defender-elam/

As we can see, this structure has some quite interesting fields that we will be able to access if we register a routine for this callback.

### Possible use cases
> The following cases haven't been tested, is just theorical. We still need to write POCs to test them on the other hand there're some big downsides which make this quite useless.

- As we can see on MP_EP_GLOBALS, if we go back in the structure from the Magic field we can get the value of IoUnregisterBootDriverCallback. This function will be called when `WdBoot` is unloaded from memory. So there's a chance to change to change that pointer to our own function (Kinda hooking) so our function will be automatically called when `WdBoot`is unloaded from memory. Of course there's a big downside here, this callback is execute only when a `KnonwBadImage` is found, and of course if this happens the system will probably Bug Check. So not really a big deal here.

![MpEbUnload](images/MpEbUnload.png)

- This one needs further investigation on `WdFilter`, but it may be possible to access the DriversListEntry(Refer to the post to see the structure used in this field) and modify the Classification that was set by the ELAM driver. This could possibly lead to `WdFilter` believing this a `KnownGoodImage`, since `WdFilter` will use this information too. The downside here is that the routine registered by `WdFilter` execute before our registered routine, but this could probably be changed modifying the CALLBACK_OBJECT.CallbackFunctions LIST_ENTRY in order to make our routine first. (**This still needs investigation**)

![WdFilter Saving DriverClassification](images/WdFilterCopyData.png)

```

`WdNriNotificationCallback/README.md`:

```md
## WdNriNotificationCallback

### Description

The callback object can be created in 2 places: `WdFilter.sys` and `WdNisDrv.sys`. But a callback function is registered only in `WdFilter.sys`, last time we checked the callback was named `MpNriNotificationCallback`. The callback in itself isn't very interesting and in essence is just a wrapper around `MpRefreshProcessNotifications`, which we already sketched in [WdProcessNotificationCallback](../WdProcessNotificationCallback). Callback's code is provided just as a future reference:

![callback](images/callback.png)

We observed that this callback object is notified from `WdNisDrv.sys` - `set_process_exceptions(PMP_DATA , PIRP *)`.

![callback_notif](images/callback_notif.png)

```

`WdProcessNotificationCallback/README.md`:

```md
## WdProcessNotificationCallback

### Description

`WdProcessNotificationCallback` callback object is "born" either from `WdFilter.sys` or `WdNisDrv.sys`. In both cases it is created by a wrapper function called `MpCreateCallback`.
But `WdFilter` is a bit special, because the callback object can be named `MpProcessNotificationCallback`(observe the difference of 2 characters in the prefix). This change of behavior
is controlled byte a `boolean` flag(exhausting his existence at offset `+0x6B1`) in `MpData` context structure maintained by the driver - `MpData`. If the value of the `boolean` flag is `1`, look
for `WdProcessNotificationCallback`...
![obj_creation](images/obj_creation.png)

Unsurprisingly, the code path that ends in notifying this object goes through `WdFilter.sys` and last 4 stack frames, in case of process creation or termination, can be stamped as:

![stack_frames](images/stack_frames.png)

Before going further, it is necessary to know when our callback will receive a notification for the callback object we've registered. Extending the thought from above and observing that there are _5_
calls to `ExNotifyCallback` having their first argument `MpData + 0x6D8`, standing for `CallbackObject` parameter as presented in [MSDN](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exnotifycallback), it is possible to affirm that the following operations are going to "disturb" our callback:
- **Process creation**
- **Process termination**, both called from `MpHandleProcessNotification`
- **Refresh process notifications**, called from `MpRefreshProcessNotification`
- **Set trusted process**, called from `MpSetTrustedProcess`
- **Set untrusted process**, called from `MpSetUntrustedProcess`

In order to understand what data our callback will obtain, we have to peel the onion level by level. Let's start with process creation and termination. At the outer level, an easy target, we find `MpCreateProcessNotifyRoutineEx` which receives 3 arguments.
For convenience, the [prototype](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nc-ntddk-pcreate_process_notify_routine_ex) of this function is:
```C
void PcreateProcessNotifyRoutineEx(
  PEPROCESS                 Process,
  HANDLE                    ProcessId,
  PPS_CREATE_NOTIFY_INFO    CreateInfo
)
```
The last parameter is a pointer to `PS_CREATE_NOTIFY_INFO` structure, created inside `PspCallProcessNotifyRoutines`, having the following [definition](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-_ps_create_notify_info):
```C
typedef struct _PS_CREATE_NOTIFY_INFO {
  SIZE_T              Size;
  union {
    ULONG Flags;
    struct {
      ULONG FileOpenNameAvailable : 1;
      ULONG IsSubsystemProcess : 1;
      ULONG Reserved : 30;
    };
  };
  HANDLE              ParentProcessId;
  CLIENT_ID           CreatingThreadId;
  struct _FILE_OBJECT *FileObject;
  PCUNICODE_STRING    ImageFileName;
  PCUNICODE_STRING    CommandLine;
  NTSTATUS            CreationStatus;
} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;
```

Skipping some details in `MpCreateProcessNotifyRoutineEx`, our attention can be directed to the call into `MpHandleProcessNotification`. Here's an attempt of outlining a prototype for this routine:
```C
VOID MpHandleProcessNotification(PEPROCESS          Process,
                                 HANDLE             PPid,
                                 HANDLE             Pid,
                                 BOOL               Create,
                                 BOOL               IsTransactedFileOperation,
                                 PUNICODE_STRING    ImageFileName,
                                 PUNICODE_STRING    CommandLine,
                                 PVOID              pOutput);
```

Fourth parameter, `Create`, when `TRUE` indicates that `WdFilter` has to handle _process creation_ and _process termination_ for the opposite case.
Before sending a notification for _process creation_, a couple of other interesting actions are taken. Let's start with:
```C
NTSTATUS MpCreateProcessContext(HANDLE              Pid,
                                LONGLONG            ProcessCreationTime,
                                PCUNICODE_STRING    *ImageFileName,
                                MP_PROCESS_CONTEXT  **ProcessContextListEntry)
```

The purpose of `MpCreateProcessContext` is clear from its name, but our interest is what is the definition of a process context. First things first, every created process that reaches this code path
will have a process context inside `WdFilter`. There's a global structure, whose structure definition we named `MP_PROCESS_TABLE`, pointed by `MpProcessTable` global variable that keeps
record of what processes were created. Currently, based on the code that initializes this structure - `MpInitializeProcessTable`, `WdFilter` keeps track of maximum _128_ processes. Some of this structure's
fields we hadn't observed being used, thus we consider them to be reserved or simply unused currently( or we made some mistake, we hope not). Our definition for it is:

```C
typedef struct _MP_PROCESS_TABLE
{
  DWORD64               Magic; // 0x1C0DA13, 0x1C0 is the size of the structure, so the first field can be the SizeOfStruct, but...
  ERESOURCE             MpProcessTableEresource;
  PVOID                 Reserved1;
  PVOID                 Reserved2;
  NPAGED_LOOKASIDE_LIST PagedLookasideList1;
  NPAGED_LOOKASIDE_LIST PagedLookasideList2;
  PLIST_ENTRY           ProcessContexts;
  KEVENT                MpProcessTableKevent;
  __int64               AddendTrustedProcess;
  __int64               AddendUntrustedProcess;
  __int64               Addend3;
  PVOID                 Reserved3;
} MP_PROCESS_TABLE, *PMP_PROCESS_TABLE;
```

Every new process gets a "seat" inside the list named `ProcessContexts`. Every member actually is part of another structure, which we named(surprise, surprise) - `MP_PROCESS_CONTEXT`. The fields of
each process context are initialized inside `MpCreateProcessContext`. Unfortunately, as before, some fields remain a mystery to us, for some of them the semantics isn't well understood and for others no trace of usage. Living those as reserved, the definition looks like so:

```C
typedef struct _MP_PROCESS_CONTEXT
{
  DWORD64                           Magic; // 0xC0DA0F; previous version of WdFilter used 0xC8DA0F, 8 bytes more and it was containing the field that is commented `FileNameInformation`
  LIST_ENTRY                        ListEntry;
  HANDLE                            Pid;
  LONGLONG                          ProcessCreationTime;
  PUNICODE_STRING                   ProcessCommandLine;
  INT32                             Addend;
  DWORD32                           ProcessFlags;
  DWORD32                           Reserved1;
  DWORD32                           Reserved2;
  INT64                             Reserved3;
  INT64                             Reserved4;
  PMP_DOC_OPEN_RULE                 MpDocOpenRule;
  PFLT_COMPLETED_ASYNC_IO_CALLBACK  PfltCompletedAsyncIoCallback;
  INT32                             Addend2;
  INT32                             Addend3;
  INT64                             Addend4;
  INT64                             Reserved5;
  SUBSYSTEM_INFORMATION_TYPE        ProcessSubsystemInfo;
  PUNICODE_STRING                   ProcessName;
  _m128                             Reserved6;
  _m128                             Reserved7;
  _m128                             Reserved8;
  _PS_PROTECTION                    ProcessProtectionInfo;
  INT32                             Reserved9; // initialized to 0
  // PFLT_FILE_NAME_INFORMATION        FileNameInformation;
} MP_PROCESS_CONTEXT, *PMP_PROCESS_CONTEXT;
```

An interesting member residing in the above definition is `MpDocOpenRule`. There are a set of functions that contain the pattern `DocOpenRule`, into which we didn't dig, but it was easy to understand
that the data structures follow the same architectural pattern as before, a global struct in this case named `MpBmDocOpenRules` containing a linked list where members are stored. The definitions that we derived are:

```C
typedef struct _MP_DOC_OPEN_RULES
{
  DWORD64               Magic; // 0x100DA14
  PLIST_ENTRY           ListEntryHead;
  ERESOURCE             MpDocEresource;
  PVOID                 Reserved;
  PAGED_LOOKASIDE_LIST  MpDocLookasideList;
} MP_DOC_OPEN_RULES, *PMP_DOC_OPEN_RULES;
```

```C
typedef struct _MP_DOC_OPEN_RULE
{
  DWORD32       Magic; // 0x228DA15
  INT32         Addend;
  PLIST_ENTRY   ListEntryHead;
  WCHAR         pBuffer[261];
  PVOID         PagedPoolBuffer;
} MP_DOC_OPEN_RULE, *PMP_DOC_OPEN_RULE;
```
For example the above buffer, `pBuffer` can contain data like:
```
0: kd> db ffff9588`dfd99dd0
ffff9588`dfd99dd0  41 00 63 00 72 00 6f 00-52 00 64 00 33 00 32 00  A.c.r.o.R.d.3.2.
ffff9588`dfd99de0  2e 00 65 00 78 00 65 00-00 00 00 00 00 00 00 00  ..e.x.e.........
```
And `PagedPoolBuffer`:
```
0: kd> db ffff9588`dfdd8eaa La
ffff9588`dfdd8eaa  70 00 64 00 66 00 00 00-00 00                    p.d.f.....
```

Seems like a _surjective function_ mapping a tool to a file extension such that `WD` can check if a `pdf` is opened with an expected tool? Not sure. They deserve some more research(for another time).

Ok, next are following a couple of other interesting function calls, let's welcome - `MpSetProcessDocOpenRule`, `MpSetProcessPreScanHook`, `MpSetProcessExempt`, `MpSetProcessHardening` and `MpSetProcessHardeningExclusion`.
Just from their names we see how appealing this functions are, but for the sake of keeping these notes as short as possible(and easy to understand) and not reversing the whole driver we're not going to dig into them now.
The next station(/call) is our destination, it's where we're meeting - [ExNotifyCallback](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exnotifycallback). We already know what is going to be the first argument, the third one is `NULL` for both cases(_process creation_ and _process termination_). We walked through to see what is going to be served for `Argument1`(second parameter). To understand it easier let's see a snippet from the code:

![proc_create_notif](images/proc_create_notif.png)

So this is the structure filled with sweets that we're going to get a pointer to. In a rush we quickly sputter a definition:
```C
typedef struct _WD_PS_NOTIFY_INFO
{
  HANDLE            Pid;
  PHANDLE           pPPid;
  PUNICODE_STRING   ImageFileName;
  DWORD32           OperationType;
  BOOLEAN           IsTrustedProcess;
} WD_PS_NOTIFY_INFO, *PWD_PS_NOTIFY_INFO;
```

But the sparkling thing in all that structure seems to be it's second field(highlighted in the image). And we think that's because we have a pointer to _parent pid_ instead of having it's value. Moreover that pointer is to a stack location. Why is that so?

![proc_create_stack](images/proc_create_stack.png)

So, in our opinion that second field is a pointer because this way we can get access to more information abstracted by the pointer to `MP_PROCESS_CONTEXT`. An updated structure definition and image:

```C
typedef struct _WD_PS_NOTIFY_INFO_EX
{
    PMP_PROCESS_CONTEXT pMpProcessContext;
    HANDLE              PPid;
    WD_PS_NOTIFY_INFO   WdPsNotifyInfo;
} WD_PS_NOTIFY_INFO_EX, *PWD_PS_NOTIFY_INFO_EX;
```
![proc_create_notif2](images/proc_create_notif2.png)

Until now we were in the realm of _process creation_. For _process termination_ there's not much to say, only two fields carrying useful information, `Pid` and `OperationType`.

![proc_termination](images/proc_termination.png)

When it comes to _set trusted process_ and _set untrusted process_ there's no much difference between them, both can be identified by `OperationType` being equal to _3_:
![set_trusted](images/set_trusted.png)
![set_untrusted](images/set_untrusted.png)

Both changes in state can be triggered from `MpUpdateProcessesWithExclusions` or `MpSetProcessInfoByContext`. State of being _trusted_ or _untrusted_ can be also obtained from `MP_PROCESS_CONTEXT.ProcessFlags` by checking _7th_ bit. For example this is how it is checked inside `MpSetUntrustedProcess`:
![set_untrusted_check](images/set_untrusted_check.png)

At last, _refresh process notifications_ in essence is an iteration over the list of process contexts with the purpose of sending a notification regarding fields that are also present in _set trusted process_ and _set untrusted process_. It is being called from `MpNriNotificationCallback`.

![refresh_proc](images/refresh_proc.png)
(_SOTSOG_)

### POC

[WdProcessNotificationCallback](WdProcessNotificationCallback) is a simple proof of concept driver to show how this feature can be used.

![poc](images/poc.png)

**To our knowledge, the only registered callback function for this callback object belongs to `WdNisDrv.sys` and is named `process_notification_callback`**

## EOF
```

`WdProcessNotificationCallback/WdProcessNotificationCallback.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.757
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wk_callback_hook", "WdProcessNotificationCallback\WdProcessNotificationCallback.vcxproj", "{92ED4119-0E78-47E1-89BE-59E54D0C8E59}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{92ED4119-0E78-47E1-89BE-59E54D0C8E59}.Debug|x64.ActiveCfg = Debug|x64
		{92ED4119-0E78-47E1-89BE-59E54D0C8E59}.Debug|x64.Build.0 = Debug|x64
		{92ED4119-0E78-47E1-89BE-59E54D0C8E59}.Debug|x64.Deploy.0 = Debug|x64
		{92ED4119-0E78-47E1-89BE-59E54D0C8E59}.Release|x64.ActiveCfg = Release|x64
		{92ED4119-0E78-47E1-89BE-59E54D0C8E59}.Release|x64.Build.0 = Release|x64
		{92ED4119-0E78-47E1-89BE-59E54D0C8E59}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0BB26D7F-B8FF-4229-9372-7A96BE3BBC47}
	EndGlobalSection
EndGlobal

```

`WdProcessNotificationCallback/WdProcessNotificationCallback/WdProcessNotificationCallback.c`:

```c
#include <fltKernel.h>

DRIVER_INITIALIZE   DriverEntry;
DRIVER_UNLOAD       DriverUnload;

PVOID g_WdRegisteredCallback;

#pragma warning(disable:4214 4201)
typedef struct _PS_PROTECTION {
    union {
        UCHAR Level;
        struct {
            UCHAR Type : 3;
            UCHAR Audit : 1;                  // Reserved
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

//
// 1 Creation of a process, 2 process deleted, 3 set trusted/untrusted process
//
typedef enum _WD_PROC_CB_TYPE { WD_PROC_CREATE = 1, WD_PROC_TERMINATE, WD_PROC_SET_TRUSTED_UNTRUSTED_REFRESH } WD_PROC_CB_TYPE;

//
// Magic values for each structure, to help keeping track when they change
//
typedef enum _MP_MAGICS { MP_MAGIC_PROC_CTX = 0xC0DA0F, MP_MAGIC_DOC_RULE = 0x228DA15 } MP_MAGICS;

//
// Expected size of each structure
//
typedef enum _MP_STRUCT_SIZE { MP_STSZ_PROC_CTX = 0xC0, MP_STSZ_DOC_RULE = 0x228 } MP_STRUCT_SIZE;


typedef struct _MP_DOC_OPEN_RULE
{
    DWORD32       Magic; // 0x228DA15
    INT32         Addend;
    PLIST_ENTRY   ListEntryHead;
    WCHAR         pBuffer[261];
    PVOID         PagedPoolBuffer;
} MP_DOC_OPEN_RULE, *PMP_DOC_OPEN_RULE;

typedef struct _MP_PROCESS_CONTEXT
{
    DWORD64                           Magic; // 0xC0DA0F; previous version of WdFilter used 0xC8DA0F
    LIST_ENTRY                        ListEntry;
    HANDLE                            Pid;
    LONGLONG                          ProcessCreationTime;
    PUNICODE_STRING                   ProcessCommandLine;
    INT32                             Addend;
    DWORD32                           ProcessFlags;
    DWORD32                           Reserved1;
    DWORD32                           Reserved2;
    INT64                             Reserved3;
    INT64                             Reserved4;
    PMP_DOC_OPEN_RULE                 MpDocOpenRule;
    PFLT_COMPLETED_ASYNC_IO_CALLBACK  PfltCompletedAsyncIoCallback;
    INT32                             Addend2;
    INT32                             Addend3;
    INT64                             Addend4;
    INT64                             Reserved5;
    SUBSYSTEM_INFORMATION_TYPE        ProcessSubsystemInfo;
    PUNICODE_STRING                   ProcessName;
    UCHAR                             Reserved6[48];
    PS_PROTECTION                     ProcessProtectionInfo;
    INT32                             Reserved9; // initialized to 0
    // PFLT_FILE_NAME_INFORMATION        FileNameInformation; // was available in a previous version of the structure
} MP_PROCESS_CONTEXT, *PMP_PROCESS_CONTEXT;

typedef struct _WD_PS_NOTIFY_INFO
{
    HANDLE            Pid;
    PHANDLE           pPPid;
    PUNICODE_STRING   ImageFileName;
    DWORD32           OperationType;
    BOOLEAN           IsTrustedProcess;
} WD_PS_NOTIFY_INFO, *PWD_PS_NOTIFY_INFO;

typedef struct _WD_PS_NOTIFY_INFO_EX
{
    PMP_PROCESS_CONTEXT pMpProcessContext;
    HANDLE              PPid;
    WD_PS_NOTIFY_INFO   WdPsNotifyInfo;
} WD_PS_NOTIFY_INFO_EX, *PWD_PS_NOTIFY_INFO_EX;

CALLBACK_FUNCTION WdProcCallback;

static_assert(sizeof(WD_PS_NOTIFY_INFO) == 0x20, "Incorrect WD_PS_NOTIFY_INFO structure size");
static_assert(sizeof(WD_PS_NOTIFY_INFO_EX) == 0x30, "Incorrect WD_PS_NOTIFY_INFO_EX structure size");
static_assert(sizeof(MP_PROCESS_CONTEXT) == MP_STSZ_PROC_CTX, "Incorrect MP_PROCESS_CONTEXT structure size");
static_assert(sizeof(MP_DOC_OPEN_RULE) == MP_STSZ_DOC_RULE, "Incorrect MP_DOC_OPEN_RULE structure size");

VOID
WdProcCallback(
    _In_opt_    PVOID   CallbackContext,
    _In_opt_    PVOID   Argument1,
    _In_opt_    PVOID   Argument2
)
{
    UNREFERENCED_PARAMETER(CallbackContext);
    UNREFERENCED_PARAMETER(Argument2);

    if (NULL == Argument1) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": Argument1 NULL !?");

        return;
    }

    PWD_PS_NOTIFY_INFO pWdProcNotifInfo = (PWD_PS_NOTIFY_INFO)Argument1;
    switch (pWdProcNotifInfo->OperationType)
    {
    case WD_PROC_CREATE:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": [+] New process with PID: %08x ImageFileName: %wZ\n",
                   HandleToULong(pWdProcNotifInfo->Pid),
                   pWdProcNotifInfo->ImageFileName
        );

        if (pWdProcNotifInfo->pPPid != NULL) {
            PWD_PS_NOTIFY_INFO_EX pWdProcNotifInfoEx = CONTAINING_RECORD(pWdProcNotifInfo->pPPid, WD_PS_NOTIFY_INFO_EX, PPid);
            if (NULL == pWdProcNotifInfoEx) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_ERROR_LEVEL,
                           __FUNCTION__ ": [!] Extended info isn't available!\n"
                );

                return;
            }
            if (pWdProcNotifInfoEx->pMpProcessContext->Magic != MP_MAGIC_PROC_CTX) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_ERROR_LEVEL,
                           __FUNCTION__ ": [!] MP_PROC_CONTEXT.Magic isn't matching: %08llX\n",
                           pWdProcNotifInfoEx->pMpProcessContext->Magic
                );
            } else {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           __FUNCTION__ ": [+] ProcessCreationTime: %lld ProcessCmdLine: %wZ PPID: %08x\n",
                           pWdProcNotifInfoEx->pMpProcessContext->ProcessCreationTime,
                           pWdProcNotifInfoEx->pMpProcessContext->ProcessCommandLine,
                           HandleToULong(pWdProcNotifInfoEx->PPid)
                );

                if (pWdProcNotifInfoEx->pMpProcessContext->MpDocOpenRule != NULL) {
                    if (pWdProcNotifInfoEx->pMpProcessContext->MpDocOpenRule->Magic != MP_MAGIC_DOC_RULE) {
                        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                                   DPFLTR_ERROR_LEVEL,
                                   __FUNCTION__ ": [!] MP_DOC_OPEN_RULE.Magic isn't matching: %04X\n",
                                   pWdProcNotifInfoEx->pMpProcessContext->MpDocOpenRule->Magic
                        );
                    } else {
                        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                                   DPFLTR_INFO_LEVEL,
                                   __FUNCTION__ ": [+] Doc Rule buffer: %lS\n",
                                   pWdProcNotifInfoEx->pMpProcessContext->MpDocOpenRule->pBuffer
                        );
                    }
                }
            }
            //
            // An earlier version of WdFilter(on Windows 10 Insiders Preview 19008) MP_PROCESS_CONTEXT had a PFLT_FILE_NAME_INFORMATION
            // pointer as its last field, so the size of the structure was 0xC8DA0F. Later that field was removed and the size of the
            // structure became 0xC0DA0F. Leaving this piece of code as a reference or maybe they'll rethink and add it back ;)
            //
#if 0
            if ((pWdProcNotifInfoEx->pMpProcessContext->Magic == 0xC8DA0F) && 
                (pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation != NULL)) {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                           DPFLTR_INFO_LEVEL,
                           "File name: %wZ",
                           &pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->Name
                );

                if ((pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->NamesParsed & FLTFL_FILE_NAME_PARSED_EXTENSION) &&
                    (pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->Extension.Length != 0)) {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                               DPFLTR_INFO_LEVEL,
                               "File extension: %wZ",
                               pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->Extension
                    );
                }
                if ((pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->NamesParsed & FLTFL_FILE_NAME_PARSED_PARENT_DIR) &&
                    (pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->ParentDir.Length != 0)) {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                               DPFLTR_INFO_LEVEL,
                               "File parent dir: %wZ",
                               &pWdProcNotifInfoEx->pMpProcessContext->FileNameInformation->ParentDir
                    );
                }
            }
#endif
        }

        break;

    case WD_PROC_TERMINATE:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": [-] Process terminated PID %08x\n", HandleToULong(pWdProcNotifInfo->Pid));

        break;
    case WD_PROC_SET_TRUSTED_UNTRUSTED_REFRESH:
        if (pWdProcNotifInfo->IsTrustedProcess) {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ ": [*] Set trusted process PID %08x\n", HandleToULong(pWdProcNotifInfo->Pid));
        } else {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                       DPFLTR_INFO_LEVEL,
                       __FUNCTION__ ": [*] Set untrusted process PID %08x\n", HandleToULong(pWdProcNotifInfo->Pid));
        }

        break;
    default:
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": [!] Why are you not treating me equally: %08x!?\n", pWdProcNotifInfo->OperationType);
        break;
    }
}

VOID DriverUnload(
    _In_    PDRIVER_OBJECT  DriverObject
)
{
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // The check is needed as ExUnregisterCallback doesn't check for a NULL pointer
    //
    if (g_WdRegisteredCallback != NULL) {
        ExUnregisterCallback(g_WdRegisteredCallback);
    }
}

NTSTATUS
DriverEntry(
    _In_    PDRIVER_OBJECT  DriverObject,
    _In_    PUNICODE_STRING RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    DriverObject->DriverUnload = DriverUnload;

    PCALLBACK_OBJECT    pWdProcessNotifCb = NULL;
    UNICODE_STRING      WdObjName = RTL_CONSTANT_STRING(L"\\Callback\\WdProcessNotificationCallback");
    OBJECT_ATTRIBUTES   WdProcNotifObjAttr; // InitializeObjectAttributes would be recommended to use, but...
    RtlSecureZeroMemory(&WdProcNotifObjAttr, sizeof(OBJECT_ATTRIBUTES));
    WdProcNotifObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    WdProcNotifObjAttr.ObjectName = &WdObjName;
    WdProcNotifObjAttr.Attributes = 0x210;

    if (!NT_SUCCESS(ExCreateCallback(&pWdProcessNotifCb, &WdProcNotifObjAttr, FALSE, FALSE))) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   __FUNCTION__ ": Failed to obtain callback object!\n");

        return STATUS_NOT_FOUND;
    }

    g_WdRegisteredCallback = ExRegisterCallback(pWdProcessNotifCb, WdProcCallback, NULL);
    if (g_WdRegisteredCallback != NULL) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": Callback was successfully registered!\n");

    } else {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_INFO_LEVEL,
                   __FUNCTION__ ": Hmmm, something wrong!\n");

    }

    return STATUS_SUCCESS;
}
```

`WdProcessNotificationCallback/WdProcessNotificationCallback/WdProcessNotificationCallback.inf`:

```inf
;
; WdProcessNotificationCallback.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=WdProcessNotificationCallback.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
WdProcessNotificationCallback_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
WdProcessNotificationCallback.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%WdProcessNotificationCallback.DeviceDesc%=WdProcessNotificationCallback_Device, Root\WdProcessNotificationCallback ; TODO: edit hw-id

[WdProcessNotificationCallback_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
WdProcessNotificationCallback.sys

;-------------- Service installation
[WdProcessNotificationCallback_Device.NT.Services]
AddService = WdProcessNotificationCallback,%SPSVCINST_ASSOCSERVICE%, WdProcessNotificationCallback_Service_Inst

; -------------- WdProcessNotificationCallback driver install sections
[WdProcessNotificationCallback_Service_Inst]
DisplayName    = %WdProcessNotificationCallback.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\WdProcessNotificationCallback.sys

;
;--- WdProcessNotificationCallback_Device Coinstaller installation ------
;

[WdProcessNotificationCallback_Device.NT.CoInstallers]
AddReg=WdProcessNotificationCallback_Device_CoInstaller_AddReg
CopyFiles=WdProcessNotificationCallback_Device_CoInstaller_CopyFiles

[WdProcessNotificationCallback_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[WdProcessNotificationCallback_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[WdProcessNotificationCallback_Device.NT.Wdf]
KmdfService =  WdProcessNotificationCallback, WdProcessNotificationCallback_wdfsect
[WdProcessNotificationCallback_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "WdProcessNotificationCallback Installation Disk"
WdProcessNotificationCallback.DeviceDesc = "WdProcessNotificationCallback Device"
WdProcessNotificationCallback.SVCDESC = "WdProcessNotificationCallback Service"

```

`WdProcessNotificationCallback/WdProcessNotificationCallback/WdProcessNotificationCallback.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{92ED4119-0E78-47E1-89BE-59E54D0C8E59}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>WdProcessNotificationCallback</RootNamespace>
    <ProjectName>WdProcessNotificationCallback</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="WdProcessNotificationCallback.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WdProcessNotificationCallback.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`WdProcessNotificationCallback/WdProcessNotificationCallback/WdProcessNotificationCallback.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="WdProcessNotificationCallback.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WdProcessNotificationCallback.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```