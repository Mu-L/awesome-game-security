Project Path: arc_stackOverflower92_FightingGame-UE5_ix4nz7yg

Source Tree:

```txt
arc_stackOverflower92_FightingGame-UE5_ix4nz7yg
├── Config
│   ├── DefaultEditor.ini
│   ├── DefaultEngine.ini
│   ├── DefaultGame.ini
│   ├── DefaultInput.ini
│   └── HoloLens
│       └── HoloLensEngine.ini
├── Content
│   ├── Fighter_Animations
│   │   ├── Animation
│   │   │   └── Sequence
│   │   │       ├── 01_Idle
│   │   │       │   ├── Idle_Combat_Seq.uasset
│   │   │       │   ├── Idle_Combat_to_Idle_Seq.uasset
│   │   │       │   ├── Idle_Seq.uasset
│   │   │       │   └── Idle_to_Idle_Combat_Seq.uasset
│   │   │       ├── 02_Walk
│   │   │       │   ├── 01_Walk_RM
│   │   │       │   │   ├── 01_Walk_F_0_RM
│   │   │       │   │   │   ├── Walk_F_0_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_0_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_F_0_Start_RM_Seq.uasset
│   │   │       │   │   ├── 02_Walk_F_L_45_RM
│   │   │       │   │   │   ├── Walk_F_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_F_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 03_Walk_F_R_45_RM
│   │   │       │   │   │   ├── Walk_F_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_F_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 04_Walk_F_L_90_RM
│   │   │       │   │   │   ├── Walk_F_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_F_L_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 05_Walk_F_R_90_RM
│   │   │       │   │   │   ├── Walk_F_R_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_R_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_F_R_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 06_Walk_B_180_RM
│   │   │       │   │   │   ├── Walk_B_180_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_180_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_B_180_Start_RM_Seq.uasset
│   │   │       │   │   ├── 07_Walk_B_L_45_RM
│   │   │       │   │   │   ├── Walk_B_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_L_45_Strat_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_F_L_45_Strat_RM_Seq.uasset
│   │   │       │   │   ├── 08_Walk_B_R_45_RM
│   │   │       │   │   │   ├── Walk_B_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_B_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 09_Walk_B_L_90_RM
│   │   │       │   │   │   ├── Walk_B_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_B_L_90_Start_RM_Seq.uasset
│   │   │       │   │   └── 10_Walk_B_R_90_RM
│   │   │       │   │       ├── Walk_B_R_90_End_RM_Seq.uasset
│   │   │       │   │       ├── Walk_B_R_90_Loop_RM_Seq.uasset
│   │   │       │   │       └── Walk_B_R_90_Start_RM_Seq.uasset
│   │   │       │   ├── 02_Walk_IP
│   │   │       │   │   ├── 01_Walk_F_0_IP
│   │   │       │   │   │   ├── Walk_F_0_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_0_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_F_0_Start_IP_Seq.uasset
│   │   │       │   │   ├── 02_Walk_F_L_45_IP
│   │   │       │   │   │   ├── Walk_F_L_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_L_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_F_L_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 03_Walk_F_R_45_IP
│   │   │       │   │   │   ├── Walk_F_R_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_R_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_F_R_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 04_Walk_F_L_90_IP
│   │   │       │   │   │   ├── Walk_F_L_90_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_L_90_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_F_L_90_Start_IP_Seq.uasset
│   │   │       │   │   ├── 05_Walk_F_R_90_IP
│   │   │       │   │   │   ├── Walk_F_R_90_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_F_R_90_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_F_R_90_Start_IP_Seq.uasset
│   │   │       │   │   ├── 06_Walk_B_180_IP
│   │   │       │   │   │   ├── Walk_B_180_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_180_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_B_180_Start_IP_Seq.uasset
│   │   │       │   │   ├── 07_Walk_B_L_45_IP
│   │   │       │   │   │   ├── Walk_B_L_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_L_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_B_L_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 08_Walk_B_R_45_IP
│   │   │       │   │   │   ├── Walk_B_R_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_R_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_B_R_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 09_Walk_B_L_90_IP
│   │   │       │   │   │   ├── Walk_B_L_90_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_B_L_90_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_B_L_90_Start_IP_Seq.uasset
│   │   │       │   │   └── 10_Walk_B_R_90_IP
│   │   │       │   │       ├── Walk_B_R_90_End_IP_Seq.uasset
│   │   │       │   │       ├── Walk_B_R_90_Loop_IP_Seq.uasset
│   │   │       │   │       └── Walk_B_R_90_Start_IP_Seq.uasset
│   │   │       │   ├── 03_Walk_Combat_RM
│   │   │       │   │   ├── 01_Walk_Combat_F_0_RM
│   │   │       │   │   │   ├── Walk_Combat_F_0_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_0_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_0_Start_RM_Seq.uasset
│   │   │       │   │   ├── 02_Walk_Combat_F_L_45_RM
│   │   │       │   │   │   ├── Walk_Combat_F_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 03_Walk_Combat_F_R_45_RM
│   │   │       │   │   │   ├── Walk_Combat_F_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 04_Walk_Combat_F_L_90_RM
│   │   │       │   │   │   ├── Walk_Combat_F_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_L_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 05_Walk_Combat_F_R_90_RM
│   │   │       │   │   │   ├── Walk_Combat_F_R_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_R_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_R_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 06_Walk_Combat_B_180_RM
│   │   │       │   │   │   ├── Walk_Combat_B_180_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_180_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_180_Start_RM_Seq.uasset
│   │   │       │   │   ├── 07_Walk_Combat_B_L_45_RM
│   │   │       │   │   │   ├── Walk_Combat_B_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 08_Walk_Combat_B_R_45_RM
│   │   │       │   │   │   ├── Walk_Combat_B_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 09_Walk_Combat_B_L_90_RM
│   │   │       │   │   │   ├── Walk_Combat_B_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_L_90_Start_RM_Seq.uasset
│   │   │       │   │   └── 10_Walk_Combat_B_R_90_RM
│   │   │       │   │       ├── Walk_Combat_B_R_90_End_RM_Seq.uasset
│   │   │       │   │       ├── Walk_Combat_B_R_90_Loop_RM_Seq.uasset
│   │   │       │   │       └── Walk_Combat_B_R_90_Start_RM_Seq.uasset
│   │   │       │   ├── 04_Walk_Combat_IP
│   │   │       │   │   ├── 01_Walk_Combat_F_0_IP
│   │   │       │   │   │   ├── Walk_Combat_F_0_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_0_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_0_Start_IP_Seq.uasset
│   │   │       │   │   ├── 02_Walk_Combat_F_L_45_IP
│   │   │       │   │   │   ├── Walk_Combat_F_L_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_L_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_L_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 03_Walk_Combat_F_R_45_IP
│   │   │       │   │   │   ├── Walk_Combat_F_R_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_R_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_R_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 04_Walk_Combat_F_L_90_IP
│   │   │       │   │   │   ├── Walk_Combat_F_L_90_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_L_90_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_L_90_Start_IP_Seq.uasset
│   │   │       │   │   ├── 05_Walk_Combat_F_R_90_IP
│   │   │       │   │   │   ├── Walk_Combat_F_R_90_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_F_R_90_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_F_R_90_Start_IP_Seq.uasset
│   │   │       │   │   ├── 06_Walk_Combat_B_180_IP
│   │   │       │   │   │   ├── Walk_Combat_B_180_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_180_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_180_Start_IP_Seq.uasset
│   │   │       │   │   ├── 07_Walk_Combat_B_L_45_IP
│   │   │       │   │   │   ├── Walk_Combat_B_L_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_L_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_L_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 08_Walk_Combat_B_R_45_IP
│   │   │       │   │   │   ├── Walk_Combat_B_R_45_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_R_45_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_R_45_Start_IP_Seq.uasset
│   │   │       │   │   ├── 09_Walk_Combat_B_L_90_IP
│   │   │       │   │   │   ├── Walk_Combat_B_L_90_End_IP_Seq.uasset
│   │   │       │   │   │   ├── Walk_Combat_B_L_90_Loop_IP_Seq.uasset
│   │   │       │   │   │   └── Walk_Combat_B_L_90_Start_IP_Seq.uasset
│   │   │       │   │   └── 10_Walk_Combat_B_R_90_IP
│   │   │       │   │       ├── Walk_Combat_B_R_90_End_IP_Seq.uasset
│   │   │       │   │       ├── Walk_Combat_B_R_90_Loop_IP_Seq.uasset
│   │   │       │   │       └── Walk_Combat_B_R_90_Start_IP_Seq.uasset
│   │   │       │   ├── 05_Walk_Block_RM
│   │   │       │   │   ├── 01_Walk_Block_F_0_RM
│   │   │       │   │   │   ├── Walk_Block_F_0_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_F_0_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_F_0_Start_RM_Seq.uasset
│   │   │       │   │   ├── 02_Walk_Block_F_L_45_RM
│   │   │       │   │   │   ├── Walk_Block_F_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_F_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_F_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 03_Walk_Block_F_R_45_RM
│   │   │       │   │   │   ├── Walk_Block_F_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_F_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_F_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 04_Walk_Block_F_L_90_RM
│   │   │       │   │   │   ├── Walk_Block_F_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_F_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_F_L_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 05_Walk_Block_F_R_90_RM
│   │   │       │   │   │   ├── Walk_Block_F_R_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_F_R_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_F_R_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 06_Walk_Block_B_180_RM
│   │   │       │   │   │   ├── Walk_Block_B_180_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_B_180_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_B_180_Start_RM_Seq.uasset
│   │   │       │   │   ├── 07_Walk_Block_B_L_45_RM
│   │   │       │   │   │   ├── Walk_Block_B_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_B_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_B_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 08_Walk_Block_B_R_45_RM
│   │   │       │   │   │   ├── Walk_Block_B_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_B_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_B_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 09_Walk_Block_B_L_90_RM
│   │   │       │   │   │   ├── Walk_Block_B_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Walk_Block_B_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Walk_Block_B_L_90_Start_RM_Seq.uasset
│   │   │       │   │   └── 10_Walk_Block_B_R_90_RM
│   │   │       │   │       ├── Walk_Block_B_R_90_End_RM_Seq.uasset
│   │   │       │   │       ├── Walk_Block_B_R_90_Loop_RM_Seq.uasset
│   │   │       │   │       └── Walk_Block_B_R_90_Start_RM_Seq.uasset
│   │   │       │   └── 06_Walk_Block_IP
│   │   │       │       ├── 01_Walk_Block_F_0_IP
│   │   │       │       │   ├── Walk_Block_F_0_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_F_0_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_F_0_Start_IP_Seq.uasset
│   │   │       │       ├── 02_Walk_Block_F_L_45_IP
│   │   │       │       │   ├── Walk_Block_F_L_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_F_L_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_F_L_45_Start_IP_Seq.uasset
│   │   │       │       ├── 03_Walk_Block_F_R_45_IP
│   │   │       │       │   ├── Walk_Block_F_R_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_F_R_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_F_R_45_Start_IP_Seq.uasset
│   │   │       │       ├── 04_Walk_Block_F_L_90_IP
│   │   │       │       │   ├── Walk_Block_F_L_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_F_L_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_F_L_90_Start_IP_Seq.uasset
│   │   │       │       ├── 05_Walk_Block_F_R_90_IP
│   │   │       │       │   ├── Walk_Block_F_R_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_F_R_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_F_R_90_Start_IP_Seq.uasset
│   │   │       │       ├── 06_Walk_Block_B_180_IP
│   │   │       │       │   ├── Walk_Block_B_180_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_B_180_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_B_180_Start_IP_Seq.uasset
│   │   │       │       ├── 07_Walk_Block_B_L_45_IP
│   │   │       │       │   ├── Walk_Block_B_L_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_B_L_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_B_L_45_Start_IP_Seq.uasset
│   │   │       │       ├── 08_Walk_Block_B_R_45_IP
│   │   │       │       │   ├── Walk_Block_B_R_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_B_R_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_B_R_45_Start_IP_Seq.uasset
│   │   │       │       ├── 09_Walk_Block_B_L_90_IP
│   │   │       │       │   ├── Walk_Block_B_L_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Walk_Block_B_L_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Walk_Block_B_L_90_Start_IP_Seq.uasset
│   │   │       │       └── 10_Walk_Block_B_R_90_IP
│   │   │       │           ├── Walk_Block_B_R_90_End_IP_Seq.uasset
│   │   │       │           ├── Walk_Block_B_R_90_Loop_IP_Seq.uasset
│   │   │       │           └── Walk_Block_B_R_90_Start_IP_Seq.uasset
│   │   │       ├── 03_Run
│   │   │       │   ├── 01_Run_RM
│   │   │       │   │   ├── 01_Run_F_0_RM
│   │   │       │   │   │   ├── Run_F_0_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_F_0_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_F_0_Start_RM_Seq.uasset
│   │   │       │   │   ├── 02_Run_F_L_45_RM
│   │   │       │   │   │   ├── Run_F_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_F_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_F_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 03_Run_F_R_45_RM
│   │   │       │   │   │   ├── Run_F_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_F_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_F_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 04_Run_F_L_90_RM
│   │   │       │   │   │   ├── Run_F_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_F_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_F_L_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 05_Run_F_R_90_RM
│   │   │       │   │   │   ├── Run_F_R_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_F_R_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_F_R_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 06_Run_B_180_RM
│   │   │       │   │   │   ├── Run_B_180_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_B_180_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_B_180_Start_RM_Seq.uasset
│   │   │       │   │   ├── 07_Run_B_L_45_RM
│   │   │       │   │   │   ├── Run_B_L_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_B_L_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_B_L_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 08_Run_B_R_45_RM
│   │   │       │   │   │   ├── Run_B_R_45_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_B_R_45_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_B_R_45_Start_RM_Seq.uasset
│   │   │       │   │   ├── 09_Run_B_L_90_RM
│   │   │       │   │   │   ├── Run_B_L_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_B_L_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_B_L_90_Start_RM_Seq.uasset
│   │   │       │   │   ├── 10_Run_B_R_90_RM
│   │   │       │   │   │   ├── Run_B_R_90_End_RM_Seq.uasset
│   │   │       │   │   │   ├── Run_B_R_90_Loop_RM_Seq.uasset
│   │   │       │   │   │   └── Run_B_R_90_Start_RM_Seq.uasset
│   │   │       │   │   └── 11_Run_Fast_RM
│   │   │       │   │       ├── Run_Fast_End_RM_Seq.uasset
│   │   │       │   │       ├── Run_Fast_Loop_RM_Seq.uasset
│   │   │       │   │       └── Run_Fast_Start_RM_Seq.uasset
│   │   │       │   └── 02_Run_IP
│   │   │       │       ├── 01_Run_F_0_IP
│   │   │       │       │   ├── Run_F_0_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_F_0_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_F_0_Start_IP_Seq.uasset
│   │   │       │       ├── 02_Run_F_L_45_IP
│   │   │       │       │   ├── Run_F_L_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_F_L_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_F_L_45_Start_IP_Seq.uasset
│   │   │       │       ├── 03_Run_F_R_45_IP
│   │   │       │       │   ├── Run_F_R_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_F_R_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_F_R_45_Start_IP_Seq.uasset
│   │   │       │       ├── 04_Run_F_L_90_IP
│   │   │       │       │   ├── Run_F_L_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_F_L_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_F_L_90_Start_IP_Seq.uasset
│   │   │       │       ├── 05_Run_F_R_90_IP
│   │   │       │       │   ├── Run_F_R_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_F_R_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_F_R_90_Start_IP_Seq.uasset
│   │   │       │       ├── 06_Run_B_180_IP
│   │   │       │       │   ├── Run_B_180_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_B_180_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_B_180_Start_IP_Seq.uasset
│   │   │       │       ├── 07_Run_B_L_45_IP
│   │   │       │       │   ├── Run_B_L_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_B_L_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_B_L_45_Start_IP_Seq.uasset
│   │   │       │       ├── 08_Run_B_R_45_IP
│   │   │       │       │   ├── Run_B_R_45_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_B_R_45_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_B_R_45_Start_IP_Seq.uasset
│   │   │       │       ├── 09_Run_B_L_90_IP
│   │   │       │       │   ├── Run_B_L_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_B_L_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_B_L_90_Start_IP_Seq.uasset
│   │   │       │       ├── 10_Run_B_R_90_IP
│   │   │       │       │   ├── Run_B_R_90_End_IP_Seq.uasset
│   │   │       │       │   ├── Run_B_R_90_Loop_IP_Seq.uasset
│   │   │       │       │   └── Run_B_R_90_Start_IP_Seq.uasset
│   │   │       │       └── 11_Run_Fast_IP
│   │   │       │           ├── Run_Fast_End_IP_Seq.uasset
│   │   │       │           ├── Run_Fast_Loop_IP_Seq.uasset
│   │   │       │           └── Run_Fast_Start_IP_Seq.uasset
│   │   │       ├── 04_Jump
│   │   │       │   ├── 01_Jump
│   │   │       │   │   ├── Jump_0_End_Seq.uasset
│   │   │       │   │   ├── Jump_0_Loop_Seq.uasset
│   │   │       │   │   ├── Jump_0_Seq.uasset
│   │   │       │   │   ├── Jump_0_Start_Seq.uasset
│   │   │       │   │   ├── Jump_B_180_Seq.uasset
│   │   │       │   │   ├── Jump_F_0_Seq.uasset
│   │   │       │   │   ├── Jump_L_90_Seq.uasset
│   │   │       │   │   └── Jump_R_90_Seq.uasset
│   │   │       │   ├── 02_Double_Jump
│   │   │       │   │   ├── Double_Jump_0_Seq.uasset
│   │   │       │   │   ├── Double_Jump_B_180_Seq.uasset
│   │   │       │   │   ├── Double_Jump_F_0_Seq.uasset
│   │   │       │   │   ├── Double_Jump_L_90_Seq.uasset
│   │   │       │   │   └── Double_Jump_R_90_Seq.uasset
│   │   │       │   ├── Jump_0_End_Seq.uasset
│   │   │       │   ├── Jump_0_Loop_Seq.uasset
│   │   │       │   ├── Jump_0_Seq.uasset
│   │   │       │   ├── Jump_0_Start_Seq.uasset
│   │   │       │   ├── Jump_B_180_Seq.uasset
│   │   │       │   ├── Jump_F_0_Seq.uasset
│   │   │       │   ├── Jump_L_90_Seq.uasset
│   │   │       │   └── Jump_R_90_Seq.uasset
│   │   │       ├── 05_Dodge
│   │   │       │   ├── 01_Dodge
│   │   │       │   │   ├── Dodge_Back_Seq.uasset
│   │   │       │   │   ├── Dodge_Front_Seq.uasset
│   │   │       │   │   ├── Dodge_L_Seq.uasset
│   │   │       │   │   └── Dodge_R_Seq.uasset
│   │   │       │   ├── 02_Dodge_Air
│   │   │       │   │   ├── Dodge_Air_Back_Seq.uasset
│   │   │       │   │   ├── Dodge_Air_Front_Seq.uasset
│   │   │       │   │   ├── Dodge_Air_L_Seq.uasset
│   │   │       │   │   └── Dodge_Air_R_Seq.uasset
│   │   │       │   ├── Dodge_Back_Seq.uasset
│   │   │       │   ├── Dodge_Front_Seq.uasset
│   │   │       │   ├── Dodge_L_Seq.uasset
│   │   │       │   └── Dodge_R_Seq.uasset
│   │   │       ├── 06_Roll
│   │   │       │   ├── Roll_B_180_Seq.uasset
│   │   │       │   ├── Roll_F_0_Seq.uasset
│   │   │       │   ├── Roll_L_90_Seq.uasset
│   │   │       │   └── Roll_R_90_Seq.uasset
│   │   │       ├── 07_Hit
│   │   │       │   ├── Block_Hit_Break_Seq.uasset
│   │   │       │   ├── Block_Hit_Seq.uasset
│   │   │       │   ├── Block_Idle_Seq.uasset
│   │   │       │   ├── Get_Up_Seq.uasset
│   │   │       │   ├── Hit_Air_1_Seq.uasset
│   │   │       │   ├── Hit_Air_2_Seq.uasset
│   │   │       │   ├── Hit_Air_3_Seq.uasset
│   │   │       │   ├── Hit_B_Seq.uasset
│   │   │       │   ├── Hit_Death_Seq.uasset
│   │   │       │   ├── Hit_F_Seq.uasset
│   │   │       │   ├── Hit_Heavy_End_Seq.uasset
│   │   │       │   ├── Hit_Heavy_Loop_Seq.uasset
│   │   │       │   ├── Hit_Heavy_Seq.uasset
│   │   │       │   ├── Hit_Heavy_Start_Seq.uasset
│   │   │       │   ├── Hit_L_Seq.uasset
│   │   │       │   ├── Hit_R_Seq.uasset
│   │   │       │   ├── Knock_Down_Death_Seq.uasset
│   │   │       │   ├── Knock_Down_Get_Up_Seq.uasset
│   │   │       │   ├── Knock_Down_Loop_Seq.uasset
│   │   │       │   ├── Knock_Down_Strat_Seq.uasset
│   │   │       │   └── Parry_Counter_Seq.uasset
│   │   │       ├── 08_Combo_01
│   │   │       │   ├── Combo_01-1_Seq.uasset
│   │   │       │   ├── Combo_01-2_Seq.uasset
│   │   │       │   ├── Combo_01-3_Seq.uasset
│   │   │       │   ├── Combo_01-4_Seq.uasset
│   │   │       │   └── Combo_01_Seq.uasset
│   │   │       ├── 09_Combo_02
│   │   │       │   ├── Combo_02-1_Seq.uasset
│   │   │       │   ├── Combo_02-2_Seq.uasset
│   │   │       │   ├── Combo_02-3_Seq.uasset
│   │   │       │   ├── Combo_02-4_Seq.uasset
│   │   │       │   └── Combo_02_Seq.uasset
│   │   │       ├── 10_Combo_03
│   │   │       │   ├── Combo_03-1_Seq.uasset
│   │   │       │   ├── Combo_03-2_Seq.uasset
│   │   │       │   ├── Combo_03-3_Seq.uasset
│   │   │       │   ├── Combo_03-4_Seq.uasset
│   │   │       │   └── Combo_03_Seq.uasset
│   │   │       ├── 11_Combo_04
│   │   │       │   ├── Combo_04-1_Seq.uasset
│   │   │       │   ├── Combo_04-2_Seq.uasset
│   │   │       │   ├── Combo_04-3_Seq.uasset
│   │   │       │   ├── Combo_04-4_Seq.uasset
│   │   │       │   └── Combo_04_Seq.uasset
│   │   │       ├── 12_Air_combo
│   │   │       │   ├── Air_Combo-1_Seq.uasset
│   │   │       │   ├── Air_Combo-2_Seq.uasset
│   │   │       │   ├── Air_Combo-3_Seq.uasset
│   │   │       │   ├── Air_Combo-4_Seq.uasset
│   │   │       │   └── Air_Combo_Seq.uasset
│   │   │       ├── 13_Attack
│   │   │       │   ├── Attack_01_Seq.uasset
│   │   │       │   ├── Attack_02_Seq.uasset
│   │   │       │   ├── Attack_03_Seq.uasset
│   │   │       │   ├── Attack_04_Seq.uasset
│   │   │       │   ├── Attack_05_Seq.uasset
│   │   │       │   ├── Attack_06_Seq.uasset
│   │   │       │   ├── Run_Attack_01_Seq.uasset
│   │   │       │   └── Run_Attack_02_Seq.uasset
│   │   │       ├── 14_Turn
│   │   │       │   ├── 01_Turn
│   │   │       │   │   ├── Turn_180_L_Seq.uasset
│   │   │       │   │   ├── Turn_180_R_Seq.uasset
│   │   │       │   │   ├── Turn_90_L_Seq.uasset
│   │   │       │   │   └── Turn_90_R_Seq.uasset
│   │   │       │   └── 02_Turn_Combat
│   │   │       │       ├── Turn_Combat_180_L_Seq.uasset
│   │   │       │       ├── Turn_Combat_180_R_Seq.uasset
│   │   │       │       ├── Turn_Combat_90_L_Seq.uasset
│   │   │       │       └── Turn_Combat_90_R_Seq.uasset
│   │   │       ├── 15_Execution
│   │   │       │   ├── 01_Execution
│   │   │       │   │   ├── Execution_01_Seq.uasset
│   │   │       │   │   ├── Execution_02_Seq.uasset
│   │   │       │   │   └── Execution_03_Seq.uasset
│   │   │       │   └── 02_Target
│   │   │       │       ├── Execution_Target_01_Seq.uasset
│   │   │       │       ├── Execution_Target_02_Seq.uasset
│   │   │       │       └── Execution_Target_03_Seq.uasset
│   │   │       └── 16_Air_Attack
│   │   │           ├── 01_Attack_Air_to_Floor_01
│   │   │           │   ├── Attack_Air_to_Floor_01_End_Seq.uasset
│   │   │           │   ├── Attack_Air_to_Floor_01_Loop_Seq.uasset
│   │   │           │   └── Attack_Air_to_Floor_01_Start_Seq.uasset
│   │   │           ├── 02_Attack_Air_to_Floor_02
│   │   │           │   ├── Attack_Air_to_Floor_02_End_Seq.uasset
│   │   │           │   ├── Attack_Air_to_Floor_02_Loop_Seq.uasset
│   │   │           │   └── Attack_Air_to_Floor_02_Start_Seq.uasset
│   │   │           ├── 03_Attack_Air_to_Floor_03
│   │   │           │   ├── Attack_Air_to_Floor_03_End_Seq.uasset
│   │   │           │   ├── Attack_Air_to_Floor_03_Loop_Seq.uasset
│   │   │           │   └── Attack_Air_to_Floor_03_Start_Seq.uasset
│   │   │           ├── 04_Attack_Air_Up_01
│   │   │           │   └── Attack_Air_Up_01_Seq.uasset
│   │   │           └── 05_Attack_Air_Up_02
│   │   │               └── Attack_Air_Up_02_Seq.uasset
│   │   ├── Level
│   │   │   └── Demo_Map.umap
│   │   ├── Mannequin
│   │   │   └── Character
│   │   │       ├── Materials
│   │   │       │   ├── M_UE4Man_Body.uasset
│   │   │       │   ├── M_UE4Man_ChestLogo.uasset
│   │   │       │   └── MaterialLayers
│   │   │       │       ├── ML_GlossyBlack_Latex_UE4.uasset
│   │   │       │       ├── ML_Plastic_Shiny_Beige.uasset
│   │   │       │       ├── ML_Plastic_Shiny_Beige_LOGO.uasset
│   │   │       │       ├── ML_SoftMetal_UE4.uasset
│   │   │       │       ├── T_ML_Aluminum01.uasset
│   │   │       │       ├── T_ML_Aluminum01_N.uasset
│   │   │       │       ├── T_ML_Rubber_Blue_01_D.uasset
│   │   │       │       └── T_ML_Rubber_Blue_01_N.uasset
│   │   │       ├── Mesh
│   │   │       │   ├── SK_Mannequin.uasset
│   │   │       │   ├── SK_Mannequin_PhysicsAsset.uasset
│   │   │       │   ├── UE4_Mannequin_Skeleton.uasset
│   │   │       │   └── UE4_Mannequin_Skeleton_AnimBlueprint.uasset
│   │   │       └── Textures
│   │   │           ├── UE4Man_Logo_N.uasset
│   │   │           ├── UE4_LOGO_CARD.uasset
│   │   │           ├── UE4_Mannequin_MAT_MASKA.uasset
│   │   │           └── UE4_Mannequin__normals.uasset
│   │   └── Material
│   │       ├── M_Floor.uasset
│   │       ├── M_Floor_Sub.uasset
│   │       ├── M_Wall.uasset
│   │       └── M_Wall_2.uasset
│   ├── Game
│   │   ├── Camera
│   │   │   ├── BP_CameraManager.uasset
│   │   │   ├── BP_CharactersSharedCamera.uasset
│   │   │   └── Shakes
│   │   │       └── CS_SurfaceHit.uasset
│   │   ├── Characters
│   │   │   └── TestCharacter
│   │   │       ├── BP_TestCharacter.uasset
│   │   │       ├── FreeAnimations
│   │   │       │   └── ANIM_AirborneKnockedBack.uasset
│   │   │       ├── MDT_TestCharacter.uasset
│   │   │       ├── Mesh
│   │   │       │   ├── SK_TestCharacter.uasset
│   │   │       │   ├── SK_TestCharacter_PhysicsAsset.uasset
│   │   │       │   └── UE4_TestCharacter_Skeleton.uasset
│   │   │       ├── Moves
│   │   │       │   ├── Actions
│   │   │       │   │   ├── GroundCounter
│   │   │       │   │   │   ├── ANIM_GroundCounter.uasset
│   │   │       │   │   │   ├── ANIM_GroundCounter_Montage.uasset
│   │   │       │   │   │   └── MDA_GroundCounter.uasset
│   │   │       │   │   ├── GroundCounterAttack
│   │   │       │   │   │   ├── ANIM_GroundCounterAttack.uasset
│   │   │       │   │   │   ├── ANIM_GroundCounterAttack_Montage.uasset
│   │   │       │   │   │   └── MDA_GroundCounterAttack.uasset
│   │   │       │   │   ├── Idle
│   │   │       │   │   │   └── ANIM_Idle.uasset
│   │   │       │   │   ├── JabSequence
│   │   │       │   │   │   ├── Jab01
│   │   │       │   │   │   │   ├── ANIM_Jab01.uasset
│   │   │       │   │   │   │   ├── ANIM_Jab01_Montage.uasset
│   │   │       │   │   │   │   └── MDA_Jab01.uasset
│   │   │       │   │   │   └── Jab02
│   │   │       │   │   │       ├── ANIM_Jab02.uasset
│   │   │       │   │   │       ├── ANIM_Jab02_Montage.uasset
│   │   │       │   │   │       └── MDA_Jab02.uasset
│   │   │       │   │   ├── Jump
│   │   │       │   │   │   ├── ANIM_Jump.uasset
│   │   │       │   │   │   ├── ANIM_JumpLoop.uasset
│   │   │       │   │   │   ├── ANIM_JumpStart.uasset
│   │   │       │   │   │   ├── ANIM_JumpStart_Montage.uasset
│   │   │       │   │   │   ├── ANIM_Jump_Montage.uasset
│   │   │       │   │   │   └── MDA_JumpStart.uasset
│   │   │       │   │   ├── Land
│   │   │       │   │   │   ├── ANIM_Land.uasset
│   │   │       │   │   │   ├── ANIM_Land_Montage.uasset
│   │   │       │   │   │   └── MDA_Land.uasset
│   │   │       │   │   ├── PunchSequence
│   │   │       │   │   │   ├── Punch01
│   │   │       │   │   │   │   ├── ANIM_Punch01.uasset
│   │   │       │   │   │   │   ├── ANIM_Punch01_Montage.uasset
│   │   │       │   │   │   │   ├── HDDA_Punch01_Hand.uasset
│   │   │       │   │   │   │   ├── HDDA_Punch01_LowerArm.uasset
│   │   │       │   │   │   │   ├── MDA_Punch01.uasset
│   │   │       │   │   │   │   ├── SND_Punch_01.uasset
│   │   │       │   │   │   │   └── SND_Punch_01_Cue.uasset
│   │   │       │   │   │   ├── Punch02
│   │   │       │   │   │   │   ├── ANIM_Punch02.uasset
│   │   │       │   │   │   │   ├── ANIM_Punch02_Montage.uasset
│   │   │       │   │   │   │   ├── HDDA_Punch02_Hand.uasset
│   │   │       │   │   │   │   ├── HDDA_Punch02_LowerArm.uasset
│   │   │       │   │   │   │   ├── MDA_Punch02.uasset
│   │   │       │   │   │   │   ├── SND_Punch_02.uasset
│   │   │       │   │   │   │   └── SND_Punch_02_Cue.uasset
│   │   │       │   │   │   └── Punch03
│   │   │       │   │   │       ├── ANIM_Punch03.uasset
│   │   │       │   │   │       ├── ANIM_Punch03_Montage.uasset
│   │   │       │   │   │       ├── HDDA_Punch03_Foot.uasset
│   │   │       │   │   │       ├── MDA_Punch03.uasset
│   │   │       │   │   │       ├── SND_Punch_03.uasset
│   │   │       │   │   │       └── SND_Punch_03_Cue.uasset
│   │   │       │   │   ├── RoundhouseKick
│   │   │       │   │   │   ├── ANIM_RHKick_01.uasset
│   │   │       │   │   │   ├── ANIM_RHKick_02.uasset
│   │   │       │   │   │   ├── ANIM_RHKick_Montage.uasset
│   │   │       │   │   │   ├── HDDA_RoundhouseKick_01.uasset
│   │   │       │   │   │   ├── HDDA_RoundhouseKick_02.uasset
│   │   │       │   │   │   ├── MDA_RoundhouseKick.uasset
│   │   │       │   │   │   ├── SND_RoundhouseKick_01.uasset
│   │   │       │   │   │   ├── SND_RoundhouseKick_01_Cue.uasset
│   │   │       │   │   │   ├── SND_RoundhouseKick_02.uasset
│   │   │       │   │   │   └── SND_RoundhouseKick_02_Cue.uasset
│   │   │       │   │   ├── Run
│   │   │       │   │   │   ├── ANIM_RunFast.uasset
│   │   │       │   │   │   ├── ANIM_WalkB.uasset
│   │   │       │   │   │   └── ANIM_WalkF.uasset
│   │   │       │   │   ├── TestProjectile
│   │   │       │   │   │   ├── ANIM_TestProjectile.uasset
│   │   │       │   │   │   ├── ANIM_TestProjectile_Montage.uasset
│   │   │       │   │   │   ├── MDA_TestProjectile.uasset
│   │   │       │   │   │   ├── SND_TestProjectile_01.uasset
│   │   │       │   │   │   └── SND_TestProjectile_01_Cue.uasset
│   │   │       │   │   └── Uppercut
│   │   │       │   │       ├── ANIM_Uppercut.uasset
│   │   │       │   │       ├── ANIM_Uppercut_Montage.uasset
│   │   │       │   │       ├── HDDA_Uppercut_Hand.uasset
│   │   │       │   │       ├── HDDA_Uppercut_LowerArm.uasset
│   │   │       │   │       ├── MDA_Uppercut.uasset
│   │   │       │   │       ├── SND_Uppercut_01.uasset
│   │   │       │   │       └── SND_Uppercut_01_Cue.uasset
│   │   │       │   ├── InputSequences
│   │   │       │   │   ├── IS_Attack.uasset
│   │   │       │   │   ├── IS_Counter.uasset
│   │   │       │   │   ├── IS_FQCF_A.uasset
│   │   │       │   │   ├── IS_FQCF_A_Easy.uasset
│   │   │       │   │   ├── IS_Jump.uasset
│   │   │       │   │   ├── IS_QCB_A.uasset
│   │   │       │   │   └── IS_QCF_A.uasset
│   │   │       │   └── Reactions
│   │   │       │       ├── GetUp
│   │   │       │       │   ├── ANIM_GetUp.uasset
│   │   │       │       │   ├── ANIM_GetUp_Montage.uasset
│   │   │       │       │   └── MDA_ReactionGetUp.uasset
│   │   │       │       ├── GroundBlock
│   │   │       │       │   ├── ANIM_GroundBlock.uasset
│   │   │       │       │   ├── ANIM_GroundBlock_Montage.uasset
│   │   │       │       │   └── MDA_GroundBlock.uasset
│   │   │       │       ├── LightAirborneHit
│   │   │       │       │   ├── ANIM_ReactionLightAirborne.uasset
│   │   │       │       │   ├── ANIM_ReactionLightAirborne_Montage.uasset
│   │   │       │       │   └── MDA_ReactionLightAirborne.uasset
│   │   │       │       ├── LightGroundedHit
│   │   │       │       │   ├── ANIM_ReactionLightGrounded.uasset
│   │   │       │       │   ├── ANIM_ReactionLightGrounded_Cut.uasset
│   │   │       │       │   ├── ANIM_ReactionLightGrounded_Montage.uasset
│   │   │       │       │   └── MDA_ReactionLightGrounded.uasset
│   │   │       │       └── PassiveLand
│   │   │       │           ├── ANIM_ReactionLand.uasset
│   │   │       │           ├── ANIM_ReactionLand_Montage.uasset
│   │   │       │           └── MDA_ReactionLand.uasset
│   │   │       ├── Projectiles
│   │   │       │   ├── BP_TestProjectile.uasset
│   │   │       │   └── HDDA_TestProjectile_Default.uasset
│   │   │       ├── States
│   │   │       │   ├── Actions
│   │   │       │   │   ├── FCS_Airborne.uasset
│   │   │       │   │   ├── FCS_GroundCounter.uasset
│   │   │       │   │   ├── FCS_GroundCounter_Attack.uasset
│   │   │       │   │   ├── FCS_Idle.uasset
│   │   │       │   │   ├── FCS_Jump.uasset
│   │   │       │   │   ├── FCS_Land.uasset
│   │   │       │   │   ├── FCS_RoundhouseKick.uasset
│   │   │       │   │   ├── FCS_Run.uasset
│   │   │       │   │   ├── FCS_TestProjectile.uasset
│   │   │       │   │   ├── FCS_Uppercut.uasset
│   │   │       │   │   ├── JabSequence
│   │   │       │   │   │   ├── FCS_Jab01.uasset
│   │   │       │   │   │   └── FCS_Jab02.uasset
│   │   │       │   │   └── PunchSequence
│   │   │       │   │       ├── FCS_Punch01.uasset
│   │   │       │   │       ├── FCS_Punch02.uasset
│   │   │       │   │       └── FCS_Punch03.uasset
│   │   │       │   ├── FCS_DEFAULT.uasset
│   │   │       │   ├── FCS_Delay.uasset
│   │   │       │   ├── Reactions
│   │   │       │   │   ├── FCS_GroundBlock.uasset
│   │   │       │   │   ├── FCS_ReactionAirKnockback.uasset
│   │   │       │   │   ├── FCS_ReactionGetUp.uasset
│   │   │       │   │   ├── FCS_ReactionLand.uasset
│   │   │       │   │   ├── FCS_ReactionLightAirborne.uasset
│   │   │       │   │   └── FCS_ReactionLightGrounded.uasset
│   │   │       │   └── Transitions
│   │   │       │       ├── FGT_Delay_JumpToAirborne.uasset
│   │   │       │       ├── FGT_MontageEnded.uasset
│   │   │       │       ├── Grounded
│   │   │       │       │   ├── FGT_Grounded_Airborne.uasset
│   │   │       │       │   └── FGT_Grounded_Grounded.uasset
│   │   │       │       ├── InputTransitions
│   │   │       │       │   ├── FCT_Input_Attack.uasset
│   │   │       │       │   ├── FCT_Input_Attack_Hit.uasset
│   │   │       │       │   ├── FCT_Input_Special.uasset
│   │   │       │       │   ├── FCT_Input_Special_Hit.uasset
│   │   │       │       │   └── FCT_Input_StartJump.uasset
│   │   │       │       ├── InputsSequenceTransitions
│   │   │       │       │   └── FCT_InputsSequence_QCF_HitLanded.uasset
│   │   │       │       ├── MoveTransitions
│   │   │       │       │   └── FCT_TestProjectile.uasset
│   │   │       │       └── Movement
│   │   │       │           ├── FGT_Movement_Start.uasset
│   │   │       │           └── FGT_Movement_Stop.uasset
│   │   │       └── Tuning
│   │   │           ├── C_KnockbackMultiplier.uasset
│   │   │           └── DT_InputsSequenceToState.uasset
│   │   ├── Common
│   │   │   └── BP_InputSequenceResolver.uasset
│   │   ├── Debugging
│   │   │   └── SphereVisualizer
│   │   │       ├── BP_SphereVisualizer.uasset
│   │   │       ├── MAT_HitboxVisualizer.uasset
│   │   │       └── MAT_HitboxVisualizer_Inst.uasset
│   │   ├── Framework
│   │   │   └── BP_GameFramework.uasset
│   │   ├── GameInstance
│   │   │   └── BP_CustomGameInstance.uasset
│   │   ├── GameMode
│   │   │   └── BP_FreeForAll.uasset
│   │   ├── Maps
│   │   │   ├── Map_Sandbox.umap
│   │   │   └── Map_Sandbox_Sky.umap
│   │   ├── PlayerController
│   │   │   └── BP_FightingGamePlayerController.uasset
│   │   ├── Props
│   │   │   └── BP_HitProp.uasset
│   │   └── UI
│   │       └── HUD
│   │           ├── HUD_1v1.uasset
│   │           ├── WBP_CharacterHealth.uasset
│   │           └── WBP_HUD.uasset
│   └── StarterContent
│       ├── Architecture
│       │   ├── Floor_400x400.uasset
│       │   ├── Pillar_50x500.uasset
│       │   ├── SM_AssetPlatform.uasset
│       │   ├── Wall_400x200.uasset
│       │   ├── Wall_400x300.uasset
│       │   ├── Wall_400x400.uasset
│       │   ├── Wall_500x500.uasset
│       │   ├── Wall_Door_400x300.uasset
│       │   ├── Wall_Door_400x400.uasset
│       │   ├── Wall_Window_400x300.uasset
│       │   └── Wall_Window_400x400.uasset
│       ├── Audio
│       │   ├── Collapse01.uasset
│       │   ├── Collapse02.uasset
│       │   ├── Collapse_Cue.uasset
│       │   ├── Explosion01.uasset
│       │   ├── Explosion02.uasset
│       │   ├── Explosion_Cue.uasset
│       │   ├── Fire01.uasset
│       │   ├── Fire01_Cue.uasset
│       │   ├── Fire_Sparks01.uasset
│       │   ├── Fire_Sparks01_Cue.uasset
│       │   ├── Light01.uasset
│       │   ├── Light01_Cue.uasset
│       │   ├── Light02.uasset
│       │   ├── Light02_Cue.uasset
│       │   ├── Smoke01.uasset
│       │   ├── Smoke01_Cue.uasset
│       │   ├── Starter_Background_Cue.uasset
│       │   ├── Starter_Birds01.uasset
│       │   ├── Starter_Music01.uasset
│       │   ├── Starter_Music_Cue.uasset
│       │   ├── Starter_Wind05.uasset
│       │   ├── Starter_Wind06.uasset
│       │   ├── Steam01.uasset
│       │   └── Steam01_Cue.uasset
│       ├── Blueprints
│       │   ├── Assets
│       │   │   ├── FogBrightnessLUT.uasset
│       │   │   ├── M_LightStage_Arrows.uasset
│       │   │   ├── M_LightStage_Skybox_Black.uasset
│       │   │   ├── M_LightStage_Skybox_HDRI.uasset
│       │   │   ├── M_LightStage_Skybox_Master.uasset
│       │   │   ├── SM_Arrows.uasset
│       │   │   ├── Skybox.uasset
│       │   │   └── SunlightColorLUT.uasset
│       │   ├── BP_LightStudio.uasset
│       │   ├── Blueprint_CeilingLight.uasset
│       │   ├── Blueprint_Effect_Explosion.uasset
│       │   ├── Blueprint_Effect_Fire.uasset
│       │   ├── Blueprint_Effect_Smoke.uasset
│       │   ├── Blueprint_Effect_Sparks.uasset
│       │   ├── Blueprint_Effect_Steam.uasset
│       │   └── Blueprint_WallSconce.uasset
│       ├── HDRI
│       │   └── HDRI_Epic_Courtyard_Daylight.uasset
│       ├── Maps
│       │   ├── Advanced_Lighting.umap
│       │   ├── Minimal_Default.umap
│       │   └── StarterMap.umap
│       ├── Materials
│       │   ├── M_AssetPlatform.uasset
│       │   ├── M_Basic_Floor.uasset
│       │   ├── M_Basic_Wall.uasset
│       │   ├── M_Brick_Clay_Beveled.uasset
│       │   ├── M_Brick_Clay_New.uasset
│       │   ├── M_Brick_Clay_Old.uasset
│       │   ├── M_Brick_Cut_Stone.uasset
│       │   ├── M_Brick_Hewn_Stone.uasset
│       │   ├── M_Ceramic_Tile_Checker.uasset
│       │   ├── M_CobbleStone_Pebble.uasset
│       │   ├── M_CobbleStone_Rough.uasset
│       │   ├── M_CobbleStone_Smooth.uasset
│       │   ├── M_ColorGrid_LowSpec.uasset
│       │   ├── M_Concrete_Grime.uasset
│       │   ├── M_Concrete_Panels.uasset
│       │   ├── M_Concrete_Poured.uasset
│       │   ├── M_Concrete_Tiles.uasset
│       │   ├── M_Glass.uasset
│       │   ├── M_Ground_Grass.uasset
│       │   ├── M_Ground_Gravel.uasset
│       │   ├── M_Ground_Moss.uasset
│       │   ├── M_Metal_Brushed_Nickel.uasset
│       │   ├── M_Metal_Burnished_Steel.uasset
│       │   ├── M_Metal_Chrome.uasset
│       │   ├── M_Metal_Copper.uasset
│       │   ├── M_Metal_Gold.uasset
│       │   ├── M_Metal_Rust.uasset
│       │   ├── M_Metal_Steel.uasset
│       │   ├── M_Rock_Basalt.uasset
│       │   ├── M_Rock_Marble_Polished.uasset
│       │   ├── M_Rock_Sandstone.uasset
│       │   ├── M_Rock_Slate.uasset
│       │   ├── M_Tech_Checker_Dot.uasset
│       │   ├── M_Tech_Hex_Tile.uasset
│       │   ├── M_Tech_Hex_Tile_Pulse.uasset
│       │   ├── M_Tech_Panel.uasset
│       │   ├── M_Water_Lake.uasset
│       │   ├── M_Water_Ocean.uasset
│       │   ├── M_Wood_Floor_Walnut_Polished.uasset
│       │   ├── M_Wood_Floor_Walnut_Worn.uasset
│       │   ├── M_Wood_Oak.uasset
│       │   ├── M_Wood_Pine.uasset
│       │   └── M_Wood_Walnut.uasset
│       ├── Particles
│       │   ├── Materials
│       │   │   ├── M_Burst.uasset
│       │   │   ├── M_Dust_Particle.uasset
│       │   │   ├── M_Fire_SubUV.uasset
│       │   │   ├── M_Heat_Distortion.uasset
│       │   │   ├── M_Radial_Gradient.uasset
│       │   │   ├── M_Spark.uasset
│       │   │   ├── M_explosion_subUV.uasset
│       │   │   ├── M_radial_ramp.uasset
│       │   │   ├── M_smoke_subUV.uasset
│       │   │   └── m_flare_01.uasset
│       │   ├── P_Ambient_Dust.uasset
│       │   ├── P_Explosion.uasset
│       │   ├── P_Fire.uasset
│       │   ├── P_Smoke.uasset
│       │   ├── P_Sparks.uasset
│       │   └── P_Steam_Lit.uasset
│       ├── Props
│       │   ├── MaterialSphere.uasset
│       │   ├── Materials
│       │   │   ├── M_Bush.uasset
│       │   │   ├── M_Chair.uasset
│       │   │   ├── M_Door.uasset
│       │   │   ├── M_Frame.uasset
│       │   │   ├── M_Lamp.uasset
│       │   │   ├── M_MaterialSphere.uasset
│       │   │   ├── M_MaterialSphere_Plain.uasset
│       │   │   ├── M_Rock.uasset
│       │   │   ├── M_Shelf.uasset
│       │   │   ├── M_Statue.uasset
│       │   │   ├── M_StatueGlass.uasset
│       │   │   └── M_TableRound.uasset
│       │   ├── SM_Bush.uasset
│       │   ├── SM_Chair.uasset
│       │   ├── SM_CornerFrame.uasset
│       │   ├── SM_Couch.uasset
│       │   ├── SM_Door.uasset
│       │   ├── SM_DoorFrame.uasset
│       │   ├── SM_GlassWindow.uasset
│       │   ├── SM_Lamp_Ceiling.uasset
│       │   ├── SM_Lamp_Wall.uasset
│       │   ├── SM_MatPreviewMesh_02.uasset
│       │   ├── SM_PillarFrame.uasset
│       │   ├── SM_PillarFrame300.uasset
│       │   ├── SM_Rock.uasset
│       │   ├── SM_Shelf.uasset
│       │   ├── SM_Stairs.uasset
│       │   ├── SM_Statue.uasset
│       │   ├── SM_TableRound.uasset
│       │   └── SM_WindowFrame.uasset
│       ├── Shapes
│       │   ├── Shape_Cone.uasset
│       │   ├── Shape_Cube.uasset
│       │   ├── Shape_Cylinder.uasset
│       │   ├── Shape_NarrowCapsule.uasset
│       │   ├── Shape_Pipe.uasset
│       │   ├── Shape_Pipe_180.uasset
│       │   ├── Shape_Pipe_90.uasset
│       │   ├── Shape_Plane.uasset
│       │   ├── Shape_QuadPyramid.uasset
│       │   ├── Shape_Sphere.uasset
│       │   ├── Shape_Torus.uasset
│       │   ├── Shape_TriPyramid.uasset
│       │   ├── Shape_Trim.uasset
│       │   ├── Shape_Trim_90_In.uasset
│       │   ├── Shape_Trim_90_Out.uasset
│       │   ├── Shape_Tube.uasset
│       │   ├── Shape_Wedge_A.uasset
│       │   ├── Shape_Wedge_B.uasset
│       │   └── Shape_WideCapsule.uasset
│       └── Textures
│           ├── T_Brick_Clay_Beveled_D.uasset
│           ├── T_Brick_Clay_Beveled_M.uasset
│           ├── T_Brick_Clay_Beveled_N.uasset
│           ├── T_Brick_Clay_New_D.uasset
│           ├── T_Brick_Clay_New_M.uasset
│           ├── T_Brick_Clay_New_N.uasset
│           ├── T_Brick_Clay_Old_D.uasset
│           ├── T_Brick_Clay_Old_N.uasset
│           ├── T_Brick_Cut_Stone_D.uasset
│           ├── T_Brick_Cut_Stone_N.uasset
│           ├── T_Brick_Hewn_Stone_D.uasset
│           ├── T_Brick_Hewn_Stone_M.uasset
│           ├── T_Brick_Hewn_Stone_N.uasset
│           ├── T_Burst_M.uasset
│           ├── T_Bush_D.uasset
│           ├── T_Bush_N.uasset
│           ├── T_Ceramic_Tile_M.uasset
│           ├── T_Ceramic_Tile_N.uasset
│           ├── T_Chair_M.uasset
│           ├── T_Chair_N.uasset
│           ├── T_Checker_Noise_M.uasset
│           ├── T_CobbleStone_Pebble_D.uasset
│           ├── T_CobbleStone_Pebble_M.uasset
│           ├── T_CobbleStone_Pebble_N.uasset
│           ├── T_CobbleStone_Rough_D.uasset
│           ├── T_CobbleStone_Rough_N.uasset
│           ├── T_CobbleStone_Smooth_D.uasset
│           ├── T_CobbleStone_Smooth_M.uasset
│           ├── T_CobbleStone_Smooth_N.uasset
│           ├── T_Concrete_Grime_D.uasset
│           ├── T_Concrete_Panels_D.uasset
│           ├── T_Concrete_Panels_N.uasset
│           ├── T_Concrete_Poured_D.uasset
│           ├── T_Concrete_Poured_N.uasset
│           ├── T_Concrete_Tiles_D.uasset
│           ├── T_Concrete_Tiles_M.uasset
│           ├── T_Concrete_Tiles_N.uasset
│           ├── T_Concrete_Tiles_Variation_M.uasset
│           ├── T_Detail_Rocky_N.uasset
│           ├── T_Door_M.uasset
│           ├── T_Door_N.uasset
│           ├── T_Dust_Particle_D.uasset
│           ├── T_Explosion_SubUV.uasset
│           ├── T_Fire_SubUV.uasset
│           ├── T_Fire_Tiled_D.uasset
│           ├── T_Frame_M.uasset
│           ├── T_Frame_N.uasset
│           ├── T_Gradinet_01.uasset
│           ├── T_Ground_Grass_D.uasset
│           ├── T_Ground_Grass_N.uasset
│           ├── T_Ground_Gravel_D.uasset
│           ├── T_Ground_Gravel_N.uasset
│           ├── T_Ground_Moss_N.uasset
│           ├── T_Lamp_M.uasset
│           ├── T_Lamp_N.uasset
│           ├── T_MacroVariation.uasset
│           ├── T_Metal_Aluminum_D.uasset
│           ├── T_Metal_Copper_D.uasset
│           ├── T_Metal_Gold_D.uasset
│           ├── T_Metal_Gold_N.uasset
│           ├── T_Metal_Rust_D.uasset
│           ├── T_Metal_Rust_N.uasset
│           ├── T_Metal_Steel_D.uasset
│           ├── T_Metal_Steel_N.uasset
│           ├── T_Perlin_Noise_M.uasset
│           ├── T_RockMesh_M.uasset
│           ├── T_RockMesh_N.uasset
│           ├── T_Rock_Basalt_D.uasset
│           ├── T_Rock_Basalt_N.uasset
│           ├── T_Rock_Marble_Polished_D.uasset
│           ├── T_Rock_Sandstone_D.uasset
│           ├── T_Rock_Sandstone_N.uasset
│           ├── T_Rock_Slate_D.uasset
│           ├── T_Rock_Slate_N.uasset
│           ├── T_Rock_Smooth_Granite_D.uasset
│           ├── T_Shelf_M.uasset
│           ├── T_Shelf_N.uasset
│           ├── T_Single_Tile_N.uasset
│           ├── T_Smoke_SubUV.uasset
│           ├── T_Smoke_Tiled_D.uasset
│           ├── T_Spark_Core.uasset
│           ├── T_Statue_M.uasset
│           ├── T_Statue_N.uasset
│           ├── T_TableRound_M.uasset
│           ├── T_TableRound_N.uasset
│           ├── T_Tech_Dot_M.uasset
│           ├── T_Tech_Dot_N.uasset
│           ├── T_Tech_Hex_Tile_M.uasset
│           ├── T_Tech_Hex_Tile_N.uasset
│           ├── T_Tech_Panel_M.uasset
│           ├── T_Tech_Panel_N.uasset
│           ├── T_Water_M.uasset
│           ├── T_Water_N.uasset
│           ├── T_Wood_Floor_Walnut_D.uasset
│           ├── T_Wood_Floor_Walnut_M.uasset
│           ├── T_Wood_Floor_Walnut_N.uasset
│           ├── T_Wood_Oak_D.uasset
│           ├── T_Wood_Oak_N.uasset
│           ├── T_Wood_Pine_D.uasset
│           ├── T_Wood_Pine_N.uasset
│           ├── T_Wood_Walnut_D.uasset
│           ├── T_Wood_Walnut_N.uasset
│           └── T_ground_Moss_D.uasset
├── Fighter_Animations.png
├── FightingGame.uproject
├── Plugins
│   ├── Developer
│   │   └── RiderLink
│   │       ├── Resources
│   │       │   ├── Icon128.png
│   │       │   └── checksum
│   │       ├── RiderLink.uplugin
│   │       └── Source
│   │           ├── RD
│   │           │   ├── RD.Build.cs
│   │           │   ├── RD.cpp
│   │           │   ├── RD.h
│   │           │   ├── src
│   │           │   │   ├── rd_core_cpp
│   │           │   │   │   ├── rd_core_export.h
│   │           │   │   │   └── src
│   │           │   │   │       └── main
│   │           │   │   │           ├── lifetime
│   │           │   │   │           │   ├── Lifetime.cpp
│   │           │   │   │           │   ├── Lifetime.h
│   │           │   │   │           │   ├── LifetimeDefinition.cpp
│   │           │   │   │           │   ├── LifetimeDefinition.h
│   │           │   │   │           │   ├── LifetimeImpl.cpp
│   │           │   │   │           │   ├── LifetimeImpl.h
│   │           │   │   │           │   ├── SequentialLifetimes.cpp
│   │           │   │   │           │   └── SequentialLifetimes.h
│   │           │   │   │           ├── reactive
│   │           │   │   │           │   ├── Property.h
│   │           │   │   │           │   ├── ViewableList.h
│   │           │   │   │           │   ├── ViewableMap.h
│   │           │   │   │           │   ├── ViewableSet.h
│   │           │   │   │           │   └── base
│   │           │   │   │           │       ├── IProperty.h
│   │           │   │   │           │       ├── IPropertyBase.h
│   │           │   │   │           │       ├── IViewableList.h
│   │           │   │   │           │       ├── IViewableMap.h
│   │           │   │   │           │       ├── IViewableSet.h
│   │           │   │   │           │       ├── SignalCookie.cpp
│   │           │   │   │           │       ├── SignalCookie.h
│   │           │   │   │           │       ├── SignalX.h
│   │           │   │   │           │       ├── interfaces.h
│   │           │   │   │           │       └── viewable_collections.h
│   │           │   │   │           ├── std
│   │           │   │   │           │   ├── allocator.h
│   │           │   │   │           │   ├── hash.h
│   │           │   │   │           │   ├── list.h
│   │           │   │   │           │   ├── to_string.h
│   │           │   │   │           │   ├── unordered_map.h
│   │           │   │   │           │   └── unordered_set.h
│   │           │   │   │           ├── types
│   │           │   │   │           │   ├── DateTime.cpp
│   │           │   │   │           │   ├── DateTime.h
│   │           │   │   │           │   ├── Void.h
│   │           │   │   │           │   └── wrapper.h
│   │           │   │   │           └── util
│   │           │   │   │               ├── core_traits.h
│   │           │   │   │               ├── core_util.h
│   │           │   │   │               ├── enum.h
│   │           │   │   │               ├── erase_if.h
│   │           │   │   │               ├── gen_util.h
│   │           │   │   │               ├── overloaded.h
│   │           │   │   │               └── shared_function.h
│   │           │   │   ├── rd_framework_cpp
│   │           │   │   │   ├── rd_framework_export.h
│   │           │   │   │   └── src
│   │           │   │   │       └── main
│   │           │   │   │           ├── base
│   │           │   │   │           │   ├── IProtocol.cpp
│   │           │   │   │           │   ├── IProtocol.h
│   │           │   │   │           │   ├── IRdBindable.h
│   │           │   │   │           │   ├── IRdDynamic.h
│   │           │   │   │           │   ├── IRdReactive.h
│   │           │   │   │           │   ├── IRdWireable.cpp
│   │           │   │   │           │   ├── IRdWireable.h
│   │           │   │   │           │   ├── ISerializersOwner.cpp
│   │           │   │   │           │   ├── ISerializersOwner.h
│   │           │   │   │           │   ├── IUnknownInstance.cpp
│   │           │   │   │           │   ├── IUnknownInstance.h
│   │           │   │   │           │   ├── IWire.h
│   │           │   │   │           │   ├── RdBindableBase.cpp
│   │           │   │   │           │   ├── RdBindableBase.h
│   │           │   │   │           │   ├── RdPropertyBase.h
│   │           │   │   │           │   ├── RdReactiveBase.cpp
│   │           │   │   │           │   ├── RdReactiveBase.h
│   │           │   │   │           │   ├── WireBase.cpp
│   │           │   │   │           │   └── WireBase.h
│   │           │   │   │           ├── ext
│   │           │   │   │           │   ├── ExtWire.cpp
│   │           │   │   │           │   ├── ExtWire.h
│   │           │   │   │           │   ├── RdExtBase.cpp
│   │           │   │   │           │   └── RdExtBase.h
│   │           │   │   │           ├── impl
│   │           │   │   │           │   ├── RName.cpp
│   │           │   │   │           │   ├── RName.h
│   │           │   │   │           │   ├── RdList.h
│   │           │   │   │           │   ├── RdMap.h
│   │           │   │   │           │   ├── RdProperty.h
│   │           │   │   │           │   ├── RdSet.h
│   │           │   │   │           │   └── RdSignal.h
│   │           │   │   │           ├── intern
│   │           │   │   │           │   ├── InternRoot.cpp
│   │           │   │   │           │   ├── InternRoot.h
│   │           │   │   │           │   ├── InternScheduler.cpp
│   │           │   │   │           │   └── InternScheduler.h
│   │           │   │   │           ├── protocol
│   │           │   │   │           │   ├── Buffer.cpp
│   │           │   │   │           │   ├── Buffer.h
│   │           │   │   │           │   ├── Identities.cpp
│   │           │   │   │           │   ├── Identities.h
│   │           │   │   │           │   ├── MessageBroker.cpp
│   │           │   │   │           │   ├── MessageBroker.h
│   │           │   │   │           │   ├── Protocol.cpp
│   │           │   │   │           │   ├── Protocol.h
│   │           │   │   │           │   ├── RdId.cpp
│   │           │   │   │           │   └── RdId.h
│   │           │   │   │           ├── scheduler
│   │           │   │   │           │   ├── SimpleScheduler.cpp
│   │           │   │   │           │   ├── SimpleScheduler.h
│   │           │   │   │           │   ├── SingleThreadScheduler.cpp
│   │           │   │   │           │   ├── SingleThreadScheduler.h
│   │           │   │   │           │   ├── SynchronousScheduler.cpp
│   │           │   │   │           │   ├── SynchronousScheduler.h
│   │           │   │   │           │   └── base
│   │           │   │   │           │       ├── IScheduler.cpp
│   │           │   │   │           │       ├── IScheduler.h
│   │           │   │   │           │       ├── SingleThreadSchedulerBase.cpp
│   │           │   │   │           │       └── SingleThreadSchedulerBase.h
│   │           │   │   │           ├── serialization
│   │           │   │   │           │   ├── AbstractPolymorphic.h
│   │           │   │   │           │   ├── ArraySerializer.h
│   │           │   │   │           │   ├── DefaultAbstractDeclaration.cpp
│   │           │   │   │           │   ├── DefaultAbstractDeclaration.h
│   │           │   │   │           │   ├── ISerializable.cpp
│   │           │   │   │           │   ├── ISerializable.h
│   │           │   │   │           │   ├── InternedAnySerializer.h
│   │           │   │   │           │   ├── InternedSerializer.h
│   │           │   │   │           │   ├── NullableSerializer.h
│   │           │   │   │           │   ├── Polymorphic.cpp
│   │           │   │   │           │   ├── Polymorphic.h
│   │           │   │   │           │   ├── RdAny.cpp
│   │           │   │   │           │   ├── RdAny.h
│   │           │   │   │           │   ├── SerializationCtx.cpp
│   │           │   │   │           │   ├── SerializationCtx.h
│   │           │   │   │           │   ├── Serializers.cpp
│   │           │   │   │           │   └── Serializers.h
│   │           │   │   │           ├── task
│   │           │   │   │           │   ├── RdCall.h
│   │           │   │   │           │   ├── RdEndpoint.h
│   │           │   │   │           │   ├── RdSymmetricCall.h
│   │           │   │   │           │   ├── RdTask.h
│   │           │   │   │           │   ├── RdTaskImpl.h
│   │           │   │   │           │   ├── RdTaskResult.h
│   │           │   │   │           │   ├── WiredRdTask.h
│   │           │   │   │           │   └── WiredRdTaskImpl.h
│   │           │   │   │           ├── util
│   │           │   │   │           │   ├── framework_traits.h
│   │           │   │   │           │   ├── guards.h
│   │           │   │   │           │   ├── hashing.cpp
│   │           │   │   │           │   ├── hashing.h
│   │           │   │   │           │   ├── thread_util.cpp
│   │           │   │   │           │   └── thread_util.h
│   │           │   │   │           └── wire
│   │           │   │   │               ├── ByteBufferAsyncProcessor.cpp
│   │           │   │   │               ├── ByteBufferAsyncProcessor.h
│   │           │   │   │               ├── PkgInputStream.cpp
│   │           │   │   │               ├── PkgInputStream.h
│   │           │   │   │               ├── PumpScheduler.cpp
│   │           │   │   │               ├── PumpScheduler.h
│   │           │   │   │               ├── SocketWire.cpp
│   │           │   │   │               ├── SocketWire.h
│   │           │   │   │               ├── WireUtil.cpp
│   │           │   │   │               └── WireUtil.h
│   │           │   │   └── rd_gen_cpp
│   │           │   │       └── src
│   │           │   │           ├── RdTextBuffer.cpp
│   │           │   │           └── RdTextBuffer.h
│   │           │   └── thirdparty
│   │           │       ├── CTPL
│   │           │       │   ├── LICENSE
│   │           │       │   ├── README.md
│   │           │       │   └── include
│   │           │       │       └── ctpl_stl.h
│   │           │       ├── clsocket
│   │           │       │   ├── README
│   │           │       │   └── src
│   │           │       │       ├── ActiveSocket.cpp
│   │           │       │       ├── ActiveSocket.h
│   │           │       │       ├── Host.h
│   │           │       │       ├── PassiveSocket.cpp
│   │           │       │       ├── PassiveSocket.h
│   │           │       │       ├── SimpleSocket.cpp
│   │           │       │       ├── SimpleSocket.h
│   │           │       │       └── StatTimer.h
│   │           │       ├── countdownlatch
│   │           │       │   ├── LICENSE
│   │           │       │   ├── README.md
│   │           │       │   ├── countdownlatch.cpp
│   │           │       │   └── countdownlatch.hpp
│   │           │       ├── optional
│   │           │       │   ├── COPYING
│   │           │       │   ├── README.md
│   │           │       │   └── tl
│   │           │       │       └── optional.hpp
│   │           │       ├── ordered-map
│   │           │       │   ├── LICENSE
│   │           │       │   ├── README.md
│   │           │       │   └── include
│   │           │       │       └── tsl
│   │           │       │           ├── ordered_hash.h
│   │           │       │           ├── ordered_map.h
│   │           │       │           └── ordered_set.h
│   │           │       ├── spdlog
│   │           │       │   ├── LICENSE
│   │           │       │   ├── README.md
│   │           │       │   ├── cmake
│   │           │       │   │   ├── ide.cmake
│   │           │       │   │   ├── pch.h.in
│   │           │       │   │   ├── spdlog.pc.in
│   │           │       │   │   ├── spdlogCPack.cmake
│   │           │       │   │   ├── spdlogConfig.cmake.in
│   │           │       │   │   ├── utils.cmake
│   │           │       │   │   └── version.rc.in
│   │           │       │   ├── include
│   │           │       │   │   └── spdlog
│   │           │       │   │       ├── async.h
│   │           │       │   │       ├── async_logger-inl.h
│   │           │       │   │       ├── async_logger.h
│   │           │       │   │       ├── cfg
│   │           │       │   │       │   ├── argv.h
│   │           │       │   │       │   ├── env.h
│   │           │       │   │       │   ├── helpers-inl.h
│   │           │       │   │       │   ├── helpers.h
│   │           │       │   │       │   └── log_levels.h
│   │           │       │   │       ├── common-inl.h
│   │           │       │   │       ├── common.h
│   │           │       │   │       ├── details
│   │           │       │   │       │   ├── backtracer-inl.h
│   │           │       │   │       │   ├── backtracer.h
│   │           │       │   │       │   ├── circular_q.h
│   │           │       │   │       │   ├── console_globals.h
│   │           │       │   │       │   ├── file_helper-inl.h
│   │           │       │   │       │   ├── file_helper.h
│   │           │       │   │       │   ├── fmt_helper.h
│   │           │       │   │       │   ├── log_msg-inl.h
│   │           │       │   │       │   ├── log_msg.h
│   │           │       │   │       │   ├── log_msg_buffer-inl.h
│   │           │       │   │       │   ├── log_msg_buffer.h
│   │           │       │   │       │   ├── mpmc_blocking_q.h
│   │           │       │   │       │   ├── null_mutex.h
│   │           │       │   │       │   ├── os-inl.h
│   │           │       │   │       │   ├── os.h
│   │           │       │   │       │   ├── periodic_worker-inl.h
│   │           │       │   │       │   ├── periodic_worker.h
│   │           │       │   │       │   ├── registry-inl.h
│   │           │       │   │       │   ├── registry.h
│   │           │       │   │       │   ├── synchronous_factory.h
│   │           │       │   │       │   ├── tcp_client-windows.h
│   │           │       │   │       │   ├── tcp_client.h
│   │           │       │   │       │   ├── thread_pool-inl.h
│   │           │       │   │       │   ├── thread_pool.h
│   │           │       │   │       │   ├── udp_client-windows.h
│   │           │       │   │       │   ├── udp_client.h
│   │           │       │   │       │   └── windows_include.h
│   │           │       │   │       ├── fmt
│   │           │       │   │       │   ├── bin_to_hex.h
│   │           │       │   │       │   ├── bundled
│   │           │       │   │       │   │   ├── LICENSE.rst
│   │           │       │   │       │   │   ├── args.h
│   │           │       │   │       │   │   ├── chrono.h
│   │           │       │   │       │   │   ├── color.h
│   │           │       │   │       │   │   ├── compile.h
│   │           │       │   │       │   │   ├── core.h
│   │           │       │   │       │   │   ├── fmt.license.rst
│   │           │       │   │       │   │   ├── format-inl.h
│   │           │       │   │       │   │   ├── format.h
│   │           │       │   │       │   │   ├── locale.h
│   │           │       │   │       │   │   ├── os.h
│   │           │       │   │       │   │   ├── ostream.h
│   │           │       │   │       │   │   ├── posix.h
│   │           │       │   │       │   │   ├── printf.h
│   │           │       │   │       │   │   ├── ranges.h
│   │           │       │   │       │   │   └── xchar.h
│   │           │       │   │       │   ├── chrono.h
│   │           │       │   │       │   ├── compile.h
│   │           │       │   │       │   ├── fmt.h
│   │           │       │   │       │   ├── ostr.h
│   │           │       │   │       │   ├── ranges.h
│   │           │       │   │       │   └── xchar.h
│   │           │       │   │       ├── formatter.h
│   │           │       │   │       ├── fwd.h
│   │           │       │   │       ├── logger-inl.h
│   │           │       │   │       ├── logger.h
│   │           │       │   │       ├── pattern_formatter-inl.h
│   │           │       │   │       ├── pattern_formatter.h
│   │           │       │   │       ├── sinks
│   │           │       │   │       │   ├── android_sink.h
│   │           │       │   │       │   ├── ansicolor_sink-inl.h
│   │           │       │   │       │   ├── ansicolor_sink.h
│   │           │       │   │       │   ├── base_sink-inl.h
│   │           │       │   │       │   ├── base_sink.h
│   │           │       │   │       │   ├── basic_file_sink-inl.h
│   │           │       │   │       │   ├── basic_file_sink.h
│   │           │       │   │       │   ├── daily_file_sink.h
│   │           │       │   │       │   ├── dist_sink.h
│   │           │       │   │       │   ├── dup_filter_sink.h
│   │           │       │   │       │   ├── hourly_file_sink.h
│   │           │       │   │       │   ├── mongo_sink.h
│   │           │       │   │       │   ├── msvc_sink.h
│   │           │       │   │       │   ├── null_sink.h
│   │           │       │   │       │   ├── ostream_sink.h
│   │           │       │   │       │   ├── qt_sinks.h
│   │           │       │   │       │   ├── ringbuffer_sink.h
│   │           │       │   │       │   ├── rotating_file_sink-inl.h
│   │           │       │   │       │   ├── rotating_file_sink.h
│   │           │       │   │       │   ├── sink-inl.h
│   │           │       │   │       │   ├── sink.h
│   │           │       │   │       │   ├── stdout_color_sinks-inl.h
│   │           │       │   │       │   ├── stdout_color_sinks.h
│   │           │       │   │       │   ├── stdout_sinks-inl.h
│   │           │       │   │       │   ├── stdout_sinks.h
│   │           │       │   │       │   ├── syslog_sink.h
│   │           │       │   │       │   ├── systemd_sink.h
│   │           │       │   │       │   ├── tcp_sink.h
│   │           │       │   │       │   ├── udp_sink.h
│   │           │       │   │       │   ├── win_eventlog_sink.h
│   │           │       │   │       │   ├── wincolor_sink-inl.h
│   │           │       │   │       │   └── wincolor_sink.h
│   │           │       │   │       ├── spdlog-inl.h
│   │           │       │   │       ├── spdlog.h
│   │           │       │   │       ├── stopwatch.h
│   │           │       │   │       ├── tweakme.h
│   │           │       │   │       └── version.h
│   │           │       │   ├── logos
│   │           │       │   │   └── jetbrains-variant-4.svg
│   │           │       │   ├── scripts
│   │           │       │   │   ├── extract_version.py
│   │           │       │   │   └── format.sh
│   │           │       │   └── src
│   │           │       │       ├── async.cpp
│   │           │       │       ├── cfg.cpp
│   │           │       │       ├── color_sinks.cpp
│   │           │       │       ├── file_sinks.cpp
│   │           │       │       ├── fmt.cpp
│   │           │       │       ├── spdlog.cpp
│   │           │       │       └── stdout_sinks.cpp
│   │           │       ├── string-view-lite
│   │           │       │   ├── LICENSE.txt
│   │           │       │   ├── README.md
│   │           │       │   ├── cmake
│   │           │       │   │   └── string_view-lite-config.cmake.in
│   │           │       │   └── include
│   │           │       │       └── nonstd
│   │           │       │           └── string_view.hpp
│   │           │       ├── thirdparty.cpp
│   │           │       ├── thirdparty.hpp
│   │           │       └── variant
│   │           │           ├── CMakeLists.txt
│   │           │           ├── LICENSE.md
│   │           │           ├── README.md
│   │           │           ├── cmake
│   │           │           │   └── mpark_variant-config.cmake.in
│   │           │           └── include
│   │           │               └── mpark
│   │           │                   ├── config.hpp
│   │           │                   ├── in_place.hpp
│   │           │                   ├── lib.hpp
│   │           │                   └── variant.hpp
│   │           ├── RiderBlueprint
│   │           │   ├── Private
│   │           │   │   ├── BlueprintProvider.cpp
│   │           │   │   └── RiderBlueprint.cpp
│   │           │   ├── Public
│   │           │   │   ├── BlueprintProvider.hpp
│   │           │   │   └── RiderBlueprint.hpp
│   │           │   └── RiderBlueprint.Build.cs
│   │           ├── RiderGameControl
│   │           │   ├── Private
│   │           │   │   └── RiderGameControl.cpp
│   │           │   ├── Public
│   │           │   │   └── RiderGameControl.hpp
│   │           │   └── RiderGameControl.Build.cs
│   │           ├── RiderLink
│   │           │   ├── Private
│   │           │   │   ├── ProtocolFactory.cpp
│   │           │   │   ├── ProtocolFactory.h
│   │           │   │   ├── RiderLink.cpp
│   │           │   │   ├── RiderLink.hpp
│   │           │   │   └── UE4TypesMarshallers.cpp
│   │           │   ├── Public
│   │           │   │   ├── IRiderLink.hpp
│   │           │   │   ├── Model
│   │           │   │   │   ├── Library
│   │           │   │   │   │   ├── CMakeLists.txt
│   │           │   │   │   │   ├── UE4Library
│   │           │   │   │   │   │   ├── BlueprintFunction.Generated.cpp
│   │           │   │   │   │   │   ├── BlueprintFunction.Generated.h
│   │           │   │   │   │   │   ├── BlueprintHighlighter.Generated.cpp
│   │           │   │   │   │   │   ├── BlueprintHighlighter.Generated.h
│   │           │   │   │   │   │   ├── BlueprintReference.Generated.cpp
│   │           │   │   │   │   │   ├── BlueprintReference.Generated.h
│   │           │   │   │   │   │   ├── ConnectionInfo.Generated.cpp
│   │           │   │   │   │   │   ├── ConnectionInfo.Generated.h
│   │           │   │   │   │   │   ├── EmptyScriptCallStack.Generated.cpp
│   │           │   │   │   │   │   ├── EmptyScriptCallStack.Generated.h
│   │           │   │   │   │   │   ├── IScriptCallStack.Generated.cpp
│   │           │   │   │   │   │   ├── IScriptCallStack.Generated.h
│   │           │   │   │   │   │   ├── IScriptCallStack_Unknown.Generated.cpp
│   │           │   │   │   │   │   ├── IScriptCallStack_Unknown.Generated.h
│   │           │   │   │   │   │   ├── IScriptMsg.Generated.cpp
│   │           │   │   │   │   │   ├── IScriptMsg.Generated.h
│   │           │   │   │   │   │   ├── IScriptMsg_Unknown.Generated.cpp
│   │           │   │   │   │   │   ├── IScriptMsg_Unknown.Generated.h
│   │           │   │   │   │   │   ├── LogMessageInfo.Generated.cpp
│   │           │   │   │   │   │   ├── LogMessageInfo.Generated.h
│   │           │   │   │   │   │   ├── NotificationType.Generated.cpp
│   │           │   │   │   │   │   ├── NotificationType.Generated.h
│   │           │   │   │   │   │   ├── PlayState.Generated.cpp
│   │           │   │   │   │   │   ├── PlayState.Generated.h
│   │           │   │   │   │   │   ├── RequestFailed.Generated.cpp
│   │           │   │   │   │   │   ├── RequestFailed.Generated.h
│   │           │   │   │   │   │   ├── RequestResultBase.Generated.cpp
│   │           │   │   │   │   │   ├── RequestResultBase.Generated.h
│   │           │   │   │   │   │   ├── RequestResultBase_Unknown.Generated.cpp
│   │           │   │   │   │   │   ├── RequestResultBase_Unknown.Generated.h
│   │           │   │   │   │   │   ├── RequestSucceed.Generated.cpp
│   │           │   │   │   │   │   ├── RequestSucceed.Generated.h
│   │           │   │   │   │   │   ├── ScriptCallStack.Generated.cpp
│   │           │   │   │   │   │   ├── ScriptCallStack.Generated.h
│   │           │   │   │   │   │   ├── ScriptCallStackFrame.Generated.cpp
│   │           │   │   │   │   │   ├── ScriptCallStackFrame.Generated.h
│   │           │   │   │   │   │   ├── ScriptMsgCallStack.Generated.cpp
│   │           │   │   │   │   │   ├── ScriptMsgCallStack.Generated.h
│   │           │   │   │   │   │   ├── ScriptMsgException.Generated.cpp
│   │           │   │   │   │   │   ├── ScriptMsgException.Generated.h
│   │           │   │   │   │   │   ├── StringRange.Generated.cpp
│   │           │   │   │   │   │   ├── StringRange.Generated.h
│   │           │   │   │   │   │   ├── UClass.Generated.cpp
│   │           │   │   │   │   │   ├── UClass.Generated.h
│   │           │   │   │   │   │   ├── UE4Library.Generated.cpp
│   │           │   │   │   │   │   ├── UE4Library.Generated.h
│   │           │   │   │   │   │   ├── UnableToDisplayScriptCallStack.Generated.cpp
│   │           │   │   │   │   │   ├── UnableToDisplayScriptCallStack.Generated.h
│   │           │   │   │   │   │   ├── UnrealLogEvent.Generated.cpp
│   │           │   │   │   │   │   └── UnrealLogEvent.Generated.h
│   │           │   │   │   │   ├── instantiations_UE4Library.cpp
│   │           │   │   │   │   └── instantiations_UE4Library.h
│   │           │   │   │   └── RdEditorProtocol
│   │           │   │   │       ├── CMakeLists.txt
│   │           │   │   │       ├── RdEditorModel
│   │           │   │   │       │   ├── RdEditorModel.Generated.cpp
│   │           │   │   │       │   └── RdEditorModel.Generated.h
│   │           │   │   │       ├── RdEditorRoot
│   │           │   │   │       │   ├── RdEditorRoot.Generated.cpp
│   │           │   │   │       │   └── RdEditorRoot.Generated.h
│   │           │   │   │       ├── instantiations_RdEditorRoot.cpp
│   │           │   │   │       └── instantiations_RdEditorRoot.h
│   │           │   │   └── UE4TypesMarshallers.h
│   │           │   └── RiderLink.Build.cs
│   │           ├── RiderLogging
│   │           │   ├── Private
│   │           │   │   ├── RiderLogging.cpp
│   │           │   │   ├── RiderLogging.hpp
│   │           │   │   ├── RiderOutputDevice.cpp
│   │           │   │   └── RiderOutputDevice.hpp
│   │           │   └── RiderLogging.Build.cs
│   │           └── RiderShaderInfo
│   │               ├── RiderShaderInfo.Build.cs
│   │               ├── RiderShaderInfo.cpp
│   │               └── RiderShaderInfo.h
│   └── ImGui
└── Source
    ├── FightingGame
    │   ├── Animation
    │   │   ├── FightingCharacterAnimInstance.cpp
    │   │   └── FightingCharacterAnimInstance.h
    │   ├── Camera
    │   │   ├── CameraManager.cpp
    │   │   ├── CameraManager.h
    │   │   ├── CharactersSharedCamera.cpp
    │   │   ├── CharactersSharedCamera.h
    │   │   ├── GameCamera.cpp
    │   │   └── GameCamera.h
    │   ├── Character
    │   │   ├── FightingCharacter.cpp
    │   │   └── FightingCharacter.h
    │   ├── Collision
    │   │   └── CustomCollisionChannels.h
    │   ├── Combat
    │   │   ├── CameraShakeNotify.cpp
    │   │   ├── CameraShakeNotify.h
    │   │   ├── CombatManager.cpp
    │   │   ├── CombatManager.h
    │   │   ├── CounterEntity.cpp
    │   │   ├── CounterEntity.h
    │   │   ├── CounterNotifyState.cpp
    │   │   ├── CounterNotifyState.h
    │   │   ├── FacingEntity.cpp
    │   │   ├── FacingEntity.h
    │   │   ├── GroundSensitiveEntity.cpp
    │   │   ├── GroundSensitiveEntity.h
    │   │   ├── HitData.cpp
    │   │   ├── HitData.h
    │   │   ├── HitStopComponent.cpp
    │   │   ├── HitStopComponent.h
    │   │   ├── HitboxDescription.cpp
    │   │   ├── HitboxDescription.h
    │   │   ├── HitboxDescriptionDataAsset.cpp
    │   │   ├── HitboxDescriptionDataAsset.h
    │   │   ├── HitboxHandlerComponent.cpp
    │   │   ├── HitboxHandlerComponent.h
    │   │   ├── HitboxNotifyState.cpp
    │   │   ├── HitboxNotifyState.h
    │   │   ├── Hittable.cpp
    │   │   ├── Hittable.h
    │   │   ├── InputSequenceResolver.cpp
    │   │   ├── InputSequenceResolver.h
    │   │   ├── InputsSequenceToStateMap.cpp
    │   │   ├── InputsSequenceToStateMap.h
    │   │   ├── InvincibilityNotifyState.cpp
    │   │   ├── InvincibilityNotifyState.h
    │   │   ├── JumpNotify.cpp
    │   │   ├── JumpNotify.h
    │   │   ├── MoveDataAsset.cpp
    │   │   ├── MoveDataAsset.h
    │   │   ├── MoveInputState.h
    │   │   ├── PushCharacterNotify.cpp
    │   │   ├── PushCharacterNotify.h
    │   │   ├── SpawnProjectileNotify.cpp
    │   │   ├── SpawnProjectileNotify.h
    │   │   ├── SuperArmorData.cpp
    │   │   ├── SuperArmorData.h
    │   │   ├── SuperArmorNotifyState.cpp
    │   │   └── SuperArmorNotifyState.h
    │   ├── Common
    │   │   ├── CombatStatics.cpp
    │   │   ├── CombatStatics.h
    │   │   ├── ConversionStatics.cpp
    │   │   ├── ConversionStatics.h
    │   │   ├── FSMStatics.cpp
    │   │   ├── FSMStatics.h
    │   │   ├── GameFramework.cpp
    │   │   ├── GameFramework.h
    │   │   ├── GlobalDelegates.cpp
    │   │   ├── GlobalDelegates.h
    │   │   ├── Manager.cpp
    │   │   ├── Manager.h
    │   │   ├── MathStatics.cpp
    │   │   └── MathStatics.h
    │   ├── Debugging
    │   │   ├── Debug.h
    │   │   ├── HitboxVisualizer.cpp
    │   │   ├── HitboxVisualizer.h
    │   │   ├── SphereVisualizer.cpp
    │   │   └── SphereVisualizer.h
    │   ├── FSM
    │   │   ├── DelayedTransition.cpp
    │   │   ├── DelayedTransition.h
    │   │   ├── FightingCharacterState.cpp
    │   │   ├── FightingCharacterState.h
    │   │   ├── FightingCharacterStateTransition.cpp
    │   │   ├── FightingCharacterStateTransition.h
    │   │   ├── GroundedTransition.cpp
    │   │   ├── GroundedTransition.h
    │   │   ├── InputTransition.cpp
    │   │   ├── InputTransition.h
    │   │   ├── InputsSequenceTransition.cpp
    │   │   ├── InputsSequenceTransition.h
    │   │   ├── MontageEndedTransition.cpp
    │   │   ├── MontageEndedTransition.h
    │   │   ├── MoveTransition.cpp
    │   │   ├── MoveTransition.h
    │   │   ├── MovementTransition.cpp
    │   │   ├── MovementTransition.h
    │   │   ├── StateMachineComponent.cpp
    │   │   ├── StateMachineComponent.h
    │   │   ├── StateMachineState.cpp
    │   │   └── StateMachineState.h
    │   ├── FightingGame.Build.cs
    │   ├── FightingGame.cpp
    │   ├── FightingGame.h
    │   ├── FightingGameGameModeBase.cpp
    │   ├── FightingGameGameModeBase.h
    │   ├── GameInstance
    │   │   ├── CustomGameInstance.cpp
    │   │   ├── CustomGameInstance.h
    │   │   ├── CustomGameState.cpp
    │   │   └── CustomGameState.h
    │   ├── GameMode
    │   │   ├── FreeForAllGameMode.cpp
    │   │   ├── FreeForAllGameMode.h
    │   │   ├── IndexedPlayerStart.cpp
    │   │   └── IndexedPlayerStart.h
    │   ├── Input
    │   │   ├── InputEntry.h
    │   │   ├── InputPhase.h
    │   │   ├── InputsSequence.cpp
    │   │   ├── InputsSequence.h
    │   │   ├── InputsSequenceStateMappingRow.cpp
    │   │   ├── InputsSequenceStateMappingRow.h
    │   │   ├── MovesBufferComponent.cpp
    │   │   └── MovesBufferComponent.h
    │   ├── PlayerController
    │   │   ├── FightingGameCheatManager.cpp
    │   │   ├── FightingGameCheatManager.h
    │   │   ├── FightingGamePlayerController.cpp
    │   │   └── FightingGamePlayerController.h
    │   ├── Projectile
    │   │   ├── Projectile.cpp
    │   │   ├── Projectile.h
    │   │   ├── ProjectileSpawnerComponent.cpp
    │   │   └── ProjectileSpawnerComponent.h
    │   ├── Prop
    │   │   ├── Prop.cpp
    │   │   └── Prop.h
    │   └── UI
    │       ├── CharacterHealthBarWidget.cpp
    │       ├── CharacterHealthBarWidget.h
    │       ├── HUDBase.cpp
    │       └── HUDBase.h
    ├── FightingGame.Target.cs
    └── FightingGameEditor.Target.cs

```

`Config/DefaultEngine.ini`:

```ini


[/Script/EngineSettings.GameMapsSettings]
GameDefaultMap=/Game/Game/Maps/Map_Sandbox.Map_Sandbox


EditorStartupMap=/Game/Game/Maps/Map_Sandbox_Sky.Map_Sandbox_Sky
GlobalDefaultGameMode=/Game/Game/GameMode/BP_FreeForAll.BP_FreeForAll_C
bUseSplitscreen=False
bOffsetPlayerGamepadIds=True
GameInstanceClass=/Game/Game/GameInstance/BP_CustomGameInstance.BP_CustomGameInstance_C

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12

[/Script/Engine.RendererSettings]
r.GenerateMeshDistanceFields=True
r.DynamicGlobalIlluminationMethod=1
r.ReflectionMethod=1
r.Shadow.Virtual.Enable=1

[/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'

[/Script/Engine.Engine]
+ActiveGameNameRedirects=(OldGameName="TP_Blank",NewGameName="/Script/FightingGame")
+ActiveGameNameRedirects=(OldGameName="/Script/TP_Blank",NewGameName="/Script/FightingGame")
+ActiveClassRedirects=(OldClassName="TP_BlankGameModeBase",NewClassName="FightingGameGameModeBase")

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=FE6A328C48E01AC0C405C0B25A978950
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/Engine.CollisionProfile]
-Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
-Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
-Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
-Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
-Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
-Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
-Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
-Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
-Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
+Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
+Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
+Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
+Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
+Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
+Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
+Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
+Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
+Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
+Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
+Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
+Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
+Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
+Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Ignore,bTraceType=False,bStaticObject=False,Name="Hurtbox")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel2,DefaultResponse=ECR_Ignore,bTraceType=False,bStaticObject=False,Name="Pushbox")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel3,DefaultResponse=ECR_Block,bTraceType=False,bStaticObject=False,Name="Wall")
-ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
-ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
-ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
-ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
-ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
+ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
+ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
+ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
+ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
+ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
-CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
-CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
-CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
-CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
+CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
+CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
+CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
+CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")

[CoreRedirects]
+FunctionRedirects=(OldName="/Script/FightingGame.CombatStatics.CalculateKnockbackVectorFromOrientation",NewName="/Script/FightingGame.CombatStatics.GetKnockbackVectorFromOrientation")
+FunctionRedirects=(OldName="/Script/FightingGame.CombatStatics.GetKnockbackVectorFromOrientation",NewName="/Script/FightingGame.CombatStatics.GetKnockbackFromOrientation")
+ClassRedirects=(OldName="/Script/FightingGame.FightingGamePlayerController",NewName="/Script/FightingGame.FightingGamePlayerController")
+ClassRedirects=(OldName="/Script/FightingGame.UFightingCharacterStateTransition",NewName="/Script/FightingGame.FightingCharacterStateTransition")
+ClassRedirects=(OldName="/Script/FightingGame.PushCharacterNotifyState",NewName="/Script/FightingGame.PushCharacterNotify")
+FunctionRedirects=(OldName="/Script/FightingGame.FightingCharacter.EnableHitStun",NewName="/Script/FightingGame.FightingCharacter.EnableHitStop")
+FunctionRedirects=(OldName="/Script/FightingGame.FightingCharacter.DisableHitStun",NewName="/Script/FightingGame.FightingCharacter.DisableHitStop")
+PropertyRedirects=(OldName="/Script/FightingGame.HitboxNotifyState.m_HitStunDuration",NewName="/Script/FightingGame.HitboxNotifyState.m_HitStopDuration")
+FunctionRedirects=(OldName="/Script/FightingGame.CombatStatics.GetHitStunInitialDelay",NewName="/Script/FightingGame.CombatStatics.GetHitStopInitialDelay")
+FunctionRedirects=(OldName="/Script/FightingGame.CombatStatics.GetMinCustomTimeDilation",NewName="/Script/FightingGame.CombatStatics.GetHitStopTimeDilation")
+EnumRedirects=(OldName="/Script/FightingGame.EMoveType",NewName="/Script/FightingGame.EInputEntry")
+FunctionRedirects=(OldName="/Script/FightingGame.MathStatics.GetAngleBetween",NewName="/Script/FightingGame.MathStatics.GetSignedAngle")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.ClearBuffer",NewName="/Script/FightingGame.MovesBufferComponent.ClearInputsBuffer")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.ClearBuffer",NewName="/Script/FightingGame.MovesBufferComponent.ClearInputsBuffer")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.InitBuffer",NewName="/Script/FightingGame.MovesBufferComponent.InitInputBuffer")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.InitBuffer",NewName="/Script/FightingGame.MovesBufferComponent.InitInputBuffer")
+PropertyRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.m_BufferSizeFrames",NewName="/Script/FightingGame.MovesBufferComponent.m_InputBufferSizeFrames")
+PropertyRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.m_BufferSizeFrames",NewName="/Script/FightingGame.MovesBufferComponent.m_InputBufferSizeFrames")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.IsMoveBuffered",NewName="/Script/FightingGame.MovesBufferComponent.IsInputsSequenceBuffered")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.ClearMovesBuffer",NewName="/Script/FightingGame.MovesBufferComponent.ClearInputsSequenceBuffer")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.InitMovesBuffer",NewName="/Script/FightingGame.MovesBufferComponent.InitInputsSequenceBuffer")
+FunctionRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.UseBufferedMove",NewName="/Script/FightingGame.MovesBufferComponent.UseBufferedInputsSequence")
+ClassRedirects=(OldName="/Script/FightingGame.ComplexInputTransition",NewName="/Script/FightingGame.InputsSequenceTransition")
+PropertyRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.m_BufferFrameRate",NewName="/Script/FightingGame.MovesBufferComponent.m_InputBufferFrameRate")
+PropertyRedirects=(OldName="/Script/FightingGame.MovesBufferComponent.m_MovesList",NewName="/Script/FightingGame.MovesBufferComponent.m_InputsList")
+PropertyRedirects=(OldName="/Script/FightingGame.MoveInputState.m_InputEvent",NewName="/Script/FightingGame.MoveInputState.m_InputType")
+ClassRedirects=(OldName="/Script/FightingGame.InputsSequenceStateMappingRow",NewName="/Script/FightingGame.InputsSequenceStateMappingRow")
+PropertyRedirects=(OldName="/Script/FightingGame.FightingCharacterState.m_InputsSequenceNameToStateMap",NewName="/Script/FightingGame.FightingCharacterState.m_InputsSequencesOverrides")
+PropertyRedirects=(OldName="/Script/FightingGame.InputsSequenceStateMappingRow.m_CanBeUsedToCancelOnHit",NewName="/Script/FightingGame.InputsSequenceStateMappingRow.m_AllowAsOnHitCancel")
+PropertyRedirects=(OldName="/Script/FightingGame.InputsSequenceStateMappingRow.m_AllowOnHit",NewName="/Script/FightingGame.InputsSequenceStateMappingRow.m_AllowAsOnHitCancel")
+ClassRedirects=(OldName="/Script/FightingGame.GameState",NewName="/Script/FightingGame.CustomGameState")
+PropertyRedirects=(OldName="/Script/FightingGame.MoveInputState.m_InputType",NewName="/Script/FightingGame.MoveInputState.m_InputPhase")
+ClassRedirects=(OldName="/Script/FightingGame.SuperArmorNotify",NewName="/Script/FightingGame.SuperArmorNotifyState")


```

`Config/DefaultGame.ini`:

```ini

[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=1223E39A415FB4C6D2E62083B57A59BE
ProjectName=Project Seed
CompanyName=Giammarco Agazzotti
CompanyDistinguishedName=Giammarco Agazzotti
CopyrightNotice=Copyright (c) Giammarco Agazzotti
ProjectDisplayedTitle=NSLOCTEXT("[/Script/EngineSettings]", "03C59F4A46D9DB63318DED875350CE7B", "Project Seed")

[StartupActions]
bAddPacks=True
InsertPack=(PackSource="StarterContent.upack",PackName="StarterContent")


```

`Config/DefaultInput.ini`:

```ini
[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Touch",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
+ActionMappings=(ActionName="Attack",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=I)
+ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
+ActionMappings=(ActionName="Attack",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
+ActionMappings=(ActionName="Attack",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Left)
+ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Bottom)
+ActionMappings=(ActionName="Special",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=O)
+ActionMappings=(ActionName="Special",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Top)
+ActionMappings=(ActionName="Counter",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=U)
+ActionMappings=(ActionName="Counter",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_LeftShoulder)
+AxisMappings=(AxisName="MoveHorizontal",Scale=1.000000,Key=D)
+AxisMappings=(AxisName="MoveHorizontal",Scale=-1.000000,Key=A)
+AxisMappings=(AxisName="MoveHorizontal",Scale=1.000000,Key=Gamepad_LeftX)
+AxisMappings=(AxisName="MoveVertical",Scale=1.000000,Key=W)
+AxisMappings=(AxisName="MoveVertical",Scale=-1.000000,Key=S)
+AxisMappings=(AxisName="MoveVertical",Scale=1.000000,Key=Gamepad_LeftY)
+AxisMappings=(AxisName="MoveHorizontal",Scale=1.000000,Key=Gamepad_DPad_Right)
+AxisMappings=(AxisName="MoveHorizontal",Scale=-1.000000,Key=Gamepad_DPad_Left)
+AxisMappings=(AxisName="MoveVertical",Scale=1.000000,Key=Gamepad_DPad_Up)
+AxisMappings=(AxisName="MoveVertical",Scale=-1.000000,Key=Gamepad_DPad_Down)
DefaultPlayerInputClass=/Script/Engine.PlayerInput
DefaultInputComponentClass=/Script/Engine.InputComponent
DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
-ConsoleKeys=Tilde
+ConsoleKeys=Nine


```

`Config/HoloLens/HoloLensEngine.ini`:

```ini


[/Script/HoloLensPlatformEditor.HoloLensTargetSettings]
bBuildForEmulation=False
bBuildForDevice=True
bUseNameForLogo=True
bBuildForRetailWindowsStore=False
bAutoIncrementVersion=False
bShouldCreateAppInstaller=False
AppInstallerInstallationURL=
HoursBetweenUpdateChecks=0
bEnablePIXProfiling=False
TileBackgroundColor=(B=64,G=0,R=0,A=255)
SplashScreenBackgroundColor=(B=64,G=0,R=0,A=255)
+PerCultureResources=(CultureId="",Strings=(PackageDisplayName="",PublisherDisplayName="",PackageDescription="",ApplicationDisplayName="",ApplicationDescription=""),Images=())
TargetDeviceFamily=Windows.Holographic
MinimumPlatformVersion=
MaximumPlatformVersionTested=10.0.18362.0
MaxTrianglesPerCubicMeter=500.000000
SpatialMeshingVolumeSize=20.000000
CompilerVersion=Default
Windows10SDKVersion=10.0.18362.0
+CapabilityList=internetClientServer
+CapabilityList=privateNetworkClientServer
+Uap2CapabilityList=spatialPerception
bSetDefaultCapabilities=False
SpatializationPlugin=
ReverbPlugin=
OcclusionPlugin=
SoundCueCookQualityIndex=-1


```

`FightingGame.uproject`:

```uproject
{
  "FileVersion": 3,
  "EngineAssociation": "5.0",
  "Category": "",
  "Description": "",
  "Modules": [
    {
      "Name": "FightingGame",
      "Type": "Runtime",
      "LoadingPhase": "Default",
      "AdditionalDependencies": [
        "Engine"
      ]
    }
  ],
  "Plugins": [
    {
      "Name": "ModelingToolsEditorMode",
      "Enabled": true,
      "TargetAllowList": [
        "Editor"
      ]
    },
    {
      "Name": "AssetSearch",
      "Enabled": true
    }
  ]
}
```

`Plugins/Developer/RiderLink/Resources/checksum`:

```
¦¥©+˜‚¿_œ#P÷Ë;f
```

`Plugins/Developer/RiderLink/RiderLink.uplugin`:

```uplugin
{
  "FileVersion": 3,
  "Version": 1,
  "VersionName": "2022.3.0.125",
  "FriendlyName": "RiderLink",
  "Description": "Plugin for establishing IPC connection with JetBrains Rider IDE",
  "Category": "Programming",
  "CreatedBy": "JetBrains",
  "CreatedByURL": "https://www.jetbrains.com/",
  "DocsURL": "",
  "MarketplaceURL": "",
  "SupportURL": "",
  "CanContainContent": false,
  "IsBetaVersion": true,
  "Installed": false,
  "Modules": [
    {
      "Name": "RD",
      "Type": "EditorNoCommandlet",
      "LoadingPhase": "PreDefault"
    },
    {
      "Name": "RiderLink",
      "Type": "EditorNoCommandlet",
      "LoadingPhase": "PreDefault"
    },
    {
      "Name": "RiderLogging",
      "Type": "EditorNoCommandlet",
      "LoadingPhase": "PreDefault"
    },
    {
      "Name": "RiderBlueprint",
      "Type": "EditorNoCommandlet",
      "LoadingPhase": "Default"
    },
    {
      "Name": "RiderGameControl",
      "Type": "EditorNoCommandlet",
      "LoadingPhase": "Default"
    },
    {
      "Name": "RiderShaderInfo",
      "Type": "EditorNoCommandlet",
      "LoadingPhase": "PostEngineInit"
    }
  ],
  "EnabledByDefault": true
}
```

`Plugins/Developer/RiderLink/Source/RD/RD.Build.cs`:

```cs
// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

using System.IO;
using UnrealBuildTool;

public class RD : ModuleRules
{
	public RD(ReadOnlyTargetRules Target) : base(Target)
	{
		PublicDependencyModuleNames.Add("Core");
		bUseRTTI = true;
		bEnforceIWYU = false;

#if UE_4_22_OR_LATER
		CppStandard = CppStandardVersion.Cpp17;
#endif

#if UE_4_22_OR_LATER
		PCHUsage = PCHUsageMode.NoPCHs;
#else
		PCHUsage = PCHUsageMode.NoSharedPCHs;
#endif

#if UE_4_24_OR_LATER
		ShadowVariableWarningLevel = WarningLevel.Off;
		bUseUnity = false;
#else
		bEnableShadowVariableWarnings = false;
		bFasterWithoutUnity = true;
#endif

		PublicDefinitions.Add("_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS");

		if (Target.Platform == UnrealTargetPlatform.Win64)
		{
			PublicDefinitions.Add("_WINSOCK_DEPRECATED_NO_WARNINGS");
			PublicDefinitions.Add("_CRT_SECURE_NO_WARNINGS");
			PublicDefinitions.Add("_CRT_NONSTDC_NO_DEPRECATE");
			PublicDefinitions.Add("SPDLOG_WCHAR_FILENAMES");
			PublicDefinitions.Add("SPDLOG_WCHAR_TO_UTF8_SUPPORT");
			PrivateDefinitions.Add("WIN32_LEAN_AND_MEAN");
		}

		if (Target.Platform == UnrealTargetPlatform.Mac)
		{
			PublicDefinitions.Add("_DARWIN");
		}

		// Common dependencies
		PrivateDefinitions.Add("rd_framework_cpp_EXPORTS");
		PrivateDefinitions.Add("rd_core_cpp_EXPORTS");
		PrivateDefinitions.Add("spdlog_EXPORTS");
		PrivateDefinitions.Add("FMT_EXPORT");

		PublicDefinitions.Add("SPDLOG_NO_EXCEPTIONS");
		PublicDefinitions.Add("SPDLOG_COMPILED_LIB");
		PublicDefinitions.Add("SPDLOG_SHARED_LIB");
		PublicDefinitions.Add(
			"nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_NONSTD");
		PublicDefinitions.Add("FMT_SHARED");

		string[] Paths =
		{
			"src", "src/rd_core_cpp", "src/rd_core_cpp/src/main"
			, "src/rd_framework_cpp", "src/rd_framework_cpp/src/main"
			, "src/rd_framework_cpp/src/main/util", "src/rd_gen_cpp/src"
			, "thirdparty", "thirdparty/ordered-map/include"
			, "thirdparty/optional/tl", "thirdparty/variant/include"
			, "thirdparty/string-view-lite/include", "thirdparty/spdlog/include"
			, "thirdparty/clsocket/src", "thirdparty/CTPL/include"
		};

		foreach (var Item in Paths)
		{
			PublicIncludePaths.Add(Path.Combine(ModuleDirectory, Item));
		}
	}
}

```

`Plugins/Developer/RiderLink/Source/RD/RD.cpp`:

```cpp
#include "RD.h"

#include <Modules/ModuleManager.h>

#define LOCTEXT_NAMESPACE "RD"

DEFINE_LOG_CATEGORY(FLogRDModule);

IMPLEMENT_MODULE(FRDModule, RD);
```

`Plugins/Developer/RiderLink/Source/RD/RD.h`:

```h
// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Logging/LogMacros.h"
#include "Logging/LogVerbosity.h"
#include "Modules/ModuleInterface.h"

DECLARE_LOG_CATEGORY_EXTERN(FLogRDModule, Log, All);

class FRDModule : public IModuleInterface
{
public:
	FRDModule() = default;
	~FRDModule() = default;
};

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/rd_core_export.h`:

```h

#ifndef RD_CORE_API_H
#define RD_CORE_API_H

#if defined(_WIN32)
#ifdef RD_CORE_STATIC_DEFINE
#  define RD_CORE_API
#  define RD_CORE_NO_EXPORT
#else
#  ifndef RD_CORE_API
#    ifdef rd_core_cpp_EXPORTS
        /* We are building this library */
#      define RD_CORE_API __declspec(dllexport)
#    else
        /* We are using this library */
#      define RD_CORE_API __declspec(dllimport)
#    endif
#  endif

#  ifndef RD_CORE_NO_EXPORT
#    define RD_CORE_NO_EXPORT
#  endif
#endif

#ifndef RD_CORE_DEPRECATED
#  define RD_CORE_DEPRECATED __declspec(deprecated)
#endif

#ifndef RD_CORE_DEPRECATED_EXPORT
#  define RD_CORE_DEPRECATED_EXPORT RD_CORE_API RD_CORE_DEPRECATED
#endif

#ifndef RD_CORE_DEPRECATED_NO_EXPORT
#  define RD_CORE_DEPRECATED_NO_EXPORT RD_CORE_NO_EXPORT RD_CORE_DEPRECATED
#endif

#if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef RD_CORE_NO_DEPRECATED
#    define RD_CORE_NO_DEPRECATED
#  endif
#endif
#endif

#if defined(unix) || defined(__unix__) || defined(__unix) || defined(__APPLE__)
#ifdef RD_CORE_STATIC_DEFINE
#  define RD_CORE_API
#  define RD_CORE_NO_EXPORT
#else
#  ifndef RD_CORE_API
#    ifdef rd_core_cpp_EXPORTS
        /* We are building this library */
#      define RD_CORE_API __attribute__((visibility("default")))
#    else
        /* We are using this library */
#      define RD_CORE_API __attribute__((visibility("default")))
#    endif
#  endif

#  ifndef RD_CORE_NO_EXPORT
#    define RD_CORE_NO_EXPORT __attribute__((visibility("hidden")))
#  endif
#endif

#ifndef RD_CORE_DEPRECATED
#  define RD_CORE_DEPRECATED __attribute__ ((__deprecated__))
#endif

#ifndef RD_CORE_DEPRECATED_EXPORT
#  define RD_CORE_DEPRECATED_EXPORT RD_CORE_API RD_CORE_DEPRECATED
#endif

#ifndef RD_CORE_DEPRECATED_NO_EXPORT
#  define RD_CORE_DEPRECATED_NO_EXPORT RD_CORE_NO_EXPORT RD_CORE_DEPRECATED
#endif

#if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef RD_CORE_NO_DEPRECATED
#    define RD_CORE_NO_DEPRECATED
#  endif
#endif
#endif

#endif /* RD_CORE_API_H */

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/Lifetime.cpp`:

```cpp
#include "Lifetime.h"

#include <memory>

#include <thirdparty.hpp>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>

namespace rd
{
/*thread_local */ Lifetime::Allocator Lifetime::allocator;

LifetimeImpl* Lifetime::operator->() const
{
	return ptr.operator->();
}

std::once_flag onceFlag;

Lifetime::Lifetime(bool is_eternal) : ptr(std::allocate_shared<LifetimeImpl, Allocator>(allocator, is_eternal))
{
	std::call_once(onceFlag, [] {
		spdlog::set_default_logger(spdlog::stderr_color_mt<spdlog::synchronous_factory>("default", spdlog::color_mode::automatic));
	});
}

Lifetime Lifetime::create_nested() const
{
	Lifetime lw(false);
	ptr->attach_nested(lw.ptr);
	return lw;
}

Lifetime const& Lifetime::Eternal()
{
	static Lifetime ETERNAL(true);
	return ETERNAL;
}

bool operator==(Lifetime const& lw1, Lifetime const& lw2)
{
	return lw1.ptr == lw2.ptr;
}

bool operator!=(Lifetime const& lw1, Lifetime const& lw2)
{
	return !(lw1 == lw2);
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/Lifetime.h`:

```h
#ifndef RD_CPP_CORE_LIFETIMEWRAPPER_H
#define RD_CPP_CORE_LIFETIMEWRAPPER_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "LifetimeImpl.h"

#include <std/hash.h>

#include <memory>

#include <rd_core_export.h>

namespace rd
{
class Lifetime;

template <>
struct RD_CORE_API hash<Lifetime>
{
	size_t operator()(const Lifetime& value) const noexcept;
};

class RD_CORE_API Lifetime final
{
private:
	using Allocator = std::allocator<LifetimeImpl>;

	static /*thread_local */ Allocator allocator;

	friend class LifetimeDefinition;

	friend struct hash<Lifetime>;

	std::shared_ptr<LifetimeImpl> ptr;

public:
	static Lifetime const& Eternal();

	// region ctor/dtor

	Lifetime(Lifetime const& other) = default;

	Lifetime& operator=(Lifetime const& other) = default;

	Lifetime(Lifetime&& other) noexcept = default;

	Lifetime& operator=(Lifetime&& other) noexcept = default;

	~Lifetime() = default;
	// endregion

	friend bool RD_CORE_API operator==(Lifetime const& lw1, Lifetime const& lw2);
	friend bool RD_CORE_API operator!=(Lifetime const& lw1, Lifetime const& lw2);

	explicit Lifetime(bool is_eternal = false);

	LifetimeImpl* operator->() const;

	Lifetime create_nested() const;
};

inline size_t hash<Lifetime>::operator()(const Lifetime& value) const noexcept
{
	return hash<std::shared_ptr<LifetimeImpl> >()(value.ptr);
}
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_CORE_LIFETIMEWRAPPER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/LifetimeDefinition.cpp`:

```cpp
#include "LifetimeDefinition.h"

#include <spdlog/spdlog.h>

namespace rd
{
LifetimeDefinition::LifetimeDefinition(bool eternaled) : eternaled(eternaled), lifetime(eternaled)
{
}

LifetimeDefinition::LifetimeDefinition(const Lifetime& parent) : LifetimeDefinition(false)
{
	parent->attach_nested(lifetime.ptr);
}

bool LifetimeDefinition::is_terminated() const
{
	return lifetime->is_terminated();
}

void LifetimeDefinition::terminate()
{
	lifetime->terminate();
}

bool LifetimeDefinition::is_eternal() const
{
	return lifetime->is_eternal();
}

namespace
{
LifetimeDefinition ETERNAL(true);
}

std::shared_ptr<LifetimeDefinition> LifetimeDefinition::get_shared_eternal()
{
	return std::shared_ptr<LifetimeDefinition>(&ETERNAL, [](LifetimeDefinition* /*ld*/) {});
}

LifetimeDefinition::~LifetimeDefinition()
{
	if (lifetime.ptr != nullptr)
	{	 // wasn't moved
		if (!is_eternal())
		{
			if (!lifetime->is_terminated())
			{
				lifetime->terminate();
			}
		}
	}
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/LifetimeDefinition.h`:

```h
#ifndef RD_CPP_CORE_LIFETIME_DEFINITION_H
#define RD_CPP_CORE_LIFETIME_DEFINITION_H

#include "util/core_traits.h"

#include "LifetimeImpl.h"
#include "Lifetime.h"

#include <functional>
#include <type_traits>

#include <rd_core_export.h>

namespace rd
{
class RD_CORE_API LifetimeDefinition
{
private:
	friend class SequentialLifetimes;

	bool eternaled = false;

public:
	Lifetime lifetime;

	explicit LifetimeDefinition(bool is_eternal = false);

	explicit LifetimeDefinition(const Lifetime& parent);

	LifetimeDefinition(LifetimeDefinition const& other) = delete;

	LifetimeDefinition& operator=(LifetimeDefinition const& other) = delete;

	LifetimeDefinition(LifetimeDefinition&& other) = default;

	LifetimeDefinition& operator=(LifetimeDefinition&& other) = default;

	virtual ~LifetimeDefinition();

	//    static std::shared_ptr<LifetimeDefinition> eternal;
	static std::shared_ptr<LifetimeDefinition> get_shared_eternal();

	bool is_terminated() const;

	bool is_eternal() const;

	void terminate();

	template <typename F>
	static auto use(F&& block) -> typename util::result_of_t<F(Lifetime)>
	{
		LifetimeDefinition definition(false);
		Lifetime lw = definition.lifetime.create_nested();
		return block(lw);
	}
};
}	 // namespace rd

#endif	  // RD_CPP_CORE_LIFETIME_DEFINITION_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/LifetimeImpl.cpp`:

```cpp
#include "LifetimeImpl.h"

#include <utility>

namespace rd
{
#if __cplusplus < 201703L
LifetimeImpl::counter_t LifetimeImpl::get_id = 0;
#endif

LifetimeImpl::LifetimeImpl(bool is_eternal) : eternaled(is_eternal), id(LifetimeImpl::get_id++)
{
}

void LifetimeImpl::terminate()
{
	if (is_eternal())
		return;

	terminated = true;

	// region thread-safety section

	actions_t actions_copy;
	{
		std::lock_guard<decltype(actions_lock)> guard(actions_lock);
		actions_copy = std::move(actions);

		actions.clear();
	}
	// endregion

	for (auto it = actions_copy.rbegin(); it != actions_copy.rend(); ++it)
	{
		it->second();
	}
}

bool LifetimeImpl::is_terminated() const
{
	return terminated;
}

bool LifetimeImpl::is_eternal() const
{
	return eternaled;
}

void LifetimeImpl::attach_nested(std::shared_ptr<LifetimeImpl> nested)
{
	if (nested->is_terminated() || is_eternal())
		return;

	std::function<void()> action = [nested] { nested->terminate(); };
	counter_t action_id = add_action(action);
	nested->add_action([this, id = action_id] { actions.erase(id); });
}

LifetimeImpl::~LifetimeImpl()
{
	/*if (!is_eternal() && !is_terminated()) {
		spdlog::error("forget to terminate lifetime with id: {}", to_string(id));
		terminate();
	}*/
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/LifetimeImpl.h`:

```h
#ifndef RD_CPP_CORE_LIFETIME_H
#define RD_CPP_CORE_LIFETIME_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <std/hash.h>

#include <functional>
#include <map>
#include <memory>
#include <mutex>
#include <atomic>
#include <utility>

#include <thirdparty.hpp>

#include <rd_core_export.h>

namespace rd
{
class RD_CORE_API LifetimeImpl final
{
public:
	friend class LifetimeDefinition;

	friend class Lifetime;

	using counter_t = int32_t;

private:
	bool eternaled = false;
	std::atomic<bool> terminated{false};

	counter_t id = 0;

	counter_t action_id_in_map = 0;
	using actions_t = ordered_map<int, std::function<void()>, rd::hash<int>>;
	actions_t actions;

	void terminate();

	std::mutex actions_lock;

public:
	// region ctor/dtor
	explicit LifetimeImpl(bool is_eternal = false);

	LifetimeImpl(LifetimeImpl const& other) = delete;

	~LifetimeImpl();
	// endregion

	template <typename F>
	counter_t add_action(F&& action)
	{
		std::lock_guard<decltype(actions_lock)> guard(actions_lock);

		if (is_eternal())
		{
			return -1;
		}
		if (is_terminated())
		{
			throw std::invalid_argument("Already Terminated");
		}

		actions[action_id_in_map] = std::forward<F>(action);
		return action_id_in_map++;
	}

	void remove_action(counter_t i)
	{
		std::lock_guard<decltype(actions_lock)> guard(actions_lock);

		actions.erase(i);
	}

#if __cplusplus >= 201703L
	static inline counter_t get_id = 0;
#else
	static counter_t get_id;
#endif

	template <typename F, typename G>
	void bracket(F&& opening, G&& closing)
	{
		if (is_terminated())
			return;
		opening();
		add_action(std::forward<G>(closing));
	}

	bool is_terminated() const;

	bool is_eternal() const;

	void attach_nested(std::shared_ptr<LifetimeImpl> nested);
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_CORE_LIFETIME_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/SequentialLifetimes.cpp`:

```cpp
#include "SequentialLifetimes.h"

namespace rd
{
SequentialLifetimes::SequentialLifetimes(Lifetime parent_lifetime) : parent_lifetime(std::move(parent_lifetime))
{
	this->parent_lifetime->add_action([this] { set_current_lifetime(LifetimeDefinition::get_shared_eternal()); });
}

Lifetime SequentialLifetimes::next()
{
	std::shared_ptr<LifetimeDefinition> new_def = std::make_shared<LifetimeDefinition>(parent_lifetime);
	set_current_lifetime(new_def);
	return current_def->lifetime;
}

void SequentialLifetimes::terminate_current()
{
	set_current_lifetime(LifetimeDefinition::get_shared_eternal());
}

bool SequentialLifetimes::is_terminated() const
{
	return current_def->is_eternal() || current_def->is_terminated();
}

void SequentialLifetimes::set_current_lifetime(std::shared_ptr<LifetimeDefinition> new_def)
{
	std::shared_ptr<LifetimeDefinition> prev = current_def;
	current_def = new_def;
	prev->terminate();
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/lifetime/SequentialLifetimes.h`:

```h
#ifndef RD_CPP_CORE_SEQUENTIAL_LIFETIMES_H
#define RD_CPP_CORE_SEQUENTIAL_LIFETIMES_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "LifetimeDefinition.h"
#include "Lifetime.h"

#include <rd_core_export.h>

namespace rd
{
class RD_CORE_API SequentialLifetimes
{
private:
	std::shared_ptr<LifetimeDefinition> current_def = LifetimeDefinition::get_shared_eternal();
	Lifetime parent_lifetime;

public:
	// region ctor/dtor
	SequentialLifetimes() = delete;

	SequentialLifetimes(SequentialLifetimes const&) = delete;

	SequentialLifetimes& operator=(SequentialLifetimes const&) = delete;

	SequentialLifetimes(SequentialLifetimes&&) = delete;

	SequentialLifetimes& operator=(SequentialLifetimes&&) = delete;

	explicit SequentialLifetimes(Lifetime parent_lifetime);
	// endregion

	Lifetime next();

	void terminate_current();

	bool is_terminated() const;

	void set_current_lifetime(std::shared_ptr<LifetimeDefinition> new_def);
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_CORE_SEQUENTIAL_LIFETIMES_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/Property.h`:

```h
#ifndef RD_CPP_CORE_PROPERTY_H
#define RD_CPP_CORE_PROPERTY_H

#include "base/IProperty.h"
#include "reactive/base/SignalX.h"

#include <util/core_util.h>

namespace rd
{
/**
 * \brief complete class which has \a Property<T> 's properties.
 * \tparam T type of stored value (may be abstract)
 */
template <typename T>
class Property : public IProperty<T>
{
	using WT = typename IProperty<T>::WT;

public:
	// region ctor/dtor

	Property() = default;

	Property(Property&& other) = default;

	Property& operator=(Property&& other) = default;

	virtual ~Property() = default;

	template <typename F>
	explicit Property(F&& value) : IProperty<T>(std::forward<F>(value))
	{
	}
	// endregion

	T const& get() const override
	{
		RD_ASSERT_THROW_MSG(this->has_value(), "get of uninitialized value from property");
		return *(this->value);
	}

	void set(WT new_value) const override
	{
		if (!this->has_value() || (this->get() != wrapper::get<T>(new_value)))
		{
			if (this->has_value())
			{
				this->before_change.fire(*(this->value));
			}
			this->value = std::move(new_value);
			this->change.fire(*(this->value));
		}
	}

	friend bool operator==(const Property& lhs, const Property& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const Property& lhs, const Property& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(Property const& value)
	{
		return value.has_value() ? to_string(value.get()) : "empty property"s;
	}
};
}	 // namespace rd

static_assert(std::is_move_constructible<rd::Property<int>>::value, "Is not move constructible from Property<int>");

#endif	  // RD_CPP_CORE_PROPERTY_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/ViewableList.h`:

```h
#ifndef RD_CPP_CORE_VIEWABLELIST_H
#define RD_CPP_CORE_VIEWABLELIST_H

#include "base/IViewableList.h"
#include "reactive/base/SignalX.h"
#include "util/core_util.h"

#include <algorithm>
#include <iterator>
#include <utility>

namespace rd
{
/**
 * \brief complete class which has @code IViewableList<T>'s properties
 */
template <typename T, typename A = allocator<T>>
class ViewableList : public IViewableList<T>
{
public:
	using Event = typename IViewableList<T>::Event;

private:
	using WA = typename std::allocator_traits<A>::template rebind_alloc<Wrapper<T>>;

	using data_t = std::vector<Wrapper<T>, WA>;
	mutable data_t list;
	Signal<Event> change;

protected:
	using WT = typename IViewableList<T>::WT;

	const std::vector<Wrapper<T>>& getList() const override
	{
		return list;
	}

public:
	// region ctor/dtor

	ViewableList() = default;

	ViewableList(ViewableList&&) = default;

	ViewableList& operator=(ViewableList&&) = default;

	virtual ~ViewableList() = default;

	// endregion

	// region iterators
public:
	class iterator
	{
		friend class ViewableList<T>;

		typename data_t::iterator it_;

		explicit iterator(const typename data_t::iterator& it) : it_(it)
		{
		}

	public:
		using iterator_category = std::random_access_iterator_tag;
		using value_type = T;
		using difference_type = std::ptrdiff_t;
		using pointer = T const*;
		using reference = T const&;

		iterator(const iterator& other) = default;

		iterator(iterator&& other) noexcept = default;

		iterator& operator=(const iterator& other) = default;

		iterator& operator=(iterator&& other) noexcept = default;

		iterator& operator++()
		{
			++it_;
			return *this;
		}

		iterator operator++(int)
		{
			auto it = *this;
			++*this;
			return it;
		}

		iterator& operator--()
		{
			--it_;
			return *this;
		}

		iterator operator--(int)
		{
			auto it = *this;
			--*this;
			return it;
		}

		iterator& operator+=(difference_type delta)
		{
			it_ += delta;
			return *this;
		}

		iterator& operator-=(difference_type delta)
		{
			it_ -= delta;
			return *this;
		}

		iterator operator+(difference_type delta) const
		{
			auto it = *this;
			return it += delta;
		}

		iterator operator-(difference_type delta) const
		{
			auto it = *this;
			return it -= delta;
		}

		difference_type operator-(iterator const& other) const
		{
			return it_ - other.it_;
		}

		bool operator<(iterator const& other) const noexcept
		{
			return this->it_ < other.it_;
		}

		bool operator>(iterator const& other) const noexcept
		{
			return this->it_ > other.it_;
		}

		bool operator==(iterator const& other) const noexcept
		{
			return this->it_ == other.it_;
		}

		bool operator!=(iterator const& other) const noexcept
		{
			return !(*this == other);
		}

		bool operator<=(iterator const& other) const noexcept
		{
			return (this->it_ < other.it_) || (*this == other);
		}

		bool operator>=(iterator const& other) const noexcept
		{
			return (this->it_ > other.it_) || (*this == other);
		}

		reference operator*() noexcept
		{
			return **it_;
		}

		reference operator*() const noexcept
		{
			return **it_;
		}

		pointer operator->() noexcept
		{
			return (*it_).get();
		}

		pointer operator->() const noexcept
		{
			return (*it_).get();
		}
	};

	using reverse_iterator = std::reverse_iterator<iterator>;

	iterator begin() const
	{
		return iterator(list.begin());
	}

	iterator end() const
	{
		return iterator(list.end());
	}

	reverse_iterator rbegin() const
	{
		return reverse_iterator(end());
	}

	reverse_iterator rend() const
	{
		return reverse_iterator(begin());
	}
	// endregion

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override
	{
		if (lifetime->is_terminated())
			return;
		change.advise(lifetime, handler);
		for (int32_t i = 0; i < static_cast<int32_t>(size()); ++i)
		{
			handler(typename Event::Add(i, &(*list[i])));
		}
	}

	bool add(WT element) const override
	{
		list.emplace_back(std::move(element));
		change.fire(typename Event::Add(static_cast<int32_t>(size()) - 1, &(*list.back())));
		return true;
	}

	bool add(size_t index, WT element) const override
	{
		list.emplace(list.begin() + index, std::move(element));
		change.fire(typename Event::Add(static_cast<int32_t>(index), &(*list[index])));
		return true;
	}

	WT removeAt(size_t index) const override
	{
		auto res = std::move(list[index]);
		list.erase(list.begin() + index);

		change.fire(typename Event::Remove(static_cast<int32_t>(index), &(*res)));
		return wrapper::unwrap<T>(std::move(res));
	}

	bool remove(T const& element) const override
	{
		auto it = std::find_if(list.begin(), list.end(), [&element](auto const& p) { return *p == element; });
		if (it == list.end())
		{
			return false;
		}
		ViewableList::removeAt(std::distance(list.begin(), it));
		return true;
	}

	T const& get(size_t index) const override
	{
		return *list[index];
	}

	WT set(size_t index, WT element) const override
	{
		auto old_value = std::move(list[index]);
		list[index] = Wrapper<T>(std::move(element));
		change.fire(typename Event::Update(static_cast<int32_t>(index), &(*old_value), &(*list[index])));	   //???
		return wrapper::unwrap<T>(std::move(old_value));
	}

	bool addAll(size_t index, std::vector<WT> elements) const override
	{
		for (auto& element : elements)
		{
			ViewableList::add(index, std::move(element));
			++index;
		}
		return true;
	}

	bool addAll(std::vector<WT> elements) const override
	{
		for (auto&& element : elements)
		{
			ViewableList::add(std::move(element));
		}
		return true;
	}

	void clear() const override
	{
		std::vector<Event> changes;
		for (size_t i = size(); i > 0; --i)
		{
			changes.push_back(typename Event::Remove(static_cast<int32_t>(i - 1), &(*list[i - 1])));
		}
		for (auto const& e : changes)
		{
			change.fire(e);
		}
		list.clear();
	}

	bool removeAll(std::vector<WT> elements) const override
	{
		// TO-DO faster
		//        std::unordered_set<T> set(elements.begin(), elements.end());

		bool res = false;
		for (size_t i = list.size(); i > 0; --i)
		{
			auto const& x = list[i - 1];
			if (std::count_if(elements.begin(), elements.end(),
					[&x](auto const& elem) { return wrapper::TransparentKeyEqual<T>()(elem, x); }) > 0)
			{
				removeAt(i - 1);
				res = true;
			}
		}
		return res;
	}

	size_t size() const override
	{
		return list.size();
	}

	bool empty() const override
	{
		return list.empty();
	}
};
}	 // namespace rd

static_assert(std::is_move_constructible<rd::ViewableList<int>>::value, "Is move constructible from ViewableList<int>");

#endif	  // RD_CPP_CORE_VIEWABLELIST_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/ViewableMap.h`:

```h
#ifndef RD_CPP_CORE_VIEWABLE_MAP_H
#define RD_CPP_CORE_VIEWABLE_MAP_H

#include "base/IViewableMap.h"
#include "reactive/base/SignalX.h"

#include <util/core_util.h>
#include <std/unordered_map.h>

#include <thirdparty.hpp>

#include <iterator>
#include <utility>

namespace rd
{
/**
 * \brief complete class which has @code IViewableMap<K, V>'s properties
 */
template <typename K, typename V, typename KA = std::allocator<K>, typename VA = std::allocator<V>>
class ViewableMap : public IViewableMap<K, V>
{
public:
	using Event = typename IViewableMap<K, V>::Event;

private:
	using WK = typename IViewableMap<K, V>::WK;
	using WV = typename IViewableMap<K, V>::WV;
	using OV = typename IViewableMap<K, V>::OV;
	using PA = typename std::allocator_traits<VA>::template rebind_alloc<std::pair<Wrapper<K>, Wrapper<V>>>;

	Signal<Event> change;

	using data_t = ordered_map<Wrapper<K>, Wrapper<V>, wrapper::TransparentHash<K>, wrapper::TransparentKeyEqual<K>, PA>;
	mutable data_t map;

public:
	// region ctor/dtor

	ViewableMap() = default;

	ViewableMap(ViewableMap&&) = default;

	ViewableMap& operator=(ViewableMap&&) = default;

	virtual ~ViewableMap() = default;
	// endregion

	// region iterators

public:
	class iterator
	{
		friend class ViewableMap<K, V>;

		mutable typename data_t::iterator it_;

		explicit iterator(const typename data_t::iterator& it) : it_(it)
		{
		}

	public:
		using iterator_category = typename data_t::iterator::iterator_category;
		using key_type = K;
		using value_type = V;
		using difference_type = std::ptrdiff_t;
		using reference = V const&;
		using pointer = V const*;

		iterator(const iterator& other) = default;

		iterator(iterator&& other) noexcept = default;

		iterator& operator=(const iterator& other) = default;

		iterator& operator=(iterator&& other) noexcept = default;

		iterator& operator++()
		{
			++it_;
			return *this;
		}

		iterator operator++(int)
		{
			auto it = *this;
			++*this;
			return it;
		}

		iterator& operator--()
		{
			--it_;
			return *this;
		}

		iterator operator--(int)
		{
			auto it = *this;
			--*this;
			return it;
		}

		iterator& operator+=(difference_type delta)
		{
			it_ += delta;
			return *this;
		}

		iterator& operator-=(difference_type delta)
		{
			it_ -= delta;
			return *this;
		}

		iterator operator+(difference_type delta) const
		{
			auto it = *this;
			return it += delta;
		}

		iterator operator-(difference_type delta) const
		{
			auto it = *this;
			return it -= delta;
		}

		difference_type operator-(iterator const& other) const
		{
			return it_ - other.it_;
		}

		bool operator<(iterator const& other) const noexcept
		{
			return this->it_ < other.it_;
		}

		bool operator>(iterator const& other) const noexcept
		{
			return this->it_ > other.it_;
		}

		bool operator==(iterator const& other) const noexcept
		{
			return this->it_ == other.it_;
		}

		bool operator!=(iterator const& other) const noexcept
		{
			return !(*this == other);
		}

		bool operator<=(iterator const& other) const noexcept
		{
			return (this->it_ < other.it_) || (*this == other);
		}

		bool operator>=(iterator const& other) const noexcept
		{
			return (this->it_ > other.it_) || (*this == other);
		}

		reference operator*() const noexcept
		{
			return *it_.value();
		}

		pointer operator->() const noexcept
		{
			return it_.value().get();
		}

		key_type const& key() const
		{
			return *it_.key();
		}

		value_type const& value() const
		{
			return *it_.value();
		}
	};

	class reverse_iterator : public std::reverse_iterator<iterator>
	{
		using base_t = std::reverse_iterator<iterator>;

	public:
		using iterator_category = typename iterator::iterator_category;
		using key_type = typename iterator::key_type;
		using value_type = typename iterator::value_type;
		using difference_type = typename iterator::difference_type;
		using reference = typename iterator::reference;
		using pointer = typename iterator::pointer;

		reverse_iterator(const reverse_iterator& other) = default;

		reverse_iterator& operator=(const reverse_iterator& other) = default;

		explicit reverse_iterator(const iterator& other) : base_t(other){};

		reverse_iterator& operator=(const iterator& other)
		{
			static_cast<base_t>(*this) = other;
		};

		key_type const& key() const
		{
			auto it = base_t::current;
			return (--(it)).key();
		}

		value_type const& value() const
		{
			auto it = base_t::current;
			return (--it).value();
		}
	};

	iterator begin() const
	{
		return iterator(map.begin());
	}

	iterator end() const
	{
		return iterator(map.end());
	}

	reverse_iterator rbegin() const
	{
		return reverse_iterator(end());
	}

	reverse_iterator rend() const
	{
		return reverse_iterator(begin());
	}

	// endregion

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override
	{
		change.advise(lifetime, handler);
		/*for (auto const &[key, value] : map) {*/
		for (auto const& it : map)
		{
			auto& key = it.first;
			auto& value = it.second;
			handler(Event(typename Event::Add(&(*key), &(*value))));
			;
		}
	}

	const V* get(K const& key) const override
	{
		auto it = map.find(key);
		if (it == map.end())
		{
			return nullptr;
		}
		return &(*it->second);
	}

	const V* set(WK key, WV value) const override
	{
		if (map.count(key) == 0)
		{
			/*auto[it, success] = map.emplace(std::make_unique<K>(std::move(key)), std::make_unique<V>(std::move(value)));*/
			auto node = map.emplace(std::move(key), std::move(value));
			auto& it = node.first;
			auto const& key_ptr = it->first;
			auto const& value_ptr = it->second;
			change.fire(typename Event::Add(&(*key_ptr), &(*value_ptr)));
			return nullptr;
		}
		else
		{
			auto it = map.find(key);
			auto const& key_ptr = it->first;
			auto const& value_ptr = it->second;

			if (*value_ptr != wrapper::get<V>(value))
			{	 // TO-DO more effective
				Wrapper<V> old_value = std::move(map.at(key));

				map.at(key_ptr) = Wrapper<V>(std::move(value));
				change.fire(typename Event::Update(&(*key_ptr), &(*old_value), &(*value_ptr)));
			}
			return &*(value_ptr);
		}
	}

	OV remove(K const& key) const override
	{
		if (map.count(key) > 0)
		{
			Wrapper<V> old_value = std::move(map.at(key));
			change.fire(typename Event::Remove(&key, &(*old_value)));
			map.erase(key);
			return wrapper::unwrap<V>(std::move(old_value));
		}
		return nullopt;
	}

	void clear() const override
	{
		std::vector<Event> changes;
		/*for (auto const &[key, value] : map) {*/
		for (auto const& it : map)
		{
			changes.push_back(typename Event::Remove(&(*it.first), &(*it.second)));
		}
		for (auto const& it : changes)
		{
			change.fire(it);
		}
		map.clear();
	}

	size_t size() const override
	{
		return map.size();
	}

	bool empty() const override
	{
		return map.empty();
	}
};
}	 // namespace rd

static_assert(std::is_move_constructible<rd::ViewableMap<int, int>>::value, "Is move constructible from ViewableMap<int, int>");

#endif	  // RD_CPP_CORE_VIEWABLE_MAP_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/ViewableSet.h`:

```h
#ifndef RD_CPP_CORE_VIEWABLESET_H
#define RD_CPP_CORE_VIEWABLESET_H

#include "base/IViewableSet.h"
#include "reactive/base/SignalX.h"

#include <std/allocator.h>
#include <util/core_util.h>

namespace rd
{
/**
 * \brief complete class which has @code IViewableSet<T>'s properties
 * \tparam T
 */
template <typename T, typename A = allocator<T>>
class ViewableSet : public IViewableSet<T, A>
{
public:
	using Event = typename IViewableSet<T>::Event;

	using IViewableSet<T, A>::advise;

private:
	using WT = typename IViewableSet<T, A>::WT;
	using WA = typename std::allocator_traits<A>::template rebind_alloc<Wrapper<T>>;

	Signal<Event> change;
	using data_t = ordered_set<Wrapper<T>, wrapper::TransparentHash<T>, wrapper::TransparentKeyEqual<T>, WA>;
	mutable data_t set;

public:
	// region ctor/dtor

	ViewableSet() = default;

	ViewableSet(ViewableSet&&) = default;

	ViewableSet& operator=(ViewableSet&&) = default;

	virtual ~ViewableSet() = default;
	// endregion

	// region iterators
public:
	class iterator
	{
		friend class ViewableSet<T>;

		typename data_t::iterator it_;

		explicit iterator(const typename data_t::iterator& it) : it_(it)
		{
		}

	public:
		using iterator_category = std::random_access_iterator_tag;
		using value_type = T;
		using difference_type = std::ptrdiff_t;
		using pointer = T const*;
		using reference = T const&;

		iterator(const iterator& other) = default;

		iterator(iterator&& other) noexcept = default;

		iterator& operator=(const iterator& other) = default;

		iterator& operator=(iterator&& other) noexcept = default;

		iterator& operator++()
		{
			++it_;
			return *this;
		}

		iterator operator++(int)
		{
			auto it = *this;
			++*this;
			return it;
		}

		iterator& operator--()
		{
			--it_;
			return *this;
		}

		iterator operator--(int)
		{
			auto it = *this;
			--*this;
			return it;
		}

		iterator& operator+=(difference_type delta)
		{
			it_ += delta;
			return *this;
		}

		iterator& operator-=(difference_type delta)
		{
			it_ -= delta;
			return *this;
		}

		iterator operator+(difference_type delta) const
		{
			auto it = *this;
			return it += delta;
		}

		iterator operator-(difference_type delta) const
		{
			auto it = *this;
			return it -= delta;
		}

		difference_type operator-(iterator const& other) const
		{
			return it_ - other.it_;
		}

		bool operator<(iterator const& other) const noexcept
		{
			return this->it_ < other.it_;
		}

		bool operator>(iterator const& other) const noexcept
		{
			return this->it_ > other.it_;
		}

		bool operator==(iterator const& other) const noexcept
		{
			return this->it_ == other.it_;
		}

		bool operator!=(iterator const& other) const noexcept
		{
			return !(*this == other);
		}

		bool operator<=(iterator const& other) const noexcept
		{
			return (this->it_ < other.it_) || (*this == other);
		}

		bool operator>=(iterator const& other) const noexcept
		{
			return (this->it_ > other.it_) || (*this == other);
		}

		reference operator*() const noexcept
		{
			return **it_;
		}

		pointer operator->() const noexcept
		{
			return (*it_).get();
		}
	};

	using reverse_iterator = std::reverse_iterator<iterator>;

	iterator begin() const
	{
		return iterator(set.begin());
	}

	iterator end() const
	{
		return iterator(set.end());
	}

	reverse_iterator rbegin() const
	{
		return reverse_iterator(end());
	}

	reverse_iterator rend() const
	{
		return reverse_iterator(begin());
	}

	// endregion

	bool add(WT element) const override
	{
		/*auto const &[it, success] = set.emplace(std::make_unique<T>(std::move(element)));*/
		auto const& it = set.emplace(std::move(element));
		if (!it.second)
		{
			return false;
		}
		change.fire(Event(AddRemove::ADD, &(wrapper::get<T>(*it.first))));
		return true;
	}

	bool addAll(std::vector<WT> elements) const override
	{
		for (auto&& element : elements)
		{
			ViewableSet::add(std::move(element));
		}
		return true;
	}

	void clear() const override
	{
		std::vector<Event> changes;
		for (auto const& element : set)
		{
			changes.push_back(Event(AddRemove::REMOVE, &(*element)));
		}
		for (auto const& e : changes)
		{
			change.fire(e);
		}
		set.clear();
	}

	bool remove(T const& element) const override
	{
		if (!ViewableSet::contains(element))
		{
			return false;
		}
		auto it = set.find(element);
		change.fire(Event(AddRemove::REMOVE, &(wrapper::get<T>(*it))));
		set.erase(it);
		return true;
	}

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override
	{
		for (auto const& x : set)
		{
			handler(Event(AddRemove::ADD, &(*x)));
		}
		change.advise(lifetime, handler);
	}

	size_t size() const override
	{
		return set.size();
	}

	bool contains(T const& element) const override
	{
		return set.count(element) > 0;
	}

	bool empty() const override
	{
		return set.empty();
	}

	template <typename... Args>
	bool emplace_add(Args&&... args) const
	{
		return add(WT{std::forward<Args>(args)...});
	}
};
}	 // namespace rd

static_assert(std::is_move_constructible<rd::ViewableSet<int>>::value, "Is move constructible from ViewableSet<int>");

#endif	  // RD_CPP_CORE_VIEWABLESET_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/IProperty.h`:

```h
#ifndef RD_CPP_IPROPERTY_H
#define RD_CPP_IPROPERTY_H

#include "SignalX.h"
#include "IPropertyBase.h"

#include <lifetime/Lifetime.h>
#include <types/wrapper.h>

#include <functional>

namespace rd
{
/**
 * \brief A mutable property.
 * \tparam T type of stored value (may be abstract)
 */
template <typename T>
class IProperty : public IPropertyBase<T>
{
protected:
	using WT = typename IPropertyBase<T>::WT;

public:
	// region ctor/dtor

	IProperty() = default;

	IProperty(IProperty&& other) = default;

	IProperty& operator=(IProperty&& other) = default;

	explicit IProperty(T const& value) : IPropertyBase<T>(value)
	{
	}

	template <typename F>
	explicit IProperty(F&& value) : IPropertyBase<T>(std::forward<F>(value))
	{
	}

	virtual ~IProperty() = default;
	// endregion

	virtual T const& get() const = 0;

private:
	void advise0(Lifetime lifetime, std::function<void(T const&)> handler, Signal<T> const& signal) const
	{
		if (lifetime->is_terminated())
		{
			return;
		}
		signal.advise(lifetime, handler);
		if (this->has_value())
		{
			handler(this->get());
		}
	}

	void advise_before(Lifetime lifetime, std::function<void(T const&)> handler) const override
	{
		advise0(lifetime, handler, this->before_change);
	}

public:
	void advise(Lifetime lifetime, std::function<void(T const&)> handler) const override
	{
		advise0(lifetime, std::move(handler), this->change);
	}

	/**
	 * \brief set value of type T or derived type to it.
	 */
	virtual void set(value_or_wrapper<T>) const = 0;

	/**
	 * \brief construct value of type T and delegate call to set
	 */
	template <typename... Args>
	void emplace(Args&&... args) const
	{
		set(value_or_wrapper<T>{std::forward<Args>(args)...});
	}

	void set_if_empty(WT new_value) const
	{
		if (!this->has_value())
		{
			set(std::move(new_value));
		}
	}
};
}	 // namespace rd

#endif	  // RD_CPP_IPROPERTY_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/IPropertyBase.h`:

```h
#ifndef RD_CPP_IPROPERTYBASE_H
#define RD_CPP_IPROPERTYBASE_H

#include "interfaces.h"
#include "SignalX.h"

#include <types/wrapper.h>
#include <lifetime/SequentialLifetimes.h>

#include "thirdparty.hpp"

namespace rd
{
template <typename T>
class IPropertyBase : public ISource<T>, public IViewable<T>
{
protected:
	mutable property_storage<T> value;

	Signal<T> change, before_change;

	using WT = value_or_wrapper<T>;

public:
	bool has_value() const
	{
		return (bool) (value);
	}

	// region ctor/dtor

	IPropertyBase() = default;

	IPropertyBase(IPropertyBase&& other) = default;

	IPropertyBase& operator=(IPropertyBase&& other) = default;

	template <typename F>
	explicit IPropertyBase(F&& value) : value(std::forward<F>(value))
	{
	}

	virtual ~IPropertyBase() = default;
	// endregion

	virtual void advise_before(Lifetime lifetime, std::function<void(T const&)> handler) const = 0;

	void view(Lifetime lifetime, std::function<void(Lifetime, T const&)> handler) const override
	{
		if (lifetime->is_terminated())
			return;

		Lifetime lf = lifetime.create_nested();
		std::shared_ptr<SequentialLifetimes> seq = std::make_shared<SequentialLifetimes>(lf);

		this->advise_before(lf, [lf, seq](T const& /*v*/) {
			if (!lf->is_terminated())
			{
				seq->terminate_current();
			}
		});

		this->advise(lf, [lf, seq, handler](T const& v) {
			if (!lf->is_terminated())
			{
				handler(seq->next(), v);
			}
		});
	}
};
}	 // namespace rd

#endif	  // RD_CPP_IPROPERTYBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/IViewableList.h`:

```h
#ifndef RD_CPP_IVIEWABLELIST_H
#define RD_CPP_IVIEWABLELIST_H

#include "interfaces.h"
#include "viewable_collections.h"

#include <lifetime/LifetimeDefinition.h>
#include <util/overloaded.h>
#include <types/wrapper.h>

#include <std/unordered_map.h>

#include <vector>
#include <utility>
#include <algorithm>

#include "thirdparty.hpp"

namespace rd
{
namespace detail
{
template <typename T>
class ListEvent
{
public:
	class Add
	{
	public:
		int32_t index;
		T const* new_value;

		Add(int32_t index, T const* new_value) : index(index), new_value(new_value)
		{
		}
	};

	class Update
	{
	public:
		int32_t index;
		T const* old_value;
		T const* new_value;

		Update(int32_t index, T const* old_value, T const* new_value) : index(index), old_value(old_value), new_value(new_value)
		{
		}
	};

	class Remove
	{
	public:
		int32_t index;
		T const* old_value;

		Remove(int32_t index, T const* old_value) : index(index), old_value(old_value)
		{
		}
	};

	variant<Add, Update, Remove> v;

	ListEvent(Add x) : v(x)
	{
	}

	ListEvent(Update x) : v(x)
	{
	}

	ListEvent(Remove x) : v(x)
	{
	}

	int32_t get_index() const
	{
		return visit(util::make_visitor([](Add const& e) { return e.index; }, [](Update const& e) { return e.index; },
						 [](Remove const& e) { return e.index; }),
			v);
	}

	T const* get_new_value() const
	{
		return visit(util::make_visitor([](Add const& e) { return e.new_value; }, [](Update const& e) { return e.new_value; },
						 [](Remove const& /*e*/) { return static_cast<T const*>(nullptr); }),
			v);
	}

	friend std::string to_string(ListEvent const& e)
	{
		std::string res = visit(
			util::make_visitor(
				[](typename ListEvent::Add const& e) { return "Add " + std::to_string(e.index) + ":" + to_string(*e.new_value); },
				[](typename ListEvent::Update const& e) {
					return "Update " + std::to_string(e.index) + ":" +
						   //                       to_string(e.old_value) + ":" +
						   to_string(*e.new_value);
				},
				[](typename ListEvent::Remove const& e) { return "Remove " + std::to_string(e.index); }),
			e.v);
		return res;
	}
};
}	 // namespace detail
/**
 * \brief A list allowing its contents to be observed.
 * \tparam T type of stored values (may be abstract)
 */
template <typename T>
class IViewableList : public IViewable<std::pair<size_t, T const*>>, public ISource<detail::ListEvent<T>>
{
protected:
	using WT = value_or_wrapper<T>;

public:
	/**
	 * \brief Represents an addition, update or removal of an element in the list.
	 */
	using Event = typename detail::ListEvent<T>;

protected:
	mutable rd::unordered_map<Lifetime, std::vector<LifetimeDefinition>> lifetimes;

public:
	// region ctor/dtor

	IViewableList() = default;

	IViewableList(IViewableList&&) = default;

	IViewableList& operator=(IViewableList&&) = default;

	virtual ~IViewableList() = default;
	// endregion

	/**
	 * \brief Adds a subscription to additions and removals of list elements. When a list element is updated,
	 * the [handler] is called twice: to report the removal of the old element and the addition of the new one.
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called.
	 */
	void advise_add_remove(Lifetime lifetime, std::function<void(AddRemove, size_t, T const&)> handler) const
	{
		advise(lifetime, [handler](Event e) {
			visit(util::make_visitor([handler](typename Event::Add const& e) { handler(AddRemove::ADD, e.index, *e.new_value); },
					  [handler](typename Event::Update const& e) {
						  handler(AddRemove::REMOVE, e.index, *e.old_value);
						  handler(AddRemove::ADD, e.index, *e.new_value);
					  },
					  [handler](typename Event::Remove const& e) { handler(AddRemove::REMOVE, e.index, *e.old_value); }),
				e.v);
		});
	}

	/**
	 * \brief Adds a subscription to changes of the contents of the list.
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called.
	 */
	void view(Lifetime lifetime, std::function<void(Lifetime lifetime, std::pair<size_t, T const*> const&)> handler) const override
	{
		view(lifetime, [handler](Lifetime lt, size_t idx, T const& v) { handler(lt, std::make_pair(idx, &v)); });
	}

	/**
	 * \brief @see view	above
	 */
	void view(Lifetime lifetime, std::function<void(Lifetime, size_t, T const&)> handler) const
	{
		advise_add_remove(lifetime, [this, lifetime, handler](AddRemove kind, size_t idx, T const& value) {
			switch (kind)
			{
				case AddRemove::ADD:
				{
					LifetimeDefinition def(lifetime);
					std::vector<LifetimeDefinition>& v = lifetimes[lifetime];
					auto it = v.emplace(v.begin() + idx, std::move(def));
					handler(it->lifetime, idx, value);
					break;
				}
				case AddRemove::REMOVE:
				{
					LifetimeDefinition def = std::move(lifetimes.at(lifetime)[idx]);
					std::vector<LifetimeDefinition>& v = lifetimes.at(lifetime);
					v.erase(v.begin() + idx);
					def.terminate();
					break;
				}
			}
		});
	}

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override = 0;

	virtual bool add(WT element) const = 0;

	virtual bool add(size_t index, WT element) const = 0;

	virtual WT removeAt(size_t index) const = 0;

	virtual bool remove(T const& element) const = 0;

	virtual T const& get(size_t index) const = 0;

	virtual WT set(size_t index, WT element) const = 0;

	virtual bool addAll(size_t index, std::vector<WT> elements) const = 0;

	virtual bool addAll(std::vector<WT> elements) const = 0;

	virtual void clear() const = 0;

	virtual bool removeAll(std::vector<WT> elements) const = 0;

	virtual size_t size() const = 0;

	virtual bool empty() const = 0;

	template <typename... Args>
	bool emplace_add(Args&&... args) const
	{
		return add(WT{std::forward<Args>(args)...});
	}

	template <typename... Args>
	bool emplace_add(size_t index, Args&&... args) const
	{
		return add(index, WT{std::forward<Args>(args)...});
	}

	template <typename... Args>
	WT emplace_set(size_t index, Args&&... args) const
	{
		return set(index, WT{std::forward<Args>(args)...});
	}

	template <typename U>
	friend typename std::enable_if<(!std::is_abstract<U>::value), std::vector<U>>::type convert_to_list(
		IViewableList<U> const& list);

protected:
	virtual const std::vector<Wrapper<T>>& getList() const = 0;
};

template <typename T>
typename std::enable_if<(!std::is_abstract<T>::value), std::vector<T>>::type convert_to_list(IViewableList<T> const& list)
{
	std::vector<T> res(list.size());
	std::transform(list.getList().begin(), list.getList().end(), res.begin(), [](Wrapper<T> const& ptr) { return *ptr; });
	return res;
}
}	 // namespace rd

static_assert(
	std::is_move_constructible<rd::IViewableList<int>::Event>::value, "Is move constructible from IViewableList<int>::Event");

#endif	  // RD_CPP_IVIEWABLELIST_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/IViewableMap.h`:

```h
#ifndef RD_CPP_IVIEWABLEMAP_H
#define RD_CPP_IVIEWABLEMAP_H

#include "lifetime/LifetimeDefinition.h"
#include "util/overloaded.h"
#include "interfaces.h"
#include "viewable_collections.h"
#include "util/core_util.h"

#include "std/unordered_map.h"

#include "thirdparty.hpp"

namespace rd
{
namespace detail
{
template <typename K, typename V>
class MapEvent
{
public:
	class Add
	{
	public:
		K const* key;
		V const* new_value;

		Add(K const* key, V const* new_value) : key(key), new_value(new_value)
		{
		}
	};

	class Update
	{
	public:
		K const* key;
		V const* old_value;
		V const* new_value;

		Update(K const* key, V const* old_value, V const* new_value) : key(key), old_value(old_value), new_value(new_value)
		{
		}
	};

	class Remove
	{
	public:
		K const* key;
		V const* old_value;

		Remove(K const* key, V const* old_value) : key(key), old_value(old_value)
		{
		}
	};

	variant<Add, Update, Remove> v;

	MapEvent(Add x) : v(x)
	{
	}

	MapEvent(Update x) : v(x)
	{
	}

	MapEvent(Remove x) : v(x)
	{
	}

	K const* get_key() const
	{
		return visit(
			util::make_visitor([](typename MapEvent::Add const& e) { return e.key; },
				[](typename MapEvent::Update const& e) { return e.key; }, [](typename MapEvent::Remove const& e) { return e.key; }),
			v);
	}

	V const* get_old_value() const
	{
		return visit(util::make_visitor([](typename MapEvent::Add const& e) { return static_cast<V const*>(nullptr); },
						 [](typename MapEvent::Update const& e) { return e.old_value; },
						 [](typename MapEvent::Remove const& e) { e.old_value; }),
			v);
	}

	V const* get_new_value() const
	{
		return visit(util::make_visitor([](typename MapEvent::Add const& e) { return e.new_value; },
						 [](typename MapEvent::Update const& e) { return e.new_value; },
						 [](typename MapEvent::Remove const& /*e*/) { return static_cast<V const*>(nullptr); }),
			v);
	}

	friend std::string to_string(MapEvent const& e)
	{
		std::string res =
			visit(util::make_visitor([](typename MapEvent::Add const& e)
										 -> std::string { return "Add " + to_string(*e.key) + ":" + to_string(*e.new_value); },
					  [](typename MapEvent::Update const& e) -> std::string {
						  return "Update " + to_string(*e.key) + ":" +
								 //                       to_string(e.old_value) + ":" +
								 to_string(*e.new_value);
					  },
					  [](typename MapEvent::Remove const& e) -> std::string { return "Remove " + to_string(*e.key); }),
				e.v);
		return res;
	}
};
}	 // namespace detail

/**
 * \brief A set allowing its contents to be observed.
 * \tparam K type of stored keys (may be abstract)
 * \tparam V type of stored values (may be abstract)
 */
template <typename K, typename V>
class IViewableMap : public IViewable<std::pair<K const*, V const*>>, public ISource<detail::MapEvent<K, V>>
{
protected:
	using WK = value_or_wrapper<K>;
	using WV = value_or_wrapper<V>;
	using OV = opt_or_wrapper<V>;

	mutable rd::unordered_map<Lifetime,
		ordered_map<K const*, LifetimeDefinition, wrapper::TransparentHash<K>, wrapper::TransparentKeyEqual<K>>>
		lifetimes;

public:
	/**
	 * \brief Represents an addition, update or removal of an element in the map.
	 */
	using Event = typename detail::MapEvent<K, V>;

	// region ctor/dtor

	IViewableMap() = default;

	IViewableMap(IViewableMap&&) = default;

	IViewableMap& operator=(IViewableMap&&) = default;

	virtual ~IViewableMap() = default;
	// endregion

	void view(Lifetime lifetime, std::function<void(Lifetime lifetime, std::pair<K const*, V const*> const&)

									 >
									 handler) const override
	{
		advise_add_remove(lifetime, [this, lifetime, handler](AddRemove kind, K const& key, V const& value) {
			const std::pair<K const*, V const*> entry = std::make_pair(&key, &value);
			switch (kind)
			{
				case AddRemove::ADD:
				{
					if (lifetimes[lifetime].count(key) == 0)
					{
						/*auto const &[it, inserted] = lifetimes[lifetime].emplace(key, LifetimeDefinition(lifetime));*/
						auto const& pair = lifetimes[lifetime].emplace(&key, LifetimeDefinition(lifetime));
						auto& it = pair.first;
						auto& inserted = pair.second;
						RD_ASSERT_MSG(inserted, "lifetime definition already exists in viewable map by key:" + to_string(key));
						handler(it->second.lifetime, entry);
					}
					break;
				}
				case AddRemove::REMOVE:
				{
					RD_ASSERT_MSG(lifetimes.at(lifetime).count(key) > 0,
						"attempting to remove non-existing lifetime in viewable map by key:" + to_string(key));
					LifetimeDefinition def = std::move(lifetimes.at(lifetime).at(key));
					lifetimes.at(lifetime).erase(key);
					def.terminate();
					break;
				}
			}
		});
	}

	/**
	 * \brief Adds a subscription to additions and removals of map elements. When a map element is updated, the [handler]
	 * is called twice: to report the removal of the old element and the addition of the new one.
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called.
	 */
	void advise_add_remove(Lifetime lifetime, std::function<void(AddRemove, K const&, V const&)

												  >
												  handler) const
	{
		advise(lifetime, [handler](Event e) {
			visit(util::make_visitor([handler](typename Event::Add const& e) { handler(AddRemove::ADD, *e.key, *e.new_value); },
					  [handler](typename Event::Update const& e) {
						  handler(AddRemove::REMOVE, *e.key, *e.old_value);
						  handler(AddRemove::ADD, *e.key, *e.new_value);
					  },
					  [handler](typename Event::Remove const& e) { handler(AddRemove::REMOVE, *e.key, *e.old_value); }),
				e.v);
		});
	}

	/**
	 * \brief Adds a subscription to changes of the contents of the map, with the handler receiving keys and values
	 * as separate parameters.
	 *
	 * \details When [handler] is initially added, it is called receiving all keys and values currently in the map.
	 * Every time a key/value pair is added to the map, the [handler] is called receiving the new key and value.
	 * The [Lifetime] instance passed to the handler expires when the key/value pair is removed from the map.
	 *
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called.
	 */
	void view(Lifetime lifetime, std::function<void(Lifetime, K const&, V const&)

									 >
									 handler) const
	{
		view(lifetime,
			[handler](Lifetime lf, const std::pair<K const*, V const*> entry) { handler(lf, *entry.first, *entry.second); });
	}

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override = 0;

	virtual const V* get(K const&) const = 0;

	virtual const V* set(WK, WV) const = 0;

	virtual OV remove(K const&) const = 0;

	virtual void clear() const = 0;

	virtual size_t size() const = 0;

	virtual bool empty() const = 0;

	template <typename... Args>
	const V* emplace_set(WK wk, Args&&... args) const
	{
		return set(std::move(wk), WV{std::forward<Args>(args)...});
	}
};
}	 // namespace rd

static_assert(std::is_move_constructible<rd::IViewableMap<int, int>::Event>::value,
	"Is move constructible from IViewableMap<int, int>::Event");

#endif	  // RD_CPP_IVIEWABLEMAP_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/IViewableSet.h`:

```h
#ifndef RD_CPP_IVIEWABLESET_H
#define RD_CPP_IVIEWABLESET_H

#include "interfaces.h"
#include "viewable_collections.h"

#include <lifetime/LifetimeDefinition.h>
#include <util/core_util.h>

#include <std/unordered_map.h>

#include <thirdparty.hpp>

namespace rd
{
namespace detail
{
template <typename T>
class SetEvent
{
public:
	SetEvent(AddRemove kind, T const* value) : kind(kind), value(value)
	{
	}

	AddRemove kind;
	T const* value;

	friend std::string to_string(SetEvent const& e)
	{
		return to_string(e.kind) + ":" + to_string(*e.value);
	}
};
}	 // namespace detail

/**
 * \brief A set allowing its contents to be observed.
 * \tparam T type of stored values (may be abstract)
 */
template <typename T, typename A = allocator<T>>
class IViewableSet : public IViewable<T>, public ISource<detail::SetEvent<T>>
{
protected:
	using WT = value_or_wrapper<T>;
	mutable rd::unordered_map<Lifetime,
		ordered_map<T const*, LifetimeDefinition, wrapper::TransparentHash<T>, wrapper::TransparentKeyEqual<T>>>
		lifetimes;

public:
	// region ctor/dtor

	IViewableSet() = default;

	IViewableSet(IViewableSet&&) = default;

	IViewableSet& operator=(IViewableSet&&) = default;

	virtual ~IViewableSet() = default;
	// endregion

	/**
	 * \brief Represents an addition or removal of an element in the set.
	 */
	using Event = typename detail::SetEvent<T>;

	/**
	 * \brief Adds a subscription for additions and removals of set elements. When the subscription is initially
	 * added, [handler] is called with [AddRemove::Add] events for all elements currently in the set.
	 *
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called.
	 */
	void advise(Lifetime lifetime, std::function<void(AddRemove, T const&)> handler) const
	{
		this->advise(lifetime, [handler](Event e) { handler(e.kind, *e.value); });
	}

	/**
	 * \brief Adds a subscription to changes of the contents of the set.
	 *
	 * \details When [handler] is initially added, it is called receiving all elements currently in the set.
	 * Every time an object is added to the set, the [handler] is called receiving the new element.
	 * The [Lifetime] instance passed to the handler expires when the element is removed from the set.
	 *
	 * \param lifetime
	 * \param handler
	 */
	void view(Lifetime lifetime, std::function<void(Lifetime, T const&)> handler) const override
	{
		advise(lifetime, [this, lifetime, handler](AddRemove kind, T const& key) {
			switch (kind)
			{
				case AddRemove::ADD:
				{
					/*auto const &[it, inserted] = lifetimes[lifetime].emplace(key, LifetimeDefinition(lifetime));*/
					auto const& it = lifetimes[lifetime].emplace(&key, lifetime);
					RD_ASSERT_MSG(it.second, "lifetime definition already exists in viewable set by key:" + to_string(key));
					handler(it.first->second.lifetime, key);
					break;
				}
				case AddRemove::REMOVE:
				{
					RD_ASSERT_MSG(lifetimes.at(lifetime).count(key) > 0,
						"attempting to remove non-existing lifetime in viewable set by key:" + to_string(key));
					LifetimeDefinition def = std::move(lifetimes.at(lifetime).at(key));
					lifetimes.at(lifetime).erase(key);
					def.terminate();
					break;
				}
			}
		});
	}

	/**
	 * \brief Adds a subscription for additions and removals of set elements. When the subscription is initially
	 * added, [handler] is called with [AddRemove.Add] events for all elements currently in the set.
	 *
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called.
	 */
	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override = 0;

	virtual bool add(WT) const = 0;

	virtual bool addAll(std::vector<WT> elements) const = 0;

	virtual void clear() const = 0;

	virtual bool remove(T const&) const = 0;

	virtual size_t size() const = 0;

	virtual bool contains(T const&) const = 0;

	virtual bool empty() const = 0;

	template <typename... Args>
	bool emplace_add(Args&&... args) const
	{
		return add(WT{std::forward<Args>(args)...});
	}
};
}	 // namespace rd

static_assert(
	std::is_move_constructible<rd::IViewableSet<int>::Event>::value, "Is move constructible from IViewableSet<int>::Event");

#endif	  // RD_CPP_IVIEWABLESET_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalCookie.cpp`:

```cpp
#include "SignalCookie.h"

#include <atomic>

namespace
{
std::atomic<int32_t> cookie;
}

void rd_signal_cookie_inc()
{
	++cookie;
}

void rd_signal_cookie_dec()
{
	--cookie;
}

int32_t rd_signal_cookie_get()
{
	return cookie;
}

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalCookie.h`:

```h
#ifndef RD_CPP_SIGNALCOOKIE_H
#define RD_CPP_SIGNALCOOKIE_H

#include <cstdint>
#include <rd_core_export.h>

extern "C" void RD_CORE_API rd_signal_cookie_inc();
extern "C" void RD_CORE_API rd_signal_cookie_dec();
extern "C" int32_t RD_CORE_API rd_signal_cookie_get();

#endif	  // RD_CPP_SIGNALCOOKIE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/SignalX.h`:

```h
#ifndef RD_CPP_CORE_SIGNAL_H
#define RD_CPP_CORE_SIGNAL_H

#include "interfaces.h"
#include "SignalCookie.h"

#include <lifetime/Lifetime.h>
#include <util/core_util.h>

#include <utility>
#include <functional>
#include <atomic>

namespace rd
{
/**
 * \brief complete class which has \a Signal<T> 's properties
 */
template <typename T>
class Signal final : public ISignal<T>
{
private:
	using WT = typename ISignal<T>::WT;

	class Event
	{
	private:
		std::function<void(T const&)> action;
		Lifetime lifetime;

	public:
		// region ctor/dtor
		Event() = delete;

		template <typename F>
		Event(F&& action, Lifetime lifetime) : action(std::forward<F>(action)), lifetime(lifetime)
		{
		}

		Event(Event&&) = default;
		// endregion

		bool is_alive() const
		{
			return !lifetime->is_terminated();
		}

		void execute_if_alive(T const& value) const
		{
			if (is_alive())
			{
				action(value);
			}
		}
	};

	using counter_t = int32_t;
	using listeners_t = std::map<counter_t, Event>;

	mutable counter_t advise_id = 0;
	mutable listeners_t listeners, priority_listeners;

	static void cleanup(listeners_t& queue)
	{
		util::erase_if(queue, [](Event const& e) -> bool { return !e.is_alive(); });
	}

	void fire_impl(T const& value, listeners_t& queue) const
	{
		for (auto const& p : queue)
		{
			auto const& event = p.second;
			event.execute_if_alive(value);
		}
		cleanup(queue);
	}

	template <typename F>
	void advise0(const Lifetime& lifetime, F&& handler, listeners_t& queue) const
	{
		if (lifetime->is_terminated())
			return;
		counter_t id = advise_id /*.load()*/;
		queue.emplace(id, Event(std::forward<F>(handler), lifetime));
		++advise_id;
	}

public:
	// region ctor/dtor

	Signal() = default;

	Signal(Signal const& other) = delete;

	Signal& operator=(Signal const& other) = delete;

	Signal(Signal&&) = default;

	Signal& operator=(Signal&&) = default;

	virtual ~Signal() = default;

	// endregion

	using ISignal<T>::fire;

	void fire(T const& value) const override
	{
		fire_impl(value, priority_listeners);
		fire_impl(value, listeners);
	}

	using ISignal<T>::advise;

	void advise(Lifetime lifetime, std::function<void(T const&)> handler) const override
	{
		advise0(lifetime, std::move(handler), isPriorityAdvise() ? priority_listeners : listeners);
	}

	static bool isPriorityAdvise()
	{
		return rd_signal_cookie_get() > 0;
	}
};

template <typename F>
void priorityAdviseSection(F&& block)
{
	rd_signal_cookie_inc();
	block();
	rd_signal_cookie_dec();
}
}	 // namespace rd

static_assert(std::is_move_constructible<rd::Signal<int>>::value, "Is not move constructible from Signal<int>");
static_assert(std::is_move_constructible<rd::Signal<rd::Void>>::value, "Is not move constructible from Signal<Void>");

#endif	  // RD_CPP_CORE_SIGNAL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/interfaces.h`:

```h
#ifndef RD_CPP_CORE_INTERFACES_H
#define RD_CPP_CORE_INTERFACES_H

#include <lifetime/Lifetime.h>
#include <types/wrapper.h>
#include <util/core_traits.h>

#include <functional>
#include <type_traits>

namespace rd
{
/**
 * \brief An object that allows to subscribe to events.
 * \tparam T type of events
 */
template <typename T>
class ISource
{
public:
	virtual ~ISource() = default;

	/**
	 * \brief Adds an event subscription.
	 * \param lifetime lifetime of subscription.
	 * \param handler to be called, every time an event occurs.
	 */
	virtual void advise(Lifetime lifetime, std::function<void(T const&)> handler) const = 0;

	/**
	 * \brief @code advise with Eternal lifetime
	 */
	template <typename F>
	void advise_eternal(F&& handler) const
	{
		advise(Lifetime::Eternal(), std::forward<F>(handler));
	}

	/**
	 * \brief @code Void specialisation of @code advise method, at @tparam T=Void
	 */
	void advise(Lifetime lifetime, std::function<void()> handler) const
	{
		advise(lifetime, [handler = std::move(handler)](Void) { handler(); });
	}
};

/**
 * \brief An object that allows to subscribe to changes of its contents.
 * \tparam T type of content
 */
template <typename T>
class IViewable
{
public:
	virtual ~IViewable() = default;

	virtual void view(Lifetime lifetime, std::function<void(Lifetime, T const&)

											 >
											 handler) const = 0;
};

/**
 * \brief An object which has a collection of event listeners and can broadcast an event to the listeners.
 * \tparam T type of events
 */
template <typename T>
class ISignal : public ISource<T>
{
protected:
	using WT = value_or_wrapper<T>;

public:
	virtual ~ISignal() = default;

	virtual void fire(T const& value) const = 0;

	/**
	 * \brief @code fire specialisation at T=Void
	 */
	template <typename U = T>
	typename std::enable_if_t<util::is_void<U>> fire() const
	{
		fire(Void{});
	}
};
}	 // namespace rd

#endif	  // RD_CPP_CORE_INTERFACES_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/reactive/base/viewable_collections.h`:

```h
#ifndef RD_CPP_VIEWABLE_COLLECTIONS_H
#define RD_CPP_VIEWABLE_COLLECTIONS_H

#include <string>

namespace rd
{
enum class AddRemove
{
	ADD,
	REMOVE
};

inline std::string to_string(AddRemove kind)
{
	switch (kind)
	{
		case AddRemove::ADD:
			return "Add";
		case AddRemove::REMOVE:
			return "Remove";
		default:
			return "";
	}
}

enum class Op
{
	ADD,
	UPDATE,
	REMOVE,
	ACK
};

inline std::string to_string(Op op)
{
	switch (op)
	{
		case Op::ADD:
			return "Add";
		case Op::UPDATE:
			return "Update";
		case Op::REMOVE:
			return "Remove";
		case Op::ACK:
			return "Ack";
		default:
			return "";
	}
}
}	 // namespace rd

#endif	  // RD_CPP_VIEWABLE_COLLECTIONS_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/allocator.h`:

```h
#ifndef RD_CPP_ALLOCATOR_H
#define RD_CPP_ALLOCATOR_H

#include <memory>

namespace rd
{
template <typename T>
using allocator = std::allocator<T>;
}

#endif	  // RD_CPP_ALLOCATOR_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/hash.h`:

```h
#ifndef RD_CPP_HASH_H
#define RD_CPP_HASH_H

#include <cstddef>
#include <functional>

namespace rd
{
template <typename T>
struct hash
{
	size_t operator()(const T& value) const noexcept
	{
		return std::hash<T>()(value);
	}
};
}	 // namespace rd

#endif	  // RD_CPP_HASH_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/list.h`:

```h
#ifndef RD_CPP_LIST_H
#define RD_CPP_LIST_H

#include <vector>
#include <cstdint>

namespace rd
{
template <typename T>
int32_t size(T const& value) = delete;

// c++17 has std::size for std::vector
#if __cplusplus < 201703L

template <typename T, typename A>
int32_t size(std::vector<T, A> const& value)
{
	return static_cast<int32_t>(value.size());
}
#else	
template <typename T, typename A>
int32_t size(std::vector<T, A> const& value)
{
	return std::size(value);
}
#endif

template <typename T, typename A>
void resize(std::vector<T, A>& value, int32_t size)
{
	value.resize(size);
}
}	 // namespace rd

#endif	  // RD_CPP_LIST_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/to_string.h`:

```h
#ifndef RD_CPP_TO_STRING_H
#define RD_CPP_TO_STRING_H

#include <string>
#include <type_traits>
#include <thread>
#include <sstream>
#include <vector>
#include <atomic>
#include <future>
#include <locale>
#include <codecvt>

#include <thirdparty.hpp>

namespace rd
{
namespace detail
{
using std::to_string;

inline std::string to_string(std::string const& val)
{
	return val;
}

inline std::string to_string(const char* val)
{
	return val;
}

inline std::string to_string(std::wstring const& val)
{
	using convert_type = std::codecvt_utf8<wchar_t>;
	std::wstring_convert<convert_type> converter;
	return converter.to_bytes(val);
}

inline std::string to_string(std::thread::id const& id)
{
	std::ostringstream ss;
	ss << id;
	return ss.str();
}

inline std::string to_string(std::exception const& e)
{
	return std::string(e.what());
}

inline std::string to_string(std::future_status const& status)
{
	switch (status)
	{
		case std::future_status::ready:
			return "ready";
		case std::future_status::timeout:
			return "timeout";
		case std::future_status::deferred:
			return "deferred";
		default:
			return "unknown";
	}
}

template <typename Rep, typename Period>
inline std::string to_string(std::chrono::duration<Rep, Period> const& time)
{
	return std::to_string(std::chrono::duration_cast<std::chrono::milliseconds>(time).count()) + "ms";
}

template <typename T>
inline std::string to_string(T const* val)
{
	return val ? to_string(*val) : "nullptr";
}

template <typename T>
inline std::string to_string(std::atomic<T> const& value)
{
	return to_string(value.load());
}

template <typename T>
inline std::string to_string(optional<T> const& val)
{
	if (val.has_value())
	{
		return to_string(*val);
	}
	else
	{
		return "nullopt";
	}
}

template <typename F, typename S>
inline std::string to_string(const std::pair<F, S> p)
{
	return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

template <template <class, class> class C, typename T, typename A>
std::string to_string(C<T, A> const& v)
{
	std::string res = "[";
	for (const auto& item : v)
	{
		res += to_string(item);
		res += ",";
	}
	res += "]";
	return res;
}

template <class T>
std::string as_string(T const& t)
{
	return to_string(t);
}

using std::to_wstring;

inline std::wstring to_wstring(std::string const& s)
{
	// TO-DO: fix this wrong implementation
	return std::wstring(s.begin(), s.end());
}

template <class T>
std::wstring as_wstring(T const& t)
{
	return to_wstring(t);
}
}	 // namespace detail

template <typename T>
std::string to_string(T const& val)
{
	return detail::as_string(val);
}

template <typename T>
std::wstring to_wstring(T const& val)
{
	return detail::as_wstring(val);
}
}	 // namespace rd

#endif	  // RD_CPP_TO_STRING_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/unordered_map.h`:

```h
#ifndef RD_CPP_UNORDERED_MAP_H
#define RD_CPP_UNORDERED_MAP_H

#include "hash.h"

#include <unordered_map>

namespace rd
{
template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>,
	class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
using unordered_map = std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>;
}

#endif	  // RD_CPP_UNORDERED_MAP_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/std/unordered_set.h`:

```h
#ifndef RD_CPP_UNORDERED_SET_H
#define RD_CPP_UNORDERED_SET_H

#include "hash.h"

#include <unordered_set>

namespace rd
{
template <class _Value, class _Hash = hash<_Value>, class _Pred = std::equal_to<_Value>, class _Alloc = std::allocator<_Value> >
using unordered_set = std::unordered_set<_Value, _Hash, _Pred, _Alloc>;
}

#endif	  // RD_CPP_UNORDERED_SET_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/types/DateTime.cpp`:

```cpp
#include "DateTime.h"

#include <sstream>
#include <iomanip>

namespace rd
{
DateTime::DateTime(time_t seconds) : seconds(seconds)
{
}

bool operator<(const DateTime& lhs, const DateTime& rhs)
{
	return lhs.seconds < rhs.seconds;
}

bool operator>(const DateTime& lhs, const DateTime& rhs)
{
	return rhs < lhs;
}

bool operator<=(const DateTime& lhs, const DateTime& rhs)
{
	return !(rhs < lhs);
}

bool operator>=(const DateTime& lhs, const DateTime& rhs)
{
	return !(lhs < rhs);
}

std::string to_string(DateTime const& time)
{
	std::stringstream ss;
	ss << std::put_time(std::localtime(&time.seconds), "%F %T");
	return ss.str();
}

bool operator==(const DateTime& lhs, const DateTime& rhs)
{
	return lhs.seconds == rhs.seconds;
}

bool operator!=(const DateTime& lhs, const DateTime& rhs)
{
	return !(rhs == lhs);
}

size_t hash<rd::DateTime>::operator()(const rd::DateTime& value) const noexcept
{
	return rd::hash<decltype(value.seconds)>()(value.seconds);
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/types/DateTime.h`:

```h
#ifndef RD_CPP_DATETIME_H
#define RD_CPP_DATETIME_H

#include <std/hash.h>

#include <ctime>
#include <string>

#include <rd_core_export.h>

namespace rd
{
/**
 * \brief Wrapper around time_t to be synchronized with "Date" in Kt and "DateTime" in C#.
 */
class RD_CORE_API DateTime
{
public:
	std::time_t seconds;

	explicit DateTime(time_t seconds);

	friend bool RD_CORE_API operator<(const DateTime& lhs, const DateTime& rhs);

	friend bool RD_CORE_API operator>(const DateTime& lhs, const DateTime& rhs);

	friend bool RD_CORE_API operator<=(const DateTime& lhs, const DateTime& rhs);

	friend bool RD_CORE_API operator>=(const DateTime& lhs, const DateTime& rhs);

	friend bool RD_CORE_API operator==(const DateTime& lhs, const DateTime& rhs);

	friend bool RD_CORE_API operator!=(const DateTime& lhs, const DateTime& rhs);

	//"1970-01-01 03:01:38" for example
	friend std::string RD_CORE_API to_string(DateTime const& time);
};
}	 // namespace rd
namespace rd
{
template <>
struct RD_CORE_API hash<rd::DateTime>
{
	size_t operator()(const rd::DateTime& value) const noexcept;
};
}	 // namespace rd

#endif	  // RD_CPP_DATETIME_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/types/Void.h`:

```h
#ifndef RD_CPP_VOID_H
#define RD_CPP_VOID_H

#include <functional>
#include <string>

namespace rd
{
/**
 * \brief For using in idle events
 */
class Void
{
	friend inline bool operator==(const Void&, const Void&)
	{
		return true;
	}

	friend inline bool operator!=(const Void&, const Void&)
	{
		return false;
	}
};

inline std::string to_string(Void const&)
{
	return "void";
}
}	 // namespace rd

namespace std
{
template <>
struct hash<rd::Void>
{
	size_t operator()(const rd::Void&) const noexcept
	{
		return 0;
	}
};
}	 // namespace std

#endif	  // RD_CPP_VOID_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/types/wrapper.h`:

```h
#ifndef RD_CPP_WRAPPER_H
#define RD_CPP_WRAPPER_H

#include <util/core_traits.h>
#include <std/allocator.h>
#include <std/hash.h>
#include <std/to_string.h>

#include <thirdparty.hpp>

#include <type_traits>
#include <memory>
#include <utility>

namespace rd
{
template <typename T, typename A = std::allocator<T>>
class Wrapper;

template <typename T, typename R = void>
struct helper
{
	using value_or_wrapper_type = T;
	using opt_or_wrapper_type = optional<T>;
	using property_storage = optional<T>;
	using raw_type = T;
};

template <typename T>
struct helper<T, typename std::enable_if_t<util::in_heap_v<T>>>
{
	using value_or_wrapper_type = Wrapper<T>;
	using opt_or_wrapper_type = Wrapper<T>;
	using property_storage = Wrapper<T>;
	using raw_type = T;
};

/*template<typename T>
struct helper<optional<T>> {
	using value_or_wrapper_type = Wrapper<T>;
	using opt_or_wrapper_type = Wrapper<T>;
	using property_storage = optional<optional<T>>;
	using raw_type = T;
};*/

template <typename T>
struct helper<Wrapper<T>>
{
	using value_or_wrapper_type = Wrapper<T>;
	using opt_or_wrapper_type = Wrapper<T>;
	using property_storage = Wrapper<Wrapper<T>>;
	using raw_type = T;
};

template <typename T>
using value_or_wrapper = typename helper<T>::value_or_wrapper_type;

template <typename T>
using opt_or_wrapper = typename helper<T>::opt_or_wrapper_type;

template <typename T>
using property_storage = typename helper<T>::property_storage;

template <typename T>
using raw_type = typename helper<T>::raw_type;

template <typename>
struct is_wrapper : std::false_type
{
};

template <typename T>
struct is_wrapper<Wrapper<T>> : std::true_type
{
};

template <typename T>
constexpr bool is_wrapper_v = is_wrapper<T>::value;

/**
 * \brief wrapper over value of any type. It supports semantic of shared ownership due to shared_ptr as storage.
 * \tparam T type of value
 */
template <typename T, typename A>
class Wrapper final : public std::shared_ptr<T>
{
private:
	template <typename, typename>
	friend class Wrapper;

	using Base = std::shared_ptr<T>;

	A alloc;

public:
	using type = T;

	// region ctor/dtor

	Wrapper() = default;

	Wrapper(Wrapper const&) = default;

	Wrapper& operator=(Wrapper const&) = default;

	Wrapper(Wrapper&&) = default;

	Wrapper& operator=(Wrapper&&) = default;

	constexpr explicit Wrapper(std::nullptr_t) noexcept
	{
	}

	constexpr Wrapper(nullopt_t) noexcept
	{
	}

	template <typename R, typename = typename std::enable_if_t<util::is_base_of_v<T, R>>>
	Wrapper(Wrapper<R> const& other) : Base(std::static_pointer_cast<T>(static_cast<std::shared_ptr<R>>(other)))
	{
	}

	template <typename R, typename = typename std::enable_if_t<util::is_base_of_v<T, R>>>
	Wrapper(Wrapper<R>&& other) : Base(std::static_pointer_cast<T>(static_cast<std::shared_ptr<R>>(std::move(other))))
	{
	}

	template <typename F, typename G = typename util::not_string_literal<F&&>::type,
		typename = typename std::enable_if_t<
			/*util::negation<
				util::disjunction<
					std::is_null_pointer<std::decay_t<F>>,
					std::is_same<Wrapper<T>, std::decay_t<F>>,
					detail::is_optional<std::decay_t<F>>
				>
			>::value*/
			util::conjunction<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<G>>,
				util::negation<std::is_abstract<G>>>::value>>
	Wrapper(F&& value) : Base(std::allocate_shared<G>(alloc, std::forward<F>(value)))
	{
	}

	template <typename F>
	Wrapper(std::shared_ptr<F> const& ptr) noexcept : Base(std::static_pointer_cast<T>(ptr))
	{
	}

	template <typename F>
	Wrapper(std::shared_ptr<F>&& ptr) noexcept : Base(std::static_pointer_cast<T>(std::move(ptr)))
	{
	}

	template <typename U = T, typename R = typename std::enable_if_t<!std::is_abstract<std::decay_t<U>>::value>>
	Wrapper(optional<U>&& opt)
	{
		if (opt)
		{
			*this = std::allocate_shared<U>(alloc, *std::move(opt));
		}
	}

	template <typename R>
	static Wrapper<T> dynamic(Wrapper<R> const& w)
	{
		return Wrapper<T>(std::dynamic_pointer_cast<T>(w));
	}

	template <typename R>
	static Wrapper<T> dynamic(Wrapper<R>&& w)
	{
		return Wrapper<T>(std::dynamic_pointer_cast<T>(std::move(w)));
	}

	~Wrapper() = default;
	// endregion

	constexpr bool has_value() const
	{
		return operator bool();
	}

	constexpr T& operator*() &
	{
		return *static_cast<Base&>(*this);
	};

	constexpr T const& operator*() const&
	{
		return *static_cast<Base const&>(*this);
	};

	/*constexpr T &&operator*() &&{
		return *ptr.get();
	};*/

	T const* operator->() const
	{
		return Base::operator->();
	}

	T* operator->()
	{
		return Base::operator->();
	}

	explicit operator bool() const noexcept
	{
		return Base::operator bool();
	}

	friend bool operator==(const Wrapper& lhs, const Wrapper& rhs)
	{
		bool is_lhs = (bool) lhs;
		bool is_rhs = (bool) rhs;
		if (is_lhs != is_rhs)
		{
			return false;
		}
		if (!is_lhs && !is_rhs)
		{
			return true;
		}
		return *lhs.get() == *rhs.get();
	}

	friend bool operator!=(const Wrapper& lhs, const Wrapper& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(Wrapper const& value)
	{
		return value.has_value() ? to_string(*value) : "nullptr"s;
	}
};

namespace wrapper
{
template <typename T>
decltype(auto) get(T&& w)
{
	return std::forward<T>(w);
}

template <typename T>
decltype(auto) get(T const& w)
{
	return w;
}

template <typename T>
T& get(Wrapper<T>& w)
{
	return *w;
}

template <typename T>
T const& get(Wrapper<T> const& w)
{
	return *w;
}

template <typename T>
T&& get(Wrapper<T>&& w)
{
	return *std::move(std::move(w));
}

/*template<typename T>
Wrapper<T> make_wrapper(std::unique_ptr<T> &&value) {
	return Wrapper<T>(std::move(value));
}*/

template <typename T>
typename std::enable_if_t<!util::in_heap_v<T>, T> unwrap(Wrapper<T>&& ptr)
{
	return std::move(*ptr);
}

template <typename T>
typename std::enable_if_t<util::in_heap_v<T>, Wrapper<T>> unwrap(Wrapper<T>&& ptr)
{
	return Wrapper<T>(std::move(ptr));
}

template <typename T, typename... Args>
Wrapper<T> make_wrapper(Args&&... args)
{
	return Wrapper<T>(std::make_shared<T>(std::forward<Args>(args)...));
}

template <typename T, typename A, typename... Args>
Wrapper<T> allocate_wrapper(const A& alloc, Args&&... args)
{
	return Wrapper<T>(std::allocate_shared<T, A>(alloc, std::forward<Args>(args)...));
}
/*template<typename T>
constexpr Wrapper<T> null_wrapper = Wrapper<T>(nullptr);*/
}	 // namespace wrapper

template <typename T>
struct hash<rd::Wrapper<T>>
{
	size_t operator()(const rd::Wrapper<T>& value) const noexcept
	{
		return rd::hash<T>()(*value);
	}
};
}	 // namespace rd

static_assert(rd::is_wrapper<rd::Wrapper<std::wstring>>::value, "is wrapper doesn't work");

#endif	  // RD_CPP_WRAPPER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/core_traits.h`:

```h
#ifndef RD_CORE_CPP_TRAITS_H
#define RD_CORE_CPP_TRAITS_H

#include <types/Void.h>

#include <type_traits>
#include <string>

namespace rd
{
class IPolymorphicSerializable;

namespace util
{
// region non_std

template <typename T, typename U>
constexpr bool is_same_v = std::is_same<T, U>::value;

template <typename Base, typename Derived>
constexpr bool is_base_of_v = std::is_base_of<Base, Derived>::value;

template <bool B>
using bool_constant = std::integral_constant<bool, B>;

template <class B>
struct negation : bool_constant<!bool(B::value)>
{
};

template <class...>
struct disjunction : std::false_type
{
};
template <class B1>
struct disjunction<B1> : B1
{
};
template <class B1, class... Bn>
struct disjunction<B1, Bn...> : std::conditional_t<bool(B1::value), B1, disjunction<Bn...>>
{
};

template <class...>
struct conjunction : std::true_type
{
};
template <class B1>
struct conjunction<B1> : B1
{
};
template <class B1, class... Bn>
struct conjunction<B1, Bn...> : std::conditional_t<bool(B1::value), conjunction<Bn...>, B1>
{
};

template <class...>
using void_t = void;

template <typename F, typename... Args>
struct is_invocable
	: std::is_constructible<std::function<void(Args...)>, std::reference_wrapper<typename std::remove_reference<F>::type>>
{
};

template <typename R, typename F, typename... Args>
struct is_invocable_r
	: std::is_constructible<std::function<R(Args...)>, std::reference_wrapper<typename std::remove_reference<F>::type>>
{
};

template <class F, class... Ts>
constexpr bool is_invocable_v = is_invocable<F, Ts...>::value;

#ifdef __cpp_lib_is_invocable
template <class> struct result_of;

template <class F, class... TN>
struct result_of<F(TN...)>
{
	using type = std::invoke_result_t<F, TN...>;
};
#else
template<class... TN> using result_of = std::result_of<TN...>;
#endif
template<class... TN> using result_of_t = typename result_of<TN...>::type;

template <typename T>
constexpr bool is_enum_v = std::is_enum<T>::value;

// TO-DO: is is_pod actually required for memcpy-like serialization?
template <class T>
constexpr bool is_pod_v = std::is_trivial<T>::value && std::is_standard_layout<T>::value;
// endregion

template <typename T>
/*inline */ constexpr bool is_void = std::is_same<T, Void>::value;

// region in_heap

template <typename T>
//		using in_heap = disjunction<std::is_abstract<T>, std::is_same<T, std::wstring>>;
using in_heap = disjunction<std::is_base_of<IPolymorphicSerializable, T>, std::is_same<T, std::wstring>>;

template <typename T>
/*inline */ constexpr bool in_heap_v = in_heap<T>::value;

static_assert(in_heap_v<std::wstring>, "std::wstring should be placed in shared memory");
static_assert(!in_heap_v<int>, "int shouldn't be placed in shared memory");

// endregion

// region literal

template <typename T>
struct is_wstring_literal :
	/*std::is_same<
			T,
			std::add_lvalue_reference_t<const wchar_t[std::extent<std::remove_reference_t<T>>::value]>*/
	std::is_convertible<T, std::wstring>
{
};

template <typename T, bool = is_wstring_literal<T>::value>
struct not_string_literal
{
	using type = std::wstring;
};

template <>
struct not_string_literal<std::wstring, true>
{
	using type = std::wstring;
};

template <typename T>
struct not_string_literal<T, false>
{
	using type = std::decay_t<T>;
};

static_assert(is_wstring_literal<decltype(L" ")>::value, "is_wstring trait doesn't work");
static_assert(is_wstring_literal<decltype(L" ")&&>::value, "is_wstring trait doesn't work");
static_assert(is_wstring_literal<decltype(L" ")&>::value, "is_wstring trait doesn't work");
static_assert(is_wstring_literal<wchar_t const (&)[1]>::value, "is_wstring trait doesn't work");
static_assert(!is_wstring_literal<int>::value, "is_wstring trait doesn't work");
//		static_assert(is_wstring_literal<std::wstring>::value, "is_wstring trait doesn't work");

// endregion
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CORE_CPP_TRAITS_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/core_util.h`:

```h
#ifndef RD_CPP_CORE_CPP_UTIL_H
#define RD_CPP_CORE_CPP_UTIL_H

#include "erase_if.h"
#include "gen_util.h"
#include "overloaded.h"
#include "shared_function.h"

#include <std/hash.h>
#include <std/to_string.h>
#include <types/wrapper.h>

#include <thirdparty.hpp>
#include <spdlog/spdlog.h>

#include <memory>
#include <string>
#include <thread>
#include <atomic>
#include <iostream>
#include <sstream>
#include <cassert>

#define RD_ASSERT_MSG(expr, msg)    \
	if (!(expr))                    \
	{                               \
		spdlog::error("{}\n", msg); \
		assert(expr);               \
	}
#define RD_ASSERT_THROW_MSG(expr, msg) \
	if (!(expr))                       \
	{                                  \
		spdlog::error("{}\n", msg);    \
		throw std::runtime_error(msg); \
	}

namespace rd
{
namespace util
{
template <typename T0, typename... T>
constexpr std::vector<T0> arrayListOf(T0&& arg, T&&... args)
{
	return std::vector<T0>{std::forward<T0>(arg), std::forward<T>(args)...};
}
}	 // namespace util

namespace wrapper
{
template <typename T>
struct TransparentKeyEqual
{
	using is_transparent = void;

	bool operator()(T const& val_l, T const& val_r) const
	{
		return val_l == val_r;
	}

	bool operator()(Wrapper<T> const& ptr_l, Wrapper<T> const& ptr_r) const
	{
		return ptr_l == ptr_r;
	}

	bool operator()(T const* val_l, T const* val_r) const
	{
		return *val_l == *val_r;
	}

	bool operator()(T const& val_r, Wrapper<T> const& ptr_l) const
	{
		return *ptr_l == val_r;
	}

	bool operator()(T const& val_l, T const* ptr_r) const
	{
		return val_l == *ptr_r;
	}

	bool operator()(Wrapper<T> const& val_l, T const* ptr_r) const
	{
		return *val_l == *ptr_r;
	}
};

template <typename T>
struct TransparentHash
{
	using is_transparent = void;
	using transparent_key_equal = std::equal_to<>;

	size_t operator()(T const& val) const noexcept
	{
		return rd::hash<T>()(val);
	}

	size_t operator()(Wrapper<T> const& ptr) const noexcept
	{
		return rd::hash<Wrapper<T>>()(ptr);
	}

	size_t operator()(T const* val) const noexcept
	{
		return rd::hash<T>()(*val);
	}
};
}	 // namespace wrapper
}	 // namespace rd

#endif	  // RD_CPP_CORE_CPP_UTIL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/enum.h`:

```h
#ifndef RD_CPP_ENUM_H
#define RD_CPP_ENUM_H

#include <type_traits>

#define RD_DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE)                                                                     \
	extern "C++"                                                                                                    \
	{                                                                                                               \
		inline ENUMTYPE operator|(ENUMTYPE a, ENUMTYPE b)                                                           \
		{                                                                                                           \
			return ENUMTYPE(((std::underlying_type_t<ENUMTYPE>) a) | ((std::underlying_type_t<ENUMTYPE>) b));       \
		}                                                                                                           \
		inline ENUMTYPE& operator|=(ENUMTYPE& a, ENUMTYPE b)                                                        \
		{                                                                                                           \
			return (ENUMTYPE&) (((std::underlying_type_t<ENUMTYPE>&) a) |= ((std::underlying_type_t<ENUMTYPE>) b)); \
		}                                                                                                           \
		inline ENUMTYPE operator&(ENUMTYPE a, ENUMTYPE b)                                                           \
		{                                                                                                           \
			return ENUMTYPE(((std::underlying_type_t<ENUMTYPE>) a) & ((std::underlying_type_t<ENUMTYPE>) b));       \
		}                                                                                                           \
		inline ENUMTYPE& operator&=(ENUMTYPE& a, ENUMTYPE b)                                                        \
		{                                                                                                           \
			return (ENUMTYPE&) (((std::underlying_type_t<ENUMTYPE>&) a) &= ((std::underlying_type_t<ENUMTYPE>) b)); \
		}                                                                                                           \
		inline ENUMTYPE operator~(ENUMTYPE a)                                                                       \
		{                                                                                                           \
			return ENUMTYPE(~((std::underlying_type_t<ENUMTYPE>) a));                                               \
		}                                                                                                           \
		inline ENUMTYPE operator^(ENUMTYPE a, ENUMTYPE b)                                                           \
		{                                                                                                           \
			return ENUMTYPE(((std::underlying_type_t<ENUMTYPE>) a) ^ ((std::underlying_type_t<ENUMTYPE>) b));       \
		}                                                                                                           \
		inline ENUMTYPE& operator^=(ENUMTYPE& a, ENUMTYPE b)                                                        \
		{                                                                                                           \
			return (ENUMTYPE&) (((std::underlying_type_t<ENUMTYPE>&) a) ^= ((std::underlying_type_t<ENUMTYPE>) b)); \
		}                                                                                                           \
	}

#endif	  // RD_CPP_ENUM_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/erase_if.h`:

```h
#ifndef RD_CPP_ERASE_IF_H
#define RD_CPP_ERASE_IF_H

namespace rd
{
namespace util
{
template <typename ContainerT, class _Pr>
void erase_if(ContainerT& items, _Pr _Pred)
{
	for (auto it = items.begin(); it != items.end();)
	{
		if (_Pred(it->second))
			it = items.erase(it);
		else
			++it;
	}
}
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CPP_ERASE_IF_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/gen_util.h`:

```h
#ifndef RD_CPP_GEN_UTIL_H
#define RD_CPP_GEN_UTIL_H

#include <std/hash.h>
#include <std/allocator.h>

#include <cstdlib>

namespace rd
{

template <template <class, class> class C, typename T, typename A = allocator<T>>
size_t contentHashCode(C<T, A> const& list) noexcept
{
	size_t __r = 0;
	for (auto const& e : list)
	{
		__r = __r * 31 + hash<T>()(e);
	}
	return __r;
	// TO-DO faster for integrals
}

template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
size_t contentDeepHashCode(T const& value) noexcept
{
	return rd::hash<T>()(value);
}

template<class T>
using remove_all_t = std::remove_reference_t<std::remove_cv_t<T>>;

// optional and rd::Wrapper
template <class T, typename = std::enable_if_t<!std::is_integral<T>::value>>
typename std::enable_if_t<std::is_same<decltype(T{}.has_value()), bool>::value, size_t> contentDeepHashCode(T const& value) noexcept
{
	return rd::hash<remove_all_t<T>>()(value);
}

// containers
template <class T, typename = std::enable_if_t<!std::is_integral<T>::value>>
typename std::enable_if_t<std::is_integral<remove_all_t<decltype(*begin(T{}))>>::value, size_t> contentDeepHashCode(T const& value) noexcept
{
	return contentHashCode(value);
}

// containers of non-integral types
template <class T, typename = std::enable_if_t<!std::is_integral<T>::value>>
typename std::enable_if_t<!std::is_integral<remove_all_t<decltype(*begin(T{}))>>::value, size_t> contentDeepHashCode(T const& value) noexcept
{
	size_t result = 1;
	for (auto const& x : value)
	{
		result = 31 * result + contentDeepHashCode<remove_all_t<decltype(x)>>(x);
	}
	return result;
}

}	 // namespace rd

#endif	  // RD_CPP_GEN_UTIL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/overloaded.h`:

```h
#ifndef RD_CPP_OVERLOADED_H
#define RD_CPP_OVERLOADED_H

namespace rd
{
namespace util
{
template <typename... Ts>
struct overloaded;

template <typename T>
struct overloaded<T> : T
{
	overloaded(T t) : T(t)
	{
	}

	using T::operator();
};

template <typename T, class... Ts>
struct overloaded<T, Ts...> : T, overloaded<Ts...>
{
	overloaded(T t, Ts... rest) : T(t), overloaded<Ts...>(rest...)
	{
	}

	using T::operator();
	using overloaded<Ts...>::operator();
};

template <typename... Ts>
overloaded<Ts...> make_visitor(Ts... lambdas)
{
	return overloaded<Ts...>(lambdas...);
}
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CPP_OVERLOADED_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_core_cpp/src/main/util/shared_function.h`:

```h
#ifndef RD_CPP_SHARED_FUNCTION_H
#define RD_CPP_SHARED_FUNCTION_H

#include <memory>

namespace rd
{
namespace util
{
template <class F>
struct shared_function
{
	std::shared_ptr<F> f;

	shared_function() = delete;	   // = default works, but I don't use it
	shared_function(F&& f_) : f(std::make_shared<F>(std::move(f_)))
	{
	}

	shared_function(shared_function const&) = default;

	shared_function(shared_function&&) = default;

	shared_function& operator=(shared_function const&) = default;

	shared_function& operator=(shared_function&&) = default;

	template <class... As>
	auto operator()(As&&... as) const
	{
		return (*f)(std::forward<As>(as)...);
	}
};

template <class F>
shared_function<std::decay_t<F> > make_shared_function(F&& f)
{
	return {std::forward<F>(f)};
}
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CPP_SHARED_FUNCTION_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/rd_framework_export.h`:

```h

#ifndef RD_FRAMEWORK_API_H
#define RD_FRAMEWORK_API_H

#if defined(_WIN32)
# ifdef RD_FRAMEWORK_STATIC_DEFINE
#  define RD_FRAMEWORK_API
#  define RD_FRAMEWORK_NO_EXPORT
# else
#  ifndef RD_FRAMEWORK_API
#    ifdef rd_framework_cpp_EXPORTS
        /* We are building this library */
#      define RD_FRAMEWORK_API __declspec(dllexport)
#    else
        /* We are using this library */
#      define RD_FRAMEWORK_API __declspec(dllimport)
#    endif
#  endif

#  ifndef RD_FRAMEWORK_NO_EXPORT
#    define RD_FRAMEWORK_NO_EXPORT
#  endif
# endif

# ifndef RD_FRAMEWORK_DEPRECATED
#  define RD_FRAMEWORK_DEPRECATED __declspec(deprecated)
# endif

# ifndef RD_FRAMEWORK_DEPRECATED_EXPORT
#  define RD_FRAMEWORK_DEPRECATED_EXPORT RD_FRAMEWORK_API RD_FRAMEWORK_DEPRECATED
# endif

# ifndef RD_FRAMEWORK_DEPRECATED_NO_EXPORT
#  define RD_FRAMEWORK_DEPRECATED_NO_EXPORT RD_FRAMEWORK_NO_EXPORT RD_FRAMEWORK_DEPRECATED
# endif

# if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef RD_FRAMEWORK_NO_DEPRECATED
#    define RD_FRAMEWORK_NO_DEPRECATED
#  endif
# endif
#endif

#if defined(unix) || defined(__unix__) || defined(__unix) || defined(__APPLE__)
# ifdef RD_FRAMEWORK_STATIC_DEFINE
#  define RD_FRAMEWORK_API
#  define RD_FRAMEWORK_NO_EXPORT
# else
#  ifndef RD_FRAMEWORK_API
#    ifdef rd_framework_cpp_EXPORTS
        /* We are building this library */
#      define RD_FRAMEWORK_API __attribute__((visibility("default")))
#    else
        /* We are using this library */
#      define RD_FRAMEWORK_API __attribute__((visibility("default")))
#    endif
#  endif

#  ifndef RD_FRAMEWORK_NO_EXPORT
#    define RD_FRAMEWORK_NO_EXPORT __attribute__((visibility("hidden")))
#  endif
# endif

# ifndef RD_FRAMEWORK_DEPRECATED
#  define RD_FRAMEWORK_DEPRECATED __attribute__ ((__deprecated__))
# endif

# ifndef RD_FRAMEWORK_DEPRECATED_EXPORT
#  define RD_FRAMEWORK_DEPRECATED_EXPORT RD_FRAMEWORK_API RD_FRAMEWORK_DEPRECATED
# endif

# ifndef RD_FRAMEWORK_DEPRECATED_NO_EXPORT
#  define RD_FRAMEWORK_DEPRECATED_NO_EXPORT RD_FRAMEWORK_NO_EXPORT RD_FRAMEWORK_DEPRECATED
# endif

# if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef RD_FRAMEWORK_NO_DEPRECATED
#    define RD_FRAMEWORK_NO_DEPRECATED
#  endif
# endif
#endif

#endif /* RD_FRAMEWORK_API_H */

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IProtocol.cpp`:

```cpp
#include "IProtocol.h"

#include "scheduler/base/IScheduler.h"
#include "protocol/Identities.h"
#include "base/IWire.h"
#include "base/IProtocol.h"
//#include "serialization/SerializationCtx.h"

#include <utility>

namespace rd
{
IProtocol::IProtocol()
{
}

IProtocol::IProtocol(std::shared_ptr<Identities> identity, IScheduler* scheduler, std::shared_ptr<IWire> wire)
	: identity(std::move(identity)), scheduler(scheduler), wire(std::move(wire))
{
}

const IProtocol* IProtocol::get_protocol() const
{
	return this;
}

IScheduler* IProtocol::get_scheduler() const
{
	return scheduler;
}

const IWire* IProtocol::get_wire() const
{
	return wire.get();
}

const Serializers& IProtocol::get_serializers() const
{
	return *serializers;
}

const Identities* IProtocol::get_identity() const
{
	return identity.get();
}

const RName& IProtocol::get_location() const
{
	return location;
}

IProtocol::~IProtocol() = default;
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IProtocol.h`:

```h
#ifndef RD_CPP_IPROTOCOL_H
#define RD_CPP_IPROTOCOL_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "IRdDynamic.h"
#include "serialization/Serializers.h"
#include "protocol/Identities.h"
#include "scheduler/base/IScheduler.h"
#include "base/IWire.h"

#include <memory>

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class SerializationCtx;
// endregion

/**
 * \brief A root node in an object graph which can be synchronized with its remote copy over a network or a similar connection.
 */
class RD_FRAMEWORK_API IProtocol : public IRdDynamic
{
	friend class RdExtBase;

public:
	std::unique_ptr<Serializers> serializers = std::make_unique<Serializers>();

protected:
	mutable RName location;

	std::shared_ptr<Identities> identity;
	IScheduler* scheduler = nullptr;

public:
	std::shared_ptr<IWire> wire;
	// region ctor/dtor

	IProtocol();

	IProtocol(std::shared_ptr<Identities> identity, IScheduler* scheduler, std::shared_ptr<IWire> wire);

	IProtocol(IProtocol&& other) noexcept = default;

	IProtocol& operator=(IProtocol&& other) noexcept = default;

	virtual ~IProtocol();
	// endregion

	const Identities* get_identity() const;

	const IProtocol* get_protocol() const override;

	IScheduler* get_scheduler() const;

	const IWire* get_wire() const;

	const Serializers& get_serializers() const;

	const RName& get_location() const override;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_IPROTOCOL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IRdBindable.h`:

```h
#ifndef RD_CPP_FRAMEWORK_IRDBINDABLE_H
#define RD_CPP_FRAMEWORK_IRDBINDABLE_H

#include "IRdDynamic.h"
#include "lifetime/Lifetime.h"
#include "protocol/RdId.h"

#include <rd_framework_export.h>

namespace rd
{
class Identities;
}

namespace rd
{
/**
 * \brief A non-root node in an object graph which can be synchronized with its remote copy over a network or
 * a similar connection.
 */
class RD_FRAMEWORK_API IRdBindable : public IRdDynamic
{
public:
	// region ctor/dtor

	IRdBindable() = default;

	IRdBindable(IRdBindable&& other) = default;

	IRdBindable& operator=(IRdBindable&& other) = default;

	virtual ~IRdBindable() = default;
	// endregion

	virtual void set_id(RdId id) const = 0;
	virtual RdId get_id() const = 0;

	/**
	 * \brief Inserts the node into the object graph under the given [parent] and assigns the specified [name] to it.
	 * The node will be removed from the graph when the specified [lf] lifetime is terminated.
	 *
	 * \param lf lifetime of node.
	 * \param parent to whom bind.
	 * \param name specified name of node.
	 */
	virtual void bind(Lifetime lf, IRdDynamic const* parent, string_view name) const = 0;

	/**
	 * \brief Assigns IDs to this node and its child nodes in the graph.
	 *
	 * \param identities to generate unique identifiers for children.
	 * \param id which is assigned to this node.
	 */
	virtual void identify(Identities const& identities, RdId const& id) const = 0;
};

template <typename T>
typename std::enable_if_t<!util::is_base_of_v<IRdBindable, typename std::decay_t<T>>> inline identifyPolymorphic(
	T&&, Identities const& /*identities*/, RdId const& /*id*/)
{
}

// template <>
inline void identifyPolymorphic(const IRdBindable& that, Identities const& identities, RdId const& id)
{
	that.identify(identities, id);
}

template <typename T>
typename std::enable_if_t<util::is_base_of_v<IRdBindable, T>> inline identifyPolymorphic(
	std::vector<T> const& that, Identities const& identities, RdId const& id)
{
	for (size_t i = 0; i < that.size(); ++i)
	{
		that[i].identify(identities, id.mix(static_cast<int32_t>(i)));
	}
}

template <typename T>
typename std::enable_if_t<!util::is_base_of_v<IRdBindable, typename std::decay_t<T>>> inline bindPolymorphic(
	T&&, Lifetime /*lf*/, const IRdDynamic* /*parent*/, string_view /*name*/)
{
}

inline void bindPolymorphic(IRdBindable const& that, Lifetime lf, const IRdDynamic* parent, string_view name)
{
	that.bind(lf, parent, name);
}

template <typename T>
typename std::enable_if_t<util::is_base_of_v<IRdBindable, T>> inline bindPolymorphic(
	std::vector<T> const& that, Lifetime lf, IRdDynamic const* parent, string_view name)
{
	for (auto& obj : that)
	{
		obj.bind(lf, parent, name);
	}
}
}	 // namespace rd

#endif	  // RD_CPP_FRAMEWORK_IRDBINDABLE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IRdDynamic.h`:

```h
#ifndef RD_CPP_IRDDYNAMIC_H
#define RD_CPP_IRDDYNAMIC_H

#include "impl/RName.h"

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class IProtocol;

class SerializationCtx;
// endregion

/**
 * \brief A node in a graph of entities that can be synchronized with its remote copy over a network or
 * a similar connection.
 */
class RD_FRAMEWORK_API IRdDynamic
{
public:
	// region ctor/dtor

	IRdDynamic() = default;

	IRdDynamic(IRdDynamic&& other) = default;

	IRdDynamic& operator=(IRdDynamic&& other) = default;

	virtual ~IRdDynamic() = default;
	// endregion

	virtual const IProtocol* get_protocol() const = 0;

	virtual SerializationCtx& get_serialization_context() const = 0;

	virtual const RName& get_location() const = 0;
};
}	 // namespace rd

#endif	  // RD_CPP_IRDDYNAMIC_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IRdReactive.h`:

```h
#ifndef RD_CPP_FRAMEWORK_IRDREACTIVE_H
#define RD_CPP_FRAMEWORK_IRDREACTIVE_H

#include "IRdBindable.h"
#include "scheduler/base/IScheduler.h"
#include "IRdWireable.h"

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief A non-root node in an object graph which can be synchronized with its remote copy over a network or
 * a similar connection, and which allows to subscribe to its changes.
 */
class RD_FRAMEWORK_API IRdReactive : public virtual IRdBindable
{
public:
	/**
	 * \brief If set to true, local changes to this object can be performed on any thread.
	 * Otherwise, local changes can be performed only on the UI thread.
	 */
	bool async = false;
	// region ctor/dtor

	IRdReactive() = default;

	virtual ~IRdReactive() = default;
	// endregion

	/**
	 * \brief Scheduler on which wire invokes callback [onWireReceived]. Default is the same as [protocol]'s one.
	 * \return scheduler
	 */
	virtual IScheduler* get_wire_scheduler() const = 0;

	/**
	 * \brief Callback that wire triggers when it receives messaged
	 * \param buffer where serialised info is stored
	 */
	virtual void on_wire_received(Buffer buffer) const = 0;
};
}	 // namespace rd

#endif	  // RD_CPP_FRAMEWORK_IRDREACTIVE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IRdWireable.cpp`:

```cpp
#include "IRdWireable.h"

namespace rd
{
}
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IRdWireable.h`:

```h
#ifndef RD_CPP_IRDWIREABLE_H
#define RD_CPP_IRDWIREABLE_H

#include "protocol/RdId.h"
#include "scheduler/base/IScheduler.h"
#include "protocol/Buffer.h"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API IRdWireable
{
public:
	mutable RdId rdid = RdId::Null();
};
}	 // namespace rd

#endif	  // RD_CPP_IRDWIREABLE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/ISerializersOwner.cpp`:

```cpp
#include "ISerializersOwner.h"

namespace rd
{
void ISerializersOwner::registry(Serializers const& serializers) const
{
	auto it = used.insert(&serializers);
	if (!it.second)
	{
		return;
	}

	registerSerializersCore(serializers);
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/ISerializersOwner.h`:

```h
#ifndef RD_CPP_ISERIALIZERSOWNER_H
#define RD_CPP_ISERIALIZERSOWNER_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <unordered_set>

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class Serializers;
// endregion

class RD_FRAMEWORK_API ISerializersOwner
{
	mutable std::unordered_set<Serializers const*> used;

public:
	// region ctor/dtor

	virtual ~ISerializersOwner() = default;
	// endregion

	void registry(Serializers const& serializers) const;

	virtual void registerSerializersCore(Serializers const& serializers) const = 0;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_ISERIALIZERSOWNER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IUnknownInstance.cpp`:

```cpp
#include "IUnknownInstance.h"

namespace rd
{
IUnknownInstance::IUnknownInstance()
{
}

IUnknownInstance::IUnknownInstance(const RdId& unknownId) : unknownId(unknownId)
{
}

IUnknownInstance::IUnknownInstance(RdId&& unknownId) : unknownId(std::move(unknownId))
{
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IUnknownInstance.h`:

```h
#ifndef RD_CPP_IUNKNOWNINSTANCE_H
#define RD_CPP_IUNKNOWNINSTANCE_H

#include "protocol/RdId.h"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API IUnknownInstance
{
public:
	RdId unknownId{0};

	IUnknownInstance();

	explicit IUnknownInstance(const RdId& unknownId);

	explicit IUnknownInstance(RdId&& unknownId);
};
}	 // namespace rd

#endif	  // RD_CPP_IUNKNOWNINSTANCE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/IWire.h`:

```h
#ifndef RD_CPP_IWIRE_H
#define RD_CPP_IWIRE_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "reactive/base/interfaces.h"
#include "base/IRdReactive.h"
#include "reactive/Property.h"

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief Sends and receives serialized object data over a network or a similar connection.
 */
class RD_FRAMEWORK_API IWire
{
public:
	Property<bool> connected{false};
	Property<bool> heartbeatAlive{false};

	// region ctor/dtor

	IWire() = default;

	IWire(IWire&&) = default;

	virtual ~IWire() = default;
	// endregion

	/**
	 * \brief Sends a data block with the given [id] and the given [writer] function that can write the data.
	 * \param id of recipient.
	 * \param writer is used to serialise data before send.
	 */
	virtual void send(RdId const& id, std::function<void(Buffer& buffer)> writer) const = 0;

	/**
	 * \brief Adds a [handler] for receiving updated values of the object with the given [id]. The handler is removed
	 * when the given [lifetime] is terminated.
	 * \param lifetime lifetime of subscription.
	 * \param entity to be subscripted
	 */
	virtual void advise(Lifetime lifetime, IRdReactive const* entity) const = 0;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_IWIRE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/RdBindableBase.cpp`:

```cpp
#include "RdBindableBase.h"

#include "reactive/base/SignalX.h"

namespace rd
{
std::string RdBindableBase::toString() const
{
	return "location=" + to_string(location) + ",rdid=" + to_string(rdid);
}

bool RdBindableBase::is_bound() const
{
	return parent != nullptr;
}

void RdBindableBase::bind(Lifetime lf, IRdDynamic const* parent, string_view name) const
{
	RD_ASSERT_MSG(!is_bound(), ("Trying to bind already bound this to " + to_string(parent->get_location())));
	lf->bracket(
		[this, lf, parent, &name] {
			this->parent = parent;
			location = parent->get_location().sub(name, ".");
			this->bind_lifetime = lf;
		},
		[this, lf]() {
			this->bind_lifetime = lf;
			location = location.sub("<<unbound>>", "::");
			this->parent = nullptr;
			rdid = RdId::Null();
		});

	get_protocol()->get_scheduler()->assert_thread();

	priorityAdviseSection([this, lf]() { init(lf); });
}

// must be overriden if derived class have bindable members
void RdBindableBase::identify(const Identities& identities, RdId const& id) const
{
	RD_ASSERT_MSG(rdid.isNull(), "Already has RdId: " + to_string(rdid) + ", entities: $this");
	RD_ASSERT_MSG(!id.isNull(), "Assigned RdId mustn't be null, entities: $this");

	this->rdid = id;
	for (const auto& it : bindable_extensions)
	{
		identifyPolymorphic(*(it.second), identities, id.mix(".").mix(it.first));
	}
}

const IProtocol* RdBindableBase::get_protocol() const
{
	if (is_bound())
	{
		auto protocol = parent->get_protocol();
		if (protocol != nullptr)
		{
			return protocol;
		}
	}
	throw std::invalid_argument("Not bound: " + to_string(location));
}

const RName& RdBindableBase::get_location() const
{
	return location;
}

RdId RdBindableBase::get_id() const
{
	return rdid;
}

void RdBindableBase::set_id(RdId id) const
{
	rdid = id;
}

SerializationCtx& RdBindableBase::get_serialization_context() const
{
	if (is_bound())
	{
		return parent->get_serialization_context();
	}
	else
	{
		throw std::invalid_argument("Not bound: " + to_string(location));
	}
}

void RdBindableBase::init(Lifetime lifetime) const
{
	for (const auto& it : bindable_extensions)
	{
		if (it.second != nullptr)
		{
			bindPolymorphic(*(it.second), lifetime, this, it.first);
		}
	}
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/RdBindableBase.h`:

```h
#ifndef RD_CPP_RDBINDABLEBASE_H
#define RD_CPP_RDBINDABLEBASE_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "IRdBindable.h"
#include "base/IProtocol.h"

#include "thirdparty.hpp"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API RdBindableBase : public virtual IRdBindable /*, IPrintable*/
{
protected:
	mutable RName location;
	mutable IRdDynamic const* parent = nullptr;
	mutable RdId rdid = RdId::Null();

	mutable optional<Lifetime> bind_lifetime;

	bool is_bound() const;

	const IProtocol* get_protocol() const override;

	virtual std::string toString() const;

public:
	// region ctor/dtor

	RdBindableBase() : location("<<not bound>>")
	{
	}

	RdBindableBase(RdBindableBase&& other) = default;

	RdBindableBase& operator=(RdBindableBase&& other) = default;

	~RdBindableBase() override = default;
	// endregion

	// need to implement in subclasses
	virtual void init(Lifetime lifetime) const;

	const RName& get_location() const override;

	RdId get_id() const override;

	void set_id(RdId id) const override;

	void bind(Lifetime lf, IRdDynamic const* parent, string_view name) const override;

	void identify(const Identities& identities, RdId const& id) const override;

	SerializationCtx& get_serialization_context() const override;

	mutable ordered_map<std::string, std::shared_ptr<IRdBindable>> bindable_extensions;	   // TO-DO concurrency
	// mutable std::map<std::string, std::any> non_bindable_extensions;//TO-DO concurrency

	template <typename T, typename... Args>
	auto getOrCreateExtension(std::string name, Args&&... args) const ->
		typename std::enable_if_t<util::is_base_of_v<IRdBindable, T>, T> const&
	{
		auto it = bindable_extensions.find(name);
		if (it != bindable_extensions.end())
		{
			return *dynamic_cast<T const*>(it->second.get());
		}
		std::shared_ptr<T> new_extension = std::make_shared<T>(std::forward<Args>(args)...);
		T const& res = *new_extension.get();
		if (bind_lifetime.has_value())
		{
			auto protocol = get_protocol();
			new_extension->identify(*protocol->get_identity(), rdid.mix(".").mix(name));
			new_extension->bind(*bind_lifetime, this, name);
		}
		bindable_extensions.emplace(name, std::move(new_extension));
		return res;
	}

	/* template<typename T>
 std::enable_if_t<!util::is_base_of_v<IRdBindable, T>, T> const &
 getOrCreateExtension(std::string const &name, std::function<T()> create) const {
	 if (non_bindable_extensions.count(name) == 0) {
		 return std::any_cast<T const &>(non_bindable_extensions[name] = create());
	 }
	 return std::any_cast<T const &>(non_bindable_extensions.at(name));
 }*/
};

// T : RdBindableBase
template <typename T>
T& withId(T& that, RdId const& id)
{
	RD_ASSERT_MSG(that.get_id() == RdId::Null(), "this.id != RdId.NULL_ID, but " + to_string(that.get_id()));
	RD_ASSERT_MSG(id != RdId::Null(), "id != RdId.NULL_ID");

	that.set_id(id);
	return that;
}

template <typename T>
T& statics(T& that, int64_t id)
{
	RD_ASSERT_MSG((id > 0 && id < RdId::MAX_STATIC_ID), ("Expected id > 0 && id < RdId.MaxStaticId, got " + std::to_string(id)));
	return withId(that, RdId(static_cast<int64_t>(id)));
}

template <typename T>
T& withIdFromName(T& that, std::string const& name)
{
	return withId(that, RdId::Null().mix(name));
}
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#endif	  // RD_CPP_RDBINDABLEBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/RdPropertyBase.h`:

```h
#ifndef RD_CPP_RDPROPERTYBASE_H
#define RD_CPP_RDPROPERTYBASE_H

#include "base/RdReactiveBase.h"
#include "serialization/Polymorphic.h"
#include "reactive/Property.h"

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
template <typename T, typename S = Polymorphic<T>>
class RdPropertyBase : public RdReactiveBase, public Property<T>
{
protected:
	using WT = typename IProperty<T>::WT;
	// mastering
	mutable int32_t master_version = 0;
	mutable bool default_value_changed = false;

	// init
public:
	mutable bool optimize_nested = false;

	bool is_master = false;

	// region ctor/dtor

	RdPropertyBase() = default;

	RdPropertyBase(RdPropertyBase const&) = delete;

	RdPropertyBase(RdPropertyBase&& other) = default;

	RdPropertyBase& operator=(RdPropertyBase&& other) = default;

	template <typename F>
	explicit RdPropertyBase(F&& value) : Property<T>(std::forward<F>(value))
	{
	}

	virtual ~RdPropertyBase() = default;
	// endregion

	bool is_default_value_changed() const
	{
		return default_value_changed;
	}

	void init(Lifetime lifetime) const override
	{
		RdReactiveBase::init(lifetime);

		if (!optimize_nested)
		{
			this->change.advise(lifetime, [this](T const& v) {
				if (is_local_change)
				{
					if (this->has_value())
					{
						const IProtocol* iProtocol = get_protocol();
						const Identities* identity = iProtocol->get_identity();
						identifyPolymorphic(v, *identity, identity->next(rdid));
					}
				}
			});
		}

		advise(lifetime, [this](T const& v) {
			if (!is_local_change)
			{
				return;
			}
			if (is_master)
			{
				master_version++;
			}
			get_wire()->send(rdid, [this, &v](Buffer& buffer) {
				buffer.write_integral<int32_t>(master_version);
				S::write(this->get_serialization_context(), buffer, v);
				spdlog::get("logSend")->trace("SEND property {} + {}:: ver = {}, value = {}", to_string(location), to_string(rdid),
					std::to_string(master_version), to_string(v));
			});
		});

		get_wire()->advise(lifetime, this);

		if (!optimize_nested)
		{
			this->view(lifetime, [this](Lifetime lf, T const& v) {
				if (this->has_value())
				{
					bindPolymorphic(v, lf, this, "$");
				}
			});
		}
	}

	void on_wire_received(Buffer buffer) const override
	{
		int32_t version = buffer.read_integral<int32_t>();
		WT v = S::read(this->get_serialization_context(), buffer);

		bool rejected = is_master && version < master_version;
		spdlog::get("logSend")->trace("RECV property {} {}:: oldver={}, ver={}, value = {}{}", to_string(location), to_string(rdid),
			master_version, version, to_string(v), (rejected ? ">> REJECTED" : ""));
		if (rejected)
		{
			return;
		}
		master_version = version;

		Property<T>::set(std::move(v));
	}

	void advise(Lifetime lifetime, std::function<void(T const&)> handler) const override
	{
		if (is_bound())
		{
			assert_threading();
		}
		Property<T>::advise(lifetime, handler);
	}

	void set(value_or_wrapper<T> new_value) const override
	{
		this->local_change([this, new_value = std::move(new_value)]() mutable {
			this->default_value_changed = true;
			Property<T>::set(std::move(new_value));
		});
	}

	friend bool operator==(const RdPropertyBase& lhs, const RdPropertyBase& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const RdPropertyBase& lhs, const RdPropertyBase& rhs)
	{
		return !(rhs == lhs);
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

static_assert(std::is_move_constructible<rd::RdPropertyBase<int>>::value, "Is move constructible from RdPropertyBase<int>");

#endif	  // RD_CPP_RDPROPERTYBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/RdReactiveBase.cpp`:

```cpp
#include "RdReactiveBase.h"

#include "spdlog/sinks/stdout_color_sinks.h"

namespace rd
{
static std::shared_ptr<spdlog::logger> logReceived =
	spdlog::stderr_color_mt<spdlog::synchronous_factory>("logReceived", spdlog::color_mode::automatic);
std::shared_ptr<spdlog::logger> logSend =
	spdlog::stderr_color_mt<spdlog::synchronous_factory>("logSend", spdlog::color_mode::automatic);

RdReactiveBase::RdReactiveBase(RdReactiveBase&& other) : RdBindableBase(std::move(other)) /*, async(other.async)*/
{
	async = other.async;
}

RdReactiveBase& RdReactiveBase::operator=(RdReactiveBase&& other)
{
	async = other.async;
	static_cast<RdBindableBase&>(*this) = std::move(other);
	return *this;
}

const IWire* RdReactiveBase::get_wire() const
{
	return get_protocol()->get_wire();
}

void RdReactiveBase::assert_threading() const
{
	if (!async)
	{
		get_default_scheduler()->assert_thread();
	}
}

void RdReactiveBase::assert_bound() const
{
	if (!is_bound())
	{
		throw std::invalid_argument("Not bound");
	}
}

const Serializers& RdReactiveBase::get_serializers() const
{
	return *get_protocol()->serializers.get();
}

IScheduler* RdReactiveBase::get_default_scheduler() const
{
	return get_protocol()->get_scheduler();
}

IScheduler* RdReactiveBase::get_wire_scheduler() const
{
	return get_default_scheduler();
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/RdReactiveBase.h`:

```h
#ifndef RD_CPP_RDREACTIVEBASE_H
#define RD_CPP_RDREACTIVEBASE_H

#include "base/RdBindableBase.h"
#include "base/IRdReactive.h"
#include "guards.h"

#include "spdlog/spdlog.h"

#include <rd_framework_export.h>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
// region predeclared

class IWire;

class IProtocol;

class Serializers;
// endregion

class RD_FRAMEWORK_API RdReactiveBase : public RdBindableBase, public IRdReactive
{
public:
	// region ctor/dtor

	RdReactiveBase() = default;

	RdReactiveBase(RdReactiveBase&& other);

	RdReactiveBase& operator=(RdReactiveBase&& other);

	virtual ~RdReactiveBase() = default;
	// endregion

	const IWire* get_wire() const;

	mutable bool is_local_change = false;

	// delegated

	const Serializers& get_serializers() const;

	IScheduler* get_default_scheduler() const;

	IScheduler* get_wire_scheduler() const override;

	void assert_threading() const;

	void assert_bound() const;

	template <typename F>
	auto local_change(F&& action) const -> typename util::result_of_t<F()>
	{
		if (is_bound() && !async)
		{
			assert_threading();
		}

		RD_ASSERT_MSG(!is_local_change, "!isLocalChange for RdReactiveBase with id:" + to_string(rdid));

		util::bool_guard bool_guard(is_local_change);
		return action();
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#endif	  // RD_CPP_RDREACTIVEBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/WireBase.cpp`:

```cpp
#include "WireBase.h"

namespace rd
{
void WireBase::advise(Lifetime lifetime, const IRdReactive* entity) const
{
	message_broker.advise_on(lifetime, entity);
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/base/WireBase.h`:

```h
#ifndef RD_CPP_WIREBASE_H
#define RD_CPP_WIREBASE_H

#include "reactive/Property.h"
#include "base/IWire.h"
#include "protocol/MessageBroker.h"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API WireBase : public IWire
{
protected:
	IScheduler* scheduler = nullptr;

	MessageBroker message_broker;

public:
	// region ctor/dtor
	explicit WireBase(IScheduler* scheduler) : scheduler(scheduler), message_broker(scheduler)
	{
	}

	virtual ~WireBase() = default;
	// endregion

	void advise(Lifetime lifetime, IRdReactive const* entity) const override;
};
}	 // namespace rd

#endif	  // RD_CPP_WIREBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.cpp`:

```cpp
#include "ExtWire.h"

#include "protocol/Buffer.h"

namespace rd
{
ExtWire::ExtWire()
{
	connected.advise(Lifetime::Eternal(), [this](bool b) {
		if (b)
		{
			{
				std::lock_guard<decltype(lock)> guard(lock);
				while (true)
				{
					if (sendQ.empty())
					{
						return;
					}
					// auto[id, payload] = std::move(sendQ.front());
					auto it = std::move(sendQ.front());
					sendQ.pop();
					realWire->send(
						it.first, [payload = std::move(it.second)](Buffer& buffer) { buffer.write_byte_array_raw(payload); });
				}
			}
		}
	});
}

void ExtWire::advise(Lifetime lifetime, IRdReactive const* entity) const
{
	realWire->advise(lifetime, entity);
}

void ExtWire::send(RdId const& id, std::function<void(Buffer& buffer)> writer) const
{
	{
		std::lock_guard<decltype(lock)> guard(lock);
		if (!sendQ.empty() || !connected.get())
		{
			Buffer buffer;
			writer(buffer);
			sendQ.emplace(id, buffer.getRealArray());
			return;
		}
	}
	realWire->send(id, std::move(writer));
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/ExtWire.h`:

```h
#ifndef RD_CPP_EXTWIRE_H
#define RD_CPP_EXTWIRE_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "base/IWire.h"
#include "protocol/RdId.h"
#include "protocol/Buffer.h"

#include <queue>
#include <mutex>
#include <functional>

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API ExtWire final : public IWire
{
	mutable std::mutex lock;

	mutable std::queue<std::pair<RdId, Buffer::ByteArray> > sendQ;

public:
	ExtWire();

	mutable IWire const* realWire = nullptr;

	void advise(Lifetime lifetime, IRdReactive const* entity) const override;

	void send(RdId const& id, std::function<void(Buffer& buffer)> writer) const override;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_EXTWIRE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/RdExtBase.cpp`:

```cpp
#include "RdExtBase.h"

#include "lifetime/Lifetime.h"
#include "base/RdPropertyBase.h"
#include "protocol/Protocol.h"
#include "scheduler/SynchronousScheduler.h"

namespace rd
{
const IProtocol* RdExtBase::get_protocol() const
{
	return extProtocol ? extProtocol.get() : RdReactiveBase::get_protocol();
}

// must be overriden if derived ext have bindable members
void RdExtBase::init(Lifetime lifetime) const
{
	//    Protocol.initializationLogger.traceMe { "binding" }

	auto parentProtocol = RdReactiveBase::get_protocol();
	std::shared_ptr<IWire> parentWire = parentProtocol->wire;

	//    serializersOwner.registry(parentProtocol.serializers);

	IScheduler* sc = parentProtocol->get_scheduler();
	extWire->realWire = parentWire.get();
	lifetime->bracket(
		[&] {
			extProtocol =
				std::make_shared<Protocol>(parentProtocol->identity, sc, std::static_pointer_cast<IWire>(extWire), lifetime);
		},
		[this] { extProtocol = nullptr; });

	parentWire->advise(lifetime, this);

	// it's critical to advise before 'Ready' is sent because we advise on SynchronousScheduler

	lifetime->bracket([this, parentWire] { sendState(*parentWire, ExtState::Ready); },
		[this, parentWire] { sendState(*parentWire, ExtState::Disconnected); });

	for (auto const& it : bindable_extensions)
	{
		bindPolymorphic(*(it.second), lifetime, this, it.first);
	}
	traceMe(Protocol::initializationLogger, "created and bound");
}

void RdExtBase::on_wire_received(Buffer buffer) const
{
	ExtState remoteState = buffer.read_enum<ExtState>();
	traceMe(spdlog::get("logReceived"), "remote: " + to_string(remoteState));

	switch (remoteState)
	{
		case ExtState::Ready:
		{
			sendState(*extWire->realWire, ExtState::ReceivedCounterpart);
			extWire->connected.set(true);
			break;
		}
		case ExtState::ReceivedCounterpart:
		{
			extWire->connected.set(true);	 // don't set anything if already set
			break;
		}
		case ExtState::Disconnected:
		{
			extWire->connected.set(false);
			break;
		}
	}

	int64_t counterpartSerializationHash = buffer.read_integral<int64_t>();
	if (serializationHash != counterpartSerializationHash)
	{
		RD_ASSERT_MSG(false, "serializationHash of ext " + to_string(location) +
								 " doesn't match to counterpart: maybe you forgot to generate models?\n"
								 "our: " +
								 to_string(serializationHash) + ", counterpart:" + to_string(counterpartSerializationHash))
	}
}

void RdExtBase::sendState(IWire const& wire, ExtState state) const
{
	wire.send(rdid, [&](Buffer& buffer) {
		buffer.write_enum<ExtState>(state);
		buffer.write_integral<int64_t>(serializationHash);
	});
}

void RdExtBase::traceMe(std::shared_ptr<spdlog::logger> logger, string_view message) const
{
	logger->trace("ext {} {}:: {}", to_string(location), to_string(rdid), std::string(message));
}

IScheduler* RdExtBase::get_wire_scheduler() const
{
	return &SynchronousScheduler::Instance();
}

std::string to_string(RdExtBase::ExtState state)
{
	switch (state)
	{
		case RdExtBase::ExtState::Ready:
			return "Ready";
		case RdExtBase::ExtState::ReceivedCounterpart:
			return "ReceivedCounterpart";
		case RdExtBase::ExtState::Disconnected:
			return "Disconnected";
	}
	return {};
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/ext/RdExtBase.h`:

```h
#ifndef RD_CPP_RDEXTBASE_H
#define RD_CPP_RDEXTBASE_H

#include "base/RdReactiveBase.h"
#include "ExtWire.h"

#include "spdlog/spdlog.h"

#include <rd_framework_export.h>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#pragma warning(disable : 4251)
#endif

namespace rd
{
/**
 * \brief Base class for creating extension node according to bottom-up design.
 */
class RD_FRAMEWORK_API RdExtBase : public RdReactiveBase
{
	std::shared_ptr<ExtWire> extWire = std::make_shared<ExtWire>();
	mutable std::shared_ptr<IProtocol> extProtocol /* = nullptr*/;

public:
	enum class ExtState
	{
		Ready,
		ReceivedCounterpart,
		Disconnected
	};

	// region ctor/dtor

	RdExtBase() = default;

	RdExtBase(RdExtBase&&) = default;

	RdExtBase& operator=(RdExtBase&&) = default;

	virtual ~RdExtBase() = default;
	// endregion

	mutable int64_t serializationHash = 0;

	const IProtocol* get_protocol() const override;

	IScheduler* get_wire_scheduler() const override;

	void init(Lifetime lifetime) const override;

	void on_wire_received(Buffer buffer) const override;

	void sendState(IWire const& wire, ExtState state) const;

	void traceMe(std::shared_ptr<spdlog::logger> logger, string_view message) const;
};

std::string to_string(RdExtBase::ExtState state);
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_RDEXTBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RName.cpp`:

```cpp
#include "RName.h"

#include "thirdparty.hpp"

namespace rd
{
class RNameImpl
{
public:
	// region ctor/dtor
	RNameImpl(RName parent, string_view localName, string_view separator);

	RNameImpl(const RName& other) = delete;
	RNameImpl(RName&& other) noexcept = delete;
	RNameImpl& operator=(const RNameImpl& other) = delete;
	RNameImpl& operator=(RNameImpl&& other) noexcept = delete;
	// endregion

	friend std::string to_string(RNameImpl const& value);

private:
	RName parent;
	std::string local_name, separator;
};

RNameImpl::RNameImpl(RName parent, string_view localName, string_view separator)
	: parent(parent), local_name(localName), separator(separator)
{
}

RName::RName(RName parent, string_view localName, string_view separator)
	: impl(std::make_shared<RNameImpl>(std::move(parent), localName, separator))
{
}

RName RName::sub(string_view localName, string_view separator) const
{
	return RName(*this, localName, separator);
}

std::string to_string(RName const& value)
{
	std::string res;
	if (value.impl)
	{
		res = to_string(*value.impl);
	}
	return res;
}

std::string to_string(RNameImpl const& value)
{
	if (value.parent)
	{
		std::string res;
		res = to_string(value.parent);
		res += value.separator;
		res += value.local_name;
		return res;
	}
	return value.local_name;
}

RName::RName(string_view local_name) : RName(RName(), local_name, "")
{
}

}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RName.h`:

```h
#ifndef RD_CPP_FRAMEWORK_RNAME_H
#define RD_CPP_FRAMEWORK_RNAME_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "thirdparty.hpp"

#include <string>
#include <rd_framework_export.h>

namespace rd
{
class RNameImpl;

/**
 * \brief Recursive name. For constructs like Aaaa.Bbb::CCC
 */
class RD_FRAMEWORK_API RName
{
public:
	// region ctor/dtor

	RName() = default;

	RName(const RName& other) = default;

	RName(RName&& other) noexcept = default;

	RName& operator=(const RName& other) = default;

	RName& operator=(RName&& other) noexcept = default;

	RName(RName parent, string_view localName, string_view separator);

	explicit RName(string_view local_name);
	// endregion

	RName sub(string_view localName, string_view separator) const;

	explicit operator bool() const
	{
		return impl != nullptr;
	}

	friend std::string RD_FRAMEWORK_API to_string(RName const& value);

private:
	std::shared_ptr<RNameImpl> impl;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_FRAMEWORK_RNAME_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdList.h`:

```h
#ifndef RD_CPP_RDLIST_H
#define RD_CPP_RDLIST_H

#include "reactive/ViewableList.h"
#include "base/RdReactiveBase.h"
#include "serialization/Polymorphic.h"
#include "std/allocator.h"

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief Reactive list for connection through wire.
 *
 * \tparam T type of stored values
 * \tparam S "SerDes" for values
 * \tparam A allocator for values
 */
template <typename T, typename S = Polymorphic<T>, typename A = allocator<T>>
class RdList final : public RdReactiveBase, public ViewableList<T, A>, public ISerializable
{
private:
	using WT = typename IViewableList<T>::WT;

	//		mutable ViewableList<T> list;
	using list = ViewableList<T>;
	mutable int64_t next_version = 1;

	std::string logmsg(Op op, int64_t version, int32_t key, T const* value = nullptr) const
	{
		return "list " + to_string(location) + " " + to_string(rdid) + ":: " + to_string(op) + ":: key = " + std::to_string(key) +
			   ((version > 0) ? " :: version = " + std::to_string(version) : "") +
			   " :: value = " + (value ? to_string(*value) : "");
	}

public:
	using Event = typename IViewableList<T>::Event;

	using value_t = T;
	// region ctor/dtor

	RdList() = default;

	RdList(RdList&&) = default;

	RdList& operator=(RdList&&) = default;

	virtual ~RdList() = default;
	// endregion

	static RdList<T, S> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		RdList<T, S> result;
		int64_t next_version = buffer.read_integral<int64_t>();
		RdId id = RdId::read(buffer);

		result.next_version = next_version;
		withId(result, std::move(id));
		return result;
	}

	void write(SerializationCtx& /*ctx*/, Buffer& buffer) const override
	{
		buffer.write_integral<int64_t>(next_version);
		rdid.write(buffer);
	}

	static const int32_t versionedFlagShift = 2;	// update when changing Op

	bool optimize_nested = false;

	void init(Lifetime lifetime) const override
	{
		RdBindableBase::init(lifetime);

		local_change([this, lifetime] {
			advise(lifetime, [this, lifetime](typename IViewableList<T>::Event e) {
				if (!is_local_change)
					return;

				if (!optimize_nested)
				{
					T const* new_value = e.get_new_value();
					if (new_value)
					{
						const IProtocol* iProtocol = get_protocol();
						const Identities* identity = iProtocol->get_identity();
						identifyPolymorphic(*new_value, *identity, identity->next(rdid));
					}
				}

				get_wire()->send(rdid, [this, e](Buffer& buffer) {
					Op op = static_cast<Op>(e.v.index());

					buffer.write_integral<int64_t>(static_cast<int64_t>(op) | (next_version++ << versionedFlagShift));
					buffer.write_integral<int32_t>(static_cast<const int32_t>(e.get_index()));

					T const* new_value = e.get_new_value();
					if (new_value)
					{
						S::write(this->get_serialization_context(), buffer, *new_value);
					}
					spdlog::get("logSend")->trace(logmsg(op, next_version - 1, e.get_index(), new_value));
				});
			});
		});

		get_wire()->advise(lifetime, this);

		if (!optimize_nested)
		{
			this->view(lifetime, [this](Lifetime lf, size_t index, T const& value) {
				bindPolymorphic(value, lf, this, "[" + std::to_string(index) + "]");
			});
		}
	}

	void on_wire_received(Buffer buffer) const override
	{
		int64_t header = (buffer.read_integral<int64_t>());
		int64_t version = header >> versionedFlagShift;
		Op op = static_cast<Op>((header & ((1 << versionedFlagShift) - 1L)));
		int32_t index = (buffer.read_integral<int32_t>());

		RD_ASSERT_MSG(version == next_version,
			("Version conflict for " + to_string(location) + "}. Expected version " + std::to_string(next_version) + ", received " +
				std::to_string(version) + ". Are you modifying a list from two sides?"));

		next_version++;

		switch (op)
		{
			case Op::ADD:
			{
				auto value = S::read(this->get_serialization_context(), buffer);

				spdlog::get("logReceived")->trace(logmsg(op, version, index, &(wrapper::get<T>(value))));

				(index < 0) ? list::add(std::move(value)) : list::add(static_cast<size_t>(index), std::move(value));
				break;
			}
			case Op::UPDATE:
			{
				auto value = S::read(this->get_serialization_context(), buffer);

				spdlog::get("logReceived")->trace(logmsg(op, version, index, &(wrapper::get<T>(value))));

				list::set(static_cast<size_t>(index), std::move(value));
				break;
			}
			case Op::REMOVE:
			{
				spdlog::get("logReceived")->trace(logmsg(op, version, index));

				list::removeAt(static_cast<size_t>(index));
				break;
			}
			case Op::ACK:
				break;
		}
	}

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override
	{
		if (is_bound())
		{
			assert_threading();
		}
		list::advise(lifetime, handler);
	}

	bool add(WT element) const override
	{
		return local_change([this, element = std::move(element)]() mutable { return list::add(std::move(element)); });
	}

	bool add(size_t index, WT element) const override
	{
		return local_change([this, index, element = std::move(element)]() mutable { return list::add(index, std::move(element)); });
	}

	bool remove(T const& element) const override
	{
		return local_change([&] { return list::remove(element); });
	}

	WT removeAt(size_t index) const override
	{
		return local_change([&] { return list::removeAt(index); });
	}

	T const& get(size_t index) const override
	{
		return list::get(index);
	};

	WT set(size_t index, WT element) const override
	{
		return local_change([&] { return list::set(index, std::move(element)); });
	}

	void clear() const override
	{
		return local_change([&] { list::clear(); });
	}

	size_t size() const override
	{
		return list::size();
	}

	bool empty() const override
	{
		return list::empty();
	}

	std::vector<Wrapper<T>> const& getList() const override
	{
		return list::getList();
	}

	bool addAll(size_t index, std::vector<WT> elements) const override
	{
		return local_change([&] { return list::addAll(index, std::move(elements)); });
	}

	bool addAll(std::vector<WT> elements) const override
	{
		return local_change([&] { return list::addAll(std::move(elements)); });
	}

	bool removeAll(std::vector<WT> elements) const override
	{
		return local_change([&] { return list::removeAll(std::move(elements)); });
	}

	friend std::string to_string(RdList const& value)
	{
		std::string res = "[";
		for (auto const& p : value)
		{
			res += to_string(p) + ",";
		}
		return res + "]";
	}
	// region iterators

	using iterator = typename ViewableList<T>::iterator;

	using reverse_iterator = typename ViewableList<T>::reverse_iterator;
	// endregion
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

static_assert(std::is_move_constructible<rd::RdList<int>>::value, "Is move constructible RdList<int>");

#endif	  // RD_CPP_RDLIST_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdMap.h`:

```h
#ifndef RD_CPP_RDMAP_H
#define RD_CPP_RDMAP_H

#include "reactive/ViewableMap.h"
#include "base/RdReactiveBase.h"
#include "serialization/Polymorphic.h"
#include "util/shared_function.h"

#include <cstdint>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief Reactive map for connection through wire.
 *
 * \tparam K type of stored keys
 * \tparam V type of stored values
 * \tparam KS "SerDes" for keys
 * \tparam VS "SerDes" for values
 * \tparam KA allocator for keys
 * \tparam VA allocator for values
 */
template <typename K, typename V, typename KS = Polymorphic<K>, typename VS = Polymorphic<V>, typename KA = std::allocator<K>,
	typename VA = std::allocator<V>>
class RdMap final : public RdReactiveBase, public ViewableMap<K, V, KA, VA>, public ISerializable
{
private:
	using WK = typename IViewableMap<K, V>::WK;
	using WV = typename IViewableMap<K, V>::WV;
	using OV = typename IViewableMap<K, V>::OV;

	using map = ViewableMap<K, V>;
	mutable int64_t next_version = 0;
	mutable ordered_map<K const*, int64_t, wrapper::TransparentHash<K>, wrapper::TransparentKeyEqual<K>> pendingForAck;

	std::string logmsg(Op op, int64_t version, K const* key, V const* value = nullptr) const
	{
		return "map " + to_string(location) + " " + to_string(rdid) + ":: " + to_string(op) + ":: key = " + to_string(*key) +
			   ((version > 0) ? " :: version = " + std::to_string(version) : "") +
			   " :: value = " + (value ? to_string(*value) : "");
	}

	std::string logmsg(Op op, int64_t version, K const* key, optional<WV> const& value) const
	{
		return logmsg(op, version, key, value ? &(wrapper::get(*value)) : nullptr);
	}

public:
	bool is_master = false;

	bool optimize_nested = false;

	using Event = typename IViewableMap<K, V>::Event;

	using key_type = K;
	using value_type = V;

	// region ctor/dtor

	RdMap() = default;

	RdMap(RdMap&&) = default;

	RdMap& operator=(RdMap&&) = default;

	virtual ~RdMap() = default;
	// endregion

	static RdMap<K, V, KS, VS> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		RdMap<K, V, KS, VS> res;
		RdId id = RdId::read(buffer);
		withId(res, id);
		return res;
	}

	void write(SerializationCtx& /*ctx*/, Buffer& buffer) const override
	{
		rdid.write(buffer);
	}

	static const int32_t versionedFlagShift = 8;

	void init(Lifetime lifetime) const override
	{
		RdBindableBase::init(lifetime);

		local_change([this, lifetime]() {
			advise(lifetime, [this, lifetime](Event e) {
				if (!is_local_change)
					return;

				V const* new_value = e.get_new_value();
				if (new_value)
				{
					const IProtocol* iProtocol = get_protocol();
					const Identities* identity = iProtocol->get_identity();
					identifyPolymorphic(*new_value, *identity, identity->next(rdid));
				}

				get_wire()->send(rdid, [this, e](Buffer& buffer) {
					int32_t versionedFlag = ((is_master ? 1 : 0)) << versionedFlagShift;
					Op op = static_cast<Op>(e.v.index());

					buffer.write_integral<int32_t>(static_cast<int32_t>(op) | versionedFlag);

					int64_t version = is_master ? ++next_version : 0L;

					if (is_master)
					{
						pendingForAck.emplace(e.get_key(), version);
						buffer.write_integral(version);
					}

					KS::write(this->get_serialization_context(), buffer, *e.get_key());

					V const* new_value = e.get_new_value();
					if (new_value)
					{
						VS::write(this->get_serialization_context(), buffer, *new_value);
					}

					spdlog::get("logSend")->trace("SEND{}", logmsg(op, next_version - 1, e.get_key(), new_value));
				});
			});
		});

		get_wire()->advise(lifetime, this);

		if (!optimize_nested)
			this->view(lifetime, [this](Lifetime lf, std::pair<K const*, V const*> entry) {
				bindPolymorphic(entry.second, lf, this, "[" + to_string(*entry.first) + "]");
			});
	}

	void on_wire_received(Buffer buffer) const override
	{
		int32_t header = buffer.read_integral<int32_t>();
		bool msg_versioned = (header >> versionedFlagShift) != 0;
		Op op = static_cast<Op>(header & ((1 << versionedFlagShift) - 1));

		int64_t version = msg_versioned ? buffer.read_integral<int64_t>() : 0;

		WK key = KS::read(this->get_serialization_context(), buffer);

		if (op == Op::ACK)
		{
			std::string errmsg;
			if (!msg_versioned)
			{
				errmsg = "Received " + to_string(Op::ACK) + " while msg hasn't versioned flag set";
			}
			else if (!is_master)
			{
				errmsg = "Received " + to_string(Op::ACK) + " when not a Master";
			}
			else
			{
				if (pendingForAck.count(key) > 0)
				{
					int64_t pendingVersion = pendingForAck.at(key);
					if (pendingVersion < version)
					{
						errmsg = "Pending version " + std::to_string(pendingVersion) + " < " + to_string(Op::ACK) + " version `" +
								 std::to_string(version);
					}
					else
					{
						// side effect
						if (pendingVersion == version)
						{
							pendingForAck.erase(key);	 // else we don't need to remove, silently drop
						}
						// return good result
					}
				}
				else
				{
					errmsg = "No pending for " + to_string(Op::ACK);
				}
			}
			if (errmsg.empty())
			{
				spdlog::get("logReceived")->trace(logmsg(Op::ACK, version, &(wrapper::get<K>(key))));
			}
			else
			{
				spdlog::get("logReceived")->error(logmsg(Op::ACK, version, &(wrapper::get<K>(key))) + " >> " + errmsg);
			}
		}
		else
		{
			Buffer serialized_key;
			KS::write(this->get_serialization_context(), serialized_key, wrapper::get<K>(key));

			bool is_put = (op == Op::ADD || op == Op::UPDATE);
			optional<WV> value;
			if (is_put)
			{
				value = VS::read(this->get_serialization_context(), buffer);
			}

			if (msg_versioned || !is_master || pendingForAck.count(key) == 0)
			{
				spdlog::get("logReceived")->trace("RECV{}", logmsg(op, version, &(wrapper::get<K>(key)), value));
				if (value.has_value())
				{
					map::set(std::move(key), *std::move(value));
				}
				else
				{
					map::remove(wrapper::get<K>(key));
				}
			}
			else
			{
				spdlog::get("logReceived")->trace("{} >> REJECTED", logmsg(op, version, &(wrapper::get<K>(key)), value));
			}

			if (msg_versioned)
			{
				auto writer =
					util::make_shared_function([version, serialized_key = std::move(serialized_key)](Buffer& innerBuffer) mutable {
						innerBuffer.write_integral<int32_t>((1u << versionedFlagShift) | static_cast<int32_t>(Op::ACK));
						innerBuffer.write_integral<int64_t>(version);
						// KS::write(this->get_serialization_context(), innerBuffer, wrapper::get<K>(key));
						innerBuffer.write_byte_array_raw(serialized_key.getArray());
						// logSend.trace(logmsg(Op::ACK, version, serialized_key));
					});
				get_wire()->send(rdid, std::move(writer));
				if (is_master)
				{
					spdlog::get("logReceived")->error("Both ends are masters: {}", to_string(location));
				}
			}
		}
	}

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override
	{
		if (is_bound())
		{
			assert_threading();
		}
		map::advise(lifetime, handler);
	}

	V const* get(K const& key) const override
	{
		return local_change([&] { return map::get(key); });
	}

	V const* set(WK key, WV value) const override
	{
		return local_change([&]() mutable { return map::set(std::move(key), std::move(value)); });
	}

	OV remove(K const& key) const override
	{
		return local_change([&] { return map::remove(key); });
	}

	void clear() const override
	{
		return local_change([&] { return map::clear(); });
	}

	size_t size() const override
	{
		return map::size();
	}

	bool empty() const override
	{
		return map::empty();
	}

	friend std::string to_string(RdMap const& value)
	{
		std::string res = "[";
		for (auto it = value.begin(); it != value.end(); ++it)
		{
			res += to_string(it.key()) + "=>" + to_string(it.value()) + ",";
		}
		return res + "]";
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

static_assert(std::is_move_constructible<rd::RdMap<int, int>>::value, "Is move constructible RdMap<int, int>");
static_assert(std::is_move_assignable<rd::RdMap<int, int>>::value, "Is move constructible RdMap<int, int>");
static_assert(std::is_default_constructible<rd::RdMap<int, int>>::value, "Is default constructible RdMap<int, int>");

#endif	  // RD_CPP_RDMAP_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdProperty.h`:

```h
#ifndef RD_CPP_RDPROPERTY_H
#define RD_CPP_RDPROPERTY_H

#include "base/RdPropertyBase.h"
#include "serialization/Polymorphic.h"
#include "serialization/ISerializable.h"
#include "std/allocator.h"

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief Reactive property for connection through wire.

 * \tparam T type of stored value
 * \tparam S "SerDes" for value
 */
template <typename T, typename S = Polymorphic<T>, typename A = allocator<T>>
class RdProperty final : public RdPropertyBase<T, S>, public ISerializable
{
public:
	using value_type = T;

	// region ctor/dtor

	RdProperty() = default;

	RdProperty(RdProperty const&) = delete;

	RdProperty& operator=(RdProperty const&) = delete;

	RdProperty(RdProperty&&) = default;

	RdProperty& operator=(RdProperty&&) = default;

	template <typename F>
	explicit RdProperty(F&& value) : RdPropertyBase<T, S>(std::forward<F>(value))
	{
	}

	virtual ~RdProperty() = default;
	// endregion

	static RdProperty<T, S> read(SerializationCtx& ctx, Buffer& buffer)
	{
		RdId id = RdId::read(buffer);
		bool not_null = buffer.read_bool();	   // not null/
		(void) not_null;
		auto value = S::read(ctx, buffer);
		RdProperty<T, S> property;
		property.value = std::move(value);
		withId(property, id);
		return property;
	}

	void write(SerializationCtx& ctx, Buffer& buffer) const override
	{
		this->rdid.write(buffer);
		buffer.write_bool(true);
		S::write(ctx, buffer, this->get());
	}

	void advise(Lifetime lifetime, std::function<void(T const&)> handler) const override
	{
		RdPropertyBase<T, S>::advise(lifetime, std::move(handler));
	}

	RdProperty<T, S>& slave()
	{
		this->is_master = false;
		return *this;
	}

	void identify(Identities const& identities, RdId const& id) const override
	{
		RdBindableBase::identify(identities, id);
		if (!this->optimize_nested && this->has_value())
		{
			identifyPolymorphic(this->get(), identities, identities.next(id));
		}
	}

	friend bool operator==(const RdProperty& lhs, const RdProperty& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const RdProperty& lhs, const RdProperty& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(RdProperty const& value)
	{
		return to_string(static_cast<Property<T> const&>(value));
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

static_assert(std::is_move_constructible<rd::RdProperty<int>>::value, "Is move constructible from RdProperty<int>");

#endif	  // RD_CPP_RDPROPERTY_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdSet.h`:

```h
#ifndef RD_CPP_RDSET_H
#define RD_CPP_RDSET_H

#include "reactive/ViewableSet.h"
#include "base/RdReactiveBase.h"
#include "serialization/Polymorphic.h"
#include "std/allocator.h"

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief Reactive set for connection through wire.
 *
 * \tparam T type of stored values
 * \tparam S "SerDes" for values
 */
template <typename T, typename S = Polymorphic<T>, typename A = allocator<T>>
class RdSet final : public RdReactiveBase, public ViewableSet<T, A>, public ISerializable
{
private:
	using WT = typename IViewableSet<T>::WT;

protected:
	using set = ViewableSet<T>;

public:
	using Event = typename IViewableSet<T>::Event;

	using value_type = T;

	// region ctor/dtor

	RdSet() = default;

	RdSet(RdSet&&) = default;

	RdSet& operator=(RdSet&&) = default;

	virtual ~RdSet() = default;

	// endregion

	static RdSet<T, S> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		RdSet<T, S> result;
		RdId id = RdId::read(buffer);
		withId(result, std::move(id));
		return result;
	}

	void write(SerializationCtx& /*ctx*/, Buffer& buffer) const override
	{
		rdid.write(buffer);
	}

	bool optimize_nested = false;

	void init(Lifetime lifetime) const override
	{
		RdBindableBase::init(lifetime);

		local_change([this, lifetime] {
			advise(lifetime, [this](AddRemove kind, T const& v) {
				if (!is_local_change)
					return;

				get_wire()->send(rdid, [this, kind, &v](Buffer& buffer) {
					buffer.write_enum<AddRemove>(kind);
					S::write(this->get_serialization_context(), buffer, v);

					spdlog::get("logSend")->trace("SENDset {} {}:: {}:: {}", to_string(location), to_string(rdid), to_string(kind), to_string(v));
				});
			});
		});

		get_wire()->advise(lifetime, this);
	}

	void on_wire_received(Buffer buffer) const override
	{
		AddRemove kind = buffer.read_enum<AddRemove>();
		auto value = S::read(this->get_serialization_context(), buffer);

		switch (kind)
		{
			case AddRemove::ADD:
			{
				set::add(std::move(value));
				break;
			}
			case AddRemove::REMOVE:
			{
				set::remove(wrapper::get<T>(value));
				break;
			}
		}
	}

	bool add(WT value) const override
	{
		return local_change([this, value = std::move(value)]() mutable { return set::add(std::move(value)); });
	}

	void clear() const override
	{
		return local_change([&] { return set::clear(); });
	}

	bool remove(T const& value) const override
	{
		return local_change([&] { return set::remove(value); });
	}

	size_t size() const override
	{
		return local_change([&] { return set::size(); });
	}

	bool contains(T const& value) const override
	{
		return local_change([&] { return set::contains(value); });
	}

	bool empty() const override
	{
		return local_change([&] { return set::empty(); });
	}

	void advise(Lifetime lifetime, std::function<void(Event const&)> handler) const override
	{
		if (is_bound())
		{
			assert_threading();
		}
		set::advise(lifetime, std::move(handler));
	}

	bool addAll(std::vector<WT> elements) const override
	{
		return local_change([this, elements = std::move(elements)]() mutable { return set::addAll(elements); });
	}

	friend std::string to_string(RdSet const& value)
	{
		std::string res = "[";
		for (auto const& p : value)
		{
			res += to_string(p) + ",";
		}
		return res + "]";
	}

	using IViewableSet<T>::advise;
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

static_assert(std::is_move_constructible<rd::RdSet<int>>::value, "Is move constructible RdSet<int>");

#endif	  // RD_CPP_RDSET_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/impl/RdSignal.h`:

```h
#ifndef RD_CPP_RDSIGNAL_H
#define RD_CPP_RDSIGNAL_H

#include "lifetime/Lifetime.h"
#include "reactive/base/interfaces.h"
#include "scheduler/base/IScheduler.h"
#include "reactive/base/SignalX.h"
#include "base/RdReactiveBase.h"
#include "serialization/Polymorphic.h"

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief Reactive signal for connection through wire.
 *
 * \tparam T type of events
 * \tparam S "SerDes" for events
 */
template <typename T, typename S = Polymorphic<T>>
class RdSignal final : public RdReactiveBase, public ISignal<T>, public ISerializable
{
private:
	using WT = typename ISignal<T>::WT;

	std::string logmsg(T const& value) const
	{
		return "signal " + to_string(location) + " " + to_string(rdid) + ":: value = " + to_string(value);
	}

	mutable IScheduler* wire_scheduler{};

private:
	void set_wire_scheduler(IScheduler* scheduler) const
	{
		wire_scheduler = scheduler;
	}

protected:
	Signal<T> signal;

public:
	// region ctor/dtor

	RdSignal(RdSignal const&) = delete;

	RdSignal& operator=(RdSignal const&) = delete;

	RdSignal() = default;

	RdSignal(RdSignal&&) = default;

	RdSignal& operator=(RdSignal&&) = default;

	virtual ~RdSignal() = default;
	// endregion

	static RdSignal<T, S> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		RdSignal<T, S> res;
		const RdId& id = RdId::read(buffer);
		withId(res, id);
		return res;
	}

	void write(SerializationCtx& /*ctx*/, Buffer& buffer) const override
	{
		rdid.write(buffer);
	}

	void init(Lifetime lifetime) const override
	{
		RdReactiveBase::init(lifetime);
		set_wire_scheduler(get_default_scheduler());
		get_wire()->advise(lifetime, this);
	}

	void on_wire_received(Buffer buffer) const override
	{
		auto value = S::read(this->get_serialization_context(), buffer);
		spdlog::get("logReceived")->trace("RECV{}", logmsg(wrapper::get<T>(value)));

		signal.fire(wrapper::get<T>(value));
	}

	using ISignal<T>::fire;

	void fire(T const& value) const override
	{
	    // Disabling checking for bounding, to fix async signal being called unbound on another thread.
		// Copying hack from rd-net
		// https://github.com/JetBrains/rd/blob/d00d07c38784af5743c75ceca4bbceb92f6f8149/rd-net/RdFramework/Impl/RdSignal.cs#L72-L95
		// assert_bound();
		if (!async)
		{
			assert_threading();
		}

		if (async && !is_bound()) return;

		get_wire()->send(rdid, [this, &value](Buffer& buffer) {
			spdlog::get("logSend")->trace("SEND{}", logmsg(value));
			S::write(get_serialization_context(), buffer, value);
		});
		signal.fire(value);
	}

	using ISource<T>::advise;

	void advise(Lifetime lifetime, std::function<void(T const&)> handler) const override
	{
		if (is_bound())
		{
			assert_threading();
		}
		signal.advise(lifetime, handler);
	}

	template <typename F>
	void advise_on(Lifetime lifetime, IScheduler* scheduler, F&& handler)
	{
		if (is_bound())
		{
			assert_threading();
		}
		set_wire_scheduler(scheduler);
		signal.advise(lifetime, std::forward<F>(handler));
	}

	IScheduler* get_wire_scheduler() const override
	{
		return wire_scheduler;
	}

	friend std::string to_string(RdSignal const&)
	{
		return "";
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

static_assert(std::is_move_constructible<rd::RdSignal<int>>::value, "Is not move constructible from RdSignal<int>");

#endif	  // RD_CPP_RDSIGNAL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/intern/InternRoot.cpp`:

```cpp
#include "InternRoot.h"

#include "serialization/AbstractPolymorphic.h"
#include "serialization/InternedAnySerializer.h"

namespace rd
{
InternRoot::InternRoot()
{
	async = true;
}

IScheduler* InternRoot::get_wire_scheduler() const
{
	return &intern_scheduler;
}

void InternRoot::on_wire_received(Buffer buffer) const
{
	optional<InternedAny> value = InternedAnySerializer::read(get_serialization_context(), buffer);
	if (!value)
	{
		return;
	}
	const int32_t remote_id = buffer.read_integral<int32_t>();
	set_interned_correspondence(remote_id ^ 1, *std::move(value));
	RD_ASSERT_MSG(((remote_id & 1) == 0), "Remote sent ID marked as our own, bug?");
}

void InternRoot::bind(Lifetime lf, IRdDynamic const* parent, string_view name) const
{
	RD_ASSERT_MSG(!is_bound(), "Trying to bound already bound "s + to_string(this->location) + " to " + to_string(parent->get_location()))

	lf->bracket(
		[this, parent, &name] {
			this->parent = parent;
			location = parent->get_location().sub(name, ".");
		},
		[this] {
			location = location.sub("<<unbound>>", "::");
			this->parent = nullptr;
			rdid = RdId::Null();
		});

	{
		// if something's interned before bind
		std::lock_guard<decltype(lock)> guard(lock);
		my_items_lis.clear();
		other_items_list.clear();
		inverse_map.clear();
	}
	get_protocol()->get_wire()->advise(lf, this);
}

void InternRoot::identify(const Identities& /*identities*/, RdId const& id) const
{
	RD_ASSERT_MSG(rdid.isNull(), "Already has RdId: " + to_string(rdid) + ", entities: $this");
	RD_ASSERT_MSG(!id.isNull(), "Assigned RdId mustn't be null, entities: $this");

	rdid = id;
}

void InternRoot::set_interned_correspondence(int32_t id, InternedAny&& value) const
{
	RD_ASSERT_MSG(!is_index_owned(id), "Setting interned correspondence for object that we should have written, bug?")

	std::lock_guard<decltype(lock)> guard(lock);
	other_items_list[id / 2] = value;
	inverse_map[value] = id;
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/intern/InternRoot.h`:

```h
#ifndef RD_CPP_INTERNROOT_H
#define RD_CPP_INTERNROOT_H

#include "base/RdReactiveBase.h"
#include "InternScheduler.h"
#include "lifetime/Lifetime.h"
#include "types/wrapper.h"
#include "serialization/RdAny.h"
#include "util/core_traits.h"

#include "tsl/ordered_map.h"

#include <vector>
#include <string>
#include <mutex>

#include <rd_framework_export.h>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#pragma warning(disable : 4251)
#endif

namespace rd
{
// region predeclared

class Identities;

// endregion

/**
 * \brief Node in graph for storing interned objects.
 */
class RD_FRAMEWORK_API InternRoot final : public RdReactiveBase
{
private:
	// template<typename T>
	mutable std::vector<InternedAny> my_items_lis;

	// template<typename T>
	mutable ordered_map<int32_t, InternedAny> other_items_list;
	// template<typename T>
	mutable ordered_map<InternedAny, int32_t, any::TransparentHash, any::TransparentKeyEqual> inverse_map;

	mutable InternScheduler intern_scheduler;

	mutable std::recursive_mutex lock;

	void set_interned_correspondence(int32_t id, InternedAny&& value) const;

	static constexpr bool is_index_owned(int32_t id);

public:
	// region ctor/dtor

	InternRoot();
	// endregion

	template <typename T>
	int32_t intern_value(Wrapper<T> value) const;

	template <typename T>
	Wrapper<T> un_intern_value(int32_t id) const;

	IScheduler* get_wire_scheduler() const override;

	void bind(Lifetime lf, IRdDynamic const* parent, string_view name) const override;

	void identify(const Identities& identities, RdId const& id) const override;

	void on_wire_received(Buffer buffer) const override;
};
}	 // namespace rd

#include "serialization/InternedAnySerializer.h"

namespace rd
{
/*template<typename T>
std::vector<value_or_wrapper<T>> InternRoot::myItemsList = {};

template<typename T>
ordered_map<int32_t, value_or_wrapper<T>> InternRoot::otherItemsList = {};

template<typename T>
ordered_map<value_or_wrapper<T>, int32_t> InternRoot::inverseMap = {};*/

constexpr bool InternRoot::is_index_owned(int32_t id)
{
	return !static_cast<bool>(id & 1);
}

template <typename T>
Wrapper<T> InternRoot::un_intern_value(int32_t id) const
{
	// don't need lock because value's already exists and never removes
	return any::get<T>(is_index_owned(id) ? my_items_lis[id / 2] : other_items_list[id / 2]);
}

template <typename T>
int32_t InternRoot::intern_value(Wrapper<T> value) const
{
	InternedAny any = any::make_interned_any<T>(value);

	std::lock_guard<decltype(lock)> guard(lock);

	auto it = inverse_map.find(any);
	int32_t index = 0;
	if (it == inverse_map.end())
	{
		get_protocol()->get_wire()->send(this->rdid, [this, &index, value, any](Buffer& buffer) {
			InternedAnySerializer::write<T>(get_serialization_context(), buffer, wrapper::get<T>(value));
			{
				std::lock_guard<decltype(lock)> guard(lock);
				index = static_cast<int32_t>(my_items_lis.size()) * 2;
				my_items_lis.emplace_back(any);
			}
			buffer.write_integral<int32_t>(index);
		});
	}
	else
	{
		index = it->second;
	}
	if (inverse_map.count(any) == 0)
	{
		inverse_map[any] = index;
	}
	return index;
}
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_INTERNROOT_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/intern/InternScheduler.cpp`:

```cpp
#include "InternScheduler.h"

#include "guards.h"

namespace rd
{
thread_local int32_t InternScheduler::active_counts = 0;

InternScheduler::InternScheduler()
{
	out_of_order_execution = true;
}

void InternScheduler::queue(std::function<void()> action)
{
	util::increment_guard<int32_t> guard(active_counts);
	action();
}

void InternScheduler::flush()
{
}

bool InternScheduler::is_active() const
{
	return active_counts > 0;
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/intern/InternScheduler.h`:

```h
#ifndef RD_CPP_INTERNSCHEDULER_H
#define RD_CPP_INTERNSCHEDULER_H

#include "scheduler/base/IScheduler.h"

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief Scheduler for interning object. Maintains out of order execution.
 */
class InternScheduler : public IScheduler
{
	static thread_local int32_t active_counts;

public:
	// region ctor/dtor

	InternScheduler();
	// endregion

	void queue(std::function<void()> action) override;

	void flush() override;

	bool is_active() const override;
};
}	 // namespace rd

#endif	  // RD_CPP_INTERNSCHEDULER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Buffer.cpp`:

```cpp
#include <utility>

#include "protocol/Buffer.h"

#include <string>
#include <algorithm>

namespace rd
{
Buffer::Buffer() : Buffer(16)
{
}

Buffer::Buffer(size_t initialSize) : data_(initialSize)
{
}

Buffer::Buffer(ByteArray array, size_t offset) : data_(std::move(array)), offset(offset)
{
}

size_t Buffer::get_position() const
{
	return offset;
}

void Buffer::set_position(size_t value)
{
	offset = value;
}

void Buffer::check_available(size_t moreSize) const
{
	if (offset + moreSize > size())
	{
		throw std::out_of_range(
			"Expected " + std::to_string(moreSize) + " bytes in buffer, only" + std::to_string(size() - offset) + "available");
	}
}

void Buffer::read(word_t* dst, size_t size)
{
	if (size == 0)
		return;
	check_available(size);
	std::copy(&data_[offset], &data_[offset] + size, dst);
	offset += size;
}

void Buffer::write(const word_t* src, size_t size)
{
	if (size == 0)
		return;
	require_available(size);
	std::copy(src, src + size, &data_[offset]);
	offset += size;
}

void Buffer::require_available(size_t moreSize)
{
	if (offset + moreSize >= size())
	{
		const size_t new_size = (std::max)(size() * 2, offset + moreSize);
		data_.resize(new_size);
	}
}

void Buffer::rewind()
{
	set_position(0);
}

Buffer::ByteArray Buffer::getArray() const&
{
	return data_;
}

Buffer::ByteArray Buffer::getArray() &&
{
	rewind();
	return std::move(data_);
}

Buffer::ByteArray Buffer::getRealArray() const&
{
	auto res = getArray();
	res.resize(offset);
	return res;
}

Buffer::ByteArray Buffer::getRealArray() &&
{
	auto res = std::move(data_);
	res.resize(offset);
	rewind();
	return res;
}

Buffer::word_t const* Buffer::data() const
{
	return data_.data();
}

Buffer::word_t* Buffer::data()
{
	return data_.data();
}

Buffer::word_t const* Buffer::current_pointer() const
{
	return data() + offset;
}

Buffer::word_t* Buffer::current_pointer()
{
	return data() + offset;
}

size_t Buffer::size() const
{
	return data_.size();
}

/*std::string Buffer::readString() const {
auto v = readArray<uint8_t>();
return std::string(v.begin(), v.end());
}

void Buffer::writeString(std::string const &value) const {
std::vector<uint8_t> v(value.begin(), value.end());
writeArray<uint8_t>(v);
}*/

template <int>
std::wstring read_wstring_spec(Buffer& buffer)
{
	auto v = buffer.read_array<std::vector, uint16_t>();
	return std::wstring(v.begin(), v.end());
}

template <>
std::wstring read_wstring_spec<2>(Buffer& buffer)
{
	const int32_t len = buffer.read_integral<int32_t>();
	RD_ASSERT_MSG(len >= 0, "read null string(length =" + std::to_string(len) + ")");
	std::wstring result;
	result.resize(len);
	buffer.read(reinterpret_cast<Buffer::word_t*>(&result[0]), sizeof(wchar_t) * len);
	return result;
}

std::wstring Buffer::read_wstring()
{
	return read_wstring_spec<sizeof(wchar_t)>(*this);
}

template <int>
void write_wstring_spec(Buffer& buffer, wstring_view value)
{
	const std::vector<uint16_t> v(value.begin(), value.end());
	buffer.write_array<std::vector, uint16_t>(v);
}

template <>
void write_wstring_spec<2>(Buffer& buffer, wstring_view value)
{
	buffer.write_integral<int32_t>(static_cast<int32_t>(value.size()));
	buffer.write(reinterpret_cast<Buffer::word_t const*>(value.data()), sizeof(wchar_t) * value.size());
}

void Buffer::write_wstring(std::wstring const& value)
{
	write_wstring(wstring_view(value));
}

void Buffer::write_char16_string(const uint16_t* data, size_t len)
{
	write_integral<int32_t>(static_cast<int32_t>(len));
	write(reinterpret_cast<word_t const*>(data), sizeof(uint16_t) * len);
}

uint16_t* Buffer::read_char16_string()
{	
	const int32_t len = read_integral<int32_t>();
	RD_ASSERT_MSG(len >= 0, "read null string(length =" + std::to_string(len) + ")");
	uint16_t * result = new uint16_t[len+1];
	read(reinterpret_cast<Buffer::word_t*>(&result[0]), sizeof(uint16_t) * len);
	result[len] = 0;
	return result;
}

void Buffer::write_wstring(wstring_view value)
{
	write_wstring_spec<sizeof(wchar_t)>(*this, value);
}

void Buffer::write_wstring(Wrapper<std::wstring> const& value)
{
	write_wstring(*value);
}

int64_t TICKS_AT_EPOCH = 621355968000000000L;
int64_t TICKS_PER_MILLISECOND = 10000000;

DateTime Buffer::read_date_time()
{
	int64_t time_in_ticks = read_integral<int64_t>();
	time_t t = static_cast<time_t>(time_in_ticks / TICKS_PER_MILLISECOND - TICKS_AT_EPOCH / TICKS_PER_MILLISECOND);
	return DateTime{t};
}

void Buffer::write_date_time(DateTime const& date_time)
{
	uint64_t t = date_time.seconds * TICKS_PER_MILLISECOND + TICKS_AT_EPOCH;
	write_integral<int64_t>(t);
}

bool Buffer::read_bool()
{
	const auto res = read_integral<uint8_t>();
	RD_ASSERT_MSG(res == 0 || res == 1, "get byte:" + std::to_string(res) + " instead of 0 or 1");
	return res == 1;
}

void Buffer::write_bool(bool value)
{
	write_integral<word_t>(value ? 1 : 0);
}

wchar_t Buffer::read_char()
{
	return static_cast<wchar_t>(read_integral<uint16_t>());
}

void Buffer::write_char(wchar_t value)
{
	write_integral<uint16_t>(value);
}

void Buffer::read_byte_array(ByteArray& array)
{
	const int32_t length = read_integral<int32_t>();
	array.resize(length);
	read_byte_array_raw(array);
}

void Buffer::read_byte_array_raw(ByteArray& array)
{
	read(array.data(), array.size());
}

void Buffer::write_byte_array_raw(const ByteArray& array)
{
	write(array.data(), array.size());
}

Buffer::ByteArray& Buffer::get_data()
{
	return data_;
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Buffer.h`:

```h
#ifndef RD_CPP_UNSAFEBUFFER_H
#define RD_CPP_UNSAFEBUFFER_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "types/DateTime.h"
#include "util/core_util.h"
#include "types/wrapper.h"
#include "std/allocator.h"
#include "std/list.h"

#include <vector>
#include <type_traits>
#include <functional>
#include <memory>

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief Simple data buffer. Allows to "SerDes" plenty of types, such as integrals, arrays, etc.
 */
class RD_FRAMEWORK_API Buffer final
{
public:
	friend class PkgInputStream;

	using word_t = uint8_t;

	using Allocator = std::allocator<word_t>;

	using ByteArray = std::vector<word_t, Allocator>;

private:
	template <int>
	friend std::wstring read_wstring_spec(Buffer&);

	template <int>
	friend void write_wstring_spec(Buffer&, wstring_view);

	ByteArray data_;

	size_t offset = 0;

	// read
	void read(word_t* dst, size_t size);

	// write
	void write(const word_t* src, size_t size);

	size_t size() const;

public:
	// region ctor/dtor

	Buffer();

	explicit Buffer(size_t initial_size);

	explicit Buffer(ByteArray array, size_t offset = 0);

	Buffer(Buffer const&) = delete;

	Buffer& operator=(Buffer const&) = delete;

	Buffer(Buffer&&) noexcept = default;

	Buffer& operator=(Buffer&&) noexcept = default;

	// endregion

	size_t get_position() const;

	void set_position(size_t value);

	void require_available(size_t size);

	void check_available(size_t moreSize) const;

	void rewind();

	template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value, T>>
	T read_integral()
	{
		T result;
		read(reinterpret_cast<word_t*>(&result), sizeof(T));
		return result;
	}

	template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value>>
	void write_integral(T const& value)
	{
		write(reinterpret_cast<word_t const*>(&value), sizeof(T));
	}

	template <typename T, typename = typename std::enable_if_t<std::is_floating_point<T>::value, T>>
	T read_floating_point()
	{
		T result;
		read(reinterpret_cast<word_t*>(&result), sizeof(T));
		return result;
	}

	template <typename T, typename = typename std::enable_if_t<std::is_floating_point<T>::value>>
	void write_floating_point(T const& value)
	{
		write(reinterpret_cast<word_t const*>(&value), sizeof(T));
	}

	template <template <class, class> class C, typename T, typename A = allocator<T>,
		typename = typename std::enable_if_t<util::is_pod_v<T>>>
	C<T, A> read_array()
	{
		int32_t len = read_integral<int32_t>();
		RD_ASSERT_MSG(len >= 0, "read null array(length = " + std::to_string(len) + ")");
		C<T, A> result;
		using rd::resize;
		resize(result, len);
		if (len > 0)
		{
			read(reinterpret_cast<word_t*>(&result[0]), sizeof(T) * len);
		}
		return result;
	}

	template <template <class, class> class C, typename T, typename A = allocator<value_or_wrapper<T>>>
	C<value_or_wrapper<T>, A> read_array(std::function<value_or_wrapper<T>()> reader)
	{
		int32_t len = read_integral<int32_t>();
		C<value_or_wrapper<T>, A> result;
		using rd::resize;
		resize(result, len);
		for (int32_t i = 0; i < len; ++i)
		{
			result[i] = std::move(reader());
		}
		return result;
	}

	template <template <class, class> class C, typename T, typename A = allocator<T>,
		typename = typename std::enable_if_t<util::is_pod_v<T>>>
	void write_array(C<T, A> const& container)
	{
		using rd::size;
		const int32_t& len = rd::size(container);
		write_integral<int32_t>(static_cast<int32_t>(len));
		if (len > 0)
		{
			write(reinterpret_cast<word_t const*>(&container[0]), sizeof(T) * len);
		}
	}

	template <template <class, class> class C, typename T, typename A = allocator<T>,
		typename = typename std::enable_if_t<!rd::util::in_heap_v<T>>>
	void write_array(C<T, A> const& container, std::function<void(T const&)> writer)
	{
		using rd::size;
		write_integral<int32_t>(size(container));
		for (auto const& e : container)
		{
			writer(e);
		}
	}

	template <template <class, class> class C, typename T, typename A = allocator<Wrapper<T>>>
	void write_array(C<Wrapper<T>, A> const& container, std::function<void(T const&)> writer)
	{
		using rd::size;
		write_integral<int32_t>(size(container));
		for (auto const& e : container)
		{
			writer(*e);
		}
	}

	void read_byte_array(ByteArray& array);

	void read_byte_array_raw(ByteArray& array);

	void write_byte_array_raw(ByteArray const& array);

	//    std::string readString() const;

	//    void writeString(std::string const &value) const;

	bool read_bool();

	void write_bool(bool value);

	wchar_t read_char();

	void write_char(wchar_t value);

	void write_char16_string(const uint16_t* data, size_t len);

	uint16_t * read_char16_string();

	std::wstring read_wstring();

	void write_wstring(std::wstring const& value);

	void write_wstring(wstring_view value);

	void write_wstring(Wrapper<std::wstring> const& value);

	DateTime read_date_time();

	void write_date_time(DateTime const& date_time);

	template <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>
	T read_enum()
	{
		int32_t x = read_integral<int32_t>();
		return static_cast<T>(x);
	}

	template <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>
	void write_enum(T const& x)
	{
		write_integral<int32_t>(static_cast<int32_t>(x));
	}

	template <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>
	T read_enum_set()
	{
		int32_t x = read_integral<int32_t>();
		return static_cast<T>(x);
	}

	template <typename T, typename = typename std::enable_if_t<util::is_enum_v<T>>>
	void write_enum_set(T const& x)
	{
		write_integral<int32_t>(static_cast<int32_t>(x));
	}

	template <typename T, typename F, typename = typename std::enable_if_t<util::is_same_v<typename util::result_of_t<F()>, T>>>
	opt_or_wrapper<T> read_nullable(F&& reader)
	{
		bool nullable = !read_bool();
		if (nullable)
		{
			return {};
		}
		return {reader()};
	}

	template <typename T, typename F,
		typename = typename std::enable_if_t<util::is_same_v<typename util::result_of_t<F()>, Wrapper<T>>>>
	Wrapper<T> read_nullable(F&& reader)
	{
		bool nullable = !read_bool();
		if (nullable)
		{
			return {};
		}
		return reader();
	}

	template <typename T>
	typename std::enable_if_t<!std::is_abstract<T>::value> write_nullable(
		optional<T> const& value, std::function<void(T const&)> writer)
	{
		if (!value)
		{
			write_bool(false);
		}
		else
		{
			write_bool(true);
			writer(*value);
		}
	}

	template <typename T, typename F>
	typename std::enable_if_t<!util::is_invocable_v<F, Wrapper<T>>> write_nullable(Wrapper<T> const& value, F&& writer)
	{
		if (!value)
		{
			write_bool(false);
		}
		else
		{
			write_bool(true);
			writer(*value);
		}
	}

	template <typename T, typename F>
	typename std::enable_if_t<util::is_invocable_v<F, Wrapper<T>>> write_nullable(Wrapper<T> const& value, F&& writer)
	{
		if (!value)
		{
			write_bool(false);
		}
		else
		{
			write_bool(true);
			writer(value);
		}
	}

	ByteArray getArray() const&;

	ByteArray getArray() &&;

	ByteArray getRealArray() const&;

	ByteArray getRealArray() &&;

	word_t const* data() const;

	word_t* data();

	word_t const* current_pointer() const;

	word_t* current_pointer();

	ByteArray& get_data();
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_UNSAFEBUFFER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Identities.cpp`:

```cpp
#include "protocol/Identities.h"

namespace rd
{
constexpr Identities::IdKind Identities::SERVER;
constexpr Identities::IdKind Identities::CLIENT;

Identities::Identities(IdKind dynamicKind) : id_acc(dynamicKind == IdKind::Client ? BASE_CLIENT_ID : BASE_SERVER_ID)
{
}

RdId Identities::next(const RdId& parent) const
{
	RdId result = parent.mix(id_acc.fetch_add(2));
	return result;
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Identities.h`:

```h
#ifndef RD_CPP_FRAMEWORK_IDENTITIES_H
#define RD_CPP_FRAMEWORK_IDENTITIES_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "protocol/RdId.h"

#include <atomic>

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief Generates unique identifiers for objects in an object graph.
 */
class RD_FRAMEWORK_API Identities
{
private:
	mutable std::atomic_int32_t id_acc;

public:
	enum class IdKind
	{
		Client,
		Server
	};

	constexpr static IdKind SERVER = IdKind::Server;
	constexpr static IdKind CLIENT = IdKind::Client;

	constexpr static int32_t BASE_CLIENT_ID = RdId::MAX_STATIC_ID;

	constexpr static int32_t BASE_SERVER_ID = RdId::MAX_STATIC_ID + 1;

	// region ctor/dtor

	explicit Identities(IdKind dynamicKind);

	virtual ~Identities() = default;
	// endregion

	/**
	 * \brief Generates the next unique identifier.
	 * \param parent previous id which is used for generating.
	 * \return unique identifier.
	 */
	RdId next(const RdId& parent) const;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_FRAMEWORK_IDENTITIES_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/MessageBroker.cpp`:

```cpp
#include "protocol/MessageBroker.h"

#include "spdlog/sinks/stdout_color_sinks.h"

namespace rd
{
std::shared_ptr<spdlog::logger> MessageBroker::logger =
	spdlog::stderr_color_mt<spdlog::synchronous_factory>("logger", spdlog::color_mode::automatic);

static void execute(const IRdReactive* that, Buffer msg)
{
	msg.read_integral<int16_t>();	   // skip context
	that->on_wire_received(std::move(msg));
}

void MessageBroker::invoke(const IRdReactive* that, Buffer msg, bool sync) const
{
	if (sync)
	{
		execute(that, std::move(msg));
	}
	else
	{
		auto action = [this, that, message = std::move(msg)]() mutable {
			bool exists_id = false;
			{
				std::lock_guard<decltype(lock)> guard(lock);
				exists_id = subscriptions.count(that->get_id()) > 0;
			}
			if (exists_id)
			{
				execute(that, std::move(message));
			}
			else
			{
				logger->trace("Disappeared Handler for Reactive entities with id: {}", to_string(that->get_id()));
			}
		};
		std::function<void()> function = util::make_shared_function(std::move(action));
		that->get_wire_scheduler()->queue(std::move(function));
	}
}

MessageBroker::MessageBroker(IScheduler* defaultScheduler) : default_scheduler(defaultScheduler)
{
}

void MessageBroker::dispatch(RdId id, Buffer message) const
{
	RD_ASSERT_MSG(!id.isNull(), "id mustn't be null")

	{	 // synchronized recursively
		std::lock_guard<decltype(lock)> guard(lock);
		IRdReactive const* s = subscriptions[id];
		if (s == nullptr)
		{
			auto it = broker.find(id);
			if (it == broker.end())
			{
				it = broker.emplace(id, Mq{}).first;
			}

			broker[id].default_scheduler_messages.emplace(std::move(message));

			auto action = [this, it, id]() mutable {
				auto& current = it->second;
				IRdReactive const* subscription = subscriptions[id];

				optional<Buffer> message;
				{
					std::lock_guard<decltype(lock)> guard(lock);
					if (!current.default_scheduler_messages.empty())
					{
						message = make_optional<Buffer>(std::move(current.default_scheduler_messages.front()));
						current.default_scheduler_messages.pop();
					}
				}
				if (subscription != nullptr)
				{
					if (message)
					{
						invoke(subscription, *std::move(message), subscription->get_wire_scheduler() == default_scheduler);
					}
				}
				else
				{
					logger->trace("No handler for id: {}", to_string(id));
				}

				if (current.default_scheduler_messages.empty())
				{
					auto t = std::move(broker[id]);
					broker.erase(id);
					for (auto& it : t.custom_scheduler_messages)
					{
						RD_ASSERT_MSG(subscription->get_wire_scheduler() != default_scheduler,
							"require equals of wire and default schedulers")
						invoke(subscription, std::move(it));
					}
				}
			};
			std::function<void()> function = util::make_shared_function(std::move(action));
			default_scheduler->queue(std::move(function));
		}
		else
		{
			if (s->get_wire_scheduler() == default_scheduler || s->get_wire_scheduler()->out_of_order_execution)
			{
				invoke(s, std::move(message));
			}
			else
			{
				auto it = broker.find(id);
				if (it == broker.end())
				{
					invoke(s, std::move(message));
				}
				else
				{
					Mq& mq = it->second;
					mq.custom_scheduler_messages.push_back(std::move(message));
				}
			}
		}
	}

	//        }
}

void MessageBroker::advise_on(Lifetime lifetime, IRdReactive const* entity) const
{
	RD_ASSERT_MSG(!entity->get_id().isNull(), ("id is null for entities: " + std::string(typeid(*entity).name())))

	// advise MUST happen under default scheduler, not custom
	default_scheduler->assert_thread();

	std::lock_guard<decltype(lock)> guard(lock);
	if (!lifetime->is_terminated())
	{
		auto key = entity->get_id();
		IRdReactive const* value = entity;
		subscriptions[key] = value;
		lifetime->add_action([this, key]() { subscriptions.erase(key); });
	}
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/MessageBroker.h`:

```h
#ifndef RD_CPP_MESSAGEBROKER_H
#define RD_CPP_MESSAGEBROKER_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "base/IRdReactive.h"

#include "std/unordered_map.h"

#include "spdlog/spdlog.h"

#include <queue>

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API Mq
{
public:
	// region ctor/dtor

	Mq() = default;

	Mq(Mq const&) = delete;

	Mq& operator=(Mq const&) = delete;

	Mq(Mq&&) = default;

	Mq& operator=(Mq&&) = default;
	// endregion

	mutable std::queue<Buffer> default_scheduler_messages;
	std::vector<Buffer> custom_scheduler_messages;
};

class RD_FRAMEWORK_API MessageBroker final
{
private:
	IScheduler* default_scheduler = nullptr;
	mutable rd::unordered_map<RdId, IRdReactive const*> subscriptions;
	mutable rd::unordered_map<RdId, Mq> broker;

	mutable std::recursive_mutex lock;

	static std::shared_ptr<spdlog::logger> logger;

	void invoke(const IRdReactive* that, Buffer msg, bool sync = false) const;

public:
	// region ctor/dtor

	explicit MessageBroker(IScheduler* defaultScheduler);
	// endregion

	void dispatch(RdId id, Buffer message) const;

	void advise_on(Lifetime lifetime, IRdReactive const* entity) const;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_MESSAGEBROKER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Protocol.cpp`:

```cpp
#include "protocol/Protocol.h"

#include "serialization/SerializationCtx.h"
#include "intern/InternRoot.h"

#include "spdlog/sinks/stdout_color_sinks.h"

#include <utility>

namespace rd
{
std::shared_ptr<spdlog::logger> Protocol::initializationLogger =
	spdlog::stderr_color_mt<spdlog::synchronous_factory>("initializationLogger", spdlog::color_mode::automatic);

constexpr string_view Protocol::InternRootName;

void Protocol::initialize() const
{
	internRoot = std::make_unique<InternRoot>();

	context = std::make_unique<SerializationCtx>(
		serializers.get(), SerializationCtx::roots_t{{util::getPlatformIndependentHash("Protocol"), internRoot.get()}});

	internRoot->set_id(RdId::Null().mix(InternRootName));
	scheduler->queue([this] { internRoot->bind(lifetime, this, InternRootName); });
}

Protocol::Protocol(std::shared_ptr<Identities> identity, IScheduler* scheduler, std::shared_ptr<IWire> wire, Lifetime lifetime)
	: IProtocol(std::move(identity), scheduler, std::move(wire)), lifetime(lifetime)
{
	// initialize();
}

Protocol::Protocol(Identities::IdKind kind, IScheduler* scheduler, std::shared_ptr<IWire> wire, Lifetime lifetime)
	: IProtocol(std::make_shared<Identities>(kind), scheduler, std::move(wire)), lifetime(lifetime)
{
	// initialize();
}

Protocol::~Protocol() = default;

SerializationCtx& Protocol::get_serialization_context() const
{
	if (!context)
	{
		initialize();
	}
	return *context;
}

}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/Protocol.h`:

```h
#ifndef RD_CPP_PROTOCOL_H
#define RD_CPP_PROTOCOL_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "base/IProtocol.h"
#include "protocol/Identities.h"
#include "serialization/SerializationCtx.h"

#include <memory>

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class SerializationCtx;

class InternRoot;
// endregion

/**
 * \brief Top level node in the object graph. It stores [SerializationCtx] for polymorphic "SerDes"
 */
class RD_FRAMEWORK_API Protocol : /*IRdDynamic, */ public IProtocol
{
	constexpr static string_view InternRootName{"ProtocolInternRoot"};

	Lifetime lifetime;

	mutable std::unique_ptr<SerializationCtx> context;

	mutable std::unique_ptr<InternRoot> internRoot;

	// region ctor/dtor
private:
	void initialize() const;

public:
	Protocol(std::shared_ptr<Identities> identity, IScheduler* scheduler, std::shared_ptr<IWire> wire, Lifetime lifetime);

	Protocol(Identities::IdKind, IScheduler* scheduler, std::shared_ptr<IWire> wire, Lifetime lifetime);

	Protocol(Protocol const&) = delete;

	Protocol(Protocol&&) noexcept = default;

	Protocol& operator=(Protocol&&) noexcept = default;

	virtual ~Protocol();
	// endregion

	SerializationCtx& get_serialization_context() const override;

	static std::shared_ptr<spdlog::logger> initializationLogger;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_PROTOCOL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/RdId.cpp`:

```cpp
#include "protocol/RdId.h"

#include "protocol/Identities.h"

namespace rd
{
RdId RdId::read(Buffer& buffer)
{
	const auto number = buffer.read_integral<hash_t>();
	return RdId(number);
}

void RdId::write(Buffer& buffer) const
{
	buffer.write_integral(hash);
}

std::string to_string(RdId const& id)
{
	return std::to_string(id.hash);
}

bool operator==(RdId const& left, RdId const& right)
{
	return left.hash == right.hash;
}

bool operator!=(const RdId& lhs, const RdId& rhs)
{
	return !(rhs == lhs);
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/protocol/RdId.h`:

```h
#ifndef RD_CPP_FRAMEWORK_RDID_H
#define RD_CPP_FRAMEWORK_RDID_H

#include "protocol/Buffer.h"
#include "hashing.h"
#include "std/hash.h"

#include "thirdparty.hpp"

#include <cstdint>
#include <string>

#include <memory>
#include <rd_framework_export.h>

namespace rd
{
class RdId;

template <>
struct RD_FRAMEWORK_API hash<RdId>
{
	size_t operator()(const RdId& value) const noexcept;
};

/**
 * \brief An identifier of the object that participates in the object graph.
 */
class RD_FRAMEWORK_API RdId
{
public:
	using hash_t = util::hash_t;

private:
	friend struct hash<RdId>;

	constexpr static hash_t NULL_ID = 0;

	hash_t hash{NULL_ID};

public:
	friend bool RD_FRAMEWORK_API operator==(RdId const& left, RdId const& right);

	friend bool RD_FRAMEWORK_API operator!=(const RdId& lhs, const RdId& rhs);

	// region ctor/dtor
	constexpr RdId() = default;

	constexpr RdId(const RdId& other) = default;

	constexpr RdId& operator=(const RdId& other) = default;

	constexpr RdId(RdId&& other) noexcept = default;

	constexpr RdId& operator=(RdId&& other) noexcept = default;

	explicit constexpr RdId(hash_t hash) : hash(hash)
	{
	}
	// endregion

	//		static const RdId NULL_ID;

	static constexpr RdId Null()
	{
		return RdId{NULL_ID};
	}

	static constexpr int32_t MAX_STATIC_ID = 1'000'000;

	static RdId read(Buffer& buffer);

	void write(Buffer& buffer) const;

	constexpr hash_t get_hash() const
	{
		return hash;
	}

	constexpr bool isNull() const
	{
		return get_hash() == NULL_ID;
	}

	RdId notNull()
	{
		RD_ASSERT_MSG(!isNull(), "id is null");
		return *this;
	}

	/*template<size_t N>
	constexpr RdId mix(char const (&tail)[N]) const {
		return RdId(util::getPlatformIndependentHash<N>(tail, static_cast<util::constexpr_hash_t>(hash)));
	}*/

	constexpr RdId mix(string_view tail) const
	{
		return RdId(util::getPlatformIndependentHash(tail, static_cast<util::constexpr_hash_t>(hash)));
	}

	/*constexpr RdId mix(int32_t tail) const {
		return RdId(util::getPlatformIndependentHash(tail, static_cast<util::constexpr_hash_t>(hash)));
	}

	*/
	constexpr RdId mix(int64_t tail) const
	{
		return RdId(util::getPlatformIndependentHash(tail, static_cast<util::constexpr_hash_t>(hash)));
	}

	friend std::string RD_FRAMEWORK_API to_string(RdId const& id);
};

inline size_t hash<RdId>::operator()(const RdId& value) const noexcept
{
	return hash<RdId::hash_t>()(value.hash);
}
}	 // namespace rd

#endif	  // RD_CPP_FRAMEWORK_RDID_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/SimpleScheduler.cpp`:

```cpp
#include "SimpleScheduler.h"

namespace rd
{
void SimpleScheduler::flush()
{
}

void SimpleScheduler::queue(std::function<void()> action)
{
	action();
}

bool SimpleScheduler::is_active() const
{
	return true;
}
}	 // namespace rd
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/SimpleScheduler.h`:

```h
#ifndef RD_CPP_TESTSCHEDULER_H
#define RD_CPP_TESTSCHEDULER_H

#include "scheduler/base/IScheduler.h"

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief simple scheduler, which immediately invoke action on queue, and is always active.
 */
class RD_FRAMEWORK_API SimpleScheduler : public IScheduler
{
public:
	// region ctor/dtor
	SimpleScheduler() = default;

	virtual ~SimpleScheduler() = default;
	// endregion

	void flush() override;

	void queue(std::function<void()> action) override;

	bool is_active() const override;
};
}	 // namespace rd

#endif	  // RD_CPP_TESTSCHEDULER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/SingleThreadScheduler.cpp`:

```cpp
#include "SingleThreadScheduler.h"

#include <utility>

#include "ctpl_stl.h"

namespace rd
{
SingleThreadScheduler::SingleThreadScheduler(Lifetime lifetime, std::string name)
	: SingleThreadSchedulerBase(std::move(name)), lifetime(lifetime)
{
	lifetime->add_action([this]() {
		try
		{
			pool->stop(true);
		}
		catch (std::exception const& e)
		{
			(void)e;
			log->error("Failed to terminate {}", this->name);
		}
	});
}
}	 // namespace rd
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/SingleThreadScheduler.h`:

```h
#ifndef RD_CPP_SINGLETHREADSCHEDULER_H
#define RD_CPP_SINGLETHREADSCHEDULER_H

#include "base/SingleThreadSchedulerBase.h"

#include "lifetime/Lifetime.h"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API SingleThreadScheduler : public SingleThreadSchedulerBase
{
public:
	Lifetime lifetime;

	SingleThreadScheduler(Lifetime lifetime, std::string name);
};
}	 // namespace rd

#endif	  // RD_CPP_SINGLETHREADSCHEDULER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/SynchronousScheduler.cpp`:

```cpp
#include "SynchronousScheduler.h"

#include "guards.h"

namespace rd
{
static thread_local int32_t SynchronousScheduler_active_count = 0;

void SynchronousScheduler::queue(std::function<void()> action)
{
	util::increment_guard<int32_t> guard(SynchronousScheduler_active_count);
	action();
}

void SynchronousScheduler::flush()
{
}

bool SynchronousScheduler::is_active() const
{
	return SynchronousScheduler_active_count > 0;
}
}	 // namespace rd
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/SynchronousScheduler.h`:

```h
#ifndef RD_CPP_SYNCHRONOUSSCHEDULER_H
#define RD_CPP_SYNCHRONOUSSCHEDULER_H

#include "scheduler/base/IScheduler.h"

#include "guards.h"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API SynchronousScheduler : public IScheduler
{
public:
	// region ctor/dtor

	SynchronousScheduler() = default;

	SynchronousScheduler(SynchronousScheduler const&) = delete;

	SynchronousScheduler(SynchronousScheduler&&) = delete;

	virtual ~SynchronousScheduler() = default;
	// endregion

	void queue(std::function<void()> action) override;

	void flush() override;

	bool is_active() const override;

	/**
	 * \brief global synchronous scheduler for whole application.
	 */
	static SynchronousScheduler& Instance()
	{
		static SynchronousScheduler globalSynchronousScheduler;
		return globalSynchronousScheduler;
	}
};

}	 // namespace rd

#endif	  // RD_CPP_SYNCHRONOUSSCHEDULER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/base/IScheduler.cpp`:

```cpp
#include "IScheduler.h"

#include "spdlog/spdlog.h"

#include <functional>
#include <sstream>

namespace rd
{
void IScheduler::assert_thread() const
{
	if (!is_active())
	{
		std::ostringstream msg;
		msg << "Illegal scheduler for current action. Must be " << thread_id << ", was " << std::this_thread::get_id();
		spdlog::error(msg.str());
	}
}

void IScheduler::invoke_or_queue(std::function<void()> action)
{
	if (is_active())
	{
		action();
	}
	else
	{
		queue(action);
	}
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/base/IScheduler.h`:

```h
#ifndef RD_CPP_ISCHEDULER_H
#define RD_CPP_ISCHEDULER_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <functional>
#include <thread>

#include <rd_framework_export.h>

namespace rd
{
/**
 * \brief Allows to queue the execution of actions on a different thread.
 */
class RD_FRAMEWORK_API IScheduler
{
protected:
	std::thread::id thread_id;

public:
	// region ctor/dtor

	IScheduler() = default;

	virtual ~IScheduler() = default;
	// endregion

	/**
	 * \brief Queues the execution of the given [action].
	 *
	 * \param action to be queued.
	 */
	virtual void queue(std::function<void()> action) = 0;

	// TO-DO
	bool out_of_order_execution = false;

	virtual void assert_thread() const;

	/**
	 * \brief invoke action immediately if scheduler is active, queue it otherwise.
	 * \param action to be invoked
	 */
	virtual void invoke_or_queue(std::function<void()> action);

	virtual void flush() = 0;

	virtual bool is_active() const = 0;

	std::thread::id get_thread_id() const
	{
		return thread_id;
	}
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_ISCHEDULER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/base/SingleThreadSchedulerBase.cpp`:

```cpp
#include "SingleThreadSchedulerBase.h"

#include "util/core_util.h"

#include "ctpl_stl.h"
#include "spdlog/include/spdlog/sinks/stdout_color_sinks.h"

namespace rd
{
SingleThreadSchedulerBase::PoolTask::PoolTask(std::function<void()> f, SingleThreadSchedulerBase* scheduler)
	: f(std::move(f)), scheduler(scheduler)
{
}

void SingleThreadSchedulerBase::PoolTask::operator()(int id) const
{
	try
	{
		f();
		--scheduler->tasks_executing;
	}
	catch (std::exception const& e)
	{
		scheduler->log->error("Background task failed, scheduler={}, thread_id={} | {}", scheduler->name, id, e.what());
		--scheduler->tasks_executing;
	}
}

SingleThreadSchedulerBase::SingleThreadSchedulerBase(std::string name)
	: log(spdlog::stderr_color_mt<spdlog::synchronous_factory>(name, spdlog::color_mode::automatic))
	, name(std::move(name))
	, pool(std::make_unique<ctpl::thread_pool>(1))
{
	RD_ASSERT_THROW_MSG(pool->size() == 1, "Thread pool wasn't properly initalized");
	thread_id = pool->get_thread(0).get_id();
}

void SingleThreadSchedulerBase::flush()
{
	RD_ASSERT_MSG(!is_active(), "Can't flush this scheduler in a reentrant way: we are inside queued item's execution");

	while (tasks_executing != 0)
	{
		std::this_thread::yield();
	}
}

void SingleThreadSchedulerBase::queue(std::function<void()> action)
{
	++tasks_executing;
	PoolTask task(action, this);
	pool->push(std::move(task));
}

bool SingleThreadSchedulerBase::is_active() const
{
	return thread_id == std::this_thread::get_id();
}

SingleThreadSchedulerBase::~SingleThreadSchedulerBase() = default;
}	 // namespace rd
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/scheduler/base/SingleThreadSchedulerBase.h`:

```h
#ifndef RD_CPP_SINGLETHREADSCHEDULERBASE_H
#define RD_CPP_SINGLETHREADSCHEDULERBASE_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "scheduler/base/IScheduler.h"
#include "lifetime/Lifetime.h"
#include "spdlog/spdlog.h"

#include <utility>

#include <rd_framework_export.h>

namespace ctpl
{
class thread_pool;
}

namespace rd
{
class RD_FRAMEWORK_API SingleThreadSchedulerBase : public IScheduler
{
protected:
	std::shared_ptr<spdlog::logger> log;
	std::string name;

	std::atomic_uint32_t tasks_executing{0};
	std::atomic_uint32_t active{0};
	std::unique_ptr<ctpl::thread_pool> pool;

	class PoolTask
	{
		std::function<void()> f;
		SingleThreadSchedulerBase* scheduler;

	public:
		explicit PoolTask(std::function<void()> f, SingleThreadSchedulerBase* scheduler);

		void operator()(int id) const;
	};

public:
	// region ctor/dtor
	SingleThreadSchedulerBase(std::string name);

	virtual ~SingleThreadSchedulerBase();
	// endregion

	void flush() override;

	void queue(std::function<void()> action) override;

	bool is_active() const override;
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_SINGLETHREADSCHEDULERBASE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/AbstractPolymorphic.h`:

```h
#ifndef RD_CPP_ABSTRACTPOLYMORPHIC_H
#define RD_CPP_ABSTRACTPOLYMORPHIC_H

#include "types/wrapper.h"
#include "serialization/Polymorphic.h"
#include "serialization/SerializationCtx.h"

namespace rd
{
template <typename T>
class AbstractPolymorphic
{
public:
	static value_or_wrapper<T> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return ctx.get_serializers().readPolymorphicNullable<T>(ctx, buffer);
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, T const& value)
	{
		ctx.get_serializers().writePolymorphicNullable(ctx, buffer, value);
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<T> const& value)
	{
		ctx.get_serializers().writePolymorphicNullable(ctx, buffer, *value);
	}
};
}	 // namespace rd

#endif	  // RD_CPP_ABSTRACTPOLYMORPHIC_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/ArraySerializer.h`:

```h
#ifndef RD_CPP_ARRAYSERIALIZER_H
#define RD_CPP_ARRAYSERIALIZER_H

#include "serialization/SerializationCtx.h"
#include "framework_traits.h"

#include <vector>

namespace rd
{
template <typename S, template <class, class> class C, typename T = typename util::read_t<S>,
	typename A = allocator<value_or_wrapper<T>>>
class ArraySerializer
{
public:
	static C<value_or_wrapper<T>, A> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return buffer.read_array<C, T, A>([&] { return S::read(ctx, buffer); });
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, C<value_or_wrapper<T>, A> const& value)
	{
		buffer.write_array<C, T, A>(value, [&](T const& inner_value) { S::write(ctx, buffer, inner_value); });
	}
};
}	 // namespace rd

#endif	  // RD_CPP_ARRAYSERIALIZER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/DefaultAbstractDeclaration.cpp`:

```cpp
#include "DefaultAbstractDeclaration.h"

namespace rd
{
const std::string DefaultAbstractDeclaration::not_registered_error_message =
	"Maybe you forgot to invoke 'register()' method of corresponding Toplevel. "
	"Usually it should be done automatically during 'bind()' invocation but in complex cases you should do it manually.";

Wrapper<DefaultAbstractDeclaration> DefaultAbstractDeclaration::readUnknownInstance(
	SerializationCtx& /*ctx*/, Buffer& /*buffer*/, RdId const& unknownId, int32_t /*size*/)
{
	throw std::invalid_argument("Can't find reader by id: " + to_string(unknownId) + not_registered_error_message);
}

std::string DefaultAbstractDeclaration::type_name() const
{
	return "DefaultAbstractDeclaration";
}

bool DefaultAbstractDeclaration::equals(ISerializable const& /*serializable*/) const
{
	return false;
}

void DefaultAbstractDeclaration::write(SerializationCtx& /*ctx*/, Buffer& /*buffer*/) const
{
	throw std::invalid_argument("DefaultAbstractDeclaration couldn't be written");
}
}	 // namespace rd
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/DefaultAbstractDeclaration.h`:

```h
#ifndef RD_CPP_DEFAULTABSTRACTDECLARATION_H
#define RD_CPP_DEFAULTABSTRACTDECLARATION_H

#include "types/wrapper.h"
#include "protocol/RdId.h"
#include "serialization/ISerializable.h"
#include "base/IUnknownInstance.h"

namespace rd
{
// region predeclared

class SerializationCtx;

class Buffer;
// endregion

class DefaultAbstractDeclaration : public IPolymorphicSerializable, public IUnknownInstance
{
	const static std::string not_registered_error_message;

public:
	static Wrapper<DefaultAbstractDeclaration> readUnknownInstance(
		SerializationCtx& ctx, Buffer& buffer, RdId const& unknownId, int32_t size);

	std::string type_name() const override;

	bool equals(ISerializable const& serializable) const override;

	void write(SerializationCtx& ctx, Buffer& buffer) const override;
};
}	 // namespace rd

#endif	  // RD_CPP_DEFAULTABSTRACTDECLARATION_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/ISerializable.cpp`:

```cpp
#include "serialization/ISerializable.h"

#include "std/hash.h"

namespace rd
{
size_t IPolymorphicSerializable::hashCode() const noexcept
{
	return rd::hash<void const*>()(static_cast<void const*>(this));
}

bool operator==(const IPolymorphicSerializable& lhs, const IPolymorphicSerializable& rhs)
{
	return lhs.equals(rhs);
}

bool operator!=(const IPolymorphicSerializable& lhs, const IPolymorphicSerializable& rhs)
{
	return !(lhs == rhs);
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/ISerializable.h`:

```h
#ifndef RD_CPP_ISERIALIZABLE_H
#define RD_CPP_ISERIALIZABLE_H

#include <string>

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class Buffer;

class SerializationCtx;
// endregion

/**
 * \brief Provides \ref write for serialization to be overriden. For deserialization derived class must have static
 * method read. See examples for more information.
 */
class RD_FRAMEWORK_API ISerializable
{
public:
	virtual ~ISerializable() = default;

	virtual void write(SerializationCtx& ctx, Buffer& buffer) const = 0;
};

/**
 * \brief Dynamically polymorhic node.
 */
class RD_FRAMEWORK_API IPolymorphicSerializable : public ISerializable
{
public:
	/**
	 * \return actual class's name as written in source code.
	 */
	virtual std::string type_name()
		const = 0 /*{ throw std::invalid_argument("type doesn't support polymorphic serialization"); }*/;

	//		virtual bool equals(IPolymorphicSerializable const& object) const = 0;

	virtual size_t hashCode() const noexcept;

	virtual std::string toString() const = 0;

	virtual bool equals(ISerializable const&) const = 0;

	friend bool RD_FRAMEWORK_API operator==(const IPolymorphicSerializable& lhs, const IPolymorphicSerializable& rhs);

	friend bool RD_FRAMEWORK_API operator!=(const IPolymorphicSerializable& lhs, const IPolymorphicSerializable& rhs);
};
}	 // namespace rd

namespace std
{
template <>
struct RD_FRAMEWORK_API hash<rd::IPolymorphicSerializable>
{
	size_t operator()(const rd::IPolymorphicSerializable& value) const noexcept
	{
		return value.hashCode();
	}
};
}	 // namespace std

#endif	  // RD_CPP_ISERIALIZABLE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/InternedAnySerializer.h`:

```h
#ifndef RD_CPP_ANYSERIALIZER_H
#define RD_CPP_ANYSERIALIZER_H

#include "serialization/SerializationCtx.h"
#include "serialization/RdAny.h"

#include "thirdparty.hpp"

namespace rd
{
// region predeclared

class Buffer;
// endregion

class InternedAnySerializer
{
public:
	static optional<InternedAny> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return ctx.get_serializers().readAny(ctx, buffer);
	}

	template <typename T>
	static void write(SerializationCtx& ctx, Buffer& buffer, T const& value)
	{
		ctx.get_serializers().writePolymorphicNullable(ctx, buffer, value);
	}
};
}	 // namespace rd

#endif	  // RD_CPP_ANYSERIALIZER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/InternedSerializer.h`:

```h
#ifndef RD_CPP_INTERNEDSERIALIZER_H
#define RD_CPP_INTERNEDSERIALIZER_H

#include "serialization/SerializationCtx.h"
#include "serialization/Polymorphic.h"
#include "framework_traits.h"

namespace rd
{
template <typename S, util::hash_t InternKey, typename T = typename util::read_t<S>>
class InternedSerializer
{
public:
	static Wrapper<T> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return ctx.readInterned<T, InternKey>(buffer, [&](SerializationCtx&, Buffer&) { return S::read(ctx, buffer); });
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<T> const& value)
	{
		ctx.writeInterned<T, InternKey>(buffer, value,
			[&](SerializationCtx&, Buffer&, T const& inner_value) mutable -> void { S::write(ctx, buffer, inner_value); });
	}
};
}	 // namespace rd
#endif	  // RD_CPP_INTERNEDSERIALIZER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/NullableSerializer.h`:

```h
#ifndef RD_CPP_NULLABLESERIALIZER_H
#define RD_CPP_NULLABLESERIALIZER_H

#include "serialization/Polymorphic.h"
#include "serialization/AbstractPolymorphic.h"
#include "types/wrapper.h"
#include "framework_traits.h"

#include <type_traits>

namespace rd
{
template <typename S, typename R = void>
class NullableSerializer
{
	using T = typename util::read_t<S>;

public:
	static opt_or_wrapper<T> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return buffer.read_nullable<T>([&]() -> T { return S::read(ctx, buffer); });
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, optional<T> const& value)
	{
		buffer.write_nullable<T>(value, [&](T const& inner_value) { S::write(ctx, buffer, inner_value); });
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<T> const& value)
	{
		buffer.write_nullable<T>(value, [&](T const& inner_value) { S::write(ctx, buffer, inner_value); });
	}
};

template <typename S>
class NullableSerializer<S, std::enable_if_t<is_wrapper_v<util::read_t<S>>>>
{
	using W = typename util::read_t<S>;
	using T = typename W::type;

public:
	static Wrapper<T> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return buffer.read_nullable<T>([&]() -> Wrapper<T> { return S::read(ctx, buffer); });
	}

	static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<T> const& value)
	{
		buffer.write_nullable<T>(value, [&](T const& inner_value) { S::write(ctx, buffer, inner_value); });
	}
};
}	 // namespace rd

#endif	  // RD_CPP_NULLABLESERIALIZER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/Polymorphic.cpp`:

```cpp
#include "Polymorphic.h"

namespace rd
{
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/Polymorphic.h`:

```h
#ifndef RD_CPP_POLYMORPHIC_H
#define RD_CPP_POLYMORPHIC_H

#include "protocol/Buffer.h"
#include "base/RdReactiveBase.h"

#include <type_traits>

namespace rd
{
// region predeclared

class SerializationCtx;
// endregion

/**
 * \brief Maintains "SerDes" for statically polymorphic type [T].
 * Requires static "read" and "write" methods as in common case below.
 * \tparam T type to "SerDes"
 * \tparam R trait specialisation (void by default)
 */
template <typename T, typename R = void>
class Polymorphic
{
public:
	inline static T read(SerializationCtx& ctx, Buffer& buffer)
	{
		return T::read(ctx, buffer);
	}

	inline static void write(SerializationCtx& ctx, Buffer& buffer, T const& value)
	{
		value.write(ctx, buffer);
	}

	inline static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<T> const& value)
	{
		value->write(ctx, buffer);
	}
};

template <typename T>
class Polymorphic<T, typename std::enable_if_t<std::is_integral<T>::value>>
{
public:
	inline static T read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_integral<T>();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, T const& value)
	{
		buffer.write_integral<T>(value);
	}
};

template <typename T>
class Polymorphic<T, typename std::enable_if_t<std::is_floating_point<T>::value>>
{
public:
	inline static T read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_floating_point<T>();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, T const& value)
	{
		buffer.write_floating_point<T>(value);
	}
};

// class Polymorphic<int, void>;

template <template <class, class> class C, typename T, typename A>
class Polymorphic<C<T, A>, typename std::enable_if_t<!util::is_base_of_v<RdReactiveBase, T> &&
													 !util::is_same_v<Wrapper<T, A>, C<T, A>>>>
{
public:
	inline static C<T, A> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_array<C, T, A>();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, C<T, A> const& value)
	{
		buffer.write_array<C, T, A>(value);
	}
};

template <>
class Polymorphic<bool>
{
public:
	inline static bool read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_bool();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, bool const& value)
	{
		buffer.write_bool(value);
	}
};

template <>
class Polymorphic<wchar_t>
{
public:
	inline static wchar_t read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_char();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, bool const& value)
	{
		buffer.write_char(value);
	}
};

template <>
class Polymorphic<std::wstring>
{
public:
	inline static std::wstring read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_wstring();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, std::wstring const& value)
	{
		buffer.write_wstring(value);
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, Wrapper<std::wstring> const& value)
	{
		buffer.write_wstring(*value);
	}
};

template <>
class Polymorphic<DateTime>
{
public:
	inline static DateTime read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_date_time();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, DateTime const& value)
	{
		buffer.write_date_time(value);
	}
};

template <>
class Polymorphic<Void>
{
public:
	inline static Void read(SerializationCtx& /*ctx*/, Buffer& /*buffer*/)
	{
		return {};
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& /*buffer*/, Void const& /*value*/)
	{
	}
};

template <typename T>
class Polymorphic<T, typename std::enable_if_t<util::is_base_of_v<RdReactiveBase, T>>>
{
public:
	inline static T read(SerializationCtx& ctx, Buffer& buffer)
	{
		return T::read(ctx, buffer);
	}

	inline static void write(SerializationCtx& ctx, Buffer& buffer, T const& value)
	{
		value.write(ctx, buffer);
	}
};

template <typename T>
class Polymorphic<T, typename std::enable_if_t<util::is_enum_v<T>>>
{
public:
	inline static T read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		return buffer.read_enum<T>();
	}

	inline static void write(SerializationCtx& /*ctx*/, Buffer& buffer, T const& value)
	{
		buffer.write_enum<T>(value);
	}
};

template <typename T>
class Polymorphic<optional<T>>
{
public:
	inline static optional<T> read(SerializationCtx& ctx, Buffer& buffer)
	{
		return buffer.read_nullable<T>([&ctx, &buffer]() { return Polymorphic<T>::read(ctx, buffer); });
	}

	inline static void write(SerializationCtx& ctx, Buffer& buffer, optional<T> const& value)
	{
		buffer.write_nullable<T>(value, [&ctx, &buffer](T const& v) { Polymorphic<T>::write(ctx, buffer, v); });
	}
};

template <typename T, typename A>
class Polymorphic<Wrapper<T, A>>
{
public:
	inline static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<T, A> const& value)
	{
		value->write(ctx, buffer);
	}
};
}	 // namespace rd

#endif	  // RD_CPP_POLYMORPHIC_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/RdAny.cpp`:

```cpp
#include "RdAny.h"

namespace rd
{
namespace any
{
}
}	 // namespace rd
```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/RdAny.h`:

```h
#ifndef RD_CPP_ANY_H
#define RD_CPP_ANY_H

#include "util/core_util.h"
#include "types/wrapper.h"
#include "serialization/ISerializable.h"

#include "thirdparty.hpp"

#include <memory>
#include <string>
#include <cstring>

namespace rd
{
namespace any
{
using super_t = IPolymorphicSerializable;
using wrapped_super_t = Wrapper<super_t>;
using string = Wrapper<std::wstring>;
}	 // namespace any
/**
 * \brief Presents union type to be interned. It may be either \link std::wstring,
 * either \link rd::IPolymorphicSerializable.
 */
using InternedAny = variant<any::wrapped_super_t, any::string>;

namespace any
{
template <typename T>
InternedAny make_interned_any(Wrapper<T> wrapper)
{
	return {wrapped_super_t(wrapper)};
}

template <>
inline InternedAny make_interned_any<std::wstring>(Wrapper<std::wstring> wrapper)
{
	return {wrapper};
}

template <typename T, typename Any>
typename std::enable_if_t<!util::is_base_of_v<IPolymorphicSerializable, T>, any::string> get(Any const& any)
{
	return get<string>(any);
}

template <typename T, typename Any>
typename std::enable_if_t<util::is_base_of_v<IPolymorphicSerializable, T>, Wrapper<T>> get(Any&& any)
{
	return Wrapper<T>::dynamic(get<wrapped_super_t>(std::forward<Any>(any)));
}

struct TransparentKeyEqual
{
	using is_transparent = void;

	bool operator()(InternedAny const& val_l, InternedAny const& val_r) const
	{
		return val_l == val_r;
	}

	bool operator()(InternedAny const& val_l, wrapped_super_t const& val_r) const
	{
		return visit(util::make_visitor(
						 [&](wrapped_super_t const& value) { return *value == *val_r; }, [](any::string const&) { return false; }),
			val_l);
	}

	bool operator()(super_t const& val_l, InternedAny const& val_r) const
	{
		return operator()(val_r, val_l);
	}

	bool operator()(InternedAny const& val_l, super_t const& val_r) const
	{
		return visit(util::make_visitor(
						 [&](wrapped_super_t const& value) { return *value == val_r; }, [](any::string const&) { return false; }),
			val_l);
	}

	bool operator()(wrapped_super_t const& val_l, InternedAny const& val_r) const
	{
		return operator()(val_r, val_l);
	}

	bool operator()(InternedAny const& val_l, any::string const& val_r) const
	{
		return visit(util::make_visitor(
						 [](wrapped_super_t const& /*value*/) { return false; }, [&](any::string const& s) { return s == val_r; }),
			val_l);
	}

	bool operator()(any::string const& val_l, InternedAny const& val_r) const
	{
		return operator()(val_r, val_l);
	}
};

struct TransparentHash
{
	using is_transparent = void;
	using transparent_key_equal = std::equal_to<>;

	size_t operator()(InternedAny const& value) const noexcept
	{
		return visit(util::make_visitor([](wrapped_super_t const& value) { return rd::hash<wrapped_super_t>()(value); },
						 [](any::string const& value) { return rd::hash<any::string>()(value); }),
			value);
	}

	size_t operator()(wrapped_super_t const& value) const noexcept
	{
		return rd::hash<wrapped_super_t>()(value);
	}

	size_t operator()(super_t const& value) const noexcept
	{
		return rd::hash<super_t>()(value);
	}

	size_t operator()(any::string const& value) const noexcept
	{
		return rd::hash<any::string>()(value);
	}
};
}	 // namespace any
}	 // namespace rd

static_assert(!std::is_trivially_copy_constructible<rd::Wrapper<rd::IPolymorphicSerializable>>::value,
	"wrapper mustn't be trivially_copy_constructible");

#endif	  // RD_CPP_ANY_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/SerializationCtx.cpp`:

```cpp
#include "SerializationCtx.h"

namespace rd
{
//	SerializationCtx::SerializationCtx(const IProtocol &protocol) : serializers(protocol.serializers.get()) {}

//	SerializationCtx::SerializationCtx(const Serializers *const serializers) : serializers(serializers) {}

SerializationCtx::SerializationCtx(const Serializers* serializers, roots_t intern_roots)
	: serializers(serializers), intern_roots(std::move(intern_roots))
{
}

SerializationCtx SerializationCtx::withInternRootsHere(
	RdBindableBase const& owner, std::initializer_list<std::string> new_roots) const
{
	roots_t next_roots = intern_roots;
	for (const auto& item : new_roots)
	{
		auto const& name = "InternRoot-" + item;
		InternRoot const& root = owner.getOrCreateExtension<InternRoot>(name);
		withId(root, owner.get_id().mix(".").mix(name));
		next_roots.emplace(util::getPlatformIndependentHash(item), &root);
	}
	return SerializationCtx(serializers, std::move(next_roots));
}

Serializers const& SerializationCtx::get_serializers() const
{
	return *serializers;
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/SerializationCtx.h`:

```h
#ifndef RD_CPP_FRAMEWORK_SERIALIZATIONCTX_H
#define RD_CPP_FRAMEWORK_SERIALIZATIONCTX_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "protocol/Buffer.h"
#include "protocol/RdId.h"

#include "std/unordered_map.h"

#include <functional>
#include <string>
#include <utility>
#include <regex>

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class IProtocol;

class Serializers;

class InternRoot;

class RdBindableBase;
// endregion

class RD_FRAMEWORK_API SerializationCtx
{
	Serializers const* serializers = nullptr;

public:
	using roots_t = rd::unordered_map<util::hash_t, InternRoot const*>;

	roots_t intern_roots{};

	// region ctor/dtor

	//    SerializationCtx() = delete;

	SerializationCtx(SerializationCtx const& other) = delete;

	SerializationCtx& operator=(SerializationCtx const& other) = delete;

	SerializationCtx(SerializationCtx&& other) = default;

	SerializationCtx& operator=(SerializationCtx&& other) = default;

	//		explicit SerializationCtx(const Serializers *serializers = nullptr);

	explicit SerializationCtx(const Serializers* serializers, roots_t intern_roots = {});

	SerializationCtx withInternRootsHere(RdBindableBase const& owner, std::initializer_list<std::string> new_roots) const;

	// endregion

	template <typename T, util::hash_t InternKey>
	Wrapper<T> readInterned(Buffer& buffer, std::function<T(SerializationCtx&, Buffer&)> readValueDelegate);

	template <typename T, util::hash_t InternKey, typename F,
		typename = typename std::enable_if_t<util::is_invocable<F, SerializationCtx&, Buffer&, T>::value> >
	void writeInterned(Buffer& buffer, Wrapper<T> const& value, F&& writeValueDelegate);

	Serializers const& get_serializers() const;
};
}	 // namespace rd

#include "intern/InternRoot.h"

namespace rd
{
template <typename T, util::hash_t InternKey>
Wrapper<T> SerializationCtx::readInterned(Buffer& buffer, std::function<T(SerializationCtx&, Buffer&)> readValueDelegate)
{
	auto it = intern_roots.find(InternKey);
	if (it != intern_roots.end())
	{
		int32_t index = buffer.read_integral<int32_t>() ^ 1;
		return it->second->un_intern_value<T>(index);
	}
	else
	{
		return wrapper::make_wrapper<T>(readValueDelegate(*this, buffer));
	}
}

template <typename T, util::hash_t InternKey, typename F, typename>
void SerializationCtx::writeInterned(Buffer& buffer, const Wrapper<T>& value, F&& writeValueDelegate)
{
	auto it = intern_roots.find(InternKey);
	if (it != intern_roots.end())
	{
		int32_t index = it->second->intern_value<T>(value);
		buffer.write_integral<int32_t>(index);
	}
	else
	{
		writeValueDelegate(const_cast<SerializationCtx&>(*this), buffer, *value);
	}
}
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#endif	  // RD_CPP_FRAMEWORK_SERIALIZATIONCTX_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/Serializers.cpp`:

```cpp
#include "Serializers.h"

#include "serialization/AbstractPolymorphic.h"

namespace rd
{
constexpr RdId STRING_PREDEFINED_ID = RdId(10);

RdId Serializers::real_rd_id(const IUnknownInstance& value)
{
	return value.unknownId;
}

RdId Serializers::real_rd_id(const IPolymorphicSerializable& value)
{
	return RdId(util::getPlatformIndependentHash(value.type_name()));
}

RdId Serializers::real_rd_id(const std::wstring& /*value*/)
{
	return STRING_PREDEFINED_ID;
}

void Serializers::real_write(SerializationCtx& /*ctx*/, Buffer& buffer, IUnknownInstance const& value)
{
	value.unknownId.write(buffer);
}

void Serializers::real_write(SerializationCtx& ctx, Buffer& buffer, IPolymorphicSerializable const& value)
{
	value.write(ctx, buffer);
}

void Serializers::real_write(SerializationCtx& ctx, Buffer& buffer, std::wstring const& value)
{
	Polymorphic<std::wstring>::write(ctx, buffer, value);
}

void Serializers::register_in()
{
	readers[STRING_PREDEFINED_ID] = [](SerializationCtx& ctx, Buffer& buffer) -> InternedAny {
		return {wrapper::make_wrapper<std::wstring>(Polymorphic<std::wstring>::read(ctx, buffer))};
	};
}

Serializers::Serializers()
{
	register_in();
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/serialization/Serializers.h`:

```h
#ifndef RD_CPP_SERIALIZERS_H
#define RD_CPP_SERIALIZERS_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "protocol/RdId.h"
#include "serialization/ISerializable.h"
#include "protocol/Identities.h"
#include "base/IUnknownInstance.h"
#include "hashing.h"
#include "serialization/RdAny.h"
#include "DefaultAbstractDeclaration.h"

#include "std/unordered_map.h"

#include <utility>
#include <iostream>
#include <unordered_set>

#include <rd_framework_export.h>

namespace rd
{
// region predeclared

class SerializationCtx;
// endregion

class RD_FRAMEWORK_API Serializers
{
private:
	static RdId real_rd_id(IUnknownInstance const& value);

	static RdId real_rd_id(IPolymorphicSerializable const& value);

	static RdId real_rd_id(std::wstring const& value);

	static void real_write(SerializationCtx& ctx, Buffer& buffer, IUnknownInstance const& value);

	static void real_write(SerializationCtx& ctx, Buffer& buffer, IPolymorphicSerializable const& value);

	static void real_write(SerializationCtx& ctx, Buffer& buffer, std::wstring const& value);

	void register_in();

	mutable rd::unordered_map<RdId, std::function<InternedAny(SerializationCtx&, Buffer&)>> readers;

public:
	Serializers();

	template <typename T, typename = typename std::enable_if_t<util::is_base_of_v<IPolymorphicSerializable, T>>>
	void registry() const;

	template <typename T = DefaultAbstractDeclaration>
	optional<InternedAny> readAny(SerializationCtx& ctx, Buffer& buffer) const;

	template <typename T>
	value_or_wrapper<T> readPolymorphicNullable(SerializationCtx& ctx, Buffer& buffer) const;

	template <typename T /*, typename = typename std::enable_if<std::is_base_of<IPolymorphicSerializable, T>::value>::type*/>
	void writePolymorphicNullable(SerializationCtx& ctx, Buffer& buffer, const T& value) const;

	template <typename T>
	value_or_wrapper<T> readPolymorphic(SerializationCtx& ctx, Buffer& buffer) const;

	template <typename T>
	void writePolymorphic(SerializationCtx& ctx, Buffer& stream, const Wrapper<T>& value) const;

	template <typename T>
	void writePolymorphic(SerializationCtx& ctx, Buffer& stream, T const& value) const;
};
}	 // namespace rd

namespace rd
{
template <typename T, typename>
void Serializers::registry() const
{
	std::string type_name = T::static_type_name();
	util::hash_t h = util::getPlatformIndependentHash(type_name);
	RdId id(h);

	RD_ASSERT_MSG(readers.count(id) == 0, "Can't register " + type_name + " with id: " + to_string(id));

	readers[id] = [](SerializationCtx& ctx, Buffer& buffer) -> Wrapper<IPolymorphicSerializable> {
		return wrapper::make_wrapper<T>(T::read(ctx, buffer));
	};
}

template <typename T>
optional<InternedAny> Serializers::readAny(SerializationCtx& ctx, Buffer& buffer) const
{
	RdId id = RdId::read(buffer);
	if (id.isNull())
	{
		return nullopt;
	}
	int32_t size = buffer.read_integral<int32_t>();
	buffer.check_available(static_cast<size_t>(size));

	if (readers.count(id) == 0)
	{
		return any::make_interned_any<T>(T::readUnknownInstance(ctx, buffer, id, size));
	}
	auto const& reader = readers.at(id);
	return reader(ctx, buffer);
}

template <typename T>
value_or_wrapper<T> Serializers::readPolymorphicNullable(SerializationCtx& ctx, Buffer& buffer) const
{
	optional<InternedAny> any = readAny<T>(ctx, buffer);
	return any::get<T>(*(std::move(any)));
}

template <typename T /*, typename*/>
void Serializers::writePolymorphicNullable(SerializationCtx& ctx, Buffer& buffer, const T& value) const
{
	real_rd_id(value).write(buffer);

	int32_t length_tag_position = static_cast<int32_t>(buffer.get_position());
	buffer.write_integral<int32_t>(0);
	int32_t object_start_position = static_cast<int32_t>(buffer.get_position());
	real_write(ctx, buffer, value);
	//		value.write(ctx, buffer);
	int32_t object_end_position = static_cast<int32_t>(buffer.get_position());
	buffer.set_position(static_cast<size_t>(length_tag_position));
	buffer.write_integral<int32_t>(object_end_position - object_start_position);
	buffer.set_position(static_cast<size_t>(object_end_position));
}

template <typename T>
value_or_wrapper<T> Serializers::readPolymorphic(SerializationCtx& ctx, Buffer& buffer) const
{
	return readPolymorphicNullable<T>(ctx, buffer);
}

template <typename T>
void Serializers::writePolymorphic(SerializationCtx& ctx, Buffer& stream, const Wrapper<T>& value) const
{
	writePolymorphicNullable(ctx, stream, *value);
}

template <typename T>
void Serializers::writePolymorphic(SerializationCtx& ctx, Buffer& stream, T const& value) const
{
	writePolymorphicNullable(ctx, stream, value);
}
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_SERIALIZERS_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/RdCall.h`:

```h
#ifndef RD_CPP_RDCALL_H
#define RD_CPP_RDCALL_H

#include "serialization/Polymorphic.h"
#include "RdTask.h"
#include "RdTaskResult.h"
#include "scheduler/SynchronousScheduler.h"
#include "WiredRdTask.h"

#include <thread>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief Represents an API provided by the remote process which can be invoked through the protocol.
 *
 * \tparam TReq type of request
 * \tparam TRes type of response
 * \tparam ReqSer "SerDes" for request
 * \tparam ResSer "SerDes" for response
 */
template <typename TReq, typename TRes, typename ReqSer = Polymorphic<TReq>, typename ResSer = Polymorphic<TRes> >
class RdCall : public virtual RdReactiveBase, public ISerializable
{
	using WTReq = value_or_wrapper<TReq>;
	using WTRes = value_or_wrapper<TRes>;

	mutable optional<RdId> sync_task_id;

public:
	// region ctor/dtor
	RdCall() = default;

	RdCall(RdCall&&) = default;

	RdCall& operator=(RdCall&&) = default;

	virtual ~RdCall() = default;
	// endregion

	static RdCall<TReq, TRes, ReqSer, ResSer> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		RdCall<TReq, TRes, ReqSer, ResSer> res;
		const RdId& id = RdId::read(buffer);
		withId(res, id);
		return res;
	}

	void write(SerializationCtx& /*ctx*/, Buffer& buffer) const override
	{
		rdid.write(buffer);
	}

	void init(Lifetime lifetime) const override
	{
		RdBindableBase::init(lifetime);
		bind_lifetime = lifetime;
		get_wire()->advise(lifetime, this);
	}

	/**
	 * \brief Invokes the API with the parameters given as [request] and waits for the result.
	 *
	 * \param request value to deliver
	 * \return result of remote invoking
	 */
	WiredRdTask<TRes, ResSer> sync(TReq const& request, std::chrono::milliseconds timeout = 200ms) const
	{
		auto task = start_internal(request, true, &SynchronousScheduler::Instance());
		auto time_at_start = std::chrono::system_clock::now();
		while (!task.has_value() && !(*bind_lifetime)->is_terminated() &&
			   ((std::chrono::system_clock::now() - time_at_start) < timeout))
		{
			std::this_thread::yield();
		}
		spdlog::debug("Time elapsed: {}, has_value={}", to_string(std::chrono::system_clock::now() - time_at_start),
			to_string(task.has_value()));
		task.value_or_throw().unwrap();	   // check for existing value
		sync_task_id = nullopt;
		return task;
	}

	IScheduler* get_wire_scheduler() const override
	{
		return &SynchronousScheduler::Instance();
	}

	/**
	 * \brief Asynchronously invokes the API with the parameters given as [request] and waits for the result.
	 *
	 * \param request value of request
	 * \param responseScheduler to assign value
	 * \return task which will have its result value.
	 */
	WiredRdTask<TRes, ResSer> start(TReq const& request, IScheduler* responseScheduler = nullptr) const
	{
		return start_internal(request, false, responseScheduler ? responseScheduler : get_default_scheduler());
	}

	void on_wire_received(Buffer buffer) const override
	{
		RD_ASSERT_MSG(false, "RdCall.on_wire_received called")
	}

private:
	WiredRdTask<TRes, ResSer> start_internal(TReq const& request, bool sync, IScheduler* scheduler) const
	{
		assert_bound();
		if (!async)
		{
			assert_threading();
		}

		RdId task_id = get_protocol()->get_identity()->next(rdid);
		WiredRdTask<TRes, ResSer> task{*bind_lifetime, *this, task_id, scheduler};

		if (sync)
		{
			if (sync_task_id.has_value())
			{
				throw std::invalid_argument(
					"Already exists sync task for call " + to_string(location) + ", taskId = " + rd::to_string(*sync_task_id));
			}
			sync_task_id = task_id;
		}

		get_wire()->send(rdid, [&](Buffer& buffer) {
			spdlog::get("logSend")->trace("call {}::{} send {} request {} : {}", to_string(location), to_string(rdid), (sync ? "SYNC" : "ASYNC"),
				to_string(task_id), to_string(request));
			task_id.write(buffer);
			ReqSer::write(get_serialization_context(), buffer, request);
		});

		return task;
	}

public:
	friend bool operator==(const RdCall& lhs, const RdCall& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const RdCall& lhs, const RdCall& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(RdCall const& /*value*/)
	{
		return "RdCall";
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#endif	  // RD_CPP_RDCALL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/RdEndpoint.h`:

```h
#ifndef RD_CPP_RDENDPOINT_H
#define RD_CPP_RDENDPOINT_H

#include "serialization/Polymorphic.h"
#include "RdTask.h"

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4250)
#endif

namespace rd
{
/**
 * \brief An API that is exposed to the remote process and can be invoked over the protocol.
 *
 * \tparam TReq type of request
 * \tparam TRes type of response
 * \tparam ReqSer "SerDes" for request
 * \tparam ResSer "SerDes" for response
 */
template <typename TReq, typename TRes, typename ReqSer = Polymorphic<TReq>, typename ResSer = Polymorphic<TRes>>
class RdEndpoint : public virtual RdReactiveBase, public ISerializable
{
	using WTReq = value_or_wrapper<TReq>;
	using WTRes = value_or_wrapper<TRes>;

	using handler_t = std::function<RdTask<TRes, ResSer>(Lifetime, TReq const&)>;
	mutable handler_t local_handler;

	mutable tsl::ordered_map<RdId, RdTask<TRes, ResSer>, rd::hash<RdId>> awaiting_tasks;	// TO-DO get rid of it
public:
	// region ctor/dtor

	RdEndpoint() = default;

	explicit RdEndpoint(handler_t handler)
	{
		set(std::move(handler));
	}

	explicit RdEndpoint(std::function<WTRes(TReq const&)> handler)
	{
		set(std::move(handler));
	}

	RdEndpoint(RdEndpoint&&) = default;

	RdEndpoint& operator=(RdEndpoint&&) = default;

	virtual ~RdEndpoint() = default;
	// endregion

	static RdEndpoint<TReq, TRes, ReqSer, ResSer> read(SerializationCtx& /*ctx*/, Buffer& buffer)
	{
		RdEndpoint<TReq, TRes, ReqSer, ResSer> res;
		const RdId& id = RdId::read(buffer);
		withId(res, id);
		return res;
	}

	void write(SerializationCtx& /*ctx*/, Buffer& buffer) const override
	{
		rdid.write(buffer);
	}

	/**
	 * \brief Assigns a handler that executes the API asynchronously.
	 * \param handler to assign
	 */
	void set(handler_t handler) const
	{
		RD_ASSERT_MSG(handler, "handler is set already");
		local_handler = std::move(handler);
	}

	/**
	 * \brief @see set above
	 */
	void set(std::function<WTRes(TReq const&)> functor) const
	{
		local_handler = [handler = std::move(functor)](Lifetime _, TReq const& req) -> RdTask<TRes, ResSer>
		{ return RdTask<TRes, ResSer>::from_result(handler(req)); };
	}

	void init(Lifetime lifetime) const override
	{
		RdReactiveBase::init(lifetime);
		bind_lifetime = lifetime;
		get_wire()->advise(lifetime, this);
	}

	void on_wire_received(Buffer buffer) const override
	{
		auto task_id = RdId::read(buffer);
		auto value = ReqSer::read(get_serialization_context(), buffer);
		spdlog::get("logReceived")->trace("endpoint {}::{} request = {}", to_string(location), to_string(rdid), to_string(value));
		if (!local_handler)
		{
			throw std::invalid_argument("handler is empty for RdEndPoint");
		}
		auto task = awaiting_tasks[task_id] = {};
		try
		{
			task = local_handler(*bind_lifetime, wrapper::get<TReq>(value));
		}
		catch (std::exception const& e)
		{
			task.fault(e);
		}
		task.advise(*bind_lifetime,
			[this, task_id, &task](RdTaskResult<TRes, ResSer> const& task_result)
			{
				spdlog::get("logSend")->trace(
					"endpoint {}::{} response = {}", to_string(location), to_string(rdid), to_string(*task.result));
				get_wire()->send(
					task_id, [&](Buffer& inner_buffer) { task_result.write(get_serialization_context(), inner_buffer); });
				// TO-DO remove from awaiting_tasks
			});
	}

	friend bool operator==(const RdEndpoint& lhs, const RdEndpoint& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const RdEndpoint& lhs, const RdEndpoint& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(RdEndpoint const& /*value*/)
	{
		return "RdEndpoint";
	}
};
}	 // namespace rd

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#endif	  // RD_CPP_RDENDPOINT_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/RdSymmetricCall.h`:

```h
#ifndef RD_CPP_RDSYMMETRICCALL_H
#define RD_CPP_RDSYMMETRICCALL_H

#include "task/RdCall.h"
#include "task/RdEndpoint.h"

namespace rd
{
template <typename TReq, typename TRes, typename ReqSer = Polymorphic<TReq>, typename ResSer = Polymorphic<TRes> >
class RdSymmetricCall : public RdCall<TReq, TRes, ReqSer, ResSer>, public RdEndpoint<TReq, TRes, ReqSer, ResSer>
{
public:
	void init(Lifetime lifetime) const override
	{
		RdCall<TReq, TRes, ReqSer, ResSer>::init(lifetime);
	}

	void on_wire_received(Buffer buffer) const override
	{
		RdEndpoint<TReq, TRes, ReqSer, ResSer>::on_wire_received(std::move(buffer));
	}

	friend bool operator==(const RdSymmetricCall& lhs, const RdSymmetricCall& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const RdSymmetricCall& lhs, const RdSymmetricCall& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(RdSymmetricCall const& value)
	{
		return "RdSymmetricCall";
	}
};
}	 // namespace rd

#endif	  // RD_CPP_RDSYMMETRICCALL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/RdTask.h`:

```h
#ifndef RD_CPP_RDTASK_H
#define RD_CPP_RDTASK_H

#include "RdTaskImpl.h"
#include "serialization/Polymorphic.h"

#include <functional>

namespace rd
{
/**
 * \brief Represents a task that can be asynchronously executed.
 *
 * \tparam T type of stored value
 * \tparam S "SerDes" for value
 */
template <typename T, typename S = Polymorphic<T>>
class RdTask
{
protected:
	using WT = value_or_wrapper<T>;

	using TRes = RdTaskResult<T, S>;

	mutable std::shared_ptr<detail::RdTaskImpl<T, S>> impl{std::make_shared<detail::RdTaskImpl<T, S>>()};

	Property<RdTaskResult<T, S>>* result{&impl->result};

public:
	using result_type = RdTaskResult<T, S>;

	template <typename, typename, typename, typename>
	friend class RdEndpoint;
	// region ctor/dtor

	RdTask() = default;

	RdTask(RdTask const& other) = default;

	RdTask& operator=(RdTask const& other) = default;

	RdTask(RdTask&& other) = default;

	RdTask& operator=(RdTask&& other) = default;

	virtual ~RdTask() = default;
	// endregion

	static RdTask from_result(WT value)
	{
		RdTask<T, S> res;
		res.set(std::move(value));
		return res;
	}

	void set(WT value) const
	{
		typename TRes::Success t(std::move(value));
		impl->result.set(std::move(t));
	}

	void set_result(TRes value) const
	{
		impl->result.set(std::move(value));
	}

	void set_result_if_empty(TRes value) const
	{
		impl->result.set_if_empty(std::move(value));
	}

	void cancel() const
	{
		impl->result.set(typename TRes::Cancelled());
	}

	void fault(std::exception const& e) const
	{
		impl->result.set(typename TRes::Fault(e));
	}

	bool has_value() const
	{
		return impl->result.has_value();
	}

	const TRes& value_or_throw() const
	{
		if (impl->result.has_value())
		{
			return impl->result.get();
		}
		else
		{
			throw std::invalid_argument("task is empty");
		}
	}

	bool is_succeeded() const
	{
		return has_value() && value_or_throw().is_succeeded();
	};

	bool is_canceled() const
	{
		return has_value() && value_or_throw().is_canceled();
	};

	bool is_faulted() const
	{
		return has_value() && value_or_throw().is_faulted();	// TO-DO atomic
	}

	void advise(Lifetime lifetime, std::function<void(TRes const&)> handler) const
	{
		impl->result.advise(lifetime, [handler = std::move(handler)](optional<TRes> const& opt_value) {
			if (opt_value)
			{
				handler(*opt_value);
			}
		});
	}
};
}	 // namespace rd

#endif	  // RD_CPP_RDTASK_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/RdTaskImpl.h`:

```h
#ifndef RD_CPP_RDTASKIMPL_H
#define RD_CPP_RDTASKIMPL_H

#include "serialization/Polymorphic.h"
#include "RdTaskResult.h"

#include "thirdparty.hpp"

namespace rd
{
template <typename, typename>
class RdTask;

namespace detail
{
template <typename T, typename S = Polymorphic<T>>
class RdTaskImpl
{
private:
	mutable Property<RdTaskResult<T, S>> result;

public:
	template <typename, typename>
	friend class ::rd::RdTask;
};
}	 // namespace detail
}	 // namespace rd

#endif	  // RD_CPP_RDTASKIMPL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/RdTaskResult.h`:

```h
#ifndef RD_CPP_RDTASKRESULT_H
#define RD_CPP_RDTASKRESULT_H

#include "serialization/Polymorphic.h"
#include "util/overloaded.h"
#include "types/wrapper.h"
#include "util/core_util.h"

#include "thirdparty.hpp"

#include <exception>
#include <functional>

namespace rd
{
/**
 * \brief Advanced monad result. It is in of following states: Success, Cancelled, Fault;
 * Success -  Execution completed. Result stores in it.
 * Cancelled - Task was cancelled on callee side.
 * Fault - Something went wrong and reason stores in it.
 * \tparam T type of result
 * \tparam S "SerDes" for T
 */
template <typename T, typename S = Polymorphic<T> >
class RdTaskResult final : public ISerializable
{
	using WT = value_or_wrapper<T>;

public:
	class Success
	{
	public:
		mutable WT value;

		explicit Success(WT&& value) : value(std::move(value))
		{
		}
	};

	class Cancelled
	{
	};

	class Fault
	{
	public:
		std::wstring reason_type_fqn;
		std::wstring reason_message;
		std::wstring reason_as_text;

		Fault(std::wstring reason_type_fqn, std::wstring reason_message, std::wstring reason_as_text)
			: reason_type_fqn(std::move(reason_type_fqn))
			, reason_message(std::move(reason_message))
			, reason_as_text(std::move(reason_as_text))
		{
		}

		explicit Fault(const std::exception& e)
		{
			reason_message = to_wstring(to_string(e));
		}
	};

	// region ctor/dtor

	template <typename F>
	RdTaskResult(F&& v) : v(std::forward<F>(v))
	{
	}

	RdTaskResult(RdTaskResult const&) = default;

	RdTaskResult(RdTaskResult&&) = default;

	RdTaskResult& operator=(RdTaskResult&&) = default;

	virtual ~RdTaskResult() = default;
	// endregion

	static RdTaskResult<T, S> read(SerializationCtx& ctx, Buffer& buffer)
	{
		const int32_t kind = buffer.read_integral<int32_t>();
		switch (kind)
		{
			case 0:
			{
				return Success(std::move(S::read(ctx, buffer)));
			}
			case 1:
			{
				return Cancelled();
			}
			case 2:
			{
				auto reason_type_fqn = buffer.read_wstring();
				auto reason_message = buffer.read_wstring();
				auto reason_as_text = buffer.read_wstring();
				return Fault(std::move(reason_type_fqn), std::move(reason_message), std::move(reason_as_text));
			}
			default:
				throw std::invalid_argument("Fail on RdTaskResult reading with kind: " + std::to_string(kind));
		}
	}

	void write(SerializationCtx& ctx, Buffer& buffer) const override
	{
		visit(util::make_visitor(
				  [&ctx, &buffer](Success const& value) {
					  buffer.write_integral<int32_t>(0);
					  S::write(ctx, buffer, value.value);
				  },
				  [&buffer](Cancelled const&) { buffer.write_integral<int32_t>(1); },
				  [&buffer](Fault const& value) {
					  buffer.write_integral<int32_t>(2);
					  buffer.write_wstring(value.reason_type_fqn);
					  buffer.write_wstring(value.reason_message);
					  buffer.write_wstring(value.reason_as_text);
				  }),
			v);
	}

	T const& unwrap() const
	{
		return visit(util::make_visitor([](Success const& value) -> T const& { return wrapper::get<T>(value.value); },
						 [](Cancelled const&) -> T const& { throw std::invalid_argument("Task finished in Cancelled state"); },
						 [](Fault const& value) -> T const& { throw std::runtime_error(to_string(value.reason_message)); }),
			v);
	}

	bool is_succeeded() const
	{
		return v.index() == 0;
	}

	bool is_canceled() const
	{
		return v.index() == 1;
	}

	void as_canceled(std::function<void(Cancelled const&)> f) const
	{
		f(rd::get<Cancelled>(v));
	}

	bool is_faulted() const
	{
		return v.index() == 2;
	}

	void as_faulted(std::function<void(Fault const&)> f)
	{
		f(rd::get<Fault>(v));
	}

	friend bool operator==(const RdTaskResult& lhs, const RdTaskResult& rhs)
	{
		return &lhs == &rhs;
	}

	friend bool operator!=(const RdTaskResult& lhs, const RdTaskResult& rhs)
	{
		return !(rhs == lhs);
	}

	friend std::string to_string(RdTaskResult const& taskResult)
	{
		return visit(util::make_visitor([](Success const& value) -> std::string { return to_string(value.value); },
						 [](Cancelled const&) -> std::string { return "Cancelled state"; },
						 [](Fault const& value) -> std::string { return to_string(value.reason_message); }),
			taskResult.v);
	}

private:
	mutable variant<Success, Cancelled, Fault> v;
};
}	 // namespace rd

#endif	  // RD_CPP_RDTASKRESULT_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/WiredRdTask.h`:

```h
#ifndef RD_CPP_WIREDRDTASK_H
#define RD_CPP_WIREDRDTASK_H

#include "RdTask.h"
#include "WiredRdTaskImpl.h"
#include "base/RdReactiveBase.h"
#include "scheduler/base/IScheduler.h"

namespace rd
{
template <typename T, typename S = Polymorphic<T>>
class WiredRdTask final : public RdTask<T, S>
{
	mutable std::shared_ptr<detail::WiredRdTaskImpl<T, S>> impl{};

public:
	// region ctor/dtor
	WiredRdTask() = delete;

	WiredRdTask(Lifetime lifetime, RdReactiveBase const& call, RdId rdid, IScheduler* scheduler)
		: impl(std::make_shared<detail::WiredRdTaskImpl<T, S>>(lifetime, call, rdid, scheduler, RdTask<T, S>::result))
	{
	}

	WiredRdTask(WiredRdTask const& other) = default;

	WiredRdTask& operator=(WiredRdTask const& other) = default;

	WiredRdTask(WiredRdTask&& other) = default;

	WiredRdTask& operator=(WiredRdTask&& other) = default;

	virtual ~WiredRdTask() = default;
	// endregion
};
}	 // namespace rd

#endif	  // RD_CPP_WIREDRDTASK_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/task/WiredRdTaskImpl.h`:

```h
#ifndef RD_CPP_WIREDRDTASKIMPL_H
#define RD_CPP_WIREDRDTASKIMPL_H

#include "serialization/Polymorphic.h"
#include "RdTaskResult.h"

namespace rd
{
template <typename, typename>
class WiredRdTask;

namespace detail
{
template <typename T, typename S = Polymorphic<T>>
class WiredRdTaskImpl : public RdReactiveBase
{
private:
	Lifetime lifetime;
	RdReactiveBase const* cutpoint{};
	IScheduler* scheduler{};
	Property<RdTaskResult<T, S>>* result{};

	LifetimeImpl::counter_t termination_lifetime_id{};

public:
	template <typename, typename>
	friend class ::rd::WiredRdTask;

	WiredRdTaskImpl(
		Lifetime lifetime, RdReactiveBase const& cutpoint, RdId rdid, IScheduler* scheduler, Property<RdTaskResult<T, S>>* result)
		: lifetime(lifetime), cutpoint(&cutpoint), scheduler(scheduler), result(result)
	{
		this->rdid = std::move(rdid);
		cutpoint.get_wire()->advise(lifetime, this);
		termination_lifetime_id =
			lifetime->add_action([this]() { this->result->set_if_empty(typename RdTaskResult<T, S>::Cancelled{}); });
	}

	virtual ~WiredRdTaskImpl()
	{
		lifetime->remove_action(termination_lifetime_id);
	}

	void on_wire_received(Buffer buffer) const override
	{
		auto read_result = RdTaskResult<T, S>::read(cutpoint->get_serialization_context(), buffer);
		spdlog::get("logReceived")
			->trace("call {} {} received response {} : {}", to_string(cutpoint->get_location()), to_string(rdid), to_string(rdid),
				to_string(read_result));
		scheduler->queue([&, result = std::move(read_result)]() mutable {
			if (this->result->has_value())
			{
				spdlog::get("logReceived")->trace("call {} {} response was dropped, task result is: {}", to_string(location), to_string(rdid),
					to_string(result.unwrap()));
			}
			else
			{
				this->result->set_if_empty(std::move(result));
			}
		});
	}

	IScheduler* get_wire_scheduler() const override
	{
		return &SynchronousScheduler::Instance();
	}
};
}	 // namespace detail
}	 // namespace rd

#endif	  // RD_CPP_WIREDRDTASKIMPL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/util/framework_traits.h`:

```h
#ifndef RD_CPP_FRAMEWORK_TRAITS_H
#define RD_CPP_FRAMEWORK_TRAITS_H

#include "serialization/Polymorphic.h"

#include <utility>
#include <type_traits>

namespace rd
{
namespace util
{
template <typename S, typename T = decltype((S::read(std::declval<rd::SerializationCtx&>(), std::declval<rd::Buffer&>())))>
using read_t = T;

static_assert(util::is_same_v<std::wstring, read_t<Polymorphic<std::wstring>>>, " ");
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CPP_FRAMEWORK_TRAITS_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/util/guards.h`:

```h
#ifndef RD_CPP_GUARDS_H
#define RD_CPP_GUARDS_H

namespace rd
{
namespace util
{
template <typename T>
class increment_guard
{
	T& x;

public:
	explicit increment_guard(T& new_x) : x(new_x)
	{
		++x;
	}

	~increment_guard()
	{
		--x;
	}
};

class bool_guard
{
	bool& x;

public:
	explicit bool_guard(bool& new_x) : x(new_x)
	{
		x = true;
	}

	~bool_guard()
	{
		x = false;
	}
};
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CPP_GUARDS_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/util/hashing.h`:

```h
#ifndef RD_CPP_HASHING_H
#define RD_CPP_HASHING_H

#include "nonstd/string_view.hpp"

#include <cstdint>
#include <cstdlib>
#include <string>

namespace rd
{
namespace util
{
using hash_t = int64_t;
using constexpr_hash_t = uint64_t;	  // hash_t;

constexpr constexpr_hash_t DEFAULT_HASH = 19;
constexpr constexpr_hash_t HASH_FACTOR = 31;

// PLEASE DO NOT CHANGE IT!!! IT'S EXACTLY THE SAME ON C# SIDE
constexpr hash_t hashImpl(constexpr_hash_t initial, char const* begin, char const* end)
{
	return (begin == end) ? initial : hashImpl(initial * HASH_FACTOR + *begin, begin + 1, end);
}

/*template<size_t N>
constexpr hash_t getPlatformIndependentHash(char const (&that)[N], constexpr_hash_t initial = DEFAULT_HASH) {
	return static_cast<hash_t>(hashImpl(initial, &that[0], &that[N - 1]));
}*/

constexpr hash_t getPlatformIndependentHash(string_view that, constexpr_hash_t initial = DEFAULT_HASH)
{
	return static_cast<hash_t>(hashImpl(initial, &that[0], &that[that.length() - 1] + 1));
}

constexpr hash_t getPlatformIndependentHash(int32_t const& that, constexpr_hash_t initial = DEFAULT_HASH)
{
	return static_cast<hash_t>(initial * HASH_FACTOR + static_cast<constexpr_hash_t>(that + 1));
}

constexpr hash_t getPlatformIndependentHash(int64_t const& that, constexpr_hash_t initial = DEFAULT_HASH)
{
	return static_cast<hash_t>(initial * HASH_FACTOR + static_cast<constexpr_hash_t>(that + 1));
}
}	 // namespace util
}	 // namespace rd
#endif	  // RD_CPP_HASHING_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/util/thread_util.cpp`:

```cpp
#include "thread_util.h"

#ifdef _WIN32

#include <windows.h>
const DWORD MS_VC_EXCEPTION = 0x406D1388;

#pragma pack(push, 8)
typedef struct tagTHREADNAME_INFO
{
	DWORD dwType;		 // Must be 0x1000.
	LPCSTR szName;		 // Pointer to name (in user addr space).
	DWORD dwThreadID;	 // Thread ID (-1=caller thread).
	DWORD dwFlags;		 // Reserved for future use, must be zero.
} THREADNAME_INFO;
#pragma pack(pop)

void SetThreadName(uint32_t dwThreadID, const char* threadName)
{
	THREADNAME_INFO info;
	info.dwType = 0x1000;
	info.szName = threadName;
	info.dwThreadID = dwThreadID;
	info.dwFlags = 0;

	__try
	{
		RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*) &info);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}
}

void SetThreadName(const char* threadName)
{
	SetThreadName(GetCurrentThreadId(), threadName);
}

#elif defined(__APPLE__)

#include <pthread.h>

void SetThreadName(const char* threadName)
{
	pthread_setname_np(threadName);
}

#else

#include <pthread.h>

void SetThreadName(const char* threadName)
{
	pthread_setname_np(pthread_self(), threadName);
}

#endif

namespace rd
{
namespace util
{
void set_thread_name(const char* name)
{
	SetThreadName(name);
}

}	 // namespace util
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/util/thread_util.h`:

```h
#ifndef RD_CPP_THREAD_UTIL_H
#define RD_CPP_THREAD_UTIL_H

#include <thread>

namespace rd
{
namespace util
{
void set_thread_name(const char* name);

}

}	 // namespace rd

#endif	  // RD_CPP_THREAD_UTIL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/ByteBufferAsyncProcessor.cpp`:

```cpp
#include "ByteBufferAsyncProcessor.h"

#include "util/guards.h"
#include <util/thread_util.h>

#include "spdlog/sinks/stdout_color_sinks.h"

namespace rd
{
size_t ByteBufferAsyncProcessor::INITIAL_CAPACITY = 1024 * 1024;

std::shared_ptr<spdlog::logger> ByteBufferAsyncProcessor::logger =
	spdlog::stderr_color_mt<spdlog::synchronous_factory>("byteBufferLog", spdlog::color_mode::automatic);

ByteBufferAsyncProcessor::ByteBufferAsyncProcessor(
	std::string id, std::function<bool(Buffer::ByteArray const&, sequence_number_t)> processor)
	: id(std::move(id)), processor(std::move(processor))
{
	data.reserve(INITIAL_CAPACITY);
}

void ByteBufferAsyncProcessor::cleanup0()
{
	{
		std::lock_guard<decltype(lock)> guard(lock);

		state = StateKind::Terminated;
	}
	// TO-DO clean data

	cv.notify_all();
}

bool ByteBufferAsyncProcessor::terminate0(time_t timeout, StateKind state_to_set, string_view action)
{
	{
		std::lock_guard<decltype(lock)> guard(lock);
		if (state == StateKind::Initialized)
		{
			logger->debug("Can't {} \'{}\', because it hasn't been started yet", std::string(action), id);
			cleanup0();
			return true;
		}

		if (state >= state_to_set)
		{
			logger->debug("Trying to {} async processor \'{}' but it's in state {}", std::string(action), id, to_string(state));
			return true;
		}

		state = state_to_set;
	}
	cv.notify_all();

	std::future_status status = async_future.wait_for(timeout);

	bool success = true;

	if (status == std::future_status::timeout)
	{
		logger->error("Couldn't wait async thread during time: {}", to_string(timeout));
		success = false;
	}

	cleanup0();

	return success;
}

void ByteBufferAsyncProcessor::add_data(std::vector<Buffer::ByteArray>&& new_data)
{
	std::lock_guard<decltype(queue_lock)> guard(queue_lock);
	std::move(new_data.begin(), new_data.end(), std::back_inserter(queue));
	//		for (auto &&item : new_data) {
	//			queue.emplace(std::move(item));
	//		}
}

bool ByteBufferAsyncProcessor::reprocess()
{
	{
		std::lock_guard<decltype(queue_lock)> guard(queue_lock);

		logger->debug("{}: reprocessing started", id);

		std::unique_lock<decltype(processing_lock)> ul(processing_lock);
		processing_cv.wait(ul, [this]() -> bool { return !in_processing; });

		logger->debug("{}: reprocessing waited for main processing", id);

		while (current_seqn <= acknowledged_seqn)
		{
			pending_queue.pop_front();
			++current_seqn;
		}
		for (int i = 0; i < pending_queue.size(); ++i)
		{
			auto const& item = pending_queue[i];
			if (!processor(item, current_seqn + i))
			{
				return false;
			}
		}
	}
	return true;
}

void ByteBufferAsyncProcessor::process()
{
	{
		std::lock_guard<decltype(queue_lock)> guard(queue_lock);
		std::unique_lock<decltype(processing_lock)> ul(processing_lock);
		util::bool_guard bool_guard(in_processing);

		logger->debug("{}: processing started", id);

		while (!queue.empty() && processor(queue.front(), max_sent_seqn + 1))
		{
			++max_sent_seqn;
			pending_queue.push_back(std::move(queue.front()));
			queue.pop_front();
		}
	}
	processing_cv.notify_all();

	cv.notify_all();
}

void ByteBufferAsyncProcessor::ThreadProc()
{
	rd::util::set_thread_name(id.empty() ? "ByteBufferAsyncProcessor Thread" : id.c_str());
	async_thread_id = std::this_thread::get_id();

	while (true)
	{
		{
			std::lock_guard<decltype(lock)> guard(lock);

			if (state >= StateKind::Terminated)
			{
				return;
			}

			while (data.empty() || interrupt_balance != 0)
			{
				if (state >= StateKind::Stopping)
				{
					return;
				}
				cv.wait(lock);

				logger->debug("{}'s ThreadProc waited for notify", id);

				if (state >= StateKind::Terminating)
				{
					return;
				}
			}
			add_data(std::move(data));
			data.clear();
		}

		try
		{
			process();
		}
		catch (std::exception const& e)
		{
			logger->error("Exception while processing byte queue | {}", e.what());
		}
	}
}

void ByteBufferAsyncProcessor::start()
{
	{
		std::lock_guard<decltype(lock)> guard(lock);

		if (state != StateKind::Initialized)
		{
			logger->debug("Trying to START async processor {} but it's in state {}", id, to_string(state));
			return;
		}

		state = StateKind::AsyncProcessing;

		async_future = std::async(std::launch::async, &ByteBufferAsyncProcessor::ThreadProc, this);
	}
}

bool ByteBufferAsyncProcessor::stop(time_t timeout)
{
	return terminate0(timeout, StateKind::Stopping, "STOP");
}

bool ByteBufferAsyncProcessor::terminate(time_t timeout)
{
	return terminate0(timeout, StateKind::Terminating, "TERMINATE");
}

void ByteBufferAsyncProcessor::put(Buffer::ByteArray new_data)
{
	{
		std::lock_guard<decltype(lock)> guard(lock);

		if (state >= StateKind::Stopping)
		{
			return;
		}
		data.emplace_back(std::move(new_data));
	}
	cv.notify_all();
}

void ByteBufferAsyncProcessor::pause(const std::string& reason)
{
	std::lock_guard<decltype(lock)> guard(lock);

	++interrupt_balance;

	logger->debug("{} paused with reason={},state={}", id, reason, to_string(state));

	auto current_thread_id = std::this_thread::get_id();
	if (current_thread_id != async_thread_id)
	{
		logger->debug("{} paused from another thread : {}", id, to_string(current_thread_id));
		std::unique_lock<decltype(processing_lock)> ul(processing_lock);
		processing_cv.wait(ul, [this]() -> bool { return !in_processing; });
		logger->debug("{}: pausing waited for main processing", id);
	}
}

void ByteBufferAsyncProcessor::resume()
{
	{
		std::lock_guard<decltype(lock)> guard(lock);

		reprocess();

		--interrupt_balance;

		logger->debug("{} resumed", id);
	}

	cv.notify_all();
}

void ByteBufferAsyncProcessor::acknowledge(sequence_number_t seqn)
{
	std::lock_guard<decltype(lock)> guard(lock);

	if (seqn > acknowledged_seqn)
	{
		logger->trace("{}: new acknowledged seqn: {}", this->id, seqn);
		acknowledged_seqn = seqn;
	}
	else
	{
		logger->error("Acknowledge {} called, while next seqn MUST BE greater than {}", seqn, acknowledged_seqn);
	}
}

std::string to_string(ByteBufferAsyncProcessor::StateKind state)
{
	switch (state)
	{
		case ByteBufferAsyncProcessor::StateKind::Initialized:
			return "Initialized";
		case ByteBufferAsyncProcessor::StateKind::AsyncProcessing:
			return "AsyncProcessing";
		case ByteBufferAsyncProcessor::StateKind::Stopping:
			return "Stopping";
		case ByteBufferAsyncProcessor::StateKind::Terminating:
			return "Terminating";
		case ByteBufferAsyncProcessor::StateKind::Terminated:
			return "Terminated";
	}
	return {};
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/ByteBufferAsyncProcessor.h`:

```h
#ifndef RD_CPP_BYTEBUFFERASYNCPROCESSOR_H
#define RD_CPP_BYTEBUFFERASYNCPROCESSOR_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "protocol/Buffer.h"
#include "spdlog/spdlog.h"

#include <chrono>
#include <string>
#include <mutex>
#include <condition_variable>
#include <future>
#include <list>

#include <rd_framework_export.h>

namespace rd
{
using sequence_number_t = int64_t;

class RD_FRAMEWORK_API ByteBufferAsyncProcessor
{
public:
	enum class StateKind
	{
		Initialized,
		AsyncProcessing,
		Stopping,
		Terminating,
		Terminated
	};

private:
	using time_t = std::chrono::milliseconds;

	static size_t INITIAL_CAPACITY;

	std::recursive_mutex lock;
	std::condition_variable_any cv;

	std::string id;

	std::function<bool(Buffer::ByteArray const&, sequence_number_t seqn)> processor;

	StateKind state{StateKind::Initialized};
	static std::shared_ptr<spdlog::logger> logger;

	std::thread::id async_thread_id;
	std::future<void> async_future;

	std::vector<Buffer::ByteArray> data;
	std::mutex queue_lock;
	std::deque<Buffer::ByteArray> queue{};
	std::deque<Buffer::ByteArray> pending_queue{};

	sequence_number_t max_sent_seqn = 0;
	sequence_number_t current_seqn = 1;
	sequence_number_t acknowledged_seqn = 0;

	int32_t interrupt_balance = 0;
	bool in_processing = false;
	std::mutex processing_lock;
	std::condition_variable processing_cv;

public:
	// region ctor/dtor

	explicit ByteBufferAsyncProcessor(std::string id, std::function<bool(Buffer::ByteArray const&, sequence_number_t)> processor);

	// endregion
private:
	void cleanup0();

	bool terminate0(time_t timeout, StateKind state_to_set, string_view action);

	void add_data(std::vector<Buffer::ByteArray>&& new_data);

	bool reprocess();

	void process();

	void ThreadProc();

public:
	void start();

	bool stop(time_t timeout = time_t(0));

	bool terminate(time_t timeout = time_t(0) /*InfiniteDuration*/);

	void put(Buffer::ByteArray new_data);

	void pause(const std::string& reason);

	void resume();

	void acknowledge(int64_t seqn);
};

std::string to_string(ByteBufferAsyncProcessor::StateKind state);
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_BYTEBUFFERASYNCPROCESSOR_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/PkgInputStream.cpp`:

```cpp
#define NOMINMAX

#include "PkgInputStream.h"

#include <algorithm>

namespace rd
{
void PkgInputStream::rewind()
{
	buffer.rewind();
}

void PkgInputStream::require_available(int size)
{
	buffer.require_available(size);
}

size_t PkgInputStream::get_position() const
{
	return buffer.get_position();
}

Buffer::word_t* PkgInputStream::data()
{
	return buffer.data();
}

Buffer& PkgInputStream::get_buffer()
{
	return buffer;
}

int32_t PkgInputStream::try_read(Buffer::word_t* res, size_t size)
{
	if (memory == -1 || buffer.get_position() == memory)
	{
		memory = request_data();
		if (memory == -1)
		{
			return -1;
		}
	}
	const int32_t n = static_cast<int32_t>((std::min)(size, memory - buffer.get_position()));
	Buffer::word_t* start = buffer.current_pointer();
	std::copy(start, start + n, res);
	buffer.set_position(buffer.get_position() + n);
	return n;
}

bool PkgInputStream::read(Buffer::word_t* res, size_t size)
{
	//		spdlog::trace("PkgInputStream call: size={}, pos={}, memory={}", size, buffer.get_position(), memory);

	int32_t summary_size = 0;
	while (summary_size < size)
	{
		const int32_t bytes_read = try_read(res + summary_size, size - summary_size);
		if (bytes_read == -1)
		{
			return false;
		}
		summary_size += bytes_read;
	}
	return true;
}
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/PkgInputStream.h`:

```h
#ifndef RD_CPP_PKGINPUTSTREAM_H
#define RD_CPP_PKGINPUTSTREAM_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "protocol/Buffer.h"

#include <rd_framework_export.h>

namespace rd
{
class RD_FRAMEWORK_API PkgInputStream
{
private:
	Buffer buffer;

	std::function<int32_t()> request_data;

	size_t memory = 0;

public:
	template <typename F>
	explicit PkgInputStream(F&& f) : request_data(std::forward<F>(f))
	{
	}

	void rewind();

	void require_available(int size);

	size_t get_position() const;

	Buffer::word_t* data();

	Buffer& get_buffer();

	int32_t try_read(Buffer::word_t* res, size_t size);

	bool read(Buffer::word_t* res, size_t size);

	template <typename T>
	T read_integral()
	{
		T x{};
		if (!read(reinterpret_cast<Buffer::word_t*>(&x), sizeof(T)))
		{
			return -1;
		}
		return x;
	}
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_PKGINPUTSTREAM_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/PumpScheduler.cpp`:

```cpp
#include "wire/PumpScheduler.h"

#include "util/core_util.h"

namespace rd
{
namespace test
{
namespace util
{
PumpScheduler::PumpScheduler() : created_thread_id(std::this_thread::get_id())
{
}

void PumpScheduler::flush()
{
	assert_thread();
	auto action = std::move(messages.front());
	messages.pop();
	action();
}

void PumpScheduler::queue(std::function<void()> action)
{
	{
		std::lock_guard<decltype(lock)> guard(lock);
		messages.push(std::move(action));
	}
	cv.notify_all();
}

bool PumpScheduler::is_active() const
{
	return true;
}

void PumpScheduler::assert_thread() const
{
	RD_ASSERT_MSG(created_thread_id == std::this_thread::get_id(),
		"Illegal thread for current action, must be: " + to_string(created_thread_id) +
			", current thread: " + to_string(std::this_thread::get_id()))
}

void PumpScheduler::pump_one_message()
{
	{
		std::unique_lock<decltype(lock)> ul(lock);
		cv.wait(ul, [this]() -> bool { return !messages.empty(); });
	}
	flush();
}

PumpScheduler::PumpScheduler(std::string const& name) : PumpScheduler()
{
	this->name = name;
}
}	 // namespace util
}	 // namespace test
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/PumpScheduler.h`:

```h
#ifndef RD_CPP_PUMPSCHEDULER_H
#define RD_CPP_PUMPSCHEDULER_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "scheduler/base/IScheduler.h"

#include <condition_variable>
#include <thread>
#include <queue>

#include <rd_framework_export.h>

namespace rd
{
namespace test
{
namespace util
{
class RD_FRAMEWORK_API PumpScheduler : public IScheduler
{
public:
	std::string name;

	mutable std::condition_variable cv;
	mutable std::mutex lock;

	std::thread::id created_thread_id;
	mutable std::queue<std::function<void()> > messages;

	// region ctor/dtor

	PumpScheduler();

	explicit PumpScheduler(std::string const& name);

	virtual ~PumpScheduler() = default;
	// endregion

	void flush() override;

	void queue(std::function<void()> action) override;

	bool is_active() const override;

	void assert_thread() const override;

	void pump_one_message();
};
}	 // namespace util
}	 // namespace test
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_PUMPSCHEDULER_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.cpp`:

```cpp
#include "wire/SocketWire.h"

#include <util/thread_util.h>

#include "spdlog/sinks/stdout_color_sinks.h"

#include <SimpleSocket.h>
#include <ActiveSocket.h>
#include <PassiveSocket.h>

#include <utility>
#include <thread>
#include <csignal>

namespace rd
{
std::shared_ptr<spdlog::logger> SocketWire::Base::logger =
	spdlog::stderr_color_mt<spdlog::synchronous_factory>("wireLog", spdlog::color_mode::automatic);

std::chrono::milliseconds SocketWire::timeout = std::chrono::milliseconds(500);

constexpr int32_t SocketWire::Base::ACK_MESSAGE_LENGTH;
constexpr int32_t SocketWire::Base::PING_MESSAGE_LENGTH;
constexpr int32_t SocketWire::Base::PACKAGE_HEADER_LENGTH;

SocketWire::Base::Base(std::string id, Lifetime parentLifetime, IScheduler* scheduler)
	: WireBase(scheduler), id(std::move(id)), scheduler(scheduler), lifetimeDef(parentLifetime)
{
	async_send_buffer.pause("initial");
	async_send_buffer.start();
	ping_pkg_header.write_integral(PING_MESSAGE_LENGTH);
}

SocketWire::Base::~Base()
{
	if (!lifetimeDef.is_terminated())
	{
		lifetimeDef.terminate();
	}
}

void SocketWire::Base::receiverProc() const
{
	while (!lifetimeDef.lifetime->is_terminated())
	{
		try
		{
			if (!socket_provider->IsSocketValid())
			{
				logger->debug("{}: stop receive messages because socket disconnected", this->id);
				//					async_send_buffer.terminate();
				break;
			}

			if (!read_and_dispatch_message())
			{
				logger->debug("{}: connection was gracefully shutdown", id);
				//					async_send_buffer.terminate();
				break;
			}
		}
		catch (std::exception const& ex)
		{
			logger->error("{} caught processing | {}", this->id, ex.what());
			//				async_send_buffer.terminate();
			break;
		}
	}
}

bool SocketWire::Base::send0(Buffer::ByteArray const& msg, sequence_number_t seqn) const
{
	try
	{
		std::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);

		int32_t msglen = static_cast<int32_t>(msg.size());

		send_package_header.rewind();
		send_package_header.write_integral(msglen);
		send_package_header.write_integral(seqn);

		RD_ASSERT_THROW_MSG(
			socket_provider->Send(send_package_header.data(), send_package_header.get_position()) == PACKAGE_HEADER_LENGTH,
			this->id +
				": failed to send header over the network"
				", reason: " +
				socket_provider->DescribeError())

		RD_ASSERT_THROW_MSG(socket_provider->Send(msg.data(), msglen) == msglen, this->id +
																					 ": failed to send package over the network"
																					 ", reason: " +
																					 socket_provider->DescribeError());
		logger->info("{}: were sent {} bytes", this->id, msglen);
		//        RD_ASSERT_MSG(socketProvider->Flush(), "{}: failed to flush");
		return true;
	}
	catch (std::exception const& e)
	{
		//			async_send_buffer.pause("send0");
		logger->warn("Send0 failed due to: | {}", e.what());
		return false;
	}
}

void SocketWire::Base::send(RdId const& rd_id, std::function<void(Buffer& buffer)> writer) const
{
	RD_ASSERT_MSG(!rd_id.isNull(), "{}: id mustn't be null");

	Buffer local_send_buffer;
	local_send_buffer.write_integral<int32_t>(0);	 // placeholder for length
	rd_id.write(local_send_buffer);					 // write id
	local_send_buffer.write_integral<int16_t>(0);	 // placeholder for context
	writer(local_send_buffer);						 // write rest

	int32_t len = static_cast<int32_t>(local_send_buffer.get_position());

	local_send_buffer.rewind();
	local_send_buffer.write_integral<int32_t>(len - 4);
	local_send_buffer.set_position(len);
	async_send_buffer.put(std::move(local_send_buffer).getRealArray());
}

void SocketWire::Base::set_socket_provider(std::shared_ptr<CActiveSocket> new_socket)
{
	{
		std::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);
		socket_provider = std::move(new_socket);
		socket_send_var.notify_all();
	}
	{
		std::lock_guard<decltype(lock)> guard(lock);
		if (lifetimeDef.lifetime->is_terminated())
		{
			return;
		}
	}

	auto heartbeat = LifetimeDefinition::use([this](Lifetime heartbeatLifetime) {
		const auto heartbeat = start_heartbeat(heartbeatLifetime).share();

		async_send_buffer.resume();

		connected.set(true);

		receiverProc();

		connected.set(false);

		async_send_buffer.pause("Disconnected");

		return heartbeat;
	});
	const auto status = heartbeat.wait_for(timeout);

	logger->debug("{}: waited for heartbeat to stop with status: {}", this->id, static_cast<uint32_t>(status));

	if (!socket_provider->IsSocketValid())
	{
		logger->debug("{}: socket was already shut down", this->id);
	}
	else if (!socket_provider->Shutdown(CSimpleSocket::Both))
	{
		// double close?
		logger->warn("{}: possibly double close after disconnect", this->id);
	}
}

bool SocketWire::Base::connection_established(int32_t timestamp, int32_t notion_timestamp)
{
	return timestamp - notion_timestamp <= MaximumHeartbeatDelay;
}

std::future<void> SocketWire::Base::start_heartbeat(Lifetime lifetime)
{
	return std::async([this, lifetime] {
		while (!lifetime->is_terminated())
		{
			std::this_thread::sleep_for(heartBeatInterval);
			ping();
		}
	});
}

bool SocketWire::Base::read_from_socket(Buffer::word_t* res, int32_t msglen) const
{
	int32_t ptr = 0;
	while (ptr < msglen)
	{
		RD_ASSERT_MSG(hi >= lo, "hi >= lo")

		int32_t rest = msglen - ptr;
		int32_t available = static_cast<int32_t>(hi - lo);

		if (available > 0)
		{
			int32_t copylen = (std::min)(rest, available);
			std::copy(lo, lo + copylen, res + ptr);
			lo += copylen;
			ptr += copylen;
		}
		else
		{
			if (hi == receiver_buffer.end())
			{
				hi = lo = receiver_buffer.begin();
			}
			logger->info("{}: receive started", this->id);
			int32_t read = socket_provider->Receive(static_cast<int32_t>(receiver_buffer.end() - hi), &*hi);
			if (read == -1)
			{
				auto err = socket_provider->GetSocketError();
				if (err == CSimpleSocket::SocketInvalidSocket)
				{
					logger->info("{}: socket was shut down for receiving", this->id);
					return false;
				}
				logger->error("{}: error has occurred while receiving", this->id);
				return false;
			}
			if (read == 0)
			{
				logger->info("{}: socket was shut down for receiving", this->id);
				return false;
			}
			hi += read;
			if (read > 0)
			{
				logger->info("{}: receive finished: {} bytes read", this->id, read);
			}
		}
	}
	if (ptr != msglen)
	{
		logger->error("read invalid number of bytes from socket, expected: {}, actual: {}", msglen, ptr);
		assert(false);
	}
	return true;
}

static constexpr std::pair<int, sequence_number_t> INVALID_HEADER = std::make_pair(-1, -1);

std::pair<int, sequence_number_t> SocketWire::Base::read_header() const
{
	int32_t len = 0;
	sequence_number_t seqn = 0;
	while (true)
	{
		if (!read_integral_from_socket(len))
		{
			return INVALID_HEADER;
		}
		if (len == PING_MESSAGE_LENGTH)
		{
			int32_t received_timestamp = 0;
			int32_t received_counterpart_timestamp = 0;
			if (!read_integral_from_socket(received_timestamp))
			{
				return INVALID_HEADER;
			}
			if (!read_integral_from_socket(received_counterpart_timestamp))
			{
				return INVALID_HEADER;
			}

			counterpart_timestamp = received_timestamp;
			counterpart_acknowledge_timestamp = received_counterpart_timestamp;

			if ((connection_established(current_timestamp, counterpart_acknowledge_timestamp)))
			{
				if (!heartbeatAlive.get())
				{	 // only on change
					logger->trace(
						"Connection is alive after receiving PING {}: "
						"received_timestamp: {}, "
						"received_counterpart_timestamp: {}, "
						"current_timestamp: {}, "
						"counterpart_timestamp: {}, "
						"counterpart_acknowledge_timestamp: {}, ",
						id, received_timestamp, received_counterpart_timestamp, current_timestamp, counterpart_timestamp,
						counterpart_acknowledge_timestamp);
				}
				heartbeatAlive.set(true);
			}
			continue;
		}
		if (!read_integral_from_socket(seqn))
		{
			return INVALID_HEADER;
		}

		if (len == ACK_MESSAGE_LENGTH)
		{
			async_send_buffer.acknowledge(seqn);
			continue;
		}
		return std::make_pair(len, seqn);
	}
}

int32_t SocketWire::Base::read_package() const
{
	receive_pkg.rewind();

	const auto pair = read_header();
	if (pair == INVALID_HEADER)
	{
		logger->debug("{}: failed to read header", this->id);
		return -1;
	}
	const auto len = pair.first;
	const auto seqn = pair.second;

	logger->debug("{}: read len={}, seqn={}, max_received_seqn={}", this->id, len, seqn, max_received_seqn);

	receive_pkg.require_available(len);
	if (!read_data_from_socket(receive_pkg.data(), len))
	{
		logger->debug("{}: failed to read package", this->id);
		return -1;
	}
	send_ack(seqn);
	if (seqn <= max_received_seqn && seqn != 1)
	{
		return true;
	}
	max_received_seqn = seqn;

	logger->info("{}: was received package, bytes={}, seqn={}", this->id, len, seqn);
	return len;
}

bool SocketWire::Base::read_and_dispatch_message() const
{
	sz = (sz == -1 ? receive_pkg.read_integral<int32_t>() : sz);
	if (sz == -1)
	{
		logger->debug("{}: sz == -1", this->id);
		return false;
	}
	id_ = (id_ == -1 ? receive_pkg.read_integral<RdId::hash_t>() : id_);
	if (id_ == -1)
	{
		logger->error("id == -1");
		return false;
	}
	logger->trace("{}: message info: sz={}, id={}", this->id, sz, id_);
	const RdId rd_id{id_};
	sz -= 8;	// RdId
	message.require_available(sz);

	if (!receive_pkg.read(message.data() + message.get_position(), sz - message.get_position()))
	{
		logger->error("{}: constructing message failed", this->id);
		return false;
	}

	logger->debug("{}: message received", this->id);
	message_broker.dispatch(rd_id, std::move(message));
	logger->debug("{}: message dispatched", this->id);

	sz = -1;
	id_ = -1;
	message.rewind();
	return true;
	//		RD_ASSERT_MSG(summary_size == sz, "Broken message, read:%d bytes, expected:%d bytes", summary_size, sz)
}

CSimpleSocket* SocketWire::Base::get_socket_provider() const
{
	return socket_provider.get();
}

void SocketWire::Base::ping() const
{
	if (!connection_established(current_timestamp, counterpart_acknowledge_timestamp))
	{
		if (heartbeatAlive.get())
		{	 // only on change
			logger->trace(
				"Disconnect detected while sending PING {}: "
				"current_timestamp: {}, "
				"counterpart_timestamp: {}, "
				"counterpart_acknowledge_timestamp: {}",
				this->id, current_timestamp, counterpart_timestamp, counterpart_acknowledge_timestamp);
		}
		heartbeatAlive.set(false);
	}
	try
	{
		ping_pkg_header.set_position(sizeof(PING_MESSAGE_LENGTH));
		ping_pkg_header.write_integral(current_timestamp);
		ping_pkg_header.write_integral(counterpart_timestamp);
		{
			std::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);
			int32_t sent = socket_provider->Send(ping_pkg_header.data(), ping_pkg_header.get_position());
			if (sent == 0 && !socket_provider->IsSocketValid())
			{
				logger->debug("{}: failed to send ping over the network, reason: socket was shut down for sending", this->id);
				return;
			}
			RD_ASSERT_THROW_MSG(sent == PACKAGE_HEADER_LENGTH,
				fmt::format("{}: failed to send ping over the network, reason: {}", this->id, socket_provider->DescribeError()))
		}

		++current_timestamp;
	}
	catch (std::exception const& e)
	{
		logger->debug("{}: exception raised during PING | {}", this->id, e.what());
	}
}

bool SocketWire::Base::send_ack(sequence_number_t seqn) const
{
	logger->trace("{} send ack {}", id, seqn);
	try
	{
		ack_buffer.rewind();
		ack_buffer.write_integral(ACK_MESSAGE_LENGTH);
		ack_buffer.write_integral(seqn);
		{
			std::lock_guard<decltype(socket_send_lock)> guard(socket_send_lock);
			RD_ASSERT_THROW_MSG(socket_provider->Send(ack_buffer.data(), ack_buffer.get_position()) == PACKAGE_HEADER_LENGTH,
				this->id +
					": failed to send ack over the network"
					", reason: " +
					socket_provider->DescribeError())
		}
		return true;
	}
	catch (std::exception const& e)
	{
		logger->warn("{}: exception raised during ACK, seqn = {} | {}", id, seqn, e.what());
		return false;
	}
}

bool SocketWire::Base::try_shutdown_connection() const
{
	auto s = get_socket_provider();
	if (s == nullptr)
		return false;

	return s->Shutdown(CSimpleSocket::Both);
}

SocketWire::Client::Client(Lifetime parentLifetime, IScheduler* scheduler, uint16_t port, const std::string& id)
	: Base(id, parentLifetime, scheduler), port(port), clientLifetimeDefinition(parentLifetime)
{
	Lifetime lifetime = clientLifetimeDefinition.lifetime;
	thread = std::thread([this, lifetime]() mutable {
		rd::util::set_thread_name(this->id.empty() ? "SocketWire::Client Thread" : this->id.c_str());

		try
		{
			logger->info("{}: started, port: {}.", this->id, this->port);

			while (!lifetime->is_terminated())
			{
				try
				{
					socket = std::make_shared<CActiveSocket>();
					RD_ASSERT_THROW_MSG(socket->Initialize(),
						fmt::format("{}: failed to init ActiveSocket, reason: {}", this->id, socket->DescribeError()));
					RD_ASSERT_THROW_MSG(socket->DisableNagleAlgoritm(),
						fmt::format("{}: failed to DisableNagleAlgoritm, reason: {}", this->id, socket->DescribeError()));

					// On windows connect will try to send SYN 3 times with interval of 500ms (total time is 1second)
					// Connect timeout doesn't work if it's more than 1 second. But we don't need it because we can close socket any
					// moment.

					// https://stackoverflow.com/questions/22417228/prevent-tcp-socket-connection-retries
					// HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\TcpMaxConnectRetransmissions
					logger->info("{}: connecting 127.0.0.1: {}", this->id, this->port);
					RD_ASSERT_THROW_MSG(socket->Open("127.0.0.1", this->port),
						fmt::format("{}: failed to open ActiveSocket, reason: {}", this->id, socket->DescribeError()));
					{
						std::lock_guard<decltype(lock)> guard(lock);
						if (lifetime->is_terminated())
						{
							if (!socket->Close())
							{
								logger->error("{} failed to close socket, reason: {}", this->id, socket->DescribeError());
							}
							return;
						}
					}

					set_socket_provider(socket);
				}
				catch (std::exception const& e)
				{
					logger->debug("{}: connection error for port {} ({}).", this->id, this->port, e.what());

					std::lock_guard<decltype(lock)> guard(lock);
					bool should_reconnect = false;
					if (!lifetime->is_terminated())
					{
						cv.wait_for(lock, timeout);
						should_reconnect = !lifetime->is_terminated();
					}
					if (should_reconnect)
					{
						continue;
					}
					break;
				}
			}
		}
		catch (std::exception const& e)
		{
			logger->info("{}: closed with exception: {}", this->id, e.what());
		}
		logger->info("{}: terminated, port: {}.", this->id, this->port);
	});

	lifetime->add_action([this]() {
		logger->info("{}: starts terminating lifetime", this->id);

		const bool send_buffer_stopped = async_send_buffer.stop(timeout);
		logger->debug("{}: send buffer stopped, success: {}", this->id, send_buffer_stopped);

		{
			std::lock_guard<decltype(lock)> guard(lock);
			logger->debug("{}: closing socket", this->id);

			if (socket != nullptr)
			{
				if (!socket->Close())
				{
					logger->error("{}: failed to close socket", this->id);
				}
			}
		}
		cv.notify_all();

		logger->debug("{}: waiting for receiver thread", this->id);
		logger->debug("{}: is thread joinable? {}", this->id, thread.joinable());
		thread.join();
		logger->info("{}: termination finished", this->id);
	});
}

SocketWire::Client::~Client()
{
	if (!clientLifetimeDefinition.is_terminated())
	{
		clientLifetimeDefinition.terminate();
	}
}

SocketWire::Server::Server(Lifetime parentLifetime, IScheduler* scheduler, uint16_t port, const std::string& id)
	: Base(id, parentLifetime, scheduler), ss(std::make_unique<CPassiveSocket>()), serverLifetimeDefinition(parentLifetime)
{
#ifdef SIGPIPE
	signal(SIGPIPE, SIG_IGN);
#endif
	RD_ASSERT_MSG(ss->Initialize(), fmt::format("{}: failed to initialize socket, reason: {}", this->id, socket->DescribeError()));
	RD_ASSERT_MSG(ss->Listen("127.0.0.1", port),
		fmt::format("{}: failed to listen socket on port: {}, reason: {}", this->id, std::to_string(port), ss->DescribeError()));

	this->port = ss->GetServerPort();
	RD_ASSERT_MSG(this->port != 0, fmt::format("{}: port wasn't chosen", this->id));

	logger->info("{}: listening 127.0.0.1/{}", this->id, this->port);
	Lifetime lifetime = serverLifetimeDefinition.lifetime;

	thread = std::thread([this, lifetime]() mutable {
		rd::util::set_thread_name(this->id.empty() ? "SocketWire::Server Thread" : this->id.c_str());

		logger->info("{}: started, port: {}.", this->id, this->port);

		try
		{
			while (!lifetime->is_terminated())
			{
				try
				{
					logger->info("{}: accepting started", this->id);

					// [HACK]: Fix RIDER-51111.
					// winsock blocking accept hangs after creating new process with createprocess with inheritHandles=true
					// property. Unreal Engine uses the same logic for handling sockets where they wait for timeout on select
					// before trying to accept connection.
					while(ss->IsSocketValid() && !ss->Select(0, 300)){}

					CActiveSocket* accepted = ss->Accept();
					RD_ASSERT_THROW_MSG(
						accepted != nullptr, fmt::format("{}: accepting failed, reason: {}", this->id, ss->DescribeError()));
					socket.reset(accepted);
					logger->info("{}: accepted passive socket {}/{}", this->id, socket->GetClientAddr(), socket->GetClientPort());
					RD_ASSERT_THROW_MSG(socket->DisableNagleAlgoritm(),
						fmt::format("{}: tcpNoDelay failed, reason: {}", this->id, socket->DescribeError()));

					{
						std::lock_guard<decltype(lock)> guard(lock);
						if (lifetime->is_terminated())
						{
							logger->debug("{}: closing passive socket", this->id);
							if (!socket->Close())
							{
								logger->error("{}: failed to close socket", this->id);
							}
							logger->info("{}: close passive socket", this->id);
						}
					}

					logger->debug("{}: setting socket provider", this->id);
					set_socket_provider(socket);
				}
				catch (std::exception const& e)
				{
					logger->info("{}: closed with exception: {}", this->id, e.what());
				}
			}
		}
		catch (std::exception const& e)
		{
			logger->error("{}: terminal socket error ({}).", this->id, e.what());
		}

		logger->info("{}: terminated, port: {}.", this->id, this->port);
	});

	lifetime->add_action([this] {
		logger->info("{}: start terminating lifetime", this->id);

		const bool send_buffer_stopped = async_send_buffer.stop(timeout);
		logger->debug("{}: send buffer stopped, success: {}", this->id, send_buffer_stopped);

		logger->debug("{}: closing server socket", this->id);
		if (!ss->Close())
		{
			logger->error("{}: failed to close server socket", this->id);
		}

		{
			std::lock_guard<decltype(lock)> guard(lock);
			logger->debug("{}: closing socket", this->id);
			if (socket != nullptr)
			{
				if (!socket->Close())
				{
					logger->error("{}: failed to close socket", this->id);
				}
			}
		}

		logger->debug("{}: waiting for receiver thread", this->id);
		logger->debug("{}: is thread joinable? {}", this->id, thread.joinable());
		thread.join();
		logger->info("{}: termination finished", this->id);
	});
}

SocketWire::Server::~Server()
{
	if (!serverLifetimeDefinition.is_terminated())
	{
		serverLifetimeDefinition.terminate();
	}
}

}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/SocketWire.h`:

```h
#ifndef RD_CPP_SOCKETWIRE_H
#define RD_CPP_SOCKETWIRE_H

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include "scheduler/base/IScheduler.h"
#include "base/WireBase.h"
#include "ByteBufferAsyncProcessor.h"
#include "PkgInputStream.h"

#include <string>
#include <array>
#include <condition_variable>

#include <rd_framework_export.h>

class CSimpleSocket;
class CActiveSocket;
class CPassiveSocket;

namespace rd
{
class RD_FRAMEWORK_API SocketWire
{
	static std::chrono::milliseconds timeout;

public:
	class RD_FRAMEWORK_API Base : public WireBase
	{
	protected:
		static std::shared_ptr<spdlog::logger> logger;

		std::timed_mutex lock;
		mutable std::mutex socket_send_lock;
		mutable std::mutex wire_send_lock;

		std::thread thread{};

		std::string id;
		IScheduler* scheduler = nullptr;
		std::shared_ptr<CSimpleSocket> socket_provider;

		std::shared_ptr<CActiveSocket> socket;

		mutable std::condition_variable socket_send_var;
		mutable ByteBufferAsyncProcessor async_send_buffer{id + "-AsyncSendProcessor",
			[this](Buffer::ByteArray const& it, sequence_number_t seqn) -> bool { return this->send0(it, seqn); }};

		static constexpr size_t RECEIVE_BUFFER_SIZE = 1u << 16;
		mutable std::array<Buffer::word_t, RECEIVE_BUFFER_SIZE> receiver_buffer{};
		mutable decltype(receiver_buffer)::iterator lo = receiver_buffer.begin(), hi = receiver_buffer.begin();

		static constexpr int32_t ACK_MESSAGE_LENGTH = -1;
		static constexpr int32_t PING_MESSAGE_LENGTH = -2;
		static constexpr int32_t PACKAGE_HEADER_LENGTH = sizeof(ACK_MESSAGE_LENGTH) + sizeof(sequence_number_t);
		mutable Buffer ack_buffer{PACKAGE_HEADER_LENGTH};

		/**
		 * \brief Timestamp of this wire which increases at intervals of [heartBeatInterval].
		 */
		mutable int32_t current_timestamp = 0;

		/**
		 * \brief Actual knowledge about counterpart's [currentTimeStamp].
		 */
		mutable int32_t counterpart_timestamp = 0;

		/**
		 * \brief The latest received counterpart's acknowledge of this wire's [currentTimeStamp].
		 */
		mutable int32_t counterpart_acknowledge_timestamp = 0;

		mutable Buffer ping_pkg_header{PACKAGE_HEADER_LENGTH};

		mutable sequence_number_t max_received_seqn = 0;
		mutable Buffer send_package_header{PACKAGE_HEADER_LENGTH};

		static constexpr int32_t CHUNK_SIZE = 16370;
		mutable int32_t sz = -1;
		mutable RdId::hash_t id_ = -1;
		mutable PkgInputStream receive_pkg{[this]() -> int32_t { return this->read_package(); }};

		mutable Buffer message{CHUNK_SIZE};

		bool read_from_socket(Buffer::word_t* res, int32_t msglen) const;

		template <typename T>
		bool read_integral_from_socket(T& x) const
		{
			return read_from_socket(reinterpret_cast<Buffer::word_t*>(&x), sizeof(T));
		}

		bool read_data_from_socket(Buffer::word_t* data, size_t len) const
		{
			return read_from_socket(reinterpret_cast<Buffer::word_t*>(data), static_cast<int32_t>(len));
		}

		void set_socket_provider(std::shared_ptr<CActiveSocket> new_socket);

		CSimpleSocket* get_socket_provider() const;

	public:
		static constexpr int32_t MaximumHeartbeatDelay = 3;
		std::chrono::milliseconds heartBeatInterval = std::chrono::milliseconds(500);

		// region ctor/dtor

		Base(std::string id, Lifetime lifetime, IScheduler* scheduler);

		virtual ~Base() override;

		// endregion

		std::pair<int, sequence_number_t> read_header() const;

		int32_t read_package() const;

		bool read_and_dispatch_message() const;

		void receiverProc() const;

		bool send0(Buffer::ByteArray const& msg, sequence_number_t seqn) const;

		void send(RdId const& rd_id, std::function<void(Buffer& buffer)> writer) const override;

		static bool connection_established(int32_t timestamp, int32_t acknowledged_timestamp);

		std::future<void> start_heartbeat(Lifetime lifetime);

		void ping() const;

		bool send_ack(sequence_number_t seqn) const;

		bool try_shutdown_connection() const;
		
	private:		
		LifetimeDefinition lifetimeDef;
	};

	class RD_FRAMEWORK_API Client : public Base
	{
	public:
		uint16_t port = 0;

		// region ctor/dtor

		Client(Lifetime parentLifetime, IScheduler* scheduler, uint16_t port = 0, const std::string& id = "ClientSocket");

		virtual ~Client() override;
		// endregion

		std::condition_variable_any cv;
	private:		
		LifetimeDefinition clientLifetimeDefinition;
	};

	class RD_FRAMEWORK_API Server : public Base
	{
	public:
		uint16_t port = 0;

		std::unique_ptr<CPassiveSocket> ss;

		// region ctor/dtor

		Server(Lifetime lifetime, IScheduler* scheduler, uint16_t port = 0, const std::string& id = "ServerSocket");

		virtual ~Server() override;
		// endregion
	private:
		LifetimeDefinition serverLifetimeDefinition;
	};
};
}	 // namespace rd
#if defined(_MSC_VER)
#pragma warning(pop)
#endif


#endif	  // RD_CPP_SOCKETWIRE_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/WireUtil.cpp`:

```cpp
#include "wire/WireUtil.h"

#include "util/core_util.h"

#include "PassiveSocket.h"
#include "Host.h"

#include <utility>
#include <thread>

namespace rd
{
namespace util
{
uint16_t find_free_port()
{
	CPassiveSocket fake_server;
	fake_server.Initialize();
	fake_server.Listen("127.0.0.1", 0);
	uint16_t port = fake_server.GetServerPort();
	RD_ASSERT_MSG(port != 0, "no free port");
	return port;
}

void sleep_this_thread(int64_t ms)
{
	std::this_thread::sleep_for(std::chrono::milliseconds(ms));
}
}	 // namespace util
}	 // namespace rd

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_framework_cpp/src/main/wire/WireUtil.h`:

```h
#ifndef RD_CPP_WIREUTIL_H
#define RD_CPP_WIREUTIL_H

#include <cstdint>

#include <rd_framework_export.h>

namespace rd
{
namespace util
{
uint16_t RD_FRAMEWORK_API find_free_port();

void RD_FRAMEWORK_API sleep_this_thread(int64_t ms);
}	 // namespace util
}	 // namespace rd

#endif	  // RD_CPP_WIREUTIL_H

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_gen_cpp/src/RdTextBuffer.cpp`:

```cpp
#include "RdTextBuffer.h"

```

`Plugins/Developer/RiderLink/Source/RD/src/rd_gen_cpp/src/RdTextBuffer.h`:

```h
#ifndef RD_CPP_RDTEXTBUFFER_H
#define RD_CPP_RDTEXTBUFFER_H

namespace rd
{
class RdTextBuffer
{
};
}	 // namespace rd

#endif	  // RD_CPP_RDTEXTBUFFER_H

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE`:

```
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS


   Copyright (C) 2014 by Vitaliy Vitsentiy

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/README.md`:

```md
CTPL
====

Modern and efficient C++ Thread Pool Library


A thread pool is a programming pattern for parallel execution of jobs, http://en.wikipedia.org/wiki/Thread_pool_pattern.

More specifically, there are some threads dedicated to the pool and a container of jobs. The jobs come to the pool dynamically. A job is fetched and deleted from the container when there is an idle thread. The job is then run on that thread.

A thread pool is helpful when you want to minimize time of loading and destroying threads and when you want to limit the number of parallel jobs that run simultanuasly. For example, time consuming event handlers may be processed in a thread pool to make UI more responsive.

Features:
- standard c++ language, tested to compile on MS Visual Studio 2013 (2012?), gcc 4.8.2 and mingw 4.8.1(with posix threads)
- simple but effiecient solution, one header only, no need to compile a binary library
- query the number of idle threads and resize the pool dynamically
- one API to push to the thread pool any collable object: lambdas, functors, functions, result of bind expression
- collable objects with variadic number of parameters plus index of the thread running the object
- automatic template argument deduction
- get returned value of any type with standard c++ futures
- get fired exceptions with standard c++ futures
- use for any purpose under Apache license
- two variants, one depends on Boost Lockfree Queue library, http://boost.org, which is a header only library


Sample usage

<code>void first(int id) {
    std::cout << "hello from " << id << '\n';
}</code>

<code>&#32;&#32;struct Second {
    void operator()(int id) const {
        std::cout << "hello from " << id << '\n';
    }
} second;

<code>void third(int id, const std::string & additional_param) {}</code>


<code>int main () {</code>

<code>&#32;&#32;&#32;&#32;ctpl::thread_pool p(2 /* two threads in the pool */);</code>

<code>&#32;&#32;&#32;&#32;p.push(first);  // function</code>

<code>&#32;&#32;&#32;&#32;p.push(third, "additional_param");</code>

<code>&#32;&#32;&#32;&#32;p.push( &#91;&#93; (int id){
  std::cout << "hello from " << id << '\n';
});  // lambda</code>

<code>&#32;&#32;&#32;&#32;p.push(std::ref(second));  // functor, reference</code>

<code>&#32;&#32;&#32;&#32;p.push(const_cast&#60;const Second &&#62;(second));  // functor, copy ctor</code>

<code>&#32;&#32;&#32;&#32;p.push(std::move(second));  // functor, move ctor</code>

<code>}</code>

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/include/ctpl_stl.h`:

```h
/*********************************************************
*
*  Copyright (C) 2014 by Vitaliy Vitsentiy
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*********************************************************/


#ifndef __ctpl_stl_thread_pool_H__
#define __ctpl_stl_thread_pool_H__

#include <functional>
#include <thread>
#include <atomic>
#include <vector>
#include <memory>
#include <exception>
#include <future>
#include <mutex>
#include <queue>



// thread pool to run user's functors with signature
//      ret func(int id, other_params)
// where id is the index of the thread that runs the functor
// ret is some return type


namespace ctpl {

    namespace detail {
        template <typename T>
        class Queue {
        public:
            bool push(T const & value) {
                std::unique_lock<std::mutex> lock(this->mutex);
                this->q.push(value);
                return true;
            }
            // deletes the retrieved element, do not use for non integral types
            bool pop(T & v) {
                std::unique_lock<std::mutex> lock(this->mutex);
                if (this->q.empty())
                    return false;
                v = this->q.front();
                this->q.pop();
                return true;
            }
            bool empty() {
                std::unique_lock<std::mutex> lock(this->mutex);
                return this->q.empty();
            }
        private:
            std::queue<T> q;
            std::mutex mutex;
        };
    }

    class thread_pool {

    public:

        thread_pool() { this->init(); }
        thread_pool(int nThreads) { this->init(); this->resize(nThreads); }

        // the destructor waits for all the functions in the queue to be finished
        ~thread_pool() {
            this->stop(true);
        }

        // get the number of running threads in the pool
        int size() { return static_cast<int>(this->threads.size()); }

        // number of idle threads
        int n_idle() { return this->nWaiting; }
        std::thread & get_thread(int i) { return *this->threads[i]; }

        // change the number of threads in the pool
        // should be called from one thread, otherwise be careful to not interleave, also with this->stop()
        // nThreads must be >= 0
        void resize(int nThreads) {
            if (!this->isStop && !this->isDone) {
                int oldNThreads = static_cast<int>(this->threads.size());
                if (oldNThreads <= nThreads) {  // if the number of threads is increased
                    this->threads.resize(nThreads);
                    this->flags.resize(nThreads);

                    for (int i = oldNThreads; i < nThreads; ++i) {
                        this->flags[i] = std::make_shared<std::atomic<bool>>(false);
                        this->set_thread(i);
                    }
                }
                else {  // the number of threads is decreased
                    for (int i = oldNThreads - 1; i >= nThreads; --i) {
                        *this->flags[i] = true;  // this thread will finish
                        this->threads[i]->detach();
                    }
                    {
                        // stop the detached threads that were waiting
                        std::unique_lock<std::mutex> lock(this->mutex);
                        this->cv.notify_all();
                    }
                    this->threads.resize(nThreads);  // safe to delete because the threads are detached
                    this->flags.resize(nThreads);  // safe to delete because the threads have copies of shared_ptr of the flags, not originals
                }
            }
        }

        // empty the queue
        void clear_queue() {
            std::function<void(int id)> * _f;
            while (this->q.pop(_f))
                delete _f; // empty the queue
        }

        // pops a functional wrapper to the original function
        std::function<void(int)> pop() {
            std::function<void(int id)> * _f = nullptr;
            this->q.pop(_f);
            std::unique_ptr<std::function<void(int id)>> func(_f); // at return, delete the function even if an exception occurred
            std::function<void(int)> f;
            if (_f)
                f = *_f;
            return f;
        }

        // wait for all computing threads to finish and stop all threads
        // may be called asynchronously to not pause the calling thread while waiting
        // if isWait == true, all the functions in the queue are run, otherwise the queue is cleared without running the functions
        void stop(bool isWait = false) {
            if (!isWait) {
                if (this->isStop)
                    return;
                this->isStop = true;
                for (int i = 0, n = this->size(); i < n; ++i) {
                    *this->flags[i] = true;  // command the threads to stop
                }
                this->clear_queue();  // empty the queue
            }
            else {
                if (this->isDone || this->isStop)
                    return;
                this->isDone = true;  // give the waiting threads a command to finish
            }
            {
                std::unique_lock<std::mutex> lock(this->mutex);
                this->cv.notify_all();  // stop all waiting threads
            }
            for (int i = 0; i < static_cast<int>(this->threads.size()); ++i) {  // wait for the computing threads to finish
                    if (this->threads[i]->joinable())
                        this->threads[i]->join();
            }
            // if there were no threads in the pool but some functors in the queue, the functors are not deleted by the threads
            // therefore delete them here
            this->clear_queue();
            this->threads.clear();
            this->flags.clear();
        }

        template<typename F, typename... Rest>
        auto push(F && f, Rest&&... rest) ->std::future<decltype(f(0, rest...))> {
            auto pck = std::make_shared<std::packaged_task<decltype(f(0, rest...))(int)>>(
                std::bind(std::forward<F>(f), std::placeholders::_1, std::forward<Rest>(rest)...)
                );
            auto _f = new std::function<void(int id)>([pck](int id) {
                (*pck)(id);
            });
            this->q.push(_f);
            std::unique_lock<std::mutex> lock(this->mutex);
            this->cv.notify_one();
            return pck->get_future();
        }

        // run the user's function that excepts argument int - id of the running thread. returned value is templatized
        // operator returns std::future, where the user can get the result and rethrow the catched exceptins
        template<typename F>
        auto push(F && f) ->std::future<decltype(f(0))> {
            auto pck = std::make_shared<std::packaged_task<decltype(f(0))(int)>>(std::forward<F>(f));
            auto _f = new std::function<void(int id)>([pck](int id) {
                (*pck)(id);
            });
            this->q.push(_f);
            std::unique_lock<std::mutex> lock(this->mutex);
            this->cv.notify_one();
            return pck->get_future();
        }


    private:

        // deleted
        thread_pool(const thread_pool &);// = delete;
        thread_pool(thread_pool &&);// = delete;
        thread_pool & operator=(const thread_pool &);// = delete;
        thread_pool & operator=(thread_pool &&);// = delete;

        void set_thread(int i) {
            std::shared_ptr<std::atomic<bool>> flag(this->flags[i]); // a copy of the shared ptr to the flag
            auto f = [this, i, flag/* a copy of the shared ptr to the flag */]() {
                std::atomic<bool> & _flag = *flag;
                std::function<void(int id)> * _f;
                bool isPop = this->q.pop(_f);
                while (true) {
                    while (isPop) {  // if there is anything in the queue
                        std::unique_ptr<std::function<void(int id)>> func(_f); // at return, delete the function even if an exception occurred
                        (*_f)(i);
                        if (_flag)
                            return;  // the thread is wanted to stop, return even if the queue is not empty yet
                        else
                            isPop = this->q.pop(_f);
                    }
                    // the queue is empty here, wait for the next command
                    std::unique_lock<std::mutex> lock(this->mutex);
                    ++this->nWaiting;
                    this->cv.wait(lock, [this, &_f, &isPop, &_flag](){ isPop = this->q.pop(_f); return isPop || this->isDone || _flag; });
                    --this->nWaiting;
                    if (!isPop)
                        return;  // if the queue is empty and this->isDone == true or *flag then return
                }
            };
            this->threads[i].reset(new std::thread(f)); // compiler may not support std::make_unique()
        }

        void init() { this->nWaiting = 0; this->isStop = false; this->isDone = false; }

        std::vector<std::unique_ptr<std::thread>> threads;
        std::vector<std::shared_ptr<std::atomic<bool>>> flags;
        detail::Queue<std::function<void(int id)> *> q;
        std::atomic<bool> isDone;
        std::atomic<bool> isStop;
        std::atomic<int> nWaiting;  // how many threads are waiting

        std::mutex mutex;
        std::condition_variable cv;
    };

}

#endif // __ctpl_stl_thread_pool_H__

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/README`:

```
------------------------------------------------------------------------------------------
* History
------------------------------------------------------------------------------------------
Written by Mark Carrier to provide a mechanism for writing cross platform socket code. This library was originally written to only support blocking TCP sockets. Over the years it has been extended to support UDP and RAW sockets as well. This is the first official release of the library and the following functionality is supported:

    * Cross platform socket support.
          o Windows 95, Windows 98, Windows XP
          o Linux, Unix
          o Macintosh OSX
    * Support for sychronious, and asychronious sockets
    * Supports TCP Streams
    * Supports UDP Datagrams
    * Supports Raw Sockets
    * Thread Safe
    * Signal Safe

------------------------------------------------------------------------------------------
* Building and Installing	
------------------------------------------------------------------------------------------
This is a very small library and is very easy to build and configure.  To build and install
make sure you are logged in as a user who has access to the recommend GNU installation 
directories. Then type

make -BUILD=Release && make install

That is it now you are off and running.

NOTE: When using the library with WINDOWS you must define _WIN32 and when using with LINUX
      you must define _LINUX.

------------------------------------------------------------------------------------------
* SimpleSocket Class Overview
------------------------------------------------------------------------------------------
Network communications via sockets can be abstracted into two categories of functionality; the active socket and the passive socket. The active socket object initiates a connection with a known host, whereas the passive socket object waits (or listens) for inbound requests for communication. The functionality of both objects is identical as far as sending and receiving data. This library makes distinction between the two objects because the operations for constructing and destructing the two are different.

This library is different from other socket libraries which define TCP sockets, UDP sockets, HTTP sockets, etc. The reason is the operations required for TCP, UDP, and RAW network communication is identical from a logical stand point. Thus a program could initially be written employing TCP streams, and then at some future point it could be discovered that UDP datagrams would satisify the solution. Changing between the two transport protocols would only require changing how the object is instantiated. The remaining code would in theory require minimal to no changes.

This library avoids abstractions like HTTP socket, or SMTP socket, soley because this type of object mixes the application and the transport layer. These types of abstractions can be created using this library as a base class.

The simple socket library is comprised of two class which can be used to represent all socket communications.

    * Active Socket Class
    * Passive Socket Class 


------------------------------------------------------------------------------------------
* SimpleSocket Class Examples
------------------------------------------------------------------------------------------
When operating on a socket object most methods will return true or false
Simple Active Socket
As mentioned previously the active socket (CActiveSocket) is used to initiate a connections with a server on some known port. So you want to connect to an existing server...

How do you do it?

There are many ways using the existing Berkley Socket API, but the goal of this class is to remove the many calls and man page lookups and replace them with clear, concise set of methods which allow a developer to focus on the logic of network programming.

The following code will connect to a DAYTIME server on port 13, query for the current time, and close the socket.

#include <string.h>
#include "ActiveSocket.h"       // Include header for active socket object definition

int main(int argc, char **argv)
{
    CActiveSocket socket;       // Instantiate active socket object (defaults to TCP).
    char          time[50];

    memset(&time, 0, 50);

    //--------------------------------------------------------------------------
    // Initialize our socket object 
    //--------------------------------------------------------------------------
    socket.Initialize();

    //--------------------------------------------------------------------------
    // Create a connection to the time server so that data can be sent
    // and received.
    //--------------------------------------------------------------------------
    if (socket.Open("time-C.timefreq.bldrdoc.gov", 13))
    {
        //----------------------------------------------------------------------
        // Send a requtest the server requesting the current time.
        //----------------------------------------------------------------------
        if (socket.Send((const uint8 *)"\n", 1))
        {
            //----------------------------------------------------------------------
            // Receive response from the server.
            //----------------------------------------------------------------------
            socket.Receive(49);
            memcpy(&time, socket.GetData(), 49);
            printf("%s\n", time);

            //----------------------------------------------------------------------
            // Close the connection.
            //----------------------------------------------------------------------
            socket.Close();
        }
    }


    return 1;
}

You can see that the amount of code required to an object for network communciation is very small and simple.
Simple Passive Socket
Now you want to build a server.

How do you do it?

For a practical test lets build an echo server. The server will listen on port 6789 an repsond back with what ever has been sent to the server.

#include "PassiveSocket.h"       // Include header for active socket object definition

#define MAX_PACKET 4096 

int main(int argc, char **argv)
{
    CPassiveSocket socket;
    CActiveSocket *pClient = NULL;

    //--------------------------------------------------------------------------
    // Initialize our socket object 
    //--------------------------------------------------------------------------
    socket.Initialize();

    socket.Listen("127.0.0.1", 6789);

    while (true)
    {
        if ((pClient = socket.Accept()) != NULL)
        {
            //----------------------------------------------------------------------
            // Receive request from the client.
            //----------------------------------------------------------------------
            if (pClient->Receive(MAX_PACKET))
            {
                //------------------------------------------------------------------
                // Send response to client and close connection to the client.
                //------------------------------------------------------------------
                pClient->Send( pClient->GetData(), pClient->GetBytesReceived() );
                pClient->Close();
            }

            delete pClient;
        }
    }

    //-----------------------------------------------------------------------------
    // Receive request from the client.
    //-----------------------------------------------------------------------------
    socket.Close();

    return 1;
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/ActiveSocket.cpp`:

```cpp
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* CActiveSocket.cpp - Active Socket Implementation                          */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#include "ActiveSocket.h"

CActiveSocket::CActiveSocket(CSocketType nType) : CSimpleSocket(nType)
{
}

//------------------------------------------------------------------------------
//
// ConnectTCP() -
//
//------------------------------------------------------------------------------
bool CActiveSocket::ConnectTCP(const char *pAddr, uint16_t nPort)
{
    bool           bRetVal = false;
    struct in_addr stIpAddress;

    //------------------------------------------------------------------
    // Preconnection setup that must be preformed
    //------------------------------------------------------------------
    memset(&m_stServerSockaddr, 0, sizeof(m_stServerSockaddr));
    m_stServerSockaddr.sin_family = AF_INET;

    if ((m_pHE = GETHOSTBYNAME(pAddr)) == NULL)
    {
#ifdef _WIN32
        TranslateSocketError();
#else
        if (h_errno == HOST_NOT_FOUND)
        {
            SetSocketError(SocketInvalidAddress);
        }
#endif
        return bRetVal;
    }

    memcpy(&stIpAddress, m_pHE->h_addr_list[0], m_pHE->h_length);
    m_stServerSockaddr.sin_addr.s_addr = stIpAddress.s_addr;

    if ((int32_t)m_stServerSockaddr.sin_addr.s_addr == CSimpleSocket::SocketError)
    {
        TranslateSocketError();
        return bRetVal;
    }

    m_stServerSockaddr.sin_port = htons(nPort);

    //------------------------------------------------------------------
    // Connect to address "xxx.xxx.xxx.xxx"    (IPv4) address only.
    //
    //------------------------------------------------------------------
    m_timer.Initialize();
    m_timer.SetStartTime();

    if (connect(m_socket, (struct sockaddr*)&m_stServerSockaddr, sizeof(m_stServerSockaddr)) ==
            CSimpleSocket::SocketError)
    {
        //--------------------------------------------------------------
        // Get error value this might be a non-blocking new_socket so we
        // must first check.
        //--------------------------------------------------------------
        TranslateSocketError();

        //--------------------------------------------------------------
        // If the new_socket is non-blocking and the current new_socket error
        // is SocketEinprogress or SocketEwouldblock then poll connection
        // with select for designated timeout period.
        // Linux returns EINPROGRESS and Windows returns WSAEWOULDBLOCK.
        //--------------------------------------------------------------
        if ((IsNonblocking()) &&
                ((GetSocketError() == CSimpleSocket::SocketEwouldblock) ||
                 (GetSocketError() == CSimpleSocket::SocketEinprogress)))
        {
            bRetVal = Select(GetConnectTimeoutSec(), GetConnectTimeoutUSec());
        }
    }
    else
    {
        TranslateSocketError();
        bRetVal = true;
    }

    m_timer.SetEndTime();

    return bRetVal;
}

//------------------------------------------------------------------------------
//
// ConnectUDP() -
//
//------------------------------------------------------------------------------
bool CActiveSocket::ConnectUDP(const char *pAddr, uint16_t nPort)
{
    bool           bRetVal = false;
    struct in_addr stIpAddress;

    //------------------------------------------------------------------
    // Pre-connection setup that must be preformed
    //------------------------------------------------------------------
    memset(&m_stServerSockaddr, 0, sizeof(m_stServerSockaddr));
    m_stServerSockaddr.sin_family = AF_INET;

    if ((m_pHE = GETHOSTBYNAME(pAddr)) == NULL)
    {
#ifdef _WIN32
        TranslateSocketError();
#else
        if (h_errno == HOST_NOT_FOUND)
        {
            SetSocketError(SocketInvalidAddress);
        }
#endif
        return bRetVal;
    }

    memcpy(&stIpAddress, m_pHE->h_addr_list[0], m_pHE->h_length);
    m_stServerSockaddr.sin_addr.s_addr = stIpAddress.s_addr;

    if ((int32_t)m_stServerSockaddr.sin_addr.s_addr == CSimpleSocket::SocketError)
    {
        TranslateSocketError();
        return bRetVal;
    }

    m_stServerSockaddr.sin_port = htons(nPort);

    //------------------------------------------------------------------
    // Connect to address "xxx.xxx.xxx.xxx"    (IPv4) address only.
    //
    //------------------------------------------------------------------
    m_timer.Initialize();
    m_timer.SetStartTime();

    if (connect(m_socket, (struct sockaddr*)&m_stServerSockaddr, sizeof(m_stServerSockaddr)) != CSimpleSocket::SocketError)
    {
        bRetVal = true;
    }

    TranslateSocketError();

    m_timer.SetEndTime();

    return bRetVal;
}

//------------------------------------------------------------------------------
//
// ConnectRAW() -
//
//------------------------------------------------------------------------------
bool CActiveSocket::ConnectRAW(const char *pAddr, uint16_t nPort)
{
    bool           bRetVal = false;
    struct in_addr stIpAddress;
    //------------------------------------------------------------------
    // Pre-connection setup that must be preformed
    //------------------------------------------------------------------
    memset(&m_stServerSockaddr, 0, sizeof(m_stServerSockaddr));
    m_stServerSockaddr.sin_family = AF_INET;

    if ((m_pHE = GETHOSTBYNAME(pAddr)) == NULL)
    {
#ifdef _WIN32
        TranslateSocketError();
#else
        if (h_errno == HOST_NOT_FOUND)
        {
            SetSocketError(SocketInvalidAddress);
        }
#endif
        return bRetVal;
    }

    memcpy(&stIpAddress, m_pHE->h_addr_list[0], m_pHE->h_length);
    m_stServerSockaddr.sin_addr.s_addr = stIpAddress.s_addr;

    if ((int32_t)m_stServerSockaddr.sin_addr.s_addr == CSimpleSocket::SocketError)
    {
        TranslateSocketError();
        return bRetVal;
    }

    m_stServerSockaddr.sin_port = htons(nPort);

    //------------------------------------------------------------------
    // Connect to address "xxx.xxx.xxx.xxx"    (IPv4) address only.
    //
    //------------------------------------------------------------------
    m_timer.Initialize();
    m_timer.SetStartTime();

    if (connect(m_socket, (struct sockaddr*)&m_stServerSockaddr, sizeof(m_stServerSockaddr)) != CSimpleSocket::SocketError)
    {
        bRetVal = true;
    }

    TranslateSocketError();

    m_timer.SetEndTime();

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Open() - Create a connection to a specified address on a specified port
//
//------------------------------------------------------------------------------
bool CActiveSocket::Open(const char *pAddr, uint16_t nPort)
{
    bool bRetVal = false;

    if (IsSocketValid() == false)
    {
        SetSocketError(CSimpleSocket::SocketInvalidSocket);
        return bRetVal;
    }

    if (pAddr == NULL)
    {
        SetSocketError(CSimpleSocket::SocketInvalidAddress);
        return bRetVal;
    }

    if (nPort == 0)
    {
        SetSocketError(CSimpleSocket::SocketInvalidPort);
        return bRetVal;
    }

    switch (m_nSocketType)
    {
    case CSimpleSocket::SocketTypeTcp :
    {
        bRetVal = ConnectTCP(pAddr, nPort);
        break;
    }
    case CSimpleSocket::SocketTypeUdp :
    {
        bRetVal = ConnectUDP(pAddr, nPort);
        break;
    }
    case CSimpleSocket::SocketTypeRaw :
        break;
    default:
        break;
    }

    //--------------------------------------------------------------------------
    // If successful then create a local copy of the address and port
    //--------------------------------------------------------------------------
    if (bRetVal)
    {
        socklen_t nSockLen = sizeof(struct sockaddr);

        memset(&m_stServerSockaddr, 0, nSockLen);
        getpeername(m_socket, (struct sockaddr *)&m_stServerSockaddr, &nSockLen);

        nSockLen = sizeof(struct sockaddr);
        memset(&m_stClientSockaddr, 0, nSockLen);
        getsockname(m_socket, (struct sockaddr *)&m_stClientSockaddr, &nSockLen);

        SetSocketError(SocketSuccess);
    }

    return bRetVal;
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/ActiveSocket.h`:

```h
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* ActiveSocket.h - Active Socket Decleration                                */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#ifndef __ACTIVESOCKET_H__
#define __ACTIVESOCKET_H__

#include "SimpleSocket.h"

class CPassiveSocket;

/// Provides a platform independent class to create an active socket.
/// An active socket is used to create a socket which connects to a server.
/// This type of object would be used when an application needs to send/receive
/// data from a server.
class CActiveSocket : public CSimpleSocket {
public:
    friend class CPassiveSocket;

    CActiveSocket(CSocketType type = SocketTypeTcp);

    CActiveSocket(CActiveSocket &&) noexcept = default;

    CActiveSocket &operator=(CActiveSocket &&) noexcept = default;

    virtual ~CActiveSocket() {
        Close();
    };

    /// Established a connection to the address specified by pAddr.
    /// Connection-based protocol sockets (CSocket::SocketTypeTcp) may
    /// successfully call Open() only once, however; connectionless protocol
    /// sockets (CSocket::SocketTypeUdp) may use Open() multiple times to
    /// change their association.
    ///  @param pAddr specifies the destination address to connect.
    ///  @param nPort specifies the destination port.
    ///  @return true if successful connection made, otherwise false.
    virtual bool Open(const char *pAddr, uint16_t nPort);

private:
    /// Utility function used to create a TCP connection, called from Open().
    ///  @return true if successful connection made, otherwise false.
    bool ConnectTCP(const char *pAddr, uint16_t nPort);

    /// Utility function used to create a UDP connection, called from Open().
    ///  @return true if successful connection made, otherwise false.
    bool ConnectUDP(const char *pAddr, uint16_t nPort);

    /// Utility function used to create a RAW connection, called from Open().
    ///  @return true if successful connection made, otherwise false.
    bool ConnectRAW(const char *pAddr, uint16_t nPort);

private:
    struct hostent *m_pHE;
};

#endif /*  __ACTIVESOCKET_H__  */


```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/Host.h`:

```h
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Host.h - Basic header file to provide cross-platform solutions via        */
/*                   macros, conditional compilation, etc.                   */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#ifndef __HOST_H__
#define __HOST_H__

#include <limits.h>
#include <cstdint>

#ifdef __cplusplus
extern "C"
{
#endif

/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Type Definition Macros                                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/
#ifndef __WORDSIZE
  /* Assume 32 */
  #define __WORDSIZE 32
#endif

#if defined(__linux__) || defined(_DARWIN)
    typedef int            SOCKET;
#endif

#ifdef _WIN32
    struct iovec {
        void  *iov_base;
        size_t iov_len;
    };
#endif

#ifdef _WIN32
    typedef int socklen_t;
#endif

#ifdef _WIN32

  #ifndef UINT8_MAX
    #define UINT8_MAX  (UCHAR_MAX)
  #endif
  #ifndef UINT16_MAX
    #define UINT16_MAX (USHRT_MAX)
  #endif
  #ifndef UINT32_MAX
    #define UINT32_MAX (ULONG_MAX)
  #endif

  #if __WORDSIZE == 64
    #define SIZE_MAX (18446744073709551615UL)
  #else
    #ifndef SIZE_MAX
    #define SIZE_MAX (4294967295U)
  #endif
  #endif
#endif

#if defined(_WIN32)
  #define ssize_t size_t
#endif

#ifndef TRUE
  #define TRUE 1
#endif

#ifndef FALSE
  #define FALSE 0
#endif

#ifndef htonll
#ifdef _BIG_ENDIAN
#define htonll(x)   (x)
#define ntohll(x)   (x)
#else
#define htonll(x)   ((((uint64_t)htonl(x)) << 32) + htonl(x >> 32))
#define ntohll(x)   ((((uint64_t)ntohl(x)) << 32) + ntohl(x >> 32))
#endif
#endif

/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Socket Macros                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
#ifdef _WIN32
#define SHUT_RD                0
#define SHUT_WR                1
#define SHUT_RDWR              2
#define ACCEPT(a,b,c)          accept(a,b,c)
#define CONNECT(a,b,c)         connect(a,b,c)
#define CLOSE(a)               closesocket(a)
#define READ(a,b,c)            read(a,b,c)
#define RECV(a,b,c,d)          recv(a, (char *)b, c, d)
#define RECVFROM(a,b,c,d,e,f)  recvfrom(a, (char *)b, c, d, (sockaddr *)e, (int *)f)
#define RECV_FLAGS             MSG_WAITALL
#define SELECT(a,b,c,d,e)      select((int32_t)a,b,c,d,e)
#define SEND(a,b,c,d)          send(a, (const char *)b, (int)c, d)
#define SENDTO(a,b,c,d,e,f)    sendto(a, (const char *)b, (int)c, d, e, f)
#define SEND_FLAGS             0
#define SENDFILE(a,b,c,d)      sendfile(a, b, c, d)
#define SET_SOCKET_ERROR(x,y)  errno=y
#define SOCKET_ERROR_INTERUPT  EINTR
#define SOCKET_ERROR_TIMEDOUT  EAGAIN
#define WRITE(a,b,c)           write(a,b,c)
#define WRITEV(a,b,c)          Writev(b, c)
#define GETSOCKOPT(a,b,c,d,e)  getsockopt(a,b,c,(char *)d, (int *)e)
#define SETSOCKOPT(a,b,c,d,e)  setsockopt(a,b,c,(char *)d, (int)e)
#define GETHOSTBYNAME(a)       gethostbyname(a)
#endif

#if defined(__linux__) || defined(_DARWIN)
#define ACCEPT(a,b,c)          accept(a,b,c)
#define CONNECT(a,b,c)         connect(a,b,c)
#define CLOSE(a)               close(a)
#define READ(a,b,c)            read(a,b,c)
#define RECV(a,b,c,d)          recv(a, (void *)b, c, d)
#define RECVFROM(a,b,c,d,e,f)  recvfrom(a, (char *)b, c, d, (sockaddr *)e, f)
#define RECV_FLAGS             MSG_WAITALL
#define SELECT(a,b,c,d,e)      select(a,b,c,d,e)
#define SEND(a,b,c,d)          send(a, (const int8_t *)b, c, d)
#define SENDTO(a,b,c,d,e,f)    sendto(a, (const int8_t *)b, c, d, e, f)
#define SEND_FLAGS             0
#define SENDFILE(a,b,c,d)      sendfile(a, b, c, d)
#define SET_SOCKET_ERROR(x,y)  errno=y
#define SOCKET_ERROR_INTERUPT  EINTR
#define SOCKET_ERROR_TIMEDOUT  EAGAIN
#define WRITE(a,b,c)           write(a,b,c)
#define WRITEV(a,b,c)          writev(a, b, c)
#define GETSOCKOPT(a,b,c,d,e)  getsockopt((int)a,(int)b,(int)c,(void *)d,(socklen_t *)e)
#define SETSOCKOPT(a,b,c,d,e)  setsockopt((int)a,(int)b,(int)c,(const void *)d,(int)e)
#define GETHOSTBYNAME(a)       gethostbyname(a)
#endif


/*---------------------------------------------------------------------------*/
/*                                                                           */
/* File Macros                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
#define STRUCT_STAT         struct stat
#define LSTAT(x,y)          lstat(x,y)
#define FILE_HANDLE         FILE *
#define CLEARERR(x)         clearerr(x)
#define FCLOSE(x)           fclose(x)
#define FEOF(x)             feof(x)
#define FERROR(x)           ferror(x)
#define FFLUSH(x)           fflush(x)
#define FILENO(s)           fileno(s)
#define FOPEN(x,y)          fopen(x, y)
  //#define FREAD(a,b,c,d)      fread(a, b, c, d)
#define FSTAT(s, st)        fstat(FILENO(s), st)
    //#define FWRITE(a,b,c,d)     fwrite(a, b, c, d)
#define STAT_BLK_SIZE(x)    ((x).st_blksize)


/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Misc Macros                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
#if defined(_WIN32)
  #define GET_CLOCK_COUNT(x) QueryPerformanceCounter((LARGE_INTEGER *)x)
#else
  #define GET_CLOCK_COUNT(x) gettimeofday(x, NULL)
#endif

#if defined(_WIN32)
  #define STRTOULL(x) _atoi64(x)
#else
  #define STRTOULL(x) strtoull(x, NULL, 10)
#endif

#if defined(_WIN32)
  #define SNPRINTF _snprintf
  #define PRINTF   printf
  #define VPRINTF  vprintf
  #define FPRINTF  fprintf
#else
  #define SNPRINTF snprintf
  #define PRINTF   printf
  #define VPRINTF  vprintf
  #define FPRINTF  fprintf
#endif

#ifdef __cplusplus
}
#endif

#endif /* __HOST_H__ */

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/PassiveSocket.cpp`:

```cpp
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* PassiveSocket.cpp - Passive Socket Implementation                         */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#include "PassiveSocket.h"


CPassiveSocket::CPassiveSocket(CSocketType nType) : CSimpleSocket(nType) {
}

bool CPassiveSocket::BindMulticast(const char *pInterface, const char *pGroup, uint16_t nPort) {
    bool bRetVal = false;
#ifdef _WIN32
    ULONG inAddr;
#else
    in_addr_t      inAddr;
#endif

    //--------------------------------------------------------------------------
    // Set the following new_socket option SO_REUSEADDR.  This will allow the file
    // descriptor to be reused immediately after the new_socket is closed instead
    // of setting in a TIMED_WAIT state.
    //--------------------------------------------------------------------------
    memset(&m_stMulticastGroup, 0, sizeof(m_stMulticastGroup));
    m_stMulticastGroup.sin_family = AF_INET;
    m_stMulticastGroup.sin_port = htons(nPort);

    //--------------------------------------------------------------------------
    // If no IP Address (interface ethn) is supplied, or the loop back is
    // specified then bind to any interface, else bind to specified interface.
    //--------------------------------------------------------------------------
    if ((pInterface == NULL) || (!strlen(pInterface))) {
        m_stMulticastGroup.sin_addr.s_addr = htonl(INADDR_ANY);
    } else {
        if ((inAddr = inet_addr(pInterface)) != INADDR_NONE) {
            m_stMulticastGroup.sin_addr.s_addr = inAddr;
        }
    }

    //--------------------------------------------------------------------------
    // Bind to the specified port
    //--------------------------------------------------------------------------
    if (bind(m_socket, (struct sockaddr *) &m_stMulticastGroup, sizeof(m_stMulticastGroup)) == 0) {
        //----------------------------------------------------------------------
        // Join the multicast group
        //----------------------------------------------------------------------
        m_stMulticastRequest.imr_multiaddr.s_addr = inet_addr(pGroup);
        m_stMulticastRequest.imr_interface.s_addr = m_stMulticastGroup.sin_addr.s_addr;

        if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                       (void *) &m_stMulticastRequest,
                       sizeof(m_stMulticastRequest)) == CSimpleSocket::SocketSuccess) {
            bRetVal = true;
        }

        m_timer.SetEndTime();
    }

    m_timer.Initialize();
    m_timer.SetStartTime();


    //--------------------------------------------------------------------------
    // If there was a new_socket error then close the new_socket to clean out the
    // connection in the backlog.
    //--------------------------------------------------------------------------
    TranslateSocketError();

    if (bRetVal == false) {
        Close();
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Listen() -
//
//------------------------------------------------------------------------------
bool CPassiveSocket::Listen(const char *pAddr, uint16_t nPort, int32_t nConnectionBacklog) {
    bool bRetVal = false;
#ifdef _WIN32
    ULONG inAddr;
#else
    in_addr_t      inAddr;

    int32_t          nReuse;
    nReuse = IPTOS_LOWDELAY;

    //--------------------------------------------------------------------------
    // Set the following new_socket option SO_REUSEADDR.  This will allow the file
    // descriptor to be reused immediately after the new_socket is closed instead
    // of setting in a TIMED_WAIT state.
    //--------------------------------------------------------------------------
    SETSOCKOPT(m_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&nReuse, sizeof(int32_t));
    SETSOCKOPT(m_socket, IPPROTO_TCP, IP_TOS, &nReuse, sizeof(int32_t));
#endif

    memset(&m_stServerSockaddr, 0, sizeof(m_stServerSockaddr));
    m_stServerSockaddr.sin_family = AF_INET;
    m_stServerSockaddr.sin_port = htons(nPort);

    //--------------------------------------------------------------------------
    // If no IP Address (interface ethn) is supplied, or the loop back is
    // specified then bind to any interface, else bind to specified interface.
    //--------------------------------------------------------------------------
    if ((pAddr == NULL) || (!strlen(pAddr))) {
        m_stServerSockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    } else {
        if ((inAddr = inet_addr(pAddr)) != INADDR_NONE) {
            m_stServerSockaddr.sin_addr.s_addr = inAddr;
        }
    }

    m_timer.Initialize();
    m_timer.SetStartTime();

    //--------------------------------------------------------------------------
    // Bind to the specified port
    //--------------------------------------------------------------------------
    if (bind(m_socket, (struct sockaddr *) &m_stServerSockaddr, sizeof(m_stServerSockaddr)) !=
        CSimpleSocket::SocketError) {
        socklen_t namelen = sizeof(m_stServerSockaddr);
        if (getsockname(m_socket, (struct sockaddr *) &m_stServerSockaddr, &namelen) != CSimpleSocket::SocketError) {
            if (m_nSocketType == CSimpleSocket::SocketTypeTcp) {
                if (listen(m_socket, nConnectionBacklog) != CSimpleSocket::SocketError) {
                    bRetVal = true;
                }
            } else {
                bRetVal = true;
            }
        } else {
            bRetVal = false;
        }
    }

    m_timer.SetEndTime();

    //--------------------------------------------------------------------------
    // If there was a new_socket error then close the new_socket to clean out the
    // connection in the backlog.
    //--------------------------------------------------------------------------
    TranslateSocketError();

    if (bRetVal == false) {
        CSocketError err = GetSocketError();
        Close();
        SetSocketError(err);
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Accept() -
//
//------------------------------------------------------------------------------
CActiveSocket *CPassiveSocket::Accept() {
    uint32_t nSockLen;
    CActiveSocket *pClientSocket = NULL;
    SOCKET socket = static_cast<SOCKET>(CSimpleSocket::SocketError);

    if (m_nSocketType != CSimpleSocket::SocketTypeTcp) {
        SetSocketError(CSimpleSocket::SocketProtocolError);
        return pClientSocket;
    }

    pClientSocket = new CActiveSocket();

    //--------------------------------------------------------------------------
    // Wait for incoming connection.
    //--------------------------------------------------------------------------
    if (pClientSocket != NULL) {
        CSocketError socketErrno = SocketSuccess;

        m_timer.Initialize();
        m_timer.SetStartTime();

        nSockLen = sizeof(m_stClientSockaddr);

        do {
            errno = 0;
            socket = accept(m_socket, (struct sockaddr *) &m_stClientSockaddr, (socklen_t *) &nSockLen);

            if (socket != static_cast<SOCKET>(-1)) {
                pClientSocket->SetSocketHandle(socket);
                pClientSocket->TranslateSocketError();
                socketErrno = pClientSocket->GetSocketError();
                socklen_t nSockLen = sizeof(struct sockaddr);

                //-------------------------------------------------------------
                // Store client and server IP and port information for this
                // connection.
                //-------------------------------------------------------------
                getpeername(m_socket, (struct sockaddr *) &pClientSocket->m_stClientSockaddr, &nSockLen);
                memcpy((void *) &pClientSocket->m_stClientSockaddr, (void *) &m_stClientSockaddr, nSockLen);

                memset(&pClientSocket->m_stServerSockaddr, 0, nSockLen);
                getsockname(m_socket, (struct sockaddr *) &pClientSocket->m_stServerSockaddr, &nSockLen);
            } else {
                TranslateSocketError();
                socketErrno = GetSocketError();
            }

        } while (socketErrno == CSimpleSocket::SocketInterrupted);

        m_timer.SetEndTime();

        if (socketErrno != CSimpleSocket::SocketSuccess) {
            delete pClientSocket;
            pClientSocket = NULL;
        }
    }

    return pClientSocket;
}


//------------------------------------------------------------------------------
//
// Send() - Send data on a valid new_socket
//
//------------------------------------------------------------------------------
int32_t CPassiveSocket::Send(const uint8_t *pBuf, size_t bytesToSend) {
    SetSocketError(SocketSuccess);
    m_nBytesSent = 0;

    switch (m_nSocketType) {
        case CSimpleSocket::SocketTypeUdp: {
            if (IsSocketValid()) {
                if ((bytesToSend > 0) && (pBuf != NULL)) {
                    m_timer.Initialize();
                    m_timer.SetStartTime();

                    m_nBytesSent = SENDTO(m_socket, pBuf, bytesToSend, 0,
                                          (const sockaddr *) &m_stClientSockaddr,
                                          sizeof(m_stClientSockaddr));

                    m_timer.SetEndTime();

                    if (m_nBytesSent == CSimpleSocket::SocketError) {
                        TranslateSocketError();
                    }
                }
            }
            break;
        }
        case CSimpleSocket::SocketTypeTcp:
            CSimpleSocket::Send(pBuf, bytesToSend);
            break;
        default:
            SetSocketError(SocketProtocolError);
            break;
    }

    return m_nBytesSent;
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/PassiveSocket.h`:

```h
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Socket.h - Passive Socket Decleration.                                    */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#ifndef __PASSIVESOCKET_H__
#define __PASSIVESOCKET_H__
#include "ActiveSocket.h"

/// Provides a platform independent class to create a passive new_socket.
/// A passive new_socket is used to create a "listening" new_socket.  This type
/// of object would be used when an application needs to wait for
/// inbound connections.  Support for CSimpleSocket::SocketTypeTcp,
/// CSimpleSocket::SocketTypeUdp, and CSimpleSocket::SocketTypeRaw is handled
/// in a similar fashion.  The big difference is that the method
/// CPassiveSocket::Accept should not be called on the latter two new_socket
/// types.
class CPassiveSocket : public CSimpleSocket {
public:
    CPassiveSocket(CSocketType type = SocketTypeTcp);
    virtual ~CPassiveSocket() {
        Close();
    };

    /// Extracts the first connection request on the queue of pending
    /// connections and creates a newly connected new_socket.  Used with
    /// CSocketType CSimpleSocket::SocketTypeTcp.  It is the responsibility of
    /// the caller to delete the returned object when finished.
    ///  @return if successful a pointer to a newly created CActiveSocket object
    ///          will be returned and the internal error condition of the CPassiveSocket
    ///          object will be CPassiveSocket::SocketSuccess.  If an error condition was encountered
    ///          the NULL will be returned and one of the following error conditions will be set:
    ///    CPassiveSocket::SocketEwouldblock, CPassiveSocket::SocketInvalidSocket,
    ///    CPassiveSocket::SocketConnectionAborted, CPassiveSocket::SocketInterrupted
    ///    CPassiveSocket::SocketProtocolError, CPassiveSocket::SocketFirewallError
    virtual CActiveSocket *Accept(void);

    /// Bind to a multicast group on  a specified interface, multicast group, and port
    ///
    ///  @param pInterface - interface on which to bind.
    ///  @param pGroup - multicast group address to bind.
    ///  @param nPort - port on which multicast
    ///  @return true if able to bind to interface and multicast group.
    ///      If not successful, the false is returned and one of the following error
    ///      condiitions will be set: CPassiveSocket::SocketAddressInUse, CPassiveSocket::SocketProtocolError,
    ///      CPassiveSocket::SocketInvalidSocket.  The following new_socket errors are for Linux/Unix
    ///      derived systems only: CPassiveSocket::SocketInvalidSocketBuffer
    bool BindMulticast(const char *pInterface, const char *pGroup, uint16_t nPort);

    /// Create a listening new_socket at local ip address 'x.x.x.x' or 'localhost'
    /// if pAddr is NULL on port nPort.
    ///
    ///  @param pAddr specifies the IP address on which to listen.
    ///  @param nPort specifies the port on which to listen.
    ///  @param nConnectionBacklog specifies connection queue backlog (default 30,000)
    ///  @return true if a listening new_socket was created.
    ///      If not successful, the false is returned and one of the following error
    ///      conditions will be set: CPassiveSocket::SocketAddressInUse, CPassiveSocket::SocketProtocolError,
    ///      CPassiveSocket::SocketInvalidSocket.  The following new_socket errors are for Linux/Unix
    ///      derived systems only: CPassiveSocket::SocketInvalidSocketBuffer
    virtual bool Listen(const char *pAddr, uint16_t nPort, int32_t nConnectionBacklog = 30000);

    /// Attempts to send a block of data on an established connection.
    /// @param pBuf block of data to be sent.
    /// @param bytesToSend size of data block to be sent.
    /// @return number of bytes actually sent, return of zero means the
    /// connection has been shutdown on the other side, and a return of -1
    /// means that an error has occurred.  If an error was signaled then one
    /// of the following error codes will be set: CPassiveSocket::SocketInvalidSocket,
    /// CPassiveSocket::SocketEwouldblock, SimpleSocket::SocketConnectionReset,
    /// CPassiveSocket::SocketInvalidSocketBuffer, CPassiveSocket::SocketInterrupted,
    /// CPassiveSocket::SocketProtocolError, CPassiveSocket::SocketNotconnected
    /// <br>\b Note: This function is used only for a new_socket of type
    /// CSimpleSocket::SocketTypeUdp
    virtual int32_t Send(const uint8_t *pBuf, size_t bytesToSend);

private:
    struct ip_mreq  m_stMulticastRequest;   /// group address for multicast

};

#endif // __PASSIVESOCKET_H__

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp`:

```cpp
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* CSimpleSocket.cpp - CSimpleSocket Implementation                          */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#include "SimpleSocket.h"

CSimpleSocket::CSimpleSocket(CSocketType nType) :
    m_socket(INVALID_SOCKET),
    m_socketErrno(CSimpleSocket::SocketInvalidSocket),
    m_pBuffer(NULL), m_nBufferSize(0), m_nSocketDomain(AF_INET),
    m_nSocketType(SocketTypeInvalid), m_nBytesReceived(-1),
    m_nBytesSent(-1), m_nFlags(0),
    m_bIsBlocking(true)
{
    SetConnectTimeout(1, 0);
    memset(&m_stRecvTimeout, 0, sizeof(struct timeval));
    memset(&m_stSendTimeout, 0, sizeof(struct timeval));
    memset(&m_stLinger, 0, sizeof(struct linger));

    switch(nType)
    {
        //----------------------------------------------------------------------
        // Declare socket type stream - TCP
        //----------------------------------------------------------------------
    case CSimpleSocket::SocketTypeTcp:
    {
        m_nSocketDomain = AF_INET;
        m_nSocketType = CSimpleSocket::SocketTypeTcp;
        break;
    }
    case CSimpleSocket::SocketTypeTcp6:
    {
        m_nSocketDomain = AF_INET6;
        m_nSocketType = CSimpleSocket::SocketTypeTcp6;
        break;
    }
    //----------------------------------------------------------------------
    // Declare socket type datagram - UDP
    //----------------------------------------------------------------------
    case CSimpleSocket::SocketTypeUdp:
    {
        m_nSocketDomain = AF_INET;
        m_nSocketType = CSimpleSocket::SocketTypeUdp;
        break;
    }
    case CSimpleSocket::SocketTypeUdp6:
    {
        m_nSocketDomain = AF_INET6;
        m_nSocketType = CSimpleSocket::SocketTypeUdp6;
        break;
    }
    //----------------------------------------------------------------------
    // Declare socket type raw Ethernet - Ethernet
    //----------------------------------------------------------------------
    case CSimpleSocket::SocketTypeRaw:
    {
#if defined(__linux__) && !defined(_DARWIN)
        m_nSocketDomain = AF_PACKET;
        m_nSocketType = CSimpleSocket::SocketTypeRaw;
#endif
#ifdef _WIN32
        m_nSocketType = CSimpleSocket::SocketTypeInvalid;
#endif
        break;
    }
    default:
        m_nSocketType = CSimpleSocket::SocketTypeInvalid;
        break;
    }
}

CSimpleSocket::CSimpleSocket(CSimpleSocket &socket)
{
    m_pBuffer = new uint8_t[socket.m_nBufferSize];
    m_nBufferSize = socket.m_nBufferSize;
    memcpy(m_pBuffer, socket.m_pBuffer, socket.m_nBufferSize);
}

CSimpleSocket *CSimpleSocket::operator=(CSimpleSocket &socket)
{
    if (m_nBufferSize != socket.m_nBufferSize)
    {
        delete m_pBuffer;
        m_pBuffer = new uint8_t[socket.m_nBufferSize];
        m_nBufferSize = socket.m_nBufferSize;
        memcpy(m_pBuffer, socket.m_pBuffer, socket.m_nBufferSize);
    }

    return this;
}


//------------------------------------------------------------------------------
//
// Initialize() - Initialize socket class
//
//------------------------------------------------------------------------------
bool CSimpleSocket::Initialize()
{
    errno = CSimpleSocket::SocketSuccess;

#ifdef _WIN32
    //-------------------------------------------------------------------------
    // Data structure containing general Windows Sockets Info
    //-------------------------------------------------------------------------
    memset(&m_hWSAData, 0, sizeof(m_hWSAData));
    WSAStartup(MAKEWORD(2, 0), &m_hWSAData);
#endif

    //-------------------------------------------------------------------------
    // Create the basic Socket Handle
    //-------------------------------------------------------------------------
    m_timer.Initialize();
    m_timer.SetStartTime();
    m_socket = socket(m_nSocketDomain, m_nSocketType, 0);
    m_timer.SetEndTime();

    TranslateSocketError();

    return (IsSocketValid());
}


//------------------------------------------------------------------------------
//
// BindInterface()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::BindInterface(const char *pInterface)
{
    bool           bRetVal = false;
    struct in_addr stInterfaceAddr;

    if (GetMulticast() == true)
    {
        if (pInterface)
        {
            stInterfaceAddr.s_addr= inet_addr(pInterface);
            if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_MULTICAST_IF, &stInterfaceAddr, sizeof(stInterfaceAddr)) == SocketSuccess)
            {
                bRetVal = true;
            }
        }
    }
    else
    {
        SetSocketError(CSimpleSocket::SocketProtocolError);
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// SetMulticast()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetMulticast(bool bEnable, uint8_t multicastTTL)
{
    bool bRetVal = false;

    if (GetSocketType() == CSimpleSocket::SocketTypeUdp)
    {
        m_bIsMulticast = bEnable;
        if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_MULTICAST_TTL, (void *)&multicastTTL, sizeof(multicastTTL)) == SocketError)
        {
            TranslateSocketError();
            bRetVal = false;
        }
        else
        {
            bRetVal = true;
        }
    }
    else
    {
        m_socketErrno = CSimpleSocket::SocketProtocolError;
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// SetSocketDscp()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetSocketDscp(int32_t nDscp)
{
    bool  bRetVal = true;
    int32_t nTempVal = nDscp;

    nTempVal <<= 4;
    nTempVal /= 4;

    if (IsSocketValid())
    {
        if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_TOS, &nTempVal, sizeof(nTempVal)) == SocketError)
        {
            TranslateSocketError();
            bRetVal = false;
        }
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// GetSocketDscp()
//
//------------------------------------------------------------------------------
int32_t CSimpleSocket::GetSocketDscp(void)
{
    int32_t      nTempVal = 0;
    socklen_t  nLen = 0;

    if (IsSocketValid())
    {
        if (GETSOCKOPT(m_socket, IPPROTO_IP, IP_TOS, &nTempVal, &nLen) == SocketError)
        {
            TranslateSocketError();
        }

        nTempVal *= 4;
        nTempVal >>= 4;
    }

    return nTempVal;
}


//------------------------------------------------------------------------------
//
// GetWindowSize()
//
//------------------------------------------------------------------------------
uint32_t CSimpleSocket::GetWindowSize(uint32_t nOptionName)
{
    uint32_t nTcpWinSize = 0;

    //-------------------------------------------------------------------------
    // no socket given, return system default allocate our own new socket
    //-------------------------------------------------------------------------
    if (m_socket != static_cast<SOCKET>(CSimpleSocket::SocketError))
    {
        socklen_t nLen = sizeof(nTcpWinSize);

        //---------------------------------------------------------------------
        // query for buffer size
        //---------------------------------------------------------------------
        GETSOCKOPT(m_socket, SOL_SOCKET, nOptionName, &nTcpWinSize, &nLen);
        TranslateSocketError();
    }
    else
    {
        SetSocketError(CSimpleSocket::SocketInvalidSocket);
    }

    return nTcpWinSize;
}


//------------------------------------------------------------------------------
//
// SetWindowSize()
//
//------------------------------------------------------------------------------
uint32_t CSimpleSocket::SetWindowSize(uint32_t nOptionName, uint32_t nWindowSize)
{
    //-------------------------------------------------------------------------
    // no socket given, return system default allocate our own new socket
    //-------------------------------------------------------------------------
    if (m_socket != static_cast<SOCKET>(CSimpleSocket::SocketError))
    {
        SETSOCKOPT(m_socket, SOL_SOCKET, nOptionName, &nWindowSize, sizeof(nWindowSize));
        TranslateSocketError();
    }
    else
    {
        SetSocketError(CSimpleSocket::SocketInvalidSocket);
    }

    return nWindowSize;
}


//------------------------------------------------------------------------------
//
// DisableNagleAlgorithm()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::DisableNagleAlgoritm()
{
    bool  bRetVal = false;
    int32_t nTcpNoDelay = 1;

    //----------------------------------------------------------------------
    // Set TCP NoDelay flag to true
    //----------------------------------------------------------------------
    if (SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nTcpNoDelay, sizeof(int32_t)) == 0)
    {
        bRetVal = true;
    }

    TranslateSocketError();

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// EnableNagleAlgorithm()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::EnableNagleAlgoritm()
{
    bool  bRetVal = false;
    int32_t nTcpNoDelay = 0;

    //----------------------------------------------------------------------
    // Set TCP NoDelay flag to false
    //----------------------------------------------------------------------
    if (SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nTcpNoDelay, sizeof(int32_t)) == 0)
    {
        bRetVal = true;
    }

    TranslateSocketError();

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Send() - Send data on a valid socket
//
//------------------------------------------------------------------------------
int32_t CSimpleSocket::Send(const uint8_t *pBuf, size_t bytesToSend)
{
    SetSocketError(SocketSuccess);
    m_nBytesSent = 0;

    switch(m_nSocketType)
    {
    case CSimpleSocket::SocketTypeTcp:
    {
        if (IsSocketValid())
        {
            if ((bytesToSend > 0) && (pBuf != NULL))
            {
                m_timer.Initialize();
                m_timer.SetStartTime();

                //---------------------------------------------------------
                // Check error condition and attempt to resend if call
                // was interrupted by a signal.
                //---------------------------------------------------------
                do
                {
                    m_nBytesSent = SEND(m_socket, pBuf, bytesToSend, 0);
                    TranslateSocketError();
                } while (GetSocketError() == CSimpleSocket::SocketInterrupted);

                m_timer.SetEndTime();
            }
        }
        break;
    }
    case CSimpleSocket::SocketTypeUdp:
    {
        if (IsSocketValid())
        {
            if ((bytesToSend > 0) && (pBuf != NULL))
            {
                m_timer.Initialize();
                m_timer.SetStartTime();

                //---------------------------------------------------------
                // Check error condition and attempt to resend if call
                // was interrupted by a signal.
                //---------------------------------------------------------
                //                    if (GetMulticast())
                //                    {
                //                        do
                //                        {
                //                            m_nBytesSent = SENDTO(m_socket, pBuf, bytesToSend, 0, (const sockaddr *)&m_stMulticastGroup,
                //                                                  sizeof(m_stMulticastGroup));
                //                            TranslateSocketError();
                //                        } while (GetSocketError() == CSimpleSocket::SocketInterrupted);
                //                    }
                //                    else
                {
                    do
                    {
                        m_nBytesSent = SENDTO(m_socket, pBuf, bytesToSend, 0, (const sockaddr *)&m_stServerSockaddr, sizeof(m_stServerSockaddr));
                        TranslateSocketError();
                    } while (GetSocketError() == CSimpleSocket::SocketInterrupted);
                }

                m_timer.SetEndTime();
            }
        }
        break;
    }
    default:
        break;
    }

    return m_nBytesSent;
}


//------------------------------------------------------------------------------
//
// Close() - Close socket and free up any memory allocated for the socket
//
//------------------------------------------------------------------------------
bool CSimpleSocket::Close(void)
{
    bool bRetVal = false;

    //--------------------------------------------------------------------------
    // delete internal buffer
    //--------------------------------------------------------------------------
    if (m_pBuffer != NULL)
    {
        delete [] m_pBuffer;
        m_pBuffer = NULL;
    }

    //--------------------------------------------------------------------------
    // if socket handle is currently valid, close and then invalidate
    //--------------------------------------------------------------------------
    if (IsSocketValid())
    {
		Shutdown(Both);
        if (CLOSE(m_socket) != CSimpleSocket::SocketError)
		{
			m_socket = INVALID_SOCKET;
			bRetVal = true;
		}
    }

    TranslateSocketError();

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Shtudown()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::Shutdown(CShutdownMode nShutdown)
{
    CSocketError nRetVal = SocketEunknown;

    nRetVal = (CSocketError)shutdown(m_socket, nShutdown);
    TranslateSocketError();

    return nRetVal == CSimpleSocket::SocketSuccess;
}


//------------------------------------------------------------------------------
//
// Flush()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::Flush()
{
    int32_t nTcpNoDelay = 1;
    int32_t nCurFlags = 0;
    uint8_t tmpbuf = 0;
    bool  bRetVal = false;

    //--------------------------------------------------------------------------
    // Get the current setting of the TCP_NODELAY flag.
    //--------------------------------------------------------------------------
    if (GETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nCurFlags, sizeof(int32_t)) == 0)
    {
        //----------------------------------------------------------------------
        // Set TCP NoDelay flag
        //----------------------------------------------------------------------
        if (SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nTcpNoDelay, sizeof(int32_t)) == 0)
        {
            //------------------------------------------------------------------
            // Send empty byte stream to flush the TCP send buffer
            //------------------------------------------------------------------
            if (Send(&tmpbuf, 0) != CSimpleSocket::SocketError)
            {
                bRetVal = true;
            }

            TranslateSocketError();
        }

        //----------------------------------------------------------------------
        // Reset the TCP_NODELAY flag to original state.
        //----------------------------------------------------------------------
        SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nCurFlags, sizeof(int32_t));
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Writev -
//
//------------------------------------------------------------------------------
int32_t CSimpleSocket::Writev(const struct iovec *pVector, size_t nCount)
{
    int32_t nBytes     = 0;
    int32_t nBytesSent = 0;
    int32_t i          = 0;

    //--------------------------------------------------------------------------
    // Send each buffer as a separate send, windows does not support this
    // function call.
    //--------------------------------------------------------------------------
    for (i = 0; i < (int32_t)nCount; i++)
    {
        if ((nBytes = Send((uint8_t *)pVector[i].iov_base, pVector[i].iov_len)) == CSimpleSocket::SocketError)
        {
            break;
        }

        nBytesSent += nBytes;
    }

    if (i > 0)
    {
        Flush();
    }

    return nBytesSent;
}


//------------------------------------------------------------------------------
//
// Send() - Send data on a valid socket via a vector of buffers.
//
//------------------------------------------------------------------------------
int32_t CSimpleSocket::Send(const struct iovec *sendVector, int32_t nNumItems)
{
    SetSocketError(SocketSuccess);
    m_nBytesSent = 0;

    if ((m_nBytesSent = WRITEV(m_socket, sendVector, nNumItems)) == CSimpleSocket::SocketError)
    {
        TranslateSocketError();
    }

    return m_nBytesSent;
}


//------------------------------------------------------------------------------
//
// SetReceiveTimeout()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetReceiveTimeout(int32_t nRecvTimeoutSec, int32_t nRecvTimeoutUsec)
{
    bool bRetVal = true;

    memset(&m_stRecvTimeout, 0, sizeof(struct timeval));

    m_stRecvTimeout.tv_sec = nRecvTimeoutSec;
    m_stRecvTimeout.tv_usec = nRecvTimeoutUsec;

    //--------------------------------------------------------------------------
    // Sanity check to make sure the options are supported!
    //--------------------------------------------------------------------------
    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_RCVTIMEO, &m_stRecvTimeout,
                   sizeof(struct timeval)) == CSimpleSocket::SocketError)
    {
        bRetVal = false;
        TranslateSocketError();
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// SetSendTimeout()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetSendTimeout(int32_t nSendTimeoutSec, int32_t nSendTimeoutUsec)
{
    bool bRetVal = true;

    memset(&m_stSendTimeout, 0, sizeof(struct timeval));
    m_stSendTimeout.tv_sec = nSendTimeoutSec;
    m_stSendTimeout.tv_usec = nSendTimeoutUsec;

    //--------------------------------------------------------------------------
    // Sanity check to make sure the options are supported!
    //--------------------------------------------------------------------------
    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_SNDTIMEO, &m_stSendTimeout,
                   sizeof(struct timeval)) == CSimpleSocket::SocketError)
    {
        bRetVal = false;
        TranslateSocketError();
    }

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// SetOptionReuseAddr()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetOptionReuseAddr()
{
    bool  bRetVal = false;
    int32_t nReuse  = IPTOS_LOWDELAY;

    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&nReuse, sizeof(int32_t)) == 0)
    {
        bRetVal = true;
    }

    TranslateSocketError();

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// SetOptionLinger()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetOptionLinger(bool bEnable, uint16_t nTime)
{
    bool bRetVal = false;

    m_stLinger.l_onoff = (bEnable == true) ? 1: 0;
    m_stLinger.l_linger = nTime;

    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_LINGER, &m_stLinger, sizeof(m_stLinger)) == 0)
    {
        bRetVal = true;
    }

    TranslateSocketError();

    return bRetVal;
}


//------------------------------------------------------------------------------
//
// Receive() - Attempts to receive a block of data on an established
//             connection.    Data is received in an internal buffer managed
//             by the class.  This buffer is only valid until the next call
//             to Receive(), a call to Close(), or until the object goes out
//             of scope.
//
//------------------------------------------------------------------------------
int32_t CSimpleSocket::Receive(int32_t nMaxBytes, uint8_t * pBuffer )
{
    m_nBytesReceived = 0;

    //--------------------------------------------------------------------------
    // If the socket is invalid then return false.
    //--------------------------------------------------------------------------
    if (IsSocketValid() == false)
    {
        return m_nBytesReceived;
    }

    uint8_t * pWorkBuffer = pBuffer;
    if ( pBuffer == NULL )
    {
        //--------------------------------------------------------------------------
        // Free existing buffer and allocate a new buffer the size of
        // nMaxBytes.
        //--------------------------------------------------------------------------
        if ((m_pBuffer != NULL) && (nMaxBytes != m_nBufferSize))
        {
            delete [] m_pBuffer;
            m_pBuffer = NULL;
        }

        //--------------------------------------------------------------------------
        // Allocate a new internal buffer to receive data.
        //--------------------------------------------------------------------------
        if (m_pBuffer == NULL)
        {
            m_nBufferSize = nMaxBytes;
            m_pBuffer = new uint8_t[nMaxBytes];
        }

        pWorkBuffer = m_pBuffer;
    }

    SetSocketError(SocketSuccess);

    m_timer.Initialize();
    m_timer.SetStartTime();

    switch (m_nSocketType)
    {
        //----------------------------------------------------------------------
        // If zero bytes are received, then return.  If SocketERROR is
        // received, free buffer and return CSocket::SocketError (-1) to caller.
        //----------------------------------------------------------------------
    case CSimpleSocket::SocketTypeTcp:
    {
        do
        {
            m_nBytesReceived = RECV(m_socket, (pWorkBuffer + m_nBytesReceived),
                                    nMaxBytes, m_nFlags);
            TranslateSocketError();
        } while ((GetSocketError() == CSimpleSocket::SocketInterrupted));

        break;
    }
    case CSimpleSocket::SocketTypeUdp:
    {
        uint32_t srcSize;

        srcSize = sizeof(struct sockaddr_in);

        if (GetMulticast() == true)
        {
            do
            {
                m_nBytesReceived = RECVFROM(m_socket, pWorkBuffer, nMaxBytes, 0,
                                            &m_stMulticastGroup, &srcSize);
                TranslateSocketError();
            } while (GetSocketError() == CSimpleSocket::SocketInterrupted);
        }
        else
        {
            do
            {
                m_nBytesReceived = RECVFROM(m_socket, pWorkBuffer, nMaxBytes, 0,
                                            &m_stClientSockaddr, &srcSize);
                TranslateSocketError();
            } while (GetSocketError() == CSimpleSocket::SocketInterrupted);
        }

        break;
    }
    default:
        break;
    }

    m_timer.SetEndTime();
    TranslateSocketError();

    //--------------------------------------------------------------------------
    // If we encounter an error translate the error code and return.  One
    // possible error code could be EAGAIN (EWOULDBLOCK) if the socket is
    // non-blocking.  This does not mean there is an error, but no data is
    // yet available on the socket.
    //--------------------------------------------------------------------------
    if (m_nBytesReceived == CSimpleSocket::SocketError)
    {
        if (m_pBuffer != NULL)
        {
            delete [] m_pBuffer;
            m_pBuffer = NULL;
        }
    }

    return m_nBytesReceived;
}


//------------------------------------------------------------------------------
//
// SetNonblocking()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetNonblocking(void)
{
    int32_t  nCurFlags;

#ifdef _WIN32
    nCurFlags = 1;

    if (ioctlsocket(m_socket, FIONBIO, (ULONG *)&nCurFlags) != 0)
    {
        TranslateSocketError();
        return false;
    }
#else
    if ((nCurFlags = fcntl(m_socket, F_GETFL)) < 0)
    {
        TranslateSocketError();
        return false;
    }

    nCurFlags |= O_NONBLOCK;

    if (fcntl(m_socket, F_SETFL, nCurFlags) != 0)
    {
        TranslateSocketError();
        return false;
    }
#endif

    m_bIsBlocking = false;

    return true;
}


//------------------------------------------------------------------------------
//
// SetBlocking()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::SetBlocking(void)
{
    int32_t nCurFlags;

#ifdef _WIN32
    nCurFlags = 0;

    if (ioctlsocket(m_socket, FIONBIO, (ULONG *)&nCurFlags) != 0)
    {
        return false;
    }
#else
    if ((nCurFlags = fcntl(m_socket, F_GETFL)) < 0)
    {
        TranslateSocketError();
        return false;
    }

    nCurFlags &= (~O_NONBLOCK);

    if (fcntl(m_socket, F_SETFL, nCurFlags) != 0)
    {
        TranslateSocketError();
        return false;
    }
#endif
    m_bIsBlocking = true;

    return true;
}


//------------------------------------------------------------------------------
//
// SendFile() - stands-in for system provided sendfile
//
//------------------------------------------------------------------------------
int32_t CSimpleSocket::SendFile(int32_t nOutFd, int32_t nInFd, off_t *pOffset, int32_t nCount)
{
    int32_t  nOutCount = CSimpleSocket::SocketError;

    static char szData[SOCKET_SENDFILE_BLOCKSIZE];
    int32_t       nInCount = 0;

    if (lseek(nInFd, *pOffset, SEEK_SET) == -1)
    {
        return -1;
    }

    while (nOutCount < nCount)
    {
        nInCount = (nCount - nOutCount) < SOCKET_SENDFILE_BLOCKSIZE ? (nCount - nOutCount) : SOCKET_SENDFILE_BLOCKSIZE;

        if ((read(nInFd, szData, nInCount)) != (int32_t)nInCount)
        {
            return -1;
        }

        if ((SEND(nOutFd, szData, nInCount, 0)) != (int32_t)nInCount)
        {
            return -1;
        }

        nOutCount += nInCount;
    }

    *pOffset += nOutCount;

    TranslateSocketError();

    return nOutCount;
}


//------------------------------------------------------------------------------
//
// TranslateSocketError() -
//
//------------------------------------------------------------------------------
void CSimpleSocket::TranslateSocketError(void)
{
#if defined(__linux__) || defined(_DARWIN)
    switch (errno)
    {
    case EXIT_SUCCESS:
        SetSocketError(CSimpleSocket::SocketSuccess);
        break;
    case ENOTCONN:
        SetSocketError(CSimpleSocket::SocketNotconnected);
        break;
    case ENOTSOCK:
    case EBADF:
    case EACCES:
    case EAFNOSUPPORT:
    case EMFILE:
    case ENFILE:
    case ENOBUFS:
    case ENOMEM:
    case EPROTONOSUPPORT:
    case EPIPE:
        SetSocketError(CSimpleSocket::SocketInvalidSocket);
        break;
    case ECONNREFUSED :
        SetSocketError(CSimpleSocket::SocketConnectionRefused);
        break;
    case ETIMEDOUT:
        SetSocketError(CSimpleSocket::SocketTimedout);
        break;
    case EINPROGRESS:
        SetSocketError(CSimpleSocket::SocketEinprogress);
        break;
    case EWOULDBLOCK:
        //        case EAGAIN:
        SetSocketError(CSimpleSocket::SocketEwouldblock);
        break;
    case EINTR:
        SetSocketError(CSimpleSocket::SocketInterrupted);
        break;
    case ECONNABORTED:
        SetSocketError(CSimpleSocket::SocketConnectionAborted);
        break;
    case EINVAL:
    case EPROTO:
        SetSocketError(CSimpleSocket::SocketProtocolError);
        break;
    case EPERM:
        SetSocketError(CSimpleSocket::SocketFirewallError);
        break;
    case EFAULT:
        SetSocketError(CSimpleSocket::SocketInvalidSocketBuffer);
        break;
    case ECONNRESET:
    case ENOPROTOOPT:
        SetSocketError(CSimpleSocket::SocketConnectionReset);
        break;
    default:
        SetSocketError(CSimpleSocket::SocketEunknown);
        break;
    }
#endif
#ifdef _WIN32
    int32_t nError = WSAGetLastError();
    switch (nError)
    {
    case EXIT_SUCCESS:
        SetSocketError(CSimpleSocket::SocketSuccess);
        break;
    case WSAEBADF:
    case WSAENOTCONN:
        SetSocketError(CSimpleSocket::SocketNotconnected);
        break;
    case WSAEINTR:
        SetSocketError(CSimpleSocket::SocketInterrupted);
        break;
    case WSAEACCES:
    case WSAEAFNOSUPPORT:
    case WSAEINVAL:
    case WSAEMFILE:
    case WSAENOBUFS:
    case WSAEPROTONOSUPPORT:
        SetSocketError(CSimpleSocket::SocketInvalidSocket);
        break;
    case WSAECONNREFUSED :
        SetSocketError(CSimpleSocket::SocketConnectionRefused);
        break;
    case WSAETIMEDOUT:
        SetSocketError(CSimpleSocket::SocketTimedout);
        break;
    case WSAEINPROGRESS:
        SetSocketError(CSimpleSocket::SocketEinprogress);
        break;
    case WSAECONNABORTED:
        SetSocketError(CSimpleSocket::SocketConnectionAborted);
        break;
    case WSAEWOULDBLOCK:
        SetSocketError(CSimpleSocket::SocketEwouldblock);
        break;
    case WSAENOTSOCK:
        SetSocketError(CSimpleSocket::SocketInvalidSocket);
        break;
    case WSAECONNRESET:
        SetSocketError(CSimpleSocket::SocketConnectionReset);
        break;
    case WSANO_DATA:
        SetSocketError(CSimpleSocket::SocketInvalidAddress);
        break;
    case WSAEADDRINUSE:
        SetSocketError(CSimpleSocket::SocketAddressInUse);
        break;
    case WSAEFAULT:
        SetSocketError(CSimpleSocket::SocketInvalidPointer);
        break;
    default:
        SetSocketError(CSimpleSocket::SocketEunknown);
        break;
    }
#endif
}

//------------------------------------------------------------------------------
//
// DescribeError()
//
//------------------------------------------------------------------------------

const char *CSimpleSocket::DescribeError(CSocketError err)
{
    switch (err) {
        case CSimpleSocket::SocketError:
            return "Generic socket error translates to error below.";
        case CSimpleSocket::SocketSuccess:
            return "No socket error.";
        case CSimpleSocket::SocketInvalidSocket:
            return "Invalid socket handle.";
        case CSimpleSocket::SocketInvalidAddress:
            return "Invalid destination address specified.";
        case CSimpleSocket::SocketInvalidPort:
            return "Invalid destination port specified.";
        case CSimpleSocket::SocketConnectionRefused:
            return "No server is listening at remote address.";
        case CSimpleSocket::SocketTimedout:
            return "Timed out while attempting operation.";
        case CSimpleSocket::SocketEwouldblock:
            return "Operation would block if socket were blocking.";
        case CSimpleSocket::SocketNotconnected:
            return "Currently not connected.";
        case CSimpleSocket::SocketEinprogress:
            return "Socket is non-blocking and the connection cannot be completed immediately";
        case CSimpleSocket::SocketInterrupted:
            return "Call was interrupted by a signal that was caught before a valid connection arrived.";
        case CSimpleSocket::SocketConnectionAborted:
            return "The connection has been aborted.";
        case CSimpleSocket::SocketProtocolError:
            return "Invalid protocol for operation.";
        case CSimpleSocket::SocketFirewallError:
            return "Firewall rules forbid connection.";
        case CSimpleSocket::SocketInvalidSocketBuffer:
            return "The receive buffer point outside the process's address space.";
        case CSimpleSocket::SocketConnectionReset:
            return "Connection was forcibly closed by the remote host.";
        case CSimpleSocket::SocketAddressInUse:
            return "Address already in use.";
        case CSimpleSocket::SocketInvalidPointer:
            return "Pointer type supplied as argument is invalid.";
        case CSimpleSocket::SocketEunknown:
            return "Unknown error";
        default:
            return "No such CSimpleSocket error";
    }
}

//------------------------------------------------------------------------------
//
// Select()
//
//------------------------------------------------------------------------------
bool CSimpleSocket::Select(int32_t nTimeoutSec, int32_t nTimeoutUSec)
{
    bool            bRetVal = false;
    struct timeval *pTimeout = NULL;
    struct timeval  timeout;
    int32_t           nNumDescriptors = -1;
    int32_t           nError = 0;

    FD_ZERO(&m_errorFds);
    FD_ZERO(&m_readFds);
    FD_ZERO(&m_writeFds);
    FD_SET(m_socket, &m_errorFds);
    FD_SET(m_socket, &m_readFds);
    FD_SET(m_socket, &m_writeFds);

    //---------------------------------------------------------------------
    // If timeout has been specified then set value, otherwise set timeout
    // to NULL which will block until a descriptor is ready for read/write
    // or an error has occurred.
    //---------------------------------------------------------------------
    if ((nTimeoutSec > 0) || (nTimeoutUSec > 0))
    {
        timeout.tv_sec = nTimeoutSec;
        timeout.tv_usec = nTimeoutUSec;
        pTimeout = &timeout;
    }

    nNumDescriptors = SELECT(m_socket+1, &m_readFds, &m_writeFds, &m_errorFds, pTimeout);
//    nNumDescriptors = SELECT(m_socket+1, &m_readFds, NULL, NULL, pTimeout);

    //----------------------------------------------------------------------
    // Handle timeout
    //----------------------------------------------------------------------
    if (nNumDescriptors == 0)
    {
        SetSocketError(CSimpleSocket::SocketTimedout);
    }
    //----------------------------------------------------------------------
    // If a file descriptor (read/write) is set then check the
    // socket error (SO_ERROR) to see if there is a pending error.
    //----------------------------------------------------------------------
    else if ((FD_ISSET(m_socket, &m_readFds)) || (FD_ISSET(m_socket, &m_writeFds)))
    {
        int32_t nLen = sizeof(nError);

        if (GETSOCKOPT(m_socket, SOL_SOCKET, SO_ERROR, &nError, &nLen) == 0)
        {
            errno = nError;

            if (nError == 0)
            {
                bRetVal = true;
            }
        }

        TranslateSocketError();
    }

    return bRetVal;
}


```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h`:

```h
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* SimpleSocket.h - Simple Socket base class decleration.                    */
/*                                                                           */
/* Author : Mark Carrier (mark@carrierlabs.com)                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#ifndef __SOCKET_H__
#define __SOCKET_H__

#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>

#if defined(__linux__) || defined (_DARWIN)
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <netdb.h>
#endif
#ifdef __linux__
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if.h>
#include <sys/sendfile.h>
#endif
#ifdef _DARWIN
#include <net/if.h>
#endif
#if defined(__linux__) || defined (_DARWIN)
#include <sys/time.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#endif

#ifdef _WIN32
#pragma warning( push )
#pragma warning( disable:4668 )
	#include <io.h>
	#include <winsock2.h>
	#include <Ws2tcpip.h>
#pragma warning( pop )

#define IPTOS_LOWDELAY  0x10

#endif
#include "Host.h"
#include "StatTimer.h"

//-----------------------------------------------------------------------------
// General class macro definitions and typedefs
//-----------------------------------------------------------------------------
#ifndef INVALID_SOCKET
#define INVALID_SOCKET    ~(0)
#endif

#define SOCKET_SENDFILE_BLOCKSIZE 8192

/// Provides a platform independent class to for socket development.
/// This class is designed to abstract socket communication development in a
/// platform independent manner.
/// - Socket types
///  -# CActiveSocket Class
///  -# CPassiveSocket Class
class CSimpleSocket {
public:
    /// Defines the three possible states for shuting down a socket.
    typedef enum
    {
        Receives = SHUT_RD, ///< Shutdown passive socket.
        Sends = SHUT_WR,    ///< Shutdown active socket.
        Both = SHUT_RDWR    ///< Shutdown both active and passive sockets.
    } CShutdownMode;

    /// Defines the socket types defined by CSimpleSocket class.
    typedef enum
    {
        SocketTypeInvalid,   ///< Invalid socket type.
        SocketTypeTcp,       ///< Defines socket as TCP socket.
        SocketTypeUdp,       ///< Defines socket as UDP socket.
        SocketTypeTcp6,      ///< Defines socket as IPv6 TCP socket.
        SocketTypeUdp6,      ///< Defines socket as IPv6 UDP socket.
        SocketTypeRaw        ///< Provides raw network protocol access.
    } CSocketType;

    /// Defines all error codes handled by the CSimpleSocket class.
    typedef enum
    {
        SocketError = -1,          ///< Generic socket error translates to error below.
        SocketSuccess = 0,         ///< No socket error.
        SocketInvalidSocket,       ///< Invalid socket handle.
        SocketInvalidAddress,      ///< Invalid destination address specified.
        SocketInvalidPort,         ///< Invalid destination port specified.
        SocketConnectionRefused,   ///< No server is listening at remote address.
        SocketTimedout,            ///< Timed out while attempting operation.
        SocketEwouldblock,         ///< Operation would block if socket were blocking.
        SocketNotconnected,        ///< Currently not connected.
        SocketEinprogress,         ///< Socket is non-blocking and the connection cannot be completed immediately
        SocketInterrupted,         ///< Call was interrupted by a signal that was caught before a valid connection arrived.
        SocketConnectionAborted,   ///< The connection has been aborted.
        SocketProtocolError,       ///< Invalid protocol for operation.
        SocketFirewallError,       ///< Firewall rules forbid connection.
        SocketInvalidSocketBuffer, ///< The receive buffer point outside the process's address space.
        SocketConnectionReset,     ///< Connection was forcibly closed by the remote host.
        SocketAddressInUse,        ///< Address already in use.
        SocketInvalidPointer,      ///< Pointer type supplied as argument is invalid.
        SocketEunknown             ///< Unknown error please report to mark@carrierlabs.com
    } CSocketError;

public:
    CSimpleSocket(CSocketType type = SocketTypeTcp);
    CSimpleSocket(CSimpleSocket &socket);

    CSimpleSocket(CSimpleSocket &&socket) noexcept = default;
    CSimpleSocket& operator=(CSimpleSocket &&socket) noexcept = default;

    virtual ~CSimpleSocket()
    {
        if (m_pBuffer != NULL)
        {
            delete [] m_pBuffer;
            m_pBuffer = NULL;
        }
    };

    /// Initialize instance of CSocket.  This method MUST be called before an
    /// object can be used. Errors : CSocket::SocketProtocolError,
    /// CSocket::SocketInvalidSocket,
    /// @return true if properly initialized.
    virtual bool Initialize(void);

    /// Close socket
    /// @return true if successfully closed otherwise returns false.
    virtual bool Close(void);

    /// Shutdown shut down socket send and receive operations
    ///    CShutdownMode::Receives - Disables further receive operations.
    ///    CShutdownMode::Sends    - Disables further send operations.
    ///    CShutdownBoth::         - Disables further send and receive operations.
    /// @param nShutdown specifies the type of shutdown.
    /// @return true if successfully shutdown otherwise returns false.
    virtual bool Shutdown(CShutdownMode nShutdown);

    /// Examine the socket descriptor sets currently owned by the instance of
    /// the socket class (the readfds, writefds, and errorfds parameters) to
    /// see whether some of their descriptors are ready for reading, are ready
    /// for writing, or have an exceptional condition pending, respectively.
    /// Block until an event happens on the specified file descriptors.
    /// @return true if socket has data ready, or false if not ready or timed out.
    virtual bool Select(void) {
        return Select(0,0);
    };

    /// Examine the socket descriptor sets currently owned by the instance of
    /// the socket class (the readfds, writefds, and errorfds parameters) to
    /// see whether some of their descriptors are ready for reading, are ready
    /// for writing, or have an exceptional condition pending, respectively.
    /// @param nTimeoutSec timeout in seconds for select.
    /// @param nTimeoutUSec timeout in micro seconds for select.
    /// @return true if socket has data ready, or false if not ready or timed out.
    virtual bool Select(int32_t nTimeoutSec, int32_t nTimeoutUSec);

    /// Does the current instance of the socket object contain a valid socket
    /// descriptor.
    ///  @return true if the socket object contains a valid socket descriptor.
    virtual bool IsSocketValid(void) {
        return (m_socket != static_cast<SOCKET>(SocketError));
    };

    /// Provides a standard error code for cross platform development by
    /// mapping the operating system error to an error defined by the CSocket
    /// class.
    void TranslateSocketError(void);

    /// Returns a human-readable description of the given error code
    /// or the last error code of a socket
    static const char *DescribeError(CSocketError err);
    inline const char *DescribeError() {
        return DescribeError(m_socketErrno);
    };

    /// Attempts to receive a block of data on an established connection.
    /// @param nMaxBytes maximum number of bytes to receive.
    /// @param pBuffer, memory where to receive the data,
    ///        NULL receives to internal buffer returned with GetData()
    ///        Non-NULL receives directly there, but GetData() will return WRONG ptr!
    /// @return number of bytes actually received.
    /// @return of zero means the connection has been shutdown on the other side.
    /// @return of -1 means that an error has occurred.
    virtual int32_t Receive(int32_t nMaxBytes = 1, uint8_t * pBuffer = 0);

    /// Attempts to send a block of data on an established connection.
    /// @param pBuf block of data to be sent.
    /// @param bytesToSend size of data block to be sent.
    /// @return number of bytes actually sent.
    /// @return of zero means the connection has been shutdown on the other side.
    /// @return of -1 means that an error has occurred.
    virtual int32_t Send(const uint8_t *pBuf, size_t bytesToSend);

    /// Attempts to send at most nNumItem blocks described by sendVector
    /// to the socket descriptor associated with the socket object.
    /// @param sendVector pointer to an array of iovec structures
    /// @param nNumItems number of items in the vector to process
    /// <br>\b NOTE: Buffers are processed in the order specified.
    /// @return number of bytes actually sent, return of zero means the
    /// connection has been shutdown on the other side, and a return of -1
    /// means that an error has occurred.
    virtual int32_t Send(const struct iovec *sendVector, int32_t nNumItems);

    /// Copies data between one file descriptor and another.
    /// On some systems this copying is done within the kernel, and thus is
    /// more efficient than the combination of CSimpleSocket::Send and
    /// CSimpleSocket::Receive, which would require transferring data to and
    /// from user space.
    /// <br>\b Note: This is available on all implementations, but the kernel
    /// implementation is only available on Unix type systems.
    /// @param nOutFd descriptor opened for writing.
    /// @param nInFd descriptor opened for reading.
    /// @param pOffset from which to start reading data from input file.
    /// @param nCount number of bytes to copy between file descriptors.
    /// @return number of bytes written to the out socket descriptor.
    virtual int32_t SendFile(int32_t nOutFd, int32_t nInFd, off_t *pOffset, int32_t nCount);

    /// Returns blocking/non-blocking state of socket.
    /// @return true if the socket is non-blocking, else return false.
    bool IsNonblocking(void) {
        return (m_bIsBlocking == false);
    };

    /// Set the socket to blocking.
    /// @return true if successful set to blocking, else return false;
    bool SetBlocking(void);

    /// Set the socket as non-blocking.
    /// @return true if successful set to non-blocking, else return false;
    bool SetNonblocking(void);

    /// Get a pointer to internal receive buffer.  The user MUST not free this
    /// pointer when finished.  This memory is managed internally by the CSocket
    /// class.
    /// @return pointer to data if valid, else returns NULL.
    uint8_t *GetData(void)  {
        return m_pBuffer;
    };

    /// Returns the number of bytes received on the last call to
    /// CSocket::Receive().
    /// @return number of bytes received.
    int32_t GetBytesReceived(void) {
        return m_nBytesReceived;
    };

    /// Returns the number of bytes sent on the last call to
    /// CSocket::Send().
    /// @return number of bytes sent.
    int32_t GetBytesSent(void) {
        return m_nBytesSent;
    };

    /// Controls the actions taken when CSimpleSocket::Close is executed on a
    /// socket object that has unsent data.  The default value for this option
    /// is \b off.
    /// - Following are the three possible scenarios.
    ///  -# \b bEnable is false, CSimpleSocket::Close returns immediately, but
    ///  any unset data is transmitted (after CSimpleSocket::Close returns)
    ///  -# \b bEnable is true and \b nTime is zero, CSimpleSocket::Close return
    /// immediately and any unsent data is discarded.
    ///  -# \b bEnable is true and \b nTime is nonzero, CSimpleSocket::Close does
    ///  not return until all unsent data is transmitted (or the connection is
    ///  Closed by the remote system).
    /// <br><p>
    /// @param bEnable true to enable option false to disable option.
    /// @param nTime time in seconds to linger.
    /// @return true if option successfully set
    bool SetOptionLinger(bool bEnable, uint16_t nTime);

    /// Tells the kernel that even if this port is busy (in the TIME_WAIT state),
    /// go ahead and reuse it anyway.  If it is busy, but with another state,
    /// you will still get an address already in use error.
    /// @return true if option successfully set
    bool SetOptionReuseAddr();

    /// Gets the timeout value that specifies the maximum number of seconds a
    /// call to CSimpleSocket::Open waits until it completes.
    /// @return the length of time in seconds
    int32_t GetConnectTimeoutSec(void) {
        return  m_stConnectTimeout.tv_sec;
    };

    /// Gets the timeout value that specifies the maximum number of microseconds
    /// a call to CSimpleSocket::Open waits until it completes.
    /// @return the length of time in microseconds
    int32_t GetConnectTimeoutUSec(void) {
        return  m_stConnectTimeout.tv_usec;
    };

    /// Sets the timeout value that specifies the maximum amount of time a call
    /// to CSimpleSocket::Receive waits until it completes. Use the method
    /// CSimpleSocket::SetReceiveTimeout to specify the number of seconds to wait.
    /// If a call to CSimpleSocket::Receive has blocked for the specified length of
    /// time without receiving additional data, it returns with a partial count
    /// or CSimpleSocket::GetSocketError set to CSimpleSocket::SocketEwouldblock if no data
    /// were received.
    /// @param nConnectTimeoutSec of timeout in seconds.
    /// @param nConnectTimeoutUsec of timeout in microseconds.
    /// @return true if socket connection timeout was successfully set.
    void SetConnectTimeout(int32_t nConnectTimeoutSec, int32_t nConnectTimeoutUsec = 0)
    {
        m_stConnectTimeout.tv_sec = nConnectTimeoutSec;
        m_stConnectTimeout.tv_usec = nConnectTimeoutUsec;
    };

    /// Gets the timeout value that specifies the maximum number of seconds a
    /// a call to CSimpleSocket::Receive waits until it completes.
    /// @return the length of time in seconds
    int32_t GetReceiveTimeoutSec(void) {
        return  m_stRecvTimeout.tv_sec;
    };

    /// Gets the timeout value that specifies the maximum number of microseconds
    /// a call to CSimpleSocket::Receive waits until it completes.
    /// @return the length of time in microseconds
    int32_t GetReceiveTimeoutUSec(void) {
        return  m_stRecvTimeout.tv_usec;
    };

    /// Sets the timeout value that specifies the maximum amount of time a call
    /// to CSimpleSocket::Receive waits until it completes. Use the method
    /// CSimpleSocket::SetReceiveTimeout to specify the number of seconds to wait.
    /// If a call to CSimpleSocket::Receive has blocked for the specified length of
    /// time without receiving additional data, it returns with a partial count
    /// or CSimpleSocket::GetSocketError set to CSimpleSocket::SocketEwouldblock if no data
    /// were received.
    ///  @param nRecvTimeoutSec of timeout in seconds.
    ///  @param nRecvTimeoutUsec of timeout in microseconds.
    ///  @return true if socket timeout was successfully set.
    bool SetReceiveTimeout(int32_t nRecvTimeoutSec, int32_t nRecvTimeoutUsec = 0);

    /// Enable/disable multicast for a socket.  This options is only valid for
    /// socket descriptors of type CSimpleSocket::SocketTypeUdp.
    /// @return true if multicast was enabled or false if socket type is not
    /// CSimpleSocket::SocketTypeUdp and the error will be set to
    /// CSimpleSocket::SocketProtocolError
    bool SetMulticast(bool bEnable, uint8_t multicastTTL = 1);

    /// Return true if socket is multicast or false is socket is unicast
    /// @return true if multicast is enabled
    bool GetMulticast() {
        return m_bIsMulticast;
    };

    /// Bind socket to a specific interface when using multicast.
    /// @return true if successfully bound to interface
    bool BindInterface(const char *pInterface);

    /// Gets the timeout value that specifies the maximum number of seconds a
    /// a call to CSimpleSocket::Send waits until it completes.
    /// @return the length of time in seconds
    int32_t GetSendTimeoutSec(void) {
        return  m_stSendTimeout.tv_sec;
    };

    /// Gets the timeout value that specifies the maximum number of microseconds
    /// a call to CSimpleSocket::Send waits until it completes.
    /// @return the length of time in microseconds
    int32_t GetSendTimeoutUSec(void) {
        return  m_stSendTimeout.tv_usec;
    };

    /// Gets the timeout value that specifies the maximum amount of time a call
    /// to CSimpleSocket::Send waits until it completes.
    /// @return the length of time in seconds
    bool SetSendTimeout(int32_t nSendTimeoutSec, int32_t nSendTimeoutUsec = 0);

    /// Returns the last error that occured for the instace of the CSimpleSocket
    /// instance.  This method should be called immediately to retrieve the
    /// error code for the failing mehtod call.
    ///  @return last error that occured.
    CSocketError GetSocketError(void) {
        return m_socketErrno;
    };

    /// Get the total time the of the last operation in milliseconds.
    ///  @return number of milliseconds of last operation.
    uint32_t GetTotalTimeMs() {
        return m_timer.GetMilliSeconds();
    };

    /// Get the total time the of the last operation in microseconds.
    ///  @return number of microseconds or last operation.
    uint32_t GetTotalTimeUsec() {
        return m_timer.GetMicroSeconds();
    };

    /// Return Differentiated Services Code Point (DSCP) value currently set on the socket object.
    /// @return DSCP for current socket object.
    /// <br><br> \b NOTE: Windows special notes http://support.microsoft.com/kb/248611.
    int GetSocketDscp(void);

    /// Set Differentiated Services Code Point (DSCP) for socket object.
    ///  @param nDscp value of TOS setting which will be converted to DSCP
    ///  @return true if DSCP value was properly set
    /// <br><br> \b NOTE: Windows special notes http://support.microsoft.com/kb/248611.
    bool SetSocketDscp(int nDscp);

    /// Return socket descriptor
    ///  @return socket descriptor which is a signed 32 bit integer.
    SOCKET GetSocketDescriptor() {
        return m_socket;
    };

    /// Return socket descriptor
    ///  @return socket descriptor which is a signed 32 bit integer.
    CSocketType GetSocketType() {
        return m_nSocketType;
    };

    /// Returns clients Internet host address as a string in standard numbers-and-dots notation.
    ///  @return NULL if invalid
    const char *GetClientAddr() {
        return inet_ntoa(m_stClientSockaddr.sin_addr);
    };

    /// Returns the port number on which the client is connected.
    ///  @return client port number.
    uint16_t GetClientPort() {
        return m_stClientSockaddr.sin_port;
    };

    /// Returns server Internet host address as a string in standard numbers-and-dots notation.
    ///  @return NULL if invalid
    const char *GetServerAddr() {
        return inet_ntoa(m_stServerSockaddr.sin_addr);
    };

    /// Returns the port number on which the server is connected.
    ///  @return server port number.
    uint16_t GetServerPort() {
        return ntohs(m_stServerSockaddr.sin_port);
    };

    /// Get the TCP receive buffer window size for the current socket object.
    /// <br><br>\b NOTE: Linux will set the receive buffer to twice the value passed.
    ///  @return zero on failure else the number of bytes of the TCP receive buffer window size if successful.
    uint32_t GetReceiveWindowSize() {
        return GetWindowSize(SO_RCVBUF);
    };

    /// Get the TCP send buffer window size for the current socket object.
    /// <br><br>\b NOTE: Linux will set the send buffer to twice the value passed.
    ///  @return zero on failure else the number of bytes of the TCP receive buffer window size if successful.
    uint32_t GetSendWindowSize() {
        return GetWindowSize(SO_SNDBUF);
    };

    /// Set the TCP receive buffer window size for the current socket object.
    /// <br><br>\b NOTE: Linux will set the receive buffer to twice the value passed.
    ///  @return zero on failure else the number of bytes of the TCP send buffer window size if successful.
    uint32_t SetReceiveWindowSize(uint32_t nWindowSize) {
        return SetWindowSize(SO_RCVBUF, nWindowSize);
    };

    /// Set the TCP send buffer window size for the current socket object.
    /// <br><br>\b NOTE: Linux will set the send buffer to twice the value passed.
    ///  @return zero on failure else the number of bytes of the TCP send buffer window size if successful.
    uint32_t SetSendWindowSize(uint32_t nWindowSize) {
        return SetWindowSize(SO_SNDBUF, nWindowSize);
    };

    /// Disable the Nagle algorithm (Set TCP_NODELAY to true)
    /// @return false if failed to set socket option otherwise return true;
    bool DisableNagleAlgoritm();

    /// Enable the Nagle algorithm (Set TCP_NODELAY to false)
    /// @return false if failed to set socket option otherwise return true;
    bool EnableNagleAlgoritm();


    /// Flush the socket descriptor owned by the object.
    /// @return true data was successfully sent, else return false;
    bool Flush();

protected:
    /// Set internal socket error to that specified error
    ///  @param error type of error
    void SetSocketError(CSimpleSocket::CSocketError error) {
        m_socketErrno = error;
    };

    /// Set object socket handle to that specified as parameter
    ///  @param socket value of socket descriptor
    void SetSocketHandle(SOCKET socket) {
        m_socket = socket;
    };

private:
    /// Generic function used to get the send/receive window size
    ///  @return zero on failure else the number of bytes of the TCP window size if successful.
    uint32_t GetWindowSize(uint32_t nOptionName);

    /// Generic function used to set the send/receive window size
    ///  @return zero on failure else the number of bytes of the TCP window size if successful.
    uint32_t SetWindowSize(uint32_t nOptionName, uint32_t nWindowSize);


    /// Attempts to send at most nNumItem blocks described by sendVector
    /// to the socket descriptor associated with the socket object.
    /// @param sendVector pointer to an array of iovec structures
    /// @param nNumItems number of items in the vector to process
    /// <br>\b Note: This implementation is for systems that don't natively
    /// support this functionality.
    /// @return number of bytes actually sent, return of zero means the
    /// connection has been shutdown on the other side, and a return of -1
    /// means that an error has occurred.
    int32_t Writev(const struct iovec *pVector, size_t nCount);

    CSimpleSocket *operator=(CSimpleSocket &socket);

protected:
    SOCKET               m_socket;            /// socket handle
    CSocketError         m_socketErrno;       /// number of last error
    uint8_t               *m_pBuffer;           /// internal send/receive buffer
    int32_t                m_nBufferSize;       /// size of internal send/receive buffer
    int32_t                m_nSocketDomain;     /// socket type PF_INET, PF_INET6
    CSocketType          m_nSocketType;       /// socket type - UDP, TCP or RAW
    int32_t                m_nBytesReceived;    /// number of bytes received
    int32_t                m_nBytesSent;        /// number of bytes sent
    uint32_t               m_nFlags;            /// socket flags
    bool                 m_bIsBlocking;       /// is socket blocking
    bool                 m_bIsMulticast;      /// is the UDP socket multicast;
    struct timeval       m_stConnectTimeout;  /// connection timeout
    struct timeval       m_stRecvTimeout;     /// receive timeout
    struct timeval       m_stSendTimeout;     /// send timeout
    struct sockaddr_in   m_stServerSockaddr;  /// server address
    struct sockaddr_in   m_stClientSockaddr;  /// client address
    struct sockaddr_in   m_stMulticastGroup;  /// multicast group to bind to
    struct linger        m_stLinger;          /// linger flag
    CStatTimer           m_timer;             /// internal statistics.
#ifdef _WIN32
    WSADATA              m_hWSAData;          /// Windows
#endif
    fd_set               m_writeFds;          /// write file descriptor set
    fd_set               m_readFds;           /// read file descriptor set
    fd_set               m_errorFds;          /// error file descriptor set
};


#endif /*  __SOCKET_H__  */


```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/StatTimer.h`:

```h
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* StatTimer.h: interface for the CStatTimer class.                           */
/*                                                                            */
/* Author: Mark Carrier (mark@carrierlabs.com)                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Copyright (c) 2006 CarrierLabs, LLC.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. The name "CarrierLabs" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    mark@carrierlabs.com.
 *
 * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *----------------------------------------------------------------------------*/
#ifndef __CSTATTIMER_H__
#define __CSTATTIMER_H__

#include <string.h>

#ifdef _WIN32

#pragma warning( push )
#pragma warning( disable:4668 )
  #include <Winsock2.h>
  #include <time.h>
#pragma warning( pop )

#endif

#ifdef __linux__
  #include <stdio.h>
  #include <sys/time.h>
#endif

#include "Host.h"

#if defined(_WIN32)
  #define GET_CLOCK_COUNT(x) QueryPerformanceCounter((LARGE_INTEGER *)x)
#else
  #define GET_CLOCK_COUNT(x) gettimeofday(x, NULL)
#endif

#define MILLISECONDS_CONVERSION 1000
#define MICROSECONDS_CONVERSION 1000000

/// Class to abstract socket communications in a cross platform manner.
/// This class is designed
class CStatTimer {
public:
    CStatTimer()
    {
    };

    ~CStatTimer()
    {
    };

    void Initialize()
    {
        memset(&m_startTime, 0, sizeof(struct timeval));
        memset(&m_endTime, 0, sizeof(struct timeval));
    };

    struct timeval GetStartTime() { return m_startTime; };
    void SetStartTime() { GET_CLOCK_COUNT(&m_startTime); };

    struct timeval GetEndTime() { return m_endTime; };
    void SetEndTime() { GET_CLOCK_COUNT(&m_endTime); };

    uint32_t GetMilliSeconds() { return (CalcTotalUSec() / MILLISECONDS_CONVERSION); };
    uint32_t GetMicroSeconds() { return (CalcTotalUSec()); };
    uint32_t GetSeconds() { return (CalcTotalUSec() / MICROSECONDS_CONVERSION); };

    uint32_t GetCurrentTime()
    {
        struct timeval tmpTime;
        GET_CLOCK_COUNT(&tmpTime);
        return ((tmpTime.tv_sec * MICROSECONDS_CONVERSION) + tmpTime.tv_usec);
    };

private:
    uint32_t CalcTotalUSec() { return (((m_endTime.tv_sec - m_startTime.tv_sec) * MICROSECONDS_CONVERSION) +
                                    (m_endTime.tv_usec - m_startTime.tv_usec)); };


private:
    struct timeval  m_startTime;
    struct timeval  m_endTime;
};

#endif // __CSTATTIMER_H__

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/countdownlatch/LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2016 Nipun Talukdar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/countdownlatch/README.md`:

```md
CountdownLatch for C++ multi-threaded programming
================================================

**CountdownLatch in C++**

-----------------------
countdownlatch is a C++ library providing similar functionalities as availble with standard Java
CountdownLatch class. It's main usage is: it allows one or more threads to wait until a set of
operations being performed on other threads completes.


**Below is an example regarding how to use the library**

---

```c++
#include <unistd.h>
#include <thread>
#include <vector>
#include <iostream>
#include <countdownlatch.hpp>

void fun(clatch::countdownlatch *cl) {
    cl->await();
    std::cout << "Wait is over " << std::endl;
}

int main() {
    auto cl = new clatch::countdownlatch(10);
    int i = 0;
    std::vector<std::thread*> ts;
    while (i++ < 2) {
        std::thread *t  = new std::thread(fun, cl);
        ts.push_back(t);
    }

    i = 0;
    while (i++ < 10) {
        sleep(1);
        cl->count_down();
    }
    i = 0;
    while (i < 2) {
        ts[i++]->join();
    }
    i = 0;
    while (i < 2) {
        delete ts[i++];
    }
    delete cl;
    return 0;
}

```

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/countdownlatch/countdownlatch.cpp`:

```cpp
#include <chrono>
#include "countdownlatch.hpp"

clatch::countdownlatch::countdownlatch(uint32_t count) {
   this->count = count; 
}

void clatch::countdownlatch::await(uint64_t nanosecs) {
    std::unique_lock<std::mutex> lck(lock);
    if (0 == count){
        return;
    }
    if (nanosecs > 0) {
       cv.wait_for(lck, std::chrono::nanoseconds(nanosecs));
    } else {
       cv.wait(lck);
    }
}

uint32_t clatch::countdownlatch::get_count() {
    std::unique_lock<std::mutex> lck(lock);
    return count;
}

void clatch::countdownlatch::count_down() {
    std::unique_lock<std::mutex> lck(lock);
    if (0 == count) {
        return;
    } 
    --count;
    if (0 == count) {
        cv.notify_all();
    }
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/countdownlatch/countdownlatch.hpp`:

```hpp
#ifndef __COUNTDOWNLATCH_NIPUN__
#define __COUNTDOWNLATCH_NIPUN__

#include <cinttypes>
#include <cstdint>
#include <mutex>
#include <condition_variable>


namespace clatch 
{
    class countdownlatch {
    public:
        /*! Constructor
          \param count, the value the countdownlatch object should be initialized with
        */
        explicit countdownlatch(uint32_t count);


        /*!
            await causes the caller to wait until the latch is counted down to zero, 
            if wait time nanosecs is not zero, then maximum wait is for nanosec nanoseconds 
          \param nanosecs is waittime in nanoseconds, by default it is zero which specifies 
           indefinite wait  
        */
        void await(uint64_t nanosecs=0);

        /*!
          Countdown decrements the count of the latch, signalling all waiting thread if the 
          count reaches zero.
         */
        void count_down();

        /*!
          get_count returns the current count  
         */
        uint32_t get_count(); 

    private:
        std::condition_variable cv;
        std::mutex lock;
        uint32_t count;
        
        // deleted constructors/assignmenet operators
        countdownlatch() = delete;
        countdownlatch(const countdownlatch& other) = delete;
        countdownlatch& operator=(const countdownlatch& opther) = delete;
    };
}

#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/COPYING`:

```
Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works ("Commons") that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the "Affirmer"), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
"License"). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/README.md`:

```md
# optional
Single header implementation of `std::optional` with functional-style extensions and support for references.

Clang + GCC: [![Linux Build Status](https://travis-ci.org/TartanLlama/optional.png?branch=master)](https://travis-ci.org/TartanLlama/optional)
MSVC: [![Windows Build Status](https://ci.appveyor.com/api/projects/status/k5x00xa11y3s5wsg?svg=true)](https://ci.appveyor.com/project/TartanLlama/optional)

`std::optional` is the preferred way to represent an object which may or may not have a value. Unfortunately, chaining together many computations which may or may not produce a value can be verbose, as empty-checking code will be mixed in with the actual programming logic. This implementation provides a number of utilities to make coding with `optional` cleaner.

For example, instead of writing this code:

```c++
std::optional<image> get_cute_cat (const image& img) {
    auto cropped = crop_to_cat(img);
    if (!cropped) {
      return std::nullopt;
    }

    auto with_tie = add_bow_tie(*cropped);
    if (!with_tie) {
      return std::nullopt;
    }

    auto with_sparkles = make_eyes_sparkle(*with_tie);
    if (!with_sparkles) {
      return std::nullopt;
    }

    return add_rainbow(make_smaller(*with_sparkles));
}
```

You can do this:

```c++
tl::optional<image> get_cute_cat (const image& img) {
    return crop_to_cat(img)
           .and_then(add_bow_tie)
           .and_then(make_eyes_sparkle)
           .map(make_smaller)
           .map(add_rainbow);
}
```

Full documentation available at [optional.tartanllama.xyz](https://optional.tartanllama.xyz)

The interface is the same as `std::optional`, but the following member functions are also defined. Explicit types are for clarity.

- `map`: carries out some operation on the stored object if there is one.
  * `tl::optional<std::size_t> s = opt_string.map(&std::string::size);`
- `and_then`: like `map`, but for operations which return a `tl::optional`.
  * `tl::optional<int> stoi (const std::string& s);`
  * `tl::optional<int> i = opt_string.and_then(stoi);`
- `or_else`: calls some function if there is no value stored.
  * `opt.or_else([] { throw std::runtime_error{"oh no"}; });`
- `map_or`: carries out a `map` if there is a value, otherwise returns a default value.
  * `tl::optional<std::size_t> s = opt_string.map_or(&std::string::size, 0);`
- `map_or_else`: carries out a `map` if there is a value, otherwise returns the result of a given default function.
  * `std::size_t get_default();`
  * `tl::optional<std::size_t> s = opt_string.map_or(&std::string::size, get_default);`
- `conjunction`: returns the argument if a value is stored in the optional, otherwise an empty optional.
  * `tl::make_optional(42).conjunction(13); //13`
  * `tl::optional<int>){}.conjunction(13); //empty`
- `disjunction`: returns the argument if the optional is empty, otherwise the current value.
  * `tl::make_optional(42).disjunction(13); //42`
  * `tl::optional<int>{}.disjunction(13); //13`
- `take`: returns the current value, leaving the optional empty.
  * `opt_string.take().map(&std::string::size); //opt_string now empty;`

In addition to those member functions, optional references are also supported:

```c++
int i = 42;
tl::optional<int&> o = i;
*o == 42; //true
i = 12;
*o = 12; //true
&*o == &i; //true
```

Assignment has rebind semantics rather than assign-through semantics:

```c++
int j = 8;
o = j;

&*o == &j; //true
```

### Compiler support

Tested on:


- Linux
  * clang 6.0.1
  * clang 5.0.2
  * clang 4.0.1
  * clang 3.9
  * clang 3.8
  * clang 3.7
  * clang 3.6
  * clang 3.5
  * g++ 8.0.1
  * g++ 7.3
  * g++ 6.4
  * g++ 5.5
  * g++ 4.9
  * g++ 4.8
- Windows
  * MSVC 2015
  * MSVC 2017

### Dependencies

Requires [Standardese](https://github.com/foonathan/standardese) for generating documentation.

Requires [Catch](https://github.com/philsquared/Catch) for testing. This is bundled in the test directory.

### Standards Proposal

This library also serves as an implementation of WG21 standards paper [P0798R0: Monadic operations for std::optional](https://wg21.tartanllama.xyz/monadic-optional). This paper proposes adding `map`, `and_then`, and `or_else` to `std::optional`.

----------

[![CC0](http://i.creativecommons.org/p/zero/1.0/88x31.png)]("http://creativecommons.org/publicdomain/zero/1.0/")

To the extent possible under law, [Simon Brand](https://twitter.com/TartanLlama) has waived all copyright and related or neighboring rights to the `optional` library. This work is published from: United Kingdom.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp`:

```hpp

///
// optional - An implementation of std::optional with extensions
// Written in 2017 by Simon Brand (tartanllama@gmail.com, @TartanLlama)
//
// To the extent possible under law, the author(s) have dedicated all
// copyright and related and neighboring rights to this software to the
// public domain worldwide. This software is distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication
// along with this software. If not, see
// <http://creativecommons.org/publicdomain/zero/1.0/>.
///

#ifndef TL_OPTIONAL_HPP
#define TL_OPTIONAL_HPP

#define TL_OPTIONAL_VERSION_MAJOR 0
#define TL_OPTIONAL_VERSION_MINOR 5

#include <exception>
#include <functional>
#include <new>
#include <type_traits>
#include <utility>

#if (defined(_MSC_VER) && _MSC_VER == 1900)
#define TL_OPTIONAL_MSVC2015
#endif

#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
     !defined(__clang__))
#define TL_OPTIONAL_GCC49
#endif

#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 &&              \
     !defined(__clang__))
#define TL_OPTIONAL_GCC54
#endif

#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 &&              \
     !defined(__clang__))
#define TL_OPTIONAL_GCC55
#endif

#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
     !defined(__clang__))
// GCC < 5 doesn't support overloading on const&& for member functions
#define TL_OPTIONAL_NO_CONSTRR

// GCC < 5 doesn't support some standard C++11 type traits
#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \
  std::has_trivial_copy_constructor<T>::value
#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) std::has_trivial_copy_assign<T>::value

// This one will be different for GCC 5.7 if it's ever supported
#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>::value

// GCC 5 < v < 8 has an issue in is_trivially_copy_constructible which breaks std::vector
// for non-copyable types
#elif (defined(__GNUC__) && __GNUC__ < 8 &&                                                \
     !defined(__clang__))
#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
namespace tl {
  namespace detail {
      template<class T>
      struct is_trivially_copy_constructible : std::is_trivially_copy_constructible<T>{};
#ifdef _GLIBCXX_VECTOR
      template<class T, class A>
      struct is_trivially_copy_constructible<std::vector<T,A>>
          : std::is_trivially_copy_constructible<T>{};
#endif      
  }
}
#endif

#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \
    tl::detail::is_trivially_copy_constructible<T>::value
#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                                        \
  std::is_trivially_copy_assignable<T>::value
#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>::value
#else
#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \
  std::is_trivially_copy_constructible<T>::value
#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                                        \
  std::is_trivially_copy_assignable<T>::value
#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>::value
#endif

#if __cplusplus > 201103L
#define TL_OPTIONAL_CXX14
#endif

// constexpr implies const in C++11, not C++14
#if (__cplusplus == 201103L || defined(TL_OPTIONAL_MSVC2015) ||                \
     defined(TL_OPTIONAL_GCC49))
/// \exclude
#define TL_OPTIONAL_11_CONSTEXPR
#else
/// \exclude
#define TL_OPTIONAL_11_CONSTEXPR constexpr
#endif

namespace tl {
#ifndef TL_MONOSTATE_INPLACE_MUTEX
#define TL_MONOSTATE_INPLACE_MUTEX
/// \brief Used to represent an optional with no data; essentially a bool
class monostate {};

/// \brief A tag type to tell optional to construct its value in-place
struct in_place_t {
  explicit in_place_t() = default;
};
/// \brief A tag to tell optional to construct its value in-place
static constexpr in_place_t in_place{};
#endif

template <class T> class optional;

/// \exclude
namespace detail {
#ifndef TL_TRAITS_MUTEX
#define TL_TRAITS_MUTEX
// C++14-style aliases for brevity
template <class T> using remove_const_t = typename std::remove_const<T>::type;
template <class T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <class T> using decay_t = typename std::decay<T>::type;
template <bool E, class T = void>
using enable_if_t = typename std::enable_if<E, T>::type;
template <bool B, class T, class F>
using conditional_t = typename std::conditional<B, T, F>::type;

// std::conjunction from C++17
template <class...> struct conjunction : std::true_type {};
template <class B> struct conjunction<B> : B {};
template <class B, class... Bs>
struct conjunction<B, Bs...>
    : std::conditional<bool(B::value), conjunction<Bs...>, B>::type {};

#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L
#define TL_OPTIONAL_LIBCXX_MEM_FN_WORKAROUND
#endif

// In C++11 mode, there's an issue in libc++'s std::mem_fn
// which results in a hard-error when using it in a noexcept expression
// in some cases. This is a check to workaround the common failing case.
#ifdef TL_OPTIONAL_LIBCXX_MEM_FN_WORKAROUND
template <class T> struct is_pointer_to_non_const_member_func : std::false_type{};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*) (Args...)> : std::true_type{};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*) (Args...)&> : std::true_type{};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*) (Args...)&&> : std::true_type{};        
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*) (Args...) volatile> : std::true_type{};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*) (Args...) volatile&> : std::true_type{};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*) (Args...) volatile&&> : std::true_type{};        

template <class T> struct is_const_or_const_ref : std::false_type{};
template <class T> struct is_const_or_const_ref<T const&> : std::true_type{};
template <class T> struct is_const_or_const_ref<T const> : std::true_type{};    
#endif

// std::invoke from C++17
// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround
template <typename Fn, typename... Args,
#ifdef TL_OPTIONAL_LIBCXX_MEM_FN_WORKAROUND
          typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value 
                                 && is_const_or_const_ref<Args...>::value)>, 
#endif
          typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>,
          int = 0>
constexpr auto invoke(Fn &&f, Args &&... args) noexcept(
    noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))
    -> decltype(std::mem_fn(f)(std::forward<Args>(args)...)) {
  return std::mem_fn(f)(std::forward<Args>(args)...);
}

template <typename Fn, typename... Args,
          typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>
constexpr auto invoke(Fn &&f, Args &&... args) noexcept(
    noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))
    -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...)) {
  return std::forward<Fn>(f)(std::forward<Args>(args)...);
}

// std::invoke_result from C++17
template <class F, class, class... Us> struct invoke_result_impl;

template <class F, class... Us>
struct invoke_result_impl<
    F, decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),
    Us...> {
  using type = decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));
};

template <class F, class... Us>
using invoke_result = invoke_result_impl<F, void, Us...>;

template <class F, class... Us>
using invoke_result_t = typename invoke_result<F, Us...>::type;
#endif

// std::void_t from C++17
template <class...> struct voider { using type = void; };
template <class... Ts> using void_t = typename voider<Ts...>::type;

// Trait for checking if a type is a tl::optional
template <class T> struct is_optional_impl : std::false_type {};
template <class T> struct is_optional_impl<optional<T>> : std::true_type {};
template <class T> using is_optional = is_optional_impl<decay_t<T>>;

// Change void to tl::monostate
template <class U>
using fixup_void = conditional_t<std::is_void<U>::value, monostate, U>;

template <class F, class U, class = invoke_result_t<F, U>>
using get_map_return = optional<fixup_void<invoke_result_t<F, U>>>;

// Check if invoking F for some Us returns void
template <class F, class = void, class... U> struct returns_void_impl;
template <class F, class... U>
struct returns_void_impl<F, void_t<invoke_result_t<F, U...>>, U...>
    : std::is_void<invoke_result_t<F, U...>> {};
template <class F, class... U>
using returns_void = returns_void_impl<F, void, U...>;

template <class T, class... U>
using enable_if_ret_void = enable_if_t<returns_void<T &&, U...>::value>;

template <class T, class... U>
using disable_if_ret_void = enable_if_t<!returns_void<T &&, U...>::value>;

template <class T, class U>
using enable_forward_value =
    detail::enable_if_t<std::is_constructible<T, U &&>::value &&
                        !std::is_same<detail::decay_t<U>, in_place_t>::value &&
                        !std::is_same<optional<T>, detail::decay_t<U>>::value>;

template <class T, class U, class Other>
using enable_from_other = detail::enable_if_t<
    std::is_constructible<T, Other>::value &&
    !std::is_constructible<T, optional<U> &>::value &&
    !std::is_constructible<T, optional<U> &&>::value &&
    !std::is_constructible<T, const optional<U> &>::value &&
    !std::is_constructible<T, const optional<U> &&>::value &&
    !std::is_convertible<optional<U> &, T>::value &&
    !std::is_convertible<optional<U> &&, T>::value &&
    !std::is_convertible<const optional<U> &, T>::value &&
    !std::is_convertible<const optional<U> &&, T>::value>;

template <class T, class U>
using enable_assign_forward = detail::enable_if_t<
    !std::is_same<optional<T>, detail::decay_t<U>>::value &&
    !detail::conjunction<std::is_scalar<T>,
                         std::is_same<T, detail::decay_t<U>>>::value &&
    std::is_constructible<T, U>::value && std::is_assignable<T &, U>::value>;

template <class T, class U, class Other>
using enable_assign_from_other = detail::enable_if_t<
    std::is_constructible<T, Other>::value &&
    std::is_assignable<T &, Other>::value &&
    !std::is_constructible<T, optional<U> &>::value &&
    !std::is_constructible<T, optional<U> &&>::value &&
    !std::is_constructible<T, const optional<U> &>::value &&
    !std::is_constructible<T, const optional<U> &&>::value &&
    !std::is_convertible<optional<U> &, T>::value &&
    !std::is_convertible<optional<U> &&, T>::value &&
    !std::is_convertible<const optional<U> &, T>::value &&
    !std::is_convertible<const optional<U> &&, T>::value &&
    !std::is_assignable<T &, optional<U> &>::value &&
    !std::is_assignable<T &, optional<U> &&>::value &&
    !std::is_assignable<T &, const optional<U> &>::value &&
    !std::is_assignable<T &, const optional<U> &&>::value>;

#ifdef _MSC_VER
// TO-DO make a version which works with MSVC
template <class T, class U = T> struct is_swappable : std::true_type {};

template <class T, class U = T> struct is_nothrow_swappable : std::true_type {};
#else
// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept
namespace swap_adl_tests {
// if swap ADL finds this then it would call std::swap otherwise (same
// signature)
struct tag {};

template <class T> tag swap(T &, T &);
template <class T, std::size_t N> tag swap(T (&a)[N], T (&b)[N]);

// helper functions to test if an unqualified swap is possible, and if it
// becomes std::swap
template <class, class> std::false_type can_swap(...) noexcept(false);
template <class T, class U,
          class = decltype(swap(std::declval<T &>(), std::declval<U &>()))>
std::true_type can_swap(int) noexcept(noexcept(swap(std::declval<T &>(),
                                                    std::declval<U &>())));

template <class, class> std::false_type uses_std(...);
template <class T, class U>
std::is_same<decltype(swap(std::declval<T &>(), std::declval<U &>())), tag>
uses_std(int);

template <class T>
struct is_std_swap_noexcept
    : std::integral_constant<bool,
                             std::is_nothrow_move_constructible<T>::value &&
                                 std::is_nothrow_move_assignable<T>::value> {};

template <class T, std::size_t N>
struct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T> {};

template <class T, class U>
struct is_adl_swap_noexcept
    : std::integral_constant<bool, noexcept(can_swap<T, U>(0))> {};
} // namespace swap_adl_tests

template <class T, class U = T>
struct is_swappable
    : std::integral_constant<
          bool,
          decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&
              (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||
               (std::is_move_assignable<T>::value &&
                std::is_move_constructible<T>::value))> {};

template <class T, std::size_t N>
struct is_swappable<T[N], T[N]>
    : std::integral_constant<
          bool,
          decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&
              (!decltype(
                   detail::swap_adl_tests::uses_std<T[N], T[N]>(0))::value ||
               is_swappable<T, T>::value)> {};

template <class T, class U = T>
struct is_nothrow_swappable
    : std::integral_constant<
          bool,
          is_swappable<T, U>::value &&
              ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value
                    &&detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||
               (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
                    detail::swap_adl_tests::is_adl_swap_noexcept<T,
                                                                 U>::value))> {
};
#endif

// The storage base manages the actual storage, and correctly propagates
// trivial destruction from T. This case is for when T is not trivially
// destructible.
template <class T, bool = ::std::is_trivially_destructible<T>::value>
struct optional_storage_base {
  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept
      : m_dummy(), m_has_value(false) {}

  template <class... U>
  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U &&... u)
      : m_value(std::forward<U>(u)...), m_has_value(true) {}

  ~optional_storage_base() {
    if (m_has_value) {
      m_value.~T();
      m_has_value = false;
    }
  }

  struct dummy {};
  union {
    dummy m_dummy;
    T m_value;
  };

  bool m_has_value;
};

// This case is for when T is trivially destructible.
template <class T> struct optional_storage_base<T, true> {
  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept
      : m_dummy(), m_has_value(false) {}

  template <class... U>
  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U &&... u)
      : m_value(std::forward<U>(u)...), m_has_value(true) {}

  // No destructor, so this class is trivially destructible

  struct dummy {};
  union {
    dummy m_dummy;
    T m_value;
  };

  bool m_has_value = false;
};

// This base class provides some handy member functions which can be used in
// further derived classes
template <class T> struct optional_operations_base : optional_storage_base<T> {
  using optional_storage_base<T>::optional_storage_base;

  void hard_reset() noexcept {
    get().~T();
    this->m_has_value = false;
  }

  template <class... Args> void construct(Args &&... args) noexcept {
    new (std::addressof(this->m_value)) T(std::forward<Args>(args)...);
    this->m_has_value = true;
  }

  template <class Opt> void assign(Opt &&rhs) {
    if (this->has_value()) {
      if (rhs.has_value()) {
        this->m_value = std::forward<Opt>(rhs).get();
      } else {
        this->m_value.~T();
        this->m_has_value = false;
      }
    }

    else if (rhs.has_value()) {
      construct(std::forward<Opt>(rhs).get());
    }
  }

  bool has_value() const { return this->m_has_value; }

  TL_OPTIONAL_11_CONSTEXPR T &get() & { return this->m_value; }
  TL_OPTIONAL_11_CONSTEXPR const T &get() const & { return this->m_value; }
  TL_OPTIONAL_11_CONSTEXPR T &&get() && { return std::move(this->m_value); }
#ifndef TL_OPTIONAL_NO_CONSTRR
  constexpr const T &&get() const && { return std::move(this->m_value); }
#endif
};

// This class manages conditionally having a trivial copy constructor
// This specialization is for when T is trivially copy constructible
template <class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>
struct optional_copy_base : optional_operations_base<T> {
  using optional_operations_base<T>::optional_operations_base;
};

// This specialization is for when T is not trivially copy constructible
template <class T>
struct optional_copy_base<T, false> : optional_operations_base<T> {
  using optional_operations_base<T>::optional_operations_base;

  optional_copy_base() = default;
  optional_copy_base(const optional_copy_base &rhs) {
    if (rhs.has_value()) {
      this->construct(rhs.get());
    } else {
      this->m_has_value = false;
    }
  }

  optional_copy_base(optional_copy_base &&rhs) = default;
  optional_copy_base &operator=(const optional_copy_base &rhs) = default;
  optional_copy_base &operator=(optional_copy_base &&rhs) = default;
};

// This class manages conditionally having a trivial move constructor
// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
// doesn't implement an analogue to std::is_trivially_move_constructible. We
// have to make do with a non-trivial move constructor even if T is trivially
// move constructible
#ifndef TL_OPTIONAL_GCC49
template <class T, bool = std::is_trivially_move_constructible<T>::value>
struct optional_move_base : optional_copy_base<T> {
  using optional_copy_base<T>::optional_copy_base;
};
#else
template <class T, bool = false> struct optional_move_base;
#endif
template <class T> struct optional_move_base<T, false> : optional_copy_base<T> {
  using optional_copy_base<T>::optional_copy_base;

  optional_move_base() = default;
  optional_move_base(const optional_move_base &rhs) = default;

  optional_move_base(optional_move_base &&rhs) noexcept(
      std::is_nothrow_move_constructible<T>::value) {
    if (rhs.has_value()) {
      this->construct(std::move(rhs.get()));
    } else {
      this->m_has_value = false;
    }
  }
  optional_move_base &operator=(const optional_move_base &rhs) = default;
  optional_move_base &operator=(optional_move_base &&rhs) = default;
};

// This class manages conditionally having a trivial copy assignment operator
template <class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) &&
                          TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) &&
                          TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)>
struct optional_copy_assign_base : optional_move_base<T> {
  using optional_move_base<T>::optional_move_base;
};

template <class T>
struct optional_copy_assign_base<T, false> : optional_move_base<T> {
  using optional_move_base<T>::optional_move_base;

  optional_copy_assign_base() = default;
  optional_copy_assign_base(const optional_copy_assign_base &rhs) = default;

  optional_copy_assign_base(optional_copy_assign_base &&rhs) = default;
  optional_copy_assign_base &operator=(const optional_copy_assign_base &rhs) {
    this->assign(rhs);
    return *this;
  }
  optional_copy_assign_base &
  operator=(optional_copy_assign_base &&rhs) = default;
};

// This class manages conditionally having a trivial move assignment operator
// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
// doesn't implement an analogue to std::is_trivially_move_assignable. We have
// to make do with a non-trivial move assignment operator even if T is trivially
// move assignable
#ifndef TL_OPTIONAL_GCC49
template <class T, bool = std::is_trivially_destructible<T>::value
                       &&std::is_trivially_move_constructible<T>::value
                           &&std::is_trivially_move_assignable<T>::value>
struct optional_move_assign_base : optional_copy_assign_base<T> {
  using optional_copy_assign_base<T>::optional_copy_assign_base;
};
#else
template <class T, bool = false> struct optional_move_assign_base;
#endif

template <class T>
struct optional_move_assign_base<T, false> : optional_copy_assign_base<T> {
  using optional_copy_assign_base<T>::optional_copy_assign_base;

  optional_move_assign_base() = default;
  optional_move_assign_base(const optional_move_assign_base &rhs) = default;

  optional_move_assign_base(optional_move_assign_base &&rhs) = default;

  optional_move_assign_base &
  operator=(const optional_move_assign_base &rhs) = default;

  optional_move_assign_base &
  operator=(optional_move_assign_base &&rhs) noexcept(
      std::is_nothrow_move_constructible<T>::value
          &&std::is_nothrow_move_assignable<T>::value) {
    this->assign(std::move(rhs));
    return *this;
  }
};

// optional_delete_ctor_base will conditionally delete copy and move
// constructors depending on whether T is copy/move constructible
template <class T, bool EnableCopy = std::is_copy_constructible<T>::value,
          bool EnableMove = std::is_move_constructible<T>::value>
struct optional_delete_ctor_base {
  optional_delete_ctor_base() = default;
  optional_delete_ctor_base(const optional_delete_ctor_base &) = default;
  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = default;
  optional_delete_ctor_base &
  operator=(const optional_delete_ctor_base &) = default;
  optional_delete_ctor_base &
  operator=(optional_delete_ctor_base &&) noexcept = default;
};

template <class T> struct optional_delete_ctor_base<T, true, false> {
  optional_delete_ctor_base() = default;
  optional_delete_ctor_base(const optional_delete_ctor_base &) = default;
  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = delete;
  optional_delete_ctor_base &
  operator=(const optional_delete_ctor_base &) = default;
  optional_delete_ctor_base &
  operator=(optional_delete_ctor_base &&) noexcept = default;
};

template <class T> struct optional_delete_ctor_base<T, false, true> {
  optional_delete_ctor_base() = default;
  optional_delete_ctor_base(const optional_delete_ctor_base &) = delete;
  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = default;
  optional_delete_ctor_base &
  operator=(const optional_delete_ctor_base &) = default;
  optional_delete_ctor_base &
  operator=(optional_delete_ctor_base &&) noexcept = default;
};

template <class T> struct optional_delete_ctor_base<T, false, false> {
  optional_delete_ctor_base() = default;
  optional_delete_ctor_base(const optional_delete_ctor_base &) = delete;
  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = delete;
  optional_delete_ctor_base &
  operator=(const optional_delete_ctor_base &) = default;
  optional_delete_ctor_base &
  operator=(optional_delete_ctor_base &&) noexcept = default;
};

// optional_delete_assign_base will conditionally delete copy and move
// constructors depending on whether T is copy/move constructible + assignable
template <class T,
          bool EnableCopy = (std::is_copy_constructible<T>::value &&
                             std::is_copy_assignable<T>::value),
          bool EnableMove = (std::is_move_constructible<T>::value &&
                             std::is_move_assignable<T>::value)>
struct optional_delete_assign_base {
  optional_delete_assign_base() = default;
  optional_delete_assign_base(const optional_delete_assign_base &) = default;
  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =
      default;
  optional_delete_assign_base &
  operator=(const optional_delete_assign_base &) = default;
  optional_delete_assign_base &
  operator=(optional_delete_assign_base &&) noexcept = default;
};

template <class T> struct optional_delete_assign_base<T, true, false> {
  optional_delete_assign_base() = default;
  optional_delete_assign_base(const optional_delete_assign_base &) = default;
  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =
      default;
  optional_delete_assign_base &
  operator=(const optional_delete_assign_base &) = default;
  optional_delete_assign_base &
  operator=(optional_delete_assign_base &&) noexcept = delete;
};

template <class T> struct optional_delete_assign_base<T, false, true> {
  optional_delete_assign_base() = default;
  optional_delete_assign_base(const optional_delete_assign_base &) = default;
  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =
      default;
  optional_delete_assign_base &
  operator=(const optional_delete_assign_base &) = delete;
  optional_delete_assign_base &
  operator=(optional_delete_assign_base &&) noexcept = default;
};

template <class T> struct optional_delete_assign_base<T, false, false> {
  optional_delete_assign_base() = default;
  optional_delete_assign_base(const optional_delete_assign_base &) = default;
  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =
      default;
  optional_delete_assign_base &
  operator=(const optional_delete_assign_base &) = delete;
  optional_delete_assign_base &
  operator=(optional_delete_assign_base &&) noexcept = delete;
};

} // namespace detail

/// \brief A tag type to represent an empty optional
struct nullopt_t {
  struct do_not_use {};
  constexpr explicit nullopt_t(do_not_use, do_not_use) noexcept {}
};
/// \brief Represents an empty optional
/// \synopsis static constexpr nullopt_t nullopt;
///
/// *Examples*:
/// ```
/// tl::optional<int> a = tl::nullopt;
/// void foo (tl::optional<int>);
/// foo(tl::nullopt); //pass an empty optional
/// ```
static constexpr nullopt_t nullopt{nullopt_t::do_not_use{},
                                   nullopt_t::do_not_use{}};

class bad_optional_access : public std::exception {
public:
  bad_optional_access() = default;
  const char *what() const noexcept { return "Optional has no value"; }
};

/// An optional object is an object that contains the storage for another
/// object and manages the lifetime of this contained object, if any. The
/// contained object may be initialized after the optional object has been
/// initialized, and may be destroyed before the optional object has been
/// destroyed. The initialization state of the contained object is tracked by
/// the optional object.
template <class T>
class optional : private detail::optional_move_assign_base<T>,
                 private detail::optional_delete_ctor_base<T>,
                 private detail::optional_delete_assign_base<T> {
  using base = detail::optional_move_assign_base<T>;

  static_assert(!std::is_same<T, in_place_t>::value,
                "instantiation of optional with in_place_t is ill-formed");
  static_assert(!std::is_same<detail::decay_t<T>, nullopt_t>::value,
                "instantiation of optional with nullopt_t is ill-formed");

public:
// The different versions for C++14 and 11 are needed because deduced return
// types are not SFINAE-safe. This provides better support for things like
// generic lambdas. C.f.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html
#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
  /// \group and_then
  /// Carries out some operation which returns an optional on the stored
  /// object if there is one. \requires `std::invoke(std::forward<F>(f),
  /// value())` returns a `std::optional<U>` for some `U`. \returns Let `U` be
  /// the result of `std::invoke(std::forward<F>(f), value())`. Returns a
  /// `std::optional<U>`. The return value is empty if `*this` is empty,
  /// otherwise the return value of `std::invoke(std::forward<F>(f), value())`
  /// is returned.
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) & {
    using result = detail::invoke_result_t<F, T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &&;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) && {
    using result = detail::invoke_result_t<F, T &&>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &;
  template <class F> constexpr auto and_then(F &&f) const & {
    using result = detail::invoke_result_t<F, const T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &&;
  template <class F> constexpr auto and_then(F &&f) const && {
    using result = detail::invoke_result_t<F, const T &&>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : result(nullopt);
  }
#endif
#else
  /// \group and_then
  /// Carries out some operation which returns an optional on the stored
  /// object if there is one. \requires `std::invoke(std::forward<F>(f),
  /// value())` returns a `std::optional<U>` for some `U`.
  /// \returns Let `U` be the result of `std::invoke(std::forward<F>(f),
  /// value())`. Returns a `std::optional<U>`. The return value is empty if
  /// `*this` is empty, otherwise the return value of
  /// `std::invoke(std::forward<F>(f), value())` is returned.
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &> and_then(F &&f) & {
    using result = detail::invoke_result_t<F, T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &&;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &&> and_then(F &&f) && {
    using result = detail::invoke_result_t<F, T &&>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &;
  template <class F>
  constexpr detail::invoke_result_t<F, const T &> and_then(F &&f) const & {
    using result = detail::invoke_result_t<F, const T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &&;
  template <class F>
  constexpr detail::invoke_result_t<F, const T &&> and_then(F &&f) const && {
    using result = detail::invoke_result_t<F, const T &&>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : result(nullopt);
  }
#endif
#endif

#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
  /// \brief Carries out some operation on the stored object if there is one.
  /// \returns Let `U` be the result of `std::invoke(std::forward<F>(f),
  /// value())`. Returns a `std::optional<U>`. The return value is empty if
  /// `*this` is empty, otherwise an `optional<U>` is constructed from the
  /// return value of `std::invoke(std::forward<F>(f), value())` and is
  /// returned.
  ///
  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) &;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) & {
    return optional_map_impl(*this, std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) &&;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) && {
    return optional_map_impl(std::move(*this), std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) const&;
  template <class F> constexpr auto map(F &&f) const & {
    return optional_map_impl(*this, std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) const&&;
  template <class F> constexpr auto map(F &&f) const && {
    return optional_map_impl(std::move(*this), std::forward<F>(f));
  }
#else
  /// \brief Carries out some operation on the stored object if there is one.
  /// \returns Let `U` be the result of `std::invoke(std::forward<F>(f),
  /// value())`. Returns a `std::optional<U>`. The return value is empty if
  /// `*this` is empty, otherwise an `optional<U>` is constructed from the
  /// return value of `std::invoke(std::forward<F>(f), value())` and is
  /// returned.
  ///
  /// \group map
  /// \synopsis template <class F> auto map(F &&f) &;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional &>(),
                                             std::declval<F &&>()))
  map(F &&f) & {
    return optional_map_impl(*this, std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> auto map(F &&f) &&;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional &&>(),
                                             std::declval<F &&>()))
  map(F &&f) && {
    return optional_map_impl(std::move(*this), std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> auto map(F &&f) const&;
  template <class F>
  constexpr decltype(optional_map_impl(std::declval<const optional &>(),
                              std::declval<F &&>()))
  map(F &&f) const & {
    return optional_map_impl(*this, std::forward<F>(f));
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group map
  /// \synopsis template <class F> auto map(F &&f) const&&;
  template <class F>
  constexpr decltype(optional_map_impl(std::declval<const optional &&>(),
                              std::declval<F &&>()))
  map(F &&f) const && {
    return optional_map_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

  /// \brief Calls `f` if the optional is empty
  /// \requires `std::invoke_result_t<F>` must be void or convertible to
  /// `optional<T>`.
  /// \effects If `*this` has a value, returns `*this`.
  /// Otherwise, if `f` returns `void`, calls `std::forward<F>(f)` and returns
  /// `std::nullopt`. Otherwise, returns `std::forward<F>(f)()`.
  ///
  /// \group or_else
  /// \synopsis template <class F> optional<T> or_else (F &&f) &;
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {
    if (has_value())
      return *this;

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {
    return has_value() ? *this : std::forward<F>(f)();
  }

  /// \group or_else
  /// \synopsis template <class F> optional<T> or_else (F &&f) &&;
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) && {
    if (has_value())
      return std::move(*this);

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) && {
    return has_value() ? std::move(*this) : std::forward<F>(f)();
  }

  /// \group or_else
  /// \synopsis template <class F> optional<T> or_else (F &&f) const &;
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) const & {
    if (has_value())
      return *this;

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) const & {
    return has_value() ? *this : std::forward<F>(f)();
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \exclude
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) const && {
    if (has_value())
      return std::move(*this);

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) const && {
    return has_value() ? std::move(*this) : std::forward<F>(f)();
  }
#endif

  /// \brief Maps the stored value with `f` if there is one, otherwise returns
  /// `u`.
  ///
  /// \details If there is a value stored, then `f` is called with `**this`
  /// and the value is returned. Otherwise `u` is returned.
  ///
  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u);
  }

  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u);
  }

  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) const & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) const && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u);
  }
#endif

  /// \brief Maps the stored value with `f` if there is one, otherwise calls
  /// `u` and returns the result.
  ///
  /// \details If there is a value stored, then `f` is
  /// called with `**this` and the value is returned. Otherwise
  /// `std::forward<U>(u)()` is returned.
  ///
  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u) &;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u)();
  }

  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u)
  /// &&;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u)();
  }

  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u)
  /// const &;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u)();
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u)
  /// const &&;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u)();
  }
#endif

  /// \returns `u` if `*this` has a value, otherwise an empty optional.
  template <class U>
  constexpr optional<typename std::decay<U>::type> conjunction(U &&u) const {
    using result = optional<detail::decay_t<U>>;
    return has_value() ? result{u} : result{nullopt};
  }

  /// \returns `rhs` if `*this` is empty, otherwise the current value.
  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) & {
    return has_value() ? *this : rhs;
  }

  /// \group disjunction
  constexpr optional disjunction(const optional &rhs) const & {
    return has_value() ? *this : rhs;
  }

  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) && {
    return has_value() ? std::move(*this) : rhs;
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group disjunction
  constexpr optional disjunction(const optional &rhs) const && {
    return has_value() ? std::move(*this) : rhs;
  }
#endif

  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) & {
    return has_value() ? *this : std::move(rhs);
  }

  /// \group disjunction
  constexpr optional disjunction(optional &&rhs) const & {
    return has_value() ? *this : std::move(rhs);
  }

  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) && {
    return has_value() ? std::move(*this) : std::move(rhs);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group disjunction
  constexpr optional disjunction(optional &&rhs) const && {
    return has_value() ? std::move(*this) : std::move(rhs);
  }
#endif

  /// Takes the value out of the optional, leaving it empty
  /// \group take
  optional take() & {
    optional ret = *this;
    reset();
    return ret;
  }

  /// \group take
  optional take() const & {
    optional ret = *this;
    reset();
    return ret;
  }

  /// \group take
  optional take() && {
    optional ret = std::move(*this);
    reset();
    return ret;
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group take
  optional take() const && {
    optional ret = std::move(*this);
    reset();
    return ret;
  }
#endif

  using value_type = T;

  /// Constructs an optional that does not contain a value.
  /// \group ctor_empty
  constexpr optional() noexcept = default;

  /// \group ctor_empty
  constexpr optional(nullopt_t) noexcept {}

  /// Copy constructor
  ///
  /// If `rhs` contains a value, the stored value is direct-initialized with
  /// it. Otherwise, the constructed optional is empty.
  TL_OPTIONAL_11_CONSTEXPR optional(const optional &rhs) = default;

  /// Move constructor
  ///
  /// If `rhs` contains a value, the stored value is direct-initialized with
  /// it. Otherwise, the constructed optional is empty.
  TL_OPTIONAL_11_CONSTEXPR optional(optional &&rhs) = default;

  /// Constructs the stored value in-place using the given arguments.
  /// \group in_place
  /// \synopsis template <class... Args> constexpr explicit optional(in_place_t, Args&&... args);
  template <class... Args>
  constexpr explicit optional(
      detail::enable_if_t<std::is_constructible<T, Args...>::value, in_place_t>,
      Args &&... args)
      : base(in_place, std::forward<Args>(args)...) {}

  /// \group in_place
  /// \synopsis template <class U, class... Args>\nconstexpr explicit optional(in_place_t, std::initializer_list<U>&, Args&&... args);
  template <class U, class... Args>
  TL_OPTIONAL_11_CONSTEXPR explicit optional(
      detail::enable_if_t<std::is_constructible<T, std::initializer_list<U> &,
                                                Args &&...>::value,
                          in_place_t>,
      std::initializer_list<U> il, Args &&... args) {
    this->construct(il, std::forward<Args>(args)...);
  }

  /// Constructs the stored value with `u`.
  /// \synopsis template <class U=T> constexpr optional(U &&u);
  template <
      class U = T,
      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr,
      detail::enable_forward_value<T, U> * = nullptr>
  constexpr optional(U &&u) : base(in_place, std::forward<U>(u)) {}

  /// \exclude
  template <
      class U = T,
      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr,
      detail::enable_forward_value<T, U> * = nullptr>
  constexpr explicit optional(U &&u) : base(in_place, std::forward<U>(u)) {}

  /// Converting copy constructor.
  /// \synopsis template <class U> optional(const optional<U> &rhs);
  template <
      class U, detail::enable_from_other<T, U, const U &> * = nullptr,
      detail::enable_if_t<std::is_convertible<const U &, T>::value> * = nullptr>
  optional(const optional<U> &rhs) {
    if (rhs.has_value()) {
      this->construct(*rhs);
    }
  }

  /// \exclude
  template <class U, detail::enable_from_other<T, U, const U &> * = nullptr,
            detail::enable_if_t<!std::is_convertible<const U &, T>::value> * =
                nullptr>
  explicit optional(const optional<U> &rhs) {
    if (rhs.has_value()) {
      this->construct(*rhs);
    }
  }

  /// Converting move constructor.
  /// \synopsis template <class U> optional(optional<U> &&rhs);
  template <
      class U, detail::enable_from_other<T, U, U &&> * = nullptr,
      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr>
  optional(optional<U> &&rhs) {
    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    }
  }

  /// \exclude
  template <
      class U, detail::enable_from_other<T, U, U &&> * = nullptr,
      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr>
  explicit optional(optional<U> &&rhs) {
    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    }
  }

  /// Destroys the stored value if there is one.
  ~optional() = default;

  /// Assignment to empty.
  ///
  /// Destroys the current value if there is one.
  optional &operator=(nullopt_t) noexcept {
    if (has_value()) {
      this->m_value.~T();
      this->m_has_value = false;
    }

    return *this;
  }

  /// Copy assignment.
  ///
  /// Copies the value from `rhs` if there is one. Otherwise resets the stored
  /// value in `*this`.
  optional &operator=(const optional &rhs) = default;

  /// Move assignment.
  ///
  /// Moves the value from `rhs` if there is one. Otherwise resets the stored
  /// value in `*this`.
  optional &operator=(optional &&rhs) = default;

  /// Assigns the stored value from `u`, destroying the old value if there was
  /// one.
  /// \synopsis optional &operator=(U &&u);
  template <class U = T, detail::enable_assign_forward<T, U> * = nullptr>
  optional &operator=(U &&u) {
    if (has_value()) {
      this->m_value = std::forward<U>(u);
    } else {
      this->construct(std::forward<U>(u));
    }

    return *this;
  }

  /// Converting copy assignment operator.
  ///
  /// Copies the value from `rhs` if there is one. Otherwise resets the stored
  /// value in `*this`.
  /// \synopsis optional &operator=(const optional<U> & rhs);
  template <class U,
            detail::enable_assign_from_other<T, U, const U &> * = nullptr>
  optional &operator=(const optional<U> &rhs) {
    if (has_value()) {
      if (rhs.has_value()) {
        this->m_value = *rhs;
      } else {
        this->hard_reset();
      }
    }

    if (rhs.has_value()) {
      this->construct(*rhs);
    }

    return *this;
  }

  // TO-DO check exception guarantee
  /// Converting move assignment operator.
  ///
  /// Moves the value from `rhs` if there is one. Otherwise resets the stored
  /// value in `*this`.
  /// \synopsis optional &operator=(optional<U> && rhs);
  template <class U, detail::enable_assign_from_other<T, U, U> * = nullptr>
  optional &operator=(optional<U> &&rhs) {
    if (has_value()) {
      if (rhs.has_value()) {
        this->m_value = std::move(*rhs);
      } else {
        this->hard_reset();
      }
    }

    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    }

    return *this;
  }

  /// Constructs the value in-place, destroying the current one if there is
  /// one.
  /// \group emplace
  template <class... Args> T &emplace(Args &&... args) {
    static_assert(std::is_constructible<T, Args &&...>::value,
                  "T must be constructible with Args");

    *this = nullopt;
    this->construct(std::forward<Args>(args)...);
    return value();
  }

  /// \group emplace
  /// \synopsis template <class U, class... Args>\nT& emplace(std::initializer_list<U> il, Args &&... args);
  template <class U, class... Args>
  detail::enable_if_t<
      std::is_constructible<T, std::initializer_list<U> &, Args &&...>::value,
      T &>
  emplace(std::initializer_list<U> il, Args &&... args) {
    *this = nullopt;
    this->construct(il, std::forward<Args>(args)...);
    return value();    
  }

  /// Swaps this optional with the other.
  ///
  /// If neither optionals have a value, nothing happens.
  /// If both have a value, the values are swapped.
  /// If one has a value, it is moved to the other and the movee is left
  /// valueless.
  void
  swap(optional &rhs) noexcept(std::is_nothrow_move_constructible<T>::value
                                   &&detail::is_nothrow_swappable<T>::value) {
    if (has_value()) {
      if (rhs.has_value()) {
        using std::swap;
        swap(**this, *rhs);
      } else {
        new (std::addressof(rhs.m_value)) T(std::move(this->m_value));
        this->m_value.T::~T();
      }
    } else if (rhs.has_value()) {
      new (std::addressof(this->m_value)) T(std::move(rhs.m_value));
      rhs.m_value.T::~T();
    }
  }

  /// \returns a pointer to the stored value
  /// \requires a value is stored
  /// \group pointer
  /// \synopsis constexpr const T *operator->() const;
  constexpr const T *operator->() const {
    return std::addressof(this->m_value);
  }

  /// \group pointer
  /// \synopsis constexpr T *operator->();
  TL_OPTIONAL_11_CONSTEXPR T *operator->() {
    return std::addressof(this->m_value);
  }

  /// \returns the stored value
  /// \requires a value is stored
  /// \group deref
  /// \synopsis constexpr T &operator*();
  TL_OPTIONAL_11_CONSTEXPR T &operator*() & { return this->m_value; }

  /// \group deref
  /// \synopsis constexpr const T &operator*() const;
  constexpr const T &operator*() const & { return this->m_value; }

  /// \exclude
  TL_OPTIONAL_11_CONSTEXPR T &&operator*() && {
    return std::move(this->m_value);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \exclude
  constexpr const T &&operator*() const && { return std::move(this->m_value); }
#endif

  /// \returns whether or not the optional has a value
  /// \group has_value
  constexpr bool has_value() const noexcept { return this->m_has_value; }

  /// \group has_value
  constexpr explicit operator bool() const noexcept {
    return this->m_has_value;
  }

  /// \returns the contained value if there is one, otherwise throws
  /// [bad_optional_access]
  /// \group value
  /// \synopsis constexpr T &value();
  TL_OPTIONAL_11_CONSTEXPR T &value() & {
    if (has_value())
      return this->m_value;
    throw bad_optional_access();
  }
  /// \group value
  /// \synopsis constexpr const T &value() const;
  TL_OPTIONAL_11_CONSTEXPR const T &value() const & {
    if (has_value())
      return this->m_value;
    throw bad_optional_access();
  }
  /// \exclude
  TL_OPTIONAL_11_CONSTEXPR T &&value() && {
    if (has_value())
      return std::move(this->m_value);
    throw bad_optional_access();
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \exclude
  TL_OPTIONAL_11_CONSTEXPR const T &&value() const && {
    if (has_value())
      return std::move(this->m_value);
    throw bad_optional_access();
  }
#endif

  /// \returns the stored value if there is one, otherwise returns `u`
  /// \group value_or
  template <class U> constexpr T value_or(U &&u) const & {
    static_assert(std::is_copy_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be copy constructible and convertible from U");
    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
  }

  /// \group value_or
  template <class U> TL_OPTIONAL_11_CONSTEXPR T value_or(U &&u) && {
    static_assert(std::is_move_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be move constructible and convertible from U");
    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
  }

  /// Destroys the stored value if one exists, making the optional empty
  void reset() noexcept {
    if (has_value()) {
      this->m_value.~T();
      this->m_has_value = false;
    }
  }
}; // namespace tl

/// \group relop
/// \brief Compares two optional objects
/// \details If both optionals contain a value, they are compared with `T`s
/// relational operators. Otherwise `lhs` and `rhs` are equal only if they are
/// both empty, and `lhs` is less than `rhs` only if `rhs` is empty and `lhs`
/// is not.
template <class T, class U>
inline constexpr bool operator==(const optional<T> &lhs,
                                 const optional<U> &rhs) {
  return lhs.has_value() == rhs.has_value() &&
         (!lhs.has_value() || *lhs == *rhs);
}
/// \group relop
template <class T, class U>
inline constexpr bool operator!=(const optional<T> &lhs,
                                 const optional<U> &rhs) {
  return lhs.has_value() != rhs.has_value() ||
         (lhs.has_value() && *lhs != *rhs);
}
/// \group relop
template <class T, class U>
inline constexpr bool operator<(const optional<T> &lhs,
                                const optional<U> &rhs) {
  return rhs.has_value() && (!lhs.has_value() || *lhs < *rhs);
}
/// \group relop
template <class T, class U>
inline constexpr bool operator>(const optional<T> &lhs,
                                const optional<U> &rhs) {
  return lhs.has_value() && (!rhs.has_value() || *lhs > *rhs);
}
/// \group relop
template <class T, class U>
inline constexpr bool operator<=(const optional<T> &lhs,
                                 const optional<U> &rhs) {
  return !lhs.has_value() || (rhs.has_value() && *lhs <= *rhs);
}
/// \group relop
template <class T, class U>
inline constexpr bool operator>=(const optional<T> &lhs,
                                 const optional<U> &rhs) {
  return !rhs.has_value() || (lhs.has_value() && *lhs >= *rhs);
}

/// \group relop_nullopt
/// \brief Compares an optional to a `nullopt`
/// \details Equivalent to comparing the optional to an empty optional
template <class T>
inline constexpr bool operator==(const optional<T> &lhs, nullopt_t) noexcept {
  return !lhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator==(nullopt_t, const optional<T> &rhs) noexcept {
  return !rhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator!=(const optional<T> &lhs, nullopt_t) noexcept {
  return lhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator!=(nullopt_t, const optional<T> &rhs) noexcept {
  return rhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator<(const optional<T> &, nullopt_t) noexcept {
  return false;
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator<(nullopt_t, const optional<T> &rhs) noexcept {
  return rhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator<=(const optional<T> &lhs, nullopt_t) noexcept {
  return !lhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator<=(nullopt_t, const optional<T> &) noexcept {
  return true;
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator>(const optional<T> &lhs, nullopt_t) noexcept {
  return lhs.has_value();
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator>(nullopt_t, const optional<T> &) noexcept {
  return false;
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator>=(const optional<T> &, nullopt_t) noexcept {
  return true;
}
/// \group relop_nullopt
template <class T>
inline constexpr bool operator>=(nullopt_t, const optional<T> &rhs) noexcept {
  return !rhs.has_value();
}

/// \group relop_t
/// \brief Compares the optional with a value.
/// \details If the optional has a value, it is compared with the other value
/// using `T`s relational operators. Otherwise, the optional is considered
/// less than the value.
template <class T, class U>
inline constexpr bool operator==(const optional<T> &lhs, const U &rhs) {
  return lhs.has_value() ? *lhs == rhs : false;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator==(const U &lhs, const optional<T> &rhs) {
  return rhs.has_value() ? lhs == *rhs : false;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator!=(const optional<T> &lhs, const U &rhs) {
  return lhs.has_value() ? *lhs != rhs : true;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator!=(const U &lhs, const optional<T> &rhs) {
  return rhs.has_value() ? lhs != *rhs : true;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator<(const optional<T> &lhs, const U &rhs) {
  return lhs.has_value() ? *lhs < rhs : true;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator<(const U &lhs, const optional<T> &rhs) {
  return rhs.has_value() ? lhs < *rhs : false;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator<=(const optional<T> &lhs, const U &rhs) {
  return lhs.has_value() ? *lhs <= rhs : true;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator<=(const U &lhs, const optional<T> &rhs) {
  return rhs.has_value() ? lhs <= *rhs : false;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator>(const optional<T> &lhs, const U &rhs) {
  return lhs.has_value() ? *lhs > rhs : false;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator>(const U &lhs, const optional<T> &rhs) {
  return rhs.has_value() ? lhs > *rhs : true;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator>=(const optional<T> &lhs, const U &rhs) {
  return lhs.has_value() ? *lhs >= rhs : false;
}
/// \group relop_t
template <class T, class U>
inline constexpr bool operator>=(const U &lhs, const optional<T> &rhs) {
  return rhs.has_value() ? lhs >= *rhs : true;
}

/// \synopsis template <class T>\nvoid swap(optional<T> &lhs, optional<T> &rhs);
template <class T,
          detail::enable_if_t<std::is_move_constructible<T>::value> * = nullptr,
          detail::enable_if_t<detail::is_swappable<T>::value> * = nullptr>
void swap(optional<T> &lhs,
          optional<T> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
  return lhs.swap(rhs);
}

namespace detail {
struct i_am_secret {};
} // namespace detail

template <class T = detail::i_am_secret, class U,
          class Ret =
              detail::conditional_t<std::is_same<T, detail::i_am_secret>::value,
                                    detail::decay_t<U>, T>>
inline constexpr optional<Ret> make_optional(U &&v) {
  return optional<Ret>(std::forward<U>(v));
}

template <class T, class... Args>
inline constexpr optional<T> make_optional(Args &&... args) {
  return optional<T>(in_place, std::forward<Args>(args)...);
}
template <class T, class U, class... Args>
inline constexpr optional<T> make_optional(std::initializer_list<U> il,
                                           Args &&... args) {
  return optional<T>(in_place, il, std::forward<Args>(args)...);
}

#if __cplusplus >= 201703L
template <class T> optional(T)->optional<T>;
#endif

/// \exclude
namespace detail {
#ifdef TL_OPTIONAL_CXX14
template <class Opt, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Opt>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto optional_map_impl(Opt &&opt, F &&f) {
  return opt.has_value()
             ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))
             : optional<Ret>(nullopt);
}

template <class Opt, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Opt>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto optional_map_impl(Opt &&opt, F &&f) {
  if (opt.has_value()) {
    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));
    return make_optional(monostate{});
  }

  return optional<monostate>(nullopt);
}
#else
template <class Opt, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Opt>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>

constexpr auto optional_map_impl(Opt &&opt, F &&f) -> optional<Ret> {
  return opt.has_value()
             ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))
             : optional<Ret>(nullopt);
}

template <class Opt, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Opt>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>

auto optional_map_impl(Opt &&opt, F &&f) -> optional<monostate> {
  if (opt.has_value()) {
    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));
    return monostate{};
  }

  return nullopt;
}
#endif
} // namespace detail

/// Specialization for when `T` is a reference. `optional<T&>` acts similarly
/// to a `T*`, but provides more operations and shows intent more clearly.
///
/// *Examples*:
///
/// ```
/// int i = 42;
/// tl::optional<int&> o = i;
/// *o == 42; //true
/// i = 12;
/// *o = 12; //true
/// &*o == &i; //true
/// ```
///
/// Assignment has rebind semantics rather than assign-through semantics:
///
/// ```
/// int j = 8;
/// o = j;
///
/// &*o == &j; //true
/// ```
template <class T> class optional<T &> {
public:
// The different versions for C++14 and 11 are needed because deduced return
// types are not SFINAE-safe. This provides better support for things like
// generic lambdas. C.f.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html
#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
  /// \group and_then
  /// Carries out some operation which returns an optional on the stored
  /// object if there is one. \requires `std::invoke(std::forward<F>(f),
  /// value())` returns a `std::optional<U>` for some `U`. \returns Let `U` be
  /// the result of `std::invoke(std::forward<F>(f), value())`. Returns a
  /// `std::optional<U>`. The return value is empty if `*this` is empty,
  /// otherwise the return value of `std::invoke(std::forward<F>(f), value())`
  /// is returned.
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) & {
    using result = detail::invoke_result_t<F, T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &&;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) && {
    using result = detail::invoke_result_t<F, T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &;
  template <class F> constexpr auto and_then(F &&f) const & {
    using result = detail::invoke_result_t<F, const T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &&;
  template <class F> constexpr auto and_then(F &&f) const && {
    using result = detail::invoke_result_t<F, const T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }
#endif
#else
  /// \group and_then
  /// Carries out some operation which returns an optional on the stored
  /// object if there is one. \requires `std::invoke(std::forward<F>(f),
  /// value())` returns a `std::optional<U>` for some `U`. \returns Let `U` be
  /// the result of `std::invoke(std::forward<F>(f), value())`. Returns a
  /// `std::optional<U>`. The return value is empty if `*this` is empty,
  /// otherwise the return value of `std::invoke(std::forward<F>(f), value())`
  /// is returned.
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &> and_then(F &&f) & {
    using result = detail::invoke_result_t<F, T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) &&;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &> and_then(F &&f) && {
    using result = detail::invoke_result_t<F, T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &;
  template <class F>
  constexpr detail::invoke_result_t<F, const T &> and_then(F &&f) const & {
    using result = detail::invoke_result_t<F, const T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group and_then
  /// \synopsis template <class F>\nconstexpr auto and_then(F &&f) const &&;
  template <class F>
  constexpr detail::invoke_result_t<F, const T &> and_then(F &&f) const && {
    using result = detail::invoke_result_t<F, const T &>;
    static_assert(detail::is_optional<result>::value,
                  "F must return an optional");

    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : result(nullopt);
  }
#endif
#endif

#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
  /// \brief Carries out some operation on the stored object if there is one.
  /// \returns Let `U` be the result of `std::invoke(std::forward<F>(f),
  /// value())`. Returns a `std::optional<U>`. The return value is empty if
  /// `*this` is empty, otherwise an `optional<U>` is constructed from the
  /// return value of `std::invoke(std::forward<F>(f), value())` and is
  /// returned.
  ///
  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) &;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) & {
    return detail::optional_map_impl(*this, std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) &&;
  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) && {
    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) const&;
  template <class F> constexpr auto map(F &&f) const & {
    return detail::optional_map_impl(*this, std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> constexpr auto map(F &&f) const&&;
  template <class F> constexpr auto map(F &&f) const && {
    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
  }
#else
  /// \brief Carries out some operation on the stored object if there is one.
  /// \returns Let `U` be the result of `std::invoke(std::forward<F>(f),
  /// value())`. Returns a `std::optional<U>`. The return value is empty if
  /// `*this` is empty, otherwise an `optional<U>` is constructed from the
  /// return value of `std::invoke(std::forward<F>(f), value())` and is
  /// returned.
  ///
  /// \group map
  /// \synopsis template <class F> auto map(F &&f) &;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(std::declval<optional &>(),
                                                     std::declval<F &&>()))
  map(F &&f) & {
    return detail::optional_map_impl(*this, std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> auto map(F &&f) &&;
  template <class F>
  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(std::declval<optional &&>(),
                                                     std::declval<F &&>()))
  map(F &&f) && {
    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
  }

  /// \group map
  /// \synopsis template <class F> auto map(F &&f) const&;
  template <class F>
  constexpr decltype(detail::optional_map_impl(std::declval<const optional &>(),
                                      std::declval<F &&>()))
  map(F &&f) const & {
    return detail::optional_map_impl(*this, std::forward<F>(f));
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group map
  /// \synopsis template <class F> auto map(F &&f) const&&;
  template <class F>
  constexpr decltype(detail::optional_map_impl(std::declval<const optional &&>(),
                                      std::declval<F &&>()))
  map(F &&f) const && {
    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

  /// \brief Calls `f` if the optional is empty
  /// \requires `std::invoke_result_t<F>` must be void or convertible to
  /// `optional<T>`. \effects If `*this` has a value, returns `*this`.
  /// Otherwise, if `f` returns `void`, calls `std::forward<F>(f)` and returns
  /// `std::nullopt`. Otherwise, returns `std::forward<F>(f)()`.
  ///
  /// \group or_else
  /// \synopsis template <class F> optional<T> or_else (F &&f) &;
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {
    if (has_value())
      return *this;

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {
    return has_value() ? *this : std::forward<F>(f)();
  }

  /// \group or_else
  /// \synopsis template <class F> optional<T> or_else (F &&f) &&;
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) && {
    if (has_value())
      return std::move(*this);

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) && {
    return has_value() ? std::move(*this) : std::forward<F>(f)();
  }

  /// \group or_else
  /// \synopsis template <class F> optional<T> or_else (F &&f) const &;
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) const & {
    if (has_value())
      return *this;

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) const & {
    return has_value() ? *this : std::forward<F>(f)();
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \exclude
  template <class F, detail::enable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) const && {
    if (has_value())
      return std::move(*this);

    std::forward<F>(f)();
    return nullopt;
  }

  /// \exclude
  template <class F, detail::disable_if_ret_void<F> * = nullptr>
  optional<T> or_else(F &&f) const && {
    return has_value() ? std::move(*this) : std::forward<F>(f)();
  }
#endif

  /// \brief Maps the stored value with `f` if there is one, otherwise returns
  /// `u`.
  ///
  /// \details If there is a value stored, then `f` is called with `**this`
  /// and the value is returned. Otherwise `u` is returned.
  ///
  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u);
  }

  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u);
  }

  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) const & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group map_or
  template <class F, class U> U map_or(F &&f, U &&u) const && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u);
  }
#endif

  /// \brief Maps the stored value with `f` if there is one, otherwise calls
  /// `u` and returns the result.
  ///
  /// \details If there is a value stored, then `f` is
  /// called with `**this` and the value is returned. Otherwise
  /// `std::forward<U>(u)()` is returned.
  ///
  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u) &;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u)();
  }

  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u)
  /// &&;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u)();
  }

  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u)
  /// const &;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const & {
    return has_value() ? detail::invoke(std::forward<F>(f), **this)
                       : std::forward<U>(u)();
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group map_or_else
  /// \synopsis template <class F, class U>\nauto map_or_else(F &&f, U &&u)
  /// const &&;
  template <class F, class U>
  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const && {
    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
                       : std::forward<U>(u)();
  }
#endif

  /// \returns `u` if `*this` has a value, otherwise an empty optional.
  template <class U>
  constexpr optional<typename std::decay<U>::type> conjunction(U &&u) const {
    using result = optional<detail::decay_t<U>>;
    return has_value() ? result{u} : result{nullopt};
  }

  /// \returns `rhs` if `*this` is empty, otherwise the current value.
  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) & {
    return has_value() ? *this : rhs;
  }

  /// \group disjunction
  constexpr optional disjunction(const optional &rhs) const & {
    return has_value() ? *this : rhs;
  }

  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) && {
    return has_value() ? std::move(*this) : rhs;
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group disjunction
  constexpr optional disjunction(const optional &rhs) const && {
    return has_value() ? std::move(*this) : rhs;
  }
#endif

  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) & {
    return has_value() ? *this : std::move(rhs);
  }

  /// \group disjunction
  constexpr optional disjunction(optional &&rhs) const & {
    return has_value() ? *this : std::move(rhs);
  }

  /// \group disjunction
  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) && {
    return has_value() ? std::move(*this) : std::move(rhs);
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group disjunction
  constexpr optional disjunction(optional &&rhs) const && {
    return has_value() ? std::move(*this) : std::move(rhs);
  }
#endif

  /// Takes the value out of the optional, leaving it empty
  /// \group take
  optional take() & {
    optional ret = *this;
    reset();
    return ret;
  }

  /// \group take
  optional take() const & {
    optional ret = *this;
    reset();
    return ret;
  }

  /// \group take
  optional take() && {
    optional ret = std::move(*this);
    reset();
    return ret;
  }

#ifndef TL_OPTIONAL_NO_CONSTRR
  /// \group take
  optional take() const && {
    optional ret = std::move(*this);
    reset();
    return ret;
  }
#endif

  using value_type = T &;

  /// Constructs an optional that does not contain a value.
  /// \group ctor_empty
  constexpr optional() noexcept : m_value(nullptr) {}

  /// \group ctor_empty
  constexpr optional(nullopt_t) noexcept : m_value(nullptr) {}

  /// Copy constructor
  ///
  /// If `rhs` contains a value, the stored value is direct-initialized with
  /// it. Otherwise, the constructed optional is empty.
  TL_OPTIONAL_11_CONSTEXPR optional(const optional &rhs) noexcept = default;

  /// Move constructor
  ///
  /// If `rhs` contains a value, the stored value is direct-initialized with
  /// it. Otherwise, the constructed optional is empty.
  TL_OPTIONAL_11_CONSTEXPR optional(optional &&rhs) = default;

  /// Constructs the stored value with `u`.
  /// \synopsis template <class U=T> constexpr optional(U &&u);
  template <class U = T,
            detail::enable_if_t<!detail::is_optional<detail::decay_t<U>>::value>
                * = nullptr>
  constexpr optional(U &&u) : m_value(std::addressof(u)) {
    static_assert(std::is_lvalue_reference<U>::value, "U must be an lvalue");
  }

  /// \exclude
  template <class U>
  constexpr explicit optional(const optional<U> &rhs) : optional(*rhs) {}

  /// No-op
  ~optional() = default;

  /// Assignment to empty.
  ///
  /// Destroys the current value if there is one.
  optional &operator=(nullopt_t) noexcept {
    m_value = nullptr;
    return *this;
  }

  /// Copy assignment.
  ///
  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise
  /// resets the stored value in `*this`.
  optional &operator=(const optional &rhs) = default;

  /// Rebinds this optional to `u`.
  ///
  /// \requires `U` must be an lvalue reference.
  /// \synopsis optional &operator=(U &&u);
  template <class U = T,
            detail::enable_if_t<!detail::is_optional<detail::decay_t<U>>::value>
                * = nullptr>
  optional &operator=(U &&u) {
    static_assert(std::is_lvalue_reference<U>::value, "U must be an lvalue");
    m_value = std::addressof(u);
    return *this;
  }

  /// Converting copy assignment operator.
  ///
  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise
  /// resets the stored value in `*this`.
  template <class U> optional &operator=(const optional<U> &rhs) {
    m_value = std::addressof(rhs.value());
    return *this;
  }

  /// Constructs the value in-place, destroying the current one if there is
  /// one.
  ///
  /// \group emplace
  template <class... Args> T &emplace(Args &&... args) noexcept {
    static_assert(std::is_constructible<T, Args &&...>::value,
                  "T must be constructible with Args");

    *this = nullopt;
    this->construct(std::forward<Args>(args)...);
    return value();
  }

  /// Swaps this optional with the other.
  ///
  /// If neither optionals have a value, nothing happens.
  /// If both have a value, the values are swapped.
  /// If one has a value, it is moved to the other and the movee is left
  /// valueless.
  void swap(optional &rhs) noexcept { std::swap(m_value, rhs.m_value); }

  /// \returns a pointer to the stored value
  /// \requires a value is stored
  /// \group pointer
  /// \synopsis constexpr const T *operator->() const;
  constexpr const T *operator->() const { return m_value; }

  /// \group pointer
  /// \synopsis constexpr T *operator->();
  TL_OPTIONAL_11_CONSTEXPR T *operator->() { return m_value; }

  /// \returns the stored value
  /// \requires a value is stored
  /// \group deref
  /// \synopsis constexpr T &operator*();
  TL_OPTIONAL_11_CONSTEXPR T &operator*() { return *m_value; }

  /// \group deref
  /// \synopsis constexpr const T &operator*() const;
  constexpr const T &operator*() const { return *m_value; }

  /// \returns whether or not the optional has a value
  /// \group has_value
  constexpr bool has_value() const noexcept { return m_value != nullptr; }

  /// \group has_value
  constexpr explicit operator bool() const noexcept {
    return m_value != nullptr;
  }

  /// \returns the contained value if there is one, otherwise throws
  /// [bad_optional_access]
  /// \group value
  /// synopsis constexpr T &value();
  TL_OPTIONAL_11_CONSTEXPR T &value() {
    if (has_value())
      return *m_value;
    throw bad_optional_access();
  }
  /// \group value
  /// \synopsis constexpr const T &value() const;
  TL_OPTIONAL_11_CONSTEXPR const T &value() const {
    if (has_value())
      return *m_value;
    throw bad_optional_access();
  }

  /// \returns the stored value if there is one, otherwise returns `u`
  /// \group value_or
  template <class U> constexpr T value_or(U &&u) const & {
    static_assert(std::is_copy_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be copy constructible and convertible from U");
    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
  }

  /// \group value_or
  template <class U> TL_OPTIONAL_11_CONSTEXPR T value_or(U &&u) && {
    static_assert(std::is_move_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be move constructible and convertible from U");
    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
  }

  /// Destroys the stored value if one exists, making the optional empty
  void reset() noexcept { m_value = nullptr; }

private:
  T *m_value;
}; // namespace tl



} // namespace tl

namespace std {
// TO-DO SFINAE
template <class T> struct hash<tl::optional<T>> {
  ::std::size_t operator()(const tl::optional<T> &o) const {
    if (!o.has_value())
      return 0;

    return std::hash<tl::detail::remove_const_t<T>>()(*o);
  }
};
} // namespace std

#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/ordered-map/LICENSE`:

```
MIT License

Copyright (c) 2017 Tessil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/ordered-map/README.md`:

```md
[![Build Status](https://travis-ci.org/Tessil/ordered-map.svg?branch=master)](https://travis-ci.org/Tessil/ordered-map) [![Build status](https://ci.appveyor.com/api/projects/status/7fug7piv59d0in36/branch/master?svg=true)](https://ci.appveyor.com/project/Tessil/ordered-map/branch/master)

## C++ hash map and hash set which preserves the order of insertion

The ordered-map library provides a hash map and a hash set which preserve the order of insertion in a way similar to Python's [OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict). When iterating over the map, the values will be returned in the same order as they were inserted.

The values are stored contiguously in an underlying structure, no holes in-between values even after an erase operation. By default a `std::deque` is used for this structure, but it's also possible to  use a `std::vector`. This structure is directly accessible through the `values_container()` method and if the structure is a `std::vector`, a `data()` method is also provided to easily interact with C APIs.

To resolve collisions on hashes, the library uses linear robin hood probing with backward shift deletion.

The library provides a behaviour similar to a `std::deque/std::vector` with unique values but with an average time complexity of O(1) for lookups and an amortised time complexity of O(1) for insertions. This comes at the price of a little higher memory footprint (8 bytes per bucket by default).

Two classes are provided: `tsl::ordered_map` and `tsl::ordered_set`.

**Note**: The library uses a power of two for the size of its buckets array to take advantage of the [fast modulo](https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues). For good performances, it requires the hash table to have a well-distributed hash function. If you encounter performance issues check your hash function.

### Key features

- Header-only library, just add the [include](include/) directory to your include path and you are ready to go. If you use CMake, you can also use the `tsl::ordered_map` exported target from the [CMakeLists.txt](CMakeLists.txt).
- Values are stored in the same order as the insertion order. The library provides a direct access to the underlying structure which stores the values.
- O(1) average time complexity for lookups with performances similar to `std::unordered_map` but with faster insertions and reduced memory usage (see [benchmark](https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html) for details).
- Provide random access iterators and also reverse iterators.
- Support for heterogeneous lookups allowing the usage of `find` with a type different than `Key` (e.g. if you have a map that uses `std::unique_ptr<foo>` as key, you can use a `foo*` or a `std::uintptr_t` as key parameter to `find` without constructing a `std::unique_ptr<foo>`, see [example](#heterogeneous-lookups)).
- If the hash is known before a lookup, it is possible to pass it as parameter to speed-up the lookup (see `precalculated_hash` parameter in [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a7fcde27edc6697a0b127f4b1aefa8a7d)).
- The library can be used with exceptions disabled (through `-fno-exceptions` option on Clang and GCC, without an `/EH` option on MSVC or simply by defining `TSL_NO_EXCEPTIONS`). `std::terminate` is used in replacement of the `throw` instruction when exceptions are disabled.
- API closely similar to `std::unordered_map` and `std::unordered_set`.

### Differences compare to `std::unordered_map`
`tsl::ordered_map` tries to have an interface similar to `std::unordered_map`, but some differences exist.
- The iterators are `RandomAccessIterator`.
- Iterator invalidation behaves in a way closer to `std::vector` and `std::deque` (see [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details) for details). If you use `std::vector` as `ValueTypeContainer`, you can use `reserve()` to preallocate some space and avoid the invalidation of the iterators on insert.
- Slow `erase()` operation, it has a complexity of O(n). A faster O(1) version `unordered_erase()` exists, but it breaks the insertion order (see [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a9f94a7889fa7fa92eea41ca63b3f98a4) for details). An O(1) `pop_back()` is also available.
- The equality oprators `operator==` and `operator!=` are order dependent. Two `tsl::ordered_map` with the same values but inserted in a different order don't compare equal.
- For iterators, `operator*()` and `operator->()` return a reference and a pointer to `const std::pair<Key, T>` instead of `std::pair<const Key, T>` making the value `T` not modifiable. To modify the value you have to call the `value()` method of the iterator to get a mutable reference. Example:
```c++
tsl::ordered_map<int, int> map = {{1, 1}, {2, 1}, {3, 1}};
for(auto it = map.begin(); it != map.end(); ++it) {
    //it->second = 2; // Illegal
    it.value() = 2; // Ok
}
```
- By default the map can only hold up to 2<sup>32</sup> - 1 values, that is 4 294 967 295 values. This can be raised through the `IndexType` class template parameter, check the [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details) for details. 
- No support for some bucket related methods (like `bucket_size`, `bucket`, ...).


Thread-safety guarantee is the same as `std::unordered_map`  (i.e. possible to have multiple concurrent readers with no writer).

Concerning the strong exception guarantee, it holds only if `ValueContainer::emplace_back` has the strong exception guarantee (which is true for `std::vector` and `std::deque` as long as the type `T` is not a move-only type with a move constructor that may throw an exception, see [details](http://en.cppreference.com/w/cpp/container/vector/emplace_back#Exceptions)).

These differences also apply between `std::unordered_set` and `tsl::ordered_set`.


### Installation

To use ordered-map, just add the [include](include/) directory to your include path. It is a **header-only** library.

If you use CMake, you can also use the `tsl::ordered_map` exported target from the [CMakeLists.txt](CMakeLists.txt) with `target_link_libraries`. 
```cmake
# Example where the ordered-map project is stored in a third-party directory
add_subdirectory(third-party/ordered-map)
target_link_libraries(your_target PRIVATE tsl::ordered_map)  
```

The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.

To run the tests you will need the Boost Test library and CMake.

```bash
git clone https://github.com/Tessil/ordered-map.git
cd ordered-map/tests
mkdir build
cd build
cmake ..
cmake --build .
./tsl_ordered_map_tests 
```

### Usage

The API can be found [here](https://tessil.github.io/ordered-map/).

### Example

```c++
#include <iostream>
#include <string>
#include <cstdlib>
#include <tsl/ordered_map.h>
#include <tsl/ordered_set.h>

int main() {
    tsl::ordered_map<char, int> map = {{'d', 1}, {'a', 2}, {'g', 3}};
    map.insert({'b', 4});
    map['h'] = 5;
    map['e'] = 6;
    
    map.erase('a');
    
    
    // {d, 1} {g, 3} {b, 4} {h, 5} {e, 6}
    for(const auto& key_value : map) {
        std::cout << "{" << key_value.first << ", " << key_value.second << "}" << std::endl;
    }
    
    
    map.unordered_erase('b');
    
    // Break order: {d, 1} {g, 3} {e, 6} {h, 5}
    for(const auto& key_value : map) {
        std::cout << "{" << key_value.first << ", " << key_value.second << "}" << std::endl;
    }
    
    
    for(auto it = map.begin(); it != map.end(); ++it) {
        //it->second += 2; // Not valid.
        it.value() += 2;
    }
    
    
    if(map.find('d') != map.end()) {
        std::cout << "Found 'd'." << std::endl;
    }
    
    const std::size_t precalculated_hash = std::hash<char>()('d');
    // If we already know the hash beforehand, we can pass it as argument to speed-up the lookup.
    if(map.find('d', precalculated_hash) != map.end()) {
        std::cout << "Found 'd' with hash " << precalculated_hash << "." << std::endl;
    }
    
    
    tsl::ordered_set<char, std::hash<char>, std::equal_to<char>,
                     std::allocator<char>, std::vector<char>> set;
    set.reserve(6);
    
    set = {'3', '4', '9', '2'};
    set.erase('2');
    set.insert('1');
    set.insert('\0');
    
    set.pop_back();
    set.insert({'0', '\0'});
    
    // Get raw buffer for C API: 34910
    std::cout << atoi(set.data()) << std::endl;
}
```

#### Heterogeneous lookup

Heterogeneous overloads allow the usage of other types than `Key` for lookup and erase operations as long as the used types are hashable and comparable to `Key`.

To activate the heterogeneous overloads in `tsl::ordered_map/set`, the qualified-id `KeyEqual::is_transparent` must be valid. It works the same way as for [`std::map::find`](http://en.cppreference.com/w/cpp/container/map/find). You can either use [`std::equal_to<>`](http://en.cppreference.com/w/cpp/utility/functional/equal_to_void) or define your own function object.

Both `KeyEqual` and `Hash` will need to be able to deal with the different types.

```c++
#include <functional>
#include <iostream>
#include <string>
#include <tsl/ordered_map.h>



struct employee {
    employee(int id, std::string name) : m_id(id), m_name(std::move(name)) {
    }
    
    // Either we include the comparators in the class and we use `std::equal_to<>`...
    friend bool operator==(const employee& empl, int empl_id) {
        return empl.m_id == empl_id;
    }
    
    friend bool operator==(int empl_id, const employee& empl) {
        return empl_id == empl.m_id;
    }
    
    friend bool operator==(const employee& empl1, const employee& empl2) {
        return empl1.m_id == empl2.m_id;
    }
    
    
    int m_id;
    std::string m_name;
};

// ... or we implement a separate class to compare employees.
struct equal_employee {
    using is_transparent = void;
    
    bool operator()(const employee& empl, int empl_id) const {
        return empl.m_id == empl_id;
    }
    
    bool operator()(int empl_id, const employee& empl) const {
        return empl_id == empl.m_id;
    }
    
    bool operator()(const employee& empl1, const employee& empl2) const {
        return empl1.m_id == empl2.m_id;
    }
};

struct hash_employee {
    std::size_t operator()(const employee& empl) const {
        return std::hash<int>()(empl.m_id);
    }
    
    std::size_t operator()(int id) const {
        return std::hash<int>()(id);
    }
};


int main() {
    // Use std::equal_to<> which will automatically deduce and forward the parameters
    tsl::ordered_map<employee, int, hash_employee, std::equal_to<>> map; 
    map.insert({employee(1, "John Doe"), 2001});
    map.insert({employee(2, "Jane Doe"), 2002});
    map.insert({employee(3, "John Smith"), 2003});

    // John Smith 2003
    auto it = map.find(3);
    if(it != map.end()) {
        std::cout << it->first.m_name << " " << it->second << std::endl;
    }

    map.erase(1);



    // Use a custom KeyEqual which has an is_transparent member type
    tsl::ordered_map<employee, int, hash_employee, equal_employee> map2;
    map2.insert({employee(4, "Johnny Doe"), 2004});

    // 2004
    std::cout << map2.at(4) << std::endl;
} 
```

### License

The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/ordered-map/include/tsl/ordered_hash.h`:

```h
/**
 * MIT License
 * 
 * Copyright (c) 2017 Tessil
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef TSL_ORDERED_HASH_H
#define TSL_ORDERED_HASH_H


#include <algorithm>
#include <cassert>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <exception>
#include <functional>
#include <iterator>
#include <limits>
#include <memory>
#include <stdexcept>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>


/**
 * Macros for compatibility with GCC 4.8
 */
#if (defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ < 9))
#    define TSL_OH_NO_CONTAINER_ERASE_CONST_ITERATOR
#    define TSL_OH_NO_CONTAINER_EMPLACE_CONST_ITERATOR
#endif

/**
 * Only activate tsl_oh_assert if TSL_DEBUG is defined. 
 * This way we avoid the performance hit when NDEBUG is not defined with assert as tsl_oh_assert is used a lot
 * (people usually compile with "-O3" and not "-O3 -DNDEBUG").
 */
#ifdef TSL_DEBUG
#    define tsl_oh_assert(expr) assert(expr)
#else
#    define tsl_oh_assert(expr) (static_cast<void>(0))
#endif

/**
 * If exceptions are enabled, throw the exception passed in parameter, otherwise call std::terminate.
 */
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || (defined (_MSC_VER) && defined (_CPPUNWIND))) && !defined(TSL_NO_EXCEPTIONS)
#    define TSL_OH_THROW_OR_TERMINATE(ex, msg) throw ex(msg)
#else
#    ifdef NDEBUG
#        define TSL_OH_THROW_OR_TERMINATE(ex, msg) std::terminate()
#    else
#        include <cstdio>
#        define TSL_OH_THROW_OR_TERMINATE(ex, msg) do { std::fprintf(stderr, msg); std::terminate(); } while(0)
#    endif
#endif

#undef min
#undef max

namespace tsl {

namespace detail_ordered_hash {
    
template<typename T>
struct make_void {
    using type = void;
};

template<typename T, typename = void>
struct has_is_transparent: std::false_type {
};

template<typename T>
struct has_is_transparent<T, typename make_void<typename T::is_transparent>::type>: std::true_type {
};


template<typename T, typename = void>
struct is_vector: std::false_type {
};

template<typename T>
struct is_vector<T, typename std::enable_if<
                        std::is_same<T, std::vector<typename T::value_type, typename T::allocator_type>>::value
                    >::type>: std::true_type {
};


/**
 * Each bucket entry stores an index which is the index in m_values corresponding to the bucket's value 
 * and a hash (which may be truncated to 32 bits depending on IndexType) corresponding to the hash of the value.
 * 
 * The size of IndexType limits the size of the hash table to std::numeric_limits<IndexType>::max() - 1 elements (-1 due to 
 * a reserved value used to mark a bucket as empty).
 */
template<class IndexType>
class bucket_entry {
    static_assert(std::is_unsigned<IndexType>::value, "IndexType must be an unsigned value.");
    static_assert(std::numeric_limits<IndexType>::max() <= std::numeric_limits<std::size_t>::max(), 
                  "std::numeric_limits<IndexType>::max() must be <= std::numeric_limits<std::size_t>::max().");
    
public:
    using index_type = IndexType;
    using truncated_hash_type = typename std::conditional<std::numeric_limits<IndexType>::max() <= 
                                                          std::numeric_limits<std::uint_least32_t>::max(),
                                                              std::uint_least32_t, 
                                                              std::size_t>::type;
    
    bucket_entry() noexcept: m_index(EMPTY_MARKER_INDEX), m_hash(0) {
    }
    
    bool empty() const noexcept {
        return m_index == EMPTY_MARKER_INDEX;
    }
    
    void clear() noexcept {
        m_index = EMPTY_MARKER_INDEX;
    }
    
    index_type index() const noexcept {
        tsl_oh_assert(!empty());
        return m_index;
    }
    
    index_type& index_ref() noexcept {
        tsl_oh_assert(!empty());
        return m_index;
    }
    
    void set_index(index_type index) noexcept {
        tsl_oh_assert(index <= max_size());
        
        m_index = index;
    }
    
    truncated_hash_type truncated_hash() const noexcept {
        tsl_oh_assert(!empty());
        return m_hash;
    }
    
    truncated_hash_type& truncated_hash_ref() noexcept {
        tsl_oh_assert(!empty());
        return m_hash;
    }
    
    void set_hash(std::size_t hash) noexcept {
        m_hash = truncate_hash(hash);
    }
    
    
    
    static truncated_hash_type truncate_hash(std::size_t hash) noexcept {
        return truncated_hash_type(hash);
    }
    
    static std::size_t max_size() noexcept {
        return static_cast<std::size_t>(std::numeric_limits<index_type>::max()) - NB_RESERVED_INDEXES;
    }
    
private:
    static const index_type EMPTY_MARKER_INDEX = std::numeric_limits<index_type>::max();
    static const std::size_t NB_RESERVED_INDEXES = 1;
    
    index_type m_index;
    truncated_hash_type m_hash;
};



/**
 * Internal common class used by ordered_map and ordered_set.
 * 
 * ValueType is what will be stored by ordered_hash (usually std::pair<Key, T> for map and Key for set).
 * 
 * KeySelect should be a FunctionObject which takes a ValueType in parameter and return a reference to the key.
 * 
 * ValueSelect should be a FunctionObject which takes a ValueType in parameter and return a reference to the value. 
 * ValueSelect should be void if there is no value (in set for example).
 * 
 * ValueTypeContainer is the container which will be used to store ValueType values. 
 * Usually a std::deque<ValueType, Allocator> or std::vector<ValueType, Allocator>.
 * 
 * 
 * 
 * The orderd_hash structure is a hash table which preserves the order of insertion of the elements.
 * To do so, it stores the values in the ValueTypeContainer (m_values) using emplace_back at each
 * insertion of a new element. Another structure (m_buckets of type std::vector<bucket_entry>) will 
 * serve as buckets array for the hash table part. Each bucket stores an index which corresponds to 
 * the index in m_values where the bucket's value is and the (truncated) hash of this value. An index
 * is used instead of a pointer to the value to reduce the size of each bucket entry.
 * 
 * To resolve collisions in the buckets array, the structures use robin hood linear probing with 
 * backward shift deletion.
 */
template<class ValueType,
         class KeySelect,
         class ValueSelect,
         class Hash,
         class KeyEqual,
         class Allocator,
         class ValueTypeContainer,
         class IndexType>
class ordered_hash: private Hash, private KeyEqual {
private:
    template<typename U>
    using has_mapped_type = typename std::integral_constant<bool, !std::is_same<U, void>::value>;
    
    static_assert(std::is_same<typename ValueTypeContainer::value_type, ValueType>::value, 
                  "ValueTypeContainer::value_type != ValueType. "
                  "Check that the ValueTypeContainer has 'Key' as type for a set or 'std::pair<Key, T>' as type for a map.");
    
    static_assert(std::is_same<typename ValueTypeContainer::allocator_type, Allocator>::value, 
                  "ValueTypeContainer::allocator_type != Allocator. "
                  "Check that the allocator for ValueTypeContainer is the same as Allocator.");
    
    static_assert(std::is_same<typename Allocator::value_type, ValueType>::value, 
                  "Allocator::value_type != ValueType. "
                  "Check that the allocator has 'Key' as type for a set or 'std::pair<Key, T>' as type for a map.");
    
    
public:
    template<bool IsConst>
    class ordered_iterator;
    
    using key_type = typename KeySelect::key_type;
    using value_type = ValueType;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using hasher = Hash;
    using key_equal = KeyEqual;
    using allocator_type = Allocator;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = value_type*;
    using const_pointer = const value_type*;
    using iterator = ordered_iterator<false>;
    using const_iterator = ordered_iterator<true>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    
    using values_container_type = ValueTypeContainer;
    
public:
    template<bool IsConst>
    class ordered_iterator {
        friend class ordered_hash;
        
    private:
        using iterator = typename std::conditional<IsConst, 
                                                    typename values_container_type::const_iterator, 
                                                    typename values_container_type::iterator>::type;
    
        
        ordered_iterator(iterator it) noexcept: m_iterator(it) {
        }
        
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = const typename ordered_hash::value_type;
        using difference_type = typename iterator::difference_type;
        using reference = value_type&;
        using pointer = value_type*;
        
        
        ordered_iterator() noexcept {
        }
        
        ordered_iterator(const ordered_iterator<false>& other) noexcept: m_iterator(other.m_iterator) {
        }

        const typename ordered_hash::key_type& key() const {
            return KeySelect()(*m_iterator);
        }

        template<class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value && IsConst>::type* = nullptr>
        const typename U::value_type& value() const {
            return U()(*m_iterator);
        }

        template<class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value && !IsConst>::type* = nullptr>
        typename U::value_type& value() {
            return U()(*m_iterator);
        }
        
        reference operator*() const { return *m_iterator; }
        pointer operator->() const { return m_iterator.operator->(); }
        
        ordered_iterator& operator++() { ++m_iterator; return *this; }
        ordered_iterator& operator--() { --m_iterator; return *this; }
        
        ordered_iterator operator++(int) { ordered_iterator tmp(*this); ++(*this); return tmp; }
        ordered_iterator operator--(int) { ordered_iterator tmp(*this); --(*this); return tmp; }
        
        reference operator[](difference_type n) const { return m_iterator[n]; }
        
        ordered_iterator& operator+=(difference_type n) { m_iterator += n; return *this; }
        ordered_iterator& operator-=(difference_type n) { m_iterator -= n; return *this; }
        
        ordered_iterator operator+(difference_type n) { ordered_iterator tmp(*this); tmp += n; return tmp; }
        ordered_iterator operator-(difference_type n) { ordered_iterator tmp(*this); tmp -= n; return tmp; }
        
        friend bool operator==(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator == rhs.m_iterator; 
        }
        
        friend bool operator!=(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator != rhs.m_iterator; 
        }
        
        friend bool operator<(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator < rhs.m_iterator; 
        }
        
        friend bool operator>(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator > rhs.m_iterator; 
        }
        
        friend bool operator<=(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator <= rhs.m_iterator; 
        }
        
        friend bool operator>=(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator >= rhs.m_iterator; 
        }

        friend ordered_iterator operator+(difference_type n, const ordered_iterator& it) { 
            return n + it.m_iterator;
        }

        friend difference_type operator-(const ordered_iterator& lhs, const ordered_iterator& rhs) { 
            return lhs.m_iterator - rhs.m_iterator; 
        }

    private:
        iterator m_iterator;
    };
    
    
private:
    using bucket_entry = tsl::detail_ordered_hash::bucket_entry<IndexType>;
                                         
    using buckets_container_allocator = typename 
                            std::allocator_traits<allocator_type>::template rebind_alloc<bucket_entry>; 
                            
    using buckets_container_type = std::vector<bucket_entry, buckets_container_allocator>;
    
    
    using truncated_hash_type = typename bucket_entry::truncated_hash_type;
    using index_type = typename bucket_entry::index_type;
    
public:
    ordered_hash(size_type bucket_count, 
                 const Hash& hash,
                 const KeyEqual& equal,
                 const Allocator& alloc,
                 float max_load_factor): Hash(hash),
                                         KeyEqual(equal), 
                                         m_buckets(alloc), 
                                         m_first_or_empty_bucket(static_empty_bucket_ptr()), 
                                         m_mask(0),
                                         m_values(alloc), 
                                         m_grow_on_next_insert(false)
    {
        if(bucket_count > max_bucket_count()) {
            TSL_OH_THROW_OR_TERMINATE(std::length_error, "The map exceeds its maxmimum size.");
        }
        
        if(bucket_count > 0) {
            bucket_count = round_up_to_power_of_two(bucket_count);
            
            m_buckets.resize(bucket_count);
            m_first_or_empty_bucket = m_buckets.data(),
            m_mask = bucket_count - 1; 
        }
        
        this->max_load_factor(max_load_factor);
    }
    
    ordered_hash(const ordered_hash& other): Hash(other),
                                             KeyEqual(other),
                                             m_buckets(other.m_buckets),
                                             m_first_or_empty_bucket(m_buckets.empty()?static_empty_bucket_ptr():m_buckets.data()),
                                             m_mask(other.m_mask),
                                             m_values(other.m_values),
                                             m_grow_on_next_insert(other.m_grow_on_next_insert),
                                             m_max_load_factor(other.m_max_load_factor),
                                             m_load_threshold(other.m_load_threshold)
    {
    }
    
    ordered_hash(ordered_hash&& other) noexcept(std::is_nothrow_move_constructible<Hash>::value &&
                                                std::is_nothrow_move_constructible<KeyEqual>::value &&
                                                std::is_nothrow_move_constructible<buckets_container_type>::value &&
                                                std::is_nothrow_move_constructible<values_container_type>::value)
                                          : Hash(std::move(static_cast<Hash&>(other))),
                                            KeyEqual(std::move(static_cast<KeyEqual&>(other))),
                                            m_buckets(std::move(other.m_buckets)),
                                            m_first_or_empty_bucket(m_buckets.empty()?static_empty_bucket_ptr():m_buckets.data()),
                                            m_mask(other.m_mask),
                                            m_values(std::move(other.m_values)),
                                            m_grow_on_next_insert(other.m_grow_on_next_insert),
                                            m_max_load_factor(other.m_max_load_factor),
                                            m_load_threshold(other.m_load_threshold)
    {
        other.m_buckets.clear();
        other.m_first_or_empty_bucket = static_empty_bucket_ptr();
        other.m_mask = 0;
        other.m_values.clear();
        other.m_grow_on_next_insert = false;
        other.m_load_threshold = 0;
    }
    
    ordered_hash& operator=(const ordered_hash& other) {
        if(&other != this) {
            Hash::operator=(other);
            KeyEqual::operator=(other);
            
            m_buckets = other.m_buckets;
            m_first_or_empty_bucket = m_buckets.empty()?static_empty_bucket_ptr():
                                                        m_buckets.data();
                                                        
            m_mask = other.m_mask;
            m_values = other.m_values;
            m_grow_on_next_insert = other.m_grow_on_next_insert;
            m_max_load_factor = other.m_max_load_factor;
            m_load_threshold = other.m_load_threshold;
        }
        
        return *this;
    }
    
    ordered_hash& operator=(ordered_hash&& other) {
        other.swap(*this);
        other.clear();
        
        return *this;
    }
    
    allocator_type get_allocator() const {
        return m_values.get_allocator();
    }
    
    
    /*
     * Iterators
     */
    iterator begin() noexcept {
        return iterator(m_values.begin());
    }
    
    const_iterator begin() const noexcept {
        return cbegin();
    }
    
    const_iterator cbegin() const noexcept {
        return const_iterator(m_values.cbegin());
    }
    
    iterator end() noexcept {
        return iterator(m_values.end());
    }
    
    const_iterator end() const noexcept {
        return cend();
    }
    
    const_iterator cend() const noexcept {
        return const_iterator(m_values.cend());
    }  
    
    
    reverse_iterator rbegin() noexcept {
        return reverse_iterator(m_values.end());
    }
    
    const_reverse_iterator rbegin() const noexcept {
        return rcbegin();
    }
    
    const_reverse_iterator rcbegin() const noexcept {
        return const_reverse_iterator(m_values.cend());
    }
    
    reverse_iterator rend() noexcept {
        return reverse_iterator(m_values.begin());
    }
    
    const_reverse_iterator rend() const noexcept {
        return rcend();
    }
    
    const_reverse_iterator rcend() const noexcept {
        return const_reverse_iterator(m_values.cbegin());
    }  
    
    
    /*
     * Capacity
     */
    bool empty() const noexcept {
        return m_values.empty();
    }
    
    size_type size() const noexcept {
        return m_values.size();
    }
    
    size_type max_size() const noexcept {
        return std::min(bucket_entry::max_size(), m_values.max_size());
    }
    

    /*
     * Modifiers
     */
    void clear() noexcept {
        for(auto& bucket: m_buckets) {
            bucket.clear();
        }
        
        m_values.clear();
        m_grow_on_next_insert = false;
    }
    
    template<typename P>
    std::pair<iterator, bool> insert(P&& value) {
        return insert_impl(KeySelect()(value), std::forward<P>(value));
    }
    
    template<typename P>
    iterator insert(const_iterator hint, P&& value) { 
        if(hint != cend() && compare_keys(KeySelect()(*hint), KeySelect()(value))) { 
            return mutable_iterator(hint); 
        }
        
        return insert(std::forward<P>(value)).first; 
    }
    
    template<class InputIt>
    void insert(InputIt first, InputIt last) {
        if(std::is_base_of<std::forward_iterator_tag, 
                           typename std::iterator_traits<InputIt>::iterator_category>::value) 
        {
            const auto nb_elements_insert = std::distance(first, last);
            const size_type nb_free_buckets = m_load_threshold - size();
            tsl_oh_assert(m_load_threshold >= size());
            
            if(nb_elements_insert > 0 && nb_free_buckets < size_type(nb_elements_insert)) {
                reserve(size() + size_type(nb_elements_insert));
            }
        }
        
        for(; first != last; ++first) {
            insert(*first);
        }
    }
    
    
    
    template<class K, class M>
    std::pair<iterator, bool> insert_or_assign(K&& key, M&& value) {
        auto it = try_emplace(std::forward<K>(key), std::forward<M>(value));
        if(!it.second) {
            it.first.value() = std::forward<M>(value);
        }
        
        return it;
    }
    
    template<class K, class M>
    iterator insert_or_assign(const_iterator hint, K&& key, M&& obj) {
        if(hint != cend() && compare_keys(KeySelect()(*hint), key)) { 
            auto it = mutable_iterator(hint); 
            it.value() = std::forward<M>(obj);
            
            return it;
        }
        
        return insert_or_assign(std::forward<K>(key), std::forward<M>(obj)).first;
    }
    
    
    
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&&... args) {
        return insert(value_type(std::forward<Args>(args)...));
    }
    
    template<class... Args>
    iterator emplace_hint(const_iterator hint, Args&&... args) { 
        return insert(hint, value_type(std::forward<Args>(args)...));
    }
    
    
    
    template<class K, class... Args>
    std::pair<iterator, bool> try_emplace(K&& key, Args&&... value_args) {
        return insert_impl(key, std::piecewise_construct, 
                                std::forward_as_tuple(std::forward<K>(key)), 
                                std::forward_as_tuple(std::forward<Args>(value_args)...));     
    }
    
    template<class K, class... Args>
    iterator try_emplace(const_iterator hint, K&& key, Args&&... args) {
        if(hint != cend() && compare_keys(KeySelect()(*hint), key)) { 
            return mutable_iterator(hint); 
        }
        
        return try_emplace(std::forward<K>(key), std::forward<Args>(args)...).first;
    }
    
    
    
    /**
     * Here to avoid `template<class K> size_type erase(const K& key)` being used when
     * we use an `iterator` instead of a `const_iterator`.
     */
    iterator erase(iterator pos) {
        return erase(const_iterator(pos));
    }
    
    iterator erase(const_iterator pos) {
        tsl_oh_assert(pos != cend());
        
        const std::size_t index_erase = iterator_to_index(pos);
        
        auto it_bucket = find_key(pos.key(), hash_key(pos.key()));
        tsl_oh_assert(it_bucket != m_buckets.end());
        
        erase_value_from_bucket(it_bucket);
        
        /*
         * One element was removed from m_values, due to the left shift the next element 
         * is now at the position of the previous element (or end if none).
         */
        return begin() + index_erase;
    }

    iterator erase(const_iterator first, const_iterator last) {
        if(first == last) {
            return mutable_iterator(first);
        }
        
        tsl_oh_assert(std::distance(first, last) > 0);
        const std::size_t start_index = iterator_to_index(first);
        const std::size_t nb_values = std::size_t(std::distance(first, last));
        const std::size_t end_index = start_index + nb_values;
        
        // Delete all values
#ifdef TSL_OH_NO_CONTAINER_ERASE_CONST_ITERATOR     
        auto next_it = m_values.erase(mutable_iterator(first).m_iterator, mutable_iterator(last).m_iterator);   
#else
        auto next_it = m_values.erase(first.m_iterator, last.m_iterator);
#endif
        
        /*
         * Mark the buckets corresponding to the values as empty and do a backward shift.
         * 
         * Also, the erase operation on m_values has shifted all the values on the right of last.m_iterator.
         * Adapt the indexes for these values.
         */
        std::size_t ibucket = 0;
        while(ibucket < m_buckets.size()) {
            if(m_buckets[ibucket].empty()) {
                ibucket++;
            }
            else if(m_buckets[ibucket].index() >= start_index && m_buckets[ibucket].index() < end_index) {
                m_buckets[ibucket].clear();
                backward_shift(ibucket);
                // Don't increment ibucket, backward_shift may have replaced current bucket.
            }
            else if(m_buckets[ibucket].index() >= end_index) {
                m_buckets[ibucket].set_index(index_type(m_buckets[ibucket].index() - nb_values));
                ibucket++;
            }
            else {
                ibucket++;
            }
        }
        
        return iterator(next_it);
    }
    

    template<class K>
    size_type erase(const K& key) {
        return erase(key, hash_key(key));
    }
    
    template<class K>
    size_type erase(const K& key, std::size_t hash) {
        return erase_impl(key, hash);
    }
    
    void swap(ordered_hash& other) {
        using std::swap;
        
        swap(static_cast<Hash&>(*this), static_cast<Hash&>(other));
        swap(static_cast<KeyEqual&>(*this), static_cast<KeyEqual&>(other));
        swap(m_buckets, other.m_buckets);
        swap(m_first_or_empty_bucket, other.m_first_or_empty_bucket);
        swap(m_mask, other.m_mask);
        swap(m_values, other.m_values);
        swap(m_grow_on_next_insert, other.m_grow_on_next_insert);
        swap(m_max_load_factor, other.m_max_load_factor);
        swap(m_load_threshold, other.m_load_threshold);
    }
    
        
    

    /*
     * Lookup
     */    
    template<class K, class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
    typename U::value_type& at(const K& key) {
        return at(key, hash_key(key));
    }
    
    template<class K, class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
    typename U::value_type& at(const K& key, std::size_t hash) {
        return const_cast<typename U::value_type&>(static_cast<const ordered_hash*>(this)->at(key, hash));
    }
    
    template<class K, class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
    const typename U::value_type& at(const K& key) const {
        return at(key, hash_key(key));
    }
    
    template<class K, class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
    const typename U::value_type& at(const K& key, std::size_t hash) const {
        auto it = find(key, hash);
        if(it != end()) {
            return it.value();
        }
        else {
            TSL_OH_THROW_OR_TERMINATE(std::out_of_range, "Couldn't find the key.");
        }
    }
    
    
    template<class K, class U = ValueSelect, typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
    typename U::value_type& operator[](K&& key) {
        return try_emplace(std::forward<K>(key)).first.value();
    }
    
    
    template<class K>
    size_type count(const K& key) const {
        return count(key, hash_key(key));
    }
    
    template<class K>
    size_type count(const K& key, std::size_t hash) const {
        if(find(key, hash) == cend()) {
            return 0;
        }
        else {
            return 1;
        }
    }
    
    template<class K>
    iterator find(const K& key) {
        return find(key, hash_key(key));
    }
    
    template<class K>
    iterator find(const K& key, std::size_t hash) {
        auto it_bucket = find_key(key, hash);
        return (it_bucket != m_buckets.end())?iterator(m_values.begin() + it_bucket->index()):end();
    }
    
    template<class K>
    const_iterator find(const K& key) const {
        return find(key, hash_key(key));
    }
    
    template<class K>
    const_iterator find(const K& key, std::size_t hash) const {
        auto it_bucket = find_key(key, hash);
        return (it_bucket != m_buckets.cend())?const_iterator(m_values.begin() + it_bucket->index()):end();
    }
    
    
    template<class K>
    std::pair<iterator, iterator> equal_range(const K& key) {
        return equal_range(key, hash_key(key));
    }
    
    template<class K>
    std::pair<iterator, iterator> equal_range(const K& key, std::size_t hash) {
        iterator it = find(key, hash);
        return std::make_pair(it, (it == end())?it:std::next(it));
    }
    
    template<class K>
    std::pair<const_iterator, const_iterator> equal_range(const K& key) const {
        return equal_range(key, hash_key(key));
    }
    
    template<class K>
    std::pair<const_iterator, const_iterator> equal_range(const K& key, std::size_t hash) const {
        const_iterator it = find(key, hash);
        return std::make_pair(it, (it == cend())?it:std::next(it));
    }    
    
    
    /*
     * Bucket interface 
     */
    size_type bucket_count() const {
        return m_buckets.size(); 
    }
    
    size_type max_bucket_count() const {
        return m_buckets.max_size();
    }    
    
    /*
     *  Hash policy 
     */
    float load_factor() const {
        if(bucket_count() == 0) {
            return 0;
        }
        
        return float(size())/float(bucket_count());
    }
    
    float max_load_factor() const {
        return m_max_load_factor;
    }
    
    void max_load_factor(float ml) {
        m_max_load_factor = std::max(0.1f, std::min(ml, 0.95f));
        m_load_threshold = size_type(float(bucket_count())*m_max_load_factor);
    }
    
    void rehash(size_type count) {
        count = std::max(count, size_type(std::ceil(float(size())/max_load_factor())));
        rehash_impl(count);
    }
    
    void reserve(size_type count) {
        reserve_space_for_values(count);
        
        count = size_type(std::ceil(float(count)/max_load_factor()));
        rehash(count);
    }
    
    
    /*
     * Observers
     */
    hasher hash_function() const {
        return static_cast<const Hash&>(*this);
    }
    
    key_equal key_eq() const {
        return static_cast<const KeyEqual&>(*this);
    }

    
    /*
     * Other
     */
    iterator mutable_iterator(const_iterator pos) {
        return iterator(m_values.begin() + iterator_to_index(pos));
    }
    
    iterator nth(size_type index) {
        tsl_oh_assert(index <= size());
        return iterator(m_values.begin() + index);
    }
    
    const_iterator nth(size_type index) const {
        tsl_oh_assert(index <= size());
        return const_iterator(m_values.cbegin() + index);
    }
    
    const_reference front() const {
        tsl_oh_assert(!empty());
        return m_values.front();
    }
    
    const_reference back() const {
        tsl_oh_assert(!empty());
        return m_values.back();
    }
    
    const values_container_type& values_container() const noexcept {
        return m_values;
    }
    
    template<class U = values_container_type, typename std::enable_if<is_vector<U>::value>::type* = nullptr>    
    const typename values_container_type::value_type* data() const noexcept {
        return m_values.data();
    }
    
    template<class U = values_container_type, typename std::enable_if<is_vector<U>::value>::type* = nullptr>    
    size_type capacity() const noexcept {
        return m_values.capacity();
    }
    
    void shrink_to_fit() {
        m_values.shrink_to_fit();
    }
    
    
    template<typename P>
    std::pair<iterator, bool> insert_at_position(const_iterator pos, P&& value) {
        return insert_at_position_impl(pos.m_iterator, KeySelect()(value), std::forward<P>(value));
    }
    
    template<class... Args>
    std::pair<iterator, bool> emplace_at_position(const_iterator pos, Args&&... args) {
        return insert_at_position(pos, value_type(std::forward<Args>(args)...));
    }
    
    template<class K, class... Args>
    std::pair<iterator, bool> try_emplace_at_position(const_iterator pos, K&& key, Args&&... value_args) {
        return insert_at_position_impl(pos.m_iterator, key, 
                                       std::piecewise_construct, 
                                       std::forward_as_tuple(std::forward<K>(key)), 
                                       std::forward_as_tuple(std::forward<Args>(value_args)...));
    }
    

    void pop_back() {
        tsl_oh_assert(!empty());
        erase(std::prev(end()));
    }
    
    
    /**
     * Here to avoid `template<class K> size_type unordered_erase(const K& key)` being used when
     * we use a iterator instead of a const_iterator.
     */    
    iterator unordered_erase(iterator pos) {
        return unordered_erase(const_iterator(pos));
    }
    
    iterator unordered_erase(const_iterator pos) {
        const std::size_t index_erase = iterator_to_index(pos);
        unordered_erase(pos.key());
        
        /*
         * One element was deleted, index_erase now points to the next element as the elements after
         * the deleted value were shifted to the left in m_values (will be end() if we deleted the last element).
         */
        return begin() + index_erase;
    }
    
    template<class K>
    size_type unordered_erase(const K& key) {
        return unordered_erase(key, hash_key(key));
    }
    
    template<class K>
    size_type unordered_erase(const K& key, std::size_t hash) {
        auto it_bucket_key = find_key(key, hash);
        if(it_bucket_key == m_buckets.end()) {
            return 0;
        }
        
        /**
         * If we are not erasing the last element in m_values, we swap 
         * the element we are erasing with the last element. We then would 
         * just have to do a pop_back() in m_values.
         */
        if(!compare_keys(key, KeySelect()(back()))) {
            auto it_bucket_last_elem = find_key(KeySelect()(back()), hash_key(KeySelect()(back())));
            tsl_oh_assert(it_bucket_last_elem != m_buckets.end());
            tsl_oh_assert(it_bucket_last_elem->index() == m_values.size() - 1);
            
            using std::swap;
            swap(m_values[it_bucket_key->index()], m_values[it_bucket_last_elem->index()]);
            swap(it_bucket_key->index_ref(), it_bucket_last_elem->index_ref());
        }
        
        erase_value_from_bucket(it_bucket_key);
        
        return 1;
    }
    
    friend bool operator==(const ordered_hash& lhs, const ordered_hash& rhs) {
        return lhs.m_values == rhs.m_values;
    }
    
    friend bool operator!=(const ordered_hash& lhs, const ordered_hash& rhs) {
        return lhs.m_values != rhs.m_values;
    }
    
    friend bool operator<(const ordered_hash& lhs, const ordered_hash& rhs) {
        return lhs.m_values < rhs.m_values;
    }
    
    friend bool operator<=(const ordered_hash& lhs, const ordered_hash& rhs) {
        return lhs.m_values <= rhs.m_values;
    }
    
    friend bool operator>(const ordered_hash& lhs, const ordered_hash& rhs) {
        return lhs.m_values > rhs.m_values;
    }
    
    friend bool operator>=(const ordered_hash& lhs, const ordered_hash& rhs) {
        return lhs.m_values >= rhs.m_values;
    }
    
    
private:
    template<class K>
    std::size_t hash_key(const K& key) const {
        return Hash::operator()(key);
    }
    
    template<class K1, class K2>
    bool compare_keys(const K1& key1, const K2& key2) const {
        return KeyEqual::operator()(key1, key2);
    }
    
    template<class K>
    typename buckets_container_type::iterator find_key(const K& key, std::size_t hash) {
        auto it = static_cast<const ordered_hash*>(this)->find_key(key, hash);
        return m_buckets.begin() + std::distance(m_buckets.cbegin(), it);
    }
    
    /**
     * Return bucket which has the key 'key' or m_buckets.end() if none.
     * 
     * From the bucket_for_hash, search for the value until we either find an empty bucket
     * or a bucket which has a value with a distance from its ideal bucket longer
     * than the probe length for the value we are looking for.
     */
    template<class K>
    typename buckets_container_type::const_iterator find_key(const K& key, std::size_t hash) const {
        for(std::size_t ibucket = bucket_for_hash(hash), dist_from_ideal_bucket = 0; ; 
            ibucket = next_bucket(ibucket), dist_from_ideal_bucket++) 
        {
            if((m_first_or_empty_bucket + ibucket)->empty()) {
                return m_buckets.end();
            }
            else if((m_first_or_empty_bucket + ibucket)->truncated_hash() == bucket_entry::truncate_hash(hash) && 
                    compare_keys(key, KeySelect()(m_values[(m_first_or_empty_bucket + ibucket)->index()]))) 
            {
                return m_buckets.begin() + ibucket;
            }
            else if(dist_from_ideal_bucket > distance_from_ideal_bucket(ibucket)) {
                return m_buckets.end();
            }
        }
    }
    
    void rehash_impl(size_type bucket_count) {
        tsl_oh_assert(bucket_count >= size_type(std::ceil(float(size())/max_load_factor())));
        
        if(bucket_count > max_bucket_count()) {
            TSL_OH_THROW_OR_TERMINATE(std::length_error, "The map exceeds its maxmimum size.");
        }
        
        if(bucket_count > 0) {
            bucket_count = round_up_to_power_of_two(bucket_count);
        }
        
        if(bucket_count == this->bucket_count()) {
            return;
        }
        
        
        buckets_container_type old_buckets(bucket_count);
        m_buckets.swap(old_buckets);
        m_first_or_empty_bucket = m_buckets.data();
        // Everything should be noexcept from here.
        
        m_mask = (bucket_count > 0)?(bucket_count - 1):0;
        this->max_load_factor(m_max_load_factor);
        m_grow_on_next_insert = false;
        
        
        
        for(const bucket_entry& old_bucket: old_buckets) {
            if(old_bucket.empty()) {
                continue;
            }
            
            truncated_hash_type insert_hash = old_bucket.truncated_hash();
            index_type insert_index = old_bucket.index();
            
            for(std::size_t ibucket = bucket_for_hash(insert_hash), dist_from_ideal_bucket = 0; ; 
                ibucket = next_bucket(ibucket), dist_from_ideal_bucket++) 
            {
                if(m_buckets[ibucket].empty()) {
                    m_buckets[ibucket].set_index(insert_index);
                    m_buckets[ibucket].set_hash(insert_hash);
                    break;
                }
                
                const std::size_t distance = distance_from_ideal_bucket(ibucket);
                if(dist_from_ideal_bucket > distance) {
                    std::swap(insert_index, m_buckets[ibucket].index_ref());
                    std::swap(insert_hash, m_buckets[ibucket].truncated_hash_ref());
                    dist_from_ideal_bucket = distance;
                }
            }
        }
    }
    
    template<class T = values_container_type, typename std::enable_if<is_vector<T>::value>::type* = nullptr>
    void reserve_space_for_values(size_type count) {
        m_values.reserve(count);
    }
    
    template<class T = values_container_type, typename std::enable_if<!is_vector<T>::value>::type* = nullptr>
    void reserve_space_for_values(size_type /*count*/) {
    }
    
    /**
     * Swap the empty bucket with the values on its right until we cross another empty bucket
     * or if the other bucket has a distance_from_ideal_bucket == 0.
     */
    void backward_shift(std::size_t empty_ibucket) noexcept {
        tsl_oh_assert(m_buckets[empty_ibucket].empty());
        
        std::size_t previous_ibucket = empty_ibucket;
        for(std::size_t current_ibucket = next_bucket(previous_ibucket); 
            !m_buckets[current_ibucket].empty() && distance_from_ideal_bucket(current_ibucket) > 0;
            previous_ibucket = current_ibucket, current_ibucket = next_bucket(current_ibucket)) 
        {
            std::swap(m_buckets[current_ibucket], m_buckets[previous_ibucket]);
        }
    }
    
    void erase_value_from_bucket(typename buckets_container_type::iterator it_bucket) {
        tsl_oh_assert(it_bucket != m_buckets.end() && !it_bucket->empty());
        
        m_values.erase(m_values.begin() + it_bucket->index());
        
        /*
         * m_values.erase shifted all the values on the right of the erased value, 
         * shift the indexes by -1 in the buckets array for these values.
         */
        if(it_bucket->index() != m_values.size()) {
            shift_indexes_in_buckets(it_bucket->index(), char(-1));
        }        
        
        // Mark the bucket as empty and do a backward shift of the values on the right
        it_bucket->clear();
        backward_shift(std::size_t(std::distance(m_buckets.begin(), it_bucket)));
    }
    
    /**
     * Go through each value from [from_ivalue, m_values.size()) in m_values and for each
     * bucket corresponding to the value, shift the index by delta.
     */
    void shift_indexes_in_buckets(index_type from_ivalue, char delta) noexcept  {
        tsl_oh_assert(delta == 1 || delta == -1);
        
        for(std::size_t ivalue = from_ivalue; ivalue < m_values.size(); ivalue++) {
            // All the values in m_values have been shifted by delta. Find the bucket corresponding 
            // to the value m_values[ivalue]
            const index_type old_index = static_cast<index_type>(ivalue - delta);
            
            std::size_t ibucket = bucket_for_hash(hash_key(KeySelect()(m_values[ivalue])));
            while(m_buckets[ibucket].index() != old_index) {
                ibucket = next_bucket(ibucket);
            }
            
            m_buckets[ibucket].set_index(index_type(ivalue));
        }
    }
    
    template<class K>
    size_type erase_impl(const K& key, std::size_t hash) {
        auto it_bucket = find_key(key, hash);
        if(it_bucket != m_buckets.end()) {
            erase_value_from_bucket(it_bucket);
            
            return 1;
        }
        else {
            return 0;
        }
    }
    
    /**
     * Insert the element at the end.
     */
    template<class K, class... Args>
    std::pair<iterator, bool> insert_impl(const K& key, Args&&... value_type_args) {
        const std::size_t hash = hash_key(key);
        
        std::size_t ibucket = bucket_for_hash(hash); 
        std::size_t dist_from_ideal_bucket = 0;
        
        while(!(m_first_or_empty_bucket + ibucket)->empty() && dist_from_ideal_bucket <= distance_from_ideal_bucket(ibucket)) {
            if((m_first_or_empty_bucket + ibucket)->truncated_hash() == bucket_entry::truncate_hash(hash) && 
               compare_keys(key, KeySelect()(m_values[(m_first_or_empty_bucket + ibucket)->index()]))) 
            {
                return std::make_pair(begin() + (m_first_or_empty_bucket + ibucket)->index(), false);
            }
            
            ibucket = next_bucket(ibucket);
            dist_from_ideal_bucket++;
        }
        
        if(size() >= max_size()) {
            TSL_OH_THROW_OR_TERMINATE(std::length_error, "We reached the maximum size for the hash table.");
        }
        
        
        if(grow_on_high_load()) {
            ibucket = bucket_for_hash(hash);
            dist_from_ideal_bucket = 0;
        }
        
                
        m_values.emplace_back(std::forward<Args>(value_type_args)...);
        insert_index(ibucket, dist_from_ideal_bucket, 
                     index_type(m_values.size() - 1), bucket_entry::truncate_hash(hash));
        
        
        return std::make_pair(std::prev(end()), true);
    }
    
    /**
     * Insert the element before insert_position.
     */
    template<class K, class... Args>
    std::pair<iterator, bool> insert_at_position_impl(typename values_container_type::const_iterator insert_position,
                                                      const K& key, Args&&... value_type_args) 
    {
        const std::size_t hash = hash_key(key);
        
        std::size_t ibucket = bucket_for_hash(hash); 
        std::size_t dist_from_ideal_bucket = 0;
        
        while(!(m_first_or_empty_bucket + ibucket)->empty() && dist_from_ideal_bucket <= distance_from_ideal_bucket(ibucket)) {
            if((m_first_or_empty_bucket + ibucket)->truncated_hash() == bucket_entry::truncate_hash(hash) && 
               compare_keys(key, KeySelect()(m_values[(m_first_or_empty_bucket + ibucket)->index()]))) 
            {
                return std::make_pair(begin() + (m_first_or_empty_bucket + ibucket)->index(), false);
            }
            
            ibucket = next_bucket(ibucket);
            dist_from_ideal_bucket++;
        }
        
        if(size() >= max_size()) {
            TSL_OH_THROW_OR_TERMINATE(std::length_error, "We reached the maximum size for the hash table.");
        }
        
        
        if(grow_on_high_load()) {
            ibucket = bucket_for_hash(hash);
            dist_from_ideal_bucket = 0;
        }
        
        
        const index_type index_insert_position = index_type(std::distance(m_values.cbegin(), insert_position));
        
#ifdef TSL_OH_NO_CONTAINER_EMPLACE_CONST_ITERATOR
        m_values.emplace(m_values.begin() + std::distance(m_values.cbegin(), insert_position), std::forward<Args>(value_type_args)...);
#else        
        m_values.emplace(insert_position, std::forward<Args>(value_type_args)...);
#endif        

        insert_index(ibucket, dist_from_ideal_bucket, 
                     index_insert_position, bucket_entry::truncate_hash(hash));
        
        /*
         * The insertion didn't happend at the end of the m_values container, 
         * we need to shift the indexes in m_buckets.
         */
        if(index_insert_position != m_values.size() - 1) {
            shift_indexes_in_buckets(index_insert_position + 1, char(1));
        }
        
        return std::make_pair(iterator(m_values.begin() + index_insert_position), true);
    }
    
    void insert_index(std::size_t ibucket, std::size_t dist_from_ideal_bucket, 
                      index_type index_insert, truncated_hash_type hash_insert) noexcept
    {
        while(!m_buckets[ibucket].empty()) {
            const std::size_t distance = distance_from_ideal_bucket(ibucket);
            if(dist_from_ideal_bucket > distance) {
                std::swap(index_insert, m_buckets[ibucket].index_ref());
                std::swap(hash_insert, m_buckets[ibucket].truncated_hash_ref());
                
                dist_from_ideal_bucket = distance;
            }

            
            ibucket = next_bucket(ibucket);
            dist_from_ideal_bucket++;
            
            
            if(dist_from_ideal_bucket > REHASH_ON_HIGH_NB_PROBES__NPROBES && !m_grow_on_next_insert &&
               load_factor() >= REHASH_ON_HIGH_NB_PROBES__MIN_LOAD_FACTOR)
            {
                // We don't want to grow the map now as we need this method to be noexcept.
                // Do it on next insert.
                m_grow_on_next_insert = true;
            }
        }
        
        
        m_buckets[ibucket].set_index(index_insert);
        m_buckets[ibucket].set_hash(hash_insert); 
    }
    
    std::size_t distance_from_ideal_bucket(std::size_t ibucket) const noexcept {
        const std::size_t ideal_bucket = bucket_for_hash(m_buckets[ibucket].truncated_hash());
        
        if(ibucket >= ideal_bucket) {
            return ibucket - ideal_bucket;
        }
        // If the bucket is smaller than the ideal bucket for the value, there was a wrapping at the end of the 
        // bucket array due to the modulo.
        else {
            return (bucket_count() + ibucket) - ideal_bucket;
        }
    }
    
    std::size_t next_bucket(std::size_t index) const noexcept {
        tsl_oh_assert(index < m_buckets.size());
        
        index++;
        return (index < m_buckets.size())?index:0;
    }
    
    std::size_t bucket_for_hash(std::size_t hash) const noexcept {
        return hash & m_mask;
    }    
    
    std::size_t iterator_to_index(const_iterator it) const noexcept {
        const auto dist = std::distance(cbegin(), it);
        tsl_oh_assert(dist >= 0);
        
        return std::size_t(dist);
    }
    
    /**
     * Return true if the map has been rehashed.
     */
    bool grow_on_high_load() {
        if(m_grow_on_next_insert || size() >= m_load_threshold) {
            rehash_impl(std::max(size_type(1), bucket_count() * 2));
            m_grow_on_next_insert = false;
            
            return true;
        }
        else {
            return false;
        }
    }
    
    static std::size_t round_up_to_power_of_two(std::size_t value) {
        if(is_power_of_two(value)) {
            return value;
        }
        
        if(value == 0) {
            return 1;
        }
        
        --value;
        for(std::size_t i = 1; i < sizeof(std::size_t) * CHAR_BIT; i *= 2) {
            value |= value >> i;
        }
        
        return value + 1;
    }
    
    static constexpr bool is_power_of_two(std::size_t value) {
        return value != 0 && (value & (value - 1)) == 0;
    }

    
public:
    static const size_type DEFAULT_INIT_BUCKETS_SIZE = 16;
    static constexpr float DEFAULT_MAX_LOAD_FACTOR = 0.75f;

private:    
    static const size_type REHASH_ON_HIGH_NB_PROBES__NPROBES = 128;
    static constexpr float REHASH_ON_HIGH_NB_PROBES__MIN_LOAD_FACTOR = 0.15f;
    
    
    /**
     * Return an always valid pointer to an static empty bucket_entry with last_bucket() == true.
     */            
    bucket_entry* static_empty_bucket_ptr() {
        static bucket_entry empty_bucket;
        return &empty_bucket;
    }
    
private:
    buckets_container_type m_buckets;
    
    /**
     * Points to m_buckets.data() if !m_buckets.empty() otherwise points to static_empty_bucket_ptr.
     * This variable is useful to avoid the cost of checking if m_buckets is empty when trying 
     * to find an element.
     */
    bucket_entry* m_first_or_empty_bucket;
    
    size_type m_mask;
    
    values_container_type m_values;
    
    bool m_grow_on_next_insert;
    float m_max_load_factor;
    size_type m_load_threshold;
};


} // end namespace detail_ordered_hash

} // end namespace tsl

#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/ordered-map/include/tsl/ordered_map.h`:

```h
/**
 * MIT License
 * 
 * Copyright (c) 2017 Tessil
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef TSL_ORDERED_MAP_H
#define TSL_ORDERED_MAP_H


#include <cstddef>
#include <cstdint>
#include <deque>
#include <functional>
#include <initializer_list>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>
#include "ordered_hash.h"


namespace tsl {


/**
 * Implementation of an hash map using open adressing with robin hood with backshift delete to resolve collisions.
 * 
 * The particularity of this hash map is that it remembers the order in which the elements were added and
 * provide a way to access the structure which stores these values through the 'values_container()' method. 
 * The used container is defined by ValueTypeContainer, by default a std::deque is used (grows faster) but
 * a std::vector may be used. In this case the map provides a 'data()' method which give a direct access 
 * to the memory used to store the values (which can be usefull to communicate with C API's).
 * 
 * The Key and T must be copy constructible and/or move constructible. To use `unordered_erase` they both
 * must be swappable.
 * 
 * The behaviour of the hash map is undefinded if the destructor of Key or T throws an exception.
 * 
 * By default the maximum size of a map is limited to 2^32 - 1 values, if needed this can be changed through
 * the IndexType template parameter. Using an `uint64_t` will raise this limit to 2^64 - 1 values but each
 * bucket will use 16 bytes instead of 8 bytes in addition to the space needed to store the values.
 * 
 * Iterators invalidation:
 *  - clear, operator=, reserve, rehash: always invalidate the iterators (also invalidate end()).
 *  - insert, emplace, emplace_hint, operator[]: when a std::vector is used as ValueTypeContainer 
 *                                               and if size() < capacity(), only end(). 
 *                                               Otherwise all the iterators are invalidated if an insert occurs.
 *  - erase, unordered_erase: when a std::vector is used as ValueTypeContainer invalidate the iterator of 
 *                            the erased element and all the ones after the erased element (including end()). 
 *                            Otherwise all the iterators are invalidated if an erase occurs.
 */
template<class Key, 
         class T, 
         class Hash = std::hash<Key>,
         class KeyEqual = std::equal_to<Key>,
         class Allocator = std::allocator<std::pair<Key, T>>,
         class ValueTypeContainer = std::deque<std::pair<Key, T>, Allocator>,
         class IndexType = std::uint_least32_t>
class ordered_map {
private:
    template<typename U>
    using has_is_transparent = tsl::detail_ordered_hash::has_is_transparent<U>;
    
    class KeySelect {
    public:
        using key_type = Key;
        
        const key_type& operator()(const std::pair<Key, T>& key_value) const noexcept {
            return key_value.first;
        }
        
        key_type& operator()(std::pair<Key, T>& key_value) noexcept {
            return key_value.first;
        }
    };  
    
    class ValueSelect {
    public:
        using value_type = T;
        
        const value_type& operator()(const std::pair<Key, T>& key_value) const noexcept {
            return key_value.second;
        }
        
        value_type& operator()(std::pair<Key, T>& key_value) noexcept {
            return key_value.second;
        }
    };
    
    using ht = detail_ordered_hash::ordered_hash<std::pair<Key, T>, KeySelect, ValueSelect,
                                                 Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType>;
    
public:
    using key_type = typename ht::key_type;
    using mapped_type = T;
    using value_type = typename ht::value_type;
    using size_type = typename ht::size_type;
    using difference_type = typename ht::difference_type;
    using hasher = typename ht::hasher;
    using key_equal = typename ht::key_equal;
    using allocator_type = typename ht::allocator_type;
    using reference = typename ht::reference;
    using const_reference = typename ht::const_reference;
    using pointer = typename ht::pointer;
    using const_pointer = typename ht::const_pointer;
    using iterator = typename ht::iterator;
    using const_iterator = typename ht::const_iterator;
    using reverse_iterator = typename ht::reverse_iterator;
    using const_reverse_iterator = typename ht::const_reverse_iterator;
    
    using values_container_type = typename ht::values_container_type;
    
    
    /*
     * Constructors
     */
    ordered_map(): ordered_map(ht::DEFAULT_INIT_BUCKETS_SIZE) {
    }
    
    explicit ordered_map(size_type bucket_count, 
                         const Hash& hash = Hash(),
                         const KeyEqual& equal = KeyEqual(),
                         const Allocator& alloc = Allocator()): 
                     m_ht(bucket_count, hash, equal, alloc, ht::DEFAULT_MAX_LOAD_FACTOR)
    {
    }
    
    ordered_map(size_type bucket_count,
                const Allocator& alloc): ordered_map(bucket_count, Hash(), KeyEqual(), alloc)
    {
    }
    
    ordered_map(size_type bucket_count,
                const Hash& hash,
                const Allocator& alloc): ordered_map(bucket_count, hash, KeyEqual(), alloc)
    {
    }
    
    explicit ordered_map(const Allocator& alloc): ordered_map(ht::DEFAULT_INIT_BUCKETS_SIZE, alloc) {
    }
    
    template<class InputIt>
    ordered_map(InputIt first, InputIt last,
                size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
                const Hash& hash = Hash(),
                const KeyEqual& equal = KeyEqual(),
                const Allocator& alloc = Allocator()): ordered_map(bucket_count, hash, equal, alloc)
    {
        insert(first, last);
    }
    
    template<class InputIt>
    ordered_map(InputIt first, InputIt last,
                size_type bucket_count,
                const Allocator& alloc): ordered_map(first, last, bucket_count, Hash(), KeyEqual(), alloc)
    {
    }
    
    template<class InputIt>
    ordered_map(InputIt first, InputIt last,
                size_type bucket_count,
                const Hash& hash,
                const Allocator& alloc): ordered_map(first, last, bucket_count, hash, KeyEqual(), alloc)
    {
    }

    ordered_map(std::initializer_list<value_type> init,
                size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
                const Hash& hash = Hash(),
                const KeyEqual& equal = KeyEqual(),
                const Allocator& alloc = Allocator()): 
            ordered_map(init.begin(), init.end(), bucket_count, hash, equal, alloc)
    {
    }

    ordered_map(std::initializer_list<value_type> init,
                size_type bucket_count,
                const Allocator& alloc): 
            ordered_map(init.begin(), init.end(), bucket_count, Hash(), KeyEqual(), alloc)
    {
    }

    ordered_map(std::initializer_list<value_type> init,
                size_type bucket_count,
                const Hash& hash,
                const Allocator& alloc): 
            ordered_map(init.begin(), init.end(), bucket_count, hash, KeyEqual(), alloc)
    {
    }

    
    ordered_map& operator=(std::initializer_list<value_type> ilist) {
        m_ht.clear();
        
        m_ht.reserve(ilist.size());
        m_ht.insert(ilist.begin(), ilist.end());
        
        return *this;
    }
    
    allocator_type get_allocator() const { return m_ht.get_allocator(); }
    

    
    /*
     * Iterators
     */
    iterator begin() noexcept { return m_ht.begin(); }
    const_iterator begin() const noexcept { return m_ht.begin(); }
    const_iterator cbegin() const noexcept { return m_ht.cbegin(); }
    
    iterator end() noexcept { return m_ht.end(); }
    const_iterator end() const noexcept { return m_ht.end(); }
    const_iterator cend() const noexcept { return m_ht.cend(); }
    
    reverse_iterator rbegin() noexcept { return m_ht.rbegin(); }
    const_reverse_iterator rbegin() const noexcept { return m_ht.rbegin(); }
    const_reverse_iterator rcbegin() const noexcept { return m_ht.rcbegin(); }
    
    reverse_iterator rend() noexcept { return m_ht.rend(); }
    const_reverse_iterator rend() const noexcept { return m_ht.rend(); }
    const_reverse_iterator rcend() const noexcept { return m_ht.rcend(); }
    
    
    /*
     * Capacity
     */
    bool empty() const noexcept { return m_ht.empty(); }
    size_type size() const noexcept { return m_ht.size(); }
    size_type max_size() const noexcept { return m_ht.max_size(); }
    
    /*
     * Modifiers
     */
    void clear() noexcept { m_ht.clear(); }
    
    
    
    std::pair<iterator, bool> insert(const value_type& value) { return m_ht.insert(value); }
        
    template<class P, typename std::enable_if<std::is_constructible<value_type, P&&>::value>::type* = nullptr>
    std::pair<iterator, bool> insert(P&& value) { return m_ht.emplace(std::forward<P>(value)); }
    
    std::pair<iterator, bool> insert(value_type&& value) { return m_ht.insert(std::move(value)); }
    
    
    iterator insert(const_iterator hint, const value_type& value) {
        return m_ht.insert(hint, value);
    }
        
    template<class P, typename std::enable_if<std::is_constructible<value_type, P&&>::value>::type* = nullptr>
    iterator insert(const_iterator hint, P&& value) {
        return m_ht.emplace_hint(hint, std::forward<P>(value));
    }
    
    iterator insert(const_iterator hint, value_type&& value) { 
        return m_ht.insert(hint, std::move(value));
    }
    
    
    template<class InputIt>
    void insert(InputIt first, InputIt last) { m_ht.insert(first, last); }
    void insert(std::initializer_list<value_type> ilist) { m_ht.insert(ilist.begin(), ilist.end()); }

    
    
    
    template<class M>
    std::pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj) { 
        return m_ht.insert_or_assign(k, std::forward<M>(obj)); 
    }

    template<class M>
    std::pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj) { 
        return m_ht.insert_or_assign(std::move(k), std::forward<M>(obj)); 
    }
    
    
    template<class M>
    iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj) {
        return m_ht.insert_or_assign(hint, k, std::forward<M>(obj));
    }
    
    template<class M>
    iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj) {
        return m_ht.insert_or_assign(hint, std::move(k), std::forward<M>(obj));
    }
    
    /**
     * Due to the way elements are stored, emplace will need to move or copy the key-value once.
     * The method is equivalent to insert(value_type(std::forward<Args>(args)...));
     * 
     * Mainly here for compatibility with the std::unordered_map interface.
     */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&&... args) { return m_ht.emplace(std::forward<Args>(args)...); }
    
    /**
     * Due to the way elements are stored, emplace_hint will need to move or copy the key-value once.
     * The method is equivalent to insert(hint, value_type(std::forward<Args>(args)...));
     * 
     * Mainly here for compatibility with the std::unordered_map interface.
     */
    template <class... Args>
    iterator emplace_hint(const_iterator hint, Args&&... args) {
        return m_ht.emplace_hint(hint, std::forward<Args>(args)...);
    }
    
    
    
    
    template<class... Args>
    std::pair<iterator, bool> try_emplace(const key_type& k, Args&&... args) { 
        return m_ht.try_emplace(k, std::forward<Args>(args)...);
    }
    
    template<class... Args>
    std::pair<iterator, bool> try_emplace(key_type&& k, Args&&... args) {
        return m_ht.try_emplace(std::move(k), std::forward<Args>(args)...);
    }
    
    template<class... Args>
    iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args) {
        return m_ht.try_emplace(hint, k, std::forward<Args>(args)...);
    }
    
    template<class... Args>
    iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args) {
        return m_ht.try_emplace(hint, std::move(k), std::forward<Args>(args)...);
    }
    
    
    

    /**
     * When erasing an element, the insert order will be preserved and no holes will be present in the container
     * returned by 'values_container()'. 
     * 
     * The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1)
     * average complexity.
     */
    iterator erase(iterator pos) { return m_ht.erase(pos); }
    
    /**
     * @copydoc erase(iterator pos)
     */
    iterator erase(const_iterator pos) { return m_ht.erase(pos); }
    
    /**
     * @copydoc erase(iterator pos)
     */    
    iterator erase(const_iterator first, const_iterator last) { return m_ht.erase(first, last); }
    
    /**
     * @copydoc erase(iterator pos)
     */    
    size_type erase(const key_type& key) { return m_ht.erase(key); }
    
    /**
     * @copydoc erase(iterator pos)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup to the value if you already have the hash.
     */    
    size_type erase(const key_type& key, std::size_t precalculated_hash) { 
        return m_ht.erase(key, precalculated_hash); 
    }
    
    /**
     * @copydoc erase(iterator pos)
     * 
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type erase(const K& key) { return m_ht.erase(key); }
    
    /**
     * @copydoc erase(const key_type& key, std::size_t precalculated_hash)
     * 
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type erase(const K& key, std::size_t precalculated_hash) { 
        return m_ht.erase(key, precalculated_hash); 
    }
    
    
    
    void swap(ordered_map& other) { other.m_ht.swap(m_ht); }
    
    /*
     * Lookup
     */
    T& at(const Key& key) { return m_ht.at(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    T& at(const Key& key, std::size_t precalculated_hash) { return m_ht.at(key, precalculated_hash); }
    
    
    const T& at(const Key& key) const { return m_ht.at(key); }
    
    /**
     * @copydoc at(const Key& key, std::size_t precalculated_hash)
     */
    const T& at(const Key& key, std::size_t precalculated_hash) const { return m_ht.at(key, precalculated_hash); }
    
    
    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    T& at(const K& key) { return m_ht.at(key); }
    
    /**
     * @copydoc at(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */    
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    T& at(const K& key, std::size_t precalculated_hash) { return m_ht.at(key, precalculated_hash); }
    
    /**
     * @copydoc at(const K& key)
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>     
    const T& at(const K& key) const { return m_ht.at(key); }
    
    /**
     * @copydoc at(const K& key, std::size_t precalculated_hash)
     */    
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    const T& at(const K& key, std::size_t precalculated_hash) const { return m_ht.at(key, precalculated_hash); }
    
    
    
    T& operator[](const Key& key) { return m_ht[key]; }    
    T& operator[](Key&& key) { return m_ht[std::move(key)]; }
    
    
    
    size_type count(const Key& key) const { return m_ht.count(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    size_type count(const Key& key, std::size_t precalculated_hash) const { 
        return m_ht.count(key, precalculated_hash); 
    }
    
    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>     
    size_type count(const K& key) const { return m_ht.count(key); }
    
    /**
     * @copydoc count(const K& key) const
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */     
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type count(const K& key, std::size_t precalculated_hash) const { 
        return m_ht.count(key, precalculated_hash);
    }
    
    
    
    iterator find(const Key& key) { return m_ht.find(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    iterator find(const Key& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }
    
    const_iterator find(const Key& key) const { return m_ht.find(key); }
    
    /**
     * @copydoc find(const Key& key, std::size_t precalculated_hash)
     */
    const_iterator find(const Key& key, std::size_t precalculated_hash) const { 
        return m_ht.find(key, precalculated_hash);
    }
    
    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    iterator find(const K& key) { return m_ht.find(key); }
    
    /**
     * @copydoc find(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    iterator find(const K& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }
    
    /**
     * @copydoc find(const K& key)
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    const_iterator find(const K& key) const { return m_ht.find(key); }
    
    /**
     * @copydoc find(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    const_iterator find(const K& key, std::size_t precalculated_hash) const { 
        return m_ht.find(key, precalculated_hash); 
    }
    
    
    
    std::pair<iterator, iterator> equal_range(const Key& key) { return m_ht.equal_range(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    std::pair<iterator, iterator> equal_range(const Key& key, std::size_t precalculated_hash) { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    
    std::pair<const_iterator, const_iterator> equal_range(const Key& key) const { return m_ht.equal_range(key); }
    
    /**
     * @copydoc equal_range(const Key& key, std::size_t precalculated_hash)
     */
    std::pair<const_iterator, const_iterator> equal_range(const Key& key, std::size_t precalculated_hash) const { 
        return m_ht.equal_range(key, precalculated_hash); 
    }

    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>     
    std::pair<iterator, iterator> equal_range(const K& key) { return m_ht.equal_range(key); }
    
    /**
     * @copydoc equal_range(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    std::pair<iterator, iterator> equal_range(const K& key, std::size_t precalculated_hash) { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    
    /**
     * @copydoc equal_range(const K& key)
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>     
    std::pair<const_iterator, const_iterator> equal_range(const K& key) const { return m_ht.equal_range(key); }
    
    /**
     * @copydoc equal_range(const K& key, std::size_t precalculated_hash)
     */    
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    std::pair<const_iterator, const_iterator> equal_range(const K& key, std::size_t precalculated_hash) const { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    
    
    
    /*
     * Bucket interface 
     */
    size_type bucket_count() const { return m_ht.bucket_count(); }
    size_type max_bucket_count() const { return m_ht.max_bucket_count(); }
    
    
    /*
     * Hash policy 
     */
    float load_factor() const { return m_ht.load_factor(); }
    float max_load_factor() const { return m_ht.max_load_factor(); }
    void max_load_factor(float ml) { m_ht.max_load_factor(ml); }
    
    void rehash(size_type count) { m_ht.rehash(count); }
    void reserve(size_type count) { m_ht.reserve(count); }
    
    
    /*
     * Observers
     */
    hasher hash_function() const { return m_ht.hash_function(); }
    key_equal key_eq() const { return m_ht.key_eq(); }
    
    
    
    /*
     * Other
     */
    
    /**
     * Convert a const_iterator to an iterator.
     */
    iterator mutable_iterator(const_iterator pos) {
        return m_ht.mutable_iterator(pos);
    }
    
    /**
     * Requires index <= size().
     * 
     * Return an iterator to the element at index. Return end() if index == size().
     */
    iterator nth(size_type index) { return m_ht.nth(index); }
    
    /**
     * @copydoc nth(size_type index)
     */
    const_iterator nth(size_type index) const { return m_ht.nth(index); }
    
    
    /**
     * Return const_reference to the first element. Requires the container to not be empty.
     */
    const_reference front() const { return m_ht.front(); }
    
    /**
     * Return const_reference to the last element. Requires the container to not be empty.
     */
    const_reference back() const { return m_ht.back(); }
    
    
    /**
     * Only available if ValueTypeContainer is a std::vector. Same as calling 'values_container().data()'.
     */
    template<class U = values_container_type, typename std::enable_if<tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>    
    const typename values_container_type::value_type* data() const noexcept { return m_ht.data(); }
        
    /**
     * Return the container in which the values are stored. The values are in the same order as the insertion order
     * and are contiguous in the structure, no holes (size() == values_container().size()).
     */
    const values_container_type& values_container() const noexcept { return m_ht.values_container(); }

    template<class U = values_container_type, typename std::enable_if<tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>    
    size_type capacity() const noexcept { return m_ht.capacity(); }
    
    void shrink_to_fit() { m_ht.shrink_to_fit(); }
    
    
    
    /**
     * Insert the value before pos shifting all the elements on the right of pos (including pos) one position 
     * to the right.
     * 
     * Amortized linear time-complexity in the distance between pos and end().
     */
    std::pair<iterator, bool> insert_at_position(const_iterator pos, const value_type& value) { 
        return m_ht.insert_at_position(pos, value); 
    }
    
    /**
     * @copydoc insert_at_position(const_iterator pos, const value_type& value)
     */
    std::pair<iterator, bool> insert_at_position(const_iterator pos, value_type&& value) { 
        return m_ht.insert_at_position(pos, std::move(value)); 
    }
    
    /**
     * @copydoc insert_at_position(const_iterator pos, const value_type& value)
     * 
     * Same as insert_at_position(pos, value_type(std::forward<Args>(args)...), mainly
     * here for coherence.
     */
    template<class... Args>
    std::pair<iterator, bool> emplace_at_position(const_iterator pos, Args&&... args) {
        return m_ht.emplace_at_position(pos, std::forward<Args>(args)...); 
    }
       
    /**
     * @copydoc insert_at_position(const_iterator pos, const value_type& value)
     */       
    template<class... Args>
    std::pair<iterator, bool> try_emplace_at_position(const_iterator pos, const key_type& k, Args&&... args) { 
        return m_ht.try_emplace_at_position(pos, k, std::forward<Args>(args)...);
    }
    
    /**
     * @copydoc insert_at_position(const_iterator pos, const value_type& value)
     */    
    template<class... Args>
    std::pair<iterator, bool> try_emplace_at_position(const_iterator pos, key_type&& k, Args&&... args) {
        return m_ht.try_emplace_at_position(pos, std::move(k), std::forward<Args>(args)...);
    }
    
    
    
    void pop_back() { m_ht.pop_back(); }
    
    /**
     * Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.
     * 
     * If an erasure occurs, the last element of the map will take the place of the erased element.
     */
    iterator unordered_erase(iterator pos) { return m_ht.unordered_erase(pos); }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     */
    iterator unordered_erase(const_iterator pos) { return m_ht.unordered_erase(pos); }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     */    
    size_type unordered_erase(const key_type& key) { return m_ht.unordered_erase(key); }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */    
    size_type unordered_erase(const key_type& key, std::size_t precalculated_hash) { 
        return m_ht.unordered_erase(key, precalculated_hash); 
    }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     * 
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type unordered_erase(const K& key) { return m_ht.unordered_erase(key); }
    
    /**
     * @copydoc unordered_erase(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type unordered_erase(const K& key, std::size_t precalculated_hash) { 
        return m_ht.unordered_erase(key, precalculated_hash); 
    }
    
    
    
    friend bool operator==(const ordered_map& lhs, const ordered_map& rhs) { return lhs.m_ht == rhs.m_ht; }
    friend bool operator!=(const ordered_map& lhs, const ordered_map& rhs) { return lhs.m_ht != rhs.m_ht; }
    friend bool operator<(const ordered_map& lhs, const ordered_map& rhs) { return lhs.m_ht < rhs.m_ht; }
    friend bool operator<=(const ordered_map& lhs, const ordered_map& rhs) { return lhs.m_ht <= rhs.m_ht; }
    friend bool operator>(const ordered_map& lhs, const ordered_map& rhs) { return lhs.m_ht > rhs.m_ht; }
    friend bool operator>=(const ordered_map& lhs, const ordered_map& rhs) { return lhs.m_ht >= rhs.m_ht; }
    
    friend void swap(ordered_map& lhs, ordered_map& rhs) { lhs.swap(rhs); }

private:
    ht m_ht;
};

} // end namespace tsl

#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/ordered-map/include/tsl/ordered_set.h`:

```h
/**
 * MIT License
 * 
 * Copyright (c) 2017 Tessil
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef TSL_ORDERED_SET_H
#define TSL_ORDERED_SET_H


#include <cstddef>
#include <cstdint>
#include <deque>
#include <functional>
#include <initializer_list>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>
#include "ordered_hash.h"


namespace tsl {


/**
 * Implementation of an hash set using open adressing with robin hood with backshift delete to resolve collisions.
 * 
 * The particularity of this hash set is that it remembers the order in which the elements were added and
 * provide a way to access the structure which stores these values through the 'values_container()' method. 
 * The used container is defined by ValueTypeContainer, by default a std::deque is used (grows faster) but
 * a std::vector may be used. In this case the set provides a 'data()' method which give a direct access 
 * to the memory used to store the values (which can be usefull to communicate with C API's).
 * 
 * The Key must be copy constructible and/or move constructible. To use `unordered_erase` it also must be swappable.
 * 
 * The behaviour of the hash set is undefinded if the destructor of Key throws an exception.
 * 
 * By default the maximum size of a set is limited to 2^32 - 1 values, if needed this can be changed through
 * the IndexType template parameter. Using an `uint64_t` will raise this limit to 2^64 - 1 values but each
 * bucket will use 16 bytes instead of 8 bytes in addition to the space needed to store the values.
 * 
 * Iterators invalidation:
 *  - clear, operator=, reserve, rehash: always invalidate the iterators (also invalidate end()).
 *  - insert, emplace, emplace_hint, operator[]: when a std::vector is used as ValueTypeContainer 
 *                                               and if size() < capacity(), only end(). 
 *                                               Otherwise all the iterators are invalidated if an insert occurs.
 *  - erase, unordered_erase: when a std::vector is used as ValueTypeContainer invalidate the iterator of 
 *                            the erased element and all the ones after the erased element (including end()). 
 *                            Otherwise all the iterators are invalidated if an erase occurs.
 */
template<class Key, 
         class Hash = std::hash<Key>,
         class KeyEqual = std::equal_to<Key>,
         class Allocator = std::allocator<Key>,
         class ValueTypeContainer = std::deque<Key, Allocator>,
         class IndexType = std::uint_least32_t>
class ordered_set {
private:
    template<typename U>
    using has_is_transparent = tsl::detail_ordered_hash::has_is_transparent<U>;
    
    class KeySelect {
    public:
        using key_type = Key;
        
        const key_type& operator()(const Key& key) const noexcept {
            return key;
        }
        
        key_type& operator()(Key& key) noexcept {
            return key;
        }
    };
    
    using ht = detail_ordered_hash::ordered_hash<Key, KeySelect, void,
                                                 Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType>;
            
public:
    using key_type = typename ht::key_type;
    using value_type = typename ht::value_type;
    using size_type = typename ht::size_type;
    using difference_type = typename ht::difference_type;
    using hasher = typename ht::hasher;
    using key_equal = typename ht::key_equal;
    using allocator_type = typename ht::allocator_type;
    using reference = typename ht::reference;
    using const_reference = typename ht::const_reference;
    using pointer = typename ht::pointer;
    using const_pointer = typename ht::const_pointer;
    using iterator = typename ht::iterator;
    using const_iterator = typename ht::const_iterator;
    using reverse_iterator = typename ht::reverse_iterator;
    using const_reverse_iterator = typename ht::const_reverse_iterator;
    
    using values_container_type = typename ht::values_container_type;

    
    /*
     * Constructors
     */
    ordered_set(): ordered_set(ht::DEFAULT_INIT_BUCKETS_SIZE) {
    }
    
    explicit ordered_set(size_type bucket_count, 
                         const Hash& hash = Hash(),
                         const KeyEqual& equal = KeyEqual(),
                         const Allocator& alloc = Allocator()): 
                        m_ht(bucket_count, hash, equal, alloc, ht::DEFAULT_MAX_LOAD_FACTOR)
    {
    }
    
    ordered_set(size_type bucket_count,
                const Allocator& alloc): ordered_set(bucket_count, Hash(), KeyEqual(), alloc)
    {
    }
    
    ordered_set(size_type bucket_count,
                const Hash& hash,
                const Allocator& alloc): ordered_set(bucket_count, hash, KeyEqual(), alloc)
    {
    }
    
    explicit ordered_set(const Allocator& alloc): ordered_set(ht::DEFAULT_INIT_BUCKETS_SIZE, alloc) {
    }
    
    template<class InputIt>
    ordered_set(InputIt first, InputIt last,
                size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
                const Hash& hash = Hash(),
                const KeyEqual& equal = KeyEqual(),
                const Allocator& alloc = Allocator()): ordered_set(bucket_count, hash, equal, alloc)
    {
        insert(first, last);
    }
    
    template<class InputIt>
    ordered_set(InputIt first, InputIt last,
                size_type bucket_count,
                const Allocator& alloc): ordered_set(first, last, bucket_count, Hash(), KeyEqual(), alloc)
    {
    }
    
    template<class InputIt>
    ordered_set(InputIt first, InputIt last,
                size_type bucket_count,
                const Hash& hash,
                const Allocator& alloc): ordered_set(first, last, bucket_count, hash, KeyEqual(), alloc)
    {
    }

    ordered_set(std::initializer_list<value_type> init,
                size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
                const Hash& hash = Hash(),
                const KeyEqual& equal = KeyEqual(),
                const Allocator& alloc = Allocator()): 
            ordered_set(init.begin(), init.end(), bucket_count, hash, equal, alloc)
    {
    }

    ordered_set(std::initializer_list<value_type> init,
                size_type bucket_count,
                const Allocator& alloc): 
            ordered_set(init.begin(), init.end(), bucket_count, Hash(), KeyEqual(), alloc)
    {
    }

    ordered_set(std::initializer_list<value_type> init,
                size_type bucket_count,
                const Hash& hash,
                const Allocator& alloc): 
            ordered_set(init.begin(), init.end(), bucket_count, hash, KeyEqual(), alloc)
    {
    }

    
    ordered_set& operator=(std::initializer_list<value_type> ilist) {
        m_ht.clear();
        
        m_ht.reserve(ilist.size());
        m_ht.insert(ilist.begin(), ilist.end());
        
        return *this;
    }
    
    allocator_type get_allocator() const { return m_ht.get_allocator(); }
    
    
    /*
     * Iterators
     */
    iterator begin() noexcept { return m_ht.begin(); }
    const_iterator begin() const noexcept { return m_ht.begin(); }
    const_iterator cbegin() const noexcept { return m_ht.cbegin(); }
    
    iterator end() noexcept { return m_ht.end(); }
    const_iterator end() const noexcept { return m_ht.end(); }
    const_iterator cend() const noexcept { return m_ht.cend(); }
    
    reverse_iterator rbegin() noexcept { return m_ht.rbegin(); }
    const_reverse_iterator rbegin() const noexcept { return m_ht.rbegin(); }
    const_reverse_iterator rcbegin() const noexcept { return m_ht.rcbegin(); }
    
    reverse_iterator rend() noexcept { return m_ht.rend(); }
    const_reverse_iterator rend() const noexcept { return m_ht.rend(); }
    const_reverse_iterator rcend() const noexcept { return m_ht.rcend(); }
    
    
    /*
     * Capacity
     */
    bool empty() const noexcept { return m_ht.empty(); }
    size_type size() const noexcept { return m_ht.size(); }
    size_type max_size() const noexcept { return m_ht.max_size(); }
    
    /*
     * Modifiers
     */
    void clear() noexcept { m_ht.clear(); }
    
    
    
    std::pair<iterator, bool> insert(const value_type& value) { return m_ht.insert(value); }
    std::pair<iterator, bool> insert(value_type&& value) { return m_ht.insert(std::move(value)); }
    
    iterator insert(const_iterator hint, const value_type& value) {
        return m_ht.insert(hint, value); 
    }
    
    iterator insert(const_iterator hint, value_type&& value) { 
        return m_ht.insert(hint, std::move(value)); 
    }
    
    template<class InputIt>
    void insert(InputIt first, InputIt last) { m_ht.insert(first, last); }
    void insert(std::initializer_list<value_type> ilist) { m_ht.insert(ilist.begin(), ilist.end()); }

    
    
    /**
     * Due to the way elements are stored, emplace will need to move or copy the key-value once.
     * The method is equivalent to insert(value_type(std::forward<Args>(args)...));
     * 
     * Mainly here for compatibility with the std::unordered_map interface.
     */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&&... args) { return m_ht.emplace(std::forward<Args>(args)...); }
    
    /**
     * Due to the way elements are stored, emplace_hint will need to move or copy the key-value once.
     * The method is equivalent to insert(hint, value_type(std::forward<Args>(args)...));
     * 
     * Mainly here for compatibility with the std::unordered_map interface.
     */
    template<class... Args>
    iterator emplace_hint(const_iterator hint, Args&&... args) {
        return m_ht.emplace_hint(hint, std::forward<Args>(args)...); 
    }

    /**
     * When erasing an element, the insert order will be preserved and no holes will be present in the container
     * returned by 'values_container()'. 
     * 
     * The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1)
     * average complexity.
     */    
    iterator erase(iterator pos) { return m_ht.erase(pos); }
    
    /**
     * @copydoc erase(iterator pos)
     */    
    iterator erase(const_iterator pos) { return m_ht.erase(pos); }
    
    /**
     * @copydoc erase(iterator pos)
     */    
    iterator erase(const_iterator first, const_iterator last) { return m_ht.erase(first, last); }
    
    /**
     * @copydoc erase(iterator pos)
     */    
    size_type erase(const key_type& key) { return m_ht.erase(key); }
    
    /**
     * @copydoc erase(iterator pos)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup to the value if you already have the hash.
     */    
    size_type erase(const key_type& key, std::size_t precalculated_hash) { 
        return m_ht.erase(key, precalculated_hash); 
    }
    
    /**
     * @copydoc erase(iterator pos)
     * 
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type erase(const K& key) { return m_ht.erase(key); }
    
    /**
     * @copydoc erase(const key_type& key, std::size_t precalculated_hash)
     * 
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type erase(const K& key, std::size_t precalculated_hash) { 
        return m_ht.erase(key, precalculated_hash); 
    }
    
    
    
    void swap(ordered_set& other) { other.m_ht.swap(m_ht); }
    
    /*
     * Lookup
     */
    size_type count(const Key& key) const { return m_ht.count(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    size_type count(const Key& key, std::size_t precalculated_hash) const { 
        return m_ht.count(key, precalculated_hash); 
    }
    
    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
    size_type count(const K& key) const { return m_ht.count(key); }
    
    /**
     * @copydoc count(const K& key) const
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */     
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type count(const K& key, std::size_t precalculated_hash) const { 
        return m_ht.count(key, precalculated_hash);
    }
    
    
    
    
    iterator find(const Key& key) { return m_ht.find(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    iterator find(const Key& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }
    
    const_iterator find(const Key& key) const { return m_ht.find(key); }
    
    /**
     * @copydoc find(const Key& key, std::size_t precalculated_hash)
     */
    const_iterator find(const Key& key, std::size_t precalculated_hash) const { 
        return m_ht.find(key, precalculated_hash);
    }
    
    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
    iterator find(const K& key) { return m_ht.find(key); }
    
    /**
     * @copydoc find(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    iterator find(const K& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }
    
    /**
     * @copydoc find(const K& key)
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
    const_iterator find(const K& key) const { return m_ht.find(key); }
    
    /**
     * @copydoc find(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    const_iterator find(const K& key, std::size_t precalculated_hash) const { 
        return m_ht.find(key, precalculated_hash); 
    }
    
    
    
    std::pair<iterator, iterator> equal_range(const Key& key) { return m_ht.equal_range(key); }
    
    /**
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    std::pair<iterator, iterator> equal_range(const Key& key, std::size_t precalculated_hash) { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    
    std::pair<const_iterator, const_iterator> equal_range(const Key& key) const { return m_ht.equal_range(key); }
    
    /**
     * @copydoc equal_range(const Key& key, std::size_t precalculated_hash)
     */
    std::pair<const_iterator, const_iterator> equal_range(const Key& key, std::size_t precalculated_hash) const { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    
    /**
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>     
    std::pair<iterator, iterator> equal_range(const K& key) { return m_ht.equal_range(key); }
    
    /**
     * @copydoc equal_range(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    std::pair<iterator, iterator> equal_range(const K& key, std::size_t precalculated_hash) { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    
    /**
     * @copydoc equal_range(const K& key)
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>     
    std::pair<const_iterator, const_iterator> equal_range(const K& key) const { return m_ht.equal_range(key); }
    
    /**
     * @copydoc equal_range(const K& key, std::size_t precalculated_hash)
     */    
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    std::pair<const_iterator, const_iterator> equal_range(const K& key, std::size_t precalculated_hash) const { 
        return m_ht.equal_range(key, precalculated_hash); 
    }
    

    /*
     * Bucket interface 
     */
    size_type bucket_count() const { return m_ht.bucket_count(); }
    size_type max_bucket_count() const { return m_ht.max_bucket_count(); }
    
    
    /*
     *  Hash policy 
     */
    float load_factor() const { return m_ht.load_factor(); }
    float max_load_factor() const { return m_ht.max_load_factor(); }
    void max_load_factor(float ml) { m_ht.max_load_factor(ml); }
    
    void rehash(size_type count) { m_ht.rehash(count); }
    void reserve(size_type count) { m_ht.reserve(count); }
    
    
    /*
     * Observers
     */
    hasher hash_function() const { return m_ht.hash_function(); }
    key_equal key_eq() const { return m_ht.key_eq(); }
    
    
    /*
     * Other
     */
    
    /**
     * Convert a const_iterator to an iterator.
     */
    iterator mutable_iterator(const_iterator pos) {
        return m_ht.mutable_iterator(pos);
    }
    
    /**
     * Requires index <= size().
     * 
     * Return an iterator to the element at index. Return end() if index == size().
     */
    iterator nth(size_type index) { return m_ht.nth(index); }
    
    /**
     * @copydoc nth(size_type index)
     */
    const_iterator nth(size_type index) const { return m_ht.nth(index); }
    
    
    /**
     * Return const_reference to the first element. Requires the container to not be empty.
     */
    const_reference front() const { return m_ht.front(); }
    
    /**
     * Return const_reference to the last element. Requires the container to not be empty.
     */
    const_reference back() const { return m_ht.back(); }
    
    
    /**
     * Only available if ValueTypeContainer is a std::vector. Same as calling 'values_container().data()'.
     */ 
    template<class U = values_container_type, typename std::enable_if<tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>    
    const typename values_container_type::value_type* data() const noexcept { return m_ht.data(); }
    
    /**
     * Return the container in which the values are stored. The values are in the same order as the insertion order
     * and are contiguous in the structure, no holes (size() == values_container().size()).
     */        
    const values_container_type& values_container() const noexcept { return m_ht.values_container(); }

    template<class U = values_container_type, typename std::enable_if<tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>    
    size_type capacity() const noexcept { return m_ht.capacity(); }
    
    void shrink_to_fit() { m_ht.shrink_to_fit(); }
    
    
    
    /**
     * Insert the value before pos shifting all the elements on the right of pos (including pos) one position 
     * to the right.
     * 
     * Amortized linear time-complexity in the distance between pos and end().
     */
    std::pair<iterator, bool> insert_at_position(const_iterator pos, const value_type& value) { 
        return m_ht.insert_at_position(pos, value); 
    }
    
    /**
     * @copydoc insert_at_position(const_iterator pos, const value_type& value)
     */
    std::pair<iterator, bool> insert_at_position(const_iterator pos, value_type&& value) { 
        return m_ht.insert_at_position(pos, std::move(value)); 
    }
    
    /**
     * @copydoc insert_at_position(const_iterator pos, const value_type& value)
     * 
     * Same as insert_at_position(pos, value_type(std::forward<Args>(args)...), mainly
     * here for coherence.
     */
    template<class... Args>
    std::pair<iterator, bool> emplace_at_position(const_iterator pos, Args&&... args) {
        return m_ht.emplace_at_position(pos, std::forward<Args>(args)...); 
    }
    
    
    
    void pop_back() { m_ht.pop_back(); }
    
    /**
     * Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.
     * 
     * If an erasure occurs, the last element of the map will take the place of the erased element.
     */    
    iterator unordered_erase(iterator pos) { return m_ht.unordered_erase(pos); }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     */    
    iterator unordered_erase(const_iterator pos) { return m_ht.unordered_erase(pos); }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     */    
    size_type unordered_erase(const key_type& key) { return m_ht.unordered_erase(key); }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */    
    size_type unordered_erase(const key_type& key, std::size_t precalculated_hash) { 
        return m_ht.unordered_erase(key, precalculated_hash); 
    }
    
    /**
     * @copydoc unordered_erase(iterator pos)
     * 
     * This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. 
     * If so, K must be hashable and comparable to Key.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type unordered_erase(const K& key) { return m_ht.unordered_erase(key); }
    
    /**
     * @copydoc unordered_erase(const K& key)
     * 
     * Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same
     * as hash_function()(key). Usefull to speed-up the lookup if you already have the hash.
     */
    template<class K, class KE = KeyEqual, typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr> 
    size_type unordered_erase(const K& key, std::size_t precalculated_hash) { 
        return m_ht.unordered_erase(key, precalculated_hash); 
    }
    
    
    
    friend bool operator==(const ordered_set& lhs, const ordered_set& rhs) { return lhs.m_ht == rhs.m_ht; }
    friend bool operator!=(const ordered_set& lhs, const ordered_set& rhs) { return lhs.m_ht != rhs.m_ht; }
    friend bool operator<(const ordered_set& lhs, const ordered_set& rhs) { return lhs.m_ht < rhs.m_ht; }
    friend bool operator<=(const ordered_set& lhs, const ordered_set& rhs) { return lhs.m_ht <= rhs.m_ht; }
    friend bool operator>(const ordered_set& lhs, const ordered_set& rhs) { return lhs.m_ht > rhs.m_ht; }
    friend bool operator>=(const ordered_set& lhs, const ordered_set& rhs) { return lhs.m_ht >= rhs.m_ht; }
    
    friend void swap(ordered_set& lhs, ordered_set& rhs) { lhs.swap(rhs); }
    
private:
    ht m_ht;    
};

} // end namespace tsl

#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2016 Gabi Melman.                                       

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

-- NOTE: Third party dependency used by this software --
This software depends on the fmt lib (MIT License),
and users must comply to its license: https://github.com/fmtlib/fmt/blob/master/LICENSE.rst


```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md`:

```md
# spdlog

Very fast, header-only/compiled, C++ logging library. [![Build Status](https://app.travis-ci.com/gabime/spdlog.svg?branch=v1.x)](https://app.travis-ci.com/gabime/spdlog)&nbsp; [![Build status](https://ci.appveyor.com/api/projects/status/d2jnxclg20vd0o50?svg=true&branch=v1.x)](https://ci.appveyor.com/project/gabime/spdlog) [![Release](https://img.shields.io/github/release/gabime/spdlog.svg)](https://github.com/gabime/spdlog/releases/latest)

## Install 
#### Header only version
Copy the include [folder](https://github.com/gabime/spdlog/tree/v1.x/include/spdlog) to your build tree and use a C++11 compiler.

#### Static lib version (recommended - much faster compile times)
```console
$ git clone https://github.com/gabime/spdlog.git
$ cd spdlog && mkdir build && cd build
$ cmake .. && make -j
```
      
   see example [CMakeLists.txt](https://github.com/gabime/spdlog/blob/v1.x/example/CMakeLists.txt) on how to use.

## Platforms
 * Linux, FreeBSD, OpenBSD, Solaris, AIX
 * Windows (msvc 2013+, cygwin)
 * macOS (clang 3.5+)
 * Android

## Package managers:
* Debian: `sudo apt install libspdlog-dev`
* Homebrew: `brew install spdlog`
* MacPorts: `sudo port install spdlog`
* FreeBSD:  `pkg install spdlog`
* Fedora: `dnf install spdlog`
* Gentoo: `emerge dev-libs/spdlog`
* Arch Linux: `pacman -S spdlog`
* vcpkg: `vcpkg install spdlog`
* conan: `spdlog/[>=1.4.1]`
* conda: `conda install -c conda-forge spdlog`
* build2: ```depends: spdlog ^1.8.2```


## Features
* Very fast (see [benchmarks](#benchmarks) below).
* Headers only or compiled
* Feature rich formatting, using the excellent [fmt](https://github.com/fmtlib/fmt) library.
* Asynchronous mode (optional)
* [Custom](https://github.com/gabime/spdlog/wiki/3.-Custom-formatting) formatting.
* Multi/Single threaded loggers.
* Various log targets:
    * Rotating log files.
    * Daily log files.
    * Console logging (colors supported).
    * syslog.
    * Windows event log.
    * Windows debugger (```OutputDebugString(..)```).
    * Easily [extendable](https://github.com/gabime/spdlog/wiki/4.-Sinks#implementing-your-own-sink) with custom log targets.
* Log filtering - log levels can be modified in runtime as well as in compile time.
* Support for loading log levels from argv or from environment var.
* [Backtrace](#backtrace-support) support - store debug messages in a ring buffer and display later on demand.
 
## Usage samples

#### Basic usage
```c++
#include "spdlog/spdlog.h"

int main() 
{
    spdlog::info("Welcome to spdlog!");
    spdlog::error("Some error message with arg: {}", 1);
    
    spdlog::warn("Easy padding in numbers like {:08d}", 12);
    spdlog::critical("Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}", 42);
    spdlog::info("Support for floats {:03.2f}", 1.23456);
    spdlog::info("Positional args are {1} {0}..", "too", "supported");
    spdlog::info("{:<30}", "left aligned");
    
    spdlog::set_level(spdlog::level::debug); // Set global log level to debug
    spdlog::debug("This message should be displayed..");    
    
    // change log pattern
    spdlog::set_pattern("[%H:%M:%S %z] [%n] [%^---%L---%$] [thread %t] %v");
    
    // Compile time log levels
    // define SPDLOG_ACTIVE_LEVEL to desired level
    SPDLOG_TRACE("Some trace message with param {}", 42);
    SPDLOG_DEBUG("Some debug message");
}

```
---
#### Create stdout/stderr logger object
```c++
#include "spdlog/spdlog.h"
#include "spdlog/sinks/stdout_color_sinks.h"
void stdout_example()
{
    // create color multi threaded logger
    auto console = spdlog::stdout_color_mt("console");    
    auto err_logger = spdlog::stderr_color_mt("stderr");    
    spdlog::get("console")->info("loggers can be retrieved from a global registry using the spdlog::get(logger_name)");
}
```

---
#### Basic file logger
```c++
#include "spdlog/sinks/basic_file_sink.h"
void basic_logfile_example()
{
    try 
    {
        auto logger = spdlog::basic_logger_mt("basic_logger", "logs/basic-log.txt");
    }
    catch (const spdlog::spdlog_ex &ex)
    {
        std::cout << "Log init failed: " << ex.what() << std::endl;
    }
}
```
---
#### Rotating files
```c++
#include "spdlog/sinks/rotating_file_sink.h"
void rotating_example()
{
    // Create a file rotating logger with 5mb size max and 3 rotated files
    auto max_size = 1048576 * 5;
    auto max_files = 3;
    auto logger = spdlog::rotating_logger_mt("some_logger_name", "logs/rotating.txt", max_size, max_files);
}
```

---
#### Daily files
```c++

#include "spdlog/sinks/daily_file_sink.h"
void daily_example()
{
    // Create a daily logger - a new file is created every day on 2:30am
    auto logger = spdlog::daily_logger_mt("daily_logger", "logs/daily.txt", 2, 30);
}

```

---
#### Backtrace support
```c++
// Debug messages can be stored in a ring buffer instead of being logged immediately.
// This is useful in order to display debug logs only when really needed (e.g. when error happens).
// When needed, call dump_backtrace() to see them.

spdlog::enable_backtrace(32); // Store the latest 32 messages in a buffer. Older messages will be dropped.
// or my_logger->enable_backtrace(32)..
for(int i = 0; i < 100; i++)
{
  spdlog::debug("Backtrace message {}", i); // not logged yet..
}
// e.g. if some error happened:
spdlog::dump_backtrace(); // log them now! show the last 32 messages

// or my_logger->dump_backtrace(32)..
```

---
#### Periodic flush
```c++
// periodically flush all *registered* loggers every 3 seconds:
// warning: only use if all your loggers are thread safe ("_mt" loggers)
spdlog::flush_every(std::chrono::seconds(3));

```

---
#### Stopwatch
```c++
// Stopwatch support for spdlog
#include "spdlog/stopwatch.h"
void stopwatch_example()
{
    spdlog::stopwatch sw;    
    spdlog::debug("Elapsed {}", sw);
    spdlog::debug("Elapsed {:.3}", sw);       
}

```

---
#### Log binary data in hex
```c++
// many types of std::container<char> types can be used.
// ranges are supported too.
// format flags:
// {:X} - print in uppercase.
// {:s} - don't separate each byte with space.
// {:p} - don't print the position on each line start.
// {:n} - don't split the output to lines.
// {:a} - show ASCII if :n is not set.

#include "spdlog/fmt/bin_to_hex.h"

void binary_example()
{
    auto console = spdlog::get("console");
    std::array<char, 80> buf;
    console->info("Binary example: {}", spdlog::to_hex(buf));
    console->info("Another binary example:{:n}", spdlog::to_hex(std::begin(buf), std::begin(buf) + 10));
    // more examples:
    // logger->info("uppercase: {:X}", spdlog::to_hex(buf));
    // logger->info("uppercase, no delimiters: {:Xs}", spdlog::to_hex(buf));
    // logger->info("uppercase, no delimiters, no position info: {:Xsp}", spdlog::to_hex(buf));
}

```

---
#### Logger with multi sinks - each with different format and log level
```c++

// create logger with 2 targets with different log levels and formats.
// the console will show only warnings or errors, while the file will log all.
void multi_sink_example()
{
    auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
    console_sink->set_level(spdlog::level::warn);
    console_sink->set_pattern("[multi_sink_example] [%^%l%$] %v");

    auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>("logs/multisink.txt", true);
    file_sink->set_level(spdlog::level::trace);

    spdlog::logger logger("multi_sink", {console_sink, file_sink});
    logger.set_level(spdlog::level::debug);
    logger.warn("this should appear in both console and file");
    logger.info("this message should not appear in the console, only in the file");
}
```

---
#### Asynchronous logging
```c++
#include "spdlog/async.h"
#include "spdlog/sinks/basic_file_sink.h"
void async_example()
{
    // default thread pool settings can be modified *before* creating the async logger:
    // spdlog::init_thread_pool(8192, 1); // queue with 8k items and 1 backing thread.
    auto async_file = spdlog::basic_logger_mt<spdlog::async_factory>("async_file_logger", "logs/async_log.txt");
    // alternatively:
    // auto async_file = spdlog::create_async<spdlog::sinks::basic_file_sink_mt>("async_file_logger", "logs/async_log.txt");   
}

```

---
#### Asynchronous logger with multi sinks  
```c++
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/sinks/rotating_file_sink.h"

void multi_sink_example2()
{
    spdlog::init_thread_pool(8192, 1);
    auto stdout_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt >();
    auto rotating_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>("mylog.txt", 1024*1024*10, 3);
    std::vector<spdlog::sink_ptr> sinks {stdout_sink, rotating_sink};
    auto logger = std::make_shared<spdlog::async_logger>("loggername", sinks.begin(), sinks.end(), spdlog::thread_pool(), spdlog::async_overflow_policy::block);
    spdlog::register_logger(logger);
}
```
 
---
#### User defined types
```c++
// user defined types logging by implementing operator<<
#include "spdlog/fmt/ostr.h" // must be included
struct my_type
{
    int i;
    template<typename OStream>
    friend OStream &operator<<(OStream &os, const my_type &c)
    {
        return os << "[my_type i=" << c.i << "]";
    }
};

void user_defined_example()
{
    spdlog::get("console")->info("user defined type: {}", my_type{14});
}

```

---
#### User defined flags in the log pattern
```c++ 
// Log patterns can contain custom flags.
// the following example will add new flag '%*' - which will be bound to a <my_formatter_flag> instance.
#include "spdlog/pattern_formatter.h"
class my_formatter_flag : public spdlog::custom_flag_formatter
{
public:
    void format(const spdlog::details::log_msg &, const std::tm &, spdlog::memory_buf_t &dest) override
    {
        std::string some_txt = "custom-flag";
        dest.append(some_txt.data(), some_txt.data() + some_txt.size());
    }

    std::unique_ptr<custom_flag_formatter> clone() const override
    {
        return spdlog::details::make_unique<my_formatter_flag>();
    }
};

void custom_flags_example()
{    
    auto formatter = std::make_unique<spdlog::pattern_formatter>();
    formatter->add_flag<my_formatter_flag>('*').set_pattern("[%n] [%*] [%^%l%$] %v");
    spdlog::set_formatter(std::move(formatter));
}

```

---
#### Custom error handler
```c++
void err_handler_example()
{
    // can be set globally or per logger(logger->set_error_handler(..))
    spdlog::set_error_handler([](const std::string &msg) { spdlog::get("console")->error("*** LOGGER ERROR ***: {}", msg); });
    spdlog::get("console")->info("some invalid message to trigger an error {}{}{}{}", 3);
}

```

---
#### syslog 
```c++
#include "spdlog/sinks/syslog_sink.h"
void syslog_example()
{
    std::string ident = "spdlog-example";
    auto syslog_logger = spdlog::syslog_logger_mt("syslog", ident, LOG_PID);
    syslog_logger->warn("This is warning that will end up in syslog.");
}
```
---
#### Android example 
```c++
#include "spdlog/sinks/android_sink.h"
void android_example()
{
    std::string tag = "spdlog-android";
    auto android_logger = spdlog::android_logger_mt("android", tag);
    android_logger->critical("Use \"adb shell logcat\" to view this message.");
}
```

---
#### Load log levels from env variable or from argv

```c++
#include "spdlog/cfg/env.h"
int main (int argc, char *argv[])
{
    spdlog::cfg::load_env_levels();
    // or from command line:
    // ./example SPDLOG_LEVEL=info,mylogger=trace
    // #include "spdlog/cfg/argv.h" // for loading levels from argv
    // spdlog::cfg::load_argv_levels(argc, argv);
}
```
So then you can:

```console
$ export SPDLOG_LEVEL=info,mylogger=trace
$ ./example
```


---
#### Log file open/close event handlers
```c++
// You can get callbacks from spdlog before/after log file has been opened or closed. 
// This is useful for cleanup procedures or for adding someting the start/end of the log files.
void file_events_example()
{
    // pass the spdlog::file_event_handlers to file sinks for open/close log file notifications
    spdlog::file_event_handlers handlers;
    handlers.before_open = [](spdlog::filename_t filename) { spdlog::info("Before opening {}", filename); };
    handlers.after_open = [](spdlog::filename_t filename, std::FILE *fstream) { fputs("After opening\n", fstream); };
    handlers.before_close = [](spdlog::filename_t filename, std::FILE *fstream) { fputs("Before closing\n", fstream); };
    handlers.after_close = [](spdlog::filename_t filename) { spdlog::info("After closing {}", filename); };
    auto my_logger = spdlog::basic_logger_st("some_logger", "logs/events-sample.txt", true, handlers);        
}
```

---
#### Replace the Default Logger
```c++
void replace_default_logger_example()
{
    auto new_logger = spdlog::basic_logger_mt("new_default_logger", "logs/new-default-log.txt", true);
    spdlog::set_default_logger(new_logger);
    spdlog::info("new logger log message");
}
```

---
## Benchmarks

Below are some [benchmarks](https://github.com/gabime/spdlog/blob/v1.x/bench/bench.cpp) done in Ubuntu 64 bit, Intel i7-4770 CPU @ 3.40GHz

#### Synchronous mode
```
[info] **************************************************************
[info] Single thread, 1,000,000 iterations
[info] **************************************************************
[info] basic_st         Elapsed: 0.17 secs        5,777,626/sec
[info] rotating_st      Elapsed: 0.18 secs        5,475,894/sec
[info] daily_st         Elapsed: 0.20 secs        5,062,659/sec
[info] empty_logger     Elapsed: 0.07 secs       14,127,300/sec
[info] **************************************************************
[info] C-string (400 bytes). Single thread, 1,000,000 iterations
[info] **************************************************************
[info] basic_st         Elapsed: 0.41 secs        2,412,483/sec
[info] rotating_st      Elapsed: 0.72 secs        1,389,196/sec
[info] daily_st         Elapsed: 0.42 secs        2,393,298/sec
[info] null_st          Elapsed: 0.04 secs       27,446,957/sec
[info] **************************************************************
[info] 10 threads, competing over the same logger object, 1,000,000 iterations
[info] **************************************************************
[info] basic_mt         Elapsed: 0.60 secs        1,659,613/sec
[info] rotating_mt      Elapsed: 0.62 secs        1,612,493/sec
[info] daily_mt         Elapsed: 0.61 secs        1,638,305/sec
[info] null_mt          Elapsed: 0.16 secs        6,272,758/sec
```
#### Asynchronous mode
```
[info] -------------------------------------------------
[info] Messages     : 1,000,000
[info] Threads      : 10
[info] Queue        : 8,192 slots
[info] Queue memory : 8,192 x 272 = 2,176 KB 
[info] -------------------------------------------------
[info] 
[info] *********************************
[info] Queue Overflow Policy: block
[info] *********************************
[info] Elapsed: 1.70784 secs     585,535/sec
[info] Elapsed: 1.69805 secs     588,910/sec
[info] Elapsed: 1.7026 secs      587,337/sec
[info] 
[info] *********************************
[info] Queue Overflow Policy: overrun
[info] *********************************
[info] Elapsed: 0.372816 secs    2,682,285/sec
[info] Elapsed: 0.379758 secs    2,633,255/sec
[info] Elapsed: 0.373532 secs    2,677,147/sec

```

## Documentation
Documentation can be found in the [wiki](https://github.com/gabime/spdlog/wiki/1.-QuickStart) pages.

---

Thanks to [JetBrains](https://www.jetbrains.com/?from=spdlog) for donating product licenses to help develop **spdlog** <a href="https://www.jetbrains.com/?from=spdlog"><img src="logos/jetbrains-variant-4.svg" width="94" align="center" /></a>



```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/ide.cmake`:

```cmake
# ---------------------------------------------------------------------------------------
# IDE support for headers
# ---------------------------------------------------------------------------------------
set(SPDLOG_HEADERS_DIR "${CMAKE_CURRENT_LIST_DIR}/../include")

file(GLOB SPDLOG_TOP_HEADERS "${SPDLOG_HEADERS_DIR}/spdlog/*.h")
file(GLOB SPDLOG_DETAILS_HEADERS "${SPDLOG_HEADERS_DIR}/spdlog/details/*.h")
file(GLOB SPDLOG_SINKS_HEADERS "${SPDLOG_HEADERS_DIR}/spdlog/sinks/*.h")
file(GLOB SPDLOG_FMT_HEADERS "${SPDLOG_HEADERS_DIR}/spdlog/fmt/*.h")
file(GLOB SPDLOG_FMT_BUNDELED_HEADERS "${SPDLOG_HEADERS_DIR}/spdlog/fmt/bundled/*.h")
set(SPDLOG_ALL_HEADERS ${SPDLOG_TOP_HEADERS} ${SPDLOG_DETAILS_HEADERS} ${SPDLOG_SINKS_HEADERS} ${SPDLOG_FMT_HEADERS}
                       ${SPDLOG_FMT_BUNDELED_HEADERS})

source_group("Header Files\\spdlog" FILES ${SPDLOG_TOP_HEADERS})
source_group("Header Files\\spdlog\\details" FILES ${SPDLOG_DETAILS_HEADERS})
source_group("Header Files\\spdlog\\sinks" FILES ${SPDLOG_SINKS_HEADERS})
source_group("Header Files\\spdlog\\fmt" FILES ${SPDLOG_FMT_HEADERS})
source_group("Header Files\\spdlog\\fmt\\bundled\\" FILES ${SPDLOG_FMT_BUNDELED_HEADERS})

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/pch.h.in`:

```in
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// details/pattern_formatter-inl.h
// fmt/bin_to_hex.h
// fmt/bundled/format-inl.h
#include <cctype>

// details/file_helper-inl.h
// details/os-inl.h
// fmt/bundled/core.h
// fmt/bundled/posix.h
// logger-inl.h
// sinks/daily_file_sink.h
// sinks/stdout_sinks.h
#include <cstdio>

// details/os-inl.h
// fmt/bundled/posix.h
#include <cstdlib>

// details/os-inl.h
// details/pattern_formatter-inl.h
// fmt/bundled/core.h
// fmt/bundled/format-inl.h
#include <cstring>

// details/os-inl.h
// details/os.h
// details/pattern_formatter-inl.h
// details/pattern_formatter.h
// fmt/bundled/chrono.h
// sinks/daily_file_sink.h
// sinks/rotating_file_sink-inl.h
#include <ctime>

// fmt/bundled/format-inl.h
#include <climits>

// fmt/bundled/format-inl.h
#include <cwchar>

// fmt/bundled/format-inl.h
// fmt/bundled/format.h
#include <cmath>

// fmt/bundled/format-inl.h
#include <cstdarg>

// details/file_helper-inl.h
// fmt/bundled/format.h
// fmt/bundled/posix.h
// sinks/rotating_file_sink-inl.h
#include <cerrno>

// details/circular_q.h
// details/thread_pool-inl.h
// fmt/bundled/format-inl.h
#include <cassert>

// async_logger-inl.h
// cfg/helpers-inl.h
// log_levels.h
// common.h
// details/file_helper-inl.h
// details/log_msg.h
// details/os-inl.h
// details/pattern_formatter-inl.h
// details/pattern_formatter.h
// details/registry-inl.h
// details/registry.h
// details/tcp_client-windows.h
// details/tcp_client.h
// fmt/bundled/core.h
// sinks/android_sink.h
// sinks/ansicolor_sink.h
// sinks/basic_file_sink.h
// sinks/daily_file_sink.h
// sinks/dup_filter_sink.h
// sinks/msvc_sink.h
// sinks/ringbuffer_sink.h
// sinks/rotating_file_sink-inl.h
// sinks/rotating_file_sink.h
// sinks/syslog_sink.h
// sinks/tcp_sink.h
// sinks/win_eventlog_sink.h
// sinks/wincolor_sink.h
// spdlog.h:
#include <string>

// cfg/helpers-inl.h
// fmt/bundled/chrono.h
#include <sstream>

// fmt/bundled/ostream.h
// sinks/ostream_sink.h
#include <ostream>

// cfg/log_levels.h
// details/registry-inl.h
// details/registry.h
#include <unordered_map>

// details/circular_q.h
// details/pattern_formatter-inl.h
// details/pattern_formatter.h
// details/thread_pool.h
// fmt/bundled/compile.h
// logger.h
// sinks/dist_sink.h
// sinks/ringbuffer_sink.h
// sinks/win_eventlog_sink.h
#include <vector>

// details/os-inl.h
// details/pattern_formatter-inl.h
// sinks/ansicolor_sink.h
// sinks/syslog_sink.h
// sinks/systemd_sink.h
// sinks/wincolor_sink.h
#include <array>

// details/file_helper-inl.h
// details/file_helper.h
// sinks/rotating_file_sink-inl.h
#include <tuple>

// details/os-inl.h
// fmt/bundled/format.h
// fmt/bundled/printf.h
#include <limits>

// common.h
// details/backtracer.h
// details/null_mutex.h
#include <atomic>

// common.h
// details/backtracer.h
// details/null_mutex.h
#include <locale>

// common.h
#include <initializer_list>

// common.h
#include <exception>

// common.h
// details/fmt_helper.h
// fmt/bundled/core.h
// fmt/bundled/ranges.h
#include <type_traits>

// cfg/helpers-inl.h
// details/null_mutex.h
// details/pattern_formatter-inl.h
#include <utility>

// async.h
// async_logger-inl.h
// common.h
// details/pattern_formatter-inl.h
// details/pattern_formatter.h
// details/registry-inl.h
// details/registry.h
// details/thread_pool.h
// fmt/bundled/format.h
// sinks/ansicolor_sink.h
// sinks/base_sink-inl.h
// sinks/dist_sink.h
// sinks/stdout_sinks-inl.h
// sinks/wincolor_sink.h
// spdlog.h
#include <memory>

// async.h
// common.h
// details/backtracer.h
// details/periodic_worker.h
// details/registry-inl.h
// details/registry.h
// details/thread_pool.h
// sinks/tcp_sink.h
// spdlog.h
#include <functional>

// details/mpmc_blocking_q.h
// details/periodic_worker.h
#include <condition_variable>

// details/os-inl.h
// fmt/bundled/format.h
// fmt/bundled/printf.h
// sinks/dist_sink.h
#include <algorithm>

// common.h
// details/file_helper-inl.h
// details/fmt_helper.h
// details/os-inl.h
// details/pattern_formatter-inl.h
// details/pattern_formatter.h
// details/periodic_worker.h
// details/registry-inl.h
// details/registry.h
// details/thread_pool.h
// fmt/bundled/chrono.h
// sinks/android_sink.h
// sinks/daily_file_sink.h
// sinks/dup_filter_sink.h
// sinks/rotating_file_sink-inl.h
// sinks/rotating_file_sink.h
// sinks/tcp_sink.h
// spdlog.h
#include <chrono>

// details/file_helper-inl.h
// details/os-inl.h
// details/pattern_formatter-inl.h
// details/periodic_worker.h
// details/thread_pool.h
// sinks/android_sink.h
#include <thread>

// async.h
// details/backtracer.h
// details/console_globals.h
// details/mpmc_blocking_q.h
// details/pattern_formatter-inl.h
// details/periodic_worker.h
// details/registry.h
// sinks/android_sink.h
// sinks/ansicolor_sink.h
// sinks/basic_file_sink.h
// sinks/daily_file_sink.h
// sinks/dist_sink.h
// sinks/dup_filter_sink.h
// sinks/msvc_sink.h
// sinks/null_sink.h
// sinks/ostream_sink.h
// sinks/ringbuffer_sink.h
// sinks/rotating_file_sink-inl.h
// sinks/rotating_file_sink.h
// sinks/tcp_sink.h
// sinks/win_eventlog_sink.h
// sinks/wincolor_sink.h
//
// color_sinks.cpp
// file_sinks.cpp
// spdlog.cpp
// stdout_sinks.cpp
#include <mutex>

// spdlog
#include <spdlog/common.h>
```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/spdlog.pc.in`:

```in
prefix=@CMAKE_INSTALL_PREFIX@
exec_prefix=${prefix}
includedir=${prefix}/include
libdir=${exec_prefix}/@CMAKE_INSTALL_LIBDIR@

Name: lib@PROJECT_NAME@
Description: Fast C++ logging library.
URL: https://github.com/gabime/@PROJECT_NAME@
Version: @SPDLOG_VERSION@
CFlags: -I${includedir} @PKG_CONFIG_DEFINES@
Libs: -L${libdir} -lspdlog -pthread
Requires: @PKG_CONFIG_REQUIRES@


```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/spdlogCPack.cmake`:

```cmake
set(CPACK_GENERATOR "TGZ;ZIP" CACHE STRING "Semicolon separated list of generators")

set(CPACK_INCLUDE_TOPLEVEL_DIRECTORY 0)
set(CPACK_INSTALL_CMAKE_PROJECTS "${CMAKE_BINARY_DIR}" "${PROJECT_NAME}" ALL .)

set(CPACK_PROJECT_URL "https://github.com/gabime/spdlog")
set(CPACK_PACKAGE_VENDOR "Gabi Melman")
set(CPACK_PACKAGE_CONTACT "Gabi Melman <gmelman1@gmail.com>")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Fast C++ logging library")
set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})
set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})
set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})
set(CPACK_PACKAGE_VERSION ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH})
if(PROJECT_VERSION_TWEAK)
    set(CPACK_PACKAGE_VERSION ${CPACK_PACKAGE_VERSION}.${PROJECT_VERSION_TWEAK})
endif()
set(CPACK_PACKAGE_RELOCATABLE ON CACHE BOOL "Build relocatable package")

set(CPACK_RPM_PACKAGE_LICENSE "MIT")
set(CPACK_RPM_PACKAGE_GROUP "Development/Libraries")
set(CPACK_DEBIAN_PACKAGE_SECTION "libs")
set(CPACK_RPM_PACKAGE_URL ${CPACK_PROJECT_URL})
set(CPACK_DEBIAN_PACKAGE_HOMEPAGE ${CPACK_PROJECT_URL})
set(CPACK_RPM_PACKAGE_DESCRIPTION "Very fast, header-only/compiled, C++ logging library.")
set(CPACK_DEBIAN_PACKAGE_DESCRIPTION "Very fast, header-only/compiled, C++ logging library.")

if(CPACK_PACKAGE_NAME)
    set(CPACK_RPM_FILE_NAME "${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}")
    set(CPACK_DEBIAN_FILE_NAME "${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}")
else()
    set(CPACK_RPM_FILE_NAME "${PROJECT_NAME}-${CPACK_PACKAGE_VERSION}")
    set(CPACK_DEBIAN_FILE_NAME "${PROJECT_NAME}-${CPACK_PACKAGE_VERSION}")
    set(CPACK_RPM_PACKAGE_NAME "${PROJECT_NAME}")
    set(CPACK_DEBIAN_PACKAGE_NAME "${PROJECT_NAME}")
endif()

if(CPACK_RPM_PACKAGE_RELEASE)
    set(CPACK_RPM_FILE_NAME "${CPACK_RPM_FILE_NAME}-${CPACK_RPM_PACKAGE_RELEASE}")
endif()
if(CPACK_DEBIAN_PACKAGE_RELEASE)
    set(CPACK_DEBIAN_FILE_NAME "${CPACK_DEBIAN_FILE_NAME}-${CPACK_DEBIAN_PACKAGE_RELEASE}")
endif()

if(CPACK_RPM_PACKAGE_ARCHITECTURE)
    set(CPACK_RPM_FILE_NAME "${CPACK_RPM_FILE_NAME}.${CPACK_RPM_PACKAGE_ARCHITECTURE}")
endif()
if(CPACK_DEBIAN_PACKAGE_ARCHITECTURE)
    set(CPACK_DEBIAN_FILE_NAME "${CPACK_DEBIAN_FILE_NAME}.${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}")
endif()
set(CPACK_RPM_FILE_NAME "${CPACK_RPM_FILE_NAME}.rpm")
set(CPACK_DEBIAN_FILE_NAME "${CPACK_DEBIAN_FILE_NAME}.deb")

if(NOT CPACK_PACKAGE_RELOCATABLE)
    # Depend on pkgconfig rpm to create the system pkgconfig folder
    set(CPACK_RPM_PACKAGE_REQUIRES pkgconfig)
    set(CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION
        "${CPACK_PACKAGING_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}/pkgconfig")
endif()

include(CPack)

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/spdlogConfig.cmake.in`:

```in
# Copyright(c) 2019 spdlog authors
# Distributed under the MIT License (http://opensource.org/licenses/MIT)

@PACKAGE_INIT@

find_package(Threads REQUIRED)

set(SPDLOG_FMT_EXTERNAL @SPDLOG_FMT_EXTERNAL@)
set(SPDLOG_FMT_EXTERNAL_HO @SPDLOG_FMT_EXTERNAL_HO@)
set(config_targets_file @config_targets_file@)

if(SPDLOG_FMT_EXTERNAL OR SPDLOG_FMT_EXTERNAL_HO)
    include(CMakeFindDependencyMacro)
    find_dependency(fmt CONFIG)
endif()


include("${CMAKE_CURRENT_LIST_DIR}/${config_targets_file}")

check_required_components(spdlog)

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/utils.cmake`:

```cmake
# Get spdlog version from include/spdlog/version.h and put it in SPDLOG_VERSION
function(spdlog_extract_version)
    file(READ "${CMAKE_CURRENT_LIST_DIR}/include/spdlog/version.h" file_contents)
    string(REGEX MATCH "SPDLOG_VER_MAJOR ([0-9]+)" _ "${file_contents}")
    if(NOT CMAKE_MATCH_COUNT EQUAL 1)
        message(FATAL_ERROR "Could not extract major version number from spdlog/version.h")
    endif()
    set(ver_major ${CMAKE_MATCH_1})

    string(REGEX MATCH "SPDLOG_VER_MINOR ([0-9]+)" _ "${file_contents}")
    if(NOT CMAKE_MATCH_COUNT EQUAL 1)
        message(FATAL_ERROR "Could not extract minor version number from spdlog/version.h")
    endif()

    set(ver_minor ${CMAKE_MATCH_1})
    string(REGEX MATCH "SPDLOG_VER_PATCH ([0-9]+)" _ "${file_contents}")
    if(NOT CMAKE_MATCH_COUNT EQUAL 1)
        message(FATAL_ERROR "Could not extract patch version number from spdlog/version.h")
    endif()
    set(ver_patch ${CMAKE_MATCH_1})

    set(SPDLOG_VERSION_MAJOR ${ver_major} PARENT_SCOPE)
    set(SPDLOG_VERSION_MINOR ${ver_minor} PARENT_SCOPE)
    set(SPDLOG_VERSION_PATCH ${ver_patch} PARENT_SCOPE)
    set(SPDLOG_VERSION "${ver_major}.${ver_minor}.${ver_patch}" PARENT_SCOPE)
endfunction()

# Turn on warnings on the given target
function(spdlog_enable_warnings target_name)
    if(SPDLOG_BUILD_WARNINGS)
        if(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
            list(APPEND MSVC_OPTIONS "/W3")
            if(MSVC_VERSION GREATER 1900) # Allow non fatal security warnings for msvc 2015
                list(APPEND MSVC_OPTIONS "/WX")
            endif()
        endif()

        target_compile_options(
            ${target_name}
            PRIVATE $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:
                    -Wall
                    -Wextra
                    -Wconversion
                    -pedantic
                    -Werror
                    -Wfatal-errors>
                    $<$<CXX_COMPILER_ID:MSVC>:${MSVC_OPTIONS}>)
    endif()
endfunction()

# Enable address sanitizer (gcc/clang only)
function(spdlog_enable_sanitizer target_name)
    if(NOT CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
        message(FATAL_ERROR "Sanitizer supported only for gcc/clang")
    endif()
    message(STATUS "Address sanitizer enabled")
    target_compile_options(${target_name} PRIVATE -fsanitize=address,undefined)
    target_compile_options(${target_name} PRIVATE -fno-sanitize=signed-integer-overflow)
    target_compile_options(${target_name} PRIVATE -fno-sanitize-recover=all)
    target_compile_options(${target_name} PRIVATE -fno-omit-frame-pointer)
    target_link_libraries(${target_name} PRIVATE -fsanitize=address,undefined -fuse-ld=gold)
endfunction()

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/cmake/version.rc.in`:

```in
#define APSTUDIO_READONLY_SYMBOLS
#include <windows.h>
#undef APSTUDIO_READONLY_SYMBOLS

LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US


VS_VERSION_INFO VERSIONINFO
 FILEVERSION @SPDLOG_VERSION_MAJOR@,@SPDLOG_VERSION_MINOR@,@SPDLOG_VERSION_PATCH@,0
 PRODUCTVERSION @SPDLOG_VERSION_MAJOR@,@SPDLOG_VERSION_MINOR@,@SPDLOG_VERSION_PATCH@,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "FileDescription", "spdlog dll\0"
            VALUE "FileVersion", "@SPDLOG_VERSION@.0\0"
            VALUE "InternalName", "spdlog.dll\0"
            VALUE "LegalCopyright", "Copyright (C) spdlog\0"
            VALUE "ProductName", "spdlog\0"
            VALUE "ProductVersion", "@SPDLOG_VERSION@.0\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END






```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/async.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

//
// Async logging using global thread pool
// All loggers created here share same global thread pool.
// Each log message is pushed to a queue along with a shared pointer to the
// logger.
// If a logger deleted while having pending messages in the queue, it's actual
// destruction will defer
// until all its messages are processed by the thread pool.
// This is because each message in the queue holds a shared_ptr to the
// originating logger.

#include <spdlog/async_logger.h>
#include <spdlog/details/registry.h>
#include <spdlog/details/thread_pool.h>

#include <memory>
#include <mutex>
#include <functional>

namespace spdlog {

namespace details {
static const size_t default_async_q_size = 8192;
}

// async logger factory - creates async loggers backed with thread pool.
// if a global thread pool doesn't already exist, create it with default queue
// size of 8192 items and single thread.
template<async_overflow_policy OverflowPolicy = async_overflow_policy::block>
struct async_factory_impl
{
    template<typename Sink, typename... SinkArgs>
    static std::shared_ptr<async_logger> create(std::string logger_name, SinkArgs &&... args)
    {
        auto &registry_inst = details::registry::instance();

        // create global thread pool if not already exists..

        auto &mutex = registry_inst.tp_mutex();
        std::lock_guard<std::recursive_mutex> tp_lock(mutex);
        auto tp = registry_inst.get_tp();
        if (tp == nullptr)
        {
            tp = std::make_shared<details::thread_pool>(details::default_async_q_size, 1U);
            registry_inst.set_tp(tp);
        }

        auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);
        auto new_logger = std::make_shared<async_logger>(std::move(logger_name), std::move(sink), std::move(tp), OverflowPolicy);
        registry_inst.initialize_logger(new_logger);
        return new_logger;
    }
};

using async_factory = async_factory_impl<async_overflow_policy::block>;
using async_factory_nonblock = async_factory_impl<async_overflow_policy::overrun_oldest>;

template<typename Sink, typename... SinkArgs>
inline std::shared_ptr<spdlog::logger> create_async(std::string logger_name, SinkArgs &&... sink_args)
{
    return async_factory::create<Sink>(std::move(logger_name), std::forward<SinkArgs>(sink_args)...);
}

template<typename Sink, typename... SinkArgs>
inline std::shared_ptr<spdlog::logger> create_async_nb(std::string logger_name, SinkArgs &&... sink_args)
{
    return async_factory_nonblock::create<Sink>(std::move(logger_name), std::forward<SinkArgs>(sink_args)...);
}

// set global thread pool.
inline void init_thread_pool(
    size_t q_size, size_t thread_count, std::function<void()> on_thread_start, std::function<void()> on_thread_stop)
{
    auto tp = std::make_shared<details::thread_pool>(q_size, thread_count, on_thread_start, on_thread_stop);
    details::registry::instance().set_tp(std::move(tp));
}

inline void init_thread_pool(size_t q_size, size_t thread_count, std::function<void()> on_thread_start)
{
    init_thread_pool(q_size, thread_count, on_thread_start, [] {});
}

inline void init_thread_pool(size_t q_size, size_t thread_count)
{
    init_thread_pool(
        q_size, thread_count, [] {}, [] {});
}

// get the global thread pool.
inline std::shared_ptr<spdlog::details::thread_pool> thread_pool()
{
    return details::registry::instance().get_tp();
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/async_logger-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/async_logger.h>
#endif

#include <spdlog/sinks/sink.h>
#include <spdlog/details/thread_pool.h>

#include <memory>
#include <string>

SPDLOG_INLINE spdlog::async_logger::async_logger(
    std::string logger_name, sinks_init_list sinks_list, std::weak_ptr<details::thread_pool> tp, async_overflow_policy overflow_policy)
    : async_logger(std::move(logger_name), sinks_list.begin(), sinks_list.end(), std::move(tp), overflow_policy)
{}

SPDLOG_INLINE spdlog::async_logger::async_logger(
    std::string logger_name, sink_ptr single_sink, std::weak_ptr<details::thread_pool> tp, async_overflow_policy overflow_policy)
    : async_logger(std::move(logger_name), {std::move(single_sink)}, std::move(tp), overflow_policy)
{}

// send the log message to the thread pool
SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg)
{
    if (auto pool_ptr = thread_pool_.lock())
    {
        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);
    }
    else
    {
        throw_spdlog_ex("async log: thread pool doesn't exist anymore");
    }
}

// send flush request to the thread pool
SPDLOG_INLINE void spdlog::async_logger::flush_()
{
    if (auto pool_ptr = thread_pool_.lock())
    {
        pool_ptr->post_flush(shared_from_this(), overflow_policy_);
    }
    else
    {
        throw_spdlog_ex("async flush: thread pool doesn't exist anymore");
    }
}

//
// backend functions - called from the thread pool to do the actual job
//
SPDLOG_INLINE void spdlog::async_logger::backend_sink_it_(const details::log_msg &msg)
{
    for (auto &sink : sinks_)
    {
        if (sink->should_log(msg.level))
        {
            SPDLOG_TRY
            {
                sink->log(msg);
            }
            SPDLOG_LOGGER_CATCH(msg.source)
        }
    }

    if (should_flush_(msg))
    {
        backend_flush_();
    }
}

SPDLOG_INLINE void spdlog::async_logger::backend_flush_()
{
    for (auto &sink : sinks_)
    {
        SPDLOG_TRY
        {
            sink->flush();
        }
        SPDLOG_LOGGER_CATCH(source_loc())
    }
}

SPDLOG_INLINE std::shared_ptr<spdlog::logger> spdlog::async_logger::clone(std::string new_name)
{
    auto cloned = std::make_shared<spdlog::async_logger>(*this);
    cloned->name_ = std::move(new_name);
    return cloned;
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/async_logger.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// Fast asynchronous logger.
// Uses pre allocated queue.
// Creates a single back thread to pop messages from the queue and log them.
//
// Upon each log write the logger:
//    1. Checks if its log level is enough to log the message
//    2. Push a new copy of the message to a queue (or block the caller until
//    space is available in the queue)
// Upon destruction, logs all remaining messages in the queue before
// destructing..

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/logger.h>

namespace spdlog {

// Async overflow policy - block by default.
enum class async_overflow_policy
{
    block,         // Block until message can be enqueued
    overrun_oldest // Discard oldest message in the queue if full when trying to
                   // add new item.
};

namespace details {
class thread_pool;
}

class SPDLOG_API async_logger final : public std::enable_shared_from_this<async_logger>, public logger
{
    friend class details::thread_pool;

public:
    template<typename It>
    async_logger(std::string logger_name, It begin, It end, std::weak_ptr<details::thread_pool> tp,
        async_overflow_policy overflow_policy = async_overflow_policy::block)
        : logger(std::move(logger_name), begin, end)
        , thread_pool_(std::move(tp))
        , overflow_policy_(overflow_policy)
    {}

    async_logger(std::string logger_name, sinks_init_list sinks_list, std::weak_ptr<details::thread_pool> tp,
        async_overflow_policy overflow_policy = async_overflow_policy::block);

    async_logger(std::string logger_name, sink_ptr single_sink, std::weak_ptr<details::thread_pool> tp,
        async_overflow_policy overflow_policy = async_overflow_policy::block);

    std::shared_ptr<logger> clone(std::string new_name) override;

protected:
    void sink_it_(const details::log_msg &msg) override;
    void flush_() override;
    void backend_sink_it_(const details::log_msg &incoming_log_msg);
    void backend_flush_();

private:
    std::weak_ptr<details::thread_pool> thread_pool_;
    async_overflow_policy overflow_policy_;
};
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "async_logger-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/cfg/argv.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once
#include <spdlog/cfg/helpers.h>
#include <spdlog/details/registry.h>

//
// Init log levels using each argv entry that starts with "SPDLOG_LEVEL="
//
// set all loggers to debug level:
// example.exe "SPDLOG_LEVEL=debug"

// set logger1 to trace level
// example.exe "SPDLOG_LEVEL=logger1=trace"

// turn off all logging except for logger1 and logger2:
// example.exe "SPDLOG_LEVEL=off,logger1=debug,logger2=info"

namespace spdlog {
namespace cfg {

// search for SPDLOG_LEVEL= in the args and use it to init the levels
inline void load_argv_levels(int argc, const char **argv)
{
    const std::string spdlog_level_prefix = "SPDLOG_LEVEL=";
    for (int i = 1; i < argc; i++)
    {
        std::string arg = argv[i];
        if (arg.find(spdlog_level_prefix) == 0)
        {
            auto levels_string = arg.substr(spdlog_level_prefix.size());
            helpers::load_levels(levels_string);
        }
    }
}

inline void load_argv_levels(int argc, char **argv)
{
    load_argv_levels(argc, const_cast<const char **>(argv));
}

} // namespace cfg
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/cfg/env.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once
#include <spdlog/cfg/helpers.h>
#include <spdlog/details/registry.h>
#include <spdlog/details/os.h>

//
// Init levels and patterns from env variables SPDLOG_LEVEL
// Inspired from Rust's "env_logger" crate (https://crates.io/crates/env_logger).
// Note - fallback to "info" level on unrecognized levels
//
// Examples:
//
// set global level to debug:
// export SPDLOG_LEVEL=debug
//
// turn off all logging except for logger1:
// export SPDLOG_LEVEL="*=off,logger1=debug"
//

// turn off all logging except for logger1 and logger2:
// export SPDLOG_LEVEL="off,logger1=debug,logger2=info"

namespace spdlog {
namespace cfg {
inline void load_env_levels()
{
    auto env_val = details::os::getenv("SPDLOG_LEVEL");
    if (!env_val.empty())
    {
        helpers::load_levels(env_val);
    }
}

} // namespace cfg
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/cfg/helpers-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/cfg/helpers.h>
#endif

#include <spdlog/spdlog.h>
#include <spdlog/details/os.h>
#include <spdlog/details/registry.h>

#include <algorithm>
#include <string>
#include <utility>
#include <sstream>

namespace spdlog {
namespace cfg {
namespace helpers {

// inplace convert to lowercase
inline std::string &to_lower_(std::string &str)
{
    std::transform(
        str.begin(), str.end(), str.begin(), [](char ch) { return static_cast<char>((ch >= 'A' && ch <= 'Z') ? ch + ('a' - 'A') : ch); });
    return str;
}

// inplace trim spaces
inline std::string &trim_(std::string &str)
{
    const char *spaces = " \n\r\t";
    str.erase(str.find_last_not_of(spaces) + 1);
    str.erase(0, str.find_first_not_of(spaces));
    return str;
}

// return (name,value) trimmed pair from given "name=value" string.
// return empty string on missing parts
// "key=val" => ("key", "val")
// " key  =  val " => ("key", "val")
// "key=" => ("key", "")
// "val" => ("", "val")

inline std::pair<std::string, std::string> extract_kv_(char sep, const std::string &str)
{
    auto n = str.find(sep);
    std::string k, v;
    if (n == std::string::npos)
    {
        v = str;
    }
    else
    {
        k = str.substr(0, n);
        v = str.substr(n + 1);
    }
    return std::make_pair(trim_(k), trim_(v));
}

// return vector of key/value pairs from sequence of "K1=V1,K2=V2,.."
// "a=AAA,b=BBB,c=CCC,.." => {("a","AAA"),("b","BBB"),("c", "CCC"),...}
inline std::unordered_map<std::string, std::string> extract_key_vals_(const std::string &str)
{
    std::string token;
    std::istringstream token_stream(str);
    std::unordered_map<std::string, std::string> rv{};
    while (std::getline(token_stream, token, ','))
    {
        if (token.empty())
        {
            continue;
        }
        auto kv = extract_kv_('=', token);
        rv[kv.first] = kv.second;
    }
    return rv;
}

SPDLOG_INLINE void load_levels(const std::string &input)
{
    if (input.empty() || input.size() > 512)
    {
        return;
    }

    auto key_vals = extract_key_vals_(input);
    std::unordered_map<std::string, level::level_enum> levels;
    level::level_enum global_level = level::info;
    bool global_level_found = false;

    for (auto &name_level : key_vals)
    {
        auto &logger_name = name_level.first;
        auto level_name = to_lower_(name_level.second);
        auto level = level::from_str(level_name);
        // ignore unrecognized level names
        if (level == level::off && level_name != "off")
        {
            continue;
        }
        if (logger_name.empty()) // no logger name indicate global level
        {
            global_level_found = true;
            global_level = level;
        }
        else
        {
            levels[logger_name] = level;
        }
    }

    details::registry::instance().set_levels(std::move(levels), global_level_found ? &global_level : nullptr);
}

} // namespace helpers
} // namespace cfg
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/cfg/helpers.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <unordered_map>

namespace spdlog {
namespace cfg {
namespace helpers {
//
// Init levels from given string
//
// Examples:
//
// set global level to debug: "debug"
// turn off all logging except for logger1: "off,logger1=debug"
// turn off all logging except for logger1 and logger2: "off,logger1=debug,logger2=info"
//
SPDLOG_API void load_levels(const std::string &txt);
} // namespace helpers

} // namespace cfg
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "helpers-inl.h"
#endif // SPDLOG_HEADER_ONLY

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/cfg/log_levels.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <string>
#include <unordered_map>

namespace spdlog {
namespace cfg {
class log_levels
{
    std::unordered_map<std::string, spdlog::level::level_enum> levels_;
    spdlog::level::level_enum default_level_ = level::info;

public:
    void set(const std::string &logger_name, level::level_enum lvl)
    {
        if (logger_name.empty())
        {
            default_level_ = lvl;
        }
        else
        {
            levels_[logger_name] = lvl;
        }
    }

    void set_default(level::level_enum lvl)
    {
        default_level_ = lvl;
    }

    level::level_enum get(const std::string &logger_name)
    {
        auto it = levels_.find(logger_name);
        return it != levels_.end() ? it->second : default_level_;
    }

    level::level_enum default_level()
    {
        return default_level_;
    }
};
} // namespace cfg
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/common-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/common.h>
#endif

#include <algorithm>
#include <iterator>

namespace spdlog {
namespace level {

#if __cplusplus >= 201703L
constexpr
#endif
    static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;

static const char *short_level_names[] SPDLOG_SHORT_LEVEL_NAMES;

SPDLOG_INLINE const string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT
{
    return level_string_views[l];
}

SPDLOG_INLINE const char *to_short_c_str(spdlog::level::level_enum l) SPDLOG_NOEXCEPT
{
    return short_level_names[l];
}

SPDLOG_INLINE spdlog::level::level_enum from_str(const std::string &name) SPDLOG_NOEXCEPT
{
    auto it = std::find(std::begin(level_string_views), std::end(level_string_views), name);
    if (it != std::end(level_string_views))
        return static_cast<level::level_enum>(it - std::begin(level_string_views));

    // check also for "warn" and "err" before giving up..
    if (name == "warn")
    {
        return level::warn;
    }
    if (name == "err")
    {
        return level::err;
    }
    return level::off;
}
} // namespace level

SPDLOG_INLINE spdlog_ex::spdlog_ex(std::string msg)
    : msg_(std::move(msg))
{}

SPDLOG_INLINE spdlog_ex::spdlog_ex(const std::string &msg, int last_errno)
{
#ifdef SPDLOG_USE_STD_FORMAT
    msg_ = std::system_error(std::error_code(last_errno, std::generic_category()), msg).what();
#else
    memory_buf_t outbuf;
    fmt::format_system_error(outbuf, last_errno, msg.c_str());
    msg_ = fmt::to_string(outbuf);
#endif
}

SPDLOG_INLINE const char *spdlog_ex::what() const SPDLOG_NOEXCEPT
{
    return msg_.c_str();
}

SPDLOG_INLINE void throw_spdlog_ex(const std::string &msg, int last_errno)
{
    SPDLOG_THROW(spdlog_ex(msg, last_errno));
}

SPDLOG_INLINE void throw_spdlog_ex(std::string msg)
{
    SPDLOG_THROW(spdlog_ex(std::move(msg)));
}

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/common.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#pragma warning(disable:4275)
#endif

#include <spdlog/tweakme.h>
#include <spdlog/details/null_mutex.h>

#include <atomic>
#include <chrono>
#include <initializer_list>
#include <memory>
#include <exception>
#include <string>
#include <type_traits>
#include <functional>
#include <cstdio>

#ifdef SPDLOG_USE_STD_FORMAT
#    include <string_view>
#endif

#ifdef SPDLOG_COMPILED_LIB
#    undef SPDLOG_HEADER_ONLY
#    if defined(SPDLOG_SHARED_LIB)
#        if defined(_WIN32)
#            ifdef spdlog_EXPORTS
#                define SPDLOG_API __declspec(dllexport)
#            else // !spdlog_EXPORTS
#                define SPDLOG_API __declspec(dllimport)
#            endif
#        else // !defined(_WIN32)
#            define SPDLOG_API __attribute__((visibility("default")))
#        endif
#    else // !defined(SPDLOG_SHARED_LIB)
#        define SPDLOG_API
#    endif
#    define SPDLOG_INLINE
#else // !defined(SPDLOG_COMPILED_LIB)
#    define SPDLOG_API
#    define SPDLOG_HEADER_ONLY
#    define SPDLOG_INLINE inline
#endif // #ifdef SPDLOG_COMPILED_LIB

#include <spdlog/fmt/fmt.h>

#if !defined(SPDLOG_USE_STD_FORMAT) && FMT_VERSION >= 80000 // backward compatibility with fmt versions older than 8
#    define SPDLOG_FMT_RUNTIME(format_string) fmt::runtime(format_string)
#    if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)
#        include <spdlog/fmt/xchar.h>
#    endif
#else
#    define SPDLOG_FMT_RUNTIME(format_string) format_string
#endif

// visual studio up to 2013 does not support noexcept nor constexpr
#if defined(_MSC_VER) && (_MSC_VER < 1900)
#    define SPDLOG_NOEXCEPT _NOEXCEPT
#    define SPDLOG_CONSTEXPR
#    define SPDLOG_CONSTEXPR_FUNC
#else
#    define SPDLOG_NOEXCEPT noexcept
#    define SPDLOG_CONSTEXPR constexpr
#    if __cplusplus >= 201402L
#        define SPDLOG_CONSTEXPR_FUNC constexpr
#    else
#        define SPDLOG_CONSTEXPR_FUNC
#    endif
#endif

#if defined(__GNUC__) || defined(__clang__)
#    define SPDLOG_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#    define SPDLOG_DEPRECATED __declspec(deprecated)
#else
#    define SPDLOG_DEPRECATED
#endif

// disable thread local on msvc 2013
#ifndef SPDLOG_NO_TLS
#    if (defined(_MSC_VER) && (_MSC_VER < 1900)) || defined(__cplusplus_winrt)
#        define SPDLOG_NO_TLS 1
#    endif
#endif

#ifndef SPDLOG_FUNCTION
#    define SPDLOG_FUNCTION static_cast<const char *>(__FUNCTION__)
#endif

#ifdef SPDLOG_NO_EXCEPTIONS
#    define SPDLOG_TRY
#    define SPDLOG_THROW(ex)                                                                                                               \
        do                                                                                                                                 \
        {                                                                                                                                  \
            printf("spdlog fatal error: %s\n", ex.what());                                                                                 \
            std::abort();                                                                                                                  \
        } while (0)
#    define SPDLOG_CATCH_STD
#else
#    define SPDLOG_TRY try
#    define SPDLOG_THROW(ex) throw(ex)
#    define SPDLOG_CATCH_STD                                                                                                               \
        catch (const std::exception &) {}
#endif

namespace spdlog {

class formatter;

namespace sinks {
class sink;
}

#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
using filename_t = std::wstring;
// allow macro expansion to occur in SPDLOG_FILENAME_T
#    define SPDLOG_FILENAME_T_INNER(s) L##s
#    define SPDLOG_FILENAME_T(s) SPDLOG_FILENAME_T_INNER(s)
#else
using filename_t = std::string;
#    define SPDLOG_FILENAME_T(s) s
#endif

using log_clock = std::chrono::system_clock;
using sink_ptr = std::shared_ptr<sinks::sink>;
using sinks_init_list = std::initializer_list<sink_ptr>;
using err_handler = std::function<void(const std::string &err_msg)>;
#ifdef SPDLOG_USE_STD_FORMAT
namespace fmt_lib = std;

using string_view_t = std::string_view;
using memory_buf_t = std::string;

template<typename... Args>
using format_string_t = std::string_view;

template<class T, class Char = char>
struct is_convertible_to_basic_format_string : std::integral_constant<bool, std::is_convertible<T, std::basic_string_view<Char>>::value>
{};

#    if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)
using wstring_view_t = std::wstring_view;
using wmemory_buf_t = std::wstring;

template<typename... Args>
using wformat_string_t = std::wstring_view;
#    endif
#    define SPDLOG_BUF_TO_STRING(x) x
#else // use fmt lib instead of std::format
namespace fmt_lib = fmt;

using string_view_t = fmt::basic_string_view<char>;
using memory_buf_t = fmt::basic_memory_buffer<char, 250>;

template<typename... Args>
using format_string_t = fmt::format_string<Args...>;

template<class T>
using remove_cvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

// clang doesn't like SFINAE disabled constructor in std::is_convertible<> so have to repeat the condition from basic_format_string here,
// in addition, fmt::basic_runtime<Char> is only convertible to basic_format_string<Char> but not basic_string_view<Char>
template<class T, class Char = char>
struct is_convertible_to_basic_format_string
    : std::integral_constant<bool,
          std::is_convertible<T, fmt::basic_string_view<Char>>::value || std::is_same<remove_cvref_t<T>, fmt::basic_runtime<Char>>::value>
{};

#    if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)
using wstring_view_t = fmt::basic_string_view<wchar_t>;
using wmemory_buf_t = fmt::basic_memory_buffer<wchar_t, 250>;

template<typename... Args>
using wformat_string_t = fmt::wformat_string<Args...>;
#    endif
#    define SPDLOG_BUF_TO_STRING(x) fmt::to_string(x)
#endif

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
#    ifndef _WIN32
#        error SPDLOG_WCHAR_TO_UTF8_SUPPORT only supported on windows
#    endif // _WIN32
#endif     // SPDLOG_WCHAR_TO_UTF8_SUPPORT

template<class T>
struct is_convertible_to_any_format_string : std::integral_constant<bool, is_convertible_to_basic_format_string<T, char>::value ||
                                                                              is_convertible_to_basic_format_string<T, wchar_t>::value>
{};

#if defined(SPDLOG_NO_ATOMIC_LEVELS)
using level_t = details::null_atomic_int;
#else
using level_t = std::atomic<int>;
#endif

#define SPDLOG_LEVEL_TRACE 0
#define SPDLOG_LEVEL_DEBUG 1
#define SPDLOG_LEVEL_INFO 2
#define SPDLOG_LEVEL_WARN 3
#define SPDLOG_LEVEL_ERROR 4
#define SPDLOG_LEVEL_CRITICAL 5
#define SPDLOG_LEVEL_OFF 6

#if !defined(SPDLOG_ACTIVE_LEVEL)
#    define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_INFO
#endif

// Log level enum
namespace level {
enum level_enum : int
{
    trace = SPDLOG_LEVEL_TRACE,
    debug = SPDLOG_LEVEL_DEBUG,
    info = SPDLOG_LEVEL_INFO,
    warn = SPDLOG_LEVEL_WARN,
    err = SPDLOG_LEVEL_ERROR,
    critical = SPDLOG_LEVEL_CRITICAL,
    off = SPDLOG_LEVEL_OFF,
    n_levels
};

#define SPDLOG_LEVEL_NAME_TRACE spdlog::string_view_t("trace", 5)
#define SPDLOG_LEVEL_NAME_DEBUG spdlog::string_view_t("debug", 5)
#define SPDLOG_LEVEL_NAME_INFO spdlog::string_view_t("info", 4)
#define SPDLOG_LEVEL_NAME_WARNING spdlog::string_view_t("warning", 7)
#define SPDLOG_LEVEL_NAME_ERROR spdlog::string_view_t("error", 5)
#define SPDLOG_LEVEL_NAME_CRITICAL spdlog::string_view_t("critical", 8)
#define SPDLOG_LEVEL_NAME_OFF spdlog::string_view_t("off", 3)

#if !defined(SPDLOG_LEVEL_NAMES)
#    define SPDLOG_LEVEL_NAMES                                                                                                             \
        {                                                                                                                                  \
            SPDLOG_LEVEL_NAME_TRACE, SPDLOG_LEVEL_NAME_DEBUG, SPDLOG_LEVEL_NAME_INFO, SPDLOG_LEVEL_NAME_WARNING, SPDLOG_LEVEL_NAME_ERROR,  \
                SPDLOG_LEVEL_NAME_CRITICAL, SPDLOG_LEVEL_NAME_OFF                                                                          \
        }
#endif

#if !defined(SPDLOG_SHORT_LEVEL_NAMES)

#    define SPDLOG_SHORT_LEVEL_NAMES                                                                                                       \
        {                                                                                                                                  \
            "T", "D", "I", "W", "E", "C", "O"                                                                                              \
        }
#endif

SPDLOG_API const string_view_t &to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;
SPDLOG_API const char *to_short_c_str(spdlog::level::level_enum l) SPDLOG_NOEXCEPT;
SPDLOG_API spdlog::level::level_enum from_str(const std::string &name) SPDLOG_NOEXCEPT;

} // namespace level

//
// Color mode used by sinks with color support.
//
enum class color_mode
{
    always,
    automatic,
    never
};

//
// Pattern time - specific time getting to use for pattern_formatter.
// local time by default
//
enum class pattern_time_type
{
    local, // log localtime
    utc    // log utc
};

//
// Log exception
//
class SPDLOG_API spdlog_ex : public std::exception
{
public:
    explicit spdlog_ex(std::string msg);
    spdlog_ex(const std::string &msg, int last_errno);
    const char *what() const SPDLOG_NOEXCEPT override;

private:
    std::string msg_;
};

[[noreturn]] SPDLOG_API void throw_spdlog_ex(const std::string &msg, int last_errno);
[[noreturn]] SPDLOG_API void throw_spdlog_ex(std::string msg);

struct source_loc
{
    SPDLOG_CONSTEXPR source_loc() = default;
    SPDLOG_CONSTEXPR source_loc(const char *filename_in, int line_in, const char *funcname_in)
        : filename{filename_in}
        , line{line_in}
        , funcname{funcname_in}
    {}

    SPDLOG_CONSTEXPR bool empty() const SPDLOG_NOEXCEPT
    {
        return line == 0;
    }
    const char *filename{nullptr};
    int line{0};
    const char *funcname{nullptr};
};

struct file_event_handlers
{
    std::function<void(const filename_t &filename)> before_open;
    std::function<void(const filename_t &filename, std::FILE *file_stream)> after_open;
    std::function<void(const filename_t &filename, std::FILE *file_stream)> before_close;
    std::function<void(const filename_t &filename)> after_close;
};

namespace details {

// make_unique support for pre c++14

#if __cplusplus >= 201402L // C++14 and beyond
using std::enable_if_t;
using std::make_unique;
#else
template<bool B, class T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args &&... args)
{
    static_assert(!std::is_array<T>::value, "arrays not supported");
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
#endif

// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)
template<typename T, typename U, enable_if_t<!std::is_same<T, U>::value, int> = 0>
constexpr T conditional_static_cast(U value)
{
    return static_cast<T>(value);
}

template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
constexpr T conditional_static_cast(U value)
{
    return value;
}

} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "common-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/backtracer-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/backtracer.h>
#endif
namespace spdlog {
namespace details {
SPDLOG_INLINE backtracer::backtracer(const backtracer &other)
{
    std::lock_guard<std::mutex> lock(other.mutex_);
    enabled_ = other.enabled();
    messages_ = other.messages_;
}

SPDLOG_INLINE backtracer::backtracer(backtracer &&other) SPDLOG_NOEXCEPT
{
    std::lock_guard<std::mutex> lock(other.mutex_);
    enabled_ = other.enabled();
    messages_ = std::move(other.messages_);
}

SPDLOG_INLINE backtracer &backtracer::operator=(backtracer other)
{
    std::lock_guard<std::mutex> lock(mutex_);
    enabled_ = other.enabled();
    messages_ = std::move(other.messages_);
    return *this;
}

SPDLOG_INLINE void backtracer::enable(size_t size)
{
    std::lock_guard<std::mutex> lock{mutex_};
    enabled_.store(true, std::memory_order_relaxed);
    messages_ = circular_q<log_msg_buffer>{size};
}

SPDLOG_INLINE void backtracer::disable()
{
    std::lock_guard<std::mutex> lock{mutex_};
    enabled_.store(false, std::memory_order_relaxed);
}

SPDLOG_INLINE bool backtracer::enabled() const
{
    return enabled_.load(std::memory_order_relaxed);
}

SPDLOG_INLINE void backtracer::push_back(const log_msg &msg)
{
    std::lock_guard<std::mutex> lock{mutex_};
    messages_.push_back(log_msg_buffer{msg});
}

// pop all items in the q and apply the given fun on each of them.
SPDLOG_INLINE void backtracer::foreach_pop(std::function<void(const details::log_msg &)> fun)
{
    std::lock_guard<std::mutex> lock{mutex_};
    while (!messages_.empty())
    {
        auto &front_msg = messages_.front();
        fun(front_msg);
        messages_.pop_front();
    }
}
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/backtracer.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/details/log_msg_buffer.h>
#include <spdlog/details/circular_q.h>

#include <atomic>
#include <mutex>
#include <functional>

// Store log messages in circular buffer.
// Useful for storing debug data in case of error/warning happens.

namespace spdlog {
namespace details {
class SPDLOG_API backtracer
{
    mutable std::mutex mutex_;
    std::atomic<bool> enabled_{false};
    circular_q<log_msg_buffer> messages_;

public:
    backtracer() = default;
    backtracer(const backtracer &other);

    backtracer(backtracer &&other) SPDLOG_NOEXCEPT;
    backtracer &operator=(backtracer other);

    void enable(size_t size);
    void disable();
    bool enabled() const;
    void push_back(const log_msg &msg);

    // pop all items in the q and apply the given fun on each of them.
    void foreach_pop(std::function<void(const details::log_msg &)> fun);
};

} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "backtracer-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/circular_q.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

// circular q view of std::vector.
#pragma once

#include <vector>
#include <cassert>

namespace spdlog {
namespace details {
template<typename T>
class circular_q
{
    size_t max_items_ = 0;
    typename std::vector<T>::size_type head_ = 0;
    typename std::vector<T>::size_type tail_ = 0;
    size_t overrun_counter_ = 0;
    std::vector<T> v_;

public:
    using value_type = T;

    // empty ctor - create a disabled queue with no elements allocated at all
    circular_q() = default;

    explicit circular_q(size_t max_items)
        : max_items_(max_items + 1) // one item is reserved as marker for full q
        , v_(max_items_)
    {}

    circular_q(const circular_q &) = default;
    circular_q &operator=(const circular_q &) = default;

    // move cannot be default,
    // since we need to reset head_, tail_, etc to zero in the moved object
    circular_q(circular_q &&other) SPDLOG_NOEXCEPT
    {
        copy_moveable(std::move(other));
    }

    circular_q &operator=(circular_q &&other) SPDLOG_NOEXCEPT
    {
        copy_moveable(std::move(other));
        return *this;
    }

    // push back, overrun (oldest) item if no room left
    void push_back(T &&item)
    {
        if (max_items_ > 0)
        {
            v_[tail_] = std::move(item);
            tail_ = (tail_ + 1) % max_items_;

            if (tail_ == head_) // overrun last item if full
            {
                head_ = (head_ + 1) % max_items_;
                ++overrun_counter_;
            }
        }
    }

    // Return reference to the front item.
    // If there are no elements in the container, the behavior is undefined.
    const T &front() const
    {
        return v_[head_];
    }

    T &front()
    {
        return v_[head_];
    }

    // Return number of elements actually stored
    size_t size() const
    {
        if (tail_ >= head_)
        {
            return tail_ - head_;
        }
        else
        {
            return max_items_ - (head_ - tail_);
        }
    }

    // Return const reference to item by index.
    // If index is out of range 0…size()-1, the behavior is undefined.
    const T &at(size_t i) const
    {
        assert(i < size());
        return v_[(head_ + i) % max_items_];
    }

    // Pop item from front.
    // If there are no elements in the container, the behavior is undefined.
    void pop_front()
    {
        head_ = (head_ + 1) % max_items_;
    }

    bool empty() const
    {
        return tail_ == head_;
    }

    bool full() const
    {
        // head is ahead of the tail by 1
        if (max_items_ > 0)
        {
            return ((tail_ + 1) % max_items_) == head_;
        }
        return false;
    }

    size_t overrun_counter() const
    {
        return overrun_counter_;
    }

private:
    // copy from other&& and reset it to disabled state
    void copy_moveable(circular_q &&other) SPDLOG_NOEXCEPT
    {
        max_items_ = other.max_items_;
        head_ = other.head_;
        tail_ = other.tail_;
        overrun_counter_ = other.overrun_counter_;
        v_ = std::move(other.v_);

        // put &&other in disabled, but valid state
        other.max_items_ = 0;
        other.head_ = other.tail_ = 0;
        other.overrun_counter_ = 0;
    }
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/console_globals.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/details/null_mutex.h>
#include <mutex>

namespace spdlog {
namespace details {

struct console_mutex
{
    using mutex_t = std::mutex;
    static mutex_t &mutex()
    {
        static mutex_t s_mutex;
        return s_mutex;
    }
};

struct console_nullmutex
{
    using mutex_t = null_mutex;
    static mutex_t &mutex()
    {
        static mutex_t s_mutex;
        return s_mutex;
    }
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/file_helper-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/file_helper.h>
#endif

#include <spdlog/details/os.h>
#include <spdlog/common.h>

#include <cerrno>
#include <chrono>
#include <cstdio>
#include <string>
#include <thread>
#include <tuple>

namespace spdlog {
namespace details {

SPDLOG_INLINE file_helper::file_helper(const file_event_handlers &event_handlers)
    : event_handlers_(event_handlers)
{}

SPDLOG_INLINE file_helper::~file_helper()
{
    close();
}

SPDLOG_INLINE void file_helper::open(const filename_t &fname, bool truncate)
{
    close();
    filename_ = fname;

    auto *mode = SPDLOG_FILENAME_T("ab");
    auto *trunc_mode = SPDLOG_FILENAME_T("wb");

    if (event_handlers_.before_open)
    {
        event_handlers_.before_open(filename_);
    }
    for (int tries = 0; tries < open_tries_; ++tries)
    {
        // create containing folder if not exists already.
        os::create_dir(os::dir_name(fname));
        if (truncate)
        {
            // Truncate by opening-and-closing a tmp file in "wb" mode, always
            // opening the actual log-we-write-to in "ab" mode, since that
            // interacts more politely with eternal processes that might
            // rotate/truncate the file underneath us.
            std::FILE *tmp;
            if (os::fopen_s(&tmp, fname, trunc_mode))
            {
                continue;
            }
            std::fclose(tmp);
        }
        if (!os::fopen_s(&fd_, fname, mode))
        {
            if (event_handlers_.after_open)
            {
                event_handlers_.after_open(filename_, fd_);
            }
            return;
        }

        details::os::sleep_for_millis(open_interval_);
    }

    throw_spdlog_ex("Failed opening file " + os::filename_to_str(filename_) + " for writing", errno);
}

SPDLOG_INLINE void file_helper::reopen(bool truncate)
{
    if (filename_.empty())
    {
        throw_spdlog_ex("Failed re opening file - was not opened before");
    }
    this->open(filename_, truncate);
}

SPDLOG_INLINE void file_helper::flush()
{
    if (std::fflush(fd_) != 0)
    {
        throw_spdlog_ex("Failed flush to file " + os::filename_to_str(filename_), errno);
    }
}

SPDLOG_INLINE void file_helper::close()
{
    if (fd_ != nullptr)
    {
        if (event_handlers_.before_close)
        {
            event_handlers_.before_close(filename_, fd_);
        }

        std::fclose(fd_);
        fd_ = nullptr;

        if (event_handlers_.after_close)
        {
            event_handlers_.after_close(filename_);
        }
    }
}

SPDLOG_INLINE void file_helper::write(const memory_buf_t &buf)
{
    size_t msg_size = buf.size();
    auto data = buf.data();
    if (std::fwrite(data, 1, msg_size, fd_) != msg_size)
    {
        throw_spdlog_ex("Failed writing to file " + os::filename_to_str(filename_), errno);
    }
}

SPDLOG_INLINE size_t file_helper::size() const
{
    if (fd_ == nullptr)
    {
        throw_spdlog_ex("Cannot use size() on closed file " + os::filename_to_str(filename_));
    }
    return os::filesize(fd_);
}

SPDLOG_INLINE const filename_t &file_helper::filename() const
{
    return filename_;
}

//
// return file path and its extension:
//
// "mylog.txt" => ("mylog", ".txt")
// "mylog" => ("mylog", "")
// "mylog." => ("mylog.", "")
// "/dir1/dir2/mylog.txt" => ("/dir1/dir2/mylog", ".txt")
//
// the starting dot in filenames is ignored (hidden files):
//
// ".mylog" => (".mylog". "")
// "my_folder/.mylog" => ("my_folder/.mylog", "")
// "my_folder/.mylog.txt" => ("my_folder/.mylog", ".txt")
SPDLOG_INLINE std::tuple<filename_t, filename_t> file_helper::split_by_extension(const filename_t &fname)
{
    auto ext_index = fname.rfind('.');

    // no valid extension found - return whole path and empty string as
    // extension
    if (ext_index == filename_t::npos || ext_index == 0 || ext_index == fname.size() - 1)
    {
        return std::make_tuple(fname, filename_t());
    }

    // treat cases like "/etc/rc.d/somelogfile or "/abc/.hiddenfile"
    auto folder_index = fname.find_last_of(details::os::folder_seps_filename);
    if (folder_index != filename_t::npos && folder_index >= ext_index - 1)
    {
        return std::make_tuple(fname, filename_t());
    }

    // finally - return a valid base and extension tuple
    return std::make_tuple(fname.substr(0, ext_index), fname.substr(ext_index));
}

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/file_helper.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/common.h>
#include <tuple>

namespace spdlog {
namespace details {

// Helper class for file sinks.
// When failing to open a file, retry several times(5) with a delay interval(10 ms).
// Throw spdlog_ex exception on errors.

class SPDLOG_API file_helper
{
public:
    file_helper() = default;
    explicit file_helper(const file_event_handlers &event_handlers);

    file_helper(const file_helper &) = delete;
    file_helper &operator=(const file_helper &) = delete;
    ~file_helper();

    void open(const filename_t &fname, bool truncate = false);
    void reopen(bool truncate);
    void flush();
    void close();
    void write(const memory_buf_t &buf);
    size_t size() const;
    const filename_t &filename() const;

    //
    // return file path and its extension:
    //
    // "mylog.txt" => ("mylog", ".txt")
    // "mylog" => ("mylog", "")
    // "mylog." => ("mylog.", "")
    // "/dir1/dir2/mylog.txt" => ("/dir1/dir2/mylog", ".txt")
    //
    // the starting dot in filenames is ignored (hidden files):
    //
    // ".mylog" => (".mylog". "")
    // "my_folder/.mylog" => ("my_folder/.mylog", "")
    // "my_folder/.mylog.txt" => ("my_folder/.mylog", ".txt")
    static std::tuple<filename_t, filename_t> split_by_extension(const filename_t &fname);

private:
    const int open_tries_ = 5;
    const unsigned int open_interval_ = 10;
    std::FILE *fd_{nullptr};
    filename_t filename_;
    file_event_handlers event_handlers_;
};
} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "file_helper-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/fmt_helper.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
#pragma once

#include <chrono>
#include <type_traits>
#include <iterator>
#include <spdlog/fmt/fmt.h>
#include <spdlog/common.h>

#ifdef SPDLOG_USE_STD_FORMAT
#    include <charconv>
#    include <limits>
#endif

// Some fmt helpers to efficiently format and pad ints and strings
namespace spdlog {
namespace details {
namespace fmt_helper {

inline spdlog::string_view_t to_string_view(const memory_buf_t &buf) SPDLOG_NOEXCEPT
{
    return spdlog::string_view_t{buf.data(), buf.size()};
}

inline void append_string_view(spdlog::string_view_t view, memory_buf_t &dest)
{
    auto *buf_ptr = view.data();
    dest.append(buf_ptr, buf_ptr + view.size());
}

#ifdef SPDLOG_USE_STD_FORMAT
template<typename T>
inline void append_int(T n, memory_buf_t &dest)
{
    // Buffer should be large enough to hold all digits (digits10 + 1) and a sign
    SPDLOG_CONSTEXPR const auto BUF_SIZE = std::numeric_limits<T>::digits10 + 2;
    char buf[BUF_SIZE];

    auto [ptr, ec] = std::to_chars(buf, buf + BUF_SIZE, n, 10);
    if (ec == std::errc())
    {
        dest.append(buf, ptr);
    }
    else
    {
        throw_spdlog_ex("Failed to format int", static_cast<int>(ec));
    }
}
#else
template<typename T>
inline void append_int(T n, memory_buf_t &dest)
{
    fmt::format_int i(n);
    dest.append(i.data(), i.data() + i.size());
}
#endif

template<typename T>
SPDLOG_CONSTEXPR_FUNC unsigned int count_digits_fallback(T n)
{
    // taken from fmt: https://github.com/fmtlib/fmt/blob/8.0.1/include/fmt/format.h#L899-L912
    unsigned int count = 1;
    for (;;)
    {
        // Integer division is slow so do it for a group of four digits instead
        // of for every digit. The idea comes from the talk by Alexandrescu
        // "Three Optimization Tips for C++". See speed-test for a comparison.
        if (n < 10)
            return count;
        if (n < 100)
            return count + 1;
        if (n < 1000)
            return count + 2;
        if (n < 10000)
            return count + 3;
        n /= 10000u;
        count += 4;
    }
}

template<typename T>
inline unsigned int count_digits(T n)
{
    using count_type = typename std::conditional<(sizeof(T) > sizeof(uint32_t)), uint64_t, uint32_t>::type;
#ifdef SPDLOG_USE_STD_FORMAT
    return count_digits_fallback(static_cast<count_type>(n));
#else
    return static_cast<unsigned int>(fmt::
// fmt 7.0.0 renamed the internal namespace to detail.
// See: https://github.com/fmtlib/fmt/issues/1538
#    if FMT_VERSION < 70000
            internal
#    else
            detail
#    endif
        ::count_digits(static_cast<count_type>(n)));
#endif
}

inline void pad2(int n, memory_buf_t &dest)
{
    if (n >= 0 && n < 100) // 0-99
    {
        dest.push_back(static_cast<char>('0' + n / 10));
        dest.push_back(static_cast<char>('0' + n % 10));
    }
    else // unlikely, but just in case, let fmt deal with it
    {
        fmt_lib::format_to(std::back_inserter(dest), "{:02}", n);
    }
}

template<typename T>
inline void pad_uint(T n, unsigned int width, memory_buf_t &dest)
{
    static_assert(std::is_unsigned<T>::value, "pad_uint must get unsigned T");
    for (auto digits = count_digits(n); digits < width; digits++)
    {
        dest.push_back('0');
    }
    append_int(n, dest);
}

template<typename T>
inline void pad3(T n, memory_buf_t &dest)
{
    static_assert(std::is_unsigned<T>::value, "pad3 must get unsigned T");
    if (n < 1000)
    {
        dest.push_back(static_cast<char>(n / 100 + '0'));
        n = n % 100;
        dest.push_back(static_cast<char>((n / 10) + '0'));
        dest.push_back(static_cast<char>((n % 10) + '0'));
    }
    else
    {
        append_int(n, dest);
    }
}

template<typename T>
inline void pad6(T n, memory_buf_t &dest)
{
    pad_uint(n, 6, dest);
}

template<typename T>
inline void pad9(T n, memory_buf_t &dest)
{
    pad_uint(n, 9, dest);
}

// return fraction of a second of the given time_point.
// e.g.
// fraction<std::milliseconds>(tp) -> will return the millis part of the second
template<typename ToDuration>
inline ToDuration time_fraction(log_clock::time_point tp)
{
    using std::chrono::duration_cast;
    using std::chrono::seconds;
    auto duration = tp.time_since_epoch();
    auto secs = duration_cast<seconds>(duration);
    return duration_cast<ToDuration>(duration) - duration_cast<ToDuration>(secs);
}

} // namespace fmt_helper
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/log_msg-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/log_msg.h>
#endif

#include <spdlog/details/os.h>

namespace spdlog {
namespace details {

SPDLOG_INLINE log_msg::log_msg(spdlog::log_clock::time_point log_time, spdlog::source_loc loc, string_view_t a_logger_name,
    spdlog::level::level_enum lvl, spdlog::string_view_t msg)
    : logger_name(a_logger_name)
    , level(lvl)
    , time(log_time)
#ifndef SPDLOG_NO_THREAD_ID
    , thread_id(os::thread_id())
#endif
    , source(loc)
    , payload(msg)
{}

SPDLOG_INLINE log_msg::log_msg(
    spdlog::source_loc loc, string_view_t a_logger_name, spdlog::level::level_enum lvl, spdlog::string_view_t msg)
    : log_msg(os::now(), loc, a_logger_name, lvl, msg)
{}

SPDLOG_INLINE log_msg::log_msg(string_view_t a_logger_name, spdlog::level::level_enum lvl, spdlog::string_view_t msg)
    : log_msg(os::now(), source_loc{}, a_logger_name, lvl, msg)
{}

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/log_msg.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/common.h>
#include <string>

namespace spdlog {
namespace details {
struct SPDLOG_API log_msg
{
    log_msg() = default;
    log_msg(log_clock::time_point log_time, source_loc loc, string_view_t logger_name, level::level_enum lvl, string_view_t msg);
    log_msg(source_loc loc, string_view_t logger_name, level::level_enum lvl, string_view_t msg);
    log_msg(string_view_t logger_name, level::level_enum lvl, string_view_t msg);
    log_msg(const log_msg &other) = default;
    log_msg &operator=(const log_msg &other) = default;

    string_view_t logger_name;
    level::level_enum level{level::off};
    log_clock::time_point time;
    size_t thread_id{0};

    // wrapping the formatted text with color (updated by pattern_formatter).
    mutable size_t color_range_start{0};
    mutable size_t color_range_end{0};

    source_loc source;
    string_view_t payload;
};
} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "log_msg-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/log_msg_buffer-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/log_msg_buffer.h>
#endif

namespace spdlog {
namespace details {

SPDLOG_INLINE log_msg_buffer::log_msg_buffer(const log_msg &orig_msg)
    : log_msg{orig_msg}
{
    buffer.append(logger_name.begin(), logger_name.end());
    buffer.append(payload.begin(), payload.end());
    update_string_views();
}

SPDLOG_INLINE log_msg_buffer::log_msg_buffer(const log_msg_buffer &other)
    : log_msg{other}
{
    buffer.append(logger_name.begin(), logger_name.end());
    buffer.append(payload.begin(), payload.end());
    update_string_views();
}

SPDLOG_INLINE log_msg_buffer::log_msg_buffer(log_msg_buffer &&other) SPDLOG_NOEXCEPT : log_msg{other}, buffer{std::move(other.buffer)}
{
    update_string_views();
}

SPDLOG_INLINE log_msg_buffer &log_msg_buffer::operator=(const log_msg_buffer &other)
{
    log_msg::operator=(other);
    buffer.clear();
    buffer.append(other.buffer.data(), other.buffer.data() + other.buffer.size());
    update_string_views();
    return *this;
}

SPDLOG_INLINE log_msg_buffer &log_msg_buffer::operator=(log_msg_buffer &&other) SPDLOG_NOEXCEPT
{
    log_msg::operator=(other);
    buffer = std::move(other.buffer);
    update_string_views();
    return *this;
}

SPDLOG_INLINE void log_msg_buffer::update_string_views()
{
    logger_name = string_view_t{buffer.data(), logger_name.size()};
    payload = string_view_t{buffer.data() + logger_name.size(), payload.size()};
}

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/log_msg_buffer.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/details/log_msg.h>

namespace spdlog {
namespace details {

// Extend log_msg with internal buffer to store its payload.
// This is needed since log_msg holds string_views that points to stack data.

class SPDLOG_API log_msg_buffer : public log_msg
{
    memory_buf_t buffer;
    void update_string_views();

public:
    log_msg_buffer() = default;
    explicit log_msg_buffer(const log_msg &orig_msg);
    log_msg_buffer(const log_msg_buffer &other);
    log_msg_buffer(log_msg_buffer &&other) SPDLOG_NOEXCEPT;
    log_msg_buffer &operator=(const log_msg_buffer &other);
    log_msg_buffer &operator=(log_msg_buffer &&other) SPDLOG_NOEXCEPT;
};

} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "log_msg_buffer-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/mpmc_blocking_q.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// multi producer-multi consumer blocking queue.
// enqueue(..) - will block until room found to put the new message.
// enqueue_nowait(..) - will return immediately with false if no room left in
// the queue.
// dequeue_for(..) - will block until the queue is not empty or timeout have
// passed.

#include <spdlog/details/circular_q.h>

#include <condition_variable>
#include <mutex>

namespace spdlog {
namespace details {

template<typename T>
class mpmc_blocking_queue
{
public:
    using item_type = T;
    explicit mpmc_blocking_queue(size_t max_items)
        : q_(max_items)
    {}

#ifndef __MINGW32__
    // try to enqueue and block if no room left
    void enqueue(T &&item)
    {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            pop_cv_.wait(lock, [this] { return !this->q_.full(); });
            q_.push_back(std::move(item));
        }
        push_cv_.notify_one();
    }

    // enqueue immediately. overrun oldest message in the queue if no room left.
    void enqueue_nowait(T &&item)
    {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            q_.push_back(std::move(item));
        }
        push_cv_.notify_one();
    }

    // try to dequeue item. if no item found. wait up to timeout and try again
    // Return true, if succeeded dequeue item, false otherwise
    bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)
    {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (!push_cv_.wait_for(lock, wait_duration, [this] { return !this->q_.empty(); }))
            {
                return false;
            }
            popped_item = std::move(q_.front());
            q_.pop_front();
        }
        pop_cv_.notify_one();
        return true;
    }

#else
    // apparently mingw deadlocks if the mutex is released before cv.notify_one(),
    // so release the mutex at the very end each function.

    // try to enqueue and block if no room left
    void enqueue(T &&item)
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        pop_cv_.wait(lock, [this] { return !this->q_.full(); });
        q_.push_back(std::move(item));
        push_cv_.notify_one();
    }

    // enqueue immediately. overrun oldest message in the queue if no room left.
    void enqueue_nowait(T &&item)
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        q_.push_back(std::move(item));
        push_cv_.notify_one();
    }

    // try to dequeue item. if no item found. wait up to timeout and try again
    // Return true, if succeeded dequeue item, false otherwise
    bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        if (!push_cv_.wait_for(lock, wait_duration, [this] { return !this->q_.empty(); }))
        {
            return false;
        }
        popped_item = std::move(q_.front());
        q_.pop_front();
        pop_cv_.notify_one();
        return true;
    }

#endif

    size_t overrun_counter()
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        return q_.overrun_counter();
    }

    size_t size()
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        return q_.size();
    }

private:
    std::mutex queue_mutex_;
    std::condition_variable push_cv_;
    std::condition_variable pop_cv_;
    spdlog::details::circular_q<T> q_;
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/null_mutex.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <atomic>
#include <utility>
// null, no cost dummy "mutex" and dummy "atomic" int

namespace spdlog {
namespace details {
struct null_mutex
{
    void lock() const {}
    void unlock() const {}
    bool try_lock() const
    {
        return true;
    }
};

struct null_atomic_int
{
    int value;
    null_atomic_int() = default;

    explicit null_atomic_int(int new_value)
        : value(new_value)
    {}

    int load(std::memory_order = std::memory_order_relaxed) const
    {
        return value;
    }

    void store(int new_value, std::memory_order = std::memory_order_relaxed)
    {
        value = new_value;
    }

    int exchange(int new_value, std::memory_order = std::memory_order_relaxed)
    {
        std::swap(new_value, value);
        return new_value; // return value before the call
    }
};

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/os-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/os.h>
#endif

#include <spdlog/common.h>

#include <algorithm>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <string>
#include <thread>
#include <array>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef _WIN32

#    include <io.h>      // _get_osfhandle and _isatty support
#    include <process.h> //  _get_pid support
#    include <spdlog/details/windows_include.h>

#    ifdef __MINGW32__
#        include <share.h>
#    endif

#    if defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)
#        include <limits>
#    endif

#    include <direct.h> // for _mkdir/_wmkdir

#else // unix

#    include <fcntl.h>
#    include <unistd.h>

#    ifdef __linux__
#        include <sys/syscall.h> //Use gettid() syscall under linux to get thread id

#    elif defined(_AIX)
#        include <pthread.h> // for pthread_getthrds_np

#    elif defined(__DragonFly__) || defined(__FreeBSD__)
#        include <pthread_np.h> // for pthread_getthreadid_np

#    elif defined(__NetBSD__)
#        include <lwp.h> // for _lwp_self

#    elif defined(__sun)
#        include <thread.h> // for thr_self
#    endif

#endif // unix

#ifndef __has_feature          // Clang - feature checking macros.
#    define __has_feature(x) 0 // Compatibility with non-clang compilers.
#endif

namespace spdlog {
namespace details {
namespace os {

SPDLOG_INLINE spdlog::log_clock::time_point now() SPDLOG_NOEXCEPT
{

#if defined __linux__ && defined SPDLOG_CLOCK_COARSE
    timespec ts;
    ::clock_gettime(CLOCK_REALTIME_COARSE, &ts);
    return std::chrono::time_point<log_clock, typename log_clock::duration>(
        std::chrono::duration_cast<typename log_clock::duration>(std::chrono::seconds(ts.tv_sec) + std::chrono::nanoseconds(ts.tv_nsec)));

#else
    return log_clock::now();
#endif
}
SPDLOG_INLINE std::tm localtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    std::tm tm;
    ::localtime_s(&tm, &time_tt);
#else
    std::tm tm;
    ::localtime_r(&time_tt, &tm);
#endif
    return tm;
}

SPDLOG_INLINE std::tm localtime() SPDLOG_NOEXCEPT
{
    std::time_t now_t = ::time(nullptr);
    return localtime(now_t);
}

SPDLOG_INLINE std::tm gmtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    std::tm tm;
    ::gmtime_s(&tm, &time_tt);
#else
    std::tm tm;
    ::gmtime_r(&time_tt, &tm);
#endif
    return tm;
}

SPDLOG_INLINE std::tm gmtime() SPDLOG_NOEXCEPT
{
    std::time_t now_t = ::time(nullptr);
    return gmtime(now_t);
}

// fopen_s on non windows for writing
SPDLOG_INLINE bool fopen_s(FILE **fp, const filename_t &filename, const filename_t &mode)
{
#ifdef _WIN32
#    ifdef SPDLOG_WCHAR_FILENAMES
    *fp = ::_wfsopen((filename.c_str()), mode.c_str(), _SH_DENYNO);
#    else
    *fp = ::_fsopen((filename.c_str()), mode.c_str(), _SH_DENYNO);
#    endif
#    if defined(SPDLOG_PREVENT_CHILD_FD)
    if (*fp != nullptr)
    {
        auto file_handle = reinterpret_cast<HANDLE>(_get_osfhandle(::_fileno(*fp)));
        if (!::SetHandleInformation(file_handle, HANDLE_FLAG_INHERIT, 0))
        {
            ::fclose(*fp);
            *fp = nullptr;
        }
    }
#    endif
#else // unix
#    if defined(SPDLOG_PREVENT_CHILD_FD)
    const int mode_flag = mode == SPDLOG_FILENAME_T("ab") ? O_APPEND : O_TRUNC;
    const int fd = ::open((filename.c_str()), O_CREAT | O_WRONLY | O_CLOEXEC | mode_flag, mode_t(0644));
    if (fd == -1)
    {
        return true;
    }
    *fp = ::fdopen(fd, mode.c_str());
    if (*fp == nullptr)
    {
        ::close(fd);
    }
#    else
    *fp = ::fopen((filename.c_str()), mode.c_str());
#    endif
#endif

    return *fp == nullptr;
}

SPDLOG_INLINE int remove(const filename_t &filename) SPDLOG_NOEXCEPT
{
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
    return ::_wremove(filename.c_str());
#else
    return std::remove(filename.c_str());
#endif
}

SPDLOG_INLINE int remove_if_exists(const filename_t &filename) SPDLOG_NOEXCEPT
{
    return path_exists(filename) ? remove(filename) : 0;
}

SPDLOG_INLINE int rename(const filename_t &filename1, const filename_t &filename2) SPDLOG_NOEXCEPT
{
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
    return ::_wrename(filename1.c_str(), filename2.c_str());
#else
    return std::rename(filename1.c_str(), filename2.c_str());
#endif
}

// Return true if path exists (file or directory)
SPDLOG_INLINE bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT
{
#ifdef _WIN32
#    ifdef SPDLOG_WCHAR_FILENAMES
    auto attribs = ::GetFileAttributesW(filename.c_str());
#    else
    auto attribs = ::GetFileAttributesA(filename.c_str());
#    endif
    return attribs != INVALID_FILE_ATTRIBUTES;
#else // common linux/unix all have the stat system call
    struct stat buffer;
    return (::stat(filename.c_str(), &buffer) == 0);
#endif
}

#ifdef _MSC_VER
// avoid warning about unreachable statement at the end of filesize()
#    pragma warning(push)
#    pragma warning(disable : 4702)
#endif

// Return file size according to open FILE* object
SPDLOG_INLINE size_t filesize(FILE *f)
{
    if (f == nullptr)
    {
        throw_spdlog_ex("Failed getting file size. fd is null");
    }
#if defined(_WIN32) && !defined(__CYGWIN__)
    int fd = ::_fileno(f);
#    if defined(_WIN64) // 64 bits
    __int64 ret = ::_filelengthi64(fd);
    if (ret >= 0)
    {
        return static_cast<size_t>(ret);
    }

#    else // windows 32 bits
    long ret = ::_filelength(fd);
    if (ret >= 0)
    {
        return static_cast<size_t>(ret);
    }
#    endif

#else // unix
// OpenBSD and AIX doesn't compile with :: before the fileno(..)
#    if defined(__OpenBSD__) || defined(_AIX)
    int fd = fileno(f);
#    else
    int fd = ::fileno(f);
#    endif
// 64 bits(but not in osx or cygwin, where fstat64 is deprecated)
#    if (defined(__linux__) || defined(__sun) || defined(_AIX)) && (defined(__LP64__) || defined(_LP64))
    struct stat64 st;
    if (::fstat64(fd, &st) == 0)
    {
        return static_cast<size_t>(st.st_size);
    }
#    else // other unix or linux 32 bits or cygwin
    struct stat st;
    if (::fstat(fd, &st) == 0)
    {
        return static_cast<size_t>(st.st_size);
    }
#    endif
#endif
    throw_spdlog_ex("Failed getting file size from fd", errno);
    return 0; // will not be reached.
}

#ifdef _MSC_VER
#    pragma warning(pop)
#endif

// Return utc offset in minutes or throw spdlog_ex on failure
SPDLOG_INLINE int utc_minutes_offset(const std::tm &tm)
{

#ifdef _WIN32
#    if _WIN32_WINNT < _WIN32_WINNT_WS08
    TIME_ZONE_INFORMATION tzinfo;
    auto rv = ::GetTimeZoneInformation(&tzinfo);
#    else
    DYNAMIC_TIME_ZONE_INFORMATION tzinfo;
    auto rv = ::GetDynamicTimeZoneInformation(&tzinfo);
#    endif
    if (rv == TIME_ZONE_ID_INVALID)
        throw_spdlog_ex("Failed getting timezone info. ", errno);

    int offset = -tzinfo.Bias;
    if (tm.tm_isdst)
    {
        offset -= tzinfo.DaylightBias;
    }
    else
    {
        offset -= tzinfo.StandardBias;
    }
    return offset;
#else

#    if defined(sun) || defined(__sun) || defined(_AIX) || (!defined(_BSD_SOURCE) && !defined(_GNU_SOURCE))
    // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris
    struct helper
    {
        static long int calculate_gmt_offset(const std::tm &localtm = details::os::localtime(), const std::tm &gmtm = details::os::gmtime())
        {
            int local_year = localtm.tm_year + (1900 - 1);
            int gmt_year = gmtm.tm_year + (1900 - 1);

            long int days = (
                // difference in day of year
                localtm.tm_yday -
                gmtm.tm_yday

                // + intervening leap days
                + ((local_year >> 2) - (gmt_year >> 2)) - (local_year / 100 - gmt_year / 100) +
                ((local_year / 100 >> 2) - (gmt_year / 100 >> 2))

                // + difference in years * 365 */
                + static_cast<long int>(local_year - gmt_year) * 365);

            long int hours = (24 * days) + (localtm.tm_hour - gmtm.tm_hour);
            long int mins = (60 * hours) + (localtm.tm_min - gmtm.tm_min);
            long int secs = (60 * mins) + (localtm.tm_sec - gmtm.tm_sec);

            return secs;
        }
    };

    auto offset_seconds = helper::calculate_gmt_offset(tm);
#    else
    auto offset_seconds = tm.tm_gmtoff;
#    endif

    return static_cast<int>(offset_seconds / 60);
#endif
}

// Return current thread id as size_t
// It exists because the std::this_thread::get_id() is much slower(especially
// under VS 2013)
SPDLOG_INLINE size_t _thread_id() SPDLOG_NOEXCEPT
{
#ifdef _WIN32
    return static_cast<size_t>(::GetCurrentThreadId());
#elif defined(__linux__)
#    if defined(__ANDROID__) && defined(__ANDROID_API__) && (__ANDROID_API__ < 21)
#        define SYS_gettid __NR_gettid
#    endif
    return static_cast<size_t>(::syscall(SYS_gettid));
#elif defined(_AIX)
    struct __pthrdsinfo buf;
    int reg_size = 0;
    pthread_t pt = pthread_self();
    int retval = pthread_getthrds_np(&pt, PTHRDSINFO_QUERY_TID, &buf, sizeof(buf), NULL, &reg_size);
    int tid = (!retval) ? buf.__pi_tid : 0;
    return static_cast<size_t>(tid);
#elif defined(__DragonFly__) || defined(__FreeBSD__)
    return static_cast<size_t>(::pthread_getthreadid_np());
#elif defined(__NetBSD__)
    return static_cast<size_t>(::_lwp_self());
#elif defined(__OpenBSD__)
    return static_cast<size_t>(::getthrid());
#elif defined(__sun)
    return static_cast<size_t>(::thr_self());
#elif __APPLE__
    uint64_t tid;
    pthread_threadid_np(nullptr, &tid);
    return static_cast<size_t>(tid);
#else // Default to standard C++11 (other Unix)
    return static_cast<size_t>(std::hash<std::thread::id>()(std::this_thread::get_id()));
#endif
}

// Return current thread id as size_t (from thread local storage)
SPDLOG_INLINE size_t thread_id() SPDLOG_NOEXCEPT
{
#if defined(SPDLOG_NO_TLS)
    return _thread_id();
#else // cache thread id in tls
    static thread_local const size_t tid = _thread_id();
    return tid;
#endif
}

// This is avoid msvc issue in sleep_for that happens if the clock changes.
// See https://github.com/gabime/spdlog/issues/609
SPDLOG_INLINE void sleep_for_millis(unsigned int milliseconds) SPDLOG_NOEXCEPT
{
#if defined(_WIN32)
    ::Sleep(milliseconds);
#else
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
#endif
}

// wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
SPDLOG_INLINE std::string filename_to_str(const filename_t &filename)
{
    memory_buf_t buf;
    wstr_to_utf8buf(filename, buf);
    return SPDLOG_BUF_TO_STRING(buf);
}
#else
SPDLOG_INLINE std::string filename_to_str(const filename_t &filename)
{
    return filename;
}
#endif

SPDLOG_INLINE int pid() SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    return conditional_static_cast<int>(::GetCurrentProcessId());
#else
    return conditional_static_cast<int>(::getpid());
#endif
}

// Determine if the terminal supports colors
// Based on: https://github.com/agauniyal/rang/
SPDLOG_INLINE bool is_color_terminal() SPDLOG_NOEXCEPT
{
#ifdef _WIN32
    return true;
#else

    static const bool result = []() {
        const char *env_colorterm_p = std::getenv("COLORTERM");
        if (env_colorterm_p != nullptr)
        {
            return true;
        }

        static constexpr std::array<const char *, 16> terms = {{"ansi", "color", "console", "cygwin", "gnome", "konsole", "kterm", "linux",
            "msys", "putty", "rxvt", "screen", "vt100", "xterm", "alacritty", "vt102"}};

        const char *env_term_p = std::getenv("TERM");
        if (env_term_p == nullptr)
        {
            return false;
        }

        return std::any_of(terms.begin(), terms.end(), [&](const char *term) { return std::strstr(env_term_p, term) != nullptr; });
    }();

    return result;
#endif
}

// Determine if the terminal attached
// Source: https://github.com/agauniyal/rang/
SPDLOG_INLINE bool in_terminal(FILE *file) SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    return ::_isatty(_fileno(file)) != 0;
#else
    return ::isatty(fileno(file)) != 0;
#endif
}

#if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)
SPDLOG_INLINE void wstr_to_utf8buf(wstring_view_t wstr, memory_buf_t &target)
{
    if (wstr.size() > static_cast<size_t>((std::numeric_limits<int>::max)()) / 2 - 1)
    {
        throw_spdlog_ex("UTF-16 string is too big to be converted to UTF-8");
    }

    int wstr_size = static_cast<int>(wstr.size());
    if (wstr_size == 0)
    {
        target.resize(0);
        return;
    }

    int result_size = static_cast<int>(target.capacity());
    if ((wstr_size + 1) * 2 > result_size)
    {
        result_size = ::WideCharToMultiByte(CP_UTF8, 0, wstr.data(), wstr_size, NULL, 0, NULL, NULL);
    }

    if (result_size > 0)
    {
        target.resize(result_size);
        result_size = ::WideCharToMultiByte(CP_UTF8, 0, wstr.data(), wstr_size, target.data(), result_size, NULL, NULL);

        if (result_size > 0)
        {
            target.resize(result_size);
            return;
        }
    }

    throw_spdlog_ex(fmt_lib::format("WideCharToMultiByte failed. Last error: {}", ::GetLastError()));
}

SPDLOG_INLINE void utf8_to_wstrbuf(string_view_t str, wmemory_buf_t &target)
{
    if (str.size() > static_cast<size_t>((std::numeric_limits<int>::max)()) - 1)
    {
        throw_spdlog_ex("UTF-8 string is too big to be converted to UTF-16");
    }

    int str_size = static_cast<int>(str.size());
    if (str_size == 0)
    {
        target.resize(0);
        return;
    }

    int result_size = static_cast<int>(target.capacity());
    if (str_size + 1 > result_size)
    {
        result_size = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size, NULL, 0);
    }

    if (result_size > 0)
    {
        target.resize(result_size);
        result_size = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size, target.data(), result_size);

        if (result_size > 0)
        {
            target.resize(result_size);
            return;
        }
    }

    throw_spdlog_ex(fmt_lib::format("MultiByteToWideChar failed. Last error: {}", ::GetLastError()));
}
#endif // (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)

// return true on success
static SPDLOG_INLINE bool mkdir_(const filename_t &path)
{
#ifdef _WIN32
#    ifdef SPDLOG_WCHAR_FILENAMES
    return ::_wmkdir(path.c_str()) == 0;
#    else
    return ::_mkdir(path.c_str()) == 0;
#    endif
#else
    return ::mkdir(path.c_str(), mode_t(0755)) == 0;
#endif
}

// create the given directory - and all directories leading to it
// return true on success or if the directory already exists
SPDLOG_INLINE bool create_dir(const filename_t &path)
{
    if (path_exists(path))
    {
        return true;
    }

    if (path.empty())
    {
        return false;
    }

    size_t search_offset = 0;
    do
    {
        auto token_pos = path.find_first_of(folder_seps_filename, search_offset);
        // treat the entire path as a folder if no folder separator not found
        if (token_pos == filename_t::npos)
        {
            token_pos = path.size();
        }

        auto subdir = path.substr(0, token_pos);

        if (!subdir.empty() && !path_exists(subdir) && !mkdir_(subdir))
        {
            return false; // return error if failed creating dir
        }
        search_offset = token_pos + 1;
    } while (search_offset < path.size());

    return true;
}

// Return directory name from given path or empty string
// "abc/file" => "abc"
// "abc/" => "abc"
// "abc" => ""
// "abc///" => "abc//"
SPDLOG_INLINE filename_t dir_name(const filename_t &path)
{
    auto pos = path.find_last_of(folder_seps_filename);
    return pos != filename_t::npos ? path.substr(0, pos) : filename_t{};
}

std::string SPDLOG_INLINE getenv(const char *field)
{

#if defined(_MSC_VER)
#    if defined(__cplusplus_winrt)
    return std::string{}; // not supported under uwp
#    else
    size_t len = 0;
    char buf[128];
    bool ok = ::getenv_s(&len, buf, sizeof(buf), field) == 0;
    return ok ? buf : std::string{};
#    endif
#else // revert to getenv
    char *buf = ::getenv(field);
    return buf ? buf : std::string{};
#endif
}

} // namespace os
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/os.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <ctime> // std::time_t

namespace spdlog {
namespace details {
namespace os {

SPDLOG_API spdlog::log_clock::time_point now() SPDLOG_NOEXCEPT;

SPDLOG_API std::tm localtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT;

SPDLOG_API std::tm localtime() SPDLOG_NOEXCEPT;

SPDLOG_API std::tm gmtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT;

SPDLOG_API std::tm gmtime() SPDLOG_NOEXCEPT;

// eol definition
#if !defined(SPDLOG_EOL)
#    ifdef _WIN32
#        define SPDLOG_EOL "\r\n"
#    else
#        define SPDLOG_EOL "\n"
#    endif
#endif

SPDLOG_CONSTEXPR static const char *default_eol = SPDLOG_EOL;

// folder separator
#if !defined(SPDLOG_FOLDER_SEPS)
#    ifdef _WIN32
#        define SPDLOG_FOLDER_SEPS "\\/"
#    else
#        define SPDLOG_FOLDER_SEPS "/"
#    endif
#endif

SPDLOG_CONSTEXPR static const char folder_seps[] = SPDLOG_FOLDER_SEPS;
SPDLOG_CONSTEXPR static const filename_t::value_type folder_seps_filename[] = SPDLOG_FILENAME_T(SPDLOG_FOLDER_SEPS);

// fopen_s on non windows for writing
SPDLOG_API bool fopen_s(FILE **fp, const filename_t &filename, const filename_t &mode);

// Remove filename. return 0 on success
SPDLOG_API int remove(const filename_t &filename) SPDLOG_NOEXCEPT;

// Remove file if exists. return 0 on success
// Note: Non atomic (might return failure to delete if concurrently deleted by other process/thread)
SPDLOG_API int remove_if_exists(const filename_t &filename) SPDLOG_NOEXCEPT;

SPDLOG_API int rename(const filename_t &filename1, const filename_t &filename2) SPDLOG_NOEXCEPT;

// Return if file exists.
SPDLOG_API bool path_exists(const filename_t &filename) SPDLOG_NOEXCEPT;

// Return file size according to open FILE* object
SPDLOG_API size_t filesize(FILE *f);

// Return utc offset in minutes or throw spdlog_ex on failure
SPDLOG_API int utc_minutes_offset(const std::tm &tm = details::os::localtime());

// Return current thread id as size_t
// It exists because the std::this_thread::get_id() is much slower(especially
// under VS 2013)
SPDLOG_API size_t _thread_id() SPDLOG_NOEXCEPT;

// Return current thread id as size_t (from thread local storage)
SPDLOG_API size_t thread_id() SPDLOG_NOEXCEPT;

// This is avoid msvc issue in sleep_for that happens if the clock changes.
// See https://github.com/gabime/spdlog/issues/609
SPDLOG_API void sleep_for_millis(unsigned int milliseconds) SPDLOG_NOEXCEPT;

SPDLOG_API std::string filename_to_str(const filename_t &filename);

SPDLOG_API int pid() SPDLOG_NOEXCEPT;

// Determine if the terminal supports colors
// Source: https://github.com/agauniyal/rang/
SPDLOG_API bool is_color_terminal() SPDLOG_NOEXCEPT;

// Determine if the terminal attached
// Source: https://github.com/agauniyal/rang/
SPDLOG_API bool in_terminal(FILE *file) SPDLOG_NOEXCEPT;

#if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)
SPDLOG_API void wstr_to_utf8buf(wstring_view_t wstr, memory_buf_t &target);

SPDLOG_API void utf8_to_wstrbuf(string_view_t str, wmemory_buf_t &target);
#endif

// Return directory name from given path or empty string
// "abc/file" => "abc"
// "abc/" => "abc"
// "abc" => ""
// "abc///" => "abc//"
SPDLOG_API filename_t dir_name(const filename_t &path);

// Create a dir from the given path.
// Return true if succeeded or if this dir already exists.
SPDLOG_API bool create_dir(const filename_t &path);

// non thread safe, cross platform getenv/getenv_s
// return empty string if field not found
SPDLOG_API std::string getenv(const char *field);

} // namespace os
} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "os-inl.h"
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/periodic_worker-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/periodic_worker.h>
#endif

namespace spdlog {
namespace details {

SPDLOG_INLINE periodic_worker::periodic_worker(const std::function<void()> &callback_fun, std::chrono::seconds interval)
{
    active_ = (interval > std::chrono::seconds::zero());
    if (!active_)
    {
        return;
    }

    worker_thread_ = std::thread([this, callback_fun, interval]() {
        for (;;)
        {
            std::unique_lock<std::mutex> lock(this->mutex_);
            if (this->cv_.wait_for(lock, interval, [this] { return !this->active_; }))
            {
                return; // active_ == false, so exit this thread
            }
            callback_fun();
        }
    });
}

// stop the worker thread and join it
SPDLOG_INLINE periodic_worker::~periodic_worker()
{
    if (worker_thread_.joinable())
    {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            active_ = false;
        }
        cv_.notify_one();
        worker_thread_.join();
    }
}

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/periodic_worker.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// periodic worker thread - periodically executes the given callback function.
//
// RAII over the owned thread:
//    creates the thread on construction.
//    stops and joins the thread on destruction (if the thread is executing a callback, wait for it to finish first).

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <chrono>
#include <condition_variable>
#include <functional>
#include <mutex>
#include <thread>
namespace spdlog {
namespace details {

class SPDLOG_API periodic_worker
{
public:
    periodic_worker(const std::function<void()> &callback_fun, std::chrono::seconds interval);
    periodic_worker(const periodic_worker &) = delete;
    periodic_worker &operator=(const periodic_worker &) = delete;
    // stop the worker thread and join it
    ~periodic_worker();

private:
    bool active_;
    std::thread worker_thread_;
    std::mutex mutex_;
    std::condition_variable cv_;
};
} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "periodic_worker-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/registry-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/registry.h>
#endif

#include <spdlog/common.h>
#include <spdlog/details/periodic_worker.h>
#include <spdlog/logger.h>
#include <spdlog/pattern_formatter.h>

#ifndef SPDLOG_DISABLE_DEFAULT_LOGGER
// support for the default stdout color logger
#    ifdef _WIN32
#        include <spdlog/sinks/wincolor_sink.h>
#    else
#        include <spdlog/sinks/ansicolor_sink.h>
#    endif
#endif // SPDLOG_DISABLE_DEFAULT_LOGGER

#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include <unordered_map>

namespace spdlog {
namespace details {

SPDLOG_INLINE registry::registry()
    : formatter_(new pattern_formatter())
{

#ifndef SPDLOG_DISABLE_DEFAULT_LOGGER
    // create default logger (ansicolor_stdout_sink_mt or wincolor_stdout_sink_mt in windows).
#    ifdef _WIN32
    auto color_sink = std::make_shared<sinks::wincolor_stdout_sink_mt>();
#    else
    auto color_sink = std::make_shared<sinks::ansicolor_stdout_sink_mt>();
#    endif

    const char *default_logger_name = "";
    default_logger_ = std::make_shared<spdlog::logger>(default_logger_name, std::move(color_sink));
    loggers_[default_logger_name] = default_logger_;

#endif // SPDLOG_DISABLE_DEFAULT_LOGGER
}

SPDLOG_INLINE registry::~registry() = default;

SPDLOG_INLINE void registry::register_logger(std::shared_ptr<logger> new_logger)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    register_logger_(std::move(new_logger));
}

SPDLOG_INLINE void registry::initialize_logger(std::shared_ptr<logger> new_logger)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    new_logger->set_formatter(formatter_->clone());

    if (err_handler_)
    {
        new_logger->set_error_handler(err_handler_);
    }

    // set new level according to previously configured level or default level
    auto it = log_levels_.find(new_logger->name());
    auto new_level = it != log_levels_.end() ? it->second : global_log_level_;
    new_logger->set_level(new_level);

    new_logger->flush_on(flush_level_);

    if (backtrace_n_messages_ > 0)
    {
        new_logger->enable_backtrace(backtrace_n_messages_);
    }

    if (automatic_registration_)
    {
        register_logger_(std::move(new_logger));
    }
}

SPDLOG_INLINE std::shared_ptr<logger> registry::get(const std::string &logger_name)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    auto found = loggers_.find(logger_name);
    return found == loggers_.end() ? nullptr : found->second;
}

SPDLOG_INLINE std::shared_ptr<logger> registry::default_logger()
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    return default_logger_;
}

// Return raw ptr to the default logger.
// To be used directly by the spdlog default api (e.g. spdlog::info)
// This make the default API faster, but cannot be used concurrently with set_default_logger().
// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.
SPDLOG_INLINE logger *registry::get_default_raw()
{
    return default_logger_.get();
}

// set default logger.
// default logger is stored in default_logger_ (for faster retrieval) and in the loggers_ map.
SPDLOG_INLINE void registry::set_default_logger(std::shared_ptr<logger> new_default_logger)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    // remove previous default logger from the map
    if (default_logger_ != nullptr)
    {
        loggers_.erase(default_logger_->name());
    }
    if (new_default_logger != nullptr)
    {
        loggers_[new_default_logger->name()] = new_default_logger;
    }
    default_logger_ = std::move(new_default_logger);
}

SPDLOG_INLINE void registry::set_tp(std::shared_ptr<thread_pool> tp)
{
    std::lock_guard<std::recursive_mutex> lock(tp_mutex_);
    tp_ = std::move(tp);
}

SPDLOG_INLINE std::shared_ptr<thread_pool> registry::get_tp()
{
    std::lock_guard<std::recursive_mutex> lock(tp_mutex_);
    return tp_;
}

// Set global formatter. Each sink in each logger will get a clone of this object
SPDLOG_INLINE void registry::set_formatter(std::unique_ptr<formatter> formatter)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    formatter_ = std::move(formatter);
    for (auto &l : loggers_)
    {
        l.second->set_formatter(formatter_->clone());
    }
}

SPDLOG_INLINE void registry::enable_backtrace(size_t n_messages)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    backtrace_n_messages_ = n_messages;

    for (auto &l : loggers_)
    {
        l.second->enable_backtrace(n_messages);
    }
}

SPDLOG_INLINE void registry::disable_backtrace()
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    backtrace_n_messages_ = 0;
    for (auto &l : loggers_)
    {
        l.second->disable_backtrace();
    }
}

SPDLOG_INLINE void registry::set_level(level::level_enum log_level)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    for (auto &l : loggers_)
    {
        l.second->set_level(log_level);
    }
    global_log_level_ = log_level;
}

SPDLOG_INLINE void registry::flush_on(level::level_enum log_level)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    for (auto &l : loggers_)
    {
        l.second->flush_on(log_level);
    }
    flush_level_ = log_level;
}

SPDLOG_INLINE void registry::flush_every(std::chrono::seconds interval)
{
    std::lock_guard<std::mutex> lock(flusher_mutex_);
    auto clbk = [this]() { this->flush_all(); };
    periodic_flusher_ = details::make_unique<periodic_worker>(clbk, interval);
}

SPDLOG_INLINE void registry::set_error_handler(err_handler handler)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    for (auto &l : loggers_)
    {
        l.second->set_error_handler(handler);
    }
    err_handler_ = std::move(handler);
}

SPDLOG_INLINE void registry::apply_all(const std::function<void(const std::shared_ptr<logger>)> &fun)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    for (auto &l : loggers_)
    {
        fun(l.second);
    }
}

SPDLOG_INLINE void registry::flush_all()
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    for (auto &l : loggers_)
    {
        l.second->flush();
    }
}

SPDLOG_INLINE void registry::drop(const std::string &logger_name)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    loggers_.erase(logger_name);
    if (default_logger_ && default_logger_->name() == logger_name)
    {
        default_logger_.reset();
    }
}

SPDLOG_INLINE void registry::drop_all()
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    loggers_.clear();
    default_logger_.reset();
}

// clean all resources and threads started by the registry
SPDLOG_INLINE void registry::shutdown()
{
    {
        std::lock_guard<std::mutex> lock(flusher_mutex_);
        periodic_flusher_.reset();
    }

    drop_all();

    {
        std::lock_guard<std::recursive_mutex> lock(tp_mutex_);
        tp_.reset();
    }
}

SPDLOG_INLINE std::recursive_mutex &registry::tp_mutex()
{
    return tp_mutex_;
}

SPDLOG_INLINE void registry::set_automatic_registration(bool automatic_registration)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    automatic_registration_ = automatic_registration;
}

SPDLOG_INLINE void registry::set_levels(log_levels levels, level::level_enum *global_level)
{
    std::lock_guard<std::mutex> lock(logger_map_mutex_);
    log_levels_ = std::move(levels);
    auto global_level_requested = global_level != nullptr;
    global_log_level_ = global_level_requested ? *global_level : global_log_level_;

    for (auto &logger : loggers_)
    {
        auto logger_entry = log_levels_.find(logger.first);
        if (logger_entry != log_levels_.end())
        {
            logger.second->set_level(logger_entry->second);
        }
        else if (global_level_requested)
        {
            logger.second->set_level(*global_level);
        }
    }
}

SPDLOG_INLINE registry &registry::instance()
{
    static registry s_instance;
    return s_instance;
}

SPDLOG_INLINE void registry::throw_if_exists_(const std::string &logger_name)
{
    if (loggers_.find(logger_name) != loggers_.end())
    {
        throw_spdlog_ex("logger with name '" + logger_name + "' already exists");
    }
}

SPDLOG_INLINE void registry::register_logger_(std::shared_ptr<logger> new_logger)
{
    auto logger_name = new_logger->name();
    throw_if_exists_(logger_name);
    loggers_[logger_name] = std::move(new_logger);
}

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/registry.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// Loggers registry of unique name->logger pointer
// An attempt to create a logger with an already existing name will result with spdlog_ex exception.
// If user requests a non existing logger, nullptr will be returned
// This class is thread safe

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/common.h>

#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include <unordered_map>
#include <mutex>

namespace spdlog {
class logger;

namespace details {
class thread_pool;
class periodic_worker;

class SPDLOG_API registry
{
public:
    using log_levels = std::unordered_map<std::string, level::level_enum>;
    registry(const registry &) = delete;
    registry &operator=(const registry &) = delete;

    void register_logger(std::shared_ptr<logger> new_logger);
    void initialize_logger(std::shared_ptr<logger> new_logger);
    std::shared_ptr<logger> get(const std::string &logger_name);
    std::shared_ptr<logger> default_logger();

    // Return raw ptr to the default logger.
    // To be used directly by the spdlog default api (e.g. spdlog::info)
    // This make the default API faster, but cannot be used concurrently with set_default_logger().
    // e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.
    logger *get_default_raw();

    // set default logger.
    // default logger is stored in default_logger_ (for faster retrieval) and in the loggers_ map.
    void set_default_logger(std::shared_ptr<logger> new_default_logger);

    void set_tp(std::shared_ptr<thread_pool> tp);

    std::shared_ptr<thread_pool> get_tp();

    // Set global formatter. Each sink in each logger will get a clone of this object
    void set_formatter(std::unique_ptr<formatter> formatter);

    void enable_backtrace(size_t n_messages);

    void disable_backtrace();

    void set_level(level::level_enum log_level);

    void flush_on(level::level_enum log_level);

    void flush_every(std::chrono::seconds interval);

    void set_error_handler(err_handler handler);

    void apply_all(const std::function<void(const std::shared_ptr<logger>)> &fun);

    void flush_all();

    void drop(const std::string &logger_name);

    void drop_all();

    // clean all resources and threads started by the registry
    void shutdown();

    std::recursive_mutex &tp_mutex();

    void set_automatic_registration(bool automatic_registration);

    // set levels for all existing/future loggers. global_level can be null if should not set.
    void set_levels(log_levels levels, level::level_enum *global_level);

    static registry &instance();

private:
    registry();
    ~registry();

    void throw_if_exists_(const std::string &logger_name);
    void register_logger_(std::shared_ptr<logger> new_logger);
    bool set_level_from_cfg_(logger *logger);
    std::mutex logger_map_mutex_, flusher_mutex_;
    std::recursive_mutex tp_mutex_;
    std::unordered_map<std::string, std::shared_ptr<logger>> loggers_;
    log_levels log_levels_;
    std::unique_ptr<formatter> formatter_;
    spdlog::level::level_enum global_log_level_ = level::info;
    level::level_enum flush_level_ = level::off;
    err_handler err_handler_;
    std::shared_ptr<thread_pool> tp_;
    std::unique_ptr<periodic_worker> periodic_flusher_;
    std::shared_ptr<logger> default_logger_;
    bool automatic_registration_ = true;
    size_t backtrace_n_messages_ = 0;
};

} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "registry-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/synchronous_factory.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include "registry.h"

namespace spdlog {

// Default logger factory-  creates synchronous loggers
class logger;

struct synchronous_factory
{
    template<typename Sink, typename... SinkArgs>
    static std::shared_ptr<spdlog::logger> create(std::string logger_name, SinkArgs &&... args)
    {
        auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);
        auto new_logger = std::make_shared<spdlog::logger>(std::move(logger_name), std::move(sink));
        details::registry::instance().initialize_logger(new_logger);
        return new_logger;
    }
};
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/tcp_client-windows.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#define WIN32_LEAN_AND_MEAN
// tcp client helper
#include <spdlog/common.h>
#include <spdlog/details/os.h>

#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>

#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Mswsock.lib")
#pragma comment(lib, "AdvApi32.lib")

namespace spdlog {
namespace details {
class tcp_client
{
    SOCKET socket_ = INVALID_SOCKET;

    static void init_winsock_()
    {
        WSADATA wsaData;
        auto rv = WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (rv != 0)
        {
            throw_winsock_error_("WSAStartup failed", ::WSAGetLastError());
        }
    }

    static void throw_winsock_error_(const std::string &msg, int last_error)
    {
        char buf[512];
        ::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, last_error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, (sizeof(buf) / sizeof(char)), NULL);

        throw_spdlog_ex(fmt_lib::format("tcp_sink - {}: {}", msg, buf));
    }

public:
    tcp_client()
    {
        init_winsock_();
    }

    ~tcp_client()
    {
        close();
        ::WSACleanup();
    }

    bool is_connected() const
    {
        return socket_ != INVALID_SOCKET;
    }

    void close()
    {
        ::closesocket(socket_);
        socket_ = INVALID_SOCKET;
    }

    SOCKET fd() const
    {
        return socket_;
    }

    // try to connect or throw on failure
    void connect(const std::string &host, int port)
    {
        if (is_connected())
        {
            close();
        }
        struct addrinfo hints
        {};
        ZeroMemory(&hints, sizeof(hints));

        hints.ai_family = AF_INET;       // IPv4
        hints.ai_socktype = SOCK_STREAM; // TCP
        hints.ai_flags = AI_NUMERICSERV; // port passed as as numeric value
        hints.ai_protocol = 0;

        auto port_str = std::to_string(port);
        struct addrinfo *addrinfo_result;
        auto rv = ::getaddrinfo(host.c_str(), port_str.c_str(), &hints, &addrinfo_result);
        int last_error = 0;
        if (rv != 0)
        {
            last_error = ::WSAGetLastError();
            WSACleanup();
            throw_winsock_error_("getaddrinfo failed", last_error);
        }

        // Try each address until we successfully connect(2).

        for (auto *rp = addrinfo_result; rp != nullptr; rp = rp->ai_next)
        {
            socket_ = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
            if (socket_ == INVALID_SOCKET)
            {
                last_error = ::WSAGetLastError();
                WSACleanup();
                continue;
            }
            if (::connect(socket_, rp->ai_addr, (int)rp->ai_addrlen) == 0)
            {
                break;
            }
            else
            {
                last_error = ::WSAGetLastError();
                close();
            }
        }
        ::freeaddrinfo(addrinfo_result);
        if (socket_ == INVALID_SOCKET)
        {
            WSACleanup();
            throw_winsock_error_("connect failed", last_error);
        }

        // set TCP_NODELAY
        int enable_flag = 1;
        ::setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char *>(&enable_flag), sizeof(enable_flag));
    }

    // Send exactly n_bytes of the given data.
    // On error close the connection and throw.
    void send(const char *data, size_t n_bytes)
    {
        size_t bytes_sent = 0;
        while (bytes_sent < n_bytes)
        {
            const int send_flags = 0;
            auto write_result = ::send(socket_, data + bytes_sent, (int)(n_bytes - bytes_sent), send_flags);
            if (write_result == SOCKET_ERROR)
            {
                int last_error = ::WSAGetLastError();
                close();
                throw_winsock_error_("send failed", last_error);
            }

            if (write_result == 0) // (probably should not happen but in any case..)
            {
                break;
            }
            bytes_sent += static_cast<size_t>(write_result);
        }
    }
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/tcp_client.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifdef _WIN32
#    error include tcp_client-windows.h instead
#endif

// tcp client helper
#include <spdlog/common.h>
#include <spdlog/details/os.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/tcp.h>

#include <string>

namespace spdlog {
namespace details {
class tcp_client
{
    int socket_ = -1;

public:
    bool is_connected() const
    {
        return socket_ != -1;
    }

    void close()
    {
        if (is_connected())
        {
            ::close(socket_);
            socket_ = -1;
        }
    }

    int fd() const
    {
        return socket_;
    }

    ~tcp_client()
    {
        close();
    }

    // try to connect or throw on failure
    void connect(const std::string &host, int port)
    {
        close();
        struct addrinfo hints
        {};
        memset(&hints, 0, sizeof(struct addrinfo));
        hints.ai_family = AF_INET;       // IPv4
        hints.ai_socktype = SOCK_STREAM; // TCP
        hints.ai_flags = AI_NUMERICSERV; // port passed as as numeric value
        hints.ai_protocol = 0;

        auto port_str = std::to_string(port);
        struct addrinfo *addrinfo_result;
        auto rv = ::getaddrinfo(host.c_str(), port_str.c_str(), &hints, &addrinfo_result);
        if (rv != 0)
        {
            throw_spdlog_ex(fmt_lib::format("::getaddrinfo failed: {}", gai_strerror(rv)));
        }

        // Try each address until we successfully connect(2).
        int last_errno = 0;
        for (auto *rp = addrinfo_result; rp != nullptr; rp = rp->ai_next)
        {
#if defined(SOCK_CLOEXEC)
            const int flags = SOCK_CLOEXEC;
#else
            const int flags = 0;
#endif
            socket_ = ::socket(rp->ai_family, rp->ai_socktype | flags, rp->ai_protocol);
            if (socket_ == -1)
            {
                last_errno = errno;
                continue;
            }
            rv = ::connect(socket_, rp->ai_addr, rp->ai_addrlen);
            if (rv == 0)
            {
                break;
            }
            last_errno = errno;
            ::close(socket_);
            socket_ = -1;
        }
        ::freeaddrinfo(addrinfo_result);
        if (socket_ == -1)
        {
            throw_spdlog_ex("::connect failed", last_errno);
        }

        // set TCP_NODELAY
        int enable_flag = 1;
        ::setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char *>(&enable_flag), sizeof(enable_flag));

        // prevent sigpipe on systems where MSG_NOSIGNAL is not available
#if defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL)
        ::setsockopt(socket_, SOL_SOCKET, SO_NOSIGPIPE, reinterpret_cast<char *>(&enable_flag), sizeof(enable_flag));
#endif

#if !defined(SO_NOSIGPIPE) && !defined(MSG_NOSIGNAL)
#    error "tcp_sink would raise SIGPIPE since niether SO_NOSIGPIPE nor MSG_NOSIGNAL are available"
#endif
    }

    // Send exactly n_bytes of the given data.
    // On error close the connection and throw.
    void send(const char *data, size_t n_bytes)
    {
        size_t bytes_sent = 0;
        while (bytes_sent < n_bytes)
        {
#if defined(MSG_NOSIGNAL)
            const int send_flags = MSG_NOSIGNAL;
#else
            const int send_flags = 0;
#endif
            auto write_result = ::send(socket_, data + bytes_sent, n_bytes - bytes_sent, send_flags);
            if (write_result < 0)
            {
                close();
                throw_spdlog_ex("write(2) failed", errno);
            }

            if (write_result == 0) // (probably should not happen but in any case..)
            {
                break;
            }
            bytes_sent += static_cast<size_t>(write_result);
        }
    }
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/thread_pool-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/details/thread_pool.h>
#endif

#include <spdlog/common.h>
#include <cassert>

namespace spdlog {
namespace details {

SPDLOG_INLINE thread_pool::thread_pool(
    size_t q_max_items, size_t threads_n, std::function<void()> on_thread_start, std::function<void()> on_thread_stop)
    : q_(q_max_items)
{
    if (threads_n == 0 || threads_n > 1000)
    {
        throw_spdlog_ex("spdlog::thread_pool(): invalid threads_n param (valid "
                        "range is 1-1000)");
    }
    for (size_t i = 0; i < threads_n; i++)
    {
        threads_.emplace_back([this, on_thread_start, on_thread_stop] {
            on_thread_start();
            this->thread_pool::worker_loop_();
            on_thread_stop();
        });
    }
}

SPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items, size_t threads_n, std::function<void()> on_thread_start)
    : thread_pool(q_max_items, threads_n, on_thread_start, [] {})
{}

SPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items, size_t threads_n)
    : thread_pool(
          q_max_items, threads_n, [] {}, [] {})
{}

// message all threads to terminate gracefully join them
SPDLOG_INLINE thread_pool::~thread_pool()
{
    SPDLOG_TRY
    {
        for (size_t i = 0; i < threads_.size(); i++)
        {
            post_async_msg_(async_msg(async_msg_type::terminate), async_overflow_policy::block);
        }

        for (auto &t : threads_)
        {
            t.join();
        }
    }
    SPDLOG_CATCH_STD
}

void SPDLOG_INLINE thread_pool::post_log(async_logger_ptr &&worker_ptr, const details::log_msg &msg, async_overflow_policy overflow_policy)
{
    async_msg async_m(std::move(worker_ptr), async_msg_type::log, msg);
    post_async_msg_(std::move(async_m), overflow_policy);
}

void SPDLOG_INLINE thread_pool::post_flush(async_logger_ptr &&worker_ptr, async_overflow_policy overflow_policy)
{
    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush), overflow_policy);
}

size_t SPDLOG_INLINE thread_pool::overrun_counter()
{
    return q_.overrun_counter();
}

size_t SPDLOG_INLINE thread_pool::queue_size()
{
    return q_.size();
}

void SPDLOG_INLINE thread_pool::post_async_msg_(async_msg &&new_msg, async_overflow_policy overflow_policy)
{
    if (overflow_policy == async_overflow_policy::block)
    {
        q_.enqueue(std::move(new_msg));
    }
    else
    {
        q_.enqueue_nowait(std::move(new_msg));
    }
}

void SPDLOG_INLINE thread_pool::worker_loop_()
{
    while (process_next_msg_()) {}
}

// process next message in the queue
// return true if this thread should still be active (while no terminate msg
// was received)
bool SPDLOG_INLINE thread_pool::process_next_msg_()
{
    async_msg incoming_async_msg;
    bool dequeued = q_.dequeue_for(incoming_async_msg, std::chrono::seconds(10));
    if (!dequeued)
    {
        return true;
    }

    switch (incoming_async_msg.msg_type)
    {
    case async_msg_type::log: {
        incoming_async_msg.worker_ptr->backend_sink_it_(incoming_async_msg);
        return true;
    }
    case async_msg_type::flush: {
        incoming_async_msg.worker_ptr->backend_flush_();
        return true;
    }

    case async_msg_type::terminate: {
        return false;
    }

    default: {
        assert(false);
    }
    }

    return true;
}

} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/thread_pool.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/details/log_msg_buffer.h>
#include <spdlog/details/mpmc_blocking_q.h>
#include <spdlog/details/os.h>

#include <chrono>
#include <memory>
#include <thread>
#include <vector>
#include <functional>

namespace spdlog {
class async_logger;

namespace details {

using async_logger_ptr = std::shared_ptr<spdlog::async_logger>;

enum class async_msg_type
{
    log,
    flush,
    terminate
};

// Async msg to move to/from the queue
// Movable only. should never be copied
struct async_msg : log_msg_buffer
{
    async_msg_type msg_type{async_msg_type::log};
    async_logger_ptr worker_ptr;

    async_msg() = default;
    ~async_msg() = default;

    // should only be moved in or out of the queue..
    async_msg(const async_msg &) = delete;

// support for vs2013 move
#if defined(_MSC_VER) && _MSC_VER <= 1800
    async_msg(async_msg &&other)
        : log_msg_buffer(std::move(other))
        , msg_type(other.msg_type)
        , worker_ptr(std::move(other.worker_ptr))
    {}

    async_msg &operator=(async_msg &&other)
    {
        *static_cast<log_msg_buffer *>(this) = std::move(other);
        msg_type = other.msg_type;
        worker_ptr = std::move(other.worker_ptr);
        return *this;
    }
#else // (_MSC_VER) && _MSC_VER <= 1800
    async_msg(async_msg &&) = default;
    async_msg &operator=(async_msg &&) = default;
#endif

    // construct from log_msg with given type
    async_msg(async_logger_ptr &&worker, async_msg_type the_type, const details::log_msg &m)
        : log_msg_buffer{m}
        , msg_type{the_type}
        , worker_ptr{std::move(worker)}
    {}

    async_msg(async_logger_ptr &&worker, async_msg_type the_type)
        : log_msg_buffer{}
        , msg_type{the_type}
        , worker_ptr{std::move(worker)}
    {}

    explicit async_msg(async_msg_type the_type)
        : async_msg{nullptr, the_type}
    {}
};

class SPDLOG_API thread_pool
{
public:
    using item_type = async_msg;
    using q_type = details::mpmc_blocking_queue<item_type>;

    thread_pool(size_t q_max_items, size_t threads_n, std::function<void()> on_thread_start, std::function<void()> on_thread_stop);
    thread_pool(size_t q_max_items, size_t threads_n, std::function<void()> on_thread_start);
    thread_pool(size_t q_max_items, size_t threads_n);

    // message all threads to terminate gracefully and join them
    ~thread_pool();

    thread_pool(const thread_pool &) = delete;
    thread_pool &operator=(thread_pool &&) = delete;

    void post_log(async_logger_ptr &&worker_ptr, const details::log_msg &msg, async_overflow_policy overflow_policy);
    void post_flush(async_logger_ptr &&worker_ptr, async_overflow_policy overflow_policy);
    size_t overrun_counter();
    size_t queue_size();

private:
    q_type q_;

    std::vector<std::thread> threads_;

    void post_async_msg_(async_msg &&new_msg, async_overflow_policy overflow_policy);
    void worker_loop_();

    // process next message in the queue
    // return true if this thread should still be active (while no terminate msg
    // was received)
    bool process_next_msg_();
};

} // namespace details
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "thread_pool-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/udp_client-windows.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// Helper RAII over winsock udp client socket.
// Will throw on construction if socket creation failed.

#include <spdlog/common.h>
#include <spdlog/details/os.h>
#include <spdlog/details/windows_include.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>

#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Mswsock.lib")
#pragma comment(lib, "AdvApi32.lib")

namespace spdlog {
namespace details {
class udp_client
{
    static constexpr int TX_BUFFER_SIZE = 1024 * 10;
    SOCKET socket_ = INVALID_SOCKET;
    sockaddr_in addr_ = {0};

    static void init_winsock_()
    {
        WSADATA wsaData;
        auto rv = ::WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (rv != 0)
        {
            throw_winsock_error_("WSAStartup failed", ::WSAGetLastError());
        }
    }

    static void throw_winsock_error_(const std::string &msg, int last_error)
    {
        char buf[512];
        ::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, last_error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, (sizeof(buf) / sizeof(char)), NULL);

        throw_spdlog_ex(fmt_lib::format("udp_sink - {}: {}", msg, buf));
    }

    void cleanup_()
    {
        if (socket_ != INVALID_SOCKET)
        {
            ::closesocket(socket_);
        }
        socket_ = INVALID_SOCKET;
        ::WSACleanup();
    }

public:
    udp_client(const std::string &host, uint16_t port)
    {
        init_winsock_();

        addr_.sin_family = PF_INET;
        addr_.sin_port = htons(port);
        addr_.sin_addr.s_addr = INADDR_ANY;
        if (InetPtonA(PF_INET, host.c_str(), &addr_.sin_addr.s_addr) != 1)
        {
            int last_error = ::WSAGetLastError();
            ::WSACleanup();
            throw_winsock_error_("error: Invalid address!", last_error);
        }

        socket_ = ::socket(PF_INET, SOCK_DGRAM, 0);
        if (socket_ == INVALID_SOCKET)
        {
            int last_error = ::WSAGetLastError();
            ::WSACleanup();
            throw_winsock_error_("error: Create Socket failed", last_error);
        }

        int option_value = TX_BUFFER_SIZE;
        if (::setsockopt(socket_, SOL_SOCKET, SO_SNDBUF, reinterpret_cast<const char *>(&option_value), sizeof(option_value)) < 0)
        {
            int last_error = ::WSAGetLastError();
            cleanup_();
            throw_winsock_error_("error: setsockopt(SO_SNDBUF) Failed!", last_error);
        }
    }

    ~udp_client()
    {
        cleanup_();
    }

    SOCKET fd() const
    {
        return socket_;
    }

    void send(const char *data, size_t n_bytes)
    {
        socklen_t tolen = sizeof(struct sockaddr);
        if (::sendto(socket_, data, static_cast<int>(n_bytes), 0, (struct sockaddr *)&addr_, tolen) == -1)
        {
            throw_spdlog_ex("sendto(2) failed", errno);
        }
    }
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/udp_client.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// Helper RAII over unix udp client socket.
// Will throw on construction if the socket creation failed.

#ifdef _WIN32
#    error "include udp_client-windows.h instead"
#endif

#include <spdlog/common.h>
#include <spdlog/details/os.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/udp.h>

#include <string>

namespace spdlog {
namespace details {

class udp_client
{
    static constexpr int TX_BUFFER_SIZE = 1024 * 10;
    int socket_ = -1;
    struct sockaddr_in sockAddr_;

    void cleanup_()
    {
        if (socket_ != -1)
        {
            ::close(socket_);
            socket_ = -1;
        }
    }

public:
    udp_client(const std::string &host, uint16_t port)
    {
        socket_ = ::socket(PF_INET, SOCK_DGRAM, 0);
        if (socket_ < 0)
        {
            throw_spdlog_ex("error: Create Socket Failed!");
        }

        int option_value = TX_BUFFER_SIZE;
        if (::setsockopt(socket_, SOL_SOCKET, SO_SNDBUF, reinterpret_cast<const char *>(&option_value), sizeof(option_value)) < 0)
        {
            cleanup_();
            throw_spdlog_ex("error: setsockopt(SO_SNDBUF) Failed!");
        }

        sockAddr_.sin_family = AF_INET;
        sockAddr_.sin_port = htons(port);

        if (::inet_aton(host.c_str(), &sockAddr_.sin_addr) == 0)
        {
            cleanup_();
            throw_spdlog_ex("error: Invalid address!");
        }

        ::memset(sockAddr_.sin_zero, 0x00, sizeof(sockAddr_.sin_zero));
    }

    ~udp_client()
    {
        cleanup_();
    }

    int fd() const
    {
        return socket_;
    }

    // Send exactly n_bytes of the given data.
    // On error close the connection and throw.
    void send(const char *data, size_t n_bytes)
    {
        ssize_t toslen = 0;
        socklen_t tolen = sizeof(struct sockaddr);
        if ((toslen = ::sendto(socket_, data, n_bytes, 0, (struct sockaddr *)&sockAddr_, tolen)) == -1)
        {
            throw_spdlog_ex("sendto(2) failed", errno);
        }
    }
};
} // namespace details
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/details/windows_include.h`:

```h
#pragma once

#ifndef NOMINMAX
#    define NOMINMAX // prevent windows redefining min/max
#endif

#ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bin_to_hex.h`:

```h
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include <cctype>
#include <spdlog/common.h>

#if defined(__has_include) && __has_include(<version>)
#    include <version>
#endif

#if __cpp_lib_span >= 202002L
#    include <span>
#endif

//
// Support for logging binary data as hex
// format flags, any combination of the following:
// {:X} - print in uppercase.
// {:s} - don't separate each byte with space.
// {:p} - don't print the position on each line start.
// {:n} - don't split the output to lines.
// {:a} - show ASCII if :n is not set

//
// Examples:
//
// std::vector<char> v(200, 0x0b);
// logger->info("Some buffer {}", spdlog::to_hex(v));
// char buf[128];
// logger->info("Some buffer {:X}", spdlog::to_hex(std::begin(buf), std::end(buf)));
// logger->info("Some buffer {:X}", spdlog::to_hex(std::begin(buf), std::end(buf), 16));

namespace spdlog {
namespace details {

template<typename It>
class dump_info
{
public:
    dump_info(It range_begin, It range_end, size_t size_per_line)
        : begin_(range_begin)
        , end_(range_end)
        , size_per_line_(size_per_line)
    {}

    // do not use begin() and end() to avoid collision with fmt/ranges
    It get_begin() const
    {
        return begin_;
    }
    It get_end() const
    {
        return end_;
    }
    size_t size_per_line() const
    {
        return size_per_line_;
    }

private:
    It begin_, end_;
    size_t size_per_line_;
};
} // namespace details

// create a dump_info that wraps the given container
template<typename Container>
inline details::dump_info<typename Container::const_iterator> to_hex(const Container &container, size_t size_per_line = 32)
{
    static_assert(sizeof(typename Container::value_type) == 1, "sizeof(Container::value_type) != 1");
    using Iter = typename Container::const_iterator;
    return details::dump_info<Iter>(std::begin(container), std::end(container), size_per_line);
}

#if __cpp_lib_span >= 202002L

template<typename Value, size_t Extent>
inline details::dump_info<typename std::span<Value, Extent>::iterator> to_hex(
    const std::span<Value, Extent> &container, size_t size_per_line = 32)
{
    using Container = std::span<Value, Extent>;
    static_assert(sizeof(typename Container::value_type) == 1, "sizeof(Container::value_type) != 1");
    using Iter = typename Container::iterator;
    return details::dump_info<Iter>(std::begin(container), std::end(container), size_per_line);
}

#endif

// create dump_info from ranges
template<typename It>
inline details::dump_info<It> to_hex(const It range_begin, const It range_end, size_t size_per_line = 32)
{
    return details::dump_info<It>(range_begin, range_end, size_per_line);
}

} // namespace spdlog

namespace
#ifdef SPDLOG_USE_STD_FORMAT
    std
#else
    fmt
#endif
{

template<typename T>
struct formatter<spdlog::details::dump_info<T>, char>
{
    const char delimiter = ' ';
    bool put_newlines = true;
    bool put_delimiters = true;
    bool use_uppercase = false;
    bool put_positions = true; // position on start of each line
    bool show_ascii = false;

    // parse the format string flags
    template<typename ParseContext>
    SPDLOG_CONSTEXPR_FUNC auto parse(ParseContext &ctx) -> decltype(ctx.begin())
    {
        auto it = ctx.begin();
        while (it != ctx.end() && *it != '}')
        {
            switch (*it)
            {
            case 'X':
                use_uppercase = true;
                break;
            case 's':
                put_delimiters = false;
                break;
            case 'p':
                put_positions = false;
                break;
            case 'n':
                put_newlines = false;
                show_ascii = false;
                break;
            case 'a':
                if (put_newlines)
                {
                    show_ascii = true;
                }
                break;
            }

            ++it;
        }
        return it;
    }

    // format the given bytes range as hex
    template<typename FormatContext, typename Container>
    auto format(const spdlog::details::dump_info<Container> &the_range, FormatContext &ctx) -> decltype(ctx.out())
    {
        SPDLOG_CONSTEXPR const char *hex_upper = "0123456789ABCDEF";
        SPDLOG_CONSTEXPR const char *hex_lower = "0123456789abcdef";
        const char *hex_chars = use_uppercase ? hex_upper : hex_lower;

#if !defined(SPDLOG_USE_STD_FORMAT) && FMT_VERSION < 60000
        auto inserter = ctx.begin();
#else
        auto inserter = ctx.out();
#endif

        int size_per_line = static_cast<int>(the_range.size_per_line());
        auto start_of_line = the_range.get_begin();
        for (auto i = the_range.get_begin(); i != the_range.get_end(); i++)
        {
            auto ch = static_cast<unsigned char>(*i);

            if (put_newlines && (i == the_range.get_begin() || i - start_of_line >= size_per_line))
            {
                if (show_ascii && i != the_range.get_begin())
                {
                    *inserter++ = delimiter;
                    *inserter++ = delimiter;
                    for (auto j = start_of_line; j < i; j++)
                    {
                        auto pc = static_cast<unsigned char>(*j);
                        *inserter++ = std::isprint(pc) ? static_cast<char>(*j) : '.';
                    }
                }

                put_newline(inserter, static_cast<size_t>(i - the_range.get_begin()));

                // put first byte without delimiter in front of it
                *inserter++ = hex_chars[(ch >> 4) & 0x0f];
                *inserter++ = hex_chars[ch & 0x0f];
                start_of_line = i;
                continue;
            }

            if (put_delimiters)
            {
                *inserter++ = delimiter;
            }

            *inserter++ = hex_chars[(ch >> 4) & 0x0f];
            *inserter++ = hex_chars[ch & 0x0f];
        }
        if (show_ascii) // add ascii to last line
        {
            if (the_range.get_end() - the_range.get_begin() > size_per_line)
            {
                auto blank_num = size_per_line - (the_range.get_end() - start_of_line);
                while (blank_num-- > 0)
                {
                    *inserter++ = delimiter;
                    *inserter++ = delimiter;
                    if (put_delimiters)
                    {
                        *inserter++ = delimiter;
                    }
                }
            }
            *inserter++ = delimiter;
            *inserter++ = delimiter;
            for (auto j = start_of_line; j != the_range.get_end(); j++)
            {
                auto pc = static_cast<unsigned char>(*j);
                *inserter++ = std::isprint(pc) ? static_cast<char>(*j) : '.';
            }
        }
        return inserter;
    }

    // put newline(and position header)
    template<typename It>
    void put_newline(It inserter, std::size_t pos)
    {
#ifdef _WIN32
        *inserter++ = '\r';
#endif
        *inserter++ = '\n';

        if (put_positions)
        {
            spdlog::fmt_lib::format_to(inserter, "{:04X}: ", pos);
        }
    }
};
} // namespace std

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/LICENSE.rst`:

```rst
Copyright (c) 2012 - present, Victor Zverovich

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--- Optional exception to the license ---

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into a machine-executable object form of such
source code, you may redistribute such embedded portions in such object form
without including the above copyright and permission notices.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/args.h`:

```h
// Formatting library for C++ - dynamic format arguments
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_ARGS_H_
#define FMT_ARGS_H_

#include <functional>  // std::reference_wrapper
#include <memory>      // std::unique_ptr
#include <vector>

#include "core.h"

FMT_BEGIN_NAMESPACE

namespace detail {

template <typename T> struct is_reference_wrapper : std::false_type {};
template <typename T>
struct is_reference_wrapper<std::reference_wrapper<T>> : std::true_type {};

template <typename T> const T& unwrap(const T& v) { return v; }
template <typename T> const T& unwrap(const std::reference_wrapper<T>& v) {
  return static_cast<const T&>(v);
}

class dynamic_arg_list {
  // Workaround for clang's -Wweak-vtables. Unlike for regular classes, for
  // templates it doesn't complain about inability to deduce single translation
  // unit for placing vtable. So storage_node_base is made a fake template.
  template <typename = void> struct node {
    virtual ~node() = default;
    std::unique_ptr<node<>> next;
  };

  template <typename T> struct typed_node : node<> {
    T value;

    template <typename Arg>
    FMT_CONSTEXPR typed_node(const Arg& arg) : value(arg) {}

    template <typename Char>
    FMT_CONSTEXPR typed_node(const basic_string_view<Char>& arg)
        : value(arg.data(), arg.size()) {}
  };

  std::unique_ptr<node<>> head_;

 public:
  template <typename T, typename Arg> const T& push(const Arg& arg) {
    auto new_node = std::unique_ptr<typed_node<T>>(new typed_node<T>(arg));
    auto& value = new_node->value;
    new_node->next = std::move(head_);
    head_ = std::move(new_node);
    return value;
  }
};
}  // namespace detail

/**
  \rst
  A dynamic version of `fmt::format_arg_store`.
  It's equipped with a storage to potentially temporary objects which lifetimes
  could be shorter than the format arguments object.

  It can be implicitly converted into `~fmt::basic_format_args` for passing
  into type-erased formatting functions such as `~fmt::vformat`.
  \endrst
 */
template <typename Context>
class dynamic_format_arg_store
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
    // Workaround a GCC template argument substitution bug.
    : public basic_format_args<Context>
#endif
{
 private:
  using char_type = typename Context::char_type;

  template <typename T> struct need_copy {
    static constexpr detail::type mapped_type =
        detail::mapped_type_constant<T, Context>::value;

    enum {
      value = !(detail::is_reference_wrapper<T>::value ||
                std::is_same<T, basic_string_view<char_type>>::value ||
                std::is_same<T, detail::std_string_view<char_type>>::value ||
                (mapped_type != detail::type::cstring_type &&
                 mapped_type != detail::type::string_type &&
                 mapped_type != detail::type::custom_type))
    };
  };

  template <typename T>
  using stored_type = conditional_t<detail::is_string<T>::value &&
                                        !has_formatter<T, Context>::value &&
                                        !detail::is_reference_wrapper<T>::value,
                                    std::basic_string<char_type>, T>;

  // Storage of basic_format_arg must be contiguous.
  std::vector<basic_format_arg<Context>> data_;
  std::vector<detail::named_arg_info<char_type>> named_info_;

  // Storage of arguments not fitting into basic_format_arg must grow
  // without relocation because items in data_ refer to it.
  detail::dynamic_arg_list dynamic_args_;

  friend class basic_format_args<Context>;

  unsigned long long get_types() const {
    return detail::is_unpacked_bit | data_.size() |
           (named_info_.empty()
                ? 0ULL
                : static_cast<unsigned long long>(detail::has_named_args_bit));
  }

  const basic_format_arg<Context>* data() const {
    return named_info_.empty() ? data_.data() : data_.data() + 1;
  }

  template <typename T> void emplace_arg(const T& arg) {
    data_.emplace_back(detail::make_arg<Context>(arg));
  }

  template <typename T>
  void emplace_arg(const detail::named_arg<char_type, T>& arg) {
    if (named_info_.empty()) {
      constexpr const detail::named_arg_info<char_type>* zero_ptr{nullptr};
      data_.insert(data_.begin(), {zero_ptr, 0});
    }
    data_.emplace_back(detail::make_arg<Context>(detail::unwrap(arg.value)));
    auto pop_one = [](std::vector<basic_format_arg<Context>>* data) {
      data->pop_back();
    };
    std::unique_ptr<std::vector<basic_format_arg<Context>>, decltype(pop_one)>
        guard{&data_, pop_one};
    named_info_.push_back({arg.name, static_cast<int>(data_.size() - 2u)});
    data_[0].value_.named_args = {named_info_.data(), named_info_.size()};
    guard.release();
  }

 public:
  constexpr dynamic_format_arg_store() = default;

  /**
    \rst
    Adds an argument into the dynamic store for later passing to a formatting
    function.

    Note that custom types and string types (but not string views) are copied
    into the store dynamically allocating memory if necessary.

    **Example**::

      fmt::dynamic_format_arg_store<fmt::format_context> store;
      store.push_back(42);
      store.push_back("abc");
      store.push_back(1.5f);
      std::string result = fmt::vformat("{} and {} and {}", store);
    \endrst
  */
  template <typename T> void push_back(const T& arg) {
    if (detail::const_check(need_copy<T>::value))
      emplace_arg(dynamic_args_.push<stored_type<T>>(arg));
    else
      emplace_arg(detail::unwrap(arg));
  }

  /**
    \rst
    Adds a reference to the argument into the dynamic store for later passing to
    a formatting function.

    **Example**::

      fmt::dynamic_format_arg_store<fmt::format_context> store;
      char band[] = "Rolling Stones";
      store.push_back(std::cref(band));
      band[9] = 'c'; // Changing str affects the output.
      std::string result = fmt::vformat("{}", store);
      // result == "Rolling Scones"
    \endrst
  */
  template <typename T> void push_back(std::reference_wrapper<T> arg) {
    static_assert(
        need_copy<T>::value,
        "objects of built-in types and string views are always copied");
    emplace_arg(arg.get());
  }

  /**
    Adds named argument into the dynamic store for later passing to a formatting
    function. ``std::reference_wrapper`` is supported to avoid copying of the
    argument. The name is always copied into the store.
  */
  template <typename T>
  void push_back(const detail::named_arg<char_type, T>& arg) {
    const char_type* arg_name =
        dynamic_args_.push<std::basic_string<char_type>>(arg.name).c_str();
    if (detail::const_check(need_copy<T>::value)) {
      emplace_arg(
          fmt::arg(arg_name, dynamic_args_.push<stored_type<T>>(arg.value)));
    } else {
      emplace_arg(fmt::arg(arg_name, arg.value));
    }
  }

  /** Erase all elements from the store */
  void clear() {
    data_.clear();
    named_info_.clear();
    dynamic_args_ = detail::dynamic_arg_list();
  }

  /**
    \rst
    Reserves space to store at least *new_cap* arguments including
    *new_cap_named* named arguments.
    \endrst
  */
  void reserve(size_t new_cap, size_t new_cap_named) {
    FMT_ASSERT(new_cap >= new_cap_named,
               "Set of arguments includes set of named arguments");
    data_.reserve(new_cap);
    named_info_.reserve(new_cap_named);
  }
};

FMT_END_NAMESPACE

#endif  // FMT_ARGS_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/chrono.h`:

```h
// Formatting library for C++ - chrono support
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_CHRONO_H_
#define FMT_CHRONO_H_

#include <algorithm>
#include <chrono>
#include <ctime>
#include <iterator>
#include <locale>
#include <ostream>
#include <type_traits>

#include "format.h"

FMT_BEGIN_NAMESPACE

// Enable tzset.
#ifndef FMT_USE_TZSET
// UWP doesn't provide _tzset.
#  if FMT_HAS_INCLUDE("winapifamily.h")
#    include <winapifamily.h>
#  endif
#  if defined(_WIN32) && (!defined(WINAPI_FAMILY) || \
                          (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
#    define FMT_USE_TZSET 1
#  else
#    define FMT_USE_TZSET 0
#  endif
#endif

// Enable safe chrono durations, unless explicitly disabled.
#ifndef FMT_SAFE_DURATION_CAST
#  define FMT_SAFE_DURATION_CAST 1
#endif
#if FMT_SAFE_DURATION_CAST

// For conversion between std::chrono::durations without undefined
// behaviour or erroneous results.
// This is a stripped down version of duration_cast, for inclusion in fmt.
// See https://github.com/pauldreik/safe_duration_cast
//
// Copyright Paul Dreik 2019
namespace safe_duration_cast {

template <typename To, typename From,
          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
                        std::numeric_limits<From>::is_signed ==
                            std::numeric_limits<To>::is_signed)>
FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
  ec = 0;
  using F = std::numeric_limits<From>;
  using T = std::numeric_limits<To>;
  static_assert(F::is_integer, "From must be integral");
  static_assert(T::is_integer, "To must be integral");

  // A and B are both signed, or both unsigned.
  if (detail::const_check(F::digits <= T::digits)) {
    // From fits in To without any problem.
  } else {
    // From does not always fit in To, resort to a dynamic check.
    if (from < (T::min)() || from > (T::max)()) {
      // outside range.
      ec = 1;
      return {};
    }
  }
  return static_cast<To>(from);
}

/**
 * converts From to To, without loss. If the dynamic value of from
 * can't be converted to To without loss, ec is set.
 */
template <typename To, typename From,
          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
                        std::numeric_limits<From>::is_signed !=
                            std::numeric_limits<To>::is_signed)>
FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
  ec = 0;
  using F = std::numeric_limits<From>;
  using T = std::numeric_limits<To>;
  static_assert(F::is_integer, "From must be integral");
  static_assert(T::is_integer, "To must be integral");

  if (detail::const_check(F::is_signed && !T::is_signed)) {
    // From may be negative, not allowed!
    if (fmt::detail::is_negative(from)) {
      ec = 1;
      return {};
    }
    // From is positive. Can it always fit in To?
    if (detail::const_check(F::digits > T::digits) &&
        from > static_cast<From>(detail::max_value<To>())) {
      ec = 1;
      return {};
    }
  }

  if (detail::const_check(!F::is_signed && T::is_signed &&
                          F::digits >= T::digits) &&
      from > static_cast<From>(detail::max_value<To>())) {
    ec = 1;
    return {};
  }
  return static_cast<To>(from);  // Lossless conversion.
}

template <typename To, typename From,
          FMT_ENABLE_IF(std::is_same<From, To>::value)>
FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
  ec = 0;
  return from;
}  // function

// clang-format off
/**
 * converts From to To if possible, otherwise ec is set.
 *
 * input                            |    output
 * ---------------------------------|---------------
 * NaN                              | NaN
 * Inf                              | Inf
 * normal, fits in output           | converted (possibly lossy)
 * normal, does not fit in output   | ec is set
 * subnormal                        | best effort
 * -Inf                             | -Inf
 */
// clang-format on
template <typename To, typename From,
          FMT_ENABLE_IF(!std::is_same<From, To>::value)>
FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
  ec = 0;
  using T = std::numeric_limits<To>;
  static_assert(std::is_floating_point<From>::value, "From must be floating");
  static_assert(std::is_floating_point<To>::value, "To must be floating");

  // catch the only happy case
  if (std::isfinite(from)) {
    if (from >= T::lowest() && from <= (T::max)()) {
      return static_cast<To>(from);
    }
    // not within range.
    ec = 1;
    return {};
  }

  // nan and inf will be preserved
  return static_cast<To>(from);
}  // function

template <typename To, typename From,
          FMT_ENABLE_IF(std::is_same<From, To>::value)>
FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
  ec = 0;
  static_assert(std::is_floating_point<From>::value, "From must be floating");
  return from;
}

/**
 * safe duration cast between integral durations
 */
template <typename To, typename FromRep, typename FromPeriod,
          FMT_ENABLE_IF(std::is_integral<FromRep>::value),
          FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
                      int& ec) {
  using From = std::chrono::duration<FromRep, FromPeriod>;
  ec = 0;
  // the basic idea is that we need to convert from count() in the from type
  // to count() in the To type, by multiplying it with this:
  struct Factor
      : std::ratio_divide<typename From::period, typename To::period> {};

  static_assert(Factor::num > 0, "num must be positive");
  static_assert(Factor::den > 0, "den must be positive");

  // the conversion is like this: multiply from.count() with Factor::num
  // /Factor::den and convert it to To::rep, all this without
  // overflow/underflow. let's start by finding a suitable type that can hold
  // both To, From and Factor::num
  using IntermediateRep =
      typename std::common_type<typename From::rep, typename To::rep,
                                decltype(Factor::num)>::type;

  // safe conversion to IntermediateRep
  IntermediateRep count =
      lossless_integral_conversion<IntermediateRep>(from.count(), ec);
  if (ec) return {};
  // multiply with Factor::num without overflow or underflow
  if (detail::const_check(Factor::num != 1)) {
    const auto max1 = detail::max_value<IntermediateRep>() / Factor::num;
    if (count > max1) {
      ec = 1;
      return {};
    }
    const auto min1 =
        (std::numeric_limits<IntermediateRep>::min)() / Factor::num;
    if (count < min1) {
      ec = 1;
      return {};
    }
    count *= Factor::num;
  }

  if (detail::const_check(Factor::den != 1)) count /= Factor::den;
  auto tocount = lossless_integral_conversion<typename To::rep>(count, ec);
  return ec ? To() : To(tocount);
}

/**
 * safe duration_cast between floating point durations
 */
template <typename To, typename FromRep, typename FromPeriod,
          FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
          FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
                      int& ec) {
  using From = std::chrono::duration<FromRep, FromPeriod>;
  ec = 0;
  if (std::isnan(from.count())) {
    // nan in, gives nan out. easy.
    return To{std::numeric_limits<typename To::rep>::quiet_NaN()};
  }
  // maybe we should also check if from is denormal, and decide what to do about
  // it.

  // +-inf should be preserved.
  if (std::isinf(from.count())) {
    return To{from.count()};
  }

  // the basic idea is that we need to convert from count() in the from type
  // to count() in the To type, by multiplying it with this:
  struct Factor
      : std::ratio_divide<typename From::period, typename To::period> {};

  static_assert(Factor::num > 0, "num must be positive");
  static_assert(Factor::den > 0, "den must be positive");

  // the conversion is like this: multiply from.count() with Factor::num
  // /Factor::den and convert it to To::rep, all this without
  // overflow/underflow. let's start by finding a suitable type that can hold
  // both To, From and Factor::num
  using IntermediateRep =
      typename std::common_type<typename From::rep, typename To::rep,
                                decltype(Factor::num)>::type;

  // force conversion of From::rep -> IntermediateRep to be safe,
  // even if it will never happen be narrowing in this context.
  IntermediateRep count =
      safe_float_conversion<IntermediateRep>(from.count(), ec);
  if (ec) {
    return {};
  }

  // multiply with Factor::num without overflow or underflow
  if (detail::const_check(Factor::num != 1)) {
    constexpr auto max1 = detail::max_value<IntermediateRep>() /
                          static_cast<IntermediateRep>(Factor::num);
    if (count > max1) {
      ec = 1;
      return {};
    }
    constexpr auto min1 = std::numeric_limits<IntermediateRep>::lowest() /
                          static_cast<IntermediateRep>(Factor::num);
    if (count < min1) {
      ec = 1;
      return {};
    }
    count *= static_cast<IntermediateRep>(Factor::num);
  }

  // this can't go wrong, right? den>0 is checked earlier.
  if (detail::const_check(Factor::den != 1)) {
    using common_t = typename std::common_type<IntermediateRep, intmax_t>::type;
    count /= static_cast<common_t>(Factor::den);
  }

  // convert to the to type, safely
  using ToRep = typename To::rep;

  const ToRep tocount = safe_float_conversion<ToRep>(count, ec);
  if (ec) {
    return {};
  }
  return To{tocount};
}
}  // namespace safe_duration_cast
#endif

// Prevents expansion of a preceding token as a function-style macro.
// Usage: f FMT_NOMACRO()
#define FMT_NOMACRO

namespace detail {
template <typename T = void> struct null {};
inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }
inline null<> localtime_s(...) { return null<>(); }
inline null<> gmtime_r(...) { return null<>(); }
inline null<> gmtime_s(...) { return null<>(); }

inline const std::locale& get_classic_locale() {
  static const auto& locale = std::locale::classic();
  return locale;
}

template <typename CodeUnit> struct codecvt_result {
  static constexpr const size_t max_size = 32;
  CodeUnit buf[max_size];
  CodeUnit* end;
};
template <typename CodeUnit>
constexpr const size_t codecvt_result<CodeUnit>::max_size;

template <typename CodeUnit>
void write_codecvt(codecvt_result<CodeUnit>& out, string_view in_buf,
                   const std::locale& loc) {
  using codecvt = std::codecvt<CodeUnit, char, std::mbstate_t>;
#if FMT_CLANG_VERSION
#  pragma clang diagnostic push
#  pragma clang diagnostic ignored "-Wdeprecated"
  auto& f = std::use_facet<codecvt>(loc);
#  pragma clang diagnostic pop
#else
  auto& f = std::use_facet<codecvt>(loc);
#endif
  auto mb = std::mbstate_t();
  const char* from_next = nullptr;
  auto result = f.in(mb, in_buf.begin(), in_buf.end(), from_next,
                     std::begin(out.buf), std::end(out.buf), out.end);
  if (result != std::codecvt_base::ok)
    FMT_THROW(format_error("failed to format time"));
}

template <typename OutputIt>
auto write_encoded_tm_str(OutputIt out, string_view in, const std::locale& loc)
    -> OutputIt {
  if (detail::is_utf8() && loc != get_classic_locale()) {
    // char16_t and char32_t codecvts are broken in MSVC (linkage errors) and
    // gcc-4.
#if FMT_MSC_VER != 0 || \
    (defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI))
    // The _GLIBCXX_USE_DUAL_ABI macro is always defined in libstdc++ from gcc-5
    // and newer.
    using code_unit = wchar_t;
#else
    using code_unit = char32_t;
#endif

    using unit_t = codecvt_result<code_unit>;
    unit_t unit;
    write_codecvt(unit, in, loc);
    // In UTF-8 is used one to four one-byte code units.
    auto&& buf = basic_memory_buffer<char, unit_t::max_size * 4>();
    for (code_unit* p = unit.buf; p != unit.end; ++p) {
      uint32_t c = static_cast<uint32_t>(*p);
      if (sizeof(code_unit) == 2 && c >= 0xd800 && c <= 0xdfff) {
        // surrogate pair
        ++p;
        if (p == unit.end || (c & 0xfc00) != 0xd800 ||
            (*p & 0xfc00) != 0xdc00) {
          FMT_THROW(format_error("failed to format time"));
        }
        c = (c << 10) + static_cast<uint32_t>(*p) - 0x35fdc00;
      }
      if (c < 0x80) {
        buf.push_back(static_cast<char>(c));
      } else if (c < 0x800) {
        buf.push_back(static_cast<char>(0xc0 | (c >> 6)));
        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
      } else if ((c >= 0x800 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xffff)) {
        buf.push_back(static_cast<char>(0xe0 | (c >> 12)));
        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));
        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
      } else if (c >= 0x10000 && c <= 0x10ffff) {
        buf.push_back(static_cast<char>(0xf0 | (c >> 18)));
        buf.push_back(static_cast<char>(0x80 | ((c & 0x3ffff) >> 12)));
        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));
        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
      } else {
        FMT_THROW(format_error("failed to format time"));
      }
    }
    return copy_str<char>(buf.data(), buf.data() + buf.size(), out);
  }
  return copy_str<char>(in.data(), in.data() + in.size(), out);
}

template <typename Char, typename OutputIt,
          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
    -> OutputIt {
  codecvt_result<Char> unit;
  write_codecvt(unit, sv, loc);
  return copy_str<Char>(unit.buf, unit.end, out);
}

template <typename Char, typename OutputIt,
          FMT_ENABLE_IF(std::is_same<Char, char>::value)>
auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
    -> OutputIt {
  return write_encoded_tm_str(out, sv, loc);
}

template <typename Char>
inline void do_write(buffer<Char>& buf, const std::tm& time,
                     const std::locale& loc, char format, char modifier) {
  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
  auto&& os = std::basic_ostream<Char>(&format_buf);
  os.imbue(loc);
  using iterator = std::ostreambuf_iterator<Char>;
  const auto& facet = std::use_facet<std::time_put<Char, iterator>>(loc);
  auto end = facet.put(os, os, Char(' '), &time, format, modifier);
  if (end.failed()) FMT_THROW(format_error("failed to format time"));
}

template <typename Char, typename OutputIt,
          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
auto write(OutputIt out, const std::tm& time, const std::locale& loc,
           char format, char modifier = 0) -> OutputIt {
  auto&& buf = get_buffer<Char>(out);
  do_write<Char>(buf, time, loc, format, modifier);
  return buf.out();
}

template <typename Char, typename OutputIt,
          FMT_ENABLE_IF(std::is_same<Char, char>::value)>
auto write(OutputIt out, const std::tm& time, const std::locale& loc,
           char format, char modifier = 0) -> OutputIt {
  auto&& buf = basic_memory_buffer<Char>();
  do_write<char>(buf, time, loc, format, modifier);
  return write_encoded_tm_str(out, string_view(buf.data(), buf.size()), loc);
}

}  // namespace detail

FMT_MODULE_EXPORT_BEGIN

/**
  Converts given time since epoch as ``std::time_t`` value into calendar time,
  expressed in local time. Unlike ``std::localtime``, this function is
  thread-safe on most platforms.
 */
inline std::tm localtime(std::time_t time) {
  struct dispatcher {
    std::time_t time_;
    std::tm tm_;

    dispatcher(std::time_t t) : time_(t) {}

    bool run() {
      using namespace fmt::detail;
      return handle(localtime_r(&time_, &tm_));
    }

    bool handle(std::tm* tm) { return tm != nullptr; }

    bool handle(detail::null<>) {
      using namespace fmt::detail;
      return fallback(localtime_s(&tm_, &time_));
    }

    bool fallback(int res) { return res == 0; }

#if !FMT_MSC_VER
    bool fallback(detail::null<>) {
      using namespace fmt::detail;
      std::tm* tm = std::localtime(&time_);
      if (tm) tm_ = *tm;
      return tm != nullptr;
    }
#endif
  };
  dispatcher lt(time);
  // Too big time values may be unsupported.
  if (!lt.run()) FMT_THROW(format_error("time_t value out of range"));
  return lt.tm_;
}

inline std::tm localtime(
    std::chrono::time_point<std::chrono::system_clock> time_point) {
  return localtime(std::chrono::system_clock::to_time_t(time_point));
}

/**
  Converts given time since epoch as ``std::time_t`` value into calendar time,
  expressed in Coordinated Universal Time (UTC). Unlike ``std::gmtime``, this
  function is thread-safe on most platforms.
 */
inline std::tm gmtime(std::time_t time) {
  struct dispatcher {
    std::time_t time_;
    std::tm tm_;

    dispatcher(std::time_t t) : time_(t) {}

    bool run() {
      using namespace fmt::detail;
      return handle(gmtime_r(&time_, &tm_));
    }

    bool handle(std::tm* tm) { return tm != nullptr; }

    bool handle(detail::null<>) {
      using namespace fmt::detail;
      return fallback(gmtime_s(&tm_, &time_));
    }

    bool fallback(int res) { return res == 0; }

#if !FMT_MSC_VER
    bool fallback(detail::null<>) {
      std::tm* tm = std::gmtime(&time_);
      if (tm) tm_ = *tm;
      return tm != nullptr;
    }
#endif
  };
  dispatcher gt(time);
  // Too big time values may be unsupported.
  if (!gt.run()) FMT_THROW(format_error("time_t value out of range"));
  return gt.tm_;
}

inline std::tm gmtime(
    std::chrono::time_point<std::chrono::system_clock> time_point) {
  return gmtime(std::chrono::system_clock::to_time_t(time_point));
}

FMT_BEGIN_DETAIL_NAMESPACE

// Writes two-digit numbers a, b and c separated by sep to buf.
// The method by Pavel Novikov based on
// https://johnnylee-sde.github.io/Fast-unsigned-integer-to-time-string/.
inline void write_digit2_separated(char* buf, unsigned a, unsigned b,
                                   unsigned c, char sep) {
  unsigned long long digits =
      a | (b << 24) | (static_cast<unsigned long long>(c) << 48);
  // Convert each value to BCD.
  // We have x = a * 10 + b and we want to convert it to BCD y = a * 16 + b.
  // The difference is
  //   y - x = a * 6
  // a can be found from x:
  //   a = floor(x / 10)
  // then
  //   y = x + a * 6 = x + floor(x / 10) * 6
  // floor(x / 10) is (x * 205) >> 11 (needs 16 bits).
  digits += (((digits * 205) >> 11) & 0x000f00000f00000f) * 6;
  // Put low nibbles to high bytes and high nibbles to low bytes.
  digits = ((digits & 0x00f00000f00000f0) >> 4) |
           ((digits & 0x000f00000f00000f) << 8);
  auto usep = static_cast<unsigned long long>(sep);
  // Add ASCII '0' to each digit byte and insert separators.
  digits |= 0x3030003030003030 | (usep << 16) | (usep << 40);

  constexpr const size_t len = 8;
  if (const_check(is_big_endian())) {
    char tmp[len];
    memcpy(tmp, &digits, len);
    std::reverse_copy(tmp, tmp + len, buf);
  } else {
    memcpy(buf, &digits, len);
  }
}

template <typename Period> FMT_CONSTEXPR inline const char* get_units() {
  if (std::is_same<Period, std::atto>::value) return "as";
  if (std::is_same<Period, std::femto>::value) return "fs";
  if (std::is_same<Period, std::pico>::value) return "ps";
  if (std::is_same<Period, std::nano>::value) return "ns";
  if (std::is_same<Period, std::micro>::value) return "µs";
  if (std::is_same<Period, std::milli>::value) return "ms";
  if (std::is_same<Period, std::centi>::value) return "cs";
  if (std::is_same<Period, std::deci>::value) return "ds";
  if (std::is_same<Period, std::ratio<1>>::value) return "s";
  if (std::is_same<Period, std::deca>::value) return "das";
  if (std::is_same<Period, std::hecto>::value) return "hs";
  if (std::is_same<Period, std::kilo>::value) return "ks";
  if (std::is_same<Period, std::mega>::value) return "Ms";
  if (std::is_same<Period, std::giga>::value) return "Gs";
  if (std::is_same<Period, std::tera>::value) return "Ts";
  if (std::is_same<Period, std::peta>::value) return "Ps";
  if (std::is_same<Period, std::exa>::value) return "Es";
  if (std::is_same<Period, std::ratio<60>>::value) return "m";
  if (std::is_same<Period, std::ratio<3600>>::value) return "h";
  return nullptr;
}

enum class numeric_system {
  standard,
  // Alternative numeric system, e.g. 十二 instead of 12 in ja_JP locale.
  alternative
};

// Parses a put_time-like format string and invokes handler actions.
template <typename Char, typename Handler>
FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
                                              const Char* end,
                                              Handler&& handler) {
  auto ptr = begin;
  while (ptr != end) {
    auto c = *ptr;
    if (c == '}') break;
    if (c != '%') {
      ++ptr;
      continue;
    }
    if (begin != ptr) handler.on_text(begin, ptr);
    ++ptr;  // consume '%'
    if (ptr == end) FMT_THROW(format_error("invalid format"));
    c = *ptr++;
    switch (c) {
    case '%':
      handler.on_text(ptr - 1, ptr);
      break;
    case 'n': {
      const Char newline[] = {'\n'};
      handler.on_text(newline, newline + 1);
      break;
    }
    case 't': {
      const Char tab[] = {'\t'};
      handler.on_text(tab, tab + 1);
      break;
    }
    // Year:
    case 'Y':
      handler.on_year(numeric_system::standard);
      break;
    case 'y':
      handler.on_short_year(numeric_system::standard);
      break;
    case 'C':
      handler.on_century(numeric_system::standard);
      break;
    case 'G':
      handler.on_iso_week_based_year();
      break;
    case 'g':
      handler.on_iso_week_based_short_year();
      break;
    // Day of the week:
    case 'a':
      handler.on_abbr_weekday();
      break;
    case 'A':
      handler.on_full_weekday();
      break;
    case 'w':
      handler.on_dec0_weekday(numeric_system::standard);
      break;
    case 'u':
      handler.on_dec1_weekday(numeric_system::standard);
      break;
    // Month:
    case 'b':
    case 'h':
      handler.on_abbr_month();
      break;
    case 'B':
      handler.on_full_month();
      break;
    case 'm':
      handler.on_dec_month(numeric_system::standard);
      break;
    // Day of the year/month:
    case 'U':
      handler.on_dec0_week_of_year(numeric_system::standard);
      break;
    case 'W':
      handler.on_dec1_week_of_year(numeric_system::standard);
      break;
    case 'V':
      handler.on_iso_week_of_year(numeric_system::standard);
      break;
    case 'j':
      handler.on_day_of_year();
      break;
    case 'd':
      handler.on_day_of_month(numeric_system::standard);
      break;
    case 'e':
      handler.on_day_of_month_space(numeric_system::standard);
      break;
    // Hour, minute, second:
    case 'H':
      handler.on_24_hour(numeric_system::standard);
      break;
    case 'I':
      handler.on_12_hour(numeric_system::standard);
      break;
    case 'M':
      handler.on_minute(numeric_system::standard);
      break;
    case 'S':
      handler.on_second(numeric_system::standard);
      break;
    // Other:
    case 'c':
      handler.on_datetime(numeric_system::standard);
      break;
    case 'x':
      handler.on_loc_date(numeric_system::standard);
      break;
    case 'X':
      handler.on_loc_time(numeric_system::standard);
      break;
    case 'D':
      handler.on_us_date();
      break;
    case 'F':
      handler.on_iso_date();
      break;
    case 'r':
      handler.on_12_hour_time();
      break;
    case 'R':
      handler.on_24_hour_time();
      break;
    case 'T':
      handler.on_iso_time();
      break;
    case 'p':
      handler.on_am_pm();
      break;
    case 'Q':
      handler.on_duration_value();
      break;
    case 'q':
      handler.on_duration_unit();
      break;
    case 'z':
      handler.on_utc_offset();
      break;
    case 'Z':
      handler.on_tz_name();
      break;
    // Alternative representation:
    case 'E': {
      if (ptr == end) FMT_THROW(format_error("invalid format"));
      c = *ptr++;
      switch (c) {
      case 'Y':
        handler.on_year(numeric_system::alternative);
        break;
      case 'y':
        handler.on_offset_year();
        break;
      case 'C':
        handler.on_century(numeric_system::alternative);
        break;
      case 'c':
        handler.on_datetime(numeric_system::alternative);
        break;
      case 'x':
        handler.on_loc_date(numeric_system::alternative);
        break;
      case 'X':
        handler.on_loc_time(numeric_system::alternative);
        break;
      default:
        FMT_THROW(format_error("invalid format"));
      }
      break;
    }
    case 'O':
      if (ptr == end) FMT_THROW(format_error("invalid format"));
      c = *ptr++;
      switch (c) {
      case 'y':
        handler.on_short_year(numeric_system::alternative);
        break;
      case 'm':
        handler.on_dec_month(numeric_system::alternative);
        break;
      case 'U':
        handler.on_dec0_week_of_year(numeric_system::alternative);
        break;
      case 'W':
        handler.on_dec1_week_of_year(numeric_system::alternative);
        break;
      case 'V':
        handler.on_iso_week_of_year(numeric_system::alternative);
        break;
      case 'd':
        handler.on_day_of_month(numeric_system::alternative);
        break;
      case 'e':
        handler.on_day_of_month_space(numeric_system::alternative);
        break;
      case 'w':
        handler.on_dec0_weekday(numeric_system::alternative);
        break;
      case 'u':
        handler.on_dec1_weekday(numeric_system::alternative);
        break;
      case 'H':
        handler.on_24_hour(numeric_system::alternative);
        break;
      case 'I':
        handler.on_12_hour(numeric_system::alternative);
        break;
      case 'M':
        handler.on_minute(numeric_system::alternative);
        break;
      case 'S':
        handler.on_second(numeric_system::alternative);
        break;
      default:
        FMT_THROW(format_error("invalid format"));
      }
      break;
    default:
      FMT_THROW(format_error("invalid format"));
    }
    begin = ptr;
  }
  if (begin != ptr) handler.on_text(begin, ptr);
  return ptr;
}

template <typename Derived> struct null_chrono_spec_handler {
  FMT_CONSTEXPR void unsupported() {
    static_cast<Derived*>(this)->unsupported();
  }
  FMT_CONSTEXPR void on_year(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_short_year(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_offset_year() { unsupported(); }
  FMT_CONSTEXPR void on_century(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_iso_week_based_year() { unsupported(); }
  FMT_CONSTEXPR void on_iso_week_based_short_year() { unsupported(); }
  FMT_CONSTEXPR void on_abbr_weekday() { unsupported(); }
  FMT_CONSTEXPR void on_full_weekday() { unsupported(); }
  FMT_CONSTEXPR void on_dec0_weekday(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_dec1_weekday(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_abbr_month() { unsupported(); }
  FMT_CONSTEXPR void on_full_month() { unsupported(); }
  FMT_CONSTEXPR void on_dec_month(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_day_of_year() { unsupported(); }
  FMT_CONSTEXPR void on_day_of_month(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_24_hour(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_12_hour(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_minute(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_second(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_datetime(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_loc_date(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_loc_time(numeric_system) { unsupported(); }
  FMT_CONSTEXPR void on_us_date() { unsupported(); }
  FMT_CONSTEXPR void on_iso_date() { unsupported(); }
  FMT_CONSTEXPR void on_12_hour_time() { unsupported(); }
  FMT_CONSTEXPR void on_24_hour_time() { unsupported(); }
  FMT_CONSTEXPR void on_iso_time() { unsupported(); }
  FMT_CONSTEXPR void on_am_pm() { unsupported(); }
  FMT_CONSTEXPR void on_duration_value() { unsupported(); }
  FMT_CONSTEXPR void on_duration_unit() { unsupported(); }
  FMT_CONSTEXPR void on_utc_offset() { unsupported(); }
  FMT_CONSTEXPR void on_tz_name() { unsupported(); }
};

struct tm_format_checker : null_chrono_spec_handler<tm_format_checker> {
  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no format")); }

  template <typename Char>
  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
  FMT_CONSTEXPR void on_year(numeric_system) {}
  FMT_CONSTEXPR void on_short_year(numeric_system) {}
  FMT_CONSTEXPR void on_offset_year() {}
  FMT_CONSTEXPR void on_century(numeric_system) {}
  FMT_CONSTEXPR void on_iso_week_based_year() {}
  FMT_CONSTEXPR void on_iso_week_based_short_year() {}
  FMT_CONSTEXPR void on_abbr_weekday() {}
  FMT_CONSTEXPR void on_full_weekday() {}
  FMT_CONSTEXPR void on_dec0_weekday(numeric_system) {}
  FMT_CONSTEXPR void on_dec1_weekday(numeric_system) {}
  FMT_CONSTEXPR void on_abbr_month() {}
  FMT_CONSTEXPR void on_full_month() {}
  FMT_CONSTEXPR void on_dec_month(numeric_system) {}
  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) {}
  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) {}
  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) {}
  FMT_CONSTEXPR void on_day_of_year() {}
  FMT_CONSTEXPR void on_day_of_month(numeric_system) {}
  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) {}
  FMT_CONSTEXPR void on_24_hour(numeric_system) {}
  FMT_CONSTEXPR void on_12_hour(numeric_system) {}
  FMT_CONSTEXPR void on_minute(numeric_system) {}
  FMT_CONSTEXPR void on_second(numeric_system) {}
  FMT_CONSTEXPR void on_datetime(numeric_system) {}
  FMT_CONSTEXPR void on_loc_date(numeric_system) {}
  FMT_CONSTEXPR void on_loc_time(numeric_system) {}
  FMT_CONSTEXPR void on_us_date() {}
  FMT_CONSTEXPR void on_iso_date() {}
  FMT_CONSTEXPR void on_12_hour_time() {}
  FMT_CONSTEXPR void on_24_hour_time() {}
  FMT_CONSTEXPR void on_iso_time() {}
  FMT_CONSTEXPR void on_am_pm() {}
  FMT_CONSTEXPR void on_utc_offset() {}
  FMT_CONSTEXPR void on_tz_name() {}
};

inline const char* tm_wday_full_name(int wday) {
  static constexpr const char* full_name_list[] = {
      "Sunday",   "Monday", "Tuesday", "Wednesday",
      "Thursday", "Friday", "Saturday"};
  return wday >= 0 && wday <= 6 ? full_name_list[wday] : "?";
}
inline const char* tm_wday_short_name(int wday) {
  static constexpr const char* short_name_list[] = {"Sun", "Mon", "Tue", "Wed",
                                                    "Thu", "Fri", "Sat"};
  return wday >= 0 && wday <= 6 ? short_name_list[wday] : "???";
}

inline const char* tm_mon_full_name(int mon) {
  static constexpr const char* full_name_list[] = {
      "January", "February", "March",     "April",   "May",      "June",
      "July",    "August",   "September", "October", "November", "December"};
  return mon >= 0 && mon <= 11 ? full_name_list[mon] : "?";
}
inline const char* tm_mon_short_name(int mon) {
  static constexpr const char* short_name_list[] = {
      "Jan", "Feb", "Mar", "Apr", "May", "Jun",
      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  };
  return mon >= 0 && mon <= 11 ? short_name_list[mon] : "???";
}

template <typename T, typename = void>
struct has_member_data_tm_gmtoff : std::false_type {};
template <typename T>
struct has_member_data_tm_gmtoff<T, void_t<decltype(T::tm_gmtoff)>>
    : std::true_type {};

template <typename T, typename = void>
struct has_member_data_tm_zone : std::false_type {};
template <typename T>
struct has_member_data_tm_zone<T, void_t<decltype(T::tm_zone)>>
    : std::true_type {};

#if FMT_USE_TZSET
inline void tzset_once() {
  static bool init = []() -> bool {
    _tzset();
    return true;
  }();
  ignore_unused(init);
}
#endif

template <typename OutputIt, typename Char> class tm_writer {
 private:
  static constexpr int days_per_week = 7;

  const std::locale& loc_;
  const bool is_classic_;
  OutputIt out_;
  const std::tm& tm_;

  auto tm_sec() const noexcept -> int {
    FMT_ASSERT(tm_.tm_sec >= 0 && tm_.tm_sec <= 61, "");
    return tm_.tm_sec;
  }
  auto tm_min() const noexcept -> int {
    FMT_ASSERT(tm_.tm_min >= 0 && tm_.tm_min <= 59, "");
    return tm_.tm_min;
  }
  auto tm_hour() const noexcept -> int {
    FMT_ASSERT(tm_.tm_hour >= 0 && tm_.tm_hour <= 23, "");
    return tm_.tm_hour;
  }
  auto tm_mday() const noexcept -> int {
    FMT_ASSERT(tm_.tm_mday >= 1 && tm_.tm_mday <= 31, "");
    return tm_.tm_mday;
  }
  auto tm_mon() const noexcept -> int {
    FMT_ASSERT(tm_.tm_mon >= 0 && tm_.tm_mon <= 11, "");
    return tm_.tm_mon;
  }
  auto tm_year() const noexcept -> long long { return 1900ll + tm_.tm_year; }
  auto tm_wday() const noexcept -> int {
    FMT_ASSERT(tm_.tm_wday >= 0 && tm_.tm_wday <= 6, "");
    return tm_.tm_wday;
  }
  auto tm_yday() const noexcept -> int {
    FMT_ASSERT(tm_.tm_yday >= 0 && tm_.tm_yday <= 365, "");
    return tm_.tm_yday;
  }

  auto tm_hour12() const noexcept -> int {
    const auto h = tm_hour();
    const auto z = h < 12 ? h : h - 12;
    return z == 0 ? 12 : z;
  }

  // POSIX and the C Standard are unclear or inconsistent about what %C and %y
  // do if the year is negative or exceeds 9999. Use the convention that %C
  // concatenated with %y yields the same output as %Y, and that %Y contains at
  // least 4 characters, with more only if necessary.
  auto split_year_lower(long long year) const noexcept -> int {
    auto l = year % 100;
    if (l < 0) l = -l;  // l in [0, 99]
    return static_cast<int>(l);
  }

  // Algorithm:
  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_from_a_month_and_day_of_the_month_or_ordinal_date
  auto iso_year_weeks(long long curr_year) const noexcept -> int {
    const auto prev_year = curr_year - 1;
    const auto curr_p =
        (curr_year + curr_year / 4 - curr_year / 100 + curr_year / 400) %
        days_per_week;
    const auto prev_p =
        (prev_year + prev_year / 4 - prev_year / 100 + prev_year / 400) %
        days_per_week;
    return 52 + ((curr_p == 4 || prev_p == 3) ? 1 : 0);
  }
  auto iso_week_num(int tm_yday, int tm_wday) const noexcept -> int {
    return (tm_yday + 11 - (tm_wday == 0 ? days_per_week : tm_wday)) /
           days_per_week;
  }
  auto tm_iso_week_year() const noexcept -> long long {
    const auto year = tm_year();
    const auto w = iso_week_num(tm_yday(), tm_wday());
    if (w < 1) return year - 1;
    if (w > iso_year_weeks(year)) return year + 1;
    return year;
  }
  auto tm_iso_week_of_year() const noexcept -> int {
    const auto year = tm_year();
    const auto w = iso_week_num(tm_yday(), tm_wday());
    if (w < 1) return iso_year_weeks(year - 1);
    if (w > iso_year_weeks(year)) return 1;
    return w;
  }

  void write1(int value) {
    *out_++ = static_cast<char>('0' + to_unsigned(value) % 10);
  }
  void write2(int value) {
    const char* d = digits2(to_unsigned(value) % 100);
    *out_++ = *d++;
    *out_++ = *d;
  }

  void write_year_extended(long long year) {
    // At least 4 characters.
    int width = 4;
    if (year < 0) {
      *out_++ = '-';
      year = 0 - year;
      --width;
    }
    uint32_or_64_or_128_t<long long> n = to_unsigned(year);
    const int num_digits = count_digits(n);
    if (width > num_digits) out_ = std::fill_n(out_, width - num_digits, '0');
    out_ = format_decimal<Char>(out_, n, num_digits).end;
  }
  void write_year(long long year) {
    if (year >= 0 && year < 10000) {
      write2(static_cast<int>(year / 100));
      write2(static_cast<int>(year % 100));
    } else {
      write_year_extended(year);
    }
  }

  void write_utc_offset(long offset) {
    if (offset < 0) {
      *out_++ = '-';
      offset = -offset;
    } else {
      *out_++ = '+';
    }
    offset /= 60;
    write2(static_cast<int>(offset / 60));
    write2(static_cast<int>(offset % 60));
  }
  template <typename T, FMT_ENABLE_IF(has_member_data_tm_gmtoff<T>::value)>
  void format_utc_offset_impl(const T& tm) {
    write_utc_offset(tm.tm_gmtoff);
  }
  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_gmtoff<T>::value)>
  void format_utc_offset_impl(const T& tm) {
#if defined(_WIN32) && defined(_UCRT)
#  if FMT_USE_TZSET
    tzset_once();
#  endif
    long offset = 0;
    _get_timezone(&offset);
    if (tm.tm_isdst) {
      long dstbias = 0;
      _get_dstbias(&dstbias);
      offset += dstbias;
    }
    write_utc_offset(-offset);
#else
    ignore_unused(tm);
    format_localized('z');
#endif
  }

  template <typename T, FMT_ENABLE_IF(has_member_data_tm_zone<T>::value)>
  void format_tz_name_impl(const T& tm) {
    if (is_classic_)
      out_ = write_tm_str<Char>(out_, tm.tm_zone, loc_);
    else
      format_localized('Z');
  }
  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_zone<T>::value)>
  void format_tz_name_impl(const T&) {
    format_localized('Z');
  }

  void format_localized(char format, char modifier = 0) {
    out_ = write<Char>(out_, tm_, loc_, format, modifier);
  }

 public:
  tm_writer(const std::locale& loc, OutputIt out, const std::tm& tm)
      : loc_(loc),
        is_classic_(loc_ == get_classic_locale()),
        out_(out),
        tm_(tm) {}

  OutputIt out() const { return out_; }

  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
    out_ = copy_str<Char>(begin, end, out_);
  }

  void on_abbr_weekday() {
    if (is_classic_)
      out_ = write(out_, tm_wday_short_name(tm_wday()));
    else
      format_localized('a');
  }
  void on_full_weekday() {
    if (is_classic_)
      out_ = write(out_, tm_wday_full_name(tm_wday()));
    else
      format_localized('A');
  }
  void on_dec0_weekday(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) return write1(tm_wday());
    format_localized('w', 'O');
  }
  void on_dec1_weekday(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) {
      auto wday = tm_wday();
      write1(wday == 0 ? days_per_week : wday);
    } else {
      format_localized('u', 'O');
    }
  }

  void on_abbr_month() {
    if (is_classic_)
      out_ = write(out_, tm_mon_short_name(tm_mon()));
    else
      format_localized('b');
  }
  void on_full_month() {
    if (is_classic_)
      out_ = write(out_, tm_mon_full_name(tm_mon()));
    else
      format_localized('B');
  }

  void on_datetime(numeric_system ns) {
    if (is_classic_) {
      on_abbr_weekday();
      *out_++ = ' ';
      on_abbr_month();
      *out_++ = ' ';
      on_day_of_month_space(numeric_system::standard);
      *out_++ = ' ';
      on_iso_time();
      *out_++ = ' ';
      on_year(numeric_system::standard);
    } else {
      format_localized('c', ns == numeric_system::standard ? '\0' : 'E');
    }
  }
  void on_loc_date(numeric_system ns) {
    if (is_classic_)
      on_us_date();
    else
      format_localized('x', ns == numeric_system::standard ? '\0' : 'E');
  }
  void on_loc_time(numeric_system ns) {
    if (is_classic_)
      on_iso_time();
    else
      format_localized('X', ns == numeric_system::standard ? '\0' : 'E');
  }
  void on_us_date() {
    char buf[8];
    write_digit2_separated(buf, to_unsigned(tm_mon() + 1),
                           to_unsigned(tm_mday()),
                           to_unsigned(split_year_lower(tm_year())), '/');
    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
  }
  void on_iso_date() {
    auto year = tm_year();
    char buf[10];
    size_t offset = 0;
    if (year >= 0 && year < 10000) {
      copy2(buf, digits2(to_unsigned(year / 100)));
    } else {
      offset = 4;
      write_year_extended(year);
      year = 0;
    }
    write_digit2_separated(buf + 2, static_cast<unsigned>(year % 100),
                           to_unsigned(tm_mon() + 1), to_unsigned(tm_mday()),
                           '-');
    out_ = copy_str<Char>(std::begin(buf) + offset, std::end(buf), out_);
  }

  void on_utc_offset() { format_utc_offset_impl(tm_); }
  void on_tz_name() { format_tz_name_impl(tm_); }

  void on_year(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard)
      return write_year(tm_year());
    format_localized('Y', 'E');
  }
  void on_short_year(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard)
      return write2(split_year_lower(tm_year()));
    format_localized('y', 'O');
  }
  void on_offset_year() {
    if (is_classic_) return write2(split_year_lower(tm_year()));
    format_localized('y', 'E');
  }

  void on_century(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) {
      auto year = tm_year();
      auto upper = year / 100;
      if (year >= -99 && year < 0) {
        // Zero upper on negative year.
        *out_++ = '-';
        *out_++ = '0';
      } else if (upper >= 0 && upper < 100) {
        write2(static_cast<int>(upper));
      } else {
        out_ = write<Char>(out_, upper);
      }
    } else {
      format_localized('C', 'E');
    }
  }

  void on_dec_month(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard)
      return write2(tm_mon() + 1);
    format_localized('m', 'O');
  }

  void on_dec0_week_of_year(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard)
      return write2((tm_yday() + days_per_week - tm_wday()) / days_per_week);
    format_localized('U', 'O');
  }
  void on_dec1_week_of_year(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) {
      auto wday = tm_wday();
      write2((tm_yday() + days_per_week -
              (wday == 0 ? (days_per_week - 1) : (wday - 1))) /
             days_per_week);
    } else {
      format_localized('W', 'O');
    }
  }
  void on_iso_week_of_year(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard)
      return write2(tm_iso_week_of_year());
    format_localized('V', 'O');
  }

  void on_iso_week_based_year() { write_year(tm_iso_week_year()); }
  void on_iso_week_based_short_year() {
    write2(split_year_lower(tm_iso_week_year()));
  }

  void on_day_of_year() {
    auto yday = tm_yday() + 1;
    write1(yday / 100);
    write2(yday % 100);
  }
  void on_day_of_month(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) return write2(tm_mday());
    format_localized('d', 'O');
  }
  void on_day_of_month_space(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) {
      auto mday = to_unsigned(tm_mday()) % 100;
      const char* d2 = digits2(mday);
      *out_++ = mday < 10 ? ' ' : d2[0];
      *out_++ = d2[1];
    } else {
      format_localized('e', 'O');
    }
  }

  void on_24_hour(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) return write2(tm_hour());
    format_localized('H', 'O');
  }
  void on_12_hour(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard)
      return write2(tm_hour12());
    format_localized('I', 'O');
  }
  void on_minute(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) return write2(tm_min());
    format_localized('M', 'O');
  }
  void on_second(numeric_system ns) {
    if (is_classic_ || ns == numeric_system::standard) return write2(tm_sec());
    format_localized('S', 'O');
  }

  void on_12_hour_time() {
    if (is_classic_) {
      char buf[8];
      write_digit2_separated(buf, to_unsigned(tm_hour12()),
                             to_unsigned(tm_min()), to_unsigned(tm_sec()), ':');
      out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
      *out_++ = ' ';
      on_am_pm();
    } else {
      format_localized('r');
    }
  }
  void on_24_hour_time() {
    write2(tm_hour());
    *out_++ = ':';
    write2(tm_min());
  }
  void on_iso_time() {
    char buf[8];
    write_digit2_separated(buf, to_unsigned(tm_hour()), to_unsigned(tm_min()),
                           to_unsigned(tm_sec()), ':');
    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
  }

  void on_am_pm() {
    if (is_classic_) {
      *out_++ = tm_hour() < 12 ? 'A' : 'P';
      *out_++ = 'M';
    } else {
      format_localized('p');
    }
  }

  // These apply to chrono durations but not tm.
  void on_duration_value() {}
  void on_duration_unit() {}
};

struct chrono_format_checker : null_chrono_spec_handler<chrono_format_checker> {
  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no date")); }

  template <typename Char>
  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
  FMT_CONSTEXPR void on_24_hour(numeric_system) {}
  FMT_CONSTEXPR void on_12_hour(numeric_system) {}
  FMT_CONSTEXPR void on_minute(numeric_system) {}
  FMT_CONSTEXPR void on_second(numeric_system) {}
  FMT_CONSTEXPR void on_12_hour_time() {}
  FMT_CONSTEXPR void on_24_hour_time() {}
  FMT_CONSTEXPR void on_iso_time() {}
  FMT_CONSTEXPR void on_am_pm() {}
  FMT_CONSTEXPR void on_duration_value() {}
  FMT_CONSTEXPR void on_duration_unit() {}
};

template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
inline bool isnan(T) {
  return false;
}
template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
inline bool isnan(T value) {
  return std::isnan(value);
}

template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
inline bool isfinite(T) {
  return true;
}

// Converts value to Int and checks that it's in the range [0, upper).
template <typename T, typename Int, FMT_ENABLE_IF(std::is_integral<T>::value)>
inline Int to_nonnegative_int(T value, Int upper) {
  FMT_ASSERT(value >= 0 && to_unsigned(value) <= to_unsigned(upper),
             "invalid value");
  (void)upper;
  return static_cast<Int>(value);
}
template <typename T, typename Int, FMT_ENABLE_IF(!std::is_integral<T>::value)>
inline Int to_nonnegative_int(T value, Int upper) {
  if (value < 0 || value > static_cast<T>(upper))
    FMT_THROW(format_error("invalid value"));
  return static_cast<Int>(value);
}

template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
inline T mod(T x, int y) {
  return x % static_cast<T>(y);
}
template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
inline T mod(T x, int y) {
  return std::fmod(x, static_cast<T>(y));
}

// If T is an integral type, maps T to its unsigned counterpart, otherwise
// leaves it unchanged (unlike std::make_unsigned).
template <typename T, bool INTEGRAL = std::is_integral<T>::value>
struct make_unsigned_or_unchanged {
  using type = T;
};

template <typename T> struct make_unsigned_or_unchanged<T, true> {
  using type = typename std::make_unsigned<T>::type;
};

#if FMT_SAFE_DURATION_CAST
// throwing version of safe_duration_cast
template <typename To, typename FromRep, typename FromPeriod>
To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {
  int ec;
  To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
  if (ec) FMT_THROW(format_error("cannot format duration"));
  return to;
}
#endif

template <typename Rep, typename Period,
          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
inline std::chrono::duration<Rep, std::milli> get_milliseconds(
    std::chrono::duration<Rep, Period> d) {
  // this may overflow and/or the result may not fit in the
  // target type.
#if FMT_SAFE_DURATION_CAST
  using CommonSecondsType =
      typename std::common_type<decltype(d), std::chrono::seconds>::type;
  const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);
  const auto d_as_whole_seconds =
      fmt_safe_duration_cast<std::chrono::seconds>(d_as_common);
  // this conversion should be nonproblematic
  const auto diff = d_as_common - d_as_whole_seconds;
  const auto ms =
      fmt_safe_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
  return ms;
#else
  auto s = std::chrono::duration_cast<std::chrono::seconds>(d);
  return std::chrono::duration_cast<std::chrono::milliseconds>(d - s);
#endif
}

// Returns the number of fractional digits in the range [0, 18] according to the
// C++20 spec. If more than 18 fractional digits are required then returns 6 for
// microseconds precision.
constexpr int count_fractional_digits(long long num, long long den, int n = 0) {
  return num % den == 0
             ? n
             : (n > 18 ? 6 : count_fractional_digits(num * 10, den, n + 1));
}

constexpr long long pow10(std::uint32_t n) {
  return n == 0 ? 1 : 10 * pow10(n - 1);
}

template <class Rep, class Period,
          FMT_ENABLE_IF(std::numeric_limits<Rep>::is_signed)>
constexpr std::chrono::duration<Rep, Period> abs(
    std::chrono::duration<Rep, Period> d) {
  // We need to compare the duration using the count() method directly
  // due to a compiler bug in clang-11 regarding the spaceship operator,
  // when -Wzero-as-null-pointer-constant is enabled.
  // In clang-12 the bug has been fixed. See
  // https://bugs.llvm.org/show_bug.cgi?id=46235 and the reproducible example:
  // https://www.godbolt.org/z/Knbb5joYx.
  return d.count() >= d.zero().count() ? d : -d;
}

template <class Rep, class Period,
          FMT_ENABLE_IF(!std::numeric_limits<Rep>::is_signed)>
constexpr std::chrono::duration<Rep, Period> abs(
    std::chrono::duration<Rep, Period> d) {
  return d;
}

template <typename Char, typename Rep, typename OutputIt,
          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
OutputIt format_duration_value(OutputIt out, Rep val, int) {
  return write<Char>(out, val);
}

template <typename Char, typename Rep, typename OutputIt,
          FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
  auto specs = basic_format_specs<Char>();
  specs.precision = precision;
  specs.type = precision >= 0 ? presentation_type::fixed_lower
                              : presentation_type::general_lower;
  return write<Char>(out, val, specs);
}

template <typename Char, typename OutputIt>
OutputIt copy_unit(string_view unit, OutputIt out, Char) {
  return std::copy(unit.begin(), unit.end(), out);
}

template <typename OutputIt>
OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
  // This works when wchar_t is UTF-32 because units only contain characters
  // that have the same representation in UTF-16 and UTF-32.
  utf8_to_utf16 u(unit);
  return std::copy(u.c_str(), u.c_str() + u.size(), out);
}

template <typename Char, typename Period, typename OutputIt>
OutputIt format_duration_unit(OutputIt out) {
  if (const char* unit = get_units<Period>())
    return copy_unit(string_view(unit), out, Char());
  *out++ = '[';
  out = write<Char>(out, Period::num);
  if (const_check(Period::den != 1)) {
    *out++ = '/';
    out = write<Char>(out, Period::den);
  }
  *out++ = ']';
  *out++ = 's';
  return out;
}

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4582 4583)
#endif

class get_locale {
 private:
  union {
    std::locale locale_;
  };
  bool has_locale_ = false;

 public:
  get_locale(bool localized, locale_ref loc) : has_locale_(localized) {
    if (localized)
      ::new (&locale_) std::locale(loc.template get<std::locale>());
  }
  ~get_locale() {
    if (has_locale_) locale_.~locale();
  }
  operator const std::locale&() const {
    return has_locale_ ? locale_ : get_classic_locale();
  }
};

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

template <typename FormatContext, typename OutputIt, typename Rep,
          typename Period>
struct chrono_formatter {
  FormatContext& context;
  OutputIt out;
  int precision;
  bool localized = false;
  // rep is unsigned to avoid overflow.
  using rep =
      conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),
                    unsigned, typename make_unsigned_or_unchanged<Rep>::type>;
  rep val;
  using seconds = std::chrono::duration<rep>;
  seconds s;
  using milliseconds = std::chrono::duration<rep, std::milli>;
  bool negative;

  using char_type = typename FormatContext::char_type;
  using tm_writer_type = tm_writer<OutputIt, char_type>;

  chrono_formatter(FormatContext& ctx, OutputIt o,
                   std::chrono::duration<Rep, Period> d)
      : context(ctx),
        out(o),
        val(static_cast<rep>(d.count())),
        negative(false) {
    if (d.count() < 0) {
      val = 0 - val;
      negative = true;
    }

    // this may overflow and/or the result may not fit in the
    // target type.
#if FMT_SAFE_DURATION_CAST
    // might need checked conversion (rep!=Rep)
    auto tmpval = std::chrono::duration<rep, Period>(val);
    s = fmt_safe_duration_cast<seconds>(tmpval);
#else
    s = std::chrono::duration_cast<seconds>(
        std::chrono::duration<rep, Period>(val));
#endif
  }

  // returns true if nan or inf, writes to out.
  bool handle_nan_inf() {
    if (isfinite(val)) {
      return false;
    }
    if (isnan(val)) {
      write_nan();
      return true;
    }
    // must be +-inf
    if (val > 0) {
      write_pinf();
    } else {
      write_ninf();
    }
    return true;
  }

  Rep hour() const { return static_cast<Rep>(mod((s.count() / 3600), 24)); }

  Rep hour12() const {
    Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));
    return hour <= 0 ? 12 : hour;
  }

  Rep minute() const { return static_cast<Rep>(mod((s.count() / 60), 60)); }
  Rep second() const { return static_cast<Rep>(mod(s.count(), 60)); }

  std::tm time() const {
    auto time = std::tm();
    time.tm_hour = to_nonnegative_int(hour(), 24);
    time.tm_min = to_nonnegative_int(minute(), 60);
    time.tm_sec = to_nonnegative_int(second(), 60);
    return time;
  }

  void write_sign() {
    if (negative) {
      *out++ = '-';
      negative = false;
    }
  }

  void write(Rep value, int width) {
    write_sign();
    if (isnan(value)) return write_nan();
    uint32_or_64_or_128_t<int> n =
        to_unsigned(to_nonnegative_int(value, max_value<int>()));
    int num_digits = detail::count_digits(n);
    if (width > num_digits) out = std::fill_n(out, width - num_digits, '0');
    out = format_decimal<char_type>(out, n, num_digits).end;
  }

  template <class Duration> void write_fractional_seconds(Duration d) {
    constexpr auto num_fractional_digits =
        count_fractional_digits(Duration::period::num, Duration::period::den);

    using subsecond_precision = std::chrono::duration<
        typename std::common_type<typename Duration::rep,
                                  std::chrono::seconds::rep>::type,
        std::ratio<1, detail::pow10(num_fractional_digits)>>;
    if (std::ratio_less<typename subsecond_precision::period,
                        std::chrono::seconds::period>::value) {
      *out++ = '.';
      // Don't convert long double to integer seconds to avoid overflow.
      using sec = conditional_t<
          std::is_same<typename Duration::rep, long double>::value,
          std::chrono::duration<long double>, std::chrono::seconds>;
      auto fractional = detail::abs(d) - std::chrono::duration_cast<sec>(d);
      const auto subseconds =
          std::chrono::treat_as_floating_point<
              typename subsecond_precision::rep>::value
              ? fractional.count()
              : std::chrono::duration_cast<subsecond_precision>(fractional)
                    .count();
      uint32_or_64_or_128_t<long long> n =
          to_unsigned(to_nonnegative_int(subseconds, max_value<long long>()));
      int num_digits = detail::count_digits(n);
      if (num_fractional_digits > num_digits)
        out = std::fill_n(out, num_fractional_digits - num_digits, '0');
      out = format_decimal<char_type>(out, n, num_digits).end;
    }
  }

  void write_nan() { std::copy_n("nan", 3, out); }
  void write_pinf() { std::copy_n("inf", 3, out); }
  void write_ninf() { std::copy_n("-inf", 4, out); }

  template <typename Callback, typename... Args>
  void format_tm(const tm& time, Callback cb, Args... args) {
    if (isnan(val)) return write_nan();
    get_locale loc(localized, context.locale());
    auto w = tm_writer_type(loc, out, time);
    (w.*cb)(args...);
    out = w.out();
  }

  void on_text(const char_type* begin, const char_type* end) {
    std::copy(begin, end, out);
  }

  // These are not implemented because durations don't have date information.
  void on_abbr_weekday() {}
  void on_full_weekday() {}
  void on_dec0_weekday(numeric_system) {}
  void on_dec1_weekday(numeric_system) {}
  void on_abbr_month() {}
  void on_full_month() {}
  void on_datetime(numeric_system) {}
  void on_loc_date(numeric_system) {}
  void on_loc_time(numeric_system) {}
  void on_us_date() {}
  void on_iso_date() {}
  void on_utc_offset() {}
  void on_tz_name() {}
  void on_year(numeric_system) {}
  void on_short_year(numeric_system) {}
  void on_offset_year() {}
  void on_century(numeric_system) {}
  void on_iso_week_based_year() {}
  void on_iso_week_based_short_year() {}
  void on_dec_month(numeric_system) {}
  void on_dec0_week_of_year(numeric_system) {}
  void on_dec1_week_of_year(numeric_system) {}
  void on_iso_week_of_year(numeric_system) {}
  void on_day_of_year() {}
  void on_day_of_month(numeric_system) {}
  void on_day_of_month_space(numeric_system) {}

  void on_24_hour(numeric_system ns) {
    if (handle_nan_inf()) return;

    if (ns == numeric_system::standard) return write(hour(), 2);
    auto time = tm();
    time.tm_hour = to_nonnegative_int(hour(), 24);
    format_tm(time, &tm_writer_type::on_24_hour, ns);
  }

  void on_12_hour(numeric_system ns) {
    if (handle_nan_inf()) return;

    if (ns == numeric_system::standard) return write(hour12(), 2);
    auto time = tm();
    time.tm_hour = to_nonnegative_int(hour12(), 12);
    format_tm(time, &tm_writer_type::on_12_hour, ns);
  }

  void on_minute(numeric_system ns) {
    if (handle_nan_inf()) return;

    if (ns == numeric_system::standard) return write(minute(), 2);
    auto time = tm();
    time.tm_min = to_nonnegative_int(minute(), 60);
    format_tm(time, &tm_writer_type::on_minute, ns);
  }

  void on_second(numeric_system ns) {
    if (handle_nan_inf()) return;

    if (ns == numeric_system::standard) {
      write(second(), 2);
      write_fractional_seconds(std::chrono::duration<rep, Period>{val});
      return;
    }
    auto time = tm();
    time.tm_sec = to_nonnegative_int(second(), 60);
    format_tm(time, &tm_writer_type::on_second, ns);
  }

  void on_12_hour_time() {
    if (handle_nan_inf()) return;
    format_tm(time(), &tm_writer_type::on_12_hour_time);
  }

  void on_24_hour_time() {
    if (handle_nan_inf()) {
      *out++ = ':';
      handle_nan_inf();
      return;
    }

    write(hour(), 2);
    *out++ = ':';
    write(minute(), 2);
  }

  void on_iso_time() {
    on_24_hour_time();
    *out++ = ':';
    if (handle_nan_inf()) return;
    on_second(numeric_system::standard);
  }

  void on_am_pm() {
    if (handle_nan_inf()) return;
    format_tm(time(), &tm_writer_type::on_am_pm);
  }

  void on_duration_value() {
    if (handle_nan_inf()) return;
    write_sign();
    out = format_duration_value<char_type>(out, val, precision);
  }

  void on_duration_unit() {
    out = format_duration_unit<char_type, Period>(out);
  }
};

FMT_END_DETAIL_NAMESPACE

#if defined(__cpp_lib_chrono) && __cpp_lib_chrono >= 201907
using weekday = std::chrono::weekday;
#else
// A fallback version of weekday.
class weekday {
 private:
  unsigned char value;

 public:
  weekday() = default;
  explicit constexpr weekday(unsigned wd) noexcept
      : value(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}
  constexpr unsigned c_encoding() const noexcept { return value; }
};

class year_month_day {};
#endif

// A rudimentary weekday formatter.
template <typename Char> struct formatter<weekday, Char> {
 private:
  bool localized = false;

 public:
  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
      -> decltype(ctx.begin()) {
    auto begin = ctx.begin(), end = ctx.end();
    if (begin != end && *begin == 'L') {
      ++begin;
      localized = true;
    }
    return begin;
  }

  template <typename FormatContext>
  auto format(weekday wd, FormatContext& ctx) const -> decltype(ctx.out()) {
    auto time = std::tm();
    time.tm_wday = static_cast<int>(wd.c_encoding());
    detail::get_locale loc(localized, ctx.locale());
    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
    w.on_abbr_weekday();
    return w.out();
  }
};

template <typename Rep, typename Period, typename Char>
struct formatter<std::chrono::duration<Rep, Period>, Char> {
 private:
  basic_format_specs<Char> specs;
  int precision = -1;
  using arg_ref_type = detail::arg_ref<Char>;
  arg_ref_type width_ref;
  arg_ref_type precision_ref;
  bool localized = false;
  basic_string_view<Char> format_str;
  using duration = std::chrono::duration<Rep, Period>;

  struct spec_handler {
    formatter& f;
    basic_format_parse_context<Char>& context;
    basic_string_view<Char> format_str;

    template <typename Id> FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
      context.check_arg_id(arg_id);
      return arg_ref_type(arg_id);
    }

    FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {
      context.check_arg_id(arg_id);
      return arg_ref_type(arg_id);
    }

    FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
      return arg_ref_type(context.next_arg_id());
    }

    void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
    FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
      f.specs.fill = fill;
    }
    FMT_CONSTEXPR void on_align(align_t align) { f.specs.align = align; }
    FMT_CONSTEXPR void on_width(int width) { f.specs.width = width; }
    FMT_CONSTEXPR void on_precision(int _precision) {
      f.precision = _precision;
    }
    FMT_CONSTEXPR void end_precision() {}

    template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
      f.width_ref = make_arg_ref(arg_id);
    }

    template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
      f.precision_ref = make_arg_ref(arg_id);
    }
  };

  using iterator = typename basic_format_parse_context<Char>::iterator;
  struct parse_range {
    iterator begin;
    iterator end;
  };

  FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context<Char>& ctx) {
    auto begin = ctx.begin(), end = ctx.end();
    if (begin == end || *begin == '}') return {begin, begin};
    spec_handler handler{*this, ctx, format_str};
    begin = detail::parse_align(begin, end, handler);
    if (begin == end) return {begin, begin};
    begin = detail::parse_width(begin, end, handler);
    if (begin == end) return {begin, begin};
    if (*begin == '.') {
      if (std::is_floating_point<Rep>::value)
        begin = detail::parse_precision(begin, end, handler);
      else
        handler.on_error("precision not allowed for this argument type");
    }
    if (begin != end && *begin == 'L') {
      ++begin;
      localized = true;
    }
    end = detail::parse_chrono_format(begin, end,
                                      detail::chrono_format_checker());
    return {begin, end};
  }

 public:
  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
      -> decltype(ctx.begin()) {
    auto range = do_parse(ctx);
    format_str = basic_string_view<Char>(
        &*range.begin, detail::to_unsigned(range.end - range.begin));
    return range.end;
  }

  template <typename FormatContext>
  auto format(const duration& d, FormatContext& ctx) const
      -> decltype(ctx.out()) {
    auto specs_copy = specs;
    auto precision_copy = precision;
    auto begin = format_str.begin(), end = format_str.end();
    // As a possible future optimization, we could avoid extra copying if width
    // is not specified.
    basic_memory_buffer<Char> buf;
    auto out = std::back_inserter(buf);
    detail::handle_dynamic_spec<detail::width_checker>(specs_copy.width,
                                                       width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(precision_copy,
                                                           precision_ref, ctx);
    if (begin == end || *begin == '}') {
      out = detail::format_duration_value<Char>(out, d.count(), precision_copy);
      detail::format_duration_unit<Char, Period>(out);
    } else {
      detail::chrono_formatter<FormatContext, decltype(out), Rep, Period> f(
          ctx, out, d);
      f.precision = precision_copy;
      f.localized = localized;
      detail::parse_chrono_format(begin, end, f);
    }
    return detail::write(
        ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs_copy);
  }
};

template <typename Char, typename Duration>
struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
                 Char> : formatter<std::tm, Char> {
  FMT_CONSTEXPR formatter() {
    this->do_parse(default_specs,
                   default_specs + sizeof(default_specs) / sizeof(Char));
  }

  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return this->do_parse(ctx.begin(), ctx.end(), true);
  }

  template <typename FormatContext>
  auto format(std::chrono::time_point<std::chrono::system_clock> val,
              FormatContext& ctx) const -> decltype(ctx.out()) {
    return formatter<std::tm, Char>::format(localtime(val), ctx);
  }

  static constexpr const Char default_specs[] = {'%', 'F', ' ', '%', 'T'};
};

template <typename Char, typename Duration>
constexpr const Char
    formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
              Char>::default_specs[];

template <typename Char> struct formatter<std::tm, Char> {
 private:
  enum class spec {
    unknown,
    year_month_day,
    hh_mm_ss,
  };
  spec spec_ = spec::unknown;
  basic_string_view<Char> specs;

 protected:
  template <typename It>
  FMT_CONSTEXPR auto do_parse(It begin, It end, bool with_default = false)
      -> It {
    if (begin != end && *begin == ':') ++begin;
    end = detail::parse_chrono_format(begin, end, detail::tm_format_checker());
    if (!with_default || end != begin)
      specs = {begin, detail::to_unsigned(end - begin)};
    // basic_string_view<>::compare isn't constexpr before C++17.
    if (specs.size() == 2 && specs[0] == Char('%')) {
      if (specs[1] == Char('F'))
        spec_ = spec::year_month_day;
      else if (specs[1] == Char('T'))
        spec_ = spec::hh_mm_ss;
    }
    return end;
  }

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return this->do_parse(ctx.begin(), ctx.end());
  }

  template <typename FormatContext>
  auto format(const std::tm& tm, FormatContext& ctx) const
      -> decltype(ctx.out()) {
    const auto loc_ref = ctx.locale();
    detail::get_locale loc(static_cast<bool>(loc_ref), loc_ref);
    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), tm);
    if (spec_ == spec::year_month_day)
      w.on_iso_date();
    else if (spec_ == spec::hh_mm_ss)
      w.on_iso_time();
    else
      detail::parse_chrono_format(specs.begin(), specs.end(), w);
    return w.out();
  }
};

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_CHRONO_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/color.h`:

```h
// Formatting library for C++ - color support
//
// Copyright (c) 2018 - present, Victor Zverovich and fmt contributors
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_COLOR_H_
#define FMT_COLOR_H_

#include "format.h"

// __declspec(deprecated) is broken in some MSVC versions.
#if FMT_MSC_VER
#  define FMT_DEPRECATED_NONMSVC
#else
#  define FMT_DEPRECATED_NONMSVC FMT_DEPRECATED
#endif

FMT_BEGIN_NAMESPACE
FMT_MODULE_EXPORT_BEGIN

enum class color : uint32_t {
  alice_blue = 0xF0F8FF,               // rgb(240,248,255)
  antique_white = 0xFAEBD7,            // rgb(250,235,215)
  aqua = 0x00FFFF,                     // rgb(0,255,255)
  aquamarine = 0x7FFFD4,               // rgb(127,255,212)
  azure = 0xF0FFFF,                    // rgb(240,255,255)
  beige = 0xF5F5DC,                    // rgb(245,245,220)
  bisque = 0xFFE4C4,                   // rgb(255,228,196)
  black = 0x000000,                    // rgb(0,0,0)
  blanched_almond = 0xFFEBCD,          // rgb(255,235,205)
  blue = 0x0000FF,                     // rgb(0,0,255)
  blue_violet = 0x8A2BE2,              // rgb(138,43,226)
  brown = 0xA52A2A,                    // rgb(165,42,42)
  burly_wood = 0xDEB887,               // rgb(222,184,135)
  cadet_blue = 0x5F9EA0,               // rgb(95,158,160)
  chartreuse = 0x7FFF00,               // rgb(127,255,0)
  chocolate = 0xD2691E,                // rgb(210,105,30)
  coral = 0xFF7F50,                    // rgb(255,127,80)
  cornflower_blue = 0x6495ED,          // rgb(100,149,237)
  cornsilk = 0xFFF8DC,                 // rgb(255,248,220)
  crimson = 0xDC143C,                  // rgb(220,20,60)
  cyan = 0x00FFFF,                     // rgb(0,255,255)
  dark_blue = 0x00008B,                // rgb(0,0,139)
  dark_cyan = 0x008B8B,                // rgb(0,139,139)
  dark_golden_rod = 0xB8860B,          // rgb(184,134,11)
  dark_gray = 0xA9A9A9,                // rgb(169,169,169)
  dark_green = 0x006400,               // rgb(0,100,0)
  dark_khaki = 0xBDB76B,               // rgb(189,183,107)
  dark_magenta = 0x8B008B,             // rgb(139,0,139)
  dark_olive_green = 0x556B2F,         // rgb(85,107,47)
  dark_orange = 0xFF8C00,              // rgb(255,140,0)
  dark_orchid = 0x9932CC,              // rgb(153,50,204)
  dark_red = 0x8B0000,                 // rgb(139,0,0)
  dark_salmon = 0xE9967A,              // rgb(233,150,122)
  dark_sea_green = 0x8FBC8F,           // rgb(143,188,143)
  dark_slate_blue = 0x483D8B,          // rgb(72,61,139)
  dark_slate_gray = 0x2F4F4F,          // rgb(47,79,79)
  dark_turquoise = 0x00CED1,           // rgb(0,206,209)
  dark_violet = 0x9400D3,              // rgb(148,0,211)
  deep_pink = 0xFF1493,                // rgb(255,20,147)
  deep_sky_blue = 0x00BFFF,            // rgb(0,191,255)
  dim_gray = 0x696969,                 // rgb(105,105,105)
  dodger_blue = 0x1E90FF,              // rgb(30,144,255)
  fire_brick = 0xB22222,               // rgb(178,34,34)
  floral_white = 0xFFFAF0,             // rgb(255,250,240)
  forest_green = 0x228B22,             // rgb(34,139,34)
  fuchsia = 0xFF00FF,                  // rgb(255,0,255)
  gainsboro = 0xDCDCDC,                // rgb(220,220,220)
  ghost_white = 0xF8F8FF,              // rgb(248,248,255)
  gold = 0xFFD700,                     // rgb(255,215,0)
  golden_rod = 0xDAA520,               // rgb(218,165,32)
  gray = 0x808080,                     // rgb(128,128,128)
  green = 0x008000,                    // rgb(0,128,0)
  green_yellow = 0xADFF2F,             // rgb(173,255,47)
  honey_dew = 0xF0FFF0,                // rgb(240,255,240)
  hot_pink = 0xFF69B4,                 // rgb(255,105,180)
  indian_red = 0xCD5C5C,               // rgb(205,92,92)
  indigo = 0x4B0082,                   // rgb(75,0,130)
  ivory = 0xFFFFF0,                    // rgb(255,255,240)
  khaki = 0xF0E68C,                    // rgb(240,230,140)
  lavender = 0xE6E6FA,                 // rgb(230,230,250)
  lavender_blush = 0xFFF0F5,           // rgb(255,240,245)
  lawn_green = 0x7CFC00,               // rgb(124,252,0)
  lemon_chiffon = 0xFFFACD,            // rgb(255,250,205)
  light_blue = 0xADD8E6,               // rgb(173,216,230)
  light_coral = 0xF08080,              // rgb(240,128,128)
  light_cyan = 0xE0FFFF,               // rgb(224,255,255)
  light_golden_rod_yellow = 0xFAFAD2,  // rgb(250,250,210)
  light_gray = 0xD3D3D3,               // rgb(211,211,211)
  light_green = 0x90EE90,              // rgb(144,238,144)
  light_pink = 0xFFB6C1,               // rgb(255,182,193)
  light_salmon = 0xFFA07A,             // rgb(255,160,122)
  light_sea_green = 0x20B2AA,          // rgb(32,178,170)
  light_sky_blue = 0x87CEFA,           // rgb(135,206,250)
  light_slate_gray = 0x778899,         // rgb(119,136,153)
  light_steel_blue = 0xB0C4DE,         // rgb(176,196,222)
  light_yellow = 0xFFFFE0,             // rgb(255,255,224)
  lime = 0x00FF00,                     // rgb(0,255,0)
  lime_green = 0x32CD32,               // rgb(50,205,50)
  linen = 0xFAF0E6,                    // rgb(250,240,230)
  magenta = 0xFF00FF,                  // rgb(255,0,255)
  maroon = 0x800000,                   // rgb(128,0,0)
  medium_aquamarine = 0x66CDAA,        // rgb(102,205,170)
  medium_blue = 0x0000CD,              // rgb(0,0,205)
  medium_orchid = 0xBA55D3,            // rgb(186,85,211)
  medium_purple = 0x9370DB,            // rgb(147,112,219)
  medium_sea_green = 0x3CB371,         // rgb(60,179,113)
  medium_slate_blue = 0x7B68EE,        // rgb(123,104,238)
  medium_spring_green = 0x00FA9A,      // rgb(0,250,154)
  medium_turquoise = 0x48D1CC,         // rgb(72,209,204)
  medium_violet_red = 0xC71585,        // rgb(199,21,133)
  midnight_blue = 0x191970,            // rgb(25,25,112)
  mint_cream = 0xF5FFFA,               // rgb(245,255,250)
  misty_rose = 0xFFE4E1,               // rgb(255,228,225)
  moccasin = 0xFFE4B5,                 // rgb(255,228,181)
  navajo_white = 0xFFDEAD,             // rgb(255,222,173)
  navy = 0x000080,                     // rgb(0,0,128)
  old_lace = 0xFDF5E6,                 // rgb(253,245,230)
  olive = 0x808000,                    // rgb(128,128,0)
  olive_drab = 0x6B8E23,               // rgb(107,142,35)
  orange = 0xFFA500,                   // rgb(255,165,0)
  orange_red = 0xFF4500,               // rgb(255,69,0)
  orchid = 0xDA70D6,                   // rgb(218,112,214)
  pale_golden_rod = 0xEEE8AA,          // rgb(238,232,170)
  pale_green = 0x98FB98,               // rgb(152,251,152)
  pale_turquoise = 0xAFEEEE,           // rgb(175,238,238)
  pale_violet_red = 0xDB7093,          // rgb(219,112,147)
  papaya_whip = 0xFFEFD5,              // rgb(255,239,213)
  peach_puff = 0xFFDAB9,               // rgb(255,218,185)
  peru = 0xCD853F,                     // rgb(205,133,63)
  pink = 0xFFC0CB,                     // rgb(255,192,203)
  plum = 0xDDA0DD,                     // rgb(221,160,221)
  powder_blue = 0xB0E0E6,              // rgb(176,224,230)
  purple = 0x800080,                   // rgb(128,0,128)
  rebecca_purple = 0x663399,           // rgb(102,51,153)
  red = 0xFF0000,                      // rgb(255,0,0)
  rosy_brown = 0xBC8F8F,               // rgb(188,143,143)
  royal_blue = 0x4169E1,               // rgb(65,105,225)
  saddle_brown = 0x8B4513,             // rgb(139,69,19)
  salmon = 0xFA8072,                   // rgb(250,128,114)
  sandy_brown = 0xF4A460,              // rgb(244,164,96)
  sea_green = 0x2E8B57,                // rgb(46,139,87)
  sea_shell = 0xFFF5EE,                // rgb(255,245,238)
  sienna = 0xA0522D,                   // rgb(160,82,45)
  silver = 0xC0C0C0,                   // rgb(192,192,192)
  sky_blue = 0x87CEEB,                 // rgb(135,206,235)
  slate_blue = 0x6A5ACD,               // rgb(106,90,205)
  slate_gray = 0x708090,               // rgb(112,128,144)
  snow = 0xFFFAFA,                     // rgb(255,250,250)
  spring_green = 0x00FF7F,             // rgb(0,255,127)
  steel_blue = 0x4682B4,               // rgb(70,130,180)
  tan = 0xD2B48C,                      // rgb(210,180,140)
  teal = 0x008080,                     // rgb(0,128,128)
  thistle = 0xD8BFD8,                  // rgb(216,191,216)
  tomato = 0xFF6347,                   // rgb(255,99,71)
  turquoise = 0x40E0D0,                // rgb(64,224,208)
  violet = 0xEE82EE,                   // rgb(238,130,238)
  wheat = 0xF5DEB3,                    // rgb(245,222,179)
  white = 0xFFFFFF,                    // rgb(255,255,255)
  white_smoke = 0xF5F5F5,              // rgb(245,245,245)
  yellow = 0xFFFF00,                   // rgb(255,255,0)
  yellow_green = 0x9ACD32              // rgb(154,205,50)
};                                     // enum class color

enum class terminal_color : uint8_t {
  black = 30,
  red,
  green,
  yellow,
  blue,
  magenta,
  cyan,
  white,
  bright_black = 90,
  bright_red,
  bright_green,
  bright_yellow,
  bright_blue,
  bright_magenta,
  bright_cyan,
  bright_white
};

enum class emphasis : uint8_t {
  bold = 1,
  faint = 1 << 1,
  italic = 1 << 2,
  underline = 1 << 3,
  blink = 1 << 4,
  reverse = 1 << 5,
  conceal = 1 << 6,
  strikethrough = 1 << 7,
};

// rgb is a struct for red, green and blue colors.
// Using the name "rgb" makes some editors show the color in a tooltip.
struct rgb {
  FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}
  FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}
  FMT_CONSTEXPR rgb(uint32_t hex)
      : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b(hex & 0xFF) {}
  FMT_CONSTEXPR rgb(color hex)
      : r((uint32_t(hex) >> 16) & 0xFF),
        g((uint32_t(hex) >> 8) & 0xFF),
        b(uint32_t(hex) & 0xFF) {}
  uint8_t r;
  uint8_t g;
  uint8_t b;
};

FMT_BEGIN_DETAIL_NAMESPACE

// color is a struct of either a rgb color or a terminal color.
struct color_type {
  FMT_CONSTEXPR color_type() FMT_NOEXCEPT : is_rgb(), value{} {}
  FMT_CONSTEXPR color_type(color rgb_color) FMT_NOEXCEPT : is_rgb(true),
                                                           value{} {
    value.rgb_color = static_cast<uint32_t>(rgb_color);
  }
  FMT_CONSTEXPR color_type(rgb rgb_color) FMT_NOEXCEPT : is_rgb(true), value{} {
    value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16) |
                      (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;
  }
  FMT_CONSTEXPR color_type(terminal_color term_color) FMT_NOEXCEPT : is_rgb(),
                                                                     value{} {
    value.term_color = static_cast<uint8_t>(term_color);
  }
  bool is_rgb;
  union color_union {
    uint8_t term_color;
    uint32_t rgb_color;
  } value;
};

FMT_END_DETAIL_NAMESPACE

/** A text style consisting of foreground and background colors and emphasis. */
class text_style {
 public:
  FMT_CONSTEXPR text_style(emphasis em = emphasis()) FMT_NOEXCEPT
      : set_foreground_color(),
        set_background_color(),
        ems(em) {}

  FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {
    if (!set_foreground_color) {
      set_foreground_color = rhs.set_foreground_color;
      foreground_color = rhs.foreground_color;
    } else if (rhs.set_foreground_color) {
      if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
        FMT_THROW(format_error("can't OR a terminal color"));
      foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;
    }

    if (!set_background_color) {
      set_background_color = rhs.set_background_color;
      background_color = rhs.background_color;
    } else if (rhs.set_background_color) {
      if (!background_color.is_rgb || !rhs.background_color.is_rgb)
        FMT_THROW(format_error("can't OR a terminal color"));
      background_color.value.rgb_color |= rhs.background_color.value.rgb_color;
    }

    ems = static_cast<emphasis>(static_cast<uint8_t>(ems) |
                                static_cast<uint8_t>(rhs.ems));
    return *this;
  }

  friend FMT_CONSTEXPR text_style operator|(text_style lhs,
                                            const text_style& rhs) {
    return lhs |= rhs;
  }

  FMT_DEPRECATED_NONMSVC FMT_CONSTEXPR text_style& operator&=(
      const text_style& rhs) {
    return and_assign(rhs);
  }

  FMT_DEPRECATED_NONMSVC friend FMT_CONSTEXPR text_style
  operator&(text_style lhs, const text_style& rhs) {
    return lhs.and_assign(rhs);
  }

  FMT_CONSTEXPR bool has_foreground() const FMT_NOEXCEPT {
    return set_foreground_color;
  }
  FMT_CONSTEXPR bool has_background() const FMT_NOEXCEPT {
    return set_background_color;
  }
  FMT_CONSTEXPR bool has_emphasis() const FMT_NOEXCEPT {
    return static_cast<uint8_t>(ems) != 0;
  }
  FMT_CONSTEXPR detail::color_type get_foreground() const FMT_NOEXCEPT {
    FMT_ASSERT(has_foreground(), "no foreground specified for this style");
    return foreground_color;
  }
  FMT_CONSTEXPR detail::color_type get_background() const FMT_NOEXCEPT {
    FMT_ASSERT(has_background(), "no background specified for this style");
    return background_color;
  }
  FMT_CONSTEXPR emphasis get_emphasis() const FMT_NOEXCEPT {
    FMT_ASSERT(has_emphasis(), "no emphasis specified for this style");
    return ems;
  }

 private:
  FMT_CONSTEXPR text_style(bool is_foreground,
                           detail::color_type text_color) FMT_NOEXCEPT
      : set_foreground_color(),
        set_background_color(),
        ems() {
    if (is_foreground) {
      foreground_color = text_color;
      set_foreground_color = true;
    } else {
      background_color = text_color;
      set_background_color = true;
    }
  }

  // DEPRECATED!
  FMT_CONSTEXPR text_style& and_assign(const text_style& rhs) {
    if (!set_foreground_color) {
      set_foreground_color = rhs.set_foreground_color;
      foreground_color = rhs.foreground_color;
    } else if (rhs.set_foreground_color) {
      if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
        FMT_THROW(format_error("can't AND a terminal color"));
      foreground_color.value.rgb_color &= rhs.foreground_color.value.rgb_color;
    }

    if (!set_background_color) {
      set_background_color = rhs.set_background_color;
      background_color = rhs.background_color;
    } else if (rhs.set_background_color) {
      if (!background_color.is_rgb || !rhs.background_color.is_rgb)
        FMT_THROW(format_error("can't AND a terminal color"));
      background_color.value.rgb_color &= rhs.background_color.value.rgb_color;
    }

    ems = static_cast<emphasis>(static_cast<uint8_t>(ems) &
                                static_cast<uint8_t>(rhs.ems));
    return *this;
  }

  friend FMT_CONSTEXPR_DECL text_style fg(detail::color_type foreground)
      FMT_NOEXCEPT;

  friend FMT_CONSTEXPR_DECL text_style bg(detail::color_type background)
      FMT_NOEXCEPT;

  detail::color_type foreground_color;
  detail::color_type background_color;
  bool set_foreground_color;
  bool set_background_color;
  emphasis ems;
};

/** Creates a text style from the foreground (text) color. */
FMT_CONSTEXPR inline text_style fg(detail::color_type foreground) FMT_NOEXCEPT {
  return text_style(true, foreground);
}

/** Creates a text style from the background color. */
FMT_CONSTEXPR inline text_style bg(detail::color_type background) FMT_NOEXCEPT {
  return text_style(false, background);
}

FMT_CONSTEXPR inline text_style operator|(emphasis lhs,
                                          emphasis rhs) FMT_NOEXCEPT {
  return text_style(lhs) | rhs;
}

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Char> struct ansi_color_escape {
  FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
                                  const char* esc) FMT_NOEXCEPT {
    // If we have a terminal color, we need to output another escape code
    // sequence.
    if (!text_color.is_rgb) {
      bool is_background = esc == string_view("\x1b[48;2;");
      uint32_t value = text_color.value.term_color;
      // Background ASCII codes are the same as the foreground ones but with
      // 10 more.
      if (is_background) value += 10u;

      size_t index = 0;
      buffer[index++] = static_cast<Char>('\x1b');
      buffer[index++] = static_cast<Char>('[');

      if (value >= 100u) {
        buffer[index++] = static_cast<Char>('1');
        value %= 100u;
      }
      buffer[index++] = static_cast<Char>('0' + value / 10u);
      buffer[index++] = static_cast<Char>('0' + value % 10u);

      buffer[index++] = static_cast<Char>('m');
      buffer[index++] = static_cast<Char>('\0');
      return;
    }

    for (int i = 0; i < 7; i++) {
      buffer[i] = static_cast<Char>(esc[i]);
    }
    rgb color(text_color.value.rgb_color);
    to_esc(color.r, buffer + 7, ';');
    to_esc(color.g, buffer + 11, ';');
    to_esc(color.b, buffer + 15, 'm');
    buffer[19] = static_cast<Char>(0);
  }
  FMT_CONSTEXPR ansi_color_escape(emphasis em) FMT_NOEXCEPT {
    uint8_t em_codes[num_emphases] = {};
    if (has_emphasis(em, emphasis::bold)) em_codes[0] = 1;
    if (has_emphasis(em, emphasis::faint)) em_codes[1] = 2;
    if (has_emphasis(em, emphasis::italic)) em_codes[2] = 3;
    if (has_emphasis(em, emphasis::underline)) em_codes[3] = 4;
    if (has_emphasis(em, emphasis::blink)) em_codes[4] = 5;
    if (has_emphasis(em, emphasis::reverse)) em_codes[5] = 7;
    if (has_emphasis(em, emphasis::conceal)) em_codes[6] = 8;
    if (has_emphasis(em, emphasis::strikethrough)) em_codes[7] = 9;

    size_t index = 0;
    for (size_t i = 0; i < num_emphases; ++i) {
      if (!em_codes[i]) continue;
      buffer[index++] = static_cast<Char>('\x1b');
      buffer[index++] = static_cast<Char>('[');
      buffer[index++] = static_cast<Char>('0' + em_codes[i]);
      buffer[index++] = static_cast<Char>('m');
    }
    buffer[index++] = static_cast<Char>(0);
  }
  FMT_CONSTEXPR operator const Char*() const FMT_NOEXCEPT { return buffer; }

  FMT_CONSTEXPR const Char* begin() const FMT_NOEXCEPT { return buffer; }
  FMT_CONSTEXPR_CHAR_TRAITS const Char* end() const FMT_NOEXCEPT {
    return buffer + std::char_traits<Char>::length(buffer);
  }

 private:
  static constexpr size_t num_emphases = 8;
  Char buffer[7u + 3u * num_emphases + 1u];

  static FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,
                                   char delimiter) FMT_NOEXCEPT {
    out[0] = static_cast<Char>('0' + c / 100);
    out[1] = static_cast<Char>('0' + c / 10 % 10);
    out[2] = static_cast<Char>('0' + c % 10);
    out[3] = static_cast<Char>(delimiter);
  }
  static FMT_CONSTEXPR bool has_emphasis(emphasis em,
                                         emphasis mask) FMT_NOEXCEPT {
    return static_cast<uint8_t>(em) & static_cast<uint8_t>(mask);
  }
};

template <typename Char>
FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(
    detail::color_type foreground) FMT_NOEXCEPT {
  return ansi_color_escape<Char>(foreground, "\x1b[38;2;");
}

template <typename Char>
FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(
    detail::color_type background) FMT_NOEXCEPT {
  return ansi_color_escape<Char>(background, "\x1b[48;2;");
}

template <typename Char>
FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) FMT_NOEXCEPT {
  return ansi_color_escape<Char>(em);
}

template <typename Char>
inline void fputs(const Char* chars, FILE* stream) FMT_NOEXCEPT {
  std::fputs(chars, stream);
}

template <>
inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) FMT_NOEXCEPT {
  std::fputws(chars, stream);
}

template <typename Char> inline void reset_color(FILE* stream) FMT_NOEXCEPT {
  fputs("\x1b[0m", stream);
}

template <> inline void reset_color<wchar_t>(FILE* stream) FMT_NOEXCEPT {
  fputs(L"\x1b[0m", stream);
}

template <typename Char>
inline void reset_color(buffer<Char>& buffer) FMT_NOEXCEPT {
  auto reset_color = string_view("\x1b[0m");
  buffer.append(reset_color.begin(), reset_color.end());
}

template <typename Char>
void vformat_to(buffer<Char>& buf, const text_style& ts,
                basic_string_view<Char> format_str,
                basic_format_args<buffer_context<type_identity_t<Char>>> args) {
  bool has_style = false;
  if (ts.has_emphasis()) {
    has_style = true;
    auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
    buf.append(emphasis.begin(), emphasis.end());
  }
  if (ts.has_foreground()) {
    has_style = true;
    auto foreground = detail::make_foreground_color<Char>(ts.get_foreground());
    buf.append(foreground.begin(), foreground.end());
  }
  if (ts.has_background()) {
    has_style = true;
    auto background = detail::make_background_color<Char>(ts.get_background());
    buf.append(background.begin(), background.end());
  }
  detail::vformat_to(buf, format_str, args, {});
  if (has_style) detail::reset_color<Char>(buf);
}

FMT_END_DETAIL_NAMESPACE

template <typename S, typename Char = char_t<S>>
void vprint(std::FILE* f, const text_style& ts, const S& format,
            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
  basic_memory_buffer<Char> buf;
  detail::vformat_to(buf, ts, to_string_view(format), args);
  buf.push_back(Char(0));
  detail::fputs(buf.data(), f);
}

/**
  \rst
  Formats a string and prints it to the specified file stream using ANSI
  escape sequences to specify text formatting.

  **Example**::

    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
               "Elapsed time: {0:.2f} seconds", 1.23);
  \endrst
 */
template <typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_string<S>::value)>
void print(std::FILE* f, const text_style& ts, const S& format_str,
           const Args&... args) {
  vprint(f, ts, format_str,
         fmt::make_args_checked<Args...>(format_str, args...));
}

/**
  \rst
  Formats a string and prints it to stdout using ANSI escape sequences to
  specify text formatting.

  **Example**::

    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
               "Elapsed time: {0:.2f} seconds", 1.23);
  \endrst
 */
template <typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_string<S>::value)>
void print(const text_style& ts, const S& format_str, const Args&... args) {
  return print(stdout, ts, format_str, args...);
}

template <typename S, typename Char = char_t<S>>
inline std::basic_string<Char> vformat(
    const text_style& ts, const S& format_str,
    basic_format_args<buffer_context<type_identity_t<Char>>> args) {
  basic_memory_buffer<Char> buf;
  detail::vformat_to(buf, ts, to_string_view(format_str), args);
  return fmt::to_string(buf);
}

/**
  \rst
  Formats arguments and returns the result as a string using ANSI
  escape sequences to specify text formatting.

  **Example**::

    #include <fmt/color.h>
    std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),
                                      "The answer is {}", 42);
  \endrst
*/
template <typename S, typename... Args, typename Char = char_t<S>>
inline std::basic_string<Char> format(const text_style& ts, const S& format_str,
                                      const Args&... args) {
  return fmt::vformat(ts, to_string_view(format_str),
                      fmt::make_args_checked<Args...>(format_str, args...));
}

/**
  Formats a string with the given text_style and writes the output to ``out``.
 */
template <typename OutputIt, typename Char,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
OutputIt vformat_to(
    OutputIt out, const text_style& ts, basic_string_view<Char> format_str,
    basic_format_args<buffer_context<type_identity_t<Char>>> args) {
  auto&& buf = detail::get_buffer<Char>(out);
  detail::vformat_to(buf, ts, format_str, args);
  return detail::get_iterator(buf);
}

/**
  \rst
  Formats arguments with the given text_style, writes the result to the output
  iterator ``out`` and returns the iterator past the end of the output range.

  **Example**::

    std::vector<char> out;
    fmt::format_to(std::back_inserter(out),
                   fmt::emphasis::bold | fg(fmt::color::red), "{}", 42);
  \endrst
*/
template <typename OutputIt, typename S, typename... Args,
          bool enable = detail::is_output_iterator<OutputIt, char_t<S>>::value&&
              detail::is_string<S>::value>
inline auto format_to(OutputIt out, const text_style& ts, const S& format_str,
                      Args&&... args) ->
    typename std::enable_if<enable, OutputIt>::type {
  return vformat_to(out, ts, to_string_view(format_str),
                    fmt::make_args_checked<Args...>(format_str, args...));
}

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_COLOR_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/compile.h`:

```h
// Formatting library for C++ - experimental format string compilation
//
// Copyright (c) 2012 - present, Victor Zverovich and fmt contributors
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_COMPILE_H_
#define FMT_COMPILE_H_

#include "format.h"

FMT_BEGIN_NAMESPACE
namespace detail {

// An output iterator that counts the number of objects written to it and
// discards them.
class counting_iterator {
 private:
  size_t count_;

 public:
  using iterator_category = std::output_iterator_tag;
  using difference_type = std::ptrdiff_t;
  using pointer = void;
  using reference = void;
  using _Unchecked_type = counting_iterator;  // Mark iterator as checked.

  struct value_type {
    template <typename T> void operator=(const T&) {}
  };

  counting_iterator() : count_(0) {}

  size_t count() const { return count_; }

  counting_iterator& operator++() {
    ++count_;
    return *this;
  }
  counting_iterator operator++(int) {
    auto it = *this;
    ++*this;
    return it;
  }

  friend counting_iterator operator+(counting_iterator it, difference_type n) {
    it.count_ += static_cast<size_t>(n);
    return it;
  }

  value_type operator*() const { return {}; }
};

template <typename Char, typename InputIt>
inline counting_iterator copy_str(InputIt begin, InputIt end,
                                  counting_iterator it) {
  return it + (end - begin);
}

template <typename OutputIt> class truncating_iterator_base {
 protected:
  OutputIt out_;
  size_t limit_;
  size_t count_ = 0;

  truncating_iterator_base() : out_(), limit_(0) {}

  truncating_iterator_base(OutputIt out, size_t limit)
      : out_(out), limit_(limit) {}

 public:
  using iterator_category = std::output_iterator_tag;
  using value_type = typename std::iterator_traits<OutputIt>::value_type;
  using difference_type = std::ptrdiff_t;
  using pointer = void;
  using reference = void;
  using _Unchecked_type =
      truncating_iterator_base;  // Mark iterator as checked.

  OutputIt base() const { return out_; }
  size_t count() const { return count_; }
};

// An output iterator that truncates the output and counts the number of objects
// written to it.
template <typename OutputIt,
          typename Enable = typename std::is_void<
              typename std::iterator_traits<OutputIt>::value_type>::type>
class truncating_iterator;

template <typename OutputIt>
class truncating_iterator<OutputIt, std::false_type>
    : public truncating_iterator_base<OutputIt> {
  mutable typename truncating_iterator_base<OutputIt>::value_type blackhole_;

 public:
  using value_type = typename truncating_iterator_base<OutputIt>::value_type;

  truncating_iterator() = default;

  truncating_iterator(OutputIt out, size_t limit)
      : truncating_iterator_base<OutputIt>(out, limit) {}

  truncating_iterator& operator++() {
    if (this->count_++ < this->limit_) ++this->out_;
    return *this;
  }

  truncating_iterator operator++(int) {
    auto it = *this;
    ++*this;
    return it;
  }

  value_type& operator*() const {
    return this->count_ < this->limit_ ? *this->out_ : blackhole_;
  }
};

template <typename OutputIt>
class truncating_iterator<OutputIt, std::true_type>
    : public truncating_iterator_base<OutputIt> {
 public:
  truncating_iterator() = default;

  truncating_iterator(OutputIt out, size_t limit)
      : truncating_iterator_base<OutputIt>(out, limit) {}

  template <typename T> truncating_iterator& operator=(T val) {
    if (this->count_++ < this->limit_) *this->out_++ = val;
    return *this;
  }

  truncating_iterator& operator++() { return *this; }
  truncating_iterator& operator++(int) { return *this; }
  truncating_iterator& operator*() { return *this; }
};

// A compile-time string which is compiled into fast formatting code.
class compiled_string {};

template <typename S>
struct is_compiled_string : std::is_base_of<compiled_string, S> {};

/**
  \rst
  Converts a string literal *s* into a format string that will be parsed at
  compile time and converted into efficient formatting code. Requires C++17
  ``constexpr if`` compiler support.

  **Example**::

    // Converts 42 into std::string using the most efficient method and no
    // runtime format string processing.
    std::string s = fmt::format(FMT_COMPILE("{}"), 42);
  \endrst
 */
#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
#  define FMT_COMPILE(s) \
    FMT_STRING_IMPL(s, fmt::detail::compiled_string, explicit)
#else
#  define FMT_COMPILE(s) FMT_STRING(s)
#endif

#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct udl_compiled_string : compiled_string {
  using char_type = Char;
  constexpr operator basic_string_view<char_type>() const {
    return {Str.data, N - 1};
  }
};
#endif

template <typename T, typename... Tail>
const T& first(const T& value, const Tail&...) {
  return value;
}

#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
template <typename... Args> struct type_list {};

// Returns a reference to the argument at index N from [first, rest...].
template <int N, typename T, typename... Args>
constexpr const auto& get([[maybe_unused]] const T& first,
                          [[maybe_unused]] const Args&... rest) {
  static_assert(N < 1 + sizeof...(Args), "index is out of bounds");
  if constexpr (N == 0)
    return first;
  else
    return detail::get<N - 1>(rest...);
}

template <typename Char, typename... Args>
constexpr int get_arg_index_by_name(basic_string_view<Char> name,
                                    type_list<Args...>) {
  return get_arg_index_by_name<Args...>(name);
}

template <int N, typename> struct get_type_impl;

template <int N, typename... Args> struct get_type_impl<N, type_list<Args...>> {
  using type =
      remove_cvref_t<decltype(detail::get<N>(std::declval<Args>()...))>;
};

template <int N, typename T>
using get_type = typename get_type_impl<N, T>::type;

template <typename T> struct is_compiled_format : std::false_type {};

template <typename Char> struct text {
  basic_string_view<Char> data;
  using char_type = Char;

  template <typename OutputIt, typename... Args>
  constexpr OutputIt format(OutputIt out, const Args&...) const {
    return write<Char>(out, data);
  }
};

template <typename Char>
struct is_compiled_format<text<Char>> : std::true_type {};

template <typename Char>
constexpr text<Char> make_text(basic_string_view<Char> s, size_t pos,
                               size_t size) {
  return {{&s[pos], size}};
}

template <typename Char> struct code_unit {
  Char value;
  using char_type = Char;

  template <typename OutputIt, typename... Args>
  constexpr OutputIt format(OutputIt out, const Args&...) const {
    return write<Char>(out, value);
  }
};

// This ensures that the argument type is convertible to `const T&`.
template <typename T, int N, typename... Args>
constexpr const T& get_arg_checked(const Args&... args) {
  const auto& arg = detail::get<N>(args...);
  if constexpr (detail::is_named_arg<remove_cvref_t<decltype(arg)>>()) {
    return arg.value;
  } else {
    return arg;
  }
}

template <typename Char>
struct is_compiled_format<code_unit<Char>> : std::true_type {};

// A replacement field that refers to argument N.
template <typename Char, typename T, int N> struct field {
  using char_type = Char;

  template <typename OutputIt, typename... Args>
  constexpr OutputIt format(OutputIt out, const Args&... args) const {
    return write<Char>(out, get_arg_checked<T, N>(args...));
  }
};

template <typename Char, typename T, int N>
struct is_compiled_format<field<Char, T, N>> : std::true_type {};

// A replacement field that refers to argument with name.
template <typename Char> struct runtime_named_field {
  using char_type = Char;
  basic_string_view<Char> name;

  template <typename OutputIt, typename T>
  constexpr static bool try_format_argument(
      OutputIt& out,
      // [[maybe_unused]] due to unused-but-set-parameter warning in GCC 7,8,9
      [[maybe_unused]] basic_string_view<Char> arg_name, const T& arg) {
    if constexpr (is_named_arg<typename std::remove_cv<T>::type>::value) {
      if (arg_name == arg.name) {
        out = write<Char>(out, arg.value);
        return true;
      }
    }
    return false;
  }

  template <typename OutputIt, typename... Args>
  constexpr OutputIt format(OutputIt out, const Args&... args) const {
    bool found = (try_format_argument(out, name, args) || ...);
    if (!found) {
      FMT_THROW(format_error("argument with specified name is not found"));
    }
    return out;
  }
};

template <typename Char>
struct is_compiled_format<runtime_named_field<Char>> : std::true_type {};

// A replacement field that refers to argument N and has format specifiers.
template <typename Char, typename T, int N> struct spec_field {
  using char_type = Char;
  formatter<T, Char> fmt;

  template <typename OutputIt, typename... Args>
  constexpr FMT_INLINE OutputIt format(OutputIt out,
                                       const Args&... args) const {
    const auto& vargs =
        fmt::make_format_args<basic_format_context<OutputIt, Char>>(args...);
    basic_format_context<OutputIt, Char> ctx(out, vargs);
    return fmt.format(get_arg_checked<T, N>(args...), ctx);
  }
};

template <typename Char, typename T, int N>
struct is_compiled_format<spec_field<Char, T, N>> : std::true_type {};

template <typename L, typename R> struct concat {
  L lhs;
  R rhs;
  using char_type = typename L::char_type;

  template <typename OutputIt, typename... Args>
  constexpr OutputIt format(OutputIt out, const Args&... args) const {
    out = lhs.format(out, args...);
    return rhs.format(out, args...);
  }
};

template <typename L, typename R>
struct is_compiled_format<concat<L, R>> : std::true_type {};

template <typename L, typename R>
constexpr concat<L, R> make_concat(L lhs, R rhs) {
  return {lhs, rhs};
}

struct unknown_format {};

template <typename Char>
constexpr size_t parse_text(basic_string_view<Char> str, size_t pos) {
  for (size_t size = str.size(); pos != size; ++pos) {
    if (str[pos] == '{' || str[pos] == '}') break;
  }
  return pos;
}

template <typename Args, size_t POS, int ID, typename S>
constexpr auto compile_format_string(S format_str);

template <typename Args, size_t POS, int ID, typename T, typename S>
constexpr auto parse_tail(T head, S format_str) {
  if constexpr (POS !=
                basic_string_view<typename S::char_type>(format_str).size()) {
    constexpr auto tail = compile_format_string<Args, POS, ID>(format_str);
    if constexpr (std::is_same<remove_cvref_t<decltype(tail)>,
                               unknown_format>())
      return tail;
    else
      return make_concat(head, tail);
  } else {
    return head;
  }
}

template <typename T, typename Char> struct parse_specs_result {
  formatter<T, Char> fmt;
  size_t end;
  int next_arg_id;
};

constexpr int manual_indexing_id = -1;

template <typename T, typename Char>
constexpr parse_specs_result<T, Char> parse_specs(basic_string_view<Char> str,
                                                  size_t pos, int next_arg_id) {
  str.remove_prefix(pos);
  auto ctx = basic_format_parse_context<Char>(str, {}, next_arg_id);
  auto f = formatter<T, Char>();
  auto end = f.parse(ctx);
  return {f, pos + fmt::detail::to_unsigned(end - str.data()) + 1,
          next_arg_id == 0 ? manual_indexing_id : ctx.next_arg_id()};
}

template <typename Char> struct arg_id_handler {
  arg_ref<Char> arg_id;

  constexpr int operator()() {
    FMT_ASSERT(false, "handler cannot be used with automatic indexing");
    return 0;
  }
  constexpr int operator()(int id) {
    arg_id = arg_ref<Char>(id);
    return 0;
  }
  constexpr int operator()(basic_string_view<Char> id) {
    arg_id = arg_ref<Char>(id);
    return 0;
  }

  constexpr void on_error(const char* message) {
    FMT_THROW(format_error(message));
  }
};

template <typename Char> struct parse_arg_id_result {
  arg_ref<Char> arg_id;
  const Char* arg_id_end;
};

template <int ID, typename Char>
constexpr auto parse_arg_id(const Char* begin, const Char* end) {
  auto handler = arg_id_handler<Char>{arg_ref<Char>{}};
  auto arg_id_end = parse_arg_id(begin, end, handler);
  return parse_arg_id_result<Char>{handler.arg_id, arg_id_end};
}

template <typename T, typename Enable = void> struct field_type {
  using type = remove_cvref_t<T>;
};

template <typename T>
struct field_type<T, enable_if_t<detail::is_named_arg<T>::value>> {
  using type = remove_cvref_t<decltype(T::value)>;
};

template <typename T, typename Args, size_t END_POS, int ARG_INDEX, int NEXT_ID,
          typename S>
constexpr auto parse_replacement_field_then_tail(S format_str) {
  using char_type = typename S::char_type;
  constexpr auto str = basic_string_view<char_type>(format_str);
  constexpr char_type c = END_POS != str.size() ? str[END_POS] : char_type();
  if constexpr (c == '}') {
    return parse_tail<Args, END_POS + 1, NEXT_ID>(
        field<char_type, typename field_type<T>::type, ARG_INDEX>(),
        format_str);
  } else if constexpr (c == ':') {
    constexpr auto result = parse_specs<typename field_type<T>::type>(
        str, END_POS + 1, NEXT_ID == manual_indexing_id ? 0 : NEXT_ID);
    return parse_tail<Args, result.end, result.next_arg_id>(
        spec_field<char_type, typename field_type<T>::type, ARG_INDEX>{
            result.fmt},
        format_str);
  }
}

// Compiles a non-empty format string and returns the compiled representation
// or unknown_format() on unrecognized input.
template <typename Args, size_t POS, int ID, typename S>
constexpr auto compile_format_string(S format_str) {
  using char_type = typename S::char_type;
  constexpr auto str = basic_string_view<char_type>(format_str);
  if constexpr (str[POS] == '{') {
    if constexpr (POS + 1 == str.size())
      FMT_THROW(format_error("unmatched '{' in format string"));
    if constexpr (str[POS + 1] == '{') {
      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
    } else if constexpr (str[POS + 1] == '}' || str[POS + 1] == ':') {
      static_assert(ID != manual_indexing_id,
                    "cannot switch from manual to automatic argument indexing");
      constexpr auto next_id =
          ID != manual_indexing_id ? ID + 1 : manual_indexing_id;
      return parse_replacement_field_then_tail<get_type<ID, Args>, Args,
                                               POS + 1, ID, next_id>(
          format_str);
    } else {
      constexpr auto arg_id_result =
          parse_arg_id<ID>(str.data() + POS + 1, str.data() + str.size());
      constexpr auto arg_id_end_pos = arg_id_result.arg_id_end - str.data();
      constexpr char_type c =
          arg_id_end_pos != str.size() ? str[arg_id_end_pos] : char_type();
      static_assert(c == '}' || c == ':', "missing '}' in format string");
      if constexpr (arg_id_result.arg_id.kind == arg_id_kind::index) {
        static_assert(
            ID == manual_indexing_id || ID == 0,
            "cannot switch from automatic to manual argument indexing");
        constexpr auto arg_index = arg_id_result.arg_id.val.index;
        return parse_replacement_field_then_tail<get_type<arg_index, Args>,
                                                 Args, arg_id_end_pos,
                                                 arg_index, manual_indexing_id>(
            format_str);
      } else if constexpr (arg_id_result.arg_id.kind == arg_id_kind::name) {
        constexpr auto arg_index =
            get_arg_index_by_name(arg_id_result.arg_id.val.name, Args{});
        if constexpr (arg_index != invalid_arg_index) {
          constexpr auto next_id =
              ID != manual_indexing_id ? ID + 1 : manual_indexing_id;
          return parse_replacement_field_then_tail<
              decltype(get_type<arg_index, Args>::value), Args, arg_id_end_pos,
              arg_index, next_id>(format_str);
        } else {
          if constexpr (c == '}') {
            return parse_tail<Args, arg_id_end_pos + 1, ID>(
                runtime_named_field<char_type>{arg_id_result.arg_id.val.name},
                format_str);
          } else if constexpr (c == ':') {
            return unknown_format();  // no type info for specs parsing
          }
        }
      }
    }
  } else if constexpr (str[POS] == '}') {
    if constexpr (POS + 1 == str.size())
      FMT_THROW(format_error("unmatched '}' in format string"));
    return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
  } else {
    constexpr auto end = parse_text(str, POS + 1);
    if constexpr (end - POS > 1) {
      return parse_tail<Args, end, ID>(make_text(str, POS, end - POS),
                                       format_str);
    } else {
      return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]},
                                       format_str);
    }
  }
}

template <typename... Args, typename S,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
constexpr auto compile(S format_str) {
  constexpr auto str = basic_string_view<typename S::char_type>(format_str);
  if constexpr (str.size() == 0) {
    return detail::make_text(str, 0, 0);
  } else {
    constexpr auto result =
        detail::compile_format_string<detail::type_list<Args...>, 0, 0>(
            format_str);
    return result;
  }
}
#endif  // defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
}  // namespace detail

FMT_MODULE_EXPORT_BEGIN

#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)

template <typename CompiledFormat, typename... Args,
          typename Char = typename CompiledFormat::char_type,
          FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
                                          const Args&... args) {
  auto s = std::basic_string<Char>();
  cf.format(std::back_inserter(s), args...);
  return s;
}

template <typename OutputIt, typename CompiledFormat, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
constexpr FMT_INLINE OutputIt format_to(OutputIt out, const CompiledFormat& cf,
                                        const Args&... args) {
  return cf.format(out, args...);
}

template <typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
                                                           Args&&... args) {
  if constexpr (std::is_same<typename S::char_type, char>::value) {
    constexpr auto str = basic_string_view<typename S::char_type>(S());
    if constexpr (str.size() == 2 && str[0] == '{' && str[1] == '}') {
      const auto& first = detail::first(args...);
      if constexpr (detail::is_named_arg<
                        remove_cvref_t<decltype(first)>>::value) {
        return fmt::to_string(first.value);
      } else {
        return fmt::to_string(first);
      }
    }
  }
  constexpr auto compiled = detail::compile<Args...>(S());
  if constexpr (std::is_same<remove_cvref_t<decltype(compiled)>,
                             detail::unknown_format>()) {
    return format(static_cast<basic_string_view<typename S::char_type>>(S()),
                  std::forward<Args>(args)...);
  } else {
    return format(compiled, std::forward<Args>(args)...);
  }
}

template <typename OutputIt, typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {
  constexpr auto compiled = detail::compile<Args...>(S());
  if constexpr (std::is_same<remove_cvref_t<decltype(compiled)>,
                             detail::unknown_format>()) {
    return format_to(out,
                     static_cast<basic_string_view<typename S::char_type>>(S()),
                     std::forward<Args>(args)...);
  } else {
    return format_to(out, compiled, std::forward<Args>(args)...);
  }
}
#endif

template <typename OutputIt, typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n,
                                         const S& format_str, Args&&... args) {
  auto it = format_to(detail::truncating_iterator<OutputIt>(out, n), format_str,
                      std::forward<Args>(args)...);
  return {it.base(), it.count()};
}

template <typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
size_t formatted_size(const S& format_str, const Args&... args) {
  return format_to(detail::counting_iterator(), format_str, args...).count();
}

template <typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
void print(std::FILE* f, const S& format_str, const Args&... args) {
  memory_buffer buffer;
  format_to(std::back_inserter(buffer), format_str, args...);
  detail::print(f, {buffer.data(), buffer.size()});
}

template <typename S, typename... Args,
          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
void print(const S& format_str, const Args&... args) {
  print(stdout, format_str, args...);
}

#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
inline namespace literals {
template <detail_exported::fixed_string Str>
constexpr detail::udl_compiled_string<
    remove_cvref_t<decltype(Str.data[0])>,
    sizeof(Str.data) / sizeof(decltype(Str.data[0])), Str>
operator""_cf() {
  return {};
}
}  // namespace literals
#endif

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_COMPILE_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/core.h`:

```h
// Formatting library for C++ - the core API for char/UTF-8
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_CORE_H_
#define FMT_CORE_H_

#include <cstddef>  // std::byte
#include <cstdio>   // std::FILE
#include <cstring>
#include <iterator>
#include <limits>
#include <string>
#include <type_traits>

// The fmt library version in the form major * 10000 + minor * 100 + patch.
#define FMT_VERSION 80101

#if defined(__clang__) && !defined(__ibmxl__)
#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
#else
#  define FMT_CLANG_VERSION 0
#endif

#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER) && \
    !defined(__NVCOMPILER)
#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
#else
#  define FMT_GCC_VERSION 0
#endif

#ifndef FMT_GCC_PRAGMA
// Workaround _Pragma bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59884.
#  if FMT_GCC_VERSION >= 504
#    define FMT_GCC_PRAGMA(arg) _Pragma(arg)
#  else
#    define FMT_GCC_PRAGMA(arg)
#  endif
#endif

#ifdef __ICL
#  define FMT_ICC_VERSION __ICL
#elif defined(__INTEL_COMPILER)
#  define FMT_ICC_VERSION __INTEL_COMPILER
#else
#  define FMT_ICC_VERSION 0
#endif

#ifdef __NVCC__
#  define FMT_NVCC __NVCC__
#else
#  define FMT_NVCC 0
#endif

#ifdef _MSC_VER
#  define FMT_MSC_VER _MSC_VER
#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
#else
#  define FMT_MSC_VER 0
#  define FMT_MSC_WARNING(...)
#endif

#ifdef __has_feature
#  define FMT_HAS_FEATURE(x) __has_feature(x)
#else
#  define FMT_HAS_FEATURE(x) 0
#endif

#if defined(__has_include) &&                             \
    (!defined(__INTELLISENSE__) || FMT_MSC_VER > 1900) && \
    (!FMT_ICC_VERSION || FMT_ICC_VERSION >= 1600)
#  define FMT_HAS_INCLUDE(x) __has_include(x)
#else
#  define FMT_HAS_INCLUDE(x) 0
#endif

#ifdef __has_cpp_attribute
#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
#else
#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
#endif

#ifdef _MSVC_LANG
#  define FMT_CPLUSPLUS _MSVC_LANG
#else
#  define FMT_CPLUSPLUS __cplusplus
#endif

#define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
  (FMT_CPLUSPLUS >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))

#define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
  (FMT_CPLUSPLUS >= 201703L && FMT_HAS_CPP_ATTRIBUTE(attribute))

// Check if relaxed C++14 constexpr is supported.
// GCC doesn't allow throw in constexpr until version 6 (bug 67371).
#ifndef FMT_USE_CONSTEXPR
#  define FMT_USE_CONSTEXPR                                           \
    (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER >= 1912 || \
     (FMT_GCC_VERSION >= 600 && __cplusplus >= 201402L)) &&           \
        !FMT_NVCC && !FMT_ICC_VERSION
#endif
#if FMT_USE_CONSTEXPR
#  define FMT_CONSTEXPR constexpr
#  define FMT_CONSTEXPR_DECL constexpr
#else
#  define FMT_CONSTEXPR
#  define FMT_CONSTEXPR_DECL
#endif

#if ((__cplusplus >= 202002L) &&                              \
     (!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE > 9)) || \
    (__cplusplus >= 201709L && FMT_GCC_VERSION >= 1002)
#  define FMT_CONSTEXPR20 constexpr
#else
#  define FMT_CONSTEXPR20
#endif

// Check if constexpr std::char_traits<>::compare,length is supported.
#if defined(__GLIBCXX__)
#  if __cplusplus >= 201703L && defined(_GLIBCXX_RELEASE) && \
      _GLIBCXX_RELEASE >= 7  // GCC 7+ libstdc++ has _GLIBCXX_RELEASE.
#    define FMT_CONSTEXPR_CHAR_TRAITS constexpr
#  endif
#elif defined(_LIBCPP_VERSION) && __cplusplus >= 201703L && \
    _LIBCPP_VERSION >= 4000
#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
#elif FMT_MSC_VER >= 1914 && _MSVC_LANG >= 201703L
#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
#endif
#ifndef FMT_CONSTEXPR_CHAR_TRAITS
#  define FMT_CONSTEXPR_CHAR_TRAITS
#endif

// Check if exceptions are disabled.
#ifndef FMT_EXCEPTIONS
#  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \
      FMT_MSC_VER && !_HAS_EXCEPTIONS
#    define FMT_EXCEPTIONS 0
#  else
#    define FMT_EXCEPTIONS 1
#  endif
#endif

// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
#ifndef FMT_USE_NOEXCEPT
#  define FMT_USE_NOEXCEPT 0
#endif

#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
    FMT_GCC_VERSION >= 408 || FMT_MSC_VER >= 1900
#  define FMT_DETECTED_NOEXCEPT noexcept
#  define FMT_HAS_CXX11_NOEXCEPT 1
#else
#  define FMT_DETECTED_NOEXCEPT throw()
#  define FMT_HAS_CXX11_NOEXCEPT 0
#endif

#ifndef FMT_NOEXCEPT
#  if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT
#    define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
#  else
#    define FMT_NOEXCEPT
#  endif
#endif

// [[noreturn]] is disabled on MSVC and NVCC because of bogus unreachable code
// warnings.
#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VER && \
    !FMT_NVCC
#  define FMT_NORETURN [[noreturn]]
#else
#  define FMT_NORETURN
#endif

#if __cplusplus == 201103L || __cplusplus == 201402L
#  if defined(__INTEL_COMPILER) || defined(__PGI)
#    define FMT_FALLTHROUGH
#  elif defined(__clang__)
#    define FMT_FALLTHROUGH [[clang::fallthrough]]
#  elif FMT_GCC_VERSION >= 700 && \
      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
#    define FMT_FALLTHROUGH [[gnu::fallthrough]]
#  else
#    define FMT_FALLTHROUGH
#  endif
#elif FMT_HAS_CPP17_ATTRIBUTE(fallthrough)
#  define FMT_FALLTHROUGH [[fallthrough]]
#else
#  define FMT_FALLTHROUGH
#endif

#ifndef FMT_NODISCARD
#  if FMT_HAS_CPP17_ATTRIBUTE(nodiscard)
#    define FMT_NODISCARD [[nodiscard]]
#  else
#    define FMT_NODISCARD
#  endif
#endif

#ifndef FMT_USE_FLOAT
#  define FMT_USE_FLOAT 1
#endif
#ifndef FMT_USE_DOUBLE
#  define FMT_USE_DOUBLE 1
#endif
#ifndef FMT_USE_LONG_DOUBLE
#  define FMT_USE_LONG_DOUBLE 1
#endif

#ifndef FMT_INLINE
#  if FMT_GCC_VERSION || FMT_CLANG_VERSION
#    define FMT_INLINE inline __attribute__((always_inline))
#  else
#    define FMT_INLINE inline
#  endif
#endif

#ifndef FMT_DEPRECATED
#  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VER >= 1900
#    define FMT_DEPRECATED [[deprecated]]
#  else
#    if (defined(__GNUC__) && !defined(__LCC__)) || defined(__clang__)
#      define FMT_DEPRECATED __attribute__((deprecated))
#    elif FMT_MSC_VER
#      define FMT_DEPRECATED __declspec(deprecated)
#    else
#      define FMT_DEPRECATED /* deprecated */
#    endif
#  endif
#endif

#ifndef FMT_BEGIN_NAMESPACE
#  define FMT_BEGIN_NAMESPACE \
    namespace fmt {           \
    inline namespace v8 {
#  define FMT_END_NAMESPACE \
    }                       \
    }
#endif

#ifndef FMT_MODULE_EXPORT
#  define FMT_MODULE_EXPORT
#  define FMT_MODULE_EXPORT_BEGIN
#  define FMT_MODULE_EXPORT_END
#  define FMT_BEGIN_DETAIL_NAMESPACE namespace detail {
#  define FMT_END_DETAIL_NAMESPACE }
#endif

#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
#  define FMT_CLASS_API FMT_MSC_WARNING(suppress : 4275)
#  ifdef FMT_EXPORT
#    define FMT_API __declspec(dllexport)
#  elif defined(FMT_SHARED)
#    define FMT_API __declspec(dllimport)
#  endif
#else
#  define FMT_CLASS_API
#  if defined(FMT_EXPORT) || defined(FMT_SHARED)
#    if defined(__GNUC__) || defined(__clang__)
#      define FMT_API __attribute__((visibility("default")))
#    endif
#  endif
#endif
#ifndef FMT_API
#  define FMT_API
#endif

// libc++ supports string_view in pre-c++17.
#if (FMT_HAS_INCLUDE(<string_view>) &&                       \
     (__cplusplus > 201402L || defined(_LIBCPP_VERSION))) || \
    (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)
#  include <string_view>
#  define FMT_USE_STRING_VIEW
#elif FMT_HAS_INCLUDE("experimental/string_view") && __cplusplus >= 201402L
#  include <experimental/string_view>
#  define FMT_USE_EXPERIMENTAL_STRING_VIEW
#endif

#ifndef FMT_UNICODE
#  define FMT_UNICODE !FMT_MSC_VER
#endif

#ifndef FMT_CONSTEVAL
#  if ((FMT_GCC_VERSION >= 1000 || FMT_CLANG_VERSION >= 1101) &&      \
       __cplusplus > 201703L && !defined(__apple_build_version__)) || \
      (defined(__cpp_consteval) &&                                    \
       (!FMT_MSC_VER || _MSC_FULL_VER >= 193030704))
// consteval is broken in MSVC before VS2022 and Apple clang 13.
#    define FMT_CONSTEVAL consteval
#    define FMT_HAS_CONSTEVAL
#  else
#    define FMT_CONSTEVAL
#  endif
#endif

#ifndef FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
#  if defined(__cpp_nontype_template_args) &&                \
      ((FMT_GCC_VERSION >= 903 && __cplusplus >= 201709L) || \
       __cpp_nontype_template_args >= 201911L)
#    define FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 1
#  else
#    define FMT_USE_NONTYPE_TEMPLATE_PARAMETERS 0
#  endif
#endif

// Enable minimal optimizations for more compact code in debug mode.
FMT_GCC_PRAGMA("GCC push_options")
#ifndef __OPTIMIZE__
FMT_GCC_PRAGMA("GCC optimize(\"Og\")")
#endif

FMT_BEGIN_NAMESPACE
FMT_MODULE_EXPORT_BEGIN

// Implementations of enable_if_t and other metafunctions for older systems.
template <bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;
template <bool B, typename T, typename F>
using conditional_t = typename std::conditional<B, T, F>::type;
template <bool B> using bool_constant = std::integral_constant<bool, B>;
template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <typename T>
using remove_const_t = typename std::remove_const<T>::type;
template <typename T>
using remove_cvref_t = typename std::remove_cv<remove_reference_t<T>>::type;
template <typename T> struct type_identity { using type = T; };
template <typename T> using type_identity_t = typename type_identity<T>::type;

struct monostate {
  constexpr monostate() {}
};

// An enable_if helper to be used in template parameters which results in much
// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
// to workaround a bug in MSVC 2019 (see #1140 and #1186).
#ifdef FMT_DOC
#  define FMT_ENABLE_IF(...)
#else
#  define FMT_ENABLE_IF(...) enable_if_t<(__VA_ARGS__), int> = 0
#endif

FMT_BEGIN_DETAIL_NAMESPACE

// Suppress "unused variable" warnings with the method described in
// https://herbsutter.com/2009/10/18/mailbag-shutting-up-compiler-warnings/.
// (void)var does not work on many Intel compilers.
template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}

constexpr FMT_INLINE auto is_constant_evaluated(bool default_value = false)
    FMT_NOEXCEPT -> bool {
#ifdef __cpp_lib_is_constant_evaluated
  ignore_unused(default_value);
  return std::is_constant_evaluated();
#else
  return default_value;
#endif
}

// A function to suppress "conditional expression is constant" warnings.
template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
  return value;
}

FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
                                      const char* message);

#ifndef FMT_ASSERT
#  ifdef NDEBUG
// FMT_ASSERT is not empty to avoid -Werror=empty-body.
#    define FMT_ASSERT(condition, message) \
      ::fmt::detail::ignore_unused((condition), (message))
#  else
#    define FMT_ASSERT(condition, message)                                    \
      ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
           ? (void)0                                                          \
           : ::fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
#  endif
#endif

#ifdef __cpp_lib_byte
using byte = std::byte;
#else
enum class byte : unsigned char {};
#endif

#if defined(FMT_USE_STRING_VIEW)
template <typename Char> using std_string_view = std::basic_string_view<Char>;
#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
template <typename Char>
using std_string_view = std::experimental::basic_string_view<Char>;
#else
template <typename T> struct std_string_view {};
#endif

#ifdef FMT_USE_INT128
// Do nothing.
#elif defined(__SIZEOF_INT128__) && !FMT_NVCC && \
    !(FMT_CLANG_VERSION && FMT_MSC_VER)
#  define FMT_USE_INT128 1
using int128_t = __int128_t;
using uint128_t = __uint128_t;
template <typename T> inline auto convert_for_visit(T value) -> T {
  return value;
}
#else
#  define FMT_USE_INT128 0
#endif
#if !FMT_USE_INT128
enum class int128_t {};
enum class uint128_t {};
// Reduce template instantiations.
template <typename T> inline auto convert_for_visit(T) -> monostate {
  return {};
}
#endif

// Casts a nonnegative integer to unsigned.
template <typename Int>
FMT_CONSTEXPR auto to_unsigned(Int value) ->
    typename std::make_unsigned<Int>::type {
  FMT_ASSERT(value >= 0, "negative value");
  return static_cast<typename std::make_unsigned<Int>::type>(value);
}

FMT_MSC_WARNING(suppress : 4566) constexpr unsigned char micro[] = "\u00B5";

constexpr auto is_utf8() -> bool {
  // Avoid buggy sign extensions in MSVC's constant evaluation mode.
  // https://developercommunity.visualstudio.com/t/C-difference-in-behavior-for-unsigned/1233612
  using uchar = unsigned char;
  return FMT_UNICODE || (sizeof(micro) == 3 && uchar(micro[0]) == 0xC2 &&
                         uchar(micro[1]) == 0xB5);
}
FMT_END_DETAIL_NAMESPACE

/**
  An implementation of ``std::basic_string_view`` for pre-C++17. It provides a
  subset of the API. ``fmt::basic_string_view`` is used for format strings even
  if ``std::string_view`` is available to prevent issues when a library is
  compiled with a different ``-std`` option than the client code (which is not
  recommended).
 */
template <typename Char> class basic_string_view {
 private:
  const Char* data_;
  size_t size_;

 public:
  using value_type = Char;
  using iterator = const Char*;

  constexpr basic_string_view() FMT_NOEXCEPT : data_(nullptr), size_(0) {}

  /** Constructs a string reference object from a C string and a size. */
  constexpr basic_string_view(const Char* s, size_t count) FMT_NOEXCEPT
      : data_(s),
        size_(count) {}

  /**
    \rst
    Constructs a string reference object from a C string computing
    the size with ``std::char_traits<Char>::length``.
    \endrst
   */
  FMT_CONSTEXPR_CHAR_TRAITS
  FMT_INLINE
  basic_string_view(const Char* s)
      : data_(s),
        size_(detail::const_check(std::is_same<Char, char>::value &&
                                  !detail::is_constant_evaluated(true))
                  ? std::strlen(reinterpret_cast<const char*>(s))
                  : std::char_traits<Char>::length(s)) {}

  /** Constructs a string reference from a ``std::basic_string`` object. */
  template <typename Traits, typename Alloc>
  FMT_CONSTEXPR basic_string_view(
      const std::basic_string<Char, Traits, Alloc>& s) FMT_NOEXCEPT
      : data_(s.data()),
        size_(s.size()) {}

  template <typename S, FMT_ENABLE_IF(std::is_same<
                                      S, detail::std_string_view<Char>>::value)>
  FMT_CONSTEXPR basic_string_view(S s) FMT_NOEXCEPT : data_(s.data()),
                                                      size_(s.size()) {}

  /** Returns a pointer to the string data. */
  constexpr auto data() const FMT_NOEXCEPT -> const Char* { return data_; }

  /** Returns the string size. */
  constexpr auto size() const FMT_NOEXCEPT -> size_t { return size_; }

  constexpr auto begin() const FMT_NOEXCEPT -> iterator { return data_; }
  constexpr auto end() const FMT_NOEXCEPT -> iterator { return data_ + size_; }

  constexpr auto operator[](size_t pos) const FMT_NOEXCEPT -> const Char& {
    return data_[pos];
  }

  FMT_CONSTEXPR void remove_prefix(size_t n) FMT_NOEXCEPT {
    data_ += n;
    size_ -= n;
  }

  // Lexicographically compare this string reference to other.
  FMT_CONSTEXPR_CHAR_TRAITS auto compare(basic_string_view other) const -> int {
    size_t str_size = size_ < other.size_ ? size_ : other.size_;
    int result = std::char_traits<Char>::compare(data_, other.data_, str_size);
    if (result == 0)
      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
    return result;
  }

  FMT_CONSTEXPR_CHAR_TRAITS friend auto operator==(basic_string_view lhs,
                                                   basic_string_view rhs)
      -> bool {
    return lhs.compare(rhs) == 0;
  }
  friend auto operator!=(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) != 0;
  }
  friend auto operator<(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) < 0;
  }
  friend auto operator<=(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) <= 0;
  }
  friend auto operator>(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) > 0;
  }
  friend auto operator>=(basic_string_view lhs, basic_string_view rhs) -> bool {
    return lhs.compare(rhs) >= 0;
  }
};

using string_view = basic_string_view<char>;

/** Specifies if ``T`` is a character type. Can be specialized by users. */
template <typename T> struct is_char : std::false_type {};
template <> struct is_char<char> : std::true_type {};

// Returns a string view of `s`.
template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
FMT_INLINE auto to_string_view(const Char* s) -> basic_string_view<Char> {
  return s;
}
template <typename Char, typename Traits, typename Alloc>
inline auto to_string_view(const std::basic_string<Char, Traits, Alloc>& s)
    -> basic_string_view<Char> {
  return s;
}
template <typename Char>
constexpr auto to_string_view(basic_string_view<Char> s)
    -> basic_string_view<Char> {
  return s;
}
template <typename Char,
          FMT_ENABLE_IF(!std::is_empty<detail::std_string_view<Char>>::value)>
inline auto to_string_view(detail::std_string_view<Char> s)
    -> basic_string_view<Char> {
  return s;
}

// A base class for compile-time strings. It is defined in the fmt namespace to
// make formatting functions visible via ADL, e.g. format(FMT_STRING("{}"), 42).
struct compile_string {};

template <typename S>
struct is_compile_string : std::is_base_of<compile_string, S> {};

template <typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
constexpr auto to_string_view(const S& s)
    -> basic_string_view<typename S::char_type> {
  return basic_string_view<typename S::char_type>(s);
}

FMT_BEGIN_DETAIL_NAMESPACE

void to_string_view(...);
using fmt::to_string_view;

// Specifies whether S is a string type convertible to fmt::basic_string_view.
// It should be a constexpr function but MSVC 2017 fails to compile it in
// enable_if and MSVC 2015 fails to compile it as an alias template.
template <typename S>
struct is_string : std::is_class<decltype(to_string_view(std::declval<S>()))> {
};

template <typename S, typename = void> struct char_t_impl {};
template <typename S> struct char_t_impl<S, enable_if_t<is_string<S>::value>> {
  using result = decltype(to_string_view(std::declval<S>()));
  using type = typename result::value_type;
};

// Reports a compile-time error if S is not a valid format string.
template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>
FMT_INLINE void check_format_string(const S&) {
#ifdef FMT_ENFORCE_COMPILE_STRING
  static_assert(is_compile_string<S>::value,
                "FMT_ENFORCE_COMPILE_STRING requires all format strings to use "
                "FMT_STRING.");
#endif
}
template <typename..., typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
void check_format_string(S);

FMT_NORETURN FMT_API void throw_format_error(const char* message);

struct error_handler {
  constexpr error_handler() = default;
  constexpr error_handler(const error_handler&) = default;

  // This function is intentionally not constexpr to give a compile-time error.
  FMT_NORETURN FMT_API void on_error(const char* message);
};
FMT_END_DETAIL_NAMESPACE

/** String's character type. */
template <typename S> using char_t = typename detail::char_t_impl<S>::type;

/**
  \rst
  Parsing context consisting of a format string range being parsed and an
  argument counter for automatic indexing.
  You can use the ``format_parse_context`` type alias for ``char`` instead.
  \endrst
 */
template <typename Char, typename ErrorHandler = detail::error_handler>
class basic_format_parse_context : private ErrorHandler {
 private:
  basic_string_view<Char> format_str_;
  int next_arg_id_;

 public:
  using char_type = Char;
  using iterator = typename basic_string_view<Char>::iterator;

  explicit constexpr basic_format_parse_context(
      basic_string_view<Char> format_str, ErrorHandler eh = {},
      int next_arg_id = 0)
      : ErrorHandler(eh), format_str_(format_str), next_arg_id_(next_arg_id) {}

  /**
    Returns an iterator to the beginning of the format string range being
    parsed.
   */
  constexpr auto begin() const FMT_NOEXCEPT -> iterator {
    return format_str_.begin();
  }

  /**
    Returns an iterator past the end of the format string range being parsed.
   */
  constexpr auto end() const FMT_NOEXCEPT -> iterator {
    return format_str_.end();
  }

  /** Advances the begin iterator to ``it``. */
  FMT_CONSTEXPR void advance_to(iterator it) {
    format_str_.remove_prefix(detail::to_unsigned(it - begin()));
  }

  /**
    Reports an error if using the manual argument indexing; otherwise returns
    the next argument index and switches to the automatic indexing.
   */
  FMT_CONSTEXPR auto next_arg_id() -> int {
    // Don't check if the argument id is valid to avoid overhead and because it
    // will be checked during formatting anyway.
    if (next_arg_id_ >= 0) return next_arg_id_++;
    on_error("cannot switch from manual to automatic argument indexing");
    return 0;
  }

  /**
    Reports an error if using the automatic argument indexing; otherwise
    switches to the manual indexing.
   */
  FMT_CONSTEXPR void check_arg_id(int) {
    if (next_arg_id_ > 0)
      on_error("cannot switch from automatic to manual argument indexing");
    else
      next_arg_id_ = -1;
  }

  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}

  FMT_CONSTEXPR void on_error(const char* message) {
    ErrorHandler::on_error(message);
  }

  constexpr auto error_handler() const -> ErrorHandler { return *this; }
};

using format_parse_context = basic_format_parse_context<char>;

template <typename Context> class basic_format_arg;
template <typename Context> class basic_format_args;
template <typename Context> class dynamic_format_arg_store;

// A formatter for objects of type T.
template <typename T, typename Char = char, typename Enable = void>
struct formatter {
  // A deleted default constructor indicates a disabled formatter.
  formatter() = delete;
};

// Specifies if T has an enabled formatter specialization. A type can be
// formattable even if it doesn't have a formatter e.g. via a conversion.
template <typename T, typename Context>
using has_formatter =
    std::is_constructible<typename Context::template formatter_type<T>>;

// Checks whether T is a container with contiguous storage.
template <typename T> struct is_contiguous : std::false_type {};
template <typename Char>
struct is_contiguous<std::basic_string<Char>> : std::true_type {};

class appender;

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Context, typename T>
constexpr auto has_const_formatter_impl(T*)
    -> decltype(typename Context::template formatter_type<T>().format(
                    std::declval<const T&>(), std::declval<Context&>()),
                true) {
  return true;
}
template <typename Context>
constexpr auto has_const_formatter_impl(...) -> bool {
  return false;
}
template <typename T, typename Context>
constexpr auto has_const_formatter() -> bool {
  return has_const_formatter_impl<Context>(static_cast<T*>(nullptr));
}

// Extracts a reference to the container from back_insert_iterator.
template <typename Container>
inline auto get_container(std::back_insert_iterator<Container> it)
    -> Container& {
  using bi_iterator = std::back_insert_iterator<Container>;
  struct accessor : bi_iterator {
    accessor(bi_iterator iter) : bi_iterator(iter) {}
    using bi_iterator::container;
  };
  return *accessor(it).container;
}

template <typename Char, typename InputIt, typename OutputIt>
FMT_CONSTEXPR auto copy_str(InputIt begin, InputIt end, OutputIt out)
    -> OutputIt {
  while (begin != end) *out++ = static_cast<Char>(*begin++);
  return out;
}

template <typename Char, typename T, typename U,
          FMT_ENABLE_IF(
              std::is_same<remove_const_t<T>, U>::value&& is_char<U>::value)>
FMT_CONSTEXPR auto copy_str(T* begin, T* end, U* out) -> U* {
  if (is_constant_evaluated()) return copy_str<Char, T*, U*>(begin, end, out);
  auto size = to_unsigned(end - begin);
  memcpy(out, begin, size * sizeof(U));
  return out + size;
}

/**
  \rst
  A contiguous memory buffer with an optional growing ability. It is an internal
  class and shouldn't be used directly, only via `~fmt::basic_memory_buffer`.
  \endrst
 */
template <typename T> class buffer {
 private:
  T* ptr_;
  size_t size_;
  size_t capacity_;

 protected:
  // Don't initialize ptr_ since it is not accessed to save a few cycles.
  FMT_MSC_WARNING(suppress : 26495)
  buffer(size_t sz) FMT_NOEXCEPT : size_(sz), capacity_(sz) {}

  FMT_CONSTEXPR20 buffer(T* p = nullptr, size_t sz = 0,
                         size_t cap = 0) FMT_NOEXCEPT : ptr_(p),
                                                        size_(sz),
                                                        capacity_(cap) {}

  FMT_CONSTEXPR20 ~buffer() = default;
  buffer(buffer&&) = default;

  /** Sets the buffer data and capacity. */
  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) FMT_NOEXCEPT {
    ptr_ = buf_data;
    capacity_ = buf_capacity;
  }

  /** Increases the buffer capacity to hold at least *capacity* elements. */
  virtual FMT_CONSTEXPR20 void grow(size_t capacity) = 0;

 public:
  using value_type = T;
  using const_reference = const T&;

  buffer(const buffer&) = delete;
  void operator=(const buffer&) = delete;

  auto begin() FMT_NOEXCEPT -> T* { return ptr_; }
  auto end() FMT_NOEXCEPT -> T* { return ptr_ + size_; }

  auto begin() const FMT_NOEXCEPT -> const T* { return ptr_; }
  auto end() const FMT_NOEXCEPT -> const T* { return ptr_ + size_; }

  /** Returns the size of this buffer. */
  constexpr auto size() const FMT_NOEXCEPT -> size_t { return size_; }

  /** Returns the capacity of this buffer. */
  constexpr auto capacity() const FMT_NOEXCEPT -> size_t { return capacity_; }

  /** Returns a pointer to the buffer data. */
  FMT_CONSTEXPR auto data() FMT_NOEXCEPT -> T* { return ptr_; }

  /** Returns a pointer to the buffer data. */
  FMT_CONSTEXPR auto data() const FMT_NOEXCEPT -> const T* { return ptr_; }

  /** Clears this buffer. */
  void clear() { size_ = 0; }

  // Tries resizing the buffer to contain *count* elements. If T is a POD type
  // the new elements may not be initialized.
  FMT_CONSTEXPR20 void try_resize(size_t count) {
    try_reserve(count);
    size_ = count <= capacity_ ? count : capacity_;
  }

  // Tries increasing the buffer capacity to *new_capacity*. It can increase the
  // capacity by a smaller amount than requested but guarantees there is space
  // for at least one additional element either by increasing the capacity or by
  // flushing the buffer if it is full.
  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
    if (new_capacity > capacity_) grow(new_capacity);
  }

  FMT_CONSTEXPR20 void push_back(const T& value) {
    try_reserve(size_ + 1);
    ptr_[size_++] = value;
  }

  /** Appends data to the end of the buffer. */
  template <typename U> void append(const U* begin, const U* end);

  template <typename I> FMT_CONSTEXPR auto operator[](I index) -> T& {
    return ptr_[index];
  }
  template <typename I>
  FMT_CONSTEXPR auto operator[](I index) const -> const T& {
    return ptr_[index];
  }
};

struct buffer_traits {
  explicit buffer_traits(size_t) {}
  auto count() const -> size_t { return 0; }
  auto limit(size_t size) -> size_t { return size; }
};

class fixed_buffer_traits {
 private:
  size_t count_ = 0;
  size_t limit_;

 public:
  explicit fixed_buffer_traits(size_t limit) : limit_(limit) {}
  auto count() const -> size_t { return count_; }
  auto limit(size_t size) -> size_t {
    size_t n = limit_ > count_ ? limit_ - count_ : 0;
    count_ += size;
    return size < n ? size : n;
  }
};

// A buffer that writes to an output iterator when flushed.
template <typename OutputIt, typename T, typename Traits = buffer_traits>
class iterator_buffer final : public Traits, public buffer<T> {
 private:
  OutputIt out_;
  enum { buffer_size = 256 };
  T data_[buffer_size];

 protected:
  FMT_CONSTEXPR20 void grow(size_t) override {
    if (this->size() == buffer_size) flush();
  }

  void flush() {
    auto size = this->size();
    this->clear();
    out_ = copy_str<T>(data_, data_ + this->limit(size), out_);
  }

 public:
  explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
      : Traits(n), buffer<T>(data_, 0, buffer_size), out_(out) {}
  iterator_buffer(iterator_buffer&& other)
      : Traits(other), buffer<T>(data_, 0, buffer_size), out_(other.out_) {}
  ~iterator_buffer() { flush(); }

  auto out() -> OutputIt {
    flush();
    return out_;
  }
  auto count() const -> size_t { return Traits::count() + this->size(); }
};

template <typename T>
class iterator_buffer<T*, T, fixed_buffer_traits> final
    : public fixed_buffer_traits,
      public buffer<T> {
 private:
  T* out_;
  enum { buffer_size = 256 };
  T data_[buffer_size];

 protected:
  FMT_CONSTEXPR20 void grow(size_t) override {
    if (this->size() == this->capacity()) flush();
  }

  void flush() {
    size_t n = this->limit(this->size());
    if (this->data() == out_) {
      out_ += n;
      this->set(data_, buffer_size);
    }
    this->clear();
  }

 public:
  explicit iterator_buffer(T* out, size_t n = buffer_size)
      : fixed_buffer_traits(n), buffer<T>(out, 0, n), out_(out) {}
  iterator_buffer(iterator_buffer&& other)
      : fixed_buffer_traits(other),
        buffer<T>(std::move(other)),
        out_(other.out_) {
    if (this->data() != out_) {
      this->set(data_, buffer_size);
      this->clear();
    }
  }
  ~iterator_buffer() { flush(); }

  auto out() -> T* {
    flush();
    return out_;
  }
  auto count() const -> size_t {
    return fixed_buffer_traits::count() + this->size();
  }
};

template <typename T> class iterator_buffer<T*, T> final : public buffer<T> {
 protected:
  FMT_CONSTEXPR20 void grow(size_t) override {}

 public:
  explicit iterator_buffer(T* out, size_t = 0) : buffer<T>(out, 0, ~size_t()) {}

  auto out() -> T* { return &*this->end(); }
};

// A buffer that writes to a container with the contiguous storage.
template <typename Container>
class iterator_buffer<std::back_insert_iterator<Container>,
                      enable_if_t<is_contiguous<Container>::value,
                                  typename Container::value_type>>
    final : public buffer<typename Container::value_type> {
 private:
  Container& container_;

 protected:
  FMT_CONSTEXPR20 void grow(size_t capacity) override {
    container_.resize(capacity);
    this->set(&container_[0], capacity);
  }

 public:
  explicit iterator_buffer(Container& c)
      : buffer<typename Container::value_type>(c.size()), container_(c) {}
  explicit iterator_buffer(std::back_insert_iterator<Container> out, size_t = 0)
      : iterator_buffer(get_container(out)) {}
  auto out() -> std::back_insert_iterator<Container> {
    return std::back_inserter(container_);
  }
};

// A buffer that counts the number of code units written discarding the output.
template <typename T = char> class counting_buffer final : public buffer<T> {
 private:
  enum { buffer_size = 256 };
  T data_[buffer_size];
  size_t count_ = 0;

 protected:
  FMT_CONSTEXPR20 void grow(size_t) override {
    if (this->size() != buffer_size) return;
    count_ += this->size();
    this->clear();
  }

 public:
  counting_buffer() : buffer<T>(data_, 0, buffer_size) {}

  auto count() -> size_t { return count_ + this->size(); }
};

template <typename T>
using buffer_appender = conditional_t<std::is_same<T, char>::value, appender,
                                      std::back_insert_iterator<buffer<T>>>;

// Maps an output iterator to a buffer.
template <typename T, typename OutputIt>
auto get_buffer(OutputIt out) -> iterator_buffer<OutputIt, T> {
  return iterator_buffer<OutputIt, T>(out);
}

template <typename Buffer>
auto get_iterator(Buffer& buf) -> decltype(buf.out()) {
  return buf.out();
}
template <typename T> auto get_iterator(buffer<T>& buf) -> buffer_appender<T> {
  return buffer_appender<T>(buf);
}

template <typename T, typename Char = char, typename Enable = void>
struct fallback_formatter {
  fallback_formatter() = delete;
};

// Specifies if T has an enabled fallback_formatter specialization.
template <typename T, typename Char>
using has_fallback_formatter =
    std::is_constructible<fallback_formatter<T, Char>>;

struct view {};

template <typename Char, typename T> struct named_arg : view {
  const Char* name;
  const T& value;
  named_arg(const Char* n, const T& v) : name(n), value(v) {}
};

template <typename Char> struct named_arg_info {
  const Char* name;
  int id;
};

template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
struct arg_data {
  // args_[0].named_args points to named_args_ to avoid bloating format_args.
  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
  T args_[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)];
  named_arg_info<Char> named_args_[NUM_NAMED_ARGS];

  template <typename... U>
  arg_data(const U&... init) : args_{T(named_args_, NUM_NAMED_ARGS), init...} {}
  arg_data(const arg_data& other) = delete;
  auto args() const -> const T* { return args_ + 1; }
  auto named_args() -> named_arg_info<Char>* { return named_args_; }
};

template <typename T, typename Char, size_t NUM_ARGS>
struct arg_data<T, Char, NUM_ARGS, 0> {
  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
  T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];

  template <typename... U>
  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
    return nullptr;
  }
};

template <typename Char>
inline void init_named_args(named_arg_info<Char>*, int, int) {}

template <typename T> struct is_named_arg : std::false_type {};
template <typename T> struct is_statically_named_arg : std::false_type {};

template <typename T, typename Char>
struct is_named_arg<named_arg<Char, T>> : std::true_type {};

template <typename Char, typename T, typename... Tail,
          FMT_ENABLE_IF(!is_named_arg<T>::value)>
void init_named_args(named_arg_info<Char>* named_args, int arg_count,
                     int named_arg_count, const T&, const Tail&... args) {
  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
}

template <typename Char, typename T, typename... Tail,
          FMT_ENABLE_IF(is_named_arg<T>::value)>
void init_named_args(named_arg_info<Char>* named_args, int arg_count,
                     int named_arg_count, const T& arg, const Tail&... args) {
  named_args[named_arg_count++] = {arg.name, arg_count};
  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
}

template <typename... Args>
FMT_CONSTEXPR FMT_INLINE void init_named_args(std::nullptr_t, int, int,
                                              const Args&...) {}

template <bool B = false> constexpr auto count() -> size_t { return B ? 1 : 0; }
template <bool B1, bool B2, bool... Tail> constexpr auto count() -> size_t {
  return (B1 ? 1 : 0) + count<B2, Tail...>();
}

template <typename... Args> constexpr auto count_named_args() -> size_t {
  return count<is_named_arg<Args>::value...>();
}

template <typename... Args>
constexpr auto count_statically_named_args() -> size_t {
  return count<is_statically_named_arg<Args>::value...>();
}

enum class type {
  none_type,
  // Integer types should go first,
  int_type,
  uint_type,
  long_long_type,
  ulong_long_type,
  int128_type,
  uint128_type,
  bool_type,
  char_type,
  last_integer_type = char_type,
  // followed by floating-point types.
  float_type,
  double_type,
  long_double_type,
  last_numeric_type = long_double_type,
  cstring_type,
  string_type,
  pointer_type,
  custom_type
};

// Maps core type T to the corresponding type enum constant.
template <typename T, typename Char>
struct type_constant : std::integral_constant<type, type::custom_type> {};

#define FMT_TYPE_CONSTANT(Type, constant) \
  template <typename Char>                \
  struct type_constant<Type, Char>        \
      : std::integral_constant<type, type::constant> {}

FMT_TYPE_CONSTANT(int, int_type);
FMT_TYPE_CONSTANT(unsigned, uint_type);
FMT_TYPE_CONSTANT(long long, long_long_type);
FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
FMT_TYPE_CONSTANT(int128_t, int128_type);
FMT_TYPE_CONSTANT(uint128_t, uint128_type);
FMT_TYPE_CONSTANT(bool, bool_type);
FMT_TYPE_CONSTANT(Char, char_type);
FMT_TYPE_CONSTANT(float, float_type);
FMT_TYPE_CONSTANT(double, double_type);
FMT_TYPE_CONSTANT(long double, long_double_type);
FMT_TYPE_CONSTANT(const Char*, cstring_type);
FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
FMT_TYPE_CONSTANT(const void*, pointer_type);

constexpr bool is_integral_type(type t) {
  return t > type::none_type && t <= type::last_integer_type;
}

constexpr bool is_arithmetic_type(type t) {
  return t > type::none_type && t <= type::last_numeric_type;
}

struct unformattable {};
struct unformattable_char : unformattable {};
struct unformattable_const : unformattable {};
struct unformattable_pointer : unformattable {};

template <typename Char> struct string_value {
  const Char* data;
  size_t size;
};

template <typename Char> struct named_arg_value {
  const named_arg_info<Char>* data;
  size_t size;
};

template <typename Context> struct custom_value {
  using parse_context = typename Context::parse_context_type;
  void* value;
  void (*format)(void* arg, parse_context& parse_ctx, Context& ctx);
};

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4582 4583)
#endif

// A formatting argument value.
template <typename Context> class value {
 public:
  using char_type = typename Context::char_type;

  union {
    monostate no_value;
    int int_value;
    unsigned uint_value;
    long long long_long_value;
    unsigned long long ulong_long_value;
    int128_t int128_value;
    uint128_t uint128_value;
    bool bool_value;
    char_type char_value;
    float float_value;
    double double_value;
    long double long_double_value;
    const void* pointer;
    string_value<char_type> string;
    custom_value<Context> custom;
    named_arg_value<char_type> named_args;
  };

  constexpr FMT_INLINE value() : no_value() {}
  constexpr FMT_INLINE value(int val) : int_value(val) {}
  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
  constexpr FMT_INLINE value(long long val) : long_long_value(val) {}
  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
  FMT_INLINE value(int128_t val) : int128_value(val) {}
  FMT_INLINE value(uint128_t val) : uint128_value(val) {}
  constexpr FMT_INLINE value(float val) : float_value(val) {}
  constexpr FMT_INLINE value(double val) : double_value(val) {}
  FMT_INLINE value(long double val) : long_double_value(val) {}
  constexpr FMT_INLINE value(bool val) : bool_value(val) {}
  constexpr FMT_INLINE value(char_type val) : char_value(val) {}
  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
    string.data = val;
    if (is_constant_evaluated()) string.size = {};
  }
  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
    string.data = val.data();
    string.size = val.size();
  }
  FMT_INLINE value(const void* val) : pointer(val) {}
  FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
      : named_args{args, size} {}

  template <typename T> FMT_CONSTEXPR FMT_INLINE value(T& val) {
    using value_type = remove_cvref_t<T>;
    custom.value = const_cast<value_type*>(&val);
    // Get the formatter type through the context to allow different contexts
    // have different extension points, e.g. `formatter<T>` for `format` and
    // `printf_formatter<T>` for `printf`.
    custom.format = format_custom_arg<
        value_type,
        conditional_t<has_formatter<value_type, Context>::value,
                      typename Context::template formatter_type<value_type>,
                      fallback_formatter<value_type, char_type>>>;
  }
  value(unformattable);
  value(unformattable_char);
  value(unformattable_const);
  value(unformattable_pointer);

 private:
  // Formats an argument of a custom type, such as a user-defined class.
  template <typename T, typename Formatter>
  static void format_custom_arg(void* arg,
                                typename Context::parse_context_type& parse_ctx,
                                Context& ctx) {
    auto f = Formatter();
    parse_ctx.advance_to(f.parse(parse_ctx));
    using qualified_type =
        conditional_t<has_const_formatter<T, Context>(), const T, T>;
    ctx.advance_to(f.format(*static_cast<qualified_type*>(arg), ctx));
  }
};

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

template <typename Context, typename T>
FMT_CONSTEXPR auto make_arg(const T& value) -> basic_format_arg<Context>;

// To minimize the number of types we need to deal with, long is translated
// either to int or to long long depending on its size.
enum { long_short = sizeof(long) == sizeof(int) };
using long_type = conditional_t<long_short, int, long long>;
using ulong_type = conditional_t<long_short, unsigned, unsigned long long>;

// Maps formatting arguments to core types.
// arg_mapper reports errors by returning unformattable instead of using
// static_assert because it's used in the is_formattable trait.
template <typename Context> struct arg_mapper {
  using char_type = typename Context::char_type;

  FMT_CONSTEXPR FMT_INLINE auto map(signed char val) -> int { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char val) -> unsigned {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(short val) -> int { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned short val) -> unsigned {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(int val) -> int { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned val) -> unsigned { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(long val) -> long_type { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long val) -> ulong_type {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(long long val) -> long long { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long long val)
      -> unsigned long long {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(int128_t val) -> int128_t { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(uint128_t val) -> uint128_t { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(bool val) -> bool { return val; }

  template <typename T, FMT_ENABLE_IF(std::is_same<T, char>::value ||
                                      std::is_same<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(T val) -> char_type {
    return val;
  }
  template <typename T, enable_if_t<(std::is_same<T, wchar_t>::value ||
#ifdef __cpp_char8_t
                                     std::is_same<T, char8_t>::value ||
#endif
                                     std::is_same<T, char16_t>::value ||
                                     std::is_same<T, char32_t>::value) &&
                                        !std::is_same<T, char_type>::value,
                                    int> = 0>
  FMT_CONSTEXPR FMT_INLINE auto map(T) -> unformattable_char {
    return {};
  }

  FMT_CONSTEXPR FMT_INLINE auto map(float val) -> float { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(double val) -> double { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(long double val) -> long double {
    return val;
  }

  FMT_CONSTEXPR FMT_INLINE auto map(char_type* val) -> const char_type* {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
    return val;
  }
  template <typename T,
            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
                          std::is_same<char_type, char_t<T>>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> basic_string_view<char_type> {
    return to_string_view(val);
  }
  template <typename T,
            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
                          !std::is_same<char_type, char_t<T>>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T&) -> unformattable_char {
    return {};
  }
  template <typename T,
            FMT_ENABLE_IF(
                std::is_constructible<basic_string_view<char_type>, T>::value &&
                !is_string<T>::value && !has_formatter<T, Context>::value &&
                !has_fallback_formatter<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> basic_string_view<char_type> {
    return basic_string_view<char_type>(val);
  }
  template <
      typename T,
      FMT_ENABLE_IF(
          std::is_constructible<std_string_view<char_type>, T>::value &&
          !std::is_constructible<basic_string_view<char_type>, T>::value &&
          !is_string<T>::value && !has_formatter<T, Context>::value &&
          !has_fallback_formatter<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> basic_string_view<char_type> {
    return std_string_view<char_type>(val);
  }

  using cstring_result = conditional_t<std::is_same<char_type, char>::value,
                                       const char*, unformattable_pointer>;

  FMT_DEPRECATED FMT_CONSTEXPR FMT_INLINE auto map(const signed char* val)
      -> cstring_result {
    return map(reinterpret_cast<const char*>(val));
  }
  FMT_DEPRECATED FMT_CONSTEXPR FMT_INLINE auto map(const unsigned char* val)
      -> cstring_result {
    return map(reinterpret_cast<const char*>(val));
  }
  FMT_DEPRECATED FMT_CONSTEXPR FMT_INLINE auto map(signed char* val)
      -> cstring_result {
    return map(reinterpret_cast<const char*>(val));
  }
  FMT_DEPRECATED FMT_CONSTEXPR FMT_INLINE auto map(unsigned char* val)
      -> cstring_result {
    return map(reinterpret_cast<const char*>(val));
  }

  FMT_CONSTEXPR FMT_INLINE auto map(void* val) -> const void* { return val; }
  FMT_CONSTEXPR FMT_INLINE auto map(const void* val) -> const void* {
    return val;
  }
  FMT_CONSTEXPR FMT_INLINE auto map(std::nullptr_t val) -> const void* {
    return val;
  }

  // We use SFINAE instead of a const T* parameter to avoid conflicting with
  // the C array overload.
  template <
      typename T,
      FMT_ENABLE_IF(
          std::is_member_pointer<T>::value ||
          std::is_function<typename std::remove_pointer<T>::type>::value ||
          (std::is_convertible<const T&, const void*>::value &&
           !std::is_convertible<const T&, const char_type*>::value))>
  FMT_CONSTEXPR auto map(const T&) -> unformattable_pointer {
    return {};
  }

  template <typename T, std::size_t N,
            FMT_ENABLE_IF(!std::is_same<T, wchar_t>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T (&values)[N]) -> const T (&)[N] {
    return values;
  }

  template <typename T,
            FMT_ENABLE_IF(
                std::is_enum<T>::value&& std::is_convertible<T, int>::value &&
                !has_formatter<T, Context>::value &&
                !has_fallback_formatter<T, char_type>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
      -> decltype(std::declval<arg_mapper>().map(
          static_cast<typename std::underlying_type<T>::type>(val))) {
    return map(static_cast<typename std::underlying_type<T>::type>(val));
  }

  FMT_CONSTEXPR FMT_INLINE auto map(detail::byte val) -> unsigned {
    return map(static_cast<unsigned char>(val));
  }

  template <typename T, typename U = remove_cvref_t<T>>
  struct formattable
      : bool_constant<has_const_formatter<U, Context>() ||
                      !std::is_const<remove_reference_t<T>>::value ||
                      has_fallback_formatter<U, char_type>::value> {};

#if FMT_MSC_VER != 0 && FMT_MSC_VER < 1910
  // Workaround a bug in MSVC.
  template <typename T> FMT_CONSTEXPR FMT_INLINE auto do_map(T&& val) -> T& {
    return val;
  }
#else
  template <typename T, FMT_ENABLE_IF(formattable<T>::value)>
  FMT_CONSTEXPR FMT_INLINE auto do_map(T&& val) -> T& {
    return val;
  }
  template <typename T, FMT_ENABLE_IF(!formattable<T>::value)>
  FMT_CONSTEXPR FMT_INLINE auto do_map(T&&) -> unformattable_const {
    return {};
  }
#endif

  template <typename T, typename U = remove_cvref_t<T>,
            FMT_ENABLE_IF(!is_string<U>::value && !is_char<U>::value &&
                          !std::is_array<U>::value &&
                          (has_formatter<U, Context>::value ||
                           has_fallback_formatter<U, char_type>::value))>
  FMT_CONSTEXPR FMT_INLINE auto map(T&& val)
      -> decltype(this->do_map(std::forward<T>(val))) {
    return do_map(std::forward<T>(val));
  }

  template <typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
  FMT_CONSTEXPR FMT_INLINE auto map(const T& named_arg)
      -> decltype(std::declval<arg_mapper>().map(named_arg.value)) {
    return map(named_arg.value);
  }

  auto map(...) -> unformattable { return {}; }
};

// A type constant after applying arg_mapper<Context>.
template <typename T, typename Context>
using mapped_type_constant =
    type_constant<decltype(arg_mapper<Context>().map(std::declval<const T&>())),
                  typename Context::char_type>;

enum { packed_arg_bits = 4 };
// Maximum number of arguments with packed types.
enum { max_packed_args = 62 / packed_arg_bits };
enum : unsigned long long { is_unpacked_bit = 1ULL << 63 };
enum : unsigned long long { has_named_args_bit = 1ULL << 62 };

FMT_END_DETAIL_NAMESPACE

// An output iterator that appends to a buffer.
// It is used to reduce symbol sizes for the common case.
class appender : public std::back_insert_iterator<detail::buffer<char>> {
  using base = std::back_insert_iterator<detail::buffer<char>>;

  template <typename T>
  friend auto get_buffer(appender out) -> detail::buffer<char>& {
    return detail::get_container(out);
  }

 public:
  using std::back_insert_iterator<detail::buffer<char>>::back_insert_iterator;
  appender(base it) FMT_NOEXCEPT : base(it) {}
  using _Unchecked_type = appender;  // Mark iterator as checked.

  auto operator++() FMT_NOEXCEPT -> appender& { return *this; }

  auto operator++(int) FMT_NOEXCEPT -> appender { return *this; }
};

// A formatting argument. It is a trivially copyable/constructible type to
// allow storage in basic_memory_buffer.
template <typename Context> class basic_format_arg {
 private:
  detail::value<Context> value_;
  detail::type type_;

  template <typename ContextType, typename T>
  friend FMT_CONSTEXPR auto detail::make_arg(const T& value)
      -> basic_format_arg<ContextType>;

  template <typename Visitor, typename Ctx>
  friend FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,
                                             const basic_format_arg<Ctx>& arg)
      -> decltype(vis(0));

  friend class basic_format_args<Context>;
  friend class dynamic_format_arg_store<Context>;

  using char_type = typename Context::char_type;

  template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
  friend struct detail::arg_data;

  basic_format_arg(const detail::named_arg_info<char_type>* args, size_t size)
      : value_(args, size) {}

 public:
  class handle {
   public:
    explicit handle(detail::custom_value<Context> custom) : custom_(custom) {}

    void format(typename Context::parse_context_type& parse_ctx,
                Context& ctx) const {
      custom_.format(custom_.value, parse_ctx, ctx);
    }

   private:
    detail::custom_value<Context> custom_;
  };

  constexpr basic_format_arg() : type_(detail::type::none_type) {}

  constexpr explicit operator bool() const FMT_NOEXCEPT {
    return type_ != detail::type::none_type;
  }

  auto type() const -> detail::type { return type_; }

  auto is_integral() const -> bool { return detail::is_integral_type(type_); }
  auto is_arithmetic() const -> bool {
    return detail::is_arithmetic_type(type_);
  }
};

/**
  \rst
  Visits an argument dispatching to the appropriate visit method based on
  the argument type. For example, if the argument type is ``double`` then
  ``vis(value)`` will be called with the value of type ``double``.
  \endrst
 */
template <typename Visitor, typename Context>
FMT_CONSTEXPR FMT_INLINE auto visit_format_arg(
    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
  switch (arg.type_) {
  case detail::type::none_type:
    break;
  case detail::type::int_type:
    return vis(arg.value_.int_value);
  case detail::type::uint_type:
    return vis(arg.value_.uint_value);
  case detail::type::long_long_type:
    return vis(arg.value_.long_long_value);
  case detail::type::ulong_long_type:
    return vis(arg.value_.ulong_long_value);
  case detail::type::int128_type:
    return vis(detail::convert_for_visit(arg.value_.int128_value));
  case detail::type::uint128_type:
    return vis(detail::convert_for_visit(arg.value_.uint128_value));
  case detail::type::bool_type:
    return vis(arg.value_.bool_value);
  case detail::type::char_type:
    return vis(arg.value_.char_value);
  case detail::type::float_type:
    return vis(arg.value_.float_value);
  case detail::type::double_type:
    return vis(arg.value_.double_value);
  case detail::type::long_double_type:
    return vis(arg.value_.long_double_value);
  case detail::type::cstring_type:
    return vis(arg.value_.string.data);
  case detail::type::string_type:
    using sv = basic_string_view<typename Context::char_type>;
    return vis(sv(arg.value_.string.data, arg.value_.string.size));
  case detail::type::pointer_type:
    return vis(arg.value_.pointer);
  case detail::type::custom_type:
    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
  }
  return vis(monostate());
}

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Char, typename InputIt>
auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
  get_container(out).append(begin, end);
  return out;
}

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
// A workaround for gcc 4.8 to make void_t work in a SFINAE context.
template <typename... Ts> struct void_t_impl { using type = void; };
template <typename... Ts>
using void_t = typename detail::void_t_impl<Ts...>::type;
#else
template <typename...> using void_t = void;
#endif

template <typename It, typename T, typename Enable = void>
struct is_output_iterator : std::false_type {};

template <typename It, typename T>
struct is_output_iterator<
    It, T,
    void_t<typename std::iterator_traits<It>::iterator_category,
           decltype(*std::declval<It>() = std::declval<T>())>>
    : std::true_type {};

template <typename OutputIt>
struct is_back_insert_iterator : std::false_type {};
template <typename Container>
struct is_back_insert_iterator<std::back_insert_iterator<Container>>
    : std::true_type {};

template <typename OutputIt>
struct is_contiguous_back_insert_iterator : std::false_type {};
template <typename Container>
struct is_contiguous_back_insert_iterator<std::back_insert_iterator<Container>>
    : is_contiguous<Container> {};
template <>
struct is_contiguous_back_insert_iterator<appender> : std::true_type {};

// A type-erased reference to an std::locale to avoid heavy <locale> include.
class locale_ref {
 private:
  const void* locale_;  // A type-erased pointer to std::locale.

 public:
  constexpr locale_ref() : locale_(nullptr) {}
  template <typename Locale> explicit locale_ref(const Locale& loc);

  explicit operator bool() const FMT_NOEXCEPT { return locale_ != nullptr; }

  template <typename Locale> auto get() const -> Locale;
};

template <typename> constexpr auto encode_types() -> unsigned long long {
  return 0;
}

template <typename Context, typename Arg, typename... Args>
constexpr auto encode_types() -> unsigned long long {
  return static_cast<unsigned>(mapped_type_constant<Arg, Context>::value) |
         (encode_types<Context, Args...>() << packed_arg_bits);
}

template <typename Context, typename T>
FMT_CONSTEXPR auto make_arg(const T& value) -> basic_format_arg<Context> {
  basic_format_arg<Context> arg;
  arg.type_ = mapped_type_constant<T, Context>::value;
  arg.value_ = arg_mapper<Context>().map(value);
  return arg;
}

// The type template parameter is there to avoid an ODR violation when using
// a fallback formatter in one translation unit and an implicit conversion in
// another (not recommended).
template <bool IS_PACKED, typename Context, type, typename T,
          FMT_ENABLE_IF(IS_PACKED)>
FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {
  const auto& arg = arg_mapper<Context>().map(std::forward<T>(val));

  constexpr bool formattable_char =
      !std::is_same<decltype(arg), const unformattable_char&>::value;
  static_assert(formattable_char, "Mixing character types is disallowed.");

  constexpr bool formattable_const =
      !std::is_same<decltype(arg), const unformattable_const&>::value;
  static_assert(formattable_const, "Cannot format a const argument.");

  // Formatting of arbitrary pointers is disallowed. If you want to output
  // a pointer cast it to "void *" or "const void *". In particular, this
  // forbids formatting of "[const] volatile char *" which is printed as bool
  // by iostreams.
  constexpr bool formattable_pointer =
      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
  static_assert(formattable_pointer,
                "Formatting of non-void pointers is disallowed.");

  constexpr bool formattable =
      !std::is_same<decltype(arg), const unformattable&>::value;
  static_assert(
      formattable,
      "Cannot format an argument. To make type T formattable provide a "
      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
  return {arg};
}

template <bool IS_PACKED, typename Context, type, typename T,
          FMT_ENABLE_IF(!IS_PACKED)>
inline auto make_arg(const T& value) -> basic_format_arg<Context> {
  return make_arg<Context>(value);
}
FMT_END_DETAIL_NAMESPACE

// Formatting context.
template <typename OutputIt, typename Char> class basic_format_context {
 public:
  /** The character type for the output. */
  using char_type = Char;

 private:
  OutputIt out_;
  basic_format_args<basic_format_context> args_;
  detail::locale_ref loc_;

 public:
  using iterator = OutputIt;
  using format_arg = basic_format_arg<basic_format_context>;
  using parse_context_type = basic_format_parse_context<Char>;
  template <typename T> using formatter_type = formatter<T, char_type>;

  basic_format_context(basic_format_context&&) = default;
  basic_format_context(const basic_format_context&) = delete;
  void operator=(const basic_format_context&) = delete;
  /**
   Constructs a ``basic_format_context`` object. References to the arguments are
   stored in the object so make sure they have appropriate lifetimes.
   */
  constexpr basic_format_context(
      OutputIt out, basic_format_args<basic_format_context> ctx_args,
      detail::locale_ref loc = detail::locale_ref())
      : out_(out), args_(ctx_args), loc_(loc) {}

  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
  FMT_CONSTEXPR auto arg(basic_string_view<char_type> name) -> format_arg {
    return args_.get(name);
  }
  FMT_CONSTEXPR auto arg_id(basic_string_view<char_type> name) -> int {
    return args_.get_id(name);
  }
  auto args() const -> const basic_format_args<basic_format_context>& {
    return args_;
  }

  FMT_CONSTEXPR auto error_handler() -> detail::error_handler { return {}; }
  void on_error(const char* message) { error_handler().on_error(message); }

  // Returns an iterator to the beginning of the output range.
  FMT_CONSTEXPR auto out() -> iterator { return out_; }

  // Advances the begin iterator to ``it``.
  void advance_to(iterator it) {
    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
  }

  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
};

template <typename Char>
using buffer_context =
    basic_format_context<detail::buffer_appender<Char>, Char>;
using format_context = buffer_context<char>;

// Workaround an alias issue: https://stackoverflow.com/q/62767544/471164.
#define FMT_BUFFER_CONTEXT(Char) \
  basic_format_context<detail::buffer_appender<Char>, Char>

template <typename T, typename Char = char>
using is_formattable = bool_constant<
    !std::is_base_of<detail::unformattable,
                     decltype(detail::arg_mapper<buffer_context<Char>>().map(
                         std::declval<T>()))>::value &&
    !detail::has_fallback_formatter<T, Char>::value>;

/**
  \rst
  An array of references to arguments. It can be implicitly converted into
  `~fmt::basic_format_args` for passing into type-erased formatting functions
  such as `~fmt::vformat`.
  \endrst
 */
template <typename Context, typename... Args>
class format_arg_store
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
    // Workaround a GCC template argument substitution bug.
    : public basic_format_args<Context>
#endif
{
 private:
  static const size_t num_args = sizeof...(Args);
  static const size_t num_named_args = detail::count_named_args<Args...>();
  static const bool is_packed = num_args <= detail::max_packed_args;

  using value_type = conditional_t<is_packed, detail::value<Context>,
                                   basic_format_arg<Context>>;

  detail::arg_data<value_type, typename Context::char_type, num_args,
                   num_named_args>
      data_;

  friend class basic_format_args<Context>;

  static constexpr unsigned long long desc =
      (is_packed ? detail::encode_types<Context, Args...>()
                 : detail::is_unpacked_bit | num_args) |
      (num_named_args != 0
           ? static_cast<unsigned long long>(detail::has_named_args_bit)
           : 0);

 public:
  template <typename... T>
  FMT_CONSTEXPR FMT_INLINE format_arg_store(T&&... args)
      :
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
        basic_format_args<Context>(*this),
#endif
        data_{detail::make_arg<
            is_packed, Context,
            detail::mapped_type_constant<remove_cvref_t<T>, Context>::value>(
            std::forward<T>(args))...} {
    detail::init_named_args(data_.named_args(), 0, 0, args...);
  }
};

/**
  \rst
  Constructs a `~fmt::format_arg_store` object that contains references to
  arguments and can be implicitly converted to `~fmt::format_args`. `Context`
  can be omitted in which case it defaults to `~fmt::context`.
  See `~fmt::arg` for lifetime considerations.
  \endrst
 */
template <typename Context = format_context, typename... Args>
constexpr auto make_format_args(Args&&... args)
    -> format_arg_store<Context, remove_cvref_t<Args>...> {
  return {std::forward<Args>(args)...};
}

/**
  \rst
  Returns a named argument to be used in a formatting function.
  It should only be used in a call to a formatting function or
  `dynamic_format_arg_store::push_back`.

  **Example**::

    fmt::print("Elapsed time: {s:.2f} seconds", fmt::arg("s", 1.23));
  \endrst
 */
template <typename Char, typename T>
inline auto arg(const Char* name, const T& arg) -> detail::named_arg<Char, T> {
  static_assert(!detail::is_named_arg<T>(), "nested named arguments");
  return {name, arg};
}

/**
  \rst
  A view of a collection of formatting arguments. To avoid lifetime issues it
  should only be used as a parameter type in type-erased functions such as
  ``vformat``::

    void vlog(string_view format_str, format_args args);  // OK
    format_args args = make_format_args(42);  // Error: dangling reference
  \endrst
 */
template <typename Context> class basic_format_args {
 public:
  using size_type = int;
  using format_arg = basic_format_arg<Context>;

 private:
  // A descriptor that contains information about formatting arguments.
  // If the number of arguments is less or equal to max_packed_args then
  // argument types are passed in the descriptor. This reduces binary code size
  // per formatting function call.
  unsigned long long desc_;
  union {
    // If is_packed() returns true then argument values are stored in values_;
    // otherwise they are stored in args_. This is done to improve cache
    // locality and reduce compiled code size since storing larger objects
    // may require more code (at least on x86-64) even if the same amount of
    // data is actually copied to stack. It saves ~10% on the bloat test.
    const detail::value<Context>* values_;
    const format_arg* args_;
  };

  constexpr auto is_packed() const -> bool {
    return (desc_ & detail::is_unpacked_bit) == 0;
  }
  auto has_named_args() const -> bool {
    return (desc_ & detail::has_named_args_bit) != 0;
  }

  FMT_CONSTEXPR auto type(int index) const -> detail::type {
    int shift = index * detail::packed_arg_bits;
    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
    return static_cast<detail::type>((desc_ >> shift) & mask);
  }

  constexpr FMT_INLINE basic_format_args(unsigned long long desc,
                                         const detail::value<Context>* values)
      : desc_(desc), values_(values) {}
  constexpr basic_format_args(unsigned long long desc, const format_arg* args)
      : desc_(desc), args_(args) {}

 public:
  constexpr basic_format_args() : desc_(0), args_(nullptr) {}

  /**
   \rst
   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.
   \endrst
   */
  template <typename... Args>
  constexpr FMT_INLINE basic_format_args(
      const format_arg_store<Context, Args...>& store)
      : basic_format_args(format_arg_store<Context, Args...>::desc,
                          store.data_.args()) {}

  /**
   \rst
   Constructs a `basic_format_args` object from
   `~fmt::dynamic_format_arg_store`.
   \endrst
   */
  constexpr FMT_INLINE basic_format_args(
      const dynamic_format_arg_store<Context>& store)
      : basic_format_args(store.get_types(), store.data()) {}

  /**
   \rst
   Constructs a `basic_format_args` object from a dynamic set of arguments.
   \endrst
   */
  constexpr basic_format_args(const format_arg* args, int count)
      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),
                          args) {}

  /** Returns the argument with the specified id. */
  FMT_CONSTEXPR auto get(int id) const -> format_arg {
    format_arg arg;
    if (!is_packed()) {
      if (id < max_size()) arg = args_[id];
      return arg;
    }
    if (id >= detail::max_packed_args) return arg;
    arg.type_ = type(id);
    if (arg.type_ == detail::type::none_type) return arg;
    arg.value_ = values_[id];
    return arg;
  }

  template <typename Char>
  auto get(basic_string_view<Char> name) const -> format_arg {
    int id = get_id(name);
    return id >= 0 ? get(id) : format_arg();
  }

  template <typename Char>
  auto get_id(basic_string_view<Char> name) const -> int {
    if (!has_named_args()) return -1;
    const auto& named_args =
        (is_packed() ? values_[-1] : args_[-1].value_).named_args;
    for (size_t i = 0; i < named_args.size; ++i) {
      if (named_args.data[i].name == name) return named_args.data[i].id;
    }
    return -1;
  }

  auto max_size() const -> int {
    unsigned long long max_packed = detail::max_packed_args;
    return static_cast<int>(is_packed() ? max_packed
                                        : desc_ & ~detail::is_unpacked_bit);
  }
};

/** An alias to ``basic_format_args<format_context>``. */
// A separate type would result in shorter symbols but break ABI compatibility
// between clang and gcc on ARM (#1919).
using format_args = basic_format_args<format_context>;

// We cannot use enum classes as bit fields because of a gcc bug
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414.
namespace align {
enum type { none, left, right, center, numeric };
}
using align_t = align::type;
namespace sign {
enum type { none, minus, plus, space };
}
using sign_t = sign::type;

FMT_BEGIN_DETAIL_NAMESPACE

// Workaround an array initialization issue in gcc 4.8.
template <typename Char> struct fill_t {
 private:
  enum { max_size = 4 };
  Char data_[max_size] = {Char(' '), Char(0), Char(0), Char(0)};
  unsigned char size_ = 1;

 public:
  FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
    auto size = s.size();
    if (size > max_size) return throw_format_error("invalid fill");
    for (size_t i = 0; i < size; ++i) data_[i] = s[i];
    size_ = static_cast<unsigned char>(size);
  }

  constexpr auto size() const -> size_t { return size_; }
  constexpr auto data() const -> const Char* { return data_; }

  FMT_CONSTEXPR auto operator[](size_t index) -> Char& { return data_[index]; }
  FMT_CONSTEXPR auto operator[](size_t index) const -> const Char& {
    return data_[index];
  }
};
FMT_END_DETAIL_NAMESPACE

enum class presentation_type : unsigned char {
  none,
  // Integer types should go first,
  dec,             // 'd'
  oct,             // 'o'
  hex_lower,       // 'x'
  hex_upper,       // 'X'
  bin_lower,       // 'b'
  bin_upper,       // 'B'
  hexfloat_lower,  // 'a'
  hexfloat_upper,  // 'A'
  exp_lower,       // 'e'
  exp_upper,       // 'E'
  fixed_lower,     // 'f'
  fixed_upper,     // 'F'
  general_lower,   // 'g'
  general_upper,   // 'G'
  chr,             // 'c'
  string,          // 's'
  pointer          // 'p'
};

// Format specifiers for built-in and string types.
template <typename Char> struct basic_format_specs {
  int width;
  int precision;
  presentation_type type;
  align_t align : 4;
  sign_t sign : 3;
  bool alt : 1;  // Alternate form ('#').
  bool localized : 1;
  detail::fill_t<Char> fill;

  constexpr basic_format_specs()
      : width(0),
        precision(-1),
        type(presentation_type::none),
        align(align::none),
        sign(sign::none),
        alt(false),
        localized(false) {}
};

using format_specs = basic_format_specs<char>;

FMT_BEGIN_DETAIL_NAMESPACE

enum class arg_id_kind { none, index, name };

// An argument reference.
template <typename Char> struct arg_ref {
  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}

  FMT_CONSTEXPR explicit arg_ref(int index)
      : kind(arg_id_kind::index), val(index) {}
  FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
      : kind(arg_id_kind::name), val(name) {}

  FMT_CONSTEXPR auto operator=(int idx) -> arg_ref& {
    kind = arg_id_kind::index;
    val.index = idx;
    return *this;
  }

  arg_id_kind kind;
  union value {
    FMT_CONSTEXPR value(int id = 0) : index{id} {}
    FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}

    int index;
    basic_string_view<Char> name;
  } val;
};

// Format specifiers with width and precision resolved at formatting rather
// than parsing time to allow re-using the same parsed specifiers with
// different sets of arguments (precompilation of format strings).
template <typename Char>
struct dynamic_format_specs : basic_format_specs<Char> {
  arg_ref<Char> width_ref;
  arg_ref<Char> precision_ref;
};

struct auto_id {};

// A format specifier handler that sets fields in basic_format_specs.
template <typename Char> class specs_setter {
 protected:
  basic_format_specs<Char>& specs_;

 public:
  explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)
      : specs_(specs) {}

  FMT_CONSTEXPR specs_setter(const specs_setter& other)
      : specs_(other.specs_) {}

  FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
  FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
    specs_.fill = fill;
  }
  FMT_CONSTEXPR void on_sign(sign_t s) { specs_.sign = s; }
  FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
  FMT_CONSTEXPR void on_localized() { specs_.localized = true; }

  FMT_CONSTEXPR void on_zero() {
    if (specs_.align == align::none) specs_.align = align::numeric;
    specs_.fill[0] = Char('0');
  }

  FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
  FMT_CONSTEXPR void on_precision(int precision) {
    specs_.precision = precision;
  }
  FMT_CONSTEXPR void end_precision() {}

  FMT_CONSTEXPR void on_type(presentation_type type) { specs_.type = type; }
};

// Format spec handler that saves references to arguments representing dynamic
// width and precision to be resolved at formatting time.
template <typename ParseContext>
class dynamic_specs_handler
    : public specs_setter<typename ParseContext::char_type> {
 public:
  using char_type = typename ParseContext::char_type;

  FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,
                                      ParseContext& ctx)
      : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}

  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)
      : specs_setter<char_type>(other),
        specs_(other.specs_),
        context_(other.context_) {}

  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
    specs_.width_ref = make_arg_ref(arg_id);
  }

  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
    specs_.precision_ref = make_arg_ref(arg_id);
  }

  FMT_CONSTEXPR void on_error(const char* message) {
    context_.on_error(message);
  }

 private:
  dynamic_format_specs<char_type>& specs_;
  ParseContext& context_;

  using arg_ref_type = arg_ref<char_type>;

  FMT_CONSTEXPR auto make_arg_ref(int arg_id) -> arg_ref_type {
    context_.check_arg_id(arg_id);
    return arg_ref_type(arg_id);
  }

  FMT_CONSTEXPR auto make_arg_ref(auto_id) -> arg_ref_type {
    return arg_ref_type(context_.next_arg_id());
  }

  FMT_CONSTEXPR auto make_arg_ref(basic_string_view<char_type> arg_id)
      -> arg_ref_type {
    context_.check_arg_id(arg_id);
    basic_string_view<char_type> format_str(
        context_.begin(), to_unsigned(context_.end() - context_.begin()));
    return arg_ref_type(arg_id);
  }
};

template <typename Char> constexpr bool is_ascii_letter(Char c) {
  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Converts a character to ASCII. Returns a number > 127 on conversion failure.
template <typename Char, FMT_ENABLE_IF(std::is_integral<Char>::value)>
constexpr auto to_ascii(Char value) -> Char {
  return value;
}
template <typename Char, FMT_ENABLE_IF(std::is_enum<Char>::value)>
constexpr auto to_ascii(Char value) ->
    typename std::underlying_type<Char>::type {
  return value;
}

template <typename Char>
FMT_CONSTEXPR auto code_point_length(const Char* begin) -> int {
  if (const_check(sizeof(Char) != 1)) return 1;
  auto lengths =
      "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\0\2\2\2\2\3\3\4";
  int len = lengths[static_cast<unsigned char>(*begin) >> 3];

  // Compute the pointer to the next character early so that the next
  // iteration can start working on the next character. Neither Clang
  // nor GCC figure out this reordering on their own.
  return len + !len;
}

// Return the result via the out param to workaround gcc bug 77539.
template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
FMT_CONSTEXPR auto find(Ptr first, Ptr last, T value, Ptr& out) -> bool {
  for (out = first; out != last; ++out) {
    if (*out == value) return true;
  }
  return false;
}

template <>
inline auto find<false, char>(const char* first, const char* last, char value,
                              const char*& out) -> bool {
  out = static_cast<const char*>(
      std::memchr(first, value, to_unsigned(last - first)));
  return out != nullptr;
}

// Parses the range [begin, end) as an unsigned integer. This function assumes
// that the range is non-empty and the first character is a digit.
template <typename Char>
FMT_CONSTEXPR auto parse_nonnegative_int(const Char*& begin, const Char* end,
                                         int error_value) noexcept -> int {
  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
  unsigned value = 0, prev = 0;
  auto p = begin;
  do {
    prev = value;
    value = value * 10 + unsigned(*p - '0');
    ++p;
  } while (p != end && '0' <= *p && *p <= '9');
  auto num_digits = p - begin;
  begin = p;
  if (num_digits <= std::numeric_limits<int>::digits10)
    return static_cast<int>(value);
  // Check for overflow.
  const unsigned max = to_unsigned((std::numeric_limits<int>::max)());
  return num_digits == std::numeric_limits<int>::digits10 + 1 &&
                 prev * 10ull + unsigned(p[-1] - '0') <= max
             ? static_cast<int>(value)
             : error_value;
}

// Parses fill and alignment.
template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_align(const Char* begin, const Char* end,
                               Handler&& handler) -> const Char* {
  FMT_ASSERT(begin != end, "");
  auto align = align::none;
  auto p = begin + code_point_length(begin);
  if (p >= end) p = begin;
  for (;;) {
    switch (to_ascii(*p)) {
    case '<':
      align = align::left;
      break;
    case '>':
      align = align::right;
      break;
    case '^':
      align = align::center;
      break;
    default:
      break;
    }
    if (align != align::none) {
      if (p != begin) {
        auto c = *begin;
        if (c == '{')
          return handler.on_error("invalid fill character '{'"), begin;
        handler.on_fill(basic_string_view<Char>(begin, to_unsigned(p - begin)));
        begin = p + 1;
      } else
        ++begin;
      handler.on_align(align);
      break;
    } else if (p == begin) {
      break;
    }
    p = begin;
  }
  return begin;
}

template <typename Char> FMT_CONSTEXPR bool is_name_start(Char c) {
  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
}

template <typename Char, typename IDHandler>
FMT_CONSTEXPR auto do_parse_arg_id(const Char* begin, const Char* end,
                                   IDHandler&& handler) -> const Char* {
  FMT_ASSERT(begin != end, "");
  Char c = *begin;
  if (c >= '0' && c <= '9') {
    int index = 0;
    if (c != '0')
      index =
          parse_nonnegative_int(begin, end, (std::numeric_limits<int>::max)());
    else
      ++begin;
    if (begin == end || (*begin != '}' && *begin != ':'))
      handler.on_error("invalid format string");
    else
      handler(index);
    return begin;
  }
  if (!is_name_start(c)) {
    handler.on_error("invalid format string");
    return begin;
  }
  auto it = begin;
  do {
    ++it;
  } while (it != end && (is_name_start(c = *it) || ('0' <= c && c <= '9')));
  handler(basic_string_view<Char>(begin, to_unsigned(it - begin)));
  return it;
}

template <typename Char, typename IDHandler>
FMT_CONSTEXPR FMT_INLINE auto parse_arg_id(const Char* begin, const Char* end,
                                           IDHandler&& handler) -> const Char* {
  Char c = *begin;
  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  handler();
  return begin;
}

template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_width(const Char* begin, const Char* end,
                               Handler&& handler) -> const Char* {
  using detail::auto_id;
  struct width_adapter {
    Handler& handler;

    FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
      handler.on_dynamic_width(id);
    }
    FMT_CONSTEXPR void on_error(const char* message) {
      if (message) handler.on_error(message);
    }
  };

  FMT_ASSERT(begin != end, "");
  if ('0' <= *begin && *begin <= '9') {
    int width = parse_nonnegative_int(begin, end, -1);
    if (width != -1)
      handler.on_width(width);
    else
      handler.on_error("number is too big");
  } else if (*begin == '{') {
    ++begin;
    if (begin != end) begin = parse_arg_id(begin, end, width_adapter{handler});
    if (begin == end || *begin != '}')
      return handler.on_error("invalid format string"), begin;
    ++begin;
  }
  return begin;
}

template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_precision(const Char* begin, const Char* end,
                                   Handler&& handler) -> const Char* {
  using detail::auto_id;
  struct precision_adapter {
    Handler& handler;

    FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
      handler.on_dynamic_precision(id);
    }
    FMT_CONSTEXPR void on_error(const char* message) {
      if (message) handler.on_error(message);
    }
  };

  ++begin;
  auto c = begin != end ? *begin : Char();
  if ('0' <= c && c <= '9') {
    auto precision = parse_nonnegative_int(begin, end, -1);
    if (precision != -1)
      handler.on_precision(precision);
    else
      handler.on_error("number is too big");
  } else if (c == '{') {
    ++begin;
    if (begin != end)
      begin = parse_arg_id(begin, end, precision_adapter{handler});
    if (begin == end || *begin++ != '}')
      return handler.on_error("invalid format string"), begin;
  } else {
    return handler.on_error("missing precision specifier"), begin;
  }
  handler.end_precision();
  return begin;
}

template <typename Char>
FMT_CONSTEXPR auto parse_presentation_type(Char type) -> presentation_type {
  switch (to_ascii(type)) {
  case 'd':
    return presentation_type::dec;
  case 'o':
    return presentation_type::oct;
  case 'x':
    return presentation_type::hex_lower;
  case 'X':
    return presentation_type::hex_upper;
  case 'b':
    return presentation_type::bin_lower;
  case 'B':
    return presentation_type::bin_upper;
  case 'a':
    return presentation_type::hexfloat_lower;
  case 'A':
    return presentation_type::hexfloat_upper;
  case 'e':
    return presentation_type::exp_lower;
  case 'E':
    return presentation_type::exp_upper;
  case 'f':
    return presentation_type::fixed_lower;
  case 'F':
    return presentation_type::fixed_upper;
  case 'g':
    return presentation_type::general_lower;
  case 'G':
    return presentation_type::general_upper;
  case 'c':
    return presentation_type::chr;
  case 's':
    return presentation_type::string;
  case 'p':
    return presentation_type::pointer;
  default:
    return presentation_type::none;
  }
}

// Parses standard format specifiers and sends notifications about parsed
// components to handler.
template <typename Char, typename SpecHandler>
FMT_CONSTEXPR FMT_INLINE auto parse_format_specs(const Char* begin,
                                                 const Char* end,
                                                 SpecHandler&& handler)
    -> const Char* {
  if (1 < end - begin && begin[1] == '}' && is_ascii_letter(*begin) &&
      *begin != 'L') {
    presentation_type type = parse_presentation_type(*begin++);
    if (type == presentation_type::none)
      handler.on_error("invalid type specifier");
    handler.on_type(type);
    return begin;
  }

  if (begin == end) return begin;

  begin = parse_align(begin, end, handler);
  if (begin == end) return begin;

  // Parse sign.
  switch (to_ascii(*begin)) {
  case '+':
    handler.on_sign(sign::plus);
    ++begin;
    break;
  case '-':
    handler.on_sign(sign::minus);
    ++begin;
    break;
  case ' ':
    handler.on_sign(sign::space);
    ++begin;
    break;
  default:
    break;
  }
  if (begin == end) return begin;

  if (*begin == '#') {
    handler.on_hash();
    if (++begin == end) return begin;
  }

  // Parse zero flag.
  if (*begin == '0') {
    handler.on_zero();
    if (++begin == end) return begin;
  }

  begin = parse_width(begin, end, handler);
  if (begin == end) return begin;

  // Parse precision.
  if (*begin == '.') {
    begin = parse_precision(begin, end, handler);
    if (begin == end) return begin;
  }

  if (*begin == 'L') {
    handler.on_localized();
    ++begin;
  }

  // Parse type.
  if (begin != end && *begin != '}') {
    presentation_type type = parse_presentation_type(*begin++);
    if (type == presentation_type::none)
      handler.on_error("invalid type specifier");
    handler.on_type(type);
  }
  return begin;
}

template <typename Char, typename Handler>
FMT_CONSTEXPR auto parse_replacement_field(const Char* begin, const Char* end,
                                           Handler&& handler) -> const Char* {
  struct id_adapter {
    Handler& handler;
    int arg_id;

    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
      arg_id = handler.on_arg_id(id);
    }
    FMT_CONSTEXPR void on_error(const char* message) {
      if (message) handler.on_error(message);
    }
  };

  ++begin;
  if (begin == end) return handler.on_error("invalid format string"), end;
  if (*begin == '}') {
    handler.on_replacement_field(handler.on_arg_id(), begin);
  } else if (*begin == '{') {
    handler.on_text(begin, begin + 1);
  } else {
    auto adapter = id_adapter{handler, 0};
    begin = parse_arg_id(begin, end, adapter);
    Char c = begin != end ? *begin : Char();
    if (c == '}') {
      handler.on_replacement_field(adapter.arg_id, begin);
    } else if (c == ':') {
      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
      if (begin == end || *begin != '}')
        return handler.on_error("unknown format specifier"), end;
    } else {
      return handler.on_error("missing '}' in format string"), end;
    }
  }
  return begin + 1;
}

template <bool IS_CONSTEXPR, typename Char, typename Handler>
FMT_CONSTEXPR FMT_INLINE void parse_format_string(
    basic_string_view<Char> format_str, Handler&& handler) {
  // Workaround a name-lookup bug in MSVC's modules implementation.
  using detail::find;

  auto begin = format_str.data();
  auto end = begin + format_str.size();
  if (end - begin < 32) {
    // Use a simple loop instead of memchr for small strings.
    const Char* p = begin;
    while (p != end) {
      auto c = *p++;
      if (c == '{') {
        handler.on_text(begin, p - 1);
        begin = p = parse_replacement_field(p - 1, end, handler);
      } else if (c == '}') {
        if (p == end || *p != '}')
          return handler.on_error("unmatched '}' in format string");
        handler.on_text(begin, p);
        begin = ++p;
      }
    }
    handler.on_text(begin, end);
    return;
  }
  struct writer {
    FMT_CONSTEXPR void operator()(const Char* pbegin, const Char* pend) {
      if (pbegin == pend) return;
      for (;;) {
        const Char* p = nullptr;
        if (!find<IS_CONSTEXPR>(pbegin, pend, Char('}'), p))
          return handler_.on_text(pbegin, pend);
        ++p;
        if (p == pend || *p != '}')
          return handler_.on_error("unmatched '}' in format string");
        handler_.on_text(pbegin, p);
        pbegin = p + 1;
      }
    }
    Handler& handler_;
  } write{handler};
  while (begin != end) {
    // Doing two passes with memchr (one for '{' and another for '}') is up to
    // 2.5x faster than the naive one-pass implementation on big format strings.
    const Char* p = begin;
    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
      return write(begin, end);
    write(begin, p);
    begin = parse_replacement_field(p, end, handler);
  }
}

template <typename T, typename ParseContext>
FMT_CONSTEXPR auto parse_format_specs(ParseContext& ctx)
    -> decltype(ctx.begin()) {
  using char_type = typename ParseContext::char_type;
  using context = buffer_context<char_type>;
  using mapped_type = conditional_t<
      mapped_type_constant<T, context>::value != type::custom_type,
      decltype(arg_mapper<context>().map(std::declval<const T&>())), T>;
  auto f = conditional_t<has_formatter<mapped_type, context>::value,
                         formatter<mapped_type, char_type>,
                         fallback_formatter<T, char_type>>();
  return f.parse(ctx);
}

// A parse context with extra argument id checks. It is only used at compile
// time because adding checks at runtime would introduce substantial overhead
// and would be redundant since argument ids are checked when arguments are
// retrieved anyway.
template <typename Char, typename ErrorHandler = error_handler>
class compile_parse_context
    : public basic_format_parse_context<Char, ErrorHandler> {
 private:
  int num_args_;
  using base = basic_format_parse_context<Char, ErrorHandler>;

 public:
  explicit FMT_CONSTEXPR compile_parse_context(
      basic_string_view<Char> format_str,
      int num_args = (std::numeric_limits<int>::max)(), ErrorHandler eh = {})
      : base(format_str, eh), num_args_(num_args) {}

  FMT_CONSTEXPR auto next_arg_id() -> int {
    int id = base::next_arg_id();
    if (id >= num_args_) this->on_error("argument not found");
    return id;
  }

  FMT_CONSTEXPR void check_arg_id(int id) {
    base::check_arg_id(id);
    if (id >= num_args_) this->on_error("argument not found");
  }
  using base::check_arg_id;
};

template <typename ErrorHandler>
FMT_CONSTEXPR void check_int_type_spec(presentation_type type,
                                       ErrorHandler&& eh) {
  if (type > presentation_type::bin_upper && type != presentation_type::chr)
    eh.on_error("invalid type specifier");
}

// Checks char specs and returns true if the type spec is char (and not int).
template <typename Char, typename ErrorHandler = error_handler>
FMT_CONSTEXPR auto check_char_specs(const basic_format_specs<Char>& specs,
                                    ErrorHandler&& eh = {}) -> bool {
  if (specs.type != presentation_type::none &&
      specs.type != presentation_type::chr) {
    check_int_type_spec(specs.type, eh);
    return false;
  }
  if (specs.align == align::numeric || specs.sign != sign::none || specs.alt)
    eh.on_error("invalid format specifier for char");
  return true;
}

// A floating-point presentation format.
enum class float_format : unsigned char {
  general,  // General: exponent notation or fixed point based on magnitude.
  exp,      // Exponent notation with the default precision of 6, e.g. 1.2e-3.
  fixed,    // Fixed point with the default precision of 6, e.g. 0.0012.
  hex
};

struct float_specs {
  int precision;
  float_format format : 8;
  sign_t sign : 8;
  bool upper : 1;
  bool locale : 1;
  bool binary32 : 1;
  bool fallback : 1;
  bool showpoint : 1;
};

template <typename ErrorHandler = error_handler, typename Char>
FMT_CONSTEXPR auto parse_float_type_spec(const basic_format_specs<Char>& specs,
                                         ErrorHandler&& eh = {})
    -> float_specs {
  auto result = float_specs();
  result.showpoint = specs.alt;
  result.locale = specs.localized;
  switch (specs.type) {
  case presentation_type::none:
    result.format = float_format::general;
    break;
  case presentation_type::general_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::general_lower:
    result.format = float_format::general;
    break;
  case presentation_type::exp_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::exp_lower:
    result.format = float_format::exp;
    result.showpoint |= specs.precision != 0;
    break;
  case presentation_type::fixed_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::fixed_lower:
    result.format = float_format::fixed;
    result.showpoint |= specs.precision != 0;
    break;
  case presentation_type::hexfloat_upper:
    result.upper = true;
    FMT_FALLTHROUGH;
  case presentation_type::hexfloat_lower:
    result.format = float_format::hex;
    break;
  default:
    eh.on_error("invalid type specifier");
    break;
  }
  return result;
}

template <typename ErrorHandler = error_handler>
FMT_CONSTEXPR auto check_cstring_type_spec(presentation_type type,
                                           ErrorHandler&& eh = {}) -> bool {
  if (type == presentation_type::none || type == presentation_type::string)
    return true;
  if (type != presentation_type::pointer) eh.on_error("invalid type specifier");
  return false;
}

template <typename ErrorHandler = error_handler>
FMT_CONSTEXPR void check_string_type_spec(presentation_type type,
                                          ErrorHandler&& eh = {}) {
  if (type != presentation_type::none && type != presentation_type::string)
    eh.on_error("invalid type specifier");
}

template <typename ErrorHandler>
FMT_CONSTEXPR void check_pointer_type_spec(presentation_type type,
                                           ErrorHandler&& eh) {
  if (type != presentation_type::none && type != presentation_type::pointer)
    eh.on_error("invalid type specifier");
}

// A parse_format_specs handler that checks if specifiers are consistent with
// the argument type.
template <typename Handler> class specs_checker : public Handler {
 private:
  detail::type arg_type_;

  FMT_CONSTEXPR void require_numeric_argument() {
    if (!is_arithmetic_type(arg_type_))
      this->on_error("format specifier requires numeric argument");
  }

 public:
  FMT_CONSTEXPR specs_checker(const Handler& handler, detail::type arg_type)
      : Handler(handler), arg_type_(arg_type) {}

  FMT_CONSTEXPR void on_align(align_t align) {
    if (align == align::numeric) require_numeric_argument();
    Handler::on_align(align);
  }

  FMT_CONSTEXPR void on_sign(sign_t s) {
    require_numeric_argument();
    if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&
        arg_type_ != type::long_long_type && arg_type_ != type::char_type) {
      this->on_error("format specifier requires signed argument");
    }
    Handler::on_sign(s);
  }

  FMT_CONSTEXPR void on_hash() {
    require_numeric_argument();
    Handler::on_hash();
  }

  FMT_CONSTEXPR void on_localized() {
    require_numeric_argument();
    Handler::on_localized();
  }

  FMT_CONSTEXPR void on_zero() {
    require_numeric_argument();
    Handler::on_zero();
  }

  FMT_CONSTEXPR void end_precision() {
    if (is_integral_type(arg_type_) || arg_type_ == type::pointer_type)
      this->on_error("precision not allowed for this argument type");
  }
};

constexpr int invalid_arg_index = -1;

#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <int N, typename T, typename... Args, typename Char>
constexpr auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
  if constexpr (detail::is_statically_named_arg<T>()) {
    if (name == T::name) return N;
  }
  if constexpr (sizeof...(Args) > 0)
    return get_arg_index_by_name<N + 1, Args...>(name);
  (void)name;  // Workaround an MSVC bug about "unused" parameter.
  return invalid_arg_index;
}
#endif

template <typename... Args, typename Char>
FMT_CONSTEXPR auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
  if constexpr (sizeof...(Args) > 0)
    return get_arg_index_by_name<0, Args...>(name);
#endif
  (void)name;
  return invalid_arg_index;
}

template <typename Char, typename ErrorHandler, typename... Args>
class format_string_checker {
 private:
  using parse_context_type = compile_parse_context<Char, ErrorHandler>;
  enum { num_args = sizeof...(Args) };

  // Format specifier parsing function.
  using parse_func = const Char* (*)(parse_context_type&);

  parse_context_type context_;
  parse_func parse_funcs_[num_args > 0 ? num_args : 1];

 public:
  explicit FMT_CONSTEXPR format_string_checker(
      basic_string_view<Char> format_str, ErrorHandler eh)
      : context_(format_str, num_args, eh),
        parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}

  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}

  FMT_CONSTEXPR auto on_arg_id() -> int { return context_.next_arg_id(); }
  FMT_CONSTEXPR auto on_arg_id(int id) -> int {
    return context_.check_arg_id(id), id;
  }
  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
    auto index = get_arg_index_by_name<Args...>(id);
    if (index == invalid_arg_index) on_error("named argument is not found");
    return context_.check_arg_id(index), index;
#else
    (void)id;
    on_error("compile-time checks for named arguments require C++20 support");
    return 0;
#endif
  }

  FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}

  FMT_CONSTEXPR auto on_format_specs(int id, const Char* begin, const Char*)
      -> const Char* {
    context_.advance_to(context_.begin() + (begin - &*context_.begin()));
    // id >= 0 check is a workaround for gcc 10 bug (#2065).
    return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;
  }

  FMT_CONSTEXPR void on_error(const char* message) {
    context_.on_error(message);
  }
};

template <typename... Args, typename S,
          enable_if_t<(is_compile_string<S>::value), int>>
void check_format_string(S format_str) {
  FMT_CONSTEXPR auto s = to_string_view(format_str);
  using checker = format_string_checker<typename S::char_type, error_handler,
                                        remove_cvref_t<Args>...>;
  FMT_CONSTEXPR bool invalid_format =
      (parse_format_string<true>(s, checker(s, {})), true);
  ignore_unused(invalid_format);
}

template <typename Char>
void vformat_to(
    buffer<Char>& buf, basic_string_view<Char> fmt,
    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
    locale_ref loc = {});

FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
#ifndef _WIN32
inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
#endif
FMT_END_DETAIL_NAMESPACE

// A formatter specialization for the core types corresponding to detail::type
// constants.
template <typename T, typename Char>
struct formatter<T, Char,
                 enable_if_t<detail::type_constant<T, Char>::value !=
                             detail::type::custom_type>> {
 private:
  detail::dynamic_format_specs<Char> specs_;

 public:
  // Parses format specifiers stopping either at the end of the range or at the
  // terminating '}'.
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    auto begin = ctx.begin(), end = ctx.end();
    if (begin == end) return begin;
    using handler_type = detail::dynamic_specs_handler<ParseContext>;
    auto type = detail::type_constant<T, Char>::value;
    auto checker =
        detail::specs_checker<handler_type>(handler_type(specs_, ctx), type);
    auto it = detail::parse_format_specs(begin, end, checker);
    auto eh = ctx.error_handler();
    switch (type) {
    case detail::type::none_type:
      FMT_ASSERT(false, "invalid argument type");
      break;
    case detail::type::bool_type:
      if (specs_.type == presentation_type::none ||
          specs_.type == presentation_type::string) {
        break;
      }
      FMT_FALLTHROUGH;
    case detail::type::int_type:
    case detail::type::uint_type:
    case detail::type::long_long_type:
    case detail::type::ulong_long_type:
    case detail::type::int128_type:
    case detail::type::uint128_type:
      detail::check_int_type_spec(specs_.type, eh);
      break;
    case detail::type::char_type:
      detail::check_char_specs(specs_, eh);
      break;
    case detail::type::float_type:
      if (detail::const_check(FMT_USE_FLOAT))
        detail::parse_float_type_spec(specs_, eh);
      else
        FMT_ASSERT(false, "float support disabled");
      break;
    case detail::type::double_type:
      if (detail::const_check(FMT_USE_DOUBLE))
        detail::parse_float_type_spec(specs_, eh);
      else
        FMT_ASSERT(false, "double support disabled");
      break;
    case detail::type::long_double_type:
      if (detail::const_check(FMT_USE_LONG_DOUBLE))
        detail::parse_float_type_spec(specs_, eh);
      else
        FMT_ASSERT(false, "long double support disabled");
      break;
    case detail::type::cstring_type:
      detail::check_cstring_type_spec(specs_.type, eh);
      break;
    case detail::type::string_type:
      detail::check_string_type_spec(specs_.type, eh);
      break;
    case detail::type::pointer_type:
      detail::check_pointer_type_spec(specs_.type, eh);
      break;
    case detail::type::custom_type:
      // Custom format specifiers are checked in parse functions of
      // formatter specializations.
      break;
    }
    return it;
  }

  template <typename FormatContext>
  FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
      -> decltype(ctx.out());
};

template <typename Char> struct basic_runtime { basic_string_view<Char> str; };

/** A compile-time format string. */
template <typename Char, typename... Args> class basic_format_string {
 private:
  basic_string_view<Char> str_;

 public:
  template <typename S,
            FMT_ENABLE_IF(
                std::is_convertible<const S&, basic_string_view<Char>>::value)>
  FMT_CONSTEVAL FMT_INLINE basic_format_string(const S& s) : str_(s) {
    static_assert(
        detail::count<
            (std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
             std::is_reference<Args>::value)...>() == 0,
        "passing views as lvalues is disallowed");
#ifdef FMT_HAS_CONSTEVAL
    if constexpr (detail::count_named_args<Args...>() ==
                  detail::count_statically_named_args<Args...>()) {
      using checker = detail::format_string_checker<Char, detail::error_handler,
                                                    remove_cvref_t<Args>...>;
      detail::parse_format_string<true>(str_, checker(s, {}));
    }
#else
    detail::check_format_string<Args...>(s);
#endif
  }
  basic_format_string(basic_runtime<Char> r) : str_(r.str) {}

  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
};

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
// Workaround broken conversion on older gcc.
template <typename... Args> using format_string = string_view;
template <typename S> auto runtime(const S& s) -> basic_string_view<char_t<S>> {
  return s;
}
#else
template <typename... Args>
using format_string = basic_format_string<char, type_identity_t<Args>...>;
/**
  \rst
  Creates a runtime format string.

  **Example**::

    // Check format string at runtime instead of compile-time.
    fmt::print(fmt::runtime("{:d}"), "I am not a number");
  \endrst
 */
template <typename S> auto runtime(const S& s) -> basic_runtime<char_t<S>> {
  return {{s}};
}
#endif

FMT_API auto vformat(string_view fmt, format_args args) -> std::string;

/**
  \rst
  Formats ``args`` according to specifications in ``fmt`` and returns the result
  as a string.

  **Example**::

    #include <fmt/core.h>
    std::string message = fmt::format("The answer is {}.", 42);
  \endrst
*/
template <typename... T>
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
    -> std::string {
  return vformat(fmt, fmt::make_format_args(args...));
}

/** Formats a string and writes the output to ``out``. */
template <typename OutputIt,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {
  using detail::get_buffer;
  auto&& buf = get_buffer<char>(out);
  detail::vformat_to(buf, fmt, args, {});
  return detail::get_iterator(buf);
}

/**
 \rst
 Formats ``args`` according to specifications in ``fmt``, writes the result to
 the output iterator ``out`` and returns the iterator past the end of the output
 range. `format_to` does not append a terminating null character.

 **Example**::

   auto out = std::vector<char>();
   fmt::format_to(std::back_inserter(out), "{}", 42);
 \endrst
 */
template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
FMT_INLINE auto format_to(OutputIt out, format_string<T...> fmt, T&&... args)
    -> OutputIt {
  return vformat_to(out, fmt, fmt::make_format_args(args...));
}

template <typename OutputIt> struct format_to_n_result {
  /** Iterator past the end of the output range. */
  OutputIt out;
  /** Total (not truncated) output size. */
  size_t size;
};

template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
auto vformat_to_n(OutputIt out, size_t n, string_view fmt, format_args args)
    -> format_to_n_result<OutputIt> {
  using traits = detail::fixed_buffer_traits;
  auto buf = detail::iterator_buffer<OutputIt, char, traits>(out, n);
  detail::vformat_to(buf, fmt, args, {});
  return {buf.out(), buf.count()};
}

/**
  \rst
  Formats ``args`` according to specifications in ``fmt``, writes up to ``n``
  characters of the result to the output iterator ``out`` and returns the total
  (not truncated) output size and the iterator past the end of the output range.
  `format_to_n` does not append a terminating null character.
  \endrst
 */
template <typename OutputIt, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
FMT_INLINE auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt,
                            T&&... args) -> format_to_n_result<OutputIt> {
  return vformat_to_n(out, n, fmt, fmt::make_format_args(args...));
}

/** Returns the number of chars in the output of ``format(fmt, args...)``. */
template <typename... T>
FMT_NODISCARD FMT_INLINE auto formatted_size(format_string<T...> fmt,
                                             T&&... args) -> size_t {
  auto buf = detail::counting_buffer<>();
  detail::vformat_to(buf, string_view(fmt), fmt::make_format_args(args...), {});
  return buf.count();
}

FMT_API void vprint(string_view fmt, format_args args);
FMT_API void vprint(std::FILE* f, string_view fmt, format_args args);

/**
  \rst
  Formats ``args`` according to specifications in ``fmt`` and writes the output
  to ``stdout``.

  **Example**::

    fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
  \endrst
 */
template <typename... T>
FMT_INLINE void print(format_string<T...> fmt, T&&... args) {
  const auto& vargs = fmt::make_format_args(args...);
  return detail::is_utf8() ? vprint(fmt, vargs)
                           : detail::vprint_mojibake(stdout, fmt, vargs);
}

/**
  \rst
  Formats ``args`` according to specifications in ``fmt`` and writes the
  output to the file ``f``.

  **Example**::

    fmt::print(stderr, "Don't {}!", "panic");
  \endrst
 */
template <typename... T>
FMT_INLINE void print(std::FILE* f, format_string<T...> fmt, T&&... args) {
  const auto& vargs = fmt::make_format_args(args...);
  return detail::is_utf8() ? vprint(f, fmt, vargs)
                           : detail::vprint_mojibake(f, fmt, vargs);
}

FMT_MODULE_EXPORT_END
FMT_GCC_PRAGMA("GCC pop_options")
FMT_END_NAMESPACE

#ifdef FMT_HEADER_ONLY
#  include "format.h"
#endif
#endif  // FMT_CORE_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/fmt.license.rst`:

```rst
Copyright (c) 2012 - present, Victor Zverovich

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--- Optional exception to the license ---

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into a machine-executable object form of such
source code, you may redistribute such embedded portions in such object form
without including the above copyright and permission notices.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h`:

```h
// Formatting library for C++ - implementation
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_FORMAT_INL_H_
#define FMT_FORMAT_INL_H_

#include <algorithm>
#include <cctype>
#include <cerrno>  // errno
#include <climits>
#include <cmath>
#include <cstdarg>
#include <cstring>  // std::memmove
#include <cwchar>
#include <exception>

#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
#  include <locale>
#endif

#ifdef _WIN32
#  include <io.h>  // _isatty
#endif

#include "format.h"

FMT_BEGIN_NAMESPACE
namespace detail {

FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
  // Use unchecked std::fprintf to avoid triggering another assertion when
  // writing to stderr fails
  std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
  // Chosen instead of std::abort to satisfy Clang in CUDA mode during device
  // code pass.
  std::terminate();
}

FMT_FUNC void throw_format_error(const char* message) {
  FMT_THROW(format_error(message));
}

#ifndef _MSC_VER
#  define FMT_SNPRINTF snprintf
#else  // _MSC_VER
inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
  va_list args;
  va_start(args, format);
  int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
  va_end(args);
  return result;
}
#  define FMT_SNPRINTF fmt_snprintf
#endif  // _MSC_VER

FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
                                string_view message) FMT_NOEXCEPT {
  // Report error code making sure that the output fits into
  // inline_buffer_size to avoid dynamic memory allocation and potential
  // bad_alloc.
  out.try_resize(0);
  static const char SEP[] = ": ";
  static const char ERROR_STR[] = "error ";
  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.
  size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
  auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);
  if (detail::is_negative(error_code)) {
    abs_value = 0 - abs_value;
    ++error_code_size;
  }
  error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
  auto it = buffer_appender<char>(out);
  if (message.size() <= inline_buffer_size - error_code_size)
    format_to(it, FMT_STRING("{}{}"), message, SEP);
  format_to(it, FMT_STRING("{}{}"), ERROR_STR, error_code);
  FMT_ASSERT(out.size() <= inline_buffer_size, "");
}

FMT_FUNC void report_error(format_func func, int error_code,
                           const char* message) FMT_NOEXCEPT {
  memory_buffer full_message;
  func(full_message, error_code, message);
  // Don't use fwrite_fully because the latter may throw.
  if (std::fwrite(full_message.data(), full_message.size(), 1, stderr) > 0)
    std::fputc('\n', stderr);
}

// A wrapper around fwrite that throws on error.
inline void fwrite_fully(const void* ptr, size_t size, size_t count,
                         FILE* stream) {
  size_t written = std::fwrite(ptr, size, count, stream);
  if (written < count) FMT_THROW(system_error(errno, "cannot write to file"));
}

#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
template <typename Locale>
locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
  static_assert(std::is_same<Locale, std::locale>::value, "");
}

template <typename Locale> Locale locale_ref::get() const {
  static_assert(std::is_same<Locale, std::locale>::value, "");
  return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
}

template <typename Char>
FMT_FUNC auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char> {
  auto& facet = std::use_facet<std::numpunct<Char>>(loc.get<std::locale>());
  auto grouping = facet.grouping();
  auto thousands_sep = grouping.empty() ? Char() : facet.thousands_sep();
  return {std::move(grouping), thousands_sep};
}
template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {
  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
      .decimal_point();
}
#else
template <typename Char>
FMT_FUNC auto thousands_sep_impl(locale_ref) -> thousands_sep_result<Char> {
  return {"\03", FMT_STATIC_THOUSANDS_SEPARATOR};
}
template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {
  return '.';
}
#endif
}  // namespace detail

#if !FMT_MSC_VER
FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;
#endif

FMT_FUNC std::system_error vsystem_error(int error_code, string_view format_str,
                                         format_args args) {
  auto ec = std::error_code(error_code, std::generic_category());
  return std::system_error(ec, vformat(format_str, args));
}

namespace detail {

template <> FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {
  // fallback_uintptr is always stored in little endian.
  int i = static_cast<int>(sizeof(void*)) - 1;
  while (i > 0 && n.value[i] == 0) --i;
  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
  return i >= 0 ? i * char_digits + count_digits<4, unsigned>(n.value[i]) : 1;
}

// log10(2) = 0x0.4d104d427de7fbcc...
static constexpr uint64_t log10_2_significand = 0x4d104d427de7fbcc;

template <typename T = void> struct basic_impl_data {
  // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
  // These are generated by support/compute-powers.py.
  static constexpr uint64_t pow10_significands[87] = {
      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
  };

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wnarrowing"
#endif
  // Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
  // to significands above.
  static constexpr int16_t pow10_exponents[87] = {
      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
#  pragma GCC diagnostic pop
#endif

  static constexpr uint64_t power_of_10_64[20] = {
      1, FMT_POWERS_OF_10(1ULL), FMT_POWERS_OF_10(1000000000ULL),
      10000000000000000000ULL};
};

// This is a struct rather than an alias to avoid shadowing warnings in gcc.
struct impl_data : basic_impl_data<> {};

#if __cplusplus < 201703L
template <typename T>
constexpr uint64_t basic_impl_data<T>::pow10_significands[];
template <typename T> constexpr int16_t basic_impl_data<T>::pow10_exponents[];
template <typename T> constexpr uint64_t basic_impl_data<T>::power_of_10_64[];
#endif

template <typename T> struct bits {
  static FMT_CONSTEXPR_DECL const int value =
      static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);
};

// Returns the number of significand bits in Float excluding the implicit bit.
template <typename Float> constexpr int num_significand_bits() {
  // Subtract 1 to account for an implicit most significant bit in the
  // normalized form.
  return std::numeric_limits<Float>::digits - 1;
}

// A floating-point number f * pow(2, e).
struct fp {
  uint64_t f;
  int e;

  static constexpr const int num_significand_bits = bits<decltype(f)>::value;

  constexpr fp() : f(0), e(0) {}
  constexpr fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}

  // Constructs fp from an IEEE754 floating-point number. It is a template to
  // prevent compile errors on systems where n is not IEEE754.
  template <typename Float> explicit FMT_CONSTEXPR fp(Float n) { assign(n); }

  template <typename Float>
  using is_supported = bool_constant<sizeof(Float) == sizeof(uint64_t) ||
                                     sizeof(Float) == sizeof(uint32_t)>;

  // Assigns d to this and return true iff predecessor is closer than successor.
  template <typename Float, FMT_ENABLE_IF(is_supported<Float>::value)>
  FMT_CONSTEXPR bool assign(Float n) {
    // Assume float is in the format [sign][exponent][significand].
    const int num_float_significand_bits =
        detail::num_significand_bits<Float>();
    const uint64_t implicit_bit = 1ULL << num_float_significand_bits;
    const uint64_t significand_mask = implicit_bit - 1;
    constexpr bool is_double = sizeof(Float) == sizeof(uint64_t);
    auto u = bit_cast<conditional_t<is_double, uint64_t, uint32_t>>(n);
    f = u & significand_mask;
    const uint64_t exponent_mask = (~0ULL >> 1) & ~significand_mask;
    int biased_e =
        static_cast<int>((u & exponent_mask) >> num_float_significand_bits);
    // The predecessor is closer if n is a normalized power of 2 (f == 0) other
    // than the smallest normalized number (biased_e > 1).
    bool is_predecessor_closer = f == 0 && biased_e > 1;
    if (biased_e != 0)
      f += implicit_bit;
    else
      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
    const int exponent_bias = std::numeric_limits<Float>::max_exponent - 1;
    e = biased_e - exponent_bias - num_float_significand_bits;
    return is_predecessor_closer;
  }

  template <typename Float, FMT_ENABLE_IF(!is_supported<Float>::value)>
  bool assign(Float) {
    FMT_ASSERT(false, "");
    return false;
  }
};

// Normalizes the value converted from double and multiplied by (1 << SHIFT).
template <int SHIFT = 0> FMT_CONSTEXPR fp normalize(fp value) {
  // Handle subnormals.
  const uint64_t implicit_bit = 1ULL << num_significand_bits<double>();
  const auto shifted_implicit_bit = implicit_bit << SHIFT;
  while ((value.f & shifted_implicit_bit) == 0) {
    value.f <<= 1;
    --value.e;
  }
  // Subtract 1 to account for hidden bit.
  const auto offset =
      fp::num_significand_bits - num_significand_bits<double>() - SHIFT - 1;
  value.f <<= offset;
  value.e -= offset;
  return value;
}

inline bool operator==(fp x, fp y) { return x.f == y.f && x.e == y.e; }

// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.
FMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
#if FMT_USE_INT128
  auto product = static_cast<__uint128_t>(lhs) * rhs;
  auto f = static_cast<uint64_t>(product >> 64);
  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
#else
  // Multiply 32-bit parts of significands.
  uint64_t mask = (1ULL << 32) - 1;
  uint64_t a = lhs >> 32, b = lhs & mask;
  uint64_t c = rhs >> 32, d = rhs & mask;
  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
  // Compute mid 64-bit of result and round.
  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
#endif
}

FMT_CONSTEXPR inline fp operator*(fp x, fp y) {
  return {multiply(x.f, y.f), x.e + y.e + 64};
}

// Returns a cached power of 10 `c_k = c_k.f * pow(2, c_k.e)` such that its
// (binary) exponent satisfies `min_exponent <= c_k.e <= min_exponent + 28`.
FMT_CONSTEXPR inline fp get_cached_power(int min_exponent,
                                         int& pow10_exponent) {
  const int shift = 32;
  const auto significand = static_cast<int64_t>(log10_2_significand);
  int index = static_cast<int>(
      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
       ((int64_t(1) << shift) - 1))  // ceil
      >> 32                          // arithmetic shift
  );
  // Decimal exponent of the first (smallest) cached power of 10.
  const int first_dec_exp = -348;
  // Difference between 2 consecutive decimal exponents in cached powers of 10.
  const int dec_exp_step = 8;
  index = (index - first_dec_exp - 1) / dec_exp_step + 1;
  pow10_exponent = first_dec_exp + index * dec_exp_step;
  return {impl_data::pow10_significands[index],
          impl_data::pow10_exponents[index]};
}

// A simple accumulator to hold the sums of terms in bigint::square if uint128_t
// is not available.
struct accumulator {
  uint64_t lower;
  uint64_t upper;

  constexpr accumulator() : lower(0), upper(0) {}
  constexpr explicit operator uint32_t() const {
    return static_cast<uint32_t>(lower);
  }

  FMT_CONSTEXPR void operator+=(uint64_t n) {
    lower += n;
    if (lower < n) ++upper;
  }
  FMT_CONSTEXPR void operator>>=(int shift) {
    FMT_ASSERT(shift == 32, "");
    (void)shift;
    lower = (upper << 32) | (lower >> 32);
    upper >>= 32;
  }
};

class bigint {
 private:
  // A bigint is stored as an array of bigits (big digits), with bigit at index
  // 0 being the least significant one.
  using bigit = uint32_t;
  using double_bigit = uint64_t;
  enum { bigits_capacity = 32 };
  basic_memory_buffer<bigit, bigits_capacity> bigits_;
  int exp_;

  FMT_CONSTEXPR20 bigit operator[](int index) const {
    return bigits_[to_unsigned(index)];
  }
  FMT_CONSTEXPR20 bigit& operator[](int index) {
    return bigits_[to_unsigned(index)];
  }

  static FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;

  friend struct formatter<bigint>;

  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
    (*this)[index] = static_cast<bigit>(result);
    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
  }

  FMT_CONSTEXPR20 void remove_leading_zeros() {
    int num_bigits = static_cast<int>(bigits_.size()) - 1;
    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
    bigits_.resize(to_unsigned(num_bigits + 1));
  }

  // Computes *this -= other assuming aligned bigints and *this >= other.
  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
    FMT_ASSERT(compare(*this, other) >= 0, "");
    bigit borrow = 0;
    int i = other.exp_ - exp_;
    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
      subtract_bigits(i, other.bigits_[j], borrow);
    while (borrow > 0) subtract_bigits(i, 0, borrow);
    remove_leading_zeros();
  }

  FMT_CONSTEXPR20 void multiply(uint32_t value) {
    const double_bigit wide_value = value;
    bigit carry = 0;
    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
      double_bigit result = bigits_[i] * wide_value + carry;
      bigits_[i] = static_cast<bigit>(result);
      carry = static_cast<bigit>(result >> bigit_bits);
    }
    if (carry != 0) bigits_.push_back(carry);
  }

  FMT_CONSTEXPR20 void multiply(uint64_t value) {
    const bigit mask = ~bigit(0);
    const double_bigit lower = value & mask;
    const double_bigit upper = value >> bigit_bits;
    double_bigit carry = 0;
    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
      double_bigit result = bigits_[i] * lower + (carry & mask);
      carry =
          bigits_[i] * upper + (result >> bigit_bits) + (carry >> bigit_bits);
      bigits_[i] = static_cast<bigit>(result);
    }
    while (carry != 0) {
      bigits_.push_back(carry & mask);
      carry >>= bigit_bits;
    }
  }

 public:
  FMT_CONSTEXPR20 bigint() : exp_(0) {}
  explicit bigint(uint64_t n) { assign(n); }
  FMT_CONSTEXPR20 ~bigint() {
    FMT_ASSERT(bigits_.capacity() <= bigits_capacity, "");
  }

  bigint(const bigint&) = delete;
  void operator=(const bigint&) = delete;

  FMT_CONSTEXPR20 void assign(const bigint& other) {
    auto size = other.bigits_.size();
    bigits_.resize(size);
    auto data = other.bigits_.data();
    std::copy(data, data + size, make_checked(bigits_.data(), size));
    exp_ = other.exp_;
  }

  FMT_CONSTEXPR20 void assign(uint64_t n) {
    size_t num_bigits = 0;
    do {
      bigits_[num_bigits++] = n & ~bigit(0);
      n >>= bigit_bits;
    } while (n != 0);
    bigits_.resize(num_bigits);
    exp_ = 0;
  }

  FMT_CONSTEXPR20 int num_bigits() const {
    return static_cast<int>(bigits_.size()) + exp_;
  }

  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {
    FMT_ASSERT(shift >= 0, "");
    exp_ += shift / bigit_bits;
    shift %= bigit_bits;
    if (shift == 0) return *this;
    bigit carry = 0;
    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
      bigit c = bigits_[i] >> (bigit_bits - shift);
      bigits_[i] = (bigits_[i] << shift) + carry;
      carry = c;
    }
    if (carry != 0) bigits_.push_back(carry);
    return *this;
  }

  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
    FMT_ASSERT(value > 0, "");
    multiply(uint32_or_64_or_128_t<Int>(value));
    return *this;
  }

  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {
    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
    if (num_lhs_bigits != num_rhs_bigits)
      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
    int i = static_cast<int>(lhs.bigits_.size()) - 1;
    int j = static_cast<int>(rhs.bigits_.size()) - 1;
    int end = i - j;
    if (end < 0) end = 0;
    for (; i >= end; --i, --j) {
      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
    }
    if (i != j) return i > j ? 1 : -1;
    return 0;
  }

  // Returns compare(lhs1 + lhs2, rhs).
  friend FMT_CONSTEXPR20 int add_compare(const bigint& lhs1, const bigint& lhs2,
                                         const bigint& rhs) {
    int max_lhs_bigits = (std::max)(lhs1.num_bigits(), lhs2.num_bigits());
    int num_rhs_bigits = rhs.num_bigits();
    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
    if (max_lhs_bigits > num_rhs_bigits) return 1;
    auto get_bigit = [](const bigint& n, int i) -> bigit {
      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
    };
    double_bigit borrow = 0;
    int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
      double_bigit sum =
          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
      bigit rhs_bigit = get_bigit(rhs, i);
      if (sum > rhs_bigit + borrow) return 1;
      borrow = rhs_bigit + borrow - sum;
      if (borrow > 1) return -1;
      borrow <<= bigit_bits;
    }
    return borrow != 0 ? -1 : 0;
  }

  // Assigns pow(10, exp) to this bigint.
  FMT_CONSTEXPR20 void assign_pow10(int exp) {
    FMT_ASSERT(exp >= 0, "");
    if (exp == 0) return assign(1);
    // Find the top bit.
    int bitmask = 1;
    while (exp >= bitmask) bitmask <<= 1;
    bitmask >>= 1;
    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
    // repeated squaring and multiplication.
    assign(5);
    bitmask >>= 1;
    while (bitmask != 0) {
      square();
      if ((exp & bitmask) != 0) *this *= 5;
      bitmask >>= 1;
    }
    *this <<= exp;  // Multiply by pow(2, exp) by shifting.
  }

  FMT_CONSTEXPR20 void square() {
    int num_bigits = static_cast<int>(bigits_.size());
    int num_result_bigits = 2 * num_bigits;
    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
    bigits_.resize(to_unsigned(num_result_bigits));
    using accumulator_t = conditional_t<FMT_USE_INT128, uint128_t, accumulator>;
    auto sum = accumulator_t();
    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
      // Compute bigit at position bigit_index of the result by adding
      // cross-product terms n[i] * n[j] such that i + j == bigit_index.
      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
        // Most terms are multiplied twice which can be optimized in the future.
        sum += static_cast<double_bigit>(n[i]) * n[j];
      }
      (*this)[bigit_index] = static_cast<bigit>(sum);
      sum >>= bits<bigit>::value;  // Compute the carry.
    }
    // Do the same for the top half.
    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
         ++bigit_index) {
      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
        sum += static_cast<double_bigit>(n[i++]) * n[j--];
      (*this)[bigit_index] = static_cast<bigit>(sum);
      sum >>= bits<bigit>::value;
    }
    remove_leading_zeros();
    exp_ *= 2;
  }

  // If this bigint has a bigger exponent than other, adds trailing zero to make
  // exponents equal. This simplifies some operations such as subtraction.
  FMT_CONSTEXPR20 void align(const bigint& other) {
    int exp_difference = exp_ - other.exp_;
    if (exp_difference <= 0) return;
    int num_bigits = static_cast<int>(bigits_.size());
    bigits_.resize(to_unsigned(num_bigits + exp_difference));
    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
      bigits_[j] = bigits_[i];
    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
    exp_ -= exp_difference;
  }

  // Divides this bignum by divisor, assigning the remainder to this and
  // returning the quotient.
  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {
    FMT_ASSERT(this != &divisor, "");
    if (compare(*this, divisor) < 0) return 0;
    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
    align(divisor);
    int quotient = 0;
    do {
      subtract_aligned(divisor);
      ++quotient;
    } while (compare(*this, divisor) >= 0);
    return quotient;
  }
};

enum class round_direction { unknown, up, down };

// Given the divisor (normally a power of 10), the remainder = v % divisor for
// some number v and the error, returns whether v should be rounded up, down, or
// whether the rounding direction can't be determined due to error.
// error should be less than divisor / 2.
FMT_CONSTEXPR inline round_direction get_round_direction(uint64_t divisor,
                                                         uint64_t remainder,
                                                         uint64_t error) {
  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
  // Round down if (remainder + error) * 2 <= divisor.
  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
    return round_direction::down;
  // Round up if (remainder - error) * 2 >= divisor.
  if (remainder >= error &&
      remainder - error >= divisor - (remainder - error)) {
    return round_direction::up;
  }
  return round_direction::unknown;
}

namespace digits {
enum result {
  more,  // Generate more digits.
  done,  // Done generating digits.
  error  // Digit generation cancelled due to an error.
};
}

struct gen_digits_handler {
  char* buf;
  int size;
  int precision;
  int exp10;
  bool fixed;

  FMT_CONSTEXPR digits::result on_digit(char digit, uint64_t divisor,
                                        uint64_t remainder, uint64_t error,
                                        bool integral) {
    FMT_ASSERT(remainder < divisor, "");
    buf[size++] = digit;
    if (!integral && error >= remainder) return digits::error;
    if (size < precision) return digits::more;
    if (!integral) {
      // Check if error * 2 < divisor with overflow prevention.
      // The check is not needed for the integral part because error = 1
      // and divisor > (1 << 32) there.
      if (error >= divisor || error >= divisor - error) return digits::error;
    } else {
      FMT_ASSERT(error == 1 && divisor > 2, "");
    }
    auto dir = get_round_direction(divisor, remainder, error);
    if (dir != round_direction::up)
      return dir == round_direction::down ? digits::done : digits::error;
    ++buf[size - 1];
    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
      buf[i] = '0';
      ++buf[i - 1];
    }
    if (buf[0] > '9') {
      buf[0] = '1';
      if (fixed)
        buf[size++] = '0';
      else
        ++exp10;
    }
    return digits::done;
  }
};

// Generates output using the Grisu digit-gen algorithm.
// error: the size of the region (lower, upper) outside of which numbers
// definitely do not round to value (Delta in Grisu3).
FMT_INLINE FMT_CONSTEXPR20 digits::result grisu_gen_digits(
    fp value, uint64_t error, int& exp, gen_digits_handler& handler) {
  const fp one(1ULL << -value.e, value.e);
  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
  // zero because it contains a product of two 64-bit numbers with MSB set (due
  // to normalization) - 1, shifted right by at most 60 bits.
  auto integral = static_cast<uint32_t>(value.f >> -one.e);
  FMT_ASSERT(integral != 0, "");
  FMT_ASSERT(integral == value.f >> -one.e, "");
  // The fractional part of scaled value (p2 in Grisu) c = value % one.
  uint64_t fractional = value.f & (one.f - 1);
  exp = count_digits(integral);  // kappa in Grisu.
  // Non-fixed formats require at least one digit and no precision adjustment.
  if (handler.fixed) {
    // Adjust fixed precision by exponent because it is relative to decimal
    // point.
    int precision_offset = exp + handler.exp10;
    if (precision_offset > 0 &&
        handler.precision > max_value<int>() - precision_offset) {
      FMT_THROW(format_error("number is too big"));
    }
    handler.precision += precision_offset;
    // Check if precision is satisfied just by leading zeros, e.g.
    // format("{:.2f}", 0.001) gives "0.00" without generating any digits.
    if (handler.precision <= 0) {
      if (handler.precision < 0) return digits::done;
      // Divide by 10 to prevent overflow.
      uint64_t divisor = impl_data::power_of_10_64[exp - 1] << -one.e;
      auto dir = get_round_direction(divisor, value.f / 10, error * 10);
      if (dir == round_direction::unknown) return digits::error;
      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';
      return digits::done;
    }
  }
  // Generate digits for the integral part. This can produce up to 10 digits.
  do {
    uint32_t digit = 0;
    auto divmod_integral = [&](uint32_t divisor) {
      digit = integral / divisor;
      integral %= divisor;
    };
    // This optimization by Milo Yip reduces the number of integer divisions by
    // one per iteration.
    switch (exp) {
    case 10:
      divmod_integral(1000000000);
      break;
    case 9:
      divmod_integral(100000000);
      break;
    case 8:
      divmod_integral(10000000);
      break;
    case 7:
      divmod_integral(1000000);
      break;
    case 6:
      divmod_integral(100000);
      break;
    case 5:
      divmod_integral(10000);
      break;
    case 4:
      divmod_integral(1000);
      break;
    case 3:
      divmod_integral(100);
      break;
    case 2:
      divmod_integral(10);
      break;
    case 1:
      digit = integral;
      integral = 0;
      break;
    default:
      FMT_ASSERT(false, "invalid number of digits");
    }
    --exp;
    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
    auto result = handler.on_digit(static_cast<char>('0' + digit),
                                   impl_data::power_of_10_64[exp] << -one.e,
                                   remainder, error, true);
    if (result != digits::more) return result;
  } while (exp > 0);
  // Generate digits for the fractional part.
  for (;;) {
    fractional *= 10;
    error *= 10;
    char digit = static_cast<char>('0' + (fractional >> -one.e));
    fractional &= one.f - 1;
    --exp;
    auto result = handler.on_digit(digit, one.f, fractional, error, false);
    if (result != digits::more) return result;
  }
}

// A 128-bit integer type used internally,
struct uint128_wrapper {
  uint128_wrapper() = default;

#if FMT_USE_INT128
  uint128_t internal_;

  constexpr uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
      : internal_{static_cast<uint128_t>(low) |
                  (static_cast<uint128_t>(high) << 64)} {}

  constexpr uint128_wrapper(uint128_t u) : internal_{u} {}

  constexpr uint64_t high() const FMT_NOEXCEPT {
    return uint64_t(internal_ >> 64);
  }
  constexpr uint64_t low() const FMT_NOEXCEPT { return uint64_t(internal_); }

  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {
    internal_ += n;
    return *this;
  }
#else
  uint64_t high_;
  uint64_t low_;

  constexpr uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
      : high_{high},
        low_{low} {}

  constexpr uint64_t high() const FMT_NOEXCEPT { return high_; }
  constexpr uint64_t low() const FMT_NOEXCEPT { return low_; }

  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {
#  if defined(_MSC_VER) && defined(_M_X64)
    unsigned char carry = _addcarry_u64(0, low_, n, &low_);
    _addcarry_u64(carry, high_, 0, &high_);
    return *this;
#  else
    uint64_t sum = low_ + n;
    high_ += (sum < low_ ? 1 : 0);
    low_ = sum;
    return *this;
#  endif
  }
#endif
};

// Implementation of Dragonbox algorithm: https://github.com/jk-jeon/dragonbox.
namespace dragonbox {
// Computes 128-bit result of multiplication of two 64-bit unsigned integers.
inline uint128_wrapper umul128(uint64_t x, uint64_t y) FMT_NOEXCEPT {
#if FMT_USE_INT128
  return static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
#elif defined(_MSC_VER) && defined(_M_X64)
  uint128_wrapper result;
  result.low_ = _umul128(x, y, &result.high_);
  return result;
#else
  const uint64_t mask = (uint64_t(1) << 32) - uint64_t(1);

  uint64_t a = x >> 32;
  uint64_t b = x & mask;
  uint64_t c = y >> 32;
  uint64_t d = y & mask;

  uint64_t ac = a * c;
  uint64_t bc = b * c;
  uint64_t ad = a * d;
  uint64_t bd = b * d;

  uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);

  return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
          (intermediate << 32) + (bd & mask)};
#endif
}

// Computes upper 64 bits of multiplication of two 64-bit unsigned integers.
inline uint64_t umul128_upper64(uint64_t x, uint64_t y) FMT_NOEXCEPT {
#if FMT_USE_INT128
  auto p = static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
  return static_cast<uint64_t>(p >> 64);
#elif defined(_MSC_VER) && defined(_M_X64)
  return __umulh(x, y);
#else
  return umul128(x, y).high();
#endif
}

// Computes upper 64 bits of multiplication of a 64-bit unsigned integer and a
// 128-bit unsigned integer.
inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
  uint128_wrapper g0 = umul128(x, y.high());
  g0 += umul128_upper64(x, y.low());
  return g0.high();
}

// Computes upper 32 bits of multiplication of a 32-bit unsigned integer and a
// 64-bit unsigned integer.
inline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {
  return static_cast<uint32_t>(umul128_upper64(x, y));
}

// Computes middle 64 bits of multiplication of a 64-bit unsigned integer and a
// 128-bit unsigned integer.
inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {
  uint64_t g01 = x * y.high();
  uint64_t g10 = umul128_upper64(x, y.low());
  return g01 + g10;
}

// Computes lower 64 bits of multiplication of a 32-bit unsigned integer and a
// 64-bit unsigned integer.
inline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {
  return x * y;
}

// Computes floor(log10(pow(2, e))) for e in [-1700, 1700] using the method from
// https://fmt.dev/papers/Grisu-Exact.pdf#page=5, section 3.4.
inline int floor_log10_pow2(int e) FMT_NOEXCEPT {
  FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
  const int shift = 22;
  return (e * static_cast<int>(log10_2_significand >> (64 - shift))) >> shift;
}

// Various fast log computations.
inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
  FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
  const uint64_t log2_10_integer_part = 3;
  const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;
  const int shift_amount = 19;
  return (e * static_cast<int>(
                  (log2_10_integer_part << shift_amount) |
                  (log2_10_fractional_digits >> (64 - shift_amount)))) >>
         shift_amount;
}
inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
  FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
  const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;
  const int shift_amount = 22;
  return (e * static_cast<int>(log10_2_significand >> (64 - shift_amount)) -
          static_cast<int>(log10_4_over_3_fractional_digits >>
                           (64 - shift_amount))) >>
         shift_amount;
}

// Returns true iff x is divisible by pow(2, exp).
inline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp >= 1, "");
  FMT_ASSERT(x != 0, "");
#ifdef FMT_BUILTIN_CTZ
  return FMT_BUILTIN_CTZ(x) >= exp;
#else
  return exp < num_bits<uint32_t>() && x == ((x >> exp) << exp);
#endif
}
inline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp >= 1, "");
  FMT_ASSERT(x != 0, "");
#ifdef FMT_BUILTIN_CTZLL
  return FMT_BUILTIN_CTZLL(x) >= exp;
#else
  return exp < num_bits<uint64_t>() && x == ((x >> exp) << exp);
#endif
}

// Table entry type for divisibility test.
template <typename T> struct divtest_table_entry {
  T mod_inv;
  T max_quotient;
};

// Returns true iff x is divisible by pow(5, exp).
inline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp <= 10, "too large exponent");
  static constexpr const divtest_table_entry<uint32_t> divtest_table[] = {
      {0x00000001, 0xffffffff}, {0xcccccccd, 0x33333333},
      {0xc28f5c29, 0x0a3d70a3}, {0x26e978d5, 0x020c49ba},
      {0x3afb7e91, 0x0068db8b}, {0x0bcbe61d, 0x0014f8b5},
      {0x68c26139, 0x000431bd}, {0xae8d46a5, 0x0000d6bf},
      {0x22e90e21, 0x00002af3}, {0x3a2e9c6d, 0x00000897},
      {0x3ed61f49, 0x000001b7}};
  return x * divtest_table[exp].mod_inv <= divtest_table[exp].max_quotient;
}
inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
  FMT_ASSERT(exp <= 23, "too large exponent");
  static constexpr const divtest_table_entry<uint64_t> divtest_table[] = {
      {0x0000000000000001, 0xffffffffffffffff},
      {0xcccccccccccccccd, 0x3333333333333333},
      {0x8f5c28f5c28f5c29, 0x0a3d70a3d70a3d70},
      {0x1cac083126e978d5, 0x020c49ba5e353f7c},
      {0xd288ce703afb7e91, 0x0068db8bac710cb2},
      {0x5d4e8fb00bcbe61d, 0x0014f8b588e368f0},
      {0x790fb65668c26139, 0x000431bde82d7b63},
      {0xe5032477ae8d46a5, 0x0000d6bf94d5e57a},
      {0xc767074b22e90e21, 0x00002af31dc46118},
      {0x8e47ce423a2e9c6d, 0x0000089705f4136b},
      {0x4fa7f60d3ed61f49, 0x000001b7cdfd9d7b},
      {0x0fee64690c913975, 0x00000057f5ff85e5},
      {0x3662e0e1cf503eb1, 0x000000119799812d},
      {0xa47a2cf9f6433fbd, 0x0000000384b84d09},
      {0x54186f653140a659, 0x00000000b424dc35},
      {0x7738164770402145, 0x0000000024075f3d},
      {0xe4a4d1417cd9a041, 0x000000000734aca5},
      {0xc75429d9e5c5200d, 0x000000000170ef54},
      {0xc1773b91fac10669, 0x000000000049c977},
      {0x26b172506559ce15, 0x00000000000ec1e4},
      {0xd489e3a9addec2d1, 0x000000000002f394},
      {0x90e860bb892c8d5d, 0x000000000000971d},
      {0x502e79bf1b6f4f79, 0x0000000000001e39},
      {0xdcd618596be30fe5, 0x000000000000060b}};
  return x * divtest_table[exp].mod_inv <= divtest_table[exp].max_quotient;
}

// Replaces n by floor(n / pow(5, N)) returning true if and only if n is
// divisible by pow(5, N).
// Precondition: n <= 2 * pow(5, N + 1).
template <int N>
bool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {
  static constexpr struct {
    uint32_t magic_number;
    int bits_for_comparison;
    uint32_t threshold;
    int shift_amount;
  } infos[] = {{0xcccd, 16, 0x3333, 18}, {0xa429, 8, 0x0a, 20}};
  constexpr auto info = infos[N - 1];
  n *= info.magic_number;
  const uint32_t comparison_mask = (1u << info.bits_for_comparison) - 1;
  bool result = (n & comparison_mask) <= info.threshold;
  n >>= info.shift_amount;
  return result;
}

// Computes floor(n / pow(10, N)) for small n and N.
// Precondition: n <= pow(10, N + 1).
template <int N> uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {
  static constexpr struct {
    uint32_t magic_number;
    int shift_amount;
    uint32_t divisor_times_10;
  } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};
  constexpr auto info = infos[N - 1];
  FMT_ASSERT(n <= info.divisor_times_10, "n is too large");
  return n * info.magic_number >> info.shift_amount;
}

// Computes floor(n / 10^(kappa + 1)) (float)
inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {
  return n / float_info<float>::big_divisor;
}
// Computes floor(n / 10^(kappa + 1)) (double)
inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {
  return umul128_upper64(n, 0x83126e978d4fdf3c) >> 9;
}

// Various subroutines using pow10 cache
template <class T> struct cache_accessor;

template <> struct cache_accessor<float> {
  using carrier_uint = float_info<float>::carrier_uint;
  using cache_entry_type = uint64_t;

  static uint64_t get_cached_power(int k) FMT_NOEXCEPT {
    FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
               "k is out of range");
    static constexpr const uint64_t pow10_significands[] = {
        0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
        0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
        0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
        0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
        0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
        0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
        0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
        0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
        0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
        0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
        0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
        0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
        0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
        0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
        0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
        0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
        0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
        0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
        0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
        0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940984,
        0xa18f07d736b90be5, 0xc9f2c9cd04674ede, 0xfc6f7c4045812296,
        0x9dc5ada82b70b59d, 0xc5371912364ce305, 0xf684df56c3e01bc6,
        0x9a130b963a6c115c, 0xc097ce7bc90715b3, 0xf0bdc21abb48db20,
        0x96769950b50d88f4, 0xbc143fa4e250eb31, 0xeb194f8e1ae525fd,
        0x92efd1b8d0cf37be, 0xb7abc627050305ad, 0xe596b7b0c643c719,
        0x8f7e32ce7bea5c6f, 0xb35dbf821ae4f38b, 0xe0352f62a19e306e};
    return pow10_significands[k - float_info<float>::min_k];
  }

  static carrier_uint compute_mul(carrier_uint u,
                                  const cache_entry_type& cache) FMT_NOEXCEPT {
    return umul96_upper32(u, cache);
  }

  static uint32_t compute_delta(const cache_entry_type& cache,
                                int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<uint32_t>(cache >> (64 - 1 - beta_minus_1));
  }

  static bool compute_mul_parity(carrier_uint two_f,
                                 const cache_entry_type& cache,
                                 int beta_minus_1) FMT_NOEXCEPT {
    FMT_ASSERT(beta_minus_1 >= 1, "");
    FMT_ASSERT(beta_minus_1 < 64, "");

    return ((umul96_lower64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
  }

  static carrier_uint compute_left_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<carrier_uint>(
        (cache - (cache >> (float_info<float>::significand_bits + 2))) >>
        (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
  }

  static carrier_uint compute_right_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<carrier_uint>(
        (cache + (cache >> (float_info<float>::significand_bits + 1))) >>
        (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
  }

  static carrier_uint compute_round_up_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return (static_cast<carrier_uint>(
                cache >>
                (64 - float_info<float>::significand_bits - 2 - beta_minus_1)) +
            1) /
           2;
  }
};

template <> struct cache_accessor<double> {
  using carrier_uint = float_info<double>::carrier_uint;
  using cache_entry_type = uint128_wrapper;

  static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {
    FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
               "k is out of range");

    static constexpr const uint128_wrapper pow10_significands[] = {
#if FMT_USE_FULL_CACHE_DRAGONBOX
      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
      {0x9becce62836ac577, 0x4ee367f9430aec33},
      {0xc2e801fb244576d5, 0x229c41f793cda740},
      {0xf3a20279ed56d48a, 0x6b43527578c11110},
      {0x9845418c345644d6, 0x830a13896b78aaaa},
      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
      {0x91376c36d99995be, 0x23100809b9c21fa2},
      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
      {0xdd95317f31c7fa1d, 0x40405643d711d584},
      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
      {0xd863b256369d4a40, 0x90bed43e40076a83},
      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
      {0xa90de3535aaae202, 0x711515d0a205cb37},
      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
      {0x8412d9991ed58091, 0xe858790afe9486c3},
      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
      {0xc987434744ac874e, 0xa327ffb266b56221},
      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
      {0xc0314325637a1939, 0xfa911155fefb5309},
      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
      {0xb749faed14125d36, 0xcef980ec671f667c},
      {0xe51c79a85916f484, 0x82b7e12780e7401b},
      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
      {0xaecc49914078536d, 0x58fae9f773886e19},
      {0xda7f5bf590966848, 0xaf39a475506a899f},
      {0x888f99797a5e012d, 0x6d8406c952429604},
      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
      {0x823c12795db6ce57, 0x76c53d08d6b70859},
      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
      {0xc21094364dfb5636, 0x985915fc12f542e5},
      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
      {0xbd8430bd08277231, 0x50c6ff782a838354},
      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
      {0x940f4613ae5ed136, 0x871b7795e136be9a},
      {0xb913179899f68584, 0x28e2557b59846e40},
      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
      {0x89e42caaf9491b60, 0xf41686c49db57245},
      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
      {0xd77485cb25823ac7, 0x7d633293366b828c},
      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
      {0xd267caa862a12d66, 0xd072df63c324fd7c},
      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
      {0xa46116538d0deb78, 0x52d9be85f074e609},
      {0xcd795be870516656, 0x67902e276c921f8c},
      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
      {0xef340a98172aace4, 0x86fb897116c87c35},
      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
      {0xbae0a846d2195712, 0x8974836059cca10a},
      {0xe998d258869facd7, 0x2bd1a438703fc94c},
      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
      {0x8e938662882af53e, 0x547eb47b7282ee9d},
      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
      {0xae0b158b4738705e, 0x9624ab50b148d446},
      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
      {0xd47487cc8470652b, 0x7647c32000696720},
      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
      {0xa5fb0a17c777cf09, 0xf468107100525891},
      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
      {0xfd442e4688bd304a, 0x908f4a166d1da664},
      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
      {0xf7549530e188c128, 0xd12bee59e68ef47d},
      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
      {0xebdf661791d60f56, 0x111b495b3464ad22},
      {0x936b9fcebb25c995, 0xcab10dd900beec35},
      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
      {0xb3f4e093db73a093, 0x59ed216765690f57},
      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
      {0x8c974f7383725573, 0x1e414218c73a13fc},
      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
      {0xd686619ba27255a2, 0xc80a537b0efefebe},
      {0x8613fd0145877585, 0xbd06742ce95f5f37},
      {0xa798fc4196e952e7, 0x2c48113823b73705},
      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
      {0xcc963fee10b7d1b3, 0x318df905079926a9},
      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
      {0xbe89523386091465, 0xf6bbb397f1135824},
      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
      {0x843610cb4bf160cb, 0xcedf722a585139bb},
      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
      {0xce947a3da6a9273e, 0x733d226229feea33},
      {0x811ccc668829b887, 0x0806357d5a3f5260},
      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
      {0xc5029163f384a931, 0x0a9e795e65d4df12},
      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
      {0xbbe226efb628afea, 0x890489f70a55368c},
      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
      {0xb32df8e9f3546564, 0x47939822dc96abfa},
      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
      {0xaefae51477a06b03, 0xede622920b6b23f2},
      {0xdab99e59958885c4, 0xe95fab368e45ecee},
      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
      {0xd59944a37c0752a2, 0x4be76d3346f04960},
      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
      {0xc24452da229b021b, 0xfbe85badce996169},
      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
      {0xed246723473e3813, 0x290123e9aab23b69},
      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
      {0x8d590723948a535f, 0x579c487e5a38ad0f},
      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
      {0xcdb02555653131b6, 0x3792f412cb06794e},
      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
      {0xc8de047564d20a8b, 0xf245825a5a445276},
      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
      {0x9ced737bb6c4183d, 0x55464dd69685606c},
      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
      {0x95a8637627989aad, 0xdde7001379a44aa9},
      {0xbb127c53b17ec159, 0x5560c018580d5d53},
      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
      {0x9226712162ab070d, 0xcab3961304ca70e9},
      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
      {0x881cea14545c7575, 0x7e50d64177da2e55},
      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
      {0xcfb11ead453994ba, 0x67de18eda5814af3},
      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
      {0xc612062576589dda, 0x95364afe032a819e},
      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
      {0x9abe14cd44753b52, 0xc4926a9672793543},
      {0xc16d9a0095928a27, 0x75b7053c0f178294},
      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
      {0xb424dc35095cd80f, 0x538484c19ef38c95},
      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
      {0x89705f4136b4a597, 0x31680a88f8953031},
      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
      {0xcccccccccccccccc, 0xcccccccccccccccd},
      {0x8000000000000000, 0x0000000000000000},
      {0xa000000000000000, 0x0000000000000000},
      {0xc800000000000000, 0x0000000000000000},
      {0xfa00000000000000, 0x0000000000000000},
      {0x9c40000000000000, 0x0000000000000000},
      {0xc350000000000000, 0x0000000000000000},
      {0xf424000000000000, 0x0000000000000000},
      {0x9896800000000000, 0x0000000000000000},
      {0xbebc200000000000, 0x0000000000000000},
      {0xee6b280000000000, 0x0000000000000000},
      {0x9502f90000000000, 0x0000000000000000},
      {0xba43b74000000000, 0x0000000000000000},
      {0xe8d4a51000000000, 0x0000000000000000},
      {0x9184e72a00000000, 0x0000000000000000},
      {0xb5e620f480000000, 0x0000000000000000},
      {0xe35fa931a0000000, 0x0000000000000000},
      {0x8e1bc9bf04000000, 0x0000000000000000},
      {0xb1a2bc2ec5000000, 0x0000000000000000},
      {0xde0b6b3a76400000, 0x0000000000000000},
      {0x8ac7230489e80000, 0x0000000000000000},
      {0xad78ebc5ac620000, 0x0000000000000000},
      {0xd8d726b7177a8000, 0x0000000000000000},
      {0x878678326eac9000, 0x0000000000000000},
      {0xa968163f0a57b400, 0x0000000000000000},
      {0xd3c21bcecceda100, 0x0000000000000000},
      {0x84595161401484a0, 0x0000000000000000},
      {0xa56fa5b99019a5c8, 0x0000000000000000},
      {0xcecb8f27f4200f3a, 0x0000000000000000},
      {0x813f3978f8940984, 0x4000000000000000},
      {0xa18f07d736b90be5, 0x5000000000000000},
      {0xc9f2c9cd04674ede, 0xa400000000000000},
      {0xfc6f7c4045812296, 0x4d00000000000000},
      {0x9dc5ada82b70b59d, 0xf020000000000000},
      {0xc5371912364ce305, 0x6c28000000000000},
      {0xf684df56c3e01bc6, 0xc732000000000000},
      {0x9a130b963a6c115c, 0x3c7f400000000000},
      {0xc097ce7bc90715b3, 0x4b9f100000000000},
      {0xf0bdc21abb48db20, 0x1e86d40000000000},
      {0x96769950b50d88f4, 0x1314448000000000},
      {0xbc143fa4e250eb31, 0x17d955a000000000},
      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
      {0xb7abc627050305ad, 0xf14a3d9e40000000},
      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
      {0xe0352f62a19e306e, 0xd50b2037ad200000},
      {0x8c213d9da502de45, 0x4526f422cc340000},
      {0xaf298d050e4395d6, 0x9670b12b7f410000},
      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
      {0xd5d238a4abe98068, 0x72a4904598d6d880},
      {0x85a36366eb71f041, 0x47a6da2b7f864750},
      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
      {0x82818f1281ed449f, 0xbff8f10e7a8921a4},
      {0xa321f2d7226895c7, 0xaff72d52192b6a0d},
      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490},
      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
      {0x9f4f2726179a2245, 0x01d762422c946590},
      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5},
      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2},
      {0x9b934c3b330c8577, 0x63cc55f49f88eb2f},
      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb},
      {0xf316271c7fc3908a, 0x8bef464e3945ef7a},
      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ac},
      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317},
      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd},
      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a},
      {0xb975d6b6ee39e436, 0xb3e2fd538e122b44},
      {0xe7d34c64a9c85d44, 0x60dbbca87196b616},
      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd},
      {0xb51d13aea4a488dd, 0x6babab6398bdbe41},
      {0xe264589a4dcdab14, 0xc696963c7eed2dd1},
      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2},
      {0xb0de65388cc8ada8, 0x3b25a55f43294bcb},
      {0xdd15fe86affad912, 0x49ef0eb713f39ebe},
      {0x8a2dbf142dfcc7ab, 0x6e3569326c784337},
      {0xacb92ed9397bf996, 0x49c2c37f07965404},
      {0xd7e77a8f87daf7fb, 0xdc33745ec97be906},
      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3},
      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0c},
      {0xd2d80db02aabd62b, 0xf50a3fa490c30190},
      {0x83c7088e1aab65db, 0x792667c6da79e0fa},
      {0xa4b8cab1a1563f52, 0x577001b891185938},
      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
      {0x80b05e5ac60b6178, 0x544f8158315b05b4},
      {0xa0dc75f1778e39d6, 0x696361ae3db1c721},
      {0xc913936dd571c84c, 0x03bc3a19cd1e38e9},
      {0xfb5878494ace3a5f, 0x04ab48a04065c723},
      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c76},
      {0xc45d1df942711d9a, 0x3ba5d0bd324f8394},
      {0xf5746577930d6500, 0xca8f44ec7ee36479},
      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb},
      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e},
      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e},
      {0x95d04aee3b80ece5, 0xbba1f1d158724a12},
      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc97},
      {0xea1575143cf97226, 0xf52d09d71a3293bd},
      {0x924d692ca61be758, 0x593c2626705f9c56},
      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c},
      {0xe498f455c38b997a, 0x0b6dfb9c0f956447},
      {0x8edf98b59a373fec, 0x4724bd4189bd5eac},
      {0xb2977ee300c50fe7, 0x58edec91ec2cb657},
      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed},
      {0x8b865b215899f46c, 0xbd79e0d20082ee74},
      {0xae67f1e9aec07187, 0xecd8590680a3aa11},
      {0xda01ee641a708de9, 0xe80e6f4820cc9495},
      {0x884134fe908658b2, 0x3109058d147fdcdd},
      {0xaa51823e34a7eede, 0xbd4b46f0599fd415},
      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a},
      {0x850fadc09923329e, 0x03e2cf6bc604ddb0},
      {0xa6539930bf6bff45, 0x84db8346b786151c},
      {0xcfe87f7cef46ff16, 0xe612641865679a63},
      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e},
      {0xa26da3999aef7749, 0xe3be5e330f38f09d},
      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc5},
      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6},
      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa},
      {0xc646d63501a1511d, 0xb281e1fd541501b8},
      {0xf7d88bc24209a565, 0x1f225a7ca91a4226},
      {0x9ae757596946075f, 0x3375788de9b06958},
      {0xc1a12d2fc3978937, 0x0052d6b1641c83ae},
      {0xf209787bb47d6b84, 0xc0678c5dbd23a49a},
      {0x9745eb4d50ce6332, 0xf840b7ba963646e0},
      {0xbd176620a501fbff, 0xb650e5a93bc3d898},
      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe},
      {0x93ba47c980e98cdf, 0xc66f336c36b10137},
      {0xb8a8d9bbe123f017, 0xb80b0047445d4184},
      {0xe6d3102ad96cec1d, 0xa60dc059157491e5},
      {0x9043ea1ac7e41392, 0x87c89837ad68db2f},
      {0xb454e4a179dd1877, 0x29babe4598c311fb},
      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a},
      {0x8ce2529e2734bb1d, 0x1899e4a65f58660c},
      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f},
      {0xdc21a1171d42645d, 0x76707543f4fa1f73},
      {0x899504ae72497eba, 0x6a06494a791c53a8},
      {0xabfa45da0edbde69, 0x0487db9d17636892},
      {0xd6f8d7509292d603, 0x45a9d2845d3c42b6},
      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
      {0xa7f26836f282b732, 0x8e6cac7768d7141e},
      {0xd1ef0244af2364ff, 0x3207d795430cd926},
      {0x8335616aed761f1f, 0x7f44e6bd49e807b8},
      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6},
      {0xcd036837130890a1, 0x36dba887c37a8c0f},
      {0x802221226be55a64, 0xc2494954da2c9789},
      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c},
      {0xc83553c5c8965d3d, 0x6f92829494e5acc7},
      {0xfa42a8b73abbf48c, 0xcb772339ba1f17f9},
      {0x9c69a97284b578d7, 0xff2a760414536efb},
      {0xc38413cf25e2d70d, 0xfef5138519684aba},
      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d69},
      {0x98bf2f79d5993802, 0xef2f773ffbd97a61},
      {0xbeeefb584aff8603, 0xaafb550ffacfd8fa},
      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38},
      {0x952ab45cfa97a0b2, 0xdd945a747bf26183},
      {0xba756174393d88df, 0x94f971119aeef9e4},
      {0xe912b9d1478ceb17, 0x7a37cd5601aab85d},
      {0x91abb422ccb812ee, 0xac62e055c10ab33a},
      {0xb616a12b7fe617aa, 0x577b986b314d6009},
      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80b},
      {0x8e41ade9fbebc27d, 0x14588f13be847307},
      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc8},
      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb},
      {0x8aec23d680043bee, 0x25de7bb9480d5854},
      {0xada72ccc20054ae9, 0xaf561aa79a10ae6a},
      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
      {0x87aa9aff79042286, 0x90fb44d2f05d0842},
      {0xa99541bf57452b28, 0x353a1607ac744a53},
      {0xd3fa922f2d1675f2, 0x42889b8997915ce8},
      {0x847c9b5d7c2e09b7, 0x69956135febada11},
      {0xa59bc234db398c25, 0x43fab9837e699095},
      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bb},
      {0x8161afb94b44f57d, 0x1d1be0eebac278f5},
      {0xa1ba1ba79e1632dc, 0x6462d92a69731732},
      {0xca28a291859bbf93, 0x7d7b8f7503cfdcfe},
      {0xfcb2cb35e702af78, 0x5cda735244c3d43e},
      {0x9defbf01b061adab, 0x3a0888136afa64a7},
      {0xc56baec21c7a1916, 0x088aaa1845b8fdd0},
      {0xf6c69a72a3989f5b, 0x8aad549e57273d45},
      {0x9a3c2087a63f6399, 0x36ac54e2f678864b},
      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd},
      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5},
      {0x969eb7c47859e743, 0x9f644ae5a4b1b325},
      {0xbc4665b596706114, 0x873d5d9f0dde1fee},
      {0xeb57ff22fc0c7959, 0xa90cb506d155a7ea},
      {0x9316ff75dd87cbd8, 0x09a7f12442d588f2},
      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb2f},
      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fa},
      {0x8fa475791a569d10, 0xf96e017d694487bc},
      {0xb38d92d760ec4455, 0x37c981dcc395a9ac},
      {0xe070f78d3927556a, 0x85bbe253f47b1417},
      {0x8c469ab843b89562, 0x93956d7478ccec8e},
      {0xaf58416654a6babb, 0x387ac8d1970027b2},
      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319e},
      {0x88fcf317f22241e2, 0x441fece3bdf81f03},
      {0xab3c2fddeeaad25a, 0xd527e81cad7626c3},
      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b074},
      {0x85c7056562757456, 0xf6872d5667844e49},
      {0xa738c6bebb12d16c, 0xb428f8ac016561db},
      {0xd106f86e69d785c7, 0xe13336d701beba52},
      {0x82a45b450226b39c, 0xecc0024661173473},
      {0xa34d721642b06084, 0x27f002d7f95d0190},
      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f4},
      {0xff290242c83396ce, 0x7e67047175a15271},
      {0x9f79a169bd203e41, 0x0f0062c6e984d386},
      {0xc75809c42c684dd1, 0x52c07b78a3e60868},
      {0xf92e0c3537826145, 0xa7709a56ccdf8a82},
      {0x9bbcc7a142b17ccb, 0x88a66076400bb691},
      {0xc2abf989935ddbfe, 0x6acff893d00ea435},
      {0xf356f7ebf83552fe, 0x0583f6b8c4124d43},
      {0x98165af37b2153de, 0xc3727a337a8b704a},
      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c},
      {0xeda2ee1c7064130c, 0x1162def06f79df73},
      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8},
      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173692},
      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437},
      {0x910ab1d4db9914a0, 0x1d9c9892400a22a2},
      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4b},
      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61d},
      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
      {0xb10d8e1456105dad, 0x7425a83e872c5f47},
      {0xdd50f1996b947518, 0xd12f124e28f77719},
      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f},
      {0xace73cbfdc0bfb7b, 0x636cc64d1001550b},
      {0xd8210befd30efa5a, 0x3c47f7e05401aa4e},
      {0x8714a775e3e95c78, 0x65acfaec34810a71},
      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0d},
      {0xd31045a8341ca07c, 0x1ede48111209a050},
      {0x83ea2b892091e44d, 0x934aed0aab460432},
      {0xa4e4b66b68b65d60, 0xf81da84d5617853f},
      {0xce1de40642e3f4b9, 0x36251260ab9d668e},
      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019},
      {0xa1075a24e4421730, 0xb24cf65b8612f81f},
      {0xc94930ae1d529cfc, 0xdee033f26797b627},
      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b1},
      {0x9d412e0806e88aa5, 0x8e1f289560ee864e},
      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2},
      {0xf5b5d7ec8acb58a2, 0xae10af696774b1db},
      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29},
      {0xbff610b0cc6edd3f, 0x17fd090a58d32af3},
      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b0},
      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98e},
      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1},
      {0xea53df5fd18d5513, 0x84c86189216dc5ed},
      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4},
      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a1},
      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400e},
      {0xb2c71d5bca9023f8, 0x743e20e9ef511012},
      {0xdf78e4b2bd342cf6, 0x914da9246b255416},
      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e},
      {0xae9672aba3d0c320, 0xa184ac2473b529b1},
      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e},
      {0x8865899617fb1871, 0x7e2fa67c7a658892},
      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab7},
      {0xd51ea6fa85785631, 0x552a74227f3ea565},
      {0x8533285c936b35de, 0xd53a88958f87275f},
      {0xa67ff273b8460356, 0x8a892abaf368f137},
      {0xd01fef10a657842c, 0x2d2b7569b0432d85},
      {0x8213f56a67f6b29b, 0x9c3b29620e29fc73},
      {0xa298f2c501f45f42, 0x8349f3ba91b47b8f},
      {0xcb3f2f7642717713, 0x241c70a936219a73},
      {0xfe0efb53d30dd4d7, 0xed238cd383aa0110},
      {0x9ec95d1463e8a506, 0xf4363804324a40aa},
      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d5},
      {0xf81aa16fdc1b81da, 0xdd94b7868e94050a},
      {0x9b10a4e5e9913128, 0xca7cf2b4191c8326},
      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0},
      {0xf24a01a73cf2dccf, 0xbc633b39673c8cec},
      {0x976e41088617ca01, 0xd5be0503e085d813},
      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18},
      {0xec9c459d51852ba2, 0xddf8e7d60ed1219e},
      {0x93e1ab8252f33b45, 0xcabb90e5c942b503},
      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
      {0xe7109bfba19c0c9d, 0x0cc512670a783ad4},
      {0x906a617d450187e2, 0x27fb2b80668b24c5},
      {0xb484f9dc9641e9da, 0xb1f9f660802dedf6},
      {0xe1a63853bbd26451, 0x5e7873f8a0396973},
      {0x8d07e33455637eb2, 0xdb0b487b6423e1e8},
      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62},
      {0xdc5c5301c56b75f7, 0x7641a140cc7810fb},
      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d},
      {0xac2820d9623bf429, 0x546345fa9fbdcd44},
      {0xd732290fbacaf133, 0xa97c177947ad4095},
      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485d},
      {0xa81f301449ee8c70, 0x5c68f256bfff5a74},
      {0xd226fc195c6a2f8c, 0x73832eec6fff3111},
      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eab},
      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e55},
      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb},
      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b3},
      {0xa0555e361951c366, 0xd7e105bcc332621f},
      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7},
      {0xfa856334878fc150, 0xb14f98f6f0feb951},
      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3},
      {0xc3b8358109e84f07, 0x0a862f80ec4700c8},
      {0xf4a642e14c6262c8, 0xcd27bb612758c0fa},
      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789c},
      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c3},
      {0xeeea5d5004981478, 0x1858ccfce06cac74},
      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8},
      {0xbaa718e68396cffd, 0xd30560258f54e6ba},
      {0xe950df20247c83fd, 0x47c6b82ef32a2069},
      {0x91d28b7416cdd27e, 0x4cdc331d57fa5441},
      {0xb6472e511c81471d, 0xe0133fe4adf8e952},
      {0xe3d8f9e563a198e5, 0x58180fddd97723a6},
      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648},
      {0xb201833b35d63f73, 0x2cd2cc6551e513da},
      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d1},
      {0x8b112e86420f6191, 0xfb04afaf27faf782},
      {0xadd57a27d29339f6, 0x79c5db9af1f9b563},
      {0xd94ad8b1c7380874, 0x18375281ae7822bc},
      {0x87cec76f1c830548, 0x8f2293910d0b15b5},
      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb22},
      {0xd433179d9c8cb841, 0x5fa60692a46151eb},
      {0x849feec281d7f328, 0xdbc7c41ba6bcd333},
      {0xa5c7ea73224deff3, 0x12b9b522906c0800},
      {0xcf39e50feae16bef, 0xd768226b34870a00},
      {0x81842f29f2cce375, 0xe6a1158300d46640},
      {0xa1e53af46f801c53, 0x60495ae3c1097fd0},
      {0xca5e89b18b602368, 0x385bb19cb14bdfc4},
      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b5},
      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d1},
      {0xc5a05277621be293, 0xc7098b7305241885},
      { 0xf70867153aa2db38,
        0xb8cbee4fc66d1ea7 }
#else
      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
      {0x95a8637627989aad, 0xdde7001379a44aa9},
      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
      {0xc350000000000000, 0x0000000000000000},
      {0x9dc5ada82b70b59d, 0xf020000000000000},
      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
      {0xa6539930bf6bff45, 0x84db8346b786151c},
      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
      {0xaf58416654a6babb, 0x387ac8d1970027b2},
      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
      { 0x95527a5202df0ccb,
        0x0f37801e0c43ebc8 }
#endif
    };

#if FMT_USE_FULL_CACHE_DRAGONBOX
    return pow10_significands[k - float_info<double>::min_k];
#else
    static constexpr const uint64_t powers_of_5_64[] = {
        0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
        0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
        0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
        0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
        0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
        0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
        0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
        0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
        0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};

    static constexpr const uint32_t pow10_recovery_errors[] = {
        0x50001400, 0x54044100, 0x54014555, 0x55954415, 0x54115555, 0x00000001,
        0x50000000, 0x00104000, 0x54010004, 0x05004001, 0x55555544, 0x41545555,
        0x54040551, 0x15445545, 0x51555514, 0x10000015, 0x00101100, 0x01100015,
        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04450514, 0x45414110,
        0x55555145, 0x50544050, 0x15040155, 0x11054140, 0x50111514, 0x11451454,
        0x00400541, 0x00000000, 0x55555450, 0x10056551, 0x10054011, 0x55551014,
        0x69514555, 0x05151109, 0x00155555};

    static const int compression_ratio = 27;

    // Compute base index.
    int cache_index = (k - float_info<double>::min_k) / compression_ratio;
    int kb = cache_index * compression_ratio + float_info<double>::min_k;
    int offset = k - kb;

    // Get base cache.
    uint128_wrapper base_cache = pow10_significands[cache_index];
    if (offset == 0) return base_cache;

    // Compute the required amount of bit-shift.
    int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
    FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");

    // Try to recover the real cache.
    uint64_t pow5 = powers_of_5_64[offset];
    uint128_wrapper recovered_cache = umul128(base_cache.high(), pow5);
    uint128_wrapper middle_low =
        umul128(base_cache.low() - (kb < 0 ? 1u : 0u), pow5);

    recovered_cache += middle_low.high();

    uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);
    uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);

    recovered_cache =
        uint128_wrapper{(recovered_cache.low() >> alpha) | high_to_middle,
                        ((middle_low.low() >> alpha) | middle_to_low)};

    if (kb < 0) recovered_cache += 1;

    // Get error.
    int error_idx = (k - float_info<double>::min_k) / 16;
    uint32_t error = (pow10_recovery_errors[error_idx] >>
                      ((k - float_info<double>::min_k) % 16) * 2) &
                     0x3;

    // Add the error back.
    FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), "");
    return {recovered_cache.high(), recovered_cache.low() + error};
#endif
  }

  static carrier_uint compute_mul(carrier_uint u,
                                  const cache_entry_type& cache) FMT_NOEXCEPT {
    return umul192_upper64(u, cache);
  }

  static uint32_t compute_delta(cache_entry_type const& cache,
                                int beta_minus_1) FMT_NOEXCEPT {
    return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta_minus_1));
  }

  static bool compute_mul_parity(carrier_uint two_f,
                                 const cache_entry_type& cache,
                                 int beta_minus_1) FMT_NOEXCEPT {
    FMT_ASSERT(beta_minus_1 >= 1, "");
    FMT_ASSERT(beta_minus_1 < 64, "");

    return ((umul192_middle64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
  }

  static carrier_uint compute_left_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return (cache.high() -
            (cache.high() >> (float_info<double>::significand_bits + 2))) >>
           (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
  }

  static carrier_uint compute_right_endpoint_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return (cache.high() +
            (cache.high() >> (float_info<double>::significand_bits + 1))) >>
           (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
  }

  static carrier_uint compute_round_up_for_shorter_interval_case(
      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
    return ((cache.high() >>
             (64 - float_info<double>::significand_bits - 2 - beta_minus_1)) +
            1) /
           2;
  }
};

// Various integer checks
template <class T>
bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
  return exponent >=
             float_info<
                 T>::case_shorter_interval_left_endpoint_lower_threshold &&
         exponent <=
             float_info<T>::case_shorter_interval_left_endpoint_upper_threshold;
}
template <class T>
bool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,
                         int exponent, int minus_k) FMT_NOEXCEPT {
  if (exponent < float_info<T>::case_fc_pm_half_lower_threshold) return false;
  // For k >= 0.
  if (exponent <= float_info<T>::case_fc_pm_half_upper_threshold) return true;
  // For k < 0.
  if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
  return divisible_by_power_of_5(two_f, minus_k);
}

template <class T>
bool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,
                       int minus_k) FMT_NOEXCEPT {
  // Exponent for 5 is negative.
  if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
  if (exponent > float_info<T>::case_fc_upper_threshold)
    return divisible_by_power_of_5(two_f, minus_k);
  // Both exponents are nonnegative.
  if (exponent >= float_info<T>::case_fc_lower_threshold) return true;
  // Exponent for 2 is negative.
  return divisible_by_power_of_2(two_f, minus_k - exponent + 1);
}

// Remove trailing zeros from n and return the number of zeros removed (float)
FMT_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
#ifdef FMT_BUILTIN_CTZ
  int t = FMT_BUILTIN_CTZ(n);
#else
  int t = ctz(n);
#endif
  if (t > float_info<float>::max_trailing_zeros)
    t = float_info<float>::max_trailing_zeros;

  const uint32_t mod_inv1 = 0xcccccccd;
  const uint32_t max_quotient1 = 0x33333333;
  const uint32_t mod_inv2 = 0xc28f5c29;
  const uint32_t max_quotient2 = 0x0a3d70a3;

  int s = 0;
  for (; s < t - 1; s += 2) {
    if (n * mod_inv2 > max_quotient2) break;
    n *= mod_inv2;
  }
  if (s < t && n * mod_inv1 <= max_quotient1) {
    n *= mod_inv1;
    ++s;
  }
  n >>= s;
  return s;
}

// Removes trailing zeros and returns the number of zeros removed (double)
FMT_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
#ifdef FMT_BUILTIN_CTZLL
  int t = FMT_BUILTIN_CTZLL(n);
#else
  int t = ctzll(n);
#endif
  if (t > float_info<double>::max_trailing_zeros)
    t = float_info<double>::max_trailing_zeros;
  // Divide by 10^8 and reduce to 32-bits
  // Since ret_value.significand <= (2^64 - 1) / 1000 < 10^17,
  // both of the quotient and the r should fit in 32-bits

  const uint32_t mod_inv1 = 0xcccccccd;
  const uint32_t max_quotient1 = 0x33333333;
  const uint64_t mod_inv8 = 0xc767074b22e90e21;
  const uint64_t max_quotient8 = 0x00002af31dc46118;

  // If the number is divisible by 1'0000'0000, work with the quotient
  if (t >= 8) {
    auto quotient_candidate = n * mod_inv8;

    if (quotient_candidate <= max_quotient8) {
      auto quotient = static_cast<uint32_t>(quotient_candidate >> 8);

      int s = 8;
      for (; s < t; ++s) {
        if (quotient * mod_inv1 > max_quotient1) break;
        quotient *= mod_inv1;
      }
      quotient >>= (s - 8);
      n = quotient;
      return s;
    }
  }

  // Otherwise, work with the remainder
  auto quotient = static_cast<uint32_t>(n / 100000000);
  auto remainder = static_cast<uint32_t>(n - 100000000 * quotient);

  if (t == 0 || remainder * mod_inv1 > max_quotient1) {
    return 0;
  }
  remainder *= mod_inv1;

  if (t == 1 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 1) + quotient * 10000000ull;
    return 1;
  }
  remainder *= mod_inv1;

  if (t == 2 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 2) + quotient * 1000000ull;
    return 2;
  }
  remainder *= mod_inv1;

  if (t == 3 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 3) + quotient * 100000ull;
    return 3;
  }
  remainder *= mod_inv1;

  if (t == 4 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 4) + quotient * 10000ull;
    return 4;
  }
  remainder *= mod_inv1;

  if (t == 5 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 5) + quotient * 1000ull;
    return 5;
  }
  remainder *= mod_inv1;

  if (t == 6 || remainder * mod_inv1 > max_quotient1) {
    n = (remainder >> 6) + quotient * 100ull;
    return 6;
  }
  remainder *= mod_inv1;

  n = (remainder >> 7) + quotient * 10ull;
  return 7;
}

// The main algorithm for shorter interval case
template <class T>
FMT_INLINE decimal_fp<T> shorter_interval_case(int exponent) FMT_NOEXCEPT {
  decimal_fp<T> ret_value;
  // Compute k and beta
  const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
  const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);

  // Compute xi and zi
  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);

  auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(
      cache, beta_minus_1);
  auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(
      cache, beta_minus_1);

  // If the left endpoint is not an integer, increase it
  if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;

  // Try bigger divisor
  ret_value.significand = zi / 10;

  // If succeed, remove trailing zeros if necessary and return
  if (ret_value.significand * 10 >= xi) {
    ret_value.exponent = minus_k + 1;
    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
    return ret_value;
  }

  // Otherwise, compute the round-up of y
  ret_value.significand =
      cache_accessor<T>::compute_round_up_for_shorter_interval_case(
          cache, beta_minus_1);
  ret_value.exponent = minus_k;

  // When tie occurs, choose one of them according to the rule
  if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&
      exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {
    ret_value.significand = ret_value.significand % 2 == 0
                                ? ret_value.significand
                                : ret_value.significand - 1;
  } else if (ret_value.significand < xi) {
    ++ret_value.significand;
  }
  return ret_value;
}

template <typename T> decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT {
  // Step 1: integer promotion & Schubfach multiplier calculation.

  using carrier_uint = typename float_info<T>::carrier_uint;
  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
  auto br = bit_cast<carrier_uint>(x);

  // Extract significand bits and exponent bits.
  const carrier_uint significand_mask =
      (static_cast<carrier_uint>(1) << float_info<T>::significand_bits) - 1;
  carrier_uint significand = (br & significand_mask);
  int exponent = static_cast<int>((br & exponent_mask<T>()) >>
                                  float_info<T>::significand_bits);

  if (exponent != 0) {  // Check if normal.
    exponent += float_info<T>::exponent_bias - float_info<T>::significand_bits;

    // Shorter interval case; proceed like Schubfach.
    if (significand == 0) return shorter_interval_case<T>(exponent);

    significand |=
        (static_cast<carrier_uint>(1) << float_info<T>::significand_bits);
  } else {
    // Subnormal case; the interval is always regular.
    if (significand == 0) return {0, 0};
    exponent = float_info<T>::min_exponent - float_info<T>::significand_bits;
  }

  const bool include_left_endpoint = (significand % 2 == 0);
  const bool include_right_endpoint = include_left_endpoint;

  // Compute k and beta.
  const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;
  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
  const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);

  // Compute zi and deltai
  // 10^kappa <= deltai < 10^(kappa + 1)
  const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta_minus_1);
  const carrier_uint two_fc = significand << 1;
  const carrier_uint two_fr = two_fc | 1;
  const carrier_uint zi =
      cache_accessor<T>::compute_mul(two_fr << beta_minus_1, cache);

  // Step 2: Try larger divisor; remove trailing zeros if necessary

  // Using an upper bound on zi, we might be able to optimize the division
  // better than the compiler; we are computing zi / big_divisor here
  decimal_fp<T> ret_value;
  ret_value.significand = divide_by_10_to_kappa_plus_1(zi);
  uint32_t r = static_cast<uint32_t>(zi - float_info<T>::big_divisor *
                                              ret_value.significand);

  if (r > deltai) {
    goto small_divisor_case_label;
  } else if (r < deltai) {
    // Exclude the right endpoint if necessary
    if (r == 0 && !include_right_endpoint &&
        is_endpoint_integer<T>(two_fr, exponent, minus_k)) {
      --ret_value.significand;
      r = float_info<T>::big_divisor;
      goto small_divisor_case_label;
    }
  } else {
    // r == deltai; compare fractional parts
    // Check conditions in the order different from the paper
    // to take advantage of short-circuiting
    const carrier_uint two_fl = two_fc - 1;
    if ((!include_left_endpoint ||
         !is_endpoint_integer<T>(two_fl, exponent, minus_k)) &&
        !cache_accessor<T>::compute_mul_parity(two_fl, cache, beta_minus_1)) {
      goto small_divisor_case_label;
    }
  }
  ret_value.exponent = minus_k + float_info<T>::kappa + 1;

  // We may need to remove trailing zeros
  ret_value.exponent += remove_trailing_zeros(ret_value.significand);
  return ret_value;

  // Step 3: Find the significand with the smaller divisor

small_divisor_case_label:
  ret_value.significand *= 10;
  ret_value.exponent = minus_k + float_info<T>::kappa;

  const uint32_t mask = (1u << float_info<T>::kappa) - 1;
  auto dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);

  // Is dist divisible by 2^kappa?
  if ((dist & mask) == 0) {
    const bool approx_y_parity =
        ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;
    dist >>= float_info<T>::kappa;

    // Is dist divisible by 5^kappa?
    if (check_divisibility_and_divide_by_pow5<float_info<T>::kappa>(dist)) {
      ret_value.significand += dist;

      // Check z^(f) >= epsilon^(f)
      // We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1,
      // where yi == zi - epsiloni if and only if z^(f) >= epsilon^(f)
      // Since there are only 2 possibilities, we only need to care about the
      // parity. Also, zi and r should have the same parity since the divisor
      // is an even number
      if (cache_accessor<T>::compute_mul_parity(two_fc, cache, beta_minus_1) !=
          approx_y_parity) {
        --ret_value.significand;
      } else {
        // If z^(f) >= epsilon^(f), we might have a tie
        // when z^(f) == epsilon^(f), or equivalently, when y is an integer
        if (is_center_integer<T>(two_fc, exponent, minus_k)) {
          ret_value.significand = ret_value.significand % 2 == 0
                                      ? ret_value.significand
                                      : ret_value.significand - 1;
        }
      }
    }
    // Is dist not divisible by 5^kappa?
    else {
      ret_value.significand += dist;
    }
  }
  // Is dist not divisible by 2^kappa?
  else {
    // Since we know dist is small, we might be able to optimize the division
    // better than the compiler; we are computing dist / small_divisor here
    ret_value.significand +=
        small_division_by_pow10<float_info<T>::kappa>(dist);
  }
  return ret_value;
}
}  // namespace dragonbox

// Formats a floating-point number using a variation of the Fixed-Precision
// Positive Floating-Point Printout ((FPP)^2) algorithm by Steele & White:
// https://fmt.dev/papers/p372-steele.pdf.
FMT_CONSTEXPR20 inline void format_dragon(fp value, bool is_predecessor_closer,
                                          int num_digits, buffer<char>& buf,
                                          int& exp10) {
  bigint numerator;    // 2 * R in (FPP)^2.
  bigint denominator;  // 2 * S in (FPP)^2.
  // lower and upper are differences between value and corresponding boundaries.
  bigint lower;             // (M^- in (FPP)^2).
  bigint upper_store;       // upper's value if different from lower.
  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
  // Shift numerator and denominator by an extra bit or two (if lower boundary
  // is closer) to make lower and upper integers. This eliminates multiplication
  // by 2 during later computations.
  int shift = is_predecessor_closer ? 2 : 1;
  uint64_t significand = value.f << shift;
  if (value.e >= 0) {
    numerator.assign(significand);
    numerator <<= value.e;
    lower.assign(1);
    lower <<= value.e;
    if (shift != 1) {
      upper_store.assign(1);
      upper_store <<= value.e + 1;
      upper = &upper_store;
    }
    denominator.assign_pow10(exp10);
    denominator <<= shift;
  } else if (exp10 < 0) {
    numerator.assign_pow10(-exp10);
    lower.assign(numerator);
    if (shift != 1) {
      upper_store.assign(numerator);
      upper_store <<= 1;
      upper = &upper_store;
    }
    numerator *= significand;
    denominator.assign(1);
    denominator <<= shift - value.e;
  } else {
    numerator.assign(significand);
    denominator.assign_pow10(exp10);
    denominator <<= shift - value.e;
    lower.assign(1);
    if (shift != 1) {
      upper_store.assign(1ULL << 1);
      upper = &upper_store;
    }
  }
  // Invariant: value == (numerator / denominator) * pow(10, exp10).
  if (num_digits < 0) {
    // Generate the shortest representation.
    if (!upper) upper = &lower;
    bool even = (value.f & 1) == 0;
    num_digits = 0;
    char* data = buf.data();
    for (;;) {
      int digit = numerator.divmod_assign(denominator);
      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
      // numerator + upper >[=] pow10:
      bool high = add_compare(numerator, *upper, denominator) + even > 0;
      data[num_digits++] = static_cast<char>('0' + digit);
      if (low || high) {
        if (!low) {
          ++data[num_digits - 1];
        } else if (high) {
          int result = add_compare(numerator, numerator, denominator);
          // Round half to even.
          if (result > 0 || (result == 0 && (digit % 2) != 0))
            ++data[num_digits - 1];
        }
        buf.try_resize(to_unsigned(num_digits));
        exp10 -= num_digits - 1;
        return;
      }
      numerator *= 10;
      lower *= 10;
      if (upper != &lower) *upper *= 10;
    }
  }
  // Generate the given number of digits.
  exp10 -= num_digits - 1;
  if (num_digits == 0) {
    denominator *= 10;
    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
    buf.push_back(digit);
    return;
  }
  buf.try_resize(to_unsigned(num_digits));
  for (int i = 0; i < num_digits - 1; ++i) {
    int digit = numerator.divmod_assign(denominator);
    buf[i] = static_cast<char>('0' + digit);
    numerator *= 10;
  }
  int digit = numerator.divmod_assign(denominator);
  auto result = add_compare(numerator, numerator, denominator);
  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
    if (digit == 9) {
      const auto overflow = '0' + 10;
      buf[num_digits - 1] = overflow;
      // Propagate the carry.
      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
        buf[i] = '0';
        ++buf[i - 1];
      }
      if (buf[0] == overflow) {
        buf[0] = '1';
        ++exp10;
      }
      return;
    }
    ++digit;
  }
  buf[num_digits - 1] = static_cast<char>('0' + digit);
}

template <typename Float>
FMT_HEADER_ONLY_CONSTEXPR20 int format_float(Float value, int precision,
                                             float_specs specs,
                                             buffer<char>& buf) {
  // float is passed as double to reduce the number of instantiations.
  static_assert(!std::is_same<Float, float>::value, "");
  FMT_ASSERT(value >= 0, "value is negative");

  const bool fixed = specs.format == float_format::fixed;
  if (value <= 0) {  // <= instead of == to silence a warning.
    if (precision <= 0 || !fixed) {
      buf.push_back('0');
      return 0;
    }
    buf.try_resize(to_unsigned(precision));
    fill_n(buf.data(), precision, '0');
    return -precision;
  }

  if (specs.fallback) return snprintf_float(value, precision, specs, buf);

  if (!is_constant_evaluated() && precision < 0) {
    // Use Dragonbox for the shortest format.
    if (specs.binary32) {
      auto dec = dragonbox::to_decimal(static_cast<float>(value));
      write<char>(buffer_appender<char>(buf), dec.significand);
      return dec.exponent;
    }
    auto dec = dragonbox::to_decimal(static_cast<double>(value));
    write<char>(buffer_appender<char>(buf), dec.significand);
    return dec.exponent;
  }

  int exp = 0;
  bool use_dragon = true;
  if (is_fast_float<Float>()) {
    // Use Grisu + Dragon4 for the given precision:
    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
    const int min_exp = -60;  // alpha in Grisu.
    int cached_exp10 = 0;     // K in Grisu.
    fp normalized = normalize(fp(value));
    const auto cached_pow = get_cached_power(
        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
    normalized = normalized * cached_pow;
    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
        !is_constant_evaluated()) {
      exp += handler.exp10;
      buf.try_resize(to_unsigned(handler.size));
      use_dragon = false;
    } else {
      exp += handler.size - cached_exp10 - 1;
      precision = handler.precision;
    }
  }
  if (use_dragon) {
    auto f = fp();
    bool is_predecessor_closer =
        specs.binary32 ? f.assign(static_cast<float>(value)) : f.assign(value);
    // Limit precision to the maximum possible number of significant digits in
    // an IEEE754 double because we don't need to generate zeros.
    const int max_double_digits = 767;
    if (precision > max_double_digits) precision = max_double_digits;
    format_dragon(f, is_predecessor_closer, precision, buf, exp);
  }
  if (!fixed && !specs.showpoint) {
    // Remove trailing zeros.
    auto num_digits = buf.size();
    while (num_digits > 0 && buf[num_digits - 1] == '0') {
      --num_digits;
      ++exp;
    }
    buf.try_resize(num_digits);
  }
  return exp;
}

template <typename T>
int snprintf_float(T value, int precision, float_specs specs,
                   buffer<char>& buf) {
  // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
  FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
  static_assert(!std::is_same<T, float>::value, "");

  // Subtract 1 to account for the difference in precision since we use %e for
  // both general and exponent format.
  if (specs.format == float_format::general ||
      specs.format == float_format::exp)
    precision = (precision >= 0 ? precision : 6) - 1;

  // Build the format string.
  enum { max_format_size = 7 };  // The longest format is "%#.*Le".
  char format[max_format_size];
  char* format_ptr = format;
  *format_ptr++ = '%';
  if (specs.showpoint && specs.format == float_format::hex) *format_ptr++ = '#';
  if (precision >= 0) {
    *format_ptr++ = '.';
    *format_ptr++ = '*';
  }
  if (std::is_same<T, long double>()) *format_ptr++ = 'L';
  *format_ptr++ = specs.format != float_format::hex
                      ? (specs.format == float_format::fixed ? 'f' : 'e')
                      : (specs.upper ? 'A' : 'a');
  *format_ptr = '\0';

  // Format using snprintf.
  auto offset = buf.size();
  for (;;) {
    auto begin = buf.data() + offset;
    auto capacity = buf.capacity() - offset;
#ifdef FMT_FUZZ
    if (precision > 100000)
      throw std::runtime_error(
          "fuzz mode - avoid large allocation inside snprintf");
#endif
    // Suppress the warning about a nonliteral format string.
    // Cannot use auto because of a bug in MinGW (#1532).
    int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
    int result = precision >= 0
                     ? snprintf_ptr(begin, capacity, format, precision, value)
                     : snprintf_ptr(begin, capacity, format, value);
    if (result < 0) {
      // The buffer will grow exponentially.
      buf.try_reserve(buf.capacity() + 1);
      continue;
    }
    auto size = to_unsigned(result);
    // Size equal to capacity means that the last character was truncated.
    if (size >= capacity) {
      buf.try_reserve(size + offset + 1);  // Add 1 for the terminating '\0'.
      continue;
    }
    auto is_digit = [](char c) { return c >= '0' && c <= '9'; };
    if (specs.format == float_format::fixed) {
      if (precision == 0) {
        buf.try_resize(size);
        return 0;
      }
      // Find and remove the decimal point.
      auto end = begin + size, p = end;
      do {
        --p;
      } while (is_digit(*p));
      int fraction_size = static_cast<int>(end - p - 1);
      std::memmove(p, p + 1, to_unsigned(fraction_size));
      buf.try_resize(size - 1);
      return -fraction_size;
    }
    if (specs.format == float_format::hex) {
      buf.try_resize(size + offset);
      return 0;
    }
    // Find and parse the exponent.
    auto end = begin + size, exp_pos = end;
    do {
      --exp_pos;
    } while (*exp_pos != 'e');
    char sign = exp_pos[1];
    FMT_ASSERT(sign == '+' || sign == '-', "");
    int exp = 0;
    auto p = exp_pos + 2;  // Skip 'e' and sign.
    do {
      FMT_ASSERT(is_digit(*p), "");
      exp = exp * 10 + (*p++ - '0');
    } while (p != end);
    if (sign == '-') exp = -exp;
    int fraction_size = 0;
    if (exp_pos != begin + 1) {
      // Remove trailing zeros.
      auto fraction_end = exp_pos - 1;
      while (*fraction_end == '0') --fraction_end;
      // Move the fractional part left to get rid of the decimal point.
      fraction_size = static_cast<int>(fraction_end - begin - 1);
      std::memmove(begin + 1, begin + 2, to_unsigned(fraction_size));
    }
    buf.try_resize(to_unsigned(fraction_size) + offset + 1);
    return exp - fraction_size;
  }
}
}  // namespace detail

template <> struct formatter<detail::bigint> {
  FMT_CONSTEXPR format_parse_context::iterator parse(
      format_parse_context& ctx) {
    return ctx.begin();
  }

  format_context::iterator format(const detail::bigint& n,
                                  format_context& ctx) {
    auto out = ctx.out();
    bool first = true;
    for (auto i = n.bigits_.size(); i > 0; --i) {
      auto value = n.bigits_[i - 1u];
      if (first) {
        out = format_to(out, FMT_STRING("{:x}"), value);
        first = false;
        continue;
      }
      out = format_to(out, FMT_STRING("{:08x}"), value);
    }
    if (n.exp_ > 0)
      out = format_to(out, FMT_STRING("p{}"),
                      n.exp_ * detail::bigint::bigit_bits);
    return out;
  }
};

FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
  for_each_codepoint(s, [this](uint32_t cp, string_view) {
    if (cp == invalid_code_point) FMT_THROW(std::runtime_error("invalid utf8"));
    if (cp <= 0xFFFF) {
      buffer_.push_back(static_cast<wchar_t>(cp));
    } else {
      cp -= 0x10000;
      buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));
      buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));
    }
    return true;
  });
  buffer_.push_back(0);
}

FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
                                  const char* message) FMT_NOEXCEPT {
  FMT_TRY {
    auto ec = std::error_code(error_code, std::generic_category());
    write(std::back_inserter(out), std::system_error(ec, message).what());
    return;
  }
  FMT_CATCH(...) {}
  format_error_code(out, error_code, message);
}

FMT_FUNC void report_system_error(int error_code,
                                  const char* message) FMT_NOEXCEPT {
  report_error(format_system_error, error_code, message);
}

// DEPRECATED!
// This function is defined here and not inline for ABI compatiblity.
FMT_FUNC void detail::error_handler::on_error(const char* message) {
  throw_format_error(message);
}

FMT_FUNC std::string vformat(string_view fmt, format_args args) {
  // Don't optimize the "{}" case to keep the binary size small and because it
  // can be better optimized in fmt::format anyway.
  auto buffer = memory_buffer();
  detail::vformat_to(buffer, fmt, args);
  return to_string(buffer);
}

#ifdef _WIN32
namespace detail {
using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  //
    void*, const void*, dword, dword*, void*);
}  // namespace detail
#endif

namespace detail {
FMT_FUNC void print(std::FILE* f, string_view text) {
#ifdef _WIN32
  auto fd = _fileno(f);
  if (_isatty(fd)) {
    detail::utf8_to_utf16 u16(string_view(text.data(), text.size()));
    auto written = detail::dword();
    if (detail::WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)),
                              u16.c_str(), static_cast<uint32_t>(u16.size()),
                              &written, nullptr)) {
      return;
    }
    // Fallback to fwrite on failure. It can happen if the output has been
    // redirected to NUL.
  }
#endif
  detail::fwrite_fully(text.data(), 1, text.size(), f);
}
}  // namespace detail

FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
  memory_buffer buffer;
  detail::vformat_to(buffer, format_str, args);
  detail::print(f, {buffer.data(), buffer.size()});
}

#ifdef _WIN32
// Print assuming legacy (non-Unicode) encoding.
FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
                                      format_args args) {
  memory_buffer buffer;
  detail::vformat_to(buffer, format_str,
                     basic_format_args<buffer_context<char>>(args));
  fwrite_fully(buffer.data(), 1, buffer.size(), f);
}
#endif

FMT_FUNC void vprint(string_view format_str, format_args args) {
  vprint(stdout, format_str, args);
}

FMT_END_NAMESPACE

#endif  // FMT_FORMAT_INL_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h`:

```h
/*
 Formatting library for C++

 Copyright (c) 2012 - present, Victor Zverovich

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 --- Optional exception to the license ---

 As an exception, if, as a result of your compiling your source code, portions
 of this Software are embedded into a machine-executable object form of such
 source code, you may redistribute such embedded portions in such object form
 without including the above copyright and permission notices.
 */

#ifndef FMT_FORMAT_H_
#define FMT_FORMAT_H_

#include <cmath>         // std::signbit
#include <cstdint>       // uint32_t
#include <limits>        // std::numeric_limits
#include <memory>        // std::uninitialized_copy
#include <stdexcept>     // std::runtime_error
#include <system_error>  // std::system_error
#include <utility>       // std::swap

#ifdef __cpp_lib_bit_cast
#  include <bit>  // std::bitcast
#endif

#include "core.h"

#if FMT_GCC_VERSION
#  define FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
#else
#  define FMT_GCC_VISIBILITY_HIDDEN
#endif

#ifdef __NVCC__
#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
#else
#  define FMT_CUDA_VERSION 0
#endif

#ifdef __has_builtin
#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
#else
#  define FMT_HAS_BUILTIN(x) 0
#endif

#if FMT_GCC_VERSION || FMT_CLANG_VERSION
#  define FMT_NOINLINE __attribute__((noinline))
#else
#  define FMT_NOINLINE
#endif

#if FMT_MSC_VER
#  define FMT_MSC_DEFAULT = default
#else
#  define FMT_MSC_DEFAULT
#endif

#ifndef FMT_THROW
#  if FMT_EXCEPTIONS
#    if FMT_MSC_VER || FMT_NVCC
FMT_BEGIN_NAMESPACE
namespace detail {
template <typename Exception> inline void do_throw(const Exception& x) {
  // Silence unreachable code warnings in MSVC and NVCC because these
  // are nearly impossible to fix in a generic code.
  volatile bool b = true;
  if (b) throw x;
}
}  // namespace detail
FMT_END_NAMESPACE
#      define FMT_THROW(x) detail::do_throw(x)
#    else
#      define FMT_THROW(x) throw x
#    endif
#  else
#    define FMT_THROW(x)               \
      do {                             \
        FMT_ASSERT(false, (x).what()); \
      } while (false)
#  endif
#endif

#if FMT_EXCEPTIONS
#  define FMT_TRY try
#  define FMT_CATCH(x) catch (x)
#else
#  define FMT_TRY if (true)
#  define FMT_CATCH(x) if (false)
#endif

#ifndef FMT_MAYBE_UNUSED
#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
#    define FMT_MAYBE_UNUSED [[maybe_unused]]
#  else
#    define FMT_MAYBE_UNUSED
#  endif
#endif

// Workaround broken [[deprecated]] in the Intel, PGI and NVCC compilers.
#if FMT_ICC_VERSION || defined(__PGI) || FMT_NVCC
#  define FMT_DEPRECATED_ALIAS
#else
#  define FMT_DEPRECATED_ALIAS FMT_DEPRECATED
#endif

#ifndef FMT_USE_USER_DEFINED_LITERALS
// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.
#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \
       FMT_MSC_VER >= 1900) &&                                         \
      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
#    define FMT_USE_USER_DEFINED_LITERALS 1
#  else
#    define FMT_USE_USER_DEFINED_LITERALS 0
#  endif
#endif

// Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
// integer formatter template instantiations to just one by only using the
// largest integer type. This results in a reduction in binary size but will
// cause a decrease in integer formatting performance.
#if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
#  define FMT_REDUCE_INT_INSTANTIATIONS 0
#endif

// __builtin_clz is broken in clang with Microsoft CodeGen:
// https://github.com/fmtlib/fmt/issues/519.
#if !FMT_MSC_VER
#  if FMT_HAS_BUILTIN(__builtin_clz) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
#  endif
#  if FMT_HAS_BUILTIN(__builtin_clzll) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
#  endif
#endif

// __builtin_ctz is broken in Intel Compiler Classic on Windows:
// https://github.com/fmtlib/fmt/issues/2510.
#ifndef __ICL
#  if FMT_HAS_BUILTIN(__builtin_ctz) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
#  endif
#  if FMT_HAS_BUILTIN(__builtin_ctzll) || FMT_GCC_VERSION || FMT_ICC_VERSION
#    define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
#  endif
#endif

#if FMT_MSC_VER
#  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
#endif

// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
// MSVC intrinsics if the clz and clzll builtins are not available.
#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(FMT_BUILTIN_CTZLL)
FMT_BEGIN_NAMESPACE
namespace detail {
// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
#  if !defined(__clang__)
#    pragma intrinsic(_BitScanForward)
#    pragma intrinsic(_BitScanReverse)
#    if defined(_WIN64)
#      pragma intrinsic(_BitScanForward64)
#      pragma intrinsic(_BitScanReverse64)
#    endif
#  endif

inline auto clz(uint32_t x) -> int {
  unsigned long r = 0;
  _BitScanReverse(&r, x);
  FMT_ASSERT(x != 0, "");
  // Static analysis complains about using uninitialized data
  // "r", but the only way that can happen is if "x" is 0,
  // which the callers guarantee to not happen.
  FMT_MSC_WARNING(suppress : 6102)
  return 31 ^ static_cast<int>(r);
}
#  define FMT_BUILTIN_CLZ(n) detail::clz(n)

inline auto clzll(uint64_t x) -> int {
  unsigned long r = 0;
#  ifdef _WIN64
  _BitScanReverse64(&r, x);
#  else
  // Scan the high 32 bits.
  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32))) return 63 ^ (r + 32);
  // Scan the low 32 bits.
  _BitScanReverse(&r, static_cast<uint32_t>(x));
#  endif
  FMT_ASSERT(x != 0, "");
  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
  return 63 ^ static_cast<int>(r);
}
#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)

inline auto ctz(uint32_t x) -> int {
  unsigned long r = 0;
  _BitScanForward(&r, x);
  FMT_ASSERT(x != 0, "");
  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
  return static_cast<int>(r);
}
#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)

inline auto ctzll(uint64_t x) -> int {
  unsigned long r = 0;
  FMT_ASSERT(x != 0, "");
  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
#  ifdef _WIN64
  _BitScanForward64(&r, x);
#  else
  // Scan the low 32 bits.
  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
  // Scan the high 32 bits.
  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
  r += 32;
#  endif
  return static_cast<int>(r);
}
#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
}  // namespace detail
FMT_END_NAMESPACE
#endif

#ifdef FMT_HEADER_ONLY
#  define FMT_HEADER_ONLY_CONSTEXPR20 FMT_CONSTEXPR20
#else
#  define FMT_HEADER_ONLY_CONSTEXPR20
#endif

FMT_BEGIN_NAMESPACE
namespace detail {

template <typename Streambuf> class formatbuf : public Streambuf {
 private:
  using char_type = typename Streambuf::char_type;
  using streamsize = decltype(std::declval<Streambuf>().sputn(nullptr, 0));
  using int_type = typename Streambuf::int_type;
  using traits_type = typename Streambuf::traits_type;

  buffer<char_type>& buffer_;

 public:
  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}

 protected:
  // The put area is always empty. This makes the implementation simpler and has
  // the advantage that the streambuf and the buffer are always in sync and
  // sputc never writes into uninitialized memory. A disadvantage is that each
  // call to sputc always results in a (virtual) call to overflow. There is no
  // disadvantage here for sputn since this always results in a call to xsputn.

  auto overflow(int_type ch) -> int_type override {
    if (!traits_type::eq_int_type(ch, traits_type::eof()))
      buffer_.push_back(static_cast<char_type>(ch));
    return ch;
  }

  auto xsputn(const char_type* s, streamsize count) -> streamsize override {
    buffer_.append(s, s + count);
    return count;
  }
};

// Implementation of std::bit_cast for pre-C++20.
template <typename To, typename From>
FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
  static_assert(sizeof(To) == sizeof(From), "size mismatch");
#ifdef __cpp_lib_bit_cast
  if (is_constant_evaluated()) return std::bit_cast<To>(from);
#endif
  auto to = To();
  std::memcpy(&to, &from, sizeof(to));
  return to;
}

inline auto is_big_endian() -> bool {
#ifdef _WIN32
  return false;
#elif defined(__BIG_ENDIAN__)
  return true;
#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)
  return __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__;
#else
  struct bytes {
    char data[sizeof(int)];
  };
  return bit_cast<bytes>(1).data[0] == 0;
#endif
}

// A fallback implementation of uintptr_t for systems that lack it.
struct fallback_uintptr {
  unsigned char value[sizeof(void*)];

  fallback_uintptr() = default;
  explicit fallback_uintptr(const void* p) {
    *this = bit_cast<fallback_uintptr>(p);
    if (const_check(is_big_endian())) {
      for (size_t i = 0, j = sizeof(void*) - 1; i < j; ++i, --j)
        std::swap(value[i], value[j]);
    }
  }
};
#ifdef UINTPTR_MAX
using uintptr_t = ::uintptr_t;
inline auto to_uintptr(const void* p) -> uintptr_t {
  return bit_cast<uintptr_t>(p);
}
#else
using uintptr_t = fallback_uintptr;
inline auto to_uintptr(const void* p) -> fallback_uintptr {
  return fallback_uintptr(p);
}
#endif

// Returns the largest possible value for type T. Same as
// std::numeric_limits<T>::max() but shorter and not affected by the max macro.
template <typename T> constexpr auto max_value() -> T {
  return (std::numeric_limits<T>::max)();
}
template <typename T> constexpr auto num_bits() -> int {
  return std::numeric_limits<T>::digits;
}
// std::numeric_limits<T>::digits may return 0 for 128-bit ints.
template <> constexpr auto num_bits<int128_t>() -> int { return 128; }
template <> constexpr auto num_bits<uint128_t>() -> int { return 128; }
template <> constexpr auto num_bits<fallback_uintptr>() -> int {
  return static_cast<int>(sizeof(void*) *
                          std::numeric_limits<unsigned char>::digits);
}

FMT_INLINE void assume(bool condition) {
  (void)condition;
#if FMT_HAS_BUILTIN(__builtin_assume)
  __builtin_assume(condition);
#endif
}

// An approximation of iterator_t for pre-C++20 systems.
template <typename T>
using iterator_t = decltype(std::begin(std::declval<T&>()));
template <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));

// A workaround for std::string not having mutable data() until C++17.
template <typename Char>
inline auto get_data(std::basic_string<Char>& s) -> Char* {
  return &s[0];
}
template <typename Container>
inline auto get_data(Container& c) -> typename Container::value_type* {
  return c.data();
}

#if defined(_SECURE_SCL) && _SECURE_SCL
// Make a checked iterator to avoid MSVC warnings.
template <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;
template <typename T>
constexpr auto make_checked(T* p, size_t size) -> checked_ptr<T> {
  return {p, size};
}
#else
template <typename T> using checked_ptr = T*;
template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  return p;
}
#endif

// Attempts to reserve space for n extra characters in the output range.
// Returns a pointer to the reserved range or a reference to it.
template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
#if FMT_CLANG_VERSION >= 307 && !FMT_ICC_VERSION
__attribute__((no_sanitize("undefined")))
#endif
inline auto
reserve(std::back_insert_iterator<Container> it, size_t n)
    -> checked_ptr<typename Container::value_type> {
  Container& c = get_container(it);
  size_t size = c.size();
  c.resize(size + n);
  return make_checked(get_data(c) + size, n);
}

template <typename T>
inline auto reserve(buffer_appender<T> it, size_t n) -> buffer_appender<T> {
  buffer<T>& buf = get_container(it);
  buf.try_reserve(buf.size() + n);
  return it;
}

template <typename Iterator>
constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
  return it;
}

template <typename OutputIt>
using reserve_iterator =
    remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;

template <typename T, typename OutputIt>
constexpr auto to_pointer(OutputIt, size_t) -> T* {
  return nullptr;
}
template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
  buffer<T>& buf = get_container(it);
  auto size = buf.size();
  if (buf.capacity() < size + n) return nullptr;
  buf.try_resize(size + n);
  return buf.data() + size;
}

template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
inline auto base_iterator(std::back_insert_iterator<Container>& it,
                          checked_ptr<typename Container::value_type>)
    -> std::back_insert_iterator<Container> {
  return it;
}

template <typename Iterator>
constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  return it;
}

// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill_n
// instead (#1998).
template <typename OutputIt, typename Size, typename T>
FMT_CONSTEXPR auto fill_n(OutputIt out, Size count, const T& value)
    -> OutputIt {
  for (Size i = 0; i < count; ++i) *out++ = value;
  return out;
}
template <typename T, typename Size>
FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
  if (is_constant_evaluated()) {
    return fill_n<T*, Size, T>(out, count, value);
  }
  std::memset(out, value, to_unsigned(count));
  return out + count;
}

#ifdef __cpp_char8_t
using char8_type = char8_t;
#else
enum char8_type : unsigned char {};
#endif

template <typename OutChar, typename InputIt, typename OutputIt>
FMT_CONSTEXPR FMT_NOINLINE auto copy_str_noinline(InputIt begin, InputIt end,
                                                  OutputIt out) -> OutputIt {
  return copy_str<OutChar>(begin, end, out);
}

// A public domain branchless UTF-8 decoder by Christopher Wellons:
// https://github.com/skeeto/branchless-utf8
/* Decode the next character, c, from s, reporting errors in e.
 *
 * Since this is a branchless decoder, four bytes will be read from the
 * buffer regardless of the actual length of the next character. This
 * means the buffer _must_ have at least three bytes of zero padding
 * following the end of the data stream.
 *
 * Errors are reported in e, which will be non-zero if the parsed
 * character was somehow invalid: invalid byte sequence, non-canonical
 * encoding, or a surrogate half.
 *
 * The function returns a pointer to the next character. When an error
 * occurs, this pointer will be a guess that depends on the particular
 * error, but it will always advance at least one byte.
 */
FMT_CONSTEXPR inline auto utf8_decode(const char* s, uint32_t* c, int* e)
    -> const char* {
  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
  constexpr const int shiftc[] = {0, 18, 12, 6, 0};
  constexpr const int shifte[] = {0, 6, 4, 2, 0};

  int len = code_point_length(s);
  const char* next = s + len;

  // Assume a four-byte character and load four bytes. Unused bits are
  // shifted out.
  *c = uint32_t(s[0] & masks[len]) << 18;
  *c |= uint32_t(s[1] & 0x3f) << 12;
  *c |= uint32_t(s[2] & 0x3f) << 6;
  *c |= uint32_t(s[3] & 0x3f) << 0;
  *c >>= shiftc[len];

  // Accumulate the various error conditions.
  using uchar = unsigned char;
  *e = (*c < mins[len]) << 6;       // non-canonical encoding
  *e |= ((*c >> 11) == 0x1b) << 7;  // surrogate half?
  *e |= (*c > 0x10FFFF) << 8;       // out of range?
  *e |= (uchar(s[1]) & 0xc0) >> 2;
  *e |= (uchar(s[2]) & 0xc0) >> 4;
  *e |= uchar(s[3]) >> 6;
  *e ^= 0x2a;  // top two bits of each tail byte correct?
  *e >>= shifte[len];

  return next;
}

constexpr uint32_t invalid_code_point = ~uint32_t();

// Invokes f(cp, sv) for every code point cp in s with sv being the string view
// corresponding to the code point. cp is invalid_code_point on error.
template <typename F>
FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
  auto decode = [f](const char* buf_ptr, const char* ptr) {
    auto cp = uint32_t();
    auto error = 0;
    auto end = utf8_decode(buf_ptr, &cp, &error);
    bool result = f(error ? invalid_code_point : cp,
                    string_view(ptr, to_unsigned(end - buf_ptr)));
    return result ? end : nullptr;
  };
  auto p = s.data();
  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.
  if (s.size() >= block_size) {
    for (auto end = p + s.size() - block_size + 1; p < end;) {
      p = decode(p, p);
      if (!p) return;
    }
  }
  if (auto num_chars_left = s.data() + s.size() - p) {
    char buf[2 * block_size - 1] = {};
    copy_str<char>(p, p + num_chars_left, buf);
    const char* buf_ptr = buf;
    do {
      auto end = decode(buf_ptr, p);
      if (!end) return;
      p += end - buf_ptr;
      buf_ptr = end;
    } while (buf_ptr - buf < num_chars_left);
  }
}

template <typename Char>
inline auto compute_width(basic_string_view<Char> s) -> size_t {
  return s.size();
}

// Computes approximate display width of a UTF-8 string.
FMT_CONSTEXPR inline size_t compute_width(string_view s) {
  size_t num_code_points = 0;
  // It is not a lambda for compatibility with C++14.
  struct count_code_points {
    size_t* count;
    FMT_CONSTEXPR auto operator()(uint32_t cp, string_view) const -> bool {
      *count += detail::to_unsigned(
          1 +
          (cp >= 0x1100 &&
           (cp <= 0x115f ||  // Hangul Jamo init. consonants
            cp == 0x2329 ||  // LEFT-POINTING ANGLE BRACKET
            cp == 0x232a ||  // RIGHT-POINTING ANGLE BRACKET
            // CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:
            (cp >= 0x2e80 && cp <= 0xa4cf && cp != 0x303f) ||
            (cp >= 0xac00 && cp <= 0xd7a3) ||    // Hangul Syllables
            (cp >= 0xf900 && cp <= 0xfaff) ||    // CJK Compatibility Ideographs
            (cp >= 0xfe10 && cp <= 0xfe19) ||    // Vertical Forms
            (cp >= 0xfe30 && cp <= 0xfe6f) ||    // CJK Compatibility Forms
            (cp >= 0xff00 && cp <= 0xff60) ||    // Fullwidth Forms
            (cp >= 0xffe0 && cp <= 0xffe6) ||    // Fullwidth Forms
            (cp >= 0x20000 && cp <= 0x2fffd) ||  // CJK
            (cp >= 0x30000 && cp <= 0x3fffd) ||
            // Miscellaneous Symbols and Pictographs + Emoticons:
            (cp >= 0x1f300 && cp <= 0x1f64f) ||
            // Supplemental Symbols and Pictographs:
            (cp >= 0x1f900 && cp <= 0x1f9ff))));
      return true;
    }
  };
  for_each_codepoint(s, count_code_points{&num_code_points});
  return num_code_points;
}

inline auto compute_width(basic_string_view<char8_type> s) -> size_t {
  return compute_width(basic_string_view<char>(
      reinterpret_cast<const char*>(s.data()), s.size()));
}

template <typename Char>
inline auto code_point_index(basic_string_view<Char> s, size_t n) -> size_t {
  size_t size = s.size();
  return n < size ? n : size;
}

// Calculates the index of the nth code point in a UTF-8 string.
inline auto code_point_index(basic_string_view<char8_type> s, size_t n)
    -> size_t {
  const char8_type* data = s.data();
  size_t num_code_points = 0;
  for (size_t i = 0, size = s.size(); i != size; ++i) {
    if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) return i;
  }
  return s.size();
}

template <typename T, bool = std::is_floating_point<T>::value>
struct is_fast_float : bool_constant<std::numeric_limits<T>::is_iec559 &&
                                     sizeof(T) <= sizeof(double)> {};
template <typename T> struct is_fast_float<T, false> : std::false_type {};

#ifndef FMT_USE_FULL_CACHE_DRAGONBOX
#  define FMT_USE_FULL_CACHE_DRAGONBOX 0
#endif

template <typename T>
template <typename U>
void buffer<T>::append(const U* begin, const U* end) {
  while (begin != end) {
    auto count = to_unsigned(end - begin);
    try_reserve(size_ + count);
    auto free_cap = capacity_ - size_;
    if (free_cap < count) count = free_cap;
    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
    size_ += count;
    begin += count;
  }
}

template <typename T, typename Enable = void>
struct is_locale : std::false_type {};
template <typename T>
struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
}  // namespace detail

FMT_MODULE_EXPORT_BEGIN

// The number of characters to store in the basic_memory_buffer object itself
// to avoid dynamic memory allocation.
enum { inline_buffer_size = 500 };

/**
  \rst
  A dynamically growing memory buffer for trivially copyable/constructible types
  with the first ``SIZE`` elements stored in the object itself.

  You can use the ``memory_buffer`` type alias for ``char`` instead.

  **Example**::

     auto out = fmt::memory_buffer();
     format_to(std::back_inserter(out), "The answer is {}.", 42);

  This will append the following output to the ``out`` object:

  .. code-block:: none

     The answer is 42.

  The output can be converted to an ``std::string`` with ``to_string(out)``.
  \endrst
 */
template <typename T, size_t SIZE = inline_buffer_size,
          typename Allocator = std::allocator<T>>
class basic_memory_buffer final : public detail::buffer<T> {
 private:
  T store_[SIZE];

  // Don't inherit from Allocator avoid generating type_info for it.
  Allocator alloc_;

  // Deallocate memory allocated by the buffer.
  FMT_CONSTEXPR20 void deallocate() {
    T* data = this->data();
    if (data != store_) alloc_.deallocate(data, this->capacity());
  }

 protected:
  FMT_CONSTEXPR20 void grow(size_t size) override;

 public:
  using value_type = T;
  using const_reference = const T&;

  FMT_CONSTEXPR20 explicit basic_memory_buffer(
      const Allocator& alloc = Allocator())
      : alloc_(alloc) {
    this->set(store_, SIZE);
    if (detail::is_constant_evaluated()) {
      detail::fill_n(store_, SIZE, T{});
    }
  }
  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }

 private:
  // Move data from other to this buffer.
  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
    alloc_ = std::move(other.alloc_);
    T* data = other.data();
    size_t size = other.size(), capacity = other.capacity();
    if (data == other.store_) {
      this->set(store_, capacity);
      if (detail::is_constant_evaluated()) {
        detail::copy_str<T>(other.store_, other.store_ + size,
                            detail::make_checked(store_, capacity));
      } else {
        std::uninitialized_copy(other.store_, other.store_ + size,
                                detail::make_checked(store_, capacity));
      }
    } else {
      this->set(data, capacity);
      // Set pointer to the inline array so that delete is not called
      // when deallocating.
      other.set(other.store_, 0);
    }
    this->resize(size);
  }

 public:
  /**
    \rst
    Constructs a :class:`fmt::basic_memory_buffer` object moving the content
    of the other object to it.
    \endrst
   */
  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other)
      FMT_NOEXCEPT {
    move(other);
  }

  /**
    \rst
    Moves the content of the other ``basic_memory_buffer`` object to this one.
    \endrst
   */
  auto operator=(basic_memory_buffer&& other) FMT_NOEXCEPT
      -> basic_memory_buffer& {
    FMT_ASSERT(this != &other, "");
    deallocate();
    move(other);
    return *this;
  }

  // Returns a copy of the allocator associated with this buffer.
  auto get_allocator() const -> Allocator { return alloc_; }

  /**
    Resizes the buffer to contain *count* elements. If T is a POD type new
    elements may not be initialized.
   */
  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }

  /** Increases the buffer capacity to *new_capacity*. */
  void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }

  // Directly append data into the buffer
  using detail::buffer<T>::append;
  template <typename ContiguousRange>
  void append(const ContiguousRange& range) {
    append(range.data(), range.data() + range.size());
  }
};

template <typename T, size_t SIZE, typename Allocator>
FMT_CONSTEXPR20 void basic_memory_buffer<T, SIZE, Allocator>::grow(
    size_t size) {
#ifdef FMT_FUZZ
  if (size > 5000) throw std::runtime_error("fuzz mode - won't grow that much");
#endif
  const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
  size_t old_capacity = this->capacity();
  size_t new_capacity = old_capacity + old_capacity / 2;
  if (size > new_capacity)
    new_capacity = size;
  else if (new_capacity > max_size)
    new_capacity = size > max_size ? size : max_size;
  T* old_data = this->data();
  T* new_data =
      std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
  // The following code doesn't throw, so the raw pointer above doesn't leak.
  std::uninitialized_copy(old_data, old_data + this->size(),
                          detail::make_checked(new_data, new_capacity));
  this->set(new_data, new_capacity);
  // deallocate must not throw according to the standard, but even if it does,
  // the buffer already uses the new storage and will deallocate it in
  // destructor.
  if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
}

using memory_buffer = basic_memory_buffer<char>;

template <typename T, size_t SIZE, typename Allocator>
struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
};

namespace detail {
FMT_API void print(std::FILE*, string_view);
}

/** A formatting error such as invalid format string. */
FMT_CLASS_API
class FMT_API format_error : public std::runtime_error {
 public:
  explicit format_error(const char* message) : std::runtime_error(message) {}
  explicit format_error(const std::string& message)
      : std::runtime_error(message) {}
  format_error(const format_error&) = default;
  format_error& operator=(const format_error&) = default;
  format_error(format_error&&) = default;
  format_error& operator=(format_error&&) = default;
  ~format_error() FMT_NOEXCEPT override FMT_MSC_DEFAULT;
};

/**
  \rst
  Constructs a `~fmt::format_arg_store` object that contains references
  to arguments and can be implicitly converted to `~fmt::format_args`.
  If ``fmt`` is a compile-time string then `make_args_checked` checks
  its validity at compile time.
  \endrst
 */
template <typename... Args, typename S, typename Char = char_t<S>>
FMT_INLINE auto make_args_checked(const S& fmt,
                                  const remove_reference_t<Args>&... args)
    -> format_arg_store<buffer_context<Char>, remove_reference_t<Args>...> {
  static_assert(
      detail::count<(
              std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
              std::is_reference<Args>::value)...>() == 0,
      "passing views as lvalues is disallowed");
  detail::check_format_string<Args...>(fmt);
  return {args...};
}

// compile-time support
namespace detail_exported {
#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <typename Char, size_t N> struct fixed_string {
  constexpr fixed_string(const Char (&str)[N]) {
    detail::copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str),
                                               str + N, data);
  }
  Char data[N]{};
};
#endif

// Converts a compile-time string to basic_string_view.
template <typename Char, size_t N>
constexpr auto compile_string_to_view(const Char (&s)[N])
    -> basic_string_view<Char> {
  // Remove trailing NUL character if needed. Won't be present if this is used
  // with a raw character array (i.e. not defined as a string).
  return {s, N - (std::char_traits<Char>::to_int_type(s[N - 1]) == 0 ? 1 : 0)};
}
template <typename Char>
constexpr auto compile_string_to_view(detail::std_string_view<Char> s)
    -> basic_string_view<Char> {
  return {s.data(), s.size()};
}
}  // namespace detail_exported

FMT_BEGIN_DETAIL_NAMESPACE

template <typename T> struct is_integral : std::is_integral<T> {};
template <> struct is_integral<int128_t> : std::true_type {};
template <> struct is_integral<uint128_t> : std::true_type {};

template <typename T>
using is_signed =
    std::integral_constant<bool, std::numeric_limits<T>::is_signed ||
                                     std::is_same<T, int128_t>::value>;

// Returns true if value is negative, false otherwise.
// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.
template <typename T, FMT_ENABLE_IF(is_signed<T>::value)>
FMT_CONSTEXPR auto is_negative(T value) -> bool {
  return value < 0;
}
template <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>
FMT_CONSTEXPR auto is_negative(T) -> bool {
  return false;
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR auto is_supported_floating_point(T) -> uint16_t {
  return (std::is_same<T, float>::value && FMT_USE_FLOAT) ||
         (std::is_same<T, double>::value && FMT_USE_DOUBLE) ||
         (std::is_same<T, long double>::value && FMT_USE_LONG_DOUBLE);
}

// Smallest of uint32_t, uint64_t, uint128_t that is large enough to
// represent all values of an integral type T.
template <typename T>
using uint32_or_64_or_128_t =
    conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,
                  uint32_t,
                  conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;
template <typename T>
using uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;

#define FMT_POWERS_OF_10(factor)                                             \
  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
      (factor)*1000000000

// Converts value in the range [0, 100) to a string.
constexpr const char* digits2(size_t value) {
  // GCC generates slightly better code when value is pointer-size.
  return &"0001020304050607080910111213141516171819"
         "2021222324252627282930313233343536373839"
         "4041424344454647484950515253545556575859"
         "6061626364656667686970717273747576777879"
         "8081828384858687888990919293949596979899"[value * 2];
}

// Sign is a template parameter to workaround a bug in gcc 4.8.
template <typename Char, typename Sign> constexpr Char sign(Sign s) {
#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604
  static_assert(std::is_same<Sign, sign_t>::value, "");
#endif
  return static_cast<Char>("\0-+ "[s]);
}

template <typename T> FMT_CONSTEXPR auto count_digits_fallback(T n) -> int {
  int count = 1;
  for (;;) {
    // Integer division is slow so do it for a group of four digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    if (n < 10) return count;
    if (n < 100) return count + 1;
    if (n < 1000) return count + 2;
    if (n < 10000) return count + 3;
    n /= 10000u;
    count += 4;
  }
}
#if FMT_USE_INT128
FMT_CONSTEXPR inline auto count_digits(uint128_t n) -> int {
  return count_digits_fallback(n);
}
#endif

#ifdef FMT_BUILTIN_CLZLL
// It is a separate function rather than a part of count_digits to workaround
// the lack of static constexpr in constexpr functions.
inline auto do_count_digits(uint64_t n) -> int {
  // This has comparable performance to the version by Kendall Willets
  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
  // but uses smaller tables.
  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
  static constexpr uint8_t bsr2log10[] = {
      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  static constexpr const uint64_t zero_or_powers_of_10[] = {
      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
      10000000000000000000ULL};
  return t - (n < zero_or_powers_of_10[t]);
}
#endif

// Returns the number of decimal digits in n. Leading zeros are not counted
// except for n == 0 in which case count_digits returns 1.
FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
#ifdef FMT_BUILTIN_CLZLL
  if (!is_constant_evaluated()) {
    return do_count_digits(n);
  }
#endif
  return count_digits_fallback(n);
}

// Counts the number of digits in n. BITS = log2(radix).
template <int BITS, typename UInt>
FMT_CONSTEXPR auto count_digits(UInt n) -> int {
#ifdef FMT_BUILTIN_CLZ
  if (num_bits<UInt>() == 32)
    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
#endif
  // Lambda avoids unreachable code warnings from NVHPC.
  return [](UInt m) {
    int num_digits = 0;
    do {
      ++num_digits;
    } while ((m >>= BITS) != 0);
    return num_digits;
  }(n);
}

template <> auto count_digits<4>(detail::fallback_uintptr n) -> int;

#ifdef FMT_BUILTIN_CLZ
// It is a separate function rather than a part of count_digits to workaround
// the lack of static constexpr in constexpr functions.
FMT_INLINE auto do_count_digits(uint32_t n) -> int {
// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  static constexpr uint64_t table[] = {
      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  };
  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
  return static_cast<int>((n + inc) >> 32);
}
#endif

// Optional version of count_digits for better performance on 32-bit platforms.
FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
#ifdef FMT_BUILTIN_CLZ
  if (!is_constant_evaluated()) {
    return do_count_digits(n);
  }
#endif
  return count_digits_fallback(n);
}

template <typename Int> constexpr auto digits10() FMT_NOEXCEPT -> int {
  return std::numeric_limits<Int>::digits10;
}
template <> constexpr auto digits10<int128_t>() FMT_NOEXCEPT -> int {
  return 38;
}
template <> constexpr auto digits10<uint128_t>() FMT_NOEXCEPT -> int {
  return 38;
}

template <typename Char> struct thousands_sep_result {
  std::string grouping;
  Char thousands_sep;
};

template <typename Char>
FMT_API auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char>;
template <typename Char>
inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<Char> {
  auto result = thousands_sep_impl<char>(loc);
  return {result.grouping, Char(result.thousands_sep)};
}
template <>
inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<wchar_t> {
  return thousands_sep_impl<wchar_t>(loc);
}

template <typename Char>
FMT_API auto decimal_point_impl(locale_ref loc) -> Char;
template <typename Char> inline auto decimal_point(locale_ref loc) -> Char {
  return Char(decimal_point_impl<char>(loc));
}
template <> inline auto decimal_point(locale_ref loc) -> wchar_t {
  return decimal_point_impl<wchar_t>(loc);
}

// Compares two characters for equality.
template <typename Char> auto equal2(const Char* lhs, const char* rhs) -> bool {
  return lhs[0] == Char(rhs[0]) && lhs[1] == Char(rhs[1]);
}
inline auto equal2(const char* lhs, const char* rhs) -> bool {
  return memcmp(lhs, rhs, 2) == 0;
}

// Copies two characters from src to dst.
template <typename Char>
FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
    memcpy(dst, src, 2);
    return;
  }
  *dst++ = static_cast<Char>(*src++);
  *dst = static_cast<Char>(*src);
}

template <typename Iterator> struct format_decimal_result {
  Iterator begin;
  Iterator end;
};

// Formats a decimal unsigned integer value writing into out pointing to a
// buffer of specified size. The caller must ensure that the buffer is large
// enough.
template <typename Char, typename UInt>
FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
    -> format_decimal_result<Char*> {
  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  out += size;
  Char* end = out;
  while (value >= 100) {
    // Integer division is slow so do it for a group of two digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    out -= 2;
    copy2(out, digits2(static_cast<size_t>(value % 100)));
    value /= 100;
  }
  if (value < 10) {
    *--out = static_cast<Char>('0' + value);
    return {out, end};
  }
  out -= 2;
  copy2(out, digits2(static_cast<size_t>(value)));
  return {out, end};
}

template <typename Char, typename UInt, typename Iterator,
          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
inline auto format_decimal(Iterator out, UInt value, int size)
    -> format_decimal_result<Iterator> {
  // Buffer is large enough to hold all digits (digits10 + 1).
  Char buffer[digits10<UInt>() + 1];
  auto end = format_decimal(buffer, value, size).end;
  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
}

template <unsigned BASE_BITS, typename Char, typename UInt>
FMT_CONSTEXPR auto format_uint(Char* buffer, UInt value, int num_digits,
                               bool upper = false) -> Char* {
  buffer += num_digits;
  Char* end = buffer;
  do {
    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
    unsigned digit = (value & ((1 << BASE_BITS) - 1));
    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
                                                : digits[digit]);
  } while ((value >>= BASE_BITS) != 0);
  return end;
}

template <unsigned BASE_BITS, typename Char>
auto format_uint(Char* buffer, detail::fallback_uintptr n, int num_digits,
                 bool = false) -> Char* {
  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
  int start = (num_digits + char_digits - 1) / char_digits - 1;
  if (int start_digits = num_digits % char_digits) {
    unsigned value = n.value[start--];
    buffer = format_uint<BASE_BITS>(buffer, value, start_digits);
  }
  for (; start >= 0; --start) {
    unsigned value = n.value[start];
    buffer += char_digits;
    auto p = buffer;
    for (int i = 0; i < char_digits; ++i) {
      unsigned digit = (value & ((1 << BASE_BITS) - 1));
      *--p = static_cast<Char>("0123456789abcdef"[digit]);
      value >>= BASE_BITS;
    }
  }
  return buffer;
}

template <unsigned BASE_BITS, typename Char, typename It, typename UInt>
inline auto format_uint(It out, UInt value, int num_digits, bool upper = false)
    -> It {
  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
    return out;
  }
  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
  char buffer[num_bits<UInt>() / BASE_BITS + 1];
  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
}

// A converter from UTF-8 to UTF-16.
class utf8_to_utf16 {
 private:
  basic_memory_buffer<wchar_t> buffer_;

 public:
  FMT_API explicit utf8_to_utf16(string_view s);
  operator basic_string_view<wchar_t>() const { return {&buffer_[0], size()}; }
  auto size() const -> size_t { return buffer_.size() - 1; }
  auto c_str() const -> const wchar_t* { return &buffer_[0]; }
  auto str() const -> std::wstring { return {&buffer_[0], size()}; }
};

namespace dragonbox {

// Type-specific information that Dragonbox uses.
template <class T> struct float_info;

template <> struct float_info<float> {
  using carrier_uint = uint32_t;
  static const int significand_bits = 23;
  static const int exponent_bits = 8;
  static const int min_exponent = -126;
  static const int max_exponent = 127;
  static const int exponent_bias = -127;
  static const int decimal_digits = 9;
  static const int kappa = 1;
  static const int big_divisor = 100;
  static const int small_divisor = 10;
  static const int min_k = -31;
  static const int max_k = 46;
  static const int cache_bits = 64;
  static const int divisibility_check_by_5_threshold = 39;
  static const int case_fc_pm_half_lower_threshold = -1;
  static const int case_fc_pm_half_upper_threshold = 6;
  static const int case_fc_lower_threshold = -2;
  static const int case_fc_upper_threshold = 6;
  static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
  static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
  static const int shorter_interval_tie_lower_threshold = -35;
  static const int shorter_interval_tie_upper_threshold = -35;
  static const int max_trailing_zeros = 7;
};

template <> struct float_info<double> {
  using carrier_uint = uint64_t;
  static const int significand_bits = 52;
  static const int exponent_bits = 11;
  static const int min_exponent = -1022;
  static const int max_exponent = 1023;
  static const int exponent_bias = -1023;
  static const int decimal_digits = 17;
  static const int kappa = 2;
  static const int big_divisor = 1000;
  static const int small_divisor = 100;
  static const int min_k = -292;
  static const int max_k = 326;
  static const int cache_bits = 128;
  static const int divisibility_check_by_5_threshold = 86;
  static const int case_fc_pm_half_lower_threshold = -2;
  static const int case_fc_pm_half_upper_threshold = 9;
  static const int case_fc_lower_threshold = -4;
  static const int case_fc_upper_threshold = 9;
  static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
  static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
  static const int shorter_interval_tie_lower_threshold = -77;
  static const int shorter_interval_tie_upper_threshold = -77;
  static const int max_trailing_zeros = 16;
};

template <typename T> struct decimal_fp {
  using significand_type = typename float_info<T>::carrier_uint;
  significand_type significand;
  int exponent;
};

template <typename T>
FMT_API auto to_decimal(T x) FMT_NOEXCEPT -> decimal_fp<T>;
}  // namespace dragonbox

template <typename T>
constexpr auto exponent_mask() ->
    typename dragonbox::float_info<T>::carrier_uint {
  using uint = typename dragonbox::float_info<T>::carrier_uint;
  return ((uint(1) << dragonbox::float_info<T>::exponent_bits) - 1)
         << dragonbox::float_info<T>::significand_bits;
}

// Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
template <typename Char, typename It>
FMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {
  FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
  if (exp < 0) {
    *it++ = static_cast<Char>('-');
    exp = -exp;
  } else {
    *it++ = static_cast<Char>('+');
  }
  if (exp >= 100) {
    const char* top = digits2(to_unsigned(exp / 100));
    if (exp >= 1000) *it++ = static_cast<Char>(top[0]);
    *it++ = static_cast<Char>(top[1]);
    exp %= 100;
  }
  const char* d = digits2(to_unsigned(exp));
  *it++ = static_cast<Char>(d[0]);
  *it++ = static_cast<Char>(d[1]);
  return it;
}

template <typename T>
FMT_HEADER_ONLY_CONSTEXPR20 auto format_float(T value, int precision,
                                              float_specs specs,
                                              buffer<char>& buf) -> int;

// Formats a floating-point number with snprintf.
template <typename T>
auto snprintf_float(T value, int precision, float_specs specs,
                    buffer<char>& buf) -> int;

template <typename T> constexpr auto promote_float(T value) -> T {
  return value;
}
constexpr auto promote_float(float value) -> double {
  return static_cast<double>(value);
}

template <typename OutputIt, typename Char>
FMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,
                                     const fill_t<Char>& fill) -> OutputIt {
  auto fill_size = fill.size();
  if (fill_size == 1) return detail::fill_n(it, n, fill[0]);
  auto data = fill.data();
  for (size_t i = 0; i < n; ++i)
    it = copy_str<Char>(data, data + fill_size, it);
  return it;
}

// Writes the output of f, padded according to format specifications in specs.
// size: output size in code units.
// width: output display width in (terminal) column positions.
template <align::type align = align::left, typename OutputIt, typename Char,
          typename F>
FMT_CONSTEXPR auto write_padded(OutputIt out,
                                const basic_format_specs<Char>& specs,
                                size_t size, size_t width, F&& f) -> OutputIt {
  static_assert(align == align::left || align == align::right, "");
  unsigned spec_width = to_unsigned(specs.width);
  size_t padding = spec_width > width ? spec_width - width : 0;
  // Shifts are encoded as string literals because static constexpr is not
  // supported in constexpr functions.
  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  size_t left_padding = padding >> shifts[specs.align];
  size_t right_padding = padding - left_padding;
  auto it = reserve(out, size + padding * specs.fill.size());
  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  it = f(it);
  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  return base_iterator(out, it);
}

template <align::type align = align::left, typename OutputIt, typename Char,
          typename F>
constexpr auto write_padded(OutputIt out, const basic_format_specs<Char>& specs,
                            size_t size, F&& f) -> OutputIt {
  return write_padded<align>(out, specs, size, size, f);
}

template <align::type align = align::left, typename Char, typename OutputIt>
FMT_CONSTEXPR auto write_bytes(OutputIt out, string_view bytes,
                               const basic_format_specs<Char>& specs)
    -> OutputIt {
  return write_padded<align>(
      out, specs, bytes.size(), [bytes](reserve_iterator<OutputIt> it) {
        const char* data = bytes.data();
        return copy_str<Char>(data, data + bytes.size(), it);
      });
}

template <typename Char, typename OutputIt, typename UIntPtr>
auto write_ptr(OutputIt out, UIntPtr value,
               const basic_format_specs<Char>* specs) -> OutputIt {
  int num_digits = count_digits<4>(value);
  auto size = to_unsigned(num_digits) + size_t(2);
  auto write = [=](reserve_iterator<OutputIt> it) {
    *it++ = static_cast<Char>('0');
    *it++ = static_cast<Char>('x');
    return format_uint<4, Char>(it, value, num_digits);
  };
  return specs ? write_padded<align::right>(out, *specs, size, write)
               : base_iterator(out, write(reserve(out, size)));
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write_char(OutputIt out, Char value,
                              const basic_format_specs<Char>& specs)
    -> OutputIt {
  return write_padded(out, specs, 1, [=](reserve_iterator<OutputIt> it) {
    *it++ = value;
    return it;
  });
}
template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, Char value,
                         const basic_format_specs<Char>& specs,
                         locale_ref loc = {}) -> OutputIt {
  return check_char_specs(specs)
             ? write_char(out, value, specs)
             : write(out, static_cast<int>(value), specs, loc);
}

// Data for write_int that doesn't depend on output iterator type. It is used to
// avoid template code bloat.
template <typename Char> struct write_int_data {
  size_t size;
  size_t padding;

  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
                               const basic_format_specs<Char>& specs)
      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
    if (specs.align == align::numeric) {
      auto width = to_unsigned(specs.width);
      if (width > size) {
        padding = width - size;
        size = width;
      }
    } else if (specs.precision > num_digits) {
      size = (prefix >> 24) + to_unsigned(specs.precision);
      padding = to_unsigned(specs.precision - num_digits);
    }
  }
};

// Writes an integer in the format
//   <left-padding><prefix><numeric-padding><digits><right-padding>
// where <digits> are written by write_digits(it).
// prefix contains chars in three lower bytes and the size in the fourth byte.
template <typename OutputIt, typename Char, typename W>
FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, int num_digits,
                                        unsigned prefix,
                                        const basic_format_specs<Char>& specs,
                                        W write_digits) -> OutputIt {
  // Slightly faster check for specs.width == 0 && specs.precision == -1.
  if ((specs.width | (specs.precision + 1)) == 0) {
    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
    if (prefix != 0) {
      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
        *it++ = static_cast<Char>(p & 0xff);
    }
    return base_iterator(out, write_digits(it));
  }
  auto data = write_int_data<Char>(num_digits, prefix, specs);
  return write_padded<align::right>(
      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
          *it++ = static_cast<Char>(p & 0xff);
        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
        return write_digits(it);
      });
}

template <typename Char> class digit_grouping {
 private:
  thousands_sep_result<Char> sep_;

  struct next_state {
    std::string::const_iterator group;
    int pos;
  };
  next_state initial_state() const { return {sep_.grouping.begin(), 0}; }

  // Returns the next digit group separator position.
  int next(next_state& state) const {
    if (!sep_.thousands_sep) return max_value<int>();
    if (state.group == sep_.grouping.end())
      return state.pos += sep_.grouping.back();
    if (*state.group <= 0 || *state.group == max_value<char>())
      return max_value<int>();
    state.pos += *state.group++;
    return state.pos;
  }

 public:
  explicit digit_grouping(locale_ref loc, bool localized = true) {
    if (localized)
      sep_ = thousands_sep<Char>(loc);
    else
      sep_.thousands_sep = Char();
  }
  explicit digit_grouping(thousands_sep_result<Char> sep) : sep_(sep) {}

  Char separator() const { return sep_.thousands_sep; }

  int count_separators(int num_digits) const {
    int count = 0;
    auto state = initial_state();
    while (num_digits > next(state)) ++count;
    return count;
  }

  // Applies grouping to digits and write the output to out.
  template <typename Out, typename C>
  Out apply(Out out, basic_string_view<C> digits) const {
    auto num_digits = static_cast<int>(digits.size());
    auto separators = basic_memory_buffer<int>();
    separators.push_back(0);
    auto state = initial_state();
    while (int i = next(state)) {
      if (i >= num_digits) break;
      separators.push_back(i);
    }
    for (int i = 0, sep_index = static_cast<int>(separators.size() - 1);
         i < num_digits; ++i) {
      if (num_digits - i == separators[sep_index]) {
        *out++ = separator();
        --sep_index;
      }
      *out++ = static_cast<Char>(digits[to_unsigned(i)]);
    }
    return out;
  }
};

template <typename OutputIt, typename UInt, typename Char>
auto write_int_localized(OutputIt out, UInt value, unsigned prefix,
                         const basic_format_specs<Char>& specs,
                         const digit_grouping<Char>& grouping) -> OutputIt {
  static_assert(std::is_same<uint64_or_128_t<UInt>, UInt>::value, "");
  int num_digits = count_digits(value);
  char digits[40];
  format_decimal(digits, value, num_digits);
  unsigned size = to_unsigned((prefix != 0 ? 1 : 0) + num_digits +
                              grouping.count_separators(num_digits));
  return write_padded<align::right>(
      out, specs, size, size, [&](reserve_iterator<OutputIt> it) {
        if (prefix != 0) *it++ = static_cast<Char>(prefix);
        return grouping.apply(it, string_view(digits, to_unsigned(num_digits)));
      });
}

template <typename OutputIt, typename UInt, typename Char>
auto write_int_localized(OutputIt& out, UInt value, unsigned prefix,
                         const basic_format_specs<Char>& specs, locale_ref loc)
    -> bool {
  auto grouping = digit_grouping<Char>(loc);
  out = write_int_localized(out, value, prefix, specs, grouping);
  return true;
}

FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
  prefix |= prefix != 0 ? value << 8 : value;
  prefix += (1u + (value > 0xff ? 1 : 0)) << 24;
}

template <typename UInt> struct write_int_arg {
  UInt abs_value;
  unsigned prefix;
};

template <typename T>
FMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)
    -> write_int_arg<uint32_or_64_or_128_t<T>> {
  auto prefix = 0u;
  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
  if (is_negative(value)) {
    prefix = 0x01000000 | '-';
    abs_value = 0 - abs_value;
  } else {
    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
                                            0x1000000u | ' '};
    prefix = prefixes[sign];
  }
  return {abs_value, prefix};
}

template <typename Char, typename OutputIt, typename T>
FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, write_int_arg<T> arg,
                                        const basic_format_specs<Char>& specs,
                                        locale_ref loc) -> OutputIt {
  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
  auto abs_value = arg.abs_value;
  auto prefix = arg.prefix;
  switch (specs.type) {
  case presentation_type::none:
  case presentation_type::dec: {
    if (specs.localized &&
        write_int_localized(out, static_cast<uint64_or_128_t<T>>(abs_value),
                            prefix, specs, loc)) {
      return out;
    }
    auto num_digits = count_digits(abs_value);
    return write_int(
        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
          return format_decimal<Char>(it, abs_value, num_digits).end;
        });
  }
  case presentation_type::hex_lower:
  case presentation_type::hex_upper: {
    bool upper = specs.type == presentation_type::hex_upper;
    if (specs.alt)
      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
    int num_digits = count_digits<4>(abs_value);
    return write_int(
        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
          return format_uint<4, Char>(it, abs_value, num_digits, upper);
        });
  }
  case presentation_type::bin_lower:
  case presentation_type::bin_upper: {
    bool upper = specs.type == presentation_type::bin_upper;
    if (specs.alt)
      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
    int num_digits = count_digits<1>(abs_value);
    return write_int(out, num_digits, prefix, specs,
                     [=](reserve_iterator<OutputIt> it) {
                       return format_uint<1, Char>(it, abs_value, num_digits);
                     });
  }
  case presentation_type::oct: {
    int num_digits = count_digits<3>(abs_value);
    // Octal prefix '0' is counted as a digit, so only add it if precision
    // is not greater than the number of digits.
    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
      prefix_append(prefix, '0');
    return write_int(out, num_digits, prefix, specs,
                     [=](reserve_iterator<OutputIt> it) {
                       return format_uint<3, Char>(it, abs_value, num_digits);
                     });
  }
  case presentation_type::chr:
    return write_char(out, static_cast<Char>(abs_value), specs);
  default:
    throw_format_error("invalid type specifier");
  }
  return out;
}
template <typename Char, typename OutputIt, typename T>
FMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(
    OutputIt out, write_int_arg<T> arg, const basic_format_specs<Char>& specs,
    locale_ref loc) -> OutputIt {
  return write_int(out, arg, specs, loc);
}
template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_integral<T>::value &&
                        !std::is_same<T, bool>::value &&
                        std::is_same<OutputIt, buffer_appender<Char>>::value)>
FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
                                    const basic_format_specs<Char>& specs,
                                    locale_ref loc) -> OutputIt {
  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
                            loc);
}
// An inlined version of write used in format string compilation.
template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_integral<T>::value &&
                        !std::is_same<T, bool>::value &&
                        !std::is_same<OutputIt, buffer_appender<Char>>::value)>
FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
                                    const basic_format_specs<Char>& specs,
                                    locale_ref loc) -> OutputIt {
  return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,
                         const basic_format_specs<Char>& specs) -> OutputIt {
  auto data = s.data();
  auto size = s.size();
  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
    size = code_point_index(s, to_unsigned(specs.precision));
  auto width =
      specs.width != 0 ? compute_width(basic_string_view<Char>(data, size)) : 0;
  return write_padded(out, specs, size, width,
                      [=](reserve_iterator<OutputIt> it) {
                        return copy_str<Char>(data, data + size, it);
                      });
}
template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out,
                         basic_string_view<type_identity_t<Char>> s,
                         const basic_format_specs<Char>& specs, locale_ref)
    -> OutputIt {
  check_string_type_spec(specs.type);
  return write(out, s, specs);
}
template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, const Char* s,
                         const basic_format_specs<Char>& specs, locale_ref)
    -> OutputIt {
  return check_cstring_type_spec(specs.type)
             ? write(out, basic_string_view<Char>(s), specs, {})
             : write_ptr<Char>(out, to_uintptr(s), &specs);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isinf,
                                     basic_format_specs<Char> specs,
                                     const float_specs& fspecs) -> OutputIt {
  auto str =
      isinf ? (fspecs.upper ? "INF" : "inf") : (fspecs.upper ? "NAN" : "nan");
  constexpr size_t str_size = 3;
  auto sign = fspecs.sign;
  auto size = str_size + (sign ? 1 : 0);
  // Replace '0'-padding with space for non-finite values.
  const bool is_zero_fill =
      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
    if (sign) *it++ = detail::sign<Char>(sign);
    return copy_str<Char>(str, str + str_size, it);
  });
}

// A decimal floating-point number significand * pow(10, exp).
struct big_decimal_fp {
  const char* significand;
  int significand_size;
  int exponent;
};

constexpr auto get_significand_size(const big_decimal_fp& fp) -> int {
  return fp.significand_size;
}
template <typename T>
inline auto get_significand_size(const dragonbox::decimal_fp<T>& fp) -> int {
  return count_digits(fp.significand);
}

template <typename Char, typename OutputIt>
constexpr auto write_significand(OutputIt out, const char* significand,
                                 int significand_size) -> OutputIt {
  return copy_str<Char>(significand, significand + significand_size, out);
}
template <typename Char, typename OutputIt, typename UInt>
inline auto write_significand(OutputIt out, UInt significand,
                              int significand_size) -> OutputIt {
  return format_decimal<Char>(out, significand, significand_size).end;
}
template <typename Char, typename OutputIt, typename T, typename Grouping>
FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
                                       int significand_size, int exponent,
                                       const Grouping& grouping) -> OutputIt {
  if (!grouping.separator()) {
    out = write_significand<Char>(out, significand, significand_size);
    return detail::fill_n(out, exponent, static_cast<Char>('0'));
  }
  auto buffer = memory_buffer();
  write_significand<char>(appender(buffer), significand, significand_size);
  detail::fill_n(appender(buffer), exponent, '0');
  return grouping.apply(out, string_view(buffer.data(), buffer.size()));
}

template <typename Char, typename UInt,
          FMT_ENABLE_IF(std::is_integral<UInt>::value)>
inline auto write_significand(Char* out, UInt significand, int significand_size,
                              int integral_size, Char decimal_point) -> Char* {
  if (!decimal_point)
    return format_decimal(out, significand, significand_size).end;
  out += significand_size + 1;
  Char* end = out;
  int floating_size = significand_size - integral_size;
  for (int i = floating_size / 2; i > 0; --i) {
    out -= 2;
    copy2(out, digits2(significand % 100));
    significand /= 100;
  }
  if (floating_size % 2 != 0) {
    *--out = static_cast<Char>('0' + significand % 10);
    significand /= 10;
  }
  *--out = decimal_point;
  format_decimal(out - integral_size, significand, integral_size);
  return end;
}

template <typename OutputIt, typename UInt, typename Char,
          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>
inline auto write_significand(OutputIt out, UInt significand,
                              int significand_size, int integral_size,
                              Char decimal_point) -> OutputIt {
  // Buffer is large enough to hold digits (digits10 + 1) and a decimal point.
  Char buffer[digits10<UInt>() + 2];
  auto end = write_significand(buffer, significand, significand_size,
                               integral_size, decimal_point);
  return detail::copy_str_noinline<Char>(buffer, end, out);
}

template <typename OutputIt, typename Char>
FMT_CONSTEXPR auto write_significand(OutputIt out, const char* significand,
                                     int significand_size, int integral_size,
                                     Char decimal_point) -> OutputIt {
  out = detail::copy_str_noinline<Char>(significand,
                                        significand + integral_size, out);
  if (!decimal_point) return out;
  *out++ = decimal_point;
  return detail::copy_str_noinline<Char>(significand + integral_size,
                                         significand + significand_size, out);
}

template <typename OutputIt, typename Char, typename T, typename Grouping>
FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
                                       int significand_size, int integral_size,
                                       Char decimal_point,
                                       const Grouping& grouping) -> OutputIt {
  if (!grouping.separator()) {
    return write_significand(out, significand, significand_size, integral_size,
                             decimal_point);
  }
  auto buffer = basic_memory_buffer<Char>();
  write_significand(buffer_appender<Char>(buffer), significand,
                    significand_size, integral_size, decimal_point);
  grouping.apply(
      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
                                         buffer.end(), out);
}

template <typename OutputIt, typename DecimalFP, typename Char,
          typename Grouping = digit_grouping<Char>>
FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& fp,
                                    const basic_format_specs<Char>& specs,
                                    float_specs fspecs, locale_ref loc)
    -> OutputIt {
  auto significand = fp.significand;
  int significand_size = get_significand_size(fp);
  constexpr Char zero = static_cast<Char>('0');
  auto sign = fspecs.sign;
  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
  using iterator = reserve_iterator<OutputIt>;

  Char decimal_point =
      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');

  int output_exp = fp.exponent + significand_size - 1;
  auto use_exp_format = [=]() {
    if (fspecs.format == float_format::exp) return true;
    if (fspecs.format != float_format::general) return false;
    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
    const int exp_lower = -4, exp_upper = 16;
    return output_exp < exp_lower ||
           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
  };
  if (use_exp_format()) {
    int num_zeros = 0;
    if (fspecs.showpoint) {
      num_zeros = fspecs.precision - significand_size;
      if (num_zeros < 0) num_zeros = 0;
      size += to_unsigned(num_zeros);
    } else if (significand_size == 1) {
      decimal_point = Char();
    }
    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
    int exp_digits = 2;
    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;

    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
    char exp_char = fspecs.upper ? 'E' : 'e';
    auto write = [=](iterator it) {
      if (sign) *it++ = detail::sign<Char>(sign);
      // Insert a decimal point after the first digit and add an exponent.
      it = write_significand(it, significand, significand_size, 1,
                             decimal_point);
      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
      *it++ = static_cast<Char>(exp_char);
      return write_exponent<Char>(output_exp, it);
    };
    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
                           : base_iterator(out, write(reserve(out, size)));
  }

  int exp = fp.exponent + significand_size;
  if (fp.exponent >= 0) {
    // 1234e5 -> 123400000[.0+]
    size += to_unsigned(fp.exponent);
    int num_zeros = fspecs.precision - exp;
#ifdef FMT_FUZZ
    if (num_zeros > 5000)
      throw std::runtime_error("fuzz mode - avoiding excessive cpu use");
#endif
    if (fspecs.showpoint) {
      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;
      if (num_zeros > 0) size += to_unsigned(num_zeros) + 1;
    }
    auto grouping = Grouping(loc, fspecs.locale);
    size += to_unsigned(grouping.count_separators(significand_size));
    return write_padded<align::right>(out, specs, size, [&](iterator it) {
      if (sign) *it++ = detail::sign<Char>(sign);
      it = write_significand<Char>(it, significand, significand_size,
                                   fp.exponent, grouping);
      if (!fspecs.showpoint) return it;
      *it++ = decimal_point;
      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
    });
  } else if (exp > 0) {
    // 1234e-2 -> 12.34[0+]
    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
    auto grouping = Grouping(loc, fspecs.locale);
    size += to_unsigned(grouping.count_separators(significand_size));
    return write_padded<align::right>(out, specs, size, [&](iterator it) {
      if (sign) *it++ = detail::sign<Char>(sign);
      it = write_significand(it, significand, significand_size, exp,
                             decimal_point, grouping);
      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
    });
  }
  // 1234e-6 -> 0.001234
  int num_zeros = -exp;
  if (significand_size == 0 && fspecs.precision >= 0 &&
      fspecs.precision < num_zeros) {
    num_zeros = fspecs.precision;
  }
  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
  return write_padded<align::right>(out, specs, size, [&](iterator it) {
    if (sign) *it++ = detail::sign<Char>(sign);
    *it++ = zero;
    if (!pointy) return it;
    *it++ = decimal_point;
    it = detail::fill_n(it, num_zeros, zero);
    return write_significand<Char>(it, significand, significand_size);
  });
}

template <typename Char> class fallback_digit_grouping {
 public:
  constexpr fallback_digit_grouping(locale_ref, bool) {}

  constexpr Char separator() const { return Char(); }

  constexpr int count_separators(int) const { return 0; }

  template <typename Out, typename C>
  constexpr Out apply(Out out, basic_string_view<C>) const {
    return out;
  }
};

template <typename OutputIt, typename DecimalFP, typename Char>
FMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& fp,
                                 const basic_format_specs<Char>& specs,
                                 float_specs fspecs, locale_ref loc)
    -> OutputIt {
  if (is_constant_evaluated()) {
    return do_write_float<OutputIt, DecimalFP, Char,
                          fallback_digit_grouping<Char>>(out, fp, specs, fspecs,
                                                         loc);
  } else {
    return do_write_float(out, fp, specs, fspecs, loc);
  }
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR20 bool isinf(T value) {
  if (is_constant_evaluated()) {
#if defined(__cpp_if_constexpr)
    if constexpr (std::numeric_limits<double>::is_iec559) {
      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
      constexpr auto significand_bits =
          dragonbox::float_info<double>::significand_bits;
      return (bits & exponent_mask<double>()) &&
             !(bits & ((uint64_t(1) << significand_bits) - 1));
    }
#endif
  }
  return std::isinf(value);
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR20 bool isfinite(T value) {
  if (is_constant_evaluated()) {
#if defined(__cpp_if_constexpr)
    if constexpr (std::numeric_limits<double>::is_iec559) {
      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
      return (bits & exponent_mask<double>()) != exponent_mask<double>();
    }
#endif
  }
  return std::isfinite(value);
}

template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
  if (is_constant_evaluated()) {
#ifdef __cpp_if_constexpr
    if constexpr (std::numeric_limits<double>::is_iec559) {
      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
      return (bits & (uint64_t(1) << (num_bits<uint64_t>() - 1))) != 0;
    }
#endif
  }
  return std::signbit(value);
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_floating_point<T>::value)>
FMT_CONSTEXPR20 auto write(OutputIt out, T value,
                           basic_format_specs<Char> specs, locale_ref loc = {})
    -> OutputIt {
  if (const_check(!is_supported_floating_point(value))) return out;
  float_specs fspecs = parse_float_type_spec(specs);
  fspecs.sign = specs.sign;
  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
    fspecs.sign = sign::minus;
    value = -value;
  } else if (fspecs.sign == sign::minus) {
    fspecs.sign = sign::none;
  }

  if (!detail::isfinite(value))
    return write_nonfinite(out, detail::isinf(value), specs, fspecs);

  if (specs.align == align::numeric && fspecs.sign) {
    auto it = reserve(out, 1);
    *it++ = detail::sign<Char>(fspecs.sign);
    out = base_iterator(out, it);
    fspecs.sign = sign::none;
    if (specs.width != 0) --specs.width;
  }

  memory_buffer buffer;
  if (fspecs.format == float_format::hex) {
    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
    snprintf_float(promote_float(value), specs.precision, fspecs, buffer);
    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
                                     specs);
  }
  int precision = specs.precision >= 0 || specs.type == presentation_type::none
                      ? specs.precision
                      : 6;
  if (fspecs.format == float_format::exp) {
    if (precision == max_value<int>())
      throw_format_error("number is too big");
    else
      ++precision;
  }
  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
  if (!is_fast_float<T>()) fspecs.fallback = true;
  int exp = format_float(promote_float(value), precision, fspecs, buffer);
  fspecs.precision = precision;
  auto fp = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
  return write_float(out, fp, specs, fspecs, loc);
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_fast_float<T>::value)>
FMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {
  if (is_constant_evaluated()) {
    return write(out, value, basic_format_specs<Char>());
  }

  if (const_check(!is_supported_floating_point(value))) return out;

  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;
  using uint = typename dragonbox::float_info<floaty>::carrier_uint;
  auto bits = bit_cast<uint>(value);

  auto fspecs = float_specs();
  if (detail::signbit(value)) {
    fspecs.sign = sign::minus;
    value = -value;
  }

  constexpr auto specs = basic_format_specs<Char>();
  uint mask = exponent_mask<floaty>();
  if ((bits & mask) == mask)
    return write_nonfinite(out, std::isinf(value), specs, fspecs);

  auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
  return write_float(out, dec, specs, fspecs, {});
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_floating_point<T>::value &&
                        !is_fast_float<T>::value)>
inline auto write(OutputIt out, T value) -> OutputIt {
  return write(out, value, basic_format_specs<Char>());
}

template <typename Char, typename OutputIt>
auto write(OutputIt out, monostate, basic_format_specs<Char> = {},
           locale_ref = {}) -> OutputIt {
  FMT_ASSERT(false, "");
  return out;
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> value)
    -> OutputIt {
  auto it = reserve(out, value.size());
  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
  return base_iterator(out, it);
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_string<T>::value)>
constexpr auto write(OutputIt out, const T& value) -> OutputIt {
  return write<Char>(out, to_string_view(value));
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(is_integral<T>::value &&
                        !std::is_same<T, bool>::value &&
                        !std::is_same<T, Char>::value)>
FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
  bool negative = is_negative(value);
  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
  if (negative) abs_value = ~abs_value + 1;
  int num_digits = count_digits(abs_value);
  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
  auto it = reserve(out, size);
  if (auto ptr = to_pointer<Char>(it, size)) {
    if (negative) *ptr++ = static_cast<Char>('-');
    format_decimal<Char>(ptr, abs_value, num_digits);
    return out;
  }
  if (negative) *it++ = static_cast<Char>('-');
  it = format_decimal<Char>(it, abs_value, num_digits).end;
  return base_iterator(out, it);
}

// FMT_ENABLE_IF() condition separated to workaround an MSVC bug.
template <
    typename Char, typename OutputIt, typename T,
    bool check =
        std::is_enum<T>::value && !std::is_same<T, Char>::value &&
        mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=
            type::custom_type,
    FMT_ENABLE_IF(check)>
FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
  return write<Char>(
      out, static_cast<typename std::underlying_type<T>::type>(value));
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_same<T, bool>::value)>
FMT_CONSTEXPR auto write(OutputIt out, T value,
                         const basic_format_specs<Char>& specs = {},
                         locale_ref = {}) -> OutputIt {
  return specs.type != presentation_type::none &&
                 specs.type != presentation_type::string
             ? write(out, value ? 1 : 0, specs, {})
             : write_bytes(out, value ? "true" : "false", specs);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR auto write(OutputIt out, Char value) -> OutputIt {
  auto it = reserve(out, 1);
  *it++ = value;
  return base_iterator(out, it);
}

template <typename Char, typename OutputIt>
FMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)
    -> OutputIt {
  if (!value) {
    throw_format_error("string pointer is null");
  } else {
    out = write(out, basic_string_view<Char>(value));
  }
  return out;
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_same<T, void>::value)>
auto write(OutputIt out, const T* value,
           const basic_format_specs<Char>& specs = {}, locale_ref = {})
    -> OutputIt {
  check_pointer_type_spec(specs.type, error_handler());
  return write_ptr<Char>(out, to_uintptr(value), &specs);
}

// A write overload that handles implicit conversions.
template <typename Char, typename OutputIt, typename T,
          typename Context = basic_format_context<OutputIt, Char>>
FMT_CONSTEXPR auto write(OutputIt out, const T& value) -> enable_if_t<
    std::is_class<T>::value && !is_string<T>::value &&
        !std::is_same<T, Char>::value &&
        !std::is_same<const T&,
                      decltype(arg_mapper<Context>().map(value))>::value,
    OutputIt> {
  return write<Char>(out, arg_mapper<Context>().map(value));
}

template <typename Char, typename OutputIt, typename T,
          typename Context = basic_format_context<OutputIt, Char>>
FMT_CONSTEXPR auto write(OutputIt out, const T& value)
    -> enable_if_t<mapped_type_constant<T, Context>::value == type::custom_type,
                   OutputIt> {
  using formatter_type =
      conditional_t<has_formatter<T, Context>::value,
                    typename Context::template formatter_type<T>,
                    fallback_formatter<T, Char>>;
  auto ctx = Context(out, {}, {});
  return formatter_type().format(value, ctx);
}

// An argument visitor that formats the argument and writes it via the output
// iterator. It's a class and not a generic lambda for compatibility with C++11.
template <typename Char> struct default_arg_formatter {
  using iterator = buffer_appender<Char>;
  using context = buffer_context<Char>;

  iterator out;
  basic_format_args<context> args;
  locale_ref loc;

  template <typename T> auto operator()(T value) -> iterator {
    return write<Char>(out, value);
  }
  auto operator()(typename basic_format_arg<context>::handle h) -> iterator {
    basic_format_parse_context<Char> parse_ctx({});
    context format_ctx(out, args, loc);
    h.format(parse_ctx, format_ctx);
    return format_ctx.out();
  }
};

template <typename Char> struct arg_formatter {
  using iterator = buffer_appender<Char>;
  using context = buffer_context<Char>;

  iterator out;
  const basic_format_specs<Char>& specs;
  locale_ref locale;

  template <typename T>
  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
    return detail::write(out, value, specs, locale);
  }
  auto operator()(typename basic_format_arg<context>::handle) -> iterator {
    // User-defined types are handled separately because they require access
    // to the parse context.
    return out;
  }
};

template <typename Char> struct custom_formatter {
  basic_format_parse_context<Char>& parse_ctx;
  buffer_context<Char>& ctx;

  void operator()(
      typename basic_format_arg<buffer_context<Char>>::handle h) const {
    h.format(parse_ctx, ctx);
  }
  template <typename T> void operator()(T) const {}
};

template <typename T>
using is_integer =
    bool_constant<is_integral<T>::value && !std::is_same<T, bool>::value &&
                  !std::is_same<T, char>::value &&
                  !std::is_same<T, wchar_t>::value>;

template <typename ErrorHandler> class width_checker {
 public:
  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}

  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
    if (is_negative(value)) handler_.on_error("negative width");
    return static_cast<unsigned long long>(value);
  }

  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
    handler_.on_error("width is not integer");
    return 0;
  }

 private:
  ErrorHandler& handler_;
};

template <typename ErrorHandler> class precision_checker {
 public:
  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}

  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
    if (is_negative(value)) handler_.on_error("negative precision");
    return static_cast<unsigned long long>(value);
  }

  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
    handler_.on_error("precision is not integer");
    return 0;
  }

 private:
  ErrorHandler& handler_;
};

template <template <typename> class Handler, typename FormatArg,
          typename ErrorHandler>
FMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg, ErrorHandler eh) -> int {
  unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);
  if (value > to_unsigned(max_value<int>())) eh.on_error("number is too big");
  return static_cast<int>(value);
}

template <typename Context, typename ID>
FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) ->
    typename Context::format_arg {
  auto arg = ctx.arg(id);
  if (!arg) ctx.on_error("argument not found");
  return arg;
}

// The standard format specifier handler with checking.
template <typename Char> class specs_handler : public specs_setter<Char> {
 private:
  basic_format_parse_context<Char>& parse_context_;
  buffer_context<Char>& context_;

  // This is only needed for compatibility with gcc 4.4.
  using format_arg = basic_format_arg<buffer_context<Char>>;

  FMT_CONSTEXPR auto get_arg(auto_id) -> format_arg {
    return detail::get_arg(context_, parse_context_.next_arg_id());
  }

  FMT_CONSTEXPR auto get_arg(int arg_id) -> format_arg {
    parse_context_.check_arg_id(arg_id);
    return detail::get_arg(context_, arg_id);
  }

  FMT_CONSTEXPR auto get_arg(basic_string_view<Char> arg_id) -> format_arg {
    parse_context_.check_arg_id(arg_id);
    return detail::get_arg(context_, arg_id);
  }

 public:
  FMT_CONSTEXPR specs_handler(basic_format_specs<Char>& specs,
                              basic_format_parse_context<Char>& parse_ctx,
                              buffer_context<Char>& ctx)
      : specs_setter<Char>(specs), parse_context_(parse_ctx), context_(ctx) {}

  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
    this->specs_.width = get_dynamic_spec<width_checker>(
        get_arg(arg_id), context_.error_handler());
  }

  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
    this->specs_.precision = get_dynamic_spec<precision_checker>(
        get_arg(arg_id), context_.error_handler());
  }

  void on_error(const char* message) { context_.on_error(message); }
};

template <template <typename> class Handler, typename Context>
FMT_CONSTEXPR void handle_dynamic_spec(int& value,
                                       arg_ref<typename Context::char_type> ref,
                                       Context& ctx) {
  switch (ref.kind) {
  case arg_id_kind::none:
    break;
  case arg_id_kind::index:
    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.index),
                                              ctx.error_handler());
    break;
  case arg_id_kind::name:
    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.name),
                                              ctx.error_handler());
    break;
  }
}

#define FMT_STRING_IMPL(s, base, explicit)                                 \
  [] {                                                                     \
    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */ \
    /* Use a macro-like name to avoid shadowing warnings. */               \
    struct FMT_GCC_VISIBILITY_HIDDEN FMT_COMPILE_STRING : base {           \
      using char_type = fmt::remove_cvref_t<decltype(s[0])>;               \
      FMT_MAYBE_UNUSED FMT_CONSTEXPR explicit                              \
      operator fmt::basic_string_view<char_type>() const {                 \
        return fmt::detail_exported::compile_string_to_view<char_type>(s); \
      }                                                                    \
    };                                                                     \
    return FMT_COMPILE_STRING();                                           \
  }()

/**
  \rst
  Constructs a compile-time format string from a string literal *s*.

  **Example**::

    // A compile-time error because 'd' is an invalid specifier for strings.
    std::string s = fmt::format(FMT_STRING("{:d}"), "foo");
  \endrst
 */
#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::compile_string, )

#if FMT_USE_USER_DEFINED_LITERALS
template <typename Char> struct udl_formatter {
  basic_string_view<Char> str;

  template <typename... T>
  auto operator()(T&&... args) const -> std::basic_string<Char> {
    return vformat(str, fmt::make_args_checked<T...>(str, args...));
  }
};

#  if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <typename T, typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct statically_named_arg : view {
  static constexpr auto name = Str.data;

  const T& value;
  statically_named_arg(const T& v) : value(v) {}
};

template <typename T, typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct is_named_arg<statically_named_arg<T, Char, N, Str>> : std::true_type {};

template <typename T, typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct is_statically_named_arg<statically_named_arg<T, Char, N, Str>>
    : std::true_type {};

template <typename Char, size_t N,
          fmt::detail_exported::fixed_string<Char, N> Str>
struct udl_arg {
  template <typename T> auto operator=(T&& value) const {
    return statically_named_arg<T, Char, N, Str>(std::forward<T>(value));
  }
};
#  else
template <typename Char> struct udl_arg {
  const Char* str;

  template <typename T> auto operator=(T&& value) const -> named_arg<Char, T> {
    return {str, std::forward<T>(value)};
  }
};
#  endif
#endif  // FMT_USE_USER_DEFINED_LITERALS

template <typename Locale, typename Char>
auto vformat(const Locale& loc, basic_string_view<Char> format_str,
             basic_format_args<buffer_context<type_identity_t<Char>>> args)
    -> std::basic_string<Char> {
  basic_memory_buffer<Char> buffer;
  detail::vformat_to(buffer, format_str, args, detail::locale_ref(loc));
  return {buffer.data(), buffer.size()};
}

using format_func = void (*)(detail::buffer<char>&, int, const char*);

FMT_API void format_error_code(buffer<char>& out, int error_code,
                               string_view message) FMT_NOEXCEPT;

FMT_API void report_error(format_func func, int error_code,
                          const char* message) FMT_NOEXCEPT;
FMT_END_DETAIL_NAMESPACE

FMT_API auto vsystem_error(int error_code, string_view format_str,
                           format_args args) -> std::system_error;

/**
 \rst
 Constructs :class:`std::system_error` with a message formatted with
 ``fmt::format(fmt, args...)``.
  *error_code* is a system error code as given by ``errno``.

 **Example**::

   // This throws std::system_error with the description
   //   cannot open file 'madeup': No such file or directory
   // or similar (system message may vary).
   const char* filename = "madeup";
   std::FILE* file = std::fopen(filename, "r");
   if (!file)
     throw fmt::system_error(errno, "cannot open file '{}'", filename);
 \endrst
*/
template <typename... T>
auto system_error(int error_code, format_string<T...> fmt, T&&... args)
    -> std::system_error {
  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));
}

/**
  \rst
  Formats an error message for an error returned by an operating system or a
  language runtime, for example a file opening error, and writes it to *out*.
  The format is the same as the one used by ``std::system_error(ec, message)``
  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
  It is implementation-defined but normally looks like:

  .. parsed-literal::
     *<message>*: *<system-message>*

  where *<message>* is the passed message and *<system-message>* is the system
  message corresponding to the error code.
  *error_code* is a system error code as given by ``errno``.
  \endrst
 */
FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
                                 const char* message) FMT_NOEXCEPT;

// Reports a system error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_system_error(int error_code,
                                 const char* message) FMT_NOEXCEPT;

/** Fast integer formatter. */
class format_int {
 private:
  // Buffer should be large enough to hold all digits (digits10 + 1),
  // a sign and a null character.
  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
  mutable char buffer_[buffer_size];
  char* str_;

  template <typename UInt> auto format_unsigned(UInt value) -> char* {
    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
    return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
  }

  template <typename Int> auto format_signed(Int value) -> char* {
    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
    bool negative = value < 0;
    if (negative) abs_value = 0 - abs_value;
    auto begin = format_unsigned(abs_value);
    if (negative) *--begin = '-';
    return begin;
  }

 public:
  explicit format_int(int value) : str_(format_signed(value)) {}
  explicit format_int(long value) : str_(format_signed(value)) {}
  explicit format_int(long long value) : str_(format_signed(value)) {}
  explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
  explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
  explicit format_int(unsigned long long value)
      : str_(format_unsigned(value)) {}

  /** Returns the number of characters written to the output buffer. */
  auto size() const -> size_t {
    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
  }

  /**
    Returns a pointer to the output buffer content. No terminating null
    character is appended.
   */
  auto data() const -> const char* { return str_; }

  /**
    Returns a pointer to the output buffer content with terminating null
    character appended.
   */
  auto c_str() const -> const char* {
    buffer_[buffer_size - 1] = '\0';
    return str_;
  }

  /**
    \rst
    Returns the content of the output buffer as an ``std::string``.
    \endrst
   */
  auto str() const -> std::string { return std::string(str_, size()); }
};

template <typename T, typename Char>
template <typename FormatContext>
FMT_CONSTEXPR FMT_INLINE auto
formatter<T, Char,
          enable_if_t<detail::type_constant<T, Char>::value !=
                      detail::type::custom_type>>::format(const T& val,
                                                          FormatContext& ctx)
    const -> decltype(ctx.out()) {
  if (specs_.width_ref.kind != detail::arg_id_kind::none ||
      specs_.precision_ref.kind != detail::arg_id_kind::none) {
    auto specs = specs_;
    detail::handle_dynamic_spec<detail::width_checker>(specs.width,
                                                       specs.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs.precision, specs.precision_ref, ctx);
    return detail::write<Char>(ctx.out(), val, specs, ctx.locale());
  }
  return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
}

#define FMT_FORMAT_AS(Type, Base)                                        \
  template <typename Char>                                               \
  struct formatter<Type, Char> : formatter<Base, Char> {                 \
    template <typename FormatContext>                                    \
    auto format(Type const& val, FormatContext& ctx) const               \
        -> decltype(ctx.out()) {                                         \
      return formatter<Base, Char>::format(static_cast<Base>(val), ctx); \
    }                                                                    \
  }

FMT_FORMAT_AS(signed char, int);
FMT_FORMAT_AS(unsigned char, unsigned);
FMT_FORMAT_AS(short, int);
FMT_FORMAT_AS(unsigned short, unsigned);
FMT_FORMAT_AS(long, long long);
FMT_FORMAT_AS(unsigned long, unsigned long long);
FMT_FORMAT_AS(Char*, const Char*);
FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
FMT_FORMAT_AS(std::nullptr_t, const void*);
FMT_FORMAT_AS(detail::byte, unsigned char);
FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);

template <typename Char>
struct formatter<void*, Char> : formatter<const void*, Char> {
  template <typename FormatContext>
  auto format(void* val, FormatContext& ctx) const -> decltype(ctx.out()) {
    return formatter<const void*, Char>::format(val, ctx);
  }
};

template <typename Char, size_t N>
struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {
  template <typename FormatContext>
  FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const
      -> decltype(ctx.out()) {
    return formatter<basic_string_view<Char>, Char>::format(val, ctx);
  }
};

// A formatter for types known only at run time such as variant alternatives.
//
// Usage:
//   using variant = std::variant<int, std::string>;
//   template <>
//   struct formatter<variant>: dynamic_formatter<> {
//     auto format(const variant& v, format_context& ctx) {
//       return visit([&](const auto& val) {
//           return dynamic_formatter<>::format(val, ctx);
//       }, v);
//     }
//   };
template <typename Char = char> class dynamic_formatter {
 private:
  detail::dynamic_format_specs<Char> specs_;
  const Char* format_str_;

  struct null_handler : detail::error_handler {
    void on_align(align_t) {}
    void on_sign(sign_t) {}
    void on_hash() {}
  };

  template <typename Context> void handle_specs(Context& ctx) {
    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
                                                       specs_.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs_.precision, specs_.precision_ref, ctx);
  }

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    format_str_ = ctx.begin();
    // Checks are deferred to formatting time when the argument type is known.
    detail::dynamic_specs_handler<ParseContext> handler(specs_, ctx);
    return detail::parse_format_specs(ctx.begin(), ctx.end(), handler);
  }

  template <typename T, typename FormatContext>
  auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {
    handle_specs(ctx);
    detail::specs_checker<null_handler> checker(
        null_handler(), detail::mapped_type_constant<T, FormatContext>::value);
    checker.on_align(specs_.align);
    if (specs_.sign != sign::none) checker.on_sign(specs_.sign);
    if (specs_.alt) checker.on_hash();
    if (specs_.precision >= 0) checker.end_precision();
    return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
  }
};

/**
  \rst
  Converts ``p`` to ``const void*`` for pointer formatting.

  **Example**::

    auto s = fmt::format("{}", fmt::ptr(p));
  \endrst
 */
template <typename T> auto ptr(T p) -> const void* {
  static_assert(std::is_pointer<T>::value, "");
  return detail::bit_cast<const void*>(p);
}
template <typename T> auto ptr(const std::unique_ptr<T>& p) -> const void* {
  return p.get();
}
template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
  return p.get();
}

class bytes {
 private:
  string_view data_;
  friend struct formatter<bytes>;

 public:
  explicit bytes(string_view data) : data_(data) {}
};

template <> struct formatter<bytes> {
 private:
  detail::dynamic_format_specs<char> specs_;

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    using handler_type = detail::dynamic_specs_handler<ParseContext>;
    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
                                                detail::type::string_type);
    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
    detail::check_string_type_spec(specs_.type, ctx.error_handler());
    return it;
  }

  template <typename FormatContext>
  auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {
    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
                                                       specs_.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs_.precision, specs_.precision_ref, ctx);
    return detail::write_bytes(ctx.out(), b.data_, specs_);
  }
};

// group_digits_view is not derived from view because it copies the argument.
template <typename T> struct group_digits_view { T value; };

/**
  \rst
  Returns a view that formats an integer value using ',' as a locale-independent
  thousands separator.

  **Example**::

    fmt::print("{}", fmt::group_digits(12345));
    // Output: "12,345"
  \endrst
 */
template <typename T> auto group_digits(T value) -> group_digits_view<T> {
  return {value};
}

template <typename T> struct formatter<group_digits_view<T>> : formatter<T> {
 private:
  detail::dynamic_format_specs<char> specs_;

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    using handler_type = detail::dynamic_specs_handler<ParseContext>;
    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
                                                detail::type::int_type);
    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
    detail::check_string_type_spec(specs_.type, ctx.error_handler());
    return it;
  }

  template <typename FormatContext>
  auto format(group_digits_view<T> t, FormatContext& ctx)
      -> decltype(ctx.out()) {
    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
                                                       specs_.width_ref, ctx);
    detail::handle_dynamic_spec<detail::precision_checker>(
        specs_.precision, specs_.precision_ref, ctx);
    return detail::write_int_localized(
        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(t.value), 0, specs_,
        detail::digit_grouping<char>({"\3", ','}));
  }
};

template <typename It, typename Sentinel, typename Char = char>
struct join_view : detail::view {
  It begin;
  Sentinel end;
  basic_string_view<Char> sep;

  join_view(It b, Sentinel e, basic_string_view<Char> s)
      : begin(b), end(e), sep(s) {}
};

template <typename It, typename Sentinel, typename Char>
using arg_join FMT_DEPRECATED_ALIAS = join_view<It, Sentinel, Char>;

template <typename It, typename Sentinel, typename Char>
struct formatter<join_view<It, Sentinel, Char>, Char> {
 private:
  using value_type =
#ifdef __cpp_lib_ranges
      std::iter_value_t<It>;
#else
      typename std::iterator_traits<It>::value_type;
#endif
  using context = buffer_context<Char>;
  using mapper = detail::arg_mapper<context>;

  template <typename T, FMT_ENABLE_IF(has_formatter<T, context>::value)>
  static auto map(const T& value) -> const T& {
    return value;
  }
  template <typename T, FMT_ENABLE_IF(!has_formatter<T, context>::value)>
  static auto map(const T& value) -> decltype(mapper().map(value)) {
    return mapper().map(value);
  }

  using formatter_type =
      conditional_t<is_formattable<value_type, Char>::value,
                    formatter<remove_cvref_t<decltype(map(
                                  std::declval<const value_type&>()))>,
                              Char>,
                    detail::fallback_formatter<value_type, Char>>;

  formatter_type value_formatter_;

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return value_formatter_.parse(ctx);
  }

  template <typename FormatContext>
  auto format(const join_view<It, Sentinel, Char>& value, FormatContext& ctx)
      -> decltype(ctx.out()) {
    auto it = value.begin;
    auto out = ctx.out();
    if (it != value.end) {
      out = value_formatter_.format(map(*it), ctx);
      ++it;
      while (it != value.end) {
        out = detail::copy_str<Char>(value.sep.begin(), value.sep.end(), out);
        ctx.advance_to(out);
        out = value_formatter_.format(map(*it), ctx);
        ++it;
      }
    }
    return out;
  }
};

/**
  Returns a view that formats the iterator range `[begin, end)` with elements
  separated by `sep`.
 */
template <typename It, typename Sentinel>
auto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {
  return {begin, end, sep};
}

/**
  \rst
  Returns a view that formats `range` with elements separated by `sep`.

  **Example**::

    std::vector<int> v = {1, 2, 3};
    fmt::print("{}", fmt::join(v, ", "));
    // Output: "1, 2, 3"

  ``fmt::join`` applies passed format specifiers to the range elements::

    fmt::print("{:02}", fmt::join(v, ", "));
    // Output: "01, 02, 03"
  \endrst
 */
template <typename Range>
auto join(Range&& range, string_view sep)
    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>> {
  return join(std::begin(range), std::end(range), sep);
}

/**
  \rst
  Converts *value* to ``std::string`` using the default format for type *T*.

  **Example**::

    #include <fmt/format.h>

    std::string answer = fmt::to_string(42);
  \endrst
 */
template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
inline auto to_string(const T& value) -> std::string {
  auto result = std::string();
  detail::write<char>(std::back_inserter(result), value);
  return result;
}

template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
FMT_NODISCARD inline auto to_string(T value) -> std::string {
  // The buffer should be large enough to store the number including the sign
  // or "false" for bool.
  constexpr int max_size = detail::digits10<T>() + 2;
  char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];
  char* begin = buffer;
  return std::string(begin, detail::write<char>(begin, value));
}

template <typename Char, size_t SIZE>
FMT_NODISCARD auto to_string(const basic_memory_buffer<Char, SIZE>& buf)
    -> std::basic_string<Char> {
  auto size = buf.size();
  detail::assume(size < std::basic_string<Char>().max_size());
  return std::basic_string<Char>(buf.data(), size);
}

FMT_BEGIN_DETAIL_NAMESPACE

template <typename Char>
void vformat_to(
    buffer<Char>& buf, basic_string_view<Char> fmt,
    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
    locale_ref loc) {
  // workaround for msvc bug regarding name-lookup in module
  // link names into function scope
  using detail::arg_formatter;
  using detail::buffer_appender;
  using detail::custom_formatter;
  using detail::default_arg_formatter;
  using detail::get_arg;
  using detail::locale_ref;
  using detail::parse_format_specs;
  using detail::specs_checker;
  using detail::specs_handler;
  using detail::to_unsigned;
  using detail::type;
  using detail::write;
  auto out = buffer_appender<Char>(buf);
  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
    auto arg = args.get(0);
    if (!arg) error_handler().on_error("argument not found");
    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
    return;
  }

  struct format_handler : error_handler {
    basic_format_parse_context<Char> parse_context;
    buffer_context<Char> context;

    format_handler(buffer_appender<Char> out, basic_string_view<Char> str,
                   basic_format_args<buffer_context<Char>> args, locale_ref loc)
        : parse_context(str), context(out, args, loc) {}

    void on_text(const Char* begin, const Char* end) {
      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
      context.advance_to(write<Char>(context.out(), text));
    }

    FMT_CONSTEXPR auto on_arg_id() -> int {
      return parse_context.next_arg_id();
    }
    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
      return parse_context.check_arg_id(id), id;
    }
    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
      int arg_id = context.arg_id(id);
      if (arg_id < 0) on_error("argument not found");
      return arg_id;
    }

    FMT_INLINE void on_replacement_field(int id, const Char*) {
      auto arg = get_arg(context, id);
      context.advance_to(visit_format_arg(
          default_arg_formatter<Char>{context.out(), context.args(),
                                      context.locale()},
          arg));
    }

    auto on_format_specs(int id, const Char* begin, const Char* end)
        -> const Char* {
      auto arg = get_arg(context, id);
      if (arg.type() == type::custom_type) {
        parse_context.advance_to(parse_context.begin() +
                                 (begin - &*parse_context.begin()));
        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
        return parse_context.begin();
      }
      auto specs = basic_format_specs<Char>();
      specs_checker<specs_handler<Char>> handler(
          specs_handler<Char>(specs, parse_context, context), arg.type());
      begin = parse_format_specs(begin, end, handler);
      if (begin == end || *begin != '}')
        on_error("missing '}' in format string");
      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
      context.advance_to(visit_format_arg(f, arg));
      return begin;
    }
  };
  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
}

#ifndef FMT_HEADER_ONLY
extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
    -> thousands_sep_result<char>;
extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
    -> thousands_sep_result<wchar_t>;
extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
extern template auto format_float<double>(double value, int precision,
                                          float_specs specs, buffer<char>& buf)
    -> int;
extern template auto format_float<long double>(long double value, int precision,
                                               float_specs specs,
                                               buffer<char>& buf) -> int;
void snprintf_float(float, int, float_specs, buffer<char>&) = delete;
extern template auto snprintf_float<double>(double value, int precision,
                                            float_specs specs,
                                            buffer<char>& buf) -> int;
extern template auto snprintf_float<long double>(long double value,
                                                 int precision,
                                                 float_specs specs,
                                                 buffer<char>& buf) -> int;
#endif  // FMT_HEADER_ONLY

FMT_END_DETAIL_NAMESPACE

#if FMT_USE_USER_DEFINED_LITERALS
inline namespace literals {
/**
  \rst
  User-defined literal equivalent of :func:`fmt::arg`.

  **Example**::

    using namespace fmt::literals;
    fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
  \endrst
 */
#  if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
template <detail_exported::fixed_string Str>
constexpr auto operator""_a()
    -> detail::udl_arg<remove_cvref_t<decltype(Str.data[0])>,
                       sizeof(Str.data) / sizeof(decltype(Str.data[0])), Str> {
  return {};
}
#  else
constexpr auto operator"" _a(const char* s, size_t) -> detail::udl_arg<char> {
  return {s};
}
#  endif

// DEPRECATED!
// User-defined literal equivalent of fmt::format.
FMT_DEPRECATED constexpr auto operator"" _format(const char* s, size_t n)
    -> detail::udl_formatter<char> {
  return {{s, n}};
}
}  // namespace literals
#endif  // FMT_USE_USER_DEFINED_LITERALS

template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
inline auto vformat(const Locale& loc, string_view fmt, format_args args)
    -> std::string {
  return detail::vformat(loc, fmt, args);
}

template <typename Locale, typename... T,
          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
    -> std::string {
  return vformat(loc, string_view(fmt), fmt::make_format_args(args...));
}

template <typename... T, size_t SIZE, typename Allocator>
FMT_DEPRECATED auto format_to(basic_memory_buffer<char, SIZE, Allocator>& buf,
                              format_string<T...> fmt, T&&... args)
    -> appender {
  detail::vformat_to(buf, string_view(fmt), fmt::make_format_args(args...));
  return appender(buf);
}

template <typename OutputIt, typename Locale,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
                            detail::is_locale<Locale>::value)>
auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
                format_args args) -> OutputIt {
  using detail::get_buffer;
  auto&& buf = get_buffer<char>(out);
  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
  return detail::get_iterator(buf);
}

template <typename OutputIt, typename Locale, typename... T,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
                            detail::is_locale<Locale>::value)>
FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
                          format_string<T...> fmt, T&&... args) -> OutputIt {
  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));
}

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#ifdef FMT_DEPRECATED_INCLUDE_XCHAR
#  include "xchar.h"
#endif

#ifdef FMT_HEADER_ONLY
#  define FMT_FUNC inline
#  include "format-inl.h"
#else
#  define FMT_FUNC
#endif

#endif  // FMT_FORMAT_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/locale.h`:

```h
#include "xchar.h"
#warning fmt/locale.h is deprecated, include fmt/format.h or fmt/xchar.h instead

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/os.h`:

```h
// Formatting library for C++ - optional OS-specific functionality
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_OS_H_
#define FMT_OS_H_

#include <cerrno>
#include <clocale>  // locale_t
#include <cstddef>
#include <cstdio>
#include <cstdlib>       // strtod_l
#include <system_error>  // std::system_error

#if defined __APPLE__ || defined(__FreeBSD__)
#  include <xlocale.h>  // for LC_NUMERIC_MASK on OS X
#endif

#include "format.h"

#ifndef FMT_USE_FCNTL
// UWP doesn't provide _pipe.
#  if FMT_HAS_INCLUDE("winapifamily.h")
#    include <winapifamily.h>
#  endif
#  if (FMT_HAS_INCLUDE(<fcntl.h>) || defined(__APPLE__) || \
       defined(__linux__)) &&                              \
      (!defined(WINAPI_FAMILY) ||                          \
       (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
#    include <fcntl.h>  // for O_RDONLY
#    define FMT_USE_FCNTL 1
#  else
#    define FMT_USE_FCNTL 0
#  endif
#endif

#ifndef FMT_POSIX
#  if defined(_WIN32) && !defined(__MINGW32__)
// Fix warnings about deprecated symbols.
#    define FMT_POSIX(call) _##call
#  else
#    define FMT_POSIX(call) call
#  endif
#endif

// Calls to system functions are wrapped in FMT_SYSTEM for testability.
#ifdef FMT_SYSTEM
#  define FMT_POSIX_CALL(call) FMT_SYSTEM(call)
#else
#  define FMT_SYSTEM(call) ::call
#  ifdef _WIN32
// Fix warnings about deprecated symbols.
#    define FMT_POSIX_CALL(call) ::_##call
#  else
#    define FMT_POSIX_CALL(call) ::call
#  endif
#endif

// Retries the expression while it evaluates to error_result and errno
// equals to EINTR.
#ifndef _WIN32
#  define FMT_RETRY_VAL(result, expression, error_result) \
    do {                                                  \
      (result) = (expression);                            \
    } while ((result) == (error_result) && errno == EINTR)
#else
#  define FMT_RETRY_VAL(result, expression, error_result) result = (expression)
#endif

#define FMT_RETRY(result, expression) FMT_RETRY_VAL(result, expression, -1)

FMT_BEGIN_NAMESPACE
FMT_MODULE_EXPORT_BEGIN

/**
  \rst
  A reference to a null-terminated string. It can be constructed from a C
  string or ``std::string``.

  You can use one of the following type aliases for common character types:

  +---------------+-----------------------------+
  | Type          | Definition                  |
  +===============+=============================+
  | cstring_view  | basic_cstring_view<char>    |
  +---------------+-----------------------------+
  | wcstring_view | basic_cstring_view<wchar_t> |
  +---------------+-----------------------------+

  This class is most useful as a parameter type to allow passing
  different types of strings to a function, for example::

    template <typename... Args>
    std::string format(cstring_view format_str, const Args & ... args);

    format("{}", 42);
    format(std::string("{}"), 42);
  \endrst
 */
template <typename Char> class basic_cstring_view {
 private:
  const Char* data_;

 public:
  /** Constructs a string reference object from a C string. */
  basic_cstring_view(const Char* s) : data_(s) {}

  /**
    \rst
    Constructs a string reference from an ``std::string`` object.
    \endrst
   */
  basic_cstring_view(const std::basic_string<Char>& s) : data_(s.c_str()) {}

  /** Returns the pointer to a C string. */
  const Char* c_str() const { return data_; }
};

using cstring_view = basic_cstring_view<char>;
using wcstring_view = basic_cstring_view<wchar_t>;

template <typename Char> struct formatter<std::error_code, Char> {
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return ctx.begin();
  }

  template <typename FormatContext>
  FMT_CONSTEXPR auto format(const std::error_code& ec, FormatContext& ctx) const
      -> decltype(ctx.out()) {
    auto out = ctx.out();
    out = detail::write_bytes(out, ec.category().name(),
                              basic_format_specs<Char>());
    out = detail::write<Char>(out, Char(':'));
    out = detail::write<Char>(out, ec.value());
    return out;
  }
};

#ifdef _WIN32
FMT_API const std::error_category& system_category() FMT_NOEXCEPT;

FMT_BEGIN_DETAIL_NAMESPACE
// A converter from UTF-16 to UTF-8.
// It is only provided for Windows since other systems support UTF-8 natively.
class utf16_to_utf8 {
 private:
  memory_buffer buffer_;

 public:
  utf16_to_utf8() {}
  FMT_API explicit utf16_to_utf8(basic_string_view<wchar_t> s);
  operator string_view() const { return string_view(&buffer_[0], size()); }
  size_t size() const { return buffer_.size() - 1; }
  const char* c_str() const { return &buffer_[0]; }
  std::string str() const { return std::string(&buffer_[0], size()); }

  // Performs conversion returning a system error code instead of
  // throwing exception on conversion error. This method may still throw
  // in case of memory allocation error.
  FMT_API int convert(basic_string_view<wchar_t> s);
};

FMT_API void format_windows_error(buffer<char>& out, int error_code,
                                  const char* message) FMT_NOEXCEPT;
FMT_END_DETAIL_NAMESPACE

FMT_API std::system_error vwindows_error(int error_code, string_view format_str,
                                         format_args args);

/**
 \rst
 Constructs a :class:`std::system_error` object with the description
 of the form

 .. parsed-literal::
   *<message>*: *<system-message>*

 where *<message>* is the formatted message and *<system-message>* is the
 system message corresponding to the error code.
 *error_code* is a Windows error code as given by ``GetLastError``.
 If *error_code* is not a valid error code such as -1, the system message
 will look like "error -1".

 **Example**::

   // This throws a system_error with the description
   //   cannot open file 'madeup': The system cannot find the file specified.
   // or similar (system message may vary).
   const char *filename = "madeup";
   LPOFSTRUCT of = LPOFSTRUCT();
   HFILE file = OpenFile(filename, &of, OF_READ);
   if (file == HFILE_ERROR) {
     throw fmt::windows_error(GetLastError(),
                              "cannot open file '{}'", filename);
   }
 \endrst
*/
template <typename... Args>
std::system_error windows_error(int error_code, string_view message,
                                const Args&... args) {
  return vwindows_error(error_code, message, fmt::make_format_args(args...));
}

// Reports a Windows error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_windows_error(int error_code,
                                  const char* message) FMT_NOEXCEPT;
#else
inline const std::error_category& system_category() FMT_NOEXCEPT {
  return std::system_category();
}
#endif  // _WIN32

// std::system is not available on some platforms such as iOS (#2248).
#ifdef __OSX__
template <typename S, typename... Args, typename Char = char_t<S>>
void say(const S& format_str, Args&&... args) {
  std::system(format("say \"{}\"", format(format_str, args...)).c_str());
}
#endif

// A buffered file.
class buffered_file {
 private:
  FILE* file_;

  friend class file;

  explicit buffered_file(FILE* f) : file_(f) {}

 public:
  buffered_file(const buffered_file&) = delete;
  void operator=(const buffered_file&) = delete;

  // Constructs a buffered_file object which doesn't represent any file.
  buffered_file() FMT_NOEXCEPT : file_(nullptr) {}

  // Destroys the object closing the file it represents if any.
  FMT_API ~buffered_file() FMT_NOEXCEPT;

 public:
  buffered_file(buffered_file&& other) FMT_NOEXCEPT : file_(other.file_) {
    other.file_ = nullptr;
  }

  buffered_file& operator=(buffered_file&& other) {
    close();
    file_ = other.file_;
    other.file_ = nullptr;
    return *this;
  }

  // Opens a file.
  FMT_API buffered_file(cstring_view filename, cstring_view mode);

  // Closes the file.
  FMT_API void close();

  // Returns the pointer to a FILE object representing this file.
  FILE* get() const FMT_NOEXCEPT { return file_; }

  // We place parentheses around fileno to workaround a bug in some versions
  // of MinGW that define fileno as a macro.
  FMT_API int(fileno)() const;

  void vprint(string_view format_str, format_args args) {
    fmt::vprint(file_, format_str, args);
  }

  template <typename... Args>
  inline void print(string_view format_str, const Args&... args) {
    vprint(format_str, fmt::make_format_args(args...));
  }
};

#if FMT_USE_FCNTL
// A file. Closed file is represented by a file object with descriptor -1.
// Methods that are not declared with FMT_NOEXCEPT may throw
// fmt::system_error in case of failure. Note that some errors such as
// closing the file multiple times will cause a crash on Windows rather
// than an exception. You can get standard behavior by overriding the
// invalid parameter handler with _set_invalid_parameter_handler.
class file {
 private:
  int fd_;  // File descriptor.

  // Constructs a file object with a given descriptor.
  explicit file(int fd) : fd_(fd) {}

 public:
  // Possible values for the oflag argument to the constructor.
  enum {
    RDONLY = FMT_POSIX(O_RDONLY),  // Open for reading only.
    WRONLY = FMT_POSIX(O_WRONLY),  // Open for writing only.
    RDWR = FMT_POSIX(O_RDWR),      // Open for reading and writing.
    CREATE = FMT_POSIX(O_CREAT),   // Create if the file doesn't exist.
    APPEND = FMT_POSIX(O_APPEND),  // Open in append mode.
    TRUNC = FMT_POSIX(O_TRUNC)     // Truncate the content of the file.
  };

  // Constructs a file object which doesn't represent any file.
  file() FMT_NOEXCEPT : fd_(-1) {}

  // Opens a file and constructs a file object representing this file.
  FMT_API file(cstring_view path, int oflag);

 public:
  file(const file&) = delete;
  void operator=(const file&) = delete;

  file(file&& other) FMT_NOEXCEPT : fd_(other.fd_) { other.fd_ = -1; }

  // Move assignment is not noexcept because close may throw.
  file& operator=(file&& other) {
    close();
    fd_ = other.fd_;
    other.fd_ = -1;
    return *this;
  }

  // Destroys the object closing the file it represents if any.
  FMT_API ~file() FMT_NOEXCEPT;

  // Returns the file descriptor.
  int descriptor() const FMT_NOEXCEPT { return fd_; }

  // Closes the file.
  FMT_API void close();

  // Returns the file size. The size has signed type for consistency with
  // stat::st_size.
  FMT_API long long size() const;

  // Attempts to read count bytes from the file into the specified buffer.
  FMT_API size_t read(void* buffer, size_t count);

  // Attempts to write count bytes from the specified buffer to the file.
  FMT_API size_t write(const void* buffer, size_t count);

  // Duplicates a file descriptor with the dup function and returns
  // the duplicate as a file object.
  FMT_API static file dup(int fd);

  // Makes fd be the copy of this file descriptor, closing fd first if
  // necessary.
  FMT_API void dup2(int fd);

  // Makes fd be the copy of this file descriptor, closing fd first if
  // necessary.
  FMT_API void dup2(int fd, std::error_code& ec) FMT_NOEXCEPT;

  // Creates a pipe setting up read_end and write_end file objects for reading
  // and writing respectively.
  FMT_API static void pipe(file& read_end, file& write_end);

  // Creates a buffered_file object associated with this file and detaches
  // this file object from the file.
  FMT_API buffered_file fdopen(const char* mode);
};

// Returns the memory page size.
long getpagesize();

FMT_BEGIN_DETAIL_NAMESPACE

struct buffer_size {
  buffer_size() = default;
  size_t value = 0;
  buffer_size operator=(size_t val) const {
    auto bs = buffer_size();
    bs.value = val;
    return bs;
  }
};

struct ostream_params {
  int oflag = file::WRONLY | file::CREATE | file::TRUNC;
  size_t buffer_size = BUFSIZ > 32768 ? BUFSIZ : 32768;

  ostream_params() {}

  template <typename... T>
  ostream_params(T... params, int new_oflag) : ostream_params(params...) {
    oflag = new_oflag;
  }

  template <typename... T>
  ostream_params(T... params, detail::buffer_size bs)
      : ostream_params(params...) {
    this->buffer_size = bs.value;
  }

// Intel has a bug that results in failure to deduce a constructor
// for empty parameter packs.
#  if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 2000
  ostream_params(int new_oflag) : oflag(new_oflag) {}
  ostream_params(detail::buffer_size bs) : buffer_size(bs.value) {}
#  endif
};

FMT_END_DETAIL_NAMESPACE

// Added {} below to work around default constructor error known to
// occur in Xcode versions 7.2.1 and 8.2.1.
constexpr detail::buffer_size buffer_size{};

/** A fast output stream which is not thread-safe. */
class FMT_API ostream final : private detail::buffer<char> {
 private:
  file file_;

  void grow(size_t) override;

  ostream(cstring_view path, const detail::ostream_params& params)
      : file_(path, params.oflag) {
    set(new char[params.buffer_size], params.buffer_size);
  }

 public:
  ostream(ostream&& other)
      : detail::buffer<char>(other.data(), other.size(), other.capacity()),
        file_(std::move(other.file_)) {
    other.clear();
    other.set(nullptr, 0);
  }
  ~ostream() {
    flush();
    delete[] data();
  }

  void flush() {
    if (size() == 0) return;
    file_.write(data(), size());
    clear();
  }

  template <typename... T>
  friend ostream output_file(cstring_view path, T... params);

  void close() {
    flush();
    file_.close();
  }

  /**
    Formats ``args`` according to specifications in ``fmt`` and writes the
    output to the file.
   */
  template <typename... T> void print(format_string<T...> fmt, T&&... args) {
    vformat_to(detail::buffer_appender<char>(*this), fmt,
               fmt::make_format_args(args...));
  }
};

/**
  \rst
  Opens a file for writing. Supported parameters passed in *params*:

  * ``<integer>``: Flags passed to `open
    <https://pubs.opengroup.org/onlinepubs/007904875/functions/open.html>`_
    (``file::WRONLY | file::CREATE`` by default)
  * ``buffer_size=<integer>``: Output buffer size

  **Example**::

    auto out = fmt::output_file("guide.txt");
    out.print("Don't {}", "Panic");
  \endrst
 */
template <typename... T>
inline ostream output_file(cstring_view path, T... params) {
  return {path, detail::ostream_params(params...)};
}
#endif  // FMT_USE_FCNTL

#ifdef FMT_LOCALE
// A "C" numeric locale.
class locale {
 private:
#  ifdef _WIN32
  using locale_t = _locale_t;

  static void freelocale(locale_t loc) { _free_locale(loc); }

  static double strtod_l(const char* nptr, char** endptr, _locale_t loc) {
    return _strtod_l(nptr, endptr, loc);
  }
#  endif

  locale_t locale_;

 public:
  using type = locale_t;
  locale(const locale&) = delete;
  void operator=(const locale&) = delete;

  locale() {
#  ifndef _WIN32
    locale_ = FMT_SYSTEM(newlocale(LC_NUMERIC_MASK, "C", nullptr));
#  else
    locale_ = _create_locale(LC_NUMERIC, "C");
#  endif
    if (!locale_) FMT_THROW(system_error(errno, "cannot create locale"));
  }
  ~locale() { freelocale(locale_); }

  type get() const { return locale_; }

  // Converts string to floating-point number and advances str past the end
  // of the parsed input.
  FMT_DEPRECATED double strtod(const char*& str) const {
    char* end = nullptr;
    double result = strtod_l(str, &end, locale_);
    str = end;
    return result;
  }
};
using Locale FMT_DEPRECATED_ALIAS = locale;
#endif  // FMT_LOCALE
FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_OS_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/ostream.h`:

```h
// Formatting library for C++ - std::ostream support
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_OSTREAM_H_
#define FMT_OSTREAM_H_

#include <ostream>

#include "format.h"

FMT_BEGIN_NAMESPACE

template <typename OutputIt, typename Char> class basic_printf_context;

namespace detail {

// Checks if T has a user-defined operator<<.
template <typename T, typename Char, typename Enable = void>
class is_streamable {
 private:
  template <typename U>
  static auto test(int)
      -> bool_constant<sizeof(std::declval<std::basic_ostream<Char>&>()
                              << std::declval<U>()) != 0>;

  template <typename> static auto test(...) -> std::false_type;

  using result = decltype(test<T>(0));

 public:
  is_streamable() = default;

  static const bool value = result::value;
};

// Formatting of built-in types and arrays is intentionally disabled because
// it's handled by standard (non-ostream) formatters.
template <typename T, typename Char>
struct is_streamable<
    T, Char,
    enable_if_t<
        std::is_arithmetic<T>::value || std::is_array<T>::value ||
        std::is_pointer<T>::value || std::is_same<T, char8_type>::value ||
        std::is_same<T, std::basic_string<Char>>::value ||
        std::is_same<T, std_string_view<Char>>::value ||
        (std::is_convertible<T, int>::value && !std::is_enum<T>::value)>>
    : std::false_type {};

// Write the content of buf to os.
// It is a separate function rather than a part of vprint to simplify testing.
template <typename Char>
void write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {
  const Char* buf_data = buf.data();
  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;
  unsigned_streamsize size = buf.size();
  unsigned_streamsize max_size = to_unsigned(max_value<std::streamsize>());
  do {
    unsigned_streamsize n = size <= max_size ? size : max_size;
    os.write(buf_data, static_cast<std::streamsize>(n));
    buf_data += n;
    size -= n;
  } while (size != 0);
}

template <typename Char, typename T>
void format_value(buffer<Char>& buf, const T& value,
                  locale_ref loc = locale_ref()) {
  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
  auto&& output = std::basic_ostream<Char>(&format_buf);
#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
  if (loc) output.imbue(loc.get<std::locale>());
#endif
  output << value;
  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
  buf.try_resize(buf.size());
}

// Formats an object of type T that has an overloaded ostream operator<<.
template <typename T, typename Char>
struct fallback_formatter<T, Char, enable_if_t<is_streamable<T, Char>::value>>
    : private formatter<basic_string_view<Char>, Char> {
  using formatter<basic_string_view<Char>, Char>::parse;

  template <typename OutputIt>
  auto format(const T& value, basic_format_context<OutputIt, Char>& ctx)
      -> OutputIt {
    auto buffer = basic_memory_buffer<Char>();
    format_value(buffer, value, ctx.locale());
    return formatter<basic_string_view<Char>, Char>::format(
        {buffer.data(), buffer.size()}, ctx);
  }

  // DEPRECATED!
  template <typename OutputIt>
  auto format(const T& value, basic_printf_context<OutputIt, Char>& ctx)
      -> OutputIt {
    auto buffer = basic_memory_buffer<Char>();
    format_value(buffer, value, ctx.locale());
    return std::copy(buffer.begin(), buffer.end(), ctx.out());
  }
};
}  // namespace detail

FMT_MODULE_EXPORT
template <typename Char>
void vprint(std::basic_ostream<Char>& os, basic_string_view<Char> format_str,
            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
  auto buffer = basic_memory_buffer<Char>();
  detail::vformat_to(buffer, format_str, args);
  detail::write_buffer(os, buffer);
}

/**
  \rst
  Prints formatted data to the stream *os*.

  **Example**::

    fmt::print(cerr, "Don't {}!", "panic");
  \endrst
 */
FMT_MODULE_EXPORT
template <typename S, typename... Args,
          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
void print(std::basic_ostream<Char>& os, const S& format_str, Args&&... args) {
  vprint(os, to_string_view(format_str),
         fmt::make_args_checked<Args...>(format_str, args...));
}
FMT_END_NAMESPACE

#endif  // FMT_OSTREAM_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/posix.h`:

```h
#include "os.h"
#warning "fmt/posix.h is deprecated; use fmt/os.h instead"
```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/printf.h`:

```h
// Formatting library for C++ - legacy printf implementation
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_PRINTF_H_
#define FMT_PRINTF_H_

#include <algorithm>  // std::max
#include <limits>     // std::numeric_limits
#include <ostream>

#include "format.h"

FMT_BEGIN_NAMESPACE
FMT_MODULE_EXPORT_BEGIN

template <typename T> struct printf_formatter { printf_formatter() = delete; };

template <typename Char>
class basic_printf_parse_context : public basic_format_parse_context<Char> {
  using basic_format_parse_context<Char>::basic_format_parse_context;
};

template <typename OutputIt, typename Char> class basic_printf_context {
 private:
  OutputIt out_;
  basic_format_args<basic_printf_context> args_;

 public:
  using char_type = Char;
  using format_arg = basic_format_arg<basic_printf_context>;
  using parse_context_type = basic_printf_parse_context<Char>;
  template <typename T> using formatter_type = printf_formatter<T>;

  /**
    \rst
    Constructs a ``printf_context`` object. References to the arguments are
    stored in the context object so make sure they have appropriate lifetimes.
    \endrst
   */
  basic_printf_context(OutputIt out,
                       basic_format_args<basic_printf_context> args)
      : out_(out), args_(args) {}

  OutputIt out() { return out_; }
  void advance_to(OutputIt it) { out_ = it; }

  detail::locale_ref locale() { return {}; }

  format_arg arg(int id) const { return args_.get(id); }

  FMT_CONSTEXPR void on_error(const char* message) {
    detail::error_handler().on_error(message);
  }
};

FMT_BEGIN_DETAIL_NAMESPACE

// Checks if a value fits in int - used to avoid warnings about comparing
// signed and unsigned integers.
template <bool IsSigned> struct int_checker {
  template <typename T> static bool fits_in_int(T value) {
    unsigned max = max_value<int>();
    return value <= max;
  }
  static bool fits_in_int(bool) { return true; }
};

template <> struct int_checker<true> {
  template <typename T> static bool fits_in_int(T value) {
    return value >= (std::numeric_limits<int>::min)() &&
           value <= max_value<int>();
  }
  static bool fits_in_int(int) { return true; }
};

class printf_precision_handler {
 public:
  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
  int operator()(T value) {
    if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
      FMT_THROW(format_error("number is too big"));
    return (std::max)(static_cast<int>(value), 0);
  }

  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
  int operator()(T) {
    FMT_THROW(format_error("precision is not integer"));
    return 0;
  }
};

// An argument visitor that returns true iff arg is a zero integer.
class is_zero_int {
 public:
  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
  bool operator()(T value) {
    return value == 0;
  }

  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
  bool operator()(T) {
    return false;
  }
};

template <typename T> struct make_unsigned_or_bool : std::make_unsigned<T> {};

template <> struct make_unsigned_or_bool<bool> { using type = bool; };

template <typename T, typename Context> class arg_converter {
 private:
  using char_type = typename Context::char_type;

  basic_format_arg<Context>& arg_;
  char_type type_;

 public:
  arg_converter(basic_format_arg<Context>& arg, char_type type)
      : arg_(arg), type_(type) {}

  void operator()(bool value) {
    if (type_ != 's') operator()<bool>(value);
  }

  template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>
  void operator()(U value) {
    bool is_signed = type_ == 'd' || type_ == 'i';
    using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
    if (const_check(sizeof(target_type) <= sizeof(int))) {
      // Extra casts are used to silence warnings.
      if (is_signed) {
        arg_ = detail::make_arg<Context>(
            static_cast<int>(static_cast<target_type>(value)));
      } else {
        using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
        arg_ = detail::make_arg<Context>(
            static_cast<unsigned>(static_cast<unsigned_type>(value)));
      }
    } else {
      if (is_signed) {
        // glibc's printf doesn't sign extend arguments of smaller types:
        //   std::printf("%lld", -42);  // prints "4294967254"
        // but we don't have to do the same because it's a UB.
        arg_ = detail::make_arg<Context>(static_cast<long long>(value));
      } else {
        arg_ = detail::make_arg<Context>(
            static_cast<typename make_unsigned_or_bool<U>::type>(value));
      }
    }
  }

  template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>
  void operator()(U) {}  // No conversion needed for non-integral types.
};

// Converts an integer argument to T for printf, if T is an integral type.
// If T is void, the argument is converted to corresponding signed or unsigned
// type depending on the type specifier: 'd' and 'i' - signed, other -
// unsigned).
template <typename T, typename Context, typename Char>
void convert_arg(basic_format_arg<Context>& arg, Char type) {
  visit_format_arg(arg_converter<T, Context>(arg, type), arg);
}

// Converts an integer argument to char for printf.
template <typename Context> class char_converter {
 private:
  basic_format_arg<Context>& arg_;

 public:
  explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}

  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
  void operator()(T value) {
    arg_ = detail::make_arg<Context>(
        static_cast<typename Context::char_type>(value));
  }

  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
  void operator()(T) {}  // No conversion needed for non-integral types.
};

// An argument visitor that return a pointer to a C string if argument is a
// string or null otherwise.
template <typename Char> struct get_cstring {
  template <typename T> const Char* operator()(T) { return nullptr; }
  const Char* operator()(const Char* s) { return s; }
};

// Checks if an argument is a valid printf width specifier and sets
// left alignment if it is negative.
template <typename Char> class printf_width_handler {
 private:
  using format_specs = basic_format_specs<Char>;

  format_specs& specs_;

 public:
  explicit printf_width_handler(format_specs& specs) : specs_(specs) {}

  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
  unsigned operator()(T value) {
    auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
    if (detail::is_negative(value)) {
      specs_.align = align::left;
      width = 0 - width;
    }
    unsigned int_max = max_value<int>();
    if (width > int_max) FMT_THROW(format_error("number is too big"));
    return static_cast<unsigned>(width);
  }

  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
  unsigned operator()(T) {
    FMT_THROW(format_error("width is not integer"));
    return 0;
  }
};

// The ``printf`` argument formatter.
template <typename OutputIt, typename Char>
class printf_arg_formatter : public arg_formatter<Char> {
 private:
  using base = arg_formatter<Char>;
  using context_type = basic_printf_context<OutputIt, Char>;
  using format_specs = basic_format_specs<Char>;

  context_type& context_;

  OutputIt write_null_pointer(bool is_string = false) {
    auto s = this->specs;
    s.type = presentation_type::none;
    return write_bytes(this->out, is_string ? "(null)" : "(nil)", s);
  }

 public:
  printf_arg_formatter(OutputIt iter, format_specs& s, context_type& ctx)
      : base{iter, s, locale_ref()}, context_(ctx) {}

  OutputIt operator()(monostate value) { return base::operator()(value); }

  template <typename T, FMT_ENABLE_IF(detail::is_integral<T>::value)>
  OutputIt operator()(T value) {
    // MSVC2013 fails to compile separate overloads for bool and Char so use
    // std::is_same instead.
    if (std::is_same<T, Char>::value) {
      format_specs fmt_specs = this->specs;
      if (fmt_specs.type != presentation_type::none &&
          fmt_specs.type != presentation_type::chr) {
        return (*this)(static_cast<int>(value));
      }
      fmt_specs.sign = sign::none;
      fmt_specs.alt = false;
      fmt_specs.fill[0] = ' ';  // Ignore '0' flag for char types.
      // align::numeric needs to be overwritten here since the '0' flag is
      // ignored for non-numeric types
      if (fmt_specs.align == align::none || fmt_specs.align == align::numeric)
        fmt_specs.align = align::right;
      return write<Char>(this->out, static_cast<Char>(value), fmt_specs);
    }
    return base::operator()(value);
  }

  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
  OutputIt operator()(T value) {
    return base::operator()(value);
  }

  /** Formats a null-terminated C string. */
  OutputIt operator()(const char* value) {
    if (value) return base::operator()(value);
    return write_null_pointer(this->specs.type != presentation_type::pointer);
  }

  /** Formats a null-terminated wide C string. */
  OutputIt operator()(const wchar_t* value) {
    if (value) return base::operator()(value);
    return write_null_pointer(this->specs.type != presentation_type::pointer);
  }

  OutputIt operator()(basic_string_view<Char> value) {
    return base::operator()(value);
  }

  /** Formats a pointer. */
  OutputIt operator()(const void* value) {
    return value ? base::operator()(value) : write_null_pointer();
  }

  /** Formats an argument of a custom (user-defined) type. */
  OutputIt operator()(typename basic_format_arg<context_type>::handle handle) {
    auto parse_ctx =
        basic_printf_parse_context<Char>(basic_string_view<Char>());
    handle.format(parse_ctx, context_);
    return this->out;
  }
};

template <typename Char>
void parse_flags(basic_format_specs<Char>& specs, const Char*& it,
                 const Char* end) {
  for (; it != end; ++it) {
    switch (*it) {
    case '-':
      specs.align = align::left;
      break;
    case '+':
      specs.sign = sign::plus;
      break;
    case '0':
      specs.fill[0] = '0';
      break;
    case ' ':
      if (specs.sign != sign::plus) {
        specs.sign = sign::space;
      }
      break;
    case '#':
      specs.alt = true;
      break;
    default:
      return;
    }
  }
}

template <typename Char, typename GetArg>
int parse_header(const Char*& it, const Char* end,
                 basic_format_specs<Char>& specs, GetArg get_arg) {
  int arg_index = -1;
  Char c = *it;
  if (c >= '0' && c <= '9') {
    // Parse an argument index (if followed by '$') or a width possibly
    // preceded with '0' flag(s).
    int value = parse_nonnegative_int(it, end, -1);
    if (it != end && *it == '$') {  // value is an argument index
      ++it;
      arg_index = value != -1 ? value : max_value<int>();
    } else {
      if (c == '0') specs.fill[0] = '0';
      if (value != 0) {
        // Nonzero value means that we parsed width and don't need to
        // parse it or flags again, so return now.
        if (value == -1) FMT_THROW(format_error("number is too big"));
        specs.width = value;
        return arg_index;
      }
    }
  }
  parse_flags(specs, it, end);
  // Parse width.
  if (it != end) {
    if (*it >= '0' && *it <= '9') {
      specs.width = parse_nonnegative_int(it, end, -1);
      if (specs.width == -1) FMT_THROW(format_error("number is too big"));
    } else if (*it == '*') {
      ++it;
      specs.width = static_cast<int>(visit_format_arg(
          detail::printf_width_handler<Char>(specs), get_arg(-1)));
    }
  }
  return arg_index;
}

template <typename Char, typename Context>
void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
             basic_format_args<Context> args) {
  using OutputIt = buffer_appender<Char>;
  auto out = OutputIt(buf);
  auto context = basic_printf_context<OutputIt, Char>(out, args);
  auto parse_ctx = basic_printf_parse_context<Char>(format);

  // Returns the argument with specified index or, if arg_index is -1, the next
  // argument.
  auto get_arg = [&](int arg_index) {
    if (arg_index < 0)
      arg_index = parse_ctx.next_arg_id();
    else
      parse_ctx.check_arg_id(--arg_index);
    return detail::get_arg(context, arg_index);
  };

  const Char* start = parse_ctx.begin();
  const Char* end = parse_ctx.end();
  auto it = start;
  while (it != end) {
    if (!detail::find<false, Char>(it, end, '%', it)) {
      it = end;  // detail::find leaves it == nullptr if it doesn't find '%'
      break;
    }
    Char c = *it++;
    if (it != end && *it == c) {
      out = detail::write(
          out, basic_string_view<Char>(start, detail::to_unsigned(it - start)));
      start = ++it;
      continue;
    }
    out = detail::write(out, basic_string_view<Char>(
                                 start, detail::to_unsigned(it - 1 - start)));

    basic_format_specs<Char> specs;
    specs.align = align::right;

    // Parse argument index, flags and width.
    int arg_index = parse_header(it, end, specs, get_arg);
    if (arg_index == 0) parse_ctx.on_error("argument not found");

    // Parse precision.
    if (it != end && *it == '.') {
      ++it;
      c = it != end ? *it : 0;
      if ('0' <= c && c <= '9') {
        specs.precision = parse_nonnegative_int(it, end, 0);
      } else if (c == '*') {
        ++it;
        specs.precision = static_cast<int>(
            visit_format_arg(detail::printf_precision_handler(), get_arg(-1)));
      } else {
        specs.precision = 0;
      }
    }

    auto arg = get_arg(arg_index);
    // For d, i, o, u, x, and X conversion specifiers, if a precision is
    // specified, the '0' flag is ignored
    if (specs.precision >= 0 && arg.is_integral())
      specs.fill[0] =
          ' ';  // Ignore '0' flag for non-numeric types or if '-' present.
    if (specs.precision >= 0 && arg.type() == detail::type::cstring_type) {
      auto str = visit_format_arg(detail::get_cstring<Char>(), arg);
      auto str_end = str + specs.precision;
      auto nul = std::find(str, str_end, Char());
      arg = detail::make_arg<basic_printf_context<OutputIt, Char>>(
          basic_string_view<Char>(
              str, detail::to_unsigned(nul != str_end ? nul - str
                                                      : specs.precision)));
    }
    if (specs.alt && visit_format_arg(detail::is_zero_int(), arg))
      specs.alt = false;
    if (specs.fill[0] == '0') {
      if (arg.is_arithmetic() && specs.align != align::left)
        specs.align = align::numeric;
      else
        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types or if '-'
                              // flag is also present.
    }

    // Parse length and convert the argument to the required type.
    c = it != end ? *it++ : 0;
    Char t = it != end ? *it : 0;
    using detail::convert_arg;
    switch (c) {
    case 'h':
      if (t == 'h') {
        ++it;
        t = it != end ? *it : 0;
        convert_arg<signed char>(arg, t);
      } else {
        convert_arg<short>(arg, t);
      }
      break;
    case 'l':
      if (t == 'l') {
        ++it;
        t = it != end ? *it : 0;
        convert_arg<long long>(arg, t);
      } else {
        convert_arg<long>(arg, t);
      }
      break;
    case 'j':
      convert_arg<intmax_t>(arg, t);
      break;
    case 'z':
      convert_arg<size_t>(arg, t);
      break;
    case 't':
      convert_arg<std::ptrdiff_t>(arg, t);
      break;
    case 'L':
      // printf produces garbage when 'L' is omitted for long double, no
      // need to do the same.
      break;
    default:
      --it;
      convert_arg<void>(arg, c);
    }

    // Parse type.
    if (it == end) FMT_THROW(format_error("invalid format string"));
    char type = static_cast<char>(*it++);
    if (arg.is_integral()) {
      // Normalize type.
      switch (type) {
      case 'i':
      case 'u':
        type = 'd';
        break;
      case 'c':
        visit_format_arg(
            detail::char_converter<basic_printf_context<OutputIt, Char>>(arg),
            arg);
        break;
      }
    }
    specs.type = parse_presentation_type(type);
    if (specs.type == presentation_type::none)
      parse_ctx.on_error("invalid type specifier");

    start = it;

    // Format argument.
    out = visit_format_arg(
        detail::printf_arg_formatter<OutputIt, Char>(out, specs, context), arg);
  }
  detail::write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
}
FMT_END_DETAIL_NAMESPACE

template <typename Char>
using basic_printf_context_t =
    basic_printf_context<detail::buffer_appender<Char>, Char>;

using printf_context = basic_printf_context_t<char>;
using wprintf_context = basic_printf_context_t<wchar_t>;

using printf_args = basic_format_args<printf_context>;
using wprintf_args = basic_format_args<wprintf_context>;

/**
  \rst
  Constructs an `~fmt::format_arg_store` object that contains references to
  arguments and can be implicitly converted to `~fmt::printf_args`.
  \endrst
 */
template <typename... T>
inline auto make_printf_args(const T&... args)
    -> format_arg_store<printf_context, T...> {
  return {args...};
}

/**
  \rst
  Constructs an `~fmt::format_arg_store` object that contains references to
  arguments and can be implicitly converted to `~fmt::wprintf_args`.
  \endrst
 */
template <typename... T>
inline auto make_wprintf_args(const T&... args)
    -> format_arg_store<wprintf_context, T...> {
  return {args...};
}

template <typename S, typename Char = char_t<S>>
inline auto vsprintf(
    const S& fmt,
    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
    -> std::basic_string<Char> {
  basic_memory_buffer<Char> buffer;
  vprintf(buffer, to_string_view(fmt), args);
  return to_string(buffer);
}

/**
  \rst
  Formats arguments and returns the result as a string.

  **Example**::

    std::string message = fmt::sprintf("The answer is %d", 42);
  \endrst
*/
template <typename S, typename... T,
          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
inline auto sprintf(const S& fmt, const T&... args) -> std::basic_string<Char> {
  using context = basic_printf_context_t<Char>;
  return vsprintf(to_string_view(fmt), fmt::make_format_args<context>(args...));
}

template <typename S, typename Char = char_t<S>>
inline auto vfprintf(
    std::FILE* f, const S& fmt,
    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
    -> int {
  basic_memory_buffer<Char> buffer;
  vprintf(buffer, to_string_view(fmt), args);
  size_t size = buffer.size();
  return std::fwrite(buffer.data(), sizeof(Char), size, f) < size
             ? -1
             : static_cast<int>(size);
}

/**
  \rst
  Prints formatted data to the file *f*.

  **Example**::

    fmt::fprintf(stderr, "Don't %s!", "panic");
  \endrst
 */
template <typename S, typename... T, typename Char = char_t<S>>
inline auto fprintf(std::FILE* f, const S& fmt, const T&... args) -> int {
  using context = basic_printf_context_t<Char>;
  return vfprintf(f, to_string_view(fmt),
                  fmt::make_format_args<context>(args...));
}

template <typename S, typename Char = char_t<S>>
inline auto vprintf(
    const S& fmt,
    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
    -> int {
  return vfprintf(stdout, to_string_view(fmt), args);
}

/**
  \rst
  Prints formatted data to ``stdout``.

  **Example**::

    fmt::printf("Elapsed time: %.2f seconds", 1.23);
  \endrst
 */
template <typename S, typename... T, FMT_ENABLE_IF(detail::is_string<S>::value)>
inline auto printf(const S& fmt, const T&... args) -> int {
  return vprintf(
      to_string_view(fmt),
      fmt::make_format_args<basic_printf_context_t<char_t<S>>>(args...));
}

template <typename S, typename Char = char_t<S>>
FMT_DEPRECATED auto vfprintf(
    std::basic_ostream<Char>& os, const S& fmt,
    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
    -> int {
  basic_memory_buffer<Char> buffer;
  vprintf(buffer, to_string_view(fmt), args);
  os.write(buffer.data(), static_cast<std::streamsize>(buffer.size()));
  return static_cast<int>(buffer.size());
}
template <typename S, typename... T, typename Char = char_t<S>>
FMT_DEPRECATED auto fprintf(std::basic_ostream<Char>& os, const S& fmt,
                            const T&... args) -> int {
  return vfprintf(os, to_string_view(fmt),
                  fmt::make_format_args<basic_printf_context_t<Char>>(args...));
}

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_PRINTF_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/ranges.h`:

```h
// Formatting library for C++ - experimental range support
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.
//
// Copyright (c) 2018 - present, Remotion (Igor Schulz)
// All Rights Reserved
// {fmt} support for ranges, containers and types tuple interface.

#ifndef FMT_RANGES_H_
#define FMT_RANGES_H_

#include <initializer_list>
#include <tuple>
#include <type_traits>

#include "format.h"

FMT_BEGIN_NAMESPACE

namespace detail {

template <typename RangeT, typename OutputIterator>
OutputIterator copy(const RangeT& range, OutputIterator out) {
  for (auto it = range.begin(), end = range.end(); it != end; ++it)
    *out++ = *it;
  return out;
}

template <typename OutputIterator>
OutputIterator copy(const char* str, OutputIterator out) {
  while (*str) *out++ = *str++;
  return out;
}

template <typename OutputIterator>
OutputIterator copy(char ch, OutputIterator out) {
  *out++ = ch;
  return out;
}

template <typename OutputIterator>
OutputIterator copy(wchar_t ch, OutputIterator out) {
  *out++ = ch;
  return out;
}

// Returns true if T has a std::string-like interface, like std::string_view.
template <typename T> class is_std_string_like {
  template <typename U>
  static auto check(U* p)
      -> decltype((void)p->find('a'), p->length(), (void)p->data(), int());
  template <typename> static void check(...);

 public:
  static FMT_CONSTEXPR_DECL const bool value =
      is_string<T>::value ||
      std::is_convertible<T, std_string_view<char>>::value ||
      !std::is_void<decltype(check<T>(nullptr))>::value;
};

template <typename Char>
struct is_std_string_like<fmt::basic_string_view<Char>> : std::true_type {};

template <typename T> class is_map {
  template <typename U> static auto check(U*) -> typename U::mapped_type;
  template <typename> static void check(...);

 public:
#ifdef FMT_FORMAT_MAP_AS_LIST
  static FMT_CONSTEXPR_DECL const bool value = false;
#else
  static FMT_CONSTEXPR_DECL const bool value =
      !std::is_void<decltype(check<T>(nullptr))>::value;
#endif
};

template <typename T> class is_set {
  template <typename U> static auto check(U*) -> typename U::key_type;
  template <typename> static void check(...);

 public:
#ifdef FMT_FORMAT_SET_AS_LIST
  static FMT_CONSTEXPR_DECL const bool value = false;
#else
  static FMT_CONSTEXPR_DECL const bool value =
      !std::is_void<decltype(check<T>(nullptr))>::value && !is_map<T>::value;
#endif
};

template <typename... Ts> struct conditional_helper {};

template <typename T, typename _ = void> struct is_range_ : std::false_type {};

#if !FMT_MSC_VER || FMT_MSC_VER > 1800

#  define FMT_DECLTYPE_RETURN(val)  \
    ->decltype(val) { return val; } \
    static_assert(                  \
        true, "")  // This makes it so that a semicolon is required after the
                   // macro, which helps clang-format handle the formatting.

// C array overload
template <typename T, std::size_t N>
auto range_begin(const T (&arr)[N]) -> const T* {
  return arr;
}
template <typename T, std::size_t N>
auto range_end(const T (&arr)[N]) -> const T* {
  return arr + N;
}

template <typename T, typename Enable = void>
struct has_member_fn_begin_end_t : std::false_type {};

template <typename T>
struct has_member_fn_begin_end_t<T, void_t<decltype(std::declval<T>().begin()),
                                           decltype(std::declval<T>().end())>>
    : std::true_type {};

// Member function overload
template <typename T>
auto range_begin(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());
template <typename T>
auto range_end(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());

// ADL overload. Only participates in overload resolution if member functions
// are not found.
template <typename T>
auto range_begin(T&& rng)
    -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,
                   decltype(begin(static_cast<T&&>(rng)))> {
  return begin(static_cast<T&&>(rng));
}
template <typename T>
auto range_end(T&& rng) -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,
                                       decltype(end(static_cast<T&&>(rng)))> {
  return end(static_cast<T&&>(rng));
}

template <typename T, typename Enable = void>
struct has_const_begin_end : std::false_type {};
template <typename T, typename Enable = void>
struct has_mutable_begin_end : std::false_type {};

template <typename T>
struct has_const_begin_end<
    T,
    void_t<
        decltype(detail::range_begin(std::declval<const remove_cvref_t<T>&>())),
        decltype(detail::range_end(std::declval<const remove_cvref_t<T>&>()))>>
    : std::true_type {};

template <typename T>
struct has_mutable_begin_end<
    T, void_t<decltype(detail::range_begin(std::declval<T>())),
              decltype(detail::range_end(std::declval<T>())),
              enable_if_t<std::is_copy_constructible<T>::value>>>
    : std::true_type {};

template <typename T>
struct is_range_<T, void>
    : std::integral_constant<bool, (has_const_begin_end<T>::value ||
                                    has_mutable_begin_end<T>::value)> {};
#  undef FMT_DECLTYPE_RETURN
#endif

// tuple_size and tuple_element check.
template <typename T> class is_tuple_like_ {
  template <typename U>
  static auto check(U* p) -> decltype(std::tuple_size<U>::value, int());
  template <typename> static void check(...);

 public:
  static FMT_CONSTEXPR_DECL const bool value =
      !std::is_void<decltype(check<T>(nullptr))>::value;
};

// Check for integer_sequence
#if defined(__cpp_lib_integer_sequence) || FMT_MSC_VER >= 1900
template <typename T, T... N>
using integer_sequence = std::integer_sequence<T, N...>;
template <size_t... N> using index_sequence = std::index_sequence<N...>;
template <size_t N> using make_index_sequence = std::make_index_sequence<N>;
#else
template <typename T, T... N> struct integer_sequence {
  using value_type = T;

  static FMT_CONSTEXPR size_t size() { return sizeof...(N); }
};

template <size_t... N> using index_sequence = integer_sequence<size_t, N...>;

template <typename T, size_t N, T... Ns>
struct make_integer_sequence : make_integer_sequence<T, N - 1, N - 1, Ns...> {};
template <typename T, T... Ns>
struct make_integer_sequence<T, 0, Ns...> : integer_sequence<T, Ns...> {};

template <size_t N>
using make_index_sequence = make_integer_sequence<size_t, N>;
#endif

template <class Tuple, class F, size_t... Is>
void for_each(index_sequence<Is...>, Tuple&& tup, F&& f) FMT_NOEXCEPT {
  using std::get;
  // using free function get<I>(T) now.
  const int _[] = {0, ((void)f(get<Is>(tup)), 0)...};
  (void)_;  // blocks warnings
}

template <class T>
FMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> get_indexes(
    T const&) {
  return {};
}

template <class Tuple, class F> void for_each(Tuple&& tup, F&& f) {
  const auto indexes = get_indexes(tup);
  for_each(indexes, std::forward<Tuple>(tup), std::forward<F>(f));
}

template <typename Range>
using value_type =
    remove_cvref_t<decltype(*detail::range_begin(std::declval<Range>()))>;

template <typename OutputIt> OutputIt write_delimiter(OutputIt out) {
  *out++ = ',';
  *out++ = ' ';
  return out;
}

struct singleton {
  unsigned char upper;
  unsigned char lower_count;
};

inline auto is_printable(uint16_t x, const singleton* singletons,
                         size_t singletons_size,
                         const unsigned char* singleton_lowers,
                         const unsigned char* normal, size_t normal_size)
    -> bool {
  auto upper = x >> 8;
  auto lower_start = 0;
  for (size_t i = 0; i < singletons_size; ++i) {
    auto s = singletons[i];
    auto lower_end = lower_start + s.lower_count;
    if (upper < s.upper) break;
    if (upper == s.upper) {
      for (auto j = lower_start; j < lower_end; ++j) {
        if (singleton_lowers[j] == (x & 0xff)) return false;
      }
    }
    lower_start = lower_end;
  }

  auto xsigned = static_cast<int>(x);
  auto current = true;
  for (size_t i = 0; i < normal_size; ++i) {
    auto v = static_cast<int>(normal[i]);
    auto len = (v & 0x80) != 0 ? (v & 0x7f) << 8 | normal[++i] : v;
    xsigned -= len;
    if (xsigned < 0) break;
    current = !current;
  }
  return current;
}

// Returns true iff the code point cp is printable.
// This code is generated by support/printable.py.
inline auto is_printable(uint32_t cp) -> bool {
  static constexpr singleton singletons0[] = {
      {0x00, 1},  {0x03, 5},  {0x05, 6},  {0x06, 3},  {0x07, 6},  {0x08, 8},
      {0x09, 17}, {0x0a, 28}, {0x0b, 25}, {0x0c, 20}, {0x0d, 16}, {0x0e, 13},
      {0x0f, 4},  {0x10, 3},  {0x12, 18}, {0x13, 9},  {0x16, 1},  {0x17, 5},
      {0x18, 2},  {0x19, 3},  {0x1a, 7},  {0x1c, 2},  {0x1d, 1},  {0x1f, 22},
      {0x20, 3},  {0x2b, 3},  {0x2c, 2},  {0x2d, 11}, {0x2e, 1},  {0x30, 3},
      {0x31, 2},  {0x32, 1},  {0xa7, 2},  {0xa9, 2},  {0xaa, 4},  {0xab, 8},
      {0xfa, 2},  {0xfb, 5},  {0xfd, 4},  {0xfe, 3},  {0xff, 9},
  };
  static constexpr unsigned char singletons0_lower[] = {
      0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57, 0x58, 0x8b, 0x8c, 0x90,
      0x1c, 0x1d, 0xdd, 0x0e, 0x0f, 0x4b, 0x4c, 0xfb, 0xfc, 0x2e, 0x2f, 0x3f,
      0x5c, 0x5d, 0x5f, 0xb5, 0xe2, 0x84, 0x8d, 0x8e, 0x91, 0x92, 0xa9, 0xb1,
      0xba, 0xbb, 0xc5, 0xc6, 0xc9, 0xca, 0xde, 0xe4, 0xe5, 0xff, 0x00, 0x04,
      0x11, 0x12, 0x29, 0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49, 0x4a, 0x5d,
      0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4, 0xba, 0xbb, 0xc6, 0xca, 0xce, 0xcf,
      0xe4, 0xe5, 0x00, 0x04, 0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,
      0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e, 0x64, 0x65, 0x84, 0x91, 0x9b, 0x9d,
      0xc9, 0xce, 0xcf, 0x0d, 0x11, 0x29, 0x45, 0x49, 0x57, 0x64, 0x65, 0x8d,
      0x91, 0xa9, 0xb4, 0xba, 0xbb, 0xc5, 0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x0d,
      0x11, 0x45, 0x49, 0x64, 0x65, 0x80, 0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5,
      0xd7, 0xf0, 0xf1, 0x83, 0x85, 0x8b, 0xa4, 0xa6, 0xbe, 0xbf, 0xc5, 0xc7,
      0xce, 0xcf, 0xda, 0xdb, 0x48, 0x98, 0xbd, 0xcd, 0xc6, 0xce, 0xcf, 0x49,
      0x4e, 0x4f, 0x57, 0x59, 0x5e, 0x5f, 0x89, 0x8e, 0x8f, 0xb1, 0xb6, 0xb7,
      0xbf, 0xc1, 0xc6, 0xc7, 0xd7, 0x11, 0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7,
      0xfe, 0xff, 0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e, 0x0f, 0x1f, 0x6e,
      0x6f, 0x1c, 0x1d, 0x5f, 0x7d, 0x7e, 0xae, 0xaf, 0xbb, 0xbc, 0xfa, 0x16,
      0x17, 0x1e, 0x1f, 0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c, 0x5e, 0x7e,
      0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc, 0xf0, 0xf1, 0xf5, 0x72, 0x73, 0x8f,
      0x74, 0x75, 0x96, 0x2f, 0x5f, 0x26, 0x2e, 0x2f, 0xa7, 0xaf, 0xb7, 0xbf,
      0xc7, 0xcf, 0xd7, 0xdf, 0x9a, 0x40, 0x97, 0x98, 0x30, 0x8f, 0x1f, 0xc0,
      0xc1, 0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b, 0x07, 0x08, 0x0f, 0x10, 0x27,
      0x2f, 0xee, 0xef, 0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90, 0x91,
      0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9, 0xd0, 0xd1, 0xd8, 0xd9, 0xe7,
      0xfe, 0xff,
  };
  static constexpr singleton singletons1[] = {
      {0x00, 6},  {0x01, 1}, {0x03, 1},  {0x04, 2}, {0x08, 8},  {0x09, 2},
      {0x0a, 5},  {0x0b, 2}, {0x0e, 4},  {0x10, 1}, {0x11, 2},  {0x12, 5},
      {0x13, 17}, {0x14, 1}, {0x15, 2},  {0x17, 2}, {0x19, 13}, {0x1c, 5},
      {0x1d, 8},  {0x24, 1}, {0x6a, 3},  {0x6b, 2}, {0xbc, 2},  {0xd1, 2},
      {0xd4, 12}, {0xd5, 9}, {0xd6, 2},  {0xd7, 2}, {0xda, 1},  {0xe0, 5},
      {0xe1, 2},  {0xe8, 2}, {0xee, 32}, {0xf0, 4}, {0xf8, 2},  {0xf9, 2},
      {0xfa, 2},  {0xfb, 1},
  };
  static constexpr unsigned char singletons1_lower[] = {
      0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e, 0x9e, 0x9f, 0x06, 0x07,
      0x09, 0x36, 0x3d, 0x3e, 0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x36,
      0x37, 0x56, 0x57, 0x7f, 0xaa, 0xae, 0xaf, 0xbd, 0x35, 0xe0, 0x12, 0x87,
      0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,
      0x45, 0x46, 0x49, 0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5c, 0xb6, 0xb7, 0x1b,
      0x1c, 0x07, 0x08, 0x0a, 0x0b, 0x14, 0x17, 0x36, 0x39, 0x3a, 0xa8, 0xa9,
      0xd8, 0xd9, 0x09, 0x37, 0x90, 0x91, 0xa8, 0x07, 0x0a, 0x3b, 0x3e, 0x66,
      0x69, 0x8f, 0x92, 0x6f, 0x5f, 0xee, 0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27,
      0x28, 0x55, 0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8, 0xad, 0xba, 0xbc,
      0xc4, 0x06, 0x0b, 0x0c, 0x15, 0x1d, 0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7,
      0xcc, 0xcd, 0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0x3e, 0x3f, 0xc5, 0xc6,
      0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33, 0x38, 0x3a, 0x48, 0x4a, 0x4c,
      0x50, 0x53, 0x55, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65, 0x66,
      0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4, 0xaa, 0xaf, 0xb0, 0xc0, 0xd0,
      0xae, 0xaf, 0x79, 0xcc, 0x6e, 0x6f, 0x93,
  };
  static constexpr unsigned char normal0[] = {
      0x00, 0x20, 0x5f, 0x22, 0x82, 0xdf, 0x04, 0x82, 0x44, 0x08, 0x1b, 0x04,
      0x06, 0x11, 0x81, 0xac, 0x0e, 0x80, 0xab, 0x35, 0x28, 0x0b, 0x80, 0xe0,
      0x03, 0x19, 0x08, 0x01, 0x04, 0x2f, 0x04, 0x34, 0x04, 0x07, 0x03, 0x01,
      0x07, 0x06, 0x07, 0x11, 0x0a, 0x50, 0x0f, 0x12, 0x07, 0x55, 0x07, 0x03,
      0x04, 0x1c, 0x0a, 0x09, 0x03, 0x08, 0x03, 0x07, 0x03, 0x02, 0x03, 0x03,
      0x03, 0x0c, 0x04, 0x05, 0x03, 0x0b, 0x06, 0x01, 0x0e, 0x15, 0x05, 0x3a,
      0x03, 0x11, 0x07, 0x06, 0x05, 0x10, 0x07, 0x57, 0x07, 0x02, 0x07, 0x15,
      0x0d, 0x50, 0x04, 0x43, 0x03, 0x2d, 0x03, 0x01, 0x04, 0x11, 0x06, 0x0f,
      0x0c, 0x3a, 0x04, 0x1d, 0x25, 0x5f, 0x20, 0x6d, 0x04, 0x6a, 0x25, 0x80,
      0xc8, 0x05, 0x82, 0xb0, 0x03, 0x1a, 0x06, 0x82, 0xfd, 0x03, 0x59, 0x07,
      0x15, 0x0b, 0x17, 0x09, 0x14, 0x0c, 0x14, 0x0c, 0x6a, 0x06, 0x0a, 0x06,
      0x1a, 0x06, 0x59, 0x07, 0x2b, 0x05, 0x46, 0x0a, 0x2c, 0x04, 0x0c, 0x04,
      0x01, 0x03, 0x31, 0x0b, 0x2c, 0x04, 0x1a, 0x06, 0x0b, 0x03, 0x80, 0xac,
      0x06, 0x0a, 0x06, 0x21, 0x3f, 0x4c, 0x04, 0x2d, 0x03, 0x74, 0x08, 0x3c,
      0x03, 0x0f, 0x03, 0x3c, 0x07, 0x38, 0x08, 0x2b, 0x05, 0x82, 0xff, 0x11,
      0x18, 0x08, 0x2f, 0x11, 0x2d, 0x03, 0x20, 0x10, 0x21, 0x0f, 0x80, 0x8c,
      0x04, 0x82, 0x97, 0x19, 0x0b, 0x15, 0x88, 0x94, 0x05, 0x2f, 0x05, 0x3b,
      0x07, 0x02, 0x0e, 0x18, 0x09, 0x80, 0xb3, 0x2d, 0x74, 0x0c, 0x80, 0xd6,
      0x1a, 0x0c, 0x05, 0x80, 0xff, 0x05, 0x80, 0xdf, 0x0c, 0xee, 0x0d, 0x03,
      0x84, 0x8d, 0x03, 0x37, 0x09, 0x81, 0x5c, 0x14, 0x80, 0xb8, 0x08, 0x80,
      0xcb, 0x2a, 0x38, 0x03, 0x0a, 0x06, 0x38, 0x08, 0x46, 0x08, 0x0c, 0x06,
      0x74, 0x0b, 0x1e, 0x03, 0x5a, 0x04, 0x59, 0x09, 0x80, 0x83, 0x18, 0x1c,
      0x0a, 0x16, 0x09, 0x4c, 0x04, 0x80, 0x8a, 0x06, 0xab, 0xa4, 0x0c, 0x17,
      0x04, 0x31, 0xa1, 0x04, 0x81, 0xda, 0x26, 0x07, 0x0c, 0x05, 0x05, 0x80,
      0xa5, 0x11, 0x81, 0x6d, 0x10, 0x78, 0x28, 0x2a, 0x06, 0x4c, 0x04, 0x80,
      0x8d, 0x04, 0x80, 0xbe, 0x03, 0x1b, 0x03, 0x0f, 0x0d,
  };
  static constexpr unsigned char normal1[] = {
      0x5e, 0x22, 0x7b, 0x05, 0x03, 0x04, 0x2d, 0x03, 0x66, 0x03, 0x01, 0x2f,
      0x2e, 0x80, 0x82, 0x1d, 0x03, 0x31, 0x0f, 0x1c, 0x04, 0x24, 0x09, 0x1e,
      0x05, 0x2b, 0x05, 0x44, 0x04, 0x0e, 0x2a, 0x80, 0xaa, 0x06, 0x24, 0x04,
      0x24, 0x04, 0x28, 0x08, 0x34, 0x0b, 0x01, 0x80, 0x90, 0x81, 0x37, 0x09,
      0x16, 0x0a, 0x08, 0x80, 0x98, 0x39, 0x03, 0x63, 0x08, 0x09, 0x30, 0x16,
      0x05, 0x21, 0x03, 0x1b, 0x05, 0x01, 0x40, 0x38, 0x04, 0x4b, 0x05, 0x2f,
      0x04, 0x0a, 0x07, 0x09, 0x07, 0x40, 0x20, 0x27, 0x04, 0x0c, 0x09, 0x36,
      0x03, 0x3a, 0x05, 0x1a, 0x07, 0x04, 0x0c, 0x07, 0x50, 0x49, 0x37, 0x33,
      0x0d, 0x33, 0x07, 0x2e, 0x08, 0x0a, 0x81, 0x26, 0x52, 0x4e, 0x28, 0x08,
      0x2a, 0x56, 0x1c, 0x14, 0x17, 0x09, 0x4e, 0x04, 0x1e, 0x0f, 0x43, 0x0e,
      0x19, 0x07, 0x0a, 0x06, 0x48, 0x08, 0x27, 0x09, 0x75, 0x0b, 0x3f, 0x41,
      0x2a, 0x06, 0x3b, 0x05, 0x0a, 0x06, 0x51, 0x06, 0x01, 0x05, 0x10, 0x03,
      0x05, 0x80, 0x8b, 0x62, 0x1e, 0x48, 0x08, 0x0a, 0x80, 0xa6, 0x5e, 0x22,
      0x45, 0x0b, 0x0a, 0x06, 0x0d, 0x13, 0x39, 0x07, 0x0a, 0x36, 0x2c, 0x04,
      0x10, 0x80, 0xc0, 0x3c, 0x64, 0x53, 0x0c, 0x48, 0x09, 0x0a, 0x46, 0x45,
      0x1b, 0x48, 0x08, 0x53, 0x1d, 0x39, 0x81, 0x07, 0x46, 0x0a, 0x1d, 0x03,
      0x47, 0x49, 0x37, 0x03, 0x0e, 0x08, 0x0a, 0x06, 0x39, 0x07, 0x0a, 0x81,
      0x36, 0x19, 0x80, 0xb7, 0x01, 0x0f, 0x32, 0x0d, 0x83, 0x9b, 0x66, 0x75,
      0x0b, 0x80, 0xc4, 0x8a, 0xbc, 0x84, 0x2f, 0x8f, 0xd1, 0x82, 0x47, 0xa1,
      0xb9, 0x82, 0x39, 0x07, 0x2a, 0x04, 0x02, 0x60, 0x26, 0x0a, 0x46, 0x0a,
      0x28, 0x05, 0x13, 0x82, 0xb0, 0x5b, 0x65, 0x4b, 0x04, 0x39, 0x07, 0x11,
      0x40, 0x05, 0x0b, 0x02, 0x0e, 0x97, 0xf8, 0x08, 0x84, 0xd6, 0x2a, 0x09,
      0xa2, 0xf7, 0x81, 0x1f, 0x31, 0x03, 0x11, 0x04, 0x08, 0x81, 0x8c, 0x89,
      0x04, 0x6b, 0x05, 0x0d, 0x03, 0x09, 0x07, 0x10, 0x93, 0x60, 0x80, 0xf6,
      0x0a, 0x73, 0x08, 0x6e, 0x17, 0x46, 0x80, 0x9a, 0x14, 0x0c, 0x57, 0x09,
      0x19, 0x80, 0x87, 0x81, 0x47, 0x03, 0x85, 0x42, 0x0f, 0x15, 0x85, 0x50,
      0x2b, 0x80, 0xd5, 0x2d, 0x03, 0x1a, 0x04, 0x02, 0x81, 0x70, 0x3a, 0x05,
      0x01, 0x85, 0x00, 0x80, 0xd7, 0x29, 0x4c, 0x04, 0x0a, 0x04, 0x02, 0x83,
      0x11, 0x44, 0x4c, 0x3d, 0x80, 0xc2, 0x3c, 0x06, 0x01, 0x04, 0x55, 0x05,
      0x1b, 0x34, 0x02, 0x81, 0x0e, 0x2c, 0x04, 0x64, 0x0c, 0x56, 0x0a, 0x80,
      0xae, 0x38, 0x1d, 0x0d, 0x2c, 0x04, 0x09, 0x07, 0x02, 0x0e, 0x06, 0x80,
      0x9a, 0x83, 0xd8, 0x08, 0x0d, 0x03, 0x0d, 0x03, 0x74, 0x0c, 0x59, 0x07,
      0x0c, 0x14, 0x0c, 0x04, 0x38, 0x08, 0x0a, 0x06, 0x28, 0x08, 0x22, 0x4e,
      0x81, 0x54, 0x0c, 0x15, 0x03, 0x03, 0x05, 0x07, 0x09, 0x19, 0x07, 0x07,
      0x09, 0x03, 0x0d, 0x07, 0x29, 0x80, 0xcb, 0x25, 0x0a, 0x84, 0x06,
  };
  auto lower = static_cast<uint16_t>(cp);
  if (cp < 0x10000) {
    return is_printable(lower, singletons0,
                        sizeof(singletons0) / sizeof(*singletons0),
                        singletons0_lower, normal0, sizeof(normal0));
  }
  if (cp < 0x20000) {
    return is_printable(lower, singletons1,
                        sizeof(singletons1) / sizeof(*singletons1),
                        singletons1_lower, normal1, sizeof(normal1));
  }
  if (0x2a6de <= cp && cp < 0x2a700) return false;
  if (0x2b735 <= cp && cp < 0x2b740) return false;
  if (0x2b81e <= cp && cp < 0x2b820) return false;
  if (0x2cea2 <= cp && cp < 0x2ceb0) return false;
  if (0x2ebe1 <= cp && cp < 0x2f800) return false;
  if (0x2fa1e <= cp && cp < 0x30000) return false;
  if (0x3134b <= cp && cp < 0xe0100) return false;
  if (0xe01f0 <= cp && cp < 0x110000) return false;
  return cp < 0x110000;
}

inline auto needs_escape(uint32_t cp) -> bool {
  return cp < 0x20 || cp == 0x7f || cp == '"' || cp == '\\' ||
         !is_printable(cp);
}

template <typename Char> struct find_escape_result {
  const Char* begin;
  const Char* end;
  uint32_t cp;
};

template <typename Char>
auto find_escape(const Char* begin, const Char* end)
    -> find_escape_result<Char> {
  for (; begin != end; ++begin) {
    auto cp = static_cast<typename std::make_unsigned<Char>::type>(*begin);
    if (sizeof(Char) == 1 && cp >= 0x80) continue;
    if (needs_escape(cp)) return {begin, begin + 1, cp};
  }
  return {begin, nullptr, 0};
}

inline auto find_escape(const char* begin, const char* end)
    -> find_escape_result<char> {
  if (!is_utf8()) return find_escape<char>(begin, end);
  auto result = find_escape_result<char>{end, nullptr, 0};
  for_each_codepoint(string_view(begin, to_unsigned(end - begin)),
                     [&](uint32_t cp, string_view sv) {
                       if (needs_escape(cp)) {
                         result = {sv.begin(), sv.end(), cp};
                         return false;
                       }
                       return true;
                     });
  return result;
}

template <typename Char, typename OutputIt>
auto write_range_entry(OutputIt out, basic_string_view<Char> str) -> OutputIt {
  *out++ = '"';
  auto begin = str.begin(), end = str.end();
  do {
    auto escape = find_escape(begin, end);
    out = copy_str<Char>(begin, escape.begin, out);
    begin = escape.end;
    if (!begin) break;
    auto c = static_cast<Char>(escape.cp);
    switch (escape.cp) {
    case '\n':
      *out++ = '\\';
      c = 'n';
      break;
    case '\r':
      *out++ = '\\';
      c = 'r';
      break;
    case '\t':
      *out++ = '\\';
      c = 't';
      break;
    case '"':
      FMT_FALLTHROUGH;
    case '\\':
      *out++ = '\\';
      break;
    default:
      if (is_utf8()) {
        if (escape.cp < 0x100) {
          out = format_to(out, "\\x{:02x}", escape.cp);
          continue;
        }
        if (escape.cp < 0x10000) {
          out = format_to(out, "\\u{:04x}", escape.cp);
          continue;
        }
        if (escape.cp < 0x110000) {
          out = format_to(out, "\\U{:08x}", escape.cp);
          continue;
        }
      }
      for (Char escape_char : basic_string_view<Char>(
               escape.begin, to_unsigned(escape.end - escape.begin))) {
        out = format_to(
            out, "\\x{:02x}",
            static_cast<typename std::make_unsigned<Char>::type>(escape_char));
      }
      continue;
    }
    *out++ = c;
  } while (begin != end);
  *out++ = '"';
  return out;
}

template <typename Char, typename OutputIt, typename T,
          FMT_ENABLE_IF(std::is_convertible<T, std_string_view<char>>::value)>
inline auto write_range_entry(OutputIt out, const T& str) -> OutputIt {
  auto sv = std_string_view<Char>(str);
  return write_range_entry<Char>(out, basic_string_view<Char>(sv));
}

template <typename Char, typename OutputIt, typename Arg,
          FMT_ENABLE_IF(std::is_same<Arg, Char>::value)>
OutputIt write_range_entry(OutputIt out, const Arg v) {
  *out++ = '\'';
  *out++ = v;
  *out++ = '\'';
  return out;
}

template <
    typename Char, typename OutputIt, typename Arg,
    FMT_ENABLE_IF(!is_std_string_like<typename std::decay<Arg>::type>::value &&
                  !std::is_same<Arg, Char>::value)>
OutputIt write_range_entry(OutputIt out, const Arg& v) {
  return write<Char>(out, v);
}

}  // namespace detail

template <typename T> struct is_tuple_like {
  static FMT_CONSTEXPR_DECL const bool value =
      detail::is_tuple_like_<T>::value && !detail::is_range_<T>::value;
};

template <typename TupleT, typename Char>
struct formatter<TupleT, Char, enable_if_t<fmt::is_tuple_like<TupleT>::value>> {
 private:
  // C++11 generic lambda for format().
  template <typename FormatContext> struct format_each {
    template <typename T> void operator()(const T& v) {
      if (i > 0) out = detail::write_delimiter(out);
      out = detail::write_range_entry<Char>(out, v);
      ++i;
    }
    int i;
    typename FormatContext::iterator& out;
  };

 public:
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return ctx.begin();
  }

  template <typename FormatContext = format_context>
  auto format(const TupleT& values, FormatContext& ctx) -> decltype(ctx.out()) {
    auto out = ctx.out();
    *out++ = '(';
    detail::for_each(values, format_each<FormatContext>{0, out});
    *out++ = ')';
    return out;
  }
};

template <typename T, typename Char> struct is_range {
  static FMT_CONSTEXPR_DECL const bool value =
      detail::is_range_<T>::value && !detail::is_std_string_like<T>::value &&
      !detail::is_map<T>::value &&
      !std::is_convertible<T, std::basic_string<Char>>::value &&
      !std::is_constructible<detail::std_string_view<Char>, T>::value;
};

template <typename T, typename Char>
struct formatter<
    T, Char,
    enable_if_t<
        fmt::is_range<T, Char>::value
// Workaround a bug in MSVC 2019 and earlier.
#if !FMT_MSC_VER
        && (is_formattable<detail::value_type<T>, Char>::value ||
            detail::has_fallback_formatter<detail::value_type<T>, Char>::value)
#endif
        >> {
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return ctx.begin();
  }

  template <
      typename FormatContext, typename U,
      FMT_ENABLE_IF(
          std::is_same<U, conditional_t<detail::has_const_begin_end<T>::value,
                                        const T, T>>::value)>
  auto format(U& range, FormatContext& ctx) -> decltype(ctx.out()) {
#ifdef FMT_DEPRECATED_BRACED_RANGES
    Char prefix = '{';
    Char postfix = '}';
#else
    Char prefix = detail::is_set<T>::value ? '{' : '[';
    Char postfix = detail::is_set<T>::value ? '}' : ']';
#endif
    auto out = ctx.out();
    *out++ = prefix;
    int i = 0;
    auto it = std::begin(range);
    auto end = std::end(range);
    for (; it != end; ++it) {
      if (i > 0) out = detail::write_delimiter(out);
      out = detail::write_range_entry<Char>(out, *it);
      ++i;
    }
    *out++ = postfix;
    return out;
  }
};

template <typename T, typename Char>
struct formatter<
    T, Char,
    enable_if_t<
        detail::is_map<T>::value
// Workaround a bug in MSVC 2019 and earlier.
#if !FMT_MSC_VER
        && (is_formattable<detail::value_type<T>, Char>::value ||
            detail::has_fallback_formatter<detail::value_type<T>, Char>::value)
#endif
        >> {
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return ctx.begin();
  }

  template <
      typename FormatContext, typename U,
      FMT_ENABLE_IF(
          std::is_same<U, conditional_t<detail::has_const_begin_end<T>::value,
                                        const T, T>>::value)>
  auto format(U& map, FormatContext& ctx) -> decltype(ctx.out()) {
    auto out = ctx.out();
    *out++ = '{';
    int i = 0;
    for (const auto& item : map) {
      if (i > 0) out = detail::write_delimiter(out);
      out = detail::write_range_entry<Char>(out, item.first);
      *out++ = ':';
      *out++ = ' ';
      out = detail::write_range_entry<Char>(out, item.second);
      ++i;
    }
    *out++ = '}';
    return out;
  }
};

template <typename Char, typename... T> struct tuple_join_view : detail::view {
  const std::tuple<T...>& tuple;
  basic_string_view<Char> sep;

  tuple_join_view(const std::tuple<T...>& t, basic_string_view<Char> s)
      : tuple(t), sep{s} {}
};

template <typename Char, typename... T>
using tuple_arg_join = tuple_join_view<Char, T...>;

// Define FMT_TUPLE_JOIN_SPECIFIERS to enable experimental format specifiers
// support in tuple_join. It is disabled by default because of issues with
// the dynamic width and precision.
#ifndef FMT_TUPLE_JOIN_SPECIFIERS
#  define FMT_TUPLE_JOIN_SPECIFIERS 0
#endif

template <typename Char, typename... T>
struct formatter<tuple_join_view<Char, T...>, Char> {
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return do_parse(ctx, std::integral_constant<size_t, sizeof...(T)>());
  }

  template <typename FormatContext>
  auto format(const tuple_join_view<Char, T...>& value,
              FormatContext& ctx) const -> typename FormatContext::iterator {
    return do_format(value, ctx,
                     std::integral_constant<size_t, sizeof...(T)>());
  }

 private:
  std::tuple<formatter<typename std::decay<T>::type, Char>...> formatters_;

  template <typename ParseContext>
  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
                              std::integral_constant<size_t, 0>)
      -> decltype(ctx.begin()) {
    return ctx.begin();
  }

  template <typename ParseContext, size_t N>
  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
                              std::integral_constant<size_t, N>)
      -> decltype(ctx.begin()) {
    auto end = ctx.begin();
#if FMT_TUPLE_JOIN_SPECIFIERS
    end = std::get<sizeof...(T) - N>(formatters_).parse(ctx);
    if (N > 1) {
      auto end1 = do_parse(ctx, std::integral_constant<size_t, N - 1>());
      if (end != end1)
        FMT_THROW(format_error("incompatible format specs for tuple elements"));
    }
#endif
    return end;
  }

  template <typename FormatContext>
  auto do_format(const tuple_join_view<Char, T...>&, FormatContext& ctx,
                 std::integral_constant<size_t, 0>) const ->
      typename FormatContext::iterator {
    return ctx.out();
  }

  template <typename FormatContext, size_t N>
  auto do_format(const tuple_join_view<Char, T...>& value, FormatContext& ctx,
                 std::integral_constant<size_t, N>) const ->
      typename FormatContext::iterator {
    auto out = std::get<sizeof...(T) - N>(formatters_)
                   .format(std::get<sizeof...(T) - N>(value.tuple), ctx);
    if (N > 1) {
      out = std::copy(value.sep.begin(), value.sep.end(), out);
      ctx.advance_to(out);
      return do_format(value, ctx, std::integral_constant<size_t, N - 1>());
    }
    return out;
  }
};

FMT_MODULE_EXPORT_BEGIN

/**
  \rst
  Returns an object that formats `tuple` with elements separated by `sep`.

  **Example**::

    std::tuple<int, char> t = {1, 'a'};
    fmt::print("{}", fmt::join(t, ", "));
    // Output: "1, a"
  \endrst
 */
template <typename... T>
FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple, string_view sep)
    -> tuple_join_view<char, T...> {
  return {tuple, sep};
}

template <typename... T>
FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple,
                        basic_string_view<wchar_t> sep)
    -> tuple_join_view<wchar_t, T...> {
  return {tuple, sep};
}

/**
  \rst
  Returns an object that formats `initializer_list` with elements separated by
  `sep`.

  **Example**::

    fmt::print("{}", fmt::join({1, 2, 3}, ", "));
    // Output: "1, 2, 3"
  \endrst
 */
template <typename T>
auto join(std::initializer_list<T> list, string_view sep)
    -> join_view<const T*, const T*> {
  return join(std::begin(list), std::end(list), sep);
}

FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_RANGES_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/xchar.h`:

```h
// Formatting library for C++ - optional wchar_t and exotic character support
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_XCHAR_H_
#define FMT_XCHAR_H_

#include <cwchar>
#include <tuple>

#include "format.h"

FMT_BEGIN_NAMESPACE
namespace detail {
template <typename T>
using is_exotic_char = bool_constant<!std::is_same<T, char>::value>;
}

FMT_MODULE_EXPORT_BEGIN

using wstring_view = basic_string_view<wchar_t>;
using wformat_parse_context = basic_format_parse_context<wchar_t>;
using wformat_context = buffer_context<wchar_t>;
using wformat_args = basic_format_args<wformat_context>;
using wmemory_buffer = basic_memory_buffer<wchar_t>;

#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
// Workaround broken conversion on older gcc.
template <typename... Args> using wformat_string = wstring_view;
#else
template <typename... Args>
using wformat_string = basic_format_string<wchar_t, type_identity_t<Args>...>;
#endif

template <> struct is_char<wchar_t> : std::true_type {};
template <> struct is_char<detail::char8_type> : std::true_type {};
template <> struct is_char<char16_t> : std::true_type {};
template <> struct is_char<char32_t> : std::true_type {};

template <typename... Args>
constexpr format_arg_store<wformat_context, Args...> make_wformat_args(
    const Args&... args) {
  return {args...};
}

inline namespace literals {
constexpr auto operator"" _format(const wchar_t* s, size_t n)
    -> detail::udl_formatter<wchar_t> {
  return {{s, n}};
}

#if FMT_USE_USER_DEFINED_LITERALS && !FMT_USE_NONTYPE_TEMPLATE_PARAMETERS
constexpr detail::udl_arg<wchar_t> operator"" _a(const wchar_t* s, size_t) {
  return {s};
}
#endif
}  // namespace literals

template <typename It, typename Sentinel>
auto join(It begin, Sentinel end, wstring_view sep)
    -> join_view<It, Sentinel, wchar_t> {
  return {begin, end, sep};
}

template <typename Range>
auto join(Range&& range, wstring_view sep)
    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>,
                 wchar_t> {
  return join(std::begin(range), std::end(range), sep);
}

template <typename T>
auto join(std::initializer_list<T> list, wstring_view sep)
    -> join_view<const T*, const T*, wchar_t> {
  return join(std::begin(list), std::end(list), sep);
}

template <typename Char, FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
auto vformat(basic_string_view<Char> format_str,
             basic_format_args<buffer_context<type_identity_t<Char>>> args)
    -> std::basic_string<Char> {
  basic_memory_buffer<Char> buffer;
  detail::vformat_to(buffer, format_str, args);
  return to_string(buffer);
}

// Pass char_t as a default template parameter instead of using
// std::basic_string<char_t<S>> to reduce the symbol size.
template <typename S, typename... Args, typename Char = char_t<S>,
          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
auto format(const S& format_str, Args&&... args) -> std::basic_string<Char> {
  const auto& vargs = fmt::make_args_checked<Args...>(format_str, args...);
  return vformat(to_string_view(format_str), vargs);
}

template <typename Locale, typename S, typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
                            detail::is_exotic_char<Char>::value)>
inline auto vformat(
    const Locale& loc, const S& format_str,
    basic_format_args<buffer_context<type_identity_t<Char>>> args)
    -> std::basic_string<Char> {
  return detail::vformat(loc, to_string_view(format_str), args);
}

template <typename Locale, typename S, typename... Args,
          typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
                            detail::is_exotic_char<Char>::value)>
inline auto format(const Locale& loc, const S& format_str, Args&&... args)
    -> std::basic_string<Char> {
  return detail::vformat(loc, to_string_view(format_str),
                         fmt::make_args_checked<Args...>(format_str, args...));
}

template <typename OutputIt, typename S, typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                            detail::is_exotic_char<Char>::value)>
auto vformat_to(OutputIt out, const S& format_str,
                basic_format_args<buffer_context<type_identity_t<Char>>> args)
    -> OutputIt {
  auto&& buf = detail::get_buffer<Char>(out);
  detail::vformat_to(buf, to_string_view(format_str), args);
  return detail::get_iterator(buf);
}

template <typename OutputIt, typename S, typename... Args,
          typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                            detail::is_exotic_char<Char>::value)>
inline auto format_to(OutputIt out, const S& fmt, Args&&... args) -> OutputIt {
  const auto& vargs = fmt::make_args_checked<Args...>(fmt, args...);
  return vformat_to(out, to_string_view(fmt), vargs);
}

template <typename S, typename... Args, typename Char, size_t SIZE,
          typename Allocator, FMT_ENABLE_IF(detail::is_string<S>::value)>
FMT_DEPRECATED auto format_to(basic_memory_buffer<Char, SIZE, Allocator>& buf,
                              const S& format_str, Args&&... args) ->
    typename buffer_context<Char>::iterator {
  const auto& vargs = fmt::make_args_checked<Args...>(format_str, args...);
  detail::vformat_to(buf, to_string_view(format_str), vargs, {});
  return detail::buffer_appender<Char>(buf);
}

template <typename Locale, typename S, typename OutputIt, typename... Args,
          typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                            detail::is_locale<Locale>::value&&
                                detail::is_exotic_char<Char>::value)>
inline auto vformat_to(
    OutputIt out, const Locale& loc, const S& format_str,
    basic_format_args<buffer_context<type_identity_t<Char>>> args) -> OutputIt {
  auto&& buf = detail::get_buffer<Char>(out);
  vformat_to(buf, to_string_view(format_str), args, detail::locale_ref(loc));
  return detail::get_iterator(buf);
}

template <
    typename OutputIt, typename Locale, typename S, typename... Args,
    typename Char = char_t<S>,
    bool enable = detail::is_output_iterator<OutputIt, Char>::value&&
        detail::is_locale<Locale>::value&& detail::is_exotic_char<Char>::value>
inline auto format_to(OutputIt out, const Locale& loc, const S& format_str,
                      Args&&... args) ->
    typename std::enable_if<enable, OutputIt>::type {
  const auto& vargs = fmt::make_args_checked<Args...>(format_str, args...);
  return vformat_to(out, loc, to_string_view(format_str), vargs);
}

template <typename OutputIt, typename Char, typename... Args,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                            detail::is_exotic_char<Char>::value)>
inline auto vformat_to_n(
    OutputIt out, size_t n, basic_string_view<Char> format_str,
    basic_format_args<buffer_context<type_identity_t<Char>>> args)
    -> format_to_n_result<OutputIt> {
  detail::iterator_buffer<OutputIt, Char, detail::fixed_buffer_traits> buf(out,
                                                                           n);
  detail::vformat_to(buf, format_str, args);
  return {buf.out(), buf.count()};
}

template <typename OutputIt, typename S, typename... Args,
          typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                            detail::is_exotic_char<Char>::value)>
inline auto format_to_n(OutputIt out, size_t n, const S& fmt,
                        const Args&... args) -> format_to_n_result<OutputIt> {
  const auto& vargs = fmt::make_args_checked<Args...>(fmt, args...);
  return vformat_to_n(out, n, to_string_view(fmt), vargs);
}

template <typename S, typename... Args, typename Char = char_t<S>,
          FMT_ENABLE_IF(detail::is_exotic_char<Char>::value)>
inline auto formatted_size(const S& fmt, Args&&... args) -> size_t {
  detail::counting_buffer<Char> buf;
  const auto& vargs = fmt::make_args_checked<Args...>(fmt, args...);
  detail::vformat_to(buf, to_string_view(fmt), vargs);
  return buf.count();
}

inline void vprint(std::FILE* f, wstring_view fmt, wformat_args args) {
  wmemory_buffer buffer;
  detail::vformat_to(buffer, fmt, args);
  buffer.push_back(L'\0');
  if (std::fputws(buffer.data(), f) == -1)
    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
}

inline void vprint(wstring_view fmt, wformat_args args) {
  vprint(stdout, fmt, args);
}

template <typename... T>
void print(std::FILE* f, wformat_string<T...> fmt, T&&... args) {
  return vprint(f, wstring_view(fmt), fmt::make_wformat_args(args...));
}

template <typename... T> void print(wformat_string<T...> fmt, T&&... args) {
  return vprint(wstring_view(fmt), fmt::make_wformat_args(args...));
}

/**
  Converts *value* to ``std::wstring`` using the default format for type *T*.
 */
template <typename T> inline auto to_wstring(const T& value) -> std::wstring {
  return format(FMT_STRING(L"{}"), value);
}
FMT_MODULE_EXPORT_END
FMT_END_NAMESPACE

#endif  // FMT_XCHAR_H_

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/chrono.h`:

```h
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// include bundled or external copy of fmtlib's chrono support
//

#if !defined(SPDLOG_USE_STD_FORMAT)
#    if !defined(SPDLOG_FMT_EXTERNAL)
#        ifdef SPDLOG_HEADER_ONLY
#            ifndef FMT_HEADER_ONLY
#                define FMT_HEADER_ONLY
#            endif
#        endif
#        include <spdlog/fmt/bundled/chrono.h>
#    else
#        include <fmt/chrono.h>
#    endif
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/compile.h`:

```h
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// include bundled or external copy of fmtlib's compile-time support
//

#if !defined(SPDLOG_USE_STD_FORMAT)
#    if !defined(SPDLOG_FMT_EXTERNAL)
#        ifdef SPDLOG_HEADER_ONLY
#            ifndef FMT_HEADER_ONLY
#                define FMT_HEADER_ONLY
#            endif
#        endif
#        include <spdlog/fmt/bundled/compile.h>
#    else
#        include <fmt/compile.h>
#    endif
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/fmt.h`:

```h
//
// Copyright(c) 2016-2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

//
// Include a bundled header-only copy of fmtlib or an external one.
// By default spdlog include its own copy.
//

#if defined(SPDLOG_USE_STD_FORMAT) // SPDLOG_USE_STD_FORMAT is defined - use std::format
#    include <format>
#elif !defined(SPDLOG_FMT_EXTERNAL)
#    if !defined(SPDLOG_COMPILED_LIB) && !defined(FMT_HEADER_ONLY)
#        define FMT_HEADER_ONLY
#    endif
#    ifndef FMT_USE_WINDOWS_H
#        define FMT_USE_WINDOWS_H 0
#    endif
// enable the 'n' flag in for backward compatibility with fmt 6.x
#    define FMT_DEPRECATED_N_SPECIFIER
#    include <spdlog/fmt/bundled/core.h>
#    include <spdlog/fmt/bundled/format.h>
#else // SPDLOG_FMT_EXTERNAL is defined - use external fmtlib
#    include <fmt/core.h>
#    include <fmt/format.h>
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/ostr.h`:

```h
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// include bundled or external copy of fmtlib's ostream support
//

#if !defined(SPDLOG_USE_STD_FORMAT)
#    if !defined(SPDLOG_FMT_EXTERNAL)
#        ifdef SPDLOG_HEADER_ONLY
#            ifndef FMT_HEADER_ONLY
#                define FMT_HEADER_ONLY
#            endif
#        endif
#        include <spdlog/fmt/bundled/ostream.h>
#    else
#        include <fmt/ostream.h>
#    endif
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/ranges.h`:

```h
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// include bundled or external copy of fmtlib's ranges support
//

#if !defined(SPDLOG_USE_STD_FORMAT)
#    if !defined(SPDLOG_FMT_EXTERNAL)
#        ifdef SPDLOG_HEADER_ONLY
#            ifndef FMT_HEADER_ONLY
#                define FMT_HEADER_ONLY
#            endif
#        endif
#        include <spdlog/fmt/bundled/ranges.h>
#    else
#        include <fmt/ranges.h>
#    endif
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/xchar.h`:

```h
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// include bundled or external copy of fmtlib's xchar support
//

#if !defined(SPDLOG_USE_STD_FORMAT)
#    if !defined(SPDLOG_FMT_EXTERNAL)
#        ifdef SPDLOG_HEADER_ONLY
#            ifndef FMT_HEADER_ONLY
#                define FMT_HEADER_ONLY
#            endif
#        endif
#        include <spdlog/fmt/bundled/xchar.h>
#    else
#        include <fmt/xchar.h>
#    endif
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/formatter.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/fmt/fmt.h>
#include <spdlog/details/log_msg.h>

namespace spdlog {

class formatter
{
public:
    virtual ~formatter() = default;
    virtual void format(const details::log_msg &msg, memory_buf_t &dest) = 0;
    virtual std::unique_ptr<formatter> clone() const = 0;
};
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fwd.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

namespace spdlog {
class logger;
class formatter;

namespace sinks {
class sink;
}

namespace level {
enum level_enum : int;
}

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/logger-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/logger.h>
#endif

#include <spdlog/sinks/sink.h>
#include <spdlog/details/backtracer.h>
#include <spdlog/pattern_formatter.h>

#include <cstdio>

namespace spdlog {

// public methods
SPDLOG_INLINE logger::logger(const logger &other)
    : name_(other.name_)
    , sinks_(other.sinks_)
    , level_(other.level_.load(std::memory_order_relaxed))
    , flush_level_(other.flush_level_.load(std::memory_order_relaxed))
    , custom_err_handler_(other.custom_err_handler_)
    , tracer_(other.tracer_)
{}

SPDLOG_INLINE logger::logger(logger &&other) SPDLOG_NOEXCEPT : name_(std::move(other.name_)),
                                                               sinks_(std::move(other.sinks_)),
                                                               level_(other.level_.load(std::memory_order_relaxed)),
                                                               flush_level_(other.flush_level_.load(std::memory_order_relaxed)),
                                                               custom_err_handler_(std::move(other.custom_err_handler_)),
                                                               tracer_(std::move(other.tracer_))

{}

SPDLOG_INLINE logger &logger::operator=(logger other) SPDLOG_NOEXCEPT
{
    this->swap(other);
    return *this;
}

SPDLOG_INLINE void logger::swap(spdlog::logger &other) SPDLOG_NOEXCEPT
{
    name_.swap(other.name_);
    sinks_.swap(other.sinks_);

    // swap level_
    auto other_level = other.level_.load();
    auto my_level = level_.exchange(other_level);
    other.level_.store(my_level);

    // swap flush level_
    other_level = other.flush_level_.load();
    my_level = flush_level_.exchange(other_level);
    other.flush_level_.store(my_level);

    custom_err_handler_.swap(other.custom_err_handler_);
    std::swap(tracer_, other.tracer_);
}

SPDLOG_INLINE void swap(logger &a, logger &b)
{
    a.swap(b);
}

SPDLOG_INLINE void logger::set_level(level::level_enum log_level)
{
    level_.store(log_level);
}

SPDLOG_INLINE level::level_enum logger::level() const
{
    return static_cast<level::level_enum>(level_.load(std::memory_order_relaxed));
}

SPDLOG_INLINE const std::string &logger::name() const
{
    return name_;
}

// set formatting for the sinks in this logger.
// each sink will get a separate instance of the formatter object.
SPDLOG_INLINE void logger::set_formatter(std::unique_ptr<formatter> f)
{
    for (auto it = sinks_.begin(); it != sinks_.end(); ++it)
    {
        if (std::next(it) == sinks_.end())
        {
            // last element - we can be move it.
            (*it)->set_formatter(std::move(f));
            break; // to prevent clang-tidy warning
        }
        else
        {
            (*it)->set_formatter(f->clone());
        }
    }
}

SPDLOG_INLINE void logger::set_pattern(std::string pattern, pattern_time_type time_type)
{
    auto new_formatter = details::make_unique<pattern_formatter>(std::move(pattern), time_type);
    set_formatter(std::move(new_formatter));
}

// create new backtrace sink and move to it all our child sinks
SPDLOG_INLINE void logger::enable_backtrace(size_t n_messages)
{
    tracer_.enable(n_messages);
}

// restore orig sinks and level and delete the backtrace sink
SPDLOG_INLINE void logger::disable_backtrace()
{
    tracer_.disable();
}

SPDLOG_INLINE void logger::dump_backtrace()
{
    dump_backtrace_();
}

// flush functions
SPDLOG_INLINE void logger::flush()
{
    flush_();
}

SPDLOG_INLINE void logger::flush_on(level::level_enum log_level)
{
    flush_level_.store(log_level);
}

SPDLOG_INLINE level::level_enum logger::flush_level() const
{
    return static_cast<level::level_enum>(flush_level_.load(std::memory_order_relaxed));
}

// sinks
SPDLOG_INLINE const std::vector<sink_ptr> &logger::sinks() const
{
    return sinks_;
}

SPDLOG_INLINE std::vector<sink_ptr> &logger::sinks()
{
    return sinks_;
}

// error handler
SPDLOG_INLINE void logger::set_error_handler(err_handler handler)
{
    custom_err_handler_ = std::move(handler);
}

// create new logger with same sinks and configuration.
SPDLOG_INLINE std::shared_ptr<logger> logger::clone(std::string logger_name)
{
    auto cloned = std::make_shared<logger>(*this);
    cloned->name_ = std::move(logger_name);
    return cloned;
}

// protected methods
SPDLOG_INLINE void logger::log_it_(const spdlog::details::log_msg &log_msg, bool log_enabled, bool traceback_enabled)
{
    if (log_enabled)
    {
        sink_it_(log_msg);
    }
    if (traceback_enabled)
    {
        tracer_.push_back(log_msg);
    }
}

SPDLOG_INLINE void logger::sink_it_(const details::log_msg &msg)
{
    for (auto &sink : sinks_)
    {
        if (sink->should_log(msg.level))
        {
            SPDLOG_TRY
            {
                sink->log(msg);
            }
            SPDLOG_LOGGER_CATCH(msg.source)
        }
    }

    if (should_flush_(msg))
    {
        flush_();
    }
}

SPDLOG_INLINE void logger::flush_()
{
    for (auto &sink : sinks_)
    {
        SPDLOG_TRY
        {
            sink->flush();
        }
        SPDLOG_LOGGER_CATCH(source_loc())
    }
}

SPDLOG_INLINE void logger::dump_backtrace_()
{
    using details::log_msg;
    if (tracer_.enabled())
    {
        sink_it_(log_msg{name(), level::info, "****************** Backtrace Start ******************"});
        tracer_.foreach_pop([this](const log_msg &msg) { this->sink_it_(msg); });
        sink_it_(log_msg{name(), level::info, "****************** Backtrace End ********************"});
    }
}

SPDLOG_INLINE bool logger::should_flush_(const details::log_msg &msg)
{
    auto flush_level = flush_level_.load(std::memory_order_relaxed);
    return (msg.level >= flush_level) && (msg.level != level::off);
}

SPDLOG_INLINE void logger::err_handler_(const std::string &msg)
{
    if (custom_err_handler_)
    {
        custom_err_handler_(msg);
    }
    else
    {
        using std::chrono::system_clock;
        static std::mutex mutex;
        static std::chrono::system_clock::time_point last_report_time;
        static size_t err_counter = 0;
        std::lock_guard<std::mutex> lk{mutex};
        auto now = system_clock::now();
        err_counter++;
        if (now - last_report_time < std::chrono::seconds(1))
        {
            return;
        }
        last_report_time = now;
        auto tm_time = details::os::localtime(system_clock::to_time_t(now));
        char date_buf[64];
        std::strftime(date_buf, sizeof(date_buf), "%Y-%m-%d %H:%M:%S", &tm_time);
#if defined(USING_R) && defined(R_R_H) // if in R environment
        REprintf("[*** LOG ERROR #%04zu ***] [%s] [%s] {%s}\n", err_counter, date_buf, name().c_str(), msg.c_str());
#else
        std::fprintf(stderr, "[*** LOG ERROR #%04zu ***] [%s] [%s] {%s}\n", err_counter, date_buf, name().c_str(), msg.c_str());
#endif
    }
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/logger.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

// Thread safe logger (except for set_error_handler())
// Has name, log level, vector of std::shared sink pointers and formatter
// Upon each log write the logger:
// 1. Checks if its log level is enough to log the message and if yes:
// 2. Call the underlying sinks to do the job.
// 3. Each sink use its own private copy of a formatter to format the message
// and send to its destination.
//
// The use of private formatter per sink provides the opportunity to cache some
// formatted data, and support for different format per sink.

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/common.h>
#include <spdlog/details/log_msg.h>
#include <spdlog/details/backtracer.h>

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
#    ifndef _WIN32
#        error SPDLOG_WCHAR_TO_UTF8_SUPPORT only supported on windows
#    endif
#    include <spdlog/details/os.h>
#endif

#include <vector>

#ifndef SPDLOG_NO_EXCEPTIONS
#    define SPDLOG_LOGGER_CATCH(location)                                                                                                  \
        catch (const std::exception &ex)                                                                                                   \
        {                                                                                                                                  \
            if (location.filename)                                                                                                         \
            {                                                                                                                              \
                err_handler_(fmt_lib::format("{} [{}({})]", ex.what(), location.filename, location.line));                                 \
            }                                                                                                                              \
            else                                                                                                                           \
            {                                                                                                                              \
                err_handler_(ex.what());                                                                                                   \
            }                                                                                                                              \
        }                                                                                                                                  \
        catch (...)                                                                                                                        \
        {                                                                                                                                  \
            err_handler_("Rethrowing unknown exception in logger");                                                                        \
            throw;                                                                                                                         \
        }
#else
#    define SPDLOG_LOGGER_CATCH(location)
#endif

namespace spdlog {

class SPDLOG_API logger
{
public:
    // Empty logger
    explicit logger(std::string name)
        : name_(std::move(name))
        , sinks_()
    {}

    // Logger with range on sinks
    template<typename It>
    logger(std::string name, It begin, It end)
        : name_(std::move(name))
        , sinks_(begin, end)
    {}

    // Logger with single sink
    logger(std::string name, sink_ptr single_sink)
        : logger(std::move(name), {std::move(single_sink)})
    {}

    // Logger with sinks init list
    logger(std::string name, sinks_init_list sinks)
        : logger(std::move(name), sinks.begin(), sinks.end())
    {}

    virtual ~logger() = default;

    logger(const logger &other);
    logger(logger &&other) SPDLOG_NOEXCEPT;
    logger &operator=(logger other) SPDLOG_NOEXCEPT;
    void swap(spdlog::logger &other) SPDLOG_NOEXCEPT;

    template<typename... Args>
    void log(source_loc loc, level::level_enum lvl, format_string_t<Args...> fmt, Args &&... args)
    {
        log_(loc, lvl, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void log(level::level_enum lvl, format_string_t<Args...> fmt, Args &&... args)
    {
        log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);
    }

    template<typename T>
    void log(level::level_enum lvl, const T &msg)
    {
        log(source_loc{}, lvl, msg);
    }

    // T cannot be statically converted to format string (including string_view/wstring_view)
    template<class T, typename std::enable_if<!is_convertible_to_any_format_string<const T &>::value, int>::type = 0>
    void log(source_loc loc, level::level_enum lvl, const T &msg)
    {
        log(loc, lvl, "{}", msg);
    }

    void log(log_clock::time_point log_time, source_loc loc, level::level_enum lvl, string_view_t msg)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }

        details::log_msg log_msg(log_time, loc, name_, lvl, msg);
        log_it_(log_msg, log_enabled, traceback_enabled);
    }

    void log(source_loc loc, level::level_enum lvl, string_view_t msg)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }

        details::log_msg log_msg(loc, name_, lvl, msg);
        log_it_(log_msg, log_enabled, traceback_enabled);
    }

    void log(level::level_enum lvl, string_view_t msg)
    {
        log(source_loc{}, lvl, msg);
    }

    template<typename... Args>
    void trace(format_string_t<Args...> fmt, Args &&... args)
    {
        log(level::trace, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void debug(format_string_t<Args...> fmt, Args &&... args)
    {
        log(level::debug, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void info(format_string_t<Args...> fmt, Args &&... args)
    {
        log(level::info, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void warn(format_string_t<Args...> fmt, Args &&... args)
    {
        log(level::warn, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void error(format_string_t<Args...> fmt, Args &&... args)
    {
        log(level::err, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void critical(format_string_t<Args...> fmt, Args &&... args)
    {
        log(level::critical, fmt, std::forward<Args>(args)...);
    }

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
    template<typename... Args>
    void log(source_loc loc, level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&... args)
    {
        log_(loc, lvl, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void log(level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);
    }

    void log(log_clock::time_point log_time, source_loc loc, level::level_enum lvl, wstring_view_t msg)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }

        memory_buf_t buf;
        details::os::wstr_to_utf8buf(wstring_view_t(msg.data(), msg.size()), buf);
        details::log_msg log_msg(log_time, loc, name_, lvl, string_view_t(buf.data(), buf.size()));
        log_it_(log_msg, log_enabled, traceback_enabled);
    }

    void log(source_loc loc, level::level_enum lvl, wstring_view_t msg)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }

        memory_buf_t buf;
        details::os::wstr_to_utf8buf(wstring_view_t(msg.data(), msg.size()), buf);
        details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));
        log_it_(log_msg, log_enabled, traceback_enabled);
    }

    void log(level::level_enum lvl, wstring_view_t msg)
    {
        log(source_loc{}, lvl, msg);
    }

    template<typename... Args>
    void trace(wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(level::trace, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void debug(wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(level::debug, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void info(wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(level::info, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void warn(wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(level::warn, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void error(wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(level::err, fmt, std::forward<Args>(args)...);
    }

    template<typename... Args>
    void critical(wformat_string_t<Args...> fmt, Args &&... args)
    {
        log(level::critical, fmt, std::forward<Args>(args)...);
    }
#endif

    template<typename T>
    void trace(const T &msg)
    {
        log(level::trace, msg);
    }

    template<typename T>
    void debug(const T &msg)
    {
        log(level::debug, msg);
    }

    template<typename T>
    void info(const T &msg)
    {
        log(level::info, msg);
    }

    template<typename T>
    void warn(const T &msg)
    {
        log(level::warn, msg);
    }

    template<typename T>
    void error(const T &msg)
    {
        log(level::err, msg);
    }

    template<typename T>
    void critical(const T &msg)
    {
        log(level::critical, msg);
    }

    // return true logging is enabled for the given level.
    bool should_log(level::level_enum msg_level) const
    {
        return msg_level >= level_.load(std::memory_order_relaxed);
    }

    // return true if backtrace logging is enabled.
    bool should_backtrace() const
    {
        return tracer_.enabled();
    }

    void set_level(level::level_enum log_level);

    level::level_enum level() const;

    const std::string &name() const;

    // set formatting for the sinks in this logger.
    // each sink will get a separate instance of the formatter object.
    void set_formatter(std::unique_ptr<formatter> f);

    void set_pattern(std::string pattern, pattern_time_type time_type = pattern_time_type::local);

    // backtrace support.
    // efficiently store all debug/trace messages in a circular buffer until needed for debugging.
    void enable_backtrace(size_t n_messages);
    void disable_backtrace();
    void dump_backtrace();

    // flush functions
    void flush();
    void flush_on(level::level_enum log_level);
    level::level_enum flush_level() const;

    // sinks
    const std::vector<sink_ptr> &sinks() const;

    std::vector<sink_ptr> &sinks();

    // error handler
    void set_error_handler(err_handler);

    // create new logger with same sinks and configuration.
    virtual std::shared_ptr<logger> clone(std::string logger_name);

protected:
    std::string name_;
    std::vector<sink_ptr> sinks_;
    spdlog::level_t level_{level::info};
    spdlog::level_t flush_level_{level::off};
    err_handler custom_err_handler_{nullptr};
    details::backtracer tracer_;

    // common implementation for after templated public api has been resolved
    template<typename... Args>
    void log_(source_loc loc, level::level_enum lvl, string_view_t fmt, Args &&... args)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }
        SPDLOG_TRY
        {
            memory_buf_t buf;
#ifdef SPDLOG_USE_STD_FORMAT
            fmt_lib::vformat_to(std::back_inserter(buf), fmt, fmt_lib::make_format_args(std::forward<Args>(args)...));
#else
            // seems that fmt::detail::vformat_to(buf, ...) is ~20ns faster than fmt::vformat_to(std::back_inserter(buf),..)
            fmt::detail::vformat_to(buf, fmt, fmt::make_format_args(std::forward<Args>(args)...));
#endif

            details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));
            log_it_(log_msg, log_enabled, traceback_enabled);
        }
        SPDLOG_LOGGER_CATCH(loc)
    }

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
    template<typename... Args>
    void log_(source_loc loc, level::level_enum lvl, wstring_view_t fmt, Args &&... args)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }
        SPDLOG_TRY
        {
            // format to wmemory_buffer and convert to utf8
            wmemory_buf_t wbuf;
#    ifdef SPDLOG_USE_STD_FORMAT
            fmt_lib::vformat_to(
                std::back_inserter(wbuf), fmt, fmt_lib::make_format_args<fmt_lib::wformat_context>(std::forward<Args>(args)...));
#    else
            fmt::detail::vformat_to(wbuf, fmt, fmt::make_format_args<fmt::wformat_context>(std::forward<Args>(args)...));
#    endif

            memory_buf_t buf;
            details::os::wstr_to_utf8buf(wstring_view_t(wbuf.data(), wbuf.size()), buf);
            details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));
            log_it_(log_msg, log_enabled, traceback_enabled);
        }
        SPDLOG_LOGGER_CATCH(loc)
    }

    // T can be statically converted to wstring_view, and no formatting needed.
    template<class T, typename std::enable_if<std::is_convertible<const T &, spdlog::wstring_view_t>::value, int>::type = 0>
    void log_(source_loc loc, level::level_enum lvl, const T &msg)
    {
        bool log_enabled = should_log(lvl);
        bool traceback_enabled = tracer_.enabled();
        if (!log_enabled && !traceback_enabled)
        {
            return;
        }
        SPDLOG_TRY
        {
            memory_buf_t buf;
            details::os::wstr_to_utf8buf(msg, buf);
            details::log_msg log_msg(loc, name_, lvl, string_view_t(buf.data(), buf.size()));
            log_it_(log_msg, log_enabled, traceback_enabled);
        }
        SPDLOG_LOGGER_CATCH(loc)
    }

#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT

    // log the given message (if the given log level is high enough),
    // and save backtrace (if backtrace is enabled).
    void log_it_(const details::log_msg &log_msg, bool log_enabled, bool traceback_enabled);
    virtual void sink_it_(const details::log_msg &msg);
    virtual void flush_();
    void dump_backtrace_();
    bool should_flush_(const details::log_msg &msg);

    // handle errors during logging.
    // default handler prints the error to stderr at max rate of 1 message/sec.
    void err_handler_(const std::string &msg);
};

void swap(logger &a, logger &b);

} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "logger-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/pattern_formatter-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/pattern_formatter.h>
#endif

#include <spdlog/details/fmt_helper.h>
#include <spdlog/details/log_msg.h>
#include <spdlog/details/os.h>
#include <spdlog/fmt/fmt.h>
#include <spdlog/formatter.h>

#include <algorithm>
#include <array>
#include <chrono>
#include <ctime>
#include <cctype>
#include <cstring>
#include <iterator>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <utility>
#include <vector>

namespace spdlog {
namespace details {

///////////////////////////////////////////////////////////////////////
// name & level pattern appender
///////////////////////////////////////////////////////////////////////

class scoped_padder
{
public:
    scoped_padder(size_t wrapped_size, const padding_info &padinfo, memory_buf_t &dest)
        : padinfo_(padinfo)
        , dest_(dest)
    {
        remaining_pad_ = static_cast<long>(padinfo.width_) - static_cast<long>(wrapped_size);
        if (remaining_pad_ <= 0)
        {
            return;
        }

        if (padinfo_.side_ == padding_info::pad_side::left)
        {
            pad_it(remaining_pad_);
            remaining_pad_ = 0;
        }
        else if (padinfo_.side_ == padding_info::pad_side::center)
        {
            auto half_pad = remaining_pad_ / 2;
            auto reminder = remaining_pad_ & 1;
            pad_it(half_pad);
            remaining_pad_ = half_pad + reminder; // for the right side
        }
    }

    template<typename T>
    static unsigned int count_digits(T n)
    {
        return fmt_helper::count_digits(n);
    }

    ~scoped_padder()
    {
        if (remaining_pad_ >= 0)
        {
            pad_it(remaining_pad_);
        }
        else if (padinfo_.truncate_)
        {
            long new_size = static_cast<long>(dest_.size()) + remaining_pad_;
            dest_.resize(static_cast<size_t>(new_size));
        }
    }

private:
    void pad_it(long count)
    {
        fmt_helper::append_string_view(string_view_t(spaces_.data(), static_cast<size_t>(count)), dest_);
    }

    const padding_info &padinfo_;
    memory_buf_t &dest_;
    long remaining_pad_;
    string_view_t spaces_{"                                                                ", 64};
};

struct null_scoped_padder
{
    null_scoped_padder(size_t /*wrapped_size*/, const padding_info & /*padinfo*/, memory_buf_t & /*dest*/) {}

    template<typename T>
    static unsigned int count_digits(T /* number */)
    {
        return 0;
    }
};

template<typename ScopedPadder>
class name_formatter final : public flag_formatter
{
public:
    explicit name_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        ScopedPadder p(msg.logger_name.size(), padinfo_, dest);
        fmt_helper::append_string_view(msg.logger_name, dest);
    }
};

// log level appender
template<typename ScopedPadder>
class level_formatter final : public flag_formatter
{
public:
    explicit level_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        const string_view_t &level_name = level::to_string_view(msg.level);
        ScopedPadder p(level_name.size(), padinfo_, dest);
        fmt_helper::append_string_view(level_name, dest);
    }
};

// short log level appender
template<typename ScopedPadder>
class short_level_formatter final : public flag_formatter
{
public:
    explicit short_level_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        string_view_t level_name{level::to_short_c_str(msg.level)};
        ScopedPadder p(level_name.size(), padinfo_, dest);
        fmt_helper::append_string_view(level_name, dest);
    }
};

///////////////////////////////////////////////////////////////////////
// Date time pattern appenders
///////////////////////////////////////////////////////////////////////

static const char *ampm(const tm &t)
{
    return t.tm_hour >= 12 ? "PM" : "AM";
}

static int to12h(const tm &t)
{
    return t.tm_hour > 12 ? t.tm_hour - 12 : t.tm_hour;
}

// Abbreviated weekday name
static std::array<const char *, 7> days{{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}};

template<typename ScopedPadder>
class a_formatter final : public flag_formatter
{
public:
    explicit a_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        string_view_t field_value{days[static_cast<size_t>(tm_time.tm_wday)]};
        ScopedPadder p(field_value.size(), padinfo_, dest);
        fmt_helper::append_string_view(field_value, dest);
    }
};

// Full weekday name
static std::array<const char *, 7> full_days{{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}};

template<typename ScopedPadder>
class A_formatter : public flag_formatter
{
public:
    explicit A_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        string_view_t field_value{full_days[static_cast<size_t>(tm_time.tm_wday)]};
        ScopedPadder p(field_value.size(), padinfo_, dest);
        fmt_helper::append_string_view(field_value, dest);
    }
};

// Abbreviated month
static const std::array<const char *, 12> months{{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"}};

template<typename ScopedPadder>
class b_formatter final : public flag_formatter
{
public:
    explicit b_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        string_view_t field_value{months[static_cast<size_t>(tm_time.tm_mon)]};
        ScopedPadder p(field_value.size(), padinfo_, dest);
        fmt_helper::append_string_view(field_value, dest);
    }
};

// Full month name
static const std::array<const char *, 12> full_months{
    {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}};

template<typename ScopedPadder>
class B_formatter final : public flag_formatter
{
public:
    explicit B_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        string_view_t field_value{full_months[static_cast<size_t>(tm_time.tm_mon)]};
        ScopedPadder p(field_value.size(), padinfo_, dest);
        fmt_helper::append_string_view(field_value, dest);
    }
};

// Date and time representation (Thu Aug 23 15:35:46 2014)
template<typename ScopedPadder>
class c_formatter final : public flag_formatter
{
public:
    explicit c_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 24;
        ScopedPadder p(field_size, padinfo_, dest);

        fmt_helper::append_string_view(days[static_cast<size_t>(tm_time.tm_wday)], dest);
        dest.push_back(' ');
        fmt_helper::append_string_view(months[static_cast<size_t>(tm_time.tm_mon)], dest);
        dest.push_back(' ');
        fmt_helper::append_int(tm_time.tm_mday, dest);
        dest.push_back(' ');
        // time

        fmt_helper::pad2(tm_time.tm_hour, dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_min, dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_sec, dest);
        dest.push_back(' ');
        fmt_helper::append_int(tm_time.tm_year + 1900, dest);
    }
};

// year - 2 digit
template<typename ScopedPadder>
class C_formatter final : public flag_formatter
{
public:
    explicit C_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(tm_time.tm_year % 100, dest);
    }
};

// Short MM/DD/YY date, equivalent to %m/%d/%y 08/23/01
template<typename ScopedPadder>
class D_formatter final : public flag_formatter
{
public:
    explicit D_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 10;
        ScopedPadder p(field_size, padinfo_, dest);

        fmt_helper::pad2(tm_time.tm_mon + 1, dest);
        dest.push_back('/');
        fmt_helper::pad2(tm_time.tm_mday, dest);
        dest.push_back('/');
        fmt_helper::pad2(tm_time.tm_year % 100, dest);
    }
};

// year - 4 digit
template<typename ScopedPadder>
class Y_formatter final : public flag_formatter
{
public:
    explicit Y_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 4;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::append_int(tm_time.tm_year + 1900, dest);
    }
};

// month 1-12
template<typename ScopedPadder>
class m_formatter final : public flag_formatter
{
public:
    explicit m_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(tm_time.tm_mon + 1, dest);
    }
};

// day of month 1-31
template<typename ScopedPadder>
class d_formatter final : public flag_formatter
{
public:
    explicit d_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(tm_time.tm_mday, dest);
    }
};

// hours in 24 format 0-23
template<typename ScopedPadder>
class H_formatter final : public flag_formatter
{
public:
    explicit H_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(tm_time.tm_hour, dest);
    }
};

// hours in 12 format 1-12
template<typename ScopedPadder>
class I_formatter final : public flag_formatter
{
public:
    explicit I_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(to12h(tm_time), dest);
    }
};

// minutes 0-59
template<typename ScopedPadder>
class M_formatter final : public flag_formatter
{
public:
    explicit M_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(tm_time.tm_min, dest);
    }
};

// seconds 0-59
template<typename ScopedPadder>
class S_formatter final : public flag_formatter
{
public:
    explicit S_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad2(tm_time.tm_sec, dest);
    }
};

// milliseconds
template<typename ScopedPadder>
class e_formatter final : public flag_formatter
{
public:
    explicit e_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        auto millis = fmt_helper::time_fraction<std::chrono::milliseconds>(msg.time);
        const size_t field_size = 3;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad3(static_cast<uint32_t>(millis.count()), dest);
    }
};

// microseconds
template<typename ScopedPadder>
class f_formatter final : public flag_formatter
{
public:
    explicit f_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        auto micros = fmt_helper::time_fraction<std::chrono::microseconds>(msg.time);

        const size_t field_size = 6;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad6(static_cast<size_t>(micros.count()), dest);
    }
};

// nanoseconds
template<typename ScopedPadder>
class F_formatter final : public flag_formatter
{
public:
    explicit F_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        auto ns = fmt_helper::time_fraction<std::chrono::nanoseconds>(msg.time);
        const size_t field_size = 9;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::pad9(static_cast<size_t>(ns.count()), dest);
    }
};

// seconds since epoch
template<typename ScopedPadder>
class E_formatter final : public flag_formatter
{
public:
    explicit E_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        const size_t field_size = 10;
        ScopedPadder p(field_size, padinfo_, dest);
        auto duration = msg.time.time_since_epoch();
        auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
        fmt_helper::append_int(seconds, dest);
    }
};

// AM/PM
template<typename ScopedPadder>
class p_formatter final : public flag_formatter
{
public:
    explicit p_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 2;
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::append_string_view(ampm(tm_time), dest);
    }
};

// 12 hour clock 02:55:02 pm
template<typename ScopedPadder>
class r_formatter final : public flag_formatter
{
public:
    explicit r_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 11;
        ScopedPadder p(field_size, padinfo_, dest);

        fmt_helper::pad2(to12h(tm_time), dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_min, dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_sec, dest);
        dest.push_back(' ');
        fmt_helper::append_string_view(ampm(tm_time), dest);
    }
};

// 24-hour HH:MM time, equivalent to %H:%M
template<typename ScopedPadder>
class R_formatter final : public flag_formatter
{
public:
    explicit R_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 5;
        ScopedPadder p(field_size, padinfo_, dest);

        fmt_helper::pad2(tm_time.tm_hour, dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_min, dest);
    }
};

// ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S
template<typename ScopedPadder>
class T_formatter final : public flag_formatter
{
public:
    explicit T_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 8;
        ScopedPadder p(field_size, padinfo_, dest);

        fmt_helper::pad2(tm_time.tm_hour, dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_min, dest);
        dest.push_back(':');
        fmt_helper::pad2(tm_time.tm_sec, dest);
    }
};

// ISO 8601 offset from UTC in timezone (+-HH:MM)
template<typename ScopedPadder>
class z_formatter final : public flag_formatter
{
public:
    explicit z_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    z_formatter() = default;
    z_formatter(const z_formatter &) = delete;
    z_formatter &operator=(const z_formatter &) = delete;

    void format(const details::log_msg &msg, const std::tm &tm_time, memory_buf_t &dest) override
    {
        const size_t field_size = 6;
        ScopedPadder p(field_size, padinfo_, dest);

        auto total_minutes = get_cached_offset(msg, tm_time);
        bool is_negative = total_minutes < 0;
        if (is_negative)
        {
            total_minutes = -total_minutes;
            dest.push_back('-');
        }
        else
        {
            dest.push_back('+');
        }

        fmt_helper::pad2(total_minutes / 60, dest); // hours
        dest.push_back(':');
        fmt_helper::pad2(total_minutes % 60, dest); // minutes
    }

private:
    log_clock::time_point last_update_{std::chrono::seconds(0)};
    int offset_minutes_{0};

    int get_cached_offset(const log_msg &msg, const std::tm &tm_time)
    {
        // refresh every 10 seconds
        if (msg.time - last_update_ >= std::chrono::seconds(10))
        {
            offset_minutes_ = os::utc_minutes_offset(tm_time);
            last_update_ = msg.time;
        }
        return offset_minutes_;
    }
};

// Thread id
template<typename ScopedPadder>
class t_formatter final : public flag_formatter
{
public:
    explicit t_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        const auto field_size = ScopedPadder::count_digits(msg.thread_id);
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::append_int(msg.thread_id, dest);
    }
};

// Current pid
template<typename ScopedPadder>
class pid_formatter final : public flag_formatter
{
public:
    explicit pid_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &, const std::tm &, memory_buf_t &dest) override
    {
        const auto pid = static_cast<uint32_t>(details::os::pid());
        auto field_size = ScopedPadder::count_digits(pid);
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::append_int(pid, dest);
    }
};

template<typename ScopedPadder>
class v_formatter final : public flag_formatter
{
public:
    explicit v_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        ScopedPadder p(msg.payload.size(), padinfo_, dest);
        fmt_helper::append_string_view(msg.payload, dest);
    }
};

class ch_formatter final : public flag_formatter
{
public:
    explicit ch_formatter(char ch)
        : ch_(ch)
    {}

    void format(const details::log_msg &, const std::tm &, memory_buf_t &dest) override
    {
        dest.push_back(ch_);
    }

private:
    char ch_;
};

// aggregate user chars to display as is
class aggregate_formatter final : public flag_formatter
{
public:
    aggregate_formatter() = default;

    void add_ch(char ch)
    {
        str_ += ch;
    }
    void format(const details::log_msg &, const std::tm &, memory_buf_t &dest) override
    {
        fmt_helper::append_string_view(str_, dest);
    }

private:
    std::string str_;
};

// mark the color range. expect it to be in the form of "%^colored text%$"
class color_start_formatter final : public flag_formatter
{
public:
    explicit color_start_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        msg.color_range_start = dest.size();
    }
};

class color_stop_formatter final : public flag_formatter
{
public:
    explicit color_stop_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        msg.color_range_end = dest.size();
    }
};

// print source location
template<typename ScopedPadder>
class source_location_formatter final : public flag_formatter
{
public:
    explicit source_location_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        if (msg.source.empty())
        {
            ScopedPadder p(0, padinfo_, dest);
            return;
        }

        size_t text_size;
        if (padinfo_.enabled())
        {
            // calc text size for padding based on "filename:line"
            text_size = std::char_traits<char>::length(msg.source.filename) + ScopedPadder::count_digits(msg.source.line) + 1;
        }
        else
        {
            text_size = 0;
        }

        ScopedPadder p(text_size, padinfo_, dest);
        fmt_helper::append_string_view(msg.source.filename, dest);
        dest.push_back(':');
        fmt_helper::append_int(msg.source.line, dest);
    }
};

// print source filename
template<typename ScopedPadder>
class source_filename_formatter final : public flag_formatter
{
public:
    explicit source_filename_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        if (msg.source.empty())
        {
            ScopedPadder p(0, padinfo_, dest);
            return;
        }
        size_t text_size = padinfo_.enabled() ? std::char_traits<char>::length(msg.source.filename) : 0;
        ScopedPadder p(text_size, padinfo_, dest);
        fmt_helper::append_string_view(msg.source.filename, dest);
    }
};

template<typename ScopedPadder>
class short_filename_formatter final : public flag_formatter
{
public:
    explicit short_filename_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

#ifdef _MSC_VER
#    pragma warning(push)
#    pragma warning(disable : 4127) // consider using 'if constexpr' instead
#endif                              // _MSC_VER
    static const char *basename(const char *filename)
    {
        // if the size is 2 (1 character + null terminator) we can use the more efficient strrchr
        // the branch will be elided by optimizations
        if (sizeof(os::folder_seps) == 2)
        {
            const char *rv = std::strrchr(filename, os::folder_seps[0]);
            return rv != nullptr ? rv + 1 : filename;
        }
        else
        {
            const std::reverse_iterator<const char *> begin(filename + std::strlen(filename));
            const std::reverse_iterator<const char *> end(filename);

            const auto it = std::find_first_of(begin, end, std::begin(os::folder_seps), std::end(os::folder_seps) - 1);
            return it != end ? it.base() : filename;
        }
    }
#ifdef _MSC_VER
#    pragma warning(pop)
#endif // _MSC_VER

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        if (msg.source.empty())
        {
            ScopedPadder p(0, padinfo_, dest);
            return;
        }
        auto filename = basename(msg.source.filename);
        size_t text_size = padinfo_.enabled() ? std::char_traits<char>::length(filename) : 0;
        ScopedPadder p(text_size, padinfo_, dest);
        fmt_helper::append_string_view(filename, dest);
    }
};

template<typename ScopedPadder>
class source_linenum_formatter final : public flag_formatter
{
public:
    explicit source_linenum_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        if (msg.source.empty())
        {
            ScopedPadder p(0, padinfo_, dest);
            return;
        }

        auto field_size = ScopedPadder::count_digits(msg.source.line);
        ScopedPadder p(field_size, padinfo_, dest);
        fmt_helper::append_int(msg.source.line, dest);
    }
};

// print source funcname
template<typename ScopedPadder>
class source_funcname_formatter final : public flag_formatter
{
public:
    explicit source_funcname_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        if (msg.source.empty())
        {
            ScopedPadder p(0, padinfo_, dest);
            return;
        }
        size_t text_size = padinfo_.enabled() ? std::char_traits<char>::length(msg.source.funcname) : 0;
        ScopedPadder p(text_size, padinfo_, dest);
        fmt_helper::append_string_view(msg.source.funcname, dest);
    }
};

// print elapsed time since last message
template<typename ScopedPadder, typename Units>
class elapsed_formatter final : public flag_formatter
{
public:
    using DurationUnits = Units;

    explicit elapsed_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
        , last_message_time_(log_clock::now())
    {}

    void format(const details::log_msg &msg, const std::tm &, memory_buf_t &dest) override
    {
        auto delta = (std::max)(msg.time - last_message_time_, log_clock::duration::zero());
        auto delta_units = std::chrono::duration_cast<DurationUnits>(delta);
        last_message_time_ = msg.time;
        auto delta_count = static_cast<size_t>(delta_units.count());
        auto n_digits = static_cast<size_t>(ScopedPadder::count_digits(delta_count));
        ScopedPadder p(n_digits, padinfo_, dest);
        fmt_helper::append_int(delta_count, dest);
    }

private:
    log_clock::time_point last_message_time_;
};

// Full info formatter
// pattern: [%Y-%m-%d %H:%M:%S.%e] [%n] [%l] [%s:%#] %v
class full_formatter final : public flag_formatter
{
public:
    explicit full_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {}

    void format(const details::log_msg &msg, const std::tm &tm_time, memory_buf_t &dest) override
    {
        using std::chrono::duration_cast;
        using std::chrono::milliseconds;
        using std::chrono::seconds;

        // cache the date/time part for the next second.
        auto duration = msg.time.time_since_epoch();
        auto secs = duration_cast<seconds>(duration);

        if (cache_timestamp_ != secs || cached_datetime_.size() == 0)
        {
            cached_datetime_.clear();
            cached_datetime_.push_back('[');
            fmt_helper::append_int(tm_time.tm_year + 1900, cached_datetime_);
            cached_datetime_.push_back('-');

            fmt_helper::pad2(tm_time.tm_mon + 1, cached_datetime_);
            cached_datetime_.push_back('-');

            fmt_helper::pad2(tm_time.tm_mday, cached_datetime_);
            cached_datetime_.push_back(' ');

            fmt_helper::pad2(tm_time.tm_hour, cached_datetime_);
            cached_datetime_.push_back(':');

            fmt_helper::pad2(tm_time.tm_min, cached_datetime_);
            cached_datetime_.push_back(':');

            fmt_helper::pad2(tm_time.tm_sec, cached_datetime_);
            cached_datetime_.push_back('.');

            cache_timestamp_ = secs;
        }
        dest.append(cached_datetime_.begin(), cached_datetime_.end());

        auto millis = fmt_helper::time_fraction<milliseconds>(msg.time);
        fmt_helper::pad3(static_cast<uint32_t>(millis.count()), dest);
        dest.push_back(']');
        dest.push_back(' ');

        // append logger name if exists
        if (msg.logger_name.size() > 0)
        {
            dest.push_back('[');
            fmt_helper::append_string_view(msg.logger_name, dest);
            dest.push_back(']');
            dest.push_back(' ');
        }

        dest.push_back('[');
        // wrap the level name with color
        msg.color_range_start = dest.size();
        // fmt_helper::append_string_view(level::to_c_str(msg.level), dest);
        fmt_helper::append_string_view(level::to_string_view(msg.level), dest);
        msg.color_range_end = dest.size();
        dest.push_back(']');
        dest.push_back(' ');

        // add source location if present
        if (!msg.source.empty())
        {
            dest.push_back('[');
            const char *filename = details::short_filename_formatter<details::null_scoped_padder>::basename(msg.source.filename);
            fmt_helper::append_string_view(filename, dest);
            dest.push_back(':');
            fmt_helper::append_int(msg.source.line, dest);
            dest.push_back(']');
            dest.push_back(' ');
        }
        // fmt_helper::append_string_view(msg.msg(), dest);
        fmt_helper::append_string_view(msg.payload, dest);
    }

private:
    std::chrono::seconds cache_timestamp_{0};
    memory_buf_t cached_datetime_;
};

} // namespace details

SPDLOG_INLINE pattern_formatter::pattern_formatter(
    std::string pattern, pattern_time_type time_type, std::string eol, custom_flags custom_user_flags)
    : pattern_(std::move(pattern))
    , eol_(std::move(eol))
    , pattern_time_type_(time_type)
    , need_localtime_(false)
    , last_log_secs_(0)
    , custom_handlers_(std::move(custom_user_flags))
{
    std::memset(&cached_tm_, 0, sizeof(cached_tm_));
    compile_pattern_(pattern_);
}

// use by default full formatter for if pattern is not given
SPDLOG_INLINE pattern_formatter::pattern_formatter(pattern_time_type time_type, std::string eol)
    : pattern_("%+")
    , eol_(std::move(eol))
    , pattern_time_type_(time_type)
    , need_localtime_(true)
    , last_log_secs_(0)
{
    std::memset(&cached_tm_, 0, sizeof(cached_tm_));
    formatters_.push_back(details::make_unique<details::full_formatter>(details::padding_info{}));
}

SPDLOG_INLINE std::unique_ptr<formatter> pattern_formatter::clone() const
{
    custom_flags cloned_custom_formatters;
    for (auto &it : custom_handlers_)
    {
        cloned_custom_formatters[it.first] = it.second->clone();
    }
    auto cloned = details::make_unique<pattern_formatter>(pattern_, pattern_time_type_, eol_, std::move(cloned_custom_formatters));
    cloned->need_localtime(need_localtime_);
    return cloned;
}

SPDLOG_INLINE void pattern_formatter::format(const details::log_msg &msg, memory_buf_t &dest)
{
    if (need_localtime_)
    {
        const auto secs = std::chrono::duration_cast<std::chrono::seconds>(msg.time.time_since_epoch());
        if (secs != last_log_secs_)
        {
            cached_tm_ = get_time_(msg);
            last_log_secs_ = secs;
        }
    }

    for (auto &f : formatters_)
    {
        f->format(msg, cached_tm_, dest);
    }
    // write eol
    details::fmt_helper::append_string_view(eol_, dest);
}

SPDLOG_INLINE void pattern_formatter::set_pattern(std::string pattern)
{
    pattern_ = std::move(pattern);
    need_localtime_ = false;
    compile_pattern_(pattern_);
}

SPDLOG_INLINE void pattern_formatter::need_localtime(bool need)
{
    need_localtime_ = need;
}

SPDLOG_INLINE std::tm pattern_formatter::get_time_(const details::log_msg &msg)
{
    if (pattern_time_type_ == pattern_time_type::local)
    {
        return details::os::localtime(log_clock::to_time_t(msg.time));
    }
    return details::os::gmtime(log_clock::to_time_t(msg.time));
}

template<typename Padder>
SPDLOG_INLINE void pattern_formatter::handle_flag_(char flag, details::padding_info padding)
{
    // process custom flags
    auto it = custom_handlers_.find(flag);
    if (it != custom_handlers_.end())
    {
        auto custom_handler = it->second->clone();
        custom_handler->set_padding_info(padding);
        formatters_.push_back(std::move(custom_handler));
        return;
    }

    // process built-in flags
    switch (flag)
    {
    case ('+'): // default formatter
        formatters_.push_back(details::make_unique<details::full_formatter>(padding));
        need_localtime_ = true;
        break;

    case 'n': // logger name
        formatters_.push_back(details::make_unique<details::name_formatter<Padder>>(padding));
        break;

    case 'l': // level
        formatters_.push_back(details::make_unique<details::level_formatter<Padder>>(padding));
        break;

    case 'L': // short level
        formatters_.push_back(details::make_unique<details::short_level_formatter<Padder>>(padding));
        break;

    case ('t'): // thread id
        formatters_.push_back(details::make_unique<details::t_formatter<Padder>>(padding));
        break;

    case ('v'): // the message text
        formatters_.push_back(details::make_unique<details::v_formatter<Padder>>(padding));
        break;

    case ('a'): // weekday
        formatters_.push_back(details::make_unique<details::a_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('A'): // short weekday
        formatters_.push_back(details::make_unique<details::A_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('b'):
    case ('h'): // month
        formatters_.push_back(details::make_unique<details::b_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('B'): // short month
        formatters_.push_back(details::make_unique<details::B_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('c'): // datetime
        formatters_.push_back(details::make_unique<details::c_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('C'): // year 2 digits
        formatters_.push_back(details::make_unique<details::C_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('Y'): // year 4 digits
        formatters_.push_back(details::make_unique<details::Y_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('D'):
    case ('x'): // datetime MM/DD/YY
        formatters_.push_back(details::make_unique<details::D_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('m'): // month 1-12
        formatters_.push_back(details::make_unique<details::m_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('d'): // day of month 1-31
        formatters_.push_back(details::make_unique<details::d_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('H'): // hours 24
        formatters_.push_back(details::make_unique<details::H_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('I'): // hours 12
        formatters_.push_back(details::make_unique<details::I_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('M'): // minutes
        formatters_.push_back(details::make_unique<details::M_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('S'): // seconds
        formatters_.push_back(details::make_unique<details::S_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('e'): // milliseconds
        formatters_.push_back(details::make_unique<details::e_formatter<Padder>>(padding));
        break;

    case ('f'): // microseconds
        formatters_.push_back(details::make_unique<details::f_formatter<Padder>>(padding));
        break;

    case ('F'): // nanoseconds
        formatters_.push_back(details::make_unique<details::F_formatter<Padder>>(padding));
        break;

    case ('E'): // seconds since epoch
        formatters_.push_back(details::make_unique<details::E_formatter<Padder>>(padding));
        break;

    case ('p'): // am/pm
        formatters_.push_back(details::make_unique<details::p_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('r'): // 12 hour clock 02:55:02 pm
        formatters_.push_back(details::make_unique<details::r_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('R'): // 24-hour HH:MM time
        formatters_.push_back(details::make_unique<details::R_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('T'):
    case ('X'): // ISO 8601 time format (HH:MM:SS)
        formatters_.push_back(details::make_unique<details::T_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('z'): // timezone
        formatters_.push_back(details::make_unique<details::z_formatter<Padder>>(padding));
        need_localtime_ = true;
        break;

    case ('P'): // pid
        formatters_.push_back(details::make_unique<details::pid_formatter<Padder>>(padding));
        break;

    case ('^'): // color range start
        formatters_.push_back(details::make_unique<details::color_start_formatter>(padding));
        break;

    case ('$'): // color range end
        formatters_.push_back(details::make_unique<details::color_stop_formatter>(padding));
        break;

    case ('@'): // source location (filename:filenumber)
        formatters_.push_back(details::make_unique<details::source_location_formatter<Padder>>(padding));
        break;

    case ('s'): // short source filename - without directory name
        formatters_.push_back(details::make_unique<details::short_filename_formatter<Padder>>(padding));
        break;

    case ('g'): // full source filename
        formatters_.push_back(details::make_unique<details::source_filename_formatter<Padder>>(padding));
        break;

    case ('#'): // source line number
        formatters_.push_back(details::make_unique<details::source_linenum_formatter<Padder>>(padding));
        break;

    case ('!'): // source funcname
        formatters_.push_back(details::make_unique<details::source_funcname_formatter<Padder>>(padding));
        break;

    case ('%'): // % char
        formatters_.push_back(details::make_unique<details::ch_formatter>('%'));
        break;

    case ('u'): // elapsed time since last log message in nanos
        formatters_.push_back(details::make_unique<details::elapsed_formatter<Padder, std::chrono::nanoseconds>>(padding));
        break;

    case ('i'): // elapsed time since last log message in micros
        formatters_.push_back(details::make_unique<details::elapsed_formatter<Padder, std::chrono::microseconds>>(padding));
        break;

    case ('o'): // elapsed time since last log message in millis
        formatters_.push_back(details::make_unique<details::elapsed_formatter<Padder, std::chrono::milliseconds>>(padding));
        break;

    case ('O'): // elapsed time since last log message in seconds
        formatters_.push_back(details::make_unique<details::elapsed_formatter<Padder, std::chrono::seconds>>(padding));
        break;

    default: // Unknown flag appears as is
        auto unknown_flag = details::make_unique<details::aggregate_formatter>();

        if (!padding.truncate_)
        {
            unknown_flag->add_ch('%');
            unknown_flag->add_ch(flag);
            formatters_.push_back((std::move(unknown_flag)));
        }
        // fix issue #1617 (prev char was '!' and should have been treated as funcname flag instead of truncating flag)
        // spdlog::set_pattern("[%10!] %v") => "[      main] some message"
        // spdlog::set_pattern("[%3!!] %v") => "[mai] some message"
        else
        {
            padding.truncate_ = false;
            formatters_.push_back(details::make_unique<details::source_funcname_formatter<Padder>>(padding));
            unknown_flag->add_ch(flag);
            formatters_.push_back((std::move(unknown_flag)));
        }

        break;
    }
}

// Extract given pad spec (e.g. %8X, %=8X, %-8!X, %8!X, %=8!X, %-8!X, %+8!X)
// Advance the given it pass the end of the padding spec found (if any)
// Return padding.
SPDLOG_INLINE details::padding_info pattern_formatter::handle_padspec_(std::string::const_iterator &it, std::string::const_iterator end)
{
    using details::padding_info;
    using details::scoped_padder;
    const size_t max_width = 64;
    if (it == end)
    {
        return padding_info{};
    }

    padding_info::pad_side side;
    switch (*it)
    {
    case '-':
        side = padding_info::pad_side::right;
        ++it;
        break;
    case '=':
        side = padding_info::pad_side::center;
        ++it;
        break;
    default:
        side = details::padding_info::pad_side::left;
        break;
    }

    if (it == end || !std::isdigit(static_cast<unsigned char>(*it)))
    {
        return padding_info{}; // no padding if no digit found here
    }

    auto width = static_cast<size_t>(*it) - '0';
    for (++it; it != end && std::isdigit(static_cast<unsigned char>(*it)); ++it)
    {
        auto digit = static_cast<size_t>(*it) - '0';
        width = width * 10 + digit;
    }

    // search for the optional truncate marker '!'
    bool truncate;
    if (it != end && *it == '!')
    {
        truncate = true;
        ++it;
    }
    else
    {
        truncate = false;
    }
    return details::padding_info{std::min<size_t>(width, max_width), side, truncate};
}

SPDLOG_INLINE void pattern_formatter::compile_pattern_(const std::string &pattern)
{
    auto end = pattern.end();
    std::unique_ptr<details::aggregate_formatter> user_chars;
    formatters_.clear();
    for (auto it = pattern.begin(); it != end; ++it)
    {
        if (*it == '%')
        {
            if (user_chars) // append user chars found so far
            {
                formatters_.push_back(std::move(user_chars));
            }

            auto padding = handle_padspec_(++it, end);

            if (it != end)
            {
                if (padding.enabled())
                {
                    handle_flag_<details::scoped_padder>(*it, padding);
                }
                else
                {
                    handle_flag_<details::null_scoped_padder>(*it, padding);
                }
            }
            else
            {
                break;
            }
        }
        else // chars not following the % sign should be displayed as is
        {
            if (!user_chars)
            {
                user_chars = details::make_unique<details::aggregate_formatter>();
            }
            user_chars->add_ch(*it);
        }
    }
    if (user_chars) // append raw chars found so far
    {
        formatters_.push_back(std::move(user_chars));
    }
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/pattern_formatter.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#pragma warning(disable:4275)
#endif

#include <spdlog/common.h>
#include <spdlog/details/log_msg.h>
#include <spdlog/details/os.h>
#include <spdlog/formatter.h>

#include <chrono>
#include <ctime>
#include <memory>

#include <string>
#include <vector>
#include <unordered_map>

namespace spdlog {
namespace details {

// padding information.
struct padding_info
{
    enum class pad_side
    {
        left,
        right,
        center
    };

    padding_info() = default;
    padding_info(size_t width, padding_info::pad_side side, bool truncate)
        : width_(width)
        , side_(side)
        , truncate_(truncate)
        , enabled_(true)
    {}

    bool enabled() const
    {
        return enabled_;
    }
    size_t width_ = 0;
    pad_side side_ = pad_side::left;
    bool truncate_ = false;
    bool enabled_ = false;
};

class SPDLOG_API flag_formatter
{
public:
    explicit flag_formatter(padding_info padinfo)
        : padinfo_(padinfo)
    {}
    flag_formatter() = default;
    virtual ~flag_formatter() = default;
    virtual void format(const details::log_msg &msg, const std::tm &tm_time, memory_buf_t &dest) = 0;

protected:
    padding_info padinfo_;
};

} // namespace details

class SPDLOG_API custom_flag_formatter : public details::flag_formatter
{
public:
    virtual std::unique_ptr<custom_flag_formatter> clone() const = 0;

    void set_padding_info(const details::padding_info &padding)
    {
        flag_formatter::padinfo_ = padding;
    }
};

class SPDLOG_API pattern_formatter final : public formatter
{
public:
    using custom_flags = std::unordered_map<char, std::unique_ptr<custom_flag_formatter>>;

    explicit pattern_formatter(std::string pattern, pattern_time_type time_type = pattern_time_type::local,
        std::string eol = spdlog::details::os::default_eol, custom_flags custom_user_flags = custom_flags());

    // use default pattern is not given
    explicit pattern_formatter(pattern_time_type time_type = pattern_time_type::local, std::string eol = spdlog::details::os::default_eol);

    pattern_formatter(const pattern_formatter &other) = delete;
    pattern_formatter &operator=(const pattern_formatter &other) = delete;

    std::unique_ptr<formatter> clone() const override;
    void format(const details::log_msg &msg, memory_buf_t &dest) override;

    template<typename T, typename... Args>
    pattern_formatter &add_flag(char flag, Args &&... args)
    {
        custom_handlers_[flag] = details::make_unique<T>(std::forward<Args>(args)...);
        return *this;
    }
    void set_pattern(std::string pattern);
    void need_localtime(bool need = true);

private:
    std::string pattern_;
    std::string eol_;
    pattern_time_type pattern_time_type_;
    bool need_localtime_;
    std::tm cached_tm_;
    std::chrono::seconds last_log_secs_;
    std::vector<std::unique_ptr<details::flag_formatter>> formatters_;
    custom_flags custom_handlers_;

    std::tm get_time_(const details::log_msg &msg);
    template<typename Padder>
    void handle_flag_(char flag, details::padding_info padding);

    // Extract given pad spec (e.g. %8X)
    // Advance the given it pass the end of the padding spec found (if any)
    // Return padding.
    static details::padding_info handle_padspec_(std::string::const_iterator &it, std::string::const_iterator end);

    void compile_pattern_(const std::string &pattern);
};
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "pattern_formatter-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/android_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifdef __ANDROID__

#    include <spdlog/details/fmt_helper.h>
#    include <spdlog/details/null_mutex.h>
#    include <spdlog/details/os.h>
#    include <spdlog/sinks/base_sink.h>
#    include <spdlog/details/synchronous_factory.h>

#    include <android/log.h>
#    include <chrono>
#    include <mutex>
#    include <string>
#    include <thread>
#    include <type_traits>

#    if !defined(SPDLOG_ANDROID_RETRIES)
#        define SPDLOG_ANDROID_RETRIES 2
#    endif

namespace spdlog {
namespace sinks {

/*
 * Android sink
 * (logging using __android_log_write or __android_log_buf_write depending on the specified BufferID)
 */
template<typename Mutex, int BufferID = log_id::LOG_ID_MAIN>
class android_sink final : public base_sink<Mutex>
{
public:
    explicit android_sink(std::string tag = "spdlog", bool use_raw_msg = false)
        : tag_(std::move(tag))
        , use_raw_msg_(use_raw_msg)
    {}

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        const android_LogPriority priority = convert_to_android_(msg.level);
        memory_buf_t formatted;
        if (use_raw_msg_)
        {
            details::fmt_helper::append_string_view(msg.payload, formatted);
        }
        else
        {
            base_sink<Mutex>::formatter_->format(msg, formatted);
        }
        formatted.push_back('\0');
        const char *msg_output = formatted.data();

        // See system/core/liblog/logger_write.c for explanation of return value
        int ret = android_log(priority, tag_.c_str(), msg_output);
        int retry_count = 0;
        while ((ret == -11 /*EAGAIN*/) && (retry_count < SPDLOG_ANDROID_RETRIES))
        {
            details::os::sleep_for_millis(5);
            ret = android_log(priority, tag_.c_str(), msg_output);
            retry_count++;
        }

        if (ret < 0)
        {
            throw_spdlog_ex("logging to Android failed", ret);
        }
    }

    void flush_() override {}

private:
    // There might be liblog versions used, that do not support __android_log_buf_write. So we only compile and link against
    // __android_log_buf_write, if user explicitely provides a non-default log buffer. Otherwise, when using the default log buffer, always
    // log via __android_log_write.
    template<int ID = BufferID>
    typename std::enable_if<ID == static_cast<int>(log_id::LOG_ID_MAIN), int>::type android_log(int prio, const char *tag, const char *text)
    {
        return __android_log_write(prio, tag, text);
    }

    template<int ID = BufferID>
    typename std::enable_if<ID != static_cast<int>(log_id::LOG_ID_MAIN), int>::type android_log(int prio, const char *tag, const char *text)
    {
        return __android_log_buf_write(ID, prio, tag, text);
    }

    static android_LogPriority convert_to_android_(spdlog::level::level_enum level)
    {
        switch (level)
        {
        case spdlog::level::trace:
            return ANDROID_LOG_VERBOSE;
        case spdlog::level::debug:
            return ANDROID_LOG_DEBUG;
        case spdlog::level::info:
            return ANDROID_LOG_INFO;
        case spdlog::level::warn:
            return ANDROID_LOG_WARN;
        case spdlog::level::err:
            return ANDROID_LOG_ERROR;
        case spdlog::level::critical:
            return ANDROID_LOG_FATAL;
        default:
            return ANDROID_LOG_DEFAULT;
        }
    }

    std::string tag_;
    bool use_raw_msg_;
};

using android_sink_mt = android_sink<std::mutex>;
using android_sink_st = android_sink<details::null_mutex>;

template<int BufferId = log_id::LOG_ID_MAIN>
using android_sink_buf_mt = android_sink<std::mutex, BufferId>;
template<int BufferId = log_id::LOG_ID_MAIN>
using android_sink_buf_st = android_sink<details::null_mutex, BufferId>;

} // namespace sinks

// Create and register android syslog logger

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> android_logger_mt(const std::string &logger_name, const std::string &tag = "spdlog")
{
    return Factory::template create<sinks::android_sink_mt>(logger_name, tag);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> android_logger_st(const std::string &logger_name, const std::string &tag = "spdlog")
{
    return Factory::template create<sinks::android_sink_st>(logger_name, tag);
}

} // namespace spdlog

#endif // __ANDROID__
```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/ansicolor_sink-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/ansicolor_sink.h>
#endif

#include <spdlog/pattern_formatter.h>
#include <spdlog/details/os.h>

namespace spdlog {
namespace sinks {

template<typename ConsoleMutex>
SPDLOG_INLINE ansicolor_sink<ConsoleMutex>::ansicolor_sink(FILE *target_file, color_mode mode)
    : target_file_(target_file)
    , mutex_(ConsoleMutex::mutex())
    , formatter_(details::make_unique<spdlog::pattern_formatter>())

{
    set_color_mode(mode);
    colors_[level::trace] = to_string_(white);
    colors_[level::debug] = to_string_(cyan);
    colors_[level::info] = to_string_(green);
    colors_[level::warn] = to_string_(yellow_bold);
    colors_[level::err] = to_string_(red_bold);
    colors_[level::critical] = to_string_(bold_on_red);
    colors_[level::off] = to_string_(reset);
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_color(level::level_enum color_level, string_view_t color)
{
    std::lock_guard<mutex_t> lock(mutex_);
    colors_[static_cast<size_t>(color_level)] = to_string_(color);
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::log(const details::log_msg &msg)
{
    // Wrap the originally formatted message in color codes.
    // If color is not supported in the terminal, log as is instead.
    std::lock_guard<mutex_t> lock(mutex_);
    msg.color_range_start = 0;
    msg.color_range_end = 0;
    memory_buf_t formatted;
    formatter_->format(msg, formatted);
    if (should_do_colors_ && msg.color_range_end > msg.color_range_start)
    {
        // before color range
        print_range_(formatted, 0, msg.color_range_start);
        // in color range
        print_ccode_(colors_[static_cast<size_t>(msg.level)]);
        print_range_(formatted, msg.color_range_start, msg.color_range_end);
        print_ccode_(reset);
        // after color range
        print_range_(formatted, msg.color_range_end, formatted.size());
    }
    else // no color
    {
        print_range_(formatted, 0, formatted.size());
    }
    fflush(target_file_);
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::flush()
{
    std::lock_guard<mutex_t> lock(mutex_);
    fflush(target_file_);
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_pattern(const std::string &pattern)
{
    std::lock_guard<mutex_t> lock(mutex_);
    formatter_ = std::unique_ptr<spdlog::formatter>(new pattern_formatter(pattern));
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter)
{
    std::lock_guard<mutex_t> lock(mutex_);
    formatter_ = std::move(sink_formatter);
}

template<typename ConsoleMutex>
SPDLOG_INLINE bool ansicolor_sink<ConsoleMutex>::should_color()
{
    return should_do_colors_;
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_color_mode(color_mode mode)
{
    switch (mode)
    {
    case color_mode::always:
        should_do_colors_ = true;
        return;
    case color_mode::automatic:
        should_do_colors_ = details::os::in_terminal(target_file_) && details::os::is_color_terminal();
        return;
    case color_mode::never:
        should_do_colors_ = false;
        return;
    default:
        should_do_colors_ = false;
    }
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_ccode_(const string_view_t &color_code)
{
    fwrite(color_code.data(), sizeof(char), color_code.size(), target_file_);
}

template<typename ConsoleMutex>
SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_range_(const memory_buf_t &formatted, size_t start, size_t end)
{
    fwrite(formatted.data() + start, sizeof(char), end - start, target_file_);
}

template<typename ConsoleMutex>
SPDLOG_INLINE std::string ansicolor_sink<ConsoleMutex>::to_string_(const string_view_t &sv)
{
    return std::string(sv.data(), sv.size());
}

// ansicolor_stdout_sink
template<typename ConsoleMutex>
SPDLOG_INLINE ansicolor_stdout_sink<ConsoleMutex>::ansicolor_stdout_sink(color_mode mode)
    : ansicolor_sink<ConsoleMutex>(stdout, mode)
{}

// ansicolor_stderr_sink
template<typename ConsoleMutex>
SPDLOG_INLINE ansicolor_stderr_sink<ConsoleMutex>::ansicolor_stderr_sink(color_mode mode)
    : ansicolor_sink<ConsoleMutex>(stderr, mode)
{}

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/ansicolor_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/details/console_globals.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/sinks/sink.h>
#include <memory>
#include <mutex>
#include <string>
#include <array>

namespace spdlog {
namespace sinks {

/**
 * This sink prefixes the output with an ANSI escape sequence color code
 * depending on the severity
 * of the message.
 * If no color terminal detected, omit the escape codes.
 */

template<typename ConsoleMutex>
class ansicolor_sink : public sink
{
public:
    using mutex_t = typename ConsoleMutex::mutex_t;
    ansicolor_sink(FILE *target_file, color_mode mode);
    ~ansicolor_sink() override = default;

    ansicolor_sink(const ansicolor_sink &other) = delete;
    ansicolor_sink(ansicolor_sink &&other) = delete;

    ansicolor_sink &operator=(const ansicolor_sink &other) = delete;
    ansicolor_sink &operator=(ansicolor_sink &&other) = delete;

    void set_color(level::level_enum color_level, string_view_t color);
    void set_color_mode(color_mode mode);
    bool should_color();

    void log(const details::log_msg &msg) override;
    void flush() override;
    void set_pattern(const std::string &pattern) final;
    void set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter) override;

    // Formatting codes
    const string_view_t reset = "\033[m";
    const string_view_t bold = "\033[1m";
    const string_view_t dark = "\033[2m";
    const string_view_t underline = "\033[4m";
    const string_view_t blink = "\033[5m";
    const string_view_t reverse = "\033[7m";
    const string_view_t concealed = "\033[8m";
    const string_view_t clear_line = "\033[K";

    // Foreground colors
    const string_view_t black = "\033[30m";
    const string_view_t red = "\033[31m";
    const string_view_t green = "\033[32m";
    const string_view_t yellow = "\033[33m";
    const string_view_t blue = "\033[34m";
    const string_view_t magenta = "\033[35m";
    const string_view_t cyan = "\033[36m";
    const string_view_t white = "\033[37m";

    /// Background colors
    const string_view_t on_black = "\033[40m";
    const string_view_t on_red = "\033[41m";
    const string_view_t on_green = "\033[42m";
    const string_view_t on_yellow = "\033[43m";
    const string_view_t on_blue = "\033[44m";
    const string_view_t on_magenta = "\033[45m";
    const string_view_t on_cyan = "\033[46m";
    const string_view_t on_white = "\033[47m";

    /// Bold colors
    const string_view_t yellow_bold = "\033[33m\033[1m";
    const string_view_t red_bold = "\033[31m\033[1m";
    const string_view_t bold_on_red = "\033[1m\033[41m";

private:
    FILE *target_file_;
    mutex_t &mutex_;
    bool should_do_colors_;
    std::unique_ptr<spdlog::formatter> formatter_;
    std::array<std::string, level::n_levels> colors_;
    void print_ccode_(const string_view_t &color_code);
    void print_range_(const memory_buf_t &formatted, size_t start, size_t end);
    static std::string to_string_(const string_view_t &sv);
};

template<typename ConsoleMutex>
class ansicolor_stdout_sink : public ansicolor_sink<ConsoleMutex>
{
public:
    explicit ansicolor_stdout_sink(color_mode mode = color_mode::automatic);
};

template<typename ConsoleMutex>
class ansicolor_stderr_sink : public ansicolor_sink<ConsoleMutex>
{
public:
    explicit ansicolor_stderr_sink(color_mode mode = color_mode::automatic);
};

using ansicolor_stdout_sink_mt = ansicolor_stdout_sink<details::console_mutex>;
using ansicolor_stdout_sink_st = ansicolor_stdout_sink<details::console_nullmutex>;

using ansicolor_stderr_sink_mt = ansicolor_stderr_sink<details::console_mutex>;
using ansicolor_stderr_sink_st = ansicolor_stderr_sink<details::console_nullmutex>;

} // namespace sinks
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "ansicolor_sink-inl.h"
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/base_sink-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/base_sink.h>
#endif

#include <spdlog/common.h>
#include <spdlog/pattern_formatter.h>

#include <memory>

template<typename Mutex>
SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::base_sink()
    : formatter_{details::make_unique<spdlog::pattern_formatter>()}
{}

template<typename Mutex>
SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::base_sink(std::unique_ptr<spdlog::formatter> formatter)
    : formatter_{std::move(formatter)}
{}

template<typename Mutex>
void SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::log(const details::log_msg &msg)
{
    std::lock_guard<Mutex> lock(mutex_);
    sink_it_(msg);
}

template<typename Mutex>
void SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::flush()
{
    std::lock_guard<Mutex> lock(mutex_);
    flush_();
}

template<typename Mutex>
void SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::set_pattern(const std::string &pattern)
{
    std::lock_guard<Mutex> lock(mutex_);
    set_pattern_(pattern);
}

template<typename Mutex>
void SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter)
{
    std::lock_guard<Mutex> lock(mutex_);
    set_formatter_(std::move(sink_formatter));
}

template<typename Mutex>
void SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::set_pattern_(const std::string &pattern)
{
    set_formatter_(details::make_unique<spdlog::pattern_formatter>(pattern));
}

template<typename Mutex>
void SPDLOG_INLINE spdlog::sinks::base_sink<Mutex>::set_formatter_(std::unique_ptr<spdlog::formatter> sink_formatter)
{
    formatter_ = std::move(sink_formatter);
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/base_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once
//
// base sink templated over a mutex (either dummy or real)
// concrete implementation should override the sink_it_() and flush_()  methods.
// locking is taken care of in this class - no locking needed by the
// implementers..
//

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/common.h>
#include <spdlog/details/log_msg.h>
#include <spdlog/sinks/sink.h>

namespace spdlog {
namespace sinks {
template<typename Mutex>
class SPDLOG_API base_sink : public sink
{
public:
    base_sink();
    explicit base_sink(std::unique_ptr<spdlog::formatter> formatter);
    ~base_sink() override = default;

    base_sink(const base_sink &) = delete;
    base_sink(base_sink &&) = delete;

    base_sink &operator=(const base_sink &) = delete;
    base_sink &operator=(base_sink &&) = delete;

    void log(const details::log_msg &msg) final;
    void flush() final;
    void set_pattern(const std::string &pattern) final;
    void set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter) final;

protected:
    // sink formatter
    std::unique_ptr<spdlog::formatter> formatter_;
    Mutex mutex_;

    virtual void sink_it_(const details::log_msg &msg) = 0;
    virtual void flush_() = 0;
    virtual void set_pattern_(const std::string &pattern);
    virtual void set_formatter_(std::unique_ptr<spdlog::formatter> sink_formatter);
};
} // namespace sinks
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "base_sink-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/basic_file_sink-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/basic_file_sink.h>
#endif

#include <spdlog/common.h>
#include <spdlog/details/os.h>

namespace spdlog {
namespace sinks {

template<typename Mutex>
SPDLOG_INLINE basic_file_sink<Mutex>::basic_file_sink(const filename_t &filename, bool truncate, const file_event_handlers &event_handlers)
    : file_helper_{event_handlers}
{
    file_helper_.open(filename, truncate);
}

template<typename Mutex>
SPDLOG_INLINE const filename_t &basic_file_sink<Mutex>::filename() const
{
    return file_helper_.filename();
}

template<typename Mutex>
SPDLOG_INLINE void basic_file_sink<Mutex>::sink_it_(const details::log_msg &msg)
{
    memory_buf_t formatted;
    base_sink<Mutex>::formatter_->format(msg, formatted);
    file_helper_.write(formatted);
}

template<typename Mutex>
SPDLOG_INLINE void basic_file_sink<Mutex>::flush_()
{
    file_helper_.flush();
}

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/basic_file_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/details/file_helper.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/synchronous_factory.h>

#include <mutex>
#include <string>

namespace spdlog {
namespace sinks {
/*
 * Trivial file sink with single file as target
 */
template<typename Mutex>
class basic_file_sink final : public base_sink<Mutex>
{
public:
    explicit basic_file_sink(const filename_t &filename, bool truncate = false, const file_event_handlers &event_handlers = {});
    const filename_t &filename() const;

protected:
    void sink_it_(const details::log_msg &msg) override;
    void flush_() override;

private:
    details::file_helper file_helper_;
};

using basic_file_sink_mt = basic_file_sink<std::mutex>;
using basic_file_sink_st = basic_file_sink<details::null_mutex>;

} // namespace sinks

//
// factory functions
//
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> basic_logger_mt(
    const std::string &logger_name, const filename_t &filename, bool truncate = false, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::basic_file_sink_mt>(logger_name, filename, truncate, event_handlers);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> basic_logger_st(
    const std::string &logger_name, const filename_t &filename, bool truncate = false, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::basic_file_sink_st>(logger_name, filename, truncate, event_handlers);
}

} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "basic_file_sink-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/daily_file_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <spdlog/details/file_helper.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/fmt/fmt.h>
#include <spdlog/fmt/chrono.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/os.h>
#include <spdlog/details/circular_q.h>
#include <spdlog/details/synchronous_factory.h>

#include <chrono>
#include <cstdio>
#include <ctime>
#include <mutex>
#include <string>

namespace spdlog {
namespace sinks {

/*
 * Generator of daily log file names in format basename.YYYY-MM-DD.ext
 */
struct daily_filename_calculator
{
    // Create filename for the form basename.YYYY-MM-DD
    static filename_t calc_filename(const filename_t &filename, const tm &now_tm)
    {
        filename_t basename, ext;
        std::tie(basename, ext) = details::file_helper::split_by_extension(filename);
        return fmt_lib::format(
            SPDLOG_FILENAME_T("{}_{:04d}-{:02d}-{:02d}{}"), basename, now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday, ext);
    }
};

/*
 * Generator of daily log file names with strftime format.
 * Usages:
 *    auto sink =  std::make_shared<spdlog::sinks::daily_file_format_sink_mt>("myapp-%Y-%m-%d:%H:%M:%S.log", hour, minute);"
 *    auto logger = spdlog::daily_logger_format_mt("loggername, "myapp-%Y-%m-%d:%X.log", hour,  minute)"
 *
 */
struct daily_filename_format_calculator
{
    static filename_t calc_filename(const filename_t &filename, const tm &now_tm)
    {
#ifdef SPDLOG_USE_STD_FORMAT
        // adapted from fmtlib: https://github.com/fmtlib/fmt/blob/8.0.1/include/fmt/chrono.h#L522-L546

        filename_t tm_format;
        tm_format.append(filename);
        // By appending an extra space we can distinguish an empty result that
        // indicates insufficient buffer size from a guaranteed non-empty result
        // https://github.com/fmtlib/fmt/issues/2238
        tm_format.push_back(' ');

        const size_t MIN_SIZE = 10;
        filename_t buf;
        buf.resize(MIN_SIZE);
        for (;;)
        {
            size_t count = strftime(buf.data(), buf.size(), tm_format.c_str(), &now_tm);
            if (count != 0)
            {
                // Remove the extra space.
                buf.resize(count - 1);
                break;
            }
            buf.resize(buf.size() * 2);
        }

        return buf;
#else
        // generate fmt datetime format string, e.g. {:%Y-%m-%d}.
        filename_t fmt_filename = fmt::format(SPDLOG_FILENAME_T("{{:{}}}"), filename);
#    if defined(_MSC_VER) && defined(SPDLOG_WCHAR_FILENAMES) // for some reason msvc doesn't allow fmt::runtime(..) with wchar here
        return fmt::format(fmt_filename, now_tm);
#    else
        return fmt::format(SPDLOG_FMT_RUNTIME(fmt_filename), now_tm);
#    endif
#endif
    }

private:
#if defined __GNUC__
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wformat-nonliteral"
#endif

    static size_t strftime(char *str, size_t count, const char *format, const std::tm *time)
    {
        return std::strftime(str, count, format, time);
    }

    static size_t strftime(wchar_t *str, size_t count, const wchar_t *format, const std::tm *time)
    {
        return std::wcsftime(str, count, format, time);
    }

#if defined(__GNUC__)
#    pragma GCC diagnostic pop
#endif
};

/*
 * Rotating file sink based on date.
 * If truncate != false , the created file will be truncated.
 * If max_files > 0, retain only the last max_files and delete previous.
 */
template<typename Mutex, typename FileNameCalc = daily_filename_calculator>
class daily_file_sink final : public base_sink<Mutex>
{
public:
    // create daily file sink which rotates on given time
    daily_file_sink(filename_t base_filename, int rotation_hour, int rotation_minute, bool truncate = false, uint16_t max_files = 0,
        const file_event_handlers &event_handlers = {})
        : base_filename_(std::move(base_filename))
        , rotation_h_(rotation_hour)
        , rotation_m_(rotation_minute)
        , file_helper_{event_handlers}
        , truncate_(truncate)
        , max_files_(max_files)
        , filenames_q_()
    {
        if (rotation_hour < 0 || rotation_hour > 23 || rotation_minute < 0 || rotation_minute > 59)
        {
            throw_spdlog_ex("daily_file_sink: Invalid rotation time in ctor");
        }

        auto now = log_clock::now();
        auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));
        file_helper_.open(filename, truncate_);
        rotation_tp_ = next_rotation_tp_();

        if (max_files_ > 0)
        {
            init_filenames_q_();
        }
    }

    filename_t filename()
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        return file_helper_.filename();
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        auto time = msg.time;
        bool should_rotate = time >= rotation_tp_;
        if (should_rotate)
        {
            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(time));
            file_helper_.open(filename, truncate_);
            rotation_tp_ = next_rotation_tp_();
        }
        memory_buf_t formatted;
        base_sink<Mutex>::formatter_->format(msg, formatted);
        file_helper_.write(formatted);

        // Do the cleaning only at the end because it might throw on failure.
        if (should_rotate && max_files_ > 0)
        {
            delete_old_();
        }
    }

    void flush_() override
    {
        file_helper_.flush();
    }

private:
    void init_filenames_q_()
    {
        using details::os::path_exists;

        filenames_q_ = details::circular_q<filename_t>(static_cast<size_t>(max_files_));
        std::vector<filename_t> filenames;
        auto now = log_clock::now();
        while (filenames.size() < max_files_)
        {
            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));
            if (!path_exists(filename))
            {
                break;
            }
            filenames.emplace_back(filename);
            now -= std::chrono::hours(24);
        }
        for (auto iter = filenames.rbegin(); iter != filenames.rend(); ++iter)
        {
            filenames_q_.push_back(std::move(*iter));
        }
    }

    tm now_tm(log_clock::time_point tp)
    {
        time_t tnow = log_clock::to_time_t(tp);
        return spdlog::details::os::localtime(tnow);
    }

    log_clock::time_point next_rotation_tp_()
    {
        auto now = log_clock::now();
        tm date = now_tm(now);
        date.tm_hour = rotation_h_;
        date.tm_min = rotation_m_;
        date.tm_sec = 0;
        auto rotation_time = log_clock::from_time_t(std::mktime(&date));
        if (rotation_time > now)
        {
            return rotation_time;
        }
        return {rotation_time + std::chrono::hours(24)};
    }

    // Delete the file N rotations ago.
    // Throw spdlog_ex on failure to delete the old file.
    void delete_old_()
    {
        using details::os::filename_to_str;
        using details::os::remove_if_exists;

        filename_t current_file = file_helper_.filename();
        if (filenames_q_.full())
        {
            auto old_filename = std::move(filenames_q_.front());
            filenames_q_.pop_front();
            bool ok = remove_if_exists(old_filename) == 0;
            if (!ok)
            {
                filenames_q_.push_back(std::move(current_file));
                throw_spdlog_ex("Failed removing daily file " + filename_to_str(old_filename), errno);
            }
        }
        filenames_q_.push_back(std::move(current_file));
    }

    filename_t base_filename_;
    int rotation_h_;
    int rotation_m_;
    log_clock::time_point rotation_tp_;
    details::file_helper file_helper_;
    bool truncate_;
    uint16_t max_files_;
    details::circular_q<filename_t> filenames_q_;
};

using daily_file_sink_mt = daily_file_sink<std::mutex>;
using daily_file_sink_st = daily_file_sink<details::null_mutex>;
using daily_file_format_sink_mt = daily_file_sink<std::mutex, daily_filename_format_calculator>;
using daily_file_format_sink_st = daily_file_sink<details::null_mutex, daily_filename_format_calculator>;

} // namespace sinks

//
// factory functions
//
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> daily_logger_mt(const std::string &logger_name, const filename_t &filename, int hour = 0, int minute = 0,
    bool truncate = false, uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::daily_file_sink_mt>(logger_name, filename, hour, minute, truncate, max_files, event_handlers);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> daily_logger_format_mt(const std::string &logger_name, const filename_t &filename, int hour = 0,
    int minute = 0, bool truncate = false, uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::daily_file_format_sink_mt>(
        logger_name, filename, hour, minute, truncate, max_files, event_handlers);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> daily_logger_st(const std::string &logger_name, const filename_t &filename, int hour = 0, int minute = 0,
    bool truncate = false, uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::daily_file_sink_st>(logger_name, filename, hour, minute, truncate, max_files, event_handlers);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> daily_logger_format_st(const std::string &logger_name, const filename_t &filename, int hour = 0,
    int minute = 0, bool truncate = false, uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::daily_file_format_sink_st>(
        logger_name, filename, hour, minute, truncate, max_files, event_handlers);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/dist_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include "base_sink.h"
#include <spdlog/details/log_msg.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/pattern_formatter.h>

#include <algorithm>
#include <memory>
#include <mutex>
#include <vector>

// Distribution sink (mux). Stores a vector of sinks which get called when log
// is called

namespace spdlog {
namespace sinks {

template<typename Mutex>
class dist_sink : public base_sink<Mutex>
{
public:
    dist_sink() = default;
    explicit dist_sink(std::vector<std::shared_ptr<sink>> sinks)
        : sinks_(sinks)
    {}

    dist_sink(const dist_sink &) = delete;
    dist_sink &operator=(const dist_sink &) = delete;

    void add_sink(std::shared_ptr<sink> sink)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        sinks_.push_back(sink);
    }

    void remove_sink(std::shared_ptr<sink> sink)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        sinks_.erase(std::remove(sinks_.begin(), sinks_.end(), sink), sinks_.end());
    }

    void set_sinks(std::vector<std::shared_ptr<sink>> sinks)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        sinks_ = std::move(sinks);
    }

    std::vector<std::shared_ptr<sink>> &sinks()
    {
        return sinks_;
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        for (auto &sink : sinks_)
        {
            if (sink->should_log(msg.level))
            {
                sink->log(msg);
            }
        }
    }

    void flush_() override
    {
        for (auto &sink : sinks_)
        {
            sink->flush();
        }
    }

    void set_pattern_(const std::string &pattern) override
    {
        set_formatter_(details::make_unique<spdlog::pattern_formatter>(pattern));
    }

    void set_formatter_(std::unique_ptr<spdlog::formatter> sink_formatter) override
    {
        base_sink<Mutex>::formatter_ = std::move(sink_formatter);
        for (auto &sink : sinks_)
        {
            sink->set_formatter(base_sink<Mutex>::formatter_->clone());
        }
    }
    std::vector<std::shared_ptr<sink>> sinks_;
};

using dist_sink_mt = dist_sink<std::mutex>;
using dist_sink_st = dist_sink<details::null_mutex>;

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/dup_filter_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include "dist_sink.h"
#include <spdlog/details/null_mutex.h>
#include <spdlog/details/log_msg.h>

#include <cstdio>
#include <mutex>
#include <string>
#include <chrono>

// Duplicate message removal sink.
// Skip the message if previous one is identical and less than "max_skip_duration" have passed
//
// Example:
//
//     #include <spdlog/sinks/dup_filter_sink.h>
//
//     int main() {
//         auto dup_filter = std::make_shared<dup_filter_sink_st>(std::chrono::seconds(5));
//         dup_filter->add_sink(std::make_shared<stdout_color_sink_mt>());
//         spdlog::logger l("logger", dup_filter);
//         l.info("Hello");
//         l.info("Hello");
//         l.info("Hello");
//         l.info("Different Hello");
//     }
//
// Will produce:
//       [2019-06-25 17:50:56.511] [logger] [info] Hello
//       [2019-06-25 17:50:56.512] [logger] [info] Skipped 3 duplicate messages..
//       [2019-06-25 17:50:56.512] [logger] [info] Different Hello

namespace spdlog {
namespace sinks {
template<typename Mutex>
class dup_filter_sink : public dist_sink<Mutex>
{
public:
    template<class Rep, class Period>
    explicit dup_filter_sink(std::chrono::duration<Rep, Period> max_skip_duration)
        : max_skip_duration_{max_skip_duration}
    {}

protected:
    std::chrono::microseconds max_skip_duration_;
    log_clock::time_point last_msg_time_;
    std::string last_msg_payload_;
    size_t skip_counter_ = 0;

    void sink_it_(const details::log_msg &msg) override
    {
        bool filtered = filter_(msg);
        if (!filtered)
        {
            skip_counter_ += 1;
            return;
        }

        // log the "skipped.." message
        if (skip_counter_ > 0)
        {
            char buf[64];
            auto msg_size = ::snprintf(buf, sizeof(buf), "Skipped %u duplicate messages..", static_cast<unsigned>(skip_counter_));
            if (msg_size > 0 && static_cast<size_t>(msg_size) < sizeof(buf))
            {
                details::log_msg skipped_msg{msg.logger_name, level::info, string_view_t{buf, static_cast<size_t>(msg_size)}};
                dist_sink<Mutex>::sink_it_(skipped_msg);
            }
        }

        // log current message
        dist_sink<Mutex>::sink_it_(msg);
        last_msg_time_ = msg.time;
        skip_counter_ = 0;
        last_msg_payload_.assign(msg.payload.data(), msg.payload.data() + msg.payload.size());
    }

    // return whether the log msg should be displayed (true) or skipped (false)
    bool filter_(const details::log_msg &msg)
    {
        auto filter_duration = msg.time - last_msg_time_;
        return (filter_duration > max_skip_duration_) || (msg.payload != last_msg_payload_);
    }
};

using dup_filter_sink_mt = dup_filter_sink<std::mutex>;
using dup_filter_sink_st = dup_filter_sink<details::null_mutex>;

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/hourly_file_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <spdlog/details/file_helper.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/fmt/fmt.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/os.h>
#include <spdlog/details/circular_q.h>
#include <spdlog/details/synchronous_factory.h>

#include <chrono>
#include <cstdio>
#include <ctime>
#include <mutex>
#include <string>

namespace spdlog {
namespace sinks {

/*
 * Generator of Hourly log file names in format basename.YYYY-MM-DD-HH.ext
 */
struct hourly_filename_calculator
{
    // Create filename for the form basename.YYYY-MM-DD-H
    static filename_t calc_filename(const filename_t &filename, const tm &now_tm)
    {
        filename_t basename, ext;
        std::tie(basename, ext) = details::file_helper::split_by_extension(filename);
        return fmt_lib::format(SPDLOG_FILENAME_T("{}_{:04d}-{:02d}-{:02d}_{:02d}{}"), basename, now_tm.tm_year + 1900, now_tm.tm_mon + 1,
            now_tm.tm_mday, now_tm.tm_hour, ext);
    }
};

/*
 * Rotating file sink based on time.
 * If truncate != false , the created file will be truncated.
 * If max_files > 0, retain only the last max_files and delete previous.
 */
template<typename Mutex, typename FileNameCalc = hourly_filename_calculator>
class hourly_file_sink final : public base_sink<Mutex>
{
public:
    // create hourly file sink which rotates on given time
    hourly_file_sink(
        filename_t base_filename, bool truncate = false, uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
        : base_filename_(std::move(base_filename))
        , file_helper_{event_handlers}
        , truncate_(truncate)
        , max_files_(max_files)
        , filenames_q_()
    {
        auto now = log_clock::now();
        auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));
        file_helper_.open(filename, truncate_);
        rotation_tp_ = next_rotation_tp_();

        if (max_files_ > 0)
        {
            init_filenames_q_();
        }
    }

    filename_t filename()
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        return file_helper_.filename();
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        auto time = msg.time;
        bool should_rotate = time >= rotation_tp_;
        if (should_rotate)
        {
            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(time));
            file_helper_.open(filename, truncate_);
            rotation_tp_ = next_rotation_tp_();
        }
        memory_buf_t formatted;
        base_sink<Mutex>::formatter_->format(msg, formatted);
        file_helper_.write(formatted);

        // Do the cleaning only at the end because it might throw on failure.
        if (should_rotate && max_files_ > 0)
        {
            delete_old_();
        }
    }

    void flush_() override
    {
        file_helper_.flush();
    }

private:
    void init_filenames_q_()
    {
        using details::os::path_exists;

        filenames_q_ = details::circular_q<filename_t>(static_cast<size_t>(max_files_));
        std::vector<filename_t> filenames;
        auto now = log_clock::now();
        while (filenames.size() < max_files_)
        {
            auto filename = FileNameCalc::calc_filename(base_filename_, now_tm(now));
            if (!path_exists(filename))
            {
                break;
            }
            filenames.emplace_back(filename);
            now -= std::chrono::hours(1);
        }
        for (auto iter = filenames.rbegin(); iter != filenames.rend(); ++iter)
        {
            filenames_q_.push_back(std::move(*iter));
        }
    }

    tm now_tm(log_clock::time_point tp)
    {
        time_t tnow = log_clock::to_time_t(tp);
        return spdlog::details::os::localtime(tnow);
    }

    log_clock::time_point next_rotation_tp_()
    {
        auto now = log_clock::now();
        tm date = now_tm(now);
        date.tm_min = 0;
        date.tm_sec = 0;
        auto rotation_time = log_clock::from_time_t(std::mktime(&date));
        if (rotation_time > now)
        {
            return rotation_time;
        }
        return {rotation_time + std::chrono::hours(1)};
    }

    // Delete the file N rotations ago.
    // Throw spdlog_ex on failure to delete the old file.
    void delete_old_()
    {
        using details::os::filename_to_str;
        using details::os::remove_if_exists;

        filename_t current_file = file_helper_.filename();
        if (filenames_q_.full())
        {
            auto old_filename = std::move(filenames_q_.front());
            filenames_q_.pop_front();
            bool ok = remove_if_exists(old_filename) == 0;
            if (!ok)
            {
                filenames_q_.push_back(std::move(current_file));
                SPDLOG_THROW(spdlog_ex("Failed removing hourly file " + filename_to_str(old_filename), errno));
            }
        }
        filenames_q_.push_back(std::move(current_file));
    }

    filename_t base_filename_;
    log_clock::time_point rotation_tp_;
    details::file_helper file_helper_;
    bool truncate_;
    uint16_t max_files_;
    details::circular_q<filename_t> filenames_q_;
};

using hourly_file_sink_mt = hourly_file_sink<std::mutex>;
using hourly_file_sink_st = hourly_file_sink<details::null_mutex>;

} // namespace sinks

//
// factory functions
//
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> hourly_logger_mt(const std::string &logger_name, const filename_t &filename, bool truncate = false,
    uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::hourly_file_sink_mt>(logger_name, filename, truncate, max_files, event_handlers);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> hourly_logger_st(const std::string &logger_name, const filename_t &filename, bool truncate = false,
    uint16_t max_files = 0, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::hourly_file_sink_st>(logger_name, filename, truncate, max_files, event_handlers);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/mongo_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

//
// Custom sink for mongodb
// Building and using requires mongocxx library.
// For building mongocxx library check the url below
// http://mongocxx.org/mongocxx-v3/installation/
//

#include "spdlog/common.h"
#include "spdlog/details/log_msg.h"
#include "spdlog/sinks/base_sink.h"
#include <spdlog/details/synchronous_factory.h>

#include <bsoncxx/builder/stream/document.hpp>
#include <bsoncxx/types.hpp>
#include <bsoncxx/view_or_value.hpp>

#include <mongocxx/client.hpp>
#include <mongocxx/instance.hpp>
#include <mongocxx/uri.hpp>

namespace spdlog {
namespace sinks {
template<typename Mutex>
class mongo_sink : public base_sink<Mutex>
{
public:
    mongo_sink(const std::string &db_name, const std::string &collection_name, const std::string &uri = "mongodb://localhost:27017")
    {
        try
        {
            client_ = spdlog::details::make_unique<mongocxx::client>(mongocxx::uri{uri});
            db_name_ = db_name;
            coll_name_ = collection_name;
        }
        catch (const std::exception)
        {
            throw spdlog_ex("Error opening database");
        }
    }

    ~mongo_sink()
    {
        flush_();
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        using bsoncxx::builder::stream::document;
        using bsoncxx::builder::stream::finalize;

        if (client_ != nullptr)
        {
            auto doc = document{} << "timestamp" << bsoncxx::types::b_date(msg.time) << "level" << level::to_string_view(msg.level).data()
                                  << "message" << std::string(msg.payload.begin(), msg.payload.end()) << "logger_name"
                                  << std::string(msg.logger_name.begin(), msg.logger_name.end()) << "thread_id"
                                  << static_cast<int>(msg.thread_id) << finalize;
            client_->database(db_name_).collection(coll_name_).insert_one(doc.view());
        }
    }

    void flush_() override {}

private:
    static mongocxx::instance instance_;
    std::string db_name_;
    std::string coll_name_;
    std::unique_ptr<mongocxx::client> client_ = nullptr;
};
template<>
mongocxx::instance mongo_sink<std::mutex>::instance_{};

#include "spdlog/details/null_mutex.h"
#include <mutex>
using mongo_sink_mt = mongo_sink<std::mutex>;
using mongo_sink_st = mongo_sink<spdlog::details::null_mutex>;

} // namespace sinks

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> mongo_logger_mt(const std::string &logger_name, const std::string &db_name,
    const std::string &collection_name, const std::string &uri = "mongodb://localhost:27017")
{
    return Factory::template create<sinks::mongo_sink_mt>(logger_name, db_name, collection_name, uri);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> mongo_logger_st(const std::string &logger_name, const std::string &db_name,
    const std::string &collection_name, const std::string &uri = "mongodb://localhost:27017")
{
    return Factory::template create<sinks::mongo_sink_st>(logger_name, db_name, collection_name, uri);
}

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/msvc_sink.h`:

```h
// Copyright(c) 2016 Alexander Dalshov.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_WIN32)

#    include <spdlog/details/null_mutex.h>
#    include <spdlog/sinks/base_sink.h>

#    include <mutex>
#    include <string>

// Avoid including windows.h (https://stackoverflow.com/a/30741042)
extern "C" __declspec(dllimport) void __stdcall OutputDebugStringA(const char *lpOutputString);

namespace spdlog {
namespace sinks {
/*
 * MSVC sink (logging using OutputDebugStringA)
 */
template<typename Mutex>
class msvc_sink : public base_sink<Mutex>
{
public:
    msvc_sink() = default;

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        memory_buf_t formatted;
        base_sink<Mutex>::formatter_->format(msg, formatted);
        formatted.push_back('\0'); // add a null terminator for OutputDebugStringA
        OutputDebugStringA(formatted.data());
    }

    void flush_() override {}
};

using msvc_sink_mt = msvc_sink<std::mutex>;
using msvc_sink_st = msvc_sink<details::null_mutex>;

using windebug_sink_mt = msvc_sink_mt;
using windebug_sink_st = msvc_sink_st;

} // namespace sinks
} // namespace spdlog

#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/null_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/details/null_mutex.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/synchronous_factory.h>

#include <mutex>

namespace spdlog {
namespace sinks {

template<typename Mutex>
class null_sink : public base_sink<Mutex>
{
protected:
    void sink_it_(const details::log_msg &) override {}
    void flush_() override {}
};

using null_sink_mt = null_sink<details::null_mutex>;
using null_sink_st = null_sink<details::null_mutex>;

} // namespace sinks

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> null_logger_mt(const std::string &logger_name)
{
    auto null_logger = Factory::template create<sinks::null_sink_mt>(logger_name);
    null_logger->set_level(level::off);
    return null_logger;
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> null_logger_st(const std::string &logger_name)
{
    auto null_logger = Factory::template create<sinks::null_sink_st>(logger_name);
    null_logger->set_level(level::off);
    return null_logger;
}

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/ostream_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/details/null_mutex.h>
#include <spdlog/sinks/base_sink.h>

#include <mutex>
#include <ostream>

namespace spdlog {
namespace sinks {
template<typename Mutex>
class ostream_sink final : public base_sink<Mutex>
{
public:
    explicit ostream_sink(std::ostream &os, bool force_flush = false)
        : ostream_(os)
        , force_flush_(force_flush)
    {}
    ostream_sink(const ostream_sink &) = delete;
    ostream_sink &operator=(const ostream_sink &) = delete;

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        memory_buf_t formatted;
        base_sink<Mutex>::formatter_->format(msg, formatted);
        ostream_.write(formatted.data(), static_cast<std::streamsize>(formatted.size()));
        if (force_flush_)
        {
            ostream_.flush();
        }
    }

    void flush_() override
    {
        ostream_.flush();
    }

    std::ostream &ostream_;
    bool force_flush_;
};

using ostream_sink_mt = ostream_sink<std::mutex>;
using ostream_sink_st = ostream_sink<details::null_mutex>;

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/qt_sinks.h`:

```h
// Copyright(c) 2015-present, Gabi Melman, mguludag and spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

//
// Custom sink for QPlainTextEdit or QTextEdit and its childs(QTextBrowser...
// etc) Building and using requires Qt library.
//

#include "spdlog/common.h"
#include "spdlog/details/log_msg.h"
#include "spdlog/details/synchronous_factory.h"
#include "spdlog/sinks/base_sink.h"

#include <QTextEdit>
#include <QPlainTextEdit>

//
// qt_sink class
//
namespace spdlog {
namespace sinks {
template<typename Mutex>
class qt_sink : public base_sink<Mutex>
{
public:
    qt_sink(QObject *qt_object, const std::string &meta_method)
    {
        qt_object_ = qt_object;
        meta_method_ = meta_method;
    }

    ~qt_sink()
    {
        flush_();
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        memory_buf_t formatted;
        base_sink<Mutex>::formatter_->format(msg, formatted);
        string_view_t str = string_view_t(formatted.data(), formatted.size());
        QMetaObject::invokeMethod(qt_object_, meta_method_.c_str(), Qt::AutoConnection,
            Q_ARG(QString, QString::fromUtf8(str.data(), static_cast<int>(str.size())).trimmed()));
    }

    void flush_() override {}

private:
    QObject *qt_object_ = nullptr;
    std::string meta_method_;
};

#include "spdlog/details/null_mutex.h"
#include <mutex>
using qt_sink_mt = qt_sink<std::mutex>;
using qt_sink_st = qt_sink<spdlog::details::null_mutex>;
} // namespace sinks

//
// Factory functions
//
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> qt_logger_mt(const std::string &logger_name, QTextEdit *qt_object, const std::string &meta_method = "append")
{
    return Factory::template create<sinks::qt_sink_mt>(logger_name, qt_object, meta_method);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> qt_logger_st(const std::string &logger_name, QTextEdit *qt_object, const std::string &meta_method = "append")
{
    return Factory::template create<sinks::qt_sink_st>(logger_name, qt_object, meta_method);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> qt_logger_mt(
    const std::string &logger_name, QPlainTextEdit *qt_object, const std::string &meta_method = "appendPlainText")
{
    return Factory::template create<sinks::qt_sink_mt>(logger_name, qt_object, meta_method);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> qt_logger_st(
    const std::string &logger_name, QPlainTextEdit *qt_object, const std::string &meta_method = "appendPlainText")
{
    return Factory::template create<sinks::qt_sink_st>(logger_name, qt_object, meta_method);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> qt_logger_mt(const std::string &logger_name, QObject *qt_object, const std::string &meta_method)
{
    return Factory::template create<sinks::qt_sink_mt>(logger_name, qt_object, meta_method);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> qt_logger_st(const std::string &logger_name, QObject *qt_object, const std::string &meta_method)
{
    return Factory::template create<sinks::qt_sink_st>(logger_name, qt_object, meta_method);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/ringbuffer_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include "spdlog/sinks/base_sink.h"
#include "spdlog/details/circular_q.h"
#include "spdlog/details/log_msg_buffer.h"
#include "spdlog/details/null_mutex.h"

#include <mutex>
#include <string>
#include <vector>

namespace spdlog {
namespace sinks {
/*
 * Ring buffer sink
 */
template<typename Mutex>
class ringbuffer_sink final : public base_sink<Mutex>
{
public:
    explicit ringbuffer_sink(size_t n_items)
        : q_{n_items}
    {}

    std::vector<details::log_msg_buffer> last_raw(size_t lim = 0)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        auto items_available = q_.size();
        auto n_items = lim > 0 ? (std::min)(lim, items_available) : items_available;
        std::vector<details::log_msg_buffer> ret;
        ret.reserve(n_items);
        for (size_t i = (items_available - n_items); i < items_available; i++)
        {
            ret.push_back(q_.at(i));
        }
        return ret;
    }

    std::vector<std::string> last_formatted(size_t lim = 0)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
        auto items_available = q_.size();
        auto n_items = lim > 0 ? (std::min)(lim, items_available) : items_available;
        std::vector<std::string> ret;
        ret.reserve(n_items);
        for (size_t i = (items_available - n_items); i < items_available; i++)
        {
            memory_buf_t formatted;
            base_sink<Mutex>::formatter_->format(q_.at(i), formatted);
            ret.push_back(std::move(SPDLOG_BUF_TO_STRING(formatted)));
        }
        return ret;
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        q_.push_back(details::log_msg_buffer{msg});
    }
    void flush_() override {}

private:
    details::circular_q<details::log_msg_buffer> q_;
};

using ringbuffer_sink_mt = ringbuffer_sink<std::mutex>;
using ringbuffer_sink_st = ringbuffer_sink<details::null_mutex>;

} // namespace sinks

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/rotating_file_sink-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/rotating_file_sink.h>
#endif

#include <spdlog/common.h>

#include <spdlog/details/file_helper.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/fmt/fmt.h>

#include <cerrno>
#include <chrono>
#include <ctime>
#include <mutex>
#include <string>
#include <tuple>

namespace spdlog {
namespace sinks {

template<typename Mutex>
SPDLOG_INLINE rotating_file_sink<Mutex>::rotating_file_sink(
    filename_t base_filename, std::size_t max_size, std::size_t max_files, bool rotate_on_open, const file_event_handlers &event_handlers)
    : base_filename_(std::move(base_filename))
    , max_size_(max_size)
    , max_files_(max_files)
    , file_helper_{event_handlers}
{
    if (max_size == 0)
    {
        throw_spdlog_ex("rotating sink constructor: max_size arg cannot be zero");
    }

    if (max_files > 200000)
    {
        throw_spdlog_ex("rotating sink constructor: max_files arg cannot exceed 200000");
    }
    file_helper_.open(calc_filename(base_filename_, 0));
    current_size_ = file_helper_.size(); // expensive. called only once
    if (rotate_on_open && current_size_ > 0)
    {
        rotate_();
        current_size_ = 0;
    }
}

// calc filename according to index and file extension if exists.
// e.g. calc_filename("logs/mylog.txt, 3) => "logs/mylog.3.txt".
template<typename Mutex>
SPDLOG_INLINE filename_t rotating_file_sink<Mutex>::calc_filename(const filename_t &filename, std::size_t index)
{
    if (index == 0u)
    {
        return filename;
    }

    filename_t basename, ext;
    std::tie(basename, ext) = details::file_helper::split_by_extension(filename);
    return fmt_lib::format(SPDLOG_FILENAME_T("{}.{}{}"), basename, index, ext);
}

template<typename Mutex>
SPDLOG_INLINE filename_t rotating_file_sink<Mutex>::filename()
{
    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);
    return file_helper_.filename();
}

template<typename Mutex>
SPDLOG_INLINE void rotating_file_sink<Mutex>::sink_it_(const details::log_msg &msg)
{
    memory_buf_t formatted;
    base_sink<Mutex>::formatter_->format(msg, formatted);
    auto new_size = current_size_ + formatted.size();

    // rotate if the new estimated file size exceeds max size.
    // rotate only if the real size > 0 to better deal with full disk (see issue #2261).
    // we only check the real size when new_size > max_size_ because it is relatively expensive.
    if (new_size > max_size_)
    {
        file_helper_.flush();
        if (file_helper_.size() > 0)
        {
            rotate_();
            new_size = formatted.size();
        }
    }
    file_helper_.write(formatted);
    current_size_ = new_size;
}

template<typename Mutex>
SPDLOG_INLINE void rotating_file_sink<Mutex>::flush_()
{
    file_helper_.flush();
}

// Rotate files:
// log.txt -> log.1.txt
// log.1.txt -> log.2.txt
// log.2.txt -> log.3.txt
// log.3.txt -> delete
template<typename Mutex>
SPDLOG_INLINE void rotating_file_sink<Mutex>::rotate_()
{
    using details::os::filename_to_str;
    using details::os::path_exists;

    file_helper_.close();
    for (auto i = max_files_; i > 0; --i)
    {
        filename_t src = calc_filename(base_filename_, i - 1);
        if (!path_exists(src))
        {
            continue;
        }
        filename_t target = calc_filename(base_filename_, i);

        if (!rename_file_(src, target))
        {
            // if failed try again after a small delay.
            // this is a workaround to a windows issue, where very high rotation
            // rates can cause the rename to fail with permission denied (because of antivirus?).
            details::os::sleep_for_millis(100);
            if (!rename_file_(src, target))
            {
                file_helper_.reopen(true); // truncate the log file anyway to prevent it to grow beyond its limit!
                current_size_ = 0;
                throw_spdlog_ex("rotating_file_sink: failed renaming " + filename_to_str(src) + " to " + filename_to_str(target), errno);
            }
        }
    }
    file_helper_.reopen(true);
}

// delete the target if exists, and rename the src file  to target
// return true on success, false otherwise.
template<typename Mutex>
SPDLOG_INLINE bool rotating_file_sink<Mutex>::rename_file_(const filename_t &src_filename, const filename_t &target_filename)
{
    // try to delete the target file in case it already exists.
    (void)details::os::remove(target_filename);
    return details::os::rename(src_filename, target_filename) == 0;
}

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/rotating_file_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/file_helper.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/details/synchronous_factory.h>

#include <chrono>
#include <mutex>
#include <string>

namespace spdlog {
namespace sinks {

//
// Rotating file sink based on size
//
template<typename Mutex>
class rotating_file_sink final : public base_sink<Mutex>
{
public:
    rotating_file_sink(filename_t base_filename, std::size_t max_size, std::size_t max_files, bool rotate_on_open = false,
        const file_event_handlers &event_handlers = {});
    static filename_t calc_filename(const filename_t &filename, std::size_t index);
    filename_t filename();

protected:
    void sink_it_(const details::log_msg &msg) override;
    void flush_() override;

private:
    // Rotate files:
    // log.txt -> log.1.txt
    // log.1.txt -> log.2.txt
    // log.2.txt -> log.3.txt
    // log.3.txt -> delete
    void rotate_();

    // delete the target if exists, and rename the src file  to target
    // return true on success, false otherwise.
    bool rename_file_(const filename_t &src_filename, const filename_t &target_filename);

    filename_t base_filename_;
    std::size_t max_size_;
    std::size_t max_files_;
    std::size_t current_size_;
    details::file_helper file_helper_;
};

using rotating_file_sink_mt = rotating_file_sink<std::mutex>;
using rotating_file_sink_st = rotating_file_sink<details::null_mutex>;

} // namespace sinks

//
// factory functions
//

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> rotating_logger_mt(const std::string &logger_name, const filename_t &filename, size_t max_file_size,
    size_t max_files, bool rotate_on_open = false, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::rotating_file_sink_mt>(
        logger_name, filename, max_file_size, max_files, rotate_on_open, event_handlers);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> rotating_logger_st(const std::string &logger_name, const filename_t &filename, size_t max_file_size,
    size_t max_files, bool rotate_on_open = false, const file_event_handlers &event_handlers = {})
{
    return Factory::template create<sinks::rotating_file_sink_st>(
        logger_name, filename, max_file_size, max_files, rotate_on_open, event_handlers);
}
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "rotating_file_sink-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/sink-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/sink.h>
#endif

#include <spdlog/common.h>

SPDLOG_INLINE bool spdlog::sinks::sink::should_log(spdlog::level::level_enum msg_level) const
{
    return msg_level >= level_.load(std::memory_order_relaxed);
}

SPDLOG_INLINE void spdlog::sinks::sink::set_level(level::level_enum log_level)
{
    level_.store(log_level, std::memory_order_relaxed);
}

SPDLOG_INLINE spdlog::level::level_enum spdlog::sinks::sink::level() const
{
    return static_cast<spdlog::level::level_enum>(level_.load(std::memory_order_relaxed));
}

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/details/log_msg.h>
#include <spdlog/formatter.h>

namespace spdlog {

namespace sinks {
class SPDLOG_API sink
{
public:
    virtual ~sink() = default;
    virtual void log(const details::log_msg &msg) = 0;
    virtual void flush() = 0;
    virtual void set_pattern(const std::string &pattern) = 0;
    virtual void set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter) = 0;

    void set_level(level::level_enum log_level);
    level::level_enum level() const;
    bool should_log(level::level_enum msg_level) const;

protected:
    // sink log level - default is all
    level_t level_{level::trace};
};

} // namespace sinks
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "sink-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/stdout_color_sinks-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/stdout_color_sinks.h>
#endif

#include <spdlog/logger.h>
#include <spdlog/common.h>

namespace spdlog {

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stdout_color_mt(const std::string &logger_name, color_mode mode)
{
    return Factory::template create<sinks::stdout_color_sink_mt>(logger_name, mode);
}

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stdout_color_st(const std::string &logger_name, color_mode mode)
{
    return Factory::template create<sinks::stdout_color_sink_st>(logger_name, mode);
}

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stderr_color_mt(const std::string &logger_name, color_mode mode)
{
    return Factory::template create<sinks::stderr_color_sink_mt>(logger_name, mode);
}

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stderr_color_st(const std::string &logger_name, color_mode mode)
{
    return Factory::template create<sinks::stderr_color_sink_st>(logger_name, mode);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/stdout_color_sinks.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifdef _WIN32
#    include <spdlog/sinks/wincolor_sink.h>
#else
#    include <spdlog/sinks/ansicolor_sink.h>
#endif

#include <spdlog/details/synchronous_factory.h>

namespace spdlog {
namespace sinks {
#ifdef _WIN32
using stdout_color_sink_mt = wincolor_stdout_sink_mt;
using stdout_color_sink_st = wincolor_stdout_sink_st;
using stderr_color_sink_mt = wincolor_stderr_sink_mt;
using stderr_color_sink_st = wincolor_stderr_sink_st;
#else
using stdout_color_sink_mt = ansicolor_stdout_sink_mt;
using stdout_color_sink_st = ansicolor_stdout_sink_st;
using stderr_color_sink_mt = ansicolor_stderr_sink_mt;
using stderr_color_sink_st = ansicolor_stderr_sink_st;
#endif
} // namespace sinks

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stdout_color_mt(const std::string &logger_name, color_mode mode = color_mode::automatic);

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stdout_color_st(const std::string &logger_name, color_mode mode = color_mode::automatic);

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stderr_color_mt(const std::string &logger_name, color_mode mode = color_mode::automatic);

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stderr_color_st(const std::string &logger_name, color_mode mode = color_mode::automatic);

} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "stdout_color_sinks-inl.h"
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/stdout_sinks-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/stdout_sinks.h>
#endif

#include <spdlog/details/console_globals.h>
#include <spdlog/pattern_formatter.h>
#include <memory>

#ifdef _WIN32
// under windows using fwrite to non-binary stream results in \r\r\n (see issue #1675)
// so instead we use ::FileWrite
#    include <spdlog/details/windows_include.h>

#    ifndef _USING_V110_SDK71_ // fileapi.h doesn't exist in winxp
#        include <fileapi.h>   // WriteFile (..)
#    endif

#    include <io.h>    // _get_osfhandle(..)
#    include <stdio.h> // _fileno(..)
#endif                 // WIN32

namespace spdlog {

namespace sinks {

template<typename ConsoleMutex>
SPDLOG_INLINE stdout_sink_base<ConsoleMutex>::stdout_sink_base(FILE *file)
    : mutex_(ConsoleMutex::mutex())
    , file_(file)
    , formatter_(details::make_unique<spdlog::pattern_formatter>())
{
#ifdef _WIN32
    // get windows handle from the FILE* object

    handle_ = reinterpret_cast<HANDLE>(::_get_osfhandle(::_fileno(file_)));

    // don't throw to support cases where no console is attached,
    // and let the log method to do nothing if (handle_ == INVALID_HANDLE_VALUE).
    // throw only if non stdout/stderr target is requested (probably regular file and not console).
    if (handle_ == INVALID_HANDLE_VALUE && file != stdout && file != stderr)
    {
        throw_spdlog_ex("spdlog::stdout_sink_base: _get_osfhandle() failed", errno);
    }
#endif // WIN32
}

template<typename ConsoleMutex>
SPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::log(const details::log_msg &msg)
{
#ifdef _WIN32
    if (handle_ == INVALID_HANDLE_VALUE)
    {
        return;
    }
    std::lock_guard<mutex_t> lock(mutex_);
    memory_buf_t formatted;
    formatter_->format(msg, formatted);
    ::fflush(file_); // flush in case there is something in this file_ already
    auto size = static_cast<DWORD>(formatted.size());
    DWORD bytes_written = 0;
    bool ok = ::WriteFile(handle_, formatted.data(), size, &bytes_written, nullptr) != 0;
    if (!ok)
    {
        throw_spdlog_ex("stdout_sink_base: WriteFile() failed. GetLastError(): " + std::to_string(::GetLastError()));
    }
#else
    std::lock_guard<mutex_t> lock(mutex_);
    memory_buf_t formatted;
    formatter_->format(msg, formatted);
    ::fwrite(formatted.data(), sizeof(char), formatted.size(), file_);
    ::fflush(file_); // flush every line to terminal
#endif // WIN32
}

template<typename ConsoleMutex>
SPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::flush()
{
    std::lock_guard<mutex_t> lock(mutex_);
    fflush(file_);
}

template<typename ConsoleMutex>
SPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::set_pattern(const std::string &pattern)
{
    std::lock_guard<mutex_t> lock(mutex_);
    formatter_ = std::unique_ptr<spdlog::formatter>(new pattern_formatter(pattern));
}

template<typename ConsoleMutex>
SPDLOG_INLINE void stdout_sink_base<ConsoleMutex>::set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter)
{
    std::lock_guard<mutex_t> lock(mutex_);
    formatter_ = std::move(sink_formatter);
}

// stdout sink
template<typename ConsoleMutex>
SPDLOG_INLINE stdout_sink<ConsoleMutex>::stdout_sink()
    : stdout_sink_base<ConsoleMutex>(stdout)
{}

// stderr sink
template<typename ConsoleMutex>
SPDLOG_INLINE stderr_sink<ConsoleMutex>::stderr_sink()
    : stdout_sink_base<ConsoleMutex>(stderr)
{}

} // namespace sinks

// factory methods
template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stdout_logger_mt(const std::string &logger_name)
{
    return Factory::template create<sinks::stdout_sink_mt>(logger_name);
}

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stdout_logger_st(const std::string &logger_name)
{
    return Factory::template create<sinks::stdout_sink_st>(logger_name);
}

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stderr_logger_mt(const std::string &logger_name)
{
    return Factory::template create<sinks::stderr_sink_mt>(logger_name);
}

template<typename Factory>
SPDLOG_INLINE std::shared_ptr<logger> stderr_logger_st(const std::string &logger_name)
{
    return Factory::template create<sinks::stderr_sink_st>(logger_name);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/stdout_sinks.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/details/console_globals.h>
#include <spdlog/details/synchronous_factory.h>
#include <spdlog/sinks/sink.h>
#include <cstdio>

#ifdef _WIN32
#    include <spdlog/details/windows_include.h>
#endif

namespace spdlog {

namespace sinks {

template<typename ConsoleMutex>
class stdout_sink_base : public sink
{
public:
    using mutex_t = typename ConsoleMutex::mutex_t;
    explicit stdout_sink_base(FILE *file);
    ~stdout_sink_base() override = default;

    stdout_sink_base(const stdout_sink_base &other) = delete;
    stdout_sink_base(stdout_sink_base &&other) = delete;

    stdout_sink_base &operator=(const stdout_sink_base &other) = delete;
    stdout_sink_base &operator=(stdout_sink_base &&other) = delete;

    void log(const details::log_msg &msg) override;
    void flush() override;
    void set_pattern(const std::string &pattern) override;

    void set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter) override;

protected:
    mutex_t &mutex_;
    FILE *file_;
    std::unique_ptr<spdlog::formatter> formatter_;
#ifdef _WIN32
    HANDLE handle_;
#endif // WIN32
};

template<typename ConsoleMutex>
class stdout_sink : public stdout_sink_base<ConsoleMutex>
{
public:
    stdout_sink();
};

template<typename ConsoleMutex>
class stderr_sink : public stdout_sink_base<ConsoleMutex>
{
public:
    stderr_sink();
};

using stdout_sink_mt = stdout_sink<details::console_mutex>;
using stdout_sink_st = stdout_sink<details::console_nullmutex>;

using stderr_sink_mt = stderr_sink<details::console_mutex>;
using stderr_sink_st = stderr_sink<details::console_nullmutex>;

} // namespace sinks

// factory methods
template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stdout_logger_mt(const std::string &logger_name);

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stdout_logger_st(const std::string &logger_name);

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stderr_logger_mt(const std::string &logger_name);

template<typename Factory = spdlog::synchronous_factory>
std::shared_ptr<logger> stderr_logger_st(const std::string &logger_name);

} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "stdout_sinks-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/syslog_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/details/synchronous_factory.h>

#include <array>
#include <string>
#include <syslog.h>

namespace spdlog {
namespace sinks {
/**
 * Sink that write to syslog using the `syscall()` library call.
 */
template<typename Mutex>
class syslog_sink : public base_sink<Mutex>
{

public:
    syslog_sink(std::string ident, int syslog_option, int syslog_facility, bool enable_formatting)
        : enable_formatting_{enable_formatting}
        , syslog_levels_{{/* spdlog::level::trace      */ LOG_DEBUG,
              /* spdlog::level::debug      */ LOG_DEBUG,
              /* spdlog::level::info       */ LOG_INFO,
              /* spdlog::level::warn       */ LOG_WARNING,
              /* spdlog::level::err        */ LOG_ERR,
              /* spdlog::level::critical   */ LOG_CRIT,
              /* spdlog::level::off        */ LOG_INFO}}
        , ident_{std::move(ident)}
    {
        // set ident to be program name if empty
        ::openlog(ident_.empty() ? nullptr : ident_.c_str(), syslog_option, syslog_facility);
    }

    ~syslog_sink() override
    {
        ::closelog();
    }

    syslog_sink(const syslog_sink &) = delete;
    syslog_sink &operator=(const syslog_sink &) = delete;

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        string_view_t payload;
        memory_buf_t formatted;
        if (enable_formatting_)
        {
            base_sink<Mutex>::formatter_->format(msg, formatted);
            payload = string_view_t(formatted.data(), formatted.size());
        }
        else
        {
            payload = msg.payload;
        }

        size_t length = payload.size();
        // limit to max int
        if (length > static_cast<size_t>(std::numeric_limits<int>::max()))
        {
            length = static_cast<size_t>(std::numeric_limits<int>::max());
        }

        ::syslog(syslog_prio_from_level(msg), "%.*s", static_cast<int>(length), payload.data());
    }

    void flush_() override {}
    bool enable_formatting_ = false;

private:
    using levels_array = std::array<int, 7>;
    levels_array syslog_levels_;
    // must store the ident because the man says openlog might use the pointer as
    // is and not a string copy
    const std::string ident_;

    //
    // Simply maps spdlog's log level to syslog priority level.
    //
    int syslog_prio_from_level(const details::log_msg &msg) const
    {
        return syslog_levels_.at(static_cast<levels_array::size_type>(msg.level));
    }
};

using syslog_sink_mt = syslog_sink<std::mutex>;
using syslog_sink_st = syslog_sink<details::null_mutex>;
} // namespace sinks

// Create and register a syslog logger
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> syslog_logger_mt(const std::string &logger_name, const std::string &syslog_ident = "", int syslog_option = 0,
    int syslog_facility = LOG_USER, bool enable_formatting = false)
{
    return Factory::template create<sinks::syslog_sink_mt>(logger_name, syslog_ident, syslog_option, syslog_facility, enable_formatting);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> syslog_logger_st(const std::string &logger_name, const std::string &syslog_ident = "", int syslog_option = 0,
    int syslog_facility = LOG_USER, bool enable_formatting = false)
{
    return Factory::template create<sinks::syslog_sink_st>(logger_name, syslog_ident, syslog_option, syslog_facility, enable_formatting);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/systemd_sink.h`:

```h
// Copyright(c) 2019 ZVYAGIN.Alexander@gmail.com
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/details/synchronous_factory.h>

#include <array>
#ifndef SD_JOURNAL_SUPPRESS_LOCATION
#    define SD_JOURNAL_SUPPRESS_LOCATION
#endif
#include <systemd/sd-journal.h>

namespace spdlog {
namespace sinks {

/**
 * Sink that write to systemd journal using the `sd_journal_send()` library call.
 */
template<typename Mutex>
class systemd_sink : public base_sink<Mutex>
{
public:
    systemd_sink(std::string ident = "", bool enable_formatting = false)
        : ident_{std::move(ident)}
        , enable_formatting_{enable_formatting}
        , syslog_levels_{{/* spdlog::level::trace      */ LOG_DEBUG,
              /* spdlog::level::debug      */ LOG_DEBUG,
              /* spdlog::level::info       */ LOG_INFO,
              /* spdlog::level::warn       */ LOG_WARNING,
              /* spdlog::level::err        */ LOG_ERR,
              /* spdlog::level::critical   */ LOG_CRIT,
              /* spdlog::level::off        */ LOG_INFO}}
    {}

    ~systemd_sink() override {}

    systemd_sink(const systemd_sink &) = delete;
    systemd_sink &operator=(const systemd_sink &) = delete;

protected:
    const std::string ident_;
    bool enable_formatting_ = false;
    using levels_array = std::array<int, 7>;
    levels_array syslog_levels_;

    void sink_it_(const details::log_msg &msg) override
    {
        int err;
        string_view_t payload;
        memory_buf_t formatted;
        if (enable_formatting_)
        {
            base_sink<Mutex>::formatter_->format(msg, formatted);
            payload = string_view_t(formatted.data(), formatted.size());
        }
        else
        {
            payload = msg.payload;
        }

        size_t length = payload.size();
        // limit to max int
        if (length > static_cast<size_t>(std::numeric_limits<int>::max()))
        {
            length = static_cast<size_t>(std::numeric_limits<int>::max());
        }

        const string_view_t syslog_identifier = ident_.empty() ? msg.logger_name : ident_;

        // Do not send source location if not available
        if (msg.source.empty())
        {
            // Note: function call inside '()' to avoid macro expansion
            err = (sd_journal_send)("MESSAGE=%.*s", static_cast<int>(length), payload.data(), "PRIORITY=%d", syslog_level(msg.level),
                "SYSLOG_IDENTIFIER=%.*s", static_cast<int>(syslog_identifier.size()), syslog_identifier.data(), nullptr);
        }
        else
        {
            err = (sd_journal_send)("MESSAGE=%.*s", static_cast<int>(length), payload.data(), "PRIORITY=%d", syslog_level(msg.level),
                "SYSLOG_IDENTIFIER=%.*s", static_cast<int>(syslog_identifier.size()), syslog_identifier.data(), "CODE_FILE=%s",
                msg.source.filename, "CODE_LINE=%d", msg.source.line, "CODE_FUNC=%s", msg.source.funcname, nullptr);
        }

        if (err)
        {
            throw_spdlog_ex("Failed writing to systemd", errno);
        }
    }

    int syslog_level(level::level_enum l)
    {
        return syslog_levels_.at(static_cast<levels_array::size_type>(l));
    }

    void flush_() override {}
};

using systemd_sink_mt = systemd_sink<std::mutex>;
using systemd_sink_st = systemd_sink<details::null_mutex>;
} // namespace sinks

// Create and register a syslog logger
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> systemd_logger_mt(
    const std::string &logger_name, const std::string &ident = "", bool enable_formatting = false)
{
    return Factory::template create<sinks::systemd_sink_mt>(logger_name, ident, enable_formatting);
}

template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> systemd_logger_st(
    const std::string &logger_name, const std::string &ident = "", bool enable_formatting = false)
{
    return Factory::template create<sinks::systemd_sink_st>(logger_name, ident, enable_formatting);
}
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/tcp_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/null_mutex.h>
#ifdef _WIN32
#    include <spdlog/details/tcp_client-windows.h>
#else
#    include <spdlog/details/tcp_client.h>
#endif

#include <mutex>
#include <string>
#include <chrono>
#include <functional>

#pragma once

// Simple tcp client sink
// Connects to remote address and send the formatted log.
// Will attempt to reconnect if connection drops.
// If more complicated behaviour is needed (i.e get responses), you can inherit it and override the sink_it_ method.

namespace spdlog {
namespace sinks {

struct tcp_sink_config
{
    std::string server_host;
    int server_port;
    bool lazy_connect = false; // if true connect on first log call instead of on construction

    tcp_sink_config(std::string host, int port)
        : server_host{std::move(host)}
        , server_port{port}
    {}
};

template<typename Mutex>
class tcp_sink : public spdlog::sinks::base_sink<Mutex>
{
public:
    // connect to tcp host/port or throw if failed
    // host can be hostname or ip address

    explicit tcp_sink(tcp_sink_config sink_config)
        : config_{std::move(sink_config)}
    {
        if (!config_.lazy_connect)
        {
            this->client_.connect(config_.server_host, config_.server_port);
        }
    }

    ~tcp_sink() override = default;

protected:
    void sink_it_(const spdlog::details::log_msg &msg) override
    {
        spdlog::memory_buf_t formatted;
        spdlog::sinks::base_sink<Mutex>::formatter_->format(msg, formatted);
        if (!client_.is_connected())
        {
            client_.connect(config_.server_host, config_.server_port);
        }
        client_.send(formatted.data(), formatted.size());
    }

    void flush_() override {}
    tcp_sink_config config_;
    details::tcp_client client_;
};

using tcp_sink_mt = tcp_sink<std::mutex>;
using tcp_sink_st = tcp_sink<spdlog::details::null_mutex>;

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/udp_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/common.h>
#include <spdlog/sinks/base_sink.h>
#include <spdlog/details/null_mutex.h>
#ifdef _WIN32
#    include <spdlog/details/udp_client-windows.h>
#else
#    include <spdlog/details/udp_client.h>
#endif

#include <mutex>
#include <string>
#include <chrono>
#include <functional>

// Simple udp client sink
// Sends formatted log via udp

namespace spdlog {
namespace sinks {

struct udp_sink_config
{
    std::string server_host;
    uint16_t server_port;

    udp_sink_config(std::string host, uint16_t port)
        : server_host{std::move(host)}
        , server_port{port}
    {}
};

template<typename Mutex>
class udp_sink : public spdlog::sinks::base_sink<Mutex>
{
public:
    // host can be hostname or ip address
    explicit udp_sink(udp_sink_config sink_config)
        : client_{sink_config.server_host, sink_config.server_port}
    {}

    ~udp_sink() override = default;

protected:
    void sink_it_(const spdlog::details::log_msg &msg) override
    {
        spdlog::memory_buf_t formatted;
        spdlog::sinks::base_sink<Mutex>::formatter_->format(msg, formatted);
        client_.send(formatted.data(), formatted.size());
    }

    void flush_() override {}
    details::udp_client client_;
};

using udp_sink_mt = udp_sink<std::mutex>;
using udp_sink_st = udp_sink<spdlog::details::null_mutex>;

} // namespace sinks

//
// factory functions
//
template<typename Factory = spdlog::synchronous_factory>
inline std::shared_ptr<logger> udp_logger_mt(const std::string &logger_name, sinks::udp_sink_config skin_config)
{
    return Factory::template create<sinks::udp_sink_mt>(logger_name, skin_config);
}

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/win_eventlog_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

// Writing to Windows Event Log requires the registry entries below to be present, with the following modifications:
// 1. <log_name>    should be replaced with your log name (e.g. your application name)
// 2. <source_name> should be replaced with the specific source name and the key should be duplicated for
//                  each source used in the application
//
// Since typically modifications of this kind require elevation, it's better to do it as a part of setup procedure.
// The snippet below uses mscoree.dll as the message file as it exists on most of the Windows systems anyway and
// happens to contain the needed resource.
//
// You can also specify a custom message file if needed.
// Please refer to Event Log functions descriptions in MSDN for more details on custom message files.

/*---------------------------------------------------------------------------------------

Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\<log_name>]

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\<log_name>\<source_name>]
"TypesSupported"=dword:00000007
"EventMessageFile"=hex(2):25,00,73,00,79,00,73,00,74,00,65,00,6d,00,72,00,6f,\
  00,6f,00,74,00,25,00,5c,00,53,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,\
  5c,00,6d,00,73,00,63,00,6f,00,72,00,65,00,65,00,2e,00,64,00,6c,00,6c,00,00,\
  00

-----------------------------------------------------------------------------------------*/

#pragma once

#include <spdlog/details/null_mutex.h>
#include <spdlog/sinks/base_sink.h>

#include <spdlog/details/windows_include.h>
#include <winbase.h>

#include <mutex>
#include <string>
#include <vector>

namespace spdlog {
namespace sinks {

namespace win_eventlog {

namespace internal {

struct local_alloc_t
{
    HLOCAL hlocal_;

    SPDLOG_CONSTEXPR local_alloc_t() SPDLOG_NOEXCEPT : hlocal_(nullptr) {}

    local_alloc_t(local_alloc_t const &) = delete;
    local_alloc_t &operator=(local_alloc_t const &) = delete;

    ~local_alloc_t() SPDLOG_NOEXCEPT
    {
        if (hlocal_)
        {
            LocalFree(hlocal_);
        }
    }
};

/** Windows error */
struct win32_error : public spdlog_ex
{
    /** Formats an error report line: "user-message: error-code (system message)" */
    static std::string format(std::string const &user_message, DWORD error_code = GetLastError())
    {
        std::string system_message;

        local_alloc_t format_message_result{};
        auto format_message_succeeded =
            ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr,
                error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&format_message_result.hlocal_, 0, nullptr);

        if (format_message_succeeded && format_message_result.hlocal_)
        {
            system_message = fmt_lib::format(" ({})", (LPSTR)format_message_result.hlocal_);
        }

        return fmt_lib::format("{}: {}{}", user_message, error_code, system_message);
    }

    explicit win32_error(std::string const &func_name, DWORD error = GetLastError())
        : spdlog_ex(format(func_name, error))
    {}
};

/** Wrapper for security identifiers (SID) on Windows */
struct sid_t
{
    std::vector<char> buffer_;

public:
    sid_t() {}

    /** creates a wrapped SID copy */
    static sid_t duplicate_sid(PSID psid)
    {
        if (!::IsValidSid(psid))
        {
            throw_spdlog_ex("sid_t::sid_t(): invalid SID received");
        }

        auto const sid_length{::GetLengthSid(psid)};

        sid_t result;
        result.buffer_.resize(sid_length);
        if (!::CopySid(sid_length, (PSID)result.as_sid(), psid))
        {
            SPDLOG_THROW(win32_error("CopySid"));
        }

        return result;
    }

    /** Retrieves pointer to the internal buffer contents as SID* */
    SID *as_sid() const
    {
        return buffer_.empty() ? nullptr : (SID *)buffer_.data();
    }

    /** Get SID for the current user */
    static sid_t get_current_user_sid()
    {
        /* create and init RAII holder for process token */
        struct process_token_t
        {
            HANDLE token_handle_ = INVALID_HANDLE_VALUE;
            explicit process_token_t(HANDLE process)
            {
                if (!::OpenProcessToken(process, TOKEN_QUERY, &token_handle_))
                {
                    SPDLOG_THROW(win32_error("OpenProcessToken"));
                }
            }

            ~process_token_t()
            {
                ::CloseHandle(token_handle_);
            }

        } current_process_token(::GetCurrentProcess()); // GetCurrentProcess returns pseudohandle, no leak here!

        // Get the required size, this is expected to fail with ERROR_INSUFFICIENT_BUFFER and return the token size
        DWORD tusize = 0;
        if (::GetTokenInformation(current_process_token.token_handle_, TokenUser, NULL, 0, &tusize))
        {
            SPDLOG_THROW(win32_error("GetTokenInformation should fail"));
        }

        // get user token
        std::vector<unsigned char> buffer(static_cast<size_t>(tusize));
        if (!::GetTokenInformation(current_process_token.token_handle_, TokenUser, (LPVOID)buffer.data(), tusize, &tusize))
        {
            SPDLOG_THROW(win32_error("GetTokenInformation"));
        }

        // create a wrapper of the SID data as stored in the user token
        return sid_t::duplicate_sid(((TOKEN_USER *)buffer.data())->User.Sid);
    }
};

struct eventlog
{
    static WORD get_event_type(details::log_msg const &msg)
    {
        switch (msg.level)
        {
        case level::trace:
        case level::debug:
            return EVENTLOG_SUCCESS;

        case level::info:
            return EVENTLOG_INFORMATION_TYPE;

        case level::warn:
            return EVENTLOG_WARNING_TYPE;

        case level::err:
        case level::critical:
        case level::off:
            return EVENTLOG_ERROR_TYPE;

        default:
            return EVENTLOG_INFORMATION_TYPE;
        }
    }

    static WORD get_event_category(details::log_msg const &msg)
    {
        return (WORD)msg.level;
    }
};

} // namespace internal

/*
 * Windows Event Log sink
 */
template<typename Mutex>
class win_eventlog_sink : public base_sink<Mutex>
{
private:
    HANDLE hEventLog_{NULL};
    internal::sid_t current_user_sid_;
    std::string source_;
    WORD event_id_;

    HANDLE event_log_handle()
    {
        if (!hEventLog_)
        {
            hEventLog_ = ::RegisterEventSourceA(nullptr, source_.c_str());
            if (!hEventLog_ || hEventLog_ == (HANDLE)ERROR_ACCESS_DENIED)
            {
                SPDLOG_THROW(internal::win32_error("RegisterEventSource"));
            }
        }

        return hEventLog_;
    }

protected:
    void sink_it_(const details::log_msg &msg) override
    {
        using namespace internal;

        bool succeeded;
        memory_buf_t formatted;
        base_sink<Mutex>::formatter_->format(msg, formatted);
        formatted.push_back('\0');

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
        wmemory_buf_t buf;
        details::os::utf8_to_wstrbuf(string_view_t(formatted.data(), formatted.size()), buf);

        LPCWSTR lp_wstr = buf.data();
        succeeded = ::ReportEventW(event_log_handle(), eventlog::get_event_type(msg), eventlog::get_event_category(msg), event_id_,
            current_user_sid_.as_sid(), 1, 0, &lp_wstr, nullptr);
#else
        LPCSTR lp_str = formatted.data();
        succeeded = ::ReportEventA(event_log_handle(), eventlog::get_event_type(msg), eventlog::get_event_category(msg), event_id_,
            current_user_sid_.as_sid(), 1, 0, &lp_str, nullptr);
#endif

        if (!succeeded)
        {
            SPDLOG_THROW(win32_error("ReportEvent"));
        }
    }

    void flush_() override {}

public:
    win_eventlog_sink(std::string const &source, WORD event_id = 1000 /* according to mscoree.dll */)
        : source_(source)
        , event_id_(event_id)
    {
        try
        {
            current_user_sid_ = internal::sid_t::get_current_user_sid();
        }
        catch (...)
        {
            // get_current_user_sid() is unlikely to fail and if it does, we can still proceed without
            // current_user_sid but in the event log the record will have no user name
        }
    }

    ~win_eventlog_sink()
    {
        if (hEventLog_)
            DeregisterEventSource(hEventLog_);
    }
};

} // namespace win_eventlog

using win_eventlog_sink_mt = win_eventlog::win_eventlog_sink<std::mutex>;
using win_eventlog_sink_st = win_eventlog::win_eventlog_sink<details::null_mutex>;

} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/wincolor_sink-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/sinks/wincolor_sink.h>
#endif

#include <spdlog/details/windows_include.h>
#include <wincon.h>

#include <spdlog/common.h>
#include <spdlog/pattern_formatter.h>

namespace spdlog {
namespace sinks {
template<typename ConsoleMutex>
SPDLOG_INLINE wincolor_sink<ConsoleMutex>::wincolor_sink(void *out_handle, color_mode mode)
    : out_handle_(out_handle)
    , mutex_(ConsoleMutex::mutex())
    , formatter_(details::make_unique<spdlog::pattern_formatter>())
{

    set_color_mode_impl(mode);
    // set level colors
    colors_[level::trace] = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;     // white
    colors_[level::debug] = FOREGROUND_GREEN | FOREGROUND_BLUE;                      // cyan
    colors_[level::info] = FOREGROUND_GREEN;                                         // green
    colors_[level::warn] = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY; // intense yellow
    colors_[level::err] = FOREGROUND_RED | FOREGROUND_INTENSITY;                     // intense red
    colors_[level::critical] =
        BACKGROUND_RED | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY; // intense white on red background
    colors_[level::off] = 0;
}

template<typename ConsoleMutex>
SPDLOG_INLINE wincolor_sink<ConsoleMutex>::~wincolor_sink()
{
    this->flush();
}

// change the color for the given level
template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color(level::level_enum level, std::uint16_t color)
{
    std::lock_guard<mutex_t> lock(mutex_);
    colors_[level] = color;
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::log(const details::log_msg &msg)
{
    if (out_handle_ == nullptr || out_handle_ == INVALID_HANDLE_VALUE)
    {
        return;
    }

    std::lock_guard<mutex_t> lock(mutex_);
    msg.color_range_start = 0;
    msg.color_range_end = 0;
    memory_buf_t formatted;
    formatter_->format(msg, formatted);
    if (should_do_colors_ && msg.color_range_end > msg.color_range_start)
    {
        // before color range
        print_range_(formatted, 0, msg.color_range_start);
        // in color range
        auto orig_attribs = static_cast<WORD>(set_foreground_color_(colors_[msg.level]));
        print_range_(formatted, msg.color_range_start, msg.color_range_end);
        // reset to orig colors
        ::SetConsoleTextAttribute(static_cast<HANDLE>(out_handle_), orig_attribs);
        print_range_(formatted, msg.color_range_end, formatted.size());
    }
    else // print without colors if color range is invalid (or color is disabled)
    {
        write_to_file_(formatted);
    }
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::flush()
{
    // windows console always flushed?
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_pattern(const std::string &pattern)
{
    std::lock_guard<mutex_t> lock(mutex_);
    formatter_ = std::unique_ptr<spdlog::formatter>(new pattern_formatter(pattern));
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter)
{
    std::lock_guard<mutex_t> lock(mutex_);
    formatter_ = std::move(sink_formatter);
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color_mode(color_mode mode)
{
    std::lock_guard<mutex_t> lock(mutex_);
    set_color_mode_impl(mode);
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color_mode_impl(color_mode mode)
{
    if (mode == color_mode::automatic)
    {
        // should do colors only if out_handle_  points to actual console.
        DWORD console_mode;
        bool in_console = ::GetConsoleMode(static_cast<HANDLE>(out_handle_), &console_mode) != 0;
        should_do_colors_ = in_console;
    }
    else
    {
        should_do_colors_ = mode == color_mode::always ? true : false;
    }
}

// set foreground color and return the orig console attributes (for resetting later)
template<typename ConsoleMutex>
std::uint16_t SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_foreground_color_(std::uint16_t attribs)
{
    CONSOLE_SCREEN_BUFFER_INFO orig_buffer_info;
    if (!::GetConsoleScreenBufferInfo(static_cast<HANDLE>(out_handle_), &orig_buffer_info))
    {
        // just return white if failed getting console info
        return FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
    }

    // change only the foreground bits (lowest 4 bits)
    auto new_attribs = static_cast<WORD>(attribs) | (orig_buffer_info.wAttributes & 0xfff0);
    auto ignored = ::SetConsoleTextAttribute(static_cast<HANDLE>(out_handle_), static_cast<WORD>(new_attribs));
    (void)(ignored);
    return static_cast<std::uint16_t>(orig_buffer_info.wAttributes); // return orig attribs
}

// print a range of formatted message to console
template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::print_range_(const memory_buf_t &formatted, size_t start, size_t end)
{
    if (end > start)
    {
        auto size = static_cast<DWORD>(end - start);
        auto ignored = ::WriteConsoleA(static_cast<HANDLE>(out_handle_), formatted.data() + start, size, nullptr, nullptr);
        (void)(ignored);
    }
}

template<typename ConsoleMutex>
void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::write_to_file_(const memory_buf_t &formatted)
{
    auto size = static_cast<DWORD>(formatted.size());
    DWORD bytes_written = 0;
    auto ignored = ::WriteFile(static_cast<HANDLE>(out_handle_), formatted.data(), size, &bytes_written, nullptr);
    (void)(ignored);
}

// wincolor_stdout_sink
template<typename ConsoleMutex>
SPDLOG_INLINE wincolor_stdout_sink<ConsoleMutex>::wincolor_stdout_sink(color_mode mode)
    : wincolor_sink<ConsoleMutex>(::GetStdHandle(STD_OUTPUT_HANDLE), mode)
{}

// wincolor_stderr_sink
template<typename ConsoleMutex>
SPDLOG_INLINE wincolor_stderr_sink<ConsoleMutex>::wincolor_stderr_sink(color_mode mode)
    : wincolor_sink<ConsoleMutex>(::GetStdHandle(STD_ERROR_HANDLE), mode)
{}
} // namespace sinks
} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/sinks/wincolor_sink.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/common.h>
#include <spdlog/details/console_globals.h>
#include <spdlog/details/null_mutex.h>
#include <spdlog/sinks/sink.h>

#include <memory>
#include <mutex>
#include <string>
#include <array>
#include <cstdint>

namespace spdlog {
namespace sinks {
/*
 * Windows color console sink. Uses WriteConsoleA to write to the console with
 * colors
 */
template<typename ConsoleMutex>
class wincolor_sink : public sink
{
public:
    wincolor_sink(void *out_handle, color_mode mode);
    ~wincolor_sink() override;

    wincolor_sink(const wincolor_sink &other) = delete;
    wincolor_sink &operator=(const wincolor_sink &other) = delete;

    // change the color for the given level
    void set_color(level::level_enum level, std::uint16_t color);
    void log(const details::log_msg &msg) final override;
    void flush() final override;
    void set_pattern(const std::string &pattern) override final;
    void set_formatter(std::unique_ptr<spdlog::formatter> sink_formatter) override final;
    void set_color_mode(color_mode mode);

protected:
    using mutex_t = typename ConsoleMutex::mutex_t;
    void *out_handle_;
    mutex_t &mutex_;
    bool should_do_colors_;
    std::unique_ptr<spdlog::formatter> formatter_;
    std::array<std::uint16_t, level::n_levels> colors_;

    // set foreground color and return the orig console attributes (for resetting later)
    std::uint16_t set_foreground_color_(std::uint16_t attribs);

    // print a range of formatted message to console
    void print_range_(const memory_buf_t &formatted, size_t start, size_t end);

    // in case we are redirected to file (not in console mode)
    void write_to_file_(const memory_buf_t &formatted);

    void set_color_mode_impl(color_mode mode);
};

template<typename ConsoleMutex>
class wincolor_stdout_sink : public wincolor_sink<ConsoleMutex>
{
public:
    explicit wincolor_stdout_sink(color_mode mode = color_mode::automatic);
};

template<typename ConsoleMutex>
class wincolor_stderr_sink : public wincolor_sink<ConsoleMutex>
{
public:
    explicit wincolor_stderr_sink(color_mode mode = color_mode::automatic);
};

using wincolor_stdout_sink_mt = wincolor_stdout_sink<details::console_mutex>;
using wincolor_stdout_sink_st = wincolor_stdout_sink<details::console_nullmutex>;

using wincolor_stderr_sink_mt = wincolor_stderr_sink<details::console_mutex>;
using wincolor_stderr_sink_st = wincolor_stderr_sink<details::console_nullmutex>;
} // namespace sinks
} // namespace spdlog

#ifdef SPDLOG_HEADER_ONLY
#    include "wincolor_sink-inl.h"
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/spdlog-inl.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#ifndef SPDLOG_HEADER_ONLY
#    include <spdlog/spdlog.h>
#endif

#include <spdlog/common.h>
#include <spdlog/pattern_formatter.h>

namespace spdlog {

SPDLOG_INLINE void initialize_logger(std::shared_ptr<logger> logger)
{
    details::registry::instance().initialize_logger(std::move(logger));
}

SPDLOG_INLINE std::shared_ptr<logger> get(const std::string &name)
{
    return details::registry::instance().get(name);
}

SPDLOG_INLINE void set_formatter(std::unique_ptr<spdlog::formatter> formatter)
{
    details::registry::instance().set_formatter(std::move(formatter));
}

SPDLOG_INLINE void set_pattern(std::string pattern, pattern_time_type time_type)
{
    set_formatter(std::unique_ptr<spdlog::formatter>(new pattern_formatter(std::move(pattern), time_type)));
}

SPDLOG_INLINE void enable_backtrace(size_t n_messages)
{
    details::registry::instance().enable_backtrace(n_messages);
}

SPDLOG_INLINE void disable_backtrace()
{
    details::registry::instance().disable_backtrace();
}

SPDLOG_INLINE void dump_backtrace()
{
    default_logger_raw()->dump_backtrace();
}

SPDLOG_INLINE level::level_enum get_level()
{
    return default_logger_raw()->level();
}

SPDLOG_INLINE bool should_log(level::level_enum log_level)
{
    return default_logger_raw()->should_log(log_level);
}

SPDLOG_INLINE void set_level(level::level_enum log_level)
{
    details::registry::instance().set_level(log_level);
}

SPDLOG_INLINE void flush_on(level::level_enum log_level)
{
    details::registry::instance().flush_on(log_level);
}

SPDLOG_INLINE void flush_every(std::chrono::seconds interval)
{
    details::registry::instance().flush_every(interval);
}

SPDLOG_INLINE void set_error_handler(void (*handler)(const std::string &msg))
{
    details::registry::instance().set_error_handler(handler);
}

SPDLOG_INLINE void register_logger(std::shared_ptr<logger> logger)
{
    details::registry::instance().register_logger(std::move(logger));
}

SPDLOG_INLINE void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun)
{
    details::registry::instance().apply_all(fun);
}

SPDLOG_INLINE void drop(const std::string &name)
{
    details::registry::instance().drop(name);
}

SPDLOG_INLINE void drop_all()
{
    details::registry::instance().drop_all();
}

SPDLOG_INLINE void shutdown()
{
    details::registry::instance().shutdown();
}

SPDLOG_INLINE void set_automatic_registration(bool automatic_registration)
{
    details::registry::instance().set_automatic_registration(automatic_registration);
}

SPDLOG_INLINE std::shared_ptr<spdlog::logger> default_logger()
{
    return details::registry::instance().default_logger();
}

SPDLOG_INLINE spdlog::logger *default_logger_raw()
{
    return details::registry::instance().get_default_raw();
}

SPDLOG_INLINE void set_default_logger(std::shared_ptr<spdlog::logger> default_logger)
{
    details::registry::instance().set_default_logger(std::move(default_logger));
}

} // namespace spdlog

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/spdlog.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

// spdlog main header file.
// see example.cpp for usage example

#ifndef SPDLOG_H
#define SPDLOG_H

#pragma once

#include <spdlog/common.h>
#include <spdlog/details/registry.h>
#include <spdlog/logger.h>
#include <spdlog/version.h>
#include <spdlog/details/synchronous_factory.h>

#include <chrono>
#include <functional>
#include <memory>
#include <string>

namespace spdlog {

using default_factory = synchronous_factory;

// Create and register a logger with a templated sink type
// The logger's level, formatter and flush level will be set according the
// global settings.
//
// Example:
//   spdlog::create<daily_file_sink_st>("logger_name", "dailylog_filename", 11, 59);
template<typename Sink, typename... SinkArgs>
inline std::shared_ptr<spdlog::logger> create(std::string logger_name, SinkArgs &&... sink_args)
{
    return default_factory::create<Sink>(std::move(logger_name), std::forward<SinkArgs>(sink_args)...);
}

// Initialize and register a logger,
// formatter and flush level will be set according the global settings.
//
// Useful for initializing manually created loggers with the global settings.
//
// Example:
//   auto mylogger = std::make_shared<spdlog::logger>("mylogger", ...);
//   spdlog::initialize_logger(mylogger);
SPDLOG_API void initialize_logger(std::shared_ptr<logger> logger);

// Return an existing logger or nullptr if a logger with such name doesn't
// exist.
// example: spdlog::get("my_logger")->info("hello {}", "world");
SPDLOG_API std::shared_ptr<logger> get(const std::string &name);

// Set global formatter. Each sink in each logger will get a clone of this object
SPDLOG_API void set_formatter(std::unique_ptr<spdlog::formatter> formatter);

// Set global format string.
// example: spdlog::set_pattern("%Y-%m-%d %H:%M:%S.%e %l : %v");
SPDLOG_API void set_pattern(std::string pattern, pattern_time_type time_type = pattern_time_type::local);

// enable global backtrace support
SPDLOG_API void enable_backtrace(size_t n_messages);

// disable global backtrace support
SPDLOG_API void disable_backtrace();

// call dump backtrace on default logger
SPDLOG_API void dump_backtrace();

// Get global logging level
SPDLOG_API level::level_enum get_level();

// Set global logging level
SPDLOG_API void set_level(level::level_enum log_level);

// Determine whether the default logger should log messages with a certain level
SPDLOG_API bool should_log(level::level_enum lvl);

// Set global flush level
SPDLOG_API void flush_on(level::level_enum log_level);

// Start/Restart a periodic flusher thread
// Warning: Use only if all your loggers are thread safe!
SPDLOG_API void flush_every(std::chrono::seconds interval);

// Set global error handler
SPDLOG_API void set_error_handler(void (*handler)(const std::string &msg));

// Register the given logger with the given name
SPDLOG_API void register_logger(std::shared_ptr<logger> logger);

// Apply a user defined function on all registered loggers
// Example:
// spdlog::apply_all([&](std::shared_ptr<spdlog::logger> l) {l->flush();});
SPDLOG_API void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun);

// Drop the reference to the given logger
SPDLOG_API void drop(const std::string &name);

// Drop all references from the registry
SPDLOG_API void drop_all();

// stop any running threads started by spdlog and clean registry loggers
SPDLOG_API void shutdown();

// Automatic registration of loggers when using spdlog::create() or spdlog::create_async
SPDLOG_API void set_automatic_registration(bool automatic_registration);

// API for using default logger (stdout_color_mt),
// e.g: spdlog::info("Message {}", 1);
//
// The default logger object can be accessed using the spdlog::default_logger():
// For example, to add another sink to it:
// spdlog::default_logger()->sinks().push_back(some_sink);
//
// The default logger can replaced using spdlog::set_default_logger(new_logger).
// For example, to replace it with a file logger.
//
// IMPORTANT:
// The default API is thread safe (for _mt loggers), but:
// set_default_logger() *should not* be used concurrently with the default API.
// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.

SPDLOG_API std::shared_ptr<spdlog::logger> default_logger();

SPDLOG_API spdlog::logger *default_logger_raw();

SPDLOG_API void set_default_logger(std::shared_ptr<spdlog::logger> default_logger);

template<typename... Args>
inline void log(source_loc source, level::level_enum lvl, format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->log(source, lvl, fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void log(level::level_enum lvl, format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void trace(format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->trace(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void debug(format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->debug(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void info(format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->info(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void warn(format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->warn(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void error(format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->error(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void critical(format_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->critical(fmt, std::forward<Args>(args)...);
}

template<typename T>
inline void log(source_loc source, level::level_enum lvl, const T &msg)
{
    default_logger_raw()->log(source, lvl, msg);
}

template<typename T>
inline void log(level::level_enum lvl, const T &msg)
{
    default_logger_raw()->log(lvl, msg);
}

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
template<typename... Args>
inline void log(source_loc source, level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->log(source, lvl, fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void log(level::level_enum lvl, wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->log(source_loc{}, lvl, fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void trace(wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->trace(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void debug(wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->debug(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void info(wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->info(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void warn(wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->warn(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void error(wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->error(fmt, std::forward<Args>(args)...);
}

template<typename... Args>
inline void critical(wformat_string_t<Args...> fmt, Args &&... args)
{
    default_logger_raw()->critical(fmt, std::forward<Args>(args)...);
}
#endif

template<typename T>
inline void trace(const T &msg)
{
    default_logger_raw()->trace(msg);
}

template<typename T>
inline void debug(const T &msg)
{
    default_logger_raw()->debug(msg);
}

template<typename T>
inline void info(const T &msg)
{
    default_logger_raw()->info(msg);
}

template<typename T>
inline void warn(const T &msg)
{
    default_logger_raw()->warn(msg);
}

template<typename T>
inline void error(const T &msg)
{
    default_logger_raw()->error(msg);
}

template<typename T>
inline void critical(const T &msg)
{
    default_logger_raw()->critical(msg);
}

} // namespace spdlog

//
// enable/disable log calls at compile time according to global level.
//
// define SPDLOG_ACTIVE_LEVEL to one of those (before including spdlog.h):
// SPDLOG_LEVEL_TRACE,
// SPDLOG_LEVEL_DEBUG,
// SPDLOG_LEVEL_INFO,
// SPDLOG_LEVEL_WARN,
// SPDLOG_LEVEL_ERROR,
// SPDLOG_LEVEL_CRITICAL,
// SPDLOG_LEVEL_OFF
//

#define SPDLOG_LOGGER_CALL(logger, level, ...) (logger)->log(spdlog::source_loc{__FILE__, __LINE__, SPDLOG_FUNCTION}, level, __VA_ARGS__)

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_TRACE
#    define SPDLOG_LOGGER_TRACE(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::trace, __VA_ARGS__)
#    define SPDLOG_TRACE(...) SPDLOG_LOGGER_TRACE(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#    define SPDLOG_LOGGER_TRACE(logger, ...) (void)0
#    define SPDLOG_TRACE(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_DEBUG
#    define SPDLOG_LOGGER_DEBUG(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::debug, __VA_ARGS__)
#    define SPDLOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#    define SPDLOG_LOGGER_DEBUG(logger, ...) (void)0
#    define SPDLOG_DEBUG(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#    define SPDLOG_LOGGER_INFO(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::info, __VA_ARGS__)
#    define SPDLOG_INFO(...) SPDLOG_LOGGER_INFO(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#    define SPDLOG_LOGGER_INFO(logger, ...) (void)0
#    define SPDLOG_INFO(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_WARN
#    define SPDLOG_LOGGER_WARN(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::warn, __VA_ARGS__)
#    define SPDLOG_WARN(...) SPDLOG_LOGGER_WARN(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#    define SPDLOG_LOGGER_WARN(logger, ...) (void)0
#    define SPDLOG_WARN(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_ERROR
#    define SPDLOG_LOGGER_ERROR(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::err, __VA_ARGS__)
#    define SPDLOG_ERROR(...) SPDLOG_LOGGER_ERROR(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#    define SPDLOG_LOGGER_ERROR(logger, ...) (void)0
#    define SPDLOG_ERROR(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_CRITICAL
#    define SPDLOG_LOGGER_CRITICAL(logger, ...) SPDLOG_LOGGER_CALL(logger, spdlog::level::critical, __VA_ARGS__)
#    define SPDLOG_CRITICAL(...) SPDLOG_LOGGER_CRITICAL(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#    define SPDLOG_LOGGER_CRITICAL(logger, ...) (void)0
#    define SPDLOG_CRITICAL(...) (void)0
#endif

#ifdef SPDLOG_HEADER_ONLY
#    include "spdlog-inl.h"
#endif

#endif // SPDLOG_H

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/stopwatch.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#include <spdlog/fmt/fmt.h>

// Stopwatch support for spdlog  (using std::chrono::steady_clock).
// Displays elapsed seconds since construction as double.
//
// Usage:
//
// spdlog::stopwatch sw;
// ...
// spdlog::debug("Elapsed: {} seconds", sw);    =>  "Elapsed 0.005116733 seconds"
// spdlog::info("Elapsed: {:.6} seconds", sw);  =>  "Elapsed 0.005163 seconds"
//
//
// If other units are needed (e.g. millis instead of double), include "fmt/chrono.h" and use "duration_cast<..>(sw.elapsed())":
//
// #include <spdlog/fmt/chrono.h>
//..
// using std::chrono::duration_cast;
// using std::chrono::milliseconds;
// spdlog::info("Elapsed {}", duration_cast<milliseconds>(sw.elapsed())); => "Elapsed 5ms"

namespace spdlog {
class stopwatch
{
    using clock = std::chrono::steady_clock;
    std::chrono::time_point<clock> start_tp_;

public:
    stopwatch()
        : start_tp_{clock::now()}
    {}

    std::chrono::duration<double> elapsed() const
    {
        return std::chrono::duration<double>(clock::now() - start_tp_);
    }

    void reset()
    {
        start_tp_ = clock::now();
    }
};
} // namespace spdlog

// Support for fmt formatting  (e.g. "{:012.9}" or just "{}")
namespace
#ifdef SPDLOG_USE_STD_FORMAT
    std
#else
    fmt
#endif
{

template<>
struct formatter<spdlog::stopwatch> : formatter<double>
{
    template<typename FormatContext>
    auto format(const spdlog::stopwatch &sw, FormatContext &ctx) -> decltype(ctx.out())
    {
        return formatter<double>::format(sw.elapsed().count(), ctx);
    }
};
} // namespace std

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/tweakme.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// Edit this file to squeeze more performance, and to customize supported
// features
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Under Linux, the much faster CLOCK_REALTIME_COARSE clock can be used.
// This clock is less accurate - can be off by dozens of millis - depending on
// the kernel HZ.
// Uncomment to use it instead of the regular clock.
//
// #define SPDLOG_CLOCK_COARSE
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment if thread id logging is not needed (i.e. no %t in the log pattern).
// This will prevent spdlog from querying the thread id on each log call.
//
// WARNING: If the log pattern contains thread id (i.e, %t) while this flag is
// on, zero will be logged as thread id.
//
// #define SPDLOG_NO_THREAD_ID
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to prevent spdlog from using thread local storage.
//
// WARNING: if your program forks, UNCOMMENT this flag to prevent undefined
// thread ids in the children logs.
//
// #define SPDLOG_NO_TLS
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to avoid spdlog's usage of atomic log levels
// Use only if your code never modifies a logger's log levels concurrently by
// different threads.
//
// #define SPDLOG_NO_ATOMIC_LEVELS
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable usage of wchar_t for file names on Windows.
//
// #define SPDLOG_WCHAR_FILENAMES
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to override default eol ("\n" or "\r\n" under Linux/Windows)
//
// #define SPDLOG_EOL ";-)\n"
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to override default folder separators ("/" or "\\/" under
// Linux/Windows). Each character in the string is treated as a different
// separator.
//
// #define SPDLOG_FOLDER_SEPS "\\"
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to use your own copy of the fmt library instead of spdlog's copy.
// In this case spdlog will try to include <fmt/format.h> so set your -I flag
// accordingly.
//
// #define SPDLOG_FMT_EXTERNAL
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to use C++20 std::format instead of fmt. This removes compile
// time checking of format strings, but doesn't depend on the fmt library.
//
// #define SPDLOG_USE_STD_FORMAT
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable wchar_t support (convert to utf8)
//
// #define SPDLOG_WCHAR_TO_UTF8_SUPPORT
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to prevent child processes from inheriting log file descriptors
//
// #define SPDLOG_PREVENT_CHILD_FD
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to customize level names (e.g. "MY TRACE")
//
// #define SPDLOG_LEVEL_NAMES { "MY TRACE", "MY DEBUG", "MY INFO", "MY WARNING", "MY ERROR", "MY CRITICAL", "OFF" }
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to customize short level names (e.g. "MT")
// These can be longer than one character.
//
// #define SPDLOG_SHORT_LEVEL_NAMES { "T", "D", "I", "W", "E", "C", "O" }
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to disable default logger creation.
// This might save some (very) small initialization time if no default logger is needed.
//
// #define SPDLOG_DISABLE_DEFAULT_LOGGER
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment and set to compile time level with zero cost (default is INFO).
// Macros like SPDLOG_DEBUG(..), SPDLOG_INFO(..)  will expand to empty statements if not enabled
//
// #define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_INFO
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment (and change if desired) macro to use for function names.
// This is compiler dependent.
// __PRETTY_FUNCTION__ might be nicer in clang/gcc, and __FUNCTION__ in msvc.
// Defaults to __FUNCTION__ (should work on all compilers) if not defined.
//
// #ifdef __PRETTY_FUNCTION__
// # define SPDLOG_FUNCTION __PRETTY_FUNCTION__
// #else
// # define SPDLOG_FUNCTION __FUNCTION__
// #endif
///////////////////////////////////////////////////////////////////////////////

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/version.h`:

```h
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#pragma once

#define SPDLOG_VER_MAJOR 1
#define SPDLOG_VER_MINOR 10
#define SPDLOG_VER_PATCH 0

#define SPDLOG_VERSION (SPDLOG_VER_MAJOR * 10000 + SPDLOG_VER_MINOR * 100 + SPDLOG_VER_PATCH)

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/logos/jetbrains-variant-4.svg`:

```svg
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="263" height="147" viewBox="0 0 263 147">
  <defs>
    <linearGradient id="linear-gradient" x1="54.4568" y1="122.5936" x2="251.779" y2="10.2057" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#00adee"/>
      <stop offset="1" stop-color="#9f76a6"/>
    </linearGradient>
    <linearGradient id="linear-gradient-2" x1="80.247" y1="38.7607" x2="241.2622" y2="10.9511" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#ec037c"/>
      <stop offset="1" stop-color="#9f76a6"/>
    </linearGradient>
    <linearGradient id="linear-gradient-3" x1="75.7205" y1="33.5582" x2="127.8253" y2="123.9392" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#ec037c"/>
      <stop offset="1" stop-color="#5c2d90"/>
    </linearGradient>
    <linearGradient id="linear-gradient-4" x1="7.4647" y1="44.578" x2="129.4543" y2="125.0813" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#44c7f4"/>
      <stop offset="1" stop-color="#5c2d90"/>
    </linearGradient>
  </defs>
  <g>
    <path d="M261.1839,10.3622a9.6784,9.6784,0,0,0-14.7448-8.2463l0-.0006L20.6942,136.0746h0a4.6974,4.6974,0,1,0,4.1326,8.4348h0q0.09-.0467.1784-0.097l230.5273-125.25a9.653,9.653,0,0,0,1.1508-.6253l0.0332-.018-0.0014-.0023A9.6682,9.6682,0,0,0,261.1839,10.3622Z" fill="url(#linear-gradient)"/>
    <path d="M261.1839,10.3622A9.6782,9.6782,0,0,0,251.5057.684q-0.2747,0-.5456.0157-0.25.0143-.4975,0.041L76.7981,25.4187A13.7347,13.7347,0,1,0,83.5355,51.983L252.8044,19.9512a9.6363,9.6363,0,0,0,1.0358-.196l0.02-.0039,0-.0008A9.6811,9.6811,0,0,0,261.1839,10.3622Z" fill="url(#linear-gradient-2)"/>
    <path d="M145.2028,123.63a17.2372,17.2372,0,0,0-3.0637-9.4254L91.3045,32.3521A13.7366,13.7366,0,0,0,66.1132,42.9507h0a13.6332,13.6332,0,0,0,1.043,2.4984s45.2334,86.37,45.5824,86.9979q0.3089,0.556.6567,1.0861h0A17.32,17.32,0,0,0,145.2028,123.63Z" fill="url(#linear-gradient-3)"/>
    <path d="M145.2028,123.63a17.2979,17.2979,0,0,0-7.63-13.9419h0a17.3061,17.3061,0,0,0-2.6994-1.4911L9.5484,38.9679a6.064,6.064,0,0,0-6.5074,10.187l114.3963,88.704A17.3191,17.3191,0,0,0,145.2028,123.63Z" fill="url(#linear-gradient-4)"/>
    <g>
      <rect x="69" y="51" width="70" height="70"/>
      <g>
        <rect x="75.038" y="107.8746" width="26.2498" height="4.375" fill="#fff"/>
        <g>
          <path d="M74.7429,69.4315L76.78,67.5082a2.31,2.31,0,0,0,1.7929,1.0594A1.33,1.33,0,0,0,79.8607,66.97V59.75h3.1456v7.2366a4.2386,4.2386,0,0,1-1.1246,3.2108,4.2989,4.2989,0,0,1-3.1293,1.1572A4.6592,4.6592,0,0,1,74.7429,69.4315Z" fill="#fff"/>
          <path d="M83.7394,59.75h9.1761v2.673H86.8688v1.744H92.345v2.4937H86.8688V68.47H92.997v2.6893H83.7394V59.75Z" fill="#fff"/>
          <path d="M97.049,62.5208H93.6426V59.75h9.9911v2.7708h-3.4227v8.6383H97.049V62.5208Z" fill="#fff"/>
          <path d="M75.0363,73.8257h5.8511A4.2728,4.2728,0,0,1,84,74.8363a2.5675,2.5675,0,0,1,.7335,1.858v0.0326a2.6407,2.6407,0,0,1-1.76,2.5425,2.7686,2.7686,0,0,1,2.2655,2.7871v0.0326c0,1.9558-1.5973,3.1456-4.3191,3.1456H75.0363V73.8257Zm6.5846,3.5206c0-.6357-0.5052-0.9779-1.4343-0.9779h-2.07v2.0047h1.9884c0.9616,0,1.5158-.326,1.5158-0.9942V77.3463ZM80.5289,80.59H78.1166v2.1025h2.4448c0.9779,0,1.5158-.3749,1.5158-1.0431V81.6165C82.0773,80.9972,81.5883,80.59,80.5289,80.59Z" fill="#fff"/>
          <path d="M85.7116,73.8257h5.3949a5.0512,5.0512,0,0,1,3.7161,1.2224,3.5623,3.5623,0,0,1,1.01,2.6567v0.0326a3.6146,3.6146,0,0,1-2.3469,3.5205l2.7218,3.9769H92.5733l-2.2981-3.4553H88.8735v3.4553H85.7116V73.8257Zm5.2644,5.4764a1.433,1.433,0,0,0,1.6951-1.3528V77.9167c0-.9128-0.6682-1.3691-1.7114-1.3691H88.8735v2.7545H90.976Z" fill="#fff"/>
          <path d="M99.5324,73.7443H102.58l4.8571,11.4905h-3.39l-0.815-2.0536H98.8153L98,85.2348H94.6917Zm2.7707,6.9758-1.2712-3.2271L99.7443,80.72h2.5589Z" fill="#fff"/>
          <path d="M107.8117,73.8257h3.1619V85.2348h-3.1619V73.8257Z" fill="#fff"/>
          <path d="M111.7558,73.8257h2.95l4.694,6.0306V73.8257h3.1294V85.2348h-2.7545l-4.89-6.2587v6.2587h-3.1293V73.8257Z" fill="#fff"/>
          <path d="M122.7274,83.54l1.76-2.1025a5.9106,5.9106,0,0,0,3.7,1.3691c0.8638,0,1.32-.2934,1.32-0.7824V81.9914c0-.489-0.3749-0.7335-1.9395-1.1084-2.4285-.5541-4.3029-1.2387-4.3029-3.5694V77.2811c0-2.1188,1.6788-3.6509,4.417-3.6509a7.1807,7.1807,0,0,1,4.694,1.5158l-1.5809,2.2329a5.6006,5.6006,0,0,0-3.1946-1.1246c-0.766,0-1.1409.31-1.1409,0.7334V77.02c0,0.5216.3912,0.75,1.9884,1.1083,2.6077,0.57,4.2377,1.418,4.2377,3.5531v0.0326c0,2.3307-1.8418,3.7161-4.6126,3.7161A7.9992,7.9992,0,0,1,122.7274,83.54Z" fill="#fff"/>
        </g>
      </g>
    </g>
  </g>
</svg>

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/scripts/extract_version.py`:

```py
#!/usr/bin/env python3

import os
import re

base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
config_h = os.path.join(base_path, 'include', 'spdlog', 'version.h')
data = {'MAJOR': 0, 'MINOR': 0, 'PATCH': 0}
reg = re.compile(r'^\s*#define\s+SPDLOG_VER_([A-Z]+)\s+([0-9]+).*$')

with open(config_h, 'r') as fp:
    for l in fp:
        m = reg.match(l)
        if m:
            data[m.group(1)] = int(m.group(2))

print(f"{data['MAJOR']}.{data['MINOR']}.{data['PATCH']}")

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/scripts/format.sh`:

```sh
#!/bin/bash

cd "$(dirname "$0")"/..
pwd
echo -n "Running dos2unix     "
find . -name "*\.h" -o -name "*\.cpp"|grep -v bundled|xargs -I {} sh -c "dos2unix '{}' 2>/dev/null; echo -n '.'"
echo
echo -n "Running clang-format "
find . -name "*\.h" -o -name "*\.cpp"|grep -v bundled|xargs -I {} sh -c "clang-format -i {}; echo -n '.'"
echo
echo -n "Running cmake-format "
find . -name "CMakeLists.txt" -o -name "*\.cmake"|grep -v bundled|xargs -I {} sh -c "cmake-format --line-width 120 --tab-size 4 --max-subgroups-hwrap 4 -i {}; echo -n '.'"
echo




```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/async.cpp`:

```cpp
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4251)
#endif

#include <spdlog/async.h>
#include <spdlog/async_logger-inl.h>
#include <spdlog/details/periodic_worker-inl.h>
#include <spdlog/details/thread_pool-inl.h>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/cfg.cpp`:

```cpp
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#include <spdlog/cfg/helpers-inl.h>

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/color_sinks.cpp`:

```cpp
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#include <mutex>

#include <spdlog/details/null_mutex.h>
#include <spdlog/async.h>
//
// color sinks
//
#ifdef _WIN32
#    include <spdlog/sinks/wincolor_sink-inl.h>
template class SPDLOG_API spdlog::sinks::wincolor_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::wincolor_sink<spdlog::details::console_nullmutex>;
template class SPDLOG_API spdlog::sinks::wincolor_stdout_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::wincolor_stdout_sink<spdlog::details::console_nullmutex>;
template class SPDLOG_API spdlog::sinks::wincolor_stderr_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::wincolor_stderr_sink<spdlog::details::console_nullmutex>;
#else
#    include "spdlog/sinks/ansicolor_sink-inl.h"
template class SPDLOG_API spdlog::sinks::ansicolor_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::ansicolor_sink<spdlog::details::console_nullmutex>;
template class SPDLOG_API spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::ansicolor_stdout_sink<spdlog::details::console_nullmutex>;
template class SPDLOG_API spdlog::sinks::ansicolor_stderr_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::ansicolor_stderr_sink<spdlog::details::console_nullmutex>;
#endif

// factory methods for color loggers
#include "spdlog/sinks/stdout_color_sinks-inl.h"
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_color_mt<spdlog::synchronous_factory>(
    const std::string &logger_name, color_mode mode);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_color_st<spdlog::synchronous_factory>(
    const std::string &logger_name, color_mode mode);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_color_mt<spdlog::synchronous_factory>(
    const std::string &logger_name, color_mode mode);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_color_st<spdlog::synchronous_factory>(
    const std::string &logger_name, color_mode mode);

template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_color_mt<spdlog::async_factory>(
    const std::string &logger_name, color_mode mode);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_color_st<spdlog::async_factory>(
    const std::string &logger_name, color_mode mode);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_color_mt<spdlog::async_factory>(
    const std::string &logger_name, color_mode mode);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_color_st<spdlog::async_factory>(
    const std::string &logger_name, color_mode mode);

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/file_sinks.cpp`:

```cpp
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#include <spdlog/details/null_mutex.h>
#include <spdlog/details/file_helper-inl.h>
#include <spdlog/sinks/basic_file_sink-inl.h>
#include <spdlog/sinks/base_sink-inl.h>

#include <mutex>

template class SPDLOG_API spdlog::sinks::basic_file_sink<std::mutex>;
template class SPDLOG_API spdlog::sinks::basic_file_sink<spdlog::details::null_mutex>;

#include <spdlog/sinks/rotating_file_sink-inl.h>
template class SPDLOG_API spdlog::sinks::rotating_file_sink<std::mutex>;
template class SPDLOG_API spdlog::sinks::rotating_file_sink<spdlog::details::null_mutex>;

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/fmt.cpp`:

```cpp
// Slightly modified version of fmt lib's format.cc source file.
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#if !defined(SPDLOG_FMT_EXTERNAL) && !defined(SPDLOG_USE_STD_FORMAT)
#    include <spdlog/fmt/bundled/format-inl.h>

FMT_BEGIN_NAMESPACE
namespace detail {

// DEPRECATED!
template<typename T = void>
struct basic_data
{
    FMT_API static constexpr const char digits[100][2] = {{'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'}, {'0', '5'},
        {'0', '6'}, {'0', '7'}, {'0', '8'}, {'0', '9'}, {'1', '0'}, {'1', '1'}, {'1', '2'}, {'1', '3'}, {'1', '4'}, {'1', '5'}, {'1', '6'},
        {'1', '7'}, {'1', '8'}, {'1', '9'}, {'2', '0'}, {'2', '1'}, {'2', '2'}, {'2', '3'}, {'2', '4'}, {'2', '5'}, {'2', '6'}, {'2', '7'},
        {'2', '8'}, {'2', '9'}, {'3', '0'}, {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'}, {'3', '5'}, {'3', '6'}, {'3', '7'}, {'3', '8'},
        {'3', '9'}, {'4', '0'}, {'4', '1'}, {'4', '2'}, {'4', '3'}, {'4', '4'}, {'4', '5'}, {'4', '6'}, {'4', '7'}, {'4', '8'}, {'4', '9'},
        {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'}, {'5', '4'}, {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'}, {'6', '0'},
        {'6', '1'}, {'6', '2'}, {'6', '3'}, {'6', '4'}, {'6', '5'}, {'6', '6'}, {'6', '7'}, {'6', '8'}, {'6', '9'}, {'7', '0'}, {'7', '1'},
        {'7', '2'}, {'7', '3'}, {'7', '4'}, {'7', '5'}, {'7', '6'}, {'7', '7'}, {'7', '8'}, {'7', '9'}, {'8', '0'}, {'8', '1'}, {'8', '2'},
        {'8', '3'}, {'8', '4'}, {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'}, {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'},
        {'9', '4'}, {'9', '5'}, {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}};
    FMT_API static constexpr const char hex_digits[] = "0123456789abcdef";
    FMT_API static constexpr const char signs[4] = {0, '-', '+', ' '};
    FMT_API static constexpr const char left_padding_shifts[5] = {31, 31, 0, 1, 0};
    FMT_API static constexpr const char right_padding_shifts[5] = {0, 31, 0, 1, 0};
    FMT_API static constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+', 0x1000000u | ' '};
};

#    ifdef FMT_SHARED
// Required for -flto, -fivisibility=hidden and -shared to work
extern template struct basic_data<void>;
#    endif

#    if __cplusplus < 201703L
// DEPRECATED! These are here only for ABI compatiblity.
template<typename T>
constexpr const char basic_data<T>::digits[][2];
template<typename T>
constexpr const char basic_data<T>::hex_digits[];
template<typename T>
constexpr const char basic_data<T>::signs[];
template<typename T>
constexpr const char basic_data<T>::left_padding_shifts[];
template<typename T>
constexpr const char basic_data<T>::right_padding_shifts[];
template<typename T>
constexpr const unsigned basic_data<T>::prefixes[];
#    endif

template<typename T>
int format_float(char *buf, std::size_t size, const char *format, int precision, T value)
{
#    ifdef FMT_FUZZ
    if (precision > 100000)
        throw std::runtime_error("fuzz mode - avoid large allocation inside snprintf");
#    endif
    // Suppress the warning about nonliteral format string.
    int (*snprintf_ptr)(char *, size_t, const char *, ...) = FMT_SNPRINTF;
    return precision < 0 ? snprintf_ptr(buf, size, format, value) : snprintf_ptr(buf, size, format, precision, value);
}

template FMT_API dragonbox::decimal_fp<float> dragonbox::to_decimal(float x) FMT_NOEXCEPT;
template FMT_API dragonbox::decimal_fp<double> dragonbox::to_decimal(double x) FMT_NOEXCEPT;
} // namespace detail

// Workaround a bug in MSVC2013 that prevents instantiation of format_float.
int (*instantiate_format_float)(double, int, detail::float_specs, detail::buffer<char> &) = detail::format_float;

#    ifndef FMT_STATIC_THOUSANDS_SEPARATOR
template FMT_API detail::locale_ref::locale_ref(const std::locale &loc);
template FMT_API std::locale detail::locale_ref::get<std::locale>() const;
#    endif

// Explicit instantiations for char.

template FMT_API auto detail::thousands_sep_impl(locale_ref) -> thousands_sep_result<char>;
template FMT_API char detail::decimal_point_impl(locale_ref);

template FMT_API void detail::buffer<char>::append(const char *, const char *);

// DEPRECATED!
// There is no correspondent extern template in format.h because of
// incompatibility between clang and gcc (#2377).
template FMT_API void detail::vformat_to(
    detail::buffer<char> &, string_view, basic_format_args<FMT_BUFFER_CONTEXT(char)>, detail::locale_ref);

template FMT_API int detail::snprintf_float(double, int, detail::float_specs, detail::buffer<char> &);
template FMT_API int detail::snprintf_float(long double, int, detail::float_specs, detail::buffer<char> &);
template FMT_API int detail::format_float(double, int, detail::float_specs, detail::buffer<char> &);
template FMT_API int detail::format_float(long double, int, detail::float_specs, detail::buffer<char> &);

// Explicit instantiations for wchar_t.

template FMT_API auto detail::thousands_sep_impl(locale_ref) -> thousands_sep_result<wchar_t>;
template FMT_API wchar_t detail::decimal_point_impl(locale_ref);

template FMT_API void detail::buffer<wchar_t>::append(const wchar_t *, const wchar_t *);

template struct detail::basic_data<void>;

FMT_END_NAMESPACE

#endif // !SPDLOG_FMT_EXTERNAL

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/spdlog.cpp`:

```cpp
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#include <spdlog/spdlog-inl.h>
#include <spdlog/common-inl.h>
#include <spdlog/details/backtracer-inl.h>
#include <spdlog/details/registry-inl.h>
#include <spdlog/details/os-inl.h>
#include <spdlog/pattern_formatter-inl.h>
#include <spdlog/details/log_msg-inl.h>
#include <spdlog/details/log_msg_buffer-inl.h>
#include <spdlog/logger-inl.h>
#include <spdlog/sinks/sink-inl.h>
#include <spdlog/sinks/base_sink-inl.h>
#include <spdlog/details/null_mutex.h>

#include <mutex>

// template instantiate logger constructor with sinks init list
template SPDLOG_API spdlog::logger::logger(std::string name, sinks_init_list::iterator begin, sinks_init_list::iterator end);
template class SPDLOG_API spdlog::sinks::base_sink<std::mutex>;
template class SPDLOG_API spdlog::sinks::base_sink<spdlog::details::null_mutex>;

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/src/stdout_sinks.cpp`:

```cpp
// Copyright(c) 2015-present, Gabi Melman & spdlog contributors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)

#ifndef SPDLOG_COMPILED_LIB
#    error Please define SPDLOG_COMPILED_LIB to compile this file.
#endif

#include <mutex>

#include <spdlog/details/null_mutex.h>
#include <spdlog/async.h>
#include <spdlog/sinks/stdout_sinks-inl.h>

template class SPDLOG_API spdlog::sinks::stdout_sink_base<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::stdout_sink_base<spdlog::details::console_nullmutex>;
template class SPDLOG_API spdlog::sinks::stdout_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::stdout_sink<spdlog::details::console_nullmutex>;
template class SPDLOG_API spdlog::sinks::stderr_sink<spdlog::details::console_mutex>;
template class SPDLOG_API spdlog::sinks::stderr_sink<spdlog::details::console_nullmutex>;

template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_logger_mt<spdlog::synchronous_factory>(const std::string &logger_name);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_logger_st<spdlog::synchronous_factory>(const std::string &logger_name);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_logger_mt<spdlog::synchronous_factory>(const std::string &logger_name);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_logger_st<spdlog::synchronous_factory>(const std::string &logger_name);

template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_logger_mt<spdlog::async_factory>(const std::string &logger_name);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stdout_logger_st<spdlog::async_factory>(const std::string &logger_name);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_logger_mt<spdlog::async_factory>(const std::string &logger_name);
template SPDLOG_API std::shared_ptr<spdlog::logger> spdlog::stderr_logger_st<spdlog::async_factory>(const std::string &logger_name);

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/LICENSE.txt`:

```txt
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md`:

```md
# string_view lite: A single-file header-only version of a C++17-like string_view for C++98, C++11 and later

[![Language](https://img.shields.io/badge/C%2B%2B-98/11/14/17-blue.svg)](https://en.wikipedia.org/wiki/C%2B%2B#Standardization) [![License](https://img.shields.io/badge/license-BSL-blue.svg)](https://opensource.org/licenses/BSL-1.0) [![Build Status](https://travis-ci.org/martinmoene/string-view-lite.svg?branch=master)](https://travis-ci.org/martinmoene/string-view-lite) [![Build status](https://ci.appveyor.com/api/projects/status/1ha3wnxtam547m8p?svg=true)](https://ci.appveyor.com/project/martinmoene/string-view-lite) [![Version](https://badge.fury.io/gh/martinmoene%2Fstring-view-lite.svg)](https://github.com/martinmoene/string-view-lite/releases) [![download](https://img.shields.io/badge/latest-download-blue.svg)](https://github.com/martinmoene/string-view-lite/blob/master/include/nonstd/string_view.hpp) [![Conan](https://img.shields.io/badge/on-conan-blue.svg)](https://bintray.com/agauniyal/nonstd-lite/) [![Try it on wandbox](https://img.shields.io/badge/on-wandbox-blue.svg)](https://wandbox.org/permlink/w2vUu56NVdVNyOiv) [![Try it on godbolt online](https://img.shields.io/badge/on-godbolt-blue.svg)](http://bit.ly/mm-string-view-lite-godbolt)

**Contents**  
- [Example usage](#example-usage)
- [In a nutshell](#in-a-nutshell)
- [License](#license)
- [Dependencies](#dependencies)
- [Installation](#installation)
- [Synopsis](#synopsis)
- [Reported to work with](#reported-to-work-with)
- [Building the tests](#building-the-tests)
- [Other implementations of string_view](#other-implementations-of-string_view)
- [Notes and references](#notes-and-references)
- [Appendix](#appendix)


Example usage
-------------

```C++
#include "nonstd/string_view.hpp"
#include <iostream>

using namespace std::literals;
using namespace nonstd::literals;
using namespace nonstd;
    
void write( string_view sv )
{
    std::cout << sv;
}

int main()
{
    write( "hello"     );   // C-string
    write( ", "s       );   // std::string
    write( "world!"_sv );   // nonstd::string_view
}
```

### Compile and run
```
prompt> g++ -Wall -std=c++14 -I../include/ -o 01-basic.exe 01-basic.cpp && 01-basic.exe
hello, world!
```

In a nutshell
---------------
**string-view lite** is a single-file header-only library to provide a non-owning reference to a string. The library provides a [C++17-like string_view](http://en.cppreference.com/w/cpp/string/basic_string_view) for use with C++98 and later. If available, `std::string_view` is used, unless [configured otherwise](#configuration).

**Features and properties of string-view lite** are ease of installation (single header), freedom of dependencies other than the standard library. To mimic C++17-like cooperation with `std::string`, `nonstd::string_view` provides several non-standard conversion functions. These functions may be [omitted via configuration](#configuration).


License
-------
*string-view lite* is distributed under the [Boost Software License](LICENSE.txt).
 

Dependencies
------------
*string-view lite* has no other dependencies than the [C++ standard library](http://en.cppreference.com/w/cpp/header).


Installation
------------

*string-view lite* is a single-file header-only library. Put `string_view.hpp` in the [include](include) folder directly into the project source tree or somewhere reachable from your project.

Or, if you use the [conan package manager](https://www.conan.io/), follow these steps:

1. Add *nonstd-lite* to the conan remotes:

        conan remote add nonstd-lite https://api.bintray.com/conan/martinmoene/nonstd-lite

2. Add a reference to *string-view-lite* to the *requires* section of your project's `conanfile.txt` file:

        [requires]
        string-view-lite/[~=1]@nonstd-lite/testing

3. Run conan's install command:

        conan install


Synopsis
--------

**Contents**  
[Documentation of `std::string_view`](#stdstring_view)  
[C++20 extensions](#c20-extensions)  
[Non-standard extensions](#non-standard-extensions)  
[Configuration](#configuration)    

Documentation of `std::string_view`
-----------------------------------
Depending on the compiler and C++-standard used, `nonstd::string_view` behaves less or more like `std::string_view`. To get an idea of the capabilities of `nonstd::string_view` with your configuration, look at the output of the [tests](test/string_view.t.cpp), issuing `string-view-lite.t --pass @`. For `std::string_view`, see its [documentation at cppreference](http://en.cppreference.com/w/cpp/string/basic_string_view).  

C++20 extensions
----------------
*string_view-lite* provides the following C++20 *extensions*.

- *[[nodiscard]]* constexpr bool **empty**() const noexcept;
- constexpr bool ***starts_with***( basic_string_view v ) const noexcept;  // (1)
- constexpr bool ***starts_with***( CharT c ) const noexcept;  // (2)
- constexpr bool ***starts_with***( CharT const * s ) const;  // (3)
- constexpr bool ***ends_with***( basic_string_view v ) const noexcept;  // (1)
- constexpr bool ***ends_with***( CharT c ) const noexcept;  // (2)
- constexpr bool ***ends_with***( CharT const * s ) const;  // (3)

Note: [[nodiscard]], constexpr and noexcept if available.
     
Non-standard extensions
-----------------------
### `string_view` literals `sv` and `_sv`
clang compilers do not allow to write `auto sv = "..."sv` with *string-view lite* under C++11. To still provide a literal operator that can be used in that case, *string-view lite* also provides `_sv`. See section [Configuration](#configuration) for how to control the presence of these operators.

The literal operators are declared in the namespace `nonstd::literals::string_view_literals`, where both `literals` and `string_view_literals` are inline namespaces, if supported. Access to these operators can be gained with using namespace `nonstd::literals`, using namespace `nonstd::string_view_literals`, and using namespace `nonstd::literals::string_view_literals`. If inline namespaces are not supported by the compiler, only the latter form is available.

### Cooperation between `std::string` and `nonstd::string_view`
*string-view lite* can provide several methods and free functions to mimic the cooperation between `std::string` and  `nonstd::string_view` that exists in C++17. See the table below. Several macros allow you to control the presence of these functions, see section [Configuration](#configuration).

| Kind                  | Std   | Function or method |                                       
|-----------------------|-------|--------------------|
| **Free functions**    |&nbsp; | macro `nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS`|
| **`std::string_view`**|&nbsp; | &nbsp; |
| to_string()           |>=C++17| template&lt; class CharT, class Traits, class Allocator=std::allocator&lt;CharT> ><br>std::basic_string&lt;CharT, Traits, Allocator&gt;<br>**to_string**( std::basic_string_view&lt;CharT, Traits> v, Allocator const & a=Allocator() );|
| to_string_view()      |>=C++17| template&lt; class CharT, class Traits, class Allocator ><br>std::basic_string_view&lt;CharT, Traits><br>**to_string_view**( std::basic_string&lt;CharT, Traits, Allocator> const & s );|
| **`nonstd::string_view`**|&nbsp; | &nbsp;  |
| to_string()<br>&nbsp;<br>*non-msvc14 (vs2015)* |>=C++11| template&lt; class CharT, class Traits, class Allocator = std::allocator&lt;CharT> ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( basic_string_view&lt;CharT, Traits> v, Allocator const & a = Allocator() );|
| to_string()<br>&nbsp;<br>*msvc14 (vs2015)* |<C++11|template&lt; class CharT, class Traits ><br>std::basic_string&lt;CharT, Traits><br>**to_string**( basic_string_view&lt;CharT, Traits> v );|
| to_string()<br>&nbsp;<br>*msvc14 (vs2015)* |<C++11|template&lt; class CharT, class Traits, class Allocator ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( basic_string_view&lt;CharT, Traits> v, Allocator const & a );|
| to_string_view()      |>=C++98| template&lt; class CharT, class Traits, class Allocator ><br>basic_string_view&lt;CharT, Traits><br>**to_string_view**( std::basic_string&lt;CharT, Traits, Allocator> const & s );|
| &nbsp;                |&nbsp; | &nbsp; |
| **Class methods**     |&nbsp; | macro `nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS` |
| **`nonstd::basic_string_view`**|&nbsp; |&nbsp; |
| Constructor           |>=C++98| template&lt; class Allocator ><br>**basic_string_view**( std::basic_string&lt;CharT, Traits, Allocator> const & s ) nssv_noexcept;|
| Converting operator   |>=C++11| template&lt; class Allocator ><br>explicit **operator std::basic_string**&lt;CharT, Traits, Allocator>() const;|
| to_string()           |>=C++11| template&lt; class Allocator = std::allocator&lt;CharT> ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( Allocator const & a = Allocator() ) const;|
| to_string()           |<C++11 | std::basic_string&lt;CharT, Traits><br>**to_string**() const;|
| to_string()           |<C++11 | template&lt; class Allocator ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( Allocator const & a ) const;|
| &nbsp;                |&nbsp; | &nbsp; |
| **Literal operator `sv`**|>=C++11| macro `nssv_CONFIG_STD_SV_OPERATOR` |
| &nbsp;                |&nbsp; | constexpr string_view operator "" **sv**( const char* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | constexpr u16string_view operator "" **sv**( const char16_t* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | constexpr u32string_view operator "" **sv**( const char32_t* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | constexpr wstring_view operator "" **sv**( const wchar_t* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | &nbsp; |
| **Literal operator `_sv`**|>=C++11| macro `nssv_CONFIG_USR_SV_OPERATOR` |
| &nbsp;                |&nbsp; | constexpr string_view operator "" **_sv**( const char* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | constexpr u16string_view operator "" **_sv**( const char16_t* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | constexpr u32string_view operator "" **_sv**( const char32_t* str, size_t len ) noexcept; |
| &nbsp;                |&nbsp; | constexpr wstring_view operator "" **_sv**( const wchar_t* str, size_t len ) noexcept; |


Configuration
-------------

### Standard selection macro

\-D<b>nssv\_CPLUSPLUS</b>=199711L  
Define this macro to override the auto-detection of the supported C++ standard, if your compiler does not set the `__cpluplus` macro correctly.

### Select `std::string_view` or `nonstd::string_view`
At default, *string-view lite* uses `std::string_view` if it is available and lets you use it via namespace `nonstd`. You can however override this default and explicitly request to use `std::string_view` as `nonstd::string_view` or use string-view lite's `nonstd::string_view` via the following macros.

-D<b>nssv\_CONFIG\_SELECT\_STRING_VIEW</b>=nssv_STRING_VIEW_DEFAULT  
Define this to `nssv_STRING_VIEW_STD` to select `std::string_view` as `nonstd::string_view`. Define this to `nssv_STRING_VIEW_NONSTD` to select `nonstd::string_view` as `nonstd::string_view`. Default is undefined, which has the same effect as defining to `nssv_STRING_VIEW_DEFAULT`.

Note: <b>nssv_CONFIG_SELECT_STD_STRING_VIEW</b> and <b>nssv_CONFIG_SELECT_NONSTD_STRING_VIEW</b> are deprecated and have been removed.

### Disable exceptions
-D<b>nssv\_CONFIG\_NO\_EXCEPTIONS</b>=0
Define this to 1 if you want to compile without exceptions. If not defined, the header tries and detect if exceptions have been disabled (e.g. via `-fno-exceptions`). Default is undefined.

### Add or omit literal operators `sv` and `_sv`

-D<b>nssv_CONFIG_STD_SV_OPERATOR</b>=1  
Define this to 1 to provide literal operator `sv` to create a `string_view` from a literal string. Default is 0. Note that literal operators without leading underscore are reserved for the C++ standard.

-D<b>nssv_CONFIG_USR_SV_OPERATOR</b>=0  
Define this to 0 to omit literal operator `_sv` to create a `string_view` from a literal string. Default is 1.

### Omit cooperation between `std::string`&ndash;`nonstd::string_view`
At default, *string-view lite* provides several methods and free functions to mimic the cooperation between `std::string` and  `nonstd::string_view` (or `std::string_view`) that exists in C++17. See section [Non-standard extensions](#non-standard-extensions). The following macros allow you to control the presence of these functions.
 
-D<b>nssv_CONFIG_CONVERSION_STD_STRING</b>=1  
Define this to 1 to provide `std::string`&ndash; `nonstd::string_view` interoperability via methods of `nonstd::basic_string_view` and free functions, define it to 0 to omit all said methods and functions. Default is undefined.

-D<b>nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS</b>=1  
Define this to 1 to provide `std::string`&ndash; `nonstd::string_view` interoperability via methods of `nonstd::basic_string_view`, define it to 0 to omit all said methods. Default is undefined.

-D<b>nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS</b>=1  
Define this to 1 to provide `std::string`&ndash; `nonstd::string_view` interoperability via free functions, define it to 0 to omit all said functions. This also controls the presence of these function if `std::string_view` is used. Default is undefined.


Reported to work with
---------------------
The table below mentions the compiler versions *string-view lite* is reported to work with.

OS        | Compiler   | Versions |
---------:|:-----------|:---------|
Windows   | Clang/LLVM | ?        |
&nbsp;    | GCC        | 7.2.0    |
&nbsp;    | Visual C++<br>(Visual Studio)| 8 (2005), 9 (2008), 10 (2010), 11 (2012),<br>12 (2013), 14 (2015), 15 (2017) |
GNU/Linux | Clang/LLVM | 3.5 - 6.0  |
&nbsp;    | GCC        | 4.8 - 8 |
OS X      | Clang/LLVM | Xcode 6, Xcode 7, Xcode 8, Xcode 9 |


Building the tests
------------------
To build the tests you need:

- [CMake](http://cmake.org), version 3.0 or later to be installed and in your PATH.
- A [suitable compiler](#reported-to-work-with).

The [*lest* test framework](https://github.com/martinmoene/lest) is included in the [test folder](test).

The following steps assume that the [*string-view lite* source code](https://github.com/martinmoene/string-view-lite) has been cloned into a directory named `c:\string-view-lite`.

1. Create a directory for the build outputs for a particular architecture.
Here we use c:\string-view-lite\build-win-x86-vc10.

        cd c:\string-view-lite
        md build-win-x86-vc10
        cd build-win-x86-vc10

2. Configure CMake to use the compiler of your choice (run `cmake --help` for a list).

        cmake -G "Visual Studio 10 2010" -DSTRINGVIEW_LITE_OPT_BUILD_TESTS=ON ..

3. Build the test suite in the Debug configuration (alternatively use Release).    

        cmake --build . --config Debug

4. Run the test suite.    

        ctest -V -C Debug

All tests should pass, indicating your platform is supported and you are ready to use *string-view lite*.


Other implementations of string_view
------------------------------------
- Marshall Clow. [string_view implementation for libc++](https://github.com/mclow/string_view). GitHub.
- LLVM libc++. [string_view](https://llvm.org/svn/llvm-project/libcxx/trunk/include/string_view). GitHub.
- Matthew Rodusek's, @bitwizeshift. [string_view Standalone](https://github.com/bitwizeshift/string_view-standalone). GitHub.
- @satoren. [string_view for C++03 C++11 C++14](https://github.com/satoren/string_view). GitHub.
- Google Abseil [string_view](https://github.com/abseil/abseil-cpp/tree/master/absl/strings) (non-templated).
- [Search _string view c++_ on GitHub](https://github.com/search?l=C%2B%2B&q=string+view+c%2B%2B&type=Repositories&utf8=%E2%9C%93).


Notes and references
--------------------
*Interface and specification*
- [string_view on cppreference](http://en.cppreference.com/w/cpp/string/basic_string_view).
- [n4659 - C++17 Working Draft: string_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf#page=780).

*Presentations*
- Marshall Clow. [string_view - when to use it, and when not](https://cppcon2015.sched.com/event/3vch/stringview-when-to-use-it-and-when-not?iframe=yes&w=700&sidebar=yes&bg=no#). CppCon 2015. [video](https://youtu.be/H9gAaNRoon4), [slides](https://github.com/CppCon/CppCon2015/blob/master/Presentations/string_view/string_view%20-%20Marshall%20Clow%20-%20CppCon%202015.pdf).
- Neil MacIntosh. [A few good types: Evolving array_view and string_view for safe C++ code](https://cppcon2015.sched.com/event/3vbQ/a-few-good-types-evolving-arrayview-and-stringview-for-safe-c-code). CppCon 2015. [video](https://youtu.be/C4Z3c4Sv52U), [slides](https://github.com/CppCon/CppCon2015/blob/master/Presentations/A%20Few%20Good%20Types/A%20Few%20Good%20Types%20-%20Neil%20MacIntosh%20-%20CppCon%202015.pdf).

*Proposals*
- Jeffrey Yasskin. [n3334 - Proposing array_ref<T> and string_ref](https://wg21.link/n3334). 2012.
- Jeffrey Yasskin. [n3921 - string_view: a non-owning reference to a string, revision 7](http://wg21.link/n3921). **Adopted 2014-02**.
- Alisdair Meredith. [n4288 - Strike string_view::clear from Library Fundamentals](http://wg21.link/n4288). **Adopted 2014-11**.
- Neil MacIntosh. [p0123 - Unifying the interfaces of string_view and array_view](http://wg21.link/p0123). 2015.
- Beman Dawes, Alisdair Meredith. [p0220 - Adopt Library Fundamentals V1 TS Components for C++17 (R1)](https://wg21.link/p0220r1). 2016.
- Marshall Clow. [p0254 - Integrating std::string_view and std::string](http://wg21.link/p0254). **Adopted 2016-06**.
- Nicolai Josuttis. [p0392 - Adapting string_view by filesystem paths](https://wg21.link/p0392r0). 2016.
- Marshall Clow. [p0403 - Literal suffixes for basic_string_view](http://wg21.link/p0403). 2016.
- Peter Sommerlad. [p0506 - use string_view for library function parameters instead of const string &/const char *](http://wg21.link/p0506). 2017.
- Daniel Krugler. [wg2946 - LWG 2758's resolution missed further corrections](https://wg21.link/lwg2946). 2017.


Appendix
--------

### A.1 Compile-time information

The version of *string-view lite* is available via tag `[.version]`. The following tags are available for information on the compiler and on the C++ standard library used: `[.compiler]`, `[.stdc++]`, `[.stdlanguage]` and `[.stdlibrary]`.

### A.2 string-view lite test specification

```
string_view: Allows to default construct an empty string_view
string_view: Allows to construct from pointer and size
string_view: Allows to construct from C-string
string_view: Allows to copy-construct from empty string_view
string_view: Allows to copy-construct from non-empty string_view
string_view: Allows to copy-assign from empty string_view
string_view: Allows to copy-assign from non-empty string_view
string_view: Allows forward iteration
string_view: Allows const forward iteration
string_view: Allows reverse iteration
string_view: Allows const reverse iteration
string_view: Allows to obtain the size of the view via size()
string_view: Allows to obtain the size of the view via length()
string_view: Allows to obtain the maximum size a view can be via max_size()
string_view: Allows to check for an empty string_view via empty()
string_view: Allows to observe an element via array indexing
string_view: Allows to observe an element via at()
string_view: Throws at observing an element via at() with an index of size() or larger
string_view: Allows to observe elements via data()
string_view: Yields nullptr (or NULL) with data() for an empty string_view
string_view: Allows to remove a prefix of n elements
string_view: Allows to remove a suffix of n elements
string_view: Allows to swap with other string_view
string_view: Allows to copy a substring of length n, starting at position pos (default: 0) via copy()
string_view: Throws if requested position of copy() exceeds string_view's size()
string_view: Allow to obtain a sub string, starting at position pos (default: 0) and of length n (default full), via substr()
string_view: Throws if requested position of substr() exceeds string_view's size()
string_view: Allows to lexically compare to another string_view via compare(), (1)
string_view: Allows to compare empty string_views as equal via compare(), (1)
string_view: Allows to compare a sub string to another string_view via compare(), (2)
string_view: Allows to compare a sub string to another string_view sub string via compare(), (3)
string_view: Allows to compare to a C-string via compare(), (4)
string_view: Allows to compare a sub string to a C-string via compare(), (5)
string_view: Allows to compare a sub string to a C-string prefix via compare(), (6)
string_view: Allows to check for a prefix string_view via starts_with(), (1)
string_view: Allows to check for a prefix character via starts_with(), (2)
string_view: Allows to check for a prefix C-string via starts_with(), (3)
string_view: Allows to check for a suffix string_view via ends_with(), (1)
string_view: Allows to check for a suffix character via ends_with(), (2)
string_view: Allows to check for a suffix C-string via ends_with(), (3)
string_view: Allows to search for a string_view substring, starting at position pos (default: 0) via find(), (1)
string_view: Allows to search for a character, starting at position pos (default: 0) via find(), (2)
string_view: Allows to search for a C-string substring, starting at position pos and of length n via find(), (3)
string_view: Allows to search for a C-string substring, starting at position pos (default: 0) via find(), (4)
string_view: Allows to search backwards for a string_view substring, starting at position pos (default: npos) via rfind(), (1)
string_view: Allows to search backwards for a character, starting at position pos (default: npos) via rfind(), (2)
string_view: Allows to search backwards for a C-string substring, starting at position pos and of length n via rfind(), (3)
string_view: Allows to search backwards for a C-string substring, starting at position pos (default: 0) via rfind(), (4)
string_view: Allows to search for the first occurrence of any of the characters specified in a string view, starting at position pos (default: 0) via find_first_of(), (1)
string_view: Allows to search for a character, starting at position pos (default: 0) via find_first_of(), (2)
string_view: Allows to search for the first occurrence of any of the characters specified in a C-string, starting at position pos and of length n via find_first_of(), (3)
string_view: Allows to search for the first occurrence of any of the characters specified in a C-string, starting at position pos via find_first_of(), (4)
string_view: Allows to search backwards for the last occurrence of any of the characters specified in a string view, starting at position pos (default: npos) via find_last_of(), (1)
string_view: Allows to search backwards for a character, starting at position pos (default: 0) via find_last_of(), (2)
string_view: Allows to search backwards for the first occurrence of any of the characters specified in a C-string, starting at position pos and of length n via find_last_of(), (3)
string_view: Allows to search backwards for the first occurrence of any of the characters specified in a C-string, starting at position pos via find_last_of(), (4)
string_view: Allows to search for the first character not specified in a string view, starting at position pos (default: 0) via find_first_not_of(), (1)
string_view: Allows to search for the first character not equal to the specified character, starting at position pos (default: 0) via find_first_not_of(), (2)
string_view: Allows to search for  the first character not equal to any of the characters specified in a C-string, starting at position pos and of length n via find_first_not_of(), (3)
string_view: Allows to search for  the first character not equal to any of the characters specified in a C-string, starting at position pos via find_first_not_of(), (4)
string_view: Allows to search backwards for the first character not specified in a string view, starting at position pos (default: npos) via find_last_not_of(), (1)
string_view: Allows to search backwards for the first character not equal to the specified character, starting at position pos (default: npos) via find_last_not_of(), (2)
string_view: Allows to search backwards for  the first character not equal to any of the characters specified in a C-string, starting at position pos and of length n via find_last_not_of(), (3)
string_view: Allows to search backwards for  the first character not equal to any of the characters specified in a C-string, starting at position pos via find_last_not_of(), (4)
string_view: Allows to create a string_view, wstring_view, u16string_view, u32string_view via literal "sv"
string_view: Allows to create a string_view via literal "sv", using namespace nonstd::literals::string_view_literals
string_view: Allows to create a string_view via literal "sv", using namespace nonstd::string_view_literals
string_view: Allows to create a string_view via literal "sv", using namespace nonstd::literals
string_view: Allows to create a string_view, wstring_view, u16string_view, u32string_view via literal "_sv"
string_view: Allows to create a string_view via literal "_sv", using namespace nonstd::literals::string_view_literals
string_view: Allows to create a string_view via literal "_sv", using namespace nonstd::string_view_literals
string_view: Allows to create a string_view via literal "_sv", using namespace nonstd::literals
string_view: Allows to compare a string_view with another string_view
string_view: Allows to compare empty string_view-s as equal
operator<<: Allows printing a string_view to an output stream
std::hash<>: Hash value of string_view equals hash value of corresponding string object
std::hash<>: Hash value of wstring_view equals hash value of corresponding string object
std::hash<>: Hash value of u16string_view equals hash value of corresponding string object
std::hash<>: Hash value of u32string_view equals hash value of corresponding string object
string_view: construct from std::string [extension]
string_view: convert to std::string via explicit operator [extension]
string_view: convert to std::string via to_string() [extension]
to_string(): convert to std::string via to_string() [extension]
to_string_view(): convert from std::string via to_string_view() [extension]
```

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/cmake/string_view-lite-config.cmake.in`:

```in
@PACKAGE_INIT@

# Only include targets once:

if( NOT TARGET @package_name@::@package_name@ )
    include( "${CMAKE_CURRENT_LIST_DIR}/@package_target@.cmake" )
endif()

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/include/nonstd/string_view.hpp`:

```hpp
// Copyright 2017-2019 by Martin Moene
//
// string-view lite, a C++17-like string_view for C++98 and later.
// For more information see https://github.com/martinmoene/string-view-lite
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#pragma once

#ifndef NONSTD_SV_LITE_H_INCLUDED
#define NONSTD_SV_LITE_H_INCLUDED

#define string_view_lite_MAJOR  1
#define string_view_lite_MINOR  1
#define string_view_lite_PATCH  0

#define string_view_lite_VERSION  nssv_STRINGIFY(string_view_lite_MAJOR) "." nssv_STRINGIFY(string_view_lite_MINOR) "." nssv_STRINGIFY(string_view_lite_PATCH)

#define nssv_STRINGIFY(  x )  nssv_STRINGIFY_( x )
#define nssv_STRINGIFY_( x )  #x

// string-view lite configuration:

#define nssv_STRING_VIEW_DEFAULT  0
#define nssv_STRING_VIEW_NONSTD   1
#define nssv_STRING_VIEW_STD      2

#if !defined( nssv_CONFIG_SELECT_STRING_VIEW )
# define nssv_CONFIG_SELECT_STRING_VIEW  ( nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD )
#endif

#if defined( nssv_CONFIG_SELECT_STD_STRING_VIEW ) || defined( nssv_CONFIG_SELECT_NONSTD_STRING_VIEW )
# error nssv_CONFIG_SELECT_STD_STRING_VIEW and nssv_CONFIG_SELECT_NONSTD_STRING_VIEW are deprecated and removed, please use nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_...
#endif

#ifndef  nssv_CONFIG_STD_SV_OPERATOR
# define nssv_CONFIG_STD_SV_OPERATOR  0
#endif

#ifndef  nssv_CONFIG_USR_SV_OPERATOR
# define nssv_CONFIG_USR_SV_OPERATOR  1
#endif

#ifdef   nssv_CONFIG_CONVERSION_STD_STRING
# define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS   nssv_CONFIG_CONVERSION_STD_STRING
# define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS  nssv_CONFIG_CONVERSION_STD_STRING
#endif

#ifndef  nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
# define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS  1
#endif

#ifndef  nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
# define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS  1
#endif

// Control presence of exception handling (try and auto discover):

#ifndef nssv_CONFIG_NO_EXCEPTIONS
# if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)
#  define nssv_CONFIG_NO_EXCEPTIONS  0
# else
#  define nssv_CONFIG_NO_EXCEPTIONS  1
# endif
#endif

// C++ language version detection (C++20 is speculative):
// Note: VC14.0/1900 (VS2015) lacks too much from C++14.

#ifndef   nssv_CPLUSPLUS
# if defined(_MSVC_LANG ) && !defined(__clang__)
#  define nssv_CPLUSPLUS  (_MSC_VER == 1900 ? 201103L : _MSVC_LANG )
# else
#  define nssv_CPLUSPLUS  __cplusplus
# endif
#endif

#define nssv_CPP98_OR_GREATER  ( nssv_CPLUSPLUS >= 199711L )
#define nssv_CPP11_OR_GREATER  ( nssv_CPLUSPLUS >= 201103L )
#define nssv_CPP11_OR_GREATER_ ( nssv_CPLUSPLUS >= 201103L )
#define nssv_CPP14_OR_GREATER  ( nssv_CPLUSPLUS >= 201402L )
#define nssv_CPP17_OR_GREATER  ( nssv_CPLUSPLUS >= 201703L )
#define nssv_CPP20_OR_GREATER  ( nssv_CPLUSPLUS >= 202000L )

// use C++17 std::string_view if available and requested:

#if nssv_CPP17_OR_GREATER && defined(__has_include )
# if __has_include( <string_view> )
#  define nssv_HAVE_STD_STRING_VIEW  1
# else
#  define nssv_HAVE_STD_STRING_VIEW  0
# endif
#else
# define  nssv_HAVE_STD_STRING_VIEW  0
#endif

#define  nssv_USES_STD_STRING_VIEW  ( (nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_STD) || ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_DEFAULT) && nssv_HAVE_STD_STRING_VIEW) )

#define nssv_HAVE_STARTS_WITH ( nssv_CPP20_OR_GREATER || !nssv_USES_STD_STRING_VIEW )
#define nssv_HAVE_ENDS_WITH     nssv_HAVE_STARTS_WITH

//
// Use C++17 std::string_view:
//

#if nssv_USES_STD_STRING_VIEW

#include <string_view>

// Extensions for std::string:

#if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS

namespace nonstd {

template< class CharT, class Traits, class Allocator = std::allocator<CharT> >
std::basic_string<CharT, Traits, Allocator>
to_string( std::basic_string_view<CharT, Traits> v, Allocator const & a = Allocator() )
{
    return std::basic_string<CharT,Traits, Allocator>( v.begin(), v.end(), a );
}

template< class CharT, class Traits, class Allocator >
std::basic_string_view<CharT, Traits>
to_string_view( std::basic_string<CharT, Traits, Allocator> const & s )
{
    return std::basic_string_view<CharT, Traits>( s.data(), s.size() );
}

// Literal operators sv and _sv:

#if nssv_CONFIG_STD_SV_OPERATOR

using namespace std::literals::string_view_literals;

#endif

#if nssv_CONFIG_USR_SV_OPERATOR

inline namespace literals {
inline namespace string_view_literals {


constexpr std::string_view operator "" _sv( const char* str, size_t len ) noexcept  // (1)
{
    return std::string_view{ str, len };
}

constexpr std::u16string_view operator "" _sv( const char16_t* str, size_t len ) noexcept  // (2)
{
    return std::u16string_view{ str, len };
}

constexpr std::u32string_view operator "" _sv( const char32_t* str, size_t len ) noexcept  // (3)
{
    return std::u32string_view{ str, len };
}

constexpr std::wstring_view operator "" _sv( const wchar_t* str, size_t len ) noexcept  // (4)
{
    return std::wstring_view{ str, len };
}

}} // namespace literals::string_view_literals

#endif // nssv_CONFIG_USR_SV_OPERATOR

} // namespace nonstd

#endif // nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS

namespace nonstd {

using std::string_view;
using std::wstring_view;
using std::u16string_view;
using std::u32string_view;
using std::basic_string_view;

// literal "sv" and "_sv", see above

using std::operator==;
using std::operator!=;
using std::operator<;
using std::operator<=;
using std::operator>;
using std::operator>=;

using std::operator<<;

} // namespace nonstd

#else // nssv_HAVE_STD_STRING_VIEW

//
// Before C++17: use string_view lite:
//

// Compiler versions:
//
// MSVC++ 6.0  _MSC_VER == 1200 (Visual Studio 6.0)
// MSVC++ 7.0  _MSC_VER == 1300 (Visual Studio .NET 2002)
// MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio .NET 2003)
// MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
// MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
// MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
// MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
// MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
// MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
// MSVC++ 14.1 _MSC_VER >= 1910 (Visual Studio 2017)

#if defined(_MSC_VER ) && !defined(__clang__)
# define nssv_COMPILER_MSVC_VER      (_MSC_VER )
# define nssv_COMPILER_MSVC_VERSION  (_MSC_VER / 10 - 10 * ( 5 + (_MSC_VER < 1900 ) ) )
#else
# define nssv_COMPILER_MSVC_VER      0
# define nssv_COMPILER_MSVC_VERSION  0
#endif

#define nssv_COMPILER_VERSION( major, minor, patch )  (10 * ( 10 * major + minor) + patch)

#if defined(__clang__)
# define nssv_COMPILER_CLANG_VERSION  nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)
#else
# define nssv_COMPILER_CLANG_VERSION    0
#endif

#if defined(__GNUC__) && !defined(__clang__)
# define nssv_COMPILER_GNUC_VERSION  nssv_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#else
# define nssv_COMPILER_GNUC_VERSION    0
#endif

// half-open range [lo..hi):
#define nssv_BETWEEN( v, lo, hi ) ( (lo) <= (v) && (v) < (hi) )

// Presence of language and library features:

#ifdef _HAS_CPP0X
# define nssv_HAS_CPP0X  _HAS_CPP0X
#else
# define nssv_HAS_CPP0X  0
#endif

// Unless defined otherwise below, consider VC14 as C++11 for variant-lite:

#if nssv_COMPILER_MSVC_VER >= 1900
# undef  nssv_CPP11_OR_GREATER
# define nssv_CPP11_OR_GREATER  1
#endif

#define nssv_CPP11_90   (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1500)
#define nssv_CPP11_100  (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1600)
#define nssv_CPP11_110  (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1700)
#define nssv_CPP11_120  (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1800)
#define nssv_CPP11_140  (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1900)
#define nssv_CPP11_141  (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1910)

#define nssv_CPP14_000  (nssv_CPP14_OR_GREATER)
#define nssv_CPP17_000  (nssv_CPP17_OR_GREATER)

// Presence of C++11 language features:

#define nssv_HAVE_CONSTEXPR_11          nssv_CPP11_140
#define nssv_HAVE_EXPLICIT_CONVERSION   nssv_CPP11_140
#define nssv_HAVE_INLINE_NAMESPACE      nssv_CPP11_140
#define nssv_HAVE_NOEXCEPT              nssv_CPP11_140
#define nssv_HAVE_NULLPTR               nssv_CPP11_100
#define nssv_HAVE_REF_QUALIFIER         nssv_CPP11_140
#define nssv_HAVE_UNICODE_LITERALS      nssv_CPP11_140
#define nssv_HAVE_USER_DEFINED_LITERALS nssv_CPP11_140
#define nssv_HAVE_WCHAR16_T             nssv_CPP11_100
#define nssv_HAVE_WCHAR32_T             nssv_CPP11_100

#if ! ( ( nssv_CPP11_OR_GREATER && nssv_COMPILER_CLANG_VERSION ) || nssv_BETWEEN( nssv_COMPILER_CLANG_VERSION, 300, 400 ) )
# define nssv_HAVE_STD_DEFINED_LITERALS  nssv_CPP11_140
#endif

// Presence of C++14 language features:

#define nssv_HAVE_CONSTEXPR_14          nssv_CPP14_000

// Presence of C++17 language features:

#define nssv_HAVE_NODISCARD             nssv_CPP17_000

// Presence of C++ library features:

#define nssv_HAVE_STD_HASH              nssv_CPP11_120

// C++ feature usage:

#if nssv_HAVE_CONSTEXPR_11
# define nssv_constexpr  constexpr
#else
# define nssv_constexpr  /*constexpr*/
#endif

#if  nssv_HAVE_CONSTEXPR_14
# define nssv_constexpr14  constexpr
#else
# define nssv_constexpr14  /*constexpr*/
#endif

#if nssv_HAVE_EXPLICIT_CONVERSION
# define nssv_explicit  explicit
#else
# define nssv_explicit  /*explicit*/
#endif

#if nssv_HAVE_INLINE_NAMESPACE
# define nssv_inline_ns  inline
#else
# define nssv_inline_ns  /*inline*/
#endif

#if nssv_HAVE_NOEXCEPT
# define nssv_noexcept  noexcept
#else
# define nssv_noexcept  /*noexcept*/
#endif

//#if nssv_HAVE_REF_QUALIFIER
//# define nssv_ref_qual  &
//# define nssv_refref_qual  &&
//#else
//# define nssv_ref_qual  /*&*/
//# define nssv_refref_qual  /*&&*/
//#endif

#if nssv_HAVE_NULLPTR
# define nssv_nullptr  nullptr
#else
# define nssv_nullptr  NULL
#endif

#if nssv_HAVE_NODISCARD
# define nssv_nodiscard  [[nodiscard]]
#else
# define nssv_nodiscard  /*[[nodiscard]]*/
#endif

// Additional includes:

#include <algorithm>
#include <cassert>
#include <iterator>
#include <limits>
#include <ostream>
#include <string>   // std::char_traits<>

#if ! nssv_CONFIG_NO_EXCEPTIONS
# include <stdexcept>
#endif

#if nssv_CPP11_OR_GREATER
# include <type_traits>
#endif

// Clang, GNUC, MSVC warning suppression macros:

#if defined(__clang__)
# pragma clang diagnostic ignored "-Wreserved-user-defined-literal"
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wuser-defined-literals"
#elif defined(__GNUC__)
# pragma  GCC  diagnostic push
# pragma  GCC  diagnostic ignored "-Wliteral-suffix"
#endif // __clang__

#if nssv_COMPILER_MSVC_VERSION >= 140
# define nssv_SUPPRESS_MSGSL_WARNING(expr)        [[gsl::suppress(expr)]]
# define nssv_SUPPRESS_MSVC_WARNING(code, descr)  __pragma(warning(suppress: code) )
# define nssv_DISABLE_MSVC_WARNINGS(codes)        __pragma(warning(push))  __pragma(warning(disable: codes))
#else
# define nssv_SUPPRESS_MSGSL_WARNING(expr)
# define nssv_SUPPRESS_MSVC_WARNING(code, descr)
# define nssv_DISABLE_MSVC_WARNINGS(codes)
#endif

#if defined(__clang__)
# define nssv_RESTORE_WARNINGS()  _Pragma("clang diagnostic pop")
#elif defined(__GNUC__)
# define nssv_RESTORE_WARNINGS()  _Pragma("GCC diagnostic pop")
#elif nssv_COMPILER_MSVC_VERSION >= 140
# define nssv_RESTORE_WARNINGS()  __pragma(warning(pop ))
#else
# define nssv_RESTORE_WARNINGS()
#endif

// Suppress the following MSVC (GSL) warnings:
// - C4455, non-gsl   : 'operator ""sv': literal suffix identifiers that do not
//                      start with an underscore are reserved
// - C26472, gsl::t.1 : don't use a static_cast for arithmetic conversions;
//                      use brace initialization, gsl::narrow_cast or gsl::narow
// - C26481: gsl::b.1 : don't use pointer arithmetic. Use span instead

nssv_DISABLE_MSVC_WARNINGS( 4455 26481 26472 )
//nssv_DISABLE_CLANG_WARNINGS( "-Wuser-defined-literals" )
//nssv_DISABLE_GNUC_WARNINGS( -Wliteral-suffix )

namespace nonstd { namespace sv_lite {

template
<
    class CharT,
    class Traits = std::char_traits<CharT>
>
class basic_string_view;

//
// basic_string_view:
//

template
<
    class CharT,
    class Traits /* = std::char_traits<CharT> */
>
class basic_string_view
{
public:
    // Member types:

    typedef Traits traits_type;
    typedef CharT  value_type;

    typedef CharT       * pointer;
    typedef CharT const * const_pointer;
    typedef CharT       & reference;
    typedef CharT const & const_reference;

    typedef const_pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::reverse_iterator< const_iterator > reverse_iterator;
    typedef	std::reverse_iterator< const_iterator > const_reverse_iterator;

    typedef std::size_t     size_type;
    typedef std::ptrdiff_t  difference_type;

    // 24.4.2.1 Construction and assignment:

    nssv_constexpr basic_string_view() nssv_noexcept
        : data_( nssv_nullptr )
        , size_( 0 )
    {}

#if nssv_CPP11_OR_GREATER
    nssv_constexpr basic_string_view( basic_string_view const & other ) nssv_noexcept = default;
#else
    nssv_constexpr basic_string_view( basic_string_view const & other ) nssv_noexcept
        : data_( other.data_)
        , size_( other.size_)
    {}
#endif

    nssv_constexpr basic_string_view( CharT const * s, size_type count )
        : data_( s )
        , size_( count )
    {}

    /*nssv_constexpr basic_string_view( CharT const * s)
        : data_( s )
        , size_( Traits::length(s) )
    {}*/

	template<size_t N>
	nssv_constexpr basic_string_view(CharT const (&s)[N])
			: data_( s )
			, size_( N - 1 )
	{}

    // Assignment:

#if nssv_CPP11_OR_GREATER
    nssv_constexpr14 basic_string_view & operator=( basic_string_view const & other ) nssv_noexcept = default;
#else
    nssv_constexpr14 basic_string_view & operator=( basic_string_view const & other ) nssv_noexcept
    {
        data_ = other.data_;
        size_ = other.size_;
        return *this;
    }
#endif

    // 24.4.2.2 Iterator support:

    nssv_constexpr const_iterator begin()  const nssv_noexcept { return data_;         }
    nssv_constexpr const_iterator end()    const nssv_noexcept { return data_ + size_; }

    nssv_constexpr const_iterator cbegin() const nssv_noexcept { return begin(); }
    nssv_constexpr const_iterator cend()   const nssv_noexcept { return end();   }

    nssv_constexpr const_reverse_iterator rbegin()  const nssv_noexcept { return const_reverse_iterator( end() );   }
    nssv_constexpr const_reverse_iterator rend()    const nssv_noexcept { return const_reverse_iterator( begin() ); }

    nssv_constexpr const_reverse_iterator crbegin() const nssv_noexcept { return rbegin(); }
    nssv_constexpr const_reverse_iterator crend()   const nssv_noexcept { return rend();   }

    // 24.4.2.3 Capacity:

    nssv_constexpr size_type size()     const nssv_noexcept { return size_; }
    nssv_constexpr size_type length()   const nssv_noexcept { return size_; }
    nssv_constexpr size_type max_size() const nssv_noexcept { return (std::numeric_limits< size_type >::max)(); }

    // since C++20
    nssv_nodiscard nssv_constexpr bool empty() const nssv_noexcept
    {
        return 0 == size_;
    }

    // 24.4.2.4 Element access:

    nssv_constexpr const_reference operator[]( size_type pos ) const
    {
        return data_at( pos );
    }

    nssv_constexpr14 const_reference at( size_type pos ) const
    {
#if nssv_CONFIG_NO_EXCEPTIONS
        assert( pos < size() );
#else
        if ( pos >= size() )
        {
            throw std::out_of_range("nonst::string_view::at()");
        }
#endif
        return data_at( pos );
    }

    nssv_constexpr const_reference front() const { return data_at( 0 );          }
    nssv_constexpr const_reference back()  const { return data_at( size() - 1 ); }

    nssv_constexpr const_pointer   data()  const nssv_noexcept { return data_; }

    // 24.4.2.5 Modifiers:

    nssv_constexpr14 void remove_prefix( size_type n )
    {
        assert( n <= size() );
        data_ += n;
        size_ -= n;
    }

    nssv_constexpr14 void remove_suffix( size_type n )
    {
        assert( n <= size() );
        size_ -= n;
    }

    nssv_constexpr14 void swap( basic_string_view & other ) nssv_noexcept
    {
        using std::swap;
        swap( data_, other.data_ );
        swap( size_, other.size_ );
    }

    // 24.4.2.6 String operations:

    size_type copy( CharT * dest, size_type n, size_type pos = 0 ) const
    {
#if nssv_CONFIG_NO_EXCEPTIONS
        assert( pos <= size() );
#else
        if ( pos > size() )
        {
            throw std::out_of_range("nonst::string_view::copy()");
        }
#endif
        const size_type rlen = (std::min)( n, size() - pos );

        (void) Traits::copy( dest, data() + pos, rlen );

        return rlen;
    }

    nssv_constexpr14 basic_string_view substr( size_type pos = 0, size_type n = npos ) const
    {
#if nssv_CONFIG_NO_EXCEPTIONS
        assert( pos <= size() );
#else
        if ( pos > size() )
        {
            throw std::out_of_range("nonst::string_view::substr()");
        }
#endif
        return basic_string_view( data() + pos, (std::min)( n, size() - pos ) );
    }

    // compare(), 6x:

    nssv_constexpr14 int compare( basic_string_view other ) const nssv_noexcept // (1)
    {
        if ( const int result = Traits::compare( data(), other.data(), (std::min)( size(), other.size() ) ) )
            return result;

        return size() == other.size() ? 0 : size() < other.size() ? -1 : 1;
    }

    nssv_constexpr int compare( size_type pos1, size_type n1, basic_string_view other ) const // (2)
    {
        return substr( pos1, n1 ).compare( other );
    }

    nssv_constexpr int compare( size_type pos1, size_type n1, basic_string_view other, size_type pos2, size_type n2 ) const // (3)
    {
        return substr( pos1, n1 ).compare( other.substr( pos2, n2 ) );
    }

    nssv_constexpr int compare( CharT const * s ) const // (4)
    {
        return compare( basic_string_view( s ) );
    }

    nssv_constexpr int compare( size_type pos1, size_type n1, CharT const * s ) const // (5)
    {
        return substr( pos1, n1 ).compare( basic_string_view( s ) );
    }

    nssv_constexpr int compare( size_type pos1, size_type n1, CharT const * s, size_type n2 ) const // (6)
    {
        return substr( pos1, n1 ).compare( basic_string_view( s, n2 ) );
    }

    // 24.4.2.7 Searching:

    // starts_with(), 3x, since C++20:

    nssv_constexpr bool starts_with( basic_string_view v ) const nssv_noexcept  // (1)
    {
        return size() >= v.size() && compare( 0, v.size(), v ) == 0;
    }

    nssv_constexpr bool starts_with( CharT c ) const nssv_noexcept  // (2)
    {
        return starts_with( basic_string_view( &c, 1 ) );
    }

    nssv_constexpr bool starts_with( CharT const * s ) const  // (3)
    {
        return starts_with( basic_string_view( s ) );
    }

    // ends_with(), 3x, since C++20:

    nssv_constexpr bool ends_with( basic_string_view v ) const nssv_noexcept  // (1)
    {
        return size() >= v.size() && compare( size() - v.size(), npos, v ) == 0;
    }

    nssv_constexpr bool ends_with( CharT c ) const nssv_noexcept  // (2)
    {
        return ends_with( basic_string_view( &c, 1 ) );
    }

    nssv_constexpr bool ends_with( CharT const * s ) const  // (3)
    {
        return ends_with( basic_string_view( s ) );
    }

    // find(), 4x:

    nssv_constexpr14 size_type find( basic_string_view v, size_type pos = 0 ) const nssv_noexcept  // (1)
    {
        return assert( v.size() == 0 || v.data() != nssv_nullptr )
            , pos >= size()
            ? npos
            : to_pos( std::search( cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq ) );
    }

    nssv_constexpr14 size_type find( CharT c, size_type pos = 0 ) const nssv_noexcept  // (2)
    {
        return find( basic_string_view( &c, 1 ), pos );
    }

    nssv_constexpr14 size_type find( CharT const * s, size_type pos, size_type n ) const  // (3)
    {
        return find( basic_string_view( s, n ), pos );
    }

    nssv_constexpr14 size_type find( CharT const * s, size_type pos = 0 ) const  // (4)
    {
        return find( basic_string_view( s ), pos );
    }

    // rfind(), 4x:

    nssv_constexpr14 size_type rfind( basic_string_view v, size_type pos = npos ) const nssv_noexcept  // (1)
    {
        if ( size() < v.size() )
            return npos;

        if ( v.empty() )
            return (std::min)( size(), pos );

        const_iterator last   = cbegin() + (std::min)( size() - v.size(), pos ) + v.size();
        const_iterator result = std::find_end( cbegin(), last, v.cbegin(), v.cend(), Traits::eq );

        return result != last ? size_type( result - cbegin() ) : npos;
    }

    nssv_constexpr14 size_type rfind( CharT c, size_type pos = npos ) const nssv_noexcept  // (2)
    {
        return rfind( basic_string_view( &c, 1 ), pos );
    }

    nssv_constexpr14 size_type rfind( CharT const * s, size_type pos, size_type n ) const  // (3)
    {
        return rfind( basic_string_view( s, n ), pos );
    }

    nssv_constexpr14 size_type rfind( CharT const * s, size_type pos = npos ) const  // (4)
    {
        return rfind( basic_string_view( s ), pos );
    }

    // find_first_of(), 4x:

    nssv_constexpr size_type find_first_of( basic_string_view v, size_type pos = 0 ) const nssv_noexcept  // (1)
    {
        return pos >= size()
            ? npos
            : to_pos( std::find_first_of( cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq ) );
    }

    nssv_constexpr size_type find_first_of( CharT c, size_type pos = 0 ) const nssv_noexcept  // (2)
    {
        return find_first_of( basic_string_view( &c, 1 ), pos );
    }

    nssv_constexpr size_type find_first_of( CharT const * s, size_type pos, size_type n ) const  // (3)
    {
        return find_first_of( basic_string_view( s, n ), pos );
    }

    nssv_constexpr size_type find_first_of(  CharT const * s, size_type pos = 0 ) const  // (4)
    {
        return find_first_of( basic_string_view( s ), pos );
    }

    // find_last_of(), 4x:

    nssv_constexpr size_type find_last_of( basic_string_view v, size_type pos = npos ) const nssv_noexcept  // (1)
    {
        return empty()
            ? npos
            : pos >= size()
            ? find_last_of( v, size() - 1 )
            : to_pos( std::find_first_of( const_reverse_iterator( cbegin() + pos + 1 ), crend(), v.cbegin(), v.cend(), Traits::eq ) );
    }

    nssv_constexpr size_type find_last_of( CharT c, size_type pos = npos ) const nssv_noexcept  // (2)
    {
        return find_last_of( basic_string_view( &c, 1 ), pos );
    }

    nssv_constexpr size_type find_last_of( CharT const * s, size_type pos, size_type count ) const  // (3)
    {
        return find_last_of( basic_string_view( s, count ), pos );
    }

    nssv_constexpr size_type find_last_of( CharT const * s, size_type pos = npos ) const  // (4)
    {
        return find_last_of( basic_string_view( s ), pos );
    }

    // find_first_not_of(), 4x:

    nssv_constexpr size_type find_first_not_of( basic_string_view v, size_type pos = 0 ) const nssv_noexcept  // (1)
    {
        return pos >= size()
            ? npos
            : to_pos( std::find_if( cbegin() + pos, cend(), not_in_view( v ) ) );
    }

    nssv_constexpr size_type find_first_not_of( CharT c, size_type pos = 0 ) const nssv_noexcept  // (2)
    {
        return find_first_not_of( basic_string_view( &c, 1 ), pos );
    }

    nssv_constexpr size_type find_first_not_of( CharT const * s, size_type pos, size_type count ) const  // (3)
    {
        return find_first_not_of( basic_string_view( s, count ), pos );
    }

    nssv_constexpr size_type find_first_not_of( CharT const * s, size_type pos = 0 ) const  // (4)
    {
        return find_first_not_of( basic_string_view( s ), pos );
    }

    // find_last_not_of(), 4x:

    nssv_constexpr size_type find_last_not_of( basic_string_view v, size_type pos = npos ) const nssv_noexcept  // (1)
    {
        return empty()
            ? npos
            : pos >= size()
            ? find_last_not_of( v, size() - 1 )
            : to_pos( std::find_if( const_reverse_iterator( cbegin() + pos + 1 ), crend(), not_in_view( v ) ) );
    }

    nssv_constexpr size_type find_last_not_of( CharT c, size_type pos = npos ) const nssv_noexcept  // (2)
    {
        return find_last_not_of( basic_string_view( &c, 1 ), pos );
    }

    nssv_constexpr size_type find_last_not_of( CharT const * s, size_type pos, size_type count ) const  // (3)
    {
        return find_last_not_of( basic_string_view( s, count ), pos );
    }

    nssv_constexpr size_type find_last_not_of( CharT const * s, size_type pos = npos ) const  // (4)
    {
        return find_last_not_of( basic_string_view( s ), pos );
    }

    // Constants:

#if nssv_CPP17_OR_GREATER
    static nssv_constexpr size_type npos = size_type(-1);
#elif nssv_CPP11_OR_GREATER
    enum : size_type { npos = size_type(-1) };
#else
    enum { npos = size_type(-1) };
#endif

private:
    struct not_in_view
    {
        const basic_string_view v;

        nssv_constexpr not_in_view( basic_string_view v ) : v( v ) {}

        nssv_constexpr bool operator()( CharT c ) const
        {
            return npos == v.find_first_of( c );
        }
    };

    nssv_constexpr size_type to_pos( const_iterator it ) const
    {
        return it == cend() ? npos : size_type( it - cbegin() );
    }

    nssv_constexpr size_type to_pos( const_reverse_iterator it ) const
    {
        return it == crend() ? npos : size_type( crend() - it - 1 );
    }

    nssv_constexpr const_reference data_at( size_type pos ) const
    {
#if nssv_BETWEEN( nssv_COMPILER_GNUC_VERSION, 1, 500 )
        return data_[pos];
#else
        return data_[pos];
#endif
    }

private:
    const_pointer data_;
    size_type     size_;

public:
#if nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS

    template< class Allocator >
    basic_string_view( std::basic_string<CharT, Traits, Allocator> const & s ) nssv_noexcept
        : data_( s.data() )
        , size_( s.size() )
    {}

#if nssv_HAVE_EXPLICIT_CONVERSION

    template< class Allocator >
    explicit operator std::basic_string<CharT, Traits, Allocator>() const
    {
        return to_string( Allocator() );
    }

#endif // nssv_HAVE_EXPLICIT_CONVERSION

#if nssv_CPP11_OR_GREATER

    template< class Allocator = std::allocator<CharT> >
    std::basic_string<CharT, Traits, Allocator>
    to_string( Allocator const & a = Allocator() ) const
    {
        return std::basic_string<CharT, Traits, Allocator>( begin(), end(), a );
    }

#else

    std::basic_string<CharT, Traits>
    to_string() const
    {
        return std::basic_string<CharT, Traits>( begin(), end() );
    }

    template< class Allocator >
    std::basic_string<CharT, Traits, Allocator>
    to_string( Allocator const & a ) const
    {
        return std::basic_string<CharT, Traits, Allocator>( begin(), end(), a );
    }

#endif // nssv_CPP11_OR_GREATER

#endif // nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
};

//
// Non-member functions:
//

// 24.4.3 Non-member comparison functions:
// lexicographically compare two string views (function template):

template< class CharT, class Traits >
nssv_constexpr bool operator== (
    basic_string_view <CharT, Traits> lhs,
    basic_string_view <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.compare( rhs ) == 0 ; }

template< class CharT, class Traits >
nssv_constexpr bool operator!= (
    basic_string_view <CharT, Traits> lhs,
    basic_string_view <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.compare( rhs ) != 0 ; }

template< class CharT, class Traits >
nssv_constexpr bool operator< (
    basic_string_view <CharT, Traits> lhs,
    basic_string_view <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.compare( rhs ) < 0 ; }

template< class CharT, class Traits >
nssv_constexpr bool operator<= (
    basic_string_view <CharT, Traits> lhs,
    basic_string_view <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.compare( rhs ) <= 0 ; }

template< class CharT, class Traits >
nssv_constexpr bool operator> (
    basic_string_view <CharT, Traits> lhs,
    basic_string_view <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.compare( rhs ) > 0 ; }

template< class CharT, class Traits >
nssv_constexpr bool operator>= (
    basic_string_view <CharT, Traits> lhs,
    basic_string_view <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.compare( rhs ) >= 0 ; }

// Let S be basic_string_view<CharT, Traits>, and sv be an instance of S.
// Implementations shall provide sufficient additional overloads marked
// constexpr and noexcept so that an object t with an implicit conversion
// to S can be compared according to Table 67.

#if nssv_CPP11_OR_GREATER && ! nssv_BETWEEN( nssv_COMPILER_MSVC_VERSION, 100, 141 )

#define nssv_BASIC_STRING_VIEW_I(T,U)  typename std::decay< basic_string_view<T,U> >::type

#if nssv_BETWEEN( nssv_COMPILER_MSVC_VERSION, 140, 150 )
# define nssv_MSVC_ORDER(x)  , int=x
#else
# define nssv_MSVC_ORDER(x)  /*, int=x*/
#endif

// ==

template< class CharT, class Traits  nssv_MSVC_ORDER(1) >
nssv_constexpr bool operator==(
         basic_string_view  <CharT, Traits> lhs,
    nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs ) nssv_noexcept
{ return lhs.compare( rhs ) == 0; }

template< class CharT, class Traits  nssv_MSVC_ORDER(2) >
nssv_constexpr bool operator==(
    nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
         basic_string_view  <CharT, Traits> rhs ) nssv_noexcept
{ return lhs.size() == rhs.size() && lhs.compare( rhs ) == 0; }

// !=

template< class CharT, class Traits  nssv_MSVC_ORDER(1) >
nssv_constexpr bool operator!= (
         basic_string_view  < CharT, Traits > lhs,
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept
{ return lhs.size() != rhs.size() || lhs.compare( rhs ) != 0 ; }

template< class CharT, class Traits  nssv_MSVC_ORDER(2) >
nssv_constexpr bool operator!= (
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,
         basic_string_view  < CharT, Traits > rhs ) nssv_noexcept
{ return lhs.compare( rhs ) != 0 ; }

// <

template< class CharT, class Traits  nssv_MSVC_ORDER(1) >
nssv_constexpr bool operator< (
         basic_string_view  < CharT, Traits > lhs,
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept
{ return lhs.compare( rhs ) < 0 ; }

template< class CharT, class Traits  nssv_MSVC_ORDER(2) >
nssv_constexpr bool operator< (
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,
         basic_string_view  < CharT, Traits > rhs ) nssv_noexcept
{ return lhs.compare( rhs ) < 0 ; }

// <=

template< class CharT, class Traits  nssv_MSVC_ORDER(1) >
nssv_constexpr bool operator<= (
         basic_string_view  < CharT, Traits > lhs,
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept
{ return lhs.compare( rhs ) <= 0 ; }

template< class CharT, class Traits  nssv_MSVC_ORDER(2) >
nssv_constexpr bool operator<= (
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,
         basic_string_view  < CharT, Traits > rhs ) nssv_noexcept
{ return lhs.compare( rhs ) <= 0 ; }

// >

template< class CharT, class Traits  nssv_MSVC_ORDER(1) >
nssv_constexpr bool operator> (
         basic_string_view  < CharT, Traits > lhs,
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept
{ return lhs.compare( rhs ) > 0 ; }

template< class CharT, class Traits  nssv_MSVC_ORDER(2) >
nssv_constexpr bool operator> (
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,
         basic_string_view  < CharT, Traits > rhs ) nssv_noexcept
{ return lhs.compare( rhs ) > 0 ; }

// >=

template< class CharT, class Traits  nssv_MSVC_ORDER(1) >
nssv_constexpr bool operator>= (
         basic_string_view  < CharT, Traits > lhs,
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept
{ return lhs.compare( rhs ) >= 0 ; }

template< class CharT, class Traits  nssv_MSVC_ORDER(2) >
nssv_constexpr bool operator>= (
    nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,
         basic_string_view  < CharT, Traits > rhs ) nssv_noexcept
{ return lhs.compare( rhs ) >= 0 ; }

#undef nssv_MSVC_ORDER
#undef nssv_BASIC_STRING_VIEW_I

#endif // nssv_CPP11_OR_GREATER

// 24.4.4 Inserters and extractors:

namespace detail {

template< class Stream >
void write_padding( Stream & os, std::streamsize n )
{
    for ( std::streamsize i = 0; i < n; ++i )
        os.rdbuf()->sputc( os.fill() );
}

template< class Stream, class View >
Stream & write_to_stream( Stream & os, View const & sv )
{
    typename Stream::sentry sentry( os );

    if ( !os )
        return os;

    const std::streamsize length = static_cast<std::streamsize>( sv.length() );

    // Whether, and how, to pad:
    const bool      pad = ( length < os.width() );
    const bool left_pad = pad && ( os.flags() & std::ios_base::adjustfield ) == std::ios_base::right;

    if ( left_pad )
        write_padding( os, os.width() - length );

    // Write span characters:
    os.rdbuf()->sputn( sv.begin(), length );

    if ( pad && !left_pad )
        write_padding( os, os.width() - length );

    // Reset output stream width:
    os.width( 0 );

    return os;
}

} // namespace detail

template< class CharT, class Traits >
std::basic_ostream<CharT, Traits> &
operator<<(
    std::basic_ostream<CharT, Traits>& os,
    basic_string_view <CharT, Traits> sv )
{
    return detail::write_to_stream( os, sv );
}

// Several typedefs for common character types are provided:

typedef basic_string_view<char>      string_view;
typedef basic_string_view<wchar_t>   wstring_view;
#if nssv_HAVE_WCHAR16_T
typedef basic_string_view<char16_t>  u16string_view;
typedef basic_string_view<char32_t>  u32string_view;
#endif

}} // namespace nonstd::sv_lite

//
// 24.4.6 Suffix for basic_string_view literals:
//

#if nssv_HAVE_USER_DEFINED_LITERALS

namespace nonstd {
nssv_inline_ns namespace literals {
nssv_inline_ns namespace string_view_literals {

#if nssv_CONFIG_STD_SV_OPERATOR && nssv_HAVE_STD_DEFINED_LITERALS

nssv_constexpr nonstd::sv_lite::string_view operator "" sv( const char* str, size_t len ) nssv_noexcept  // (1)
{
    return nonstd::sv_lite::string_view{ str, len };
}

nssv_constexpr nonstd::sv_lite::u16string_view operator "" sv( const char16_t* str, size_t len ) nssv_noexcept  // (2)
{
    return nonstd::sv_lite::u16string_view{ str, len };
}

nssv_constexpr nonstd::sv_lite::u32string_view operator "" sv( const char32_t* str, size_t len ) nssv_noexcept  // (3)
{
    return nonstd::sv_lite::u32string_view{ str, len };
}

nssv_constexpr nonstd::sv_lite::wstring_view operator "" sv( const wchar_t* str, size_t len ) nssv_noexcept  // (4)
{
    return nonstd::sv_lite::wstring_view{ str, len };
}

#endif // nssv_CONFIG_STD_SV_OPERATOR && nssv_HAVE_STD_DEFINED_LITERALS

#if nssv_CONFIG_USR_SV_OPERATOR

nssv_constexpr nonstd::sv_lite::string_view operator "" _sv( const char* str, size_t len ) nssv_noexcept  // (1)
{
    return nonstd::sv_lite::string_view{ str, len };
}

nssv_constexpr nonstd::sv_lite::u16string_view operator "" _sv( const char16_t* str, size_t len ) nssv_noexcept  // (2)
{
    return nonstd::sv_lite::u16string_view{ str, len };
}

nssv_constexpr nonstd::sv_lite::u32string_view operator "" _sv( const char32_t* str, size_t len ) nssv_noexcept  // (3)
{
    return nonstd::sv_lite::u32string_view{ str, len };
}

nssv_constexpr nonstd::sv_lite::wstring_view operator "" _sv( const wchar_t* str, size_t len ) nssv_noexcept  // (4)
{
    return nonstd::sv_lite::wstring_view{ str, len };
}

#endif // nssv_CONFIG_USR_SV_OPERATOR

}}} // namespace nonstd::literals::string_view_literals

#endif

//
// Extensions for std::string:
//

#if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS

namespace nonstd {
namespace sv_lite {

// Exclude MSVC 14 (19.00): it yields ambiguous to_string():

#if nssv_CPP11_OR_GREATER && nssv_COMPILER_MSVC_VERSION != 140

template< class CharT, class Traits, class Allocator = std::allocator<CharT> >
std::basic_string<CharT, Traits, Allocator>
to_string( basic_string_view<CharT, Traits> v, Allocator const & a = Allocator() )
{
    return std::basic_string<CharT,Traits, Allocator>( v.begin(), v.end(), a );
}

#else

template< class CharT, class Traits >
std::basic_string<CharT, Traits>
to_string( basic_string_view<CharT, Traits> v )
{
    return std::basic_string<CharT, Traits>( v.begin(), v.end() );
}

template< class CharT, class Traits, class Allocator >
std::basic_string<CharT, Traits, Allocator>
to_string( basic_string_view<CharT, Traits> v, Allocator const & a )
{
    return std::basic_string<CharT, Traits, Allocator>( v.begin(), v.end(), a );
}

#endif // nssv_CPP11_OR_GREATER

template< class CharT, class Traits, class Allocator >
basic_string_view<CharT, Traits>
to_string_view( std::basic_string<CharT, Traits, Allocator> const & s )
{
    return basic_string_view<CharT, Traits>( s.data(), s.size() );
}

}} // namespace nonstd::sv_lite

#endif // nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS

//
// make types and algorithms available in namespace nonstd:
//

namespace nonstd {

using sv_lite::basic_string_view;
using sv_lite::string_view;
using sv_lite::wstring_view;

#if nssv_HAVE_WCHAR16_T
using sv_lite::u16string_view;
#endif
#if nssv_HAVE_WCHAR32_T
using sv_lite::u32string_view;
#endif

// literal "sv"

using sv_lite::operator==;
using sv_lite::operator!=;
using sv_lite::operator<;
using sv_lite::operator<=;
using sv_lite::operator>;
using sv_lite::operator>=;

using sv_lite::operator<<;

#if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
using sv_lite::to_string;
using sv_lite::to_string_view;
#endif

} // namespace nonstd

// 24.4.5 Hash support (C++11):

// Note: The hash value of a string view object is equal to the hash value of
// the corresponding string object.

#if nssv_HAVE_STD_HASH

#include <functional>

namespace std {

template<>
struct hash< nonstd::string_view >
{
public:
    std::size_t operator()( nonstd::string_view v ) const nssv_noexcept
    {
        return std::hash<std::string>()( std::string( v.data(), v.size() ) );
    }
};

template<>
struct hash< nonstd::wstring_view >
{
public:
    std::size_t operator()( nonstd::wstring_view v ) const nssv_noexcept
    {
        return std::hash<std::wstring>()( std::wstring( v.data(), v.size() ) );
    }
};

template<>
struct hash< nonstd::u16string_view >
{
public:
    std::size_t operator()( nonstd::u16string_view v ) const nssv_noexcept
    {
        return std::hash<std::u16string>()( std::u16string( v.data(), v.size() ) );
    }
};

template<>
struct hash< nonstd::u32string_view >
{
public:
    std::size_t operator()( nonstd::u32string_view v ) const nssv_noexcept
    {
        return std::hash<std::u32string>()( std::u32string( v.data(), v.size() ) );
    }
};

} // namespace std

#endif // nssv_HAVE_STD_HASH

nssv_RESTORE_WARNINGS()

#endif // nssv_HAVE_STD_STRING_VIEW
#endif // NONSTD_SV_LITE_H_INCLUDED

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/thirdparty.hpp`:

```hpp
#ifndef RD_CPP_THIRDPARTY_HPP
#define RD_CPP_THIRDPARTY_HPP

#include "tsl/ordered_set.h"
#include "tsl/ordered_map.h"

#if __cplusplus >= 201703L

#include <optional>
#include <variant>
#include <string_view>

namespace rd
{
using std::get;
using std::make_optional;
using std::nullopt;
using std::nullopt_t;
using std::optional;
using std::variant;
using std::visit;
}	 // namespace rd

#else

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4583)
#pragma warning(disable : 4582)
#endif
#include "optional.hpp"
#include "mpark/variant.hpp"
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

namespace rd
{
using mpark::get;
using mpark::variant;
using mpark::visit;
using tl::make_optional;
using tl::nullopt;
using tl::nullopt_t;
using tl::optional;
}	 // namespace rd

#endif

#include "nonstd/string_view.hpp"
namespace rd
{
using nonstd::string_view;
using nonstd::wstring_view;
using namespace std::literals;
using namespace nonstd::literals;
}	 // namespace rd

namespace rd
{
using tsl::ordered_map;
using tsl::ordered_set;
}	 // namespace rd

#endif	  // RD_CPP_THIRDPARTY_H

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/CMakeLists.txt`:

```txt
# MPark.Variant
#
# Copyright Michael Park, 2015-2017
#
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)

cmake_minimum_required(VERSION 3.6.3)

project(MPark.Variant VERSION 1.4.1 LANGUAGES CXX)

# Option.
set(MPARK_VARIANT_INCLUDE_TESTS "" CACHE STRING
    "Semicolon-separated list of tests to build. \
     Possible values are `mpark`, and `libc++`.")

# Target.
add_library(mpark_variant INTERFACE)
target_include_directories(mpark_variant INTERFACE
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>)

# Config.
include(CMakePackageConfigHelpers)

configure_package_config_file(
  cmake/mpark_variant-config.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/cmake/mpark_variant-config.cmake"
  INSTALL_DESTINATION lib/cmake/mpark_variant
  NO_CHECK_REQUIRED_COMPONENTS_MACRO)

write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/cmake/mpark_variant-config-version.cmake"
  COMPATIBILITY AnyNewerVersion)

# Export.
export(
  TARGETS mpark_variant
  FILE "${CMAKE_CURRENT_BINARY_DIR}/cmake/mpark_variant-targets.cmake")

# Install.
install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include/mpark
        DESTINATION "${CMAKE_INSTALL_PUBLIC_HEADER_THIRDPARTY}"
        CONFIGURATIONS Release
        FILES_MATCHING
        PATTERN *.h
        PATTERN *.hpp
        )

#[[
install(TARGETS mpark_variant EXPORT mpark_variant)

install(
  EXPORT mpark_variant
  FILE mpark_variant-targets.cmake
  DESTINATION lib/cmake/mpark_variant)

install(DIRECTORY include/mpark DESTINATION include)

install(
  FILES
  "${CMAKE_CURRENT_BINARY_DIR}/cmake/mpark_variant-config.cmake"
  "${CMAKE_CURRENT_BINARY_DIR}/cmake/mpark_variant-config-version.cmake"
  DESTINATION lib/cmake/mpark_variant)
]]

# Test.
list(REMOVE_DUPLICATES MPARK_VARIANT_INCLUDE_TESTS)

list(FIND MPARK_VARIANT_INCLUDE_TESTS "mpark" MPARK_VARIANT_INDEX)
if(NOT MPARK_VARIANT_INDEX EQUAL -1)
  set(MPARK_VARIANT_INCLUDE_MPARK_TESTS ON)
  list(REMOVE_AT MPARK_VARIANT_INCLUDE_TESTS MPARK_VARIANT_INDEX)
endif()

list(FIND MPARK_VARIANT_INCLUDE_TESTS "libc++" MPARK_VARIANT_INDEX)
if(NOT MPARK_VARIANT_INDEX EQUAL -1)
  set(MPARK_VARIANT_INCLUDE_LIBCXX_TESTS ON)
  list(REMOVE_AT MPARK_VARIANT_INCLUDE_TESTS MPARK_VARIANT_INDEX)
endif()

list(LENGTH MPARK_VARIANT_INCLUDE_TESTS MPARK_VARIANT_LENGTH)
if(MPARK_VARIANT_LENGTH GREATER 0)
  message(FATAL_ERROR
    "The following values in `MPARK_VARIANT_INCLUDE_TESTS` are not one of "
    "the possible values, `mpark`, and `libc++`: ${MPARK_VARIANT_INCLUDE_TESTS}")
endif()

if(MPARK_VARIANT_INCLUDE_MPARK_TESTS OR MPARK_VARIANT_INCLUDE_LIBCXX_TESTS)
  enable_testing()
  add_subdirectory(test)
endif()

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/LICENSE.md`:

```md
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/README.md`:

```md
# MPark.Variant

> __C++17__ `std::variant` for __C++11__/__14__/__17__

[![release][badge.release]][release]
[![header][badge.header]][header]
[![travis][badge.travis]][travis]
[![appveyor][badge.appveyor]][appveyor]
[![license][badge.license]][license]
[![godbolt][badge.godbolt]][godbolt]
[![wandbox][badge.wandbox]][wandbox]

[badge.release]: https://img.shields.io/github/release/mpark/variant.svg
[badge.header]: https://img.shields.io/badge/single%20header-master-blue.svg
[badge.travis]: https://travis-ci.org/mpark/variant.svg?branch=master
[badge.appveyor]: https://ci.appveyor.com/api/projects/status/github/mpark/variant?branch=master&svg=true
[badge.license]: https://img.shields.io/badge/license-boost-blue.svg
[badge.godbolt]: https://img.shields.io/badge/try%20it-on%20godbolt-222266.svg
[badge.wandbox]: https://img.shields.io/badge/try%20it-on%20wandbox-5cb85c.svg

[release]: https://github.com/mpark/variant/releases/latest
[header]: https://github.com/mpark/variant/blob/single-header/master/variant.hpp
[travis]: https://travis-ci.org/mpark/variant
[appveyor]: https://ci.appveyor.com/project/mpark/variant
[license]: https://github.com/mpark/variant/blob/master/LICENSE.md
[godbolt]: https://godbolt.org/z/4r7hEy
[wandbox]: https://wandbox.org/permlink/dTZxf85MVhehOqx1

## Introduction

__MPark.Variant__ is an implementation of __C++17__ `std::variant` for __C++11__/__14__/__17__.

  - Based on [my implementation of `std::variant` for __libc++__][libcxx-impl]
  - Continuously tested against __libc++__'s `std::variant` test suite.

[libcxx-impl]: https://reviews.llvm.org/rL288547

## Documentation

  - [cppreference.com](http://en.cppreference.com/w/cpp/utility/variant)
  - [eel.is/c++draft](http://eel.is/c++draft/variant)

## Integration

### Single Header

The [single-header] branch provides a standalone `variant.hpp`
file for each [release](https://github.com/mpark/variant/releases).
Copy it and `#include` away!

[single-header]: https://github.com/mpark/variant/tree/single-header

### Submodule

You can add `mpark/variant` as a submodule to your project.

```bash
git submodule add https://github.com/mpark/variant.git 3rdparty/variant
```

Add the `include` directory to your include path with
`-I3rdparty/variant/include` then `#include` the `variant.hpp` header
with `#include <mpark/variant.hpp>`.

If you use CMake, you can simply use `add_subdirectory(3rdparty/variant)`:

```cmake
cmake_minimum_required(VERSION 3.6.3)

project(HelloWorld CXX)

add_subdirectory(3rdparty/variant)

add_executable(hello-world hello_world.cpp)
target_link_libraries(hello-world mpark_variant)
```

### Installation / CMake `find_package`

```bash
git clone https://github.com/mpark/variant.git
mkdir variant/build && cd variant/build
cmake ..
cmake --build . --target install
```

This will install `mpark/variant` to the default install-directory for
your platform (`/usr/local` for Unix, `C:\Program Files` for Windows).
You can also install at a custom location via the `CMAKE_INSTALL_PREFIX`
variable, (e.g., `cmake .. -DCMAKE_INSTALL_PREFIX=/opt`).

The installed `mpark/variant` can then be found by CMake via `find_package`:

```cmake
cmake_minimum_required(VERSION 3.6.3)

project(HelloWorld CXX)

find_package(mpark_variant 1.3.0 REQUIRED)

add_executable(hello-world hello_world.cpp)
target_link_libraries(hello-world mpark_variant)
```

CMake will search for `mpark/variant` in its default set of
installation prefixes. If `mpark/variant` is installed in
a custom location via the `CMAKE_INSTALL_PREFIX` variable,
you'll likely need to use the `CMAKE_PREFIX_PATH` to specify
the location (e.g., `cmake .. -DCMAKE_PREFIX_PATH=/opt`).

## Requirements

This library requires a standard conformant __C++11__ compiler.
The following compilers are continously tested:

| Compiler                               | Operating System                            | Version String                                                                     |
| -------------------------------------- | ------------------------------------------- | ---------------------------------------------------------------------------------- |
| GCC 4.8.5                              | Ubuntu 16.04.5 LTS                          | g++-4.8 (Ubuntu 4.8.5-4ubuntu8~16.04.1) 4.8.5                                      |
| GCC 4.9.4                              | Ubuntu 16.04.5 LTS                          | g++-4.9 (Ubuntu 4.9.4-2ubuntu1~16.04) 4.9.4                                        |
| GCC 5.5.0                              | Ubuntu 16.04.5 LTS                          | g++-5 (Ubuntu 5.5.0-12ubuntu1~16.04) 5.5.0 20171010                                |
| GCC 6.5.0                              | Ubuntu 16.04.5 LTS                          | g++-6 (Ubuntu 6.5.0-2ubuntu1~16.04) 6.5.0 20181026                                 |
| GCC 7.4.0                              | Ubuntu 16.04.5 LTS                          | g++-7 (Ubuntu 7.4.0-1ubuntu1\~16.04\~ppa1) 7.4.0                                   |
| GCC 8.1.0                              | Ubuntu 16.04.5 LTS                          | g++-8 (Ubuntu 8.1.0-5ubuntu1~16.04) 8.1.0                                          |
| Clang 3.6.2                            | Ubuntu 16.04.5 LTS                          | Ubuntu clang version 3.6.2-3ubuntu2 (tags/RELEASE_362/final) (based on LLVM 3.6.2) |
| Clang 3.7.1                            | Ubuntu 16.04.5 LTS                          | Ubuntu clang version 3.7.1-2ubuntu2 (tags/RELEASE_371/final) (based on LLVM 3.7.1) |
| Clang 3.8.0                            | Ubuntu 16.04.5 LTS                          | clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)                              |
| Clang 3.9.1                            | Ubuntu 16.04.5 LTS                          | clang version 3.9.1-4ubuntu3~16.04.2 (tags/RELEASE_391/rc2)                        |
| Clang 4.0.0                            | Ubuntu 16.04.5 LTS                          | clang version 4.0.0-1ubuntu1~16.04.2 (tags/RELEASE_400/rc1)                        |
| Clang 5.0.0                            | Ubuntu 16.04.5 LTS                          | clang version 5.0.0-3~16.04.1 (tags/RELEASE_500/final)                             |
| Clang 6.0.0                            | Ubuntu 16.04.5 LTS                          | clang version 6.0.0-1ubuntu2~16.04.1 (tags/RELEASE_600/final)                      |
| Clang 7.0.1                            | Ubuntu 16.04.5 LTS                          | clang version 7.0.1-svn347285-1\~exp1\~20181124105320.40 (branches/release_70)     |
| Clang Xcode 8.3                        | Darwin Kernel Version 16.7.0 (OS X 10.12.6) | Apple LLVM version 8.1.0 (clang-802.0.42)                                          |
| Clang Xcode 9.4                        | Darwin Kernel Version 17.4.0 (OS X 10.13.3) | Apple LLVM version 9.1.0 (clang-902.0.39.2)                                        |
| Clang Xcode 10.1                       | Darwin Kernel Version 17.7.0 (OS X 10.13.6) | Apple LLVM version 10.0.0 (clang-1000.11.45.5)                                     |
| Visual Studio 14 2015                  | Visual Studio 2015 with Update 3            | MSVC 19.0.24241.7                                                                  |
| Visual Studio 15 2017                  | Visual Studio 2017 with Update 8            | MSVC 19.15.26732.1                                                                 |
| Visual Studio 15 2017                  | Visual Studio 2017 with Update 9            | MSVC 19.16.27025.1                                                                 |
| Visual Studio 15 2017 (__Clang/LLVM__) | Visual Studio 2017                          | Clang 7.0.0                                                                        |

#### NOTES
  - __GCC 4.8__/__4.9__: `constexpr` support is not available for `visit` and relational operators.
  - Enabling __libc++__ `std::variant` tests require `-std=c++17` support.

## CMake Variables

  -  __`MPARK_VARIANT_INCLUDE_TESTS`__:`STRING` (__default__: `""`)

     Semicolon-separated list of tests to build.
     Possible values are `mpark`, and `libc++`.

     __NOTE__: The __libc++__ `std::variant` tests are built with `-std=c++17`.

## Unit Tests

Refer to [test/README.md](test/README.md).

## License

Distributed under the [Boost Software License, Version 1.0](LICENSE.md).

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/cmake/mpark_variant-config.cmake.in`:

```in
# MPark.Variant
#
# Copyright Michael Park, 2015-2017
#
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)

# Config file for MPark.Variant
#
#   `MPARK_VARIANT_INCLUDE_DIRS` - include directories
#   `MPARK_VARIANT_LIBRARIES`    - libraries to link against
#
# The following `IMPORTED` target is also defined:
#
#   `mpark_variant`

@PACKAGE_INIT@

include("${CMAKE_CURRENT_LIST_DIR}/mpark_variant-targets.cmake")

get_target_property(
  MPARK_VARIANT_INCLUDE_DIRS
  mpark_variant INTERFACE_INCLUDE_DIRECTORIES)

set_and_check(MPARK_VARIANT_INCLUDE_DIRS "${MPARK_VARIANT_INCLUDE_DIRS}")
set(MPARK_VARIANT_LIBRARIES mpark_variant)

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/include/mpark/config.hpp`:

```hpp
// MPark.Variant
//
// Copyright Michael Park, 2015-2017
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)

#ifndef MPARK_CONFIG_HPP
#define MPARK_CONFIG_HPP

// MSVC 2015 Update 3.
#if __cplusplus < 201103L && (!defined(_MSC_VER) || _MSC_FULL_VER < 190024210)
#error "MPark.Variant requires C++11 support."
#endif

#ifndef __has_attribute
#define __has_attribute(x) 0
#endif

#ifndef __has_builtin
#define __has_builtin(x) 0
#endif

#ifndef __has_include
#define __has_include(x) 0
#endif

#ifndef __has_feature
#define __has_feature(x) 0
#endif

#if __has_attribute(always_inline) || defined(__GNUC__)
#define MPARK_ALWAYS_INLINE __attribute__((__always_inline__)) inline
#elif defined(_MSC_VER)
#define MPARK_ALWAYS_INLINE __forceinline
#else
#define MPARK_ALWAYS_INLINE inline
#endif

#if __has_builtin(__builtin_addressof) || \
    (defined(__GNUC__) && __GNUC__ >= 7) || defined(_MSC_VER)
#define MPARK_BUILTIN_ADDRESSOF
#endif

#if __has_builtin(__builtin_unreachable) || defined(__GNUC__)
#define MPARK_BUILTIN_UNREACHABLE __builtin_unreachable()
#elif defined(_MSC_VER)
#define MPARK_BUILTIN_UNREACHABLE __assume(false)
#else
#define MPARK_BUILTIN_UNREACHABLE
#endif

#if __has_builtin(__type_pack_element)
#define MPARK_TYPE_PACK_ELEMENT
#endif

#if defined(__cpp_constexpr) && __cpp_constexpr >= 200704 && \
    !(defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ == 9)
#define MPARK_CPP11_CONSTEXPR
#endif

#if defined(__cpp_constexpr) && __cpp_constexpr >= 201304
#define MPARK_CPP14_CONSTEXPR
#endif

#if __has_feature(cxx_exceptions) || defined(__cpp_exceptions) || \
    (defined(_MSC_VER) && defined(_CPPUNWIND))
#define MPARK_EXCEPTIONS
#endif

#if defined(__cpp_generic_lambdas) || defined(_MSC_VER)
#define MPARK_GENERIC_LAMBDAS
#endif

#if defined(__cpp_lib_integer_sequence)
#define MPARK_INTEGER_SEQUENCE
#endif

#if defined(__cpp_return_type_deduction) || defined(_MSC_VER)
#define MPARK_RETURN_TYPE_DEDUCTION
#endif

#if defined(__cpp_lib_transparent_operators) || defined(_MSC_VER)
#define MPARK_TRANSPARENT_OPERATORS
#endif

#if defined(__cpp_variable_templates) || defined(_MSC_VER)
#define MPARK_VARIABLE_TEMPLATES
#endif

#if !defined(__GLIBCXX__) || __has_include(<codecvt>)  // >= libstdc++-5
#define MPARK_TRIVIALITY_TYPE_TRAITS
#define MPARK_INCOMPLETE_TYPE_TRAITS
#endif

#endif  // MPARK_CONFIG_HPP

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/include/mpark/in_place.hpp`:

```hpp
// MPark.Variant
//
// Copyright Michael Park, 2015-2017
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)

#ifndef MPARK_IN_PLACE_HPP
#define MPARK_IN_PLACE_HPP

#include <cstddef>

#include "config.hpp"

namespace mpark {

  struct in_place_t { explicit in_place_t() = default; };

  template <std::size_t I>
  struct in_place_index_t { explicit in_place_index_t() = default; };

  template <typename T>
  struct in_place_type_t { explicit in_place_type_t() = default; };

#ifdef MPARK_VARIABLE_TEMPLATES
  constexpr in_place_t in_place{};

  template <std::size_t I> constexpr in_place_index_t<I> in_place_index{};

  template <typename T> constexpr in_place_type_t<T> in_place_type{};
#endif

}  // namespace mpark

#endif  // MPARK_IN_PLACE_HPP

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/include/mpark/lib.hpp`:

```hpp
// MPark.Variant
//
// Copyright Michael Park, 2015-2017
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)

#ifndef MPARK_LIB_HPP
#define MPARK_LIB_HPP

#include <memory>
#include <functional>
#include <type_traits>
#include <utility>

#include "config.hpp"

#define MPARK_RETURN(...) \
  noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) { return __VA_ARGS__; }

namespace mpark {
  namespace lib {
    template <typename T>
    struct identity { using type = T; };

    inline namespace cpp14 {
      template <typename T, std::size_t N>
      struct array {
        constexpr const T &operator[](std::size_t index) const {
          return data[index];
        }

        T data[N == 0 ? 1 : N];
      };

      template <typename T>
      using add_pointer_t = typename std::add_pointer<T>::type;

      template <typename... Ts>
      using common_type_t = typename std::common_type<Ts...>::type;

      template <typename T>
      using decay_t = typename std::decay<T>::type;

      template <bool B, typename T = void>
      using enable_if_t = typename std::enable_if<B, T>::type;

      template <typename T>
      using remove_const_t = typename std::remove_const<T>::type;

      template <typename T>
      using remove_reference_t = typename std::remove_reference<T>::type;

      template <typename T>
      inline constexpr T &&forward(remove_reference_t<T> &t) noexcept {
        return static_cast<T &&>(t);
      }

      template <typename T>
      inline constexpr T &&forward(remove_reference_t<T> &&t) noexcept {
        static_assert(!std::is_lvalue_reference<T>::value,
                      "can not forward an rvalue as an lvalue");
        return static_cast<T &&>(t);
      }

      template <typename T>
      inline constexpr remove_reference_t<T> &&move(T &&t) noexcept {
        return static_cast<remove_reference_t<T> &&>(t);
      }

#ifdef MPARK_INTEGER_SEQUENCE
      using std::integer_sequence;
      using std::index_sequence;
      using std::make_index_sequence;
      using std::index_sequence_for;
#else
      template <typename T, T... Is>
      struct integer_sequence {
        using value_type = T;
        static constexpr std::size_t size() noexcept { return sizeof...(Is); }
      };

      template <std::size_t... Is>
      using index_sequence = integer_sequence<std::size_t, Is...>;

      template <typename Lhs, typename Rhs>
      struct make_index_sequence_concat;

      template <std::size_t... Lhs, std::size_t... Rhs>
      struct make_index_sequence_concat<index_sequence<Lhs...>,
                                        index_sequence<Rhs...>>
          : identity<index_sequence<Lhs..., (sizeof...(Lhs) + Rhs)...>> {};

      template <std::size_t N>
      struct make_index_sequence_impl;

      template <std::size_t N>
      using make_index_sequence = typename make_index_sequence_impl<N>::type;

      template <std::size_t N>
      struct make_index_sequence_impl
          : make_index_sequence_concat<make_index_sequence<N / 2>,
                                       make_index_sequence<N - (N / 2)>> {};

      template <>
      struct make_index_sequence_impl<0> : identity<index_sequence<>> {};

      template <>
      struct make_index_sequence_impl<1> : identity<index_sequence<0>> {};

      template <typename... Ts>
      using index_sequence_for = make_index_sequence<sizeof...(Ts)>;
#endif

      // <functional>
#ifdef MPARK_TRANSPARENT_OPERATORS
      using equal_to = std::equal_to<>;
#else
      struct equal_to {
        template <typename Lhs, typename Rhs>
        inline constexpr auto operator()(Lhs &&lhs, Rhs &&rhs) const
          MPARK_RETURN(lib::forward<Lhs>(lhs) == lib::forward<Rhs>(rhs))
      };
#endif

#ifdef MPARK_TRANSPARENT_OPERATORS
      using not_equal_to = std::not_equal_to<>;
#else
      struct not_equal_to {
        template <typename Lhs, typename Rhs>
        inline constexpr auto operator()(Lhs &&lhs, Rhs &&rhs) const
          MPARK_RETURN(lib::forward<Lhs>(lhs) != lib::forward<Rhs>(rhs))
      };
#endif

#ifdef MPARK_TRANSPARENT_OPERATORS
      using less = std::less<>;
#else
      struct less {
        template <typename Lhs, typename Rhs>
        inline constexpr auto operator()(Lhs &&lhs, Rhs &&rhs) const
          MPARK_RETURN(lib::forward<Lhs>(lhs) < lib::forward<Rhs>(rhs))
      };
#endif

#ifdef MPARK_TRANSPARENT_OPERATORS
      using greater = std::greater<>;
#else
      struct greater {
        template <typename Lhs, typename Rhs>
        inline constexpr auto operator()(Lhs &&lhs, Rhs &&rhs) const
          MPARK_RETURN(lib::forward<Lhs>(lhs) > lib::forward<Rhs>(rhs))
      };
#endif

#ifdef MPARK_TRANSPARENT_OPERATORS
      using less_equal = std::less_equal<>;
#else
      struct less_equal {
        template <typename Lhs, typename Rhs>
        inline constexpr auto operator()(Lhs &&lhs, Rhs &&rhs) const
          MPARK_RETURN(lib::forward<Lhs>(lhs) <= lib::forward<Rhs>(rhs))
      };
#endif

#ifdef MPARK_TRANSPARENT_OPERATORS
      using greater_equal = std::greater_equal<>;
#else
      struct greater_equal {
        template <typename Lhs, typename Rhs>
        inline constexpr auto operator()(Lhs &&lhs, Rhs &&rhs) const
          MPARK_RETURN(lib::forward<Lhs>(lhs) >= lib::forward<Rhs>(rhs))
      };
#endif
    }  // namespace cpp14

    inline namespace cpp17 {

      // <type_traits>
      template <bool B>
      using bool_constant = std::integral_constant<bool, B>;

      template <typename...>
      struct voider : identity<void> {};

      template <typename... Ts>
      using void_t = typename voider<Ts...>::type;

      namespace detail {
        namespace swappable {

          using std::swap;

          template <typename T>
          struct is_swappable {
            private:
            template <typename U,
                      typename = decltype(swap(std::declval<U &>(),
                                               std::declval<U &>()))>
            inline static std::true_type test(int);

            template <typename U>
            inline static std::false_type test(...);

            public:
            static constexpr bool value = decltype(test<T>(0))::value;
          };

          template <bool IsSwappable, typename T>
          struct is_nothrow_swappable {
            static constexpr bool value =
                noexcept(swap(std::declval<T &>(), std::declval<T &>()));
          };

          template <typename T>
          struct is_nothrow_swappable<false, T> : std::false_type {};

        }  // namespace swappable
      }  // namespace detail

      using detail::swappable::is_swappable;

      template <typename T>
      using is_nothrow_swappable =
          detail::swappable::is_nothrow_swappable<is_swappable<T>::value, T>;

      // <functional>
      namespace detail {

        template <typename T>
        struct is_reference_wrapper : std::false_type {};

        template <typename T>
        struct is_reference_wrapper<std::reference_wrapper<T>>
            : std::true_type {};

        template <bool, int>
        struct Invoke;

        template <>
        struct Invoke<true /* pmf */, 0 /* is_base_of */> {
          template <typename R, typename T, typename Arg, typename... Args>
          inline static constexpr auto invoke(R T::*pmf, Arg &&arg, Args &&... args)
            MPARK_RETURN((lib::forward<Arg>(arg).*pmf)(lib::forward<Args>(args)...))
        };

        template <>
        struct Invoke<true /* pmf */, 1 /* is_reference_wrapper */> {
          template <typename R, typename T, typename Arg, typename... Args>
          inline static constexpr auto invoke(R T::*pmf, Arg &&arg, Args &&... args)
            MPARK_RETURN((lib::forward<Arg>(arg).get().*pmf)(lib::forward<Args>(args)...))
        };

        template <>
        struct Invoke<true /* pmf */, 2 /* otherwise */> {
          template <typename R, typename T, typename Arg, typename... Args>
          inline static constexpr auto invoke(R T::*pmf, Arg &&arg, Args &&... args)
            MPARK_RETURN(((*lib::forward<Arg>(arg)).*pmf)(lib::forward<Args>(args)...))
        };

        template <>
        struct Invoke<false /* pmo */, 0 /* is_base_of */> {
          template <typename R, typename T, typename Arg>
          inline static constexpr auto invoke(R T::*pmo, Arg &&arg)
            MPARK_RETURN(lib::forward<Arg>(arg).*pmo)
        };

        template <>
        struct Invoke<false /* pmo */, 1 /* is_reference_wrapper */> {
          template <typename R, typename T, typename Arg>
          inline static constexpr auto invoke(R T::*pmo, Arg &&arg)
            MPARK_RETURN(lib::forward<Arg>(arg).get().*pmo)
        };

        template <>
        struct Invoke<false /* pmo */, 2 /* otherwise */> {
          template <typename R, typename T, typename Arg>
          inline static constexpr auto invoke(R T::*pmo, Arg &&arg)
              MPARK_RETURN((*lib::forward<Arg>(arg)).*pmo)
        };

        template <typename R, typename T, typename Arg, typename... Args>
        inline constexpr auto invoke(R T::*f, Arg &&arg, Args &&... args)
          MPARK_RETURN(
              Invoke<std::is_function<R>::value,
                     (std::is_base_of<T, lib::decay_t<Arg>>::value
                          ? 0
                          : is_reference_wrapper<lib::decay_t<Arg>>::value
                                ? 1
                                : 2)>::invoke(f,
                                              lib::forward<Arg>(arg),
                                              lib::forward<Args>(args)...))

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4100)
#endif
        template <typename F, typename... Args>
        inline constexpr auto invoke(F &&f, Args &&... args)
          MPARK_RETURN(lib::forward<F>(f)(lib::forward<Args>(args)...))
#ifdef _MSC_VER
#pragma warning(pop)
#endif
      }  // namespace detail

      template <typename F, typename... Args>
      inline constexpr auto invoke(F &&f, Args &&... args)
        MPARK_RETURN(detail::invoke(lib::forward<F>(f),
                                    lib::forward<Args>(args)...))

      namespace detail {

        template <typename Void, typename, typename...>
        struct invoke_result {};

        template <typename F, typename... Args>
        struct invoke_result<void_t<decltype(lib::invoke(
                                 std::declval<F>(), std::declval<Args>()...))>,
                             F,
                             Args...>
            : identity<decltype(
                  lib::invoke(std::declval<F>(), std::declval<Args>()...))> {};

      }  // namespace detail

      template <typename F, typename... Args>
      using invoke_result = detail::invoke_result<void, F, Args...>;

      template <typename F, typename... Args>
      using invoke_result_t = typename invoke_result<F, Args...>::type;

      namespace detail {

        template <typename Void, typename, typename...>
        struct is_invocable : std::false_type {};

        template <typename F, typename... Args>
        struct is_invocable<void_t<invoke_result_t<F, Args...>>, F, Args...>
            : std::true_type {};

        template <typename Void, typename, typename, typename...>
        struct is_invocable_r : std::false_type {};

        template <typename R, typename F, typename... Args>
        struct is_invocable_r<void_t<invoke_result_t<F, Args...>>,
                              R,
                              F,
                              Args...>
            : std::is_convertible<invoke_result_t<F, Args...>, R> {};

      }  // namespace detail

      template <typename F, typename... Args>
      using is_invocable = detail::is_invocable<void, F, Args...>;

      template <typename R, typename F, typename... Args>
      using is_invocable_r = detail::is_invocable_r<void, R, F, Args...>;

      // <memory>
#ifdef MPARK_BUILTIN_ADDRESSOF
      template <typename T>
      inline constexpr T *addressof(T &arg) noexcept {
        return __builtin_addressof(arg);
      }
#else
      namespace detail {

        namespace has_addressof_impl {

          struct fail;

          template <typename T>
          inline fail operator&(T &&);

          template <typename T>
          inline static constexpr bool impl() {
            return (std::is_class<T>::value || std::is_union<T>::value) &&
                   !std::is_same<decltype(&std::declval<T &>()), fail>::value;
          }

        }  // namespace has_addressof_impl

        template <typename T>
        using has_addressof = bool_constant<has_addressof_impl::impl<T>()>;

        template <typename T>
        inline constexpr T *addressof(T &arg, std::true_type) noexcept {
          return std::addressof(arg);
        }

        template <typename T>
        inline constexpr T *addressof(T &arg, std::false_type) noexcept {
          return &arg;
        }

      }  // namespace detail

      template <typename T>
      inline constexpr T *addressof(T &arg) noexcept {
        return detail::addressof(arg, detail::has_addressof<T>{});
      }
#endif

      template <typename T>
      inline constexpr T *addressof(const T &&) = delete;

    }  // namespace cpp17

    template <typename T>
    struct remove_all_extents : identity<T> {};

    template <typename T, std::size_t N>
    struct remove_all_extents<array<T, N>> : remove_all_extents<T> {};

    template <typename T>
    using remove_all_extents_t = typename remove_all_extents<T>::type;

    template <std::size_t N>
    using size_constant = std::integral_constant<std::size_t, N>;

    template <std::size_t I, typename T>
    struct indexed_type : size_constant<I> { using type = T; };

    template <bool... Bs>
    using all = std::is_same<integer_sequence<bool, true, Bs...>,
                             integer_sequence<bool, Bs..., true>>;

#ifdef MPARK_TYPE_PACK_ELEMENT
    template <std::size_t I, typename... Ts>
    using type_pack_element_t = __type_pack_element<I, Ts...>;
#else
    template <std::size_t I, typename... Ts>
    struct type_pack_element_impl {
      private:
      template <typename>
      struct set;

      template <std::size_t... Is>
      struct set<index_sequence<Is...>> : indexed_type<Is, Ts>... {};

      template <typename T>
      inline static std::enable_if<true, T> impl(indexed_type<I, T>);

      inline static std::enable_if<false> impl(...);

      public:
      using type = decltype(impl(set<index_sequence_for<Ts...>>{}));
    };

    template <std::size_t I, typename... Ts>
    using type_pack_element = typename type_pack_element_impl<I, Ts...>::type;

    template <std::size_t I, typename... Ts>
    using type_pack_element_t = typename type_pack_element<I, Ts...>::type;
#endif

#ifdef MPARK_TRIVIALITY_TYPE_TRAITS
    using std::is_trivially_copy_constructible;
    using std::is_trivially_move_constructible;
    using std::is_trivially_copy_assignable;
    using std::is_trivially_move_assignable;
#else
    template <typename T>
    struct is_trivially_copy_constructible
        : bool_constant<
              std::is_copy_constructible<T>::value && __has_trivial_copy(T)> {};

    template <typename T>
    struct is_trivially_move_constructible : bool_constant<__is_trivial(T)> {};

    template <typename T>
    struct is_trivially_copy_assignable
        : bool_constant<
              std::is_copy_assignable<T>::value && __has_trivial_assign(T)> {};

    template <typename T>
    struct is_trivially_move_assignable : bool_constant<__is_trivial(T)> {};
#endif

    template <typename T, bool>
    struct dependent_type : T {};

    template <typename Is, std::size_t J>
    struct push_back;

    template <typename Is, std::size_t J>
    using push_back_t = typename push_back<Is, J>::type;

    template <std::size_t... Is, std::size_t J>
    struct push_back<index_sequence<Is...>, J> {
      using type = index_sequence<Is..., J>;
    };

  }  // namespace lib
}  // namespace mpark

#undef MPARK_RETURN

#endif  // MPARK_LIB_HPP

```

`Plugins/Developer/RiderLink/Source/RD/thirdparty/variant/include/mpark/variant.hpp`:

```hpp
// MPark.Variant
//
// Copyright Michael Park, 2015-2017
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)

#ifndef MPARK_VARIANT_HPP
#define MPARK_VARIANT_HPP

/*
   variant synopsis

namespace std {

  // 20.7.2, class template variant
  template <class... Types>
  class variant {
  public:

    // 20.7.2.1, constructors
    constexpr variant() noexcept(see below);
    variant(const variant&);
    variant(variant&&) noexcept(see below);

    template <class T> constexpr variant(T&&) noexcept(see below);

    template <class T, class... Args>
    constexpr explicit variant(in_place_type_t<T>, Args&&...);

    template <class T, class U, class... Args>
    constexpr explicit variant(
        in_place_type_t<T>, initializer_list<U>, Args&&...);

    template <size_t I, class... Args>
    constexpr explicit variant(in_place_index_t<I>, Args&&...);

    template <size_t I, class U, class... Args>
    constexpr explicit variant(
        in_place_index_t<I>, initializer_list<U>, Args&&...);

    // 20.7.2.2, destructor
    ~variant();

    // 20.7.2.3, assignment
    variant& operator=(const variant&);
    variant& operator=(variant&&) noexcept(see below);

    template <class T> variant& operator=(T&&) noexcept(see below);

    // 20.7.2.4, modifiers
    template <class T, class... Args>
    T& emplace(Args&&...);

    template <class T, class U, class... Args>
    T& emplace(initializer_list<U>, Args&&...);

    template <size_t I, class... Args>
    variant_alternative<I, variant>& emplace(Args&&...);

    template <size_t I, class U, class...  Args>
    variant_alternative<I, variant>& emplace(initializer_list<U>, Args&&...);

    // 20.7.2.5, value status
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;

    // 20.7.2.6, swap
    void swap(variant&) noexcept(see below);
  };

  // 20.7.3, variant helper classes
  template <class T> struct variant_size; // undefined

  template <class T>
  constexpr size_t variant_size_v = variant_size<T>::value;

  template <class T> struct variant_size<const T>;
  template <class T> struct variant_size<volatile T>;
  template <class T> struct variant_size<const volatile T>;

  template <class... Types>
  struct variant_size<variant<Types...>>;

  template <size_t I, class T> struct variant_alternative; // undefined

  template <size_t I, class T>
  using variant_alternative_t = typename variant_alternative<I, T>::type;

  template <size_t I, class T> struct variant_alternative<I, const T>;
  template <size_t I, class T> struct variant_alternative<I, volatile T>;
  template <size_t I, class T> struct variant_alternative<I, const volatile T>;

  template <size_t I, class... Types>
  struct variant_alternative<I, variant<Types...>>;

  constexpr size_t variant_npos = -1;

  // 20.7.4, value access
  template <class T, class... Types>
  constexpr bool holds_alternative(const variant<Types...>&) noexcept;

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>>&
  get(variant<Types...>&);

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>>&&
  get(variant<Types...>&&);

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>> const&
  get(const variant<Types...>&);

  template <size_t I, class... Types>
  constexpr variant_alternative_t<I, variant<Types...>> const&&
  get(const variant<Types...>&&);

  template <class T, class...  Types>
  constexpr T& get(variant<Types...>&);

  template <class T, class... Types>
  constexpr T&& get(variant<Types...>&&);

  template <class T, class... Types>
  constexpr const T& get(const variant<Types...>&);

  template <class T, class... Types>
  constexpr const T&& get(const variant<Types...>&&);

  template <size_t I, class... Types>
  constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
  get_if(variant<Types...>*) noexcept;

  template <size_t I, class... Types>
  constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
  get_if(const variant<Types...>*) noexcept;

  template <class T, class... Types>
  constexpr add_pointer_t<T>
  get_if(variant<Types...>*) noexcept;

  template <class T, class... Types>
  constexpr add_pointer_t<const T>
  get_if(const variant<Types...>*) noexcept;

  // 20.7.5, relational operators
  template <class... Types>
  constexpr bool operator==(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator!=(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator<(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator>(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator<=(const variant<Types...>&, const variant<Types...>&);

  template <class... Types>
  constexpr bool operator>=(const variant<Types...>&, const variant<Types...>&);

  // 20.7.6, visitation
  template <class Visitor, class... Variants>
  constexpr see below visit(Visitor&&, Variants&&...);

  // 20.7.7, class monostate
  struct monostate;

  // 20.7.8, monostate relational operators
  constexpr bool operator<(monostate, monostate) noexcept;
  constexpr bool operator>(monostate, monostate) noexcept;
  constexpr bool operator<=(monostate, monostate) noexcept;
  constexpr bool operator>=(monostate, monostate) noexcept;
  constexpr bool operator==(monostate, monostate) noexcept;
  constexpr bool operator!=(monostate, monostate) noexcept;

  // 20.7.9, specialized algorithms
  template <class... Types>
  void swap(variant<Types...>&, variant<Types...>&) noexcept(see below);

  // 20.7.10, class bad_variant_access
  class bad_variant_access;

  // 20.7.11, hash support
  template <class T> struct hash;
  template <class... Types> struct hash<variant<Types...>>;
  template <> struct hash<monostate>;

} // namespace std

*/

#include <cstddef>
#include <exception>
#include <functional>
#include <initializer_list>
#include <limits>
#include <new>
#include <type_traits>
#include <utility>

#include "config.hpp"
#include "in_place.hpp"
#include "lib.hpp"

namespace mpark {

#ifdef MPARK_RETURN_TYPE_DEDUCTION

#define AUTO auto
#define AUTO_RETURN(...) { return __VA_ARGS__; }

#define AUTO_REFREF auto &&
#define AUTO_REFREF_RETURN(...) { return __VA_ARGS__; }

#define DECLTYPE_AUTO decltype(auto)
#define DECLTYPE_AUTO_RETURN(...) { return __VA_ARGS__; }

#else

#define AUTO auto
#define AUTO_RETURN(...) \
  -> lib::decay_t<decltype(__VA_ARGS__)> { return __VA_ARGS__; }

#define AUTO_REFREF auto
#define AUTO_REFREF_RETURN(...)                                           \
  -> decltype((__VA_ARGS__)) {                                            \
    static_assert(std::is_reference<decltype((__VA_ARGS__))>::value, ""); \
    return __VA_ARGS__;                                                   \
  }

#define DECLTYPE_AUTO auto
#define DECLTYPE_AUTO_RETURN(...) \
  -> decltype(__VA_ARGS__) { return __VA_ARGS__; }

#endif

  class bad_variant_access : public std::exception {
    public:
    virtual const char *what() const noexcept override { return "bad_variant_access"; }
  };

  [[noreturn]] inline void throw_bad_variant_access() {
#ifdef MPARK_EXCEPTIONS
    throw bad_variant_access{};
#else
    std::terminate();
    MPARK_BUILTIN_UNREACHABLE;
#endif
  }

  template <typename... Ts>
  class variant;

  template <typename T>
  struct variant_size;

#ifdef MPARK_VARIABLE_TEMPLATES
  template <typename T>
  constexpr std::size_t variant_size_v = variant_size<T>::value;
#endif

  template <typename T>
  struct variant_size<const T> : variant_size<T> {};

  template <typename T>
  struct variant_size<volatile T> : variant_size<T> {};

  template <typename T>
  struct variant_size<const volatile T> : variant_size<T> {};

  template <typename... Ts>
  struct variant_size<variant<Ts...>> : lib::size_constant<sizeof...(Ts)> {};

  template <std::size_t I, typename T>
  struct variant_alternative;

  template <std::size_t I, typename T>
  using variant_alternative_t = typename variant_alternative<I, T>::type;

  template <std::size_t I, typename T>
  struct variant_alternative<I, const T>
      : std::add_const<variant_alternative_t<I, T>> {};

  template <std::size_t I, typename T>
  struct variant_alternative<I, volatile T>
      : std::add_volatile<variant_alternative_t<I, T>> {};

  template <std::size_t I, typename T>
  struct variant_alternative<I, const volatile T>
      : std::add_cv<variant_alternative_t<I, T>> {};

  template <std::size_t I, typename... Ts>
  struct variant_alternative<I, variant<Ts...>> {
    static_assert(I < sizeof...(Ts),
                  "index out of bounds in `std::variant_alternative<>`");
    using type = lib::type_pack_element_t<I, Ts...>;
  };

  constexpr std::size_t variant_npos = static_cast<std::size_t>(-1);

  namespace detail {

    constexpr std::size_t not_found = static_cast<std::size_t>(-1);
    constexpr std::size_t ambiguous = static_cast<std::size_t>(-2);

#ifdef MPARK_CPP14_CONSTEXPR
    template <typename T, typename... Ts>
    inline constexpr std::size_t find_index() {
      constexpr lib::array<bool, sizeof...(Ts)> matches = {
          {std::is_same<T, Ts>::value...}
      };
      std::size_t result = not_found;
      for (std::size_t i = 0; i < sizeof...(Ts); ++i) {
        if (matches[i]) {
          if (result != not_found) {
            return ambiguous;
          }
          result = i;
        }
      }
      return result;
    }
#else
    inline constexpr std::size_t find_index_impl(std::size_t result,
                                                 std::size_t) {
      return result;
    }

    template <typename... Bs>
    inline constexpr std::size_t find_index_impl(std::size_t result,
                                                 std::size_t idx,
                                                 bool b,
                                                 Bs... bs) {
      return b ? (result != not_found ? ambiguous
                                      : find_index_impl(idx, idx + 1, bs...))
               : find_index_impl(result, idx + 1, bs...);
    }

    template <typename T, typename... Ts>
    inline constexpr std::size_t find_index() {
      return find_index_impl(not_found, 0, std::is_same<T, Ts>::value...);
    }
#endif

    template <std::size_t I>
    using find_index_sfinae_impl =
        lib::enable_if_t<I != not_found && I != ambiguous,
                         lib::size_constant<I>>;

    template <typename T, typename... Ts>
    using find_index_sfinae = find_index_sfinae_impl<find_index<T, Ts...>()>;

    template <std::size_t I>
    struct find_index_checked_impl : lib::size_constant<I> {
      static_assert(I != not_found, "the specified type is not found.");
      static_assert(I != ambiguous, "the specified type is ambiguous.");
    };

    template <typename T, typename... Ts>
    using find_index_checked = find_index_checked_impl<find_index<T, Ts...>()>;

    struct valueless_t {};

    enum class Trait { TriviallyAvailable, Available, Unavailable };

    template <typename T,
              template <typename> class IsTriviallyAvailable,
              template <typename> class IsAvailable>
    inline constexpr Trait trait() {
      return IsTriviallyAvailable<T>::value
                 ? Trait::TriviallyAvailable
                 : IsAvailable<T>::value ? Trait::Available
                                         : Trait::Unavailable;
    }

#ifdef MPARK_CPP14_CONSTEXPR
    template <typename... Traits>
    inline constexpr Trait common_trait(Traits... traits_) {
      Trait result = Trait::TriviallyAvailable;
      lib::array<Trait, sizeof...(Traits)> traits = {{traits_...}};
      for (std::size_t i = 0; i < sizeof...(Traits); ++i) {
        Trait t = traits[i];
        if (static_cast<int>(t) > static_cast<int>(result)) {
          result = t;
        }
      }
      return result;
    }
#else
    inline constexpr Trait common_trait_impl(Trait result) { return result; }

    template <typename... Traits>
    inline constexpr Trait common_trait_impl(Trait result,
                                             Trait t,
                                             Traits... ts) {
      return static_cast<int>(t) > static_cast<int>(result)
                 ? common_trait_impl(t, ts...)
                 : common_trait_impl(result, ts...);
    }

    template <typename... Traits>
    inline constexpr Trait common_trait(Traits... ts) {
      return common_trait_impl(Trait::TriviallyAvailable, ts...);
    }
#endif

    template <typename... Ts>
    struct traits {
      static constexpr Trait copy_constructible_trait =
          common_trait(trait<Ts,
                             lib::is_trivially_copy_constructible,
                             std::is_copy_constructible>()...);

      static constexpr Trait move_constructible_trait =
          common_trait(trait<Ts,
                             lib::is_trivially_move_constructible,
                             std::is_move_constructible>()...);

      static constexpr Trait copy_assignable_trait =
          common_trait(copy_constructible_trait,
                       trait<Ts,
                             lib::is_trivially_copy_assignable,
                             std::is_copy_assignable>()...);

      static constexpr Trait move_assignable_trait =
          common_trait(move_constructible_trait,
                       trait<Ts,
                             lib::is_trivially_move_assignable,
                             std::is_move_assignable>()...);

      static constexpr Trait destructible_trait =
          common_trait(trait<Ts,
                             std::is_trivially_destructible,
                             std::is_destructible>()...);
    };

    namespace access {

      struct recursive_union {
#ifdef MPARK_RETURN_TYPE_DEDUCTION
        template <typename V>
        inline static constexpr auto &&get_alt(V &&v, in_place_index_t<0>) {
          return lib::forward<V>(v).head_;
        }

        template <typename V, std::size_t I>
        inline static constexpr auto &&get_alt(V &&v, in_place_index_t<I>) {
          return get_alt(lib::forward<V>(v).tail_, in_place_index_t<I - 1>{});
        }
#else
        template <std::size_t I, bool Dummy = true>
        struct get_alt_impl {
          template <typename V>
          inline constexpr AUTO_REFREF operator()(V &&v) const
            AUTO_REFREF_RETURN(get_alt_impl<I - 1>{}(lib::forward<V>(v).tail_))
        };

        template <bool Dummy>
        struct get_alt_impl<0, Dummy> {
          template <typename V>
          inline constexpr AUTO_REFREF operator()(V &&v) const
            AUTO_REFREF_RETURN(lib::forward<V>(v).head_)
        };

        template <typename V, std::size_t I>
        inline static constexpr AUTO_REFREF get_alt(V &&v, in_place_index_t<I>)
          AUTO_REFREF_RETURN(get_alt_impl<I>{}(lib::forward<V>(v)))
#endif
      };

      struct base {
        template <std::size_t I, typename V>
        inline static constexpr AUTO_REFREF get_alt(V &&v)
#ifdef _MSC_VER
          AUTO_REFREF_RETURN(recursive_union::get_alt(
              lib::forward<V>(v).data_, in_place_index_t<I>{}))
#else
          AUTO_REFREF_RETURN(recursive_union::get_alt(
              data(lib::forward<V>(v)), in_place_index_t<I>{}))
#endif
      };

      struct variant {
        template <std::size_t I, typename V>
        inline static constexpr AUTO_REFREF get_alt(V &&v)
          AUTO_REFREF_RETURN(base::get_alt<I>(lib::forward<V>(v).impl_))
      };

    }  // namespace access

    namespace visitation {

#if defined(MPARK_CPP14_CONSTEXPR) && !defined(_MSC_VER)
#define MPARK_VARIANT_SWITCH_VISIT
#endif

      struct base {
        template <typename Visitor, typename... Vs>
        using dispatch_result_t = decltype(
            lib::invoke(std::declval<Visitor>(),
                        access::base::get_alt<0>(std::declval<Vs>())...));

        template <typename Expected>
        struct expected {
          template <typename Actual>
          inline static constexpr bool but_got() {
            return std::is_same<Expected, Actual>::value;
          }
        };

        template <typename Expected, typename Actual>
        struct visit_return_type_check {
          static_assert(
              expected<Expected>::template but_got<Actual>(),
              "`visit` requires the visitor to have a single return type");

          template <typename Visitor, typename... Alts>
          inline static constexpr DECLTYPE_AUTO invoke(Visitor &&visitor,
                                                       Alts &&... alts)
            DECLTYPE_AUTO_RETURN(lib::invoke(lib::forward<Visitor>(visitor),
                                             lib::forward<Alts>(alts)...))
        };

#ifdef MPARK_VARIANT_SWITCH_VISIT
        template <bool B, typename R, typename... ITs>
        struct dispatcher;

        template <typename R, typename... ITs>
        struct dispatcher<false, R, ITs...> {
          template <std::size_t B, typename F, typename... Vs>
          MPARK_ALWAYS_INLINE static constexpr R dispatch(
              F &&, typename ITs::type &&..., Vs &&...) {
            MPARK_BUILTIN_UNREACHABLE;
          }

          template <std::size_t I, typename F, typename... Vs>
          MPARK_ALWAYS_INLINE static constexpr R dispatch_case(F &&, Vs &&...) {
            MPARK_BUILTIN_UNREACHABLE;
          }

          template <std::size_t B, typename F, typename... Vs>
          MPARK_ALWAYS_INLINE static constexpr R dispatch_at(std::size_t,
                                                             F &&,
                                                             Vs &&...) {
            MPARK_BUILTIN_UNREACHABLE;
          }
        };

        template <typename R, typename... ITs>
        struct dispatcher<true, R, ITs...> {
          template <std::size_t B, typename F>
          MPARK_ALWAYS_INLINE static constexpr R dispatch(
              F &&f, typename ITs::type &&... visited_vs) {
            using Expected = R;
            using Actual = decltype(lib::invoke(
                lib::forward<F>(f),
                access::base::get_alt<ITs::value>(
                    lib::forward<typename ITs::type>(visited_vs))...));
            return visit_return_type_check<Expected, Actual>::invoke(
                lib::forward<F>(f),
                access::base::get_alt<ITs::value>(
                    lib::forward<typename ITs::type>(visited_vs))...);
          }

          template <std::size_t B, typename F, typename V, typename... Vs>
          MPARK_ALWAYS_INLINE static constexpr R dispatch(
              F &&f, typename ITs::type &&... visited_vs, V &&v, Vs &&... vs) {
#define MPARK_DISPATCH(I)                                                   \
  dispatcher<(I < lib::decay_t<V>::size()),                                 \
             R,                                                             \
             ITs...,                                                        \
             lib::indexed_type<I, V>>::                                     \
      template dispatch<0>(lib::forward<F>(f),                              \
                           lib::forward<typename ITs::type>(visited_vs)..., \
                           lib::forward<V>(v),                              \
                           lib::forward<Vs>(vs)...)

#define MPARK_DEFAULT(I)                                                      \
  dispatcher<(I < lib::decay_t<V>::size()), R, ITs...>::template dispatch<I>( \
      lib::forward<F>(f),                                                     \
      lib::forward<typename ITs::type>(visited_vs)...,                        \
      lib::forward<V>(v),                                                     \
      lib::forward<Vs>(vs)...)

            switch (v.index()) {
              case B + 0: return MPARK_DISPATCH(B + 0);
              case B + 1: return MPARK_DISPATCH(B + 1);
              case B + 2: return MPARK_DISPATCH(B + 2);
              case B + 3: return MPARK_DISPATCH(B + 3);
              case B + 4: return MPARK_DISPATCH(B + 4);
              case B + 5: return MPARK_DISPATCH(B + 5);
              case B + 6: return MPARK_DISPATCH(B + 6);
              case B + 7: return MPARK_DISPATCH(B + 7);
              case B + 8: return MPARK_DISPATCH(B + 8);
              case B + 9: return MPARK_DISPATCH(B + 9);
              case B + 10: return MPARK_DISPATCH(B + 10);
              case B + 11: return MPARK_DISPATCH(B + 11);
              case B + 12: return MPARK_DISPATCH(B + 12);
              case B + 13: return MPARK_DISPATCH(B + 13);
              case B + 14: return MPARK_DISPATCH(B + 14);
              case B + 15: return MPARK_DISPATCH(B + 15);
              case B + 16: return MPARK_DISPATCH(B + 16);
              case B + 17: return MPARK_DISPATCH(B + 17);
              case B + 18: return MPARK_DISPATCH(B + 18);
              case B + 19: return MPARK_DISPATCH(B + 19);
              case B + 20: return MPARK_DISPATCH(B + 20);
              case B + 21: return MPARK_DISPATCH(B + 21);
              case B + 22: return MPARK_DISPATCH(B + 22);
              case B + 23: return MPARK_DISPATCH(B + 23);
              case B + 24: return MPARK_DISPATCH(B + 24);
              case B + 25: return MPARK_DISPATCH(B + 25);
              case B + 26: return MPARK_DISPATCH(B + 26);
              case B + 27: return MPARK_DISPATCH(B + 27);
              case B + 28: return MPARK_DISPATCH(B + 28);
              case B + 29: return MPARK_DISPATCH(B + 29);
              case B + 30: return MPARK_DISPATCH(B + 30);
              case B + 31: return MPARK_DISPATCH(B + 31);
              default: return MPARK_DEFAULT(B + 32);
            }

#undef MPARK_DEFAULT
#undef MPARK_DISPATCH
          }

          template <std::size_t I, typename F, typename... Vs>
          MPARK_ALWAYS_INLINE static constexpr R dispatch_case(F &&f,
                                                               Vs &&... vs) {
            using Expected = R;
            using Actual = decltype(
                lib::invoke(lib::forward<F>(f),
                            access::base::get_alt<I>(lib::forward<Vs>(vs))...));
            return visit_return_type_check<Expected, Actual>::invoke(
                lib::forward<F>(f),
                access::base::get_alt<I>(lib::forward<Vs>(vs))...);
          }

          template <std::size_t B, typename F, typename V, typename... Vs>
          MPARK_ALWAYS_INLINE static constexpr R dispatch_at(std::size_t index,
                                                             F &&f,
                                                             V &&v,
                                                             Vs &&... vs) {
            static_assert(lib::all<(lib::decay_t<V>::size() ==
                                    lib::decay_t<Vs>::size())...>::value,
                          "all of the variants must be the same size.");
#define MPARK_DISPATCH_AT(I)                                               \
  dispatcher<(I < lib::decay_t<V>::size()), R>::template dispatch_case<I>( \
      lib::forward<F>(f), lib::forward<V>(v), lib::forward<Vs>(vs)...)

#define MPARK_DEFAULT(I)                                                 \
  dispatcher<(I < lib::decay_t<V>::size()), R>::template dispatch_at<I>( \
      index, lib::forward<F>(f), lib::forward<V>(v), lib::forward<Vs>(vs)...)

            switch (index) {
              case B + 0: return MPARK_DISPATCH_AT(B + 0);
              case B + 1: return MPARK_DISPATCH_AT(B + 1);
              case B + 2: return MPARK_DISPATCH_AT(B + 2);
              case B + 3: return MPARK_DISPATCH_AT(B + 3);
              case B + 4: return MPARK_DISPATCH_AT(B + 4);
              case B + 5: return MPARK_DISPATCH_AT(B + 5);
              case B + 6: return MPARK_DISPATCH_AT(B + 6);
              case B + 7: return MPARK_DISPATCH_AT(B + 7);
              case B + 8: return MPARK_DISPATCH_AT(B + 8);
              case B + 9: return MPARK_DISPATCH_AT(B + 9);
              case B + 10: return MPARK_DISPATCH_AT(B + 10);
              case B + 11: return MPARK_DISPATCH_AT(B + 11);
              case B + 12: return MPARK_DISPATCH_AT(B + 12);
              case B + 13: return MPARK_DISPATCH_AT(B + 13);
              case B + 14: return MPARK_DISPATCH_AT(B + 14);
              case B + 15: return MPARK_DISPATCH_AT(B + 15);
              case B + 16: return MPARK_DISPATCH_AT(B + 16);
              case B + 17: return MPARK_DISPATCH_AT(B + 17);
              case B + 18: return MPARK_DISPATCH_AT(B + 18);
              case B + 19: return MPARK_DISPATCH_AT(B + 19);
              case B + 20: return MPARK_DISPATCH_AT(B + 20);
              case B + 21: return MPARK_DISPATCH_AT(B + 21);
              case B + 22: return MPARK_DISPATCH_AT(B + 22);
              case B + 23: return MPARK_DISPATCH_AT(B + 23);
              case B + 24: return MPARK_DISPATCH_AT(B + 24);
              case B + 25: return MPARK_DISPATCH_AT(B + 25);
              case B + 26: return MPARK_DISPATCH_AT(B + 26);
              case B + 27: return MPARK_DISPATCH_AT(B + 27);
              case B + 28: return MPARK_DISPATCH_AT(B + 28);
              case B + 29: return MPARK_DISPATCH_AT(B + 29);
              case B + 30: return MPARK_DISPATCH_AT(B + 30);
              case B + 31: return MPARK_DISPATCH_AT(B + 31);
              default: return MPARK_DEFAULT(B + 32);
            }

#undef MPARK_DEFAULT
#undef MPARK_DISPATCH_AT
          }
        };
#else
        template <typename T>
        inline static constexpr const T &at(const T &elem) noexcept {
          return elem;
        }

        template <typename T, std::size_t N, typename... Is>
        inline static constexpr const lib::remove_all_extents_t<T> &at(
            const lib::array<T, N> &elems, std::size_t i, Is... is) noexcept {
          return at(elems[i], is...);
        }

        template <typename F, typename... Fs>
        inline static constexpr lib::array<lib::decay_t<F>, sizeof...(Fs) + 1>
        make_farray(F &&f, Fs &&... fs) {
          return {{lib::forward<F>(f), lib::forward<Fs>(fs)...}};
        }

        template <typename F, typename... Vs>
        struct make_fmatrix_impl {

          template <std::size_t... Is>
          inline static constexpr dispatch_result_t<F, Vs...> dispatch(
              F &&f, Vs &&... vs) {
            using Expected = dispatch_result_t<F, Vs...>;
            using Actual = decltype(lib::invoke(
                lib::forward<F>(f),
                access::base::get_alt<Is>(lib::forward<Vs>(vs))...));
            return visit_return_type_check<Expected, Actual>::invoke(
                lib::forward<F>(f),
                access::base::get_alt<Is>(lib::forward<Vs>(vs))...);
          }

#ifdef MPARK_RETURN_TYPE_DEDUCTION
          template <std::size_t... Is>
          inline static constexpr auto impl(lib::index_sequence<Is...>) {
            return &dispatch<Is...>;
          }

          template <typename Is, std::size_t... Js, typename... Ls>
          inline static constexpr auto impl(Is,
                                            lib::index_sequence<Js...>,
                                            Ls... ls) {
            return make_farray(impl(lib::push_back_t<Is, Js>{}, ls...)...);
          }
#else
          template <typename...>
          struct impl;

          template <std::size_t... Is>
          struct impl<lib::index_sequence<Is...>> {
            inline constexpr AUTO operator()() const
              AUTO_RETURN(&dispatch<Is...>)
          };

          template <typename Is, std::size_t... Js, typename... Ls>
          struct impl<Is, lib::index_sequence<Js...>, Ls...> {
            inline constexpr AUTO operator()() const
              AUTO_RETURN(
                  make_farray(impl<lib::push_back_t<Is, Js>, Ls...>{}()...))
          };
#endif
        };

#ifdef MPARK_RETURN_TYPE_DEDUCTION
        template <typename F, typename... Vs>
        inline static constexpr auto make_fmatrix() {
          return make_fmatrix_impl<F, Vs...>::impl(
              lib::index_sequence<>{},
              lib::make_index_sequence<lib::decay_t<Vs>::size()>{}...);
        }
#else
        template <typename F, typename... Vs>
        inline static constexpr AUTO make_fmatrix()
          AUTO_RETURN(
              typename make_fmatrix_impl<F, Vs...>::template impl<
                  lib::index_sequence<>,
                  lib::make_index_sequence<lib::decay_t<Vs>::size()>...>{}())
#endif

        template <typename F, typename... Vs>
        struct make_fdiagonal_impl {
          template <std::size_t I>
          inline static constexpr dispatch_result_t<F, Vs...> dispatch(
              F &&f, Vs &&... vs) {
            using Expected = dispatch_result_t<F, Vs...>;
            using Actual = decltype(
                lib::invoke(lib::forward<F>(f),
                            access::base::get_alt<I>(lib::forward<Vs>(vs))...));
            return visit_return_type_check<Expected, Actual>::invoke(
                lib::forward<F>(f),
                access::base::get_alt<I>(lib::forward<Vs>(vs))...);
          }

          template <std::size_t... Is>
          inline static constexpr AUTO impl(lib::index_sequence<Is...>)
            AUTO_RETURN(make_farray(&dispatch<Is>...))
        };

        template <typename F, typename V, typename... Vs>
        inline static constexpr auto make_fdiagonal()
            -> decltype(make_fdiagonal_impl<F, V, Vs...>::impl(
                lib::make_index_sequence<lib::decay_t<V>::size()>{})) {
          static_assert(lib::all<(lib::decay_t<V>::size() ==
                                  lib::decay_t<Vs>::size())...>::value,
                        "all of the variants must be the same size.");
          return make_fdiagonal_impl<F, V, Vs...>::impl(
              lib::make_index_sequence<lib::decay_t<V>::size()>{});
        }
#endif
      };

#if !defined(MPARK_VARIANT_SWITCH_VISIT) && \
    (!defined(_MSC_VER) || _MSC_VER >= 1910)
      template <typename F, typename... Vs>
      using fmatrix_t = decltype(base::make_fmatrix<F, Vs...>());

      template <typename F, typename... Vs>
      struct fmatrix {
        static constexpr fmatrix_t<F, Vs...> value =
            base::make_fmatrix<F, Vs...>();
      };

      template <typename F, typename... Vs>
      constexpr fmatrix_t<F, Vs...> fmatrix<F, Vs...>::value;

      template <typename F, typename... Vs>
      using fdiagonal_t = decltype(base::make_fdiagonal<F, Vs...>());

      template <typename F, typename... Vs>
      struct fdiagonal {
        static constexpr fdiagonal_t<F, Vs...> value =
            base::make_fdiagonal<F, Vs...>();
      };

      template <typename F, typename... Vs>
      constexpr fdiagonal_t<F, Vs...> fdiagonal<F, Vs...>::value;
#endif

      struct alt {
        template <typename Visitor, typename... Vs>
        inline static constexpr DECLTYPE_AUTO visit_alt(Visitor &&visitor,
                                                        Vs &&... vs)
#ifdef MPARK_VARIANT_SWITCH_VISIT
          DECLTYPE_AUTO_RETURN(
              base::dispatcher<
                  true,
                  base::dispatch_result_t<Visitor,
                                          decltype(as_base(
                                              lib::forward<Vs>(vs)))...>>::
                  template dispatch<0>(lib::forward<Visitor>(visitor),
                                       as_base(lib::forward<Vs>(vs))...))
#elif !defined(_MSC_VER) || _MSC_VER >= 1910
          DECLTYPE_AUTO_RETURN(base::at(
              fmatrix<Visitor &&,
                      decltype(as_base(lib::forward<Vs>(vs)))...>::value,
              vs.index()...)(lib::forward<Visitor>(visitor),
                             as_base(lib::forward<Vs>(vs))...))
#else
          DECLTYPE_AUTO_RETURN(base::at(
              base::make_fmatrix<Visitor &&,
                      decltype(as_base(lib::forward<Vs>(vs)))...>(),
              vs.index()...)(lib::forward<Visitor>(visitor),
                             as_base(lib::forward<Vs>(vs))...))
#endif

        template <typename Visitor, typename... Vs>
        inline static constexpr DECLTYPE_AUTO visit_alt_at(std::size_t index,
                                                           Visitor &&visitor,
                                                           Vs &&... vs)
#ifdef MPARK_VARIANT_SWITCH_VISIT
          DECLTYPE_AUTO_RETURN(
              base::dispatcher<
                  true,
                  base::dispatch_result_t<Visitor,
                                          decltype(as_base(
                                              lib::forward<Vs>(vs)))...>>::
                  template dispatch_at<0>(index,
                                          lib::forward<Visitor>(visitor),
                                          as_base(lib::forward<Vs>(vs))...))
#elif !defined(_MSC_VER) || _MSC_VER >= 1910
          DECLTYPE_AUTO_RETURN(base::at(
              fdiagonal<Visitor &&,
                        decltype(as_base(lib::forward<Vs>(vs)))...>::value,
              index)(lib::forward<Visitor>(visitor),
                     as_base(lib::forward<Vs>(vs))...))
#else
          DECLTYPE_AUTO_RETURN(base::at(
              base::make_fdiagonal<Visitor &&,
                        decltype(as_base(lib::forward<Vs>(vs)))...>(),
              index)(lib::forward<Visitor>(visitor),
                     as_base(lib::forward<Vs>(vs))...))
#endif
      };

      struct variant {
        private:
        template <typename Visitor>
        struct visitor {
          template <typename... Values>
          inline static constexpr bool does_not_handle() {
            return lib::is_invocable<Visitor, Values...>::value;
          }
        };

        template <typename Visitor, typename... Values>
        struct visit_exhaustiveness_check {
          static_assert(visitor<Visitor>::template does_not_handle<Values...>(),
                        "`visit` requires the visitor to be exhaustive.");

          inline static constexpr DECLTYPE_AUTO invoke(Visitor &&visitor,
                                                       Values &&... values)
            DECLTYPE_AUTO_RETURN(lib::invoke(lib::forward<Visitor>(visitor),
                                             lib::forward<Values>(values)...))
        };

        template <typename Visitor>
        struct value_visitor {
          Visitor &&visitor_;

          template <typename... Alts>
          inline constexpr DECLTYPE_AUTO operator()(Alts &&... alts) const
            DECLTYPE_AUTO_RETURN(
                visit_exhaustiveness_check<
                    Visitor,
                    decltype((lib::forward<Alts>(alts).value))...>::
                    invoke(lib::forward<Visitor>(visitor_),
                           lib::forward<Alts>(alts).value...))
        };

        template <typename Visitor>
        inline static constexpr AUTO make_value_visitor(Visitor &&visitor)
          AUTO_RETURN(value_visitor<Visitor>{lib::forward<Visitor>(visitor)})

        public:
        template <typename Visitor, typename... Vs>
        inline static constexpr DECLTYPE_AUTO visit_alt(Visitor &&visitor,
                                                        Vs &&... vs)
          DECLTYPE_AUTO_RETURN(alt::visit_alt(lib::forward<Visitor>(visitor),
                                              lib::forward<Vs>(vs).impl_...))

        template <typename Visitor, typename... Vs>
        inline static constexpr DECLTYPE_AUTO visit_alt_at(std::size_t index,
                                                           Visitor &&visitor,
                                                           Vs &&... vs)
          DECLTYPE_AUTO_RETURN(
              alt::visit_alt_at(index,
                                lib::forward<Visitor>(visitor),
                                lib::forward<Vs>(vs).impl_...))

        template <typename Visitor, typename... Vs>
        inline static constexpr DECLTYPE_AUTO visit_value(Visitor &&visitor,
                                                          Vs &&... vs)
          DECLTYPE_AUTO_RETURN(
              visit_alt(make_value_visitor(lib::forward<Visitor>(visitor)),
                        lib::forward<Vs>(vs)...))

        template <typename Visitor, typename... Vs>
        inline static constexpr DECLTYPE_AUTO visit_value_at(std::size_t index,
                                                             Visitor &&visitor,
                                                             Vs &&... vs)
          DECLTYPE_AUTO_RETURN(
              visit_alt_at(index,
                           make_value_visitor(lib::forward<Visitor>(visitor)),
                           lib::forward<Vs>(vs)...))
      };

    }  // namespace visitation

    template <std::size_t Index, typename T>
    struct alt {
      using value_type = T;

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4244)
#endif
      template <typename... Args>
      inline explicit constexpr alt(in_place_t, Args &&... args)
          : value(lib::forward<Args>(args)...) {}
#ifdef _MSC_VER
#pragma warning(pop)
#endif

      T value;
    };

    template <Trait DestructibleTrait, std::size_t Index, typename... Ts>
    union recursive_union;

    template <Trait DestructibleTrait, std::size_t Index>
    union recursive_union<DestructibleTrait, Index> {};

#define MPARK_VARIANT_RECURSIVE_UNION(destructible_trait, destructor)      \
  template <std::size_t Index, typename T, typename... Ts>                 \
  union recursive_union<destructible_trait, Index, T, Ts...> {             \
    public:                                                                \
    inline explicit constexpr recursive_union(valueless_t) noexcept        \
        : dummy_{} {}                                                      \
                                                                           \
    template <typename... Args>                                            \
    inline explicit constexpr recursive_union(in_place_index_t<0>,         \
                                              Args &&... args)             \
        : head_(in_place_t{}, lib::forward<Args>(args)...) {}              \
                                                                           \
    template <std::size_t I, typename... Args>                             \
    inline explicit constexpr recursive_union(in_place_index_t<I>,         \
                                              Args &&... args)             \
        : tail_(in_place_index_t<I - 1>{}, lib::forward<Args>(args)...) {} \
                                                                           \
    recursive_union(const recursive_union &) = default;                    \
    recursive_union(recursive_union &&) = default;                         \
                                                                           \
    destructor                                                             \
                                                                           \
    recursive_union &operator=(const recursive_union &) = default;         \
    recursive_union &operator=(recursive_union &&) = default;              \
                                                                           \
    private:                                                               \
    char dummy_;                                                           \
    alt<Index, T> head_;                                                   \
    recursive_union<destructible_trait, Index + 1, Ts...> tail_;           \
                                                                           \
    friend struct access::recursive_union;                                 \
  }

    MPARK_VARIANT_RECURSIVE_UNION(Trait::TriviallyAvailable,
                                  ~recursive_union() = default;);
    MPARK_VARIANT_RECURSIVE_UNION(Trait::Available,
                                  ~recursive_union() {});
    MPARK_VARIANT_RECURSIVE_UNION(Trait::Unavailable,
                                  ~recursive_union() = delete;);

#undef MPARK_VARIANT_RECURSIVE_UNION

    template <typename... Ts>
    using index_t = typename std::conditional<
            sizeof...(Ts) < std::numeric_limits<unsigned char>::max(),
            unsigned char,
            typename std::conditional<
                sizeof...(Ts) < std::numeric_limits<unsigned short>::max(),
                unsigned short,
                unsigned int>::type
            >::type;

    template <Trait DestructibleTrait, typename... Ts>
    class base {
      public:
      inline explicit constexpr base(valueless_t tag) noexcept
          : data_(tag), index_(static_cast<index_t<Ts...>>(-1)) {}

      template <std::size_t I, typename... Args>
      inline explicit constexpr base(in_place_index_t<I>, Args &&... args)
          : data_(in_place_index_t<I>{}, lib::forward<Args>(args)...),
            index_(I) {}

      inline constexpr bool valueless_by_exception() const noexcept {
        return index_ == static_cast<index_t<Ts...>>(-1);
      }

      inline constexpr std::size_t index() const noexcept {
        return valueless_by_exception() ? variant_npos : index_;
      }

      protected:
      using data_t = recursive_union<DestructibleTrait, 0, Ts...>;

      friend inline constexpr base &as_base(base &b) { return b; }
      friend inline constexpr const base &as_base(const base &b) { return b; }
      friend inline constexpr base &&as_base(base &&b) { return lib::move(b); }
      friend inline constexpr const base &&as_base(const base &&b) { return lib::move(b); }

      friend inline constexpr data_t &data(base &b) { return b.data_; }
      friend inline constexpr const data_t &data(const base &b) { return b.data_; }
      friend inline constexpr data_t &&data(base &&b) { return lib::move(b).data_; }
      friend inline constexpr const data_t &&data(const base &&b) { return lib::move(b).data_; }

      inline static constexpr std::size_t size() { return sizeof...(Ts); }

      data_t data_;
      index_t<Ts...> index_;

      friend struct access::base;
      friend struct visitation::base;
    };

    struct dtor {
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4100)
#endif
      template <typename Alt>
      inline void operator()(Alt &alt) const noexcept { alt.~Alt(); }
#ifdef _MSC_VER
#pragma warning(pop)
#endif
    };

#if !defined(_MSC_VER) || _MSC_VER >= 1910
#define MPARK_INHERITING_CTOR(type, base) using base::base;
#else
#define MPARK_INHERITING_CTOR(type, base)         \
  template <typename... Args>                     \
  inline explicit constexpr type(Args &&... args) \
      : base(lib::forward<Args>(args)...) {}
#endif

    template <typename Traits, Trait = Traits::destructible_trait>
    class destructor;

#define MPARK_VARIANT_DESTRUCTOR(destructible_trait, definition, destroy) \
  template <typename... Ts>                                               \
  class destructor<traits<Ts...>, destructible_trait>                     \
      : public base<destructible_trait, Ts...> {                          \
    using super = base<destructible_trait, Ts...>;                        \
                                                                          \
    public:                                                               \
    MPARK_INHERITING_CTOR(destructor, super)                              \
    using super::operator=;                                               \
                                                                          \
    destructor(const destructor &) = default;                             \
    destructor(destructor &&) = default;                                  \
    definition                                                            \
    destructor &operator=(const destructor &) = default;                  \
    destructor &operator=(destructor &&) = default;                       \
                                                                          \
    protected:                                                            \
    destroy                                                               \
  }

    MPARK_VARIANT_DESTRUCTOR(
        Trait::TriviallyAvailable,
        ~destructor() = default;,
        inline void destroy() noexcept {
          this->index_ = static_cast<index_t<Ts...>>(-1);
        });

    MPARK_VARIANT_DESTRUCTOR(
        Trait::Available,
        ~destructor() { destroy(); },
        inline void destroy() noexcept {
          if (!this->valueless_by_exception()) {
            visitation::alt::visit_alt(dtor{}, *this);
          }
          this->index_ = static_cast<index_t<Ts...>>(-1);
        });

    MPARK_VARIANT_DESTRUCTOR(
        Trait::Unavailable,
        ~destructor() = delete;,
        inline void destroy() noexcept = delete;);

#undef MPARK_VARIANT_DESTRUCTOR

    template <typename Traits>
    class constructor : public destructor<Traits> {
      using super = destructor<Traits>;

      public:
      MPARK_INHERITING_CTOR(constructor, super)
      using super::operator=;

      protected:
#ifndef MPARK_GENERIC_LAMBDAS
      struct ctor {
        template <typename LhsAlt, typename RhsAlt>
        inline void operator()(LhsAlt &lhs_alt, RhsAlt &&rhs_alt) const {
          constructor::construct_alt(lhs_alt,
                                     lib::forward<RhsAlt>(rhs_alt).value);
        }
      };
#endif

      template <std::size_t I, typename T, typename... Args>
      inline static T &construct_alt(alt<I, T> &a, Args &&... args) {
        auto *result = ::new (static_cast<void *>(lib::addressof(a)))
            alt<I, T>(in_place_t{}, lib::forward<Args>(args)...);
        return result->value;
      }

      template <typename Rhs>
      inline static void generic_construct(constructor &lhs, Rhs &&rhs) {
        lhs.destroy();
        if (!rhs.valueless_by_exception()) {
          visitation::alt::visit_alt_at(
              rhs.index(),
#ifdef MPARK_GENERIC_LAMBDAS
              [](auto &lhs_alt, auto &&rhs_alt) {
                constructor::construct_alt(
                    lhs_alt, lib::forward<decltype(rhs_alt)>(rhs_alt).value);
              }
#else
              ctor{}
#endif
              ,
              lhs,
              lib::forward<Rhs>(rhs));
          lhs.index_ = rhs.index_;
        }
      }
    };

    template <typename Traits, Trait = Traits::move_constructible_trait>
    class move_constructor;

#define MPARK_VARIANT_MOVE_CONSTRUCTOR(move_constructible_trait, definition) \
  template <typename... Ts>                                                  \
  class move_constructor<traits<Ts...>, move_constructible_trait>            \
      : public constructor<traits<Ts...>> {                                  \
    using super = constructor<traits<Ts...>>;                                \
                                                                             \
    public:                                                                  \
    MPARK_INHERITING_CTOR(move_constructor, super)                           \
    using super::operator=;                                                  \
                                                                             \
    move_constructor(const move_constructor &) = default;                    \
    definition                                                               \
    ~move_constructor() = default;                                           \
    move_constructor &operator=(const move_constructor &) = default;         \
    move_constructor &operator=(move_constructor &&) = default;              \
  }

    MPARK_VARIANT_MOVE_CONSTRUCTOR(
        Trait::TriviallyAvailable,
        move_constructor(move_constructor &&that) = default;);

    MPARK_VARIANT_MOVE_CONSTRUCTOR(
        Trait::Available,
        move_constructor(move_constructor &&that) noexcept(
            lib::all<std::is_nothrow_move_constructible<Ts>::value...>::value)
            : move_constructor(valueless_t{}) {
          this->generic_construct(*this, lib::move(that));
        });

    MPARK_VARIANT_MOVE_CONSTRUCTOR(
        Trait::Unavailable,
        move_constructor(move_constructor &&) = delete;);

#undef MPARK_VARIANT_MOVE_CONSTRUCTOR

    template <typename Traits, Trait = Traits::copy_constructible_trait>
    class copy_constructor;

#define MPARK_VARIANT_COPY_CONSTRUCTOR(copy_constructible_trait, definition) \
  template <typename... Ts>                                                  \
  class copy_constructor<traits<Ts...>, copy_constructible_trait>            \
      : public move_constructor<traits<Ts...>> {                             \
    using super = move_constructor<traits<Ts...>>;                           \
                                                                             \
    public:                                                                  \
    MPARK_INHERITING_CTOR(copy_constructor, super)                           \
    using super::operator=;                                                  \
                                                                             \
    definition                                                               \
    copy_constructor(copy_constructor &&) = default;                         \
    ~copy_constructor() = default;                                           \
    copy_constructor &operator=(const copy_constructor &) = default;         \
    copy_constructor &operator=(copy_constructor &&) = default;              \
  }

    MPARK_VARIANT_COPY_CONSTRUCTOR(
        Trait::TriviallyAvailable,
        copy_constructor(const copy_constructor &that) = default;);

    MPARK_VARIANT_COPY_CONSTRUCTOR(
        Trait::Available,
        copy_constructor(const copy_constructor &that)
            : copy_constructor(valueless_t{}) {
          this->generic_construct(*this, that);
        });

    MPARK_VARIANT_COPY_CONSTRUCTOR(
        Trait::Unavailable,
        copy_constructor(const copy_constructor &) = delete;);

#undef MPARK_VARIANT_COPY_CONSTRUCTOR

    template <typename Traits>
    class assignment : public copy_constructor<Traits> {
      using super = copy_constructor<Traits>;

      public:
      MPARK_INHERITING_CTOR(assignment, super)
      using super::operator=;

      template <std::size_t I, typename... Args>
      inline /* auto & */ auto emplace(Args &&... args)
          -> decltype(this->construct_alt(access::base::get_alt<I>(*this),
                                          lib::forward<Args>(args)...)) {
        this->destroy();
        auto &result = this->construct_alt(access::base::get_alt<I>(*this),
                                           lib::forward<Args>(args)...);
        this->index_ = I;
        return result;
      }

      protected:
#ifndef MPARK_GENERIC_LAMBDAS
      template <typename That>
      struct assigner {
        template <typename ThisAlt, typename ThatAlt>
        inline void operator()(ThisAlt &this_alt, ThatAlt &&that_alt) const {
          self->assign_alt(this_alt, lib::forward<ThatAlt>(that_alt).value);
        }
        assignment *self;
      };
#endif

      template <std::size_t I, typename T, typename Arg>
      inline void assign_alt(alt<I, T> &a, Arg &&arg) {
        if (this->index() == I) {
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4244)
#endif
          a.value = lib::forward<Arg>(arg);
#ifdef _MSC_VER
#pragma warning(pop)
#endif
        } else {
          struct {
            void operator()(std::true_type) const {
              this_->emplace<I>(lib::forward<Arg>(arg_));
            }
            void operator()(std::false_type) const {
              this_->emplace<I>(T(lib::forward<Arg>(arg_)));
            }
            assignment *this_;
            Arg &&arg_;
          } impl{this, lib::forward<Arg>(arg)};
          impl(lib::bool_constant<
                   std::is_nothrow_constructible<T, Arg>::value ||
                   !std::is_nothrow_move_constructible<T>::value>{});
        }
      }

      template <typename That>
      inline void generic_assign(That &&that) {
        if (this->valueless_by_exception() && that.valueless_by_exception()) {
          // do nothing.
        } else if (that.valueless_by_exception()) {
          this->destroy();
        } else {
          visitation::alt::visit_alt_at(
              that.index(),
#ifdef MPARK_GENERIC_LAMBDAS
              [this](auto &this_alt, auto &&that_alt) {
                this->assign_alt(
                    this_alt, lib::forward<decltype(that_alt)>(that_alt).value);
              }
#else
              assigner<That>{this}
#endif
              ,
              *this,
              lib::forward<That>(that));
        }
      }
    };

    template <typename Traits, Trait = Traits::move_assignable_trait>
    class move_assignment;

#define MPARK_VARIANT_MOVE_ASSIGNMENT(move_assignable_trait, definition) \
  template <typename... Ts>                                              \
  class move_assignment<traits<Ts...>, move_assignable_trait>            \
      : public assignment<traits<Ts...>> {                               \
    using super = assignment<traits<Ts...>>;                             \
                                                                         \
    public:                                                              \
    MPARK_INHERITING_CTOR(move_assignment, super)                        \
    using super::operator=;                                              \
                                                                         \
    move_assignment(const move_assignment &) = default;                  \
    move_assignment(move_assignment &&) = default;                       \
    ~move_assignment() = default;                                        \
    move_assignment &operator=(const move_assignment &) = default;       \
    definition                                                           \
  }

    MPARK_VARIANT_MOVE_ASSIGNMENT(
        Trait::TriviallyAvailable,
        move_assignment &operator=(move_assignment &&that) = default;);

    MPARK_VARIANT_MOVE_ASSIGNMENT(
        Trait::Available,
        move_assignment &
        operator=(move_assignment &&that) noexcept(
            lib::all<(std::is_nothrow_move_constructible<Ts>::value &&
                      std::is_nothrow_move_assignable<Ts>::value)...>::value) {
          this->generic_assign(lib::move(that));
          return *this;
        });

    MPARK_VARIANT_MOVE_ASSIGNMENT(
        Trait::Unavailable,
        move_assignment &operator=(move_assignment &&) = delete;);

#undef MPARK_VARIANT_MOVE_ASSIGNMENT

    template <typename Traits, Trait = Traits::copy_assignable_trait>
    class copy_assignment;

#define MPARK_VARIANT_COPY_ASSIGNMENT(copy_assignable_trait, definition) \
  template <typename... Ts>                                              \
  class copy_assignment<traits<Ts...>, copy_assignable_trait>            \
      : public move_assignment<traits<Ts...>> {                          \
    using super = move_assignment<traits<Ts...>>;                        \
                                                                         \
    public:                                                              \
    MPARK_INHERITING_CTOR(copy_assignment, super)                        \
    using super::operator=;                                              \
                                                                         \
    copy_assignment(const copy_assignment &) = default;                  \
    copy_assignment(copy_assignment &&) = default;                       \
    ~copy_assignment() = default;                                        \
    definition                                                           \
    copy_assignment &operator=(copy_assignment &&) = default;            \
  }

    MPARK_VARIANT_COPY_ASSIGNMENT(
        Trait::TriviallyAvailable,
        copy_assignment &operator=(const copy_assignment &that) = default;);

    MPARK_VARIANT_COPY_ASSIGNMENT(
        Trait::Available,
        copy_assignment &operator=(const copy_assignment &that) {
          this->generic_assign(that);
          return *this;
        });

    MPARK_VARIANT_COPY_ASSIGNMENT(
        Trait::Unavailable,
        copy_assignment &operator=(const copy_assignment &) = delete;);

#undef MPARK_VARIANT_COPY_ASSIGNMENT

    template <typename... Ts>
    class impl : public copy_assignment<traits<Ts...>> {
      using super = copy_assignment<traits<Ts...>>;

      public:
      MPARK_INHERITING_CTOR(impl, super)
      using super::operator=;

      template <std::size_t I, typename Arg>
      inline void assign(Arg &&arg) {
        this->assign_alt(access::base::get_alt<I>(*this),
                         lib::forward<Arg>(arg));
      }

      inline void swap(impl &that) {
        if (this->valueless_by_exception() && that.valueless_by_exception()) {
          // do nothing.
        } else if (this->index() == that.index()) {
          visitation::alt::visit_alt_at(this->index(),
#ifdef MPARK_GENERIC_LAMBDAS
                                        [](auto &this_alt, auto &that_alt) {
                                          using std::swap;
                                          swap(this_alt.value,
                                               that_alt.value);
                                        }
#else
                                        swapper{}
#endif
                                        ,
                                        *this,
                                        that);
        } else {
          impl *lhs = this;
          impl *rhs = lib::addressof(that);
          if (lhs->move_nothrow() && !rhs->move_nothrow()) {
            std::swap(lhs, rhs);
          }
          impl tmp(lib::move(*rhs));
#ifdef MPARK_EXCEPTIONS
          // EXTENSION: When the move construction of `lhs` into `rhs` throws
          // and `tmp` is nothrow move constructible then we move `tmp` back
          // into `rhs` and provide the strong exception safety guarantee.
          try {
            this->generic_construct(*rhs, lib::move(*lhs));
          } catch (...) {
            if (tmp.move_nothrow()) {
              this->generic_construct(*rhs, lib::move(tmp));
            }
            throw;
          }
#else
          this->generic_construct(*rhs, lib::move(*lhs));
#endif
          this->generic_construct(*lhs, lib::move(tmp));
        }
      }

      private:
#ifndef MPARK_GENERIC_LAMBDAS
      struct swapper {
        template <typename ThisAlt, typename ThatAlt>
        inline void operator()(ThisAlt &this_alt, ThatAlt &that_alt) const {
          using std::swap;
          swap(this_alt.value, that_alt.value);
        }
      };
#endif

      inline constexpr bool move_nothrow() const {
        return this->valueless_by_exception() ||
               lib::array<bool, sizeof...(Ts)>{
                   {std::is_nothrow_move_constructible<Ts>::value...}
               }[this->index()];
      }
    };

#undef MPARK_INHERITING_CTOR

    template <std::size_t I, typename T>
    struct overload_leaf {
      using F = lib::size_constant<I> (*)(T);
      operator F() const { return nullptr; }
    };

    template <typename... Ts>
    struct overload_impl {
      private:
      template <typename>
      struct impl;

      template <std::size_t... Is>
      struct impl<lib::index_sequence<Is...>> : overload_leaf<Is, Ts>... {};

      public:
      using type = impl<lib::index_sequence_for<Ts...>>;
    };

    template <typename... Ts>
    using overload = typename overload_impl<Ts...>::type;

    template <typename T, typename... Ts>
    using best_match = lib::invoke_result_t<overload<Ts...>, T &&>;

    template <typename T>
    struct is_in_place_index : std::false_type {};

    template <std::size_t I>
    struct is_in_place_index<in_place_index_t<I>> : std::true_type {};

    template <typename T>
    struct is_in_place_type : std::false_type {};

    template <typename T>
    struct is_in_place_type<in_place_type_t<T>> : std::true_type {};

  }  // detail

  template <typename... Ts>
  class variant {
    static_assert(0 < sizeof...(Ts),
                  "variant must consist of at least one alternative.");

    static_assert(lib::all<!std::is_array<Ts>::value...>::value,
                  "variant can not have an array type as an alternative.");

    static_assert(lib::all<!std::is_reference<Ts>::value...>::value,
                  "variant can not have a reference type as an alternative.");

    static_assert(lib::all<!std::is_void<Ts>::value...>::value,
                  "variant can not have a void type as an alternative.");

    public:
    template <
        typename Front = lib::type_pack_element_t<0, Ts...>,
        lib::enable_if_t<std::is_default_constructible<Front>::value, int> = 0>
    inline constexpr variant() noexcept(
        std::is_nothrow_default_constructible<Front>::value)
        : impl_(in_place_index_t<0>{}) {}

    variant(const variant &) = default;
    variant(variant &&) = default;

    template <
        typename Arg,
        typename Decayed = lib::decay_t<Arg>,
        lib::enable_if_t<!std::is_same<Decayed, variant>::value, int> = 0,
        lib::enable_if_t<!detail::is_in_place_index<Decayed>::value, int> = 0,
        lib::enable_if_t<!detail::is_in_place_type<Decayed>::value, int> = 0,
        std::size_t I = detail::best_match<Arg, Ts...>::value,
        typename T = lib::type_pack_element_t<I, Ts...>,
        lib::enable_if_t<std::is_constructible<T, Arg>::value, int> = 0>
    inline constexpr variant(Arg &&arg) noexcept(
        std::is_nothrow_constructible<T, Arg>::value)
        : impl_(in_place_index_t<I>{}, lib::forward<Arg>(arg)) {}

    template <
        std::size_t I,
        typename... Args,
        typename T = lib::type_pack_element_t<I, Ts...>,
        lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
    inline explicit constexpr variant(
        in_place_index_t<I>,
        Args &&... args) noexcept(std::is_nothrow_constructible<T,
                                                                Args...>::value)
        : impl_(in_place_index_t<I>{}, lib::forward<Args>(args)...) {}

    template <
        std::size_t I,
        typename Up,
        typename... Args,
        typename T = lib::type_pack_element_t<I, Ts...>,
        lib::enable_if_t<std::is_constructible<T,
                                               std::initializer_list<Up> &,
                                               Args...>::value,
                         int> = 0>
    inline explicit constexpr variant(
        in_place_index_t<I>,
        std::initializer_list<Up> il,
        Args &&... args) noexcept(std::
                                      is_nothrow_constructible<
                                          T,
                                          std::initializer_list<Up> &,
                                          Args...>::value)
        : impl_(in_place_index_t<I>{}, il, lib::forward<Args>(args)...) {}

    template <
        typename T,
        typename... Args,
        std::size_t I = detail::find_index_sfinae<T, Ts...>::value,
        lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
    inline explicit constexpr variant(
        in_place_type_t<T>,
        Args &&... args) noexcept(std::is_nothrow_constructible<T,
                                                                Args...>::value)
        : impl_(in_place_index_t<I>{}, lib::forward<Args>(args)...) {}

    template <
        typename T,
        typename Up,
        typename... Args,
        std::size_t I = detail::find_index_sfinae<T, Ts...>::value,
        lib::enable_if_t<std::is_constructible<T,
                                               std::initializer_list<Up> &,
                                               Args...>::value,
                         int> = 0>
    inline explicit constexpr variant(
        in_place_type_t<T>,
        std::initializer_list<Up> il,
        Args &&... args) noexcept(std::
                                      is_nothrow_constructible<
                                          T,
                                          std::initializer_list<Up> &,
                                          Args...>::value)
        : impl_(in_place_index_t<I>{}, il, lib::forward<Args>(args)...) {}

    ~variant() = default;

    variant &operator=(const variant &) = default;
    variant &operator=(variant &&) = default;

    template <typename Arg,
              lib::enable_if_t<!std::is_same<lib::decay_t<Arg>, variant>::value,
                               int> = 0,
              std::size_t I = detail::best_match<Arg, Ts...>::value,
              typename T = lib::type_pack_element_t<I, Ts...>,
              lib::enable_if_t<(std::is_assignable<T &, Arg>::value &&
                                std::is_constructible<T, Arg>::value),
                               int> = 0>
    inline variant &operator=(Arg &&arg) noexcept(
        (std::is_nothrow_assignable<T &, Arg>::value &&
         std::is_nothrow_constructible<T, Arg>::value)) {
      impl_.template assign<I>(lib::forward<Arg>(arg));
      return *this;
    }

    template <
        std::size_t I,
        typename... Args,
        typename T = lib::type_pack_element_t<I, Ts...>,
        lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
    inline T &emplace(Args &&... args) {
      return impl_.template emplace<I>(lib::forward<Args>(args)...);
    }

    template <
        std::size_t I,
        typename Up,
        typename... Args,
        typename T = lib::type_pack_element_t<I, Ts...>,
        lib::enable_if_t<std::is_constructible<T,
                                               std::initializer_list<Up> &,
                                               Args...>::value,
                         int> = 0>
    inline T &emplace(std::initializer_list<Up> il, Args &&... args) {
      return impl_.template emplace<I>(il, lib::forward<Args>(args)...);
    }

    template <
        typename T,
        typename... Args,
        std::size_t I = detail::find_index_sfinae<T, Ts...>::value,
        lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
    inline T &emplace(Args &&... args) {
      return impl_.template emplace<I>(lib::forward<Args>(args)...);
    }

    template <
        typename T,
        typename Up,
        typename... Args,
        std::size_t I = detail::find_index_sfinae<T, Ts...>::value,
        lib::enable_if_t<std::is_constructible<T,
                                               std::initializer_list<Up> &,
                                               Args...>::value,
                         int> = 0>
    inline T &emplace(std::initializer_list<Up> il, Args &&... args) {
      return impl_.template emplace<I>(il, lib::forward<Args>(args)...);
    }

    inline constexpr bool valueless_by_exception() const noexcept {
      return impl_.valueless_by_exception();
    }

    inline constexpr std::size_t index() const noexcept {
      return impl_.index();
    }

    template <bool Dummy = true,
              lib::enable_if_t<
                  lib::all<Dummy,
                           (lib::dependent_type<std::is_move_constructible<Ts>,
                                                Dummy>::value &&
                            lib::dependent_type<lib::is_swappable<Ts>,
                                                Dummy>::value)...>::value,
                  int> = 0>
    inline void swap(variant &that) noexcept(
        lib::all<(std::is_nothrow_move_constructible<Ts>::value &&
                  lib::is_nothrow_swappable<Ts>::value)...>::value) {
      impl_.swap(that.impl_);
    }

    private:
    detail::impl<Ts...> impl_;

    friend struct detail::access::variant;
    friend struct detail::visitation::variant;
  };

  template <std::size_t I, typename... Ts>
  inline constexpr bool holds_alternative(const variant<Ts...> &v) noexcept {
    return v.index() == I;
  }

  template <typename T, typename... Ts>
  inline constexpr bool holds_alternative(const variant<Ts...> &v) noexcept {
    return holds_alternative<detail::find_index_checked<T, Ts...>::value>(v);
  }

  namespace detail {
    template <std::size_t I, typename V>
    struct generic_get_impl {
      constexpr generic_get_impl(int) noexcept {}

      constexpr AUTO_REFREF operator()(V &&v) const
        AUTO_REFREF_RETURN(
            access::variant::get_alt<I>(lib::forward<V>(v)).value)
    };

    template <std::size_t I, typename V>
    inline constexpr AUTO_REFREF generic_get(V &&v)
      AUTO_REFREF_RETURN(generic_get_impl<I, V>(
          holds_alternative<I>(v) ? 0 : (throw_bad_variant_access(), 0))(
          lib::forward<V>(v)))
  }  // namespace detail

  template <std::size_t I, typename... Ts>
  inline constexpr variant_alternative_t<I, variant<Ts...>> &get(
      variant<Ts...> &v) {
    return detail::generic_get<I>(v);
  }

  template <std::size_t I, typename... Ts>
  inline constexpr variant_alternative_t<I, variant<Ts...>> &&get(
      variant<Ts...> &&v) {
    return detail::generic_get<I>(lib::move(v));
  }

  template <std::size_t I, typename... Ts>
  inline constexpr const variant_alternative_t<I, variant<Ts...>> &get(
      const variant<Ts...> &v) {
    return detail::generic_get<I>(v);
  }

  template <std::size_t I, typename... Ts>
  inline constexpr const variant_alternative_t<I, variant<Ts...>> &&get(
      const variant<Ts...> &&v) {
    return detail::generic_get<I>(lib::move(v));
  }

  template <typename T, typename... Ts>
  inline constexpr T &get(variant<Ts...> &v) {
    return get<detail::find_index_checked<T, Ts...>::value>(v);
  }

  template <typename T, typename... Ts>
  inline constexpr T &&get(variant<Ts...> &&v) {
    return get<detail::find_index_checked<T, Ts...>::value>(lib::move(v));
  }

  template <typename T, typename... Ts>
  inline constexpr const T &get(const variant<Ts...> &v) {
    return get<detail::find_index_checked<T, Ts...>::value>(v);
  }

  template <typename T, typename... Ts>
  inline constexpr const T &&get(const variant<Ts...> &&v) {
    return get<detail::find_index_checked<T, Ts...>::value>(lib::move(v));
  }

  namespace detail {

    template <std::size_t I, typename V>
    inline constexpr /* auto * */ AUTO generic_get_if(V *v) noexcept
      AUTO_RETURN(v && holds_alternative<I>(*v)
                      ? lib::addressof(access::variant::get_alt<I>(*v).value)
                      : nullptr)

  }  // namespace detail

  template <std::size_t I, typename... Ts>
  inline constexpr lib::add_pointer_t<variant_alternative_t<I, variant<Ts...>>>
  get_if(variant<Ts...> *v) noexcept {
    return detail::generic_get_if<I>(v);
  }

  template <std::size_t I, typename... Ts>
  inline constexpr lib::add_pointer_t<
      const variant_alternative_t<I, variant<Ts...>>>
  get_if(const variant<Ts...> *v) noexcept {
    return detail::generic_get_if<I>(v);
  }

  template <typename T, typename... Ts>
  inline constexpr lib::add_pointer_t<T>
  get_if(variant<Ts...> *v) noexcept {
    return get_if<detail::find_index_checked<T, Ts...>::value>(v);
  }

  template <typename T, typename... Ts>
  inline constexpr lib::add_pointer_t<const T>
  get_if(const variant<Ts...> *v) noexcept {
    return get_if<detail::find_index_checked<T, Ts...>::value>(v);
  }

  namespace detail {
    template <typename RelOp>
    struct convert_to_bool {
      template <typename Lhs, typename Rhs>
      inline constexpr bool operator()(Lhs &&lhs, Rhs &&rhs) const {
        static_assert(std::is_convertible<lib::invoke_result_t<RelOp, Lhs, Rhs>,
                                          bool>::value,
                      "relational operators must return a type"
                      " implicitly convertible to bool");
        return lib::invoke(
            RelOp{}, lib::forward<Lhs>(lhs), lib::forward<Rhs>(rhs));
      }
    };
  }  // namespace detail

  template <typename... Ts>
  inline constexpr bool operator==(const variant<Ts...> &lhs,
                                   const variant<Ts...> &rhs) {
    using detail::visitation::variant;
    using equal_to = detail::convert_to_bool<lib::equal_to>;
#ifdef MPARK_CPP14_CONSTEXPR
    if (lhs.index() != rhs.index()) return false;
    if (lhs.valueless_by_exception()) return true;
    return variant::visit_value_at(lhs.index(), equal_to{}, lhs, rhs);
#else
    return lhs.index() == rhs.index() &&
           (lhs.valueless_by_exception() ||
            variant::visit_value_at(lhs.index(), equal_to{}, lhs, rhs));
#endif
  }

  template <typename... Ts>
  inline constexpr bool operator!=(const variant<Ts...> &lhs,
                                   const variant<Ts...> &rhs) {
    using detail::visitation::variant;
    using not_equal_to = detail::convert_to_bool<lib::not_equal_to>;
#ifdef MPARK_CPP14_CONSTEXPR
    if (lhs.index() != rhs.index()) return true;
    if (lhs.valueless_by_exception()) return false;
    return variant::visit_value_at(lhs.index(), not_equal_to{}, lhs, rhs);
#else
    return lhs.index() != rhs.index() ||
           (!lhs.valueless_by_exception() &&
            variant::visit_value_at(lhs.index(), not_equal_to{}, lhs, rhs));
#endif
  }

  template <typename... Ts>
  inline constexpr bool operator<(const variant<Ts...> &lhs,
                                  const variant<Ts...> &rhs) {
    using detail::visitation::variant;
    using less = detail::convert_to_bool<lib::less>;
#ifdef MPARK_CPP14_CONSTEXPR
    if (rhs.valueless_by_exception()) return false;
    if (lhs.valueless_by_exception()) return true;
    if (lhs.index() < rhs.index()) return true;
    if (lhs.index() > rhs.index()) return false;
    return variant::visit_value_at(lhs.index(), less{}, lhs, rhs);
#else
    return !rhs.valueless_by_exception() &&
           (lhs.valueless_by_exception() || lhs.index() < rhs.index() ||
            (lhs.index() == rhs.index() &&
             variant::visit_value_at(lhs.index(), less{}, lhs, rhs)));
#endif
  }

  template <typename... Ts>
  inline constexpr bool operator>(const variant<Ts...> &lhs,
                                  const variant<Ts...> &rhs) {
    using detail::visitation::variant;
    using greater = detail::convert_to_bool<lib::greater>;
#ifdef MPARK_CPP14_CONSTEXPR
    if (lhs.valueless_by_exception()) return false;
    if (rhs.valueless_by_exception()) return true;
    if (lhs.index() > rhs.index()) return true;
    if (lhs.index() < rhs.index()) return false;
    return variant::visit_value_at(lhs.index(), greater{}, lhs, rhs);
#else
    return !lhs.valueless_by_exception() &&
           (rhs.valueless_by_exception() || lhs.index() > rhs.index() ||
            (lhs.index() == rhs.index() &&
             variant::visit_value_at(lhs.index(), greater{}, lhs, rhs)));
#endif
  }

  template <typename... Ts>
  inline constexpr bool operator<=(const variant<Ts...> &lhs,
                                   const variant<Ts...> &rhs) {
    using detail::visitation::variant;
    using less_equal = detail::convert_to_bool<lib::less_equal>;
#ifdef MPARK_CPP14_CONSTEXPR
    if (lhs.valueless_by_exception()) return true;
    if (rhs.valueless_by_exception()) return false;
    if (lhs.index() < rhs.index()) return true;
    if (lhs.index() > rhs.index()) return false;
    return variant::visit_value_at(lhs.index(), less_equal{}, lhs, rhs);
#else
    return lhs.valueless_by_exception() ||
           (!rhs.valueless_by_exception() &&
            (lhs.index() < rhs.index() ||
             (lhs.index() == rhs.index() &&
              variant::visit_value_at(lhs.index(), less_equal{}, lhs, rhs))));
#endif
  }

  template <typename... Ts>
  inline constexpr bool operator>=(const variant<Ts...> &lhs,
                                   const variant<Ts...> &rhs) {
    using detail::visitation::variant;
    using greater_equal = detail::convert_to_bool<lib::greater_equal>;
#ifdef MPARK_CPP14_CONSTEXPR
    if (rhs.valueless_by_exception()) return true;
    if (lhs.valueless_by_exception()) return false;
    if (lhs.index() > rhs.index()) return true;
    if (lhs.index() < rhs.index()) return false;
    return variant::visit_value_at(lhs.index(), greater_equal{}, lhs, rhs);
#else
    return rhs.valueless_by_exception() ||
           (!lhs.valueless_by_exception() &&
            (lhs.index() > rhs.index() ||
             (lhs.index() == rhs.index() &&
              variant::visit_value_at(
                  lhs.index(), greater_equal{}, lhs, rhs))));
#endif
  }

  struct monostate {};

  inline constexpr bool operator<(monostate, monostate) noexcept {
    return false;
  }

  inline constexpr bool operator>(monostate, monostate) noexcept {
    return false;
  }

  inline constexpr bool operator<=(monostate, monostate) noexcept {
    return true;
  }

  inline constexpr bool operator>=(monostate, monostate) noexcept {
    return true;
  }

  inline constexpr bool operator==(monostate, monostate) noexcept {
    return true;
  }

  inline constexpr bool operator!=(monostate, monostate) noexcept {
    return false;
  }

#ifdef MPARK_CPP14_CONSTEXPR
  namespace detail {

    inline constexpr bool all(std::initializer_list<bool> bs) {
      for (bool b : bs) {
        if (!b) {
          return false;
        }
      }
      return true;
    }

  }  // namespace detail

  template <typename Visitor, typename... Vs>
  inline constexpr decltype(auto) visit(Visitor &&visitor, Vs &&... vs) {
    return (detail::all({!vs.valueless_by_exception()...})
                ? (void)0
                : throw_bad_variant_access()),
           detail::visitation::variant::visit_value(
               lib::forward<Visitor>(visitor), lib::forward<Vs>(vs)...);
  }
#else
  namespace detail {

    template <std::size_t N>
    inline constexpr bool all_impl(const lib::array<bool, N> &bs,
                                   std::size_t idx) {
      return idx >= N || (bs[idx] && all_impl(bs, idx + 1));
    }

    template <std::size_t N>
    inline constexpr bool all(const lib::array<bool, N> &bs) {
      return all_impl(bs, 0);
    }

  }  // namespace detail

  template <typename Visitor, typename... Vs>
  inline constexpr DECLTYPE_AUTO visit(Visitor &&visitor, Vs &&... vs)
    DECLTYPE_AUTO_RETURN(
        (detail::all(
             lib::array<bool, sizeof...(Vs)>{{!vs.valueless_by_exception()...}})
             ? (void)0
             : throw_bad_variant_access()),
        detail::visitation::variant::visit_value(lib::forward<Visitor>(visitor),
                                                 lib::forward<Vs>(vs)...))
#endif

  template <typename... Ts>
  inline auto swap(variant<Ts...> &lhs,
                   variant<Ts...> &rhs) noexcept(noexcept(lhs.swap(rhs)))
      -> decltype(lhs.swap(rhs)) {
    lhs.swap(rhs);
  }

  namespace detail {

    template <typename T, typename...>
    using enabled_type = T;

    namespace hash {

      template <typename H, typename K>
      constexpr bool meets_requirements() noexcept {
        return std::is_copy_constructible<H>::value &&
               std::is_move_constructible<H>::value &&
               lib::is_invocable_r<std::size_t, H, const K &>::value;
      }

      template <typename K>
      constexpr bool is_enabled() noexcept {
        using H = std::hash<K>;
        return meets_requirements<H, K>() &&
               std::is_default_constructible<H>::value &&
               std::is_copy_assignable<H>::value &&
               std::is_move_assignable<H>::value;
      }

    }  // namespace hash

  }  // namespace detail

#undef AUTO
#undef AUTO_RETURN

#undef AUTO_REFREF
#undef AUTO_REFREF_RETURN

#undef DECLTYPE_AUTO
#undef DECLTYPE_AUTO_RETURN

}  // namespace mpark

namespace std {

  template <typename... Ts>
  struct hash<mpark::detail::enabled_type<
      mpark::variant<Ts...>,
      mpark::lib::enable_if_t<mpark::lib::all<mpark::detail::hash::is_enabled<
          mpark::lib::remove_const_t<Ts>>()...>::value>>> {
    using argument_type = mpark::variant<Ts...>;
    using result_type = std::size_t;

    inline result_type operator()(const argument_type &v) const {
      using mpark::detail::visitation::variant;
      std::size_t result =
          v.valueless_by_exception()
              ? 299792458  // Random value chosen by the universe upon creation
              : variant::visit_alt(
#ifdef MPARK_GENERIC_LAMBDAS
                    [](const auto &alt) {
                      using alt_type = mpark::lib::decay_t<decltype(alt)>;
                      using value_type = mpark::lib::remove_const_t<
                          typename alt_type::value_type>;
                      return hash<value_type>{}(alt.value);
                    }
#else
                    hasher{}
#endif
                    ,
                    v);
      return hash_combine(result, hash<std::size_t>{}(v.index()));
    }

    private:
#ifndef MPARK_GENERIC_LAMBDAS
    struct hasher {
      template <typename Alt>
      inline std::size_t operator()(const Alt &alt) const {
        using alt_type = mpark::lib::decay_t<Alt>;
        using value_type =
            mpark::lib::remove_const_t<typename alt_type::value_type>;
        return hash<value_type>{}(alt.value);
      }
    };
#endif

    static std::size_t hash_combine(std::size_t lhs, std::size_t rhs) {
      return lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);
    }
  };

  template <>
  struct hash<mpark::monostate> {
    using argument_type = mpark::monostate;
    using result_type = std::size_t;

    inline result_type operator()(const argument_type &) const noexcept {
      return 66740831;  // return a fundamentally attractive random value.
    }
  };

}  // namespace std

#endif  // MPARK_VARIANT_HPP

```

`Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp`:

```cpp
#include "BlueprintProvider.hpp"

#include "Async/Async.h"

#include "AssetEditorMessages.h"
#include "BlueprintEditor.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "Kismet2/KismetEditorUtilities.h"
#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23
#include "Toolkits/AssetEditorManager.h"
#endif
#include "Kismet2/BlueprintEditorUtils.h"
#include "Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Generated.h"

#if ENGINE_MAJOR_VERSION < 5
#include "AssetData.h"
#else
#include "AssetRegistry/AssetData.h"
#endif

void BluePrintProvider::AddAsset(FAssetData const& AssetData) {
#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23
    UObject* cls = AssetData.GetAsset();
#else
    UObject* cls = AssetData.FastGetAsset();
#endif
    if (cls) {
        UBlueprint* Blueprint = Cast<UBlueprint>(cls);
        if (Blueprint && Blueprint->IsValidLowLevel()) {

        }
    }
}

bool BluePrintProvider::IsBlueprint(FString const& pathName) {
    return FPackageName::IsValidObjectPath(pathName);
}

void BluePrintProvider::OpenBlueprint(JetBrains::EditorPlugin::BlueprintReference const& BlueprintReference, TSharedPtr<FMessageEndpoint, ESPMode::ThreadSafe> const& messageEndpoint) {
    // Just to create asset manager if it wasn't created already
    const FString AssetPathName = BlueprintReference.get_pathName();
    FGuid AssetGuid;
    bool bIsValidGuid = FGuid::Parse(BlueprintReference.get_guid(), AssetGuid);
#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23
    FAssetEditorManager::Get();
    messageEndpoint->Publish(new FAssetEditorRequestOpenAsset(AssetPathName), EMessageScope::Process);
#else
    AsyncTask(ENamedThreads::GameThread, [AssetPathName, AssetGuid, bIsValidGuid]()
    {
        // An asset needs loading
        UPackage* Package = LoadPackage(nullptr, *AssetPathName, LOAD_NoRedirects);

        if (Package)
        {
            Package->FullyLoad();

            const FString AssetName = FPaths::GetBaseFilename(AssetPathName);
            UObject* Object = FindObject<UObject>(Package, *AssetName);
            const UBlueprint* Blueprint = Cast<UBlueprint>(Object);
            if(bIsValidGuid && Blueprint != nullptr)
            {
                Object = FBlueprintEditorUtils::GetNodeByGUID(Blueprint, AssetGuid);   
            }
            if(Object != nullptr)
            {
                FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(Blueprint);                
            }
        }
    });
#endif
}

```

`Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp`:

```cpp
#include "RiderBlueprint.hpp"

#include "BlueprintProvider.hpp"
#include "IRiderLink.hpp"
#include "Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Generated.h"


#include "Engine/Blueprint.h"
#include "Framework/Docking/TabManager.h"
#include "HAL/PlatformProcess.h"
#include "MessageEndpoint.h"
#include "MessageEndpointBuilder.h"
#include "Modules/ModuleManager.h"
#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION < 5
#include "AssetRegistryModule.h"
#else
#include "AssetRegistry/AssetRegistryModule.h"
#endif

#define LOCTEXT_NAMESPACE "RiderLink"

DEFINE_LOG_CATEGORY(FLogRiderBlueprintModule);

IMPLEMENT_MODULE(FRiderBlueprintModule, RiderBlueprint);

static void AllowSetForeGroundForEditor(JetBrains::EditorPlugin::RdEditorModel const & unrealToBackendModel) {
    static const int32 CurrentProcessId = FPlatformProcess::GetCurrentProcessId();
    try {
        const rd::WiredRdTask<bool> Task = unrealToBackendModel.get_allowSetForegroundWindow().sync(CurrentProcessId);
        if (Task.is_faulted()) {
            UE_LOG(FLogRiderBlueprintModule, Error, TEXT("AllowSetForeGroundForEditor failed: %hs "), rd::to_string(Task.value_or_throw()).c_str());
        }
        else if (Task.is_succeeded()) {
            if (!(Task.value_or_throw().unwrap())) {
                UE_LOG(FLogRiderBlueprintModule, Error, TEXT("AllowSetForeGroundForEditor failed: %hs "), rd::to_string(Task.value_or_throw()).c_str());
            }
        }
    }
    catch (std::exception const &e) {
        UE_LOG(FLogRiderBlueprintModule, Error, TEXT("AllowSetForeGroundForEditor failed: %hs "), rd::to_string(e).c_str());
    }
}

void FRiderBlueprintModule::StartupModule()
{
    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT("STARTUP START"));
    IRiderLinkModule& RiderLinkModule = IRiderLinkModule::Get();
    ModuleLifetimeDef = RiderLinkModule.CreateNestedLifetimeDefinition();

    const FAssetRegistryModule* AssetRegistryModule = &FModuleManager::LoadModuleChecked<FAssetRegistryModule>
        (AssetRegistryConstants::ModuleName);

    MessageEndpoint = FMessageEndpoint::Builder(FName("FAssetEditorManager")).Build();

    AssetRegistryModule->Get().OnAssetAdded().AddLambda([](const FAssetData& AssetData) {
        // TO-DO: Fix loading uasset's on 4.23-
        // BluePrintProvider::AddAsset(AssetData);
    });

    RiderLinkModule.ViewModel(ModuleLifetimeDef.lifetime, [this] (rd::Lifetime ModelLifetime, JetBrains::EditorPlugin::RdEditorModel const& UnrealToBackendModel)
    {
        UnrealToBackendModel.get_openBlueprint().advise(
            ModelLifetime,
            [this, &UnrealToBackendModel](
            JetBrains::EditorPlugin::BlueprintReference const& s)
            {
                try
                {
                    AllowSetForeGroundForEditor(UnrealToBackendModel);

                    auto Window = FGlobalTabmanager::Get()->GetRootWindow();
                    if (!Window.IsValid()) return;

                    if (Window->IsWindowMinimized())
                    {
                        Window->Restore();
                    }
                    else
                    {
                        Window->HACK_ForceToFront();
                    }
                    BluePrintProvider::OpenBlueprint(s, MessageEndpoint);
                }
                catch (std::exception const& e)
                {
                    std::cerr << rd::to_string(e);
                }
            }
        );

        UnrealToBackendModel.get_isBlueprintPathName().set([](FString const& pathName) -> bool
        {
            return BluePrintProvider::IsBlueprint(pathName);
        });
    });
    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT("STARTUP FINISH"));
}

void FRiderBlueprintModule::ShutdownModule()
{
    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT("SHUTDOWN START"));
    ModuleLifetimeDef.terminate();
    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT("SHUTDOWN FINISH"));
}

```

`Plugins/Developer/RiderLink/Source/RiderBlueprint/Public/BlueprintProvider.hpp`:

```hpp
#pragma once

#include "Delegates/Delegate.h"

namespace JetBrains
{
    namespace EditorPlugin
    {
        class BlueprintReference;
    }
}

struct FAssetData;
class FMessageEndpoint;
class UBlueprint;

class RIDERBLUEPRINT_API BluePrintProvider {
public:

    static void AddAsset(FAssetData const& AssetData);

    static bool IsBlueprint(FString const& pathName);

    static void OpenBlueprint(JetBrains::EditorPlugin::BlueprintReference const& path, TSharedPtr<FMessageEndpoint, ESPMode::ThreadSafe> const& messageEndpoint);
};

```

`Plugins/Developer/RiderLink/Source/RiderBlueprint/Public/RiderBlueprint.hpp`:

```hpp
#pragma once

#include "lifetime/LifetimeDefinition.h"

#include "Logging/LogMacros.h"
#include "Logging/LogVerbosity.h"
#include "MessageEndpoint.h"
#include "Modules/ModuleInterface.h"
#include "Templates/SharedPointer.h"

DECLARE_LOG_CATEGORY_EXTERN(FLogRiderBlueprintModule, Log, All);

class FRiderBlueprintModule : public IModuleInterface
{
public:
    FRiderBlueprintModule() = default;
    virtual ~FRiderBlueprintModule() override = default;

    /** IModuleInterface implementation */
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
    virtual bool SupportsDynamicReloading() override { return true; };
private:
    TSharedPtr<FMessageEndpoint, ESPMode::ThreadSafe> MessageEndpoint;
    rd::LifetimeDefinition ModuleLifetimeDef;
};

```

`Plugins/Developer/RiderLink/Source/RiderBlueprint/RiderBlueprint.Build.cs`:

```cs
// Copyright 1998-2020 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class RiderBlueprint : ModuleRules
{
	public RiderBlueprint(ReadOnlyTargetRules Target) : base(Target)
	{
#if UE_4_22_OR_LATER
		PCHUsage = PCHUsageMode.NoPCHs;
#else
		PCHUsage = PCHUsageMode.NoSharedPCHs;
#endif
		
		bUseRTTI = true;
		
		PublicDependencyModuleNames.Add("RD");

		PrivateDependencyModuleNames.AddRange(new []
		{
			"Core",
			"SlateCore",
			"RiderLink",
			"Slate",
			"AssetRegistry",
			"MessagingCommon",
			"UnrealEd",
			"UnrealEdMessages",
			"Engine",
			"CoreUObject"
		});
	}
}

```

`Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp`:

```cpp
#include "RiderGameControl.hpp"


#include "IRiderLink.hpp"

#include "Model/Library/UE4Library/PlayState.Generated.h"
#include "Model/Library/UE4Library/RequestFailed.Generated.h"
#include "Model/Library/UE4Library/RequestSucceed.Generated.h"
#include "RdEditorModel/RdEditorModel.Generated.h"

#include "Async/Async.h"
#include "Editor/UnrealEdEngine.h"
#include "Framework/Application/SlateApplication.h"
#include "Kismet2/DebuggerCommands.h"
#include "LevelEditor.h"
#include "LevelEditorActions.h"
#include "Misc/FeedbackContext.h"
#include "Modules/ModuleManager.h"
#include "Settings/LevelEditorPlaySettings.h"
#include "UnrealEd/Public/Editor.h"

#include "Runtime/Launch/Resources/Version.h"
#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23
#include "ILevelViewport.h"
#include "LevelEditorViewport.h"
#else
#include "IAssetViewport.h"
#include "EditorViewportClient.h"
#endif

#define LOCTEXT_NAMESPACE "RiderLink"

DEFINE_LOG_CATEGORY(FLogRiderGameControlModule);

IMPLEMENT_MODULE(FRiderGameControlModule, RiderGameControl);

extern UNREALED_API class UUnrealEdEngine* GUnrealEd;

static int NumberOfPlayers(int Mode) { return (Mode & 3) + 1; }

static bool SpawnAtPlayerStart(int Mode) { return (Mode & 4) != 0; }

static bool DedicatedServer(int Mode) { return (Mode & 8) != 0; }

enum class Compile
{
    Yes,
    No
};

static Compile CompileBeforeRun(int Mode) { return (Mode & 128) != 0 ? Compile::Yes : Compile::No; }

static EPlayModeType PlayModeFromInt(int ModeNumber)
{
    switch (ModeNumber)
    {
    default: break;
    case 1: return PlayMode_InMobilePreview;
    case 2: return PlayMode_InEditorFloating;
    case 3: return PlayMode_InVR;
    case 4: return PlayMode_InNewProcess;
    case 5: return PlayMode_Simulate;
    case 6: return PlayMode_InVulkanPreview;
    }
    return PlayMode_InViewPort;
}

static int PlayModeToInt(EPlayModeType modeType)
{
    switch (modeType)
    {
    default: break;
    case PlayMode_InTargetedMobilePreview:
    case PlayMode_InMobilePreview:
        return 1;
    case PlayMode_InEditorFloating: return 2;
    case PlayMode_InVR: return 3;
    case PlayMode_InNewProcess: return 4;
    case PlayMode_Simulate: return 5;
    case PlayMode_InVulkanPreview: return 6;
    }
    return 0;
}

FSlateApplication* SlateApplication = nullptr;

struct FPlaySettings
{
    EPlayModeType PlayMode;
    int32 NumberOfClients;
    bool bNetDedicated;
    bool bSpawnAtPlayerStart;

    static FPlaySettings UnpackFromMode(int32_t mode)
    {
        FPlaySettings settings = {
            PlayModeFromInt((mode & (16 + 32 + 64)) >> 4),
            NumberOfPlayers(mode),
            DedicatedServer(mode),
            SpawnAtPlayerStart(mode),
        };
        return settings;
    }

    static int32_t PackToMode(const FPlaySettings& settings)
    {
        return (settings.NumberOfClients - 1) +
            (settings.bSpawnAtPlayerStart ? (1 << 2) : 0) +
            (settings.bNetDedicated ? (1 << 3) : 0) +
            (PlayModeToInt(settings.PlayMode) << 4);
    }
};


static FPlaySettings RetrieveSettings(const ULevelEditorPlaySettings* PlayInSettings)
{
    check(PlayInSettings);

    FPlaySettings settings;
    settings.PlayMode = PlayInSettings->LastExecutedPlayModeType;
    PlayInSettings->GetPlayNumberOfClients(settings.NumberOfClients);
#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 24
    PlayInSettings->GetPlayNetDedicated(settings.bNetDedicated);
#else
    settings.bNetDedicated = PlayInSettings->bLaunchSeparateServer;
#endif
    settings.bSpawnAtPlayerStart = PlayInSettings->LastExecutedPlayModeLocation == PlayLocation_DefaultPlayerStart;

    return settings;
}

static void UpdateSettings(ULevelEditorPlaySettings* PlayInSettings, const FPlaySettings& settings)
{
    check(PlayInSettings);
    
    PlayInSettings->SetPlayNumberOfClients(settings.NumberOfClients);
#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 24
    PlayInSettings->SetPlayNetDedicated(settings.bNetDedicated);
#else
    PlayInSettings->bLaunchSeparateServer = settings.bNetDedicated;
#endif
    PlayInSettings->LastExecutedPlayModeLocation =
        settings.bSpawnAtPlayerStart
            ? PlayLocation_DefaultPlayerStart
            : PlayLocation_CurrentCameraLocation;
    PlayInSettings->LastExecutedPlayModeType = settings.PlayMode;

    PlayInSettings->PostEditChange();
    PlayInSettings->SaveConfig();
}


struct FCachedCommandInfo
{
    FName CommandName;
    TSharedPtr<FUICommandInfo> Command;
};

class FRiderGameControlActionsCache
{
public:
    FRiderGameControlActionsCache();
    ~FRiderGameControlActionsCache();

private:
    void UpdatePlayWorldCommandsCache();

public:
    FCachedCommandInfo PlayModeCommands[PlayMode_Count] = {
        {TEXT("PlayInViewport")},
        {TEXT("PlayInEditorFloating")},
        {TEXT("PlayInMobilePreview")},
        {FName()},
        {TEXT("PlayInVulkanPreview")},
        {TEXT("PlayInNewProcess")},
        {TEXT("PlayInVR")},
        {TEXT("Simulate")},
    };
    FCachedCommandInfo ResumePlaySession = {TEXT("ResumePlaySession")};
    FCachedCommandInfo PausePlaySession = {TEXT("PausePlaySession")};
    FCachedCommandInfo StopPlaySession = {TEXT("StopPlaySession")};
    FCachedCommandInfo SingleFrameAdvance = {TEXT("SingleFrameAdvance")};

private:
    FDelegateHandle CommandsChangedHandle;
};

FRiderGameControlActionsCache::FRiderGameControlActionsCache()
{
    const FName PlayWorldContextName = FName("PlayWorld");

    TSharedPtr<FBindingContext> PlayWorldContext = FInputBindingManager::Get().GetContextByName(PlayWorldContextName);
    if (PlayWorldContext.IsValid())
    {
        UpdatePlayWorldCommandsCache();
    }

    CommandsChangedHandle = FBindingContext::CommandsChanged.AddLambda(
        [this, PlayWorldContextName](const FBindingContext& Ctx)
        {
            if (Ctx.GetContextName() == PlayWorldContextName)
            {
                UpdatePlayWorldCommandsCache();
            }
        }
    );
}

FRiderGameControlActionsCache::~FRiderGameControlActionsCache()
{
    FBindingContext::CommandsChanged.Remove(CommandsChangedHandle);
}

void FRiderGameControlActionsCache::UpdatePlayWorldCommandsCache()
{
    FInputBindingManager& BindingManager = FInputBindingManager::Get();
    auto CacheCommand = [&] (FCachedCommandInfo &Cmd, const FName &ContextName)
    {
        Cmd.Command = BindingManager.FindCommandInContext(ContextName, Cmd.CommandName);
    };

    const FName PlayWorldContextName = FName("PlayWorld");
    for (FCachedCommandInfo& PlayModeCommand : PlayModeCommands)
    {
        if (PlayModeCommands->CommandName.IsNone()) continue;
        CacheCommand(PlayModeCommand, PlayWorldContextName);
    }
    CacheCommand(ResumePlaySession, PlayWorldContextName);
    CacheCommand(PausePlaySession, PlayWorldContextName);
    CacheCommand(StopPlaySession, PlayWorldContextName);
    CacheCommand(SingleFrameAdvance, PlayWorldContextName);
}


class FRiderGameControl
{
public:
    FRiderGameControl(rd::Lifetime Lifetime, JetBrains::EditorPlugin::RdEditorModel const &Model, FRiderGameControlActionsCache& ActionsCache);
    ~FRiderGameControl();
private:
    void RequestPlayWorldCommand(const FCachedCommandInfo& CommandInfo, int RequestID);

    void SendRequestSucceed(int RequestID);
    void SendRequestFailed(int RequestID, JetBrains::EditorPlugin::NotificationType Type, const FString& Message);

    void ScheduleModelAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Action);

private:
    FRiderGameControlActionsCache& Actions;
    JetBrains::EditorPlugin::RdEditorModel const &Model;

    int32_t playMode;

    FDelegateHandle BeginPIEHandle;
    FDelegateHandle EndPIEHandle;
    FDelegateHandle PausePIEHandle;
    FDelegateHandle ResumePIEHandle;
    FDelegateHandle SingleStepPIEHandle;
    FDelegateHandle OnObjectPropertyChangedHandle;
};


void FRiderGameControl::SendRequestSucceed(int RequestID)
{
    using namespace JetBrains::EditorPlugin;
    ScheduleModelAction([=](RdEditorModel const& EditorModel)
    {
        EditorModel.get_notificationReplyFromEditor().fire(RequestSucceed(RequestID));
    });
}

void FRiderGameControl::SendRequestFailed(int RequestID, JetBrains::EditorPlugin::NotificationType Type,
                                          const FString& Message)
{
    using namespace JetBrains::EditorPlugin;
    ScheduleModelAction([=](RdEditorModel const& EditorModel)
    {
        EditorModel.get_notificationReplyFromEditor().fire(RequestFailed(Type, Message, RequestID));
    });
}

void FRiderGameControl::RequestPlayWorldCommand(const FCachedCommandInfo& CommandInfo, int RequestID)
{
    using namespace JetBrains::EditorPlugin;
    if (!CommandInfo.Command.IsValid())
    {
        const FString Message = FString::Format(TEXT("Command '{0}' was not executed.\nCommand was not registered in Unreal Engine"),
                                                {CommandInfo.CommandName.ToString()});
        SendRequestFailed(RequestID, NotificationType::Error, Message);
        return;
    }
    AsyncTask(ENamedThreads::GameThread, [=]()
    {
        if (FPlayWorldCommands::GlobalPlayWorldActions->TryExecuteAction(CommandInfo.Command.ToSharedRef()))
        {
            SendRequestSucceed(RequestID);
        }
        else
        {
            const FString Message = FString::Format(TEXT("Command '{0}' was not executed.\nRejected by Unreal Engine"),
                                                    {CommandInfo.CommandName.ToString()});
            SendRequestFailed(RequestID, NotificationType::Message, Message);
        }
    });
}

void FRiderGameControl::ScheduleModelAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Action)
{
    IRiderLinkModule& RiderLinkModule = IRiderLinkModule::Get();
    RiderLinkModule.QueueAction([Action, this]()
    {
        Action(Model);
    });
}

FRiderGameControl::FRiderGameControl(rd::Lifetime Lifetime, JetBrains::EditorPlugin::RdEditorModel const &Model, FRiderGameControlActionsCache& ActionsCache) :
    Actions(ActionsCache), Model(Model)
{
    using namespace JetBrains::EditorPlugin;
    
    // Subscribe to Editor events
    Lifetime->bracket(
        [this]()
        {
            BeginPIEHandle = FEditorDelegates::BeginPIE.AddLambda([this](const bool)
            {
                ScheduleModelAction([](RdEditorModel const& model)
                {
                    model.get_playStateFromEditor().fire(PlayState::Play);
                });
            });
            EndPIEHandle = FEditorDelegates::EndPIE.AddLambda([this](const bool)
            {
                ScheduleModelAction([](RdEditorModel const& model)
                {
                    model.get_playStateFromEditor().fire(PlayState::Idle);
                });
            });
            PausePIEHandle = FEditorDelegates::PausePIE.AddLambda([this](const bool)
            {
                ScheduleModelAction([](RdEditorModel const& model)
                {
                    model.get_playStateFromEditor().fire(PlayState::Pause);
                });
            });
            ResumePIEHandle = FEditorDelegates::ResumePIE.AddLambda([this](const bool)
            {
                ScheduleModelAction([](RdEditorModel const& model)
                {
                    model.get_playStateFromEditor().fire(PlayState::Play);
                });
            });
            SingleStepPIEHandle = FEditorDelegates::SingleStepPIE.AddLambda([this](const bool)
            {
                ScheduleModelAction([](RdEditorModel const& model)
                {
                    model.get_playStateFromEditor().fire(PlayState::Play);
                    model.get_playStateFromEditor().fire(PlayState::Pause);
                });
            });

            OnObjectPropertyChangedHandle = FCoreUObjectDelegates::OnObjectPropertyChanged.AddLambda(
                [this](UObject* obj, FPropertyChangedEvent& ev)
                {
                    ULevelEditorPlaySettings* PlayInSettings = GetMutableDefault<ULevelEditorPlaySettings>();
                    if (!PlayInSettings || obj != PlayInSettings) return;

                    const FPlaySettings Settings = RetrieveSettings(PlayInSettings);
                    int PlayModeNew = FPlaySettings::PackToMode(Settings);
                    if (PlayModeNew == playMode) return;

                    playMode = PlayModeNew;
                    ScheduleModelAction([PlayModeNew](RdEditorModel const& Model)
                    {
                        Model.get_playModeFromEditor().fire(PlayModeNew);
                    });
                }
            );
        },
        [this]()
        {
            FCoreUObjectDelegates::OnObjectPropertyChanged.Remove(OnObjectPropertyChangedHandle);
            FEditorDelegates::SingleStepPIE.Remove(SingleStepPIEHandle);
            FEditorDelegates::ResumePIE.Remove(ResumePIEHandle);
            FEditorDelegates::PausePIE.Remove(PausePIEHandle);
            FEditorDelegates::EndPIE.Remove(EndPIEHandle);
            FEditorDelegates::BeginPIE.Remove(BeginPIEHandle);
        }
    );

    // Subscribe to model
    ScheduleModelAction([Lifetime, this](RdEditorModel const& Model)
    {
        Model.get_requestPlayFromRider()
             .advise(Lifetime, [this](int requestID)
                     {
                         const ULevelEditorPlaySettings* PlayInSettings
                             = GetDefault<ULevelEditorPlaySettings>();
                         check(PlayInSettings);
                         const EPlayModeType PlayMode = PlayInSettings->LastExecutedPlayModeType;

                         RequestPlayWorldCommand(Actions.PlayModeCommands[PlayMode], requestID);
                     }
             );
        Model.get_requestPauseFromRider()
             .advise(Lifetime, [this](int requestID)
                     {
                         RequestPlayWorldCommand(Actions.PausePlaySession, requestID);
                     }
             );
        Model.get_requestResumeFromRider()
             .advise(Lifetime, [this](int requestID)
                     {
                         RequestPlayWorldCommand(Actions.ResumePlaySession, requestID);
                     }
             );
        Model.get_requestStopFromRider()
             .advise(Lifetime, [this](int requestID)
                     {
                         RequestPlayWorldCommand(Actions.StopPlaySession, requestID);
                     }
             );
        Model.get_requestFrameSkipFromRider()
             .advise(Lifetime, [this](int requestID)
                     {
                         RequestPlayWorldCommand(Actions.SingleFrameAdvance, requestID);
                     }
             );

        Model.get_playModeFromRider()
             .advise(Lifetime, [this](int32_t mode)
                     {
                         ULevelEditorPlaySettings* PlayInSettings
                             = GetMutableDefault<ULevelEditorPlaySettings>();
                         check(PlayInSettings);
                         const FPlaySettings NewSettings = FPlaySettings::UnpackFromMode(mode);
                         UpdateSettings(PlayInSettings, NewSettings);
                     }
             );
    });

    // Initial sync.
    const ULevelEditorPlaySettings* PlayInSettings = GetDefault<ULevelEditorPlaySettings>();
    check(PlayInSettings);
    const FPlaySettings Settings = RetrieveSettings(PlayInSettings);
    playMode = FPlaySettings::PackToMode(Settings);

    ScheduleModelAction([lambdaPlayMode=playMode](RdEditorModel const &Model)
    {
        Model.get_playModeFromEditor().fire(lambdaPlayMode);
    });

    // After all initialization finished/scheduled - mark that module was initialized
    Lifetime->bracket(
        [this]()
        {
            ScheduleModelAction([](RdEditorModel const& Model)
            {
                Model.get_isGameControlModuleInitialized().set(true);
            });
        },
        [this]()
        {
            ScheduleModelAction([](RdEditorModel const& Model)
            {
                Model.get_isGameControlModuleInitialized().set(false);
            });
        }
    );
}

FRiderGameControl::~FRiderGameControl()
{
}


void FRiderGameControlModule::StartupModule()
{
    using namespace JetBrains::EditorPlugin;
    
    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT("STARTUP START"));

    // Actions cache is not related to connection and its lifetimes
    ActionsCache = MakeUnique<FRiderGameControlActionsCache>();

    IRiderLinkModule& RiderLinkModule = IRiderLinkModule::Get();
    ModuleLifetimeDefinition = RiderLinkModule.CreateNestedLifetimeDefinition();
    rd::Lifetime ModuleLifetime = ModuleLifetimeDefinition.lifetime;

    RiderLinkModule.ViewModel(
        ModuleLifetime,
        [&](rd::Lifetime ModelLifetime, RdEditorModel const& Model)
        {
            ModelLifetime->add_action([&]() { GameControl.Reset(); });
            GameControl = MakeUnique<FRiderGameControl>(ModelLifetime, Model, *ActionsCache);
        }
    );

    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT("STARTUP FINISH"));
}

void FRiderGameControlModule::ShutdownModule()
{
    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT("SHUTDOWN START"));
    ModuleLifetimeDefinition.terminate();
    ActionsCache.Reset();
    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT("SHUTDOWN FINISH"));
}

```

`Plugins/Developer/RiderLink/Source/RiderGameControl/Public/RiderGameControl.hpp`:

```hpp
#pragma once

#include "lifetime/LifetimeDefinition.h"

#include "Logging/LogMacros.h"
#include "Logging/LogVerbosity.h"
#include "Modules/ModuleInterface.h"
#include "Templates/UniquePtr.h"

DECLARE_LOG_CATEGORY_EXTERN(FLogRiderGameControlModule, Log, All);

class FRiderGameControl;
class FRiderGameControlActionsCache;

class FRiderGameControlModule : public IModuleInterface
{
public:
    FRiderGameControlModule() = default;
    virtual ~FRiderGameControlModule() override = default;

    /** IModuleInterface implementation */
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
    virtual bool SupportsDynamicReloading() override { return true; }

private:
    rd::LifetimeDefinition ModuleLifetimeDefinition;
    TUniquePtr<FRiderGameControl> GameControl;
    TUniquePtr<FRiderGameControlActionsCache> ActionsCache;
};

```

`Plugins/Developer/RiderLink/Source/RiderGameControl/RiderGameControl.Build.cs`:

```cs
// Copyright 1998-2020 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class RiderGameControl : ModuleRules
{
	public RiderGameControl(ReadOnlyTargetRules Target) : base(Target)
	{
#if UE_4_22_OR_LATER
		PCHUsage = PCHUsageMode.NoPCHs;
#else
		PCHUsage = PCHUsageMode.NoSharedPCHs;
#endif
		
		bUseRTTI = true;

		PublicDependencyModuleNames.Add("Core");

		PrivateDependencyModuleNames.AddRange(new []
		{
			"RD",
			"RiderLink",
			"HeadMountedDisplay",
			"LevelEditor",
			"UnrealEd",
			"Slate",
			"CoreUObject",
			"Engine"
		});
	}
}

```

`Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp`:

```cpp
#include "ProtocolFactory.h"

#include "scheduler/base/IScheduler.h"
#include "wire/SocketWire.h"

#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION >= 5
#include "HAL/PlatformFileManager.h"
#else
#include "HAL/PlatformFilemanager.h"
#endif
#include "Misc/App.h"
#include "Misc/FileHelper.h"
#include "Misc/Paths.h"

#if PLATFORM_WINDOWS
// ReSharper disable once CppUnusedIncludeDirective
#include "Windows/AllowWindowsPlatformTypes.h"
#include "Windows/PreWindowsApi.h"

#include "Windows/WindowsPlatformMisc.h"

#include "Windows/PostWindowsApi.h"
// ReSharper disable once CppUnusedIncludeDirective
#include "Windows/HideWindowsPlatformTypes.h"
#endif

#include "spdlog/sinks/daily_file_sink.h"

static FString GetLocalAppdataFolder()
{
    const FString EnvironmentVarName =
#if PLATFORM_WINDOWS
TEXT("LOCALAPPDATA");
#else
    TEXT("HOME");
#endif
#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 20
    TCHAR CAppDataLocalPath[4096];
    FPlatformMisc::GetEnvironmentVariable(*EnvironmentVarName, CAppDataLocalPath, ARRAY_COUNT(CAppDataLocalPath));
    return CAppDataLocalPath;
#else
    return FPlatformMisc::GetEnvironmentVariable(*EnvironmentVarName);
#endif
}

static FString GetMiscFilesFolder()
{    
    FString FAppDataLocalPath = GetLocalAppdataFolder();
    FPaths::NormalizeFilename(FAppDataLocalPath);
    return FPaths::Combine(*FAppDataLocalPath,
#if PLATFORM_WINDOWS
        TEXT("Jetbrains"), TEXT("Rider"), TEXT("Unreal")
#elif PLATFORM_MAC
        TEXT("Library"), TEXT("Logs"), TEXT("Unreal Engine")
#else
        TEXT(".config"), TEXT("unrealEngine")
#endif
    );
}

static FString GetPathToPortsFolder()
{
    const FString MiscFilesFolder = GetMiscFilesFolder();
    return FPaths::Combine(*MiscFilesFolder, TEXT("Ports"));
}

static FString GetLogFile(const FString& projectName)
{
    const FString MiscFilesFolder = GetMiscFilesFolder();
    return FPaths::Combine(*MiscFilesFolder, TEXT("Logs"), projectName + TEXT(".uproject"));
}

ProtocolFactory::ProtocolFactory(const FString& ProjectName): ProjectName(ProjectName)
{
    InitRdLogging();
}

void ProtocolFactory::InitRdLogging()
{
    spdlog::set_level(spdlog::level::err);
#if defined(ENABLE_LOG_FILE) && ENABLE_LOG_FILE == 1
    const FString LogFile = GetLogFile(ProjectName);
    const FString Msg = TEXT("[RiderLink] Path to log file: ") + LogFile;
    auto FileLogger = std::make_shared<spdlog::sinks::daily_file_sink_mt>(*LogFile, 23, 59);
    FileLogger->set_level(spdlog::level::trace);
    spdlog::apply_all([FileLogger](std::shared_ptr<spdlog::logger> Logger)
    {
        Logger->sinks().push_back(FileLogger);
    });
#endif
}

std::shared_ptr<rd::SocketWire::Server> ProtocolFactory::CreateWire(rd::IScheduler* Scheduler, rd::Lifetime SocketLifetime)
{
    return std::make_shared<rd::SocketWire::Server>(SocketLifetime, Scheduler, 0,
                                                         TCHAR_TO_UTF8(*FString::Printf(TEXT("UnrealEditorServer-%s"),
                                                             *ProjectName)));
}


TUniquePtr<rd::Protocol> ProtocolFactory::CreateProtocol(rd::IScheduler* Scheduler, rd::Lifetime SocketLifetime, std::shared_ptr<rd::SocketWire::Server> wire)
{
    auto protocol = MakeUnique<rd::Protocol>(rd::Identities::SERVER, Scheduler, wire, SocketLifetime);

    auto& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    const FString PortFullDirectoryPath = GetPathToPortsFolder();
    if (PlatformFile.CreateDirectoryTree(*PortFullDirectoryPath) && !IsRunningCommandlet())
    {
        const FString ProjectFileName = ProjectName + TEXT(".uproject");
        const FString TmpPortFile = TEXT("~") + ProjectFileName;
        const FString TmpPortFileFullPath = FPaths::Combine(*PortFullDirectoryPath, *TmpPortFile);
        FFileHelper::SaveStringToFile(FString::FromInt(wire->port), *TmpPortFileFullPath);
        const FString PortFileFullPath = FPaths::Combine(*PortFullDirectoryPath, *ProjectFileName);
        IFileManager::Get().Move(*PortFileFullPath, *TmpPortFileFullPath, true, true);
    }
    return protocol;
}

```

`Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.h`:

```h
#pragma once

#include <protocol/Protocol.h>
#include "wire/SocketWire.h"

#include "Containers/UnrealString.h"
#include "Templates/UniquePtr.h"

class ProtocolFactory
{
public:
	explicit ProtocolFactory(const FString& ProjectName);

	std::shared_ptr<rd::SocketWire::Server> CreateWire(rd::IScheduler* Scheduler, rd::Lifetime SocketLifetime);
	TUniquePtr<rd::Protocol> CreateProtocol(rd::IScheduler* Scheduler, rd::Lifetime SocketLifetime,
	                                        std::shared_ptr<rd::SocketWire::Server> wire);

private:
	void InitRdLogging();

private:
	FString ProjectName;
};

```

`Plugins/Developer/RiderLink/Source/RiderLink/Private/RiderLink.cpp`:

```cpp
#include "RiderLink.hpp"

#include "ProtocolFactory.h"
#include "UE4Library/UE4Library.Generated.h"

#include "Misc/App.h"
#include "Misc/ScopeRWLock.h"
#include "Modules/ModuleManager.h"
#include "HAL/Platform.h"

#define LOCTEXT_NAMESPACE "RiderLink"

DEFINE_LOG_CATEGORY(FLogRiderLinkModule);

IMPLEMENT_MODULE(FRiderLinkModule, RiderLink);

static FString GetProjectName()
{
	FString ProjectNameNoExtension = FApp::GetProjectName();
	if (ProjectNameNoExtension.IsEmpty())
		ProjectNameNoExtension = TEXT("<ENGINE>");
	return ProjectNameNoExtension;
}

void FRiderLinkModule::ShutdownModule()
{
	UE_LOG(FLogRiderLinkModule, Verbose, TEXT("RiderLink SHUTDOWN START"));
	ModuleLifetimeDef.terminate();
	ProtocolFactory.Reset();
	UE_LOG(FLogRiderLinkModule, Verbose, TEXT("RiderLink SHUTDOWN FINISH"));
}

void FRiderLinkModule::StartupModule()
{
	UE_LOG(FLogRiderLinkModule, Verbose, TEXT("RiderLink STARTUP START"));
	ProtocolFactory = MakeUnique<class ProtocolFactory>(GetProjectName());
	Scheduler.queue([this]()
	{
		InitProtocol();
	});
	UE_LOG(FLogRiderLinkModule, Verbose, TEXT("RiderLink STARTUP FINISH"));
}

void FRiderLinkModule::InitProtocol()
{
	WireLifetimeDef = MakeUnique<rd::LifetimeDefinition>(ModuleLifetimeDef.lifetime);
	rd::Lifetime WireLifetime = WireLifetimeDef->lifetime;
	std::shared_ptr<rd::SocketWire::Server> Wire = ProtocolFactory->CreateWire(&Scheduler, WireLifetime);
	Protocol = ProtocolFactory->CreateProtocol(&Scheduler, WireLifetime.create_nested(), Wire);
	// Exception fired for Server::Base::~Base() when trying to invoke it this way
//	WireLifetime->add_action([this]()
//	{
//		if (!ModuleLifetimeDef.is_terminated())
//		{
//			Scheduler.queue([this]()
//			{
//				InitProtocol();
//			});
//		}
//	});
	Protocol->wire->connected.view(WireLifetime, [this](rd::Lifetime ConnectionLifetime, bool const& IsConnected)
	{
		Scheduler.queue([this, ConnectionLifetime, IsConnected]()
		{
			if (!IsConnected) return;

			FRWScopeLock LockOnConnect(ModelLock, SLT_Write);
			EditorModel = MakeUnique<JetBrains::EditorPlugin::RdEditorModel>();
			EditorModel->connect(ConnectionLifetime, Protocol.Get());
			JetBrains::EditorPlugin::UE4Library::serializersOwner.registerSerializersCore(
				EditorModel->get_serialization_context().get_serializers()
			);
			ConnectionLifetime->add_action([&]() mutable
			{
				Scheduler.queue([&]()mutable
				{
                    FRWScopeLock LockOnDisconnect(ModelLock, SLT_Write);
                    RdIsModelAlive.set(false);
				});
			});
			RdIsModelAlive.set(true);
			
			FString projectName = GetProjectName();
			FString executableName = FPlatformProcess::ExecutableName(false);
			uint32_t pid = FPlatformProcess::GetCurrentProcessId();
			
			std::wstring projectNameWstr = TCHAR_TO_WCHAR(GetData(projectName));
			std::wstring executableNameWstr = TCHAR_TO_WCHAR(GetData(executableName));
			auto connectionInfo = JetBrains::EditorPlugin::ConnectionInfo(projectNameWstr, executableNameWstr, pid);
			EditorModel->get_connectionInfo().set(connectionInfo);
		});
	});
}

bool FRiderLinkModule::SupportsDynamicReloading() { return true; }


// Can't place RdEditorModel or TUniquePtr<RdEditorModel> into RdProperty.
// Have to resort to RdProperty<bool> and change it before creating new RdEditorModel
void FRiderLinkModule::ViewModel(rd::Lifetime Lifetime,
                                 TFunction<void(rd::Lifetime, JetBrains::EditorPlugin::RdEditorModel const&)> Handler)
{
	Scheduler.invoke_or_queue([this, Lifetime, Handler]
	{
		RdIsModelAlive.view(Lifetime, [this, Handler](rd::Lifetime ModelLifetime, bool const& Cond)
		{
			if (Cond) Handler(ModelLifetime, *EditorModel.Get());
		});
	});
}

void FRiderLinkModule::QueueAction(TFunction<void()> Handler)
{
	Scheduler.invoke_or_queue([this, Handler]
	{
		Handler();
	});
}

bool FRiderLinkModule::FireAsyncAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Handler)
{
	FRWScopeLock Lock(ModelLock, SLT_ReadOnly);
	if(!RdIsModelAlive.has_value()) return false;
	
	if(RdIsModelAlive.get())
	{
		Handler(*EditorModel.Get());
	}
	return RdIsModelAlive.get();
}

#undef LOCTEXT_NAMESPACE

```

`Plugins/Developer/RiderLink/Source/RiderLink/Private/RiderLink.hpp`:

```hpp
#pragma once

#include "IRiderLink.hpp"
#include "impl/RdProperty.h"
#include "lifetime/LifetimeDefinition.h"
#include "scheduler/SingleThreadScheduler.h"
#include "wire/SocketWire.h"

#include "Logging/LogMacros.h"
#include "Logging/LogVerbosity.h"
#include "Modules/ModuleManager.h"

#include "RdEditorModel/RdEditorModel.Generated.h"

class ProtocolFactory;

namespace rd
{
	class Protocol;
}

DECLARE_LOG_CATEGORY_EXTERN(FLogRiderLinkModule, Log, All);

class RIDERLINK_API FRiderLinkModule : public IRiderLinkModule
{
public:
	FRiderLinkModule() = default;
	virtual ~FRiderLinkModule() override = default;

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
	virtual bool SupportsDynamicReloading() override;

	virtual rd::LifetimeDefinition CreateNestedLifetimeDefinition() const override
	{
		return rd::LifetimeDefinition{ModuleLifetimeDef.lifetime};
	}

	virtual void ViewModel(rd::Lifetime Lifetime,
	                       TFunction<void(rd::Lifetime,
	                                      JetBrains::EditorPlugin::RdEditorModel const&)> Handler) override;
	virtual void QueueAction(TFunction<void()> Handler) override;
	virtual bool FireAsyncAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Handler) override;

private:
	void InitProtocol();

	rd::LifetimeDefinition ModuleLifetimeDef{rd::Lifetime::Eternal()};
	rd::SingleThreadScheduler Scheduler{ModuleLifetimeDef.lifetime, "MainScheduler"};
	TUniquePtr<rd::LifetimeDefinition> WireLifetimeDef;
	TUniquePtr<ProtocolFactory> ProtocolFactory;
	TUniquePtr<rd::Protocol> Protocol;
	rd::RdProperty<bool> RdIsModelAlive;
	TUniquePtr<JetBrains::EditorPlugin::RdEditorModel> EditorModel;
	FRWLock ModelLock;
};

```

`Plugins/Developer/RiderLink/Source/RiderLink/Private/UE4TypesMarshallers.cpp`:

```cpp
#include "UE4TypesMarshallers.h"

#include "Containers/StringConv.h"
#include "serialization/ArraySerializer.h"
#include "Templates/UniquePtr.h"

//region FString

namespace rd {

    FString Polymorphic<FString, void>::read(SerializationCtx& ctx, Buffer& buffer) {
        UCS2CHAR * str = buffer.read_char16_string();
        FString tmp{str};
        delete str;
        return tmp;
    }

    void Polymorphic<FString, void>::write(SerializationCtx& ctx, Buffer& buffer, FString const& value) {
        buffer.write_char16_string(reinterpret_cast<const uint16_t*>(GetData(value)), value.Len());
    }


    size_t hash<FString>::operator()(const FString& value) const noexcept {
        return GetTypeHash(value);
    }


}

template class rd::Polymorphic<FString>;
template class rd::Polymorphic<rd::Wrapper<FString>>;
template struct rd::hash<FString>;
// template class rd::Polymorphic<TArray<FString>, void>;

//endregion

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/IRiderLink.hpp`:

```hpp
#pragma once

#include "RdEditorModel/RdEditorModel.Generated.h"
#include "lifetime/LifetimeDefinition.h"

#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"

class RIDERLINK_API IRiderLinkModule : public IModuleInterface
{
public:
	static IRiderLinkModule& Get()
	{		
		return FModuleManager::GetModuleChecked<IRiderLinkModule>(GetModuleName());
	}

	static FName GetModuleName()
	{
		static const FName ModuleName = TEXT("RiderLink");
		return ModuleName;
	}

    // RiderLink API
	virtual rd::LifetimeDefinition CreateNestedLifetimeDefinition() const = 0;
	virtual void ViewModel(rd::Lifetime Lifetime, TFunction<void(rd::Lifetime, JetBrains::EditorPlugin::RdEditorModel const&)> Handler) = 0;
	virtual void QueueAction(TFunction<void()> Handler) = 0;
	virtual bool FireAsyncAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Handler) = 0;
};

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.7)
add_library(UE4Library STATIC 
instantiations_UE4Library.h
instantiations_UE4Library.cpp
UE4Library/StringRange.Generated.cpp
UE4Library/StringRange.Generated.h
UE4Library/PlayState.Generated.cpp
UE4Library/PlayState.Generated.h
UE4Library/RequestResultBase.Generated.cpp
UE4Library/RequestResultBase.Generated.h
UE4Library/RequestSucceed.Generated.cpp
UE4Library/RequestSucceed.Generated.h
UE4Library/RequestFailed.Generated.cpp
UE4Library/RequestFailed.Generated.h
UE4Library/LogMessageInfo.Generated.cpp
UE4Library/LogMessageInfo.Generated.h
UE4Library/UnrealLogEvent.Generated.cpp
UE4Library/UnrealLogEvent.Generated.h
UE4Library/UClass.Generated.cpp
UE4Library/UClass.Generated.h
UE4Library/BlueprintFunction.Generated.cpp
UE4Library/BlueprintFunction.Generated.h
UE4Library/ScriptCallStackFrame.Generated.cpp
UE4Library/ScriptCallStackFrame.Generated.h
UE4Library/IScriptCallStack.Generated.cpp
UE4Library/IScriptCallStack.Generated.h
UE4Library/EmptyScriptCallStack.Generated.cpp
UE4Library/EmptyScriptCallStack.Generated.h
UE4Library/ScriptCallStack.Generated.cpp
UE4Library/ScriptCallStack.Generated.h
UE4Library/UnableToDisplayScriptCallStack.Generated.cpp
UE4Library/UnableToDisplayScriptCallStack.Generated.h
UE4Library/IScriptMsg.Generated.cpp
UE4Library/IScriptMsg.Generated.h
UE4Library/ScriptMsgException.Generated.cpp
UE4Library/ScriptMsgException.Generated.h
UE4Library/ScriptMsgCallStack.Generated.cpp
UE4Library/ScriptMsgCallStack.Generated.h
UE4Library/BlueprintHighlighter.Generated.cpp
UE4Library/BlueprintHighlighter.Generated.h
UE4Library/BlueprintReference.Generated.cpp
UE4Library/BlueprintReference.Generated.h
UE4Library/ConnectionInfo.Generated.cpp
UE4Library/ConnectionInfo.Generated.h
UE4Library/NotificationType.Generated.cpp
UE4Library/NotificationType.Generated.h
UE4Library/UE4Library.Generated.cpp
UE4Library/UE4Library.Generated.h
UE4Library/RequestResultBase_Unknown.Generated.cpp
UE4Library/RequestResultBase_Unknown.Generated.h
UE4Library/IScriptCallStack_Unknown.Generated.cpp
UE4Library/IScriptCallStack_Unknown.Generated.h
UE4Library/IScriptMsg_Unknown.Generated.cpp
UE4Library/IScriptMsg_Unknown.Generated.h)
target_include_directories(UE4Library PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_link_libraries(UE4Library PUBLIC rd_framework_cpp)

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/BlueprintFunction.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "BlueprintFunction.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
constexpr rd::wstring_view BlueprintFunction::separator;
// initializer
void BlueprintFunction::initialize()
{
}
// primary ctor
BlueprintFunction::BlueprintFunction(rd::Wrapper<UClass> class_, FString name_) :
rd::IPolymorphicSerializable()
,class_(std::move(class_)), name_(std::move(name_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
BlueprintFunction BlueprintFunction::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto class_ = UClass::read(ctx, buffer);
    auto name_ = rd::Polymorphic<FString>::read(ctx, buffer);
    BlueprintFunction res{std::move(class_), std::move(name_)};
    return res;
}
// writer
void BlueprintFunction::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(class_)>>::write(ctx, buffer, class_);
    rd::Polymorphic<std::decay_t<decltype(name_)>>::write(ctx, buffer, name_);
}
// virtual init
// identify
// getters
UClass const & BlueprintFunction::get_class() const
{
    return *class_;
}
FString const & BlueprintFunction::get_name() const
{
    return name_;
}
// intern
// equals trait
bool BlueprintFunction::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<BlueprintFunction const&>(object);
    if (this == &other) return true;
    if (this->class_ != other.class_) return false;
    if (this->name_ != other.name_) return false;
    
    return true;
}
// equality operators
bool operator==(const BlueprintFunction &lhs, const BlueprintFunction &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const BlueprintFunction &lhs, const BlueprintFunction &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t BlueprintFunction::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<UClass>()(get_class()));
    __r = __r * 31 + (rd::hash<FString>()(get_name()));
    return __r;
}
// type name trait
std::string BlueprintFunction::type_name() const
{
    return "BlueprintFunction";
}
// static type name trait
std::string BlueprintFunction::static_type_name()
{
    return "BlueprintFunction";
}
// polymorphic to string
std::string BlueprintFunction::toString() const
{
    std::string res = "BlueprintFunction\n";
    res += "\tclass = ";
    res += rd::to_string(class_);
    res += '\n';
    res += "\tname = ";
    res += rd::to_string(name_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const BlueprintFunction & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/BlueprintFunction.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef BLUEPRINTFUNCTION_GENERATED_H
#define BLUEPRINTFUNCTION_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4Library/UClass.Generated.h"
#include "Runtime/Core/Public/Containers/UnrealString.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:136</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API BlueprintFunction : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants
    static constexpr rd::wstring_view separator{L":", 1};

protected:
    // fields
    rd::Wrapper<UClass> class_;
    FString name_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    BlueprintFunction(rd::Wrapper<UClass> class_, FString name_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 2) static_assert (I < 0 || I >= 2, "I < 0 || I >= 2");
        else if constexpr (I==0)  return static_cast<const UClass&>(get_class());
        else if constexpr (I==1)  return static_cast<const FString&>(get_name());
    }
    #endif
    
    // default ctors and dtors
    
    BlueprintFunction() = delete;
    
    BlueprintFunction(BlueprintFunction const &) = default;
    
    BlueprintFunction& operator=(BlueprintFunction const &) = default;
    
    BlueprintFunction(BlueprintFunction &&) = default;
    
    BlueprintFunction& operator=(BlueprintFunction &&) = default;
    
    virtual ~BlueprintFunction() = default;
    
    // reader
    static BlueprintFunction read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    UClass const & get_class() const;
    FString const & get_name() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const BlueprintFunction &lhs, const BlueprintFunction &rhs);
    friend bool operator!=(const BlueprintFunction &lhs, const BlueprintFunction &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const BlueprintFunction & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::BlueprintFunction> {
    size_t operator()(const JetBrains::EditorPlugin::BlueprintFunction & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::BlueprintFunction> : public integral_constant<size_t, 2> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::BlueprintFunction> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::BlueprintFunction>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // BLUEPRINTFUNCTION_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/BlueprintHighlighter.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "BlueprintHighlighter.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void BlueprintHighlighter::initialize()
{
}
// primary ctor
BlueprintHighlighter::BlueprintHighlighter(int32_t begin_, int32_t end_) :
rd::IPolymorphicSerializable()
,begin_(std::move(begin_)), end_(std::move(end_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
BlueprintHighlighter BlueprintHighlighter::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto begin_ = buffer.read_integral<int32_t>();
    auto end_ = buffer.read_integral<int32_t>();
    BlueprintHighlighter res{std::move(begin_), std::move(end_)};
    return res;
}
// writer
void BlueprintHighlighter::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_integral(begin_);
    buffer.write_integral(end_);
}
// virtual init
// identify
// getters
int32_t const & BlueprintHighlighter::get_begin() const
{
    return begin_;
}
int32_t const & BlueprintHighlighter::get_end() const
{
    return end_;
}
// intern
// equals trait
bool BlueprintHighlighter::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<BlueprintHighlighter const&>(object);
    if (this == &other) return true;
    if (this->begin_ != other.begin_) return false;
    if (this->end_ != other.end_) return false;
    
    return true;
}
// equality operators
bool operator==(const BlueprintHighlighter &lhs, const BlueprintHighlighter &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const BlueprintHighlighter &lhs, const BlueprintHighlighter &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t BlueprintHighlighter::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<int32_t>()(get_begin()));
    __r = __r * 31 + (rd::hash<int32_t>()(get_end()));
    return __r;
}
// type name trait
std::string BlueprintHighlighter::type_name() const
{
    return "BlueprintHighlighter";
}
// static type name trait
std::string BlueprintHighlighter::static_type_name()
{
    return "BlueprintHighlighter";
}
// polymorphic to string
std::string BlueprintHighlighter::toString() const
{
    std::string res = "BlueprintHighlighter\n";
    res += "\tbegin = ";
    res += rd::to_string(begin_);
    res += '\n';
    res += "\tend = ";
    res += rd::to_string(end_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const BlueprintHighlighter & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/BlueprintHighlighter.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef BLUEPRINTHIGHLIGHTER_GENERATED_H
#define BLUEPRINTHIGHLIGHTER_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:195</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API BlueprintHighlighter : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    int32_t begin_;
    int32_t end_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    BlueprintHighlighter(int32_t begin_, int32_t end_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 2) static_assert (I < 0 || I >= 2, "I < 0 || I >= 2");
        else if constexpr (I==0)  return static_cast<const int32_t&>(get_begin());
        else if constexpr (I==1)  return static_cast<const int32_t&>(get_end());
    }
    #endif
    
    // default ctors and dtors
    
    BlueprintHighlighter() = delete;
    
    BlueprintHighlighter(BlueprintHighlighter const &) = default;
    
    BlueprintHighlighter& operator=(BlueprintHighlighter const &) = default;
    
    BlueprintHighlighter(BlueprintHighlighter &&) = default;
    
    BlueprintHighlighter& operator=(BlueprintHighlighter &&) = default;
    
    virtual ~BlueprintHighlighter() = default;
    
    // reader
    static BlueprintHighlighter read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    int32_t const & get_begin() const;
    int32_t const & get_end() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const BlueprintHighlighter &lhs, const BlueprintHighlighter &rhs);
    friend bool operator!=(const BlueprintHighlighter &lhs, const BlueprintHighlighter &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const BlueprintHighlighter & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::BlueprintHighlighter> {
    size_t operator()(const JetBrains::EditorPlugin::BlueprintHighlighter & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::BlueprintHighlighter> : public integral_constant<size_t, 2> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::BlueprintHighlighter> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::BlueprintHighlighter>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // BLUEPRINTHIGHLIGHTER_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/BlueprintReference.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "BlueprintReference.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void BlueprintReference::initialize()
{
}
// primary ctor
BlueprintReference::BlueprintReference(FString pathName_, FString guid_) :
rd::IPolymorphicSerializable()
,pathName_(std::move(pathName_)), guid_(std::move(guid_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
BlueprintReference BlueprintReference::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto pathName_ = rd::Polymorphic<FString>::read(ctx, buffer);
    auto guid_ = rd::Polymorphic<FString>::read(ctx, buffer);
    BlueprintReference res{std::move(pathName_), std::move(guid_)};
    return res;
}
// writer
void BlueprintReference::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(pathName_)>>::write(ctx, buffer, pathName_);
    rd::Polymorphic<std::decay_t<decltype(guid_)>>::write(ctx, buffer, guid_);
}
// virtual init
// identify
// getters
FString const & BlueprintReference::get_pathName() const
{
    return pathName_;
}
FString const & BlueprintReference::get_guid() const
{
    return guid_;
}
// intern
// equals trait
bool BlueprintReference::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<BlueprintReference const&>(object);
    if (this == &other) return true;
    if (this->pathName_ != other.pathName_) return false;
    if (this->guid_ != other.guid_) return false;
    
    return true;
}
// equality operators
bool operator==(const BlueprintReference &lhs, const BlueprintReference &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const BlueprintReference &lhs, const BlueprintReference &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t BlueprintReference::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<FString>()(get_pathName()));
    __r = __r * 31 + (rd::hash<FString>()(get_guid()));
    return __r;
}
// type name trait
std::string BlueprintReference::type_name() const
{
    return "BlueprintReference";
}
// static type name trait
std::string BlueprintReference::static_type_name()
{
    return "BlueprintReference";
}
// polymorphic to string
std::string BlueprintReference::toString() const
{
    std::string res = "BlueprintReference\n";
    res += "\tpathName = ";
    res += rd::to_string(pathName_);
    res += '\n';
    res += "\tguid = ";
    res += rd::to_string(guid_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const BlueprintReference & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/BlueprintReference.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef BLUEPRINTREFERENCE_GENERATED_H
#define BLUEPRINTREFERENCE_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "Runtime/Core/Public/Containers/UnrealString.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:200</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API BlueprintReference : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    FString pathName_;
    FString guid_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    BlueprintReference(FString pathName_, FString guid_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 2) static_assert (I < 0 || I >= 2, "I < 0 || I >= 2");
        else if constexpr (I==0)  return static_cast<const FString&>(get_pathName());
        else if constexpr (I==1)  return static_cast<const FString&>(get_guid());
    }
    #endif
    
    // default ctors and dtors
    
    BlueprintReference() = delete;
    
    BlueprintReference(BlueprintReference const &) = default;
    
    BlueprintReference& operator=(BlueprintReference const &) = default;
    
    BlueprintReference(BlueprintReference &&) = default;
    
    BlueprintReference& operator=(BlueprintReference &&) = default;
    
    virtual ~BlueprintReference() = default;
    
    // reader
    static BlueprintReference read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    FString const & get_pathName() const;
    FString const & get_guid() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const BlueprintReference &lhs, const BlueprintReference &rhs);
    friend bool operator!=(const BlueprintReference &lhs, const BlueprintReference &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const BlueprintReference & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::BlueprintReference> {
    size_t operator()(const JetBrains::EditorPlugin::BlueprintReference & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::BlueprintReference> : public integral_constant<size_t, 2> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::BlueprintReference> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::BlueprintReference>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // BLUEPRINTREFERENCE_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ConnectionInfo.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "ConnectionInfo.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void ConnectionInfo::initialize()
{
}
// primary ctor
ConnectionInfo::ConnectionInfo(rd::Wrapper<std::wstring> projectName_, rd::Wrapper<std::wstring> executableName_, int32_t processId_) :
rd::IPolymorphicSerializable()
,projectName_(std::move(projectName_)), executableName_(std::move(executableName_)), processId_(std::move(processId_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
ConnectionInfo ConnectionInfo::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto projectName_ = buffer.read_wstring();
    auto executableName_ = buffer.read_wstring();
    auto processId_ = buffer.read_integral<int32_t>();
    ConnectionInfo res{std::move(projectName_), std::move(executableName_), std::move(processId_)};
    return res;
}
// writer
void ConnectionInfo::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_wstring(projectName_);
    buffer.write_wstring(executableName_);
    buffer.write_integral(processId_);
}
// virtual init
// identify
// getters
std::wstring const & ConnectionInfo::get_projectName() const
{
    return *projectName_;
}
std::wstring const & ConnectionInfo::get_executableName() const
{
    return *executableName_;
}
int32_t const & ConnectionInfo::get_processId() const
{
    return processId_;
}
// intern
// equals trait
bool ConnectionInfo::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<ConnectionInfo const&>(object);
    if (this == &other) return true;
    if (this->projectName_ != other.projectName_) return false;
    if (this->executableName_ != other.executableName_) return false;
    if (this->processId_ != other.processId_) return false;
    
    return true;
}
// equality operators
bool operator==(const ConnectionInfo &lhs, const ConnectionInfo &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const ConnectionInfo &lhs, const ConnectionInfo &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t ConnectionInfo::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<std::wstring>()(get_projectName()));
    __r = __r * 31 + (rd::hash<std::wstring>()(get_executableName()));
    __r = __r * 31 + (rd::hash<int32_t>()(get_processId()));
    return __r;
}
// type name trait
std::string ConnectionInfo::type_name() const
{
    return "ConnectionInfo";
}
// static type name trait
std::string ConnectionInfo::static_type_name()
{
    return "ConnectionInfo";
}
// polymorphic to string
std::string ConnectionInfo::toString() const
{
    std::string res = "ConnectionInfo\n";
    res += "\tprojectName = ";
    res += rd::to_string(projectName_);
    res += '\n';
    res += "\texecutableName = ";
    res += rd::to_string(executableName_);
    res += '\n';
    res += "\tprocessId = ";
    res += rd::to_string(processId_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const ConnectionInfo & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ConnectionInfo.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef CONNECTIONINFO_GENERATED_H
#define CONNECTIONINFO_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:205</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API ConnectionInfo : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    rd::Wrapper<std::wstring> projectName_;
    rd::Wrapper<std::wstring> executableName_;
    int32_t processId_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    ConnectionInfo(rd::Wrapper<std::wstring> projectName_, rd::Wrapper<std::wstring> executableName_, int32_t processId_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 3) static_assert (I < 0 || I >= 3, "I < 0 || I >= 3");
        else if constexpr (I==0)  return static_cast<const std::wstring&>(get_projectName());
        else if constexpr (I==1)  return static_cast<const std::wstring&>(get_executableName());
        else if constexpr (I==2)  return static_cast<const int32_t&>(get_processId());
    }
    #endif
    
    // default ctors and dtors
    
    ConnectionInfo() = delete;
    
    ConnectionInfo(ConnectionInfo const &) = default;
    
    ConnectionInfo& operator=(ConnectionInfo const &) = default;
    
    ConnectionInfo(ConnectionInfo &&) = default;
    
    ConnectionInfo& operator=(ConnectionInfo &&) = default;
    
    virtual ~ConnectionInfo() = default;
    
    // reader
    static ConnectionInfo read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    std::wstring const & get_projectName() const;
    std::wstring const & get_executableName() const;
    int32_t const & get_processId() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const ConnectionInfo &lhs, const ConnectionInfo &rhs);
    friend bool operator!=(const ConnectionInfo &lhs, const ConnectionInfo &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const ConnectionInfo & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::ConnectionInfo> {
    size_t operator()(const JetBrains::EditorPlugin::ConnectionInfo & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::ConnectionInfo> : public integral_constant<size_t, 3> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::ConnectionInfo> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::ConnectionInfo>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // CONNECTIONINFO_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/EmptyScriptCallStack.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "EmptyScriptCallStack.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
constexpr rd::wstring_view EmptyScriptCallStack::message;
// initializer
void EmptyScriptCallStack::initialize()
{
}
// primary ctor
// secondary constructor
// default ctors and dtors
EmptyScriptCallStack::EmptyScriptCallStack()
{
    initialize();
}
// reader
EmptyScriptCallStack EmptyScriptCallStack::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    EmptyScriptCallStack res{};
    return res;
}
// writer
void EmptyScriptCallStack::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
}
// virtual init
// identify
// getters
// intern
// equals trait
bool EmptyScriptCallStack::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<EmptyScriptCallStack const&>(object);
    if (this == &other) return true;
    
    return true;
}
// equality operators
bool operator==(const EmptyScriptCallStack &lhs, const EmptyScriptCallStack &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const EmptyScriptCallStack &lhs, const EmptyScriptCallStack &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t EmptyScriptCallStack::hashCode() const noexcept
{
    size_t __r = 0;
    return __r;
}
// type name trait
std::string EmptyScriptCallStack::type_name() const
{
    return "EmptyScriptCallStack";
}
// static type name trait
std::string EmptyScriptCallStack::static_type_name()
{
    return "EmptyScriptCallStack";
}
// polymorphic to string
std::string EmptyScriptCallStack::toString() const
{
    std::string res = "EmptyScriptCallStack\n";
    return res;
}
// external to string
std::string to_string(const EmptyScriptCallStack & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/EmptyScriptCallStack.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef EMPTYSCRIPTCALLSTACK_GENERATED_H
#define EMPTYSCRIPTCALLSTACK_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "IScriptCallStack.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:155</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API EmptyScriptCallStack : public IScriptCallStack {

private:
    // custom serializers

public:
    // constants
    static constexpr rd::wstring_view message{L"Script call stack: [Empty] (FFrame::GetStackTrace() called from native code)", 76};

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    
    // default ctors and dtors
    
    EmptyScriptCallStack();
    
    EmptyScriptCallStack(EmptyScriptCallStack const &) = default;
    
    EmptyScriptCallStack& operator=(EmptyScriptCallStack const &) = default;
    
    EmptyScriptCallStack(EmptyScriptCallStack &&) = default;
    
    EmptyScriptCallStack& operator=(EmptyScriptCallStack &&) = default;
    
    virtual ~EmptyScriptCallStack() = default;
    
    // reader
    static EmptyScriptCallStack read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const EmptyScriptCallStack &lhs, const EmptyScriptCallStack &rhs);
    friend bool operator!=(const EmptyScriptCallStack &lhs, const EmptyScriptCallStack &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const EmptyScriptCallStack & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::EmptyScriptCallStack> {
    size_t operator()(const JetBrains::EditorPlugin::EmptyScriptCallStack & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // EMPTYSCRIPTCALLSTACK_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptCallStack.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "IScriptCallStack.Generated.h"


#include "IScriptCallStack_Unknown.Generated.h"

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
constexpr rd::wstring_view IScriptCallStack::header;
// initializer
void IScriptCallStack::initialize()
{
}
// primary ctor
// secondary constructor
// default ctors and dtors
IScriptCallStack::IScriptCallStack()
{
    initialize();
}
// reader
rd::Wrapper<IScriptCallStack> IScriptCallStack::readUnknownInstance(rd::SerializationCtx& ctx, rd::Buffer & buffer, rd::RdId const& unknownId, int32_t size)
{
    int32_t objectStartPosition = buffer.get_position();
    auto unknownBytes = rd::Buffer::ByteArray(objectStartPosition + size - buffer.get_position());
    buffer.read_byte_array_raw(unknownBytes);
    IScriptCallStack_Unknown res{unknownId, unknownBytes};
    return rd::Wrapper<IScriptCallStack_Unknown>(std::move(res));
}
// writer
// virtual init
// identify
// getters
// intern
// equals trait
// equality operators
bool operator==(const IScriptCallStack &lhs, const IScriptCallStack &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const IScriptCallStack &lhs, const IScriptCallStack &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t IScriptCallStack::hashCode() const noexcept
{
    size_t __r = 0;
    return __r;
}
// type name trait
std::string IScriptCallStack::type_name() const
{
    return "IScriptCallStack";
}
// static type name trait
std::string IScriptCallStack::static_type_name()
{
    return "IScriptCallStack";
}
// polymorphic to string
std::string IScriptCallStack::toString() const
{
    std::string res = "IScriptCallStack\n";
    return res;
}
// external to string
std::string to_string(const IScriptCallStack & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptCallStack.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef ISCRIPTCALLSTACK_GENERATED_H
#define ISCRIPTCALLSTACK_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:150</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// abstract
class RIDERLINK_API IScriptCallStack : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants
    static constexpr rd::wstring_view header{L"Script call stack:", 18};

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    
    // default ctors and dtors
    
    IScriptCallStack();
    
    IScriptCallStack(IScriptCallStack const &) = default;
    
    IScriptCallStack& operator=(IScriptCallStack const &) = default;
    
    IScriptCallStack(IScriptCallStack &&) = default;
    
    IScriptCallStack& operator=(IScriptCallStack &&) = default;
    
    virtual ~IScriptCallStack() = default;
    
    // reader
    static rd::Wrapper<IScriptCallStack> readUnknownInstance(rd::SerializationCtx& ctx, rd::Buffer & buffer, rd::RdId const& unknownId, int32_t size);
    
    // writer
    virtual void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override = 0;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait

public:
    // equality operators
    friend bool operator==(const IScriptCallStack &lhs, const IScriptCallStack &rhs);
    friend bool operator!=(const IScriptCallStack &lhs, const IScriptCallStack &rhs);
    // hash code trait
    virtual size_t hashCode() const noexcept override = 0;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const IScriptCallStack & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::IScriptCallStack> {
    size_t operator()(const JetBrains::EditorPlugin::IScriptCallStack & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // ISCRIPTCALLSTACK_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptCallStack_Unknown.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "IScriptCallStack_Unknown.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void IScriptCallStack_Unknown::initialize()
{
}
// primary ctor
IScriptCallStack_Unknown::IScriptCallStack_Unknown(rd::RdId unknownId_, rd::Buffer::ByteArray unknownBytes_) :
IScriptCallStack(), rd::IUnknownInstance(std::move(unknownId_))

{
    initialize();
}
// secondary constructor
// default ctors and dtors
IScriptCallStack_Unknown::IScriptCallStack_Unknown()
{
    initialize();
}
// reader
IScriptCallStack_Unknown IScriptCallStack_Unknown::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    throw std::logic_error("Unknown instances should not be read via serializer");
}
// writer
void IScriptCallStack_Unknown::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_byte_array_raw(unknownBytes_);
}
// virtual init
// identify
// getters
// intern
// equals trait
bool IScriptCallStack_Unknown::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<IScriptCallStack_Unknown const&>(object);
    if (this == &other) return true;
    
    return true;
}
// equality operators
bool operator==(const IScriptCallStack_Unknown &lhs, const IScriptCallStack_Unknown &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const IScriptCallStack_Unknown &lhs, const IScriptCallStack_Unknown &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t IScriptCallStack_Unknown::hashCode() const noexcept
{
    size_t __r = 0;
    return __r;
}
// type name trait
std::string IScriptCallStack_Unknown::type_name() const
{
    return "IScriptCallStack_Unknown";
}
// static type name trait
std::string IScriptCallStack_Unknown::static_type_name()
{
    return "IScriptCallStack_Unknown";
}
// polymorphic to string
std::string IScriptCallStack_Unknown::toString() const
{
    std::string res = "IScriptCallStack_Unknown\n";
    return res;
}
// external to string
std::string to_string(const IScriptCallStack_Unknown & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptCallStack_Unknown.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef ISCRIPTCALLSTACK_UNKNOWN_GENERATED_H
#define ISCRIPTCALLSTACK_UNKNOWN_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "IScriptCallStack.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API IScriptCallStack_Unknown : public IScriptCallStack, public rd::IUnknownInstance {
friend class IScriptCallStack;

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    rd::RdId unknownId_;
    rd::Buffer::ByteArray unknownBytes_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    IScriptCallStack_Unknown(rd::RdId unknownId_, rd::Buffer::ByteArray unknownBytes_);
    
    // default ctors and dtors
    
    IScriptCallStack_Unknown();
    
    IScriptCallStack_Unknown(IScriptCallStack_Unknown const &) = default;
    
    IScriptCallStack_Unknown& operator=(IScriptCallStack_Unknown const &) = default;
    
    IScriptCallStack_Unknown(IScriptCallStack_Unknown &&) = default;
    
    IScriptCallStack_Unknown& operator=(IScriptCallStack_Unknown &&) = default;
    
    virtual ~IScriptCallStack_Unknown() = default;
    
    // reader
    static IScriptCallStack_Unknown read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const IScriptCallStack_Unknown &lhs, const IScriptCallStack_Unknown &rhs);
    friend bool operator!=(const IScriptCallStack_Unknown &lhs, const IScriptCallStack_Unknown &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const IScriptCallStack_Unknown & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::IScriptCallStack_Unknown> {
    size_t operator()(const JetBrains::EditorPlugin::IScriptCallStack_Unknown & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // ISCRIPTCALLSTACK_UNKNOWN_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptMsg.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "IScriptMsg.Generated.h"


#include "IScriptMsg_Unknown.Generated.h"

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
constexpr rd::wstring_view IScriptMsg::header;
// initializer
void IScriptMsg::initialize()
{
}
// primary ctor
// secondary constructor
// default ctors and dtors
IScriptMsg::IScriptMsg()
{
    initialize();
}
// reader
rd::Wrapper<IScriptMsg> IScriptMsg::readUnknownInstance(rd::SerializationCtx& ctx, rd::Buffer & buffer, rd::RdId const& unknownId, int32_t size)
{
    int32_t objectStartPosition = buffer.get_position();
    auto unknownBytes = rd::Buffer::ByteArray(objectStartPosition + size - buffer.get_position());
    buffer.read_byte_array_raw(unknownBytes);
    IScriptMsg_Unknown res{unknownId, unknownBytes};
    return rd::Wrapper<IScriptMsg_Unknown>(std::move(res));
}
// writer
// virtual init
// identify
// getters
// intern
// equals trait
// equality operators
bool operator==(const IScriptMsg &lhs, const IScriptMsg &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const IScriptMsg &lhs, const IScriptMsg &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t IScriptMsg::hashCode() const noexcept
{
    size_t __r = 0;
    return __r;
}
// type name trait
std::string IScriptMsg::type_name() const
{
    return "IScriptMsg";
}
// static type name trait
std::string IScriptMsg::static_type_name()
{
    return "IScriptMsg";
}
// polymorphic to string
std::string IScriptMsg::toString() const
{
    std::string res = "IScriptMsg\n";
    return res;
}
// external to string
std::string to_string(const IScriptMsg & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptMsg.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef ISCRIPTMSG_GENERATED_H
#define ISCRIPTMSG_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:172</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// abstract
class RIDERLINK_API IScriptMsg : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants
    static constexpr rd::wstring_view header{L"Script msg:", 11};

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    
    // default ctors and dtors
    
    IScriptMsg();
    
    IScriptMsg(IScriptMsg const &) = default;
    
    IScriptMsg& operator=(IScriptMsg const &) = default;
    
    IScriptMsg(IScriptMsg &&) = default;
    
    IScriptMsg& operator=(IScriptMsg &&) = default;
    
    virtual ~IScriptMsg() = default;
    
    // reader
    static rd::Wrapper<IScriptMsg> readUnknownInstance(rd::SerializationCtx& ctx, rd::Buffer & buffer, rd::RdId const& unknownId, int32_t size);
    
    // writer
    virtual void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override = 0;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait

public:
    // equality operators
    friend bool operator==(const IScriptMsg &lhs, const IScriptMsg &rhs);
    friend bool operator!=(const IScriptMsg &lhs, const IScriptMsg &rhs);
    // hash code trait
    virtual size_t hashCode() const noexcept override = 0;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const IScriptMsg & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::IScriptMsg> {
    size_t operator()(const JetBrains::EditorPlugin::IScriptMsg & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // ISCRIPTMSG_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptMsg_Unknown.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "IScriptMsg_Unknown.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void IScriptMsg_Unknown::initialize()
{
}
// primary ctor
IScriptMsg_Unknown::IScriptMsg_Unknown(rd::RdId unknownId_, rd::Buffer::ByteArray unknownBytes_) :
IScriptMsg(), rd::IUnknownInstance(std::move(unknownId_))

{
    initialize();
}
// secondary constructor
// default ctors and dtors
IScriptMsg_Unknown::IScriptMsg_Unknown()
{
    initialize();
}
// reader
IScriptMsg_Unknown IScriptMsg_Unknown::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    throw std::logic_error("Unknown instances should not be read via serializer");
}
// writer
void IScriptMsg_Unknown::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_byte_array_raw(unknownBytes_);
}
// virtual init
// identify
// getters
// intern
// equals trait
bool IScriptMsg_Unknown::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<IScriptMsg_Unknown const&>(object);
    if (this == &other) return true;
    
    return true;
}
// equality operators
bool operator==(const IScriptMsg_Unknown &lhs, const IScriptMsg_Unknown &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const IScriptMsg_Unknown &lhs, const IScriptMsg_Unknown &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t IScriptMsg_Unknown::hashCode() const noexcept
{
    size_t __r = 0;
    return __r;
}
// type name trait
std::string IScriptMsg_Unknown::type_name() const
{
    return "IScriptMsg_Unknown";
}
// static type name trait
std::string IScriptMsg_Unknown::static_type_name()
{
    return "IScriptMsg_Unknown";
}
// polymorphic to string
std::string IScriptMsg_Unknown::toString() const
{
    std::string res = "IScriptMsg_Unknown\n";
    return res;
}
// external to string
std::string to_string(const IScriptMsg_Unknown & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/IScriptMsg_Unknown.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef ISCRIPTMSG_UNKNOWN_GENERATED_H
#define ISCRIPTMSG_UNKNOWN_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "IScriptMsg.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API IScriptMsg_Unknown : public IScriptMsg, public rd::IUnknownInstance {
friend class IScriptMsg;

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    rd::RdId unknownId_;
    rd::Buffer::ByteArray unknownBytes_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    IScriptMsg_Unknown(rd::RdId unknownId_, rd::Buffer::ByteArray unknownBytes_);
    
    // default ctors and dtors
    
    IScriptMsg_Unknown();
    
    IScriptMsg_Unknown(IScriptMsg_Unknown const &) = default;
    
    IScriptMsg_Unknown& operator=(IScriptMsg_Unknown const &) = default;
    
    IScriptMsg_Unknown(IScriptMsg_Unknown &&) = default;
    
    IScriptMsg_Unknown& operator=(IScriptMsg_Unknown &&) = default;
    
    virtual ~IScriptMsg_Unknown() = default;
    
    // reader
    static IScriptMsg_Unknown read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const IScriptMsg_Unknown &lhs, const IScriptMsg_Unknown &rhs);
    friend bool operator!=(const IScriptMsg_Unknown &lhs, const IScriptMsg_Unknown &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const IScriptMsg_Unknown & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::IScriptMsg_Unknown> {
    size_t operator()(const JetBrains::EditorPlugin::IScriptMsg_Unknown & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // ISCRIPTMSG_UNKNOWN_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/LogMessageInfo.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "LogMessageInfo.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void LogMessageInfo::initialize()
{
}
// primary ctor
LogMessageInfo::LogMessageInfo(ELogVerbosity::Type type_, FString category_, rd::optional<rd::DateTime> time_) :
rd::IPolymorphicSerializable()
,type_(std::move(type_)), category_(std::move(category_)), time_(std::move(time_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
LogMessageInfo LogMessageInfo::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto type_ = rd::Polymorphic<ELogVerbosity::Type>::read(ctx, buffer);
    auto category_ = rd::Polymorphic<FString>::read(ctx, buffer);
    auto time_ = buffer.read_nullable<rd::DateTime>(
    [&ctx, &buffer]() mutable  
    { return buffer.read_date_time(); }
    );
    LogMessageInfo res{std::move(type_), std::move(category_), std::move(time_)};
    return res;
}
// writer
void LogMessageInfo::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<ELogVerbosity::Type>::write(ctx, buffer, type_);
    rd::Polymorphic<std::decay_t<decltype(category_)>>::write(ctx, buffer, category_);
    buffer.write_nullable<rd::DateTime>(time_, 
    [&ctx, &buffer](rd::DateTime const & it) mutable  -> void 
    { buffer.write_date_time(it); }
    );
}
// virtual init
// identify
// getters
ELogVerbosity::Type const & LogMessageInfo::get_type() const
{
    return type_;
}
FString const & LogMessageInfo::get_category() const
{
    return category_;
}
rd::optional<rd::DateTime> const & LogMessageInfo::get_time() const
{
    return time_;
}
// intern
// equals trait
bool LogMessageInfo::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<LogMessageInfo const&>(object);
    if (this == &other) return true;
    if (this->type_ != other.type_) return false;
    if (this->category_ != other.category_) return false;
    if (this->time_ != other.time_) return false;
    
    return true;
}
// equality operators
bool operator==(const LogMessageInfo &lhs, const LogMessageInfo &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const LogMessageInfo &lhs, const LogMessageInfo &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t LogMessageInfo::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<ELogVerbosity::Type>()(get_type()));
    __r = __r * 31 + (rd::hash<FString>()(get_category()));
    __r = __r * 31 + ((static_cast<bool>(get_time())) ? rd::hash<rd::DateTime>()(*get_time()) : 0);
    return __r;
}
// type name trait
std::string LogMessageInfo::type_name() const
{
    return "LogMessageInfo";
}
// static type name trait
std::string LogMessageInfo::static_type_name()
{
    return "LogMessageInfo";
}
// polymorphic to string
std::string LogMessageInfo::toString() const
{
    std::string res = "LogMessageInfo\n";
    res += "\ttype = ";
    res += rd::to_string(type_);
    res += '\n';
    res += "\tcategory = ";
    res += rd::to_string(category_);
    res += '\n';
    res += "\ttime = ";
    res += rd::to_string(time_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const LogMessageInfo & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/LogMessageInfo.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef LOGMESSAGEINFO_GENERATED_H
#define LOGMESSAGEINFO_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "Logging/LogVerbosity.h"
#include "Runtime/Core/Public/Containers/UnrealString.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:114</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API LogMessageInfo : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    ELogVerbosity::Type type_;
    FString category_;
    rd::optional<rd::DateTime> time_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    LogMessageInfo(ELogVerbosity::Type type_, FString category_, rd::optional<rd::DateTime> time_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 3) static_assert (I < 0 || I >= 3, "I < 0 || I >= 3");
        else if constexpr (I==0)  return static_cast<const ELogVerbosity::Type&>(get_type());
        else if constexpr (I==1)  return static_cast<const FString&>(get_category());
        else if constexpr (I==2)  return static_cast<const rd::optional<rd::DateTime>&>(get_time());
    }
    #endif
    
    // default ctors and dtors
    
    LogMessageInfo() = delete;
    
    LogMessageInfo(LogMessageInfo const &) = default;
    
    LogMessageInfo& operator=(LogMessageInfo const &) = default;
    
    LogMessageInfo(LogMessageInfo &&) = default;
    
    LogMessageInfo& operator=(LogMessageInfo &&) = default;
    
    virtual ~LogMessageInfo() = default;
    
    // reader
    static LogMessageInfo read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    ELogVerbosity::Type const & get_type() const;
    FString const & get_category() const;
    rd::optional<rd::DateTime> const & get_time() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const LogMessageInfo &lhs, const LogMessageInfo &rhs);
    friend bool operator!=(const LogMessageInfo &lhs, const LogMessageInfo &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const LogMessageInfo & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::LogMessageInfo> {
    size_t operator()(const JetBrains::EditorPlugin::LogMessageInfo & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::LogMessageInfo> : public integral_constant<size_t, 3> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::LogMessageInfo> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::LogMessageInfo>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // LOGMESSAGEINFO_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/NotificationType.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "NotificationType.Generated.h"

namespace JetBrains {
namespace EditorPlugin {
std::string to_string(const NotificationType & value)
{
    switch(value) {
    case NotificationType::Message: return "Message";
    case NotificationType::Error: return "Error";
    default: return std::to_string(static_cast<int32_t>(value));
    }
}
}
}

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/NotificationType.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef NOTIFICATIONTYPE_GENERATED_H
#define NOTIFICATIONTYPE_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:62</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

enum class NotificationType {
    Message,
    Error
};
std::string to_string(const NotificationType & value);
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // NOTIFICATIONTYPE_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/PlayState.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "PlayState.Generated.h"

namespace JetBrains {
namespace EditorPlugin {
std::string to_string(const PlayState & value)
{
    switch(value) {
    case PlayState::Idle: return "Idle";
    case PlayState::Play: return "Play";
    case PlayState::Pause: return "Pause";
    default: return std::to_string(static_cast<int32_t>(value));
    }
}
}
}

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/PlayState.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef PLAYSTATE_GENERATED_H
#define PLAYSTATE_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:48</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

enum class PlayState {
    Idle,
    Play,
    Pause
};
std::string to_string(const PlayState & value);
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // PLAYSTATE_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestFailed.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "RequestFailed.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void RequestFailed::initialize()
{
}
// primary ctor
RequestFailed::RequestFailed(NotificationType type_, FString message_, int32_t requestID_) :
RequestResultBase(std::move(requestID_))
,type_(std::move(type_)), message_(std::move(message_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
RequestFailed RequestFailed::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto requestID_ = buffer.read_integral<int32_t>();
    auto type_ = rd::Polymorphic<NotificationType>::read(ctx, buffer);
    auto message_ = rd::Polymorphic<FString>::read(ctx, buffer);
    RequestFailed res{std::move(type_), std::move(message_), std::move(requestID_)};
    return res;
}
// writer
void RequestFailed::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_integral(requestID_);
    rd::Polymorphic<NotificationType>::write(ctx, buffer, type_);
    rd::Polymorphic<std::decay_t<decltype(message_)>>::write(ctx, buffer, message_);
}
// virtual init
// identify
// getters
NotificationType const & RequestFailed::get_type() const
{
    return type_;
}
FString const & RequestFailed::get_message() const
{
    return message_;
}
// intern
// equals trait
bool RequestFailed::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<RequestFailed const&>(object);
    if (this == &other) return true;
    if (this->type_ != other.type_) return false;
    if (this->message_ != other.message_) return false;
    if (this->requestID_ != other.requestID_) return false;
    
    return true;
}
// equality operators
bool operator==(const RequestFailed &lhs, const RequestFailed &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const RequestFailed &lhs, const RequestFailed &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t RequestFailed::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<NotificationType>()(get_type()));
    __r = __r * 31 + (rd::hash<FString>()(get_message()));
    __r = __r * 31 + (rd::hash<int32_t>()(get_requestID()));
    return __r;
}
// type name trait
std::string RequestFailed::type_name() const
{
    return "RequestFailed";
}
// static type name trait
std::string RequestFailed::static_type_name()
{
    return "RequestFailed";
}
// polymorphic to string
std::string RequestFailed::toString() const
{
    std::string res = "RequestFailed\n";
    res += "\ttype = ";
    res += rd::to_string(type_);
    res += '\n';
    res += "\tmessage = ";
    res += rd::to_string(message_);
    res += '\n';
    res += "\trequestID = ";
    res += rd::to_string(requestID_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const RequestFailed & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestFailed.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef REQUESTFAILED_GENERATED_H
#define REQUESTFAILED_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4Library/NotificationType.Generated.h"
#include "Runtime/Core/Public/Containers/UnrealString.h"
#include "RequestResultBase.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:61</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API RequestFailed : public RequestResultBase {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    NotificationType type_;
    FString message_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    RequestFailed(NotificationType type_, FString message_, int32_t requestID_);
    
    // default ctors and dtors
    
    RequestFailed() = delete;
    
    RequestFailed(RequestFailed const &) = default;
    
    RequestFailed& operator=(RequestFailed const &) = default;
    
    RequestFailed(RequestFailed &&) = default;
    
    RequestFailed& operator=(RequestFailed &&) = default;
    
    virtual ~RequestFailed() = default;
    
    // reader
    static RequestFailed read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    NotificationType const & get_type() const;
    FString const & get_message() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const RequestFailed &lhs, const RequestFailed &rhs);
    friend bool operator!=(const RequestFailed &lhs, const RequestFailed &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const RequestFailed & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::RequestFailed> {
    size_t operator()(const JetBrains::EditorPlugin::RequestFailed & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // REQUESTFAILED_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestResultBase.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "RequestResultBase.Generated.h"


#include "RequestResultBase_Unknown.Generated.h"

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void RequestResultBase::initialize()
{
}
// primary ctor
RequestResultBase::RequestResultBase(int32_t requestID_) :
rd::IPolymorphicSerializable()
,requestID_(std::move(requestID_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
rd::Wrapper<RequestResultBase> RequestResultBase::readUnknownInstance(rd::SerializationCtx& ctx, rd::Buffer & buffer, rd::RdId const& unknownId, int32_t size)
{
    int32_t objectStartPosition = buffer.get_position();
    auto requestID_ = buffer.read_integral<int32_t>();
    auto unknownBytes = rd::Buffer::ByteArray(objectStartPosition + size - buffer.get_position());
    buffer.read_byte_array_raw(unknownBytes);
    RequestResultBase_Unknown res{std::move(requestID_), unknownId, unknownBytes};
    return rd::Wrapper<RequestResultBase_Unknown>(std::move(res));
}
// writer
// virtual init
// identify
// getters
int32_t const & RequestResultBase::get_requestID() const
{
    return requestID_;
}
// intern
// equals trait
// equality operators
bool operator==(const RequestResultBase &lhs, const RequestResultBase &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const RequestResultBase &lhs, const RequestResultBase &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t RequestResultBase::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<int32_t>()(get_requestID()));
    return __r;
}
// type name trait
std::string RequestResultBase::type_name() const
{
    return "RequestResultBase";
}
// static type name trait
std::string RequestResultBase::static_type_name()
{
    return "RequestResultBase";
}
// polymorphic to string
std::string RequestResultBase::toString() const
{
    std::string res = "RequestResultBase\n";
    res += "\trequestID = ";
    res += rd::to_string(requestID_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const RequestResultBase & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestResultBase.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef REQUESTRESULTBASE_GENERATED_H
#define REQUESTRESULTBASE_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:54</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// abstract
class RIDERLINK_API RequestResultBase : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    int32_t requestID_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    explicit RequestResultBase(int32_t requestID_);
    
    // default ctors and dtors
    
    RequestResultBase() = delete;
    
    RequestResultBase(RequestResultBase const &) = default;
    
    RequestResultBase& operator=(RequestResultBase const &) = default;
    
    RequestResultBase(RequestResultBase &&) = default;
    
    RequestResultBase& operator=(RequestResultBase &&) = default;
    
    virtual ~RequestResultBase() = default;
    
    // reader
    static rd::Wrapper<RequestResultBase> readUnknownInstance(rd::SerializationCtx& ctx, rd::Buffer & buffer, rd::RdId const& unknownId, int32_t size);
    
    // writer
    virtual void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override = 0;
    
    // virtual init
    
    // identify
    
    // getters
    int32_t const & get_requestID() const;
    
    // intern

private:
    // equals trait

public:
    // equality operators
    friend bool operator==(const RequestResultBase &lhs, const RequestResultBase &rhs);
    friend bool operator!=(const RequestResultBase &lhs, const RequestResultBase &rhs);
    // hash code trait
    virtual size_t hashCode() const noexcept override = 0;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const RequestResultBase & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::RequestResultBase> {
    size_t operator()(const JetBrains::EditorPlugin::RequestResultBase & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // REQUESTRESULTBASE_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestResultBase_Unknown.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "RequestResultBase_Unknown.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void RequestResultBase_Unknown::initialize()
{
}
// primary ctor
RequestResultBase_Unknown::RequestResultBase_Unknown(int32_t requestID_, rd::RdId unknownId_, rd::Buffer::ByteArray unknownBytes_) :
RequestResultBase(std::move(requestID_)), rd::IUnknownInstance(std::move(unknownId_))

{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
RequestResultBase_Unknown RequestResultBase_Unknown::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    throw std::logic_error("Unknown instances should not be read via serializer");
}
// writer
void RequestResultBase_Unknown::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_integral(requestID_);
    buffer.write_byte_array_raw(unknownBytes_);
}
// virtual init
// identify
// getters
// intern
// equals trait
bool RequestResultBase_Unknown::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<RequestResultBase_Unknown const&>(object);
    if (this == &other) return true;
    if (this->requestID_ != other.requestID_) return false;
    
    return true;
}
// equality operators
bool operator==(const RequestResultBase_Unknown &lhs, const RequestResultBase_Unknown &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const RequestResultBase_Unknown &lhs, const RequestResultBase_Unknown &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t RequestResultBase_Unknown::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<int32_t>()(get_requestID()));
    return __r;
}
// type name trait
std::string RequestResultBase_Unknown::type_name() const
{
    return "RequestResultBase_Unknown";
}
// static type name trait
std::string RequestResultBase_Unknown::static_type_name()
{
    return "RequestResultBase_Unknown";
}
// polymorphic to string
std::string RequestResultBase_Unknown::toString() const
{
    std::string res = "RequestResultBase_Unknown\n";
    res += "\trequestID = ";
    res += rd::to_string(requestID_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const RequestResultBase_Unknown & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestResultBase_Unknown.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef REQUESTRESULTBASE_UNKNOWN_GENERATED_H
#define REQUESTRESULTBASE_UNKNOWN_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "RequestResultBase.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API RequestResultBase_Unknown : public RequestResultBase, public rd::IUnknownInstance {
friend class RequestResultBase;

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    rd::RdId unknownId_;
    rd::Buffer::ByteArray unknownBytes_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    RequestResultBase_Unknown(int32_t requestID_, rd::RdId unknownId_, rd::Buffer::ByteArray unknownBytes_);
    
    // default ctors and dtors
    
    RequestResultBase_Unknown() = delete;
    
    RequestResultBase_Unknown(RequestResultBase_Unknown const &) = default;
    
    RequestResultBase_Unknown& operator=(RequestResultBase_Unknown const &) = default;
    
    RequestResultBase_Unknown(RequestResultBase_Unknown &&) = default;
    
    RequestResultBase_Unknown& operator=(RequestResultBase_Unknown &&) = default;
    
    virtual ~RequestResultBase_Unknown() = default;
    
    // reader
    static RequestResultBase_Unknown read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const RequestResultBase_Unknown &lhs, const RequestResultBase_Unknown &rhs);
    friend bool operator!=(const RequestResultBase_Unknown &lhs, const RequestResultBase_Unknown &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const RequestResultBase_Unknown & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::RequestResultBase_Unknown> {
    size_t operator()(const JetBrains::EditorPlugin::RequestResultBase_Unknown & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // REQUESTRESULTBASE_UNKNOWN_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestSucceed.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "RequestSucceed.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void RequestSucceed::initialize()
{
}
// primary ctor
RequestSucceed::RequestSucceed(int32_t requestID_) :
RequestResultBase(std::move(requestID_))

{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
RequestSucceed RequestSucceed::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto requestID_ = buffer.read_integral<int32_t>();
    RequestSucceed res{std::move(requestID_)};
    return res;
}
// writer
void RequestSucceed::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_integral(requestID_);
}
// virtual init
// identify
// getters
// intern
// equals trait
bool RequestSucceed::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<RequestSucceed const&>(object);
    if (this == &other) return true;
    if (this->requestID_ != other.requestID_) return false;
    
    return true;
}
// equality operators
bool operator==(const RequestSucceed &lhs, const RequestSucceed &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const RequestSucceed &lhs, const RequestSucceed &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t RequestSucceed::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<int32_t>()(get_requestID()));
    return __r;
}
// type name trait
std::string RequestSucceed::type_name() const
{
    return "RequestSucceed";
}
// static type name trait
std::string RequestSucceed::static_type_name()
{
    return "RequestSucceed";
}
// polymorphic to string
std::string RequestSucceed::toString() const
{
    std::string res = "RequestSucceed\n";
    res += "\trequestID = ";
    res += rd::to_string(requestID_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const RequestSucceed & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/RequestSucceed.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef REQUESTSUCCEED_GENERATED_H
#define REQUESTSUCCEED_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "RequestResultBase.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:58</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API RequestSucceed : public RequestResultBase {

private:
    // custom serializers

public:
    // constants

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    // primary ctor
    explicit RequestSucceed(int32_t requestID_);
    
    // default ctors and dtors
    
    RequestSucceed() = delete;
    
    RequestSucceed(RequestSucceed const &) = default;
    
    RequestSucceed& operator=(RequestSucceed const &) = default;
    
    RequestSucceed(RequestSucceed &&) = default;
    
    RequestSucceed& operator=(RequestSucceed &&) = default;
    
    virtual ~RequestSucceed() = default;
    
    // reader
    static RequestSucceed read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const RequestSucceed &lhs, const RequestSucceed &rhs);
    friend bool operator!=(const RequestSucceed &lhs, const RequestSucceed &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const RequestSucceed & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::RequestSucceed> {
    size_t operator()(const JetBrains::EditorPlugin::RequestSucceed & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // REQUESTSUCCEED_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptCallStack.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "ScriptCallStack.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void ScriptCallStack::initialize()
{
}
// primary ctor
ScriptCallStack::ScriptCallStack(TArray<rd::Wrapper<ScriptCallStackFrame>> frames_) :
IScriptCallStack()
,frames_(std::move(frames_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
ScriptCallStack ScriptCallStack::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto frames_ = buffer.read_array<TArray, ScriptCallStackFrame, FDefaultAllocator>(
    [&ctx, &buffer]() mutable  
    { return ScriptCallStackFrame::read(ctx, buffer); }
    );
    ScriptCallStack res{std::move(frames_)};
    return res;
}
// writer
void ScriptCallStack::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_array<TArray, ScriptCallStackFrame, FDefaultAllocator>(frames_, 
    [&ctx, &buffer](ScriptCallStackFrame const & it) mutable  -> void 
    { rd::Polymorphic<std::decay_t<decltype(it)>>::write(ctx, buffer, it); }
    );
}
// virtual init
// identify
// getters
TArray<rd::Wrapper<ScriptCallStackFrame>> const & ScriptCallStack::get_frames() const
{
    return frames_;
}
// intern
// equals trait
bool ScriptCallStack::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<ScriptCallStack const&>(object);
    if (this == &other) return true;
    if (this->frames_ != other.frames_) return false;
    
    return true;
}
// equality operators
bool operator==(const ScriptCallStack &lhs, const ScriptCallStack &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const ScriptCallStack &lhs, const ScriptCallStack &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t ScriptCallStack::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::contentDeepHashCode(get_frames()));
    return __r;
}
// type name trait
std::string ScriptCallStack::type_name() const
{
    return "ScriptCallStack";
}
// static type name trait
std::string ScriptCallStack::static_type_name()
{
    return "ScriptCallStack";
}
// polymorphic to string
std::string ScriptCallStack::toString() const
{
    std::string res = "ScriptCallStack\n";
    res += "\tframes = ";
    res += rd::to_string(frames_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const ScriptCallStack & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptCallStack.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef SCRIPTCALLSTACK_GENERATED_H
#define SCRIPTCALLSTACK_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4Library/ScriptCallStackFrame.Generated.h"
#include "IScriptCallStack.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:160</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API ScriptCallStack : public IScriptCallStack {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    TArray<rd::Wrapper<ScriptCallStackFrame>> frames_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    explicit ScriptCallStack(TArray<rd::Wrapper<ScriptCallStackFrame>> frames_);
    
    // default ctors and dtors
    
    ScriptCallStack() = delete;
    
    ScriptCallStack(ScriptCallStack const &) = default;
    
    ScriptCallStack& operator=(ScriptCallStack const &) = default;
    
    ScriptCallStack(ScriptCallStack &&) = default;
    
    ScriptCallStack& operator=(ScriptCallStack &&) = default;
    
    virtual ~ScriptCallStack() = default;
    
    // reader
    static ScriptCallStack read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    TArray<rd::Wrapper<ScriptCallStackFrame>> const & get_frames() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const ScriptCallStack &lhs, const ScriptCallStack &rhs);
    friend bool operator!=(const ScriptCallStack &lhs, const ScriptCallStack &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const ScriptCallStack & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::ScriptCallStack> {
    size_t operator()(const JetBrains::EditorPlugin::ScriptCallStack & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // SCRIPTCALLSTACK_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptCallStackFrame.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "ScriptCallStackFrame.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void ScriptCallStackFrame::initialize()
{
}
// primary ctor
ScriptCallStackFrame::ScriptCallStackFrame(FString entry_) :
rd::IPolymorphicSerializable()
,entry_(std::move(entry_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
ScriptCallStackFrame ScriptCallStackFrame::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto entry_ = rd::Polymorphic<FString>::read(ctx, buffer);
    ScriptCallStackFrame res{std::move(entry_)};
    return res;
}
// writer
void ScriptCallStackFrame::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(entry_)>>::write(ctx, buffer, entry_);
}
// virtual init
// identify
// getters
FString const & ScriptCallStackFrame::get_entry() const
{
    return entry_;
}
// intern
// equals trait
bool ScriptCallStackFrame::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<ScriptCallStackFrame const&>(object);
    if (this == &other) return true;
    if (this->entry_ != other.entry_) return false;
    
    return true;
}
// equality operators
bool operator==(const ScriptCallStackFrame &lhs, const ScriptCallStackFrame &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const ScriptCallStackFrame &lhs, const ScriptCallStackFrame &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t ScriptCallStackFrame::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<FString>()(get_entry()));
    return __r;
}
// type name trait
std::string ScriptCallStackFrame::type_name() const
{
    return "ScriptCallStackFrame";
}
// static type name trait
std::string ScriptCallStackFrame::static_type_name()
{
    return "ScriptCallStackFrame";
}
// polymorphic to string
std::string ScriptCallStackFrame::toString() const
{
    std::string res = "ScriptCallStackFrame\n";
    res += "\tentry = ";
    res += rd::to_string(entry_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const ScriptCallStackFrame & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptCallStackFrame.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef SCRIPTCALLSTACKFRAME_GENERATED_H
#define SCRIPTCALLSTACKFRAME_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "Runtime/Core/Public/Containers/UnrealString.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:144</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API ScriptCallStackFrame : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    FString entry_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    explicit ScriptCallStackFrame(FString entry_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 1) static_assert (I < 0 || I >= 1, "I < 0 || I >= 1");
        else if constexpr (I==0)  return static_cast<const FString&>(get_entry());
    }
    #endif
    
    // default ctors and dtors
    
    ScriptCallStackFrame() = delete;
    
    ScriptCallStackFrame(ScriptCallStackFrame const &) = default;
    
    ScriptCallStackFrame& operator=(ScriptCallStackFrame const &) = default;
    
    ScriptCallStackFrame(ScriptCallStackFrame &&) = default;
    
    ScriptCallStackFrame& operator=(ScriptCallStackFrame &&) = default;
    
    virtual ~ScriptCallStackFrame() = default;
    
    // reader
    static ScriptCallStackFrame read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    FString const & get_entry() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const ScriptCallStackFrame &lhs, const ScriptCallStackFrame &rhs);
    friend bool operator!=(const ScriptCallStackFrame &lhs, const ScriptCallStackFrame &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const ScriptCallStackFrame & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::ScriptCallStackFrame> {
    size_t operator()(const JetBrains::EditorPlugin::ScriptCallStackFrame & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::ScriptCallStackFrame> : public integral_constant<size_t, 1> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::ScriptCallStackFrame> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::ScriptCallStackFrame>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // SCRIPTCALLSTACKFRAME_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptMsgCallStack.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "ScriptMsgCallStack.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void ScriptMsgCallStack::initialize()
{
}
// primary ctor
ScriptMsgCallStack::ScriptMsgCallStack(FString message_, rd::Wrapper<IScriptCallStack> scriptCallStack_) :
IScriptMsg()
,message_(std::move(message_)), scriptCallStack_(std::move(scriptCallStack_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
ScriptMsgCallStack ScriptMsgCallStack::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto message_ = rd::Polymorphic<FString>::read(ctx, buffer);
    auto scriptCallStack_ = ctx.get_serializers().readPolymorphic<IScriptCallStack>(ctx, buffer);
    ScriptMsgCallStack res{std::move(message_), std::move(scriptCallStack_)};
    return res;
}
// writer
void ScriptMsgCallStack::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(message_)>>::write(ctx, buffer, message_);
    ctx.get_serializers().writePolymorphic<IScriptCallStack>(ctx, buffer, scriptCallStack_);
}
// virtual init
// identify
// getters
FString const & ScriptMsgCallStack::get_message() const
{
    return message_;
}
IScriptCallStack const & ScriptMsgCallStack::get_scriptCallStack() const
{
    return *scriptCallStack_;
}
// intern
// equals trait
bool ScriptMsgCallStack::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<ScriptMsgCallStack const&>(object);
    if (this == &other) return true;
    if (this->message_ != other.message_) return false;
    if (this->scriptCallStack_ != other.scriptCallStack_) return false;
    
    return true;
}
// equality operators
bool operator==(const ScriptMsgCallStack &lhs, const ScriptMsgCallStack &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const ScriptMsgCallStack &lhs, const ScriptMsgCallStack &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t ScriptMsgCallStack::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<FString>()(get_message()));
    __r = __r * 31 + (rd::hash<IScriptCallStack>()(get_scriptCallStack()));
    return __r;
}
// type name trait
std::string ScriptMsgCallStack::type_name() const
{
    return "ScriptMsgCallStack";
}
// static type name trait
std::string ScriptMsgCallStack::static_type_name()
{
    return "ScriptMsgCallStack";
}
// polymorphic to string
std::string ScriptMsgCallStack::toString() const
{
    std::string res = "ScriptMsgCallStack\n";
    res += "\tmessage = ";
    res += rd::to_string(message_);
    res += '\n';
    res += "\tscriptCallStack = ";
    res += rd::to_string(scriptCallStack_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const ScriptMsgCallStack & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptMsgCallStack.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef SCRIPTMSGCALLSTACK_GENERATED_H
#define SCRIPTMSGCALLSTACK_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "Runtime/Core/Public/Containers/UnrealString.h"
#include "UE4Library/IScriptCallStack.Generated.h"
#include "IScriptMsg.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:182</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API ScriptMsgCallStack : public IScriptMsg {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    FString message_;
    rd::Wrapper<IScriptCallStack> scriptCallStack_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    ScriptMsgCallStack(FString message_, rd::Wrapper<IScriptCallStack> scriptCallStack_);
    
    // default ctors and dtors
    
    ScriptMsgCallStack() = delete;
    
    ScriptMsgCallStack(ScriptMsgCallStack const &) = default;
    
    ScriptMsgCallStack& operator=(ScriptMsgCallStack const &) = default;
    
    ScriptMsgCallStack(ScriptMsgCallStack &&) = default;
    
    ScriptMsgCallStack& operator=(ScriptMsgCallStack &&) = default;
    
    virtual ~ScriptMsgCallStack() = default;
    
    // reader
    static ScriptMsgCallStack read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    FString const & get_message() const;
    IScriptCallStack const & get_scriptCallStack() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const ScriptMsgCallStack &lhs, const ScriptMsgCallStack &rhs);
    friend bool operator!=(const ScriptMsgCallStack &lhs, const ScriptMsgCallStack &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const ScriptMsgCallStack & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::ScriptMsgCallStack> {
    size_t operator()(const JetBrains::EditorPlugin::ScriptMsgCallStack & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // SCRIPTMSGCALLSTACK_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptMsgException.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "ScriptMsgException.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void ScriptMsgException::initialize()
{
}
// primary ctor
ScriptMsgException::ScriptMsgException(FString message_) :
IScriptMsg()
,message_(std::move(message_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
ScriptMsgException ScriptMsgException::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto message_ = rd::Polymorphic<FString>::read(ctx, buffer);
    ScriptMsgException res{std::move(message_)};
    return res;
}
// writer
void ScriptMsgException::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(message_)>>::write(ctx, buffer, message_);
}
// virtual init
// identify
// getters
FString const & ScriptMsgException::get_message() const
{
    return message_;
}
// intern
// equals trait
bool ScriptMsgException::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<ScriptMsgException const&>(object);
    if (this == &other) return true;
    if (this->message_ != other.message_) return false;
    
    return true;
}
// equality operators
bool operator==(const ScriptMsgException &lhs, const ScriptMsgException &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const ScriptMsgException &lhs, const ScriptMsgException &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t ScriptMsgException::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<FString>()(get_message()));
    return __r;
}
// type name trait
std::string ScriptMsgException::type_name() const
{
    return "ScriptMsgException";
}
// static type name trait
std::string ScriptMsgException::static_type_name()
{
    return "ScriptMsgException";
}
// polymorphic to string
std::string ScriptMsgException::toString() const
{
    std::string res = "ScriptMsgException\n";
    res += "\tmessage = ";
    res += rd::to_string(message_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const ScriptMsgException & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/ScriptMsgException.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef SCRIPTMSGEXCEPTION_GENERATED_H
#define SCRIPTMSGEXCEPTION_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "Runtime/Core/Public/Containers/UnrealString.h"
#include "IScriptMsg.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:177</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API ScriptMsgException : public IScriptMsg {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    FString message_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    explicit ScriptMsgException(FString message_);
    
    // default ctors and dtors
    
    ScriptMsgException() = delete;
    
    ScriptMsgException(ScriptMsgException const &) = default;
    
    ScriptMsgException& operator=(ScriptMsgException const &) = default;
    
    ScriptMsgException(ScriptMsgException &&) = default;
    
    ScriptMsgException& operator=(ScriptMsgException &&) = default;
    
    virtual ~ScriptMsgException() = default;
    
    // reader
    static ScriptMsgException read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    FString const & get_message() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const ScriptMsgException &lhs, const ScriptMsgException &rhs);
    friend bool operator!=(const ScriptMsgException &lhs, const ScriptMsgException &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const ScriptMsgException & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::ScriptMsgException> {
    size_t operator()(const JetBrains::EditorPlugin::ScriptMsgException & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // SCRIPTMSGEXCEPTION_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/StringRange.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "StringRange.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void StringRange::initialize()
{
}
// primary ctor
StringRange::StringRange(int32_t first_, int32_t last_) :
rd::IPolymorphicSerializable()
,first_(std::move(first_)), last_(std::move(last_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
StringRange StringRange::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto first_ = buffer.read_integral<int32_t>();
    auto last_ = buffer.read_integral<int32_t>();
    StringRange res{std::move(first_), std::move(last_)};
    return res;
}
// writer
void StringRange::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    buffer.write_integral(first_);
    buffer.write_integral(last_);
}
// virtual init
// identify
// getters
int32_t const & StringRange::get_first() const
{
    return first_;
}
int32_t const & StringRange::get_last() const
{
    return last_;
}
// intern
// equals trait
bool StringRange::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<StringRange const&>(object);
    if (this == &other) return true;
    if (this->first_ != other.first_) return false;
    if (this->last_ != other.last_) return false;
    
    return true;
}
// equality operators
bool operator==(const StringRange &lhs, const StringRange &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const StringRange &lhs, const StringRange &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t StringRange::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<int32_t>()(get_first()));
    __r = __r * 31 + (rd::hash<int32_t>()(get_last()));
    return __r;
}
// type name trait
std::string StringRange::type_name() const
{
    return "StringRange";
}
// static type name trait
std::string StringRange::static_type_name()
{
    return "StringRange";
}
// polymorphic to string
std::string StringRange::toString() const
{
    std::string res = "StringRange\n";
    res += "\tfirst = ";
    res += rd::to_string(first_);
    res += '\n';
    res += "\tlast = ";
    res += rd::to_string(last_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const StringRange & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/StringRange.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef STRINGRANGE_GENERATED_H
#define STRINGRANGE_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:37</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API StringRange : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    int32_t first_;
    int32_t last_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    StringRange(int32_t first_, int32_t last_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 2) static_assert (I < 0 || I >= 2, "I < 0 || I >= 2");
        else if constexpr (I==0)  return static_cast<const int32_t&>(get_first());
        else if constexpr (I==1)  return static_cast<const int32_t&>(get_last());
    }
    #endif
    
    // default ctors and dtors
    
    StringRange() = delete;
    
    StringRange(StringRange const &) = default;
    
    StringRange& operator=(StringRange const &) = default;
    
    StringRange(StringRange &&) = default;
    
    StringRange& operator=(StringRange &&) = default;
    
    virtual ~StringRange() = default;
    
    // reader
    static StringRange read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    int32_t const & get_first() const;
    int32_t const & get_last() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const StringRange &lhs, const StringRange &rhs);
    friend bool operator!=(const StringRange &lhs, const StringRange &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const StringRange & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::StringRange> {
    size_t operator()(const JetBrains::EditorPlugin::StringRange & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::StringRange> : public integral_constant<size_t, 2> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::StringRange> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::StringRange>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // STRINGRANGE_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UClass.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "UClass.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void UClass::initialize()
{
}
// primary ctor
UClass::UClass(FString name_) :
rd::IPolymorphicSerializable()
,name_(std::move(name_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
UClass UClass::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto name_ = rd::Polymorphic<FString>::read(ctx, buffer);
    UClass res{std::move(name_)};
    return res;
}
// writer
void UClass::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(name_)>>::write(ctx, buffer, name_);
}
// virtual init
// identify
// getters
FString const & UClass::get_name() const
{
    return name_;
}
// intern
// equals trait
bool UClass::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<UClass const&>(object);
    if (this == &other) return true;
    if (this->name_ != other.name_) return false;
    
    return true;
}
// equality operators
bool operator==(const UClass &lhs, const UClass &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const UClass &lhs, const UClass &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t UClass::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<FString>()(get_name()));
    return __r;
}
// type name trait
std::string UClass::type_name() const
{
    return "UClass";
}
// static type name trait
std::string UClass::static_type_name()
{
    return "UClass";
}
// polymorphic to string
std::string UClass::toString() const
{
    std::string res = "UClass\n";
    res += "\tname = ";
    res += rd::to_string(name_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const UClass & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UClass.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef UCLASS_GENERATED_H
#define UCLASS_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "Runtime/Core/Public/Containers/UnrealString.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:132</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API UClass : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    FString name_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    explicit UClass(FString name_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 1) static_assert (I < 0 || I >= 1, "I < 0 || I >= 1");
        else if constexpr (I==0)  return static_cast<const FString&>(get_name());
    }
    #endif
    
    // default ctors and dtors
    
    UClass() = delete;
    
    UClass(UClass const &) = default;
    
    UClass& operator=(UClass const &) = default;
    
    UClass(UClass &&) = default;
    
    UClass& operator=(UClass &&) = default;
    
    virtual ~UClass() = default;
    
    // reader
    static UClass read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    FString const & get_name() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const UClass &lhs, const UClass &rhs);
    friend bool operator!=(const UClass &lhs, const UClass &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const UClass & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::UClass> {
    size_t operator()(const JetBrains::EditorPlugin::UClass & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::UClass> : public integral_constant<size_t, 1> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::UClass> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::UClass>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // UCLASS_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UE4Library.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "UE4Library.Generated.h"

#include "UE4Library/StringRange.Generated.h"
#include "UE4Library/PlayState.Generated.h"
#include "UE4Library/RequestSucceed.Generated.h"
#include "UE4Library/RequestFailed.Generated.h"
#include "UE4Library/LogMessageInfo.Generated.h"
#include "UE4Library/UnrealLogEvent.Generated.h"
#include "UE4Library/UClass.Generated.h"
#include "UE4Library/BlueprintFunction.Generated.h"
#include "UE4Library/ScriptCallStackFrame.Generated.h"
#include "UE4Library/EmptyScriptCallStack.Generated.h"
#include "UE4Library/ScriptCallStack.Generated.h"
#include "UE4Library/UnableToDisplayScriptCallStack.Generated.h"
#include "UE4Library/ScriptMsgException.Generated.h"
#include "UE4Library/ScriptMsgCallStack.Generated.h"
#include "UE4Library/BlueprintHighlighter.Generated.h"
#include "UE4Library/BlueprintReference.Generated.h"
#include "UE4Library/ConnectionInfo.Generated.h"
#include "UE4Library/NotificationType.Generated.h"
#include "UE4Library/RequestResultBase_Unknown.Generated.h"
#include "UE4Library/IScriptCallStack_Unknown.Generated.h"
#include "UE4Library/IScriptMsg_Unknown.Generated.h"

#include "UE4Library/UE4Library.Generated.h"
#include "UE4Library/UE4Library.Generated.h"

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion

UE4Library::UE4LibrarySerializersOwner const UE4Library::serializersOwner;

void UE4Library::UE4LibrarySerializersOwner::registerSerializersCore(rd::Serializers const& serializers) const
{
    serializers.registry<StringRange>();
    serializers.registry<RequestSucceed>();
    serializers.registry<RequestFailed>();
    serializers.registry<LogMessageInfo>();
    serializers.registry<UnrealLogEvent>();
    serializers.registry<UClass>();
    serializers.registry<BlueprintFunction>();
    serializers.registry<ScriptCallStackFrame>();
    serializers.registry<EmptyScriptCallStack>();
    serializers.registry<ScriptCallStack>();
    serializers.registry<UnableToDisplayScriptCallStack>();
    serializers.registry<ScriptMsgException>();
    serializers.registry<ScriptMsgCallStack>();
    serializers.registry<BlueprintHighlighter>();
    serializers.registry<BlueprintReference>();
    serializers.registry<ConnectionInfo>();
    serializers.registry<RequestResultBase_Unknown>();
    serializers.registry<IScriptCallStack_Unknown>();
    serializers.registry<IScriptMsg_Unknown>();
}

void UE4Library::connect(rd::Lifetime lifetime, rd::IProtocol const * protocol)
{
    UE4Library::serializersOwner.registry(protocol->get_serializers());
    
    identify(*(protocol->get_identity()), rd::RdId::Null().mix("UE4Library"));
    bind(lifetime, protocol, "UE4Library");
}

// constants
// initializer
void UE4Library::initialize()
{
    serializationHash = 4930583670691204680L;
}
// primary ctor
// secondary constructor
// default ctors and dtors
UE4Library::UE4Library()
{
    initialize();
}
// reader
// writer
// virtual init
void UE4Library::init(rd::Lifetime lifetime) const
{
    rd::RdExtBase::init(lifetime);
}
// identify
void UE4Library::identify(const rd::Identities &identities, rd::RdId const &id) const
{
    rd::RdBindableBase::identify(identities, id);
}
// getters
// intern
// equals trait
// equality operators
bool operator==(const UE4Library &lhs, const UE4Library &rhs) {
    return &lhs == &rhs;
}
bool operator!=(const UE4Library &lhs, const UE4Library &rhs){
    return !(lhs == rhs);
}
// hash code trait
// type name trait
// static type name trait
// polymorphic to string
std::string UE4Library::toString() const
{
    std::string res = "UE4Library\n";
    return res;
}
// external to string
std::string to_string(const UE4Library & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UE4Library.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef UE4LIBRARY_GENERATED_H
#define UE4LIBRARY_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:10</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API UE4Library : public rd::RdExtBase {

public:
    struct UE4LibrarySerializersOwner final : public rd::ISerializersOwner {
        void registerSerializersCore(rd::Serializers const& serializers) const override;
    };
    
    static const UE4LibrarySerializersOwner serializersOwner;
    
    

public:
    void connect(rd::Lifetime lifetime, rd::IProtocol const * protocol);
    

private:
    // custom serializers

public:
    // constants

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    
    // default ctors and dtors
    
    UE4Library();
    
    UE4Library(UE4Library &&) = delete;
    
    UE4Library& operator=(UE4Library &&) = delete;
    
    virtual ~UE4Library() = default;
    
    // reader
    
    // writer
    
    // virtual init
    void init(rd::Lifetime lifetime) const override;
    
    // identify
    void identify(const rd::Identities &identities, rd::RdId const &id) const override;
    
    // getters
    
    // intern

private:
    // equals trait

public:
    // equality operators
    friend bool operator==(const UE4Library &lhs, const UE4Library &rhs);
    friend bool operator!=(const UE4Library &lhs, const UE4Library &rhs);
    // hash code trait
    // type name trait
    // static type name trait

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const UE4Library & value);
};

}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // UE4LIBRARY_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UnableToDisplayScriptCallStack.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "UnableToDisplayScriptCallStack.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
constexpr rd::wstring_view UnableToDisplayScriptCallStack::message;
// initializer
void UnableToDisplayScriptCallStack::initialize()
{
}
// primary ctor
// secondary constructor
// default ctors and dtors
UnableToDisplayScriptCallStack::UnableToDisplayScriptCallStack()
{
    initialize();
}
// reader
UnableToDisplayScriptCallStack UnableToDisplayScriptCallStack::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    UnableToDisplayScriptCallStack res{};
    return res;
}
// writer
void UnableToDisplayScriptCallStack::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
}
// virtual init
// identify
// getters
// intern
// equals trait
bool UnableToDisplayScriptCallStack::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<UnableToDisplayScriptCallStack const&>(object);
    if (this == &other) return true;
    
    return true;
}
// equality operators
bool operator==(const UnableToDisplayScriptCallStack &lhs, const UnableToDisplayScriptCallStack &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const UnableToDisplayScriptCallStack &lhs, const UnableToDisplayScriptCallStack &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t UnableToDisplayScriptCallStack::hashCode() const noexcept
{
    size_t __r = 0;
    return __r;
}
// type name trait
std::string UnableToDisplayScriptCallStack::type_name() const
{
    return "UnableToDisplayScriptCallStack";
}
// static type name trait
std::string UnableToDisplayScriptCallStack::static_type_name()
{
    return "UnableToDisplayScriptCallStack";
}
// polymorphic to string
std::string UnableToDisplayScriptCallStack::toString() const
{
    std::string res = "UnableToDisplayScriptCallStack\n";
    return res;
}
// external to string
std::string to_string(const UnableToDisplayScriptCallStack & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UnableToDisplayScriptCallStack.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef UNABLETODISPLAYSCRIPTCALLSTACK_GENERATED_H
#define UNABLETODISPLAYSCRIPTCALLSTACK_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "IScriptCallStack.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:165</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API UnableToDisplayScriptCallStack : public IScriptCallStack {

private:
    // custom serializers

public:
    // constants
    static constexpr rd::wstring_view message{L"Unable to display Script Callstack. Compile with DO_BLUEPRINT_GUARD=1", 69};

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    
    // default ctors and dtors
    
    UnableToDisplayScriptCallStack();
    
    UnableToDisplayScriptCallStack(UnableToDisplayScriptCallStack const &) = default;
    
    UnableToDisplayScriptCallStack& operator=(UnableToDisplayScriptCallStack const &) = default;
    
    UnableToDisplayScriptCallStack(UnableToDisplayScriptCallStack &&) = default;
    
    UnableToDisplayScriptCallStack& operator=(UnableToDisplayScriptCallStack &&) = default;
    
    virtual ~UnableToDisplayScriptCallStack() = default;
    
    // reader
    static UnableToDisplayScriptCallStack read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const UnableToDisplayScriptCallStack &lhs, const UnableToDisplayScriptCallStack &rhs);
    friend bool operator!=(const UnableToDisplayScriptCallStack &lhs, const UnableToDisplayScriptCallStack &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const UnableToDisplayScriptCallStack & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::UnableToDisplayScriptCallStack> {
    size_t operator()(const JetBrains::EditorPlugin::UnableToDisplayScriptCallStack & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // UNABLETODISPLAYSCRIPTCALLSTACK_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UnrealLogEvent.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "UnrealLogEvent.Generated.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion
// constants
// initializer
void UnrealLogEvent::initialize()
{
}
// primary ctor
UnrealLogEvent::UnrealLogEvent(rd::Wrapper<LogMessageInfo> info_, FString text_, TArray<rd::Wrapper<StringRange>> bpPathRanges_, TArray<rd::Wrapper<StringRange>> methodRanges_) :
rd::IPolymorphicSerializable()
,info_(std::move(info_)), text_(std::move(text_)), bpPathRanges_(std::move(bpPathRanges_)), methodRanges_(std::move(methodRanges_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
// reader
UnrealLogEvent UnrealLogEvent::read(rd::SerializationCtx& ctx, rd::Buffer & buffer)
{
    auto info_ = LogMessageInfo::read(ctx, buffer);
    auto text_ = rd::Polymorphic<FString>::read(ctx, buffer);
    auto bpPathRanges_ = buffer.read_array<TArray, StringRange, FDefaultAllocator>(
    [&ctx, &buffer]() mutable  
    { return StringRange::read(ctx, buffer); }
    );
    auto methodRanges_ = buffer.read_array<TArray, StringRange, FDefaultAllocator>(
    [&ctx, &buffer]() mutable  
    { return StringRange::read(ctx, buffer); }
    );
    UnrealLogEvent res{std::move(info_), std::move(text_), std::move(bpPathRanges_), std::move(methodRanges_)};
    return res;
}
// writer
void UnrealLogEvent::write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const
{
    rd::Polymorphic<std::decay_t<decltype(info_)>>::write(ctx, buffer, info_);
    rd::Polymorphic<std::decay_t<decltype(text_)>>::write(ctx, buffer, text_);
    buffer.write_array<TArray, StringRange, FDefaultAllocator>(bpPathRanges_, 
    [&ctx, &buffer](StringRange const & it) mutable  -> void 
    { rd::Polymorphic<std::decay_t<decltype(it)>>::write(ctx, buffer, it); }
    );
    buffer.write_array<TArray, StringRange, FDefaultAllocator>(methodRanges_, 
    [&ctx, &buffer](StringRange const & it) mutable  -> void 
    { rd::Polymorphic<std::decay_t<decltype(it)>>::write(ctx, buffer, it); }
    );
}
// virtual init
// identify
// getters
LogMessageInfo const & UnrealLogEvent::get_info() const
{
    return *info_;
}
FString const & UnrealLogEvent::get_text() const
{
    return text_;
}
TArray<rd::Wrapper<StringRange>> const & UnrealLogEvent::get_bpPathRanges() const
{
    return bpPathRanges_;
}
TArray<rd::Wrapper<StringRange>> const & UnrealLogEvent::get_methodRanges() const
{
    return methodRanges_;
}
// intern
// equals trait
bool UnrealLogEvent::equals(rd::ISerializable const& object) const
{
    auto const &other = dynamic_cast<UnrealLogEvent const&>(object);
    if (this == &other) return true;
    if (this->info_ != other.info_) return false;
    if (this->text_ != other.text_) return false;
    if (this->bpPathRanges_ != other.bpPathRanges_) return false;
    if (this->methodRanges_ != other.methodRanges_) return false;
    
    return true;
}
// equality operators
bool operator==(const UnrealLogEvent &lhs, const UnrealLogEvent &rhs) {
    if (lhs.type_name() != rhs.type_name()) return false;
    return lhs.equals(rhs);
}
bool operator!=(const UnrealLogEvent &lhs, const UnrealLogEvent &rhs){
    return !(lhs == rhs);
}
// hash code trait
size_t UnrealLogEvent::hashCode() const noexcept
{
    size_t __r = 0;
    __r = __r * 31 + (rd::hash<LogMessageInfo>()(get_info()));
    __r = __r * 31 + (rd::hash<FString>()(get_text()));
    __r = __r * 31 + (rd::contentDeepHashCode(get_bpPathRanges()));
    __r = __r * 31 + (rd::contentDeepHashCode(get_methodRanges()));
    return __r;
}
// type name trait
std::string UnrealLogEvent::type_name() const
{
    return "UnrealLogEvent";
}
// static type name trait
std::string UnrealLogEvent::static_type_name()
{
    return "UnrealLogEvent";
}
// polymorphic to string
std::string UnrealLogEvent::toString() const
{
    std::string res = "UnrealLogEvent\n";
    res += "\tinfo = ";
    res += rd::to_string(info_);
    res += '\n';
    res += "\ttext = ";
    res += rd::to_string(text_);
    res += '\n';
    res += "\tbpPathRanges = ";
    res += rd::to_string(bpPathRanges_);
    res += '\n';
    res += "\tmethodRanges = ";
    res += rd::to_string(methodRanges_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const UnrealLogEvent & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/UE4Library/UnrealLogEvent.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef UNREALLOGEVENT_GENERATED_H
#define UNREALLOGEVENT_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_UE4Library.h"

#include "UE4Library/LogMessageInfo.Generated.h"
#include "Runtime/Core/Public/Containers/UnrealString.h"
#include "UE4Library/StringRange.Generated.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: UE4Library.kt:120</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

// data
class RIDERLINK_API UnrealLogEvent : public rd::IPolymorphicSerializable {

private:
    // custom serializers

public:
    // constants

protected:
    // fields
    rd::Wrapper<LogMessageInfo> info_;
    FString text_;
    TArray<rd::Wrapper<StringRange>> bpPathRanges_;
    TArray<rd::Wrapper<StringRange>> methodRanges_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    UnrealLogEvent(rd::Wrapper<LogMessageInfo> info_, FString text_, TArray<rd::Wrapper<StringRange>> bpPathRanges_, TArray<rd::Wrapper<StringRange>> methodRanges_);
    
    // deconstruct trait
    #ifdef __cpp_structured_bindings
    template <size_t I>
    decltype(auto) get() const
    {
        if constexpr (I < 0 || I >= 4) static_assert (I < 0 || I >= 4, "I < 0 || I >= 4");
        else if constexpr (I==0)  return static_cast<const LogMessageInfo&>(get_info());
        else if constexpr (I==1)  return static_cast<const FString&>(get_text());
        else if constexpr (I==2)  return static_cast<const TArray<rd::Wrapper<StringRange>>&>(get_bpPathRanges());
        else if constexpr (I==3)  return static_cast<const TArray<rd::Wrapper<StringRange>>&>(get_methodRanges());
    }
    #endif
    
    // default ctors and dtors
    
    UnrealLogEvent() = delete;
    
    UnrealLogEvent(UnrealLogEvent const &) = default;
    
    UnrealLogEvent& operator=(UnrealLogEvent const &) = default;
    
    UnrealLogEvent(UnrealLogEvent &&) = default;
    
    UnrealLogEvent& operator=(UnrealLogEvent &&) = default;
    
    virtual ~UnrealLogEvent() = default;
    
    // reader
    static UnrealLogEvent read(rd::SerializationCtx& ctx, rd::Buffer & buffer);
    
    // writer
    void write(rd::SerializationCtx& ctx, rd::Buffer& buffer) const override;
    
    // virtual init
    
    // identify
    
    // getters
    LogMessageInfo const & get_info() const;
    FString const & get_text() const;
    TArray<rd::Wrapper<StringRange>> const & get_bpPathRanges() const;
    TArray<rd::Wrapper<StringRange>> const & get_methodRanges() const;
    
    // intern

private:
    // equals trait
    bool equals(rd::ISerializable const& object) const override;

public:
    // equality operators
    friend bool operator==(const UnrealLogEvent &lhs, const UnrealLogEvent &rhs);
    friend bool operator!=(const UnrealLogEvent &lhs, const UnrealLogEvent &rhs);
    // hash code trait
    size_t hashCode() const noexcept override;
    // type name trait
    std::string type_name() const override;
    // static type name trait
    static std::string static_type_name();

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const UnrealLogEvent & value);
};

}
}

// hash code trait
namespace rd {

template <>
struct hash<JetBrains::EditorPlugin::UnrealLogEvent> {
    size_t operator()(const JetBrains::EditorPlugin::UnrealLogEvent & value) const noexcept {
        return value.hashCode();
    }
};

}

#ifdef __cpp_structured_bindings
// tuple trait
namespace std {

template <>
class tuple_size<JetBrains::EditorPlugin::UnrealLogEvent> : public integral_constant<size_t, 4> {};

template <size_t I>
class tuple_element<I, JetBrains::EditorPlugin::UnrealLogEvent> {
public:
    using type = decltype (declval<JetBrains::EditorPlugin::UnrealLogEvent>().get<I>());
};

}
#endif

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // UNREALLOGEVENT_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/instantiations_UE4Library.cpp`:

```cpp
#include "instantiations_UE4Library.h"

namespace rd {
template class Polymorphic<ELogVerbosity::Type>;
}

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/Library/instantiations_UE4Library.h`:

```h
#ifndef INSTANTIATIONS_UE4LIBRARY_H
#define INSTANTIATIONS_UE4LIBRARY_H

#include "serialization/Polymorphic.h"

#include "UE4TypesMarshallers.h"
#include "Runtime/Core/Public/Containers/Array.h"
#include "Runtime/Core/Public/Containers/ContainerAllocationPolicies.h"

namespace ELogVerbosity {
enum Type : uint8;
}

namespace rd {
template <>
class Polymorphic<ELogVerbosity::Type> {

public:
    static ELogVerbosity::Type read(SerializationCtx& ctx, Buffer& buffer) {
        int32_t x = buffer.read_integral<int32_t>();
        switch (x) {
        case 10:
           return ELogVerbosity::Type::VerbosityMask;
        case 11:
           return ELogVerbosity::Type::SetColor;
        case 12:
           return ELogVerbosity::Type::BreakOnLog;
        default:
           return static_cast<ELogVerbosity::Type>(x);
        }
    }
    
    static void write(SerializationCtx& ctx, Buffer& buffer, ELogVerbosity::Type const& value) {
        switch (value) {
        case ELogVerbosity::Type::VerbosityMask: {
           buffer.write_integral<int32_t>(10);
           return;
        }
        case ELogVerbosity::Type::SetColor: {
           buffer.write_integral<int32_t>(11);
           return;
        }
        case ELogVerbosity::Type::BreakOnLog: {
           buffer.write_integral<int32_t>(12);
           return;
        }
        default:
            buffer.write_integral<int32_t>(static_cast<int32_t>(value));
        }
    }
};

extern template class Polymorphic<ELogVerbosity::Type>;

}

#endif // INSTANTIATIONS_UE4LIBRARY_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.7)
add_library(RdEditorRoot STATIC 
instantiations_RdEditorRoot.h
instantiations_RdEditorRoot.cpp
RdEditorModel/RdEditorModel.Generated.cpp
RdEditorModel/RdEditorModel.Generated.h
RdEditorRoot/RdEditorRoot.Generated.cpp
RdEditorRoot/RdEditorRoot.Generated.h)
target_include_directories(RdEditorRoot PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_link_libraries(RdEditorRoot PUBLIC rd_framework_cpp)

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "RdEditorModel.Generated.h"


#include "RdEditorRoot/RdEditorRoot.Generated.h"

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion

RdEditorModel::RdEditorModelSerializersOwner const RdEditorModel::serializersOwner;

void RdEditorModel::RdEditorModelSerializersOwner::registerSerializersCore(rd::Serializers const& serializers) const
{
}

void RdEditorModel::connect(rd::Lifetime lifetime, rd::IProtocol const * protocol)
{
    RdEditorRoot::serializersOwner.registry(protocol->get_serializers());
    
    identify(*(protocol->get_identity()), rd::RdId::Null().mix("RdEditorModel"));
    bind(lifetime, protocol, "RdEditorModel");
}

// constants
// initializer
void RdEditorModel::initialize()
{
    connectionInfo_.optimize_nested = true;
    isGameControlModuleInitialized_.optimize_nested = true;
    unrealLog_.async = true;
    onBlueprintAdded_.async = true;
    serializationHash = -55649919033701264L;
}
// primary ctor
RdEditorModel::RdEditorModel(rd::RdProperty<ConnectionInfo, rd::Polymorphic<ConnectionInfo>> connectionInfo_, rd::RdSignal<UnrealLogEvent, rd::Polymorphic<UnrealLogEvent>> unrealLog_, rd::RdSignal<BlueprintReference, rd::Polymorphic<BlueprintReference>> openBlueprint_, rd::RdSignal<UClass, rd::Polymorphic<UClass>> onBlueprintAdded_, rd::RdEndpoint<FString, bool, rd::Polymorphic<FString>, rd::Polymorphic<bool>> isBlueprintPathName_, rd::RdEndpoint<FString, rd::optional<FString>, rd::Polymorphic<FString>, RdEditorModel::__FStringNullableSerializer> getPathNameByPath_, rd::RdCall<int32_t, bool, rd::Polymorphic<int32_t>, rd::Polymorphic<bool>> allowSetForegroundWindow_, rd::RdProperty<bool, rd::Polymorphic<bool>> isGameControlModuleInitialized_, rd::RdSignal<PlayState, rd::Polymorphic<PlayState>> playStateFromEditor_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestPlayFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestPauseFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestResumeFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestStopFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestFrameSkipFromRider_, rd::RdSignal<RequestResultBase, rd::AbstractPolymorphic<RequestResultBase>> notificationReplyFromEditor_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> playModeFromEditor_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> playModeFromRider_) :
rd::RdExtBase()
,connectionInfo_(std::move(connectionInfo_)), unrealLog_(std::move(unrealLog_)), openBlueprint_(std::move(openBlueprint_)), onBlueprintAdded_(std::move(onBlueprintAdded_)), isBlueprintPathName_(std::move(isBlueprintPathName_)), getPathNameByPath_(std::move(getPathNameByPath_)), allowSetForegroundWindow_(std::move(allowSetForegroundWindow_)), isGameControlModuleInitialized_(std::move(isGameControlModuleInitialized_)), playStateFromEditor_(std::move(playStateFromEditor_)), requestPlayFromRider_(std::move(requestPlayFromRider_)), requestPauseFromRider_(std::move(requestPauseFromRider_)), requestResumeFromRider_(std::move(requestResumeFromRider_)), requestStopFromRider_(std::move(requestStopFromRider_)), requestFrameSkipFromRider_(std::move(requestFrameSkipFromRider_)), notificationReplyFromEditor_(std::move(notificationReplyFromEditor_)), playModeFromEditor_(std::move(playModeFromEditor_)), playModeFromRider_(std::move(playModeFromRider_))
{
    initialize();
}
// secondary constructor
// default ctors and dtors
RdEditorModel::RdEditorModel()
{
    initialize();
}
// reader
// writer
// virtual init
void RdEditorModel::init(rd::Lifetime lifetime) const
{
    rd::RdExtBase::init(lifetime);
    bindPolymorphic(connectionInfo_, lifetime, this, "connectionInfo");
    bindPolymorphic(unrealLog_, lifetime, this, "unrealLog");
    bindPolymorphic(openBlueprint_, lifetime, this, "openBlueprint");
    bindPolymorphic(onBlueprintAdded_, lifetime, this, "onBlueprintAdded");
    bindPolymorphic(isBlueprintPathName_, lifetime, this, "isBlueprintPathName");
    bindPolymorphic(getPathNameByPath_, lifetime, this, "getPathNameByPath");
    bindPolymorphic(allowSetForegroundWindow_, lifetime, this, "allowSetForegroundWindow");
    bindPolymorphic(isGameControlModuleInitialized_, lifetime, this, "isGameControlModuleInitialized");
    bindPolymorphic(playStateFromEditor_, lifetime, this, "playStateFromEditor");
    bindPolymorphic(requestPlayFromRider_, lifetime, this, "requestPlayFromRider");
    bindPolymorphic(requestPauseFromRider_, lifetime, this, "requestPauseFromRider");
    bindPolymorphic(requestResumeFromRider_, lifetime, this, "requestResumeFromRider");
    bindPolymorphic(requestStopFromRider_, lifetime, this, "requestStopFromRider");
    bindPolymorphic(requestFrameSkipFromRider_, lifetime, this, "requestFrameSkipFromRider");
    bindPolymorphic(notificationReplyFromEditor_, lifetime, this, "notificationReplyFromEditor");
    bindPolymorphic(playModeFromEditor_, lifetime, this, "playModeFromEditor");
    bindPolymorphic(playModeFromRider_, lifetime, this, "playModeFromRider");
}
// identify
void RdEditorModel::identify(const rd::Identities &identities, rd::RdId const &id) const
{
    rd::RdBindableBase::identify(identities, id);
    identifyPolymorphic(connectionInfo_, identities, id.mix(".connectionInfo"));
    identifyPolymorphic(unrealLog_, identities, id.mix(".unrealLog"));
    identifyPolymorphic(openBlueprint_, identities, id.mix(".openBlueprint"));
    identifyPolymorphic(onBlueprintAdded_, identities, id.mix(".onBlueprintAdded"));
    identifyPolymorphic(isBlueprintPathName_, identities, id.mix(".isBlueprintPathName"));
    identifyPolymorphic(getPathNameByPath_, identities, id.mix(".getPathNameByPath"));
    identifyPolymorphic(allowSetForegroundWindow_, identities, id.mix(".allowSetForegroundWindow"));
    identifyPolymorphic(isGameControlModuleInitialized_, identities, id.mix(".isGameControlModuleInitialized"));
    identifyPolymorphic(playStateFromEditor_, identities, id.mix(".playStateFromEditor"));
    identifyPolymorphic(requestPlayFromRider_, identities, id.mix(".requestPlayFromRider"));
    identifyPolymorphic(requestPauseFromRider_, identities, id.mix(".requestPauseFromRider"));
    identifyPolymorphic(requestResumeFromRider_, identities, id.mix(".requestResumeFromRider"));
    identifyPolymorphic(requestStopFromRider_, identities, id.mix(".requestStopFromRider"));
    identifyPolymorphic(requestFrameSkipFromRider_, identities, id.mix(".requestFrameSkipFromRider"));
    identifyPolymorphic(notificationReplyFromEditor_, identities, id.mix(".notificationReplyFromEditor"));
    identifyPolymorphic(playModeFromEditor_, identities, id.mix(".playModeFromEditor"));
    identifyPolymorphic(playModeFromRider_, identities, id.mix(".playModeFromRider"));
}
// getters
rd::IProperty<ConnectionInfo> const & RdEditorModel::get_connectionInfo() const
{
    return connectionInfo_;
}
rd::ISignal<UnrealLogEvent> const & RdEditorModel::get_unrealLog() const
{
    return unrealLog_;
}
rd::ISignal<BlueprintReference> const & RdEditorModel::get_openBlueprint() const
{
    return openBlueprint_;
}
rd::ISignal<UClass> const & RdEditorModel::get_onBlueprintAdded() const
{
    return onBlueprintAdded_;
}
rd::RdEndpoint<FString, bool, rd::Polymorphic<FString>, rd::Polymorphic<bool>> const & RdEditorModel::get_isBlueprintPathName() const
{
    return isBlueprintPathName_;
}
rd::RdEndpoint<FString, rd::optional<FString>, rd::Polymorphic<FString>, RdEditorModel::__FStringNullableSerializer> const & RdEditorModel::get_getPathNameByPath() const
{
    return getPathNameByPath_;
}
rd::RdCall<int32_t, bool, rd::Polymorphic<int32_t>, rd::Polymorphic<bool>> const & RdEditorModel::get_allowSetForegroundWindow() const
{
    return allowSetForegroundWindow_;
}
rd::IProperty<bool> const & RdEditorModel::get_isGameControlModuleInitialized() const
{
    return isGameControlModuleInitialized_;
}
rd::ISignal<PlayState> const & RdEditorModel::get_playStateFromEditor() const
{
    return playStateFromEditor_;
}
rd::ISource<int32_t> const & RdEditorModel::get_requestPlayFromRider() const
{
    return requestPlayFromRider_;
}
rd::ISource<int32_t> const & RdEditorModel::get_requestPauseFromRider() const
{
    return requestPauseFromRider_;
}
rd::ISource<int32_t> const & RdEditorModel::get_requestResumeFromRider() const
{
    return requestResumeFromRider_;
}
rd::ISource<int32_t> const & RdEditorModel::get_requestStopFromRider() const
{
    return requestStopFromRider_;
}
rd::ISource<int32_t> const & RdEditorModel::get_requestFrameSkipFromRider() const
{
    return requestFrameSkipFromRider_;
}
rd::ISignal<RequestResultBase> const & RdEditorModel::get_notificationReplyFromEditor() const
{
    return notificationReplyFromEditor_;
}
rd::ISignal<int32_t> const & RdEditorModel::get_playModeFromEditor() const
{
    return playModeFromEditor_;
}
rd::ISource<int32_t> const & RdEditorModel::get_playModeFromRider() const
{
    return playModeFromRider_;
}
// intern
// equals trait
// equality operators
bool operator==(const RdEditorModel &lhs, const RdEditorModel &rhs) {
    return &lhs == &rhs;
}
bool operator!=(const RdEditorModel &lhs, const RdEditorModel &rhs){
    return !(lhs == rhs);
}
// hash code trait
// type name trait
// static type name trait
// polymorphic to string
std::string RdEditorModel::toString() const
{
    std::string res = "RdEditorModel\n";
    res += "\tconnectionInfo = ";
    res += rd::to_string(connectionInfo_);
    res += '\n';
    res += "\tunrealLog = ";
    res += rd::to_string(unrealLog_);
    res += '\n';
    res += "\topenBlueprint = ";
    res += rd::to_string(openBlueprint_);
    res += '\n';
    res += "\tonBlueprintAdded = ";
    res += rd::to_string(onBlueprintAdded_);
    res += '\n';
    res += "\tisBlueprintPathName = ";
    res += rd::to_string(isBlueprintPathName_);
    res += '\n';
    res += "\tgetPathNameByPath = ";
    res += rd::to_string(getPathNameByPath_);
    res += '\n';
    res += "\tallowSetForegroundWindow = ";
    res += rd::to_string(allowSetForegroundWindow_);
    res += '\n';
    res += "\tisGameControlModuleInitialized = ";
    res += rd::to_string(isGameControlModuleInitialized_);
    res += '\n';
    res += "\tplayStateFromEditor = ";
    res += rd::to_string(playStateFromEditor_);
    res += '\n';
    res += "\trequestPlayFromRider = ";
    res += rd::to_string(requestPlayFromRider_);
    res += '\n';
    res += "\trequestPauseFromRider = ";
    res += rd::to_string(requestPauseFromRider_);
    res += '\n';
    res += "\trequestResumeFromRider = ";
    res += rd::to_string(requestResumeFromRider_);
    res += '\n';
    res += "\trequestStopFromRider = ";
    res += rd::to_string(requestStopFromRider_);
    res += '\n';
    res += "\trequestFrameSkipFromRider = ";
    res += rd::to_string(requestFrameSkipFromRider_);
    res += '\n';
    res += "\tnotificationReplyFromEditor = ";
    res += rd::to_string(notificationReplyFromEditor_);
    res += '\n';
    res += "\tplayModeFromEditor = ";
    res += rd::to_string(playModeFromEditor_);
    res += '\n';
    res += "\tplayModeFromRider = ";
    res += rd::to_string(playModeFromRider_);
    res += '\n';
    return res;
}
// external to string
std::string to_string(const RdEditorModel & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef RDEDITORMODEL_GENERATED_H
#define RDEDITORMODEL_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_RdEditorRoot.h"

#include "UE4Library/ConnectionInfo.Generated.h"
#include "UE4Library/UnrealLogEvent.Generated.h"
#include "UE4Library/BlueprintReference.Generated.h"
#include "UE4Library/UClass.Generated.h"
#include "Runtime/Core/Public/Containers/UnrealString.h"
#include "UE4Library/PlayState.Generated.h"
#include "UE4Library/RequestResultBase.Generated.h"

#include "UE4TypesMarshallers.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: RdEditorModel.kt:23</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API RdEditorModel : public rd::RdExtBase {

public:
    struct RdEditorModelSerializersOwner final : public rd::ISerializersOwner {
        void registerSerializersCore(rd::Serializers const& serializers) const override;
    };
    
    static const RdEditorModelSerializersOwner serializersOwner;
    
    

public:
    void connect(rd::Lifetime lifetime, rd::IProtocol const * protocol);
    

private:
    // custom serializers
    using __FStringNullableSerializer = rd::NullableSerializer<rd::Polymorphic<FString>>;

public:
    // constants

protected:
    // fields
    rd::RdProperty<ConnectionInfo, rd::Polymorphic<ConnectionInfo>> connectionInfo_;
    rd::RdSignal<UnrealLogEvent, rd::Polymorphic<UnrealLogEvent>> unrealLog_;
    rd::RdSignal<BlueprintReference, rd::Polymorphic<BlueprintReference>> openBlueprint_;
    rd::RdSignal<UClass, rd::Polymorphic<UClass>> onBlueprintAdded_;
    rd::RdEndpoint<FString, bool, rd::Polymorphic<FString>, rd::Polymorphic<bool>> isBlueprintPathName_;
    rd::RdEndpoint<FString, rd::optional<FString>, rd::Polymorphic<FString>, RdEditorModel::__FStringNullableSerializer> getPathNameByPath_;
    rd::RdCall<int32_t, bool, rd::Polymorphic<int32_t>, rd::Polymorphic<bool>> allowSetForegroundWindow_;
    rd::RdProperty<bool, rd::Polymorphic<bool>> isGameControlModuleInitialized_{false};
    rd::RdSignal<PlayState, rd::Polymorphic<PlayState>> playStateFromEditor_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestPlayFromRider_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestPauseFromRider_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestResumeFromRider_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestStopFromRider_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestFrameSkipFromRider_;
    rd::RdSignal<RequestResultBase, rd::AbstractPolymorphic<RequestResultBase>> notificationReplyFromEditor_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> playModeFromEditor_;
    rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> playModeFromRider_;
    

private:
    // initializer
    void initialize();

public:
    // primary ctor
    RdEditorModel(rd::RdProperty<ConnectionInfo, rd::Polymorphic<ConnectionInfo>> connectionInfo_, rd::RdSignal<UnrealLogEvent, rd::Polymorphic<UnrealLogEvent>> unrealLog_, rd::RdSignal<BlueprintReference, rd::Polymorphic<BlueprintReference>> openBlueprint_, rd::RdSignal<UClass, rd::Polymorphic<UClass>> onBlueprintAdded_, rd::RdEndpoint<FString, bool, rd::Polymorphic<FString>, rd::Polymorphic<bool>> isBlueprintPathName_, rd::RdEndpoint<FString, rd::optional<FString>, rd::Polymorphic<FString>, RdEditorModel::__FStringNullableSerializer> getPathNameByPath_, rd::RdCall<int32_t, bool, rd::Polymorphic<int32_t>, rd::Polymorphic<bool>> allowSetForegroundWindow_, rd::RdProperty<bool, rd::Polymorphic<bool>> isGameControlModuleInitialized_, rd::RdSignal<PlayState, rd::Polymorphic<PlayState>> playStateFromEditor_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestPlayFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestPauseFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestResumeFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestStopFromRider_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> requestFrameSkipFromRider_, rd::RdSignal<RequestResultBase, rd::AbstractPolymorphic<RequestResultBase>> notificationReplyFromEditor_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> playModeFromEditor_, rd::RdSignal<int32_t, rd::Polymorphic<int32_t>> playModeFromRider_);
    
    // default ctors and dtors
    
    RdEditorModel();
    
    RdEditorModel(RdEditorModel &&) = delete;
    
    RdEditorModel& operator=(RdEditorModel &&) = delete;
    
    virtual ~RdEditorModel() = default;
    
    // reader
    
    // writer
    
    // virtual init
    void init(rd::Lifetime lifetime) const override;
    
    // identify
    void identify(const rd::Identities &identities, rd::RdId const &id) const override;
    
    // getters
    rd::IProperty<ConnectionInfo> const & get_connectionInfo() const;
    rd::ISignal<UnrealLogEvent> const & get_unrealLog() const;
    rd::ISignal<BlueprintReference> const & get_openBlueprint() const;
    rd::ISignal<UClass> const & get_onBlueprintAdded() const;
    rd::RdEndpoint<FString, bool, rd::Polymorphic<FString>, rd::Polymorphic<bool>> const & get_isBlueprintPathName() const;
    rd::RdEndpoint<FString, rd::optional<FString>, rd::Polymorphic<FString>, RdEditorModel::__FStringNullableSerializer> const & get_getPathNameByPath() const;
    rd::RdCall<int32_t, bool, rd::Polymorphic<int32_t>, rd::Polymorphic<bool>> const & get_allowSetForegroundWindow() const;
    rd::IProperty<bool> const & get_isGameControlModuleInitialized() const;
    rd::ISignal<PlayState> const & get_playStateFromEditor() const;
    rd::ISource<int32_t> const & get_requestPlayFromRider() const;
    rd::ISource<int32_t> const & get_requestPauseFromRider() const;
    rd::ISource<int32_t> const & get_requestResumeFromRider() const;
    rd::ISource<int32_t> const & get_requestStopFromRider() const;
    rd::ISource<int32_t> const & get_requestFrameSkipFromRider() const;
    rd::ISignal<RequestResultBase> const & get_notificationReplyFromEditor() const;
    rd::ISignal<int32_t> const & get_playModeFromEditor() const;
    rd::ISource<int32_t> const & get_playModeFromRider() const;
    
    // intern

private:
    // equals trait

public:
    // equality operators
    friend bool operator==(const RdEditorModel &lhs, const RdEditorModel &rhs);
    friend bool operator!=(const RdEditorModel &lhs, const RdEditorModel &rhs);
    // hash code trait
    // type name trait
    // static type name trait

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const RdEditorModel & value);
};

}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // RDEDITORMODEL_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/RdEditorRoot/RdEditorRoot.Generated.cpp`:

```cpp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#include "RdEditorRoot.Generated.h"


#include "RdEditorRoot/RdEditorRoot.Generated.h"
#include "RdEditorRoot/RdEditorRoot.Generated.h"
#include "RdEditorModel/RdEditorModel.Generated.h"

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

namespace JetBrains {
namespace EditorPlugin {
// companion

RdEditorRoot::RdEditorRootSerializersOwner const RdEditorRoot::serializersOwner;

void RdEditorRoot::RdEditorRootSerializersOwner::registerSerializersCore(rd::Serializers const& serializers) const
{
    RdEditorModel::serializersOwner.registry(serializers);
}

void RdEditorRoot::connect(rd::Lifetime lifetime, rd::IProtocol const * protocol)
{
    RdEditorRoot::serializersOwner.registry(protocol->get_serializers());
    
    identify(*(protocol->get_identity()), rd::RdId::Null().mix("RdEditorRoot"));
    bind(lifetime, protocol, "RdEditorRoot");
}

// constants
// initializer
void RdEditorRoot::initialize()
{
    serializationHash = -441687577021743677L;
}
// primary ctor
// secondary constructor
// default ctors and dtors
RdEditorRoot::RdEditorRoot()
{
    initialize();
}
// reader
// writer
// virtual init
void RdEditorRoot::init(rd::Lifetime lifetime) const
{
    rd::RdExtBase::init(lifetime);
}
// identify
void RdEditorRoot::identify(const rd::Identities &identities, rd::RdId const &id) const
{
    rd::RdBindableBase::identify(identities, id);
}
// getters
// intern
// equals trait
// equality operators
bool operator==(const RdEditorRoot &lhs, const RdEditorRoot &rhs) {
    return &lhs == &rhs;
}
bool operator!=(const RdEditorRoot &lhs, const RdEditorRoot &rhs){
    return !(lhs == rhs);
}
// hash code trait
// type name trait
// static type name trait
// polymorphic to string
std::string RdEditorRoot::toString() const
{
    std::string res = "RdEditorRoot\n";
    return res;
}
// external to string
std::string to_string(const RdEditorRoot & value)
{
    return value.toString();
}
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif


```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/RdEditorRoot/RdEditorRoot.Generated.h`:

```h
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef RDEDITORROOT_GENERATED_H
#define RDEDITORROOT_GENERATED_H


#include "protocol/Protocol.h"
#include "types/DateTime.h"
#include "impl/RdSignal.h"
#include "impl/RdProperty.h"
#include "impl/RdList.h"
#include "impl/RdSet.h"
#include "impl/RdMap.h"
#include "base/ISerializersOwner.h"
#include "base/IUnknownInstance.h"
#include "serialization/ISerializable.h"
#include "serialization/Polymorphic.h"
#include "serialization/NullableSerializer.h"
#include "serialization/ArraySerializer.h"
#include "serialization/InternedSerializer.h"
#include "serialization/SerializationCtx.h"
#include "serialization/Serializers.h"
#include "ext/RdExtBase.h"
#include "task/RdCall.h"
#include "task/RdEndpoint.h"
#include "task/RdSymmetricCall.h"
#include "std/to_string.h"
#include "std/hash.h"
#include "std/allocator.h"
#include "util/enum.h"
#include "util/gen_util.h"

#include <cstring>
#include <cstdint>
#include <vector>
#include <ctime>

#include "thirdparty.hpp"
#include "instantiations_RdEditorRoot.h"

#include "UE4TypesMarshallers.h"


#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable:4250 )
#pragma warning( disable:4307 )
#pragma warning( disable:4267 )
#pragma warning( disable:4244 )
#pragma warning( disable:4100 )
#endif

/// <summary>
/// <p>Generated from: RdEditorModel.kt:10</p>
/// </summary>
namespace JetBrains {
namespace EditorPlugin {

class RIDERLINK_API RdEditorRoot : public rd::RdExtBase {

public:
    struct RdEditorRootSerializersOwner final : public rd::ISerializersOwner {
        void registerSerializersCore(rd::Serializers const& serializers) const override;
    };
    
    static const RdEditorRootSerializersOwner serializersOwner;
    
    

public:
    void connect(rd::Lifetime lifetime, rd::IProtocol const * protocol);
    

private:
    // custom serializers

public:
    // constants

protected:
    // fields

private:
    // initializer
    void initialize();

public:
    
    // default ctors and dtors
    
    RdEditorRoot();
    
    RdEditorRoot(RdEditorRoot &&) = delete;
    
    RdEditorRoot& operator=(RdEditorRoot &&) = delete;
    
    virtual ~RdEditorRoot() = default;
    
    // reader
    
    // writer
    
    // virtual init
    void init(rd::Lifetime lifetime) const override;
    
    // identify
    void identify(const rd::Identities &identities, rd::RdId const &id) const override;
    
    // getters
    
    // intern

private:
    // equals trait

public:
    // equality operators
    friend bool operator==(const RdEditorRoot &lhs, const RdEditorRoot &rhs);
    friend bool operator!=(const RdEditorRoot &lhs, const RdEditorRoot &rhs);
    // hash code trait
    // type name trait
    // static type name trait

private:
    // polymorphic to string
    std::string toString() const override;

public:
    // external to string
    friend std::string to_string(const RdEditorRoot & value);
};

}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif



#endif // RDEDITORROOT_GENERATED_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/instantiations_RdEditorRoot.cpp`:

```cpp
#include "instantiations_RdEditorRoot.h"

namespace rd {
}

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/Model/RdEditorProtocol/instantiations_RdEditorRoot.h`:

```h
#ifndef INSTANTIATIONS_RDEDITORROOT_H
#define INSTANTIATIONS_RDEDITORROOT_H

#include "serialization/Polymorphic.h"



namespace rd {
}

#endif // INSTANTIATIONS_RDEDITORROOT_H

```

`Plugins/Developer/RiderLink/Source/RiderLink/Public/UE4TypesMarshallers.h`:

```h
#pragma once

#include "serialization/Polymorphic.h"
#include "std/hash.h"

#include "Containers/UnrealString.h"
#include "Containers/StringConv.h"
#include "Templates/UniquePtr.h"


//region FString

inline std::string to_string(FString const& val) {
    return TCHAR_TO_UTF8(*val);
}

template <typename T, typename A>
int32_t size(TArray<T, A> const& value) {
    return static_cast<int32_t>(value.Num());
}

template <typename T, typename A>
void resize(TArray<T, A>& value, int32_t size) {
    value.Reserve(size);
}

namespace rd {
    template <>
    class Polymorphic<FString> {
    public:
        static FString read(SerializationCtx& ctx, Buffer& buffer);

        static void write(SerializationCtx& ctx, Buffer& buffer, FString const& value);
    };

    template <>
    class Polymorphic<Wrapper<FString>> {
    public:
        static void write(SerializationCtx& ctx, Buffer& buffer, Wrapper<FString> const& value);
    };

    template <>
    struct hash<FString> {
        size_t operator()(const FString& value) const noexcept;
    };

    // template <typename T>
    // std::string to_string(TArray<T> const& val);

    template <typename T>
    struct hash<TArray<T>> {
        size_t operator()(const TArray<T>& value) const noexcept;
    };

    template <typename T>
    Wrapper<T> ToRdWrapper(TUniquePtr<T>&& Ptr) {
        Wrapper<T> Result;
        Result.reset(std::move(Ptr).Release());
        return Result;
    }
}

extern template class rd::Polymorphic<FString>;
extern template class rd::Polymorphic<rd::Wrapper<FString>>;
extern template struct rd::hash<FString>;
// extern template class rd::Polymorphic<TArray<FString>, void>;

//endregion

```

`Plugins/Developer/RiderLink/Source/RiderLink/RiderLink.Build.cs`:

```cs
// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

using System.IO;
using UnrealBuildTool;

public class RiderLink : ModuleRules
{
	public RiderLink(ReadOnlyTargetRules Target) : base(Target)
	{
#if UE_4_22_OR_LATER
		PCHUsage = PCHUsageMode.NoPCHs;
#else
		PCHUsage = PCHUsageMode.NoSharedPCHs;
#endif
		
		bUseRTTI = true;

		PublicDependencyModuleNames.Add("Core");
		PublicDependencyModuleNames.Add("RD");
		string[] Paths = {
			"Public/Model/Library",
			"Public/Model/RdEditorProtocol",
		};
		
		PrivateDefinitions.Add("ENABLE_LOG_FILE=0");

		foreach(var Item in Paths)
		{
			PublicIncludePaths.Add(Path.Combine(ModuleDirectory, Item));
		}
	}
}

```

`Plugins/Developer/RiderLink/Source/RiderLogging/Private/RiderLogging.cpp`:

```cpp
#include "RiderLogging.hpp"

#include "BlueprintProvider.hpp"
#include "IRiderLink.hpp"
#include "Model/Library/UE4Library/LogMessageInfo.Generated.h"
#include "Model/Library/UE4Library/StringRange.Generated.h"
#include "Model/Library/UE4Library/UnrealLogEvent.Generated.h"

#include "Internationalization/Regex.h"
#include "Misc/DateTime.h"
#include "Modules/ModuleManager.h"

#define LOCTEXT_NAMESPACE "RiderLink"

DEFINE_LOG_CATEGORY(FLogRiderLoggingModule);

IMPLEMENT_MODULE(FRiderLoggingModule, RiderLogging);

namespace LoggingExtensionImpl
{
static TArray<rd::Wrapper<JetBrains::EditorPlugin::StringRange>> GetPathRanges(
	const FRegexPattern& Pattern,
	const FString& Str)
{
	using JetBrains::EditorPlugin::StringRange;
	FRegexMatcher Matcher(Pattern, Str);
	TArray<rd::Wrapper<StringRange>> Ranges;
	while (Matcher.FindNext())
	{
		const int Start = Matcher.GetMatchBeginning();
		const int End = Matcher.GetMatchEnding();
		FString PathName = Str.Mid(Start, End - Start);
		if (BluePrintProvider::IsBlueprint(PathName))
			Ranges.Emplace(StringRange(Start, End));
	}
	return Ranges;
}

static TArray<rd::Wrapper<JetBrains::EditorPlugin::StringRange>> GetMethodRanges(
	const FRegexPattern& Pattern,
	const FString& Str)
{
	using JetBrains::EditorPlugin::StringRange;
	FRegexMatcher Matcher(Pattern, Str);
	TArray<rd::Wrapper<StringRange>> Ranges;
	while (Matcher.FindNext())
	{
		Ranges.Emplace(StringRange(Matcher.GetMatchBeginning(), Matcher.GetMatchEnding()));
	}
	return Ranges;
}

static bool SendMessageToRider(const JetBrains::EditorPlugin::LogMessageInfo& MessageInfo, const FString& Message)
{
	static const FRegexPattern PathPattern = FRegexPattern(TEXT("(/[\\w\\.]+)+"));
	static const FRegexPattern MethodPattern = FRegexPattern(TEXT("[0-9a-z_A-Z]+::~?[0-9a-z_A-Z]+"));
	
	return IRiderLinkModule::Get().FireAsyncAction(
	[&MessageInfo, &Message] (JetBrains::EditorPlugin::RdEditorModel const& RdEditorModel)
	{
		rd::ISignal<JetBrains::EditorPlugin::UnrealLogEvent> const& UnrealLog = RdEditorModel.get_unrealLog();
		UnrealLog.fire({
			MessageInfo,
			Message,
			GetPathRanges(PathPattern, Message),
			GetMethodRanges(MethodPattern, Message)
		});
	});
}

void SendMessageInChunks(FString* Msg, const JetBrains::EditorPlugin::LogMessageInfo& MessageInfo)
{
	static int NUMBER_OF_CHUNKS = 1024;
	while (!Msg->IsEmpty())
	{
		SendMessageToRider(MessageInfo, Msg->Left(NUMBER_OF_CHUNKS));
		*Msg = Msg->RightChop(NUMBER_OF_CHUNKS);
	}
}

void ScheduledSendMessage(FString* Msg, const JetBrains::EditorPlugin::LogMessageInfo& MessageInfo)
{
	FString ToSend;
	while (Msg->Split("\n", &ToSend, Msg))
	{
		SendMessageInChunks(&ToSend, MessageInfo);
	}

	SendMessageInChunks(Msg, MessageInfo);
}
}


void FRiderLoggingModule::StartupModule()
{
	UE_LOG(FLogRiderLoggingModule, Verbose, TEXT("STARTUP START"));

	static const auto START_TIME = FDateTime::UtcNow().ToUnixTimestamp();
	static const auto GetTimeNow = [](double Time) -> rd::DateTime
	{
		return rd::DateTime(START_TIME + static_cast<int64>(Time));
	};

	ModuleLifetimeDef = IRiderLinkModule::Get().CreateNestedLifetimeDefinition();
	LoggingScheduler = MakeUnique<rd::SingleThreadScheduler>(ModuleLifetimeDef.lifetime, "LoggingScheduler");
	ModuleLifetimeDef.lifetime->bracket(
	[this]()
	{
		OutputDevice.onSerializeMessage.BindLambda(
		[this](const TCHAR* msg, ELogVerbosity::Type Type, const class FName& Name, TOptional<double> Time)
		{
			if (Type > ELogVerbosity::All) return;

			rd::optional<rd::DateTime> DateTime;
			if (Time)
			{
				DateTime = GetTimeNow(Time.GetValue());
			}
			const FString PlainName = Name.GetPlainNameString();
			const JetBrains::EditorPlugin::LogMessageInfo MessageInfo{Type, PlainName, DateTime};
			LoggingScheduler->queue([Msg = FString(msg), MessageInfo]() mutable
			{
				LoggingExtensionImpl::ScheduledSendMessage(&Msg, MessageInfo);
			});
		});
	},
	[this]()
	{
		if (OutputDevice.onSerializeMessage.IsBound())
			OutputDevice.onSerializeMessage.Unbind();
	});

	UE_LOG(FLogRiderLoggingModule, Verbose, TEXT("STARTUP FINISH"));
}

void FRiderLoggingModule::ShutdownModule()
{
	UE_LOG(FLogRiderLoggingModule, Verbose, TEXT("SHUTDOWN START"));
	ModuleLifetimeDef.terminate();
	UE_LOG(FLogRiderLoggingModule, Verbose, TEXT("SHUTDOWN FINISH"));
}

```

`Plugins/Developer/RiderLink/Source/RiderLogging/Private/RiderLogging.hpp`:

```hpp
#pragma once

#include "RiderOutputDevice.hpp"

#include "Templates/UniquePtr.h"

#include "lifetime/LifetimeDefinition.h"

#include "Logging/LogMacros.h"
#include "Logging/LogVerbosity.h"
#include "Modules/ModuleInterface.h"
#include "scheduler/SingleThreadScheduler.h"

DECLARE_LOG_CATEGORY_EXTERN(FLogRiderLoggingModule, Log, All);

class FRiderLoggingModule : public IModuleInterface
{
public:
    FRiderLoggingModule() = default;
    virtual ~FRiderLoggingModule() override = default;

    /** IModuleInterface implementation */
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
    virtual bool SupportsDynamicReloading() override { return true; }

private:
    TUniquePtr<rd::SingleThreadScheduler> LoggingScheduler;
    FRiderOutputDevice OutputDevice;
    rd::LifetimeDefinition ModuleLifetimeDef;
};

```

`Plugins/Developer/RiderLink/Source/RiderLogging/Private/RiderOutputDevice.cpp`:

```cpp
#include "RiderOutputDevice.hpp"

#include "CoreGlobals.h"
#include "Misc/OutputDeviceRedirector.h"

FRiderOutputDevice::FRiderOutputDevice() {
	GLog->AddOutputDevice(this);
	GLog->SerializeBacklog(this);
}

FRiderOutputDevice::~FRiderOutputDevice() {
	if (onSerializeMessage.IsBound())
		onSerializeMessage.Unbind();
	// At shutdown, GLog may already be null
	if (GLog != nullptr) {
		GLog->RemoveOutputDevice(this);
	}
}

void FRiderOutputDevice::Serialize(const TCHAR* V, ELogVerbosity::Type Verbosity, const FName& Category) {
	onSerializeMessage.ExecuteIfBound(V, Verbosity, Category, {});
}

void FRiderOutputDevice::Serialize(const TCHAR* V, ELogVerbosity::Type Verbosity, const FName& Category,
                                   const double Time) {
	onSerializeMessage.ExecuteIfBound(V, Verbosity, Category, {Time});
}
```

`Plugins/Developer/RiderLink/Source/RiderLogging/Private/RiderOutputDevice.hpp`:

```hpp
#pragma once

#include "Misc/OutputDevice.h"
#include "Delegates/Delegate.h"
#include "Logging/LogVerbosity.h"

DECLARE_DELEGATE_FourParams(FOnSerializeMessage, const TCHAR*, ELogVerbosity::Type, const class FName&, TOptional<double>);

class FRiderOutputDevice : public FOutputDevice {
public:
	FRiderOutputDevice();
	virtual ~FRiderOutputDevice() override;

	FOnSerializeMessage onSerializeMessage;

protected:
	virtual void Serialize(const TCHAR* V, ELogVerbosity::Type Verbosity, const class FName& Category) override;

	virtual void Serialize(const TCHAR* V, ELogVerbosity::Type Verbosity, const class FName& Category, double Time) override;
};

```

`Plugins/Developer/RiderLink/Source/RiderLogging/RiderLogging.Build.cs`:

```cs
// Copyright 1998-2020 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class RiderLogging : ModuleRules
{
	public RiderLogging(ReadOnlyTargetRules Target) : base(Target)
	{
#if UE_4_22_OR_LATER
		PCHUsage = PCHUsageMode.NoPCHs;
#else
		PCHUsage = PCHUsageMode.NoSharedPCHs;
#endif
		
		bUseRTTI = true;

		PrivateDependencyModuleNames.AddRange(new []
		{
			"Core",
			"RD",
			"RiderLink",
			"RiderBlueprint"
		});
	}
}

```

`Plugins/Developer/RiderLink/Source/RiderShaderInfo/RiderShaderInfo.Build.cs`:

```cs
// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class RiderShaderInfo : ModuleRules
{
	public RiderShaderInfo(ReadOnlyTargetRules Target) : base(Target)
	{
#if UE_4_22_OR_LATER
		PCHUsage = PCHUsageMode.NoPCHs;
#else
		PCHUsage = PCHUsageMode.NoSharedPCHs;
#endif
		PrivateDependencyModuleNames.AddRange(new string[] { "Core",  "Projects", "RenderCore" });
	}
}

```

`Plugins/Developer/RiderLink/Source/RiderShaderInfo/RiderShaderInfo.cpp`:

```cpp
#include "RiderShaderInfo.h"

#include "HAL/FileManager.h"
#include "Interfaces/IPluginManager.h"
#include "Misc/FileHelper.h"
#include "Modules/ModuleManager.h"
#include "ShaderCore.h"

IMPLEMENT_MODULE(FRiderShaderInfoModule, RiderShaderInfo);

void FRiderShaderInfoModule::StartupModule()
{
	const TSharedPtr<IPlugin> Plugin = IPluginManager::Get().FindPlugin(TEXT("RiderLink"));
	if(!Plugin.IsValid()) return;
	
	const FString MappingFile = FPaths::Combine(Plugin->GetBaseDir(), TEXT("Intermediate"), TEXT("FileSystemMappings.ini"));
	const FString TmpMappingFile = FPaths::Combine(Plugin->GetBaseDir(), TEXT("Intermediate"), TEXT("~FileSystemMappings.ini"));

	const TMap<FString, FString> ShaderMappings = AllShaderSourceDirectoryMappings();
	const TArray<FString> Mappings = [&ShaderMappings]()->TArray<FString>
	{
		TArray<FString> Result;
		for(const TTuple<FString, FString>& Pair : ShaderMappings)
		{
			Result.Add(FString::Printf(TEXT("%s=%s"), *Pair.Key,  *FPaths::ConvertRelativePathToFull(Pair.Value)));
		}
		return Result;
	}();
	if(IFileManager::Get().FileExists(*MappingFile))
	{
		TArray<FString> Result;
		FFileHelper::LoadFileToStringArray(Result, *MappingFile);
		if(Mappings == Result) return;
	}
	FFileHelper::SaveStringArrayToFile(Mappings, *TmpMappingFile);
	IFileManager::Get().Move(*MappingFile, *TmpMappingFile, true, true);
}

```

`Plugins/Developer/RiderLink/Source/RiderShaderInfo/RiderShaderInfo.h`:

```h
#pragma once

#include "Modules/ModuleInterface.h"

class RIDERSHADERINFO_API FRiderShaderInfoModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
};

```

`Source/FightingGame.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class FightingGameTarget : TargetRules
{
	public FightingGameTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		ExtraModuleNames.AddRange( new string[] { "FightingGame" } );
	}
}

```

`Source/FightingGame/Animation/FightingCharacterAnimInstance.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "FightingCharacterAnimInstance.h"
```

`Source/FightingGame/Animation/FightingCharacterAnimInstance.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "FightingCharacterAnimInstance.generated.h"

UENUM( BlueprintType )
enum class EMontageEventType : uint8
{
	Ended,
	Interrupted,

	COUNT UMETA( Hidden ),
	INVALID UMETA( Hidden ),
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams( FMontageEvent, UAnimMontage*, Montage, EMontageEventType, EventType );

UCLASS()
class FIGHTINGGAME_API UFightingCharacterAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	UFUNCTION( BlueprintImplementableEvent )
	void AnimationRequested( UAnimMontage* AnimationSequence );

	UPROPERTY( BlueprintAssignable, BlueprintCallable, DisplayName = "Montage Event" )
	FMontageEvent m_MontageEvent;
};

```

`Source/FightingGame/Camera/CameraManager.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "CameraManager.h"

#include "GameCamera.h"
#include "Kismet/GameplayStatics.h"

ACameraManager::ACameraManager()
{
    PrimaryActorTick.bCanEverTick = true;
}

void ACameraManager::BeginPlay()
{
    Super::BeginPlay();
}

void ACameraManager::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );
}

void ACameraManager::Init()
{
    TArray<TObjectPtr<AActor>> AllGameCameraActors;
    UGameplayStatics::GetAllActorsOfClass( GetWorld(), AGameCamera::StaticClass(), AllGameCameraActors );

    for( int32 i = 0; i < AllGameCameraActors.Num(); ++i )
    {
        m_GameCameras.Emplace( Cast<AGameCamera>( AllGameCameraActors[i] ) );
    }

    if( !m_FirstCameraId.IsEmpty() )
    {
        if( !SetCamera( m_FirstCameraId ) )
        {
            UE_LOG( LogTemp, Error, TEXT("Could not set camera with id [%s]"), *m_FirstCameraId );
        }
    }
}

bool ACameraManager::SetCamera( FString Id )
{
    if( APlayerController* PC = UGameplayStatics::GetPlayerController( GetWorld(), 0 ) )
    {
        auto* It = m_GameCameras.FindByPredicate( [&]( AGameCamera* Camera )
        {
            return Camera->GetId() == Id;
        } );

        if( !It ) return false;

        PC->SetViewTargetWithBlend( *It );
        (*It)->OnViewSet();

        return true;
    }

    return false;
}

```

`Source/FightingGame/Camera/CameraManager.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "CameraManager.generated.h"

class AGameCamera;
UCLASS()
class FIGHTINGGAME_API ACameraManager : public AActor
{
	GENERATED_BODY()

public:
	ACameraManager();

protected:
	UPROPERTY( EditAnywhere, DisplayName="First Camera Id" )
	FString m_FirstCameraId = TEXT( "" );

	virtual void BeginPlay() override;

public:
	virtual void Tick( float DeltaTime ) override;

	UFUNCTION( BlueprintCallable )
	void Init();

	UFUNCTION( BlueprintCallable )
	bool SetCamera( FString Id );

private:
	TArray<TObjectPtr<AGameCamera>> m_GameCameras;
};

```

`Source/FightingGame/Camera/CharactersSharedCamera.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "CharactersSharedCamera.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "Kismet/GameplayStatics.h"

ACharactersSharedCamera::ACharactersSharedCamera()
{
    PrimaryActorTick.bCanEverTick = true;
}

void ACharactersSharedCamera::BeginPlay()
{
    Super::BeginPlay();

    if( m_AutoAddTargetsOnBeginPlay )
    {
        AddAvailableTargets();
    }
}

void ACharactersSharedCamera::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );

    UpdateCameraPosition( DeltaTime );
}

void ACharactersSharedCamera::OnViewSet()
{
    Super::OnViewSet();

    AddAvailableTargets();
}

bool ACharactersSharedCamera::AddTarget( AActor* Target )
{
    if( m_Targets.Contains( Target ) )
    {
        return false;
    }

    m_Targets.Add( Target );
    return true;
}

bool ACharactersSharedCamera::RemoveTarget( AActor* Target )
{
    if( !m_Targets.Contains( Target ) )
    {
        return false;
    }

    m_Targets.Remove( Target );
    return true;
}

void ACharactersSharedCamera::AddAvailableTargets()
{
    UGameplayStatics::GetAllActorsOfClass( GetWorld(), AFightingCharacter::StaticClass(), m_Targets );
}

FVector ACharactersSharedCamera::GetCenterPosition() const
{
    return UGameplayStatics::GetActorArrayAverageLocation( m_Targets );
}

void ACharactersSharedCamera::UpdateCameraPosition( float DeltaTime )
{
    FVector TargetPosition = GetCenterPosition() + m_PositionOffset;
    FVector LerpedLocation = GetActorLocation();

    float maxDist     = GetMaxActorsDistance();
    float clampedDist = FMath::Max( maxDist, m_MinZoomDistance );

    LerpedLocation.X = FMath::Lerp( LerpedLocation.X, -clampedDist, m_MovementDamping.X * DeltaTime );
    LerpedLocation.Y = FMath::Lerp( LerpedLocation.Y, TargetPosition.Y, m_MovementDamping.Y * DeltaTime );
    LerpedLocation.Z = FMath::Lerp( LerpedLocation.Z, TargetPosition.Z, m_MovementDamping.Z * DeltaTime );

    SetActorLocation( LerpedLocation );
}

float ACharactersSharedCamera::GetMaxActorsDistance() const
{
    float maxDistance = 0.f;

    for( int32 i = 1; i < m_Targets.Num(); ++i )
    {
        for( int32 j = 0; j < m_Targets.Num(); ++j )
        {
            AActor* A = m_Targets[i];
            AActor* B = m_Targets[j];

            float currentDistance = FVector::Distance( A->GetActorLocation(), B->GetActorLocation() );
            if( currentDistance > maxDistance )
            {
                maxDistance = currentDistance;
            }
        }
    }

    return maxDistance;
}

```

`Source/FightingGame/Camera/CharactersSharedCamera.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameCamera.h"
#include "GameFramework/Actor.h"
#include "CharactersSharedCamera.generated.h"

class AFightingCharacter;

UCLASS()
class FIGHTINGGAME_API ACharactersSharedCamera : public AGameCamera
{
	GENERATED_BODY()

protected:
	UPROPERTY( EditAnywhere, DisplayName = "Auto Add Targets On Begin Play" )
	bool m_AutoAddTargetsOnBeginPlay = true;

	UPROPERTY( EditAnywhere, DisplayName = "Movement Damping" )
	FVector m_MovementDamping = FVector( 1.f, 1.f, 1.f );

	UPROPERTY( EditAnywhere, DisplayName = "Position Offset" )
	FVector m_PositionOffset;

	UPROPERTY( EditAnywhere, DisplayName = "Min Zoom Distance (Abs)" )
	float m_MinZoomDistance = 400.f;

	virtual void BeginPlay() override;

public:
	ACharactersSharedCamera();

	virtual void Tick( float DeltaTime ) override;
	virtual void OnViewSet() override;

	bool AddTarget( AActor* Target );
	bool RemoveTarget( AActor* Target );

private:
	UPROPERTY()
	TArray<AActor*> m_Targets;

	UPROPERTY()
	TMap<AActor*, FVector> m_TargetsCentersMap;

	void AddAvailableTargets();
	FVector GetCenterPosition() const;
	void UpdateCameraPosition( float DeltaTime );
	float GetMaxActorsDistance() const;
};

```

`Source/FightingGame/Camera/GameCamera.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "GameCamera.h"


AGameCamera::AGameCamera()
{
	PrimaryActorTick.bCanEverTick = true;
}

void AGameCamera::BeginPlay()
{
	Super::BeginPlay();
}

void AGameCamera::Tick( float DeltaTime )
{
	Super::Tick( DeltaTime );
}

void AGameCamera::OnViewSet()
{
}

FString AGameCamera::GetId() const
{
	return m_Id;
}

```

`Source/FightingGame/Camera/GameCamera.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Camera/CameraActor.h"
#include "GameFramework/Actor.h"
#include "GameCamera.generated.h"

UCLASS()
class FIGHTINGGAME_API AGameCamera : public ACameraActor
{
	GENERATED_BODY()

public:
	AGameCamera();

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Id" )
	FString m_Id;

	virtual void BeginPlay() override;

public:
	virtual void Tick( float DeltaTime ) override;
	virtual void OnViewSet();

	FString GetId() const;
};

```

`Source/FightingGame/Character/FightingCharacter.cpp`:

```cpp
#include "FightingCharacter.h"
#include "FightingGame/Input/MovesBufferComponent.h"
#include "FightingGame/Combat/HitboxHandlerComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include <Runtime/Engine/Classes/Kismet/KismetMathLibrary.h>

#include "Components/BoxComponent.h"
#include "FightingGame/Combat/HitStopComponent.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Debugging/Debug.h"
#include "FightingGame/FSM/StateMachineComponent.h"
#include "FightingGame/Projectile/ProjectileSpawnerComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetSystemLibrary.h"
#include <imgui.h>

namespace
{
    int32 loc_DebugDamageStats = 0;
    FG_CVAR_FLAG_DESC( CVarDebugDamageStats, TEXT( "FightingCharacter.DebugDamageStats" ), loc_DebugDamageStats );

    int32 loc_DebugFacing = 0;
    FG_CVAR_FLAG_DESC( CVarDebugFacing, TEXT( "FightingCharacter.DebugFacing" ), loc_DebugFacing );

    int32 loc_DebugEnableShake = 0;
    FG_CVAR_FLAG_DESC( CVarDebugEnableShake, TEXT( "FightingCharacter.DebugEnableShake" ), loc_DebugEnableShake );

    int32 loc_DebugHP = 0;
    FG_CVAR_FLAG_DESC( CVarDebugHP, TEXT( "FightingCharacter.DebugHP" ), loc_DebugHP );

    constexpr auto loc_RotationStartEpsilon = 1.f;
}

AFightingCharacter::AFightingCharacter()
{
    PrimaryActorTick.bCanEverTick = true;

    m_StateMachine               = CreateDefaultSubobject<UStateMachineComponent>( TEXT( "State Machine" ) );
    m_MovesBuffer                = CreateDefaultSubobject<UMovesBufferComponent>( TEXT( "Moves Buffer" ) );
    m_HitboxHandler              = CreateDefaultSubobject<UHitboxHandlerComponent>( TEXT( "Hitbox Handler" ) );
    m_HitStopComponent           = CreateDefaultSubobject<UHitStopComponent>( TEXT( "Hit Stop" ) );
    m_ProjectileSpawnerComponent = CreateDefaultSubobject<UProjectileSpawnerComponent>( TEXT( "Projectile Spawner" ) );
}

bool AFightingCharacter::IsAirborne() const
{
    return GetCharacterMovement()->IsFalling();
}

bool AFightingCharacter::IsGrounded() const
{
    return !IsAirborne();
}

void AFightingCharacter::UpdateHorizontalMovement( float value )
{
    m_CurrentHorizontalMovement = value;
    AddMovementInput( FVector( 0.f, 1.f, 0.f ), m_CurrentHorizontalMovement );
}

void AFightingCharacter::UpdateFacing()
{
    float lastHorizontalMovement = GetLastMovementInputVector().Y;

    float lastHorizontalMovementSign    = FMath::Sign( lastHorizontalMovement );
    float currentHorizontalMovementSign = FMath::Sign( m_CurrentHorizontalMovement );

    if( IsAutoFacingEnabled() )
    {
        m_IsMovingBackward = m_CurrentHorizontalMovement > 0.f && !IsFacingRight() || m_CurrentHorizontalMovement < 0.f && IsFacingRight();

        if( !IsAirborne() )
        {
            FRotator actorRotation = GetActorRotation();

            float facingMultiplier = UCombatStatics::IsOtherOnTheRight( Cast<IFacingEntity>( this ), Cast<IFacingEntity>( m_OpponentToFace ) ) ? 1.f : -1.f;
            if( IsFacingRight() && FMath::IsNearlyEqual( facingMultiplier, -1.f ) )
            {
                actorRotation.Yaw += loc_RotationStartEpsilon;
                SetActorRotation( actorRotation );
            }
            else if( !IsFacingRight() && FMath::IsNearlyEqual( facingMultiplier, 1.f ) )
            {
                actorRotation.Yaw -= loc_RotationStartEpsilon;
                SetActorRotation( actorRotation );
            }

            m_TargetRotatorYaw = facingMultiplier * 90.f;
        }
    }
    else
    {
        m_IsMovingBackward = false;

        if( !IsAirborne() || m_UpdateFacingWhenAirborne )
        {
            if( !FMath::IsNearlyZero( m_CurrentHorizontalMovement ) )
            {
                if( lastHorizontalMovementSign != currentHorizontalMovementSign )
                {
                    FRotator actorRotation = GetActorRotation();

                    if( lastHorizontalMovementSign > currentHorizontalMovementSign )
                    {
                        // Left movement requested
                        actorRotation.Yaw += loc_RotationStartEpsilon;
                        SetActorRotation( actorRotation );
                    }
                    else if( lastHorizontalMovementSign < currentHorizontalMovementSign )
                    {
                        // Right movement requested
                        actorRotation.Yaw -= loc_RotationStartEpsilon;
                        SetActorRotation( actorRotation );
                    }
                }

                m_TargetRotatorYaw = currentHorizontalMovementSign * 90.f;
            }
        }
    }
}

void AFightingCharacter::BeginPlay()
{
    Super::BeginPlay();

    m_MovesBuffer->m_OwnerCharacter = this;

    m_StateMachine->Start();

    m_HitDelegateHandle = m_HitboxHandler->m_HitDelegate.AddUObject( this, &AFightingCharacter::OnHitLanded );

    InitTimeDilations();

    m_InitialMeshRelativeLocation = GetMesh()->GetRelativeLocation();

    InitPushbox();

    GetHitboxHandler()->SetReferenceComponent( GetMesh() );

    m_InitialHP = m_HP;
}

void AFightingCharacter::EndPlay( const EEndPlayReason::Type EndPlayReason )
{
    Super::EndPlay( EndPlayReason );

    m_HitboxHandler->m_HitDelegate.Remove( m_HitDelegateHandle );
}

bool AFightingCharacter::IsFacingRight()
{
    return m_FacingRight;
}

void AFightingCharacter::SetFacingRight( bool Right, bool Instant /*= false*/ )
{
    m_TargetRotatorYaw = Right ? 90.f : -90.f;

    FRotator TargetRotation = GetActorRotation();

    if( Instant )
    {
        TargetRotation.Yaw = m_TargetRotatorYaw;

        SetActorRotation( TargetRotation );
    }
    else
    {
        if( !IsFacingRight() && Right )
        {
            TargetRotation.Yaw -= 1.f;
            SetActorRotation( TargetRotation );
        }

        if( IsFacingRight() && !Right )
        {
            TargetRotation.Yaw += 1.f;
            SetActorRotation( TargetRotation );
        }
    }
}

FVector AFightingCharacter::GetLocation()
{
    return GetActorLocation();
}

float AFightingCharacter::GetKnockbackMultiplier() const
{
    return m_KnockbackMultiplierCurve->GetFloatValue( m_DamagePercent );
}

float AFightingCharacter::GetDamagePercent() const
{
    return m_DamagePercent;
}

void AFightingCharacter::SetDamagePercent( float Percent )
{
    m_DamagePercent = FMath::Max( 0.f, Percent );
}

void AFightingCharacter::ApplyDamage( float Damage )
{
    float newHp = m_HP -= Damage;
    m_HP        = FMath::Clamp( newHp, 0.f, m_InitialHP );

    if( FMath::IsNearlyZero( m_HP ) )
    {
        m_DeathDelegate.Broadcast( this, EDeathReason::ZeroHP );
    }
}

void AFightingCharacter::SetHP( float NewHP )
{
    m_HP = FMath::Clamp( NewHP, 0.f, m_InitialHP );

    if( FMath::IsNearlyZero( m_HP ) )
    {
        m_DeathDelegate.Broadcast( this, EDeathReason::ZeroHP );
    }
}

float AFightingCharacter::GetHP() const
{
    return m_HP;
}

float AFightingCharacter::GetInitialHP() const
{
    return m_InitialHP;
}

bool AFightingCharacter::IsAirKnockbackHappening() const
{
    return m_IsAirKnockbackHappening;
}

void AFightingCharacter::SetAirKnockbackHappening( bool Value )
{
    m_IsAirKnockbackHappening = Value;
}

void AFightingCharacter::PushTimeDilation( float Value )
{
    m_TimeDilations.Push( Value );

    CustomTimeDilation = m_TimeDilations.Last();
}

void AFightingCharacter::PopTimeDilation()
{
    m_TimeDilations.Pop();
    ensureMsgf( m_TimeDilations.Num() > 0, TEXT( "Time dilations stack cannot be empty" ) );

    CustomTimeDilation = m_TimeDilations.Last();
}

void AFightingCharacter::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );

    if( loc_DebugDamageStats )
    {
        FG_TEXT( GetWorld(), GetActorLocation(),
                 FString::Printf( TEXT( "[%%: %.1f][KMul: %.2f]" ), m_DamagePercent, GetKnockbackMultiplier() ) );
    }

    m_FacingRight = m_TargetRotatorYaw > 0.f && m_TargetRotatorYaw < 180.f;
    UpdateYaw( DeltaTime );

    if( loc_DebugFacing )
    {
        FG_TEXT( GetWorld(), GetActorLocation(),
                 FString::Printf( TEXT( "[Facing Right: %s]" ), m_FacingRight ? TEXT( "TRUE" ) : TEXT( "FALSE" ) ) );
    }

    if( loc_DebugHP )
    {
        ImGui::Begin( "Character HP" );
        {
            ImGui::Text( "HP" );
            ImGui::ProgressBar( GetHP() / GetInitialHP() );
        }
        ImGui::End();
    }

    CheckGroundedEvent();
    CheckAirborneEvent();

    if( m_CanUpdateMeshShake || loc_DebugEnableShake )
    {
        UpdateMeshShake();
    }

    UpdatePushbox( DeltaTime );

    UpdateGravityScale();
    UpdateWalkingSpeed();
}

void AFightingCharacter::SetupPlayerInputComponent( UInputComponent* PlayerInputComponent )
{
    Super::SetupPlayerInputComponent( PlayerInputComponent );

    ensureMsgf( m_MovesBuffer, TEXT( "Moves buffer is null" ) );
    m_MovesBuffer->OnSetupPlayerInputComponent( PlayerInputComponent );
}

void AFightingCharacter::OnHitReceived( const HitData& HitData )
{
    if( m_IsCountering )
    {
        if( IsGrounded() )
        {
            m_StateMachine->SetState( m_GroundCounterStateName );
            return;
        }
    }

    if( !m_Hittable )
    {
        return;
    }

    if( HitData.m_ForceOpponentFacing && !m_HasSuperArmor )
    {
        UCombatStatics::FaceOther( this, HitData.m_Owner, true );
    }

    if( HitData.m_OpponentHitStopDuration > 0.f )
    {
        GetHitStopComponent()->EnableHitStop( HitData.m_OpponentHitStopDuration, HitData.m_Shake );
    }

    if( IsBlocking() && !HitData.m_IgnoreBlock )
    {
        if( IsGrounded() )
        {
            m_StateMachine->SetState( m_GroundBlockStateName );
            return;
        }
    }

    m_DamagePercent += HitData.m_DamagePercent;
    if( m_HasSuperArmor )
    {
        m_DamagePercent *= m_SuperArmorData.m_DamagePercentMultiplier;
    }

    float damageHp = HitData.m_DamageHP;
    if( m_HasSuperArmor )
    {
        damageHp *= m_SuperArmorData.m_DamageMultiplier;
    }

    ApplyDamage( damageHp );

    if( !m_HasSuperArmor )
    {
        bool ignoreKnockbackMultiplier = m_DamageIncreasesCharactersPercent ? HitData.m_IgnoreKnockbackMultiplier : true;
        UCombatStatics::ApplyKnockbackTo( HitData.m_ProcessedKnockback, HitData.m_ProcessedKnockback.Length(), this, ignoreKnockbackMultiplier );

#pragma region REACTION_HANDLING

        if( (HitData.m_KnockbackAngleDeg > 45.f && HitData.m_ProcessedKnockback.Length() >= 500.f) || IsAirborne() )
        {
            m_StateMachine->SetState( m_GroundToAirReactionStateName );
        }
        else
        {
            m_StateMachine->SetState( m_GroundedReactionStateName );
        }
    }

#pragma endregion

    if( HitData.m_HitSound )
    {
        UGameplayStatics::PlaySoundAtLocation( GetWorld(), HitData.m_HitSound, GetActorLocation() );
    }
}

bool AFightingCharacter::IsHittable()
{
    return m_Hittable;
}

bool AFightingCharacter::IsBlocking()
{
    if( !IsAutoFacingEnabled() ) return false;

    if( m_StandingStillCountsAsBlock )
    {
        return m_IsMovingBackward || FMath::IsNearlyZero( GetMovesBufferComponent()->m_InputMovement );
    }

    return m_IsMovingBackward;
}

void AFightingCharacter::EnableSuperArmor( const SuperArmorData& Data )
{
    m_SuperArmorData = Data;
    m_HasSuperArmor  = true;
}

void AFightingCharacter::DisableSuperArmor()
{
    m_HasSuperArmor = false;
}

void AFightingCharacter::SetIsCountering( bool IsCountering )
{
    m_IsCountering = IsCountering;
}

void AFightingCharacter::UpdateYaw( float DeltaTime )
{
    FRotator TargetRotator = GetActorRotation();
    TargetRotator.Yaw      = m_TargetRotatorYaw;

    FRotator UpdatedRotator;
    if( m_FacingRotationLerpMultiplier > 0.f )
    {
        UpdatedRotator = UKismetMathLibrary::RLerp( GetActorRotation(), TargetRotator, m_FacingRotationLerpMultiplier * DeltaTime, true );
    }
    else
    {
        UpdatedRotator = TargetRotator;
    }

    SetActorRotation( UpdatedRotator );
}

void AFightingCharacter::UpdateVerticalScale()
{
    FVector Scale = GetMesh()->GetRelativeScale3D();
    float YScale  = m_FacingRight ? FMath::Abs( Scale.Y ) : -FMath::Abs( Scale.Y );
    Scale.Y       = YScale;

    GetMesh()->SetRelativeScale3D( Scale );
}

void AFightingCharacter::OnHitLanded( TObjectPtr<AActor> Target, const HitData& HitData )
{
    m_HitLandedDelegate.Broadcast( Target );

    m_HasJustLandedHit = true;

    StartHitLandedTimer( m_HitLandedStateDuration >= 0.f ? m_HitLandedStateDuration : HitData.m_HitStopDuration );

    if( HitData.m_HitStopDuration > 0.f )
    {
        GetHitStopComponent()->EnableHitStop( HitData.m_HitStopDuration, false );
    }
}

void AFightingCharacter::StartHitLandedTimer( float Duration )
{
    // #TODO use hitstop duration value for this timer? maybe its cleaner and more straightforward
    if( GetWorldTimerManager().IsTimerActive( m_HitLandedStateTimerHandle ) )
    {
        GetWorldTimerManager().ClearTimer( m_HitLandedStateTimerHandle );
    }

    GetWorldTimerManager().SetTimer( m_HitLandedStateTimerHandle, this, &AFightingCharacter::OnHitLandedTimerEnded, Duration );
}

void AFightingCharacter::OnHitLandedTimerEnded()
{
    m_HasJustLandedHit = false;
}

void AFightingCharacter::CheckGroundedEvent()
{
    if( IsAirborne() )
    {
        m_GroundedDelegateBroadcast = false;
    }
    else
    {
        if( !m_GroundedDelegateBroadcast )
        {
            m_GroundedDelegateBroadcast = true;
            m_GroundedDelegate.Broadcast();
        }
    }
}

void AFightingCharacter::CheckAirborneEvent()
{
    if( !IsAirborne() )
    {
        m_AirborneDelegateBroadcast = false;
    }
    else
    {
        if( !m_AirborneDelegateBroadcast )
        {
            m_AirborneDelegateBroadcast = true;
            m_AirborneDelegate.Broadcast();
        }
    }
}

void AFightingCharacter::InitTimeDilations()
{
    m_TimeDilations.Empty();
    m_TimeDilations.Push( CustomTimeDilation );
}

void AFightingCharacter::InitPushbox()
{
    TArray<UActorComponent*> PushBoxes = GetComponentsByTag( UBoxComponent::StaticClass(), TEXT( "Pushbox" ) );
    ensure( PushBoxes.Num() <= 1 );

    if( PushBoxes.Num() > 0 )
    {
        m_Pushbox = Cast<UBoxComponent>( PushBoxes[0] );
        if( !m_Pushbox )
        {
            FG_SLOG_WARN( FString::Printf( TEXT( "Character [%s] has no Pushbox available; will overlap with other characters" ), *GetName() ) );
        }
    }
}

void AFightingCharacter::UpdatePushbox( float DeltaTime )
{
    if( m_Pushbox && IsGrounded() )
    {
        TArray<TObjectPtr<UPrimitiveComponent>> overlappingComponents;
        m_Pushbox->GetOverlappingComponents( overlappingComponents );

        for( auto component : overlappingComponents )
        {
            TObjectPtr<AActor> otherActor = component->GetOwner();

            if( TObjectPtr<IGroundSensitiveEntity> groundSensitiveEntity = Cast<IGroundSensitiveEntity>( otherActor ) )
            {
                if( groundSensitiveEntity->IsGrounded() )
                {
                    bool isOtherOnTheRight     = otherActor->GetActorLocation().Y > GetActorLocation().Y;
                    float myShiftingMultiplier = isOtherOnTheRight ? -1.f : 1.f;

                    if( m_UseVelocityForPushboxForce )
                    {
                        GetCharacterMovement()->Velocity += FVector( 0.f, myShiftingMultiplier * m_PushboxShiftRatePerFrame, 0.f );
                    }
                    else
                    {
                        const FVector currentLocation      = GetActorLocation();
                        const float nextHorizontalPosition = currentLocation.Y + (m_PushboxShiftRatePerFrame * myShiftingMultiplier * DeltaTime);
                        const FVector nextLocation         = FVector( currentLocation.X, nextHorizontalPosition, currentLocation.Z );

                        SetActorLocation( nextLocation );
                    }
                }
            }
        }
    }
}

void AFightingCharacter::InitWallBoxes()
{
    TArray<UActorComponent*> frontWallBoxes = GetComponentsByTag( UBoxComponent::StaticClass(), TEXT( "FrontWallbox" ) );
    ensure( frontWallBoxes.Num() <= 1 );

    if( frontWallBoxes.Num() > 0 )
    {
        m_FrontWallBox = Cast<UBoxComponent>( frontWallBoxes[0] );
        if( !m_FrontWallBox )
        {
            FG_SLOG_WARN( FString::Printf( TEXT( "Character [%s] has no Front Wallbox" ), *GetName() ) );
        }
    }

    TArray<UActorComponent*> backWallBoxes = GetComponentsByTag( UBoxComponent::StaticClass(), TEXT( "BackWallbox" ) );
    ensure( frontWallBoxes.Num() <= 1 );

    if( backWallBoxes.Num() > 0 )
    {
        m_BackWallBox = Cast<UBoxComponent>( backWallBoxes[0] );
        if( !m_BackWallBox )
        {
            FG_SLOG_WARN( FString::Printf( TEXT( "Character [%s] has no Back Wallbox" ), *GetName() ) );
        }
    }
}

void AFightingCharacter::UpdateWallBoxes()
{
}

void AFightingCharacter::UpdateGravityScale()
{
    float verticalVelocity = GetVelocity().Z;

    GetCharacterMovement()->GravityScale = verticalVelocity < 0.f ? m_FallingGravityScale : m_RegularGravityScale;
}

void AFightingCharacter::UpdateWalkingSpeed()
{
    GetCharacterMovement()->MaxWalkSpeed = m_IsMovingBackward ? m_BackwardWalkingSpeed : m_ForwardWalkingSpeed;
}

void AFightingCharacter::UpdateMeshShake()
{
    float ElapsedTime = UGameplayStatics::GetRealTimeSeconds( GetWorld() );
    float DeltaShake  = FMath::Sin( ElapsedTime * m_MeshShakeFrequency ) * m_MeshShakeAmplitude;

    FVector CurrentPosition = GetMesh()->GetRelativeLocation();
    CurrentPosition.X += DeltaShake;

    if( IsAirborne() )
    {
        CurrentPosition.Z += DeltaShake;
    }

    GetMesh()->SetRelativeLocation( CurrentPosition, false, nullptr, ETeleportType::TeleportPhysics );
}

void AFightingCharacter::ResetMeshRelativeLocation()
{
    GetMesh()->SetRelativeLocation( m_InitialMeshRelativeLocation );
}

bool AFightingCharacter::IsAutoFacingEnabled()
{
    return m_OpponentToFace != nullptr;
}

```

`Source/FightingGame/Character/FightingCharacter.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "FightingGame/Combat/CounterEntity.h"
#include "FightingGame/Combat/FacingEntity.h"
#include "FightingGame/Combat/GroundSensitiveEntity.h"
#include "FightingGame/Combat/Hittable.h"
#include "FightingGame/Combat/SuperArmorData.h"
#include "GameFramework/Character.h"
#include "FightingCharacter.generated.h"

class UStateMachineComponent;
class UProjectileSpawnerComponent;
class UBoxComponent;
class UHitStopComponent;
class UFSM;
class UMovesBufferComponent;
class UHitboxHandlerComponent;

UENUM( BlueprintType )
enum class EDeathReason : uint8
{
    ZeroHP,

    COUNT UMETA( Hidden ),
    INVALID UMETA( Hidden ),
};

DECLARE_MULTICAST_DELEGATE( FFacingChanged )
DECLARE_MULTICAST_DELEGATE_OneParam( FHitLanded, AActor* )
DECLARE_MULTICAST_DELEGATE( FGrounded )
DECLARE_MULTICAST_DELEGATE( FAirborne )
DECLARE_MULTICAST_DELEGATE_TwoParams( FDeath, TObjectPtr<AFightingCharacter>, EDeathReason )

UCLASS()
class FIGHTINGGAME_API AFightingCharacter : public ACharacter,
                                            public IHittable, public IFacingEntity, public IGroundSensitiveEntity, public ICounterEntity
{
    GENERATED_BODY()

public:
    AFightingCharacter();

    FFacingChanged m_FacingChangedDelegate;
    FHitLanded m_HitLandedDelegate;
    FGrounded m_GroundedDelegate;
    FAirborne m_AirborneDelegate;
    FDeath m_DeathDelegate;
    int32 m_PlayerIndex                     = 0;
    bool m_DamageIncreasesCharactersPercent = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Current Horizontal Movement" )
    float m_CurrentHorizontalMovement = 0.f;

    UPROPERTY( BlueprintReadOnly, DisplayName = "Is Reacting" )
    bool m_IsReacting = false;

    UPROPERTY( BlueprintReadOnly, DisplayName = "Pretend is Grounded" )
    bool m_PretendIsGrounded = false;

    UPROPERTY( BlueprintReadOnly, DisplayName = "Is Moving Backward" )
    bool m_IsMovingBackward = false;

    UFUNCTION( BlueprintCallable )
    virtual bool IsAirborne() const override;

    UFUNCTION( BlueprintCallable )
    virtual bool IsGrounded() const override;

    void UpdateHorizontalMovement( float value );
    void UpdateFacing();

    UFUNCTION( BlueprintCallable )
    virtual bool IsFacingRight() override;

    UFUNCTION( BlueprintCallable )
    virtual void SetFacingRight( bool Right, bool Instant ) override;

    virtual FVector GetLocation() override;

    UFUNCTION( BlueprintCallable )
    UHitboxHandlerComponent* GetHitboxHandler() const { return m_HitboxHandler; }

    float GetKnockbackMultiplier() const;
    float GetDamagePercent() const;
    void SetDamagePercent( float Percent );

    void ApplyDamage( float Damage );
    void SetHP( float NewHP );
    float GetHP() const;
    float GetInitialHP() const;

    UFUNCTION( BlueprintCallable )
    bool IsAirKnockbackHappening() const;

    UFUNCTION( BlueprintCallable )
    void SetAirKnockbackHappening( bool Value );

    void PushTimeDilation( float Value );
    void PopTimeDilation();

    virtual void Tick( float DeltaTime ) override;
    virtual void SetupPlayerInputComponent( class UInputComponent* PlayerInputComponent ) override;

    virtual void OnHitReceived( const HitData& HitData ) override;
    virtual bool IsHittable() override;
    virtual bool IsBlocking() override;
    virtual void EnableSuperArmor( const SuperArmorData& Data ) override;
    virtual void DisableSuperArmor() override;

    virtual void SetIsCountering( bool IsCountering ) override;

    FORCEINLINE TObjectPtr<UMovesBufferComponent> GetMovesBufferComponent() const { return m_MovesBuffer; }
    FORCEINLINE TObjectPtr<UStateMachineComponent> GetFSM() const { return m_StateMachine; }
    FORCEINLINE TObjectPtr<UHitStopComponent> GetHitStopComponent() const { return m_HitStopComponent; }
    FORCEINLINE TObjectPtr<UProjectileSpawnerComponent> GetProjectileSpawnerComponent() const { return m_ProjectileSpawnerComponent; }

    FORCEINLINE bool HasJustLandedHit() const { return m_HasJustLandedHit; }
    FORCEINLINE void ResetHasJustLandedHit() { m_HasJustLandedHit = false; }

    FORCEINLINE void SetHittable( bool Hittable ) { m_Hittable = Hittable; }
    FORCEINLINE bool IsHittable() const { return m_Hittable; }

    FORCEINLINE void SetOpponentToFace( TObjectPtr<AFightingCharacter> Opponent ) { m_OpponentToFace = Opponent; }
    FORCEINLINE TObjectPtr<AFightingCharacter> GetOpponentToFace() const { return m_OpponentToFace; }

    void UpdateMeshShake();
    void ResetMeshRelativeLocation();
    bool IsAutoFacingEnabled();

protected:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "State Machine" )
    TObjectPtr<UStateMachineComponent> m_StateMachine = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Moves Buffer" )
    TObjectPtr<UMovesBufferComponent> m_MovesBuffer = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hitbox Handler" )
    TObjectPtr<UHitboxHandlerComponent> m_HitboxHandler = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Knockback Multiplier Curve" )
    TObjectPtr<UCurveFloat> m_KnockbackMultiplierCurve = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hit Stop Component" )
    TObjectPtr<UHitStopComponent> m_HitStopComponent = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Projectile Spawner Component" )
    TObjectPtr<UProjectileSpawnerComponent> m_ProjectileSpawnerComponent = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "FSM First State" )
    FName m_FirstState = "IDLE";

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Update Facing When Airborne" )
    bool m_UpdateFacingWhenAirborne = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Facing Rotation Lerp Multiplier" )
    float m_FacingRotationLerpMultiplier = 1.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Grounded Reaction State Name" )
    FName m_GroundedReactionStateName = "REACTION_LIGHT_GROUNDED";

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Ground To Air Reaction State Name" )
    FName m_GroundToAirReactionStateName = "REACTION_LIGHT_AIRBORNE";

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Ground Block State Name" )
    FName m_GroundBlockStateName = "GROUND_BLOCK";

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Ground Counter State Name" )
    FName m_GroundCounterStateName = "GROUND_COUNTER";

    /*
     * If value is < 0 then the hit data hitstop duration will be used
     */
    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hit Landed State Duration" )
    float m_HitLandedStateDuration = .2f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hit Stun Time Dilation" )
    float m_HitStunTimeDilation = .001f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Mesh Shake Frequency" )
    float m_MeshShakeFrequency = 2.5f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Mesh Shake Amplitude" )
    float m_MeshShakeAmplitude = 60.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Push Box" )
    TObjectPtr<UBoxComponent> m_Pushbox = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Wall Box (Back)" )
    TObjectPtr<UBoxComponent> m_BackWallBox = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Wall Box (Front)" )
    TObjectPtr<UBoxComponent> m_FrontWallBox = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Push Box Shift Rate (Per Frame)" )
    float m_PushboxShiftRatePerFrame = 0.1f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Use Velocity for Pushbox Force" )
    bool m_UseVelocityForPushboxForce = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Gravity Scale (Regular)" )
    float m_RegularGravityScale = 1.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Gravity Scale (Falling)" )
    float m_FallingGravityScale = 2.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Auto-face Opponent" )
    bool m_AutoFaceOpponent = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Forward Walking Speed" )
    float m_ForwardWalkingSpeed = 600.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Backward Walking Speed" )
    float m_BackwardWalkingSpeed = 400.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Standing Still Counts As Block" )
    bool m_StandingStillCountsAsBlock = false;

    UPROPERTY()
    TObjectPtr<AFightingCharacter> m_OpponentToFace = nullptr;

    bool m_IsCountering = false;

    virtual void BeginPlay() override;
    virtual void EndPlay( const EEndPlayReason::Type EndPlayReason ) override;

private:
    bool m_FacingRight               = true;
    float m_TargetRotatorYaw         = 90.f;
    float m_DamagePercent            = 0.f;
    float m_HP                       = 100.f;
    float m_InitialHP                = -1.f;
    bool m_IsAirKnockbackHappening   = false;
    bool m_GroundedDelegateBroadcast = false;
    bool m_AirborneDelegateBroadcast = false;
    bool m_HasJustLandedHit          = false;
    FTimerHandle m_HitLandedStateTimerHandle;
    bool m_Hittable               = true;
    bool m_HasSuperArmor          = false;
    float m_CachedHitStopDuration = 0.f;
    bool m_CachedDoMeshShake      = false;
    bool m_CachedConsiderShake    = false;
    TArray<float> m_TimeDilations;
    bool m_CanUpdateMeshShake = false;
    FVector m_InitialMeshRelativeLocation;
    SuperArmorData m_SuperArmorData;

    FDelegateHandle m_HitDelegateHandle;
    FDelegateHandle m_DeathDelegateHandle;

    void UpdateYaw( float DeltaTime );
    void UpdateVerticalScale();

    void OnHitLanded( TObjectPtr<AActor> Target, const HitData& HitData );
    void StartHitLandedTimer( float Duration );
    void OnHitLandedTimerEnded();

    void CheckGroundedEvent();
    void CheckAirborneEvent();

    void InitTimeDilations();
    void InitPushbox();
    void UpdatePushbox( float DeltaTime );
    void InitWallBoxes();
    void UpdateWallBoxes();

    void UpdateGravityScale();
    void UpdateWalkingSpeed();
};

```

`Source/FightingGame/Collision/CustomCollisionChannels.h`:

```h
#pragma once

#define CUSTOM_TRACE_HURTBOX ECC_GameTraceChannel1

// #TODO check if this channel (in the engine config) is the correct one
#define CUSTOM_TRACE_HITBOX ECC_GameTraceChannel2

```

`Source/FightingGame/Combat/CameraShakeNotify.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "CameraShakeNotify.h"

#include "Kismet/GameplayStatics.h"

void UCameraShakeNotify::Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
	Super::Notify( MeshComp, Animation, EventReference );

	if( auto* PC = UGameplayStatics::GetPlayerController( MeshComp->GetWorld(), 0 ) )
	{
		PC->PlayerCameraManager->StartCameraShake( m_Shake );
	}
}

```

`Source/FightingGame/Combat/CameraShakeNotify.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "CameraShakeNotify.generated.h"

UCLASS()
class FIGHTINGGAME_API UCameraShakeNotify : public UAnimNotify
{
	GENERATED_BODY()

public:
	virtual void Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Shake" )
	TSubclassOf<UCameraShakeBase> m_Shake = nullptr;
};

```

`Source/FightingGame/Combat/CombatManager.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "CombatManager.h"

ACombatManager::ACombatManager()
{
	PrimaryActorTick.bCanEverTick = true;
}

void ACombatManager::BeginPlay()
{
	Super::BeginPlay();
}

void ACombatManager::Tick( float DeltaTime )
{
	Super::Tick( DeltaTime );
}

```

`Source/FightingGame/Combat/CombatManager.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingGame/Common/Manager.h"
#include "GameFramework/Actor.h"
#include "CombatManager.generated.h"

UCLASS()
class FIGHTINGGAME_API ACombatManager : public AManager
{
	GENERATED_BODY()

public:
	ACombatManager();

	FORCEINLINE float GetHitStopStartDelay() const { return m_HitStopStartDelay; }
	FORCEINLINE float GetHitStopTimeDilation() const { return m_HitStopTimeDilation; }

protected:
	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hit Stop Start Delay" )
	float m_HitStopStartDelay = 0.f;

	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hit Stop Time Dilation" )
	float m_HitStopTimeDilation = 0.001f;

	virtual void BeginPlay() override;

public:
	virtual void Tick( float DeltaTime ) override;
};

```

`Source/FightingGame/Combat/CounterEntity.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "CounterEntity.h"


void ICounterEntity::SetIsCountering( bool IsCountering )
{
}

```

`Source/FightingGame/Combat/CounterEntity.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "CounterEntity.generated.h"

// This class does not need to be modified.
UINTERFACE()
class UCounterEntity : public UInterface
{
    GENERATED_BODY()
};

class FIGHTINGGAME_API ICounterEntity
{
    GENERATED_BODY()

public:
    virtual void SetIsCountering( bool IsCountering );
};

```

`Source/FightingGame/Combat/CounterNotifyState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "CounterNotifyState.h"

#include "CounterEntity.h"

void UCounterNotifyState::NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                                       const FAnimNotifyEventReference& EventReference )
{
    Super::NotifyBegin( MeshComp, Animation, TotalDuration, EventReference );

    if( TObjectPtr<ICounterEntity> counterEntity = Cast<ICounterEntity>( MeshComp->GetOwner() ) )
    {
        counterEntity->SetIsCountering( true );
    }
}

void UCounterNotifyState::NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
    Super::NotifyEnd( MeshComp, Animation, EventReference );

    if( TObjectPtr<ICounterEntity> counterEntity = Cast<ICounterEntity>( MeshComp->GetOwner() ) )
    {
        counterEntity->SetIsCountering( false );
    }
}

```

`Source/FightingGame/Combat/CounterNotifyState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotifyState.h"
#include "UObject/Object.h"
#include "CounterNotifyState.generated.h"

UCLASS()
class FIGHTINGGAME_API UCounterNotifyState : public UAnimNotifyState
{
    GENERATED_BODY()

public:
    virtual void NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                              const FAnimNotifyEventReference& EventReference ) override;
    virtual void NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;
};

```

`Source/FightingGame/Combat/FacingEntity.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "FacingEntity.h"

bool IFacingEntity::IsFacingRight()
{
	return true;
}

void IFacingEntity::SetFacingRight( bool Right, bool Instant )
{
}

FVector IFacingEntity::GetLocation()
{
	return FVector::ZeroVector;
}

```

`Source/FightingGame/Combat/FacingEntity.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "FacingEntity.generated.h"

// This class does not need to be modified.
UINTERFACE()
class UFacingEntity : public UInterface
{
	GENERATED_BODY()
};

class FIGHTINGGAME_API IFacingEntity
{
	GENERATED_BODY()

public:
	virtual bool IsFacingRight();
	virtual void SetFacingRight( bool Right, bool Instant );

	// #TODO return TOptional<FVector> ?
	virtual FVector GetLocation();
};

```

`Source/FightingGame/Combat/GroundSensitiveEntity.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "GroundSensitiveEntity.h"

bool IGroundSensitiveEntity::IsGrounded() const
{
	return true;
}

bool IGroundSensitiveEntity::IsAirborne() const
{
	return false;
}

```

`Source/FightingGame/Combat/GroundSensitiveEntity.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "GroundSensitiveEntity.generated.h"

UINTERFACE()
class UGroundSensitiveEntity : public UInterface
{
	GENERATED_BODY()
};

class FIGHTINGGAME_API IGroundSensitiveEntity
{
	GENERATED_BODY()

public:
	virtual bool IsGrounded() const;
	virtual bool IsAirborne() const;
};

```

`Source/FightingGame/Combat/HitData.cpp`:

```cpp
#include "HitData.h"

HitData::HitData( bool InForceOpponentFacing, float InDamagePercent, float InDamageHP, float InRadius, const FVector& InProcessedKnockback,
                  float InKnockbackAngleDeg, bool InIgnoreKnockbackMultiplier,
                  float InHitStopDuration, float InOpponentHitStopDuration, bool InShake, UWorld* InWorld, AActor* InOwner, USkeletalMeshComponent* InSkeletalMesh,
                  const FName& InSocketToFollow, FVector InLocation, uint32 InId, int32 InGroupId,
                  int32 InPriority, bool InIsCounter, bool InIgnoreBlock, const TArray<TObjectPtr<AActor>>& InAdditionalActorsToIgnore,
                  TObjectPtr<USoundBase> InHitSound, bool InCanClang, int32 InClangPriority, bool InAllowOnGroundedOpponents, bool InAllowOnAirborneOpponents )
    : m_ForceOpponentFacing( InForceOpponentFacing ),
      m_DamagePercent( InDamagePercent ),
      m_DamageHP( InDamageHP ),
      m_Radius( InRadius ),
      m_ProcessedKnockback( InProcessedKnockback ),
      m_KnockbackAngleDeg( InKnockbackAngleDeg ),
      m_IgnoreKnockbackMultiplier( InIgnoreKnockbackMultiplier ),
      m_HitStopDuration( InHitStopDuration ),
      m_OpponentHitStopDuration( InOpponentHitStopDuration ),
      m_Shake( InShake ),
      m_World( InWorld ),
      m_Owner( InOwner ),
      m_SkeletalMesh( InSkeletalMesh ),
      m_SocketToFollow( InSocketToFollow ),
      m_Location( InLocation ),
      m_Id( InId ),
      m_GroupId( InGroupId ),
      m_Priority( InPriority ),
      m_IsCounter( InIsCounter ),
      m_IgnoreBlock( InIgnoreBlock ),
      m_AdditionalActorsToIgnore( InAdditionalActorsToIgnore ),
      m_HitSound( InHitSound ),
      m_CanClang( InCanClang ),
      m_ClangPriority( InClangPriority ),
      m_AllowOnGroundedOpponents( InAllowOnGroundedOpponents ),
      m_AllowOnAirborneOpponents( InAllowOnAirborneOpponents ),
      m_PendingRemoval( false )
{
}

bool operator==( const HitData& Lhs, const HitData& RHS )
{
    return Lhs.m_Id == RHS.m_Id;
}

bool operator!=( const HitData& Lhs, const HitData& RHS )
{
    return !(Lhs == RHS);
}

```

`Source/FightingGame/Combat/HitData.h`:

```h
#pragma once

// #TODO this should become a USTRUCT i think
struct HitData
{
    bool m_ForceOpponentFacing;
    float m_DamagePercent;
    float m_DamageHP;
    float m_Radius;
    FVector m_ProcessedKnockback;
    float m_KnockbackAngleDeg;
    bool m_IgnoreKnockbackMultiplier;
    float m_HitStopDuration;
    float m_OpponentHitStopDuration;
    bool m_Shake;
    UWorld* m_World;
    AActor* m_Owner;
    USkeletalMeshComponent* m_SkeletalMesh;
    FName m_SocketToFollow;
    FVector m_Location;
    uint32 m_Id;
    int32 m_GroupId;
    int32 m_Priority;
    bool m_IsCounter;
    bool m_IgnoreBlock;
    TArray<TObjectPtr<AActor>> m_AdditionalActorsToIgnore;
    TObjectPtr<USoundBase> m_HitSound;
    bool m_CanClang;
    int32 m_ClangPriority;
    bool m_AllowOnGroundedOpponents;
    bool m_AllowOnAirborneOpponents;

    bool m_PendingRemoval;

    explicit HitData( bool InForceOpponentFacing, float InDamagePercent, float InDamageHP, float InRadius, const FVector& InProcessedKnockback,
                      float InKnockbackAngleDeg, bool InIgnoreKnockbackMultiplier,
                      float InHitStopDuration, float InOpponentHitStopDuration, bool InShake, UWorld* InWorld, AActor* InOwner, USkeletalMeshComponent* InSkeletalMesh,
                      const FName& InSocketToFollow, FVector InLocation, uint32 InId, int32 InGroupId,
                      int32 InPriority, bool InIsCounter, bool InIgnoreBlock, const TArray<TObjectPtr<AActor>>& InAdditionalActorsToIgnore,
                      TObjectPtr<USoundBase> InHitSound, bool InCanClang, int32 InClangPriority, bool InAllowOnGroundedOpponents, bool InAllowOnAirborneOpponents );

    void GetActorsToIgnore( TArray<TObjectPtr<AActor>>& OutActors ) const
    {
        OutActors.Reset();

        OutActors.Emplace( m_Owner );
        for( int32 i = 0; i < m_AdditionalActorsToIgnore.Num(); ++i )
        {
            OutActors.Emplace( m_AdditionalActorsToIgnore[i] );
        }
    }

    friend bool operator==( const HitData& Lhs, const HitData& RHS );
    friend bool operator!=( const HitData& Lhs, const HitData& RHS );
};

```

`Source/FightingGame/Combat/HitStopComponent.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "HitStopComponent.h"

#include "CombatManager.h"
#include "FightingGame/FightingGameGameModeBase.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Debugging/Debug.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetSystemLibrary.h"

namespace
{
	int32 loc_ShowHitStopState = 0;
	FG_CVAR_FLAG_DESC( CVarShowHitStopState, TEXT( "HitStopComponent.ShowHitStopState" ), loc_ShowHitStopState );
}

UHitStopComponent::UHitStopComponent()
{
	PrimaryComponentTick.bCanEverTick = true;
}

void UHitStopComponent::BeginPlay()
{
	Super::BeginPlay();

	m_Character = Cast<AFightingCharacter>( GetOwner() );
	if( !m_Character )
	{
		FG_SLOG_ERR( TEXT("Cast to AFightingCharacter failed.") );
	}
}

void UHitStopComponent::EnableHitStop( float Duration, bool Shake )
{
	StartBeginHitStopTimer( Duration, Shake );
}

void UHitStopComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )
{
	Super::TickComponent( DeltaTime, TickType, ThisTickFunction );

	if( m_UpdateMeshShake )
	{
		m_Character->UpdateMeshShake();
	}

	if( loc_ShowHitStopState )
	{
		FG_TEXT( GetWorld(), GetOwner()->GetActorLocation(),
		                                       FString::Printf( TEXT( "[Hit Stop: %s]" ), m_HitStopRunning ? TEXT( "TRUE" ) : TEXT( "FALSE" ) ) );
	}
}

void UHitStopComponent::StartBeginHitStopTimer( float Duration, bool Shake )
{
	FTimerManager& TimerManager = GetOwner()->GetWorldTimerManager();

	if( TimerManager.IsTimerActive( m_HitStopBeginTimerHandle ) )
	{
		TimerManager.ClearTimer( m_HitStopBeginTimerHandle );
	}

	m_CachedHitStopDuration = Duration;
	m_CachedDoMeshShake     = Shake;

	// #TODO instead of using GetHitStunInitialDelay, interpolate directly to the next reaction animation to ensure the correcto pose is always visible
	float hitStopInitialDelay = UCombatStatics::GetHitStopInitialDelay();
	if( hitStopInitialDelay > 0.f )
	{
		TimerManager.SetTimer( m_HitStopBeginTimerHandle, this, &UHitStopComponent::OnHitStopBeginTimerEnded, hitStopInitialDelay );
	}
	else
	{
		OnHitStopBeginTimerEnded();
	}
}

void UHitStopComponent::OnHitStopBeginTimerEnded()
{
	StartStopHitStopTimer();

	if( m_CachedDoMeshShake )
	{
		m_UpdateMeshShake = true;
	}
}

void UHitStopComponent::StartStopHitStopTimer()
{
	FTimerManager& TimerManager = GetOwner()->GetWorldTimerManager();

	if( TimerManager.IsTimerActive( m_HitStopStopTimerHandle ) )
	{
		TimerManager.ClearTimer( m_HitStopStopTimerHandle );
		m_Character->PopTimeDilation();
	}

	m_HitStopRunning = true;

	// #TODO pass shake from hitdata

	m_Character->PushTimeDilation( UCombatStatics::GetHitStopTimeDilation() );
	TimerManager.SetTimer( m_HitStopStopTimerHandle, this, &UHitStopComponent::OnHitStopStopTimerEnded, m_CachedHitStopDuration );
}

void UHitStopComponent::OnHitStopStopTimerEnded()
{
	m_Character->PopTimeDilation();
	m_UpdateMeshShake = false;

	m_Character->ResetMeshRelativeLocation();

	m_HitStopRunning = false;
}

```

`Source/FightingGame/Combat/HitStopComponent.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "HitStopComponent.generated.h"

class ACombatManager;
class AFightingCharacter;
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class FIGHTINGGAME_API UHitStopComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UHitStopComponent();

protected:
    virtual void BeginPlay() override;

public:
    void EnableHitStop( float Duration, bool Shake );

    virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;

private:
    FTimerHandle m_HitStopStopTimerHandle;
    FTimerHandle m_HitStopBeginTimerHandle;

    float m_CachedHitStopDuration = 0.f;
    bool m_CachedDoMeshShake      = false;
    bool m_UpdateMeshShake        = false;

    bool m_HitStopRunning = false;

    UPROPERTY()
    TObjectPtr<AFightingCharacter> m_Character = nullptr;

    void StartBeginHitStopTimer( float Duration, bool Shake );
    void OnHitStopBeginTimerEnded();

    void StartStopHitStopTimer();
    void OnHitStopStopTimerEnded();
};

```

`Source/FightingGame/Combat/HitboxDescription.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "HitboxDescription.h"

```

`Source/FightingGame/Combat/HitboxDescription.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "HitboxDescription.generated.h"

USTRUCT( BlueprintType )
struct FHitboxDescription
{
    GENERATED_BODY()

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Socket Name (Regular)" )
    FName m_SocketName;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Socket Name (Mirrored)" )
    FName m_SocketNameMirrored;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Is Counter" )
    bool m_IsCounter = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Ignore Block" )
    bool m_IgnoreBlock = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Use Location (Instead of sockets)" )
    bool m_UseLocation = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Location (Relative to the owner)",
        meta = (EditCondition = "m_UseLocation", EditConditionHides = "m_UseLocation") )
    FVector m_Location = FVector::ZeroVector;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Priority" )
    int32 m_Priority = 0;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Force Opponent Facing" )
    bool m_ForceOpponentFacing = true;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Damage Percent" )
    float m_DamagePercent = 0.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Damage HP" )
    float m_DamageHP = 0.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Radius" )
    float m_Radius = 10.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Knockback Orientation (Degrees)" )
    float m_KnockbackOrientation = 0.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Knockback Force" )
    float m_KnockbackForce = 600.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Ignore Knockback Multiplier" )
    bool m_IgnoreKnockbackMultiplier = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Allow On Grounded Opponents" )
    bool m_AllowOnGroundedOpponents = true;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Allow On Airborne Opponents" )
    bool m_AllowOnAirborneOpponents = true;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hit Stop Duration (Owner)" )
    float m_HitStopDuration = 0.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Use Separate Hit Stop Values" )
    bool m_UseSeparateHitStopValues = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hit Stop Duration (Opponent)", meta=(EditCondition = "m_UseSeparateHitStopValues",
        EditConditionHides = "m_UseSeparateHitStopValues") )
    float m_OpponentHitStopDuration = 0.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Shake" )
    bool m_Shake = true;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hit Sound" )
    TObjectPtr<USoundBase> m_HitSound = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Can Clang" )
    bool m_CanClang = true;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Clang Priority", meta=(EditCondition = "m_CanClang", EditConditionHides = "m_CanClang") )
    int32 m_ClangPriority = 0;
};

```

`Source/FightingGame/Combat/HitboxDescriptionDataAsset.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "HitboxDescriptionDataAsset.h"

```

`Source/FightingGame/Combat/HitboxDescriptionDataAsset.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "HitboxDescription.h"
#include "HitboxDescriptionDataAsset.generated.h"

UCLASS()
class FIGHTINGGAME_API UHitboxDescriptionDataAsset : public UDataAsset
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hitbox Description" )
    FHitboxDescription m_HitboxDescription;
};

```

`Source/FightingGame/Combat/HitboxHandlerComponent.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "HitboxHandlerComponent.h"

#include "GroundSensitiveEntity.h"
#include "HitboxDescriptionDataAsset.h"
#include "Hittable.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Debugging/Debug.h"
#include "FightingGame/Debugging/HitboxVisualizer.h"
#include "FightingGame/Debugging/SphereVisualizer.h"
#include "Kismet/KismetSystemLibrary.h"

namespace
{
    int32 loc_ShowHitboxTraces = 0;
    FG_CVAR_FLAG_DESC( CVarShowHitboxTraces, TEXT( "HitboxHandlerComponent.ShowHitboxTraces" ), loc_ShowHitboxTraces );
}

UHitboxHandlerComponent::UHitboxHandlerComponent()
{
    PrimaryComponentTick.bCanEverTick = true;
}

void UHitboxHandlerComponent::BeginPlay()
{
    Super::BeginPlay();

    if( m_SpawnDefaultHitboxesOnBeginPlay )
    {
        SpawnDefaultHitboxes();
    }

    if( !m_HitboxVisualizer )
    {
        FG_SLOG_WARN( FString::Printf( TEXT( "HitboxVisualizer is null, hiboxes will not be shown for actor [%s]" ), *GetOwner()->GetName()) );
    }
}

void UHitboxHandlerComponent::EndPlay( const EEndPlayReason::Type EndPlayReason )
{
    Super::EndPlay( EndPlayReason );

    for( const auto& tuple : m_ActiveGroupedHitboxes )
    {
        for( const auto& hit : tuple.Value )
        {
            DEBUG_DestroyDebugSphere( hit.m_Id );
        }
    }
}

void UHitboxHandlerComponent::SetReferenceComponent( TObjectPtr<USceneComponent> Component )
{
    m_ReferenceComponent = Component;
}

void UHitboxHandlerComponent::AddHitbox( HitData Hit )
{
    if( m_ActiveGroupedHitboxes.Contains( Hit.m_GroupId ) )
    {
        m_ActiveGroupedHitboxes[Hit.m_GroupId].AddUnique( Hit );

        // #TODO temp, this is expensive
        m_ActiveGroupedHitboxes[Hit.m_GroupId].Sort( []( const HitData& A, const HitData& B )
        {
            return A.m_Priority < B.m_Priority;
        } );
    }
    else
    {
        m_ActiveGroupedHitboxes.Add( Hit.m_GroupId, {Hit} );
    }

    if( loc_ShowHitboxTraces && m_HitboxVisualizer )
    {
        DEBUG_SpawnDebugSphere( Hit );
    }
}

void UHitboxHandlerComponent::RemoveHitbox( uint32 HitUniqueId )
{
    for( auto& tuple : m_ActiveGroupedHitboxes )
    {
        auto* it = tuple.Value.FindByPredicate( [&HitUniqueId]( const HitData& HitData )
        {
            return HitData.m_Id == HitUniqueId;
        } );

        if( it )
        {
            it->m_PendingRemoval = true;
        }
    }
}

void UHitboxHandlerComponent::UpdateHitboxes()
{
    for( const auto& tuple : m_ActiveGroupedHitboxes )
    {
        for( int hitIdx = 0; hitIdx < tuple.Value.Num(); ++hitIdx )
        {
            const auto& hit = tuple.Value[hitIdx];
            if( !hit.m_PendingRemoval )
            {
                UpdateHitbox( hit );
            }
        }
    }
}

void UHitboxHandlerComponent::ShowDebugTraces( bool Show )
{
    m_DebugTraces = Show;
}

void UHitboxHandlerComponent::SpawnDefaultHitboxes()
{
    TArray<FHitboxDescription> aggregatedHitboxDescriptions;
    for( int i = 0; i < m_DefaultHitboxes.Num(); ++i )
    {
        aggregatedHitboxDescriptions.Emplace( m_DefaultHitboxes[i] );
    }

    for( int i = 0; i < m_DefaultHitboxesDataAssets.Num(); ++i )
    {
        if( !m_DefaultHitboxesDataAssets[i] )
        {
            FG_SLOG_ERR( "There is a null hitbox description data asset, will be skipped" );
            continue;
        }

        aggregatedHitboxDescriptions.Emplace( m_DefaultHitboxesDataAssets[i]->m_HitboxDescription );
    }

    for( int i = 0; i < aggregatedHitboxDescriptions.Num(); ++i )
    {
        AddHitbox( UCombatStatics::GenerateHitDataFromHitboxDescription( GetOwner(), nullptr, aggregatedHitboxDescriptions[i],
                                                                         i, GetOwner()->GetUniqueID(), m_AdditionalActorsToIgnore ) );
    }
}

void UHitboxHandlerComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )
{
    Super::TickComponent( DeltaTime, TickType, ThisTickFunction );

    UpdateHitboxes();

    DEBUG_UpdateDebugSpheres();

    RemovePendingHitboxes();
}

bool UHitboxHandlerComponent::TraceHitbox( const HitData& HitData, FHitResult& OutHit, ECollisionChannel CollisionChannel /*= CUSTOM_TRACE_HURTBOX*/ )
{
    TArray<TEnumAsByte<EObjectTypeQuery>> targetTraceTypes;

    const EObjectTypeQuery targetCollisionType = UEngineTypes::ConvertToObjectType( CollisionChannel );
    targetTraceTypes.Add( targetCollisionType );

    FVector location = GetHitTraceLocation( HitData );

    TArray<TObjectPtr<AActor>> actorsToIgnore;
    HitData.GetActorsToIgnore( actorsToIgnore );

    bool didHit = UKismetSystemLibrary::SphereTraceSingleForObjects( HitData.m_World, location, location, HitData.m_Radius, targetTraceTypes,
                                                                     false, actorsToIgnore, EDrawDebugTrace::None, OutHit, true );

    return didHit;
}

bool UHitboxHandlerComponent::WasActorAlreadyHit( AActor* Actor, const HitData& Hit )
{
    ensureMsgf( Actor, TEXT("Actor is null") );

    if( !m_ActorGroupsMap.Find( Actor->GetUniqueID() ) ) return false;

    return m_ActorGroupsMap[Actor->GetUniqueID()].ContainsByPredicate( [&]( const FHitGroupPair _pair )
    {
        return _pair.m_GroupId == Hit.m_GroupId;
    } );
}

void UHitboxHandlerComponent::RegisterHitActor( AActor* Actor, const HitData& Hit )
{
    ensureMsgf( Actor, TEXT("Actor is null") );

    if( m_ActorGroupsMap.Contains( Actor->GetUniqueID() ) )
    {
        m_ActorGroupsMap[Actor->GetUniqueID()].AddUnique( FHitGroupPair{Hit.m_Id, Hit.m_GroupId} );
    }
    else
    {
        TArray groupsArray = {FHitGroupPair{Hit.m_Id, Hit.m_GroupId}};
        m_ActorGroupsMap.Emplace( Actor->GetUniqueID(), groupsArray );
    }
}

void UHitboxHandlerComponent::UpdateHitbox( const HitData& HitData )
{
    // #TODO check clang

    FHitResult outHurtboxHit;
    bool didHitHurtbox = TraceHitbox( HitData, outHurtboxHit );

    TObjectPtr<AActor> hitActor = outHurtboxHit.GetActor();
    if( auto* hittable = Cast<IHittable>( hitActor ) )
    {
        if( auto* groundSensitiveEntity = Cast<IGroundSensitiveEntity>( hitActor ) )
        {
            bool groundedCheckFailed = HitData.m_AllowOnGroundedOpponents && !groundSensitiveEntity->IsGrounded();
            bool airborneCheckFailed = HitData.m_AllowOnAirborneOpponents && !groundSensitiveEntity->IsAirborne();

            if( groundedCheckFailed && airborneCheckFailed )
            {
                return;
            }
        }

        if( hittable->IsHittable() )
        {
            if( didHitHurtbox && !WasActorAlreadyHit( hitActor, HitData ) )
            {
                RegisterHitActor( hitActor, HitData );

                hittable->OnHitReceived( HitData );
                m_HitDelegate.Broadcast( hitActor, HitData );

                if( TObjectPtr<AHitboxVisualizer> visualizer = DEBUG_GetHitboxVisualizerOrDefault( HitData.m_Id ) )
                {
                    if( hittable->IsBlocking() )
                    {
                        if( HitData.m_IgnoreBlock )
                        {
                            visualizer->SetHitState();
                        }
                        else
                        {
                            visualizer->SetBlockedState();
                        }
                    }
                    else
                    {
                        visualizer->SetHitState();
                    }
                }
            }
        }
    }
}

void UHitboxHandlerComponent::RemovePendingHitboxes()
{
    for( auto& tuple : m_ActiveGroupedHitboxes )
    {
        for( int i = tuple.Value.Num() - 1; i >= 0; --i )
        {
            if( tuple.Value[i].m_PendingRemoval )
            {
                TArray<uint32> targetKeys;
                for( const auto& pair : m_ActorGroupsMap )
                {
                    if( pair.Value.ContainsByPredicate( [&]( const FHitGroupPair& hitPair )
                    {
                        return hitPair.m_Id == tuple.Value[i].m_Id;
                    } ) )
                    {
                        targetKeys.Emplace( pair.Key );
                    }
                }

                for( int keyIdx = 0; keyIdx < targetKeys.Num(); ++keyIdx )
                {
                    uint32 targetKey = targetKeys[keyIdx];

                    for( int j = m_ActorGroupsMap[targetKey].Num() - 1; j >= 0; --j )
                    {
                        if( m_ActorGroupsMap[targetKey][j].m_Id == tuple.Value[i].m_Id )
                        {
                            m_ActorGroupsMap[targetKey].RemoveAt( j );
                        }
                    }
                }

                DEBUG_DestroyDebugSphere( tuple.Value[i].m_Id );

                tuple.Value.RemoveAt( i );
            }
        }
    }
}

FVector UHitboxHandlerComponent::GetHitTraceLocation( const HitData& Hit )
{
    bool hasSocketToFollow = Hit.m_SkeletalMesh ? (!Hit.m_SocketToFollow.ToString().IsEmpty()) : false;

    if( hasSocketToFollow )
    {
        FVector socketLocation = Hit.m_SkeletalMesh->GetSocketLocation( Hit.m_SocketToFollow );
        socketLocation.X       = Hit.m_Owner->GetActorLocation().X;

        return socketLocation;
    }

    return Hit.m_Owner->GetActorLocation() + Hit.m_Location;
}

void UHitboxHandlerComponent::DEBUG_SpawnDebugSphere( const HitData& Hit )
{
    if( m_HitboxVisualizer )
    {
        TObjectPtr<AHitboxVisualizer> inst = Hit.m_World->SpawnActor<AHitboxVisualizer>( m_HitboxVisualizer );

        inst->SetId( Hit.m_Id );
        inst->SetRadius( Hit.m_Radius );
        inst->SetVisualizerOwner( Hit.m_Owner );
        inst->SetKnockback( Hit.m_ProcessedKnockback );

        if( Hit.m_SkeletalMesh )
        {
            if( m_ReferenceComponent )
            {
                inst->AttachToComponent( m_ReferenceComponent, FAttachmentTransformRules::SnapToTargetNotIncludingScale, Hit.m_SocketToFollow );
            }
        }
        else
        {
            inst->SetLocation( Hit.m_Location );
        }

        m_HitboxVisualizers.Emplace( inst );
    }
}

TObjectPtr<AHitboxVisualizer> UHitboxHandlerComponent::DEBUG_GetHitboxVisualizerOrDefault( int HitboxId )
{
    auto* it = m_HitboxVisualizers.FindByPredicate( [&HitboxId]( TObjectPtr<AHitboxVisualizer> _vis )
    {
        return _vis->GetId() == HitboxId;
    } );

    return it ? *it : nullptr;
}

void UHitboxHandlerComponent::DEBUG_DestroyDebugSphere( int HitboxId )
{
    for( int visIdx = m_HitboxVisualizers.Num() - 1; visIdx >= 0; --visIdx )
    {
        if( HitboxId == m_HitboxVisualizers[visIdx]->GetId() )
        {
            GetWorld()->DestroyActor( m_HitboxVisualizers[visIdx] );
            m_HitboxVisualizers.RemoveAt( visIdx );
        }
    }
}

void UHitboxHandlerComponent::DEBUG_UpdateDebugSpheres()
{
    for( TObjectPtr<ASphereVisualizer> visualizer : m_HitboxVisualizers )
    {
        if( visualizer->GetLocation().IsSet() && visualizer->GetVisualizerOwner() )
        {
            visualizer->SetActorLocation( visualizer->GetVisualizerOwner()->GetActorLocation() + visualizer->GetLocation().GetValue() );
        }
    }
}

```

`Source/FightingGame/Combat/HitboxHandlerComponent.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "HitboxDescription.h"
#include "Components/ActorComponent.h"
#include "FightingGame/Collision/CustomCollisionChannels.h"
#include "FightingGame/Combat/HitData.h"
#include "HitboxHandlerComponent.generated.h"

class UHitboxDescriptionDataAsset;
class AHitboxVisualizer;
struct FHitboxDescription;

DECLARE_MULTICAST_DELEGATE_TwoParams( FHit, TObjectPtr<AActor>, const HitData& )

struct FHitGroupPair
{
    uint32 m_Id   = -1;
    int m_GroupId = -1;

    friend bool operator==( const FHitGroupPair& Lhs, const FHitGroupPair& Rhs )
    {
        return Lhs.m_Id == Rhs.m_Id && Lhs.m_GroupId == Rhs.m_GroupId;
    }

    friend bool operator!=( const FHitGroupPair& Lhs, const FHitGroupPair& Rhs )
    {
        return !(Lhs == Rhs);
    }
};

UCLASS( ClassGroup = ( Custom ), meta = ( BlueprintSpawnableComponent ) )
class FIGHTINGGAME_API UHitboxHandlerComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UHitboxHandlerComponent();

protected:
    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hitbox Visualizer" )
    TSubclassOf<AHitboxVisualizer> m_HitboxVisualizer = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Default Hitboxes" )
    TArray<FHitboxDescription> m_DefaultHitboxes;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Default Hitboxes Data Assets" )
    TArray<TObjectPtr<UHitboxDescriptionDataAsset>> m_DefaultHitboxesDataAssets;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Spawn Default Hitboxes on Begin Play" )
    bool m_SpawnDefaultHitboxesOnBeginPlay = true;

    UPROPERTY()
    TObjectPtr<USceneComponent> m_ReferenceComponent = nullptr;

    virtual void BeginPlay() override;
    virtual void EndPlay( const EEndPlayReason::Type EndPlayReason ) override;

public:
    FHit m_HitDelegate;
    TArray<TObjectPtr<AActor>> m_AdditionalActorsToIgnore;

    void SetReferenceComponent( TObjectPtr<USceneComponent> Component );

    void AddHitbox( HitData Hit );
    void RemoveHitbox( uint32 HitUniqueId );
    void UpdateHitboxes();

    void ShowDebugTraces( bool Show );

    void SpawnDefaultHitboxes();

    virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;

private:
    TMap<uint32, TArray<FHitGroupPair>> m_ActorGroupsMap;
    TMap<int, TArray<HitData>> m_ActiveGroupedHitboxes;

    TArray<TObjectPtr<AHitboxVisualizer>> m_HitboxVisualizers;

    bool m_DebugTraces = true;

    bool TraceHitbox( const HitData& HitData, FHitResult& OutHit, ECollisionChannel CollisionChannel = CUSTOM_TRACE_HURTBOX );
    bool WasActorAlreadyHit( AActor* Actor, const HitData& Hit );
    void RegisterHitActor( AActor* Actor, const HitData& Hit );
    void UpdateHitbox( const HitData& HitData );

    void RemovePendingHitboxes();

    FVector GetHitTraceLocation( const HitData& Hit );

    void DEBUG_SpawnDebugSphere( const HitData& Hit );
    TObjectPtr<AHitboxVisualizer> DEBUG_GetHitboxVisualizerOrDefault( int HitboxId );
    void DEBUG_DestroyDebugSphere( int HitboxId );
    void DEBUG_UpdateDebugSpheres();
};

```

`Source/FightingGame/Combat/HitboxNotifyState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "HitboxNotifyState.h"

#include "HitboxDescriptionDataAsset.h"
#include "HitboxHandlerComponent.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Debugging/Debug.h"

void UHitboxNotifyState::NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                                      const FAnimNotifyEventReference& EventReference )
{
    Super::NotifyBegin( MeshComp, Animation, TotalDuration, EventReference );

    if( auto* character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
    {
        TArray<FHitboxDescription> aggregatedDescriptions;

        for( int32 i = 0; i < m_HitBoxes.Num(); ++i )
        {
            aggregatedDescriptions.Emplace( m_HitBoxes[i] );
        }

        for( int32 i = 0; i < m_HitboxesAssets.Num(); ++i )
        {
            if( !m_HitboxesAssets[i] )
            {
                FG_SLOG_ERR( "There is a null hitbox description data asset, will be skipped" );
                continue;
            }

            aggregatedDescriptions.Emplace( m_HitboxesAssets[i]->m_HitboxDescription );
        }

        for( int i = 0; i < aggregatedDescriptions.Num(); ++i )
        {
            const HitData& Data = UCombatStatics::GenerateHitDataFromHitboxDescription( character, MeshComp, aggregatedDescriptions[i], i, GetUniqueID() );
            character->GetHitboxHandler()->AddHitbox( Data );
        }
    }
}

void UHitboxNotifyState::NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
    Super::NotifyEnd( MeshComp, Animation, EventReference );

    if( auto* character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
    {
        TArray<FHitboxDescription> aggregatedDescriptions;

        for( int32 i = 0; i < m_HitBoxes.Num(); ++i )
        {
            aggregatedDescriptions.Emplace( m_HitBoxes[i] );
        }

        for( int32 i = 0; i < m_HitboxesAssets.Num(); ++i )
        {
            if( m_HitboxesAssets[i] )
            {
                aggregatedDescriptions.Emplace( m_HitboxesAssets[i]->m_HitboxDescription );
            }
        }

        for( int i = 0; i < aggregatedDescriptions.Num(); ++i )
        {
            character->GetHitboxHandler()->RemoveHitbox( i );
        }
    }
}

```

`Source/FightingGame/Combat/HitboxNotifyState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotifyState.h"
#include "HitboxNotifyState.generated.h"

class UHitboxDescriptionDataAsset;
struct FHitboxDescription;

UCLASS()
class FIGHTINGGAME_API UHitboxNotifyState : public UAnimNotifyState
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hitboxes" )
    TArray<FHitboxDescription> m_HitBoxes;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Hitboxes Data Assets" )
    TArray<TObjectPtr<UHitboxDescriptionDataAsset>> m_HitboxesAssets;

    virtual void NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                              const FAnimNotifyEventReference& EventReference ) override;

    virtual void NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;
};

```

`Source/FightingGame/Combat/Hittable.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "Hittable.h"

void IHittable::OnHitReceived( const HitData& HitData )
{
}

bool IHittable::IsHittable()
{
    return true;
}

bool IHittable::IsBlocking()
{
    return false;
}

void IHittable::EnableSuperArmor( const SuperArmorData& Data )
{
}

void IHittable::DisableSuperArmor()
{
}

```

`Source/FightingGame/Combat/Hittable.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "HitData.h"

#include "Hittable.generated.h"

// This class does not need to be modified.
UINTERFACE( MinimalAPI )
class UHittable : public UInterface
{
    GENERATED_BODY()
};

struct SuperArmorData;

class FIGHTINGGAME_API IHittable
{
    GENERATED_BODY()

public:
    virtual void OnHitReceived( const HitData& HitData );
    virtual bool IsHittable();
    virtual bool IsBlocking();
    virtual void EnableSuperArmor( const SuperArmorData& Data );
    virtual void DisableSuperArmor();
};

```

`Source/FightingGame/Combat/InputSequenceResolver.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "InputSequenceResolver.h"
#include "FightingGame/Debugging/Debug.h"

void UInputSequenceResolver::Init( const TArray<TObjectPtr<UInputsSequence>>& InputsList )
{
    for( int32 i = 0; i < InputsList.Num(); ++i )
    {
        TObjectPtr<UInputsSequence> sequence = InputsList[i];
        TArray<FMoveInputState>& inputs      = sequence->m_Inputs;

        auto startsWithSameInput = [&]( TSharedPtr<FInputResolverNode> _root )
        {
            ensureMsgf( !inputs.IsEmpty(), TEXT("Sequence [%s] has no inputs"), *sequence->m_Name );

            return _root->m_InputState == inputs[0];
        };

        if( auto it = m_Trees.FindByPredicate( startsWithSameInput ) )
        {
            m_CurrentSequenceRoot = *it;
        }
        else
        {
            m_CurrentSequenceRoot = MakeShared<FInputResolverNode>( sequence, inputs[0] );

            m_Trees.Emplace( m_CurrentSequenceRoot );
        }

        for( int32 j = 1; j < inputs.Num(); ++j )
        {
            auto node = MakeShared<FInputResolverNode>( sequence, inputs[j] );

            InsertNode( node );
        }
    }
}

EInputRegistrationResult UInputSequenceResolver::RegisterInput( EInputEntry InputEntry )
{
    if( !m_CurrentRouteNode && InputEntry == EInputEntry::None )
    {
        FG_SLOG_ERR( TEXT("A combo cannot start with a null entry") );
    }

    TArray<TSharedPtr<FInputResolverNode>> nodesArray = m_CurrentRouteNode ? m_CurrentRouteNode->m_Children : m_Trees;

    auto predSameInputEntry = [&InputEntry]( TSharedPtr<FInputResolverNode> _node )
    {
        return _node->m_InputState.m_InputEntry == InputEntry;
    };

    if( auto* it = nodesArray.FindByPredicate( predSameInputEntry ) )
    {
        if( (*it)->m_Children.IsEmpty() )
        {
            m_InputRouteEndedDelegate.Broadcast( (*it)->m_InputsSequence );
            m_CurrentRouteNode = nullptr;

            return EInputRegistrationResult::RouteEnded;
        }

        m_CurrentRouteNode = *it;
        ResetRouteTimer();
        StartRouteTimer();

        return EInputRegistrationResult::InputFound;
    }

    ResetRouteTimer();
    m_CurrentRouteNode = nullptr;

    return EInputRegistrationResult::InputNotFound;
}

void UInputSequenceResolver::InsertNode( TSharedPtr<FInputResolverNode> Node )
{
    if( !m_CurrentSequenceRoot )
    {
        m_CurrentSequenceRoot = Node;
    }
    else
    {
        auto predIsSameInputState = [&]( TSharedPtr<FInputResolverNode> _child )
        {
            return _child->m_InputState == Node->m_InputState;
        };

        if( auto* it = m_CurrentSequenceRoot->m_Children.FindByPredicate( predIsSameInputState ) )
        {
            m_CurrentSequenceRoot = *it;
            InsertNode( Node );
        }
        else
        {
            Node->m_Parent = m_CurrentSequenceRoot;
            m_CurrentSequenceRoot->m_Children.Emplace( Node );

            m_CurrentSequenceRoot = Node;
        }
    }
}

void UInputSequenceResolver::StartRouteTimer()
{
    FTimerManager& timerManager = GetWorld()->GetTimerManager();
    timerManager.SetTimer( m_RouteTimerHandle, this, &UInputSequenceResolver::OnRouteTimerEnded, m_RouteAutoResetTime );
}

void UInputSequenceResolver::ResetRouteTimer()
{
    FTimerManager& timerManager = GetWorld()->GetTimerManager();
    if( timerManager.IsTimerActive( m_RouteTimerHandle ) )
    {
        timerManager.ClearTimer( m_RouteTimerHandle );
    }
}

void UInputSequenceResolver::OnRouteTimerEnded()
{
    m_CurrentRouteNode = nullptr;
}

```

`Source/FightingGame/Combat/InputSequenceResolver.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "MoveDataAsset.h"
#include "FightingGame/Input/InputEntry.h"
#include "UObject/Object.h"
#include "InputSequenceResolver.generated.h"

struct FInputResolverNode
{
    FInputResolverNode( TObjectPtr<UInputsSequence> InputsSequence, FMoveInputState InputState )
        : m_InputsSequence( InputsSequence ), m_InputState( InputState )
    {
    }

    TObjectPtr<UInputsSequence> m_InputsSequence;
    FMoveInputState m_InputState;

    TSharedPtr<FInputResolverNode> m_Parent = nullptr;
    TArray<TSharedPtr<FInputResolverNode>> m_Children;
};

UENUM( BlueprintType )
enum class EInputRegistrationResult : uint8
{
    RouteEnded,
    InputFound,
    InputNotFound,

    COUNT UMETA( Hidden ),
    INVALID UMETA( Hidden ),
};

DECLARE_MULTICAST_DELEGATE_OneParam( FInputRouteEnded, TObjectPtr<UInputsSequence> )

UCLASS( Abstract, Blueprintable, BlueprintType, HideCategories = ("Cooking", "LOD", "Physics", "Activation", "Tags", "Rendering") )
class FIGHTINGGAME_API UInputSequenceResolver : public UObject
{
    GENERATED_BODY()

public:
    FInputRouteEnded m_InputRouteEndedDelegate;

    void Init( const TArray<TObjectPtr<UInputsSequence>>& InputsList );
    EInputRegistrationResult RegisterInput( EInputEntry InputEntry );

    void StartRouteTimer();
    void ResetRouteTimer();

protected:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Route Auto-Reset Time (Seconds)" )
    float m_RouteAutoResetTime = 0.1f;

private:
    TArray<TSharedPtr<FInputResolverNode>> m_Trees;
    TSharedPtr<FInputResolverNode> m_CurrentSequenceRoot      = nullptr;
    TSharedPtr<FInputResolverNode> m_CurrentDebugSequenceRoot = nullptr;

    TSharedPtr<FInputResolverNode> m_CurrentRouteNode = nullptr;

    FTimerHandle m_RouteTimerHandle;

    void InsertNode( TSharedPtr<FInputResolverNode> Node );
    void OnRouteTimerEnded();
};

```

`Source/FightingGame/Combat/InputsSequenceToStateMap.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "InputsSequenceToStateMap.h"

```

`Source/FightingGame/Combat/InputsSequenceToStateMap.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "InputsSequenceToStateMap.generated.h"

UCLASS()
class FIGHTINGGAME_API UInputsSequenceToStateMap : public UDataAsset
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Values" )
    TMap<FName, FName> m_Values;
};

```

`Source/FightingGame/Combat/InvincibilityNotifyState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "InvincibilityNotifyState.h"

#include "FightingGame/Character/FightingCharacter.h"

void UInvincibilityNotifyState::NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                                             const FAnimNotifyEventReference& EventReference )
{
	Super::NotifyBegin( MeshComp, Animation, TotalDuration, EventReference );

	if( auto* Character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
	{
		Character->SetHittable( false );
	}
}

void UInvincibilityNotifyState::NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
	Super::NotifyEnd( MeshComp, Animation, EventReference );

	if( auto* Character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
	{
		Character->SetHittable( true );
	}
}

```

`Source/FightingGame/Combat/InvincibilityNotifyState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotifyState.h"
#include "UObject/Object.h"
#include "InvincibilityNotifyState.generated.h"

UCLASS()
class FIGHTINGGAME_API UInvincibilityNotifyState : public UAnimNotifyState
{
	GENERATED_BODY()

public:
	virtual void NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
	                          const FAnimNotifyEventReference& EventReference ) override;

	virtual void NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;
};

```

`Source/FightingGame/Combat/JumpNotify.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "JumpNotify.h"

#include "FightingGame/Character/FightingCharacter.h"

void UJumpNotify::Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
	Super::Notify( MeshComp, Animation, EventReference );

	if( AFightingCharacter* Character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
	{
		Character->Jump();
	}
}

```

`Source/FightingGame/Combat/JumpNotify.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "JumpNotify.generated.h"

UCLASS()
class FIGHTINGGAME_API UJumpNotify : public UAnimNotify
{
	GENERATED_BODY()

public:
	virtual void Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;
};

```

`Source/FightingGame/Combat/MoveDataAsset.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "MoveDataAsset.h"


```

`Source/FightingGame/Combat/MoveDataAsset.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "FightingGame/Combat/MoveInputState.h"
#include "FightingGame/Input/InputsSequence.h"
#include "MoveDataAsset.generated.h"

enum class EInputEntry : uint8;
class UAnimationAsset;

UCLASS()
class FIGHTINGGAME_API UMoveDataAsset : public UDataAsset
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Id" )
    FName m_Id;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Animation Montage" )
    TObjectPtr<UAnimMontage> m_AnimationMontageAsset = nullptr;
};

```

`Source/FightingGame/Combat/MoveInputState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingGame/Input/InputPhase.h"
#include "MoveInputState.generated.h"

enum class EInputEntry : uint8;

USTRUCT( BlueprintType )
struct FIGHTINGGAME_API FMoveInputState
{
    GENERATED_BODY()

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Input" )
    EInputEntry m_InputEntry;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Phase" )
    EInputPhase m_InputPhase;

    bool operator==( const FMoveInputState& Other ) const
    {
        return m_InputEntry == Other.m_InputEntry && m_InputPhase == Other.m_InputPhase;
    }
};

```

`Source/FightingGame/Combat/PushCharacterNotify.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "PushCharacterNotify.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Debugging/Debug.h"

void UPushCharacterNotify::Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
	Super::Notify( MeshComp, Animation, EventReference );

	if( auto* character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
	{
		if( auto* facingEntity = Cast<IFacingEntity>( character ) )
		{
			FVector Knockback = UCombatStatics::GetKnockbackFromOrientation( facingEntity, m_Orientation );
			character->LaunchCharacter( Knockback.GetSafeNormal() * m_Force, true, true );
		}
		else
		{
			FG_SLOG_ERR( TEXT("Cannot convert character to IFacingEntity") );
		}
	}
}

```

`Source/FightingGame/Combat/PushCharacterNotify.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "PushCharacterNotify.generated.h"

UCLASS()
class FIGHTINGGAME_API UPushCharacterNotify : public UAnimNotify
{
	GENERATED_BODY()

public:
	virtual void Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;

protected:
	/*Positive value: towards facing, negative value: opposite to facing*/
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Force" )
	float m_Force = 0.f;

	/*Angle (degrees) of force vector, calculated from the character forward vector*/
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Orientation" )
	float m_Orientation = .0f;
};

```

`Source/FightingGame/Combat/SpawnProjectileNotify.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "SpawnProjectileNotify.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Projectile/ProjectileSpawnerComponent.h"

void USpawnProjectileNotify::Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
	Super::Notify( MeshComp, Animation, EventReference );

	if( auto* character = Cast<AFightingCharacter>( MeshComp->GetOwner() ) )
	{
		FVector rotatedOffset = m_SpawnOffset;
		rotatedOffset.Y *= character->IsFacingRight() ? 1.f : -1.f;

		FVector spawnLocation      = character->GetActorLocation() + rotatedOffset;
		float horizontalMultiplier = character->IsFacingRight() ? 1.f : -1.f;

		character->GetProjectileSpawnerComponent()->SpawnProjectile( m_ProjectileClass, spawnLocation, horizontalMultiplier, m_BaseSpeed, m_Lifetime );
	}
}

```

`Source/FightingGame/Combat/SpawnProjectileNotify.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "SpawnProjectileNotify.generated.h"

class AProjectile;
UCLASS()
class FIGHTINGGAME_API USpawnProjectileNotify : public UAnimNotify
{
	GENERATED_BODY()

public:
	virtual void Notify( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;

protected:
	UPROPERTY( EditAnywhere, DisplayName = "Projectile Class" )
	TSubclassOf<AProjectile> m_ProjectileClass = nullptr;

	UPROPERTY( EditAnywhere, DisplayName = "Spawn Offset (Account Facing)" )
	FVector m_SpawnOffset;

	UPROPERTY( EditAnywhere, DisplayName = "Base Speed" )
	float m_BaseSpeed = 100.f;

	UPROPERTY( EditAnywhere, DisplayName = "Lifetime" )
	float m_Lifetime = -1.f;
};

```

`Source/FightingGame/Combat/SuperArmorData.cpp`:

```cpp
#include "SuperArmorData.h"

```

`Source/FightingGame/Combat/SuperArmorData.h`:

```h
#pragma once

struct SuperArmorData
{
    float m_DamagePercentMultiplier = 1.f;
    float m_DamageMultiplier        = 1.f;
};

```

`Source/FightingGame/Combat/SuperArmorNotifyState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "SuperArmorNotifyState.h"

#include "Hittable.h"
#include "SuperArmorData.h"

void USuperArmorNotifyState::NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                                          const FAnimNotifyEventReference& EventReference )
{
    Super::NotifyBegin( MeshComp, Animation, TotalDuration, EventReference );

    if( auto* hittable = Cast<IHittable>( MeshComp->GetOwner() ) )
    {
        hittable->EnableSuperArmor( SuperArmorData{m_DamagePercentMultiplier, m_DamageMultiplier} );
    }
}

void USuperArmorNotifyState::NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference )
{
    Super::NotifyEnd( MeshComp, Animation, EventReference );

    if( auto* hittable = Cast<IHittable>( MeshComp->GetOwner() ) )
    {
        hittable->DisableSuperArmor();
    }
}

```

`Source/FightingGame/Combat/SuperArmorNotifyState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotifyState.h"
#include "SuperArmorNotifyState.generated.h"

UCLASS()
class FIGHTINGGAME_API USuperArmorNotifyState : public UAnimNotifyState
{
    GENERATED_BODY()

public:
    virtual void NotifyBegin( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float TotalDuration,
                              const FAnimNotifyEventReference& EventReference ) override;

    virtual void NotifyEnd( USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference ) override;

protected:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Damage Percent Multiplier" )
    float m_DamagePercentMultiplier = 1.f;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Damage Multiplier" )
    float m_DamageMultiplier = 1.f;
};

```

`Source/FightingGame/Common/CombatStatics.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "CombatStatics.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Combat/MoveDataAsset.h"
#include "FightingGame/Animation/FightingCharacterAnimInstance.h"
#include "FightingGame/Combat/HitboxDescription.h"
#include "FightingGame/Debugging/Debug.h"

namespace
{
    constexpr float loc_MinCustomTimeDilation = 0.001f;
    constexpr float loc_HitStunInitialDelay   = 0.f; //0.05f;
}

bool UCombatStatics::ExecuteMove( AFightingCharacter* Character, UMoveDataAsset* Move )
{
    if( !Character )
    {
        FG_SLOG_ERR( TEXT( "Character is null" ) );
        return false;
    }

    if( !Move )
    {
        FG_SLOG_ERR( TEXT( "Move data asset is null" ) );
        return false;
    }

    USkeletalMeshComponent* Mesh = Character->GetMesh();
    if( !Mesh )
    {
        FG_SLOG_ERR( TEXT( "Character has no skeletal mesh" ) );
        return false;
    }

    if( Move->m_AnimationMontageAsset )
    {
        UFightingCharacterAnimInstance* Inst = Cast<UFightingCharacterAnimInstance>( Mesh->GetAnimInstance() );
        if( !Inst )
        {
            FG_SLOG_ERR( TEXT( "Anim instance must be UFightingCharacterAnimInstance type" ) );
            return false;
        }

        Inst->AnimationRequested( Move->m_AnimationMontageAsset );
    }

    return true;
}

bool UCombatStatics::FaceOther( TObjectPtr<IFacingEntity> A, TObjectPtr<AActor> B, bool Instant /*= false*/ )
{
    if( !A )
    {
        FG_SLOG_ERR( TEXT("Character A is null") );
        return false;
    }

    if( !B )
    {
        FG_SLOG_ERR( TEXT( "Actor B is null" ) );
        return false;
    }

    bool Right = A->GetLocation().Y < B->GetActorLocation().Y;
    A->SetFacingRight( Right, Instant );

    return true;
}

bool UCombatStatics::FaceLocation( TObjectPtr<IFacingEntity> A, const FVector& Location )
{
    if( !A )
    {
        FG_SLOG_ERR( TEXT( "Character A is null" ) );
        return false;
    }

    bool Right = A->GetLocation().Y < Location.Y;
    A->SetFacingRight( Right, false );

    return true;
}

bool UCombatStatics::IsOtherOnTheRight( TObjectPtr<IFacingEntity> Me, TObjectPtr<IFacingEntity> Other )
{
    ensureMsgf( Me, TEXT("[Me] facing entity is null") );
    ensureMsgf( Other, TEXT("[Other] facing entity is null") );

    return Other->GetLocation().Y > Me->GetLocation().Y;
}

bool UCombatStatics::IsOtherOnTheLeft( TObjectPtr<IFacingEntity> Me, TObjectPtr<IFacingEntity> Other )
{
    return !IsOtherOnTheRight( Me, Other );
}

HitData UCombatStatics::GenerateHitDataFromHitboxDescription( TObjectPtr<AActor> HitboxOwner, TObjectPtr<USkeletalMeshComponent> SkeletalMesh,
                                                              const FHitboxDescription& HitboxDesc, int32 Id, int32 GroupId,
                                                              TArray<TObjectPtr<AActor>> AdditionalActorsToIgnore /*= {}*/ )
{
    FName socketName;
    IFacingEntity* facingEntity = Cast<IFacingEntity>( HitboxOwner );

    // #TODO how to handle the case where the owner is not an IFacingEntity? should we require it?
    if( facingEntity )
    {
        socketName = facingEntity->IsFacingRight() ? HitboxDesc.m_SocketName : HitboxDesc.m_SocketNameMirrored;
    }
    else
    {
        socketName = HitboxDesc.m_SocketName;
    }

    FVector processedKnockback = GetKnockbackFromOrientation( facingEntity, HitboxDesc.m_KnockbackOrientation ) * HitboxDesc.m_KnockbackForce;

    FVector targetLocation = HitboxDesc.m_Location;
    if( facingEntity )
    {
        targetLocation.Y *= facingEntity->IsFacingRight() ? 1.f : -1.f;
    }

    float hitStopDuration         = HitboxDesc.m_HitStopDuration;
    float opponentHitStopDuration = HitboxDesc.m_UseSeparateHitStopValues ? HitboxDesc.m_OpponentHitStopDuration : hitStopDuration;

    TObjectPtr<USkeletalMeshComponent> skeletalMesh = HitboxDesc.m_UseLocation ? nullptr : SkeletalMesh;

    return HitData( HitboxDesc.m_ForceOpponentFacing,
                    HitboxDesc.m_DamagePercent,
                    HitboxDesc.m_DamageHP,
                    HitboxDesc.m_Radius,
                    processedKnockback,
                    HitboxDesc.m_KnockbackOrientation,
                    HitboxDesc.m_IgnoreKnockbackMultiplier,
                    hitStopDuration,
                    opponentHitStopDuration,
                    HitboxDesc.m_Shake,
                    HitboxOwner->GetWorld(),
                    HitboxOwner,
                    skeletalMesh,
                    socketName,
                    targetLocation,
                    Id,
                    GroupId,
                    HitboxDesc.m_Priority,
                    HitboxDesc.m_IsCounter,
                    HitboxDesc.m_IgnoreBlock,
                    AdditionalActorsToIgnore,
                    HitboxDesc.m_HitSound,
                    HitboxDesc.m_CanClang,
                    HitboxDesc.m_ClangPriority,
                    HitboxDesc.m_AllowOnGroundedOpponents,
                    HitboxDesc.m_AllowOnAirborneOpponents );
}

FVector UCombatStatics::GetKnockbackFromOrientation( TObjectPtr<IFacingEntity> FacingEntity, float Orientation )
{
    ensureMsgf( FacingEntity, TEXT("Character is null") );

    float targetRoll = FacingEntity->IsFacingRight() ? -Orientation : -180.f + Orientation;
    FRotator rotator = FRotator( 0, 0, targetRoll );
    return rotator.RotateVector( FVector::RightVector );
}

bool UCombatStatics::ApplyKnockbackTo( const FVector& Direction, float Force, AFightingCharacter* Character, bool IgnoreMultiplier )
{
    if( !Character )
    {
        FG_SLOG_ERR( TEXT("Character is null") );
        return false;
    }

    float MultipliedForce = Force * (IgnoreMultiplier ? 1.f : Character->GetKnockbackMultiplier());
    Character->LaunchCharacter( Direction.GetSafeNormal() * MultipliedForce, true, true );

    return true;
}

float UCombatStatics::GetHitStopTimeDilation()
{
    return loc_MinCustomTimeDilation;
}

float UCombatStatics::GetHitStopInitialDelay()
{
    return loc_HitStunInitialDelay;
}

```

`Source/FightingGame/Common/CombatStatics.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "CombatStatics.generated.h"

struct FHitboxDescription;
struct HitData;

class IFacingEntity;
class AFightingCharacter;
class UMoveDataAsset;

UCLASS()
class FIGHTINGGAME_API UCombatStatics : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    UFUNCTION( BlueprintCallable, Category = "Combat" )
    static bool ExecuteMove( AFightingCharacter* Character, UMoveDataAsset* Move );

    static bool FaceOther( TObjectPtr<IFacingEntity> A, TObjectPtr<AActor> B, bool Instant = false );

    static bool FaceLocation( TObjectPtr<IFacingEntity> A, const FVector& Location );

    static bool IsOtherOnTheRight( TObjectPtr<IFacingEntity> Me, TObjectPtr<IFacingEntity> Other );
    static bool IsOtherOnTheLeft( TObjectPtr<IFacingEntity> Me, TObjectPtr<IFacingEntity> Other );

    static HitData GenerateHitDataFromHitboxDescription( TObjectPtr<AActor> HitboxOwner, TObjectPtr<USkeletalMeshComponent> SkeletalMesh,
                                                         const FHitboxDescription& HitboxDesc, int32 Id, int32 GroupId,
                                                         TArray<TObjectPtr<AActor>> AdditionalActorsToIgnore = {} );

    static FVector GetKnockbackFromOrientation( TObjectPtr<IFacingEntity> FacingEntity, float Orientation );

    UFUNCTION( BlueprintCallable, Category = "Combat" )
    static bool ApplyKnockbackTo( const FVector& Direction, float Force, AFightingCharacter* Character, bool IgnoreMultiplier );

    UFUNCTION( BlueprintCallable, Category = "Combat" )
    static float GetHitStopTimeDilation();

    UFUNCTION( BlueprintCallable, Category = "Combat" )
    static float GetHitStopInitialDelay();
};

```

`Source/FightingGame/Common/ConversionStatics.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "ConversionStatics.h"

```

`Source/FightingGame/Common/ConversionStatics.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Kismet/KismetStringLibrary.h"
#include "ConversionStatics.generated.h"

UCLASS()
class FIGHTINGGAME_API UConversionStatics : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    template<typename EnumType>
    FORCEINLINE static FString ConvertEnumValueToString( const EnumType Value, bool includeEnumName = true )
    {
        FString converted = UEnum::GetValueAsString( Value );
        if( includeEnumName )
        {
            return converted;
        }

        FString left, right;
        if( UKismetStringLibrary::Split( converted, TEXT( "::" ), left, right ) )
        {
            return right;
        }

        return converted;
    }
};

```

`Source/FightingGame/Common/FSMStatics.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "FSMStatics.h"
#include "FightingGame/Debugging/Debug.h"

namespace
{
    const FName loc_DefaultStateName = TEXT( "DEFAULT_STATE" );
}

/*bool UFSMStatics::Init( UFSM* Fsm, const FName& FirstStateName )
{
    /*if( !Fsm )
    {
        FG_SLOG_ERR( TEXT( "Fsm is null" ) );
        return false;
    }

    Fsm->Start();

    if( !Fsm->DoesStateExist( loc_DefaultStateName ) )
    {
        FG_SLOG_ERR( TEXT( "Default state does not exist in FSM" ) );
        return false;
    }

    Fsm->PushState( FirstStateName );#1#

    return true;
}

bool UFSMStatics::SetState( UFSM* Fsm, const FName& StateName )
{
    /*if( !IsFSMValid( Fsm ) ) return false;

    Fsm->PopActiveState();
    if( Fsm->GetActiveStateName() != loc_DefaultStateName )
    {
        FG_SLOG_ERR( FString::Printf( TEXT( "At this point the fsm should have the default state at the top of the stack." ) ) );
        return false;
    }

    if( !Fsm->DoesStateExist( StateName ) )
    {
        FG_SLOG_ERR( FString::Printf( TEXT( "Trying to push state [%s] that does not exist." ), *StateName.ToString() ) );
        return false;
    }

    Fsm->PushState( StateName );#1#

    return true;
}

bool UFSMStatics::PushState( UFSM* Fsm, const FName& StateName )
{
    /*if( !IsFSMValid( Fsm ) ) return false;

    if( !Fsm->DoesStateExist( StateName ) )
    {
        FG_SLOG_ERR( FString::Printf( TEXT( "Trying to push state [%s] that does not exist." ), *StateName.ToString() ) );
        return false;
    }

    Fsm->PushState( StateName );#1#

    return true;
}

bool UFSMStatics::PopState( UFSM* Fsm )
{
    /*if( !IsFSMValid( Fsm ) ) return false;

    Fsm->PopActiveState();#1#

    return true;
}

bool UFSMStatics::IsFSMValid( UFSM* Fsm )
{
    /*if( !Fsm )
    {
        FG_SLOG_ERR( TEXT( "Fsm is null" ) );
        return false;
    }

    if( !Fsm->IsMachineRunning() )
    {
        FG_SLOG_ERR( TEXT( "Fsm must be running to perform this operation" ) );
        return false;
    }#1#

    return true;
}*/

```

`Source/FightingGame/Common/FSMStatics.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "FSMStatics.generated.h"

class UFSM;

UCLASS()
class FIGHTINGGAME_API UFSMStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

/*public:
	UFUNCTION( BlueprintCallable, Category = "FSM" )
	static bool Init( UFSM* Fsm, const FName& FirstStateName );

	UFUNCTION( BlueprintCallable, Category = "FSM" )
	static bool SetState( UFSM* Fsm, const FName& StateName );

	UFUNCTION( BlueprintCallable, Category = "FSM" )
	static bool PushState( UFSM* Fsm, const FName& StateName );

	UFUNCTION( BlueprintCallable, Category = "FSM" )
	static bool PopState( UFSM* Fsm );

private:
	static bool IsFSMValid( UFSM* Fsm );*/
};

```

`Source/FightingGame/Common/GameFramework.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "GameFramework.h"

#include "Manager.h"
#include "FightingGame/Debugging/Debug.h"

AGameFramework::AGameFramework()
{
	PrimaryActorTick.bCanEverTick = true;
}

void AGameFramework::Init()
{
	for( auto& tuple : m_Managers )
	{
		// #TODO find a way to set name for this actor (tuple.Key)
		TObjectPtr<AManager> manager = Cast<AManager>( GetWorld()->SpawnActor( tuple.Value ) );
		manager->OnRegister( *this );

		m_ManagersInstances.Emplace( manager );
	}
}

void AGameFramework::ShutDown()
{
	for( TObjectPtr<AManager> manager : m_ManagersInstances )
	{
		manager->OnDeregister( *this );
	}

	for( int i = m_ManagersInstances.Num(); i >= 0; --i )
	{
		if( !GetWorld()->DestroyActor( m_ManagersInstances[i] ) )
		{
			FG_SLOG_ERR( FString::Printf(TEXT("Could not destroy manager [%s]"), *m_ManagersInstances[i]->GetName()) );
		}

		m_ManagersInstances.RemoveAt( i );
	}
}

```

`Source/FightingGame/Common/GameFramework.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Manager.h"
#include "FightingGame/Debugging/Debug.h"
#include "GameFramework/Actor.h"
#include "GameFramework.generated.h"

UCLASS()
class FIGHTINGGAME_API AGameFramework : public AActor
{
	GENERATED_BODY()

public:
	AGameFramework();

	void Init();
	void ShutDown();

	TObjectPtr<AManager> GetManager( UClass* Class ) const
	{
		ensureMsgf( Class, TEXT("Class is null") );

		auto* it = m_ManagersInstances.FindByPredicate( [&Class]( const TObjectPtr<AManager> _manager )
		{
			return _manager->IsA( Class );
		} );

		if( it )
		{
			return *it;
		}

		FG_SLOG_ERR( FString::Printf(TEXT("Cannot get manager of type [%s]: it does not exist"), *Class->GetName()) );
		return nullptr;
	}

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Managers" )
	TMap<FName, TSubclassOf<AManager>> m_Managers;

	TArray<TObjectPtr<AManager>> m_ManagersInstances;
};

```

`Source/FightingGame/Common/GlobalDelegates.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "GlobalDelegates.h"

GlobalDelegates& GlobalDelegates::Get()
{
    static GlobalDelegates instance;
    return instance;
}

```

`Source/FightingGame/Common/GlobalDelegates.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"

DECLARE_MULTICAST_DELEGATE( FGameModeInitializedDelegate )

#define DEFINE_GLOBAL_DELEGATE(DelegateType) \
public: F##DelegateType& Get##DelegateType() { return DelegateType; } \
private: F##DelegateType DelegateType;

#define DEFINE_GLOBAL_DELEGATE_TYPED(DelegateVariable, DelegateType) \
public: DelegateType& Get##DelegateVariable() { return DelegateVariable; } \
private: DelegateType DelegateVariable;

class FIGHTINGGAME_API GlobalDelegates
{
public:
    static GlobalDelegates& Get();

    FGameModeInitializedDelegate m_GameModeInitializedDelegate;
};

```

`Source/FightingGame/Common/Manager.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "Manager.h"

AManager::AManager()
{
	PrimaryActorTick.bCanEverTick = true;
}

void AManager::OnRegister( AGameFramework& Framework )
{
}

void AManager::OnDeregister( AGameFramework& Framework )
{
}

```

`Source/FightingGame/Common/Manager.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Manager.generated.h"

class AGameFramework;

UCLASS()
class FIGHTINGGAME_API AManager : public AActor
{
	GENERATED_BODY()

public:
	AManager();

	virtual void OnRegister( AGameFramework& Framework );
	virtual void OnDeregister( AGameFramework& Framework );
};

```

`Source/FightingGame/Common/MathStatics.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "MathStatics.h"

float UMathStatics::GetSignedAngle( const FVector2D A, const FVector2D B )
{
    auto normA = A.GetSafeNormal();
    auto normB = B.GetSafeNormal();

    float Ang1 = FMath::Atan2( normA.X, normA.Y );
    float Ang2 = FMath::Atan2( normB.X, normB.Y );

    float Ang = FMath::RadiansToDegrees( Ang1 - Ang2 );

    if( Ang > 180.0f )
    {
        Ang -= 360.0f;
    }
    else if( Ang < -180.0f )
    {
        Ang += 360.0f;
    }

    return Ang;
}

```

`Source/FightingGame/Common/MathStatics.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "MathStatics.generated.h"

UCLASS()
class FIGHTINGGAME_API UMathStatics : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

public:
    UFUNCTION( BlueprintCallable, Category = "Math" )
    static float GetSignedAngle( const FVector2D A, const FVector2D B );
};

```

`Source/FightingGame/Debugging/Debug.h`:

```h
#pragma once

#if UE_BUILD_SHIPPING

#define FG_CVAR(Var, CVarName, VarRef)
#define FG_CVAR_DESC(Var, CVarName, CVarDesc, VarRef)
#define FG_CVAR_FLAG_DESC(Var, CVarName, VarRef)

#define FG_SLOG_KEY(Key, Message, Color)

#define FG_SLOG(Message, Color)
#define FG_SLOG_INFO(Message)
#define FG_SLOG_WARN(Message)
#define FG_SLOG_ERR(Message)

#define FG_TEXT(World, Location, Text)

#else

#define FG_CVAR(Var, CVarName, VarRef) FAutoConsoleVariableRef Var(CVarName, VarRef, TEXT(""))
#define FG_CVAR_DESC(Var, CVarName, CVarDesc, VarRef) FAutoConsoleVariableRef Var(CVarName, VarRef, CVarDesc)
#define FG_CVAR_FLAG_DESC(Var, CVarName, VarRef) FG_CVAR_DESC(##Var, ##CVarName, TEXT("1: Enable, 0: Disable"), ##VarRef)

#define FG_SLOG_KEY(Key, Message, Color) GEngine->AddOnScreenDebugMessage(##Key, 1.f, ##Color, ##Message)

#define FG_SLOG(Message, Color) FG_SLOG_KEY(-1, ##Message, ##Color)
#define FG_SLOG_INFO(Message) FG_SLOG(##Message, FColor::White)
#define FG_SLOG_WARN(Message) FG_SLOG(##Message, FColor::Yellow)
#define FG_SLOG_ERR(Message) FG_SLOG(##Message, FColor::Red)


#define FG_TEXT(World, Location, Text) UKismetSystemLibrary::DrawDebugString(##World, ##Location, ##Text)

#endif

```

`Source/FightingGame/Debugging/HitboxVisualizer.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "HitboxVisualizer.h"

AHitboxVisualizer::AHitboxVisualizer()
{
    PrimaryActorTick.bCanEverTick = true;
}

void AHitboxVisualizer::BeginPlay()
{
    Super::BeginPlay();
}

void AHitboxVisualizer::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );

    if( m_Knockback.IsSet() )
    {
        FVector lineEnd = GetActorLocation() + m_Knockback.GetValue().GetSafeNormal() * m_Radius;
        DrawDebugLine( GetWorld(), GetActorLocation(), lineEnd, FColor::White, false, -1, SDPG_Foreground, m_KnockbackLineThickness );
    }
}

void AHitboxVisualizer::SetRegularState()
{
    SetColor( m_RegularColor );
}

void AHitboxVisualizer::SetHitState()
{
    SetColor( m_HitColor );
}

void AHitboxVisualizer::SetBlockedState()
{
    SetColor( m_BlockedColor );
}

void AHitboxVisualizer::SetColor( const FLinearColor& Color )
{
    if( UMaterialInstanceDynamic* materialInstance = m_Sphere->CreateDynamicMaterialInstance( 0, m_Sphere->GetMaterial( 0 ) ) )
    {
        materialInstance->SetVectorParameterValue( TEXT( "Color" ), Color );
    }
}

```

`Source/FightingGame/Debugging/HitboxVisualizer.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "SphereVisualizer.h"
#include "GameFramework/Actor.h"
#include "HitboxVisualizer.generated.h"

UCLASS()
class FIGHTINGGAME_API AHitboxVisualizer : public ASphereVisualizer
{
    GENERATED_BODY()

public:
    AHitboxVisualizer();

protected:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Knockback Line Thickness" )
    float m_KnockbackLineThickness = 3.f;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Regular Color" )
    FLinearColor m_RegularColor = FLinearColor::Red;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hit Color" )
    FLinearColor m_HitColor = FLinearColor::Green;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hit Color" )
    FLinearColor m_BlockedColor = FLinearColor::Blue;

    virtual void BeginPlay() override;

public:
    FORCEINLINE void SetKnockback( const FVector& Knockback ) { m_Knockback = Knockback; }

    virtual void Tick( float DeltaTime ) override;

    void SetRegularState();
    void SetHitState();
    void SetBlockedState();

protected:
    TOptional<FVector> m_Knockback;

    void SetColor( const FLinearColor& Color );
};

```

`Source/FightingGame/Debugging/SphereVisualizer.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "SphereVisualizer.h"

namespace
{
	constexpr float loc_ScaleToRadiusValue = 50.f;
}

ASphereVisualizer::ASphereVisualizer()
{
	PrimaryActorTick.bCanEverTick = true;

	m_Sphere      = CreateDefaultSubobject<UStaticMeshComponent>( TEXT( "Sphere" ) );
	RootComponent = m_Sphere;
}

void ASphereVisualizer::BeginPlay()
{
	Super::BeginPlay();
}

void ASphereVisualizer::SetRadius( float Radius )
{
	m_Radius = Radius;
	m_Sphere->SetWorldScale3D( (m_Radius / loc_ScaleToRadiusValue) * FVector::OneVector );
}

void ASphereVisualizer::Tick( float DeltaTime )
{
	Super::Tick( DeltaTime );
}

```

`Source/FightingGame/Debugging/SphereVisualizer.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SphereVisualizer.generated.h"

UCLASS()
class FIGHTINGGAME_API ASphereVisualizer : public AActor
{
	GENERATED_BODY()

public:
	ASphereVisualizer();

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Mesh" )
	TObjectPtr<UStaticMeshComponent> m_Sphere;

	virtual void BeginPlay() override;

public:
	void SetRadius( float Radius );

	FORCEINLINE void SetId( int Id ) { m_Id = Id; }
	FORCEINLINE int GetId() const { return m_Id; };

	FORCEINLINE void SetVisualizerOwner( TObjectPtr<AActor> NewOwner ) { m_Owner = NewOwner; };
	FORCEINLINE TObjectPtr<AActor> GetVisualizerOwner() const { return m_Owner; }

	FORCEINLINE void SetLocation( const FVector& Location ) { m_Location = Location; }
	FORCEINLINE TOptional<FVector> GetLocation() const { return m_Location; }

	virtual void Tick( float DeltaTime ) override;

protected:
	int m_Id       = -1;
	float m_Radius = 0.f;

	UPROPERTY()
	TObjectPtr<AActor> m_Owner = nullptr;

	TOptional<FVector> m_Location;
};

```

`Source/FightingGame/FSM/DelayedTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "DelayedTransition.h"

void UDelayedTransition::OnStateEnter()
{
	Super::OnStateEnter();

	m_CanPerform = false;

	ClearTimerIfActive();

	GetWorld()->GetTimerManager().SetTimer( m_TimerHandle, this, &UDelayedTransition::OnTimerEnded, m_Delay );
}

void UDelayedTransition::OnStateExit()
{
	Super::OnStateExit();

	ClearTimerIfActive();
}

bool UDelayedTransition::CanPerformTransition()
{
	return m_CanPerform;
}

void UDelayedTransition::ClearTimerIfActive()
{
	if( GetWorld()->GetTimerManager().IsTimerActive( m_TimerHandle ) )
	{
		GetWorld()->GetTimerManager().ClearTimer( m_TimerHandle );
	}
}

void UDelayedTransition::OnTimerEnded()
{
	m_CanPerform = true;
}

```

`Source/FightingGame/FSM/DelayedTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "UObject/Object.h"
#include "DelayedTransition.generated.h"

UCLASS()
class FIGHTINGGAME_API UDelayedTransition : public UFightingCharacterStateTransition
{
	GENERATED_BODY()

public:
	virtual void OnStateEnter() override;
	virtual void OnStateExit() override;
	virtual bool CanPerformTransition() override;

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Delay" )
	float m_Delay = 0.f;

private:
	bool m_CanPerform = false;
	FTimerHandle m_TimerHandle;

	void ClearTimerIfActive();
	void OnTimerEnded();
};

```

`Source/FightingGame/FSM/FightingCharacterState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "FightingCharacterState.h"

#include "FightingCharacterStateTransition.h"
#include "StateMachineComponent.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Animation/FightingCharacterAnimInstance.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Input/InputsSequenceStateMappingRow.h"
#include "VisualLogger/VisualLogger.h"

void UFightingCharacterState::OnInit()
{
    Super::OnInit();

    m_OwnerCharacter = Cast<AFightingCharacter>( m_FSM->GetOwner() );
    ensure( m_OwnerCharacter );

    m_AnimInstance = Cast<UFightingCharacterAnimInstance>( m_OwnerCharacter->GetMesh()->GetAnimInstance() );
    ensure( m_AnimInstance );

    for( auto Pair : m_Transitions )
    {
        TObjectPtr<UFightingCharacterStateTransition> Instance = NewObject<UFightingCharacterStateTransition>(
            m_OwnerCharacter, Pair.Value, Pair.Value->GetFName(), RF_NoFlags, Pair.Value.GetDefaultObject(), true );

        Instance->OnInit( m_OwnerCharacter );
        m_InstancedTransitions.Emplace( Pair.Key, Instance );
    }
}

void UFightingCharacterState::OnEnter()
{
    Super::OnEnter();

    m_AnimInstance->m_MontageEvent.AddDynamic( this, &UFightingCharacterState::OnMontageEvent );

    m_CharacterHitLandedHandle = m_OwnerCharacter->m_HitLandedDelegate.AddUObject( this, &UFightingCharacterState::OnCharacterHitLanded );
    m_CharacterGroundedHandle  = m_OwnerCharacter->m_GroundedDelegate.AddUObject( this, &UFightingCharacterState::OnCharacterGrounded );
    m_CharacterAirborneHandle  = m_OwnerCharacter->m_AirborneDelegate.AddUObject( this, &UFightingCharacterState::OnCharacterAirborne );

    if( m_MoveToExecute )
    {
        UCombatStatics::ExecuteMove( m_OwnerCharacter, m_MoveToExecute );
    }

    if( m_IsReaction )
    {
        m_OwnerCharacter->m_IsReacting = true;

        // #TODO what happens with AI?
        if( m_OwnerCharacter->IsPlayerControlled() )
        {
            m_OwnerCharacter->DisableInput( Cast<APlayerController>( m_OwnerCharacter->GetController() ) );
        }
    }

    m_OwnerCharacter->m_PretendIsGrounded = m_PretendIsGrounded;

    for( auto Pair : m_InstancedTransitions )
    {
        Pair.Value->OnStateEnter();
    }
}

void UFightingCharacterState::OnExit()
{
    Super::OnExit();

    if( m_AnimInstance )
    {
        m_AnimInstance->m_MontageEvent.RemoveDynamic( this, &UFightingCharacterState::OnMontageEvent );
    }

    m_OwnerCharacter->m_HitLandedDelegate.Remove( m_CharacterHitLandedHandle );
    m_OwnerCharacter->m_GroundedDelegate.Remove( m_CharacterGroundedHandle );
    m_OwnerCharacter->m_AirborneDelegate.Remove( m_CharacterAirborneHandle );

    if( m_IsReaction )
    {
        m_OwnerCharacter->m_IsReacting = false;

        // #TODO what happens with AI?
        if( m_OwnerCharacter->IsPlayerControlled() )
        {
            m_OwnerCharacter->EnableInput( Cast<APlayerController>( m_OwnerCharacter->GetController() ) );
        }
    }

    m_OwnerCharacter->m_PretendIsGrounded = false;

    for( auto Pair : m_InstancedTransitions )
    {
        Pair.Value->OnStateExit();
    }
}

void UFightingCharacterState::OnTick( float DeltaTime )
{
    Super::OnTick( DeltaTime );

    if( !m_IsReaction && !m_BlocksAllInputsSequences && (m_OwnerCharacter->HasJustLandedHit() || m_AlwaysListenForBufferedInputSequence) )
    {
        if( EvaluateInputsSequenceBufferedTransition( m_OwnerCharacter->HasJustLandedHit() ) )
        {
            // #TODO is this correct? can this transition have the ownership of that value?
            m_OwnerCharacter->ResetHasJustLandedHit();
            return;
        }
    }

    for( auto pair : m_InstancedTransitions )
    {
        if( pair.Value->CanPerformTransition() )
        {
            m_FSM->SetState( pair.Key );
        }
    }

    if( m_UpdateMovement )
    {
        m_OwnerCharacter->UpdateHorizontalMovement( m_OwnerCharacter->GetMovesBufferComponent()->m_InputMovement );
    }

    if( m_UpdateFacing )
    {
        m_OwnerCharacter->UpdateFacing();
    }
}

bool UFightingCharacterState::ThisStateOverridesInputsSequenceMapping( const FString& InputsSequenceName ) const
{
    return m_InputsSequencesOverrides.Contains( InputsSequenceName );
}

FInputsSequenceStateMappingRow* UFightingCharacterState::GetStateMappingRowFromInputsSequence( const FString& InputsSequenceName )
{
    if( TObjectPtr<UDataTable> table = m_OwnerCharacter->GetMovesBufferComponent()->m_InputsToStatesDataTable )
    {
        for( auto name : table->GetRowNames() )
        {
            auto* row = table->FindRow<FInputsSequenceStateMappingRow>( name, TEXT_EMPTY );
            verify( row );

            if( row->m_InputsSequence->m_Name == InputsSequenceName )
            {
                return row;
            }
        }
    }

    return nullptr;
}

void UFightingCharacterState::OnMontageEvent( UAnimMontage* Montage, EMontageEventType EventType )
{
    if( !m_IsReaction && m_MoveToExecute && !m_BlocksAllInputsSequences && EventType == EMontageEventType::Ended )
    {
        if( EvaluateInputsSequenceBufferedTransition( false ) )
        {
            return;
        }
    }

    for( auto Pair : m_InstancedTransitions )
    {
        Pair.Value->OnMontageEvent( Montage, EventType );
    }

    // #TODO handle other cases
    switch( EventType )
    {
        case EMontageEventType::Ended:
            {
                OnMontageEnded( Montage );
                break;
            }
    }
}

bool UFightingCharacterState::EvaluateInputsSequenceBufferedTransition( bool WasUsedDuringHit )
{
    TArray<FInputsSequenceBufferEntry> inputsSequenceSnapshot;
    m_OwnerCharacter->GetMovesBufferComponent()->GetInputsSequenceBufferSnapshot( inputsSequenceSnapshot, true, true, true );

    if( inputsSequenceSnapshot.IsEmpty() ) return false;

    FilterInputsSequenceBufferSnapshot( inputsSequenceSnapshot, WasUsedDuringHit );

    if( inputsSequenceSnapshot.IsEmpty() ) return false;

    inputsSequenceSnapshot.Sort( []( const FInputsSequenceBufferEntry& A, const FInputsSequenceBufferEntry& B )
    {
        return A.m_Priority < B.m_Priority;
    } );

    FInputsSequenceBufferEntry& targetEntry = inputsSequenceSnapshot[0];

    FString selectedInputsSequence = targetEntry.m_InputsSequenceName;
    FName targetState              = GetInputsSequenceMappedState( selectedInputsSequence );

    if( !targetState.IsNone() && targetState.IsValid() )
    {
        m_OwnerCharacter->GetMovesBufferComponent()->UseBufferedInputsSequence( targetEntry, false );

        m_FSM->SetState( targetState );

        return true;
    }

    return false;
}

void UFightingCharacterState::FilterInputsSequenceBufferSnapshot( TArray<FInputsSequenceBufferEntry>& Snapshot, bool WasUsedDuringHit )
{
    for( int32 i = Snapshot.Num() - 1; i >= 0; --i )
    {
        const FString& inputsSequence = Snapshot[i].m_InputsSequenceName;

        if( m_BlockedInputsSequences.Contains( inputsSequence ) )
        {
            Snapshot.RemoveAt( i );
            continue;
        }

        if( ThisStateOverridesInputsSequenceMapping( inputsSequence ) )
        {
            continue;
        }

        auto mappingRow = GetStateMappingRowFromInputsSequence( inputsSequence );

        if( WasUsedDuringHit && !mappingRow->m_AllowAsOnHitCancel )
        {
            Snapshot.RemoveAt( i );
            continue;
        }

        bool groundedContitionFailed = m_OwnerCharacter->IsGrounded() && !mappingRow->m_AllowWhenGrounded;
        bool airborneConditionFailed = m_OwnerCharacter->IsAirborne() && !mappingRow->m_AllowWhenAirborne;

        if( groundedContitionFailed || airborneConditionFailed )
        {
            Snapshot.RemoveAt( i );
        }
    }
}

FName UFightingCharacterState::GetInputsSequenceMappedState( const FString& InputsSequenceName )
{
    if( ThisStateOverridesInputsSequenceMapping( InputsSequenceName ) )
    {
        const auto& sequenceOverride = m_InputsSequencesOverrides[InputsSequenceName];

        if( m_OwnerCharacter->HasJustLandedHit() )
        {
            if( sequenceOverride.m_AllowAsOnHitCancel )
            {
                return sequenceOverride.m_TargetState;
            }
        }
        else
        {
            return sequenceOverride.m_TargetState;
        }
    }
    else
    {
        if( auto* row = GetStateMappingRowFromInputsSequence( InputsSequenceName ) )
        {
            return row->m_StateName;
        }
    }

    return NAME_None;
}

void UFightingCharacterState::OnCharacterAirborne_Implementation()
{
    for( auto Pair : m_InstancedTransitions )
    {
        Pair.Value->OnAirborne();
    }
}

void UFightingCharacterState::OnCharacterGrounded_Implementation()
{
    for( auto Pair : m_InstancedTransitions )
    {
        Pair.Value->OnGrounded();
    }
}

void UFightingCharacterState::OnCharacterHitLanded_Implementation( AActor* Target )
{
}

void UFightingCharacterState::OnMontageEnded_Implementation( UAnimMontage* Montage )
{
}

```

`Source/FightingGame/FSM/FightingCharacterState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "StateMachineState.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Input/InputsSequenceStateMappingRow.h"
#include "FightingGame/Input/MovesBufferComponent.h"
#include "FightingCharacterState.generated.h"

class UFightingCharacterStateTransition;
class UMoveDataAsset;
class AFightingCharacter;
class UFightingCharacterAnimInstance;

enum class EMontageEventType : uint8;

USTRUCT( BlueprintType )
struct FInputsSequenceOverrideData
{
    GENERATED_BODY()

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Target State" )
    FName m_TargetState;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Allow As Cancel On Hit" )
    bool m_AllowAsOnHitCancel = false;
};

UCLASS()
class FIGHTINGGAME_API UFightingCharacterState : public UStateMachineState
{
    GENERATED_BODY()

public:
    virtual void OnInit() override;
    virtual void OnEnter() override;
    virtual void OnExit() override;
    virtual void OnTick( float DeltaTime ) override;

protected:
    UPROPERTY( BlueprintReadOnly, DisplayName = "Owner Character" )
    TObjectPtr<AFightingCharacter> m_OwnerCharacter = nullptr;

    UPROPERTY( BlueprintReadOnly, DisplayName = "Anim Instance" )
    TObjectPtr<UFightingCharacterAnimInstance> m_AnimInstance = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Is Reaction" )
    bool m_IsReaction = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Move To Execute" )
    TObjectPtr<UMoveDataAsset> m_MoveToExecute = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Transitions" )
    TMap<FName, TSubclassOf<UFightingCharacterStateTransition>> m_Transitions;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Update Movement" )
    bool m_UpdateMovement = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Update Facing" )
    bool m_UpdateFacing = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Pretend is Grounded" )
    bool m_PretendIsGrounded = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Always Listen for Buffered Input Sequence" )
    bool m_AlwaysListenForBufferedInputSequence = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Inputs Sequences Override" )
    TMap<FString, FInputsSequenceOverrideData> m_InputsSequencesOverrides;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Inputs Sequences Blocks" )
    TArray<FString> m_BlockedInputsSequences;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Blocks All Inputs Sequences" )
    bool m_BlocksAllInputsSequences = false;

    bool ThisStateOverridesInputsSequenceMapping( const FString& InputsSequenceName ) const;


    FInputsSequenceStateMappingRow* GetStateMappingRowFromInputsSequence( const FString& InputsSequenceName );

    UFUNCTION()
    void OnMontageEvent( UAnimMontage* Montage, EMontageEventType EventType );

    UFUNCTION( BlueprintNativeEvent )
    void OnMontageEnded( UAnimMontage* Montage );

    UFUNCTION( BlueprintNativeEvent )
    void OnCharacterHitLanded( AActor* Target );

    UFUNCTION( BlueprintNativeEvent )
    void OnCharacterGrounded();

    UFUNCTION( BlueprintNativeEvent )
    void OnCharacterAirborne();

private:
    UPROPERTY()
    TMap<FName, TObjectPtr<UFightingCharacterStateTransition>> m_InstancedTransitions;

    FDelegateHandle m_CharacterHitLandedHandle;
    FDelegateHandle m_CharacterGroundedHandle;
    FDelegateHandle m_CharacterAirborneHandle;

    bool EvaluateInputsSequenceBufferedTransition( bool WasUsedDuringHit );
    void FilterInputsSequenceBufferSnapshot( TArray<FInputsSequenceBufferEntry>& Snapshot, bool WasUsedDuringHit );
    FName GetInputsSequenceMappedState( const FString& InputsSequenceName );
};

```

`Source/FightingGame/FSM/FightingCharacterStateTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "FightingCharacterStateTransition.h"

void UFightingCharacterStateTransition::OnInit( TObjectPtr<AFightingCharacter> Character )
{
	m_Character = Character;
}

void UFightingCharacterStateTransition::OnStateEnter()
{
}

void UFightingCharacterStateTransition::OnStateExit()
{
}

void UFightingCharacterStateTransition::OnMontageEvent( UAnimMontage* Montage, EMontageEventType MontageEvent )
{
}

void UFightingCharacterStateTransition::OnGrounded()
{
}

void UFightingCharacterStateTransition::OnAirborne()
{
}

bool UFightingCharacterStateTransition::CanPerformTransition()
{
	return false;
}

```

`Source/FightingGame/FSM/FightingCharacterStateTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.generated.h"

enum class EMontageEventType : uint8;
class AFightingCharacter;

UCLASS( Abstract, Blueprintable, BlueprintType, HideCategories = ("Cooking", "LOD", "Physics", "Activation", "Tags", "Rendering") )
class FIGHTINGGAME_API UFightingCharacterStateTransition : public UObject
{
	GENERATED_BODY()

public:
	virtual void OnInit( TObjectPtr<AFightingCharacter> Character );
	virtual void OnStateEnter();
	virtual void OnStateExit();

	virtual void OnMontageEvent( UAnimMontage* Montage, EMontageEventType MontageEvent );
	virtual void OnGrounded();
	virtual void OnAirborne();

	virtual bool CanPerformTransition();

protected:
	TObjectPtr<AFightingCharacter> m_Character = nullptr;
};

```

`Source/FightingGame/FSM/GroundedTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "GroundedTransition.h"

void UGroundedTransition::OnStateEnter()
{
	Super::OnStateEnter();

	m_CanTransition = false;
}

bool UGroundedTransition::CanPerformTransition()
{
	return m_CanTransition;
}

void UGroundedTransition::OnGrounded()
{
	Super::OnGrounded();

	if( m_MustBeGrounded )
	{
		m_CanTransition = true;
	}
}

void UGroundedTransition::OnAirborne()
{
	Super::OnAirborne();

	if( !m_MustBeGrounded )
	{
		m_CanTransition = true;
	}
}

```

`Source/FightingGame/FSM/GroundedTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "UObject/Object.h"
#include "GroundedTransition.generated.h"

UCLASS()
class FIGHTINGGAME_API UGroundedTransition : public UFightingCharacterStateTransition
{
	GENERATED_BODY()

public:
	virtual void OnStateEnter() override;
	virtual bool CanPerformTransition() override;
	virtual void OnGrounded() override;
	virtual void OnAirborne() override;

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Must Be Grounded" )
	bool m_MustBeGrounded = true;

private:
	bool m_CanTransition = false;
};

```

`Source/FightingGame/FSM/InputTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "InputTransition.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Input/MovesBufferComponent.h"

bool UInputTransition::CanPerformTransition()
{
    if( m_RequireHitLanded )
    {
        if( m_Character->HasJustLandedHit() )
        {
            if( m_Character->GetMovesBufferComponent()->IsInputBuffered( m_InputEntry ) )
            {
                // #TODO is this correct? can this transition have the ownership of that value?
                m_Character->ResetHasJustLandedHit();
                return true;
            }

            return false;
        }
    }
    else
    {
        return m_Character->GetMovesBufferComponent()->IsInputBuffered( m_InputEntry );
    }

    return false;
}

```

`Source/FightingGame/FSM/InputTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "FightingGame/Input/InputEntry.h"
#include "UObject/Object.h"
#include "InputTransition.generated.h"

UCLASS()
class FIGHTINGGAME_API UInputTransition : public UFightingCharacterStateTransition
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, DisplayName = "Input Entry" )
    EInputEntry m_InputEntry;

    UPROPERTY( EditAnywhere, DisplayName = "Require Hit Landed" )
    bool m_RequireHitLanded = false;

    virtual bool CanPerformTransition() override;
};

```

`Source/FightingGame/FSM/InputsSequenceTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "InputsSequenceTransition.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Input/MovesBufferComponent.h"

bool UInputsSequenceTransition::CanPerformTransition()
{
    if( m_RequireHitLanded )
    {
        if( m_Character->HasJustLandedHit() )
        {
            if( m_Character->GetMovesBufferComponent()->IsInputsSequenceBuffered( m_InputsSequenceName ) )
            {
                // #TODO is this correct? can this transition have the ownership of that value?
                m_Character->ResetHasJustLandedHit();
                return true;
            }

            return false;
        }
    }
    else
    {
        return m_Character->GetMovesBufferComponent()->IsInputsSequenceBuffered( m_InputsSequenceName );
    }

    return false;
}

```

`Source/FightingGame/FSM/InputsSequenceTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "UObject/Object.h"
#include "InputsSequenceTransition.generated.h"

UCLASS()
class FIGHTINGGAME_API UInputsSequenceTransition : public UFightingCharacterStateTransition
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, DisplayName = "Inputs Sequence Name" )
    FString m_InputsSequenceName;

    UPROPERTY( EditAnywhere, DisplayName = "Require Hit Landed" )
    bool m_RequireHitLanded = false;

    virtual bool CanPerformTransition() override;
};

```

`Source/FightingGame/FSM/MontageEndedTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "MontageEndedTransition.h"

#include "FightingGame/Animation/FightingCharacterAnimInstance.h"

void UMontageEndedTransition::OnStateEnter()
{
	Super::OnStateEnter();

	m_CanTransition = false;
}

bool UMontageEndedTransition::CanPerformTransition()
{
	return m_CanTransition;
}

void UMontageEndedTransition::OnMontageEvent( UAnimMontage* Montage, EMontageEventType EventType )
{
	switch( EventType )
	{
	case EMontageEventType::Ended:
		{
			m_CanTransition = true;
			break;
		}
	}
}

```

`Source/FightingGame/FSM/MontageEndedTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "UObject/Object.h"
#include "MontageEndedTransition.generated.h"

enum class EMontageEventType : uint8;
class UFightingCharacterAnimInstance;

UCLASS()
class FIGHTINGGAME_API UMontageEndedTransition : public UFightingCharacterStateTransition
{
	GENERATED_BODY()

public:
	virtual void OnStateEnter() override;

	virtual void OnMontageEvent( UAnimMontage* Montage, EMontageEventType MontageEvent ) override;

	virtual bool CanPerformTransition() override;

private:
	bool m_CanTransition = false;

	UPROPERTY()
	UFightingCharacterAnimInstance* m_AnimInstance = nullptr;
};

```

`Source/FightingGame/FSM/MoveTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "MoveTransition.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Input/MovesBufferComponent.h"

bool UMoveTransition::CanPerformTransition()
{
    if( m_RequireHitLanded )
    {
        if( m_Character->HasJustLandedHit() )
        {
            if( m_Character->GetMovesBufferComponent()->IsInputsSequenceBuffered( m_MoveName ) )
            {
                // #TODO is this correct? can this transition have the ownership of that value?
                m_Character->ResetHasJustLandedHit();
                return true;
            }

            return false;
        }
    }
    else
    {
        return m_Character->GetMovesBufferComponent()->IsInputsSequenceBuffered( m_MoveName );
    }

    return false;
}

```

`Source/FightingGame/FSM/MoveTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "UObject/Object.h"
#include "MoveTransition.generated.h"

UCLASS()
class FIGHTINGGAME_API UMoveTransition : public UFightingCharacterStateTransition
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Move Name" )
    FString m_MoveName;

    UPROPERTY( EditAnywhere, DisplayName = "Require Hit Landed" )
    bool m_RequireHitLanded = false;

    virtual bool CanPerformTransition() override;
};

```

`Source/FightingGame/FSM/MovementTransition.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "MovementTransition.h"

#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Input/MovesBufferComponent.h"

bool UMovementTransition::CanPerformTransition()
{
	if( m_ThresholdComparison == EThresholdComparison::GreaterThan )
	{
		return FMath::Abs( m_Character->GetMovesBufferComponent()->m_InputMovement ) > m_Threshold;
	}

	return FMath::Abs( m_Character->GetMovesBufferComponent()->m_InputMovement ) < m_Threshold;
}

```

`Source/FightingGame/FSM/MovementTransition.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingCharacterStateTransition.h"
#include "UObject/Object.h"
#include "MovementTransition.generated.h"

UENUM( BlueprintType )
enum class EThresholdComparison : uint8
{
	GreaterThan,
	LessThan,

	COUNT UMETA( Hidden ),
	INVALID UMETA( Hidden )
};

UCLASS()
class FIGHTINGGAME_API UMovementTransition : public UFightingCharacterStateTransition
{
	GENERATED_BODY()

public:
	virtual bool CanPerformTransition() override;

protected:
	UPROPERTY( EditAnywhere, DisplayName = "Threshold" )
	float m_Threshold = 0.f;

	UPROPERTY( EditAnywhere, DisplayName = "Comparison" )
	EThresholdComparison m_ThresholdComparison = EThresholdComparison::GreaterThan;
};

```

`Source/FightingGame/FSM/StateMachineComponent.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "StateMachineComponent.h"

#include "FightingGame/Debugging/Debug.h"

namespace
{
    int32 loc_DebugCurrentState = 0;
    FG_CVAR_FLAG_DESC( CVarDebugCurrentState, TEXT("StateMachine.DebugCurrentState"), loc_DebugCurrentState );

    int32 loc_DebugStatesHistory = 0;
    FG_CVAR_FLAG_DESC( CVarDebugStatesHistory, TEXT("StateMachine.DebugStatesHistory"), loc_DebugStatesHistory );
}

UStateMachineComponent::UStateMachineComponent()
{
    PrimaryComponentTick.bCanEverTick = true;
}

void UStateMachineComponent::BeginPlay()
{
    Super::BeginPlay();

    if( m_StartOnBeginPlay )
    {
        Start();
    }
}

void UStateMachineComponent::Start()
{
    if( m_Started )
    {
        FG_SLOG_ERR( TEXT("State machine was already started") );
        return;
    }

    for( int i = 0; i < m_States.Num(); ++i )
    {
        TObjectPtr<UStateMachineState> inst = NewObject<UStateMachineState>( GetOwner(), m_States[i], m_States[i]->GetFName(), RF_NoFlags,
                                                                             m_States[i].GetDefaultObject(), true );

        inst->m_FSM = this;
        inst->OnInit();

        m_StatesInstances.Emplace( inst );
    }

    m_Started = true;

    if( TObjectPtr<UStateMachineState> firstState = GetStateById( m_FirstStateName ) )
    {
        // #TODO add overload to set state by state ptr
        SetState( firstState->m_Id );
    }
}

void UStateMachineComponent::SetState( const FName& StateId )
{
    m_CanTickCurrentState = false;

    if( m_CurrentState )
    {
        if( m_CurrentState->m_Id == StateId && !m_CurrentState->m_Repeatable )
        {
            FG_SLOG_ERR( FString::Printf(TEXT("You're trying to repeat state [%s] but it's not repeatable"), *StateId.ToString()) );

            m_CanTickCurrentState = true;
            return;
        }

        m_CurrentState->OnExit();
    }

    m_CurrentState = GetStateById( StateId );
    if( m_CurrentState )
    {
        m_CurrentState->OnEnter();
        m_CanTickCurrentState = true;

        if( m_StatesHistory.Num() > m_HistoryLength )
        {
            m_StatesHistory.RemoveAt( 0 );
        }

        m_StatesHistory.Emplace( m_CurrentState );
    }
    else
    {
        FG_SLOG_ERR( FString::Printf(TEXT("Cannot find state named [%s]"), *StateId.ToString()) );
    }
}

void UStateMachineComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )
{
    Super::TickComponent( DeltaTime, TickType, ThisTickFunction );

    if( m_CurrentState && m_CurrentState->IsValidLowLevel() && m_CanTickCurrentState )
    {
        m_CurrentState->OnTick( DeltaTime );
    }

    FString ownerName = GetOwner()->GetName();
    uint64 uniqueId64 = GetOwner()->GetUniqueID();
    if( loc_DebugCurrentState )
    {
        FG_SLOG_KEY( uniqueId64, FString::Printf(TEXT("(%s) STATE: %s"), *ownerName, *m_CurrentState->m_Id.ToString()), FColor::Orange );
    }

    if( loc_DebugStatesHistory )
    {
        static int32 startIndex = uniqueId64 + 1;
        FG_SLOG_KEY( startIndex - 1, FString::Printf( TEXT( "[STATES HISTORY %s]" ), *ownerName), FColor::Emerald );

        for( int32 i = 0; i < m_StatesHistory.Num(); ++i )
        {
            FG_SLOG_KEY( startIndex + i, FString::Printf(TEXT("%s"), *m_StatesHistory[i]->m_Id.ToString()), FColor::Emerald );
        }
    }
}

TObjectPtr<UStateMachineState> UStateMachineComponent::GetStateById( const FName& Id )
{
    auto* it = m_StatesInstances.FindByPredicate( [&Id]( TObjectPtr<UStateMachineState> _state )
    {
        return _state->m_Id == Id;
    } );

    return it ? *it : nullptr;
}

```

`Source/FightingGame/FSM/StateMachineComponent.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "StateMachineState.h"
#include "Components/ActorComponent.h"
#include "StateMachineComponent.generated.h"

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class FIGHTINGGAME_API UStateMachineComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UStateMachineComponent();

protected:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "States Classes", Category = "State Machine" )
    TArray<TSubclassOf<UStateMachineState>> m_States;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Start On BeginPlay", Category = "State Machine" )
    bool m_StartOnBeginPlay = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "First State Name", Category = "State Machine" )
    FName m_FirstStateName;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "History Length", Category = "State Machine" )
    int32 m_HistoryLength = 10;

    virtual void BeginPlay() override;

public:
    void Start();

    void SetState( const FName& StateId );

    virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;

private:
    bool m_Started = false;

    UPROPERTY()
    TArray<TObjectPtr<UStateMachineState>> m_StatesInstances;

    UPROPERTY()
    TObjectPtr<UStateMachineState> m_CurrentState = nullptr;

    bool m_CanTickCurrentState = true;

    UPROPERTY()
    TArray<TObjectPtr<UStateMachineState>> m_StatesHistory;

    TObjectPtr<UStateMachineState> GetStateById( const FName& Id );
};

```

`Source/FightingGame/FSM/StateMachineState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "StateMachineState.h"

void UStateMachineState::OnInit()
{
    ReceiveOnInit();
}

void UStateMachineState::OnEnter()
{
    ReceiveOnEnter();
}

void UStateMachineState::OnExit()
{
    ReceiveOnExit();
}

void UStateMachineState::OnTick( float DeltaTime )
{
    ReceiveOnTick( DeltaTime );
}

```

`Source/FightingGame/FSM/StateMachineState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "StateMachineState.generated.h"

class UStateMachineComponent;

UCLASS( Abstract, Blueprintable, BlueprintType, HideCategories = ("Cooking", "LOD", "Physics", "Activation", "Tags", "Rendering") )
class FIGHTINGGAME_API UStateMachineState : public UObject
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "State Id" )
    FName m_Id;

    UPROPERTY()
    TObjectPtr<UStateMachineComponent> m_FSM = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Repeatable" )
    bool m_Repeatable = true;

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Init"), Category = "State Machine|State" )
    void ReceiveOnInit();

    virtual void OnInit();

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Enter"), Category = "State Machine|State" )
    void ReceiveOnEnter();

    virtual void OnEnter();

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Exit"), Category = "State Machine|State" )
    void ReceiveOnExit();

    virtual void OnExit();

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Tick"), Category = "State Machine|State" )
    void ReceiveOnTick( float DeltaTime );

    virtual void OnTick( float DeltaTime );
};

```

`Source/FightingGame/FightingGame.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class FightingGame : ModuleRules
{
	public FightingGame( ReadOnlyTargetRules Target ) : base( Target )
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange( new string[]
		{
			"Core", "CoreUObject", "Engine", "InputCore", "UMG", "ImGui"
		} );

		PrivateDependencyModuleNames.AddRange( new string[] { } );

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });

		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}
```

`Source/FightingGame/FightingGame.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "FightingGame.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, FightingGame, "FightingGame" );

```

`Source/FightingGame/FightingGame.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"


```

`Source/FightingGame/FightingGameGameModeBase.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "FightingGameGameModeBase.h"

#include "Camera/CameraManager.h"
#include "Common/GameFramework.h"
#include "Kismet/GameplayStatics.h"

void AFightingGameGameModeBase::BeginPlay()
{
	Super::BeginPlay();

	// #TODO spawn instead of getting
	if( auto* CameraManagerActor = UGameplayStatics::GetActorOfClass( GetWorld(), ACameraManager::StaticClass() ) )
	{
		m_CameraManager = Cast<ACameraManager>( CameraManagerActor );
	}

	m_GameFrameworkInstance = GetWorld()->SpawnActor<AGameFramework>();
	ensureMsgf( m_GameFrameworkInstance, TEXT("Could not spawn game framework") );

	m_GameFrameworkInstance->Init();
}

void AFightingGameGameModeBase::InitCameraManager()
{
	if( m_CameraManager )
	{
		m_CameraManager->Init();
	}
}

```

`Source/FightingGame/FightingGameGameModeBase.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "FightingGameGameModeBase.generated.h"

class ACameraManager;
class AGameFramework;

UCLASS()
class FIGHTINGGAME_API AFightingGameGameModeBase : public AGameModeBase
{
	GENERATED_BODY()

public:
	virtual void BeginPlay() override;

	FORCEINLINE TObjectPtr<AGameFramework> GetGameFramework() const { return m_GameFrameworkInstance; }

protected:
	UPROPERTY()
	TObjectPtr<ACameraManager> m_CameraManager = nullptr;

	UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Classes, DisplayName = "Game Framework Class" )
	TSubclassOf<AGameFramework> m_GameFrameworkClass;

	UPROPERTY()
	TObjectPtr<AGameFramework> m_GameFrameworkInstance = nullptr;

	void InitCameraManager();
};

```

`Source/FightingGame/GameInstance/CustomGameInstance.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "CustomGameInstance.h"

```

`Source/FightingGame/GameInstance/CustomGameInstance.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "CustomGameState.h"
#include "CustomGameInstance.generated.h"

UCLASS()
class FIGHTINGGAME_API UCustomGameInstance : public UGameInstance
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Game States" )
    TArray<TSubclassOf<UCustomGameState>> m_GameStates;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "First State Name" )
    FName m_FirstStateName;
};

```

`Source/FightingGame/GameInstance/CustomGameState.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "CustomGameState.h"

void UCustomGameState::OnInit()
{
    ReceiveOnInit();
}

void UCustomGameState::OnEnter()
{
    ReceiveOnEnter();
}

void UCustomGameState::OnExit()
{
    ReceiveOnExit();
}

void UCustomGameState::OnTick( float DeltaTime )
{
    ReceiveOnTick( DeltaTime );
}

```

`Source/FightingGame/GameInstance/CustomGameState.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "CustomGameState.generated.h"

class UCustomGameInstance;

UCLASS( Abstract, Blueprintable, BlueprintType, HideCategories = ("Cooking", "LOD", "Physics", "Activation", "Tags", "Rendering") )
class FIGHTINGGAME_API UCustomGameState : public UObject
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "State Id" )
    FName m_Id;

    UPROPERTY()
    TObjectPtr<UCustomGameInstance> m_GameInstance = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Repeatable" )
    bool m_Repeatable = false;

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Init"), Category = "Game State" )
    void ReceiveOnInit();

    virtual void OnInit();

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Enter"), Category = "Game State" )
    void ReceiveOnEnter();

    virtual void OnEnter();

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Exit"), Category = "Game State" )
    void ReceiveOnExit();

    virtual void OnExit();

    UFUNCTION( BlueprintImplementableEvent, meta=(DisplayName="On Tick"), Category = "Game State" )
    void ReceiveOnTick( float DeltaTime );

    virtual void OnTick( float DeltaTime );
};

```

`Source/FightingGame/GameMode/FreeForAllGameMode.cpp`:

```cpp
#include "FreeForAllGameMode.h"

#include "EngineUtils.h"
#include "IndexedPlayerStart.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Common/CombatStatics.h"
#include "FightingGame/Common/ConversionStatics.h"
#include "FightingGame/Common/GlobalDelegates.h"
#include "FightingGame/Debugging/Debug.h"
#include "FightingGame/UI/HUDBase.h"
#include "Kismet/GameplayStatics.h"

void AFreeForAllGameMode::BeginPlay()
{
    Super::BeginPlay();

    SpawnCharacters();
}

// #TODO check which part of this class can be moved to GameState
void AFreeForAllGameMode::SpawnCharacters()
{
    UWorld* world = GetWorld();
    for( TActorIterator<AIndexedPlayerStart> it( world ); it; ++it )
    {
        // TODO: missing checks
        m_PlayerStarts.Emplace( *it );
    }

    m_PlayerStarts.Sort( []( const AIndexedPlayerStart& A, const AIndexedPlayerStart& B )
    {
        return A.m_Index < B.m_Index;
    } );

    for( int32 i = 0; i < m_AdditionalPlayers + 1; ++i )
    {
        TObjectPtr<APlayerController> player = i == 0 ? UGameplayStatics::GetPlayerController( world, 0 ) : UGameplayStatics::CreatePlayer( GetWorld() );
        //ABasePlayerState* playerState = Cast<ABasePlayerState>( player->PlayerState );
        //playerState->CustomSetPlayerName( FName( FString::Printf( TEXT( "Player %d" ), i ) ) );

        m_PlayerControllers.Emplace( player );

        TObjectPtr<AIndexedPlayerStart> start         = m_PlayerStarts[i];
        TObjectPtr<AFightingCharacter> character      = GetWorld()->SpawnActor<AFightingCharacter>( m_CharacterClass, start->GetTransform() );
        character->m_PlayerIndex                      = i;
        character->m_DamageIncreasesCharactersPercent = m_DamageIncreasesCharactersPercent;

        character->m_DeathDelegate.AddUObject( this, &AFreeForAllGameMode::OnCharacterDeath );

        m_Characters.Emplace( character );

        player->Possess( character );

        if( TObjectPtr<IFacingEntity> facingEntity = Cast<IFacingEntity>( character ) )
        {
            UCombatStatics::FaceLocation( facingEntity, FVector::ZeroVector );
        }
        else
        {
            FG_SLOG_ERR( TEXT("Cast to IFacingEntity from character failed") );
        }
    }

    if( m_EnableCharactersAutoFacing && m_AdditionalPlayers == 1 )
    {
        ensureMsgf( m_Characters.Num() == 2, TEXT("Additional players var is set to 1 but the total number of characters is not 2") );

        m_Characters[0]->SetOpponentToFace( m_Characters[1] );
        m_Characters[1]->SetOpponentToFace( m_Characters[0] );
    }

    InitCameraManager();

    EnablePlayersInput( true );

    GlobalDelegates::Get().m_GameModeInitializedDelegate.Broadcast();
}

void AFreeForAllGameMode::EnablePlayersInput( bool Enable )
{
    for( APlayerController* player : m_PlayerControllers )
    {
        if( auto* Pawn = player->GetPawn() )
        {
            if( Enable )
            {
                Pawn->EnableInput( player );
            }
            else
            {
                Pawn->DisableInput( player );
            }
        }
    }
}

void AFreeForAllGameMode::OnCharacterDeath( TObjectPtr<AFightingCharacter> Character, EDeathReason Reason )
{
    FG_SLOG_INFO( FString::Printf(TEXT("[%s] Died. Reason: %s"), *Character->GetName(), *UConversionStatics::ConvertEnumValueToString( Reason, false )) );
}

```

`Source/FightingGame/GameMode/FreeForAllGameMode.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "FightingGame/FightingGameGameModeBase.h"
#include "FreeForAllGameMode.generated.h"

enum class EDeathReason : uint8;
class AIndexedPlayerStart;
class ACameraManager;
class AFightingCharacter;

// #TODO check which part of this class can be moved to GameState

UCLASS()
class FIGHTINGGAME_API AFreeForAllGameMode : public AFightingGameGameModeBase
{
    GENERATED_BODY()

protected:
    virtual void BeginPlay() override;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Classes, DisplayName = "Character Class" )
    TSubclassOf<AFightingCharacter> m_CharacterClass;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Additional Players" )
    int m_AdditionalPlayers = 0;

    /*
     * This only works with exactly 2 players
     */
    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Enable characters auto-facing" )
    bool m_EnableCharactersAutoFacing = false;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Damage Increases Characters Percent Value" )
    bool m_DamageIncreasesCharactersPercent = false;

private:
    TArray<TObjectPtr<AIndexedPlayerStart>> m_PlayerStarts;
    TArray<TObjectPtr<APlayerController>> m_PlayerControllers;
    TArray<TObjectPtr<AFightingCharacter>> m_Characters;

    void SpawnCharacters();
    void EnablePlayersInput( bool Enable );

    void OnCharacterDeath( TObjectPtr<AFightingCharacter> Character, EDeathReason Reason );
};

```

`Source/FightingGame/GameMode/IndexedPlayerStart.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "IndexedPlayerStart.h"

```

`Source/FightingGame/GameMode/IndexedPlayerStart.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "GameFramework/PlayerStart.h"
#include "IndexedPlayerStart.generated.h"

UCLASS()
class FIGHTINGGAME_API AIndexedPlayerStart : public APlayerStart
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Index" )
    int32 m_Index = 0;
};

```

`Source/FightingGame/Input/InputEntry.h`:

```h
#pragma once

UENUM( BlueprintType )
enum class EInputEntry : uint8
{
    None,
    Jump,
    Attack,
    Special,
    Forward,
    ForwardDown,
    Down,
    DownBackward,
    Backward,
    BackwardUp,
    Up,
    UpForward,
    Neutral,
    Counter,

    COUNT UMETA( Hidden ),
    INVALID UMETA( Hidden ),
};

FORCEINLINE EInputEntry MirrorInputEntry( EInputEntry InputEntry )
{
    switch( InputEntry )
    {
        case EInputEntry::Forward: return EInputEntry::Backward;
        case EInputEntry::Backward: return EInputEntry::Forward;

        case EInputEntry::ForwardDown: return EInputEntry::DownBackward;
        case EInputEntry::DownBackward: return EInputEntry::ForwardDown;

        case EInputEntry::UpForward: return EInputEntry::BackwardUp;
        case EInputEntry::BackwardUp: return EInputEntry::UpForward;

        default: return InputEntry;
    }
}

```

`Source/FightingGame/Input/InputPhase.h`:

```h
#pragma once

#include "CoreMinimal.h"

UENUM( BlueprintType )
enum class EInputPhase : uint8
{
    Pressed,
    Released,
    Any,

    COUNT UMETA( Hidden ),
    INVALID UMETA( Hidden ),
};

```

`Source/FightingGame/Input/InputsSequence.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "InputsSequence.h"

```

`Source/FightingGame/Input/InputsSequence.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingGame/Combat/MoveInputState.h"
#include "InputsSequence.generated.h"

UCLASS()
class FIGHTINGGAME_API UInputsSequence : public UDataAsset
{
    GENERATED_BODY()

public:
    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Name" )
    FString m_Name;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Sequence" )
    TArray<FMoveInputState> m_Inputs;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Priority" )
    int32 m_Priority = 0;
};

```

`Source/FightingGame/Input/InputsSequenceStateMappingRow.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "InputsSequenceStateMappingRow.h"

```

`Source/FightingGame/Input/InputsSequenceStateMappingRow.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "InputsSequence.h"
#include "Engine/DataTable.h"
#include "InputsSequenceStateMappingRow.generated.h"

USTRUCT( BlueprintType )
struct FIGHTINGGAME_API FInputsSequenceStateMappingRow : public FTableRowBase
{
    GENERATED_BODY()

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Input Sequence" )
    TObjectPtr<UInputsSequence> m_InputsSequence = nullptr;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "State Name" )
    FName m_StateName;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Allow When Grounded" )
    bool m_AllowWhenGrounded = true;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Allow When Airborne" )
    bool m_AllowWhenAirborne = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Allow As Cancel On Hit" )
    bool m_AllowAsOnHitCancel = false;
};

```

`Source/FightingGame/Input/MovesBufferComponent.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "MovesBufferComponent.h"

#include "imgui.h"
#include "Components/InputComponent.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Combat/InputSequenceResolver.h"
#include "FightingGame/Common/ConversionStatics.h"
#include "FightingGame/Common/MathStatics.h"
#include "FightingGame/Debugging/Debug.h"
#include "Kismet/KismetSystemLibrary.h"

namespace
{
    int32 loc_ShowInputBuffer = 0;
    FG_CVAR_FLAG_DESC( CVarShowInputBuffer, TEXT( "MovesBufferComponent.ShowInputBuffer" ), loc_ShowInputBuffer );

    int32 loc_ShowInputsSequenceBuffer = 0;
    FG_CVAR_FLAG_DESC( CVarShowMovesBuffer, TEXT( "MovesBufferComponent.ShowInputsSequenceBuffer" ), loc_ShowInputsSequenceBuffer );

    int32 loc_ShowDirectionalAngle = 0;
    FG_CVAR_FLAG_DESC( CVarShowDirectionalAngle, TEXT("MovesBufferComponent.ShowDirectionalAngle"), loc_ShowDirectionalAngle );

    int32 loc_ShowHoldInputsMap = 0;
    FG_CVAR_FLAG_DESC( CVarShowHoldInputsMap, TEXT("MovesBufferComponent.ShowHoldInputsMap"), loc_ShowHoldInputsMap );

    FName loc_JumpAction           = TEXT( "Jump" );
    FName loc_AttackAction         = TEXT( "Attack" );
    FName loc_SpecialAction        = TEXT( "Special" );
    FName loc_MoveHorizontalAction = TEXT( "MoveHorizontal" );
    FName loc_MoveVerticalAction   = TEXT( "MoveVertical" );
    FName loc_CounterAction        = TEXT( "Counter" );

    int32 loc_MaxEntryId                 = 1000;
    int32 loc_CurrentBufferEntryUniqueId = 0;
}

FBufferEntry::FBufferEntry( bool Used ): m_Used( Used )
{
    if( loc_CurrentBufferEntryUniqueId < loc_MaxEntryId )
    {
        ++loc_CurrentBufferEntryUniqueId;
    }
    else
    {
        loc_CurrentBufferEntryUniqueId = 0;
    }

    m_UniqueId = loc_CurrentBufferEntryUniqueId;
}

FInputBufferEntry::FInputBufferEntry( EInputEntry InputEntry, EInputPhase Phase, bool Used ) :
    FBufferEntry( Used ),
    m_InputEntry( InputEntry ),
    m_Phase( Phase )
{
}

FInputsSequenceBufferEntry::FInputsSequenceBufferEntry( const FString& InputsSequenceName, int32 Priority, bool Used ) :
    FBufferEntry( Used ),
    m_InputsSequenceName( InputsSequenceName ),
    m_Priority( Priority )
{
}

UMovesBufferComponent::UMovesBufferComponent()
{
    PrimaryComponentTick.bCanEverTick = true;
}

void UMovesBufferComponent::BeginPlay()
{
    Super::BeginPlay();

    m_InputSequenceResolver = m_InputSequenceResolverClass
                                  ? NewObject<UInputSequenceResolver>( GetOwner(), m_InputSequenceResolverClass )
                                  : NewObject<UInputSequenceResolver>( GetOwner() );

    m_InputSequenceResolver->m_InputRouteEndedDelegate.AddUObject( this, &UMovesBufferComponent::OnInputRouteEnded );

    m_InputSequenceResolver->Init( m_InputsList );
}

void UMovesBufferComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )
{
    Super::TickComponent( DeltaTime, TickType, ThisTickFunction );

    m_IBElapsedFrameTime += DeltaTime;

    static float bufferFrameDuration = 1.f / m_InputBufferFrameRate;
    if( m_IBElapsedFrameTime >= bufferFrameDuration )
    {
        m_IBElapsedFrameTime = 0.f;

        if( !m_IBBufferChanged )
        {
            AddToInputBuffer( EInputEntry::None, EInputPhase::Pressed );
        }

        for( TTuple<EInputEntry, FHoldInputBufferData>& pair : m_HoldInputsMap )
        {
            if( !pair.Value.m_Expired )
            {
                ++pair.Value.m_ElapsedFrames;
            }
        }

        using HoldInputsMapType = TMap<EInputEntry, FHoldInputBufferData>;
        for( HoldInputsMapType::TIterator it = m_HoldInputsMap.CreateIterator(); it; ++it )
        {
            if( (*it).Value.m_Expired )
            {
                it.RemoveCurrent();
            }
        }
    }

    m_ISBElapsedFrameTime += DeltaTime;

    static float movesBufferFrameDuration = 1.f / m_InputsSequencesBufferFrameRate;
    if( m_ISBElapsedFrameTime >= movesBufferFrameDuration )
    {
        m_ISBElapsedFrameTime = 0.f;
        if( !m_ISBBufferChanged )
        {
            AddToInputsSequenceBuffer( FInputsSequenceBufferEntry::s_SequenceNone, 0 );
        }
    }

    if( loc_ShowInputBuffer )
    {
        if( m_OwnerCharacter && m_OwnerCharacter->m_PlayerIndex == 0 )
        {
            for( int32 i = 0; i < m_InputsBuffer.Num(); ++i )
            {
                FInputBufferEntry& entry = m_InputsBuffer[i];
                FColor color             = entry.m_Used ? FColor::Red : FColor::Green;

                FG_SLOG_KEY( i, FString::Printf( TEXT( "%s [%u]" ), *entry.ToString(), entry.m_UniqueId ), color );
            }
        }
    }

    if( loc_ShowInputsSequenceBuffer )
    {
        if( m_OwnerCharacter && m_OwnerCharacter->m_PlayerIndex == 0 )
        {
            for( int32 i = 0; i < m_InputsSequenceBuffer.Num(); ++i )
            {
                FInputsSequenceBufferEntry& entry = m_InputsSequenceBuffer[i];
                FColor color                      = entry.m_Used ? FColor::Red : FColor::Green;

                FG_SLOG_KEY( i + 20, FString::Printf( TEXT( "%s [%u]" ), *entry.ToString(), entry.m_UniqueId ), color );
            }
        }
    }

    if( loc_ShowHoldInputsMap )
    {
        FString title = FString::Printf( TEXT( "Hold Inputs (%s)" ), *m_OwnerCharacter->GetName() );
        ImGui::Begin( TCHAR_TO_ANSI( *title ) );
        {
            for( const auto& pair : m_HoldInputsMap )
            {
                if( !pair.Value.m_Expired )
                {
                    FString entryStringified = UConversionStatics::ConvertEnumValueToString( pair.Key );
                    FString text             = FString::Printf( TEXT( "%s - %u" ), *entryStringified, pair.Value.m_ElapsedFrames );

                    ImGui::Text( TCHAR_TO_ANSI( *text ) );
                }
            }
        }
        ImGui::End();
    }

    m_IBBufferChanged  = false;
    m_ISBBufferChanged = false;

    UpdateMovementDirection();

    if( m_PlayerInput )
    {
        float horizontalMovement = m_PlayerInput->GetAxisValue( loc_MoveHorizontalAction );

        m_InputMovement = horizontalMovement;

        m_MovingRight = horizontalMovement > m_AnalogMovementDeadzone;
        m_MovingLeft  = horizontalMovement < -m_AnalogMovementDeadzone;

        UpdateDirectionalInputs( m_PlayerInput );
    }
}

void UMovesBufferComponent::OnSetupPlayerInputComponent( UInputComponent* PlayerInputComponent )
{
    m_PlayerInput = PlayerInputComponent;
    if( m_PlayerInput )
    {
        m_PlayerInput->BindAction( loc_JumpAction, IE_Pressed, this, &UMovesBufferComponent::OnJumpPressed );
        m_PlayerInput->BindAction( loc_JumpAction, IE_Released, this, &UMovesBufferComponent::OnJumpReleased );

        m_PlayerInput->BindAction( loc_AttackAction, IE_Pressed, this, &UMovesBufferComponent::OnAttackPressed );
        m_PlayerInput->BindAction( loc_AttackAction, IE_Released, this, &UMovesBufferComponent::OnAttackReleased );

        m_PlayerInput->BindAction( loc_SpecialAction, IE_Pressed, this, &UMovesBufferComponent::OnSpecialPressed );
        m_PlayerInput->BindAction( loc_SpecialAction, IE_Released, this, &UMovesBufferComponent::OnSpecialReleased );

        m_PlayerInput->BindAction( loc_CounterAction, IE_Pressed, this, &UMovesBufferComponent::OnCounterPressed );
        m_PlayerInput->BindAction( loc_CounterAction, IE_Released, this, &UMovesBufferComponent::OnCounterReleased );

        m_PlayerInput->BindAxis( loc_MoveHorizontalAction );
        m_PlayerInput->BindAxis( loc_MoveVerticalAction );
    }

    InitInputBuffer();

    InitInputsSequenceBuffer();
}

bool UMovesBufferComponent::IsInputBuffered( EInputEntry Input, bool ConsumeEntry )
{
    for( int32 i = 0; i < m_InputsBuffer.Num(); ++i )
    {
        FInputBufferEntry& entry = m_InputsBuffer[i];
        if( entry.m_InputEntry != EInputEntry::None && entry.m_InputEntry == Input && !entry.m_Used )
        {
            if( ConsumeEntry )
            {
                entry.m_Used = true;
            }
            return true;
        }
    }

    return false;
}

float UMovesBufferComponent::GetMovementDirection() const
{
    return m_MovementDirection;
}

float UMovesBufferComponent::GetMovementStrength() const
{
    return FMath::Abs( m_InputMovement );
}

EInputEntry UMovesBufferComponent::GetDirectionalInputEntryFromAngle( float Angle ) const
{
    // Assuming the character is facing right

    static float forwardAngle = 90.f;
    static float downAngle    = 180.f;
    static float backAngle    = -90.f;
    static float upAngle      = 0.f;

    // Up
    if( Angle > upAngle - m_DirectionalChangeRotationEpsilon && Angle < upAngle + m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::Up;
    }

    // Up-forward
    if( Angle >= upAngle + m_DirectionalChangeRotationEpsilon && Angle < forwardAngle - m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::UpForward;
    }

    // Forward
    if( Angle > forwardAngle - m_DirectionalChangeRotationEpsilon && Angle < forwardAngle + m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::Forward;
    }

    // Forward-down
    if( Angle >= forwardAngle + m_DirectionalChangeRotationEpsilon && Angle < downAngle - m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::ForwardDown;
    }

    // Down
    if( (Angle >= downAngle && Angle >= downAngle - m_DirectionalChangeRotationEpsilon) ||
        (Angle > -downAngle && Angle < -downAngle + m_DirectionalChangeRotationEpsilon) )
    {
        return EInputEntry::Down;
    }

    // Down-back
    if( Angle > -downAngle + m_DirectionalChangeRotationEpsilon && Angle < backAngle - m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::DownBackward;
    }

    // Back
    if( Angle > backAngle - m_DirectionalChangeRotationEpsilon && Angle < backAngle + m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::Backward;
    }

    // Back-Up
    if( Angle >= backAngle + m_DirectionalChangeRotationEpsilon && Angle < upAngle - m_DirectionalChangeRotationEpsilon )
    {
        return EInputEntry::BackwardUp;
    }

    return EInputEntry::None;
}

void UMovesBufferComponent::OnInputRouteEnded( TObjectPtr<UInputsSequence> InputsSequence )
{
    AddToInputsSequenceBuffer( InputsSequence->m_Name, InputsSequence->m_Priority );
}

void UMovesBufferComponent::AddToInputBuffer( EInputEntry InputEntry, EInputPhase Phase )
{
    EInputEntry targetEntry = m_OwnerCharacter->IsFacingRight() ? InputEntry : MirrorInputEntry( InputEntry );

    m_InputsBuffer.Emplace( FInputBufferEntry( targetEntry, Phase, false ) );
    m_InputsBuffer.RemoveAt( 0 );

    m_IBBufferChanged = true;

    if( InputEntry != EInputEntry::None )
    {
        auto result = m_InputSequenceResolver->RegisterInput( targetEntry );

        switch( result )
        {
            case EInputRegistrationResult::InputNotFound:
                {
                    m_InputSequenceResolver->RegisterInput( targetEntry );
                    break;
                }

            default: break;
        }
    }
}

bool UMovesBufferComponent::InputBufferContainsConsumable( EInputEntry InputEntry ) const
{
    for( const FInputBufferEntry& entry : m_InputsBuffer )
    {
        if( entry.m_InputEntry == InputEntry && !entry.m_Used )
        {
            return true;
        }
    }

    return false;
}

void UMovesBufferComponent::AddToInputsSequenceBuffer( const FString& InputsSequenceName, int32 Priority )
{
    m_InputsSequenceBuffer.Emplace( FInputsSequenceBufferEntry( InputsSequenceName, Priority, false ) );
    m_InputsSequenceBuffer.RemoveAt( 0 );

    m_ISBBufferChanged = true;
}

bool UMovesBufferComponent::InputsSequenceBufferContainsConsumable( const FString& MoveName )
{
    for( const FInputsSequenceBufferEntry& entry : m_InputsSequenceBuffer )
    {
        if( entry.m_InputsSequenceName == MoveName && !entry.m_Used )
        {
            return true;
        }
    }

    return false;
}

void UMovesBufferComponent::AddUniqueToHoldInputsMap( EInputEntry InputEntry )
{
    if( !m_HoldInputsMap.Contains( InputEntry ) )
    {
        m_HoldInputsMap.Emplace( InputEntry );
    }
}

void UMovesBufferComponent::RemoveFromHoldInputsMap( EInputEntry InputEntry )
{
    if( m_HoldInputsMap.Contains( InputEntry ) )
    {
        m_HoldInputsMap[InputEntry].m_Expired = true;
    }
}

void UMovesBufferComponent::ClearInputsBuffer()
{
    m_InputsBuffer.Empty();
}

void UMovesBufferComponent::InitInputBuffer()
{
    ClearInputsBuffer();

    for( int32 i = 0; i < m_InputBufferSizeFrames; ++i )
    {
        m_InputsBuffer.Emplace( FInputBufferEntry( EInputEntry::None, EInputPhase::Pressed, false ) );
    }
}

void UMovesBufferComponent::UseBufferedInputsSequence( const FString& InputsSequenceName )
{
    verify( InputsSequenceBufferContainsConsumable( InputsSequenceName ) );

    for( FInputsSequenceBufferEntry& entry : m_InputsSequenceBuffer )
    {
        if( entry.m_InputsSequenceName == InputsSequenceName )
        {
            entry.m_Used = true;
        }
    }
}

void UMovesBufferComponent::UseBufferedInputsSequence( const FInputsSequenceBufferEntry& Entry, bool UseId )
{
    for( FInputsSequenceBufferEntry& entry : m_InputsSequenceBuffer )
    {
        if( UseId )
        {
            if( entry.m_UniqueId == Entry.m_UniqueId )
            {
                entry.m_Used = true;
            }
        }
        else
        {
            if( entry.m_InputsSequenceName == Entry.m_InputsSequenceName )
            {
                entry.m_Used = true;
            }
        }
    }
}

void UMovesBufferComponent::ClearInputsSequenceBuffer()
{
    m_InputsSequenceBuffer.Empty();
}

void UMovesBufferComponent::InitInputsSequenceBuffer()
{
    ClearInputsSequenceBuffer();

    for( int i = 0; i < m_InputsSequencesBufferSizeFrames; ++i )
    {
        m_InputsSequenceBuffer.Emplace( FInputsSequenceBufferEntry( FInputsSequenceBufferEntry::s_SequenceNone, 0, false ) );
    }
}

void UMovesBufferComponent::GetInputsSequenceBufferSnapshot( TArray<FInputsSequenceBufferEntry>& OutEntries, bool SkipEmptyEntries, bool SkipUsedEntries,
                                                             bool UniqueEntries )
{
    OutEntries.Reset();

    for( const auto& entry : m_InputsSequenceBuffer )
    {
        bool currentEntryIsNone = entry.m_InputsSequenceName == FInputsSequenceBufferEntry::s_SequenceNone;

        if( SkipEmptyEntries && currentEntryIsNone )
        {
            continue;
        }

        if( SkipUsedEntries && entry.m_Used )
        {
            continue;
        }

        if( UniqueEntries )
        {
            auto predIsUniqueEntry = [&]( const FInputsSequenceBufferEntry& _entry )
            {
                return _entry.m_InputsSequenceName == entry.m_InputsSequenceName;
            };

            if( !OutEntries.ContainsByPredicate( predIsUniqueEntry ) )
            {
                OutEntries.Emplace( entry );
            }
        }
        else
        {
            OutEntries.Emplace( entry );
        }
    }
}

bool UMovesBufferComponent::IsInputsSequenceBuffered( const FString& InputsSequenceName, bool ConsumeEntry /*= true*/ )
{
    for( int32 i = 0; i < m_InputsSequenceBuffer.Num(); ++i )
    {
        FInputsSequenceBufferEntry& entry = m_InputsSequenceBuffer[i];

        bool isValid     = entry.m_InputsSequenceName != FInputsSequenceBufferEntry::s_SequenceNone;
        bool hasSameName = entry.m_InputsSequenceName == InputsSequenceName;
        bool canBeUsed   = !entry.m_Used;

        if( isValid && hasSameName && canBeUsed )
        {
            if( ConsumeEntry )
            {
                entry.m_Used = true;
            }

            return true;
        }
    }

    return false;
}

void UMovesBufferComponent::OnMoveHorizontal( float Value )
{
    if( FMath::Abs( Value ) > m_AnalogMovementDeadzone )
    {
        m_InputMovement = Value;

        m_MovingRight = FMath::Sign( Value ) > 0;
        m_MovingLeft  = FMath::Sign( Value ) < 0;
    }
}

// TODO: these are all the same, make it generic maybe?
void UMovesBufferComponent::OnJumpPressed()
{
    AddToInputBuffer( EInputEntry::Jump, EInputPhase::Pressed );
    AddUniqueToHoldInputsMap( EInputEntry::Jump );
}

void UMovesBufferComponent::OnJumpReleased()
{
    RemoveFromHoldInputsMap( EInputEntry::Jump );
}

void UMovesBufferComponent::OnAttackPressed()
{
    AddToInputBuffer( EInputEntry::Attack, EInputPhase::Pressed );
    AddUniqueToHoldInputsMap( EInputEntry::Attack );
}

void UMovesBufferComponent::OnAttackReleased()
{
    RemoveFromHoldInputsMap( EInputEntry::Attack );
}

void UMovesBufferComponent::OnSpecialPressed()
{
    AddToInputBuffer( EInputEntry::Special, EInputPhase::Pressed );
    AddUniqueToHoldInputsMap( EInputEntry::Special );
}

void UMovesBufferComponent::OnSpecialReleased()
{
    RemoveFromHoldInputsMap( EInputEntry::Special );
}

void UMovesBufferComponent::OnCounterPressed()
{
    AddToInputBuffer( EInputEntry::Counter, EInputPhase::Pressed );
    AddUniqueToHoldInputsMap( EInputEntry::Counter );
}

void UMovesBufferComponent::OnCounterReleased()
{
    RemoveFromHoldInputsMap( EInputEntry::Counter );
}

void UMovesBufferComponent::UpdateMovementDirection()
{
    if( (m_MovingRight && m_MovingLeft) || (!m_MovingRight && !m_MovingLeft) )
    {
        m_MovementDirection = 0.f;
    }
    else
    {
        if( m_MovingRight )
        {
            m_MovementDirection = 1.f;
        }
        else if( m_MovingLeft )
        {
            m_MovementDirection = -1.f;
        }
    }
}

void UMovesBufferComponent::UpdateDirectionalInputs( UInputComponent* InputComponent )
{
    m_DirectionalInputVector.X = InputComponent->GetAxisValue( TEXT( "MoveHorizontal" ) );
    m_DirectionalInputVector.Y = InputComponent->GetAxisValue( TEXT( "MoveVertical" ) );

    if( m_DirectionalInputVector.Length() > m_MinDirectionalInputVectorLength )
    {
        float angle       = UMathStatics::GetSignedAngle( m_DirectionalInputVector, FVector2d( 0.f, 1.f ) );
        EInputEntry entry = GetDirectionalInputEntryFromAngle( angle );

        if( loc_ShowDirectionalAngle )
        {
            FG_TEXT( GetWorld(), GetOwner()->GetActorLocation(),
                     FString::Printf( TEXT( "[Input: %s]" ), *UConversionStatics::ConvertEnumValueToString( entry, false ) ) );
        }

        if( entry != m_LastDirectionalInputEntry )
        {
            m_LastDirectionalInputEntry = entry;

            AddToInputBuffer( entry, EInputPhase::Pressed );
        }
    }
    else
    {
        if( m_LastDirectionalInputEntry != EInputEntry::Neutral )
        {
            m_LastDirectionalInputEntry = EInputEntry::Neutral;

            AddToInputBuffer( EInputEntry::Neutral, EInputPhase::Pressed );
        }
    }

    m_LastDirectionalInputVector = m_DirectionalInputVector;
}

void UMovesBufferComponent::UseBufferedInput( EInputEntry Input )
{
    verify( InputBufferContainsConsumable( Input ) );

    for( FInputBufferEntry& entry : m_InputsBuffer )
    {
        if( entry.m_InputEntry == Input )
        {
            entry.m_Used = true;
        }
    }
}

void UMovesBufferComponent::UseBufferedInput( int32 UniqueId )
{
}

```

`Source/FightingGame/Input/MovesBufferComponent.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"

#include "InputEntry.h"
#include "InputPhase.h"
#include "FightingGame/Common/ConversionStatics.h"
#include "MovesBufferComponent.generated.h"

class UDataTable;
class AFightingCharacter;
class UInputComponent;
class UInputsSequence;
class UInputSequenceResolver;

struct FBufferEntry
{
    explicit FBufferEntry( bool Used );

    virtual ~FBufferEntry() = default;

    int32 m_UniqueId = 0;
    bool m_Used;

    virtual FString ToString() = 0;
};

struct FInputBufferEntry : public FBufferEntry
{
    explicit FInputBufferEntry( EInputEntry InputEntry, EInputPhase Phase, bool Used );

    EInputEntry m_InputEntry;
    EInputPhase m_Phase;

    virtual FORCEINLINE FString ToString() override
    {
        return m_InputEntry == EInputEntry::None ? TEXT( "---" ) : UConversionStatics::ConvertEnumValueToString( m_InputEntry, false );
    }
};

struct FInputsSequenceBufferEntry : public FBufferEntry
{
    explicit FInputsSequenceBufferEntry( const FString& InputsSequenceName, int32 Priority, bool Used );

    FString m_InputsSequenceName;
    int32 m_Priority;

    inline static FString s_SequenceNone = FString( TEXT( "" ) );

    virtual FORCEINLINE FString ToString() override
    {
        return m_InputsSequenceName == s_SequenceNone ? TEXT( "---" ) : m_InputsSequenceName;
    }
};

struct FHoldInputBufferData
{
    int32 m_ElapsedFrames = 0;
    bool m_Expired        = false;
};

UCLASS( ClassGroup = ( Custom ), meta = ( BlueprintSpawnableComponent ) )
class FIGHTINGGAME_API UMovesBufferComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UMovesBufferComponent();

    TObjectPtr<AFightingCharacter> m_OwnerCharacter = nullptr;

    // INPUT BUFFER [BEGIN]
    void UseBufferedInput( EInputEntry Input );
    void UseBufferedInput( int32 UniqueId );
    bool IsInputBuffered( EInputEntry Input, bool ConsumeEntry = true );
    void ClearInputsBuffer();
    void InitInputBuffer();
    // INPUT BUFER [END]

    // MOVES BUFFER [BEGIN]
    void UseBufferedInputsSequence( const FString& InputsSequenceName );
    void UseBufferedInputsSequence( const FInputsSequenceBufferEntry& Entry, bool UseId );
    bool IsInputsSequenceBuffered( const FString& InputsSequenceName, bool ConsumeEntry = true );
    void ClearInputsSequenceBuffer();
    void InitInputsSequenceBuffer();
    void GetInputsSequenceBufferSnapshot( TArray<FInputsSequenceBufferEntry>& OutEntries, bool SkipEmptyEntries, bool SkipUsedEntries, bool UniqueEntries );
    // MOVES BUFFER [END]

    UPROPERTY( BlueprintReadOnly, DisplayName = "Input Movement" )
    float m_InputMovement = 0.f;

    UPROPERTY( BlueprintReadOnly, DisplayName = "Moving Right" )
    bool m_MovingRight = false;

    UPROPERTY( BlueprintReadOnly, DisplayName = "Moving Left" )
    bool m_MovingLeft = false;

    UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Inputs To States Data Table" )
    TObjectPtr<UDataTable> m_InputsToStatesDataTable = nullptr;

protected:
    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Inputs Buffer Size Frames" )
    int32 m_InputBufferSizeFrames = 6;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Inputs Sequence Buffer Size Frames" )
    int32 m_InputsSequencesBufferSizeFrames = 10;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Input Buffer Frame Rate (FPS)" )
    float m_InputBufferFrameRate = 30;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Inputs Sequence Buffer Frame Rate (FPS)" )
    float m_InputsSequencesBufferFrameRate = 30;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Analog Movement Deadzone" )
    float m_AnalogMovementDeadzone = 0.1f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Directional Input Min Vector Length" )
    float m_MinDirectionalInputVectorLength = .5f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Directional Change Rotation Epsilon" )
    float m_DirectionalChangeRotationEpsilon = 15.f;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Inputs List" )
    TArray<TObjectPtr<UInputsSequence>> m_InputsList;

    UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Input Sequence Resolver" )
    TSubclassOf<UInputSequenceResolver> m_InputSequenceResolverClass = nullptr;

    virtual void BeginPlay() override;

public:
    virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;

    void OnSetupPlayerInputComponent( UInputComponent* PlayerInputComponent );

    UFUNCTION( BlueprintCallable )
    float GetMovementDirection() const;

    /*
     * Returns a value from 0 to 1 indicating the "strength" of the movement input
     */
    UFUNCTION(BlueprintCallable)
    float GetMovementStrength() const;

private:
    UPROPERTY()
    UInputComponent* m_PlayerInput = nullptr;

    UPROPERTY()
    TObjectPtr<UInputSequenceResolver> m_InputSequenceResolver = nullptr;

    TArray<FInputBufferEntry> m_InputsBuffer;
    float m_IBElapsedFrameTime = 0.f;
    bool m_IBBufferChanged     = false;

    TArray<FInputsSequenceBufferEntry> m_InputsSequenceBuffer;
    float m_ISBElapsedFrameTime = 0.f;
    bool m_ISBBufferChanged     = false;

    TMap<EInputEntry, FHoldInputBufferData> m_HoldInputsMap;

    float m_MovementDirection = 0.f;

    FVector2D m_LastDirectionalInputVector;
    FVector2D m_DirectionalInputVector;
    EInputEntry m_LastDirectionalInputEntry = EInputEntry::Neutral;

    void AddToInputBuffer( EInputEntry InputEntry, EInputPhase Phase );
    bool InputBufferContainsConsumable( EInputEntry InputEntry ) const;

    void AddToInputsSequenceBuffer( const FString& InputsSequenceName, int32 Priority );
    bool InputsSequenceBufferContainsConsumable( const FString& MoveName );

    void AddUniqueToHoldInputsMap( EInputEntry InputEntry );
    void RemoveFromHoldInputsMap( EInputEntry InputEntry );

    void OnMoveHorizontal( float Value );

    void OnJumpPressed();
    void OnJumpReleased();

    void OnAttackPressed();
    void OnAttackReleased();

    void OnSpecialPressed();
    void OnSpecialReleased();

    void OnCounterPressed();
    void OnCounterReleased();

    void UpdateMovementDirection();
    void UpdateDirectionalInputs( UInputComponent* InputComponent );
    EInputEntry GetDirectionalInputEntryFromAngle( float Angle ) const;

    void OnInputRouteEnded( TObjectPtr<UInputsSequence> InputsSequence );
};

```

`Source/FightingGame/PlayerController/FightingGameCheatManager.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "FightingGameCheatManager.h"

```

`Source/FightingGame/PlayerController/FightingGameCheatManager.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/CheatManager.h"
#include "UObject/Object.h"
#include "FightingGameCheatManager.generated.h"

UCLASS()
class FIGHTINGGAME_API UFightingGameCheatManager : public UCheatManager
{
	GENERATED_BODY()
};

```

`Source/FightingGame/PlayerController/FightingGamePlayerController.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "FightingGamePlayerController.h"

```

`Source/FightingGame/PlayerController/FightingGamePlayerController.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "FightingGamePlayerController.generated.h"

UCLASS()
class FIGHTINGGAME_API AFightingGamePlayerController : public APlayerController
{
	GENERATED_BODY()
};

```

`Source/FightingGame/Projectile/Projectile.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "Projectile.h"

#include "Components/SphereComponent.h"
#include "FightingGame/Combat/HitboxHandlerComponent.h"
#include "FightingGame/Debugging/Debug.h"
#include "Kismet/KismetSystemLibrary.h"

namespace
{
    int32 loc_ProjectileDebugFacing = 0;
    FG_CVAR_FLAG_DESC( CVarProjectileDebugFacing, TEXT("Projectile.DebugFacing"), loc_ProjectileDebugFacing );
}

AProjectile::AProjectile()
{
    PrimaryActorTick.bCanEverTick = true;

    m_MainCollision = CreateDefaultSubobject<USphereComponent>( TEXT( "Main Collision" ) );
    RootComponent   = m_MainCollision;

    m_HitboxHandler = CreateDefaultSubobject<UHitboxHandlerComponent>( TEXT( "Hitbox Handler" ) );
}

void AProjectile::Init( TObjectPtr<AActor> OwnerActor, FVector Location, float HorizontalDirectionMultiplier, float BaseSpeed, float Lifetime /* = -1.f*/ )
{
    m_Owner                         = OwnerActor;
    m_HorizontalDirectionMultiplier = HorizontalDirectionMultiplier;
    m_BaseSpeed                     = BaseSpeed;
    m_Lifetime                      = Lifetime;

    GetHitboxHandlerComponent()->m_AdditionalActorsToIgnore.Emplace( m_Owner );

    TeleportTo( Location, FRotator::ZeroRotator );

    if( m_Lifetime > 0.f )
    {
        GetWorldTimerManager().SetTimer( m_LifetimeTimerHandle, this, &AProjectile::OnLifetimeTimerEnded, m_Lifetime );
    }

    GetHitboxHandlerComponent()->m_HitDelegate.AddUObject( this, &AProjectile::OnHitLanded );
    GetHitboxHandlerComponent()->SpawnDefaultHitboxes();
}

bool AProjectile::IsFacingRight()
{
    return m_HorizontalDirectionMultiplier > 0.f;
}

void AProjectile::SetFacingRight( bool /*Right*/, bool /*Instant*/ )
{
}

FVector AProjectile::GetLocation()
{
    return GetActorLocation();
}

void AProjectile::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );

    FVector currentLocation = GetActorLocation();
    currentLocation.Y += (m_HorizontalDirectionMultiplier * m_BaseSpeed * DeltaTime);

    SetActorLocation( currentLocation );

    if( loc_ProjectileDebugFacing )
    {
        FG_TEXT( GetWorld(), GetActorLocation(), FString::Printf( TEXT( "[Facing Right: %s]" ), IsFacingRight() ? TEXT( "TRUE" ) : TEXT( "FALSE" ) ) );
    }
}

void AProjectile::OnLifetimeTimerEnded()
{
    m_DestroyRequestedDelegate.Broadcast( this );
}

void AProjectile::OnHitLanded( TObjectPtr<AActor> /*Target*/, const HitData& /*HitData*/ )
{
    m_DestroyRequestedDelegate.Broadcast( this );
}

```

`Source/FightingGame/Projectile/Projectile.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingGame/Combat/FacingEntity.h"
#include "FightingGame/Combat/Hittable.h"
#include "GameFramework/Actor.h"
#include "Projectile.generated.h"

class UHitboxHandlerComponent;
class USphereComponent;

DECLARE_MULTICAST_DELEGATE_OneParam( FDestroyRequested, TObjectPtr<AProjectile> )

UCLASS()
class FIGHTINGGAME_API AProjectile : public AActor, public IFacingEntity
{
	GENERATED_BODY()

public:
	AProjectile();

	FDestroyRequested m_DestroyRequestedDelegate;

	void Init( TObjectPtr<AActor> OwnerActor, FVector Location, float HorizontalDirectionMultiplier, float BaseSpeed, float Lifetime = -1.f );

	virtual bool IsFacingRight() override;
	virtual void SetFacingRight( bool Right, bool Instant ) override;
	virtual FVector GetLocation() override;

	FORCEINLINE TObjectPtr<UHitboxHandlerComponent> GetHitboxHandlerComponent() const { return m_HitboxHandler; }

	virtual void Tick( float DeltaTime ) override;

protected:
	UPROPERTY( EditAnywhere, BlueprintReadWrite, DisplayName = "Main Collision" )
	TObjectPtr<USphereComponent> m_MainCollision = nullptr;

	UPROPERTY()
	TObjectPtr<AActor> m_Owner = nullptr;

	/*
	 * -1: Left (negative Y), 1: Right (positive Y)
	 */
	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Horizontal Direction Multiplier" )
	float m_HorizontalDirectionMultiplier = 0.f;

	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Lifetime" )
	float m_Lifetime = -1.f;

	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Base Speed" )
	float m_BaseSpeed = 10.f;

	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Horizontal Speed Multiplier Curve" )
	TObjectPtr<UCurveFloat> m_HorizontalSpeedMultiplierCurve = nullptr;

	UPROPERTY( EditAnywhere, BlueprintReadOnly, DisplayName = "Hitbox Handler" )
	TObjectPtr<UHitboxHandlerComponent> m_HitboxHandler = nullptr;

private:
	FTimerHandle m_LifetimeTimerHandle;
	void OnLifetimeTimerEnded();

	void OnHitLanded( TObjectPtr<AActor> Target, const HitData& HitData );
};

```

`Source/FightingGame/Projectile/ProjectileSpawnerComponent.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "ProjectileSpawnerComponent.h"

#include "Projectile.h"

UProjectileSpawnerComponent::UProjectileSpawnerComponent()
{
	PrimaryComponentTick.bCanEverTick = true;
}

void UProjectileSpawnerComponent::BeginPlay()
{
	Super::BeginPlay();
}

void UProjectileSpawnerComponent::SpawnProjectile( TSubclassOf<AProjectile> ProjectileClass, FVector SpawnLocation, float HorizontalDirectionMultiplier,
                                                   float BaseSpeed, float Lifetime )
{
	ensureMsgf( ProjectileClass, TEXT("Projectile class is null") );

	TObjectPtr<AProjectile> inst = GetWorld()->SpawnActor<AProjectile>( ProjectileClass, SpawnLocation, FRotator::ZeroRotator );
	inst->Init( GetOwner(), SpawnLocation, HorizontalDirectionMultiplier, BaseSpeed, Lifetime );
	inst->m_DestroyRequestedDelegate.AddUObject( this, &UProjectileSpawnerComponent::OnProjectileDestroyRequested );

	m_AliveProjectiles.Emplace( inst );
}

void UProjectileSpawnerComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )
{
	Super::TickComponent( DeltaTime, TickType, ThisTickFunction );
}

void UProjectileSpawnerComponent::OnProjectileDestroyRequested( TObjectPtr<AProjectile> Projectile )
{
	m_AliveProjectiles.Remove( Projectile );

	// #TODO temp
	GetWorld()->DestroyActor( Projectile );
}

```

`Source/FightingGame/Projectile/ProjectileSpawnerComponent.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "ProjectileSpawnerComponent.generated.h"

class AProjectile;

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class FIGHTINGGAME_API UProjectileSpawnerComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UProjectileSpawnerComponent();

protected:
	virtual void BeginPlay() override;

public:
	void SpawnProjectile( TSubclassOf<AProjectile> ProjectileClass, FVector SpawnLocation, float HorizontalDirectionMultiplier, float BaseSpeed, float Lifetime );

	virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;

private:
	TArray<TObjectPtr<AProjectile>> m_AliveProjectiles;

	void OnProjectileDestroyRequested( TObjectPtr<AProjectile> Projectile );
};

```

`Source/FightingGame/Prop/Prop.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "Prop.h"


AProp::AProp()
{
    PrimaryActorTick.bCanEverTick = true;
}

void AProp::BeginPlay()
{
    Super::BeginPlay();
}

void AProp::OnHitReceived( const HitData& HitData )
{
}

bool AProp::IsHittable()
{
    return true;
}

bool AProp::IsBlocking()
{
    return false;
}

void AProp::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );
}

```

`Source/FightingGame/Prop/Prop.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "FightingGame/Combat/Hittable.h"
#include "GameFramework/Actor.h"
#include "Prop.generated.h"

UCLASS()
class FIGHTINGGAME_API AProp : public AActor, public IHittable
{
	GENERATED_BODY()

public:
	AProp();

protected:
	virtual void BeginPlay() override;

public:
	virtual void OnHitReceived( const HitData& HitData ) override;
    virtual bool IsHittable() override;
    virtual bool IsBlocking() override;

	virtual void Tick( float DeltaTime ) override;
};

```

`Source/FightingGame/UI/CharacterHealthBarWidget.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti


#include "CharacterHealthBarWidget.h"

#include "EngineUtils.h"
#include "Components/ProgressBar.h"
#include "Components/TextBlock.h"
#include "FightingGame/Character/FightingCharacter.h"
#include "FightingGame/Debugging/Debug.h"

void UCharacterHealthBarWidget::NativeConstruct()
{
    Super::NativeConstruct();

    for( TActorIterator<AFightingCharacter> it( GetWorld() ); it; ++it )
    {
        if( (*it)->m_PlayerIndex == CharacterNumber )
        {
            m_Character = *it;
            break;
        }
    }

    if( !m_Character )
    {
        FG_SLOG_ERR( TEXT("Could not find player for widget") );
        return;
    }

    NameText->SetText( FText::FromString( m_Character->GetName() ) );
}

void UCharacterHealthBarWidget::NativeTick( const FGeometry& MyGeometry, float InDeltaTime )
{
    Super::NativeTick( MyGeometry, InDeltaTime );

    if( m_Character )
    {
        HPGauge->Percent = m_Character->GetHP() / m_Character->GetInitialHP();
    }
}

```

`Source/FightingGame/UI/CharacterHealthBarWidget.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "CharacterHealthBarWidget.generated.h"

class UProgressBar;
class UTextBlock;
class AFightingCharacter;

UCLASS( Abstract )
class FIGHTINGGAME_API UCharacterHealthBarWidget : public UUserWidget
{
    GENERATED_BODY()

protected:
    UPROPERTY( EditAnywhere, BlueprintReadWrite )
    int32 CharacterNumber = 0;

    UPROPERTY( EditAnywhere, meta=(BindWidget) )
    TObjectPtr<UTextBlock> NameText = nullptr;

    UPROPERTY( EditAnywhere, meta=(BindWidget) )
    TObjectPtr<UProgressBar> HPGauge = nullptr;

    TObjectPtr<AFightingCharacter> m_Character = nullptr;

    virtual void NativeConstruct() override;
    virtual void NativeTick( const FGeometry& MyGeometry, float InDeltaTime ) override;
};

```

`Source/FightingGame/UI/HUDBase.cpp`:

```cpp
// Copyright (c) Giammarco Agazzotti

#include "HUDBase.h"

AHUDBase::AHUDBase()
{
    PrimaryActorTick.bCanEverTick = true;
}

void AHUDBase::BeginPlay()
{
    Super::BeginPlay();
}

void AHUDBase::Tick( float DeltaTime )
{
    Super::Tick( DeltaTime );
}

void AHUDBase::OnReady()
{
}

```

`Source/FightingGame/UI/HUDBase.h`:

```h
// Copyright (c) Giammarco Agazzotti

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "HUDBase.generated.h"

UCLASS()
class FIGHTINGGAME_API AHUDBase : public AHUD
{
    GENERATED_BODY()

public:
    AHUDBase();

protected:
    virtual void BeginPlay() override;

public:
    virtual void Tick( float DeltaTime ) override;

    virtual void OnReady();
};

```

`Source/FightingGameEditor.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class FightingGameEditorTarget : TargetRules
{
	public FightingGameEditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		ExtraModuleNames.AddRange( new string[] { "FightingGame" } );
	}
}

```