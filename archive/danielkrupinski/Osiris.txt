Project Path: arc_danielkrupinski_Osiris_exhdbatc

Source Tree:

```txt
arc_danielkrupinski_Osiris_exhdbatc
├── CMakeLists.txt
├── LICENSE
├── Osiris.sln
├── README.md
├── Source
│   ├── BuildConfig.h
│   ├── CMakeLists.txt
│   ├── CS2
│   │   ├── Classes
│   │   │   ├── CCSPlayer_HostageServices.h
│   │   │   ├── CCSPlayer_WeaponServices.h
│   │   │   ├── CCSWeaponBaseVData.h
│   │   │   ├── CCS_PortraitWorld.h
│   │   │   ├── CCvar.h
│   │   │   ├── CEntitySubclassVDataBase.h
│   │   │   ├── CGameSceneNode.h
│   │   │   ├── CGlowProperty.h
│   │   │   ├── CLoopModeGame.h
│   │   │   ├── CPlantedC4.h
│   │   │   ├── CRenderComponent.h
│   │   │   ├── CSceneObject.h
│   │   │   ├── CSceneSystem.h
│   │   │   ├── CUtlAbstractDelegate.h
│   │   │   ├── CUtlFilenameSymbolTable.h
│   │   │   ├── CUtlLinkedList.h
│   │   │   ├── CUtlMap.h
│   │   │   ├── CUtlString.h
│   │   │   ├── CUtlVector.h
│   │   │   ├── CViewRender.h
│   │   │   ├── C_CSGameRules.h
│   │   │   ├── ClientModeCSNormal.h
│   │   │   ├── Color.h
│   │   │   ├── ConVar.h
│   │   │   ├── ConVarTypes.h
│   │   │   ├── Entities
│   │   │   │   ├── CBaseAnimGraph.h
│   │   │   │   ├── CCSPlayerController.h
│   │   │   │   ├── CEntityInstance.h
│   │   │   │   ├── C_BaseCSGrenadeProjectile.h
│   │   │   │   ├── C_BaseEntity.h
│   │   │   │   ├── C_BaseModelEntity.h
│   │   │   │   ├── C_CSGO_PreviewPlayer.h
│   │   │   │   ├── C_CSPlayerPawn.h
│   │   │   │   ├── C_CSPlayerResource.h
│   │   │   │   ├── C_CSWeaponBase.h
│   │   │   │   ├── C_Hostage.h
│   │   │   │   ├── GrenadeProjectiles.h
│   │   │   │   └── WeaponEntities.h
│   │   │   ├── EntitySystem
│   │   │   │   ├── CConcreteEntityList.h
│   │   │   │   ├── CEntityClass.h
│   │   │   │   ├── CEntityHandle.h
│   │   │   │   ├── CEntityIdentity.h
│   │   │   │   ├── CEntityIndex.h
│   │   │   │   └── CGameEntitySystem.h
│   │   │   ├── FileSystem.h
│   │   │   ├── GlobalVars.h
│   │   │   ├── Glow.h
│   │   │   ├── IMemAlloc.h
│   │   │   ├── SceneObjectUpdaterHandle_t.h
│   │   │   ├── Sound.h
│   │   │   ├── VMatrix.h
│   │   │   └── Vector.h
│   │   ├── Constants
│   │   │   ├── AspectRatio.h
│   │   │   ├── BombsiteIndex.h
│   │   │   ├── ColorConstants.h
│   │   │   ├── CrosshairColorIndex.h
│   │   │   ├── DllNames.h
│   │   │   ├── EntityClasses.h
│   │   │   ├── EntityHandle.h
│   │   │   ├── IconURLs.h
│   │   │   ├── LifeStateConstants.h
│   │   │   ├── PanelIDs.h
│   │   │   ├── RoundWinStatus.h
│   │   │   ├── SceneObjectAttributeNames.h
│   │   │   ├── SoundNames.h
│   │   │   ├── StylePropertySymbolNames.h
│   │   │   ├── StylePropertyTypeNames.h
│   │   │   └── TeamNumberConstants.h
│   │   ├── Econ
│   │   │   ├── ItemDefinitionIndex.h
│   │   │   ├── ItemId.h
│   │   │   └── PaintKitIndex.h
│   │   └── Panorama
│   │       ├── CDropDown.h
│   │       ├── CImagePanel.h
│   │       ├── CLabel.h
│   │       ├── CPanel2D.h
│   │       ├── CPanelStyle.h
│   │       ├── CPanoramaSymbol.h
│   │       ├── CSlider.h
│   │       ├── CStyleSymbol.h
│   │       ├── CTextEntry.h
│   │       ├── CTopLevelWindow.h
│   │       ├── CUIEngine.h
│   │       ├── CUILength.h
│   │       ├── CUIPanel.h
│   │       ├── CUI_3dPanel.h
│   │       ├── CUI_Item3dPanel.h
│   │       ├── PanelHandle.h
│   │       ├── StyleEnums.h
│   │       ├── StyleProperties.h
│   │       └── Transform3D.h
│   ├── Common
│   │   └── Visibility.h
│   ├── Config
│   │   ├── Config.h
│   │   ├── ConfigFileOperation.h
│   │   ├── ConfigFromString.h
│   │   ├── ConfigParams.h
│   │   ├── ConfigSchema.h
│   │   ├── ConfigState.h
│   │   ├── ConfigStringConversionState.h
│   │   ├── ConfigToString.h
│   │   ├── ConfigVariable.h
│   │   ├── ConfigVariableChangeHandler.h
│   │   ├── ConfigVariableTypes.h
│   │   ├── ConfigVariables.h
│   │   └── RangeConstrainedVariableParams.h
│   ├── EntryPoints
│   │   ├── EntryPoints.h
│   │   └── GuiEntryPoints.h
│   ├── Features
│   │   ├── Combat
│   │   │   └── SniperRifles
│   │   │       └── NoScopeInaccuracyVis
│   │   │           ├── NoScopeInaccuracyVis.h
│   │   │           ├── NoScopeInaccuracyVisConfigVariables.h
│   │   │           ├── NoScopeInaccuracyVisParams.h
│   │   │           └── NoScopeInaccuracyVisState.h
│   │   ├── Common
│   │   │   ├── FeatureToggle.h
│   │   │   ├── InWorldPanelIndex.h
│   │   │   ├── InWorldPanelListEntry.h
│   │   │   ├── InWorldPanels.h
│   │   │   ├── InWorldPanelsPerHookState.h
│   │   │   ├── InWorldPanelsState.h
│   │   │   └── RenderingHookEntityLoop.h
│   │   ├── FeaturesStates.h
│   │   ├── Hud
│   │   │   ├── BombPlantAlert
│   │   │   │   ├── BombPlantAlert.h
│   │   │   │   ├── BombPlantAlertConfigVariables.h
│   │   │   │   ├── BombPlantAlertPanelFactory.h
│   │   │   │   ├── BombPlantAlertPanelParams.h
│   │   │   │   ├── BombPlantAlertParams.h
│   │   │   │   └── BombPlantAlertState.h
│   │   │   ├── BombTimer
│   │   │   │   ├── BombSiteIconPanel.h
│   │   │   │   ├── BombTimer.h
│   │   │   │   ├── BombTimerCondition.h
│   │   │   │   ├── BombTimerConfigVariables.h
│   │   │   │   ├── BombTimerContext.h
│   │   │   │   ├── BombTimerPanel.h
│   │   │   │   ├── BombTimerPanelFactory.h
│   │   │   │   ├── BombTimerPanelParams.h
│   │   │   │   ├── BombTimerState.h
│   │   │   │   └── BombTimerTextPanel.h
│   │   │   ├── DefusingAlert
│   │   │   │   ├── DefusingAlert.h
│   │   │   │   ├── DefusingAlertCondition.h
│   │   │   │   ├── DefusingAlertConfigVariables.h
│   │   │   │   ├── DefusingAlertContext.h
│   │   │   │   ├── DefusingAlertPanel.h
│   │   │   │   ├── DefusingAlertPanelParams.h
│   │   │   │   ├── DefusingAlertState.h
│   │   │   │   └── DefusingCountdownTextPanel.h
│   │   │   ├── HudFeaturesStates.h
│   │   │   ├── KillfeedPreserver
│   │   │   │   ├── KillfeedPreserver.h
│   │   │   │   ├── KillfeedPreserverConfigVariables.h
│   │   │   │   └── KillfeedPreserverContext.h
│   │   │   └── PostRoundTimer
│   │   │       ├── PostRoundTimer.h
│   │   │       ├── PostRoundTimerCondition.h
│   │   │       ├── PostRoundTimerConfigVariables.h
│   │   │       ├── PostRoundTimerContext.h
│   │   │       ├── PostRoundTimerPanel.h
│   │   │       ├── PostRoundTimerPanelFactory.h
│   │   │       ├── PostRoundTimerPanelParams.h
│   │   │       └── PostRoundTimerState.h
│   │   ├── Sound
│   │   │   ├── BombBeepVisualizer.h
│   │   │   ├── BombDefuseVisualizer.h
│   │   │   ├── BombPlantVisualizer.h
│   │   │   ├── Details
│   │   │   │   ├── BombBeepSound.h
│   │   │   │   ├── BombDefuseSound.h
│   │   │   │   ├── BombPlantSound.h
│   │   │   │   ├── FootstepSound.h
│   │   │   │   ├── PlayedSound.h
│   │   │   │   ├── SoundExpiryChecker.h
│   │   │   │   ├── SoundVisualization.h
│   │   │   │   ├── SoundVisualizationFeature.h
│   │   │   │   ├── SoundVisualizationPanelFactory.h
│   │   │   │   ├── SoundVisualizationPanelProperties.h
│   │   │   │   ├── SoundWatcher.h
│   │   │   │   ├── SoundWatcherImpl.h
│   │   │   │   ├── SoundWatcherImplState.h
│   │   │   │   ├── SoundWatcherState.h
│   │   │   │   ├── WatchedSounds.h
│   │   │   │   ├── WeaponReloadSound.h
│   │   │   │   └── WeaponScopeSound.h
│   │   │   ├── FootstepVisualizer.h
│   │   │   ├── SoundFeatures.h
│   │   │   ├── SoundVisualizationConfigVariables.h
│   │   │   ├── SoundVisualizationPanelTypes.h
│   │   │   ├── WeaponReloadVisualizer.h
│   │   │   └── WeaponScopeVisualizer.h
│   │   └── Visuals
│   │       ├── ModelGlow
│   │       │   ├── DefuseKitModelGlow
│   │       │   │   └── DefuseKitModelGlow.h
│   │       │   ├── DroppedBombModelGlow
│   │       │   │   └── DroppedBombModelGlow.h
│   │       │   ├── GrenadeProjectileModelGlow
│   │       │   │   └── GrenadeProjectileModelGlow.h
│   │       │   ├── ModelGlow.h
│   │       │   ├── ModelGlowConfigVariables.h
│   │       │   ├── ModelGlowDeactivationFlags.h
│   │       │   ├── ModelGlowParams.h
│   │       │   ├── ModelGlowState.h
│   │       │   ├── PlayerModelGlow
│   │       │   │   └── PlayerModelGlow.h
│   │       │   ├── Preview
│   │       │   │   ├── BaseEntityForModelGlowPreview.h
│   │       │   │   ├── EnemyTeam.h
│   │       │   │   ├── PlayerControllerForModelGlowPreview.h
│   │       │   │   ├── PlayerModelGlowPreview.h
│   │       │   │   ├── PlayerModelGlowPreviewColorMode.h
│   │       │   │   ├── PlayerModelGlowPreviewParams.h
│   │       │   │   ├── PlayerModelGlowPreviewState.h
│   │       │   │   ├── PlayerPawnForModelGlowPreview.h
│   │       │   │   ├── WeaponModelGlowPreview.h
│   │       │   │   └── WeaponModelGlowPreviewState.h
│   │       │   ├── TickingBombModelGlow
│   │       │   │   └── TickingBombModelGlow.h
│   │       │   └── WeaponModelGlow
│   │       │       └── WeaponModelGlow.h
│   │       ├── OutlineGlow
│   │       │   ├── DefuseKitOutlineGlow
│   │       │   │   └── DefuseKitOutlineGlow.h
│   │       │   ├── DroppedBombOutlineGlow
│   │       │   │   └── DroppedBombOutlineGlow.h
│   │       │   ├── GrenadeProjectileOutlineGlow
│   │       │   │   └── GrenadeProjectileOutlineGlow.h
│   │       │   ├── HostageOutlineGlow
│   │       │   │   └── HostageOutlineGlow.h
│   │       │   ├── OutlineGlow.h
│   │       │   ├── OutlineGlowConfigVariables.h
│   │       │   ├── OutlineGlowParams.h
│   │       │   ├── PlayerOutlineGlow
│   │       │   │   ├── PlayerOutlineGlow.h
│   │       │   │   └── PlayerOutlineGlowColorType.h
│   │       │   ├── TickingBombOutlineGlow
│   │       │   │   └── TickingBombOutlineGlow.h
│   │       │   └── WeaponOutlineGlow
│   │       │       └── WeaponOutlineGlow.h
│   │       ├── PlayerInfoInWorld
│   │       │   ├── ActiveWeaponAmmo
│   │       │   │   ├── ActiveWeaponAmmoPanelParams.h
│   │       │   │   ├── PlayerActiveWeaponAmmoPanel.h
│   │       │   │   └── PlayerActiveWeaponAmmoPanelContext.h
│   │       │   ├── PlayerHealth
│   │       │   │   ├── PlayerHealthPanel.h
│   │       │   │   ├── PlayerHealthPanelContext.h
│   │       │   │   └── PlayerHealthPanelParams.h
│   │       │   ├── PlayerInfoContainerPanelParams.h
│   │       │   ├── PlayerInfoInWorld.h
│   │       │   ├── PlayerInfoInWorldCondition.h
│   │       │   ├── PlayerInfoInWorldConfigVariables.h
│   │       │   ├── PlayerInfoInWorldContext.h
│   │       │   ├── PlayerInfoInWorldPanelFactory.h
│   │       │   ├── PlayerInfoInWorldState.h
│   │       │   ├── PlayerInfoPanel.h
│   │       │   ├── PlayerInfoPanelCache.h
│   │       │   ├── PlayerInfoPanelCacheEntry.h
│   │       │   ├── PlayerInfoPanelCachePerHookState.h
│   │       │   ├── PlayerInfoPanelCacheState.h
│   │       │   ├── PlayerInfoPanelTypes.h
│   │       │   ├── PlayerPositionArrow
│   │       │   │   ├── PlayerPositionArrowColorType.h
│   │       │   │   ├── PlayerPositionArrowPanel.h
│   │       │   │   ├── PlayerPositionArrowPanelContext.h
│   │       │   │   └── PlayerPositionArrowPanelParams.h
│   │       │   ├── PlayerStateIcons
│   │       │   │   ├── PlayerStateIconsPanel.h
│   │       │   │   ├── PlayerStateIconsPanelContext.h
│   │       │   │   ├── PlayerStateIconsPanelParams.h
│   │       │   │   └── PlayerStateIconsToShow.h
│   │       │   └── PlayerWeaponIcon
│   │       │       ├── ActiveWeaponIcon
│   │       │       │   ├── ActiveWeaponIconPanelParams.h
│   │       │       │   ├── PlayerActiveWeaponIconPanel.h
│   │       │       │   └── PlayerActiveWeaponIconPanelContext.h
│   │       │       ├── BombIcon
│   │       │       │   ├── PlayerBombIconPanel.h
│   │       │       │   ├── PlayerBombIconPanelContext.h
│   │       │       │   └── PlayerBombIconPanelParams.h
│   │       │       ├── PlayerWeaponIconPanel.h
│   │       │       ├── PlayerWeaponIconPanelContext.h
│   │       │       └── PlayerWeaponIconPanelParams.h
│   │       ├── ViewmodelMod
│   │       │   ├── ViewmodelMod.h
│   │       │   ├── ViewmodelModConfigVariables.h
│   │       │   └── ViewmodelModParams.h
│   │       └── VisualFeaturesStates.h
│   ├── GameClient
│   │   ├── ConVars
│   │   │   ├── ConVarTypes.h
│   │   │   ├── ConVarsBase.h
│   │   │   └── CvarSystem.h
│   │   ├── Crosshair.h
│   │   ├── DLLs
│   │   │   └── Tier0Dll.h
│   │   ├── Econ
│   │   │   └── FauxItemId.h
│   │   ├── Entities
│   │   │   ├── BaseEntity.h
│   │   │   ├── BaseModelEntity.h
│   │   │   ├── BaseWeapon.h
│   │   │   ├── C4.h
│   │   │   ├── EntityClassifier.h
│   │   │   ├── GameRules.h
│   │   │   ├── GlowProperty.h
│   │   │   ├── HostageServices.h
│   │   │   ├── LifeState.h
│   │   │   ├── PlantedC4.h
│   │   │   ├── PlayerController.h
│   │   │   ├── PlayerPawn.h
│   │   │   ├── PlayerResource.h
│   │   │   ├── PlayerWeapons.h
│   │   │   ├── PreviewPlayer.h
│   │   │   ├── RenderComponent.h
│   │   │   ├── SmokeGrenadeProjectile.h
│   │   │   ├── TeamNumber.h
│   │   │   └── WeaponServices.h
│   │   ├── EntitySystem
│   │   │   ├── EntityHandle.h
│   │   │   ├── EntityIdentity.h
│   │   │   └── EntitySystem.h
│   │   ├── FileNameSymbolTable.h
│   │   ├── FileNameSymbolTableState.h
│   │   ├── FileSystem.h
│   │   ├── GameSceneNode.h
│   │   ├── GlobalVars.h
│   │   ├── Hud
│   │   │   ├── BombStatus
│   │   │   │   ├── BombStatusPanel.h
│   │   │   │   ├── BombStatusPanelContext.h
│   │   │   │   ├── BombStatusPanelManager.h
│   │   │   │   ├── BombStatusPanelManagerContext.h
│   │   │   │   └── BombStatusPanelState.h
│   │   │   ├── DeathNotice.h
│   │   │   ├── DeathNoticeContext.h
│   │   │   ├── DeathNotices.h
│   │   │   ├── Hud.h
│   │   │   ├── HudContext.h
│   │   │   └── HudState.h
│   │   ├── MemAlloc.h
│   │   ├── MemAllocState.h
│   │   ├── Panorama
│   │   │   ├── ClientPanel.h
│   │   │   ├── ImagePanel.h
│   │   │   ├── PanelAlignmentParams.h
│   │   │   ├── PanelFactory.h
│   │   │   ├── PanelFontParams.h
│   │   │   ├── PanelHandle.h
│   │   │   ├── PanelMarginParams.h
│   │   │   ├── PanelShadowParams.h
│   │   │   ├── PanelStylePropertyFactory.h
│   │   │   ├── PanoramaDropDown.h
│   │   │   ├── PanoramaLabel.h
│   │   │   ├── PanoramaSymbols.h
│   │   │   ├── PanoramaTransformFactory.h
│   │   │   ├── PanoramaTransformations.h
│   │   │   ├── PanoramaUiEngine.h
│   │   │   ├── PanoramaUiPanel.h
│   │   │   ├── PanoramaUiPanelChildPanels.h
│   │   │   ├── PanoramaUiPanelClasses.h
│   │   │   ├── PanoramaUiPanelIterator.h
│   │   │   ├── PanoramaUiPanelMethodInvoker.h
│   │   │   ├── Slider.h
│   │   │   ├── StylePropertiesSymbolsAndVMTs.h
│   │   │   ├── StylePropertySymbolMap.h
│   │   │   ├── TextEntry.h
│   │   │   ├── TopLevelWindow.h
│   │   │   ├── Ui3dPanel.h
│   │   │   └── UiItem3dPanel.h
│   │   ├── PortraitWorld.h
│   │   ├── SceneSystem
│   │   │   ├── SceneObject.h
│   │   │   ├── SceneObjectAttributes.h
│   │   │   ├── SceneObjectUpdater.h
│   │   │   ├── SceneObjectUpdaters.h
│   │   │   └── SceneSystem.h
│   │   └── WorldToScreen
│   │       ├── ClipSpaceCoordinates.h
│   │       ├── NormalizedDeviceCoordinates.h
│   │       ├── ViewToProjectionMatrix.h
│   │       └── WorldToClipSpaceConverter.h
│   ├── GlobalContext
│   │   ├── DeferredCompleteObject.h
│   │   ├── FullGlobalContext.h
│   │   ├── GlobalContext.h
│   │   ├── OsirisDirectoryPath.h
│   │   ├── PartialGlobalContext.h
│   │   └── UnloadFlag.h
│   ├── HookContext
│   │   ├── HookContext.h
│   │   └── HookContextMacros.h
│   ├── Hooks
│   │   ├── ClientModeHooks.h
│   │   ├── Hooks.h
│   │   ├── PeepEventsHook.h
│   │   └── ViewRenderHook.h
│   ├── MemoryAllocation
│   │   ├── FreeMemoryRegion.h
│   │   ├── FreeMemoryRegionList.h
│   │   ├── MemoryAllocator.h
│   │   ├── MemoryAllocatorBase.h
│   │   ├── MemoryAllocatorBaseImpl.h
│   │   ├── MemoryDeleter.h
│   │   └── UniquePtr.h
│   ├── MemoryPatterns
│   │   ├── AllMemoryPatternSearchResults.h
│   │   ├── Linux
│   │   │   ├── BaseModelEntityPatternsLinux.h
│   │   │   ├── C4PatternsLinux.h
│   │   │   ├── ClientPatternsLinux.h
│   │   │   ├── ConVarPatternsLinux.h
│   │   │   ├── CvarPatternsLinux.h
│   │   │   ├── EntityPatternsLinux.h
│   │   │   ├── EntitySystemPatternsLinux.h
│   │   │   ├── FileSystemPatternsLinux.h
│   │   │   ├── GameRulesPatternsLinux.h
│   │   │   ├── GameSceneNodePatternsLinux.h
│   │   │   ├── GlobalVarsPatternsLinux.h
│   │   │   ├── GlowPropertyPatternsLinux.h
│   │   │   ├── GlowSceneObjectPatternsLinux.h
│   │   │   ├── HostageServicesPatternsLinux.h
│   │   │   ├── LinuxPatterns.h
│   │   │   ├── MemAllocPatternsLinux.h
│   │   │   ├── PanelPatternsLinux.h
│   │   │   ├── PanelStylePatternsLinux.h
│   │   │   ├── PanoramaDropDownPatternsLinux.h
│   │   │   ├── PanoramaImagePanelPatternsLinux.h
│   │   │   ├── PanoramaLabelPatternsLinux.h
│   │   │   ├── PanoramaUiEnginePatternsLinux.h
│   │   │   ├── PanoramaUiPanelPatternsLinux.h
│   │   │   ├── PlantedC4PatternsLinux.h
│   │   │   ├── PlayerControllerPatternsLinux.h
│   │   │   ├── PlayerPawnPatternsLinux.h
│   │   │   ├── PlayerResourcePatternsLinux.h
│   │   │   ├── PortraitWorldPatternsLinux.h
│   │   │   ├── RenderComponentPatternsLinux.h
│   │   │   ├── SceneObjectPatternsLinux.h
│   │   │   ├── SceneObjectUpdaterPatternsLinux.h
│   │   │   ├── SceneSystemPatternsLinux.h
│   │   │   ├── SdlPatternsLinux.h
│   │   │   ├── SliderPatternsLinux.h
│   │   │   ├── SmokeGrenadeProjectilePatternsLinux.h
│   │   │   ├── SoundSystemPatternsLinux.h
│   │   │   ├── TextEntryPatternsLinux.h
│   │   │   ├── TopLevelWindowPatternsLinux.h
│   │   │   ├── Ui3dPanelPatternsLinux.h
│   │   │   ├── UiItem3dPanelPatternsLinux.h
│   │   │   ├── WeaponPatternsLinux.h
│   │   │   ├── WeaponServicesPatternsLinux.h
│   │   │   └── WeaponVDataPatternsLinux.h
│   │   ├── MemoryPatterns.h
│   │   ├── PatternFinders.h
│   │   ├── PatternTypes
│   │   │   ├── BaseModelEntityPatternTypes.h
│   │   │   ├── C4PatternTypes.h
│   │   │   ├── ClientPatternTypes.h
│   │   │   ├── ConVarPatternTypes.h
│   │   │   ├── CvarPatternTypes.h
│   │   │   ├── EntityPatternTypes.h
│   │   │   ├── EntitySystemPatternTypes.h
│   │   │   ├── FileSystemPatternTypes.h
│   │   │   ├── GameRulesPatternTypes.h
│   │   │   ├── GameSceneNodePatternTypes.h
│   │   │   ├── GlobalVarsPatternTypes.h
│   │   │   ├── GlowPropertyPatternTypes.h
│   │   │   ├── GlowSceneObjectPatternTypes.h
│   │   │   ├── HostageServicesPatternTypes.h
│   │   │   ├── MemAllocPatternTypes.h
│   │   │   ├── PanelPatternTypes.h
│   │   │   ├── PanelStylePatternTypes.h
│   │   │   ├── PanoramaDropDownPatternTypes.h
│   │   │   ├── PanoramaImagePanelPatternTypes.h
│   │   │   ├── PanoramaLabelPatternTypes.h
│   │   │   ├── PlantedC4PatternTypes.h
│   │   │   ├── PlayerControllerPatternTypes.h
│   │   │   ├── PlayerPawnPatternTypes.h
│   │   │   ├── PlayerResourcePatternTypes.h
│   │   │   ├── PortraitWorldPatternTypes.h
│   │   │   ├── RenderComponentPatternTypes.h
│   │   │   ├── SceneObjectPatternTypes.h
│   │   │   ├── SceneObjectUpdaterPatternTypes.h
│   │   │   ├── SceneSystemPatternTypes.h
│   │   │   ├── SliderPatternTypes.h
│   │   │   ├── SmokeGrenadeProjectilePatternTypes.h
│   │   │   ├── SoundSystemPatternTypes.h
│   │   │   ├── TextEntryPatternTypes.h
│   │   │   ├── TopLevelWindowPatternTypes.h
│   │   │   ├── Ui3dPanelPatternTypes.h
│   │   │   ├── UiEnginePatternTypes.h
│   │   │   ├── UiItem3dPanelPatternTypes.h
│   │   │   ├── UiPanelPatternTypes.h
│   │   │   ├── WeaponPatternTypes.h
│   │   │   ├── WeaponServicesPatternTypes.h
│   │   │   └── WeaponVDataPatternTypes.h
│   │   └── Windows
│   │       ├── BaseModelEntityPatternsWindows.h
│   │       ├── C4PatternsWindows.h
│   │       ├── ClientPatternsWindows.h
│   │       ├── ConVarPatternsWindows.h
│   │       ├── CvarPatternsWindows.h
│   │       ├── EntityPatternsWindows.h
│   │       ├── EntitySystemPatternsWindows.h
│   │       ├── FileSystemPatternsWindows.h
│   │       ├── GameRulesPatternsWindows.h
│   │       ├── GameSceneNodePatternsWindows.h
│   │       ├── GlobalVarsPatternsWindows.h
│   │       ├── GlowPropertyPatternsWindows.h
│   │       ├── GlowSceneObjectPatternsWindows.h
│   │       ├── HostageServicesPatternsWindows.h
│   │       ├── MemAllocPatternsWindows.h
│   │       ├── PanelPatternsWindows.h
│   │       ├── PanelStylePatternsWindows.h
│   │       ├── PanoramaDropDownPatternsWindows.h
│   │       ├── PanoramaImagePanelPatternsWindows.h
│   │       ├── PanoramaLabelPatternsWindows.h
│   │       ├── PanoramaUiEnginePatternsWindows.h
│   │       ├── PanoramaUiPanelPatternsWindows.h
│   │       ├── PlantedC4PatternsWindows.h
│   │       ├── PlayerControllerPatternsWindows.h
│   │       ├── PlayerPawnPatternsWindows.h
│   │       ├── PlayerResourcePatternsWindows.h
│   │       ├── PortraitWorldPatternsWindows.h
│   │       ├── RenderComponentPatternsWindows.h
│   │       ├── SceneObjectPatternsWindows.h
│   │       ├── SceneObjectUpdaterPatternsWindows.h
│   │       ├── SceneSystemPatternsWindows.h
│   │       ├── SdlPatternWindows.h
│   │       ├── SliderPatternsWindows.h
│   │       ├── SmokeGrenadeProjectilePatternsWindows.h
│   │       ├── SoundSystemPatternsWindows.h
│   │       ├── TextEntryPatternsWindows.h
│   │       ├── TopLevelWindowPatternsWindows.h
│   │       ├── Ui3dPanelPatternsWindows.h
│   │       ├── UiItem3dPanelPatternsWindows.h
│   │       ├── WeaponPatternsWindows.h
│   │       ├── WeaponServicesPatternsWindows.h
│   │       ├── WeaponVDataPatternsWindows.h
│   │       └── WindowsPatterns.h
│   ├── MemorySearch
│   │   ├── BytePattern.h
│   │   ├── BytePatternConverter.h
│   │   ├── BytePatternLiteral.h
│   │   ├── BytePatternStorage.h
│   │   ├── BytePatternView.h
│   │   ├── CodePattern.h
│   │   ├── CodePatternOperation.h
│   │   ├── HybridPatternFinder.h
│   │   ├── PatternFinder.h
│   │   ├── PatternFinderSIMD.h
│   │   ├── PatternFinderScalar.h
│   │   ├── PatternNotFoundLogger.h
│   │   ├── PatternPool.h
│   │   ├── PatternPoolBuilder.h
│   │   ├── PatternPoolView.h
│   │   ├── PatternSearchResult.h
│   │   ├── PatternSearchResults.h
│   │   ├── PatternSearchResultsView.h
│   │   ├── PatternStringWildcard.h
│   │   └── TempPatternPool.h
│   ├── Osiris.vcxproj
│   ├── Osiris.vcxproj.filters
│   ├── OutlineGlow
│   │   ├── GlowSceneObject.h
│   │   ├── GlowSceneObjectContext.h
│   │   ├── GlowSceneObjectPointer.h
│   │   ├── GlowSceneObjectState.h
│   │   ├── GlowSceneObjects.h
│   │   └── GlowSceneObjectsState.h
│   ├── Platform
│   │   ├── DynamicLibrary.h
│   │   ├── Linux
│   │   │   ├── FileSystem
│   │   │   │   ├── FileDescriptor.h
│   │   │   │   └── LinuxInputFile.h
│   │   │   ├── LinuxDynamicLibrary.h
│   │   │   ├── LinuxMessageBox.h
│   │   │   ├── LinuxPlatformApi.h
│   │   │   ├── LinuxPlatformApiImpl.h
│   │   │   ├── LinuxVmt.h
│   │   │   ├── LinuxVmtFinder.h
│   │   │   ├── LinuxVmtFinderParams.h
│   │   │   ├── RTTI
│   │   │   │   ├── LinuxRttiTypeDescriptor.h
│   │   │   │   └── LinuxRttiTypeDescriptorFinder.h
│   │   │   └── UserHomeFolderPath.h
│   │   ├── Macros
│   │   │   ├── CallStack.h
│   │   │   ├── CallingConventions.h
│   │   │   ├── FunctionAttributes.h
│   │   │   ├── IsCompiler.h
│   │   │   ├── IsPlatform.h
│   │   │   └── PlatformSpecific.h
│   │   ├── PlatformApi.h
│   │   ├── PlatformPath.h
│   │   ├── SimpleMessageBox.h
│   │   ├── TypeInfoPrecedingVmt.h
│   │   ├── VmtFinder.h
│   │   └── Windows
│   │       ├── CRTWindows.cpp
│   │       ├── CoTaskMemDeleter.h
│   │       ├── DLLs
│   │       │   ├── CombaseDll.h
│   │       │   └── Shell32Dll.h
│   │       ├── FileSystem
│   │       │   ├── WindowsFileSystem.h
│   │       │   └── WindowsInputFile.h
│   │       ├── NtHandle.h
│   │       ├── PebLdr.h
│   │       ├── PortableExecutable.h
│   │       ├── RTTI
│   │       │   ├── RttiCompleteObjectLocator.h
│   │       │   ├── RttiCompleteObjectLocatorFinder.h
│   │       │   ├── RttiTypeDescriptor.h
│   │       │   ├── RttiTypeDescriptorFinder.h
│   │       │   └── ToRvaConverter.h
│   │       ├── Syscalls
│   │       │   ├── SyscallParams.h
│   │       │   ├── WindowsSyscall.asm
│   │       │   ├── WindowsSyscallIndex.h
│   │       │   └── WindowsSyscalls.h
│   │       ├── UserDocumentsFolderPath.h
│   │       ├── Win.h
│   │       ├── WindowsDynamicLibrary.h
│   │       ├── WindowsMessageBox.h
│   │       ├── WindowsPlatformApi.h
│   │       ├── WindowsPlatformApiImpl.h
│   │       ├── WindowsVmtFinder.h
│   │       └── WindowsVmtFinderParams.h
│   ├── SDL
│   │   ├── SdlConstants.h
│   │   ├── SdlDll.h
│   │   └── SdlFunctions.h
│   ├── UI
│   │   └── Panorama
│   │       ├── CombatTab.h
│   │       ├── CreateGUI.js
│   │       ├── HudTab.h
│   │       ├── OnOffDropdownSelectionChangeHandler.h
│   │       ├── PanoramaCommandDispatcher.h
│   │       ├── PanoramaGUI.h
│   │       ├── PanoramaGuiState.h
│   │       ├── SetCommandHandler.h
│   │       ├── SoundTab.h
│   │       ├── Tabs
│   │       │   └── VisualsTab
│   │       │       ├── HueSlider.h
│   │       │       ├── IntSlider.h
│   │       │       ├── PlayerInfoInWorldDropdownSelectionChangeHandler.h
│   │       │       ├── PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler.h
│   │       │       ├── PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler.h
│   │       │       ├── PlayerModelGlowColorModeDropdownSelectionChangeHandler.h
│   │       │       ├── PlayerModelGlowDropdownSelectionChangeHandler.h
│   │       │       ├── PlayerOutlineGlowColorModeDropdownSelectionChangeHandler.h
│   │       │       ├── PlayerOutlineGlowDropdownSelectionChangeHandler.h
│   │       │       ├── ViewmodelModPreviewPanel.h
│   │       │       └── ViewmodelModPreviewPanelState.h
│   │       └── VisualsTab.h
│   ├── Utils
│   │   ├── Align.h
│   │   ├── BitFlags.h
│   │   ├── Bits.h
│   │   ├── CString.h
│   │   ├── CharUtils.h
│   │   ├── ColorUtils.h
│   │   ├── DynamicArray.h
│   │   ├── EnumFlags.h
│   │   ├── FieldFieldOffset.h
│   │   ├── FieldOffset.h
│   │   ├── FileSlice.h
│   │   ├── FlagsBuilder.h
│   │   ├── GenericFunctionPointer.h
│   │   ├── GenericPointer.h
│   │   ├── HexChars.h
│   │   ├── IdentityMacro.h
│   │   ├── InRange.h
│   │   ├── LazyInitialized.h
│   │   ├── Lvalue.h
│   │   ├── ManuallyDestructible.h
│   │   ├── MemorySection.h
│   │   ├── Meta.h
│   │   ├── Optional.h
│   │   ├── OptionalPointee.h
│   │   ├── Pad.h
│   │   ├── PrivateTag.h
│   │   ├── RefCountedHook.h
│   │   ├── ReturnAddress.h
│   │   ├── SpanSlice.h
│   │   ├── StringBuilder.h
│   │   ├── StringParser.h
│   │   ├── StrongTypeAlias.h
│   │   ├── TemplateParameterCstring.h
│   │   ├── ToUnderlying.h
│   │   ├── TypeBitFlags.h
│   │   ├── TypeIndex.h
│   │   ├── TypeList.h
│   │   ├── TypedStaticStringPool.h
│   │   └── Wcslen.h
│   ├── Verification
│   │   ├── Verifier.h
│   │   └── VerifyMacros.h
│   ├── Vmt
│   │   ├── VmtCopy.h
│   │   ├── VmtLength.h
│   │   ├── VmtLengthCalculator.h
│   │   └── VmtSwapper.h
│   └── dllmain.cpp
└── Tests
    ├── CMakeLists.txt
    ├── Configs
    │   ├── config_current.cfg
    │   ├── config_v1.cfg
    │   ├── config_v2.cfg
    │   ├── config_v3.cfg
    │   ├── config_v4.cfg
    │   ├── config_v5.cfg
    │   ├── config_v6.cfg
    │   ├── config_v7.cfg
    │   ├── config_v8.cfg
    │   └── config_v9.cfg
    ├── FunctionalTests
    │   ├── CMakeLists.txt
    │   └── Config
    │       └── ConfigCompatibilityTests.cpp
    ├── Matchers
    │   └── Matchers.h
    ├── Mocks
    │   ├── BombTimerMocks
    │   │   ├── MockBombSiteIconPanel.h
    │   │   ├── MockBombTimer.h
    │   │   ├── MockBombTimerCondition.h
    │   │   ├── MockBombTimerContext.h
    │   │   ├── MockBombTimerPanel.h
    │   │   └── MockBombTimerTextPanel.h
    │   ├── DefusingAlertMocks
    │   │   ├── MockDefusingAlertCondition.h
    │   │   ├── MockDefusingAlertContext.h
    │   │   ├── MockDefusingAlertPanel.h
    │   │   └── MockDefusingCountdownTextPanel.h
    │   ├── Features
    │   │   └── Hud
    │   │       └── BombPlantAlert
    │   │           └── MockBombPlantAlertPanelFactory.h
    │   ├── HudMocks
    │   │   ├── MockBombStatusPanel.h
    │   │   ├── MockBombStatusPanelContext.h
    │   │   ├── MockBombStatusPanelManagerContext.h
    │   │   ├── MockDeathNotice.h
    │   │   ├── MockDeathNotices.h
    │   │   └── MockHud.h
    │   ├── KillfeedPreserverMocks
    │   │   └── MockKillfeedPreserverContext.h
    │   ├── MockBaseEntity.h
    │   ├── MockBaseWeapon.h
    │   ├── MockC4.h
    │   ├── MockClientPanel.h
    │   ├── MockConfig.h
    │   ├── MockConfigConversion.h
    │   ├── MockCrosshair.h
    │   ├── MockCvarSystem.h
    │   ├── MockGameRules.h
    │   ├── MockGlowProperty.h
    │   ├── MockGui.h
    │   ├── MockHookContext.h
    │   ├── MockImagePanel.h
    │   ├── MockLabelPanel.h
    │   ├── MockMemoryAllocator.h
    │   ├── MockModelEntity.h
    │   ├── MockPanel.h
    │   ├── MockPanelFactory.h
    │   ├── MockPanelHandle.h
    │   ├── MockPanoramaUiEngine.h
    │   ├── MockPlantedC4.h
    │   ├── MockPlayerController.h
    │   ├── MockPlayerPawn.h
    │   ├── MockSmokeGrenadeProjectile.h
    │   ├── MockViewToProjectionMatrix.h
    │   └── PostRoundTimer
    │       ├── MockPostRoundTimer.h
    │       ├── MockPostRoundTimerCondition.h
    │       ├── MockPostRoundTimerContext.h
    │       └── MockPostRoundTimerPanel.h
    └── UnitTests
        ├── CMakeLists.txt
        ├── Config
        │   ├── CMakeLists.txt
        │   ├── ConfigFromStringTests.cpp
        │   ├── ConfigSchemaTests.cpp
        │   ├── ConfigToStringTests.cpp
        │   └── ConfigVariablesTests.cpp
        ├── Features
        │   ├── CMakeLists.txt
        │   ├── Combat
        │   │   ├── CMakeLists.txt
        │   │   └── SniperRifles
        │   │       ├── CMakeLists.txt
        │   │       └── NoScopeInaccuracyVisTests.cpp
        │   ├── Hud
        │   │   ├── BombPlantAlert
        │   │   │   ├── BombPlantAlertPanelFactoryTests.cpp
        │   │   │   ├── BombPlantAlertTests.cpp
        │   │   │   └── CMakeLists.txt
        │   │   ├── BombTimer
        │   │   │   ├── BombSiteIconPanelTests.cpp
        │   │   │   ├── BombTimerConditionTests.cpp
        │   │   │   ├── BombTimerPanelTests.cpp
        │   │   │   ├── BombTimerTests.cpp
        │   │   │   ├── BombTimerTextPanelTests.cpp
        │   │   │   └── CMakeLists.txt
        │   │   ├── CMakeLists.txt
        │   │   ├── DefusingAlert
        │   │   │   ├── CMakeLists.txt
        │   │   │   ├── DefusingAlertConditionTests.cpp
        │   │   │   ├── DefusingAlertPanelTests.cpp
        │   │   │   ├── DefusingAlertTests.cpp
        │   │   │   └── DefusingCountdownTextPanelTests.cpp
        │   │   ├── KillfeedPreserver
        │   │   │   ├── CMakeLists.txt
        │   │   │   ├── KillfeedPreserverContextTests.cpp
        │   │   │   └── KillfeedPreserverTests.cpp
        │   │   └── PostRoundTimer
        │   │       ├── CMakeLists.txt
        │   │       ├── PostRoundTimerConditionTests.cpp
        │   │       ├── PostRoundTimerContextTests.cpp
        │   │       ├── PostRoundTimerPanelFactoryTests.cpp
        │   │       └── PostRoundTimerTests.cpp
        │   └── Visuals
        │       ├── CMakeLists.txt
        │       ├── ModelGlow
        │       │   ├── CMakeLists.txt
        │       │   ├── DefuseKitModelGlowTests.cpp
        │       │   ├── DroppedBombModelGlowTests.cpp
        │       │   ├── GrenadeProjectileModelGlowTests.cpp
        │       │   ├── ModelGlowTests.cpp
        │       │   ├── PlayerModelGlowTests.cpp
        │       │   ├── TickingBombModelGlowTests.cpp
        │       │   └── WeaponModelGlowTests.cpp
        │       ├── OutlineGlow
        │       │   ├── CMakeLists.txt
        │       │   ├── DefuseKitOutlineGlowTests.cpp
        │       │   ├── DroppedBombOutlineGlowTests.cpp
        │       │   ├── GrenadeProjectileOutlineGlowTests.cpp
        │       │   ├── HostageOutlineGlowTests.cpp
        │       │   ├── OutlineGlowTests.cpp
        │       │   ├── PlayerOutlineGlowTests.cpp
        │       │   ├── TickingBombOutlineGlowTests.cpp
        │       │   └── WeaponOutlineGlowTests.cpp
        │       └── ViewmodelMod
        │           ├── CMakeLists.txt
        │           └── ViewmodelModTests.cpp
        ├── GameClient
        │   ├── CMakeLists.txt
        │   └── Hud
        │       ├── BombStatus
        │       │   ├── BombStatusPanelManagerTests.cpp
        │       │   ├── BombStatusPanelTests.cpp
        │       │   └── CMakeLists.txt
        │       └── CMakeLists.txt
        ├── MemorySearch
        │   ├── BytePatternConverterTests.cpp
        │   ├── BytePatternLiteralTests.cpp
        │   ├── BytePatternStorageTests.cpp
        │   ├── BytePatternTests.cpp
        │   ├── CMakeLists.txt
        │   ├── PatternFinderSIMDTests.cpp
        │   └── PatternSearchResultTests.cpp
        ├── Platform
        │   ├── CMakeLists.txt
        │   ├── Linux
        │   │   ├── CMakeLists.txt
        │   │   └── SharedObjectTests.cpp
        │   └── Windows
        │       ├── CMakeLists.txt
        │       ├── MockWindowsPlatformApi.cpp
        │       ├── PebLdrBuilder.h
        │       └── PebLdrTests.cpp
        └── Utils
            ├── BitsTests.cpp
            ├── CMakeLists.txt
            ├── EnumFlagsTests.cpp
            ├── FlagsBuilderTests.cpp
            ├── OptionalTests.cpp
            ├── PatternFinderTests.cpp
            ├── RefCountedHookTests.cpp
            ├── ReturnAddressTests.cpp
            ├── SpanSliceTests.cpp
            └── StringBuilderTests.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.24)
project(Osiris LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

if(WIN32)
  enable_language(ASM_MASM)
elseif(UNIX)
  enable_language(ASM-ATT)
endif()

set(ENABLE_TESTS CACHE STRING "List of test types to enable e.g. \"unit;functional\"")

add_subdirectory(Source)

if(ENABLE_TESTS)
  enable_testing()
  add_subdirectory(Tests)
endif()

```

`LICENSE`:

```
MIT License

Copyright (c) 2018-2025 Daniel Krupiński

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Osiris.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Osiris", "Source\Osiris.vcxproj", "{DD077013-2B61-4122-970E-63E63055EAA8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DD077013-2B61-4122-970E-63E63055EAA8}.Debug|x64.ActiveCfg = Debug|x64
		{DD077013-2B61-4122-970E-63E63055EAA8}.Debug|x64.Build.0 = Debug|x64
		{DD077013-2B61-4122-970E-63E63055EAA8}.Release|x64.ActiveCfg = Release|x64
		{DD077013-2B61-4122-970E-63E63055EAA8}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8983F957-671F-4A13-B67E-5585161828A9}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# Osiris

[![Windows](https://github.com/danielkrupinski/Osiris/actions/workflows/windows.yml/badge.svg?branch=master&event=push)](https://github.com/danielkrupinski/Osiris/actions/workflows/windows.yml)
[![Linux](https://github.com/danielkrupinski/Osiris/actions/workflows/linux.yml/badge.svg?branch=master&event=push)](https://github.com/danielkrupinski/Osiris/actions/workflows/linux.yml)

Cross-platform (Windows, Linux) game hack for **Counter-Strike 2** with GUI and rendering based on game's Panorama UI. Compatible with the latest game update on Steam.

## What's new

* 04 November 2025
    * Improved smoothness of "Player Info in World" on moving players

* 30 October 2025
    * Added Bomb Plant Alert feature
        * Green color means the bomb will be planted before the end of the round if uninterrupted
        * Red color means the bomb can not be planted before the end of the round

    <img width="201" height="146" alt="Bomb Plant Alert" src="https://github.com/user-attachments/assets/21c0f8fb-a20d-42df-9857-f578cfc9b9f9" />

* 23 October 2025
    * Hostage Outline Glow hue is now customizable

* 20 October 2025
    * Added "No Scope Inaccuracy Visualization" feature

    <img height="300" alt="no scope inaccuracy visualization" src="https://github.com/user-attachments/assets/860c944a-00b1-4b67-9d41-6f43e46f4252" />

* 09 October 2025
    * Added viewmodel fov modification

    ![Viewmodel fov modification](https://github.com/user-attachments/assets/3b9d6bde-a68c-4739-913c-d3b6caba4117)

## Technical features

* C++ runtime library (CRT) is not used in release builds
* No heap memory allocations
* No static imports in release build on Windows
* No threads are created
* Exceptions are not used
* No external dependencies

## Compiling

### Prerequisites

#### Windows

* **Microsoft Visual Studio 2022** with **Desktop development with C++** workload

#### Linux

* **CMake 3.24** or newer
* **g++ 11 or newer** or **clang++ 18 or newer**

### Compiling from source

#### Windows

Open **Osiris.sln** in Visual Studio 2022, set build configuration to **Release | x64**. Press *Build solution* and you should receive **Osiris.dll** file.

#### Linux

Configure with CMake:

    cmake -DCMAKE_BUILD_TYPE=Release -B build

Build:

    cmake --build build -j $(nproc --all)

After following these steps you should receive **libOsiris.so** file in **build/Source/** directory.

### Loading / Injecting into game process

#### Windows

You need a **DLL injector** to inject (load) **Osiris.dll** into game process.

Counter-Strike 2 blocks LoadLibrary injection method, so you have to use a manual mapping (aka reflective DLL injection) injector.

**Xenos** and **Extreme Injector** are known to be **detected** by VAC.

#### Linux

You can simply run the following script in the directory containing **libOsiris.so**:

    sudo gdb -batch-silent -p $(pidof cs2) -ex "call (void*)dlopen(\"$PWD/libOsiris.so\", 2)"

However, this injection method might be detected by VAC as gdb is visible under **TracerPid** in `/proc/$(pidof cs2)/status` for the duration of the injection.

## FAQ

### Where are the settings stored on disk?

In a configuration file `default.cfg` inside `%appdata%\OsirisCS2\configs` directory on Windows and `$HOME/OsirisCS2/configs` on Linux.

## License

> Copyright (c) 2018-2025 Daniel Krupiński

This project is licensed under the [MIT License](https://opensource.org/licenses/mit-license.php) - see the [LICENSE](https://github.com/danielkrupinski/Osiris/blob/master/LICENSE) file for details.

```

`Source/BuildConfig.h`:

```h
#pragma once

#include <string_view>
#include <Platform/Macros/PlatformSpecific.h>

namespace build
{

constexpr auto MEMORY_CAPACITY = 1'000'000;

constexpr std::basic_string_view kOsirisDirectoryName{WIN64_LINUX(L"OsirisCS2", "OsirisCS2")};
constexpr std::basic_string_view kConfigDirectoryName{WIN64_LINUX(L"configs", "configs")};
constexpr auto kConfigFileBufferSize{4096};

}

```

`Source/CMakeLists.txt`:

```txt
add_library(Osiris SHARED dllmain.cpp)

set_target_properties(Osiris PROPERTIES
  CXX_VISIBILITY_PRESET hidden
  C_VISIBILITY_PRESET hidden
  POSITION_INDEPENDENT_CODE ON)

target_include_directories(Osiris PRIVATE "${CMAKE_SOURCE_DIR}/Source")
target_link_libraries(Osiris PRIVATE ${CMAKE_DL_LIBS})

if(WIN32)
  target_sources(Osiris PRIVATE Platform/Windows/Syscalls/WindowsSyscall.asm)
endif()

if(MSVC)
  set_target_properties(Osiris PROPERTIES MSVC_RUNTIME_LIBRARY "$<$<CONFIG:Debug>:MultiThreadedDebugDLL>")
  string(REGEX REPLACE "/EH[a-z]+" "" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})
  target_sources(Osiris PRIVATE $<$<CONFIG:Release>:Platform/Windows/CRTWindows.cpp>)
  target_compile_options(Osiris PRIVATE $<$<COMPILE_LANGUAGE:CXX>:/W4 $<$<CONFIG:Release>:/sdl- /GS->>)
  target_compile_definitions(Osiris PRIVATE $<$<CONFIG:Release>:_USE_STD_VECTOR_ALGORITHMS=0>)
  target_link_options(Osiris PRIVATE $<$<CONFIG:Release>:/nodefaultlib /ENTRY:"DllMain">)
endif()

if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
  if(NOT CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL "MSVC")
    target_compile_options(Osiris PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Wall>)
    target_link_options(Osiris PRIVATE LINKER:--no-undefined -z noexecstack)
  endif()

  target_compile_options(Osiris PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Wno-missing-braces>)
endif()

if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 14.0)
  target_compile_options(Osiris PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-Wno-dangling-reference>) # false positive
endif()

if(CMAKE_BUILD_TYPE STREQUAL "Release")
  if(UNIX)
    target_compile_options(Osiris PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-fno-stack-protector -fno-exceptions -fno-asynchronous-unwind-tables -fno-unwind-tables>)
    target_link_options(Osiris PRIVATE -nostdlib)
    target_link_libraries(Osiris PRIVATE c)

    if(CMAKE_STRIP)
      add_custom_command(TARGET Osiris POST_BUILD COMMAND ${CMAKE_STRIP} "$<TARGET_FILE:Osiris>")
    endif()
  endif()
endif()

```

`Source/CS2/Classes/CCSPlayer_HostageServices.h`:

```h
#pragma once

namespace cs2
{

struct CEntityHandle;

struct CCSPlayer_HostageServices {
    using m_hCarriedHostage = CEntityHandle;
};

}

```

`Source/CS2/Classes/CCSPlayer_WeaponServices.h`:

```h
#pragma once

#include "EntitySystem/CEntityHandle.h"
#include "CUtlVector.h"

namespace cs2
{

struct CCSPlayer_WeaponServices {
    using m_hActiveWeapon = CEntityHandle;
    using m_hMyWeapons = CUtlVector<CEntityHandle>;
};

}

```

`Source/CS2/Classes/CCSWeaponBaseVData.h`:

```h
#pragma once

#include "CEntitySubclassVDataBase.h"

namespace cs2
{

struct CCSWeaponBaseVData : CEntitySubclassVDataBase {
    using m_szName = const char*;
};

}

```

`Source/CS2/Classes/CCS_PortraitWorld.h`:

```h
#pragma once

#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Classes/CUtlVector.h>

namespace cs2
{

struct CCS_PortraitWorld {
    using DynamicEntityHandles = CUtlVector<CEntityHandle>;
    using MapEntityHandles = CUtlVector<CEntityHandle>;
};

}

```

`Source/CS2/Classes/CCvar.h`:

```h
#pragma once

#include "ConVar.h"
#include "CUtlLinkedList.h"

namespace cs2
{

struct CCvar {
    using ConVarList = CUtlLinkedList<ConVar*>;
};

}

```

`Source/CS2/Classes/CEntitySubclassVDataBase.h`:

```h
#pragma once

namespace cs2
{

struct CEntitySubclassVDataBase {};

}

```

`Source/CS2/Classes/CGameSceneNode.h`:

```h
#pragma once

#include "Entities/CEntityInstance.h"
#include "Vector.h"

namespace cs2
{

struct CGameSceneNode {
    using m_pOwner = CEntityInstance*;
    using m_pChild = CGameSceneNode*;
    using m_pNextSibling = CGameSceneNode*;
    using m_vecAbsOrigin = Vector;
};

}

```

`Source/CS2/Classes/CGlowProperty.h`:

```h
#pragma once

namespace cs2
{

struct CGlowProperty {
    using m_bGlowing = bool;
};

}

```

`Source/CS2/Classes/CLoopModeGame.h`:

```h
#pragma once

namespace cs2
{

struct CLoopModeGame {
    using getWorldSession = void* (*)(CLoopModeGame* thisptr);
};

}

```

`Source/CS2/Classes/CPlantedC4.h`:

```h
#pragma once

#include <cstdint>

#include "Entities/C_BaseModelEntity.h"

namespace cs2
{

struct CPlantedC4 : C_BaseModelEntity {
    using m_nBombSite = int;
    using m_bBombTicking = bool;
    using m_hBombDefuser = std::uint32_t;
    using m_flC4Blow = float;
    using m_flDefuseCountDown = float;
};

}

```

`Source/CS2/Classes/CRenderComponent.h`:

```h
#pragma once

#include "CUtlVector.h"
#include "SceneObjectUpdaterHandle_t.h"

namespace cs2
{

struct CRenderComponent {
    using sceneObjectUpdaters = cs2::CUtlVector<SceneObjectUpdaterHandle_t*>;
};

}

```

`Source/CS2/Classes/CSceneObject.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

enum SceneObjectFlags {
    SceneObjectFlag_IsDeleted = 0x20
};

enum ESceneObjectFlags : std::uint64_t {
    SCENEOBJECTFLAG_VIEWMODEL_LAYER = (std::uint64_t{1} << 8),
    SCENEOBJECTFLAG_PIPELINE_SPECIFIC_2 = (std::uint64_t{1} << 50)
};

struct SceneObjectAttributes {
    struct FloatAttributes {};

    FloatAttributes floatAttributes;
};

struct CSceneObject {
    using m_nObjectClass = std::uint8_t;
    using flags = std::uint8_t;
    using attributes = SceneObjectAttributes*;
    using m_nRenderableFlags = std::uint64_t;
};

}

```

`Source/CS2/Classes/CSceneSystem.h`:

```h
#pragma once

namespace cs2
{

struct CSceneObject;

struct CSceneSystem {
    using DeleteSceneObject = void(CSceneSystem* sceneSystem, CSceneObject* sceneObject);
    using AllocateAttributeList = void(CSceneSystem* sceneSystem, CSceneObject* sceneObject);
};

}

```

`Source/CS2/Classes/CUtlAbstractDelegate.h`:

```h
#pragma once

#include <cassert>
#include <cstdint>
#include <type_traits>

#include <Platform/Macros/PlatformSpecific.h>

namespace cs2
{

#if IS_WIN64()

struct CUtlAbstractDelegate {
    template <typename F>
        requires (std::is_pointer_v<F>&& std::is_function_v<std::remove_pointer_t<F>>)
    CUtlAbstractDelegate(F f)
        : function{std::uintptr_t(f)}
    {
    }

    void* thisptr{};
    std::uintptr_t function{};
};
static_assert(sizeof(CUtlAbstractDelegate) == 16);

#elif IS_LINUX()

struct CUtlAbstractDelegate {
    template <typename F>
        requires (std::is_pointer_v<F>&& std::is_function_v<std::remove_pointer_t<F>>)
    CUtlAbstractDelegate(F f)
        : functionOrVirtualMethodOffset{std::uintptr_t(f)}
    {
        assert(isUsingFunctionPointer());
    }

    [[nodiscard]] bool isUsingFunctionPointer() const noexcept
    {
        return (functionOrVirtualMethodOffset & 1) == 0;
    }

    void* thisptr{};
    std::uintptr_t functionOrVirtualMethodOffset{};
    std::ptrdiff_t offsetToThis{};
};
static_assert(sizeof(CUtlAbstractDelegate) == 24);

#endif
}

```

`Source/CS2/Classes/CUtlFilenameSymbolTable.h`:

```h
#pragma once

namespace cs2
{

using FileNameHandle_t = void*;

struct CUtlFilenameSymbolTable {
    using String = bool(CUtlFilenameSymbolTable* thisptr, const FileNameHandle_t* handle, char* buf, int buflen);
};

}

```

`Source/CS2/Classes/CUtlLinkedList.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

template <typename ElementType, typename IndexType = std::uint16_t>
struct CUtlLinkedList {
    struct UtlLinkedListElem_t {
        ElementType m_Element;
        IndexType m_Previous;
        IndexType m_Next;
    };

    static constexpr auto kInvalidIndex{static_cast<IndexType>(-1)};

    IndexType size;
    IndexType allocationCount;
    UtlLinkedListElem_t* memory;
    IndexType m_Head;
};

}

```

`Source/CS2/Classes/CUtlMap.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

template <typename Key, typename Value, typename Index = int>
struct Node {
    Index left;
    Index right;
    Index parent;
    Index type;
    Key key;
    Value value;
};

template <typename Key, typename Value, typename Index = int>
struct CUtlMap {
    Index size;
    Index allocationCount;
    Node<Key, Value, Index>* memory;
    Index root;
    Index numElements;
};

}

```

`Source/CS2/Classes/CUtlString.h`:

```h
#pragma once

namespace cs2
{

struct CUtlString {
    char* m_pString;
};

}

```

`Source/CS2/Classes/CUtlVector.h`:

```h
#pragma once

namespace cs2
{

template <typename T>
struct CUtlVector {
    int size;
    T* memory;
    int allocationCount;
    int growSize;
};

}

```

`Source/CS2/Classes/CViewRender.h`:

```h
#pragma once

namespace cs2
{

struct CViewRender {
    using OnRenderStart = void(CViewRender* thisptr);
};

}

```

`Source/CS2/Classes/C_CSGameRules.h`:

```h
#pragma once

#include <CS2/Constants/RoundWinStatus.h>

namespace cs2
{

struct C_CSGameRules {
    using m_fRoundStartTime = float;
    using m_flRestartRoundTime = float;
    using m_iRoundTime = int;
    using m_iRoundWinStatus = RoundWinStatus;
};

}

```

`Source/CS2/Classes/ClientModeCSNormal.h`:

```h
#pragma once

namespace cs2
{

struct ClientModeCSNormal {
    using GetViewmodelFov = float(ClientModeCSNormal* thisptr);
};

}

```

`Source/CS2/Classes/Color.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

struct Color {
    constexpr Color(std::uint8_t r, std::uint8_t g, std::uint8_t b, std::uint8_t a = 255) noexcept
        : rgba{ r, g, b, a }
    {
    }

    constexpr bool operator==(const Color&) const = default;

    [[nodiscard]] constexpr std::uint8_t r() const noexcept
    {
        return rgba[0];
    }

    [[nodiscard]] constexpr std::uint8_t g() const noexcept
    {
        return rgba[1];
    }

    [[nodiscard]] constexpr std::uint8_t b() const noexcept
    {
        return rgba[2];
    }

    [[nodiscard]] constexpr std::uint8_t a() const noexcept
    {
        return rgba[3];
    }

    [[nodiscard]] constexpr auto setAlpha(std::uint8_t newAlpha) const noexcept
    {
        return Color{r(), g(), b(), newAlpha};
    }

private:
    std::uint8_t rgba[4];
};

}

```

`Source/CS2/Classes/ConVar.h`:

```h
#pragma once

#include <cstdint>
#include <type_traits>

namespace cs2
{

enum class ConVarValueType : std::uint16_t {
    boolean,
    int16,
    uint16,
    int32,
    uint32,
    int64,
    uint64,
    float32,
    float64,
    string
};

struct ConVar {
    const char* name;

    using ValueType = ConVarValueType;
    using Value = void;
};

}

```

`Source/CS2/Classes/ConVarTypes.h`:

```h
#pragma once

#define CONVAR_STRINGIFY(name) #name
#define CONVAR(name, valueType) \
struct name { \
    static constexpr auto kName{CONVAR_STRINGIFY(name)}; \
    using ValueType = valueType; \
}

namespace cs2
{

CONVAR(mp_teammates_are_enemies, bool);
CONVAR(viewmodel_fov, float);
CONVAR(cl_crosshaircolor, int);
CONVAR(cl_crosshaircolor_r, int);
CONVAR(cl_crosshaircolor_g, int);
CONVAR(cl_crosshaircolor_b, int);

}

#undef CONVAR_STRINGIFY

```

`Source/CS2/Classes/Entities/CBaseAnimGraph.h`:

```h
#pragma once

#include "C_BaseModelEntity.h"

namespace cs2
{

struct CBaseAnimGraph : C_BaseModelEntity {
};

}

```

`Source/CS2/Classes/Entities/CCSPlayerController.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <Platform/Macros/PlatformSpecific.h>

#include "C_BaseEntity.h"

namespace cs2
{

enum class PlayerColorIndex : std::int32_t {
    Blue = 0,
    Green = 1,
    Yellow = 2,
    Orange = 3,
    Purple = 4
};

constexpr auto kPlayerColorIndexCount{5};

struct CCSPlayerController : C_BaseEntity {
    static constexpr auto kMangledTypeName{WIN64_LINUX(".?AVCCSPlayerController@@", "19CCSPlayerController")};

    using m_hPawn = CEntityHandle;
    using m_iCompTeammateColor = PlayerColorIndex;
};

}

```

`Source/CS2/Classes/Entities/CEntityInstance.h`:

```h
#pragma once

#include <Utils/Pad.h>

namespace cs2
{

struct CEntityIdentity;

struct CEntityInstance {
    const void* vmt;
    PAD(8);
    CEntityIdentity* identity;
};

}

```

`Source/CS2/Classes/Entities/C_BaseCSGrenadeProjectile.h`:

```h
#pragma once

#include "C_BaseModelEntity.h"

namespace cs2
{

struct C_BaseCSGrenadeProjectile : C_BaseModelEntity {
};

}

```

`Source/CS2/Classes/Entities/C_BaseEntity.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include "CEntityInstance.h"

namespace cs2
{

struct CEntitySubclassVDataBase;
struct CGameSceneNode;
struct CRenderComponent;
struct Vector;

struct C_BaseEntity : CEntityInstance {
    using m_pGameSceneNode = CGameSceneNode*;
    using m_iHealth = std::int32_t;
    using m_lifeState = std::uint8_t;
    using m_iTeamNum = std::uint8_t;
    using m_pSubclassVData = CEntitySubclassVDataBase*;
    using m_pRenderComponent = CRenderComponent*;
    using m_hOwnerEntity = CEntityHandle;
    using GetAbsOrigin = Vector*(C_BaseEntity* thisptr);
};

}

```

`Source/CS2/Classes/Entities/C_BaseModelEntity.h`:

```h
#pragma once

#include <CS2/Classes/CGlowProperty.h>
#include "C_BaseEntity.h"

namespace cs2
{

struct C_BaseModelEntity : C_BaseEntity {
    using m_Glow = CGlowProperty;
};

}

```

`Source/CS2/Classes/Entities/C_CSGO_PreviewPlayer.h`:

```h
#pragma once

#include "C_CSPlayerPawn.h"

namespace cs2
{

struct C_CSGO_PreviewPlayer : C_CSPlayerPawn {
};

}

```

`Source/CS2/Classes/Entities/C_CSPlayerPawn.h`:

```h
#pragma once

#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Classes/SceneObjectUpdaterHandle_t.h>

#include "C_BaseModelEntity.h"

namespace cs2
{

struct CCSPlayer_HostageServices;
struct CCSPlayer_WeaponServices;

struct C_CSPlayerPawn : C_BaseModelEntity {
    using m_bGunGameImmunity = bool;
    using m_pWeaponServices = CCSPlayer_WeaponServices*;
    using m_hController = CEntityHandle;
    using m_bIsDefusing = bool;
    using m_bIsGrabbingHostage = bool;
    using m_pHostageServices = CCSPlayer_HostageServices*;
    using m_flFlashBangTime = float;
    using sceneObjectUpdaterHandle = SceneObjectUpdaterHandle_t*;
    using m_bIsScoped = bool;
};

}

```

`Source/CS2/Classes/Entities/C_CSPlayerResource.h`:

```h
#pragma once

#include "C_BaseEntity.h"
#include <CS2/Classes/Vector.h>

namespace cs2
{

struct C_CSPlayerResource : C_BaseEntity {
    using m_bombsiteCenterA = Vector;
    using m_bombsiteCenterB = Vector;
};

}

```

`Source/CS2/Classes/Entities/C_CSWeaponBase.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/SceneObjectUpdaterHandle_t.h>
#include "C_BaseModelEntity.h"

namespace cs2
{

struct C_CSWeaponBase : C_BaseModelEntity {
    using m_iClip1 = std::int32_t;
    using sceneObjectUpdaterHandle = SceneObjectUpdaterHandle_t*;
    using GetInaccuracy = float(C_CSWeaponBase* thisptr, float* movementInaccuracy, float* airSpeedInaccuracy);
    using GetSpread = float(C_CSWeaponBase* thisptr);
};

}

```

`Source/CS2/Classes/Entities/C_Hostage.h`:

```h
#pragma once

#include "C_BaseModelEntity.h"

namespace cs2
{

struct C_Hostage : C_BaseModelEntity {
};

}

```

`Source/CS2/Classes/Entities/GrenadeProjectiles.h`:

```h
#pragma once

#include "C_BaseCSGrenadeProjectile.h"

namespace cs2
{

struct C_HEGrenadeProjectile : C_BaseCSGrenadeProjectile {
};

struct C_SmokeGrenadeProjectile : C_BaseCSGrenadeProjectile {
    using m_bDidSmokeEffect = bool;
};

struct C_MolotovProjectile : C_BaseCSGrenadeProjectile {
};

struct C_FlashbangProjectile : C_BaseCSGrenadeProjectile {
};

}

```

`Source/CS2/Classes/Entities/WeaponEntities.h`:

```h
#pragma once

#include "C_CSWeaponBase.h"

namespace cs2
{

struct C_WeaponGlock : C_CSWeaponBase {
};

struct C_WeaponHKP2000 : C_CSWeaponBase {
};

struct C_WeaponElite : C_CSWeaponBase {
};

struct C_WeaponP250 : C_CSWeaponBase {
};

struct C_WeaponTec9 : C_CSWeaponBase {
};

struct C_WeaponFiveSeven : C_CSWeaponBase {
};

struct C_DEagle : C_CSWeaponBase {
};

struct C_WeaponMAC10 : C_CSWeaponBase {
};

struct C_WeaponMP7 : C_CSWeaponBase {
};

struct C_WeaponMP9 : C_CSWeaponBase {
};

struct C_WeaponUMP45 : C_CSWeaponBase {
};

struct C_WeaponP90 : C_CSWeaponBase {
};

struct C_WeaponBizon : C_CSWeaponBase {
};

struct C_WeaponMag7 : C_CSWeaponBase {
};

struct C_WeaponSawedoff : C_CSWeaponBase {
};

struct C_WeaponXM1014 : C_CSWeaponBase {
};

struct C_WeaponNOVA : C_CSWeaponBase {
};

struct C_WeaponM249 : C_CSWeaponBase {
};

struct C_WeaponNegev : C_CSWeaponBase {
};

struct C_WeaponGalilAR : C_CSWeaponBase {
};

struct C_WeaponFamas : C_CSWeaponBase {
};

struct C_AK47 : C_CSWeaponBase {
};

struct C_WeaponM4A1 : C_CSWeaponBase {
};

struct C_WeaponSG556 : C_CSWeaponBase {
};

struct C_WeaponAug : C_CSWeaponBase {
};

struct C_WeaponSSG08 : C_CSWeaponBase {
};

struct C_WeaponAWP : C_CSWeaponBase {
};

struct C_WeaponG3SG1 : C_CSWeaponBase {
};

struct C_WeaponSCAR20 : C_CSWeaponBase {
};

struct C_WeaponTaser : C_CSWeaponBase {
};

struct C_Knife : C_CSWeaponBase {
};

struct C_Flashbang : C_CSWeaponBase {
};

struct C_HEGrenade : C_CSWeaponBase {
};

struct C_SmokeGrenade : C_CSWeaponBase {
};

struct C_MolotovGrenade : C_CSWeaponBase {
};

struct C_IncendiaryGrenade : C_CSWeaponBase {
};

struct C_DecoyGrenade : C_CSWeaponBase {
};

struct C_C4 : C_CSWeaponBase {
    using m_bStartedArming = bool;
    using m_fArmedTime = float;
};

struct C_Item_Healthshot : C_CSWeaponBase {
};

}

```

`Source/CS2/Classes/EntitySystem/CConcreteEntityList.h`:

```h
#pragma once

#include "CEntityIdentity.h"

namespace cs2
{

struct CConcreteEntityList {
    static constexpr auto kNumberOfChunks{64};
    static constexpr auto kNumberOfNetworkableEntityChunks{32};
    static constexpr auto kNumberOfIdentitiesPerChunk{512};

    using EntityChunk = CEntityIdentity[kNumberOfIdentitiesPerChunk];

    EntityChunk* chunks[kNumberOfChunks];
};

}

```

`Source/CS2/Classes/EntitySystem/CEntityClass.h`:

```h
#pragma once

namespace cs2
{

struct CEntityClass {};

}

```

`Source/CS2/Classes/EntitySystem/CEntityHandle.h`:

```h
#pragma once

#include <cstdint>

#include "CEntityIndex.h"

namespace cs2
{

struct CEntityHandle {
    [[nodiscard]] CEntityIndex index() const noexcept
    {
        return CEntityIndex{static_cast<int>(value & 0x7FFF)};
    }

    [[nodiscard]] constexpr bool operator==(const CEntityHandle&) const = default;

    std::uint32_t value;
};

}

```

`Source/CS2/Classes/EntitySystem/CEntityIdentity.h`:

```h
#pragma once

#include <Utils/Pad.h>

#include "CEntityHandle.h"

namespace cs2
{

struct CEntityInstance;
struct CEntityClass;

struct CEntityIdentity {
    CEntityInstance* entity;
    CEntityClass* entityClass;
    CEntityHandle handle;
    PAD(92);
};

static_assert(sizeof(CEntityIdentity) == 112);

}

```

`Source/CS2/Classes/EntitySystem/CEntityIndex.h`:

```h
#pragma once

namespace cs2
{

struct CEntityIndex {
    [[nodiscard]] constexpr bool isValid() const noexcept;

    int value;
};

constexpr CEntityIndex kMaxValidEntityIndex{0x7FFE};

constexpr bool CEntityIndex::isValid() const noexcept
{
    return value >= 0 && value <= kMaxValidEntityIndex.value;
}

}

```

`Source/CS2/Classes/EntitySystem/CGameEntitySystem.h`:

```h
#pragma once

#include <cstdint>
#include <CS2/Classes/CUtlMap.h>
#include "CEntityClass.h"

namespace cs2
{

struct CGameEntitySystem {
    using EntityClasses = CUtlMap<const char*, CEntityClass*, std::uint16_t>;
};

}

```

`Source/CS2/Classes/FileSystem.h`:

```h
#pragma once

#include "CUtlFilenameSymbolTable.h"

namespace cs2
{

struct CBaseFileSystem {
    using m_FileNames = CUtlFilenameSymbolTable;
};

}

```

`Source/CS2/Classes/GlobalVars.h`:

```h
#pragma once

#include <Utils/Pad.h>

namespace cs2
{

struct GlobalVars {
    PAD(48); // FIXME: get offset to curtime dynamically
    float curtime;
    using frametime = float;
};

}

```

`Source/CS2/Classes/Glow.h`:

```h
#pragma once

#include <Platform/Macros/IsPlatform.h>

#include "CSceneObject.h"
#include "Entities/C_BaseEntity.h"

namespace cs2
{

struct CGlowHelperSceneObject : CSceneObject {
    using entity = C_BaseEntity*;
    using attachedSceneObject = CSceneObject*;
};

#if IS_WIN64()

using ManageGlowSceneObject = void(
    CGlowHelperSceneObject** glowHelperSceneObject,
    CGlowHelperSceneObject** unused,
    CSceneObject* sceneObject,
    float color[4], float glowRangeMin, float glowRange, int glowType, float glowBackfaceMult);

#elif IS_LINUX()
          
using ManageGlowSceneObject = void(
    CGlowHelperSceneObject** glowHelperSceneObject,
    CGlowHelperSceneObject** unused,
    CSceneObject* sceneObject,
    int glowType,
    double colorGA, double colorRG, float glowRangeMin, float glowRange, float glowBackfaceMult);

#endif

}

```

`Source/CS2/Classes/IMemAlloc.h`:

```h
#pragma once

#include <cstddef>

namespace cs2
{

struct IMemAlloc {
    using Alloc = void*(IMemAlloc* thisptr, std::size_t size);

    const void* vmt;
};

}

```

`Source/CS2/Classes/SceneObjectUpdaterHandle_t.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

struct CSceneObject;

struct SceneObjectUpdaterHandle_t {
   using sceneObject = CSceneObject*;

   void* updaterFunctionParameter;
   std::uint64_t(*updaterFunction)(void* parameter, void* unknown, bool unknownBool);
};

}

```

`Source/CS2/Classes/Sound.h`:

```h
#pragma once

#include "CUtlFilenameSymbolTable.h"
#include "CUtlVector.h"
#include "Vector.h"

#include <Utils/Pad.h>

namespace cs2
{

struct CSfxTable {
    PAD(40); // TODO: get dynamically, was broken: 2024.05.23
    FileNameHandle_t fileNameHandle;
};

struct ChannelInfo1 {
    CSfxTable* sfx;
    int guid;
    PAD(52); // TODO: get sizeof dynamically, was broken: 2024.02.07, broken again (reverted to previous) 2024.05.23, broken again 2025.07.29
};

static_assert(sizeof(ChannelInfo1) == 64);

struct ChannelInfo2 {
    Vector origin;
    PAD(120);
};

static_assert(sizeof(ChannelInfo2) == 132);

struct SoundChannels {
    CUtlVector<ChannelInfo1> channelInfo1;
    CUtlVector<ChannelInfo2> channelInfo2;
};

}

```

`Source/CS2/Classes/VMatrix.h`:

```h
#pragma once

namespace cs2
{

struct VMatrix {
    static consteval VMatrix identity() noexcept
    {
        return VMatrix{{
            {1.0f, 0.0f, 0.0f, 0.0f},
            {0.0f, 1.0f, 0.0f, 0.0f},
            {0.0f, 0.0f, 1.0f, 0.0f},
            {0.0f, 0.0f, 0.0f, 1.0f}
        }};
    }

    float m[4][4];
};

}

```

`Source/CS2/Classes/Vector.h`:

```h
#pragma once

namespace cs2
{

struct Vector {
    float x, y, z;

    [[nodiscard]] constexpr float squareDistTo(const Vector& other) const noexcept
    {
        return (*this - other).squareLength();
    }

    [[nodiscard]] constexpr float squareLength() const noexcept
    {
        return x * x + y * y + z * z;
    }

    [[nodiscard]] friend constexpr Vector operator-(const Vector& a, const Vector& b) noexcept
    {
        return Vector{a.x - b.x, a.y - b.y, a.z - b.z};
    }

    [[nodiscard]] bool operator==(const Vector&) const = default;
};

}

```

`Source/CS2/Constants/AspectRatio.h`:

```h
#pragma once

namespace cs2
{

constexpr auto kDefaultAspectRatio{4.0f / 3.0f};

}

```

`Source/CS2/Constants/BombsiteIndex.h`:

```h
#pragma once

namespace cs2
{

enum class BombsiteIndex : int {
    BombsiteA = 0,
    BombsiteB = 1
};

}

```

`Source/CS2/Constants/ColorConstants.h`:

```h
#pragma once

#include <array>

#include <CS2/Classes/Color.h>

namespace cs2
{

constexpr Color kColorBlack{0, 0, 0};
constexpr Color kColorWhite{255, 255, 255};
constexpr Color kColorGreen{0, 180, 0};
constexpr Color kColorLightGreen{144, 238, 144};
constexpr Color kColorRed{255, 0, 0};
constexpr Color kColorYellow{255, 255, 0};
constexpr Color kColorSilver{192, 192, 192};

constexpr Color kColorTeamTT{234, 190, 84};
constexpr Color kColorTeamCT{150, 200, 250};

constexpr Color kColorPlayerYellow{248, 246, 45};
constexpr Color kColorPlayerPurple{192, 54, 153};
constexpr Color kColorPlayerGreen{29, 162, 132};
constexpr Color kColorPlayerBlue{136, 206, 245};
constexpr Color kColorPlayerOrange{255, 155, 37};

constexpr Color kColorDefuseKit{119, 221, 255};

constexpr Color kColorCrosshairRed{250, 50, 50};
constexpr Color kColorCrosshairGreen{50, 250, 50};
constexpr Color kColorCrosshairYellow{250, 250, 50};
constexpr Color kColorCrosshairBlue{50, 50, 250};
constexpr Color kColorCrosshairCyan{50, 250, 250};

}

```

`Source/CS2/Constants/CrosshairColorIndex.h`:

```h
#pragma once

namespace cs2
{

enum class CrosshairColorIndex {
    Red = 0,
    Green = 1,
    Yellow = 2,
    Blue = 3,
    Cyan = 4,
    RGB = 5
};

}

```

`Source/CS2/Constants/DllNames.h`:

```h
#pragma once

#include <Platform/Macros/PlatformSpecific.h>

namespace cs2
{

constexpr auto CLIENT_DLL = WIN64_LINUX("client.dll", "libclient.so");
constexpr auto ENGINE_DLL = WIN64_LINUX("engine2.dll", "libengine2.so");
constexpr auto FILESYSTEM_DLL = WIN64_LINUX("filesystem_stdio.dll", "libfilesystem_stdio.so");
constexpr auto PANORAMA_DLL = WIN64_LINUX("panorama.dll", "libpanorama.so");
constexpr auto SCENESYSTEM_DLL = WIN64_LINUX("scenesystem.dll", "libscenesystem.so");
constexpr auto SDL_DLL = WIN64_LINUX("SDL3.dll", "libSDL3.so.0");
constexpr auto SOUNDSYSTEM_DLL = WIN64_LINUX("soundsystem.dll", "libsoundsystem.so");
constexpr auto TIER0_DLL = WIN64_LINUX("tier0.dll", "libtier0.so");

}

```

`Source/CS2/Constants/EntityClasses.h`:

```h
#pragma once

#include <CS2/Classes/Entities/CBaseAnimGraph.h>
#include <CS2/Classes/Entities/C_CSGO_PreviewPlayer.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/C_Hostage.h>
#include <CS2/Classes/Entities/GrenadeProjectiles.h>
#include <CS2/Classes/Entities/WeaponEntities.h>
#include <CS2/Classes/CPlantedC4.h>
#include <Utils/TypedStaticStringPool.h>

namespace cs2
{

constexpr auto kEntityClassNames = TypedStaticStringPool{}
    .add<C_CSPlayerPawn>("C_CSPlayerPawn")
    .add<C_WeaponGlock>("C_WeaponGlock")
    .add<C_WeaponHKP2000>("C_WeaponHKP2000")
    .add<C_WeaponElite>("C_WeaponElite")
    .add<C_WeaponP250>("C_WeaponP250")
    .add<C_WeaponTec9>("C_WeaponTec9")
    .add<C_WeaponFiveSeven>("C_WeaponFiveSeven")
    .add<C_DEagle>("C_DEagle")
    .add<C_WeaponMAC10>("C_WeaponMAC10")
    .add<C_WeaponMP7>("C_WeaponMP7")
    .add<C_WeaponMP9>("C_WeaponMP9")
    .add<C_WeaponBizon>("C_WeaponBizon")
    .add<C_WeaponP90>("C_WeaponP90")
    .add<C_WeaponUMP45>("C_WeaponUMP45")
    .add<C_WeaponMag7>("C_WeaponMag7")
    .add<C_WeaponSawedoff>("C_WeaponSawedoff")
    .add<C_WeaponXM1014>("C_WeaponXM1014")
    .add<C_WeaponNOVA>("C_WeaponNOVA")
    .add<C_WeaponM249>("C_WeaponM249")
    .add<C_WeaponNegev>("C_WeaponNegev")
    .add<C_WeaponGalilAR>("C_WeaponGalilAR")
    .add<C_WeaponFamas>("C_WeaponFamas")
    .add<C_AK47>("C_AK47")
    .add<C_WeaponM4A1>("C_WeaponM4A1")
    .add<C_WeaponSG556>("C_WeaponSG556")
    .add<C_WeaponAug>("C_WeaponAug")
    .add<C_WeaponSSG08>("C_WeaponSSG08")
    .add<C_WeaponAWP>("C_WeaponAWP")
    .add<C_WeaponG3SG1>("C_WeaponG3SG1")
    .add<C_WeaponSCAR20>("C_WeaponSCAR20")
    .add<C_WeaponTaser>("C_WeaponTaser")
    .add<C_Knife>("C_Knife")
    .add<C_Flashbang>("C_Flashbang")
    .add<C_HEGrenade>("C_HEGrenade")
    .add<C_SmokeGrenade>("C_SmokeGrenade")
    .add<C_MolotovGrenade>("C_MolotovGrenade")
    .add<C_IncendiaryGrenade>("C_IncendiaryGrenade")
    .add<C_DecoyGrenade>("C_DecoyGrenade")
    .add<CBaseAnimGraph>("CBaseAnimGraph")
    .add<C_HEGrenadeProjectile>("C_HEGrenadeProjectile")
    .add<C_SmokeGrenadeProjectile>("C_SmokeGrenadeProjectile")
    .add<C_MolotovProjectile>("C_MolotovProjectile")
    .add<C_FlashbangProjectile>("C_FlashbangProjectile")
    .add<C_C4>("C_C4")
    .add<CPlantedC4>("C_PlantedC4")
    .add<C_Hostage>("C_Hostage")
    .add<C_Item_Healthshot>("C_Item_Healthshot")
    .add<C_CSGO_PreviewPlayer>("C_CSGO_PreviewPlayer");

using EntityClasses = decltype(kEntityClassNames)::TypeList;

}

```

`Source/CS2/Constants/EntityHandle.h`:

```h
#pragma once

namespace cs2
{

constexpr auto INVALID_EHANDLE_INDEX = 0xFFFFFFFF;

}

```

`Source/CS2/Constants/IconURLs.h`:

```h
#pragma once

namespace cs2
{

constexpr auto kBombSiteAIconUrl = "s2r://panorama/images/icons/ui/map_bombzone_a.vsvg";
constexpr auto kBombSiteBIconUrl = "s2r://panorama/images/icons/ui/map_bombzone_b.vsvg";
constexpr auto kBombsiteAPlantingIconUrl = "s2r://panorama/images/icons/ui/chatwheel_sitea.vsvg";
constexpr auto kBombsiteBPlantingIconUrl = "s2r://panorama/images/icons/ui/chatwheel_siteb.vsvg";

}

```

`Source/CS2/Constants/LifeStateConstants.h`:

```h
#pragma once

namespace cs2
{

constexpr auto LIFE_ALIVE = 0;

}

```

`Source/CS2/Constants/PanelIDs.h`:

```h
#pragma once

namespace cs2::panel_id
{

constexpr auto HudTeamCounter = "HudTeamCounter";
constexpr auto HudScope = "HudScope";
constexpr auto ScopeCircle = "ScopeCircle";
constexpr auto ScopeDust = "ScopeDust";
constexpr auto ScoreAndTimeAndBomb = "ScoreAndTimeAndBomb";
constexpr auto BombStatus = "BombStatus";
constexpr auto BombPlanted = "BombPlanted";
constexpr auto HudDeathNotice = "HudDeathNotice";
constexpr auto VisibleNotices = "VisibleNotices";
constexpr auto HudReticle = "HudReticle";
constexpr auto TimerText = "TimerText";

}

```

`Source/CS2/Constants/RoundWinStatus.h`:

```h
#pragma once

namespace cs2
{

enum class RoundWinStatus : int {
    None = 0
};

}

```

`Source/CS2/Constants/SceneObjectAttributeNames.h`:

```h
#pragma once

namespace cs2::scene_object_attribute
{

constexpr auto kSpawnInvulnerabilityHash = 0x244EC9B0; // murmur2 hash of "SpawnInvulnerability"
constexpr auto kInvulnerabilityColorHash = 0xB2CAF4DF; // murmur2 hash of "InvulnerabilityColor"

}

```

`Source/CS2/Constants/SoundNames.h`:

```h
#pragma once

#include <string_view>

#include <Platform/Macros/IsPlatform.h>

namespace cs2
{

#if IS_WIN64()
constexpr std::string_view kPlayerFootstepSoundsPath = "sounds\\player\\footsteps\\";
constexpr std::string_view kBombPlantSoundPath = "sounds\\weapons\\c4\\c4_initiate.vsnd";
constexpr std::string_view kBombSoundsPath = "sounds\\weapons\\c4\\";
constexpr std::string_view kWeaponSoundsPath = "sounds\\weapons\\";
#elif IS_LINUX()
constexpr std::string_view kPlayerFootstepSoundsPath = "sounds/player/footsteps/";
constexpr std::string_view kBombPlantSoundPath = "sounds/weapons/c4/c4_initiate.vsnd";
constexpr std::string_view kBombSoundsPath = "sounds/weapons/c4/";
constexpr std::string_view kWeaponSoundsPath = "sounds/weapons/";
#endif

constexpr std::string_view kZoomSoundNamePart = "zoom";
constexpr std::string_view kPlayerSuitSoundPrefix = "suit";
constexpr std::string_view kBassSoundPrefix = "bass";
constexpr std::string_view kBombBeepSoundsPrefix = "c4_beep";
constexpr std::string_view kBombDefuseStartSoundName = "c4_disarmstart.vsnd";
constexpr std::string_view kClipOutSoundSuffix = "clipout.vsnd";
constexpr std::string_view kCoverUpSoundSuffix = "coverup.vsnd";

}

```

`Source/CS2/Constants/StylePropertySymbolNames.h`:

```h
#pragma once

#include <CS2/Panorama/StyleProperties.h>
#include <Utils/TypedStaticStringPool.h>

namespace cs2
{
    
constexpr auto kStylePropertySymbolNames = TypedStaticStringPool{}
    .add<CStylePropertyWidth>("width")
    .add<CStylePropertyOpacity>("opacity")
    .add<CStylePropertyZIndex>("z-index")
    .add<CStylePropertyHeight>("height")
    .add<CStylePropertyImageShadow>("img-shadow")
    .add<CStylePropertyPosition>("position")
    .add<CStylePropertyTransformOrigin>("transform-origin")
    .add<CStylePropertyAlign>("align")
    .add<CStylePropertyWashColor>("wash-color")
    .add<CStylePropertyFlowChildren>("flow-children")
    .add<CStylePropertyFont>("font")
    .add<CStylePropertyTextShadow>("text-shadow")
    .add<CStylePropertyMargin>("margin")
    .add<CStylePropertyMixBlendMode>("-s2-mix-blend-mode")
    .add<CStylePropertyTextAlign>("text-align")
    .add<CStylePropertyForegroundColor>("color")
    .add<CStylePropertyBackgroundColor>("background-color")
    .add<CStylePropertyTransform3D>("transform")
    .add<CStylePropertyBorder>("border")
    .add<CStylePropertyBorderRadius>("border-radius");

}

```

`Source/CS2/Constants/StylePropertyTypeNames.h`:

```h
#pragma once

#include <CS2/Panorama/StyleProperties.h>
#include <Platform/Macros/PlatformSpecific.h>
#include <Utils/TypedStaticStringPool.h>

namespace cs2
{

constexpr auto kStylePropertyTypeNames = TypedStaticStringPool{}
    .add<CStylePropertyWidth>(WIN64_LINUX(".?AVCStylePropertyWidth@panorama@@", "N8panorama19CStylePropertyWidthE"))
    .add<CStylePropertyOpacity>(WIN64_LINUX(".?AVCStylePropertyOpacity@panorama@@", "N8panorama21CStylePropertyOpacityE"))
    .add<CStylePropertyZIndex>(WIN64_LINUX(".?AVCStylePropertyZIndex@panorama@@", "N8panorama20CStylePropertyZIndexE"))
    .add<CStylePropertyHeight>(WIN64_LINUX(".?AVCStylePropertyHeight@panorama@@", "N8panorama20CStylePropertyHeightE"))
    .add<CStylePropertyImageShadow>(WIN64_LINUX(".?AVCStylePropertyImageShadow@panorama@@", "N8panorama25CStylePropertyImageShadowE"))
    .add<CStylePropertyPosition>(WIN64_LINUX(".?AVCStylePropertyPosition@panorama@@", "N8panorama22CStylePropertyPositionE"))
    .add<CStylePropertyTransformOrigin>(WIN64_LINUX(".?AVCStylePropertyTransformOrigin@panorama@@", "N8panorama29CStylePropertyTransformOriginE"))
    .add<CStylePropertyAlign>(WIN64_LINUX(".?AVCStylePropertyAlign@panorama@@", "N8panorama19CStylePropertyAlignE"))
    .add<CStylePropertyWashColor>(WIN64_LINUX(".?AVCStylePropertyWashColor@panorama@@", "N8panorama23CStylePropertyWashColorE"))
    .add<CStylePropertyFlowChildren>(WIN64_LINUX(".?AVCStylePropertyFlowChildren@panorama@@", "N8panorama26CStylePropertyFlowChildrenE"))
    .add<CStylePropertyFont>(WIN64_LINUX(".?AVCStylePropertyFont@panorama@@", "N8panorama18CStylePropertyFontE"))
    .add<CStylePropertyTextShadow>(WIN64_LINUX(".?AVCStylePropertyTextShadow@panorama@@", "N8panorama24CStylePropertyTextShadowE"))
    .add<CStylePropertyMargin>(WIN64_LINUX(".?AVCStylePropertyMargin@panorama@@", "N8panorama20CStylePropertyMarginE"))
    .add<CStylePropertyMixBlendMode>(WIN64_LINUX(".?AVCStylePropertyMixBlendMode@panorama@@", "N8panorama26CStylePropertyMixBlendModeE"))
    .add<CStylePropertyTextAlign>(WIN64_LINUX(".?AVCStylePropertyTextAlign@panorama@@", "N8panorama23CStylePropertyTextAlignE"))
    .add<CStylePropertyForegroundColor>(WIN64_LINUX(".?AVCStylePropertyForegroundColor@panorama@@", "N8panorama29CStylePropertyForegroundColorE"))
    .add<CStylePropertyBackgroundColor>(WIN64_LINUX(".?AVCStylePropertyBackgroundColor@panorama@@", "N8panorama29CStylePropertyBackgroundColorE"))
    .add<CStylePropertyTransform3D>(WIN64_LINUX(".?AVCStylePropertyTransform3D@panorama@@", "N8panorama25CStylePropertyTransform3DE"))
    .add<CStylePropertyBorder>(WIN64_LINUX(".?AVCStylePropertyBorder@panorama@@", "N8panorama20CStylePropertyBorderE"))
    .add<CStylePropertyBorderRadius>(WIN64_LINUX(".?AVCStylePropertyBorderRadius@panorama@@", "N8panorama26CStylePropertyBorderRadiusE"));

}

```

`Source/CS2/Constants/TeamNumberConstants.h`:

```h
#pragma once

namespace cs2
{

constexpr auto TEAM_TERRORIST = 2;
constexpr auto TEAM_CT = 3;

}

```

`Source/CS2/Econ/ItemDefinitionIndex.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

// item_definition_index_t
enum class ItemDefinitionIndex : std::uint16_t {
    M4A4 = 16,
    Flashbang = 43,
    HEGrenade = 44,
    SmokeGrenade = 45,
    Incendiary = 48,
    M9Bayonet = 508
};

}

```

`Source/CS2/Econ/ItemId.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

// itemid_t
enum class ItemId : std::uint64_t {};

static constexpr auto kFauxItemIdMask{0xF000000000000000ull};
static constexpr auto kFauxItemIdPaintKitIndexShift{16};

}

```

`Source/CS2/Econ/PaintKitIndex.h`:

```h
#pragma once

namespace cs2
{

enum class PaintKitIndex : int {
    AsiimovM4A4 = 255,
    MarbleFade = 413
};

}

```

`Source/CS2/Panorama/CDropDown.h`:

```h
#pragma once

#include "CPanel2D.h"
#include "PanelHandle.h"

namespace cs2
{

struct CDropDown : CPanel2D {
    PanelHandle dropdownMenu;

    using SetSelectedIndex = void(CDropDown* thisptr, int index);
    using selectedOption = PanelHandle;

    using DropDownSelectionChangedHandler = bool(void* delegateThisptr, CPanel2D* panel);
};

struct CDropDownMenu : CPanel2D {
    CDropDown* dropdown;
    CPanel2D* selectedChild;
};

}

```

`Source/CS2/Panorama/CImagePanel.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <CS2/Classes/CUtlString.h>
#include <Utils/Pad.h>

#include "CPanel2D.h"

namespace cs2
{

enum class SvgAttributeType {
    FillColor = 0,

    Count = 11
};

struct SvgAttribute {
    std::byte value[4];
};

struct ImageProperties {
    PAD(16);
    int textureWidth;
    int textureHeight;
    float scale;
    SvgAttribute svgAttributes[static_cast<std::size_t>(SvgAttributeType::Count)];
    std::uint32_t presentSvgAttributes;
};

struct CImagePanel : CPanel2D {
    using m_strSource = CUtlString;

    using Constructor = void(CImagePanel* thisptr, CPanel2D* parent, const char* id);
    using SetImage = void(CImagePanel* thisptr, const char* imageUrl, const char* defaultImageUrl, ImageProperties* properties);
};

}

```

`Source/CS2/Panorama/CLabel.h`:

```h
#pragma once

#include "CPanel2D.h"

namespace cs2
{

struct CLabel : CPanel2D {
    using Constructor = void(CLabel* thisptr, CPanel2D* parent, const char* id);
    using setTextInternal = void (*)(CLabel* thisptr, const char* value, int textType, bool trustedSource);
};

}

```

`Source/CS2/Panorama/CPanel2D.h`:

```h
#pragma once

#include "PanelHandle.h"

namespace cs2
{

struct CUIPanel;

struct CPanel2D {
    const void* vmt;
    CUIPanel* uiPanel;
    PanelHandle tooltipHandle;
    void* v8Pointer;

    using Create = CPanel2D*(const char* id, CPanel2D* parent);
};

};

```

`Source/CS2/Panorama/CPanelStyle.h`:

```h
#pragma once

#include <CS2/Classes/CUtlMap.h>
#include <CS2/Classes/CUtlString.h>
#include "CStyleSymbol.h"

namespace cs2
{

struct CStyleProperty;

struct CPanelStyle {
    using SetProperty = void(CPanelStyle* thisptr, CStyleProperty* styleProperty, bool transition);

    using StylePropertySymbols = CUtlMap<CUtlString, CStyleSymbol>;
};

}

```

`Source/CS2/Panorama/CPanoramaSymbol.h`:

```h
#pragma once

namespace cs2
{

using CPanoramaSymbol = short;

}

```

`Source/CS2/Panorama/CSlider.h`:

```h
#pragma once

#include "CPanel2D.h"

namespace cs2
{

struct CSlider : CPanel2D {
    using SetValue = void(CSlider* thisptr, float value);

    using SliderValueChangedEventHandler = bool(void* delegateThisptr, CPanel2D* panel, float value);
};

}

```

`Source/CS2/Panorama/CStyleSymbol.h`:

```h
#pragma once

#include <cstdint>
#include <Platform/Macros/PlatformSpecific.h>

namespace cs2
{

struct LINUX_ONLY([[gnu::packed]]) CStyleSymbol {
    static constexpr auto kInvalidId{0xFF};

    [[nodiscard]] bool isValid() const noexcept
    {
        return m_Id != kInvalidId;
    }

    std::uint8_t m_Id{kInvalidId};
};

}

```

`Source/CS2/Panorama/CTextEntry.h`:

```h
#pragma once

#include "CPanel2D.h"

namespace cs2
{

struct CTextEntry : CPanel2D {
    using SetText = void(CTextEntry* thisptr, const char* text);

    using TextEntrySubmitEventHandler = bool(void* delegateThisptr, CPanel2D* panel, const char* value);
};

}

```

`Source/CS2/Panorama/CTopLevelWindow.h`:

```h
#pragma once

namespace cs2
{

struct CTopLevelWindow {
    using m_flScaleFactor = float;
};

}

```

`Source/CS2/Panorama/CUIEngine.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CUtlAbstractDelegate.h>
#include <Platform/Macros/IsPlatform.h>
#include "CPanel2D.h"
#include "CPanoramaSymbol.h"
#include "CUIPanel.h"
#include "PanelHandle.h"

namespace cs2
{

struct CUIEngine {
    using getPanelPointer = CUIPanel* (*)(CUIEngine* thisptr, const PanelHandle* handle);
    using runScript = void (*)(CUIEngine* thisptr, CUIPanel* contextPanel, const char* scriptSource, const char* originFile, std::uint64_t line);
    using makeSymbol = CPanoramaSymbol(*)(CUIEngine* thisptr, int type, const char* text);
    using onDeletePanel = void (*)(CUIEngine* thisptr, CPanel2D* panel);
    using RegisterEventHandler = void (*)(CUIEngine* thisptr, CPanoramaSymbol eventName, CUIPanel* panel, CUtlAbstractDelegate* handler);
};

}

```

`Source/CS2/Panorama/CUILength.h`:

```h
#pragma once

namespace cs2
{

struct CUILength {
    enum EUILengthTypes {
        k_EUILengthUnset,
        k_EUILengthLength,
        k_EUILengthPercent,
        k_EUILengthFitChildren,
        k_EUILengthFillParentFlow,
        k_EUILengthHeightPercentage,
        k_EUILengthWidthPercentage
    };

    [[nodiscard]] static constexpr CUILength pixels(float value) noexcept
    {
        return CUILength{value, k_EUILengthLength};
    }

    [[nodiscard]] static constexpr CUILength percent(float value) noexcept
    {
        return CUILength{value, k_EUILengthPercent};
    }

    [[nodiscard]] static constexpr CUILength fillParentFlow(float value) noexcept
    {
        return CUILength{value, k_EUILengthFillParentFlow};
    }

    [[nodiscard]] static constexpr CUILength heightPercentage(float value) noexcept
    {
        return CUILength{value, k_EUILengthHeightPercentage};
    }

    constexpr bool operator==(const CUILength&) const = default;

    float m_flValue;
    EUILengthTypes m_eType;
};

}

```

`Source/CS2/Panorama/CUIPanel.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CUtlString.h>
#include <CS2/Classes/CUtlVector.h>

#include "CPanel2D.h"
#include "CPanoramaSymbol.h"

namespace cs2
{

enum EPanelFlag {
    k_EPanelFlag_IsVisible = 0x01,
    k_EPanelFlag_HasOwnLayoutFile = 0x40
};

struct CUIPanel {
    const void* vmt;
    CPanel2D* clientPanel;

    using setParent = void (*)(CUIPanel* thisptr, CUIPanel* parent);
    using setVisible = void (*)(CUIPanel* thisptr, bool visible);
    using getAttributeString = const char* (*)(CUIPanel* thisptr, CPanoramaSymbol attributeName, const char* defaultValue);
    using setAttributeString = void (*)(CUIPanel* thisptr, CPanoramaSymbol attributeName, const char* value);

    using childrenVector = CUtlVector<CUIPanel*>;
    using classesVector = CUtlVector<CPanoramaSymbol>;
    using m_pchID = CUtlString;
    using PanelFlags = std::uint8_t;
};

}

```

`Source/CS2/Panorama/CUI_3dPanel.h`:

```h
#pragma once

#include <CS2/Classes/CCS_PortraitWorld.h>
#include <CS2/Panorama/CPanel2D.h>

namespace cs2
{

struct CUI_3dPanel : CPanel2D {
    using PortraitWorld = CCS_PortraitWorld*;
    using Fov = float;
    using FovWeight = float;
};

}

```

`Source/CS2/Panorama/CUI_Item3dPanel.h`:

```h
#pragma once

#include <cstdint>
#include <CS2/Econ/ItemId.h>
#include <CS2/Panorama/CUI_3dPanel.h>

namespace cs2
{

struct CUI_Item3dPanel : CUI_3dPanel {
    using SetItemItemId = void(cs2::CUI_Item3dPanel* thisptr, ItemId itemId, const char* attributes);

    struct Properties {
        using UnknownField = std::int32_t;
    };
    using StartWeaponLookAt = bool;
};

}

```

`Source/CS2/Panorama/PanelHandle.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{
    
struct PanelHandle {
    std::int32_t panelIndex = -1;
    std::uint32_t serialNumber;

    [[nodiscard]] bool isValid() const noexcept
    {
        return panelIndex != -1;
    }

    [[nodiscard]] constexpr bool operator==(const PanelHandle&) const = default;
};

}

```

`Source/CS2/Panorama/StyleEnums.h`:

```h
#pragma once

#include <cstdint>

namespace cs2
{

enum EHorizontalAlignment : std::uint8_t {
    k_EHorizontalAlignmentUnset,
    k_EHorizontalAlignmentLeft,
    k_EHorizontalAlignmentCenter,
    k_EHorizontalAlignmentRight
};

enum EVerticalAlignment : std::uint8_t {
    k_EVerticalAlignmentUnset,
    k_EVerticalAlignmentTop,
    k_EVerticalAlignmentCenter,
    k_EVerticalAlignmentBottom
};

enum EFlowDirection : std::uint8_t {
    k_EFlowNone = 1,
    k_EFlowDown,
    k_EFlowRight
};

enum EFontStyle : std::int8_t {
    k_EFontStyleUnset = -1,
    k_EFontStyleNormal = 0,
    k_EFontStyleItalic = 2,
};

enum EFontWeight : std::int8_t {
    k_EFontWeightUnset = -1,
    k_EFontWeightNormal = 0,
    k_EFontWeightMedium = 1,
    k_EFontWeightBold = 2,
    k_EFontWeightBlack = 3,
    k_EFontWeightThin = 4,
    k_EFontWeightLight = 5,
    k_EFontWeightSemiBold = 6,
};

enum EFontStretch : std::int8_t {
    k_EFontStretchUnset = -1,
    k_EFontStretchNormal = 0,
    k_EFontStretchCondensed = 1,
    k_EFontStretchExpanded = 2
};

enum EMixBlendMode : std::uint8_t {
    k_EMixBlendModeNormal,
    k_EMixBlendModeMultiply,
    k_EMixBlendModeScreen,
    k_EMixBlendModeAdditive,
    k_EMixBlendModeOpaque
};

enum ETextAlign : std::int8_t {
    k_ETextAlignUnset = -1,
    k_ETextAlignLeft = 0,
    k_ETextAlignCenter = 1,
    k_ETextAlignRight = 2,
    k_ETextAlignJustify = 3,
    k_ETextAlignJustifyLetterSpacing = 4
};

enum EStrokeType : std::uint32_t {
    k_EStrokeTypeFillColor,
    k_EStrokeTypeLinearGradient,
    k_EStrokeTypeRadialGradient
};

enum EBorderStyle : std::int8_t {
    k_EBorderStyleSolid = 1
};

}

```

`Source/CS2/Panorama/StyleProperties.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>
#include <CS2/Classes/CUtlString.h>
#include <CS2/Classes/VMatrix.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <Platform/Macros/PlatformSpecific.h>

#include "CStyleSymbol.h"
#include "Transform3D.h"

namespace cs2
{

struct CStyleProperty {
};

#define BASE_STYLE_PROPERTY_FIELDS() \
const void* vmt; \
CStyleSymbol m_symPropertyName; \
bool m_bDisallowTransition; \
WIN64_ONLY(std::byte pad[6]{};)

struct CStylePropertyWidth : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUILength m_Length;
};
static_assert(std::is_standard_layout_v<CStylePropertyWidth>);
static_assert(sizeof(CStylePropertyWidth) == 24);
static_assert(offsetof(CStylePropertyWidth, m_Length) == WIN64_LINUX(16, 12));

struct CStylePropertyOpacity : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    float opacity;
};
static_assert(std::is_standard_layout_v<CStylePropertyOpacity>);
static_assert(sizeof(CStylePropertyOpacity) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyOpacity, opacity) == WIN64_LINUX(16, 12));

struct CStylePropertyZIndex : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    float zindex;
};
static_assert(std::is_standard_layout_v<CStylePropertyZIndex>);
static_assert(sizeof(CStylePropertyZIndex) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyZIndex, zindex) == WIN64_LINUX(16, 12));

struct CStylePropertyHeight : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUILength m_Height;
};
static_assert(std::is_standard_layout_v<CStylePropertyHeight>);
static_assert(sizeof(CStylePropertyHeight) == 24);
static_assert(offsetof(CStylePropertyHeight, m_Height) == WIN64_LINUX(16, 12));

struct CStylePropertyImageShadow : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    bool fullySet;
    CUILength horizontalOffset;
    CUILength verticalOffset;
    CUILength blurRadius;
    float strength;
    Color color;
};
static_assert(std::is_standard_layout_v<CStylePropertyImageShadow>);
static_assert(sizeof(CStylePropertyImageShadow) == WIN64_LINUX(56, 48));
static_assert(offsetof(CStylePropertyImageShadow, fullySet) == WIN64_LINUX(16, 10));
static_assert(offsetof(CStylePropertyImageShadow, horizontalOffset) == WIN64_LINUX(20, 12));
static_assert(offsetof(CStylePropertyImageShadow, verticalOffset) == WIN64_LINUX(28, 20));
static_assert(offsetof(CStylePropertyImageShadow, blurRadius) == WIN64_LINUX(36, 28));
static_assert(offsetof(CStylePropertyImageShadow, strength) == WIN64_LINUX(44, 36));
static_assert(offsetof(CStylePropertyImageShadow, color) == WIN64_LINUX(48, 40));

struct CStylePropertyPosition : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUILength x;
    CUILength y;
    CUILength z;
};
static_assert(std::is_standard_layout_v<CStylePropertyPosition>);
static_assert(sizeof(CStylePropertyPosition) == 40);
static_assert(offsetof(CStylePropertyPosition, x) == WIN64_LINUX(16, 12));
static_assert(offsetof(CStylePropertyPosition, y) == WIN64_LINUX(24, 20));
static_assert(offsetof(CStylePropertyPosition, z) == WIN64_LINUX(32, 28));

struct CStylePropertyTransformOrigin : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUILength x;
    CUILength y;
    bool m_bParentRelative;
};
static_assert(std::is_standard_layout_v<CStylePropertyTransformOrigin>);
static_assert(sizeof(CStylePropertyTransformOrigin) == WIN64_LINUX(40, 32));
static_assert(offsetof(CStylePropertyTransformOrigin, x) == WIN64_LINUX(16, 12));
static_assert(offsetof(CStylePropertyTransformOrigin, y) == WIN64_LINUX(24, 20));
static_assert(offsetof(CStylePropertyTransformOrigin, m_bParentRelative) == WIN64_LINUX(32, 28));

struct CStylePropertyAlign : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    EHorizontalAlignment m_eHorizontalAlignment;
    EVerticalAlignment m_eVerticalAlignment;
};
static_assert(std::is_standard_layout_v<CStylePropertyAlign>);
static_assert(sizeof(CStylePropertyAlign) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyAlign, m_eHorizontalAlignment) == WIN64_LINUX(16, 10));
static_assert(offsetof(CStylePropertyAlign, m_eVerticalAlignment) == WIN64_LINUX(17, 11));

struct CStylePropertyWashColor : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    Color color;
    bool fullySet;
};
static_assert(std::is_standard_layout_v<CStylePropertyWashColor>);
static_assert(sizeof(CStylePropertyWashColor) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyWashColor, color) == WIN64_LINUX(16, 10));
static_assert(offsetof(CStylePropertyWashColor, fullySet) == WIN64_LINUX(20, 14));

struct CStylePropertyFlowChildren : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    EFlowDirection m_eFlowDirection;
};
static_assert(std::is_standard_layout_v<CStylePropertyFlowChildren>);
static_assert(sizeof(CStylePropertyFlowChildren) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyFlowChildren, m_eFlowDirection) == WIN64_LINUX(16, 10));

struct CStylePropertyFont : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUtlString m_strFontFamily;
    float m_flFontSize;
    EFontStyle m_eFontStyle;
    EFontWeight m_eFontWeight;
    EFontStretch m_eFontStretch;
};
static_assert(std::is_standard_layout_v<CStylePropertyFont>);
static_assert(sizeof(CStylePropertyFont) == 32);
static_assert(offsetof(CStylePropertyFont, m_strFontFamily) == 16);
static_assert(offsetof(CStylePropertyFont, m_flFontSize) == 24);
static_assert(offsetof(CStylePropertyFont, m_eFontStyle) == 28);
static_assert(offsetof(CStylePropertyFont, m_eFontWeight) == 29);
static_assert(offsetof(CStylePropertyFont, m_eFontStretch) == 30);

struct CStylePropertyTextShadow : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    bool fullySet;
    CUILength horizontalOffset;
    CUILength verticalOffset;
    CUILength blurRadius;
    float strength;
    Color color;
};
static_assert(std::is_standard_layout_v<CStylePropertyTextShadow>);
static_assert(sizeof(CStylePropertyTextShadow) == WIN64_LINUX(56, 48));
static_assert(offsetof(CStylePropertyTextShadow, fullySet) == WIN64_LINUX(16, 10));
static_assert(offsetof(CStylePropertyTextShadow, horizontalOffset) == WIN64_LINUX(20, 12));
static_assert(offsetof(CStylePropertyTextShadow, verticalOffset) == WIN64_LINUX(28, 20));
static_assert(offsetof(CStylePropertyTextShadow, blurRadius) == WIN64_LINUX(36, 28));
static_assert(offsetof(CStylePropertyTextShadow, strength) == WIN64_LINUX(44, 36));
static_assert(offsetof(CStylePropertyTextShadow, color) == WIN64_LINUX(48, 40));

struct CStylePropertyMixBlendMode : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    EMixBlendMode m_eMixBlendMode;
    bool m_bSet;
};
static_assert(std::is_standard_layout_v<CStylePropertyMixBlendMode>);
static_assert(sizeof(CStylePropertyMixBlendMode) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyMixBlendMode, m_eMixBlendMode) == WIN64_LINUX(16, 10));
static_assert(offsetof(CStylePropertyMixBlendMode, m_bSet) == WIN64_LINUX(17, 11));

struct CStylePropertyTextAlign : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    ETextAlign m_eAlign;
};
static_assert(std::is_standard_layout_v<CStylePropertyTextAlign>);
static_assert(sizeof(CStylePropertyTextAlign) == WIN64_LINUX(24, 16));
static_assert(offsetof(CStylePropertyTextAlign, m_eAlign) == WIN64_LINUX(16, 10));

struct CStylePropertyMargin : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUILength m_left;
    CUILength m_top;
    CUILength m_right;
    CUILength m_bottom;
};
static_assert(std::is_standard_layout_v<CStylePropertyMargin>);
static_assert(sizeof(CStylePropertyMargin) == 48);
static_assert(offsetof(CStylePropertyMargin, m_left) == WIN64_LINUX(16, 12));
static_assert(offsetof(CStylePropertyMargin, m_top) == WIN64_LINUX(24, 20));
static_assert(offsetof(CStylePropertyMargin, m_right) == WIN64_LINUX(32, 28));
static_assert(offsetof(CStylePropertyMargin, m_bottom) == WIN64_LINUX(40, 36));

struct CFillBrush {
    EStrokeType type;
    union {
        Color fillColor;
        struct CLinearGradient* linearGradient;
        struct CRadialGradient* radialGradient;
    };
    float opacity;
};
static_assert(offsetof(CFillBrush, fillColor) == 8);
static_assert(sizeof(CFillBrush) == 24);

struct CStylePropertyFillColor : CStyleProperty {
};

template <typename T>
struct FixedGrowableVector {
    int numberOfElements;
    int growSize;
    union {
        T* elements;
        T element;
    };
};

#define STYLE_PROPERTY_FILLCOLOR_FIELDS() \
BASE_STYLE_PROPERTY_FIELDS(); \
FixedGrowableVector<CFillBrush> fillBrushes

struct CStylePropertyForegroundColor : CStylePropertyFillColor {
    STYLE_PROPERTY_FILLCOLOR_FIELDS();
};
static_assert(std::is_standard_layout_v<CStylePropertyForegroundColor>);
static_assert(sizeof(CStylePropertyForegroundColor) == 48);
static_assert(offsetof(CStylePropertyForegroundColor, fillBrushes) == 16);

struct CStylePropertyBackgroundColor : CStylePropertyFillColor {
    STYLE_PROPERTY_FILLCOLOR_FIELDS();
    float opacity;
};
static_assert(std::is_standard_layout_v<CStylePropertyBackgroundColor>);
static_assert(sizeof(CStylePropertyBackgroundColor) == 56);
static_assert(offsetof(CStylePropertyBackgroundColor, fillBrushes) == 16);
static_assert(offsetof(CStylePropertyBackgroundColor, opacity) == 48);

struct CStylePropertyTransform3D : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CUtlVector<CTransform3D*> transforms;
    float cachedParentWidth;
    float cachedParentHeight;
    bool dirty;
    VMatrix matrix;
    bool interpolated;
    bool fullySet;
};
static_assert(std::is_standard_layout_v<CStylePropertyTransform3D>);
static_assert(sizeof(CStylePropertyTransform3D) == 120);
static_assert(offsetof(CStylePropertyTransform3D, transforms) == 16);
static_assert(offsetof(CStylePropertyTransform3D, cachedParentWidth) == 40);
static_assert(offsetof(CStylePropertyTransform3D, cachedParentHeight) == 44);
static_assert(offsetof(CStylePropertyTransform3D, dirty) == 48);
static_assert(offsetof(CStylePropertyTransform3D, matrix) == 52);
static_assert(offsetof(CStylePropertyTransform3D, interpolated) == 116);
static_assert(offsetof(CStylePropertyTransform3D, fullySet) == 117);

struct CStylePropertyBorder : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    EBorderStyle m_rgBorderStyle[4];
    CUILength m_rgBorderWidth[4];
    bool m_rgColorsSet[4];
    Color m_rgBorderColor[4];
};
static_assert(std::is_standard_layout_v<CStylePropertyBorder>);

struct CornerRadii_t {
    CUILength horizontalRadius;
    CUILength verticalRadius;
};

struct CStylePropertyBorderRadius : CStyleProperty {
    BASE_STYLE_PROPERTY_FIELDS();
    CornerRadii_t m_rgCornerRaddi[4];
};
static_assert(std::is_standard_layout_v<CStylePropertyBorderRadius>);

};

```

`Source/CS2/Panorama/Transform3D.h`:

```h
#pragma once

#include <CS2/Classes/Vector.h>
#include "CUILength.h"

namespace cs2
{

struct CTransform3D {
    const void* vmt;
};

struct CTransformTranslate3D : CTransform3D {
    CUILength m_x;
    CUILength m_y;
    CUILength m_z;
};

struct CTransformScale3D : CTransform3D {
    Vector m_VecScale;
};

}

```

`Source/Common/Visibility.h`:

```h
#pragma once

enum class Visibility : bool {
    Hidden,
    Visible
};

```

`Source/Config/Config.h`:

```h
#pragma once

#include <cassert>
#include <BuildConfig.h>
#include <MemoryAllocation/UniquePtr.h>
#include <Platform/PlatformPath.h>

#include "ConfigFileOperation.h"
#include "ConfigFromString.h"
#include "ConfigSchema.h"
#include "ConfigStringConversionState.h"
#include "ConfigToString.h"
#include "ConfigVariableChangeHandler.h"

#if IS_WIN64()
#include <Platform/Windows/FileSystem/WindowsFileSystem.h>
#include <Platform/Macros/PlatformSpecific.h>
#include <Utils/Wcslen.h>
#elif IS_LINUX()
#include <Platform/Linux/LinuxPlatformApi.h>
#endif

template <typename HookContext>
class Config {
public:
    explicit Config(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void init() noexcept
    {
        buildConfigDirectoryPath();
        buildConfigFilePath(WIN64_LINUX(L"default.cfg", "default.cfg"));
        buildConfigTempFilePath();
        static constinit char8_t fileOperationBuffer[build::kConfigFileBufferSize];
        state().fileOperationBuffer = fileOperationBuffer;
    }

    template <typename ConfigVariable>
    [[nodiscard]] auto getVariable() noexcept
    {
        return state().configVariables.template getVariableValue<ConfigVariable>();
    }

    template <typename ConfigVariable>
    bool setVariable(ConfigVariable::ValueType newValue) noexcept
    {
        if (changeVariableValue<ConfigVariable>(newValue)) {
            scheduleAutoSave();
            return true;
        }
        return false;
    }

    template <typename ConfigVariable>
    void setVariableWithoutAutoSave(ConfigVariable::ValueType newValue) noexcept
    {
        changeVariableValue<ConfigVariable>(newValue);
    }

    void restoreDefaults() noexcept
    {
        ConfigVariableTypes::forEach([this] <typename ConfigVariable> (std::type_identity<ConfigVariable>) {
            this->setVariableWithoutAutoSave<ConfigVariable>(ConfigVariable::kDefaultValue);
        });
        scheduleAutoSave();
        hookContext.gui().updateFromConfig();
    }

    void scheduleLoad() noexcept
    {
        state().loadScheduled = true;
    }

    void update()
    {
        switch (state().currentFileOperation) {
        case ConfigFileOperation::None:
            if (state().autoSaveScheduled) {
                state().currentFileOperation = ConfigFileOperation::Save;
                prepareSaveToFile();
                state().autoSaveScheduled = false;
                break;
            }
            if (state().loadScheduled) {
                state().currentFileOperation = ConfigFileOperation::Load;
                state().bufferUsedBytes = 0;
                state().loadScheduled = false;
                break;
            }
            break;
        case ConfigFileOperation::Load:
            finishLoadFromFile();
            break;
        default:
            break;
        }
    }

    void performFileOperation() noexcept
    {
        switch (state().currentFileOperation) {
        case ConfigFileOperation::Load:
            loadFromFile();
            break;
        case ConfigFileOperation::Save:
            saveToFile();
            break;
        default:
            break;
        }
    }

private:
    template <typename ConfigVariable>
    bool changeVariableValue(ConfigVariable::ValueType newValue) noexcept
    {
        if (getVariable<ConfigVariable>() == newValue)
            return false;

        ConfigVariableChangeHandler{hookContext}.template onConfigVariableValueChanged<ConfigVariable>(newValue);
        state().configVariables.template storeVariableValue<ConfigVariable>(newValue);
        return true;
    }

    void scheduleAutoSave() noexcept
    {
        state().autoSaveScheduled = true;
    }

    [[nodiscard]] auto& state()
    {
        return hookContext.configState();
    }

    void loadFromFile() noexcept
    {
        if (!state().pathToConfigFile)
            return;

#if IS_WIN64()
        const std::basic_string_view path{state().pathToConfigFile.get(), utils::wcslen(state().pathToConfigFile.get())};
        UNICODE_STRING pathStr{.Length = static_cast<USHORT>(path.length() * sizeof(wchar_t)), .MaximumLength = static_cast<USHORT>(path.length() * sizeof(wchar_t)), .Buffer = const_cast<wchar_t*>(path.data())};
        if (const auto handle = WindowsFileSystem::openFileForReading(pathStr); handle != INVALID_HANDLE_VALUE) {
            state().bufferUsedBytes = WindowsFileSystem::readFile(handle, 0, state().fileOperationBuffer, build::kConfigFileBufferSize);
            WindowsSyscalls::NtClose(handle);
        }
#elif IS_LINUX()
        if (const auto fd = LinuxPlatformApi::open(state().pathToConfigFile.get(), O_RDONLY); fd >= 0) {
            if (const auto read = LinuxPlatformApi::pread(fd, state().fileOperationBuffer, build::kConfigFileBufferSize, 0); read > 0)
                state().bufferUsedBytes = static_cast<std::size_t>(read);
            LinuxPlatformApi::close(fd);
        }
#endif
    }

    void finishLoadFromFile()
    {
        assert(state().currentFileOperation == ConfigFileOperation::Load);
        state().currentFileOperation = ConfigFileOperation::None;

        const auto readBytes = state().bufferUsedBytes;
        assert(readBytes < build::kConfigFileBufferSize && "Currently file must fit into a buffer");
        ConfigStringConversionState conversionState;
        std::size_t parsedBytes{0};
        do {
            assert(conversionState.offset <= readBytes);
            ConfigFromString configFromString{std::span{state().fileOperationBuffer + conversionState.offset, readBytes - conversionState.offset}, conversionState};
            parsedBytes = ConfigSchema{hookContext}.performConversion(configFromString);
        } while (parsedBytes != 0 && (conversionState.nestingLevel != 0 || conversionState.indexInNestingLevel[0] != 1));
        
        assert(readBytes == 0 || (conversionState.nestingLevel == 0 && conversionState.indexInNestingLevel[0] == 1));
        hookContext.gui().updateFromConfig();
    }

    void prepareSaveToFile()
    {
        ConfigStringConversionState conversionState;
        ConfigToString configToString{std::span{state().fileOperationBuffer, build::kConfigFileBufferSize}, conversionState};
        state().bufferUsedBytes = ConfigSchema{hookContext}.performConversion(configToString);
        assert(conversionState.nestingLevel == 0 && conversionState.indexInNestingLevel[0] == 1);
    }

    void saveToFile() noexcept
    {
        assert(state().currentFileOperation == ConfigFileOperation::Save);
        state().currentFileOperation = ConfigFileOperation::None;

        if (!hookContext.osirisDirectoryPath().get() || !state().pathToConfigDirectory || !state().pathToConfigFile || !state().pathToConfigTempFile)
            return;

        const auto numberOfBytesToWrite = state().bufferUsedBytes;
#if IS_WIN64()
        WindowsFileSystem::createDirectory(hookContext.osirisDirectoryPath().get());
        WindowsFileSystem::createDirectory(state().pathToConfigDirectory.get());

        if (const auto handle = WindowsFileSystem::createFileForOverwrite(state().pathToConfigTempFile.get()); handle != INVALID_HANDLE_VALUE) {
            if (WindowsFileSystem::writeFile(handle, 0, state().fileOperationBuffer, numberOfBytesToWrite) == numberOfBytesToWrite)
                WindowsFileSystem::renameFile(handle, state().pathToConfigFile.get());
            WindowsSyscalls::NtClose(handle);
        }
#elif IS_LINUX()
        mkdir(hookContext.osirisDirectoryPath().get(), 0777);
        mkdir(state().pathToConfigDirectory.get(), 0777);

        if (const auto fd = LinuxPlatformApi::open(state().pathToConfigTempFile.get(), O_CREAT | O_WRONLY, 0666); fd >= 0) {
            if (std::cmp_equal(LinuxPlatformApi::write(fd, state().fileOperationBuffer, numberOfBytesToWrite), numberOfBytesToWrite))
                rename(state().pathToConfigTempFile.get(), state().pathToConfigFile.get());
            LinuxPlatformApi::close(fd);
        }
#endif
    }

    void buildConfigDirectoryPath() noexcept
    {
        if (!hookContext.osirisDirectoryPath().get())
            return;

        const std::basic_string_view osirisDirectoryPath{hookContext.osirisDirectoryPath().get(), WIN64_LINUX(utils::wcslen, std::strlen)(hookContext.osirisDirectoryPath().get())};
        constexpr auto kPathSeparatorLength{1};
        constexpr auto kNullTerminatorLength{1};
        const auto length = osirisDirectoryPath.length() + kPathSeparatorLength + build::kConfigDirectoryName.length() + kNullTerminatorLength;
        state().pathToConfigDirectory = mem::makeUniqueForOverwrite<platform::PathCharType[]>(length);
        if (!state().pathToConfigDirectory)
            return;
        std::size_t writeIndex{0};
        std::ranges::copy(osirisDirectoryPath, state().pathToConfigDirectory.get() + writeIndex);
        writeIndex += osirisDirectoryPath.length();
        state().pathToConfigDirectory.get()[writeIndex++] = platform::kPathSeparator;
        std::ranges::copy(build::kConfigDirectoryName, state().pathToConfigDirectory.get() + writeIndex);
        writeIndex += build::kConfigDirectoryName.length();
        state().pathToConfigDirectory.get()[writeIndex++] = 0;
    }

    void buildConfigFilePath(std::basic_string_view<platform::PathCharType> configFileName) noexcept
    {
        if (!state().pathToConfigDirectory)
            return;

        const std::basic_string_view pathToConfigDirectory{state().pathToConfigDirectory.get(), WIN64_LINUX(utils::wcslen, std::strlen)(state().pathToConfigDirectory.get())};
        constexpr auto kPathSeparatorLength{1};
        constexpr auto kNullTerminatorLength{1};
        const auto length = pathToConfigDirectory.length() + kPathSeparatorLength + configFileName.length() + kNullTerminatorLength;
        state().pathToConfigFile = mem::makeUniqueForOverwrite<platform::PathCharType[]>(length);
        if (!state().pathToConfigFile)
            return;
        std::size_t writeIndex{0};
        std::ranges::copy(pathToConfigDirectory, state().pathToConfigFile.get() + writeIndex);
        writeIndex += pathToConfigDirectory.length();
        state().pathToConfigFile.get()[writeIndex++] = platform::kPathSeparator;
        std::ranges::copy(configFileName, state().pathToConfigFile.get() + writeIndex);
        writeIndex += configFileName.length();
        state().pathToConfigFile.get()[writeIndex++] = 0;
    }

    void buildConfigTempFilePath() noexcept
    {
        if (!state().pathToConfigFile)
            return;

        const std::basic_string_view pathToConfigFile{state().pathToConfigFile.get(), WIN64_LINUX(utils::wcslen, std::strlen)(state().pathToConfigFile.get())};
        const std::basic_string_view configTempFileSuffix{WIN64_LINUX(L".new", ".new")};
        constexpr auto kNullTerminatorLength{1};
        const auto length = pathToConfigFile.length() + configTempFileSuffix.length() + kNullTerminatorLength;
        state().pathToConfigTempFile = mem::makeUniqueForOverwrite<platform::PathCharType[]>(length);
        if (!state().pathToConfigTempFile)
            return;
        std::size_t writeIndex{0};
        std::ranges::copy(pathToConfigFile, state().pathToConfigTempFile.get() + writeIndex);
        writeIndex += pathToConfigFile.length();
        std::ranges::copy(configTempFileSuffix, state().pathToConfigTempFile.get() + writeIndex);
        writeIndex += configTempFileSuffix.length();
        state().pathToConfigTempFile.get()[writeIndex++] = 0;
    }

    HookContext& hookContext;
};

```

`Source/Config/ConfigFileOperation.h`:

```h
#pragma once

enum class ConfigFileOperation {
    None,
    Load,
    Save
};

```

`Source/Config/ConfigFromString.h`:

```h
#pragma once

#include <span>

#include "ConfigStringConversionState.h"
#include <Platform/Macros/FunctionAttributes.h>

class ConfigFromString {
public:
    ConfigFromString(std::span<const char8_t> buffer, ConfigStringConversionState& conversionState) noexcept
        : buffer{buffer}
        , conversionState{conversionState}
    {
    }

    void beginRoot() noexcept
    {
        if (shouldReadMe() && skipWhitespaces() && readChar(u8'{'))
            increaseConversionNestingLevel();
        increaseNestingLevel();
    }

    [[nodiscard]] std::size_t endRoot() noexcept
    {
        if (shouldReadMe() && skipWhitespaces() && readChar(u8'}'))
            markConversionComplete();
        decreaseNestingLevel();
        conversionState.offset += readIndex;
        return readIndex;
    }

    void beginObject(const char8_t* key) noexcept
    {
        if (shouldReadMe()) {
            const auto previousReadIndex = readIndex;
            if (readUntilStartOfValue(key) && readChar(u8'{'))
                increaseConversionNestingLevel();
            else
                readIndex = previousReadIndex;
        }
        increaseNestingLevel();
    }

    void endObject() noexcept
    {
        if (shouldReadMe() && skipWhitespaces() && readChar(u8'}'))
            decreaseConversionNestingLevel();
        decreaseNestingLevel();
    }

    void boolean(const char8_t* key, auto&& valueSetter, auto&& /* valueGetter */)
    {
        if (bool value; parseBool(key, value))
            valueSetter(value);
    }

    void uint(const char8_t* key, auto&& valueSetter, auto&& /* valueGetter */)
    {
        if (std::uint64_t value; parseUint(key, value))
            valueSetter(value);
    }

private:
    [[nodiscard]] bool parseBool(const char8_t* key, bool& value) noexcept
    {
        bool parsed = false;
        if (shouldReadMe()) {
            const auto previousReadIndex = readIndex;
            if (readUntilStartOfValue(key) && parseBool(value)) {
                parsed = true;
                markElementReadAtCurrentNestingLevel();
            } else {
                readIndex = previousReadIndex;
            }
        }
        increaseIndexInNestingLevel();
        return parsed;
    }

    [[nodiscard]] bool parseUint(const char8_t* key, std::uint64_t& value) noexcept
    {
        bool parsed = false;
        if (shouldReadMe()) {
            const auto previousReadIndex = readIndex;
            if (readUntilStartOfValue(key) && parseUint(value)) {
                parsed = true;
                markElementReadAtCurrentNestingLevel();
            } else {
                readIndex = previousReadIndex;
            }
        }
        increaseIndexInNestingLevel();
        return parsed;
    }

    void markConversionComplete() noexcept
    {
        assert(conversionState.nestingLevel == 1);
        assert(conversionState.indexInNestingLevel[0] == 0);
        ++conversionState.indexInNestingLevel[--conversionState.nestingLevel];
    }

    void markElementReadAtCurrentNestingLevel() noexcept
    {
        conversionState.indexInNestingLevel[conversionState.nestingLevel] = 0;
    }

    [[nodiscard]] bool readUntilStartOfValue(const char8_t* key) noexcept
    {
        return readCommaAfterPreviousElement() && readKey(key) && skipWhitespaces();
    }

    [[nodiscard]] bool readCommaAfterPreviousElement() noexcept
    {
        if (conversionState.indexInNestingLevel[conversionState.nestingLevel] != config_params::kInvalidObjectIndex) {
            skipWhitespaces();
            return readChar(u8',');
        }
        return true;
    }

    [[nodiscard]] bool readKey(const char8_t* key) noexcept
    {
        return skipWhitespaces() && readChar(u8'"') && readString(key) && readChar(u8'"') && skipWhitespaces() && readChar(u8':');
    }

    void increaseNestingLevel() noexcept
    {
        assert(nestingLevel < config_params::kMaxNestingLevel);
        indexInNestingLevel[++nestingLevel] = 0;
    }

    void increaseConversionNestingLevel() noexcept
    {
        assert(conversionState.nestingLevel < config_params::kMaxNestingLevel);
        conversionState.indexInNestingLevel[conversionState.nestingLevel] = indexInNestingLevel[nestingLevel];
        conversionState.indexInNestingLevel[++conversionState.nestingLevel] = config_params::kInvalidObjectIndex;
    }

    void decreaseNestingLevel() noexcept
    {
        assert(nestingLevel > 0);
        assert(indexInNestingLevel[nestingLevel - 1] < config_params::kMaxObjectIndex);
        ++indexInNestingLevel[--nestingLevel];
    }

    void decreaseConversionNestingLevel() noexcept
    {
        assert(conversionState.nestingLevel > 0);
        --conversionState.nestingLevel;
    }  

    void increaseIndexInNestingLevel() noexcept
    {
        ++indexInNestingLevel[nestingLevel];
    }

    [[nodiscard]] bool shouldReadMe() const noexcept
    {
        if (conversionState.nestingLevel != nestingLevel)
            return false;
        for (auto i = 0; i < conversionState.nestingLevel; ++i) {
            if (indexInNestingLevel[i] != conversionState.indexInNestingLevel[i])
                return false;
        }
        return true;
    }

    [[nodiscard]] bool parseUint(std::uint64_t& result) noexcept
    {
        result = 0;
        bool parsedAtLeastOneDigit = false;
        while (readIndex < buffer.size()) {
            if (const char c = buffer[readIndex]; c >= u8'0' && c <= u8'9') {
                parsedAtLeastOneDigit = true;
                ++readIndex;
                const auto lastResult = result;
                result *= 10;
                result += c - u8'0';
                if (result < lastResult)
                    return false;
            } else {
                return parsedAtLeastOneDigit;
            }
        }
        return false;
    }

    [[nodiscard]] bool parseBool(bool& result) noexcept
    {
        const auto previousReadIndex = readIndex;
        if (readString(u8"true")) {
            result = true;
            return true;
        }

        readIndex = previousReadIndex;
        if (readString(u8"false")) {
            result = false;
            return true;
        }

        readIndex = previousReadIndex;
        return false;
    }

    [[nodiscard]] static constexpr bool isWhitespace(char8_t c) noexcept
    {
        switch (c) {
        case u8' ':
        case u8'\t':
        case u8'\n':
        case u8'\r':
            return true;
        default:
            return false;
        }
    }

    [[NOINLINE]] bool skipWhitespaces() noexcept
    {
        while (readIndex < buffer.size() && isWhitespace(buffer[readIndex]))
            ++readIndex;
        return true; 
    }

    [[nodiscard]] bool readChar(char8_t c) noexcept
    {
        if (readIndex < buffer.size() && buffer[readIndex] == c) {
            ++readIndex;
            return true;
        }
        return false;
    }

    [[nodiscard]] bool readString(const char8_t* str) noexcept
    {
        while (*str && readIndex < buffer.size()) {
            if (*str++ != buffer[readIndex++])
                return false;
        }
        return *str == 0;
    }

    std::span<const char8_t> buffer;
    std::size_t readIndex{0};
    ConfigStringConversionState& conversionState;
    std::array<config_params::ObjectIndexType, config_params::kMaxNestingLevel + 1> indexInNestingLevel{};
    config_params::NestingLevelIndexType nestingLevel{0};
};

```

`Source/Config/ConfigParams.h`:

```h
#pragma once

#include <cstdint>
#include <limits>

namespace config_params
{
    using ObjectIndexType = std::uint16_t;
    using NestingLevelIndexType = std::uint8_t;

    static constexpr NestingLevelIndexType kMaxNestingLevel{7};
    static constexpr ObjectIndexType kInvalidObjectIndex{(std::numeric_limits<ObjectIndexType>::max)()};
    static constexpr ObjectIndexType kMaxObjectIndex{kInvalidObjectIndex - 1};
}

```

`Source/Config/ConfigSchema.h`:

```h
#pragma once

#include <algorithm>

#include "ConfigVariableTypes.h"
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
class ConfigSchema {
public:
    explicit ConfigSchema(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) performConversion(auto&& configConversion)
    {
        configConversion.beginRoot();
        combatObject(configConversion);
        hudObject(configConversion);
        visualsObject(configConversion);
        soundObject(configConversion);
        return configConversion.endRoot();
    }

private:
    void combatObject(auto&& configConversion)
    {
        configConversion.beginObject(u8"Combat");

        configConversion.beginObject(u8"NoScopeInaccuracyVis");
        configConversion.boolean(u8"Enabled", loadVariable<no_scope_inaccuracy_vis_vars::Enabled>(), saveVariable<no_scope_inaccuracy_vis_vars::Enabled>());
        configConversion.endObject();

        configConversion.endObject();
    }

    void hudObject(auto&& configConversion)
    {
        configConversion.beginObject(u8"Hud");

        configConversion.beginObject(u8"BombTimer");
        configConversion.boolean(u8"Enabled", loadVariable<BombTimerEnabled>(), saveVariable<BombTimerEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"BombDefuseAlert");
        configConversion.boolean(u8"Enabled", loadVariable<DefusingAlertEnabled>(), saveVariable<DefusingAlertEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"PreserveKillfeed");
        configConversion.boolean(u8"Enabled", loadVariable<KillfeedPreserverEnabled>(), saveVariable<KillfeedPreserverEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"PostRoundTimer");
        configConversion.boolean(u8"Enabled", loadVariable<PostRoundTimerEnabled>(), saveVariable<PostRoundTimerEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"BombPlantAlert");
        configConversion.boolean(u8"Enabled", loadVariable<BombPlantAlertEnabled>(), saveVariable<BombPlantAlertEnabled>());
        configConversion.endObject();

        configConversion.endObject();
    }

    void visualsObject(auto&& configConversion)
    {
        configConversion.beginObject(u8"Visuals");

        configConversion.beginObject(u8"ModelGlow");
        configConversion.boolean(u8"Enabled", loadVariable<model_glow_vars::Enabled>(), saveVariable<model_glow_vars::Enabled>());
        configConversion.beginObject(u8"Players");
        configConversion.boolean(u8"Enabled", loadVariable<model_glow_vars::GlowPlayers>(), saveVariable<model_glow_vars::GlowPlayers>());
        configConversion.boolean(u8"OnlyEnemies", loadVariable<model_glow_vars::GlowOnlyEnemies>(), saveVariable<model_glow_vars::GlowOnlyEnemies>());
        configConversion.uint(u8"ColorMode", loadVariable<model_glow_vars::PlayerGlowColorMode>(), saveVariable<model_glow_vars::PlayerGlowColorMode>());
        configConversion.endObject();
        configConversion.boolean(u8"Weapons", loadVariable<model_glow_vars::GlowWeapons>(), saveVariable<model_glow_vars::GlowWeapons>());
        configConversion.boolean(u8"DroppedBomb", loadVariable<model_glow_vars::GlowDroppedBomb>(), saveVariable<model_glow_vars::GlowDroppedBomb>());
        configConversion.boolean(u8"TickingBomb", loadVariable<model_glow_vars::GlowTickingBomb>(), saveVariable<model_glow_vars::GlowTickingBomb>());
        configConversion.boolean(u8"DefuseKits", loadVariable<model_glow_vars::GlowDefuseKits>(), saveVariable<model_glow_vars::GlowDefuseKits>());
        configConversion.boolean(u8"GrenadeProjectiles", loadVariable<model_glow_vars::GlowGrenadeProjectiles>(), saveVariable<model_glow_vars::GlowGrenadeProjectiles>());
        configConversion.beginObject(u8"Hues");
        configConversion.uint(u8"PlayerBlue", loadVariable<model_glow_vars::PlayerBlueHue>(), saveVariable<model_glow_vars::PlayerBlueHue>());
        configConversion.uint(u8"PlayerGreen", loadVariable<model_glow_vars::PlayerGreenHue>(), saveVariable<model_glow_vars::PlayerGreenHue>());
        configConversion.uint(u8"PlayerYellow", loadVariable<model_glow_vars::PlayerYellowHue>(), saveVariable<model_glow_vars::PlayerYellowHue>());
        configConversion.uint(u8"PlayerOrange", loadVariable<model_glow_vars::PlayerOrangeHue>(), saveVariable<model_glow_vars::PlayerOrangeHue>());
        configConversion.uint(u8"PlayerPurple", loadVariable<model_glow_vars::PlayerPurpleHue>(), saveVariable<model_glow_vars::PlayerPurpleHue>());
        configConversion.uint(u8"TeamT", loadVariable<model_glow_vars::TeamTHue>(), saveVariable<model_glow_vars::TeamTHue>());
        configConversion.uint(u8"TeamCT", loadVariable<model_glow_vars::TeamCTHue>(), saveVariable<model_glow_vars::TeamCTHue>());
        configConversion.uint(u8"LowHealth", loadVariable<model_glow_vars::LowHealthHue>(), saveVariable<model_glow_vars::LowHealthHue>());
        configConversion.uint(u8"HighHealth", loadVariable<model_glow_vars::HighHealthHue>(), saveVariable<model_glow_vars::HighHealthHue>());
        configConversion.uint(u8"Enemy", loadVariable<model_glow_vars::EnemyHue>(), saveVariable<model_glow_vars::EnemyHue>());
        configConversion.uint(u8"Ally", loadVariable<model_glow_vars::AllyHue>(), saveVariable<model_glow_vars::AllyHue>());
        configConversion.uint(u8"Molotov", loadVariable<model_glow_vars::MolotovHue>(), saveVariable<model_glow_vars::MolotovHue>());
        configConversion.uint(u8"Flashbang", loadVariable<model_glow_vars::FlashbangHue>(), saveVariable<model_glow_vars::FlashbangHue>());
        configConversion.uint(u8"HEGrenade", loadVariable<model_glow_vars::HEGrenadeHue>(), saveVariable<model_glow_vars::HEGrenadeHue>());
        configConversion.uint(u8"SmokeGrenade", loadVariable<model_glow_vars::SmokeGrenadeHue>(), saveVariable<model_glow_vars::SmokeGrenadeHue>());
        configConversion.uint(u8"DroppedBomb", loadVariable<model_glow_vars::DroppedBombHue>(), saveVariable<model_glow_vars::DroppedBombHue>());
        configConversion.uint(u8"TickingBomb", loadVariable<model_glow_vars::TickingBombHue>(), saveVariable<model_glow_vars::TickingBombHue>());
        configConversion.uint(u8"DefuseKit", loadVariable<model_glow_vars::DefuseKitHue>(), saveVariable<model_glow_vars::DefuseKitHue>());
        configConversion.endObject();
        configConversion.endObject();

        configConversion.beginObject(u8"OutlineGlow");
        configConversion.boolean(u8"Enabled", loadVariable<outline_glow_vars::Enabled>(), saveVariable<outline_glow_vars::Enabled>());
        configConversion.beginObject(u8"Players");
        configConversion.boolean(u8"Enabled", loadVariable<outline_glow_vars::GlowPlayers>(), saveVariable<outline_glow_vars::GlowPlayers>());
        configConversion.boolean(u8"OnlyEnemies", loadVariable<outline_glow_vars::GlowOnlyEnemies>(), saveVariable<outline_glow_vars::GlowOnlyEnemies>());
        configConversion.uint(u8"ColorMode", loadVariable<outline_glow_vars::PlayerGlowColorMode>(), saveVariable<outline_glow_vars::PlayerGlowColorMode>());
        configConversion.endObject();
        configConversion.boolean(u8"Weapons", loadVariable<outline_glow_vars::GlowWeapons>(), saveVariable<outline_glow_vars::GlowWeapons>());
        configConversion.boolean(u8"DroppedBomb", loadVariable<outline_glow_vars::GlowDroppedBomb>(), saveVariable<outline_glow_vars::GlowDroppedBomb>());
        configConversion.boolean(u8"TickingBomb", loadVariable<outline_glow_vars::GlowTickingBomb>(), saveVariable<outline_glow_vars::GlowTickingBomb>());
        configConversion.boolean(u8"DefuseKits", loadVariable<outline_glow_vars::GlowDefuseKits>(), saveVariable<outline_glow_vars::GlowDefuseKits>());
        configConversion.boolean(u8"Hostages", loadVariable<outline_glow_vars::GlowHostages>(), saveVariable<outline_glow_vars::GlowHostages>());
        configConversion.boolean(u8"GrenadeProjectiles", loadVariable<outline_glow_vars::GlowGrenadeProjectiles>(), saveVariable<outline_glow_vars::GlowGrenadeProjectiles>());
        configConversion.beginObject(u8"Hues");
        configConversion.uint(u8"PlayerBlue", loadVariable<outline_glow_vars::PlayerBlueHue>(), saveVariable<outline_glow_vars::PlayerBlueHue>());
        configConversion.uint(u8"PlayerGreen", loadVariable<outline_glow_vars::PlayerGreenHue>(), saveVariable<outline_glow_vars::PlayerGreenHue>());
        configConversion.uint(u8"PlayerYellow", loadVariable<outline_glow_vars::PlayerYellowHue>(), saveVariable<outline_glow_vars::PlayerYellowHue>());
        configConversion.uint(u8"PlayerOrange", loadVariable<outline_glow_vars::PlayerOrangeHue>(), saveVariable<outline_glow_vars::PlayerOrangeHue>());
        configConversion.uint(u8"PlayerPurple", loadVariable<outline_glow_vars::PlayerPurpleHue>(), saveVariable<outline_glow_vars::PlayerPurpleHue>());
        configConversion.uint(u8"TeamT", loadVariable<outline_glow_vars::TeamTHue>(), saveVariable<outline_glow_vars::TeamTHue>());
        configConversion.uint(u8"TeamCT", loadVariable<outline_glow_vars::TeamCTHue>(), saveVariable<outline_glow_vars::TeamCTHue>());
        configConversion.uint(u8"LowHealth", loadVariable<outline_glow_vars::LowHealthHue>(), saveVariable<outline_glow_vars::LowHealthHue>());
        configConversion.uint(u8"HighHealth", loadVariable<outline_glow_vars::HighHealthHue>(), saveVariable<outline_glow_vars::HighHealthHue>());
        configConversion.uint(u8"Enemy", loadVariable<outline_glow_vars::EnemyHue>(), saveVariable<outline_glow_vars::EnemyHue>());
        configConversion.uint(u8"Ally", loadVariable<outline_glow_vars::AllyHue>(), saveVariable<outline_glow_vars::AllyHue>());
        configConversion.uint(u8"Molotov", loadVariable<outline_glow_vars::MolotovHue>(), saveVariable<outline_glow_vars::MolotovHue>());
        configConversion.uint(u8"Flashbang", loadVariable<outline_glow_vars::FlashbangHue>(), saveVariable<outline_glow_vars::FlashbangHue>());
        configConversion.uint(u8"HEGrenade", loadVariable<outline_glow_vars::HEGrenadeHue>(), saveVariable<outline_glow_vars::HEGrenadeHue>());
        configConversion.uint(u8"SmokeGrenade", loadVariable<outline_glow_vars::SmokeGrenadeHue>(), saveVariable<outline_glow_vars::SmokeGrenadeHue>());
        configConversion.uint(u8"DroppedBomb", loadVariable<outline_glow_vars::DroppedBombHue>(), saveVariable<outline_glow_vars::DroppedBombHue>());
        configConversion.uint(u8"TickingBomb", loadVariable<outline_glow_vars::TickingBombHue>(), saveVariable<outline_glow_vars::TickingBombHue>());
        configConversion.uint(u8"DefuseKit", loadVariable<outline_glow_vars::DefuseKitHue>(), saveVariable<outline_glow_vars::DefuseKitHue>());
        configConversion.uint(u8"Hostage", loadVariable<outline_glow_vars::HostageHue>(), saveVariable<outline_glow_vars::HostageHue>());
        configConversion.endObject();
        configConversion.endObject();

        configConversion.beginObject(u8"PlayerInfoInWorld");
        configConversion.boolean(u8"Enabled", loadVariable<player_info_vars::Enabled>(), saveVariable<player_info_vars::Enabled>());
        configConversion.boolean(u8"OnlyEnemies", loadVariable<player_info_vars::OnlyEnemies>(), saveVariable<player_info_vars::OnlyEnemies>());

        configConversion.beginObject(u8"PlayerPositionArrow");
        configConversion.boolean(u8"Enabled", loadVariable<player_info_vars::PlayerPositionArrowEnabled>(), saveVariable<player_info_vars::PlayerPositionArrowEnabled>());
        configConversion.uint(u8"ColorMode", loadVariable<player_info_vars::PlayerPositionArrowColorMode>(), saveVariable<player_info_vars::PlayerPositionArrowColorMode>());
        configConversion.endObject();

        configConversion.beginObject(u8"Health");
        configConversion.boolean(u8"Enabled", loadVariable<player_info_vars::PlayerHealthEnabled>(), saveVariable<player_info_vars::PlayerHealthEnabled>());
        configConversion.uint(u8"ColorMode", loadVariable<player_info_vars::PlayerHealthColorMode>(), saveVariable<player_info_vars::PlayerHealthColorMode>());
        configConversion.endObject();

        configConversion.boolean(u8"ActiveWeaponIcon", loadVariable<player_info_vars::ActiveWeaponIconEnabled>(), saveVariable<player_info_vars::ActiveWeaponIconEnabled>());
        configConversion.boolean(u8"BombCarrierIcon", loadVariable<player_info_vars::BombCarrierIconEnabled>(), saveVariable<player_info_vars::BombCarrierIconEnabled>());
        configConversion.boolean(u8"BombPlantIcon", loadVariable<player_info_vars::BombPlantIconEnabled>(), saveVariable<player_info_vars::BombPlantIconEnabled>());
        configConversion.boolean(u8"ActiveWeaponAmmo", loadVariable<player_info_vars::ActiveWeaponAmmoEnabled>(), saveVariable<player_info_vars::ActiveWeaponAmmoEnabled>());
        configConversion.boolean(u8"BombDefuseIcon", loadVariable<player_info_vars::BombDefuseIconEnabled>(), saveVariable<player_info_vars::BombDefuseIconEnabled>());
        configConversion.boolean(u8"HostagePickupIcon", loadVariable<player_info_vars::HostagePickupIconEnabled>(), saveVariable<player_info_vars::HostagePickupIconEnabled>());
        configConversion.boolean(u8"HostageRescueIcon", loadVariable<player_info_vars::HostageRescueIconEnabled>(), saveVariable<player_info_vars::HostageRescueIconEnabled>());
        configConversion.boolean(u8"BlindedIcon", loadVariable<player_info_vars::BlindedIconEnabled>(), saveVariable<player_info_vars::BlindedIconEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"ViewmodelMod");
        configConversion.boolean(u8"Enabled", loadVariable<viewmodel_mod_vars::Enabled>(), saveVariable<viewmodel_mod_vars::Enabled>());
        configConversion.boolean(u8"ModifyFov", loadVariable<viewmodel_mod_vars::ModifyFov>(), saveVariable<viewmodel_mod_vars::ModifyFov>());
        configConversion.uint(u8"Fov", loadVariable<viewmodel_mod_vars::Fov>(), saveVariable<viewmodel_mod_vars::Fov>());
        configConversion.endObject();

        configConversion.endObject();
    }

    void soundObject(auto&& configConversion)
    {
        configConversion.beginObject(u8"Sound");
        configConversion.beginObject(u8"Visualizations");

        configConversion.beginObject(u8"Footsteps");
        configConversion.boolean(u8"Enabled", loadVariable<FootstepSoundVisualizationEnabled>(), saveVariable<FootstepSoundVisualizationEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"BombPlant");
        configConversion.boolean(u8"Enabled", loadVariable<BombPlantSoundVisualizationEnabled>(), saveVariable<BombPlantSoundVisualizationEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"BombBeep");
        configConversion.boolean(u8"Enabled", loadVariable<BombBeepSoundVisualizationEnabled>(), saveVariable<BombBeepSoundVisualizationEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"BombDefuse");
        configConversion.boolean(u8"Enabled", loadVariable<BombDefuseSoundVisualizationEnabled>(), saveVariable<BombDefuseSoundVisualizationEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"WeaponScope");
        configConversion.boolean(u8"Enabled", loadVariable<WeaponScopeSoundVisualizationEnabled>(), saveVariable<WeaponScopeSoundVisualizationEnabled>());
        configConversion.endObject();

        configConversion.beginObject(u8"WeaponReload");
        configConversion.boolean(u8"Enabled", loadVariable<WeaponReloadSoundVisualizationEnabled>(), saveVariable<WeaponReloadSoundVisualizationEnabled>());
        configConversion.endObject();

        configConversion.endObject();
        configConversion.endObject();
    }

    template <std::unsigned_integral T>
    [[nodiscard]] static T saturateCast(std::unsigned_integral auto value) noexcept
    {
        if (value < (std::numeric_limits<T>::min)())
            return (std::numeric_limits<T>::min)();
        if (value > (std::numeric_limits<T>::max)())
            return (std::numeric_limits<T>::max)();
        return static_cast<T>(value);
    }

    template <typename ConfigVariable>
    [[nodiscard]] auto loadVariable()
    {
        if constexpr (IsRangeConstrained<typename ConfigVariable::ValueType>::value) {
            return [this](auto value) {
                if constexpr (std::is_same_v<color::HueInteger, typename ConfigVariable::ValueType::ValueType>) {
                    color::HueInteger hue{std::clamp(saturateCast<color::HueInteger::UnderlyingType>(value), color::HueInteger::kMin, color::HueInteger::kMax)};
                    hookContext.config().template setVariableWithoutAutoSave<ConfigVariable>(typename ConfigVariable::ValueType{std::clamp(hue, ConfigVariable::ValueType::kMin, ConfigVariable::ValueType::kMax)});
                } else if constexpr (std::is_same_v<std::uint8_t, typename ConfigVariable::ValueType::ValueType>) {
                    hookContext.config().template setVariableWithoutAutoSave<ConfigVariable>(typename ConfigVariable::ValueType{std::clamp(saturateCast<std::uint8_t>(value), ConfigVariable::ValueType::kMin, ConfigVariable::ValueType::kMax)});
                } else {
                    static_assert(!std::is_same_v<ConfigVariable, ConfigVariable>, "Unsupported type");
                }
            };
        } else if constexpr (std::is_enum_v<typename ConfigVariable::ValueType>) {
            return [this](std::integral auto value) {
                hookContext.config().template setVariableWithoutAutoSave<ConfigVariable>(static_cast<ConfigVariable::ValueType>(value));
            };
        } else {
            return [this](ConfigVariable::ValueType value) {
                hookContext.config().template setVariableWithoutAutoSave<ConfigVariable>(value);
            };
        }
    }

    template <typename ConfigVariable>
    [[nodiscard]] auto saveVariable()
    {
        if constexpr (IsRangeConstrained<typename ConfigVariable::ValueType>::value) {
            return [this] {
                return static_cast<typename ConfigVariable::ValueType::ValueType>(GET_CONFIG_VAR(ConfigVariable));
            };
        } else if constexpr (std::is_enum_v<typename ConfigVariable::ValueType>) {
            return [this] {
                return static_cast<std::underlying_type_t<typename ConfigVariable::ValueType>>(GET_CONFIG_VAR(ConfigVariable));
            };
        } else {
            return [this] {
                return GET_CONFIG_VAR(ConfigVariable);
            };
        }
    }

    HookContext& hookContext;
};

```

`Source/Config/ConfigState.h`:

```h
#pragma once

#include "ConfigFileOperation.h"
#include <MemoryAllocation/UniquePtr.h>
#include <Platform/PlatformPath.h>

#include "ConfigVariables.h"

struct ConfigState {
    bool autoSaveScheduled{false};
    bool loadScheduled{false};
    ConfigFileOperation currentFileOperation{ConfigFileOperation::None};
    char8_t* fileOperationBuffer{};
    std::size_t bufferUsedBytes{};
    UniquePtr<platform::PathCharType[]> pathToConfigDirectory{};
    UniquePtr<platform::PathCharType[]> pathToConfigFile{};
    UniquePtr<platform::PathCharType[]> pathToConfigTempFile{};
    ConfigVariables configVariables{};
};

```

`Source/Config/ConfigStringConversionState.h`:

```h
#pragma once

#include <array>
#include <cstddef>

#include "ConfigParams.h"

struct ConfigStringConversionState {
    config_params::NestingLevelIndexType nestingLevel{0};
    std::array<config_params::ObjectIndexType, config_params::kMaxNestingLevel + 1> indexInNestingLevel{};
    std::size_t offset{0};
};

```

`Source/Config/ConfigToString.h`:

```h
#pragma once

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <span>

#include "ConfigParams.h"
#include "ConfigStringConversionState.h"

class ConfigToString {
public:
    ConfigToString(std::span<char8_t> buffer, ConfigStringConversionState& conversionState) noexcept
        : buffer{buffer}
        , conversionState{conversionState}
    {
    }

    void beginRoot() noexcept
    {
        assert(nestingLevel == 0 && "beginRoot() called on invalid nesting level");
        assert(indexInNestingLevel[0] == 0 && "can not beginRoot() after endRoot()");

        if (shouldWriteMe() && writeChar(u8'{'))
            increaseConversionNestingLevel();
        increaseNestingLevel();
    }

    [[nodiscard]] std::size_t endRoot() noexcept
    {
        assert(nestingLevel == 1 && "endRoot() called on invalid nesting level");
        assert(indexInNestingLevel[0] == 0 && "endRoot() has been already called");

        if (shouldWriteMe() && writeChar(u8'}'))
            decreaseConversionNestingLevel();
        decreaseNestingLevel();
        return writeIndex;
    }

    void beginObject(const char8_t* key) noexcept
    {
        if (shouldWriteMe()) {
            const auto previousWriteIndex = writeIndex;
            if (writeCommaAfterPreviousElement() && writeKey(key) && writeChar(u8'{'))
                increaseConversionNestingLevel();
            else
                writeIndex = previousWriteIndex;
        }
        increaseNestingLevel();
    }

    void endObject() noexcept
    {
        if (shouldWriteMe() && writeChar(u8'}'))
            decreaseConversionNestingLevel();
        decreaseNestingLevel();
    }

    void boolean(const char8_t* key, auto&& /* valueSetter */, auto&& valueGetter)
    {
        writeBool(key, valueGetter());
    }

    void uint(const char8_t* key, auto&& /* valueSetter */, auto&& valueGetter)
    {
        writeUint(key, valueGetter());
    }

private:
    void writeBool(const char8_t* key, bool value) noexcept
    {
        if (shouldWriteMe()) {
            const auto previousWriteIndex = writeIndex;
            if (writeCommaAfterPreviousElement() && writeKey(key) && writeBool(value))
                increaseConversionIndexInNestingLevel();
            else
                writeIndex = previousWriteIndex;
        }
        increaseIndexInNestingLevel();
    }

    void writeUint(const char8_t* key, std::uint64_t value) noexcept
    {
        if (shouldWriteMe()) {
            const auto previousWriteIndex = writeIndex;
            if (writeCommaAfterPreviousElement() && writeKey(key) && writeUint(value))
                increaseConversionIndexInNestingLevel();
            else
                writeIndex = previousWriteIndex;
        }
        increaseIndexInNestingLevel();
    }

    [[nodiscard]] bool writeKey(const char8_t* key) noexcept
    {
        return writeChar(u8'"') && writeString(key) && writeString(u8"\":");
    }

    [[nodiscard]] bool writeCommaAfterPreviousElement() noexcept
    {
        if (conversionState.indexInNestingLevel[conversionState.nestingLevel] != 0)
            return writeChar(u8',');
        return true;
    }

    void increaseNestingLevel() noexcept
    {
        assert(nestingLevel < config_params::kMaxNestingLevel);
        indexInNestingLevel[++nestingLevel] = 0;
    }

    void increaseConversionNestingLevel()const noexcept
    {
        assert(conversionState.nestingLevel < config_params::kMaxNestingLevel);
        conversionState.indexInNestingLevel[++conversionState.nestingLevel] = 0;
    }

    void decreaseNestingLevel() noexcept
    {
        assert(nestingLevel > 0);
        assert(indexInNestingLevel[nestingLevel - 1] < config_params::kMaxObjectIndex);
        ++indexInNestingLevel[--nestingLevel];
    }

    void decreaseConversionNestingLevel() const noexcept
    {
        assert(conversionState.nestingLevel > 0);
        assert(conversionState.indexInNestingLevel[conversionState.nestingLevel - 1] < config_params::kMaxObjectIndex);
        ++conversionState.indexInNestingLevel[--conversionState.nestingLevel];
    }
    
    void increaseIndexInNestingLevel() noexcept
    {
        assert(indexInNestingLevel[nestingLevel] < config_params::kMaxObjectIndex);
        ++indexInNestingLevel[nestingLevel];
    }

    void increaseConversionIndexInNestingLevel() const noexcept
    {
        assert(conversionState.indexInNestingLevel[conversionState.nestingLevel] < config_params::kMaxObjectIndex);
        ++conversionState.indexInNestingLevel[conversionState.nestingLevel];
    }

    [[nodiscard]] bool shouldWriteMe() const noexcept
    {
        if (conversionState.nestingLevel != nestingLevel)
            return false;
        for (config_params::NestingLevelIndexType i = 0; i <= nestingLevel; ++i) {
            if (indexInNestingLevel[i] != conversionState.indexInNestingLevel[i])
                return false;
        }
        return true;
    }

    [[nodiscard]] bool writeUint(std::uint64_t value) noexcept
    {
        const auto beginIndex = writeIndex;
        do {
            if (!writeChar(u8"0123456789"[value % 10])) {
                writeIndex = beginIndex;
                return false;
            }
            value /= 10;
        } while (value != 0);

        std::reverse(buffer.data() + beginIndex, buffer.data() + writeIndex);
        return true;
    }

    [[nodiscard]] bool writeBool(bool value) noexcept
    {
        return writeString(value ? u8"true" : u8"false");
    }

    [[nodiscard]] bool writeChar(char8_t c) noexcept
    {
        if (writeIndex < buffer.size()) {
            buffer[writeIndex++] = c;
            return true;
        }
        return false;
    }

    [[nodiscard]] bool writeString(std::u8string_view str) noexcept
    {
        if (writeIndex < buffer.size() && buffer.size() - writeIndex >= str.length()) {
            std::ranges::copy(str, &buffer[writeIndex]);
            writeIndex += str.length();
            return true;
        }
        return false;
    }

    std::span<char8_t> buffer;
    ConfigStringConversionState& conversionState;
    std::size_t writeIndex{0};
    config_params::NestingLevelIndexType nestingLevel{0};
    std::array<config_params::ObjectIndexType, config_params::kMaxNestingLevel + 1> indexInNestingLevel{};
};

```

`Source/Config/ConfigVariable.h`:

```h
#pragma once

#include <Utils/ColorUtils.h>
#include <Utils/IdentityMacro.h>
#include <Utils/InRange.h>

#define CONFIG_VARIABLE(name, type, defaultValue) \
struct name { \
    using ValueType = type; \
    static constexpr ValueType kDefaultValue{defaultValue}; \
}

template <typename ConfigVariable>
struct UnpackConfigVariable {
    using type = typename ConfigVariable::ValueType;
};

#define CONFIG_VARIABLE_HUE(name, hueParams) \
CONFIG_VARIABLE(name, \
    IDENTITY(InRange<color::HueInteger, color::HueInteger{hueParams.min}, color::HueInteger{hueParams.max}>), \
    color::HueInteger{hueParams.def})

#define CONFIG_VARIABLE_RANGE(name, params) \
CONFIG_VARIABLE(name, IDENTITY(InRange<decltype(params)::Type, params.min, params.max>), params.def)

```

`Source/Config/ConfigVariableChangeHandler.h`:

```h
#pragma once

#include <type_traits>

#include <Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVis.h>
#include <Features/Hud/BombPlantAlert/BombPlantAlert.h>
#include <Features/Hud/BombTimer/BombTimer.h>
#include <Features/Hud/DefusingAlert/DefusingAlert.h>
#include <Features/Hud/PostRoundTimer/PostRoundTimer.h>
#include <Features/Sound/Details/BombBeepSound.h>
#include <Features/Sound/Details/BombDefuseSound.h>
#include <Features/Sound/Details/BombPlantSound.h>
#include <Features/Sound/Details/FootstepSound.h>
#include <Features/Sound/Details/WeaponReloadSound.h>
#include <Features/Sound/Details/WeaponScopeSound.h>
#include <Features/Visuals/ModelGlow/ModelGlowDeactivationFlags.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerStateIcons/PlayerStateIconsToShow.h>
#include <Hooks/ClientModeHooks.h>
#include <OutlineGlow/GlowSceneObjects.h>

template <typename HookContext>
class ConfigVariableChangeHandler {
public:
    explicit ConfigVariableChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    template <typename ConfigVariable>
    void onConfigVariableValueChanged(ConfigVariable::ValueType newValue) const noexcept
    {
        onConfigVariableValueChanged(newValue, std::type_identity<ConfigVariable>{});
    }

private:
    template <typename ConfigVariable>
    void onConfigVariableValueChanged(ConfigVariable::ValueType /* newValue */, std::type_identity<ConfigVariable>) const noexcept
    {
    }

    #define ON_CHANGE(ConfigVariable) \
    void onConfigVariableValueChanged(ConfigVariable::ValueType newValue, std::type_identity<ConfigVariable>) const noexcept

    ON_CHANGE(BombTimerEnabled)
    {
        if (newValue == false)
            hookContext.template make<BombTimer>().onDisable();
    }

    ON_CHANGE(DefusingAlertEnabled)
    {
        if (newValue == false)
            hookContext.template make<DefusingAlert>().onDisable();
    }

    ON_CHANGE(PostRoundTimerEnabled)
    {
        if (newValue == false)
            hookContext.template make<PostRoundTimer>().onDisable();
    }

    ON_CHANGE(BombBeepSoundVisualizationEnabled)
    {
        if (newValue == true)
            hookContext.soundWatcher().template startWatching<BombBeepSound>();
        else
            hookContext.soundWatcher().template stopWatching<BombBeepSound>();
    }

    ON_CHANGE(BombDefuseSoundVisualizationEnabled)
    {
        if (newValue == true)
            hookContext.soundWatcher().template startWatching<BombDefuseSound>();
        else
            hookContext.soundWatcher().template stopWatching<BombDefuseSound>();
    }

    ON_CHANGE(BombPlantSoundVisualizationEnabled)
    {
        if (newValue == true)
            hookContext.soundWatcher().template startWatching<BombPlantSound>();
        else
            hookContext.soundWatcher().template stopWatching<BombPlantSound>();
    }

    ON_CHANGE(FootstepSoundVisualizationEnabled)
    {
        if (newValue == true)
            hookContext.soundWatcher().template startWatching<FootstepSound>();
        else
            hookContext.soundWatcher().template stopWatching<FootstepSound>();
    }

    ON_CHANGE(WeaponReloadSoundVisualizationEnabled)
    {
        if (newValue == true)
            hookContext.soundWatcher().template startWatching<WeaponReloadSound>();
        else
            hookContext.soundWatcher().template stopWatching<WeaponReloadSound>();
    }

    ON_CHANGE(WeaponScopeSoundVisualizationEnabled)
    {
        if (newValue == true)
            hookContext.soundWatcher().template startWatching<WeaponScopeSound>();
        else
            hookContext.soundWatcher().template stopWatching<WeaponScopeSound>();
    }

    ON_CHANGE(model_glow_vars::Enabled)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::ModelGlowDeactivating);
    }

    ON_CHANGE(model_glow_vars::GlowDefuseKits)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::DefuseKitModelGlowDeactivating);
    }

    ON_CHANGE(model_glow_vars::GlowDroppedBomb)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::DroppedBombModelGlowDeactivating);
    }

    ON_CHANGE(model_glow_vars::GlowGrenadeProjectiles)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::GrenadeProjectileModelGlowDeactivating);
    }

    ON_CHANGE(model_glow_vars::GlowPlayers)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::PlayerModelGlowDeactivating);
    }

    ON_CHANGE(model_glow_vars::GlowTickingBomb)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::TickingBombModelGlowDeactivating);
    }

    ON_CHANGE(model_glow_vars::GlowWeapons)
    {
        if (newValue == false)
            modelGlowDeactivationFlags().set(ModelGlowDeactivationFlags::WeaponModelGlowDeactivating);
    }

    ON_CHANGE(outline_glow_vars::Enabled)
    {
        if (newValue == false)
            hookContext.template make<GlowSceneObjects>().clearObjects();
    }

    ON_CHANGE(player_info_vars::BombDefuseIconEnabled)
    {
        if (newValue)
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template set<DefuseIconPanel>();
        else
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template unset<DefuseIconPanel>();
    }

    ON_CHANGE(player_info_vars::HostagePickupIconEnabled)
    {
        if (newValue)
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template set<HostagePickupPanel>();
        else
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template unset<HostagePickupPanel>();
    }

    ON_CHANGE(player_info_vars::HostageRescueIconEnabled)
    {
        if (newValue)
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template set<HostageRescuePanel>();
        else
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template unset<HostageRescuePanel>();
    }

    ON_CHANGE(player_info_vars::BlindedIconEnabled)
    {
        if (newValue)
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template set<BlindedIconPanel>();
        else
            hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState.playerStateIconsToShow.template unset<BlindedIconPanel>();
    }

    ON_CHANGE(viewmodel_mod_vars::Enabled)
    {
        if (newValue == true && GET_CONFIG_VAR(viewmodel_mod_vars::ModifyFov))
            hookContext.template make<ClientModeHooks>().hookGetViewmodelFov();
        else
            hookContext.template make<ClientModeHooks>().restoreGetViewmodelFov();
    }

    ON_CHANGE(viewmodel_mod_vars::ModifyFov)
    {
        if (newValue == true && GET_CONFIG_VAR(viewmodel_mod_vars::Enabled))
            hookContext.template make<ClientModeHooks>().hookGetViewmodelFov();
        else
            hookContext.template make<ClientModeHooks>().restoreGetViewmodelFov();
    }

    ON_CHANGE(no_scope_inaccuracy_vis_vars::Enabled)
    {
        if (newValue == false)
            hookContext.template make<NoScopeInaccuracyVis>().onDisable();
    }

    ON_CHANGE(BombPlantAlertEnabled)
    {
        if (newValue == false)
            hookContext.template make<BombPlantAlert>().onDisable();
    }

    #undef ON_CHANGE

    [[nodiscard]] auto& modelGlowDeactivationFlags() const
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState.deactivationFlags;
    }

    HookContext& hookContext;
};

```

`Source/Config/ConfigVariableTypes.h`:

```h
#pragma once

#include <Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVisConfigVariables.h>
#include <Features/Hud/BombPlantAlert/BombPlantAlertConfigVariables.h>
#include <Features/Hud/BombTimer/BombTimerConfigVariables.h>
#include <Features/Hud/DefusingAlert/DefusingAlertConfigVariables.h>
#include <Features/Hud/KillfeedPreserver/KillfeedPreserverConfigVariables.h>
#include <Features/Hud/PostRoundTimer/PostRoundTimerConfigVariables.h>
#include <Features/Sound/SoundVisualizationConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldConfigVariables.h>
#include <Features/Visuals/ViewmodelMod/ViewmodelModConfigVariables.h>
#include <Utils/TypeList.h>

using ConfigVariableTypes = TypeList<
    BombTimerEnabled,
    DefusingAlertEnabled,
    KillfeedPreserverEnabled,
    PostRoundTimerEnabled,
    BombBeepSoundVisualizationEnabled,
    BombDefuseSoundVisualizationEnabled,
    BombPlantSoundVisualizationEnabled,
    FootstepSoundVisualizationEnabled,
    WeaponReloadSoundVisualizationEnabled,
    WeaponScopeSoundVisualizationEnabled,
    model_glow_vars::Enabled,
    model_glow_vars::GlowPlayers,
    model_glow_vars::PlayerGlowColorMode,
    model_glow_vars::GlowOnlyEnemies,
    model_glow_vars::GlowWeapons,
    model_glow_vars::GlowDroppedBomb,
    model_glow_vars::GlowTickingBomb,
    model_glow_vars::GlowDefuseKits,
    model_glow_vars::GlowGrenadeProjectiles,
    model_glow_vars::PlayerBlueHue,
    model_glow_vars::PlayerGreenHue,
    model_glow_vars::PlayerYellowHue,
    model_glow_vars::PlayerOrangeHue,
    model_glow_vars::PlayerPurpleHue,
    model_glow_vars::TeamTHue,
    model_glow_vars::TeamCTHue,
    model_glow_vars::LowHealthHue,
    model_glow_vars::HighHealthHue,
    model_glow_vars::AllyHue,
    model_glow_vars::EnemyHue,
    model_glow_vars::MolotovHue,
    model_glow_vars::FlashbangHue,
    model_glow_vars::HEGrenadeHue,
    model_glow_vars::SmokeGrenadeHue,
    model_glow_vars::DroppedBombHue,
    model_glow_vars::TickingBombHue,
    model_glow_vars::DefuseKitHue,
    outline_glow_vars::Enabled,
    outline_glow_vars::GlowDefuseKits,
    outline_glow_vars::GlowDroppedBomb,
    outline_glow_vars::GlowGrenadeProjectiles,
    outline_glow_vars::GlowHostages,
    outline_glow_vars::GlowPlayers,
    outline_glow_vars::GlowOnlyEnemies,
    outline_glow_vars::PlayerGlowColorMode,
    outline_glow_vars::GlowTickingBomb,
    outline_glow_vars::GlowWeapons,
    outline_glow_vars::PlayerBlueHue,
    outline_glow_vars::PlayerGreenHue,
    outline_glow_vars::PlayerYellowHue,
    outline_glow_vars::PlayerOrangeHue,
    outline_glow_vars::PlayerPurpleHue,
    outline_glow_vars::TeamTHue,
    outline_glow_vars::TeamCTHue,
    outline_glow_vars::LowHealthHue,
    outline_glow_vars::HighHealthHue,
    outline_glow_vars::AllyHue,
    outline_glow_vars::EnemyHue,
    outline_glow_vars::MolotovHue,
    outline_glow_vars::FlashbangHue,
    outline_glow_vars::HEGrenadeHue,
    outline_glow_vars::SmokeGrenadeHue,
    outline_glow_vars::DroppedBombHue,
    outline_glow_vars::TickingBombHue,
    outline_glow_vars::DefuseKitHue,
    outline_glow_vars::HostageHue,
    player_info_vars::Enabled,
    player_info_vars::OnlyEnemies,
    player_info_vars::PlayerPositionArrowEnabled,
    player_info_vars::PlayerPositionArrowColorMode,
    player_info_vars::PlayerHealthEnabled,
    player_info_vars::PlayerHealthColorMode,
    player_info_vars::ActiveWeaponIconEnabled,
    player_info_vars::ActiveWeaponAmmoEnabled,
    player_info_vars::BombCarrierIconEnabled,
    player_info_vars::BombPlantIconEnabled,
    player_info_vars::BombDefuseIconEnabled,
    player_info_vars::HostagePickupIconEnabled,
    player_info_vars::HostageRescueIconEnabled,
    player_info_vars::BlindedIconEnabled,
    viewmodel_mod_vars::Enabled,
    viewmodel_mod_vars::ModifyFov,
    viewmodel_mod_vars::Fov,
    no_scope_inaccuracy_vis_vars::Enabled,
    BombPlantAlertEnabled
>;

```

`Source/Config/ConfigVariables.h`:

```h
#pragma once

#include <array>
#include <bit>
#include <cstddef>
#include <cstring>
#include <type_traits>

#include "ConfigVariable.h"
#include "ConfigVariableTypes.h"
#include <Utils/Meta.h>

class ConfigVariables {
public:
    ConfigVariables() noexcept
    {
        ConfigVariableTypes::forEach([this] <typename ConfigVariable> (std::type_identity<ConfigVariable>) {
            storeVariableValue<ConfigVariable>(ConfigVariable::kDefaultValue);
        });
    }

    template <typename ConfigVariable>
    [[nodiscard]] auto getVariableValue() noexcept
    {
        return std::bit_cast<typename ConfigVariable::ValueType>(variableStorage<ConfigVariable>());
    }

    template <typename ConfigVariable>
    void storeVariableValue(ConfigVariable::ValueType value) noexcept
    {
        std::memcpy(&variableStorage<ConfigVariable>(), &value, sizeof(value));
    }

private:
    template <typename ConfigVariable>
    [[nodiscard]] auto& variableStorage() noexcept
    {
        if constexpr (OneByteConfigVariables::contains<ConfigVariable>())
            return oneByteConfigVariables[OneByteConfigVariables::template indexOf<ConfigVariable>()];
        else if constexpr (TwoByteConfigVariables::contains<ConfigVariable>())
            return twoByteConfigVariables[TwoByteConfigVariables::template indexOf<ConfigVariable>()];
        else
            static_assert(!std::is_same_v<ConfigVariable, ConfigVariable>, "Unknown type");
    }

    using OneByteConfigVariables = ConfigVariableTypes::filter<Projected<UnpackConfigVariable, WithSizeOf<1>::Equal>::Value>;
    using TwoByteConfigVariables = ConfigVariableTypes::filter<Projected<UnpackConfigVariable, WithSizeOf<2>::Equal>::Value>;

    std::array<std::byte[1], OneByteConfigVariables::size()> oneByteConfigVariables;
    std::array<std::byte[2], TwoByteConfigVariables::size()> twoByteConfigVariables;
};

```

`Source/Config/RangeConstrainedVariableParams.h`:

```h
#pragma once

#include <Utils/ColorUtils.h>

template <typename T>
struct RangeConstrainedVariableParams {
    using Type = T;

    T min, max, def;
};

using HueVariableParams = RangeConstrainedVariableParams<color::HueInteger::UnderlyingType>;

```

`Source/EntryPoints/EntryPoints.h`:

```h
#pragma once

#include "GlobalContext/GlobalContext.h"
#include "Hooks/PeepEventsHook.h"
#include "Utils/ReturnAddress.h"

[[NOINLINE]] void finishInit(auto& hookContext)
{
    hookContext.entityClassifier().init(hookContext);
    if (const auto mainMenu{hookContext.patternSearchResults().template get<MainMenuPanelPointer>()}; mainMenu && *mainMenu)
        hookContext.template make<PanoramaGUI>().init(hookContext.template make<PanoramaUiPanel>((*mainMenu)->uiPanel));
    hookContext.config().init();
    hookContext.config().scheduleLoad();
    hookContext.hooks().peepEventsHook.disable();
    hookContext.hooks().viewRenderHook.install();
}

int SDLHook_PeepEvents(void* events, int numevents, int action, unsigned minType, unsigned maxType) noexcept
{
    const auto initInProgress = !HookContext<GlobalContext>::isGlobalContextComplete();
    if (initInProgress)
        HookContext<GlobalContext>::initCompleteGlobalContextFromGameThread();

    HookContext<GlobalContext> hookContext;

    if (initInProgress)
        finishInit(hookContext);

    return hookContext.hooks().peepEventsHook.original(events, numevents, action, minType, maxType);
}

[[NOINLINE]] void unload(auto& hookContext) noexcept
{
    hookContext.template make<BombTimer>().onUnload();
    hookContext.template make<DefusingAlert>().onUnload();
    hookContext.template make<PostRoundTimer>().onUnload();
    hookContext.template make<OutlineGlow>().onUnload();
    hookContext.template make<BombStatusPanel>().onUnload();
    hookContext.template make<InWorldPanels>().onUnload();
    hookContext.template make<PanoramaGUI>().onUnload();
    hookContext.hooks().viewRenderHook.uninstall();
    hookContext.template make<ClientModeHooks>().restoreGetViewmodelFov();
    hookContext.template make<PlayerModelGlowPreview>().onUnload();
    hookContext.template make<WeaponModelGlowPreview>().onUnload();
    hookContext.template make<NoScopeInaccuracyVis>().onUnload();
    hookContext.template make<BombPlantAlert>().onUnload();

    hookContext.template make<EntitySystem>().forEachNetworkableEntityIdentity([&hookContext](const auto& entityIdentity) {
        auto&& baseEntity = hookContext.template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(entityIdentity.entity));
        const auto entityTypeInfo = baseEntity.classify();
        if (entityTypeInfo.template is<cs2::C_CSPlayerPawn>())
            hookContext.template make<ModelGlow>().onUnload()(PlayerModelGlow{hookContext}, baseEntity.template as<PlayerPawn>());
        else if (entityTypeInfo.template is<cs2::C_C4>())
            hookContext.template make<ModelGlow>().onUnload()(DroppedBombModelGlow{hookContext}, baseEntity.template as<BaseWeapon>());
        else if (entityTypeInfo.template is<cs2::CBaseAnimGraph>())
            hookContext.template make<ModelGlow>().onUnload()(DefuseKitModelGlow{hookContext}, baseEntity);
        else if (entityTypeInfo.template is<cs2::CPlantedC4>())
            hookContext.template make<ModelGlow>().onUnload()(TickingBombModelGlow{hookContext}, baseEntity.template as<PlantedC4>());
        else if (entityTypeInfo.isGrenadeProjectile())
            hookContext.template make<ModelGlow>().onUnload()(GrenadeProjectileModelGlow{hookContext}, baseEntity);
        else if (entityTypeInfo.isWeapon())
            hookContext.template make<ModelGlow>().onUnload()(WeaponModelGlow{hookContext}, baseEntity.template as<BaseWeapon>());
    });
}

void ViewRenderHook_onRenderStart(cs2::CViewRender* thisptr) noexcept
{
    HookContext<GlobalContext> hookContext;
    hookContext.hooks().viewRenderHook.getOriginalOnRenderStart()(thisptr);
    hookContext.make<InWorldPanels>().updateState();
    SoundWatcher<decltype(hookContext)> soundWatcher{hookContext.soundWatcherState(), hookContext};
    soundWatcher.update();
    SoundFeatures{hookContext.soundWatcherState(), hookContext.hooks().viewRenderHook, hookContext}.runOnViewMatrixUpdate();

    hookContext.make<NoScopeInaccuracyVis>().update();
    hookContext.make<RenderingHookEntityLoop>().run();
    hookContext.make<GlowSceneObjects>().removeUnreferencedObjects();
    hookContext.make<DefusingAlert>().run();
    hookContext.make<KillfeedPreserver>().run();
    hookContext.make<BombStatusPanelManager>().run();
    hookContext.make<InWorldPanels>().hideUnusedPanels();

    UnloadFlag unloadFlag;
    hookContext.make<PanoramaGUI>().run(unloadFlag);
    hookContext.config().update();
    hookContext.config().performFileOperation();

    if (unloadFlag) {
        unload(hookContext);
        HookContext<GlobalContext>::destroyGlobalContext();
    }  
}

LINUX_ONLY([[gnu::aligned(8)]]) std::uint64_t PlayerPawn_sceneObjectUpdater(cs2::C_CSPlayerPawn* playerPawn, void* unknown, bool unknownBool) noexcept
{
    HookContext<GlobalContext> hookContext;
    const auto originalReturnValue = hookContext.featuresStates().visualFeaturesStates.modelGlowState.originalPlayerPawnSceneObjectUpdater(playerPawn, unknown, unknownBool);

    auto&& playerPawn_ = hookContext.make<PlayerPawn>(playerPawn);
    if (auto&& previewPlayer = playerPawn_.template cast<PreviewPlayer>(); !previewPlayer)
        hookContext.make<ModelGlow>().updateInSceneObjectUpdater()(PlayerModelGlow{hookContext}, playerPawn_, EntityTypeInfo{});
    else
        hookContext.make<PlayerModelGlowPreview>().applyPreviewPlayerModelGlow(previewPlayer);

    return originalReturnValue;
}

LINUX_ONLY([[gnu::aligned(8)]]) std::uint64_t Weapon_sceneObjectUpdater(cs2::C_CSWeaponBase* weapon, void* unknown, bool unknownBool) noexcept
{
    HookContext<GlobalContext> hookContext;
    const auto originalReturnValue = hookContext.featuresStates().visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater(weapon, unknown, unknownBool);
    if (auto&& c4 = hookContext.make<BaseWeapon>(weapon).template cast<C4>())
        hookContext.make<ModelGlow>().updateInSceneObjectUpdater()(DroppedBombModelGlow{hookContext}, c4.baseWeapon(), EntityTypeInfo{});
    else
        hookContext.make<ModelGlow>().updateInSceneObjectUpdater()(WeaponModelGlow{hookContext}, hookContext.make<BaseWeapon>(weapon), hookContext.make<BaseWeapon>(weapon).baseEntity().classify());
    return originalReturnValue;
}

float ClientModeHook_getViewmodelFov(cs2::ClientModeCSNormal* clientMode) noexcept
{
    HookContext<GlobalContext> hookContext;
    const auto originalFov = hookContext.hooks().originalGetViewmodelFov(clientMode);
    if (auto&& viewmodelMod = hookContext.template make<ViewmodelMod>(); viewmodelMod.shouldModifyViewmodelFov())
        return viewmodelMod.viewmodelFov();
    return originalFov;
}

```

`Source/EntryPoints/GuiEntryPoints.h`:

```h
#pragma once

#include <CS2/Panorama/CPanel2D.h>
#include <Utils/TemplateParameterCstring.h>

template <typename HookContext>
class GuiEntryPoints {
public:
    template <typename ConfigVariable, TemplateParameterCstring kPanelName>
    LINUX_ONLY([[gnu::aligned(8)]]) static bool hueSliderValueChanged(void* /* thisptr */, cs2::CPanel2D* /* panel */, float value)
    {
        HookContext hookContext;
        hookContext.gui().template onHueSliderValueChanged<ConfigVariable>(kPanelName, value);
        return true;
    }

    template <typename ConfigVariable, TemplateParameterCstring kPanelName>
    LINUX_ONLY([[gnu::aligned(8)]]) static bool hueSliderTextEntrySubmit(void* /* thisptr */, cs2::CPanel2D* /* panel */, const char* value)
    {
        HookContext hookContext;
        hookContext.gui().template onHueSliderTextEntrySubmit<ConfigVariable>(kPanelName, value);
        return true;
    }

    template <typename DropdownSelectionChangedHandler>
    LINUX_ONLY([[gnu::aligned(8)]]) static bool dropDownSelectionChanged(void* /* thisptr */, cs2::CPanel2D* panel)
    {
        HookContext hookContext;
        auto&& dropdown = hookContext.template make<ClientPanel>(panel).template as<PanoramaDropDown>();
        hookContext.template make<DropdownSelectionChangedHandler>().onSelectionChanged(dropdown.getSelectedIndex());
        return true;
    }
};

```

`Source/Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVis.h`:

```h
#pragma once

#include <GameClient/Crosshair.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelHandle.h>
#include <GameClient/Panorama/PanoramaUiEngine.h>
#include <GameClient/WorldToScreen/ViewToProjectionMatrix.h>
#include "NoScopeInaccuracyVisParams.h"
#include "NoScopeInaccuracyVisConfigVariables.h"

template <typename HookContext>
class NoScopeInaccuracyVis {
public:
    NoScopeInaccuracyVis(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void update() const
    {
        if (!enabled())
            return;

        const auto visible = shouldShow();
        auto&& panel = getPanel();
        panel.setVisible(visible);
        if (visible) {
            panel.setHeight(computeHeightFromInaccuracy());
            using namespace no_scope_inaccuracy_vis_params;
            const auto color = hookContext.template make<Crosshair>().getColor().valueOr(kFallbackColor);
            panel.setBorder(kBorderWidth, color.setAlpha(kBorderAlpha));
            panel.setBackgroundColor(color.setAlpha(kBackgroundAlpha));
        }
    }

    void onDisable() const
    {
        hookContext.template make<PanelHandle>(state().panelHandle).get().hide();
    }

    void onUnload() const
    {
        hookContext.template make<PanoramaUiEngine>().deletePanelByHandle(state().panelHandle);
    }

private:
    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(no_scope_inaccuracy_vis_vars::Enabled);
    }

    [[nodiscard]] bool shouldShow() const
    {
        auto&& localPlayerPawn = hookContext.activeLocalPlayerPawn();
        return localPlayerPawn
            && !localPlayerPawn.isScoped().valueOr(true)
            && localPlayerPawn.isUsingSniperRifle();
    }

    [[nodiscard]] cs2::CUILength computeHeightFromInaccuracy() const
    {
        const auto y = hookContext.template make<ViewToProjectionMatrix>().transformY(getInaccuracy());
        return cs2::CUILength::percent(y.value_or(0.0f) * 100.0f);
    }

    [[nodiscard]] float getInaccuracy() const
    {
        return hookContext.localPlayerBulletInaccuracy().valueOr(0.0f);
    }

    [[nodiscard]] decltype(auto) getPanel() const
    {
        return hookContext.template make<PanelHandle>(state().panelHandle).getOrInit(createPanel());
    }

    [[nodiscard]] auto createPanel() const noexcept
    {
        return [this] () -> decltype(auto) {
            auto&& panel = hookContext.panelFactory().createPanel(hookContext.hud().getHudReticle()).uiPanel();
            panel.setWidth(cs2::CUILength::heightPercentage(100));
            panel.setBorderRadius(cs2::CUILength::percent(50));
            panel.setAlign(PanelAlignmentParams{
                .horizontalAlignment = cs2::k_EHorizontalAlignmentCenter,
                .verticalAlignment = cs2::k_EVerticalAlignmentCenter});
            return utils::lvalue<decltype(panel)>(panel);
        };
    }

    [[nodiscard]] auto& state() const
    {
        return hookContext.featuresStates().noScopeInaccuracyVisState;
    }
    
    HookContext& hookContext;
};

```

`Source/Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVisConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

namespace no_scope_inaccuracy_vis_vars
{

CONFIG_VARIABLE(Enabled, bool, false);

}

```

`Source/Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVisParams.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>
#include <CS2/Panorama/CUILength.h>

namespace no_scope_inaccuracy_vis_params
{

constexpr cs2::Color kFallbackColor{255, 255, 255};
constexpr auto kBorderAlpha{255};
constexpr auto kBackgroundAlpha{30};
constexpr auto kBorderWidth{cs2::CUILength::pixels(1)};

}

```

`Source/Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVisState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>

struct NoScopeInaccuracyVisState {
    cs2::PanelHandle panelHandle{};
};

```

`Source/Features/Common/FeatureToggle.h`:

```h
#pragma once

#include <concepts>
#include <Utils/PrivateTag.h>

template <typename Feature, bool HasOnEnable, bool HasOnDisable>
class FeatureToggleBase {
public:
    using ToggleMethod = PrivateTag<FeatureToggleBase>;

    void enable() noexcept
    {
        if (auto& enabled = static_cast<Feature&>(*this).enabledVariable(ToggleMethod{}); !enabled) {
            enabled = true;
            callOnEnable();
        }
    }

    void disable() noexcept
    {
        if (auto& enabled = static_cast<Feature&>(*this).enabledVariable(ToggleMethod{})) {
            enabled = false;
            callOnDisable();
        }
    }

private:
    void callOnEnable() noexcept
    {
        static_assert(HasOnEnable == requires (Feature& feature) { { feature.onEnable(ToggleMethod{}) } -> std::same_as<void>; });
        if constexpr (HasOnEnable)
            static_cast<Feature&>(*this).onEnable(ToggleMethod{});
    }

    void callOnDisable() noexcept
    {
        static_assert(HasOnDisable == requires (Feature& feature) { { feature.onDisable(ToggleMethod{}) } -> std::same_as<void>; });
        if constexpr (HasOnDisable)
            static_cast<Feature&>(*this).onDisable(ToggleMethod{});
    }
};

template <typename Feature>
using FeatureToggleOnOff = FeatureToggleBase<Feature, true, true>;

template <typename Feature>
using FeatureToggleOn = FeatureToggleBase<Feature, true, false>;

template <typename Feature>
using FeatureToggleOff = FeatureToggleBase<Feature, false, true>;

template <typename Feature>
using FeatureToggle = FeatureToggleBase<Feature, false, false>;

```

`Source/Features/Common/InWorldPanelIndex.h`:

```h
#pragma once

#include <cstdint>
#include <limits>

class InWorldPanelIndex {
public:
    using ValueType = std::uint16_t;

    static constexpr auto kNumberOfValueBits{std::numeric_limits<ValueType>::digits - 1};
    static constexpr ValueType kMaxValue{(1 << kNumberOfValueBits) - 1};
    static constexpr ValueType kMaxValidValue{kMaxValue - 1};

    [[nodiscard]] bool isValid() const noexcept
    {
        return value <= kMaxValidValue;
    }

    ValueType value{kMaxValue};
};

```

`Source/Features/Common/InWorldPanelListEntry.h`:

```h
#pragma once

#include <limits>

#include "InWorldPanelIndex.h"

class InWorldPanelListEntry {
public:
    InWorldPanelListEntry() = default;
    explicit InWorldPanelListEntry(InWorldPanelIndex index) noexcept
        : value{static_cast<InWorldPanelIndex::ValueType>(index.value | kIsPanelActiveMask)}
    {
    }

    [[nodiscard]] bool isPanelActive() const noexcept
    {
        return (value & kIsPanelActiveMask) != 0;
    }

    void markPanelActive() noexcept
    {
        value |= kIsPanelActiveMask;
    }

    void markPanelInactive() noexcept
    {
        value &= ~kIsPanelActiveMask;
    }

    [[nodiscard]] InWorldPanelIndex indexOfNextPanelOfSameType() const noexcept
    {
        return InWorldPanelIndex{static_cast<InWorldPanelIndex::ValueType>(value & kPanelIndexMask)};
    }

private:
    static_assert(InWorldPanelIndex::kNumberOfValueBits < std::numeric_limits<InWorldPanelIndex::ValueType>::digits);

    static constexpr auto kIsPanelActiveMask{(1 << InWorldPanelIndex::kNumberOfValueBits)};
    static constexpr auto kPanelIndexMask{(1 << InWorldPanelIndex::kNumberOfValueBits) - 1};

    InWorldPanelIndex::ValueType value{InWorldPanelIndex{}.value};
};

```

`Source/Features/Common/InWorldPanels.h`:

```h
#pragma once

#include <cstddef>
#include <tuple>
#include <type_traits>

#include <CS2/Panorama/CUIPanel.h>
#include <Features/Sound/Details/SoundVisualizationPanelFactory.h>
#include <Features/Sound/SoundVisualizationPanelTypes.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldPanelFactory.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanel.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCache.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelTypes.h>
#include <GameClient/Panorama/PanelHandle.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>
#include <Utils/Lvalue.h>

#include "InWorldPanelIndex.h"
#include "InWorldPanelListEntry.h"

template <typename HookContext>
class InWorldPanels {
public:
    explicit InWorldPanels(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void updateState() const noexcept
    {
        if (!containerPanelExists()) {
            hookContext.template make<PlayerInfoPanelCache>().clear();
            state().reset();
        }
    }

    [[nodiscard]] decltype(auto) getNextPlayerInfoPanel() const noexcept
    {
        if (auto&& existingPanel = getNextExistingPanel(state().playerInfoPanelListHead, perHookState().lastUsedPlayerInfoPanelIndex))
            return existingPanel.template as<PlayerInfoPanel>(hookContext.template make<PlayerInfoPanelCache>().nextEntry());
        auto&& newPanel = createPlayerInfoPanel(getOrCreateContainerPanel());
        registerNewPanel(state().playerInfoPanelListHead, perHookState().lastUsedPlayerInfoPanelIndex);
        hookContext.template make<PlayerInfoPanelCache>().allocateNewEntry();
        return newPanel.template as<PlayerInfoPanel>(hookContext.template make<PlayerInfoPanelCache>().nextEntry());
    }

    template <typename Type>
    [[nodiscard]] decltype(auto) getNextSoundVisualizationPanel() const noexcept
    {
        if (auto&& existingPanel = getNextExistingPanel(state().soundVisualizationPanelListHeads[SoundVisualizationPanelTypes::indexOf<Type>()], perHookState().lastUsedSoundVisualizationPanelIndexes[SoundVisualizationPanelTypes::indexOf<Type>()]))
            return utils::lvalue<decltype(existingPanel)>(existingPanel);
        auto&& newPanel = createSoundVisualizationPanel<Type>(getOrCreateContainerPanel());
        registerNewPanel(state().soundVisualizationPanelListHeads[SoundVisualizationPanelTypes::indexOf<Type>()], perHookState().lastUsedSoundVisualizationPanelIndexes[SoundVisualizationPanelTypes::indexOf<Type>()]);
        return utils::lvalue<decltype(newPanel)>(newPanel);
    }

    void hideUnusedPanels() const noexcept
    {
        hideUnusedPanels(state().playerInfoPanelListHead, perHookState().lastUsedPlayerInfoPanelIndex);
        for (std::size_t i = 0; i < SoundVisualizationPanelTypes::size(); ++i)
            hideUnusedPanels(state().soundVisualizationPanelListHeads[i], perHookState().lastUsedSoundVisualizationPanelIndexes[i]);
    }

    void onUnload() const noexcept
    {
        hookContext.template make<PanoramaUiEngine>().deletePanelByHandle(state().containerPanelHandle);
    }

private:
    void registerNewPanel(InWorldPanelIndex& panelOfTypeListHead, InWorldPanelIndex& lastUsedPanelOfTypeIndex) const noexcept
    {
        const InWorldPanelIndex newPanelIndex{static_cast<InWorldPanelIndex::ValueType>(state().panelList.getSize())};
        if (lastUsedPanelOfTypeIndex.isValid())
            state().panelList[lastUsedPanelOfTypeIndex.value] = InWorldPanelListEntry{newPanelIndex};
        else
            panelOfTypeListHead = newPanelIndex;
        lastUsedPanelOfTypeIndex = newPanelIndex;
        state().panelList.pushBack(InWorldPanelListEntry{InWorldPanelIndex{}});
    }

    void hideUnusedPanels(InWorldPanelIndex panelOfTypeListHead, InWorldPanelIndex lastUsedPanelOfTypeIndex) const noexcept
    {
        const auto firstIndex = lastUsedPanelOfTypeIndex.isValid()
            ? state().panelList[lastUsedPanelOfTypeIndex.value].indexOfNextPanelOfSameType()
            : panelOfTypeListHead;

        for (auto index = firstIndex; index.isValid(); index = state().panelList[index.value].indexOfNextPanelOfSameType()) {
            if (state().panelList[index.value].isPanelActive()) {
                state().panelList[index.value].markPanelInactive();
                deactivatePanel(getContainerPanel().children()[index.value]);
            }
        }
    }

    template <typename Type>
    [[nodiscard]] decltype(auto) createSoundVisualizationPanel(auto&& parent) const noexcept
    {
        return hookContext.template make<SoundVisualizationPanelFactory>(*static_cast<cs2::CUIPanel*>(parent))
            .createSoundVisualizationPanel(Type::soundVisualizationPanelProperties());
    }

    [[nodiscard]] decltype(auto) createPlayerInfoPanel(auto&& parent) const noexcept
    {
        auto&& factory = hookContext.template make<PlayerInfoInWorldPanelFactory>();
        auto&& containerPanel = factory.createContainerPanel(parent);
        createPanels(std::type_identity<PlayerInfoPanelTypes<HookContext>>{}, factory, containerPanel);
        return utils::lvalue<decltype(containerPanel)>(containerPanel);
    }

    template <typename... PanelTypes>
    void createPanels(std::type_identity<std::tuple<PanelTypes...>>, auto&& factory, auto&& containerPanel) const noexcept
    {
        (factory.createPanel(std::type_identity<PanelTypes>{}, containerPanel), ...);
    }

    [[nodiscard]] InWorldPanelIndex nextExistingPanelIndex(InWorldPanelIndex panelOfTypeListHead, InWorldPanelIndex lastUsedPanelIndex) const noexcept
    {
        if (lastUsedPanelIndex.isValid())
            return state().panelList[lastUsedPanelIndex.value].indexOfNextPanelOfSameType();
        return panelOfTypeListHead;
    }

    [[nodiscard]] decltype(auto) getNextExistingPanel(InWorldPanelIndex panelOfTypeListHead, InWorldPanelIndex& lastUsedPanelIndex) const noexcept
    {
        const auto nextIndex = nextExistingPanelIndex(panelOfTypeListHead, lastUsedPanelIndex);
        if (nextIndex.isValid()) {
            lastUsedPanelIndex = nextIndex;
            auto& nextPanelEntry = state().panelList[nextIndex.value];
            auto&& panel = getContainerPanel().children()[nextIndex.value];
            if (!nextPanelEntry.isPanelActive()) {
                activatePanel(panel);
                nextPanelEntry.markPanelActive();
            }
            return utils::lvalue<decltype(panel)>(panel);
        }
        return hookContext.template make<PanoramaUiPanel>(nullptr);
    }

    void activatePanel(auto&& panel) const noexcept
    {
        panel.setVisible(true);
    }

    void deactivatePanel(auto&& panel) const noexcept
    {
        panel.setVisible(false);
    }

    [[nodiscard]] auto& perHookState() const noexcept
    {
        return hookContext.inWorldPanelsPerHookState();
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.inWorldPanelsState();
    }

    [[nodiscard]] decltype(auto) getOrCreateContainerPanel() const noexcept
    {
        return containerPanelHandle().getOrInit(createContainerPanel());
    }

    [[nodiscard]] decltype(auto) getContainerPanel() const noexcept
    {
        return containerPanelHandle().get();
    }

    [[nodiscard]] decltype(auto) containerPanelHandle() const noexcept
    {
        return hookContext.template make<PanelHandle>(state().containerPanelHandle);
    }

    [[nodiscard]] bool containerPanelExists() const noexcept
    {
        return containerPanelHandle().panelExists();
    }

    [[nodiscard]] auto createContainerPanel() const noexcept
    {
        return [this] {
            auto&& panel = hookContext.panelFactory().createPanel(hookContext.hud().getHudReticle()).uiPanel();
            panel.fitParent();
            return panel;
        };
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Common/InWorldPanelsPerHookState.h`:

```h
#pragma once

#include <array>
#include <Features/Sound/SoundVisualizationPanelTypes.h>
#include "InWorldPanelIndex.h"

struct InWorldPanelsPerHookState {
    InWorldPanelIndex lastUsedPlayerInfoPanelIndex{};
    std::array<InWorldPanelIndex, SoundVisualizationPanelTypes::size()> lastUsedSoundVisualizationPanelIndexes{};
};

```

`Source/Features/Common/InWorldPanelsState.h`:

```h
#pragma once

#include <array>

#include <CS2/Panorama/PanelHandle.h>
#include <Features/Sound/SoundVisualizationPanelTypes.h>
#include <Utils/DynamicArray.h>

#include "InWorldPanelIndex.h"
#include "InWorldPanelListEntry.h"

struct InWorldPanelsState {
    cs2::PanelHandle containerPanelHandle;
    DynamicArray<InWorldPanelListEntry> panelList;
    InWorldPanelIndex playerInfoPanelListHead{};
    std::array<InWorldPanelIndex, SoundVisualizationPanelTypes::size()> soundVisualizationPanelListHeads{};

    void reset() noexcept
    {
        containerPanelHandle = {};
        panelList.clear();
        playerInfoPanelListHead = {};
        soundVisualizationPanelListHeads = {};
    }
};

```

`Source/Features/Common/RenderingHookEntityLoop.h`:

```h
#pragma once

#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <GameClient/Entities/BaseEntity.h>
#include <GameClient/Entities/BaseModelEntity.h>
#include <GameClient/Entities/PlayerPawn.h>
#include <Features/Visuals/ModelGlow/ModelGlow.h>
#include <Features/Visuals/OutlineGlow/OutlineGlow.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorld.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <Features/Hud/BombPlantAlert/BombPlantAlert.h>

template <typename HookContext>
class RenderingHookEntityLoop {
public:
    explicit RenderingHookEntityLoop(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void run() const noexcept
    {
        auto bombPlantAlertVisibility = Visibility::Hidden;
        hookContext.template make<EntitySystem>().forEachNetworkableEntityIdentity([this, &bombPlantAlertVisibility](const auto& entityIdentity) { handleEntityIdentity(entityIdentity, bombPlantAlertVisibility); });
        hookContext.template make<ModelGlow>().postUpdateInMainThread();
        if (bombPlantAlertVisibility == Visibility::Hidden)
            hookContext.template make<BombPlantAlert>().hide();
    }

private:
    void handleEntityIdentity(const cs2::CEntityIdentity& entityIdentity, Visibility& bombPlantAlertVisibility) const noexcept
    {
        const auto entityTypeInfo = hookContext.entityClassifier().classifyEntity(entityIdentity.entityClass);
        auto&& baseEntity = hookContext.template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(entityIdentity.entity));

        if (entityTypeInfo.template is<cs2::C_CSPlayerPawn>()) {
            auto&& playerPawn = baseEntity.template as<PlayerPawn>();
            hookContext.template make<PlayerInfoInWorld>().drawPlayerInformation(playerPawn);
            updateModelGlow<PlayerModelGlow>(playerPawn, entityTypeInfo);
            applyOutlineGlow<PlayerOutlineGlow>(playerPawn, entityTypeInfo);
            if (bombPlantAlertVisibility != Visibility::Visible)
                bombPlantAlertVisibility = hookContext.template make<BombPlantAlert>().show(playerPawn);
        } else if (entityTypeInfo.template is<cs2::C_C4>()) {
            updateModelGlow<DroppedBombModelGlow>(baseEntity.template as<BaseWeapon>(), entityTypeInfo);
            applyOutlineGlow<DroppedBombOutlineGlow>(baseEntity, entityTypeInfo);
        } else if (entityTypeInfo.template is<cs2::CBaseAnimGraph>()) {
            updateModelGlow<DefuseKitModelGlow>(baseEntity, entityTypeInfo);
            applyOutlineGlow<DefuseKitOutlineGlow>(baseEntity, entityTypeInfo);
        } else if (entityTypeInfo.template is<cs2::CPlantedC4>()) {
            updateModelGlow<TickingBombModelGlow>(baseEntity.template as<PlantedC4>(), entityTypeInfo);
            applyOutlineGlow<TickingBombOutlineGlow>(baseEntity.template as<PlantedC4>(), entityTypeInfo);
        }  else if (entityTypeInfo.template is<cs2::C_Hostage>()) {
            applyOutlineGlow<HostageOutlineGlow>(baseEntity, entityTypeInfo);
        } else if (entityTypeInfo.isGrenadeProjectile()) {
            updateModelGlow<GrenadeProjectileModelGlow>(baseEntity, entityTypeInfo);
            applyOutlineGlow<GrenadeProjectileOutlineGlow>(baseEntity, entityTypeInfo);
        } else if (entityTypeInfo.isWeapon()) {
            updateModelGlow<WeaponModelGlow>(baseEntity.template as<BaseWeapon>(), entityTypeInfo);
            applyOutlineGlow<WeaponOutlineGlow>(baseEntity, entityTypeInfo);
        }
    }

    template <template <typename> typename Glow, typename... Args>
    void updateModelGlow(Args&&... args) const
    {
        hookContext.template make<ModelGlow>().updateInMainThread()(Glow{hookContext}, std::forward<Args>(args)...);
    }

    template <template <typename> typename Glow, typename... Args>
    void applyOutlineGlow(Args&&... args) const
    {
        hookContext.template make<OutlineGlow>().applyGlow()(Glow{hookContext}, std::forward<Args>(args)...);
    }

    HookContext& hookContext;
};

```

`Source/Features/FeaturesStates.h`:

```h
#pragma once

#include "Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVisState.h"
#include "Hud/HudFeaturesStates.h"
#include "Visuals/VisualFeaturesStates.h"

struct FeaturesStates {
    HudFeaturesStates hudFeaturesStates;
    VisualFeaturesStates visualFeaturesStates;
    NoScopeInaccuracyVisState noScopeInaccuracyVisState;
};

```

`Source/Features/Hud/BombPlantAlert/BombPlantAlert.h`:

```h
#pragma once

#include "BombPlantAlertConfigVariables.h"
#include "BombPlantAlertPanelFactory.h"
#include "BombPlantAlertParams.h"
#include <CS2/Constants/BombsiteIndex.h>
#include <CS2/Constants/IconURLs.h>
#include <Common/Visibility.h>
#include <GameClient/Entities/C4.h>
#include <GameClient/Panorama/PanelHandle.h>
#include <GameClient/Panorama/PanoramaLabel.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/StringBuilder.h>

template <typename HookContext>
class BombPlantAlert {
public:
    explicit BombPlantAlert(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] Visibility show(auto&& playerPawn) const
    {
        if (!GET_CONFIG_VAR(BombPlantAlertEnabled))
            return Visibility::Hidden;

        auto&& bomb = playerPawn.getActiveWeapon().template cast<C4>();
        if (!shouldShowPlantAlert(bomb))
            return Visibility::Hidden;

        const auto canBePlantedBeforeRoundEnd = canFinishArmingBeforeRoundEnd(bomb);
        updateContainerPanel(canBePlantedBeforeRoundEnd);
        updateBombsiteIcon(bomb.nearestBombsiteIndex());
        updateTimerPanel(canBePlantedBeforeRoundEnd, bomb);

        return Visibility::Visible;
    }

    void hide() const
    {
        if (GET_CONFIG_VAR(BombPlantAlertEnabled))
            getPanel(state().containerPanelHandle).setVisible(false);
    }

    void onDisable() const
    {
        getPanel(state().containerPanelHandle).setVisible(false);
    }

    void onUnload() const
    {
        hookContext.template make<PanoramaUiEngine>().deletePanelByHandle(state().containerPanelHandle);
    }

private:
    [[nodiscard]] Optional<bool> canFinishArmingBeforeRoundEnd(auto&& bomb) const
    {
        auto&& gameRules = hookContext.gameRules();
        if (gameRules.isRoundOver().valueOr(false))
            return false;
        return bomb.armingEndTime().lessThan(gameRules.roundEndTime());
    }

    [[nodiscard]] bool shouldShowPlantAlert(auto&& bomb) const
    {
        return bomb && bomb.isBeingPlanted().valueOr(false) && bomb.timeToArmingEnd().greaterThan(0.0f).valueOr(false);
    }

    void updateContainerPanel(auto canBePlantedBeforeRoundEnd) const
    {
        auto&& panel = hookContext.template make<PanelHandle>(state().containerPanelHandle).getOrInit(createPanel());
        panel.setVisible(true);
        panel.setBackgroundColor(backgroundColor(canBePlantedBeforeRoundEnd));
    }

    void updateBombsiteIcon(auto bombsiteIndex) const
    {
        getPanel(state().bombsiteAIconPanelHandle).setVisible(bombsiteIndex == cs2::BombsiteIndex::BombsiteA);
        getPanel(state().bombsiteBIconPanelHandle).setVisible(bombsiteIndex == cs2::BombsiteIndex::BombsiteB);
    }

    void updateTimerPanel(auto canBePlantedBeforeRoundEnd, auto&& bomb) const
    {
        auto&& timerPanel = getPanel(state().timerPanelHandle);
        const auto timeToArmingEnd = bomb.timeToArmingEnd();
        if (timeToArmingEnd.hasValue()) {
            timerPanel.clientPanel().template as<PanoramaLabel>().setText(StringBuilderStorage<10>{}.builder().put(
                static_cast<int>(timeToArmingEnd.value()), '.', static_cast<int>(timeToArmingEnd.value() * 10) % 10).cstring());
        }
        timerPanel.setColor(timerColor(canBePlantedBeforeRoundEnd));
    }

    [[nodiscard]] decltype(auto) getPanel(auto panelHandle) const
    {
        return hookContext.template make<PanoramaUiEngine>().getPanelFromHandle(panelHandle);
    }

    [[nodiscard]] static cs2::Color backgroundColor(auto canBePlantedBeforeRoundEnd) noexcept
    {
        using namespace bomb_plant_alert_params;
        if (canBePlantedBeforeRoundEnd.hasValue())
            return canBePlantedBeforeRoundEnd.value() ? kPositiveBackgroundColor : kNegativeBackgroundColor;
        return kFallbackBackgroundColor;
    }

    [[nodiscard]] static cs2::Color timerColor(auto canBePlantedBeforeRoundEnd) noexcept
    {
        using namespace bomb_plant_alert_params;
        if (canBePlantedBeforeRoundEnd.hasValue())
            return canBePlantedBeforeRoundEnd.value() ? kPositiveTimerColor : kNegativeTimerColor;
        return kFallbackTimerColor;
    }

    [[nodiscard]] auto createPanel() const noexcept
    {
        return [this] () -> decltype(auto) {
            auto&& factory = hookContext.template make<BombPlantAlertPanelFactory>();
            auto&& container = factory.createContainerPanel(hookContext.hud().scoreAndTimeAndBomb());
            state().containerPanelHandle = container.getHandle();
            state().bombsiteAIconPanelHandle = factory.createBombsiteIconPanel(container, cs2::kBombsiteAPlantingIconUrl).getHandle();
            state().bombsiteBIconPanelHandle = factory.createBombsiteIconPanel(container, cs2::kBombsiteBPlantingIconUrl).getHandle();
            state().timerPanelHandle = factory.createTimerPanel(container).getHandle();
            return utils::lvalue<decltype(container)>(container);
        };
    }

    [[nodiscard]] auto& state() const
    {
        return hookContext.featuresStates().hudFeaturesStates.bombPlantAlertState;
    }

    HookContext& hookContext;
};

```

`Source/Features/Hud/BombPlantAlert/BombPlantAlertConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

CONFIG_VARIABLE(BombPlantAlertEnabled, bool, false);

```

`Source/Features/Hud/BombPlantAlert/BombPlantAlertPanelFactory.h`:

```h
#pragma once

#include "BombPlantAlertPanelParams.h"
#include <GameClient/Panorama/PanoramaUiEngine.h>
#include <Utils/Lvalue.h>

template <typename HookContext>
class BombPlantAlertPanelFactory {
public:
    explicit BombPlantAlertPanelFactory(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    decltype(auto) createContainerPanel(auto&& parentPanel) const
    {
        using namespace bomb_plant_alert_panel_params::container_panel_params;

        auto&& container = hookContext.panelFactory().createPanel(parentPanel, "BombPlantAlert").uiPanel();
        container.setFlowChildren(kChildrenFlow);
        container.setWidth(kWidth);
        container.setHeight(kHeight);
        container.setPosition(kPositionX, kPositionY);
        container.setBorderRadius(kBorderRadius);
        // todo: implement setting below style properties in C++
        hookContext.template make<PanoramaUiEngine>().runScript(parentPanel,
            R"(
(function() {
  var panel = $.GetContextPanel().FindChildInLayoutFile('BombPlantAlert');
  panel.style.worldBlur = 'gaussian(2, 2, 2)';
  panel.style.backgroundImage = 'url("s2r://panorama/images/backgrounds/bluedots_large_png.vtex")';
  panel.style.backgroundSize = 'auto 390px';
  panel.style.backgroundImgOpacity = '0.04';
})();
)");
        return utils::lvalue<decltype(container)>(container);
    }

    decltype(auto) createBombsiteIconPanel(auto&& containerPanel, const char* imageUrl) const
    {
        using namespace bomb_plant_alert_panel_params::bombsite_icon_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(imageUrl, kTextureHeight);
    
        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setMargin(kMargin);
        return utils::lvalue<decltype(uiPanel)>(uiPanel);
    }

    decltype(auto) createTimerPanel(auto&& containerPanel) const
    {
        using namespace bomb_plant_alert_panel_params::timer_panel_params;

        auto&& panel = hookContext.panelFactory().createLabelPanel(containerPanel).uiPanel();
        panel.setWidth(kWidth);
        panel.setFont(kFont);
        panel.setMixBlendMode(kMixBlendMode);
        panel.setAlign(kAlignment);
        panel.setMargin(kMargin);
        panel.setTextAlign(kTextAlign);
        return utils::lvalue<decltype(panel)>(panel);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Hud/BombPlantAlert/BombPlantAlertPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>

#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace bomb_plant_alert_panel_params::container_panel_params
{
    constexpr auto kChildrenFlow = cs2::k_EFlowRight;
    constexpr auto kWidth = cs2::CUILength::percent(100);
    constexpr auto kHeight = cs2::CUILength::pixels(40);
    constexpr auto kPositionX = cs2::CUILength::pixels(0);
    constexpr auto kPositionY = cs2::CUILength::pixels(100);
    constexpr auto kBorderRadius = cs2::CUILength::pixels(5);
}

namespace bomb_plant_alert_panel_params::bombsite_icon_panel_params
{
    constexpr auto kTextureHeight = 32;
    constexpr auto kAlignment = PanelAlignmentParams{.verticalAlignment = cs2::k_EVerticalAlignmentCenter};
    constexpr auto kMargin = PanelMarginParams{.marginLeft = cs2::CUILength::pixels(5)};
}

namespace bomb_plant_alert_panel_params::timer_panel_params
{
    constexpr auto kWidth = cs2::CUILength::fillParentFlow(1.0f);
    constexpr auto kFont = PanelFontParams{
        .fontFamily = "Stratum2 Bold TF, 'Arial Unicode MS'",
        .fontSize = 26};
    constexpr auto kMixBlendMode = cs2::k_EMixBlendModeAdditive;
    constexpr auto kColor = cs2::kColorWhite;
    constexpr auto kAlignment = PanelAlignmentParams{.verticalAlignment = cs2::k_EVerticalAlignmentCenter};
    constexpr auto kTextAlign = cs2::k_ETextAlignCenter;
    constexpr auto kMargin = PanelMarginParams{.marginRight = cs2::CUILength::pixels(5)};
}

```

`Source/Features/Hud/BombPlantAlert/BombPlantAlertParams.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>

namespace bomb_plant_alert_params
{

constexpr cs2::Color kPositiveBackgroundColor{0, 77, 0, 127};
constexpr cs2::Color kNegativeBackgroundColor{77, 0, 0, 127};
constexpr cs2::Color kFallbackBackgroundColor{0, 0, 0, 127};

constexpr cs2::Color kPositiveTimerColor{0, 180, 0};
constexpr cs2::Color kNegativeTimerColor{255, 0, 0};
constexpr cs2::Color kFallbackTimerColor{255, 255, 255};

}

```

`Source/Features/Hud/BombPlantAlert/BombPlantAlertState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>

struct BombPlantAlertState {
    cs2::PanelHandle containerPanelHandle{};
    cs2::PanelHandle bombsiteAIconPanelHandle{};
    cs2::PanelHandle bombsiteBIconPanelHandle{};
    cs2::PanelHandle timerPanelHandle{};
};

```

`Source/Features/Hud/BombTimer/BombSiteIconPanel.h`:

```h
#pragma once

template <typename ImagePanel>
struct BombSiteIconPanel {
    explicit BombSiteIconPanel(ImagePanel panel) noexcept
        : panel{panel}
    {
    }

    void setIcon(const char* bombsiteIconUrl) const noexcept
    {
        if (bombsiteIconUrl)
            panel.setImageSvg(bombsiteIconUrl);
    }

    ImagePanel panel;
};

```

`Source/Features/Hud/BombTimer/BombTimer.h`:

```h
#pragma once

#include <utility>

#include <Common/Visibility.h>
#include "BombTimerContext.h"

template <typename HookContext, typename Context = BombTimerContext<HookContext>>
class BombTimer {
public:
    template <typename... Args>
    explicit BombTimer(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    [[nodiscard]] Visibility update() const noexcept
    {
        decltype(auto) condition{context.bombTimerCondition()};
        if (!condition.shouldRun())
            return Visibility::Hidden;

        if (condition.shouldShowBombTimer()) {
            context.bombTimerPanel().showAndUpdate();
            return Visibility::Visible;
        } else {
            context.bombTimerPanel().hide();
            return Visibility::Hidden;
        }
    }

    void forceHide() const noexcept
    {
        if (context.bombTimerCondition().shouldRun())
            context.bombTimerPanel().hide();
    }

    void onDisable() const noexcept
    {
        context.bombTimerPanel().hide();
    }

    void onUnload() const noexcept
    {
        auto&& uiEngine = context.uiEngine();
        uiEngine.deletePanelByHandle(context.state().bombTimerPanelHandle);
        uiEngine.deletePanelByHandle(context.state().bombTimerContainerPanelHandle);
    }

private:
    Context context;
};

```

`Source/Features/Hud/BombTimer/BombTimerCondition.h`:

```h
#pragma once

#include "BombTimerConfigVariables.h"

template <typename Context>
struct BombTimerCondition {
    explicit BombTimerCondition(Context context) noexcept
        : context{context}
    {
    }

    [[nodiscard]] bool shouldRun() const noexcept
    {
        return context.config().template getVariable<BombTimerEnabled>();
    }

    [[nodiscard]] bool shouldShowBombTimer() const noexcept
    {
        return context.bombPlantedPanel().isVisible().valueOr(true) && context.hasTickingC4();
    }

private:
    Context context;
};

```

`Source/Features/Hud/BombTimer/BombTimerConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

CONFIG_VARIABLE(BombTimerEnabled, bool, false);

```

`Source/Features/Hud/BombTimer/BombTimerContext.h`:

```h
#pragma once

#include <GameClient/Panorama/ImagePanel.h>
#include <GameClient/Panorama/PanoramaLabel.h>
#include <GameClient/Panorama/PanoramaUiEngine.h>
#include <Utils/Lvalue.h>

#include "BombSiteIconPanel.h"
#include "BombTimerCondition.h"
#include "BombTimerPanel.h"
#include "BombTimerPanelFactory.h"
#include "BombTimerTextPanel.h"

template <typename HookContext>
struct BombTimerContext {
    BombTimerContext(HookContext& context) noexcept
        : _context{context}
    {
    }

    [[nodiscard]] bool hasTickingC4() const noexcept
    {
        const auto plantedC4{_context.plantedC4()};
        return plantedC4 && plantedC4->isTicking().valueOr(true) && plantedC4->getTimeToExplosion().greaterThan(0.0f).valueOr(false);
    }

    [[nodiscard]] auto tickingC4() const noexcept
    {
        return *_context.plantedC4();
    }

    [[nodiscard]] auto bombTimerCondition() const noexcept
    {
        return BombTimerCondition{*this};
    }

    [[nodiscard]] auto bombTimerPanel() const noexcept
    {
        return BombTimerPanel{*this};
    }

    [[nodiscard]] decltype(auto) bombPlantedPanel() const noexcept
    {
        return _context.hud().bombPlantedPanel();
    }

    [[nodiscard]] decltype(auto) bombTimerContainerPanel() const noexcept
    {
        if (auto&& bombTimerContainer = uiEngine().getPanelFromHandle(state().bombTimerContainerPanelHandle))
            return utils::lvalue<decltype(bombTimerContainer)>(bombTimerContainer);

        updatePanelHandles();
        return uiEngine().getPanelFromHandle(state().bombTimerContainerPanelHandle);
    }

    [[nodiscard]] auto bombSiteIconPanel() const noexcept
    {
        return BombSiteIconPanel{uiEngine().getPanelFromHandle(state().bombSiteIconPanelHandle).clientPanel().template as<ImagePanel>()};
    }

    [[nodiscard]] auto bombTimerTextPanel() const noexcept
    {
        return BombTimerTextPanel{uiEngine().getPanelFromHandle(state().bombTimerPanelHandle).clientPanel().template as<PanoramaLabel>()};
    }

    void updatePanelHandles() const noexcept
    {
        auto&& factory = _context.template make<BombTimerPanelFactory>();
        auto&& containerPanel = factory.createContainerPanel(_context.hud().scoreAndTimeAndBomb());
        state().bombTimerContainerPanelHandle = containerPanel.getHandle();

        auto&& bombSiteIconPanel = factory.createBombSiteIconPanel(containerPanel);
        state().bombSiteIconPanelHandle = bombSiteIconPanel.getHandle();

        auto&& timerTextPanel = factory.createTimerTextPanel(containerPanel);
        state().bombTimerPanelHandle = timerTextPanel.getHandle();
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return _context.featuresStates().hudFeaturesStates.bombTimerState;
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return _context.config();
    }

    [[nodiscard]] decltype(auto) uiEngine() const noexcept
    {
        return _context.template make<PanoramaUiEngine>();
    }

private:
    HookContext& _context;
};

```

`Source/Features/Hud/BombTimer/BombTimerPanel.h`:

```h
#pragma once

#include <CS2/Constants/BombsiteIndex.h>
#include <CS2/Constants/IconURLs.h>

template <typename Context>
struct BombTimerPanel {
    explicit BombTimerPanel(Context context) noexcept
        : context{context}
    {
    }

    void showAndUpdate() const noexcept
    {
        context.bombTimerContainerPanel().show();

        decltype(auto) tickingC4{context.tickingC4()};
        context.bombSiteIconPanel().setIcon(getBombSiteIconUrl(tickingC4));
        context.bombTimerTextPanel().setTimeToExplosion(tickingC4.getTimeToExplosion().valueOr(0.0f));
    }

    void hide() const noexcept
    {
        context.bombTimerContainerPanel().hide();
    }

private:
    [[nodiscard]] const char* getBombSiteIconUrl(auto&& tickingC4) const noexcept
    {
        auto&& bombsiteIndex = tickingC4.bombsiteIndex();
        if (!bombsiteIndex.hasValue())
            return nullptr;

        switch (bombsiteIndex.value()) {
        case cs2::BombsiteIndex::BombsiteA: return cs2::kBombSiteAIconUrl;
        case cs2::BombsiteIndex::BombsiteB: return cs2::kBombSiteBIconUrl;
        default: return nullptr;
        }
    }

    Context context;
};

```

`Source/Features/Hud/BombTimer/BombTimerPanelFactory.h`:

```h
#pragma once

#include <Utils/Lvalue.h>

#include "BombTimerPanelParams.h"

template <typename HookContext>
class BombTimerPanelFactory {
public:
    explicit BombTimerPanelFactory(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    decltype(auto) createContainerPanel(auto&& parentPanel) const noexcept
    {
        using namespace bomb_timer_panel_params::container_panel_params;

        auto&& panel = hookContext.panelFactory().createPanel(parentPanel).uiPanel();
        panel.setFlowChildren(kChildrenFlow);
        panel.setWidth(kWidth);
        panel.setHeight(kHeight);
        panel.setVisible(false);
        return utils::lvalue<decltype(panel)>(panel);
    }

    decltype(auto) createBombSiteIconPanel(auto&& parentPanel) const noexcept
    {
        using namespace bomb_timer_panel_params::bombsite_icon_panel_params;

        auto&& panel = hookContext.panelFactory().createImagePanel(parentPanel).uiPanel();
        panel.setWidth(kWidth);
        panel.setHeight(kHeight);
        panel.setAlign(kAlignment);
        panel.setMargin(kMargin);
        return utils::lvalue<decltype(panel)>(panel);
    }

    decltype(auto) createTimerTextPanel(auto&& parentPanel) const noexcept
    {
        using namespace bomb_timer_panel_params::timer_text_panel_params;

        auto&& panel = hookContext.panelFactory().createLabelPanel(parentPanel).uiPanel();
        panel.setWidth(kWidth);
        panel.setFont(kFont);
        panel.setMixBlendMode(kMixBlendMode);
        panel.setColor(kColor);
        panel.setAlign(kAlignment);
        panel.setTextAlign(kTextAlign);
        return utils::lvalue<decltype(panel)>(panel);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Hud/BombTimer/BombTimerPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>

#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace bomb_timer_panel_params::container_panel_params
{
    static constexpr auto kChildrenFlow = cs2::k_EFlowRight;
    static constexpr auto kWidth = cs2::CUILength::percent(100);
    static constexpr auto kHeight = cs2::CUILength::pixels(32);
}

namespace bomb_timer_panel_params::bombsite_icon_panel_params
{
    static constexpr auto kWidth = cs2::CUILength::pixels(26);
    static constexpr auto kHeight = cs2::CUILength::pixels(26);
    static constexpr auto kAlignment = PanelAlignmentParams{.verticalAlignment = cs2::k_EVerticalAlignmentCenter};
    static constexpr auto kMargin = PanelMarginParams{.marginLeft = cs2::CUILength::pixels(5)};
}

namespace bomb_timer_panel_params::timer_text_panel_params
{
    static constexpr auto kWidth = cs2::CUILength::fillParentFlow(1.0f);
    static constexpr auto kFont = PanelFontParams{
        .fontFamily = "Stratum2 Bold TF, 'Arial Unicode MS'",
        .fontSize = 22};
    static constexpr auto kMixBlendMode = cs2::k_EMixBlendModeAdditive;
    static constexpr auto kColor = cs2::kColorWhite;
    static constexpr auto kAlignment = PanelAlignmentParams{.verticalAlignment = cs2::k_EVerticalAlignmentCenter};
    static constexpr auto kTextAlign = cs2::k_ETextAlignCenter;
}

```

`Source/Features/Hud/BombTimer/BombTimerState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>

struct BombTimerState {
    cs2::PanelHandle bombTimerContainerPanelHandle;
    cs2::PanelHandle bombSiteIconPanelHandle;
    cs2::PanelHandle bombTimerPanelHandle;
};

```

`Source/Features/Hud/BombTimer/BombTimerTextPanel.h`:

```h
#pragma once

#include <Utils/StringBuilder.h>

template <typename LabelPanel>
struct BombTimerTextPanel {
    explicit BombTimerTextPanel(LabelPanel panel) noexcept
        : panel{panel}
    {
    }

    void setTimeToExplosion(float timeToExplosion) const noexcept
    {
        StringBuilderStorage<10> storage;
        StringBuilder builder = storage.builder();
        builder.put(static_cast<int>(timeToExplosion), '.', static_cast<int>(timeToExplosion * 10) % 10);
        panel.setText(builder.cstring());
    }

    LabelPanel panel;
};

```

`Source/Features/Hud/DefusingAlert/DefusingAlert.h`:

```h
#pragma once

#include <utility>

#include "DefusingAlertContext.h"

template <typename HookContext, typename Context = DefusingAlertContext<HookContext>>
class DefusingAlert {
public:
    template <typename... Args>
    DefusingAlert(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void run() const noexcept
    {
        decltype(auto) condition{context.defusingAlertCondition()};
        if (!condition.shouldRun())
            return;

        if (condition.shouldShowDefuseAlert())
            context.defusingAlertPanel().showAndUpdate();
        else
            context.defusingAlertPanel().hide();
    }

    void onDisable() const noexcept
    {
        context.defusingAlertPanel().hide();
    }

    void onUnload() const noexcept
    {
        context.uiEngine().deletePanelByHandle(context.state().defusingAlertContainerPanelHandle);
    }

private:
    Context context;
};

```

`Source/Features/Hud/DefusingAlert/DefusingAlertCondition.h`:

```h
#pragma once

#include "DefusingAlertConfigVariables.h"

template <typename Context>
struct DefusingAlertCondition {
    explicit DefusingAlertCondition(Context context) noexcept
        : context{context}
    {
    }

    [[nodiscard]] bool shouldRun() const noexcept
    {
        return context.config().template getVariable<DefusingAlertEnabled>();
    }

    [[nodiscard]] bool shouldShowDefuseAlert() const noexcept
    {
        return context.hasC4BeingDefused();
    }

private:
    Context context;
};

```

`Source/Features/Hud/DefusingAlert/DefusingAlertConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

CONFIG_VARIABLE(DefusingAlertEnabled, bool, false);

```

`Source/Features/Hud/DefusingAlert/DefusingAlertContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelMarginParams.h>
#include <GameClient/Panorama/ImagePanel.h>
#include <GameClient/Panorama/PanoramaLabel.h>
#include <GameClient/Panorama/PanoramaUiEngine.h>
#include <Utils/Lvalue.h>

#include "DefusingAlertCondition.h"
#include "DefusingAlertPanel.h"
#include "DefusingAlertPanelParams.h"
#include "DefusingAlertState.h"
#include "DefusingCountdownTextPanel.h"

template <typename HookContext>
class DefusingAlertContext {
public:
    DefusingAlertContext(HookContext& context) noexcept
        : context{context}
    {
    }

    [[nodiscard]] decltype(auto) defusingAlertContainerPanel() const noexcept
    {
        if (auto&& panel = uiEngine().getPanelFromHandle(state().defusingAlertContainerPanelHandle))
            return utils::lvalue<decltype(panel)>(panel);

        updatePanelHandles();
        return uiEngine().getPanelFromHandle(state().defusingAlertContainerPanelHandle);
    }

    [[nodiscard]] auto defusingAlertCondition() const noexcept
    {
        return DefusingAlertCondition{*this};
    }

    [[nodiscard]] auto defusingAlertPanel() const noexcept
    {
        return DefusingAlertPanel{*this};
    }

    [[nodiscard]] auto c4BeingDefused() const noexcept
    {
        return *context.plantedC4();
    }

    [[nodiscard]] bool hasC4BeingDefused() const noexcept
    {
        const auto plantedC4{context.plantedC4()};
        return plantedC4 && plantedC4->isBeingDefused();
    }

    [[nodiscard]] DefusingAlertState& state() const noexcept
    {
        return context.featuresStates().hudFeaturesStates.defusingAlertState;
    }

    [[nodiscard]] auto defusingCountdownTextPanel() const noexcept
    {
        return DefusingCountdownTextPanel{uiEngine().getPanelFromHandle(state().defusingTimerPanelHandle).clientPanel().template as<PanoramaLabel>()};
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return context.config();
    }

    [[nodiscard]] decltype(auto) uiEngine() const noexcept
    {
        return context.template make<PanoramaUiEngine>();
    }

private:
    void updatePanelHandles() const noexcept
    {
        if (uiEngine().getPanelFromHandle(state().defusingTimerPanelHandle))
            return;

        auto&& hudTeamCounter = context.hud().hudTeamCounter();
        if (!hudTeamCounter)
            return;

        uiEngine().runScript(hudTeamCounter,
            R"(
(function() {
  $.CreatePanel('Panel', $.GetContextPanel().FindChildInLayoutFile('ScoreAndTimeAndBomb'), 'DefusingAlertContainer', {
    style: 'border-radius: 3px; world-blur: hudWorldBlur; background-image: url( "s2r://panorama/images/backgrounds/bluedots_large_png.vtex"); background-size: auto 390px; background-img-opacity: 0.04; background-color: #0000007f;'
  });
})();
)");

        const auto defusingAlertContainer = hudTeamCounter.findChildInLayoutFile("DefusingAlertContainer");
        if (!defusingAlertContainer)
            return;

        defusingAlertContainer.setVisible(false);
        defusingAlertContainer.setFlowChildren(cs2::k_EFlowRight);
        defusingAlertContainer.setWidth(cs2::CUILength::percent(100));
        defusingAlertContainer.setHeight(cs2::CUILength::pixels(35));
        defusingAlertContainer.setPosition(cs2::CUILength::pixels(0), cs2::CUILength::pixels(100));
        defusingAlertContainer.setMargin(PanelMarginParams{.marginLeft = cs2::CUILength::pixels(1), .marginRight = cs2::CUILength::pixels(1)});

        createIconPanel(defusingAlertContainer);
        auto&& defusingTimer = createTimerPanel(defusingAlertContainer);
        state().defusingAlertContainerPanelHandle = defusingAlertContainer.getHandle();
        state().defusingTimerPanelHandle = defusingTimer.getHandle();
    }

    decltype(auto) createIconPanel(auto&& containerPanel) const noexcept
    {
        using namespace defusing_alert_panel_params::defuse_icon_panel_params;

        auto&& imagePanel = context.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(SvgImageParams{.imageUrl = kImageUrl, .textureHeight = kTextureHeight, .fillColor = kColor});
    
        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setMargin(kMargin);
        return utils::lvalue<decltype(uiPanel)>(uiPanel);
    }

    decltype(auto) createTimerPanel(auto&& containerPanel) const noexcept
    {
        using namespace defusing_alert_panel_params::timer_text_panel_params;

        auto&& panel = context.panelFactory().createLabelPanel(containerPanel).uiPanel();
        panel.setWidth(kWidth);
        panel.setFont(kFont);
        panel.setMixBlendMode(kMixBlendMode);
        panel.setColor(kColor);
        panel.setAlign(kAlignment);
        panel.setTextAlign(kTextAlign);
        return utils::lvalue<decltype(panel)>(panel);
    }

    HookContext& context;
};

```

`Source/Features/Hud/DefusingAlert/DefusingAlertPanel.h`:

```h
#pragma once

template <typename Context>
struct DefusingAlertPanel {
    explicit DefusingAlertPanel(Context context) noexcept
        : context{context}
    {
    }

    void showAndUpdate() const noexcept
    {
        context.defusingAlertContainerPanel().show();
        decltype(auto) c4BeingDefused{context.c4BeingDefused()};
        context.defusingCountdownTextPanel()
            .setTimeToDefuseEnd(c4BeingDefused.getTimeToDefuseEnd())
            .setCanBeDefused(c4BeingDefused.canBeDefused());
    }

    void hide() const noexcept
    {
        context.defusingAlertContainerPanel().hide();
    }

private:
    Context context;
};

```

`Source/Features/Hud/DefusingAlert/DefusingAlertPanelParams.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>
#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace defusing_alert_panel_params::timer_text_panel_params
{
    constexpr auto kWidth = cs2::CUILength::fillParentFlow(1.0f);
    constexpr auto kFont = PanelFontParams{
        .fontFamily = "Stratum2 Bold TF, 'Arial Unicode MS'",
        .fontSize = 24};
    constexpr auto kMixBlendMode = cs2::k_EMixBlendModeAdditive;
    constexpr auto kColor = cs2::kColorWhite;
    constexpr auto kAlignment = PanelAlignmentParams{.verticalAlignment = cs2::k_EVerticalAlignmentCenter};
    constexpr auto kTextAlign = cs2::k_ETextAlignCenter;
}

namespace defusing_alert_panel_params::defuse_icon_panel_params
{
    constexpr auto kImageUrl = "s2r://panorama/images/icons/equipment/defuser.vsvg";
    constexpr auto kTextureHeight = 25;
    constexpr auto kAlignment = PanelAlignmentParams{.verticalAlignment = cs2::k_EVerticalAlignmentCenter};
    constexpr auto kColor = cs2::kColorDefuseKit;
    constexpr auto kMargin = PanelMarginParams{.marginLeft = cs2::CUILength::pixels(5)};
}

```

`Source/Features/Hud/DefusingAlert/DefusingAlertState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>

struct DefusingAlertState {
    cs2::PanelHandle defusingAlertContainerPanelHandle;
    cs2::PanelHandle defusingTimerPanelHandle;
};

```

`Source/Features/Hud/DefusingAlert/DefusingCountdownTextPanel.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>
#include <CS2/Constants/ColorConstants.h>
#include <Utils/Optional.h>
#include <Utils/StringBuilder.h>

template <typename LabelPanel>
struct DefusingCountdownTextPanel {
    explicit DefusingCountdownTextPanel(LabelPanel panel) noexcept
        : panel{panel}
    {
    }

    auto& setTimeToDefuseEnd(Optional<float> timeToDefuseEnd) const noexcept
    {
        if (timeToDefuseEnd.hasValue()) {
            panel.setText(StringBuilderStorage<10>{}.builder().put(
                static_cast<int>(timeToDefuseEnd.value()), '.', static_cast<int>(timeToDefuseEnd.value() * 10) % 10).cstring());
        }
        return *this;
    }

    auto& setCanBeDefused(Optional<bool> canBeDefused) const noexcept
    {
        panel.uiPanel().setColor(getDefusingCountdownColor(canBeDefused));
        return *this;
    }

private:
    [[nodiscard]] static cs2::Color getDefusingCountdownColor(Optional<bool> canBeDefused) noexcept
    {
        if (canBeDefused.hasValue())
            return canBeDefused.value() ? cs2::kColorGreen : cs2::kColorRed;
        return cs2::kColorWhite;
    }

    LabelPanel panel;
};

```

`Source/Features/Hud/HudFeaturesStates.h`:

```h
#pragma once

#include "BombTimer/BombTimerState.h"
#include "BombPlantAlert/BombPlantAlertState.h"
#include "DefusingAlert/DefusingAlertState.h"
#include "PostRoundTimer/PostRoundTimerState.h"

struct HudFeaturesStates {
    BombTimerState bombTimerState;
    DefusingAlertState defusingAlertState;
    PostRoundTimerState postRoundTimerState;
    BombPlantAlertState bombPlantAlertState;
};

```

`Source/Features/Hud/KillfeedPreserver/KillfeedPreserver.h`:

```h
#pragma once

#include <utility>

#include "KillfeedPreserverConfigVariables.h"
#include "KillfeedPreserverContext.h"

template <typename HookContext, typename Context = KillfeedPreserverContext<HookContext>>
class KillfeedPreserver {
public:
    template <typename... Args>
    KillfeedPreserver(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void run() noexcept
    {
        if (context.config().template getVariable<KillfeedPreserverEnabled>())
            context.deathNotices().forEach(context.preserveDeathNotice());
    }

private:
    Context context;
};

```

`Source/Features/Hud/KillfeedPreserver/KillfeedPreserverConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

CONFIG_VARIABLE(KillfeedPreserverEnabled, bool, false);

```

`Source/Features/Hud/KillfeedPreserver/KillfeedPreserverContext.h`:

```h
#pragma once

template <typename HookContext>
struct KillfeedPreserverContext {
    KillfeedPreserverContext(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) deathNotices() const noexcept
    {
        return hookContext.hud().deathNotices();
    }

    [[nodiscard]] auto preserveDeathNotice() const noexcept
    {
        return [](auto&& deathNotice)
        {
            if (deathNotice.isLocalPlayerKiller() && deathNotice.wasSpawnedThisRound().valueOr(false))
                deathNotice.markAsJustSpawned();
        };
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return hookContext.config();
    }
    
private:
    HookContext& hookContext;
};

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimer.h`:

```h
#pragma once

#include <utility>
#include <Common/Visibility.h>
#include "PostRoundTimerContext.h"

template <typename HookContext, typename Context = PostRoundTimerContext<HookContext>>
class PostRoundTimer {
public:
    template <typename... Args>
    PostRoundTimer(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    [[nodiscard]] Visibility update() const noexcept
    {
        using enum Visibility;

        auto&& condition = context.condition();
        if (!condition.shouldRun())
            return Hidden;

        if (condition.shouldShowPostRoundTimer()) {
            context.postRoundTimerPanel().showAndUpdate();
            return Visible;
        } else {
            context.postRoundTimerPanel().hide();
            return Hidden;
        }
    }

    void onDisable() const noexcept
    {
        context.postRoundTimerPanel().hide();
    }

    void onUnload() const noexcept
    {
        context.uiEngine().deletePanelByHandle(context.state().countdownContainerPanelHandle);
    }

private:
    Context context;
};

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerCondition.h`:

```h
#pragma once

#include "PostRoundTimerConfigVariables.h"

template <typename Context>
struct PostRoundTimerCondition {
    explicit PostRoundTimerCondition(Context context) noexcept
        : context{context}
    {
    }

    [[nodiscard]] bool shouldRun() const noexcept
    {
        return context.config().template getVariable<PostRoundTimerEnabled>();
    }

    [[nodiscard]] bool shouldShowPostRoundTimer() const noexcept
    {
        return context.gameRules().hasScheduledRoundRestart() && !context.isGameRoundTimeVisible();
    }

private:
    Context context;
};

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

CONFIG_VARIABLE(PostRoundTimerEnabled, bool, false);

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerContext.h`:

```h
#pragma once

#include <GameClient/Panorama/PanoramaLabel.h>
#include <GameClient/Panorama/PanelHandle.h>

#include "PostRoundTimerCondition.h"
#include "PostRoundTimerPanel.h"
#include "PostRoundTimerPanelFactory.h"

template <typename HookContext>
struct PostRoundTimerContext {
    explicit PostRoundTimerContext(HookContext& hookContext) noexcept
        : _hookContext{hookContext}
    {
    }

    [[nodiscard]] bool isGameRoundTimeVisible() const noexcept
    {
        return _hookContext.hud().timerTextPanel().isVisible().valueOr(false);
    }

    [[nodiscard]] decltype(auto) gameRules() const noexcept
    {
        return _hookContext.gameRules();
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return _hookContext.featuresStates().hudFeaturesStates.postRoundTimerState;
    }

    [[nodiscard]] decltype(auto) countdownTextPanel() const noexcept
    {
        return countdownContainerPanel().children()[0].clientPanel().template as<PanoramaLabel>();
    }

    [[nodiscard]] decltype(auto) countdownContainerPanel() const noexcept
    {
        return countdownContainerPanelHandle().getOrInit(createCountdownContainerPanel());
    }

    [[nodiscard]] auto condition() const noexcept
    {
        return PostRoundTimerCondition{*this};
    }

    [[nodiscard]] auto postRoundTimerPanel() const noexcept
    {
        return PostRoundTimerPanel{*this};
    }

    [[nodiscard]] decltype(auto) localPlayerTeamNumber() const noexcept
    {
        return _hookContext.localPlayerController().teamNumber();
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return _hookContext.config();
    }

    [[nodiscard]] decltype(auto) uiEngine() const noexcept
    {
        return _hookContext.template make<PanoramaUiEngine>();
    }

private:
    [[nodiscard]] decltype(auto) countdownContainerPanelHandle() const noexcept
    {
        return _hookContext.template make<PanelHandle>(state().countdownContainerPanelHandle);
    }

    [[nodiscard]] decltype(auto) createCountdownContainerPanel() const noexcept
    {
        return [this] {
            auto&& factory = _hookContext.template make<PostRoundTimerPanelFactory>();
            auto&& containerPanel = factory.createCountdownContainerPanel(_hookContext.hud().scoreAndTimeAndBomb());
            factory.createCountdownTextPanel(containerPanel);
            return containerPanel;
        };
    }

    HookContext& _hookContext;
};

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerPanel.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <GameClient/Entities/TeamNumber.h>
#include <Utils/StringBuilder.h>

template <typename Context>
struct PostRoundTimerPanel {
    explicit PostRoundTimerPanel(Context context) noexcept
        : context{context}
    {
    }

    void showAndUpdate() const noexcept
    {
        context.countdownContainerPanel().show();

        auto&& countdownTextPanel = context.countdownTextPanel();
        updateCountdownTime(countdownTextPanel);
        countdownTextPanel.uiPanel().setColor(getColor());
    }

    void hide() const noexcept
    {
        context.countdownContainerPanel().hide();
    }

private:
    [[nodiscard]] auto getColor() const noexcept
    {
        switch (context.localPlayerTeamNumber()) {
        using enum TeamNumber;
        case TT: return cs2::kColorTeamTT;
        case CT: return cs2::kColorTeamCT;
        default: return cs2::kColorSilver;
        }
    }

    void updateCountdownTime(auto&& countdownTextPanel) const noexcept
    {
        const auto timeToRoundRestart = getTimeToRoundRestart();
        countdownTextPanel.setText(StringBuilderStorage<10>{}.builder().put(static_cast<int>(timeToRoundRestart), '.', static_cast<int>(timeToRoundRestart * 10) % 10).cstring());
    }

    [[nodiscard]] float getTimeToRoundRestart() const noexcept
    {
        if (auto&& timeToRoundRestart = context.gameRules().timeToRoundRestart(); timeToRoundRestart.hasValue() && timeToRoundRestart.value() >= 0.0f)
            return timeToRoundRestart.value();
        return 0.0f;
    }

    Context context;
};

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerPanelFactory.h`:

```h
#pragma once

#include <Utils/Lvalue.h>

#include "PostRoundTimerPanelParams.h"

template <typename HookContext>
struct PostRoundTimerPanelFactory {
    explicit PostRoundTimerPanelFactory(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    decltype(auto) createCountdownContainerPanel(auto&& parentPanel) const noexcept
    {
        using namespace post_round_timer_panel_params::container_panel_params;

        auto&& panel = hookContext.panelFactory().createPanel(parentPanel).uiPanel();
        panel.setWidth(kWidth);
        panel.setHeight(kHeight);
        return utils::lvalue<decltype(panel)>(panel);
    }

    decltype(auto) createCountdownTextPanel(auto&& containerPanel) const noexcept
    {
        using namespace post_round_timer_panel_params::text_panel_params;

        auto&& panel = hookContext.panelFactory().createLabelPanel(containerPanel).uiPanel();
        panel.setWidth(kWidth);
        panel.setMixBlendMode(kMixBlendMode);
        panel.setFont(kFont);
        panel.setTextAlign(kTextAlign);
        return utils::lvalue<decltype(panel)>(panel);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerPanelParams.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelFontParams.h>

namespace post_round_timer_panel_params::container_panel_params
{
    static constexpr auto kWidth = cs2::CUILength::percent(100);
    static constexpr auto kHeight = cs2::CUILength::pixels(32);
}

namespace post_round_timer_panel_params::text_panel_params
{
    static constexpr auto kWidth = cs2::CUILength::percent(100);
    static constexpr auto kMixBlendMode = cs2::k_EMixBlendModeAdditive;
    static constexpr auto kTextAlign = cs2::k_ETextAlignCenter;
    static constexpr auto kFont = PanelFontParams{
        .fontFamily = "Stratum2 Bold TF, 'Arial Unicode MS'",
        .fontSize = 28
    };
}

```

`Source/Features/Hud/PostRoundTimer/PostRoundTimerState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>

struct PostRoundTimerState {
    cs2::PanelHandle countdownContainerPanelHandle;
};

```

`Source/Features/Sound/BombBeepVisualizer.h`:

```h
#pragma once

#include "Details/BombBeepSound.h"
#include "Details/SoundVisualizationFeature.h"
#include "Details/SoundVisualizationPanelProperties.h"

struct BombBeepPanels {
    [[nodiscard]] static SoundVisualizationPanelProperties soundVisualizationPanelProperties() noexcept
    {
        return SoundVisualizationPanelProperties{
            .svgImagePath = "s2r://panorama/images/icons/ui/bomb_c4.svg",
            .svgTextureHeight = 40,
            .position = SoundVisualizationPosition::AtOrigin};
    }
};

template <typename HookContext>
using BombBeepVisualizer = SoundVisualizationFeature<HookContext, BombBeepPanels, BombBeepSound>;

```

`Source/Features/Sound/BombDefuseVisualizer.h`:

```h
#pragma once

#include "Details/BombDefuseSound.h"
#include "Details/SoundVisualizationFeature.h"
#include "Details/SoundVisualizationPanelProperties.h"

struct BombDefusePanels {
    [[nodiscard]] static SoundVisualizationPanelProperties soundVisualizationPanelProperties() noexcept
    {
        return SoundVisualizationPanelProperties{
            .svgImagePath = "s2r://panorama/images/icons/equipment/defuser.vsvg",
            .svgTextureHeight = 40,
            .position = SoundVisualizationPosition::AtOrigin};
    }
};

template <typename HookContext>
using BombDefuseVisualizer = SoundVisualizationFeature<HookContext, BombDefusePanels, BombDefuseSound>;

```

`Source/Features/Sound/BombPlantVisualizer.h`:

```h
#pragma once

#include "Details/BombPlantSound.h"
#include "Details/SoundVisualizationFeature.h"
#include "Details/SoundVisualizationPanelProperties.h"

struct BombPlantPanels {
    [[nodiscard]] static SoundVisualizationPanelProperties soundVisualizationPanelProperties() noexcept
    {
        return SoundVisualizationPanelProperties{
            .svgImagePath = "s2r://panorama/images/icons/ui/chatwheel_bombat.svg",
            .svgTextureHeight = 64,
            .position = SoundVisualizationPosition::AboveOrigin};
    }
};

template <typename HookContext>
using BombPlantVisualizer = SoundVisualizationFeature<HookContext, BombPlantPanels, BombPlantSound>;

```

`Source/Features/Sound/Details/BombBeepSound.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Constants/SoundNames.h>

struct BombBeepSound {
    static constexpr auto kFadeAwayStart = 0.0f;
    static constexpr auto kFadeAwayDuration = 0.3f;
    static constexpr auto kMinScale = 0.4f;

    [[nodiscard]] static constexpr bool isSound(std::string_view soundName) noexcept
    {
        return soundName.starts_with(cs2::kBombSoundsPath) && std::string_view{ soundName.data() + cs2::kBombSoundsPath.length(), soundName.length() - cs2::kBombSoundsPath.length() }.starts_with(cs2::kBombBeepSoundsPrefix);
    }
};

```

`Source/Features/Sound/Details/BombDefuseSound.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Constants/SoundNames.h>

struct BombDefuseSound {
    static constexpr auto kFadeAwayStart = 2.0f;
    static constexpr auto kFadeAwayDuration = 1.0f;
    static constexpr auto kMinScale = 0.4f;

    [[nodiscard]] static constexpr bool isSound(std::string_view soundName) noexcept
    {
        return soundName.starts_with(cs2::kBombSoundsPath) && std::string_view{ soundName.data() + cs2::kBombSoundsPath.length(), soundName.length() - cs2::kBombSoundsPath.length() }.starts_with(cs2::kBombDefuseStartSoundName);
    }
};

```

`Source/Features/Sound/Details/BombPlantSound.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Constants/SoundNames.h>

struct BombPlantSound {
    static constexpr auto kFadeAwayStart = 2.1f;
    static constexpr auto kFadeAwayDuration = 0.4f;
    static constexpr auto kMinScale = 0.4f;

    [[nodiscard]] static constexpr bool isSound(std::string_view soundName) noexcept
    {
        return soundName == cs2::kBombPlantSoundPath;
    }
};

```

`Source/Features/Sound/Details/FootstepSound.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Constants/SoundNames.h>

struct FootstepSound {
    static constexpr auto kFadeAwayStart = 1.6f;
    static constexpr auto kFadeAwayDuration = 0.4f;
    static constexpr auto kMinScale = 0.3f;

    [[nodiscard]] static constexpr bool isSound(std::string_view soundName) noexcept
    {
        if (soundName.starts_with(cs2::kPlayerFootstepSoundsPath)) {
            const auto soundFileName = std::string_view{soundName.data() + cs2::kPlayerFootstepSoundsPath.length(), soundName.length() - cs2::kPlayerFootstepSoundsPath.length()};
            return !soundFileName.starts_with(cs2::kPlayerSuitSoundPrefix) && !soundFileName.starts_with(cs2::kBassSoundPrefix);
        }
        return false;
    }
};

```

`Source/Features/Sound/Details/PlayedSound.h`:

```h
#pragma once

#include <limits>

#include <CS2/Classes/Vector.h>

struct PlayedSound {
    float spawnTime;
    cs2::Vector origin;

    [[nodiscard]] float getTimeAlive(float curtime) const noexcept
    {
        if (curtime >= spawnTime)
            return curtime - spawnTime;
        return (std::numeric_limits<float>::max)();
    }

    [[nodiscard]] bool isAlive(float curtime, float lifetime) const noexcept
    {
        return getTimeAlive(curtime) <= lifetime;
    }
};

```

`Source/Features/Sound/Details/SoundExpiryChecker.h`:

```h
#pragma once

#include <CS2/Classes/CUtlVector.h>
#include <CS2/Classes/Sound.h>

#include "PlayedSound.h"

struct SoundExpiryChecker {
    SoundExpiryChecker(const cs2::CUtlVector<cs2::ChannelInfo1>& channelInfo, float curtime, float lifeSpan) noexcept
        : channelInfo{ channelInfo }
        , curtime{ curtime }
        , lifeSpan{ lifeSpan }
    {
    }

    [[nodiscard]] bool operator()(const PlayedSound& sound) const noexcept
    {
        return !sound.isAlive(curtime, lifeSpan);
    }

    [[nodiscard]] bool operator()(int guid) const noexcept
    {
        return !hasChannelWithGuid(guid);
    }

private:
    [[nodiscard]] bool hasChannelWithGuid(int guid) const noexcept
    {
        for (int i = 0; i < channelInfo.size; ++i) {
            if (const auto& channel = channelInfo.memory[i]; channel.sfx && channel.guid == guid)
                return true;
        }
        return false;
    }

    const cs2::CUtlVector<cs2::ChannelInfo1>& channelInfo;
    float curtime;
    float lifeSpan;
};

```

`Source/Features/Sound/Details/SoundVisualization.h`:

```h
#pragma once

#include <algorithm>

template <typename SoundType>
struct SoundVisualization {
    [[nodiscard]] static constexpr float getScale(float z, float fovScale) noexcept
    {
        constexpr auto kMaxScale{1.0f};
        return std::clamp(500.0f / (z / fovScale + 400.0f), SoundType::kMinScale, kMaxScale);
    }

    [[nodiscard]] static constexpr float getOpacity(float timeAlive) noexcept
    {
        if (timeAlive >= SoundType::kFadeAwayStart) {
            return 1.0f - (std::min)((timeAlive - SoundType::kFadeAwayStart) / SoundType::kFadeAwayDuration, 1.0f);
        } else {
            return 1.0f;
        }
    }
};

```

`Source/Features/Sound/Details/SoundVisualizationFeature.h`:

```h
#pragma once

#include <utility>

#include <GameClient/Panorama/PanoramaTransformations.h>
#include <Features/Sound/Details/PlayedSound.h>
#include <Features/Sound/Details/SoundWatcher.h>
#include <Features/Sound/SoundVisualizationConfigVariables.h>
#include <Features/Common/FeatureToggle.h>
#include <GameClient/WorldToScreen/ViewToProjectionMatrix.h>
#include <GameClient/WorldToScreen/WorldToClipSpaceConverter.h>
#include <Features/Common/InWorldPanels.h>
#include <Hooks/ViewRenderHook.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include "SoundVisualization.h"

template <typename HookContext, typename PanelsType, typename SoundType>
class SoundVisualizationFeature {
public:
    SoundVisualizationFeature(
        HookContext& hookContext,
        ViewRenderHook& viewRenderHook,
        SoundWatcher<HookContext> soundWatcher) noexcept
        : hookContext{hookContext}
        , viewRenderHook{viewRenderHook}
        , soundWatcher{soundWatcher}
    {
    }

    void run() noexcept
    {
        if (!enabled())
            return;

        const auto curtime = hookContext.globalVars().curtime();
        if (!curtime.hasValue())
            return;

        std::as_const(soundWatcher).template getSoundsOfType<SoundType>().forEach([this, curtime](const PlayedSound& sound) {
            const auto soundInClipSpace = hookContext.template make<WorldToClipSpaceConverter>().toClipSpace(sound.origin);
            if (!soundInClipSpace.onScreen())
                return;

            const auto opacity = SoundVisualization<SoundType>::getOpacity(sound.getTimeAlive(curtime.value()));
            if (opacity <= 0.0f)
                return;

            auto&& panel = hookContext.template make<InWorldPanels>().template getNextSoundVisualizationPanel<PanelsType>();
            panel.setOpacity(opacity);
            panel.setZIndex(-soundInClipSpace.z);

            const auto deviceCoordinates = soundInClipSpace.toNormalizedDeviceCoordinates();

            auto&& transformFactory = hookContext.panoramaTransformFactory();
            PanoramaTransformations{
                transformFactory.scale(SoundVisualization<SoundType>::getScale(soundInClipSpace.z, ViewToProjectionMatrix{hookContext}.getFovScale())),
                transformFactory.translate(deviceCoordinates.getX(), deviceCoordinates.getY())
            }.applyTo(panel);
        });
    }

private:
    [[nodiscard]] auto enabled() noexcept
    {
        if constexpr (std::is_same_v<SoundType, BombBeepSound>)
            return GET_CONFIG_VAR(BombBeepSoundVisualizationEnabled);
        else if constexpr (std::is_same_v<SoundType, BombDefuseSound>)
            return GET_CONFIG_VAR(BombBeepSoundVisualizationEnabled);
        else if constexpr (std::is_same_v<SoundType, BombPlantSound>)
            return GET_CONFIG_VAR(BombPlantSoundVisualizationEnabled);
        else if constexpr (std::is_same_v<SoundType, FootstepSound>)
            return GET_CONFIG_VAR(FootstepSoundVisualizationEnabled);
        else if constexpr (std::is_same_v<SoundType, WeaponReloadSound>)
            return GET_CONFIG_VAR(WeaponReloadSoundVisualizationEnabled);
        else if constexpr (std::is_same_v<SoundType, WeaponScopeSound>)
            return GET_CONFIG_VAR(WeaponScopeSoundVisualizationEnabled);
        else
            static_assert(!std::is_same_v<SoundType, SoundType>, "Unknown type");
    }

    HookContext& hookContext;
    ViewRenderHook& viewRenderHook;
    SoundWatcher<HookContext> soundWatcher;
};

```

`Source/Features/Sound/Details/SoundVisualizationPanelFactory.h`:

```h
#pragma once

#include <cassert>

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/CUIPanel.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <Utils/Lvalue.h>

#include "SoundVisualizationPanelProperties.h"

template <typename HookContext>
class SoundVisualizationPanelFactory {
public:
    SoundVisualizationPanelFactory(HookContext& hookContext, cs2::CUIPanel& parentPanel) noexcept
        : hookContext{hookContext}
        , parentPanel{parentPanel}
    {
    }

    [[nodiscard]] decltype(auto) createSoundVisualizationPanel(const SoundVisualizationPanelProperties& properties) const noexcept
    {
        auto&& panelFactory = hookContext.panelFactory();
        auto&& containerPanel = panelFactory.createPanel(&parentPanel).uiPanel();

        containerPanel.setWidth(cs2::CUILength::pixels(kWidth));
        containerPanel.setHeight(cs2::CUILength::pixels(kHeight));
        if (properties.position == SoundVisualizationPosition::AboveOrigin) {
            containerPanel.setPosition(cs2::CUILength::pixels(-kWidth * 0.5f), cs2::CUILength::pixels(-kHeight));
            containerPanel.setTransformOrigin(cs2::CUILength::percent(50), cs2::CUILength::percent(100));
        } else {
            assert(properties.position == SoundVisualizationPosition::AtOrigin);
            containerPanel.setPosition(cs2::CUILength::pixels(-kWidth * 0.5f), cs2::CUILength::pixels(-kHeight * 0.5f));
        }

        applyStyleToImagePanel(panelFactory.createImagePanel(containerPanel), properties);
        return utils::lvalue<decltype(containerPanel)>(containerPanel);
    }

private:
    void applyStyleToImagePanel(auto&& imagePanel, const SoundVisualizationPanelProperties& properties) const noexcept
    {
        imagePanel.setImageSvg(properties.svgImagePath, properties.svgTextureHeight);
        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(PanelAlignmentParams{cs2::k_EHorizontalAlignmentCenter, imageVerticalAlignment(properties.position)});
        uiPanel.setImageShadow(imageShadowParams());
    }

    [[nodiscard]] static PanelShadowParams imageShadowParams() noexcept
    {
        return PanelShadowParams{
            .horizontalOffset{cs2::CUILength::pixels(0)},
            .verticalOffset{cs2::CUILength::pixels(0)},
            .blurRadius{cs2::CUILength::pixels(1)},
            .strength = 3,
            .color{cs2::kColorBlack}
        };
    }

    [[nodiscard]] static cs2::EVerticalAlignment imageVerticalAlignment(SoundVisualizationPosition position) noexcept
    {
        if (position == SoundVisualizationPosition::AboveOrigin)
            return cs2::k_EVerticalAlignmentBottom;
        return cs2::k_EVerticalAlignmentCenter;
    }

    static constexpr auto kWidth{256};
    static constexpr auto kHeight{256};

    HookContext& hookContext;
    cs2::CUIPanel& parentPanel;
};

```

`Source/Features/Sound/Details/SoundVisualizationPanelProperties.h`:

```h
#pragma once

enum class SoundVisualizationPosition {
    AtOrigin,
    AboveOrigin
};

struct SoundVisualizationPanelProperties {
    const char* svgImagePath;
    int svgTextureHeight{-1};
    SoundVisualizationPosition position;
};

```

`Source/Features/Sound/Details/SoundWatcher.h`:

```h
#pragma once

#include "SoundWatcherImpl.h"
#include "SoundWatcherState.h"

template <typename HookContext>
using SoundWatcher = SoundWatcherImpl<HookContext, SoundWatcherState>;

```

`Source/Features/Sound/Details/SoundWatcherImpl.h`:

```h
#pragma once

#include <array>
#include <cassert>
#include <cstddef>
#include <string_view>
#include <tuple>

#include <CS2/Classes/Sound.h>
#include <CS2/Classes/Vector.h>
#include <GameClient/FileSystem.h>
#include <MemoryPatterns/PatternTypes/SoundSystemPatternTypes.h>
#include "PlayedSound.h"
#include "WatchedSounds.h"
#include <Utils/TypeIndex.h>

#include "SoundExpiryChecker.h"
#include "SoundWatcherImplState.h"

template <typename HookContext, typename Sounds>
class SoundWatcherImpl;

template <typename HookContext, typename... Sounds>
class SoundWatcherImpl<HookContext, SoundWatcherImplState<Sounds...>> {
public:
    explicit SoundWatcherImpl(SoundWatcherImplState<Sounds...>& state, HookContext& hookContext) noexcept
        : state{state}
        , hookContext{hookContext}
    {
    }

    template <typename Sound>
    void startWatching() noexcept
    {
        assert(!isWatching<Sound>());
        state.soundsToWatch.template set<Sound>();
    }

    template <typename Sound>
    void stopWatching() noexcept
    {
        assert(isWatching<Sound>());
        state.soundsToWatch.template unset<Sound>();
    }

    void update() noexcept
    {
        const auto curtime = hookContext.globalVars().curtime();
        if (!curtime.hasValue())
            return;

        auto soundChannels = hookContext.patternSearchResults().template get<SoundChannelsPointer>();
        if (!soundChannels || !*soundChannels)
            return;

        (removeExpiredSounds<Sounds>(**soundChannels, curtime.value()), ...);
        collectNewSounds(**soundChannels, curtime.value());
    }

    template <typename Sound>
    [[nodiscard]] const WatchedSounds& getSoundsOfType() const noexcept
    {
        return state.watchedSounds[indexOf<Sound>()];
    }

private:
    template <typename Sound>
    void removeExpiredSounds(cs2::SoundChannels& soundChannels, float curtime) noexcept
    {
        if (isWatching<Sound>())
            getSoundsOfType<Sound>().removeExpiredSounds(SoundExpiryChecker{soundChannels.channelInfo1, curtime, Sound::kFadeAwayStart + Sound::kFadeAwayDuration});
    }

    template <typename Sound>
    [[nodiscard]] bool isWatching() const noexcept
    {
        return state.soundsToWatch.template has<Sound>();
    }

    template <typename Sound>
    [[nodiscard]] WatchedSounds& getSoundsOfType() noexcept
    {
        return state.watchedSounds[indexOf<Sound>()];
    }

    void collectNewSounds(cs2::SoundChannels& soundChannels, float curtime) noexcept
    {
        if (!state.soundsToWatch)
            return;

        const auto fileNames = hookContext.template make<FileSystem<HookContext>>().fileNames();
        if (!fileNames)
            return;

        const auto& channelInfo1 = soundChannels.channelInfo1;
        const auto& channelInfo2 = soundChannels.channelInfo2;

        for (int i = 0; i < channelInfo1.size; ++i) {
            const auto& channel = channelInfo1.memory[i];
            if (!channel.sfx)
                continue;

            std::array<char, 1024> buffer;
            fileNames.getString(channel.sfx->fileNameHandle, buffer);
            buffer.back() = '\0';

            if (const auto sounds = getSoundsToAddTo(std::string_view{buffer.data()}, channel.guid))
                sounds->addSound(channel.guid, PlayedSound{ .spawnTime = curtime, .origin = correctSoundOrigin(channelInfo2.memory[i].origin) });
        }
    }

    [[nodiscard]] WatchedSounds* getSoundsToAddTo(std::string_view soundName, int guid) noexcept
    {
        WatchedSounds* result = nullptr;
        std::ignore = (getSoundsToAddTo<Sounds>(soundName, guid, result) || ...);
        return result;
    }

    template <typename Sound>
    [[nodiscard]] bool getSoundsToAddTo(std::string_view soundName, int guid, WatchedSounds*& out) noexcept
    {
        if (!isWatching<Sound>())
            return false;

        if (Sound::isSound(soundName)) {
            if (auto& sounds = getSoundsOfType<Sound>(); !sounds.hasSound(guid))
                out = &sounds;
            return true;
        }
        return false;
    }

    [[nodiscard]] static cs2::Vector correctSoundOrigin(cs2::Vector origin) noexcept
    {
        constexpr auto heightDifference = -20.0f;
        return cs2::Vector{ origin.x, origin.y, origin.z + heightDifference };
    }

    template <typename Sound>
    [[nodiscard]] static consteval std::size_t indexOf() noexcept
    {
        return utils::typeIndex<Sound, std::tuple<Sounds...>>();
    }

    SoundWatcherImplState<Sounds...>& state;
    HookContext& hookContext;
};

```

`Source/Features/Sound/Details/SoundWatcherImplState.h`:

```h
#pragma once

#include <array>

#include <Utils/TypeBitFlags.h>
#include "WatchedSounds.h"

template <typename... Sounds>
struct SoundWatcherImplState {
    TypeBitFlags<Sounds...> soundsToWatch;
    std::array<WatchedSounds, sizeof...(Sounds)> watchedSounds;
};

```

`Source/Features/Sound/Details/SoundWatcherState.h`:

```h
#include <Features/Sound/Details/BombBeepSound.h>
#include <Features/Sound/Details/BombDefuseSound.h>
#include <Features/Sound/Details/BombPlantSound.h>
#include <Features/Sound/Details/FootstepSound.h>
#include <Features/Sound/Details/WeaponReloadSound.h>
#include <Features/Sound/Details/WeaponScopeSound.h>

#include "SoundWatcherImplState.h"

using SoundWatcherState = SoundWatcherImplState<
    FootstepSound,
    BombPlantSound,
    BombBeepSound,
    BombDefuseSound,
    WeaponScopeSound,
    WeaponReloadSound
>;

```

`Source/Features/Sound/Details/WatchedSounds.h`:

```h
#pragma once

#include <algorithm>
#include <cstddef>
#include <utility>

#include "PlayedSound.h"
#include <CS2/Classes/Vector.h>
#include <Utils/DynamicArray.h>

class WatchedSounds {
public:
    void addSound(int guid, const PlayedSound& sound) noexcept
    {
        if (!guids.pushBack(guid))
            return;

        if (const auto soundAtSameOrigin = findSoundAtOrigin(sound.origin)) {
            soundAtSameOrigin->spawnTime = sound.spawnTime;
        } else if (sounds.pushBack(sound)) {
            std::swap(guids.back(), guids[sounds.getSize() - 1]);
        }
    }

    [[nodiscard]] bool hasSound(int soundGuid) const noexcept
    {
        // can not use std::ranges::find() because it tries to link with __std_find_trivial_4
        for (const auto guid : guids) {
            if (guid == soundGuid)
                return true;
        }
        return false;
    }

    template <typename Predicate>
    void removeExpiredSounds(Predicate&& predicate) noexcept
    {
        for (std::size_t i = 0; i < guids.getSize();) {
            if (!tryRemoveGuidAndSound(std::forward<Predicate>(predicate), i))
                ++i;
        }
    }

    template <typename F>
    void forEach(F&& f) const noexcept
    {
        std::ranges::for_each(sounds, std::forward<F>(f));
    }

private:
    template <typename Predicate>
    [[nodiscard]] bool tryRemoveGuidAndSound(Predicate&& predicate, std::size_t index) noexcept
    {
        const auto hasSoundAssociatedWithGuid = index < sounds.getSize();
        const auto canRemoveSound = !hasSoundAssociatedWithGuid || predicate(std::as_const(sounds[index]));

        if (canRemoveSound && predicate(std::as_const(guids[index]))) {
            hasSoundAssociatedWithGuid ? removeSoundAndGuid(index) : removeGuid(index);
            return true;
        }
        return false;
    }

    [[nodiscard]] PlayedSound* findSoundAtOrigin(const cs2::Vector& origin) noexcept
    {
        if (const auto found = std::ranges::find(sounds, origin, &PlayedSound::origin); found != sounds.end())
            return found;
        return nullptr;
    }

    void removeSoundAndGuid(std::size_t index) noexcept
    {
        sounds.fastRemoveAt(index);
        guids[index] = guids[sounds.getSize()];
        removeGuid(sounds.getSize());
    }

    void removeGuid(std::size_t index) noexcept
    {
        guids.fastRemoveAt(index);
    }

    DynamicArray<int> guids;
    DynamicArray<PlayedSound> sounds;
};

```

`Source/Features/Sound/Details/WeaponReloadSound.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Constants/SoundNames.h>

struct WeaponReloadSound {
    static constexpr auto kFadeAwayStart = 1.8f;
    static constexpr auto kFadeAwayDuration = 0.8f;
    static constexpr auto kMinScale = 0.5f;

    [[nodiscard]] static constexpr bool isSound(std::string_view soundName) noexcept
    {
        return soundName.starts_with(cs2::kWeaponSoundsPath) && (soundName.ends_with(cs2::kClipOutSoundSuffix) || soundName.ends_with(cs2::kCoverUpSoundSuffix));
    }
};

```

`Source/Features/Sound/Details/WeaponScopeSound.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Constants/SoundNames.h>

struct WeaponScopeSound {
    static constexpr auto kFadeAwayStart = 1.8f;
    static constexpr auto kFadeAwayDuration = 0.8f;
    static constexpr auto kMinScale = 0.5f;

    [[nodiscard]] static constexpr bool isSound(std::string_view soundName) noexcept
    {
        return soundName.starts_with(cs2::kWeaponSoundsPath) && soundName.find(cs2::kZoomSoundNamePart) != std::string_view::npos;
    }
};

```

`Source/Features/Sound/FootstepVisualizer.h`:

```h
#pragma once

#include "Details/FootstepSound.h"
#include "Details/SoundVisualizationFeature.h"
#include "Details/SoundVisualizationPanelProperties.h"

struct FootstepPanels {
    [[nodiscard]] static SoundVisualizationPanelProperties soundVisualizationPanelProperties() noexcept
    {
        return SoundVisualizationPanelProperties{
            .svgImagePath = "s2r://panorama/images/icons/equipment/stomp_damage.svg",
            .position = SoundVisualizationPosition::AboveOrigin};
    }
};

template <typename HookContext>
using FootstepVisualizer = SoundVisualizationFeature<HookContext, FootstepPanels, FootstepSound>;

```

`Source/Features/Sound/SoundFeatures.h`:

```h
#pragma once

#include <Features/Sound/Details/SoundWatcher.h>
#include <Features/Sound/Details/SoundWatcherState.h>
#include <Hooks/ViewRenderHook.h>

#include "Details/BombBeepSound.h"
#include "Details/BombDefuseSound.h"
#include "Details/BombPlantSound.h"
#include "Details/FootstepSound.h"
#include "Details/WeaponReloadSound.h"
#include "Details/WeaponScopeSound.h"
#include "BombBeepVisualizer.h"
#include "BombDefuseVisualizer.h"
#include "BombPlantVisualizer.h"
#include "FootstepVisualizer.h"
#include "WeaponReloadVisualizer.h"
#include "WeaponScopeVisualizer.h"

template <typename HookContext>
struct SoundFeatures {
    SoundFeatures(SoundWatcherState& soundWatcherState, ViewRenderHook& viewRenderHook, HookContext& hookContext) noexcept
        : soundWatcherState{soundWatcherState}
        , viewRenderHook{viewRenderHook}
        , hookContext{hookContext}
    {
    }

    void runOnViewMatrixUpdate() noexcept
    {
        footstepVisualizer().run();
        bombPlantVisualizer().run();
        bombBeepVisualizer().run();
        bombDefuseVisualizer().run();
        weaponScopeVisualizer().run();
        weaponReloadVisualizer().run();
    }

private:
    [[nodiscard]] auto footstepVisualizer() const noexcept
    {
        return soundVisualizationFeature<FootstepVisualizer>();
    }

    [[nodiscard]] auto bombPlantVisualizer() const noexcept
    {
        return soundVisualizationFeature<BombPlantVisualizer>();
    }

    [[nodiscard]] auto bombBeepVisualizer() const noexcept
    {
        return soundVisualizationFeature<BombBeepVisualizer>();
    }

    [[nodiscard]] auto bombDefuseVisualizer() const noexcept
    {
        return soundVisualizationFeature<BombDefuseVisualizer>();
    }

    [[nodiscard]] auto weaponScopeVisualizer() const noexcept
    {
        return soundVisualizationFeature<WeaponScopeVisualizer>();
    }

    [[nodiscard]] auto weaponReloadVisualizer() const noexcept
    {
        return soundVisualizationFeature<WeaponReloadVisualizer>();
    }

    template <template <typename> typename SoundVisualizationFeature>
    [[nodiscard]] auto soundVisualizationFeature() const noexcept
    {
        return SoundVisualizationFeature<HookContext>{
            hookContext,
            viewRenderHook,
            SoundWatcher<HookContext>{soundWatcherState, hookContext},
        };
    }

    SoundWatcherState& soundWatcherState;
    ViewRenderHook& viewRenderHook;
    HookContext& hookContext;
};

```

`Source/Features/Sound/SoundVisualizationConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>

CONFIG_VARIABLE(BombBeepSoundVisualizationEnabled, bool, false);
CONFIG_VARIABLE(BombDefuseSoundVisualizationEnabled, bool, false);
CONFIG_VARIABLE(BombPlantSoundVisualizationEnabled, bool, false);
CONFIG_VARIABLE(FootstepSoundVisualizationEnabled, bool, false);
CONFIG_VARIABLE(WeaponReloadSoundVisualizationEnabled, bool, false);
CONFIG_VARIABLE(WeaponScopeSoundVisualizationEnabled, bool, false);

```

`Source/Features/Sound/SoundVisualizationPanelTypes.h`:

```h
#pragma once

#include <Utils/TypeList.h>

struct BombBeepPanels;
struct BombDefusePanels;
struct BombPlantPanels;
struct FootstepPanels;
struct WeaponReloadPanels;
struct WeaponScopePanels;

using SoundVisualizationPanelTypes = TypeList<
    BombBeepPanels,
    BombDefusePanels,
    BombPlantPanels,
    FootstepPanels,
    WeaponReloadPanels,
    WeaponScopePanels>;

```

`Source/Features/Sound/WeaponReloadVisualizer.h`:

```h
#pragma once

#include "Details/WeaponReloadSound.h"
#include "Details/SoundVisualizationFeature.h"
#include "Details/SoundVisualizationPanelProperties.h"

struct WeaponReloadPanels {
    [[nodiscard]] static SoundVisualizationPanelProperties soundVisualizationPanelProperties() noexcept
    {
        return SoundVisualizationPanelProperties{
            .svgImagePath = "s2r://panorama/images/icons/ui/switch_teams_dead.svg",
            .position = SoundVisualizationPosition::AtOrigin};
    }
};

template <typename HookContext>
using WeaponReloadVisualizer = SoundVisualizationFeature<HookContext, WeaponReloadPanels, WeaponReloadSound>;

```

`Source/Features/Sound/WeaponScopeVisualizer.h`:

```h
#pragma once

#include "Details/WeaponScopeSound.h"
#include "Details/SoundVisualizationFeature.h"
#include "Details/SoundVisualizationPanelProperties.h"

struct WeaponScopePanels {
    [[nodiscard]] static SoundVisualizationPanelProperties soundVisualizationPanelProperties() noexcept
    {
        return SoundVisualizationPanelProperties{
            .svgImagePath = "s2r://panorama/images/icons/ui/chatwheel_sniperspotted.svg",
            .position = SoundVisualizationPosition::AtOrigin};
    }
};

template <typename HookContext>
using WeaponScopeVisualizer = SoundVisualizationFeature<HookContext, WeaponScopePanels, WeaponScopeSound>;

```

`Source/Features/Visuals/ModelGlow/DefuseKitModelGlow/DefuseKitModelGlow.h`:

```h
#pragma once

#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowParams.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
class DefuseKitModelGlow {
public:
    explicit DefuseKitModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::GlowDefuseKits);    
    }

    [[nodiscard]] auto deactivationFlag() const noexcept
    {
        return ModelGlowDeactivationFlags::DefuseKitModelGlowDeactivating;
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(model_glow_vars::DefuseKitHue);
    }

private:
    [[nodiscard]] auto& state() const
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/DroppedBombModelGlow/DroppedBombModelGlow.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowParams.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <HookContext/HookContextMacros.h>

std::uint64_t Weapon_sceneObjectUpdater(cs2::C_CSWeaponBase* weapon, void* unknown, bool unknownBool) noexcept;

template <typename HookContext>
class DroppedBombModelGlow {
public:
    explicit DroppedBombModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::GlowDroppedBomb);
    }

    [[nodiscard]] bool shouldApplyGlow(auto&& bomb) const
    {
        return !bomb.baseEntity().hasOwner().valueOr(true);
    }

    [[nodiscard]] auto deactivationFlag() const noexcept
    {
        return ModelGlowDeactivationFlags::DroppedBombModelGlowDeactivating;
    }

    [[nodiscard]] auto& originalSceneObjectUpdater() const
    {
        return state().originalWeaponSceneObjectUpdater;
    }

    [[nodiscard]] auto replacementSceneObjectUpdater() const
    {
        return &Weapon_sceneObjectUpdater;
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(model_glow_vars::DroppedBombHue);
    }

private:
    [[nodiscard]] auto& state() const
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/GrenadeProjectileModelGlow/GrenadeProjectileModelGlow.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/GrenadeProjectiles.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowParams.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
class GrenadeProjectileModelGlow {
public:
    explicit GrenadeProjectileModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::GlowGrenadeProjectiles);
    }

    [[nodiscard]] auto deactivationFlag() const noexcept
    {
        return ModelGlowDeactivationFlags::GrenadeProjectileModelGlowDeactivating;
    }

    [[nodiscard]] Optional<color::HueInteger> hue(EntityTypeInfo entityTypeInfo) const
    {
        switch (entityTypeInfo.typeIndex) {
        case EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>(): return GET_CONFIG_VAR(model_glow_vars::FlashbangHue);
        case EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>(): return GET_CONFIG_VAR(model_glow_vars::HEGrenadeHue);
        case EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>(): return GET_CONFIG_VAR(model_glow_vars::SmokeGrenadeHue);
        case EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>(): return GET_CONFIG_VAR(model_glow_vars::MolotovHue);
        default: return {};
        }
    }

private:
    [[nodiscard]] auto& state() const
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/ModelGlow.h`:

```h
#pragma once

#include <CS2/Classes/CPlantedC4.h>
#include <CS2/Classes/Entities/CBaseAnimGraph.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/WeaponEntities.h>
#include <GameClient/Entities/BaseWeapon.h>
#include <GameClient/Entities/C4.h>
#include <GameClient/Entities/PlantedC4.h>
#include <GameClient/Entities/PlayerPawn.h>
#include <GameClient/Entities/EntityClassifier.h>

#include "DefuseKitModelGlow/DefuseKitModelGlow.h"
#include "DroppedBombModelGlow/DroppedBombModelGlow.h"
#include "GrenadeProjectileModelGlow/GrenadeProjectileModelGlow.h"
#include "ModelGlowState.h"
#include "PlayerModelGlow/PlayerModelGlow.h"
#include "TickingBombModelGlow/TickingBombModelGlow.h"
#include "WeaponModelGlow/WeaponModelGlow.h"

template <typename HookContext>
class ModelGlow {
public:
    ModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] auto updateInMainThread() const noexcept
    {
        return [this](auto&& glow, auto&& entity, EntityTypeInfo entityTypeInfo) {
            if (isModelGlowDeactivated() || isModelGlowDeactivated(glow))
                return;

            if (modelGlowEnabled() && glow.enabled() && shouldApplyGlow(glow, entity))
                applyGlowInMainThread(glow, entityTypeInfo, entity);
            else
                removeGlowInMainThread(glow, entity);
        };
    }

    [[nodiscard]] auto updateInSceneObjectUpdater() const noexcept
    {
        return [this](auto&& glow, auto&& entity, EntityTypeInfo entityTypeInfo) {
            static_assert(isUsingSceneObjectUpdaterHook<decltype(glow)>());
            if (modelGlowEnabled() && glow.enabled() && shouldApplyGlow(glow, entity))
                entity.baseEntity().applySpawnProtectionEffectRecursively(getGlowHue(glow, entity, entityTypeInfo));
        };
    }

    [[nodiscard]] auto onUnload() const noexcept
    {
        return [this](auto&& glow, auto&& entity) {
            assert(!state().deactivationFlags.has(ModelGlowDeactivationFlags::ModelGlowDeactivating) && "Should be already deactivated");
            assert(!state().deactivationFlags.has(glow.deactivationFlag()) && "Should be already deactivated");

            if (modelGlowEnabled() && glow.enabled())
                removeGlowInMainThread(glow, entity);
        };
    }

    void postUpdateInMainThread() const
    {
        state().deactivationFlags.clear();
    }

private:
    [[nodiscard]] bool isModelGlowDeactivated() const
    {
        return !modelGlowEnabled() && !state().deactivationFlags.has(ModelGlowDeactivationFlags::ModelGlowDeactivating);
    }

    [[nodiscard]] bool isModelGlowDeactivated(auto&& glow) const
    {
        return !glow.enabled() && !state().deactivationFlags.has(glow.deactivationFlag());
    }

    [[nodiscard]] static bool shouldApplyGlow(auto&& glow, auto&& entity)
    {
        if constexpr (requires { { glow.shouldApplyGlow(entity) } -> std::same_as<bool>; })
            return glow.shouldApplyGlow(entity);
        else
            return true;
    }

    template <typename Glow>
    [[nodiscard]] static constexpr bool isUsingSceneObjectUpdaterHook() noexcept
    {
        return requires (Glow glow) {
            { glow.originalSceneObjectUpdater() };
            { glow.replacementSceneObjectUpdater() };
        };
    }

    void applyGlowInMainThread(auto&& glow, [[maybe_unused]] EntityTypeInfo entityTypeInfo, auto&& entity) const
    {
        if constexpr (isUsingSceneObjectUpdaterHook<decltype(glow)>())
            hookSceneObjectUpdater(entity, glow);
        else
            entity.baseEntity().applySpawnProtectionEffectRecursively(getGlowHue(glow, entity, entityTypeInfo));
    }

    void removeGlowInMainThread(auto&& glow, auto&& entity) const
    {
        if constexpr (isUsingSceneObjectUpdaterHook<decltype(glow)>())
            restoreSceneObjectUpdater(entity, glow);
        else
            entity.baseEntity().removeSpawnProtectionEffectRecursively();
    }

    template <typename Hue>
    [[nodiscard]] cs2::Color getColor(Optional<Hue> hue, color::Saturation saturation) const
    {
        if (hue.hasValue())
            return color::HSBtoRGB(hue.value(), saturation, color::Brightness{1.0f});
        return model_glow_params::kFallbackColor;
    }

    [[nodiscard]] cs2::Color getColor(auto hue, color::Saturation saturation) const
    {
        return color::HSBtoRGB(hue, saturation, color::Brightness{1.0f});
    }

    [[nodiscard]] color::Saturation getSaturation(auto&& glow, auto&& entity) const
    {
        if constexpr (requires { { glow.saturation(entity) } -> std::same_as<color::Saturation>; })
            return glow.saturation(entity);
        else
            return color::Saturation{1.0f};
    }

    [[nodiscard]] cs2::Color getGlowHue(auto&& glow, auto&& entity, [[maybe_unused]] EntityTypeInfo entityTypeInfo) const
    {
        if constexpr (requires { { glow.hue(entity) }; }) {
            return getColor(glow.hue(entity), getSaturation(glow, entity));
        } else if constexpr (requires { { glow.hue(entityTypeInfo) }; }) {
            return getColor(glow.hue(entityTypeInfo), getSaturation(glow, entity));
        } else {
            return getColor(glow.hue(), getSaturation(glow, entity));
        }
    }

    void hookSceneObjectUpdater(auto&& entity, auto&& glow) const
    {
        if (entity.getSceneObjectUpdater() != glow.replacementSceneObjectUpdater()) {
            storeOriginalSceneObjectUpdater(glow, entity);
            entity.setSceneObjectUpdater(glow.replacementSceneObjectUpdater());
        }
    }

    void restoreSceneObjectUpdater(auto&& entity, auto&& glow) const
    {
        if (entity.getSceneObjectUpdater() == glow.replacementSceneObjectUpdater())
            entity.setSceneObjectUpdater(glow.originalSceneObjectUpdater());
    }

    void storeOriginalSceneObjectUpdater(auto&& glow, auto&& entity) const
    {
        auto& originalSceneObjectUpdater = glow.originalSceneObjectUpdater();
        assert(originalSceneObjectUpdater == nullptr || entity.getSceneObjectUpdater() == nullptr || originalSceneObjectUpdater == entity.getSceneObjectUpdater());
        if (originalSceneObjectUpdater == nullptr)
            originalSceneObjectUpdater = entity.getSceneObjectUpdater();
    }

    [[nodiscard]] auto& state() const
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    [[nodiscard]] bool modelGlowEnabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::Enabled);
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/ModelGlowConfigVariables.h`:

```h
#pragma once

#include <cstdint>

#include <Config/ConfigVariable.h>
#include <Utils/ColorUtils.h>
#include <Utils/IdentityMacro.h>
#include <Utils/InRange.h>
#include "ModelGlowParams.h"

enum class PlayerModelGlowColorType : std::uint8_t {
    PlayerOrTeamColor,
    TeamColor,
    HealthBased,
    EnemyAlly
};

namespace model_glow_vars
{

CONFIG_VARIABLE(Enabled, bool, false);
CONFIG_VARIABLE(GlowPlayers, bool, true);
CONFIG_VARIABLE(PlayerGlowColorMode, PlayerModelGlowColorType, PlayerModelGlowColorType::PlayerOrTeamColor);
CONFIG_VARIABLE(GlowOnlyEnemies, bool, true);
CONFIG_VARIABLE(GlowWeapons, bool, true);
CONFIG_VARIABLE(GlowDroppedBomb, bool, true);
CONFIG_VARIABLE(GlowTickingBomb, bool, true);
CONFIG_VARIABLE(GlowDefuseKits, bool, true);
CONFIG_VARIABLE(GlowGrenadeProjectiles, bool, true);

CONFIG_VARIABLE_HUE(PlayerBlueHue, model_glow_params::kPlayerBlueHue);
CONFIG_VARIABLE_HUE(PlayerGreenHue, model_glow_params::kPlayerGreenHue);
CONFIG_VARIABLE_HUE(PlayerYellowHue, model_glow_params::kPlayerYellowHue);
CONFIG_VARIABLE_HUE(PlayerOrangeHue, model_glow_params::kPlayerOrangeHue);
CONFIG_VARIABLE_HUE(PlayerPurpleHue, model_glow_params::kPlayerPurpleHue);

CONFIG_VARIABLE_HUE(TeamTHue, model_glow_params::kTeamTHue);
CONFIG_VARIABLE_HUE(TeamCTHue, model_glow_params::kTeamCTHue);

CONFIG_VARIABLE_HUE(LowHealthHue, model_glow_params::kLowHealthHue);
CONFIG_VARIABLE_HUE(HighHealthHue, model_glow_params::kHighHealthHue);

CONFIG_VARIABLE_HUE(AllyHue, model_glow_params::kAllyHue);
CONFIG_VARIABLE_HUE(EnemyHue, model_glow_params::kEnemyHue);

CONFIG_VARIABLE_HUE(MolotovHue, model_glow_params::kMolotovHue);
CONFIG_VARIABLE_HUE(FlashbangHue, model_glow_params::kFlashbangHue);
CONFIG_VARIABLE_HUE(HEGrenadeHue, model_glow_params::kHEGrenadeHue);
CONFIG_VARIABLE_HUE(SmokeGrenadeHue, model_glow_params::kSmokeGrenadeHue);

CONFIG_VARIABLE_HUE(DroppedBombHue, model_glow_params::kDroppedBombHue);
CONFIG_VARIABLE_HUE(TickingBombHue, model_glow_params::kTickingBombHue);
CONFIG_VARIABLE_HUE(DefuseKitHue, model_glow_params::kDefuseKitHue);

}

```

`Source/Features/Visuals/ModelGlow/ModelGlowDeactivationFlags.h`:

```h
#pragma once

enum class ModelGlowDeactivationFlags {
    ModelGlowDeactivating = 1 << 0,
    PlayerModelGlowDeactivating = 1 << 1,
    WeaponModelGlowDeactivating = 1 << 2,
    DroppedBombModelGlowDeactivating = 1 << 3,
    TickingBombModelGlowDeactivating = 1 << 4,
    DefuseKitModelGlowDeactivating = 1 << 5,
    GrenadeProjectileModelGlowDeactivating = 1 << 6
};

```

`Source/Features/Visuals/ModelGlow/ModelGlowParams.h`:

```h
#pragma once

#include <Config/RangeConstrainedVariableParams.h>
#include <CS2/Classes/Color.h>
#include <CS2/Constants/ColorConstants.h>
#include <Utils/ColorUtils.h>

namespace model_glow_params
{
    constexpr cs2::Color kFallbackColor{cs2::kColorWhite};

    constexpr HueVariableParams kPlayerBlueHue{.min = 191, .max = 240, .def = 215};
    constexpr HueVariableParams kPlayerGreenHue{.min = 110, .max = 140, .def = 125};
    constexpr HueVariableParams kPlayerYellowHue{.min = 47, .max = 60, .def = 53};
    constexpr HueVariableParams kPlayerOrangeHue{.min = 11, .max = 20, .def = 15};
    constexpr HueVariableParams kPlayerPurpleHue{.min = 250, .max = 280, .def = 265};

    constexpr HueVariableParams kTeamTHue{.min = 30, .max = 40, .def = 35};
    constexpr HueVariableParams kTeamCTHue{.min = 210, .max = 230, .def = 220};

    constexpr HueVariableParams kLowHealthHue{.min = 0, .max = 359, .def = 0};
    constexpr HueVariableParams kHighHealthHue{.min = 0, .max = 359, .def = 120};

    constexpr HueVariableParams kAllyHue{.min = 0, .max = 359, .def = 120};
    constexpr HueVariableParams kEnemyHue{.min = 0, .max = 359, .def = 0};

    constexpr HueVariableParams kMolotovHue{.min = 20, .max = 60, .def = 40};
    constexpr HueVariableParams kFlashbangHue{.min = 191, .max = 250, .def = 219};
    constexpr HueVariableParams kHEGrenadeHue{.min = 300, .max = 359, .def = 359};
    constexpr HueVariableParams kSmokeGrenadeHue{.min = 110, .max = 140, .def = 120};

    constexpr HueVariableParams kDroppedBombHue{.min = 0, .max = 359, .def = 60};
    constexpr HueVariableParams kTickingBombHue{.min = 0, .max = 359, .def = 0};
    constexpr HueVariableParams kDefuseKitHue{.min = 0, .max = 359, .def = 184};

    constexpr color::Saturation kNormalPlayerColorSaturation{1.0f};
    constexpr color::Saturation kImmunePlayerColorSaturation{0.5f};
}

```

`Source/Features/Visuals/ModelGlow/ModelGlowState.h`:

```h
#pragma once

#include <cstdint>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <Utils/EnumFlags.h>
#include "ModelGlowDeactivationFlags.h"

struct ModelGlowState {
    EnumFlags<ModelGlowDeactivationFlags> deactivationFlags{};

    std::uint64_t(*originalPlayerPawnSceneObjectUpdater)(cs2::C_CSPlayerPawn* playerPawn, void*, bool){nullptr};
    std::uint64_t(*originalWeaponSceneObjectUpdater)(cs2::C_CSWeaponBase* baseWeapon, void*, bool){nullptr};
};

```

`Source/Features/Visuals/ModelGlow/PlayerModelGlow/PlayerModelGlow.h`:

```h
#pragma once

#include <algorithm>
#include <cstdint>
#include <optional>
#include <span>
#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <CS2/Constants/ColorConstants.h>
#include <GameClient/Entities/TeamNumber.h>
#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>
#include <Utils/Optional.h>

std::uint64_t PlayerPawn_sceneObjectUpdater(cs2::C_CSPlayerPawn* playerPawn, void* unknown, bool unknownBool) noexcept;

template <typename HookContext>
class PlayerModelGlow {
public:
    explicit PlayerModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::GlowPlayers);
    }

    [[nodiscard]] bool shouldApplyGlow(auto&& playerPawn) const
    {
        return playerPawn.isAlive().value_or(true)
            && playerPawn.health().greaterThan(0).valueOr(true)
            && !playerPawn.isControlledByLocalPlayer()
            && playerPawn.isTTorCT()
            && (!GET_CONFIG_VAR(model_glow_vars::GlowOnlyEnemies) || playerPawn.isEnemy().value_or(true));
    }

    [[nodiscard]] auto deactivationFlag() const noexcept
    {
        return ModelGlowDeactivationFlags::PlayerModelGlowDeactivating;
    }

    [[nodiscard]] auto& originalSceneObjectUpdater() const
    {
        return state().originalPlayerPawnSceneObjectUpdater;
    }

    [[nodiscard]] auto replacementSceneObjectUpdater() const
    {
        return &PlayerPawn_sceneObjectUpdater;
    }

    [[nodiscard]] Optional<color::Hue> hue(auto&& playerPawn) const
    {
        switch (GET_CONFIG_VAR(model_glow_vars::PlayerGlowColorMode)) {
        using enum PlayerModelGlowColorType;
        case EnemyAlly: return enemyAllyColorModeHue(playerPawn);
        case HealthBased: return healthBasedColorModeHue(playerPawn);
        case PlayerOrTeamColor:
            if (const auto playerColor = getPlayerColorHue(playerPawn.playerController().playerColorIndex()); playerColor.hasValue())
                return playerColor.value().toHueFloat();
            [[fallthrough]];
        case TeamColor: return teamColorModeHue(playerPawn);
        default: return {};
        }
    }

    [[nodiscard]] color::Saturation saturation(auto&& playerPawn) const
    {
        return playerPawn.hasImmunity().valueOr(false)
            ? model_glow_params::kImmunePlayerColorSaturation
            : model_glow_params::kNormalPlayerColorSaturation;
    }

private:
    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    [[nodiscard]] Optional<color::Hue> teamColorModeHue(auto&& playerPawn) const noexcept
    {
        switch (playerPawn.teamNumber()) {
        case TeamNumber::TT: return static_cast<color::HueInteger>(GET_CONFIG_VAR(model_glow_vars::TeamTHue)).toHueFloat();
        case TeamNumber::CT: return static_cast<color::HueInteger>(GET_CONFIG_VAR(model_glow_vars::TeamCTHue)).toHueFloat();
        default: return {};
        }
    }

    [[nodiscard]] Optional<color::Hue> enemyAllyColorModeHue(auto&& playerPawn) const noexcept
    {
        if (const auto isEnemy = playerPawn.isEnemy(); isEnemy.has_value())
            return (*isEnemy ? static_cast<color::HueInteger>(GET_CONFIG_VAR(model_glow_vars::EnemyHue)) : static_cast<color::HueInteger>(GET_CONFIG_VAR(model_glow_vars::AllyHue))).toHueFloat();
        return {};
    }

    [[nodiscard]] Optional<color::Hue> healthBasedColorModeHue(auto&& playerPawn) const noexcept
    {
        if (const auto healthValue = playerPawn.health(); healthValue.hasValue()) {
            const auto fraction = healthFraction(healthValue.value());

            const color::HueInteger lowHealthHue{GET_CONFIG_VAR(model_glow_vars::LowHealthHue)};
            const color::HueInteger highHealthHue{GET_CONFIG_VAR(model_glow_vars::HighHealthHue)};
            if (lowHealthHue < highHealthHue)
                return color::Hue{(lowHealthHue + (highHealthHue - lowHealthHue) * fraction) / 360.0f};
            else
                return color::Hue{(lowHealthHue - (lowHealthHue - highHealthHue) * fraction) / 360.0f};
        }
        return {};
    }

    [[nodiscard]] static constexpr float healthFraction(int playerHealth) noexcept
    {
        constexpr auto kMinHealth = 1;
        constexpr auto kMaxHealth = 100;

        if (playerHealth <= kMinHealth)
            return 0.0f;
        if (playerHealth >= kMaxHealth)
            return 1.0f;
        return static_cast<float>(playerHealth - kMinHealth) / (kMaxHealth - kMinHealth); 
    }

    [[nodiscard]] Optional<color::HueInteger> getPlayerColorHue(auto playerColorIndex) const noexcept
    {
        if (!playerColorIndex.hasValue())
            return {};

        switch (playerColorIndex.value()) {
        using enum cs2::PlayerColorIndex;
        case Blue: return GET_CONFIG_VAR(model_glow_vars::PlayerBlueHue);
        case Green: return GET_CONFIG_VAR(model_glow_vars::PlayerGreenHue);
        case Yellow: return GET_CONFIG_VAR(model_glow_vars::PlayerYellowHue);
        case Orange: return GET_CONFIG_VAR(model_glow_vars::PlayerOrangeHue);
        case Purple: return GET_CONFIG_VAR(model_glow_vars::PlayerPurpleHue);
        default: return {};
        }
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/Preview/BaseEntityForModelGlowPreview.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <GameClient/Entities/BaseEntity.h>

template <typename HookContext>
class BaseEntityForModelGlowPreview {
public:
    BaseEntityForModelGlowPreview(HookContext& hookContext, cs2::C_BaseEntity* baseEntity) noexcept
        : hookContext{hookContext}
        , baseEntity{baseEntity}
    {
    }

    template <typename... Args>
    void applySpawnProtectionEffectRecursively(Args&&... args) const noexcept
    {
        hookContext.template make<BaseEntity>(baseEntity).applySpawnProtectionEffectRecursively(std::forward<Args>(args)...);
    }

private:
    HookContext& hookContext;
    cs2::C_BaseEntity* baseEntity;
};

```

`Source/Features/Visuals/ModelGlow/Preview/EnemyTeam.h`:

```h
#pragma once

enum class EnemyTeam {
    None,
    Both,
    CT,
    T
};

```

`Source/Features/Visuals/ModelGlow/Preview/PlayerControllerForModelGlowPreview.h`:

```h
#pragma once

#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <Utils/Optional.h>

template <typename HookContext>
class PlayerControllerForModelGlowPreview {
public:
    explicit PlayerControllerForModelGlowPreview(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] Optional<cs2::CCSPlayerController::m_iCompTeammateColor> playerColorIndex() const noexcept
    {
        return hookContext.playerModelGlowPreviewState().previewPlayerColorIndex;
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreview.h`:

```h
#pragma once

#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <GameClient/Entities/TeamNumber.h>
#include <Features/Visuals/ModelGlow/ModelGlow.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <Features/Visuals/ModelGlow/PlayerModelGlow/PlayerModelGlow.h>
#include <Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreviewColorMode.h>
#include <GameClient/EntitySystem/EntitySystem.h>

#include "EnemyTeam.h"
#include "PlayerPawnForModelGlowPreview.h"
#include "PlayerModelGlowPreviewParams.h"

template <typename HookContext>
class PlayerModelGlowPreview {
public:
    explicit PlayerModelGlowPreview(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void setPreviewPlayerTT(auto&& previewPlayer) const noexcept
    {
        state().previewPlayerHandleTT = previewPlayer.baseEntity().handle();
    }

    [[nodiscard]] bool isPreviewPlayerSetTT() const noexcept
    {
        return static_cast<bool>(hookContext.template make<EntitySystem>().getEntityFromHandle(state().previewPlayerHandleTT));
    }

    void setPreviewPlayerCT(auto&& previewPlayer) const noexcept
    {
        state().previewPlayerHandleCT = previewPlayer.baseEntity().handle();
    }

    [[nodiscard]] bool isPreviewPlayerSetCT() const noexcept
    {
        return static_cast<bool>(hookContext.template make<EntitySystem>().getEntityFromHandle(state().previewPlayerHandleCT));
    }

    void update() const noexcept
    {
        updateAnimationProgress();

        const auto previewPlayerHealth = computePreviewPlayerHealth();
        const auto previewPlayerColorIndex = computePreviewPlayerColorIndex();
        const auto colorMode = computeColorMode();
        const auto enemyTeam = computeEnemyTeam();

        state().shouldUpdatePanel = shouldUpdatePreviewPanel(colorMode, previewPlayerColorIndex, previewPlayerHealth, enemyTeam);
        state().previewPlayerHealth = previewPlayerHealth;
        state().colorMode = colorMode;
        state().previewPlayerColorIndex = previewPlayerColorIndex;
        state().enemyTeam = enemyTeam;
    }

    void hookPreviewPlayersSceneObjectUpdaters() const noexcept
    {
        hookContext.template make<ModelGlow>().updateInMainThread()(PlayerModelGlow{hookContext}, previewPlayerTT(), EntityTypeInfo{});
        hookContext.template make<ModelGlow>().updateInMainThread()(PlayerModelGlow{hookContext}, previewPlayerCT(), EntityTypeInfo{});
    }

    void onUnload() const noexcept
    {
        hookContext.template make<ModelGlow>().onUnload()(PlayerModelGlow{hookContext}, previewPlayerTT());
        hookContext.template make<ModelGlow>().onUnload()(PlayerModelGlow{hookContext}, previewPlayerCT());
    }

    void applyPreviewPlayerModelGlow(auto&& previewPlayer) const noexcept
    {
        hookContext.template make<ModelGlow>().updateInSceneObjectUpdater()(PlayerModelGlow{hookContext}, hookContext.template make<PlayerPawnForModelGlowPreview>(previewPlayer, previewPlayerTeamNumber(previewPlayer)), EntityTypeInfo{});
    }

private:
    [[nodiscard]] bool previewActive() const noexcept
    {
        return GET_CONFIG_VAR(model_glow_vars::Enabled) && GET_CONFIG_VAR(model_glow_vars::GlowPlayers);
    }

    void updateAnimationProgress() const noexcept
    {
        if (!previewActive()) {
            state().animationProgress = 0.0f;
            return;
        }

        constexpr auto kDefaultFrameTime{1 / 60.0f};
        const auto frameTime = hookContext.globalVars().frametime().valueOr(kDefaultFrameTime);

        using namespace player_model_glow_preview_params;
        if (frameTime < kAnimationCycleDuration - state().animationProgress)
            state().animationProgress += frameTime;
        else
            state().animationProgress = 0.0f;
    }

    [[nodiscard]] auto computeEnemyTeam() const noexcept
    {
        if (GET_CONFIG_VAR(model_glow_vars::GlowPlayers) && GET_CONFIG_VAR(model_glow_vars::GlowOnlyEnemies))
            return EnemyTeam::Both;

        if (GET_CONFIG_VAR(model_glow_vars::PlayerGlowColorMode) == PlayerModelGlowColorType::EnemyAlly)
            return enemyTeamAnimationStep() == 0 ? EnemyTeam::T : EnemyTeam::CT;

        return EnemyTeam::None;
    }

    [[nodiscard]] int enemyTeamAnimationStep() const noexcept
    {
        using namespace player_model_glow_preview_params::team_animation_params;
        return static_cast<int>(state().animationProgress / kStepDuration) % kSteps;
    }

    [[nodiscard]] auto computePreviewPlayerHealth() const noexcept
    {
        return healthAnimationStepToHealthValue(healthAnimationStep());
    }

    [[nodiscard]] auto computePreviewPlayerColorIndex() const noexcept
    {
        const auto step = colorIndexAnimationStep();
        return isPlayerColorStep(step) ? playerColorIndexFromStep(step) : cs2::PlayerColorIndex{-1};
    }

    [[nodiscard]] auto computeColorMode() const noexcept
    {
        if (!previewActive())
            return PlayerModelGlowPreviewColorMode::None;

        switch (GET_CONFIG_VAR(model_glow_vars::PlayerGlowColorMode)) {
        case PlayerModelGlowColorType::HealthBased: return PlayerModelGlowPreviewColorMode::HealthBased;
        case PlayerModelGlowColorType::PlayerOrTeamColor: return PlayerModelGlowPreviewColorMode::PlayerOrTeamColor;
        case PlayerModelGlowColorType::TeamColor: return PlayerModelGlowPreviewColorMode::TeamColor;
        case PlayerModelGlowColorType::EnemyAlly: return PlayerModelGlowPreviewColorMode::EnemyAlly;
        default: return PlayerModelGlowPreviewColorMode::None;
        }
    }

    [[nodiscard]] bool shouldUpdatePreviewPanel(auto colorMode, auto previewPlayerColorIndex, auto previewPlayerHealth, auto enemyTeam) const noexcept
    {
        if (colorMode != state().colorMode)
            return true;
        if (enemyTeam != state().enemyTeam)
            return true;

        switch (colorMode) {
        case PlayerModelGlowPreviewColorMode::TeamColor:
        case PlayerModelGlowPreviewColorMode::PlayerOrTeamColor:
            return previewPlayerColorIndex != state().previewPlayerColorIndex;
        case PlayerModelGlowPreviewColorMode::HealthBased:
            return previewPlayerHealth != state().previewPlayerHealth;
        default:
            return true;
        }
    }

    [[nodiscard]] auto& modelGlowState() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    [[nodiscard]] int colorIndexAnimationStep() const noexcept
    {
        using namespace player_model_glow_preview_params::player_color_animation_params;
        return static_cast<int>(state().animationProgress / kStepDuration) % kSteps;
    }

    [[nodiscard]] static bool isPlayerColorStep(int step) noexcept
    {
        using namespace player_model_glow_preview_params::player_color_animation_params;
        return step >= kTeamColorSteps;
    }

    [[nodiscard]] static cs2::PlayerColorIndex playerColorIndexFromStep(int step) noexcept
    {
        using namespace player_model_glow_preview_params::player_color_animation_params;
        return cs2::PlayerColorIndex{step - kTeamColorSteps};
    }

    [[nodiscard]] int healthAnimationStepToHealthValue(int step) const noexcept
    {
        using namespace player_model_glow_preview_params::player_health_animation_params;
        if (step > kMaxPlayerHealth)
            return (step - kMaxPlayerHealth) + kMinPlayerHealth;
        else
            return (kMaxPlayerHealth - step) + kMinPlayerHealth;
    }

    [[nodiscard]] int healthAnimationStep() const noexcept
    {
        using namespace player_model_glow_preview_params::player_health_animation_params;
        return static_cast<int>(state().animationProgress / kStepDuration) % kSteps;
    }

    [[nodiscard]] decltype(auto) previewPlayerTT() const noexcept
    {
        return hookContext.template make<EntitySystem>().getEntityIdentityFromHandle(state().previewPlayerHandleTT).entity().template as<PlayerPawnForModelGlowPreview>(TeamNumber::TT);
    }

    [[nodiscard]] decltype(auto) previewPlayerCT() const noexcept
    {
        return hookContext.template make<EntitySystem>().getEntityIdentityFromHandle(state().previewPlayerHandleCT).entity().template as<PlayerPawnForModelGlowPreview>(TeamNumber::CT);
    }

    [[nodiscard]] auto previewPlayerTeamNumber(auto&& previewPlayer) const noexcept
    {
        return previewPlayer.baseEntity().handle() == state().previewPlayerHandleTT ? TeamNumber::TT : TeamNumber::CT;
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.playerModelGlowPreviewState();
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreviewColorMode.h`:

```h
#pragma once

enum class PlayerModelGlowPreviewColorMode {
    None,
    HealthBased,
    PlayerOrTeamColor,
    TeamColor,
    EnemyAlly
};

```

`Source/Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreviewParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>

namespace player_model_glow_preview_params::player_color_animation_params
{
    constexpr auto kCycleDuration{15.0f};
    constexpr auto kTeamColorSteps{1};
    constexpr auto kPlayerColorSteps{cs2::kPlayerColorIndexCount};
    constexpr auto kSteps{kTeamColorSteps + kPlayerColorSteps};
    constexpr auto kStepDuration{kCycleDuration / kSteps};
}

namespace player_model_glow_preview_params::player_health_animation_params
{
    constexpr auto kMinPlayerHealth{1};
    constexpr auto kMaxPlayerHealth{100};
    constexpr auto kCycleDuration{10.0f};
    constexpr auto kSteps{2 * (kMaxPlayerHealth - kMinPlayerHealth + 1)};
    constexpr auto kStepDuration{kCycleDuration / kSteps};
}

namespace player_model_glow_preview_params::team_animation_params
{
    constexpr auto kCycleDuration{10.0f};
    constexpr auto kSteps{2};
    constexpr auto kStepDuration{kCycleDuration / kSteps};
}

namespace player_model_glow_preview_params
{
    constexpr auto kAnimationCycleDuration{player_color_animation_params::kCycleDuration * player_health_animation_params::kCycleDuration * team_animation_params::kCycleDuration};
}

```

`Source/Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreviewState.h`:

```h
#pragma once

#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Constants/EntityHandle.h>
#include "PlayerModelGlowPreviewColorMode.h"

struct PlayerModelGlowPreviewState {
    cs2::CEntityHandle previewPlayerHandleTT{cs2::INVALID_EHANDLE_INDEX};
    cs2::CEntityHandle previewPlayerHandleCT{cs2::INVALID_EHANDLE_INDEX};
    float animationProgress{0.0f};
    int previewPlayerHealth{-1};
    PlayerModelGlowPreviewColorMode colorMode{};
    cs2::CCSPlayerController::m_iCompTeammateColor previewPlayerColorIndex{};
    bool shouldUpdatePanel{true};
    EnemyTeam enemyTeam{EnemyTeam::None};
};

```

`Source/Features/Visuals/ModelGlow/Preview/PlayerPawnForModelGlowPreview.h`:

```h
#pragma once

#include <optional>
#include <utility>

#include <CS2/Classes/Entities/C_CSGO_PreviewPlayer.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <GameClient/Entities/PlayerPawn.h>
#include <GameClient/Entities/TeamNumber.h>
#include <Utils/Optional.h>

#include "BaseEntityForModelGlowPreview.h"
#include "PlayerControllerForModelGlowPreview.h"

template <typename HookContext>
class PlayerPawnForModelGlowPreview {
public:
    using RawType = cs2::C_CSGO_PreviewPlayer;

    PlayerPawnForModelGlowPreview(HookContext& hookContext, cs2::C_CSPlayerPawn* playerPawnPointer, TeamNumber playerTeamNumber) noexcept
        : hookContext{hookContext}
        , playerPawnPointer{playerPawnPointer}
        , playerTeamNumber{playerTeamNumber}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntityForModelGlowPreview>(playerPawnPointer);
    }

    [[nodiscard]] decltype(auto) playerController() const noexcept
    {
        return hookContext.template make<PlayerControllerForModelGlowPreview>();
    }

    [[nodiscard]] TeamNumber teamNumber() const noexcept
    {
        return playerTeamNumber;
    }

    [[nodiscard]] std::optional<bool> isAlive() const noexcept
    {
        return true;
    }

    [[nodiscard]] Optional<bool> hasImmunity() const noexcept
    {
        return false;
    }

    [[nodiscard]] Optional<int> health() const noexcept
    {
        return hookContext.playerModelGlowPreviewState().previewPlayerHealth;
    }

    [[nodiscard]] bool isControlledByLocalPlayer() const noexcept
    {
        return false;
    }

    [[nodiscard]] bool isTTorCT() const noexcept
    {
        return true;
    }

    [[nodiscard]] std::optional<bool> isEnemy() const noexcept
    {
        switch (hookContext.playerModelGlowPreviewState().enemyTeam) {
        case EnemyTeam::CT: return playerTeamNumber == TeamNumber::CT;
        case EnemyTeam::T: return playerTeamNumber == TeamNumber::TT;
        case EnemyTeam::None: return false;
        default: return true;
        }
    }

    template <typename... Args>
    void setSceneObjectUpdater(Args&&... args) const noexcept
    {
        playerPawn().setSceneObjectUpdater(std::forward<Args>(args)...);
    }

    [[nodiscard]] decltype(auto) getSceneObjectUpdater() const noexcept
    {
        return playerPawn().getSceneObjectUpdater();
    }

private:
    [[nodiscard]] decltype(auto) playerPawn() const noexcept
    {
        return hookContext.template make<PlayerPawn>(playerPawnPointer);
    }

    HookContext& hookContext;
    cs2::C_CSPlayerPawn* playerPawnPointer;
    TeamNumber playerTeamNumber;
};

```

`Source/Features/Visuals/ModelGlow/Preview/WeaponModelGlowPreview.h`:

```h
#pragma once

#include <GameClient/EntitySystem/EntityHandle.h>
#include <GameClient/Panorama/UiItem3dPanel.h>
#include <Platform/Macros/FunctionAttributes.h>
#include <GameClient/Econ/FauxItemId.h>

template <typename HookContext>
class WeaponModelGlowPreview {
public:
    explicit WeaponModelGlowPreview(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void updateSceneObjectUpdaterHooks() const noexcept
    {
        hookContext.template make<ModelGlow>().updateInMainThread()(WeaponModelGlow{hookContext}, previewWeapon(), EntityTypeInfo{});
        hookContext.template make<ModelGlow>().updateInMainThread()(WeaponModelGlow{hookContext}, previewFlashbang(), EntityTypeInfo{});
        hookContext.template make<ModelGlow>().updateInMainThread()(WeaponModelGlow{hookContext}, previewSmokeGrenade(), EntityTypeInfo{});
        hookContext.template make<ModelGlow>().updateInMainThread()(WeaponModelGlow{hookContext}, previewHEGrenade(), EntityTypeInfo{});
        hookContext.template make<ModelGlow>().updateInMainThread()(WeaponModelGlow{hookContext}, previewIncendiary(), EntityTypeInfo{});
    }

    void onUnload() const noexcept
    {
        hookContext.template make<ModelGlow>().onUnload()(WeaponModelGlow{hookContext}, previewWeapon());
        hookContext.template make<ModelGlow>().onUnload()(WeaponModelGlow{hookContext}, previewFlashbang());
        hookContext.template make<ModelGlow>().onUnload()(WeaponModelGlow{hookContext}, previewSmokeGrenade());
        hookContext.template make<ModelGlow>().onUnload()(WeaponModelGlow{hookContext}, previewHEGrenade());
        hookContext.template make<ModelGlow>().onUnload()(WeaponModelGlow{hookContext}, previewIncendiary());
    }

private:
    [[nodiscard]] [[NOINLINE]] decltype(auto) previewWeapon(cs2::CEntityHandle& handle, bool& hadHandle, const char* panelId, cs2::ItemId itemId) const noexcept
    {
        auto&& entityIdentity = hookContext.template make<EntityHandle>(handle).getOrInit(
            [&hadHandle] { hadHandle = true; },
            [this, &hadHandle, panelId, itemId] {
                auto&& previewPanel = hookContext.gui().modelGlowPreviewPanel(panelId);
                auto&& portraitWorld = previewPanel.portraitWorld();
                if (hadHandle && portraitWorld.isMapLoaded()) {
                    previewPanel.template as<UiItem3dPanel>().createItem(itemId);
                    hadHandle = false;
                }
                return portraitWorld.findPreviewWeapon().baseEntity().handle();
            });
        return entityIdentity.template as<BaseWeapon>();
    }

    [[nodiscard]] decltype(auto) previewWeapon() const noexcept
    {
        return previewWeapon(state().previewWeaponHandle, state().hadPreviewWeaponHandle, "ModelGlowPreviewWeapon", FauxItemId{cs2::ItemDefinitionIndex::M4A4, cs2::PaintKitIndex::AsiimovM4A4});
    }

    [[nodiscard]] decltype(auto) previewFlashbang() const noexcept
    {
        return previewWeapon(state().previewFlashbangHandle, state().hadPreviewFlashbangHandle, "ModelGlowPreviewFlashbang", FauxItemId{cs2::ItemDefinitionIndex::Flashbang});
    }

    [[nodiscard]] decltype(auto) previewHEGrenade() const noexcept
    {
        return previewWeapon(state().previewHEGrenadeHandle, state().hadPreviewHEGrenadeHandle, "ModelGlowPreviewHEGrenade", FauxItemId{cs2::ItemDefinitionIndex::HEGrenade});
    }

    [[nodiscard]] decltype(auto) previewSmokeGrenade() const noexcept
    {
        return previewWeapon(state().previewSmokeGrenadeHandle, state().hadPreviewSmokeGrenadeHandle, "ModelGlowPreviewSmoke", FauxItemId{cs2::ItemDefinitionIndex::SmokeGrenade});
    }

    [[nodiscard]] decltype(auto) previewIncendiary() const noexcept
    {
        return previewWeapon(state().previewIncendiaryHandle, state().hadPreviewIncendiaryHandle, "ModelGlowPreviewIncendiary", FauxItemId{cs2::ItemDefinitionIndex::Incendiary});
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.weaponModelGlowPreviewState();
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/Preview/WeaponModelGlowPreviewState.h`:

```h
#pragma once

#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Constants/EntityHandle.h>

struct WeaponModelGlowPreviewState {
    cs2::CEntityHandle previewWeaponHandle{cs2::INVALID_EHANDLE_INDEX};
    cs2::CEntityHandle previewFlashbangHandle{cs2::INVALID_EHANDLE_INDEX};
    cs2::CEntityHandle previewHEGrenadeHandle{cs2::INVALID_EHANDLE_INDEX};
    cs2::CEntityHandle previewSmokeGrenadeHandle{cs2::INVALID_EHANDLE_INDEX};
    cs2::CEntityHandle previewIncendiaryHandle{cs2::INVALID_EHANDLE_INDEX};
    bool hadPreviewWeaponHandle{false};
    bool hadPreviewFlashbangHandle{false};
    bool hadPreviewHEGrenadeHandle{false};
    bool hadPreviewSmokeGrenadeHandle{false};
    bool hadPreviewIncendiaryHandle{false};
};

```

`Source/Features/Visuals/ModelGlow/TickingBombModelGlow/TickingBombModelGlow.h`:

```h
#pragma once

#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowParams.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
class TickingBombModelGlow {
public:
    explicit TickingBombModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::GlowTickingBomb);
    }

    [[nodiscard]] bool shouldApplyGlow(auto&& plantedBomb) const
    {
        return plantedBomb.isTicking().valueOr(true);
    }

    [[nodiscard]] auto deactivationFlag() const noexcept
    {
        return ModelGlowDeactivationFlags::TickingBombModelGlowDeactivating;
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(model_glow_vars::TickingBombHue);
    }

private:
    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/ModelGlow/WeaponModelGlow/WeaponModelGlow.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <CS2/Classes/Entities/WeaponEntities.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <Features/Visuals/ModelGlow/ModelGlowParams.h>
#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <HookContext/HookContextMacros.h>
#include <Platform/Macros/FunctionAttributes.h>

std::uint64_t Weapon_sceneObjectUpdater(cs2::C_CSWeaponBase* weapon, void* unknown, bool unknownBool) noexcept;

template <typename HookContext>
class WeaponModelGlow {
public:
    explicit WeaponModelGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(model_glow_vars::GlowWeapons);
    }

    [[nodiscard]] bool shouldApplyGlow(auto&& weapon) const
    {
        return !weapon.baseEntity().hasOwner().valueOr(true);
    }

    [[nodiscard]] auto deactivationFlag() const noexcept
    {
        return ModelGlowDeactivationFlags::WeaponModelGlowDeactivating;
    }

    [[nodiscard]] auto& originalSceneObjectUpdater() const
    {
        return state().originalWeaponSceneObjectUpdater;
    }

    [[nodiscard]] auto replacementSceneObjectUpdater() const
    {
        return &Weapon_sceneObjectUpdater;
    }

    [[nodiscard]] Optional<color::HueInteger> hue(EntityTypeInfo entityTypeInfo) const
    {
        switch (entityTypeInfo.typeIndex) {
        case EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>():
        case EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>(): return GET_CONFIG_VAR(model_glow_vars::MolotovHue);
        case EntityTypeInfo::indexOf<cs2::C_Flashbang>(): return GET_CONFIG_VAR(model_glow_vars::FlashbangHue);
        case EntityTypeInfo::indexOf<cs2::C_HEGrenade>(): return GET_CONFIG_VAR(model_glow_vars::HEGrenadeHue);
        case EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>(): return GET_CONFIG_VAR(model_glow_vars::SmokeGrenadeHue);
        default: return {};
        }
    }

private:
    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.modelGlowState;
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/DefuseKitOutlineGlow/DefuseKitOutlineGlow.h`:

```h
#pragma once

#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowParams.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>

template <typename HookContext>
class DefuseKitOutlineGlow {
public:
    explicit DefuseKitOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowDefuseKits);
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::DefuseKitHue);
    }

    [[nodiscard]] int getGlowRange() const noexcept
    {
        return outline_glow_params::kDefuseKitGlowRange;
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/DroppedBombOutlineGlow/DroppedBombOutlineGlow.h`:

```h
#pragma once

#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowParams.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>

template <typename HookContext>
class DroppedBombOutlineGlow {
public:
    explicit DroppedBombOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowDroppedBomb);
    }

    [[nodiscard]] bool shouldApplyGlow(EntityTypeInfo /* entityTypeInfo */, auto&& bomb) const
    {
        return !bomb.hasOwner().valueOr(true);
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::DroppedBombHue);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/GrenadeProjectileOutlineGlow/GrenadeProjectileOutlineGlow.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/GrenadeProjectiles.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowParams.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <GameClient/Entities/SmokeGrenadeProjectile.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/Optional.h>

template <typename HookContext>
class GrenadeProjectileOutlineGlow {
public:
    explicit GrenadeProjectileOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const noexcept
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowGrenadeProjectiles);
    }

    [[nodiscard]] bool shouldApplyGlow(EntityTypeInfo entityTypeInfo, auto&& grenadeProjectile) const noexcept
    {
        return !entityTypeInfo.is<cs2::C_SmokeGrenadeProjectile>() || !grenadeProjectile.template as<SmokeGrenadeProjectile>().didSmokeEffect().valueOr(false);
    }

    [[nodiscard]] Optional<color::HueInteger> hue(EntityTypeInfo entityTypeInfo, auto&& /* grenadeProjectile */) const noexcept
    {
        switch (entityTypeInfo.typeIndex) {
        case EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>(): return GET_CONFIG_VAR(outline_glow_vars::FlashbangHue);
        case EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>(): return GET_CONFIG_VAR(outline_glow_vars::HEGrenadeHue);
        case EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>(): return GET_CONFIG_VAR(outline_glow_vars::MolotovHue);
        case EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>(): return GET_CONFIG_VAR(outline_glow_vars::SmokeGrenadeHue);
        default: return {};
        }
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/HostageOutlineGlow/HostageOutlineGlow.h`:

```h
#pragma once

#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowParams.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>

template <typename HookContext>
class HostageOutlineGlow {
public:
    explicit HostageOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowHostages);
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::HostageHue);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/OutlineGlow.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/CPlantedC4.h>
#include <CS2/Classes/Entities/CBaseAnimGraph.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/C_Hostage.h>
#include <CS2/Classes/Entities/WeaponEntities.h>
#include <GameClient/Entities/BaseModelEntity.h>
#include <GameClient/Entities/PlantedC4.h>
#include <GameClient/Entities/PlayerPawn.h>
#include <GameClient/Entities/EntityClassifier.h>

#include "DefuseKitOutlineGlow/DefuseKitOutlineGlow.h"
#include "DroppedBombOutlineGlow/DroppedBombOutlineGlow.h"
#include "GrenadeProjectileOutlineGlow/GrenadeProjectileOutlineGlow.h"
#include "HostageOutlineGlow/HostageOutlineGlow.h"
#include "PlayerOutlineGlow/PlayerOutlineGlow.h"
#include "TickingBombOutlineGlow/TickingBombOutlineGlow.h"
#include "WeaponOutlineGlow/WeaponOutlineGlow.h"

template <typename HookContext>
class OutlineGlow {
public:
    explicit OutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] auto applyGlow() const noexcept
    {
        return [this](auto&& glow, auto&& entity, EntityTypeInfo entityTypeInfo) {
            if (!GET_CONFIG_VAR(outline_glow_vars::Enabled) || !glow.enabled())
                return;

            if (!entityTypeInfo.isModelEntity() || entity.baseEntity().template as<BaseModelEntity>().glowProperty().isGlowing().valueOr(false))
                return;

            if (shouldApplyGlow(glow, entityTypeInfo, entity))
                entity.baseEntity().applyGlowRecursively(getGlowColor(glow, entity, entityTypeInfo), getGlowRange(glow));
        };
    }

    void onUnload() const noexcept
    {
        hookContext.template make<GlowSceneObjects>().clearObjects();
    }

private:
    [[nodiscard]] static bool shouldApplyGlow(auto&& glow, [[maybe_unused]] EntityTypeInfo entityTypeInfo, auto&& entity)
    {
        if constexpr (requires { { glow.shouldApplyGlow(entityTypeInfo, entity) } -> std::same_as<bool>; })
            return glow.shouldApplyGlow(entityTypeInfo, entity);
        else
            return true;
    }

    template <typename Hue>
    [[nodiscard]] static cs2::Color colorFromHue(Optional<Hue> hue) noexcept
    {
        using namespace outline_glow_params;
        if (hue.hasValue())
            return color::HSBtoRGB(hue.value(), kSaturation, kBrightness);
        return kFallbackColor;
    }

    [[nodiscard]] static cs2::Color colorFromHue(auto hue) noexcept
    {
        using namespace outline_glow_params;
        return color::HSBtoRGB(hue, kSaturation, kBrightness);
    }

    [[nodiscard]] static auto getGlowHue(auto&& glow, auto&& entity, [[maybe_unused]] EntityTypeInfo entityTypeInfo)
    {
        if constexpr (requires { { glow.hue(entityTypeInfo, entity) }; })
            return glow.hue(entityTypeInfo, entity);
        else
            return glow.hue();
    }

    [[nodiscard]] static auto getGlowColor(auto&& glow, auto&& entity, EntityTypeInfo entityTypeInfo)
    {
        return colorFromHue(getGlowHue(glow, entity, entityTypeInfo)).setAlpha(getGlowColorAlpha(glow, entity));
    }

    [[nodiscard]] static std::uint8_t getGlowColorAlpha(auto&& glow, auto&& entity) noexcept
    {
        if constexpr (requires { { glow.getGlowColorAlpha(entity) } -> std::same_as<std::uint8_t>; })
            return glow.getGlowColorAlpha(entity);
        else
            return outline_glow_params::kGlowAlpha;
    }

    [[nodiscard]] static int getGlowRange(auto&& glow) noexcept
    {
        if constexpr (requires { { glow.getGlowRange() } -> std::same_as<int>; })
            return glow.getGlowRange();
        else
            return 0;
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>
#include "PlayerOutlineGlow/PlayerOutlineGlowColorType.h"
#include "OutlineGlowParams.h"

namespace outline_glow_vars
{

CONFIG_VARIABLE(Enabled, bool, false);
CONFIG_VARIABLE(GlowDefuseKits, bool, true);
CONFIG_VARIABLE(GlowDroppedBomb, bool, true);
CONFIG_VARIABLE(GlowGrenadeProjectiles, bool, true);
CONFIG_VARIABLE(GlowHostages, bool, true);
CONFIG_VARIABLE(GlowPlayers, bool, true);
CONFIG_VARIABLE(GlowOnlyEnemies, bool, true);
CONFIG_VARIABLE(PlayerGlowColorMode, PlayerOutlineGlowColorType, PlayerOutlineGlowColorType::PlayerOrTeamColor);
CONFIG_VARIABLE(GlowTickingBomb, bool, true);
CONFIG_VARIABLE(GlowWeapons, bool, true);

CONFIG_VARIABLE_HUE(PlayerBlueHue, outline_glow_params::kPlayerBlueHue);
CONFIG_VARIABLE_HUE(PlayerGreenHue, outline_glow_params::kPlayerGreenHue);
CONFIG_VARIABLE_HUE(PlayerYellowHue, outline_glow_params::kPlayerYellowHue);
CONFIG_VARIABLE_HUE(PlayerOrangeHue, outline_glow_params::kPlayerOrangeHue);
CONFIG_VARIABLE_HUE(PlayerPurpleHue, outline_glow_params::kPlayerPurpleHue);

CONFIG_VARIABLE_HUE(TeamTHue, outline_glow_params::kTeamTHue);
CONFIG_VARIABLE_HUE(TeamCTHue, outline_glow_params::kTeamCTHue);

CONFIG_VARIABLE_HUE(LowHealthHue, outline_glow_params::kLowHealthHue);
CONFIG_VARIABLE_HUE(HighHealthHue, outline_glow_params::kHighHealthHue);

CONFIG_VARIABLE_HUE(AllyHue, outline_glow_params::kAllyHue);
CONFIG_VARIABLE_HUE(EnemyHue, outline_glow_params::kEnemyHue);

CONFIG_VARIABLE_HUE(MolotovHue, outline_glow_params::kMolotovHue);
CONFIG_VARIABLE_HUE(FlashbangHue, outline_glow_params::kFlashbangHue);
CONFIG_VARIABLE_HUE(HEGrenadeHue, outline_glow_params::kHEGrenadeHue);
CONFIG_VARIABLE_HUE(SmokeGrenadeHue, outline_glow_params::kSmokeGrenadeHue);

CONFIG_VARIABLE_HUE(DroppedBombHue, outline_glow_params::kDroppedBombHue);
CONFIG_VARIABLE_HUE(TickingBombHue, outline_glow_params::kTickingBombHue);
CONFIG_VARIABLE_HUE(DefuseKitHue, outline_glow_params::kDefuseKitHue);

CONFIG_VARIABLE_HUE(HostageHue, outline_glow_params::kHostageHue);

}

```

`Source/Features/Visuals/OutlineGlow/OutlineGlowParams.h`:

```h
#pragma once

#include <Config/RangeConstrainedVariableParams.h>
#include <CS2/Classes/Color.h>
#include <Utils/ColorUtils.h>

namespace outline_glow_params
{
    constexpr auto kDefuseKitGlowRange = 800;
    constexpr auto kWeaponGlowRange = 800;

    constexpr auto kGlowAlpha = 102;
    constexpr auto kImmunePlayerGlowAlpha = 40;
    constexpr color::Saturation kSaturation{0.5f};
    constexpr color::Brightness kBrightness{1.0f};

    constexpr HueVariableParams kHostageHue{.min = 0, .max = 359, .def = 50};

    constexpr HueVariableParams kPlayerBlueHue{.min = 191, .max = 240, .def = 215};
    constexpr HueVariableParams kPlayerGreenHue{.min = 110, .max = 140, .def = 125};
    constexpr HueVariableParams kPlayerYellowHue{.min = 47, .max = 60, .def = 53};
    constexpr HueVariableParams kPlayerOrangeHue{.min = 11, .max = 20, .def = 15};
    constexpr HueVariableParams kPlayerPurpleHue{.min = 250, .max = 280, .def = 265};

    constexpr HueVariableParams kTeamTHue{.min = 30, .max = 40, .def = 35};
    constexpr HueVariableParams kTeamCTHue{.min = 210, .max = 230, .def = 220};

    constexpr HueVariableParams kLowHealthHue{.min = 0, .max = 359, .def = 0};
    constexpr HueVariableParams kHighHealthHue{.min = 0, .max = 359, .def = 120};

    constexpr HueVariableParams kAllyHue{.min = 0, .max = 359, .def = 120};
    constexpr HueVariableParams kEnemyHue{.min = 0, .max = 359, .def = 0};

    constexpr HueVariableParams kMolotovHue{.min = 20, .max = 60, .def = 40};
    constexpr HueVariableParams kFlashbangHue{.min = 191, .max = 250, .def = 219};
    constexpr HueVariableParams kHEGrenadeHue{.min = 300, .max = 359, .def = 359};
    constexpr HueVariableParams kSmokeGrenadeHue{.min = 110, .max = 140, .def = 120};

    constexpr HueVariableParams kDroppedBombHue{.min = 0, .max = 359, .def = 60};
    constexpr HueVariableParams kTickingBombHue{.min = 0, .max = 359, .def = 0};
    constexpr HueVariableParams kDefuseKitHue{.min = 0, .max = 359, .def = 184};

    constexpr cs2::Color kFallbackColor{191, 191, 191, kGlowAlpha};
}

```

`Source/Features/Visuals/OutlineGlow/PlayerOutlineGlow/PlayerOutlineGlow.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <CS2/Constants/ColorConstants.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <GameClient/Entities/TeamNumber.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>
#include "PlayerOutlineGlowColorType.h"

template <typename HookContext>
class PlayerOutlineGlow {
public:
    explicit PlayerOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowPlayers);
    }

    [[nodiscard]] bool shouldApplyGlow(EntityTypeInfo /* entityTypeInfo */, auto&& playerPawn) const noexcept
    {
        return playerPawn.isAlive().value_or(true)
            && playerPawn.health().greaterThan(0).valueOr(true)
            && !playerPawn.isControlledByLocalPlayer()
            && playerPawn.isTTorCT()
            && (!GET_CONFIG_VAR(outline_glow_vars::GlowOnlyEnemies) || playerPawn.isEnemy().value_or(true));
    }

    [[nodiscard]] Optional<color::Hue> hue(EntityTypeInfo /* entityTypeInfo */, auto&& playerPawn) const noexcept
    {
        switch (GET_CONFIG_VAR(outline_glow_vars::PlayerGlowColorMode)) {
        using enum PlayerOutlineGlowColorType;
        case EnemyAlly:
            if (const auto hue = enemyAllyColorModeHue(playerPawn))
                return hue->toHueFloat();
            return {};
        case HealthBased:
            return healthBasedColorModeHue(playerPawn);
        case PlayerOrTeamColor:
            if (const auto playerColor = getPlayerColorHue(playerPawn.playerController().playerColorIndex()))
                return playerColor->toHueFloat();
            [[fallthrough]];
        case TeamColor:
            if (const auto teamHue = teamColorModeHue(playerPawn))
                return teamHue->toHueFloat();
        default:
            return {};
        }
    }

    [[nodiscard]] std::uint8_t getGlowColorAlpha(auto&& playerPawn) const noexcept
    {
        using namespace outline_glow_params;
        return playerPawn.hasImmunity().valueOr(false) ? kImmunePlayerGlowAlpha : kGlowAlpha;
    }

private:
    [[nodiscard]] std::optional<color::HueInteger> teamColorModeHue(auto&& playerPawn) const noexcept
    {
        switch (playerPawn.teamNumber()) {
        case TeamNumber::TT: return GET_CONFIG_VAR(outline_glow_vars::TeamTHue);
        case TeamNumber::CT: return GET_CONFIG_VAR(outline_glow_vars::TeamCTHue);
        default: return {};
        }
    }

    [[nodiscard]] std::optional<color::HueInteger> enemyAllyColorModeHue(auto&& playerPawn) const noexcept
    {
        if (const auto isEnemy = playerPawn.isEnemy(); isEnemy.has_value())
            return *isEnemy ? GET_CONFIG_VAR(outline_glow_vars::EnemyHue) : GET_CONFIG_VAR(outline_glow_vars::AllyHue);
        return {};
    }

    [[nodiscard]] Optional<color::Hue> healthBasedColorModeHue(auto&& playerPawn) const noexcept
    {
        if (const auto healthValue = playerPawn.health(); healthValue.hasValue()) {
            const auto fraction = healthFraction(healthValue.value());

            const color::HueInteger lowHealthHue{GET_CONFIG_VAR(outline_glow_vars::LowHealthHue)};
            const color::HueInteger highHealthHue{GET_CONFIG_VAR(outline_glow_vars::HighHealthHue)};
            if (lowHealthHue < highHealthHue)
                return color::Hue{(lowHealthHue + (highHealthHue - lowHealthHue) * fraction) / 360.0f};
            else
                return color::Hue{(lowHealthHue - (lowHealthHue - highHealthHue) * fraction) / 360.0f};
        }
        return {};
    }

    [[nodiscard]] static constexpr float healthFraction(int playerHealth) noexcept
    {
        constexpr auto kMinHealth = 1;
        constexpr auto kMaxHealth = 100;

        if (playerHealth <= kMinHealth)
            return 0.0f;
        if (playerHealth >= kMaxHealth)
            return 1.0f;
        return static_cast<float>(playerHealth - kMinHealth) / (kMaxHealth - kMinHealth); 
    }

    [[nodiscard]] std::optional<color::HueInteger> getPlayerColorHue(auto playerColorIndex) const noexcept
    {
        if (!playerColorIndex.hasValue())
            return {};

        switch (playerColorIndex.value()) {
        using enum cs2::PlayerColorIndex;
        case Blue: return GET_CONFIG_VAR(outline_glow_vars::PlayerBlueHue);
        case Green: return GET_CONFIG_VAR(outline_glow_vars::PlayerGreenHue);
        case Yellow: return GET_CONFIG_VAR(outline_glow_vars::PlayerYellowHue);
        case Orange: return GET_CONFIG_VAR(outline_glow_vars::PlayerOrangeHue);
        case Purple: return GET_CONFIG_VAR(outline_glow_vars::PlayerPurpleHue);
        default: return {};
        }
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/PlayerOutlineGlow/PlayerOutlineGlowColorType.h`:

```h
#pragma once

#include <cstdint>

enum class PlayerOutlineGlowColorType : std::uint8_t {
    PlayerOrTeamColor,
    TeamColor,
    HealthBased,
    EnemyAlly
};

```

`Source/Features/Visuals/OutlineGlow/TickingBombOutlineGlow/TickingBombOutlineGlow.h`:

```h
#pragma once

#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowParams.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>

template <typename HookContext>
class TickingBombOutlineGlow {
public:
    TickingBombOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowTickingBomb);
    }

    [[nodiscard]] bool shouldApplyGlow(EntityTypeInfo /* entityTypeInfo */, auto&& plantedBomb) const
    {
        return plantedBomb.isTicking().valueOr(true);
    }

    [[nodiscard]] color::HueInteger hue() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::TickingBombHue);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/OutlineGlow/WeaponOutlineGlow/WeaponOutlineGlow.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/Entities/WeaponEntities.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowParams.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/ColorUtils.h>

template <typename HookContext>
class WeaponOutlineGlow {
public:
    explicit WeaponOutlineGlow(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool enabled() const
    {
        return GET_CONFIG_VAR(outline_glow_vars::GlowWeapons);
    }

    [[nodiscard]] bool shouldApplyGlow(EntityTypeInfo /* entityTypeInfo */, auto&& weapon) const noexcept
    {
        return !weapon.hasOwner().valueOr(true);
    }

    [[nodiscard]] Optional<color::HueInteger> hue(EntityTypeInfo entityTypeInfo, auto&& /* weapon */) const
    {
        switch (entityTypeInfo.typeIndex) {
        case EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>():
        case EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>(): return GET_CONFIG_VAR(outline_glow_vars::MolotovHue);
        case EntityTypeInfo::indexOf<cs2::C_Flashbang>(): return GET_CONFIG_VAR(outline_glow_vars::FlashbangHue);
        case EntityTypeInfo::indexOf<cs2::C_HEGrenade>(): return GET_CONFIG_VAR(outline_glow_vars::HEGrenadeHue);
        case EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>(): return GET_CONFIG_VAR(outline_glow_vars::SmokeGrenadeHue);
        default: return {};
        }
    }

    [[nodiscard]] int getGlowRange() const noexcept
    {
        return outline_glow_params::kWeaponGlowRange;
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/ActiveWeaponAmmo/ActiveWeaponAmmoPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace active_weapon_ammo_panel_params::container_panel_params
{
    static constexpr auto kAlignment = PanelAlignmentParams{
        .horizontalAlignment = cs2::k_EHorizontalAlignmentCenter,
        .verticalAlignment = cs2::k_EVerticalAlignmentTop
    };
    static constexpr auto kMargin = PanelMarginParams{.marginTop = cs2::CUILength::pixels(3)};
    static constexpr auto kChildrenFlow = cs2::k_EFlowRight;
}

namespace active_weapon_ammo_panel_params::ammo_text_panel_params
{
    static constexpr auto kFont = PanelFontParams{
        .fontFamily = "Stratum2, 'Arial Unicode MS'",
        .fontSize = 24,
        .fontWeight = cs2::k_EFontWeightBlack
    };
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
    static constexpr auto kColor = cs2::kColorWhite;
}

namespace active_weapon_ammo_panel_params::ammo_icon_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/hud/bullet_single.vsvg";
    static constexpr auto kTextureHeight = 20;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kMargin = PanelMarginParams{.marginLeft = cs2::CUILength::pixels(5)};
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

```

`Source/Features/Visuals/PlayerInfoInWorld/ActiveWeaponAmmo/PlayerActiveWeaponAmmoPanel.h`:

```h
#pragma once

#include <utility>

#include "PlayerActiveWeaponAmmoPanelContext.h"
#include <GameClient/Panorama/PanoramaLabel.h>
#include <Utils/StringBuilder.h>

template <typename HookContext, typename Context = PlayerActiveWeaponAmmoPanelContext<HookContext>>
class PlayerActiveWeaponAmmoPanel {
public:
    template <typename... Args>
    explicit PlayerActiveWeaponAmmoPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void update(auto&& playerPawn) const noexcept
    {
        if (!context.shouldShowOn(playerPawn)) {
            context.panel().setVisible(false);
            return;
        }

        context.panel().setVisible(true);
        const auto ammo = playerPawn.getActiveWeapon().clipAmmo().valueOr(-1);
        if (context.cache().activeWeaponAmmo(ammo))
            context.panel().children()[0].clientPanel().template as<PanoramaLabel>().setText(StringBuilderStorage<10>{}.builder().put(ammo).cstring());
    }

private:
    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/ActiveWeaponAmmo/PlayerActiveWeaponAmmoPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldConfigVariables.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheEntry.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
class PlayerActiveWeaponAmmoPanelContext {
public:
    PlayerActiveWeaponAmmoPanelContext(HookContext& hookContext, cs2::CUIPanel* panel, PlayerInfoPanelCacheEntry& cache) noexcept
        : hookContext{hookContext}
        , _panel{panel}
        , _cache{cache}
    {
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] bool shouldShowOn(auto&& playerPawn) const noexcept
    {
        return GET_CONFIG_VAR(player_info_vars::ActiveWeaponAmmoEnabled) && playerPawn.getActiveWeapon().clipAmmo().greaterThan(-1).valueOr(true);
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(_panel);
    }

    [[nodiscard]] auto& cache() const noexcept
    {
        return _cache;
    }

private:
    HookContext& hookContext;
    cs2::CUIPanel* _panel;
    PlayerInfoPanelCacheEntry& _cache;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerHealth/PlayerHealthPanel.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Constants/ColorConstants.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldState.h>
#include <GameClient/Panorama/PanoramaLabel.h>
#include <Utils/StringBuilder.h>

#include "PlayerHealthPanelContext.h"

template <typename HookContext, typename Context = PlayerHealthPanelContext<HookContext>>
class PlayerHealthPanel {
public:
    template <typename... Args>
    explicit PlayerHealthPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void update(auto&& playerPawn) const noexcept
    {
        if (!context.config().template getVariable<player_info_vars::PlayerHealthEnabled>()) {
            context.panel().setVisible(false);
            return;
        }

        context.panel().setVisible(true);

        auto&& healthValuePanel = context.panel().children()[1];

        if (const auto healthTextColor = getColor(playerPawn); context.cache().playerHealthTextColor(healthTextColor))
            healthValuePanel.setColor(healthTextColor);

        if (const auto playerHealth = playerPawn.health().valueOr(0); context.cache().playerHealth(playerHealth))
            healthValuePanel.clientPanel().template as<PanoramaLabel>().setText(StringBuilderStorage<10>{}.builder().put(playerHealth).cstring());
    }

private:
    [[nodiscard]] cs2::Color getColor(auto&& playerPawn) const noexcept
    {
        if (context.config().template getVariable<player_info_vars::PlayerHealthColorMode>() == PlayerHealthTextColor::HealthBased)
            return healthColor(playerPawn).value_or(cs2::kColorWhite);
        return cs2::kColorWhite;
    }

    [[nodiscard]] std::optional<cs2::Color> healthColor(auto&& playerPawn, float saturation = 0.7f) const noexcept
    {
        if (const auto healthValue = playerPawn.health(); healthValue.hasValue())
            return getColorOfHealthFraction(saturation, std::clamp(healthValue.value(), 0, 100) / 100.0f);
        return {};
    }

    [[nodiscard]] static cs2::Color getColorOfHealthFraction(float saturation, float healthFraction) noexcept
    {
        return color::HSBtoRGB(color::Hue{color::kRedHue + (color::kGreenHue - color::kRedHue) * healthFraction}, color::Saturation{saturation}, color::Brightness{1.0f});
    }

    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerHealth/PlayerHealthPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheEntry.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
class PlayerHealthPanelContext {
public:
    PlayerHealthPanelContext(HookContext& hookContext, cs2::CUIPanel* panel, PlayerInfoPanelCacheEntry& cache) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
        , _cache{cache}
    {
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return _hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

    [[nodiscard]] auto& cache() const noexcept
    {
        return _cache;
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return _hookContext.config();
    }

private:
    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
    PlayerInfoPanelCacheEntry& _cache;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerHealth/PlayerHealthPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace player_health_panel_params::container_panel_params
{
    static constexpr auto kAlignment = PanelAlignmentParams{
        .horizontalAlignment = cs2::k_EHorizontalAlignmentCenter,
        .verticalAlignment = cs2::k_EVerticalAlignmentTop
    };
    static constexpr auto kMargin = PanelMarginParams{.marginTop = cs2::CUILength::pixels(1)};
    static constexpr auto kChildrenFlow = cs2::k_EFlowRight;
}

namespace player_health_panel_params::health_icon_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/hud/health_cross.vsvg";
    static constexpr auto kTextureHeight = 24;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kMargin = PanelMarginParams{.marginRight = cs2::CUILength::pixels(5)};
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

namespace player_health_panel_params::health_text_panel_params
{
    static constexpr auto kFont = PanelFontParams{
        .fontFamily = "Stratum2, 'Arial Unicode MS'",
        .fontSize = 24,
        .fontWeight = cs2::k_EFontWeightBlack
    };
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoContainerPanelParams.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>

namespace player_info_container_panel_params
{
    static constexpr auto kWidth = cs2::CUILength::pixels(256);
    static constexpr auto kHeight = cs2::CUILength::pixels(256);
    static constexpr auto kPositionX = cs2::CUILength::pixels(-kWidth.m_flValue * 0.5f);
    static constexpr auto kPositionY = cs2::CUILength::pixels(0.0f);
    static constexpr auto kTransformOriginX = cs2::CUILength::percent(50);
    static constexpr auto kTransformOriginY = cs2::CUILength::percent(0);
    static constexpr auto kChildrenFlow = cs2::k_EFlowDown;
}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorld.h`:

```h
#pragma once

#include <Features/Common/InWorldPanels.h>
#include <Features/Common/FeatureToggle.h>
#include <GameClient/WorldToScreen/WorldToClipSpaceConverter.h>
#include <Hooks/ViewRenderHook.h>

#include "PlayerInfoInWorldContext.h"
#include "PlayerInfoInWorldState.h"
#include "PlayerPositionArrow/PlayerPositionArrowColorType.h"
#include "PlayerStateIcons/PlayerStateIconsToShow.h"

template <typename HookContext>
class PlayerInfoInWorld {
public:
    PlayerInfoInWorld(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void drawPlayerInformation(auto&& playerPawn) noexcept
    {
        auto&& condition = context().condition();
        if (!condition.shouldRun() || !condition.shouldDrawInfoOnPawn(playerPawn))
            return;

        const auto absOrigin = playerPawn.absOrigin();
        if (!absOrigin.hasValue())
            return;

        const auto positionInClipSpace = hookContext.template make<WorldToClipSpaceConverter>().toClipSpace(absOrigin.value());
        if (!positionInClipSpace.onScreen())
            return;

        auto&& playerInformationPanel = hookContext.template make<InWorldPanels>().getNextPlayerInfoPanel();
        playerInformationPanel.drawPlayerInfo(playerPawn);
        playerInformationPanel.updatePosition(absOrigin.value());
    }

private:
    [[nodiscard]] decltype(auto) context() const noexcept
    {
        return hookContext.template make<PlayerInfoInWorldContext>();
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldCondition.h`:

```h
#pragma once

template <typename Context>
class PlayerInfoInWorldCondition {
public:
    explicit PlayerInfoInWorldCondition(auto& otherContext) noexcept
        : context{otherContext}
    {
    }

    [[nodiscard]] bool shouldRun() const noexcept
    {
        return context.config().template getVariable<player_info_vars::Enabled>();
    }

    [[nodiscard]] bool shouldDrawInfoOnPawn(auto&& playerPawn) const noexcept
    {
        return playerPawn.isAlive().value_or(true)
            && playerPawn.health().greaterThan(0).valueOr(true)
            && !playerPawn.isControlledByLocalPlayer()
            && playerPawn.isTTorCT()
            && (!context.config().template getVariable<player_info_vars::OnlyEnemies>() || playerPawn.isEnemy().value_or(true));
    }

private:
    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>
#include "PlayerPositionArrow/PlayerPositionArrowColorType.h"

enum class PlayerHealthTextColor : std::uint8_t {
    HealthBased,
    White
};

namespace player_info_vars
{

CONFIG_VARIABLE(Enabled, bool, false);
CONFIG_VARIABLE(OnlyEnemies, bool, false);
CONFIG_VARIABLE(PlayerPositionArrowEnabled, bool, true);
CONFIG_VARIABLE(PlayerPositionArrowColorMode, PlayerPositionArrowColorType, PlayerPositionArrowColorType::PlayerOrTeamColor);
CONFIG_VARIABLE(PlayerHealthEnabled, bool, true);
CONFIG_VARIABLE(PlayerHealthColorMode, PlayerHealthTextColor, PlayerHealthTextColor::HealthBased);
CONFIG_VARIABLE(ActiveWeaponIconEnabled, bool, true);
CONFIG_VARIABLE(ActiveWeaponAmmoEnabled, bool, true);
CONFIG_VARIABLE(BombCarrierIconEnabled, bool, true);
CONFIG_VARIABLE(BombPlantIconEnabled, bool, true);
CONFIG_VARIABLE(BombDefuseIconEnabled, bool, true);
CONFIG_VARIABLE(HostagePickupIconEnabled, bool, true);
CONFIG_VARIABLE(HostageRescueIconEnabled, bool, true);
CONFIG_VARIABLE(BlindedIconEnabled, bool, true);

}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldContext.h`:

```h
#pragma once

#include "PlayerInfoInWorldCondition.h"

template <typename HookContext>
class PlayerInfoInWorldContext {
public:
    explicit PlayerInfoInWorldContext(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] decltype(auto) condition() const noexcept
    {
        return hookContext.template make<PlayerInfoInWorldCondition<PlayerInfoInWorldContext>>();
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return hookContext.config();
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldPanelFactory.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Panorama/ImagePanel.h>
#include <GameClient/Panorama/PanoramaTransformations.h>
#include <Utils/Lvalue.h>

#include "ActiveWeaponAmmo/ActiveWeaponAmmoPanelParams.h"
#include "ActiveWeaponAmmo/PlayerActiveWeaponAmmoPanel.h"
#include "PlayerHealth/PlayerHealthPanel.h"
#include "PlayerHealth/PlayerHealthPanelParams.h"
#include "PlayerInfoContainerPanelParams.h"
#include "PlayerPositionArrow/PlayerPositionArrowPanel.h"
#include "PlayerPositionArrow/PlayerPositionArrowPanelParams.h"
#include "PlayerStateIcons/PlayerStateIconsPanel.h"
#include "PlayerStateIcons/PlayerStateIconsPanelParams.h"
#include "PlayerWeaponIcon/ActiveWeaponIcon/ActiveWeaponIconPanelParams.h"
#include "PlayerWeaponIcon/BombIcon/PlayerBombIconPanelParams.h"
#include "PlayerWeaponIcon/PlayerWeaponIconPanel.h"
#include "PlayerWeaponIcon/PlayerWeaponIconPanelParams.h"

template <typename HookContext>
class PlayerInfoInWorldPanelFactory {
public:
    PlayerInfoInWorldPanelFactory(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) createContainerPanel(auto&& parentPanel) const noexcept
    {
        using namespace player_info_container_panel_params;

        auto&& uiPanel = hookContext.panelFactory().createPanel(parentPanel).uiPanel();
        uiPanel.setWidth(kWidth);
        uiPanel.setHeight(kHeight);
        uiPanel.setPosition(kPositionX, kPositionY);
        uiPanel.setTransformOrigin(kTransformOriginX, kTransformOriginY);
        uiPanel.setFlowChildren(kChildrenFlow);
        return utils::lvalue<decltype(uiPanel)>(uiPanel);
    }

    void createPanel(std::type_identity<PlayerPositionArrowPanel<HookContext>>, auto&& containerPanel) const noexcept
    {
        using namespace player_position_arrow_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(kImageUrl, kTextureHeight);

        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setImageShadow(kShadowParams);
        PanoramaTransformations{
            hookContext.panoramaTransformFactory().scale(1.0f, -1.0f),
        }.applyTo(uiPanel);
    }

    void createPanel(std::type_identity<PlayerActiveWeaponAmmoPanel<HookContext>>, auto&& containerPanel) const noexcept
    {
        auto&& ammoPanel = createActiveWeaponAmmoContainerPanel(containerPanel);
        createActiveWeaponAmmoTextPanel(ammoPanel);
        createActiveWeaponAmmoIconPanel(ammoPanel);
    }

    void createPanel(std::type_identity<PlayerStateIconsPanel<HookContext>>, auto&& containerPanel) const noexcept
    {
        using namespace player_state_icons_panel_params::container_panel_params;

        auto&& panel = hookContext.panelFactory().createPanel(containerPanel).uiPanel();
        panel.setAlign(kAlignment);
        panel.setMargin(kMargin);
        panel.setFlowChildren(kChildrenFlow);

        createDefuseIconPanel(panel);
        createHostagePickupPanel(panel);
        createHostageRescuePanel(panel);
        createBlindedIconPanel(panel);
    }

    void createPanel(std::type_identity<PlayerWeaponIconPanel<HookContext>>, cs2::CUIPanel* parentPanel) const noexcept
    {
        using namespace player_weapon_icon_panel_params;

        auto&& containerPanel = hookContext.panelFactory().createPanel(parentPanel).uiPanel();
        containerPanel.setFlowChildren(kChildrenFlow);
        containerPanel.setAlign(kAlignment);
        containerPanel.setMargin(kMargin);

        createPlayerActiveWeaponIconPanel(containerPanel);
        createBombIconContainerPanel(containerPanel);
    }

    void createPanel(std::type_identity<PlayerHealthPanel<HookContext>>, cs2::CUIPanel* containerPanel) const noexcept
    {
        using namespace player_health_panel_params::container_panel_params;

        auto&& healthPanel = hookContext.panelFactory().createPanel(containerPanel).uiPanel();
        healthPanel.setAlign(kAlignment);
        healthPanel.setMargin(kMargin);
        healthPanel.setFlowChildren(kChildrenFlow);

        createHealthIconPanel(healthPanel);
        createHealthTextPanel(healthPanel);
    }

private:
    [[nodiscard]] decltype(auto) createActiveWeaponAmmoContainerPanel(auto&& containerPanel) const noexcept
    {
        using namespace active_weapon_ammo_panel_params::container_panel_params;

        auto&& uiPanel = hookContext.panelFactory().createPanel(containerPanel).uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setMargin(kMargin);
        uiPanel.setFlowChildren(kChildrenFlow);
        return utils::lvalue<decltype(uiPanel)>(uiPanel);
    }

    void createActiveWeaponAmmoTextPanel(auto&& containerPanel) const
    {
        using namespace active_weapon_ammo_panel_params::ammo_text_panel_params;

        auto&& label = hookContext.panelFactory().createLabelPanel(containerPanel).uiPanel();
        label.setFont(kFont);
        label.setAlign(kAlignment);
        label.setTextShadow(kShadowParams);
        label.setColor(kColor);
    }

    void createActiveWeaponAmmoIconPanel(auto&& containerPanel) const
    {
        using namespace active_weapon_ammo_panel_params::ammo_icon_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(kImageUrl, kTextureHeight);
        
        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setMargin(kMargin);
        uiPanel.setImageShadow(kShadowParams);
    }

    void createDefuseIconPanel(auto&& containerPanel) const noexcept
    {
        using namespace player_state_icons_panel_params::defuse_icon_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(SvgImageParams{.imageUrl = kImageUrl, .textureHeight = kTextureHeight, .fillColor = kWashColor});
    
        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setImageShadow(kShadowParams);
    }

    void createHostagePickupPanel(cs2::CUIPanel* containerPanel) const noexcept
    {
        createHostageIconPanel(containerPanel, cs2::kColorYellow);
    }

    void createHostageRescuePanel(cs2::CUIPanel* containerPanel) const noexcept
    {
        createHostageIconPanel(containerPanel, cs2::kColorLightGreen);
    }

    void createHostageIconPanel(cs2::CUIPanel* containerPanel, cs2::Color color) const noexcept
    {
        using namespace player_state_icons_panel_params::hostage_icon_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(SvgImageParams{.imageUrl = kImageUrl, .textureHeight = kTextureHeight, .fillColor = color});
    
        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setImageShadow(kShadowParams);
    }

    void createBlindedIconPanel(cs2::CUIPanel* containerPanel) const noexcept
    {
        using namespace player_state_icons_panel_params::blinded_icon_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(kImageUrl, kTextureHeight);

        auto&& uiPanel = imagePanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setImageShadow(kShadowParams);
    }

    void createBombIconContainerPanel(cs2::CUIPanel* parentPanel) const noexcept
    {
        using namespace player_bomb_icon_panel_params::container_panel_params;

        auto&& containerPanel = hookContext.panelFactory().createPanel(parentPanel).uiPanel();
        containerPanel.setAlign(kAlignment);
        containerPanel.setMargin(kMargin);

        createBombIconPanel(containerPanel, kColorCarryingC4);
        createBombIconPanel(containerPanel, kColorPlantingC4);
    }

    void createBombIconPanel(cs2::CUIPanel* containerPanel, cs2::Color color) const noexcept
    {
        using namespace player_bomb_icon_panel_params::bomb_icon_panel_params;

        auto&& imagePanel = hookContext.panelFactory().createImagePanel(containerPanel);
        imagePanel.setImageSvg(SvgImageParams{.imageUrl = kImageUrl, .textureHeight = kTextureHeight, .fillColor = color});
        imagePanel.uiPanel().setImageShadow(kShadowParams);
    }

    void createHealthIconPanel(cs2::CUIPanel* containerPanel) const
    {
        using namespace player_health_panel_params::health_icon_panel_params;

        auto&& healthIconPanel = hookContext.panelFactory().createImagePanel(containerPanel);
        healthIconPanel.setImageSvg(kImageUrl, kTextureHeight);

        auto&& uiPanel = healthIconPanel.uiPanel();
        uiPanel.setAlign(kAlignment);
        uiPanel.setMargin(kMargin);
        uiPanel.setImageShadow(kShadowParams);
    }

    void createHealthTextPanel(cs2::CUIPanel* containerPanel) const
    {
        using namespace player_health_panel_params::health_text_panel_params;

        auto&& label = hookContext.panelFactory().createLabelPanel(containerPanel).uiPanel();
        label.setFont(kFont);
        label.setAlign(kAlignment);
        label.setTextShadow(kShadowParams);
    }

    void createPlayerActiveWeaponIconPanel(cs2::CUIPanel* parentPanel) const noexcept
    {
        using namespace active_weapon_icon_panel_params;

        auto&& panel = hookContext.panelFactory().createImagePanel(parentPanel).uiPanel();
        panel.setAlign(kAlignment);
        panel.setImageShadow(kShadowParams);
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldState.h`:

```h
#pragma once

#include "PlayerStateIcons/PlayerStateIconsToShow.h"

struct PlayerInfoInWorldState {
    PlayerStateIconsToShow playerStateIconsToShow{
        PlayerStateIconsToShow{}
            .set<DefuseIconPanel>()
            .set<HostagePickupPanel>()
            .set<HostageRescuePanel>()
            .set<BlindedIconPanel>()};
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoPanel.h`:

```h
#pragma once

#include <algorithm>
#include <tuple>
#include <type_traits>

#include <CS2/Classes/Vector.h>
#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/WorldToScreen/ViewToProjectionMatrix.h>
#include <GameClient/WorldToScreen/WorldToClipSpaceConverter.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <GameClient/Panorama/PanoramaTransformations.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>
#include <Utils/TypeIndex.h>
#include "PlayerInfoPanelCacheEntry.h"
#include "PlayerInfoPanelTypes.h"

template <typename HookContext>
class PlayerInfoPanel {
public:
    explicit PlayerInfoPanel(HookContext& hookContext, cs2::CUIPanel* panel, PlayerInfoPanelCacheEntry& cache) noexcept
        : hookContext{hookContext}
        , panel{panel}
        , cache{cache}
    {
    }

    void drawPlayerInfo(auto&& playerPawn) const noexcept
    {
        updatePanels(std::type_identity<PlayerInfoPanelTypes<HookContext>>{}, playerPawn);
        if (const auto opacity = getOpacity(playerPawn); cache.opacity(opacity))
            getPanel().setOpacity(opacity);
    }

    void updatePosition(const cs2::Vector& origin) const noexcept
    {
        const auto positionInClipSpace = hookContext.template make<WorldToClipSpaceConverter>().toClipSpace(origin);
        getPanel().setZIndex(-positionInClipSpace.z);

        constexpr auto kMaxScale{1.0f};
        const auto scale = std::clamp(500.0f / (positionInClipSpace.z / getFovScale() + 400.0f), 0.4f, kMaxScale);

        const auto deviceCoordinates = positionInClipSpace.toNormalizedDeviceCoordinates();
        PanoramaTransformations{
            hookContext.panoramaTransformFactory().scale(scale),
            hookContext.panoramaTransformFactory().translate(deviceCoordinates.getX(), deviceCoordinates.getY())
        }.applyTo(getPanel());
    }

private:
    [[nodiscard]] float getOpacity(auto&& playerPawn) const noexcept
    {
        return playerPawn.hasImmunity().valueOr(false) ? 0.5f : 1.0f;
    }

    [[nodiscard]] float getFovScale() const noexcept
    {
        return ViewToProjectionMatrix{hookContext}.getFovScale();
    }

    template <typename... PanelTypes>
    void updatePanels(std::type_identity<std::tuple<PanelTypes...>>, auto&& playerPawn) const noexcept
    {
        auto&& childPanels = getPanel().children();
        (hookContext.template make<PanelTypes>(childPanels[utils::typeIndex<PanelTypes, std::tuple<PanelTypes...>>()], cache).update(playerPawn), ...);
    }

    [[nodiscard]] decltype(auto) getPanel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(panel);
    }

    HookContext& hookContext;
    cs2::CUIPanel* panel;
    PlayerInfoPanelCacheEntry& cache;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCache.h`:

```h
#pragma once

template <typename HookContext>
class PlayerInfoPanelCache {
public:
    explicit PlayerInfoPanelCache(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void allocateNewEntry() const noexcept
    {
        state().cache.pushBack({});
    }

    [[nodiscard]] auto& nextEntry() const noexcept
    {
        return state().cache[perHookState().nextEntryIndex++];
    }

    void clear() const noexcept
    {
        state().cache.clear();
    }

private:
    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.playerInfoPanelCacheState();
    }

    [[nodiscard]] auto& perHookState() const noexcept
    {
        return hookContext.playerInfoPanelCachePerHookState();
    }

    HookContext& hookContext;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheEntry.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>

struct PlayerInfoPanelCacheEntry {
    template <typename T>
    struct Cached {
        Cached() = default;
        Cached(T value) noexcept
            : cachedValue{value}
        {
        }

        [[nodiscard]] bool operator()(T currentValue) noexcept
        {
            if (cachedValue != currentValue) {
                cachedValue = currentValue;
                return true;
            }
            return false;
        }

    private:
        T cachedValue{};
    };

    Cached<cs2::Color> playerPositionArrowColor{cs2::Color{0, 0, 0, 0}};
    Cached<cs2::Color> playerHealthTextColor{cs2::Color{0, 0, 0, 0}};
    Cached<int> playerHealth{-1};
    Cached<int> activeWeaponAmmo{-1};
    Cached<float> opacity{-1.0f};
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCachePerHookState.h`:

```h
#pragma once

#include <cstdint>

struct PlayerInfoPanelCachePerHookState {
    std::uint8_t nextEntryIndex{};
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheState.h`:

```h
#pragma once

#include <Utils/DynamicArray.h>

#include "PlayerInfoPanelCacheEntry.h"

struct PlayerInfoPanelCacheState {
    DynamicArray<PlayerInfoPanelCacheEntry> cache;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelTypes.h`:

```h
#pragma once

#include <tuple>

#include "ActiveWeaponAmmo/PlayerActiveWeaponAmmoPanel.h"
#include "PlayerHealth/PlayerHealthPanel.h"
#include "PlayerPositionArrow/PlayerPositionArrowPanel.h"
#include "PlayerStateIcons/PlayerStateIconsPanel.h"
#include "PlayerWeaponIcon/PlayerWeaponIconPanel.h"

template <typename HookContext>
using PlayerInfoPanelTypes = std::tuple<
    PlayerPositionArrowPanel<HookContext>,
    PlayerHealthPanel<HookContext>,
    PlayerWeaponIconPanel<HookContext>,
    PlayerActiveWeaponAmmoPanel<HookContext>,
    PlayerStateIconsPanel<HookContext>>;

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerPositionArrow/PlayerPositionArrowColorType.h`:

```h
#pragma once

#include <cstdint>

enum class PlayerPositionArrowColorType : std::uint8_t {
    PlayerOrTeamColor,
    TeamColor
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerPositionArrow/PlayerPositionArrowPanel.h`:

```h
#pragma once

#include <utility>

#include <CS2/Constants/ColorConstants.h>
#include <GameClient/Entities/TeamNumber.h>

#include "PlayerPositionArrowColorType.h"
#include "PlayerPositionArrowPanelContext.h"

template <typename HookContext, typename Context = PlayerPositionArrowPanelContext<HookContext>>
class PlayerPositionArrowPanel {
public:
    template <typename... Args>
    explicit PlayerPositionArrowPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void update(auto&& playerPawn) const noexcept
    {
        if (!context.config().template getVariable<player_info_vars::PlayerPositionArrowEnabled>()) {
            context.panel().setVisible(false);
            return;
        }

        context.panel().setVisible(true);

        const auto arrowColor = getArrowColor(playerPawn);
        if (context.cache().playerPositionArrowColor(arrowColor))
            context.panel().setWashColor(arrowColor);
    }

private:
    [[nodiscard]] cs2::Color getArrowColor(auto&& playerPawn) const noexcept
    {
        if (context.config().template getVariable<player_info_vars::PlayerPositionArrowColorMode>() == PlayerPositionArrowColorType::PlayerOrTeamColor) {
            const auto playerColor = getPlayerColor(playerPawn.playerController().playerColorIndex());
            if (playerColor.has_value())
                return *playerColor;
        }

        switch (playerPawn.teamNumber()) {
            using enum TeamNumber;
            case TT: return cs2::kColorTeamTT;
            case CT: return cs2::kColorTeamCT;
            default: return cs2::kColorWhite;
        }
    }

    [[nodiscard]] std::optional<cs2::Color> getPlayerColor(auto playerColorIndex) const noexcept
    {
        if (!playerColorIndex.hasValue())
            return {};

        switch (playerColorIndex.value()) {
        using enum cs2::PlayerColorIndex;
        case Blue: return cs2::kColorPlayerBlue;
        case Green: return cs2::kColorPlayerGreen;
        case Yellow: return cs2::kColorPlayerYellow;
        case Orange: return cs2::kColorPlayerOrange;
        case Purple: return cs2::kColorPlayerPurple;
        default: return {};
        }
    }

    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerPositionArrow/PlayerPositionArrowPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheEntry.h>

template <typename HookContext>
class PlayerPositionArrowPanelContext {
public:
    PlayerPositionArrowPanelContext(HookContext& hookContext, cs2::CUIPanel* panel, PlayerInfoPanelCacheEntry& cache) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
        , _cache{cache}
    {
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return _hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

    [[nodiscard]] auto& cache() const noexcept
    {
        return _cache;
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return _hookContext.config();
    }

private:
    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
    PlayerInfoPanelCacheEntry& _cache;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerPositionArrow/PlayerPositionArrowPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>

namespace player_position_arrow_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/hud/reticle/playerid_arrow.vsvg";
    static constexpr auto kTextureHeight = 24;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .horizontalAlignment = cs2::k_EHorizontalAlignmentCenter,
        .verticalAlignment = cs2::k_EVerticalAlignmentTop
    };
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerStateIcons/PlayerStateIconsPanel.h`:

```h
#pragma once

#include <utility>

#include "PlayerStateIconsPanelContext.h"
#include "PlayerStateIconsToShow.h"

template <typename HookContext, typename Context = PlayerStateIconsPanelContext<HookContext>>
class PlayerStateIconsPanel {
public:
    template <typename... Args>
    explicit PlayerStateIconsPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void update(auto&& playerPawn) const noexcept
    {
        if (!context.state().playerStateIconsToShow) {
            context.panel().setVisible(false);
            return;
        }

        context.panel().setVisible(true);

        auto&& playerStateChildren = context.panel().children();
        playerStateChildren[0].setVisible(context.state().playerStateIconsToShow.template has<DefuseIconPanel>() && playerPawn.isDefusing().valueOr(false));
        playerStateChildren[1].setVisible(context.state().playerStateIconsToShow.template has<HostagePickupPanel>() && playerPawn.isPickingUpHostage().valueOr(false));
        playerStateChildren[2].setVisible(context.state().playerStateIconsToShow.template has<HostageRescuePanel>() && playerPawn.isRescuingHostage());
        updateBlindedIconPanel(playerStateChildren[3], playerPawn);
    }

private:
    void updateBlindedIconPanel(auto&& blindedIconPanel, auto&& playerPawn) const noexcept
    {
        if (!context.state().playerStateIconsToShow.template has<BlindedIconPanel>()) {
            blindedIconPanel.setVisible(false);
            return;
        }

        const auto remainingFlashBangTime = playerPawn.getRemainingFlashBangTime();
        constexpr auto kFullBlindEnd{3.0f};
        constexpr auto kBlindEnd{1.0f};
        constexpr auto kPartiallyBlindDuration{kFullBlindEnd - kBlindEnd};
        if (remainingFlashBangTime <= kBlindEnd) {
            blindedIconPanel.setVisible(false);
            return;
        }

        blindedIconPanel.setVisible(true);
        const auto opacity = remainingFlashBangTime >= kFullBlindEnd ? 1.0f : (remainingFlashBangTime - kBlindEnd) / kPartiallyBlindDuration;
        blindedIconPanel.setOpacity(opacity);
    }

    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerStateIcons/PlayerStateIconsPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheEntry.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
class PlayerStateIconsPanelContext {
public:
    PlayerStateIconsPanelContext(HookContext& hookContext, cs2::CUIPanel* panel, PlayerInfoPanelCacheEntry&) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
    {
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return _hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

private:
    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerStateIcons/PlayerStateIconsPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace player_state_icons_panel_params::container_panel_params
{
    static constexpr auto kAlignment = PanelAlignmentParams{
        .horizontalAlignment = cs2::k_EHorizontalAlignmentCenter,
        .verticalAlignment = cs2::k_EVerticalAlignmentTop
    };
    static constexpr auto kMargin = PanelMarginParams{.marginTop = cs2::CUILength::pixels(3)};
    static constexpr auto kChildrenFlow = cs2::k_EFlowRight;
}

namespace player_state_icons_panel_params::defuse_icon_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/icons/equipment/defuser.vsvg";
    static constexpr auto kTextureHeight = 24;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kWashColor = cs2::kColorDefuseKit;
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

namespace player_state_icons_panel_params::hostage_icon_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/icons/ui/hostage_transit.svg";
    static constexpr auto kTextureHeight = 32;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

namespace player_state_icons_panel_params::blinded_icon_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/hud/deathnotice/blind_kill.svg";
    static constexpr auto kTextureHeight = 26;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerStateIcons/PlayerStateIconsToShow.h`:

```h
#pragma once

#include <Utils/TypeBitFlags.h>

struct DefuseIconPanel;
struct HostagePickupPanel;
struct HostageRescuePanel;
struct BlindedIconPanel;

using PlayerStateIconsToShow = TypeBitFlags<DefuseIconPanel, HostagePickupPanel, HostageRescuePanel, BlindedIconPanel>;

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/ActiveWeaponIcon/ActiveWeaponIconPanelParams.h`:

```h
#pragma once

#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace active_weapon_icon_panel_params
{
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kMargin = PanelMarginParams{.marginLeft = cs2::CUILength::pixels(2.5), .marginRight = cs2::CUILength::pixels(2.5)};
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/ActiveWeaponIcon/PlayerActiveWeaponIconPanel.h`:

```h
#pragma once

#include <utility>

#include <Common/Visibility.h>
#include <GameClient/Entities/C4.h>
#include <GameClient/Panorama/ImagePanel.h>
#include <Utils/CString.h>
#include <Utils/StringBuilder.h>
#include "PlayerActiveWeaponIconPanelContext.h"

template <typename HookContext, typename Context = PlayerActiveWeaponIconPanelContext<HookContext>>
class PlayerActiveWeaponIconPanel {
public:
    template <typename... Args>
    explicit PlayerActiveWeaponIconPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void update(auto&& playerPawn, Visibility bombIconVisibility) const noexcept
    {
        if (!context.config().template getVariable<player_info_vars::ActiveWeaponIconEnabled>() || (bombIconVisibility == Visibility::Visible && playerPawn.getActiveWeapon().template is<C4>())) {
            context.panel().setVisible(false);
            return;
        }

        auto weaponName = CString{playerPawn.getActiveWeapon().getName()};
        if (!weaponName.string)
            return;
        weaponName.skipPrefix("weapon_");

        context.panel().setVisible(true);

        StringBuilderStorage<100> weaponIconPathStorage;
        auto weaponIconPathBuilder = weaponIconPathStorage.builder();
        weaponIconPathBuilder.put("s2r://panorama/images/icons/equipment/", weaponName.string, ".svg");
        const auto weaponIconPath = weaponIconPathBuilder.cstring();

        auto&& weaponIconImagePanel = context.panel().clientPanel().template as<ImagePanel>();
        if (shouldUpdateImagePanel(weaponIconImagePanel, weaponIconPath))
            weaponIconImagePanel.setImageSvg(weaponIconPath, 24);
    }

private:
    [[nodiscard]] bool shouldUpdateImagePanel(auto&& imagePanel, const char* newImagePath) const noexcept
    {
        return imagePanel.getImagePath() != newImagePath;
    }

    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/ActiveWeaponIcon/PlayerActiveWeaponIconPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
class PlayerActiveWeaponIconPanelContext {
public:
    PlayerActiveWeaponIconPanelContext(HookContext& hookContext, cs2::CUIPanel* panel) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
    {
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return _hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

    [[nodiscard]] decltype(auto) config() const noexcept
    {
        return _hookContext.config();
    }

private:
    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/BombIcon/PlayerBombIconPanel.h`:

```h
#pragma once

#include <utility>

#include <Common/Visibility.h>
#include "PlayerBombIconPanelContext.h"

template <typename HookContext, typename Context = PlayerBombIconPanelContext<HookContext>>
class PlayerBombIconPanel {
public:
    template <typename... Args>
    explicit PlayerBombIconPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    [[nodiscard]] Visibility update(auto&& playerPawn) const noexcept
    {
        if (!context.shouldShowOnPlayer(playerPawn)) {
            context.panel().setVisible(false);
            return Visibility::Hidden;
        }

        context.panel().setVisible(true);
        const auto shouldShowPlantingColor = context.shouldShowPlantingColor(playerPawn);
        context.panel().children()[0].setVisible(!shouldShowPlantingColor);
        context.panel().children()[1].setVisible(shouldShowPlantingColor);
        return Visibility::Visible;
    }

private:
    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/BombIcon/PlayerBombIconPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
class PlayerBombIconPanelContext {
public:
    PlayerBombIconPanelContext(HookContext& hookContext, cs2::CUIPanel* panel) noexcept
        : hookContext{hookContext}
        , _panel{panel}
    {
    }

    [[nodiscard]] bool shouldShowOnPlayer(auto&& playerPawn) const noexcept
    {
        if (GET_CONFIG_VAR(player_info_vars::BombCarrierIconEnabled))
            return playerPawn.isCarryingC4();
        if (GET_CONFIG_VAR(player_info_vars::BombPlantIconEnabled))
            return playerPawn.carriedC4().isBeingPlanted().valueOr(false);
        return false;
    }

    [[nodiscard]] bool shouldShowPlantingColor(auto&& playerPawn) const noexcept
    {
        return GET_CONFIG_VAR(player_info_vars::BombPlantIconEnabled) && playerPawn.carriedC4().isBeingPlanted().valueOr(false);
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.featuresStates().visualFeaturesStates.playerInfoInWorldState;
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(_panel);
    }

private:
    HookContext& hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/BombIcon/PlayerBombIconPanelParams.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>
#include <CS2/Constants/ColorConstants.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace player_bomb_icon_panel_params::bomb_icon_panel_params
{
    static constexpr auto kImageUrl = "s2r://panorama/images/icons/equipment/c4.svg";
    static constexpr auto kTextureHeight = 24;
    static constexpr auto kShadowParams = PanelShadowParams{
        .horizontalOffset{cs2::CUILength::pixels(0)},
        .verticalOffset{cs2::CUILength::pixels(0)},
        .blurRadius{cs2::CUILength::pixels(3)},
        .strength = 3,
        .color{cs2::kColorBlack}
    };
}

namespace player_bomb_icon_panel_params::container_panel_params
{
    static constexpr auto kAlignment = PanelAlignmentParams{
        .verticalAlignment = cs2::k_EVerticalAlignmentCenter
    };
    static constexpr auto kMargin = PanelMarginParams{.marginLeft = cs2::CUILength::pixels(2.5), .marginRight = cs2::CUILength::pixels(2.5)};
    static constexpr auto kColorCarryingC4 = cs2::Color{255, 255, 77};
    static constexpr auto kColorPlantingC4 = cs2::Color{255, 193, 77};
}

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/PlayerWeaponIconPanel.h`:

```h
#pragma once

#include <utility>

#include "PlayerWeaponIconPanelContext.h"

template <typename HookContext, typename Context = PlayerWeaponIconPanelContext<HookContext>>
class PlayerWeaponIconPanel {
public:
    template <typename... Args>
    explicit PlayerWeaponIconPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void update(auto&& playerPawn) const noexcept
    {
        const auto bombIconPanelVisibility = context.bombIconPanel().update(playerPawn);
        context.activeWeaponIconPanel().update(playerPawn, bombIconPanelVisibility);
    }

private:
    Context context;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/PlayerWeaponIconPanelContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheEntry.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

#include "ActiveWeaponIcon/PlayerActiveWeaponIconPanel.h"
#include "BombIcon/PlayerBombIconPanel.h"

template <typename HookContext>
class PlayerWeaponIconPanelContext {
public:
    PlayerWeaponIconPanelContext(HookContext& hookContext, cs2::CUIPanel* panel, PlayerInfoPanelCacheEntry&) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
    {
    }

    [[nodiscard]] decltype(auto) activeWeaponIconPanel() const noexcept
    {
        return _hookContext.template make<PlayerActiveWeaponIconPanel>(panel().children()[0]);
    }

    [[nodiscard]] decltype(auto) bombIconPanel() const noexcept
    {
        return _hookContext.template make<PlayerBombIconPanel>(panel().children()[1]);
    }

private:
    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/Features/Visuals/PlayerInfoInWorld/PlayerWeaponIcon/PlayerWeaponIconPanelParams.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

namespace player_weapon_icon_panel_params
{
    static constexpr auto kChildrenFlow = cs2::k_EFlowRight;
    static constexpr auto kAlignment = PanelAlignmentParams{
        .horizontalAlignment = cs2::k_EHorizontalAlignmentCenter,
        .verticalAlignment = cs2::k_EVerticalAlignmentTop
    };
    static constexpr auto kMargin = PanelMarginParams{.marginTop = cs2::CUILength::pixels(3)};
}

```

`Source/Features/Visuals/ViewmodelMod/ViewmodelMod.h`:

```h
#pragma once

#include <optional>
#include <GameClient/Entities/PlayerPawn.h>
#include <HookContext/HookContextMacros.h>
#include "ViewmodelModConfigVariables.h"

template <typename HookContext>
class ViewmodelMod {
public:
    explicit ViewmodelMod(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] bool fovModificationActive() const
    {
        return GET_CONFIG_VAR(viewmodel_mod_vars::Enabled) && GET_CONFIG_VAR(viewmodel_mod_vars::ModifyFov);
    }

    [[nodiscard]] bool shouldModifyViewmodelFov() const
    {
        auto&& localPlayerPawn = hookContext.localPlayerController().pawn().template cast<PlayerPawn>();
        return localPlayerPawn && !localPlayerPawn.isScoped().valueOr(false);
    }

    [[nodiscard]] float viewmodelFov() const
    {
        return GET_CONFIG_VAR(viewmodel_mod_vars::Fov);
    }

private:
    HookContext& hookContext;
};

```

`Source/Features/Visuals/ViewmodelMod/ViewmodelModConfigVariables.h`:

```h
#pragma once

#include <Config/ConfigVariable.h>
#include "ViewmodelModParams.h"

namespace viewmodel_mod_vars
{

CONFIG_VARIABLE(Enabled, bool, false);
CONFIG_VARIABLE(ModifyFov, bool, true);
CONFIG_VARIABLE_RANGE(Fov, viewmodel_mod_params::kFov);

}

```

`Source/Features/Visuals/ViewmodelMod/ViewmodelModParams.h`:

```h
#pragma once

#include <cstdint>
#include <Config/RangeConstrainedVariableParams.h>

namespace viewmodel_mod_params
{

constexpr auto kFov = RangeConstrainedVariableParams<std::uint8_t>{.min = 40, .max = 90, .def = 80};
constexpr auto kPreviewFallbackFov = 54.0f;

}

```

`Source/Features/Visuals/VisualFeaturesStates.h`:

```h
#pragma once

#include "ModelGlow/ModelGlowState.h"
#include "PlayerInfoInWorld/PlayerInfoInWorldState.h"

struct VisualFeaturesStates {
    PlayerInfoInWorldState playerInfoInWorldState;
    ModelGlowState modelGlowState;
};

```

`Source/GameClient/ConVars/ConVarTypes.h`:

```h
#pragma once

#include <CS2/Classes/ConVarTypes.h>
#include <Utils/TypeList.h>

using ConVarTypes = TypeList<
    cs2::mp_teammates_are_enemies,
    cs2::viewmodel_fov,
    cs2::cl_crosshaircolor,
    cs2::cl_crosshaircolor_r,
    cs2::cl_crosshaircolor_g,
    cs2::cl_crosshaircolor_b
>;

```

`Source/GameClient/ConVars/ConVarsBase.h`:

```h
#pragma once

#include <array>
#include <tuple>

#include <CS2/Classes/ConVar.h>
#include <Utils/TypeIndex.h>
#include "ConVarTypes.h"

struct ConVarsBase {
    explicit ConVarsBase(auto&& cvarSystem) noexcept
    {
        ConVarTypes::forEach([i = std::size_t{0}, this, &cvarSystem] <typename ConVar> (std::type_identity<ConVar>) mutable {
            conVars[i++] = cvarSystem.findConVar(ConVar::kName);
        });
    }

    template <typename ConVar>
    [[nodiscard]] cs2::ConVar* getConVar() const noexcept
    {
        return conVars[ConVarTypes::indexOf<ConVar>()];
    }

private:
    std::array<cs2::ConVar*, ConVarTypes::size()> conVars;
};

```

`Source/GameClient/ConVars/CvarSystem.h`:

```h
#pragma once

#include <cstring>

#include <CS2/Classes/CCvar.h>
#include <CS2/Classes/ConVar.h>

template <typename HookContext>
class CvarSystem {
public:
    explicit CvarSystem(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] cs2::ConVar* findConVar(const char* name) const noexcept
    {
        const auto conVarList = getConVarList();
        if (!conVarList)
            return nullptr;

        for (auto i = conVarList->m_Head; i != conVarList->kInvalidIndex;) {
            const auto& node = conVarList->memory[i];
            const auto conVar = node.m_Element;
            if (std::strcmp(conVar->name, name) == 0)
                return conVar;
            i = node.m_Next;
        }
        return nullptr;
    }

    template <typename ConVarType>
    [[nodiscard]] auto getConVarValue() const
    {
        return getValue<ConVarType>(hookContext.getConVarsBase().template getConVar<ConVarType>());
    }

private:
    template <typename ConVarType>
    [[nodiscard]] std::optional<typename ConVarType::ValueType> getValue(cs2::ConVar* conVar) const
    {
        if (hookContext.patternSearchResults().template get<OffsetToConVarValueType>().of(conVar).toOptional().equal(conVarValueTypeForType<typename ConVarType::ValueType>()).valueOr(false))
            return readValueAs<typename ConVarType::ValueType>(conVar);
        return {};
    }

    template <typename T>
    [[nodiscard]] static consteval auto conVarValueTypeForType() noexcept
    {
        if constexpr (std::is_same_v<T, bool>)
            return cs2::ConVarValueType::boolean;
        else if constexpr (std::is_same_v<T, float>)
            return cs2::ConVarValueType::float32;
        else if constexpr (std::is_same_v<T, int>)
            return cs2::ConVarValueType::int32;
        else
            static_assert(!std::is_same_v<T, T>, "Unsupported type");
    }

    template <typename T>
    [[nodiscard]] std::optional<T> readValueAs(cs2::ConVar* conVar) const
    {
        const auto pointerToValue = hookContext.patternSearchResults().template get<OffsetToConVarValue>().of(conVar).get();
        if (!pointerToValue)
            return {};

        T value;
        std::memcpy(&value, pointerToValue, sizeof(value));
        return value;
    }

    [[nodiscard]] cs2::CCvar::ConVarList* getConVarList() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToConVarList>().of(cvar()).get();
    }

    [[nodiscard]] cs2::CCvar* cvar() const noexcept
    {
        if (const auto cvarPointer = hookContext.patternSearchResults().template get<CvarPointer>())
            return *cvarPointer;
        return nullptr;
    }

    HookContext& hookContext;
};

```

`Source/GameClient/Crosshair.h`:

```h
#pragma once

#include <CS2/Classes/ConVarTypes.h>
#include <CS2/Constants/ColorConstants.h>
#include <CS2/Constants/CrosshairColorIndex.h>
#include <HookContext/HookContextMacros.h>
#include <Utils/Optional.h>

template <typename HookContext>
class Crosshair {
public:
    explicit Crosshair(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] Optional<cs2::Color> getColor() const
    {
        if (const auto colorIndex = GET_CONVAR_VALUE(cs2::cl_crosshaircolor); colorIndex.has_value())
            return cs2::CrosshairColorIndex{*colorIndex} == cs2::CrosshairColorIndex::RGB ? colorRGB() : colorFixed(*colorIndex);
        return {};
    }

private:
    [[nodiscard]] Optional<cs2::Color> colorRGB() const
    {
        const auto r = GET_CONVAR_VALUE(cs2::cl_crosshaircolor_r);
        const auto g = GET_CONVAR_VALUE(cs2::cl_crosshaircolor_g);
        const auto b = GET_CONVAR_VALUE(cs2::cl_crosshaircolor_b);
        if (r.has_value() && g.has_value() && b.has_value())
            return cs2::Color{static_cast<std::uint8_t>(*r), static_cast<std::uint8_t>(*g), static_cast<std::uint8_t>(*b)};
        return {};
    }

    [[nodiscard]] static constexpr cs2::Color colorFixed(cs2::cl_crosshaircolor::ValueType colorIndex) noexcept
    {
        switch (cs2::CrosshairColorIndex{colorIndex}) {
        using enum cs2::CrosshairColorIndex;
        case Red: return cs2::kColorCrosshairRed;
        case Green: return cs2::kColorCrosshairGreen;
        case Yellow: return cs2::kColorCrosshairYellow;
        case Blue: return cs2::kColorCrosshairBlue;
        case Cyan: return cs2::kColorCrosshairCyan;
        default: return cs2::kColorCrosshairGreen;
        }
    }

    HookContext& hookContext;
};

```

`Source/GameClient/DLLs/Tier0Dll.h`:

```h
#pragma once

#include <CS2/Classes/CUtlFilenameSymbolTable.h>
#include <CS2/Constants/DllNames.h>
#include <Platform/DynamicLibrary.h>
#include <Platform/Macros/IsPlatform.h>

namespace cs2
{
    struct IMemAlloc;
}

struct Tier0Dll : DynamicLibrary {
    Tier0Dll() noexcept
        : DynamicLibrary{ cs2::TIER0_DLL }
    {
    }

    [[nodiscard]] cs2::CUtlFilenameSymbolTable::String* filenameSymbolTableString() const noexcept
    {
#if IS_WIN64()
        return getFunctionAddress("?String@CUtlFilenameSymbolTable@@QEAA_NAEBIPEADH@Z").as<cs2::CUtlFilenameSymbolTable::String*>();
#elif IS_LINUX()
        return getFunctionAddress("_ZN23CUtlFilenameSymbolTable6StringERKjPci").as<cs2::CUtlFilenameSymbolTable::String*>();
#endif
    }

    [[nodiscard]] cs2::IMemAlloc** memAlloc() const noexcept
    {
        return getFunctionAddress("g_pMemAlloc").as<cs2::IMemAlloc**>();
    }
};

```

`Source/GameClient/Econ/FauxItemId.h`:

```h
#pragma once

#include <CS2/Econ/ItemDefinitionIndex.h>
#include <CS2/Econ/ItemId.h>
#include <CS2/Econ/PaintKitIndex.h>
#include <Utils/ToUnderlying.h>

class FauxItemId {
public:
    constexpr FauxItemId(cs2::ItemDefinitionIndex itemDefinitionIndex, cs2::PaintKitIndex paintKitIndex = cs2::PaintKitIndex{}) noexcept
        : itemId{cs2::kFauxItemIdMask | toUnderlying(itemDefinitionIndex)
            | (toUnderlying(paintKitIndex) << cs2::kFauxItemIdPaintKitIndexShift)}
    {
    }

    [[nodiscard]] constexpr operator cs2::ItemId() const noexcept
    {
        return itemId;
    }

private:
    cs2::ItemId itemId;
};

```

`Source/GameClient/Entities/BaseEntity.h`:

```h
#pragma once

#include <optional>
#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Classes/EntitySystem/CEntityIdentity.h>
#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Constants/EntityHandle.h>
#include <CS2/Constants/SceneObjectAttributeNames.h>
#include <GameClient/Entities/LifeState.h>
#include <GameClient/Entities/TeamNumber.h>
#include <MemoryPatterns/PatternTypes/EntityPatternTypes.h>
#include <OutlineGlow/GlowSceneObjects.h>

#include <GameClient/EntitySystem/EntityIdentity.h>
#include <GameClient/GameSceneNode.h>
#include "RenderComponent.h"

template <typename HookContext>
class BaseEntity {
public:
    BaseEntity(HookContext& hookContext, cs2::C_BaseEntity* entity) noexcept
        : hookContext{hookContext}
        , entity{entity}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return *this;
    }

    [[nodiscard]] Optional<cs2::Vector> absOrigin() const noexcept
    {
        if (entity && hookContext.patternSearchResults().template get<GetAbsOriginFunction>())
            return *hookContext.patternSearchResults().template get<GetAbsOriginFunction>()(entity);
        return {};
    }

    [[nodiscard]] decltype(auto) entityIdentity() const noexcept
    {
        return hookContext.template make<EntityIdentity>(entity ? entity->identity : nullptr);
    }

    [[nodiscard]] decltype(auto) classify() const noexcept
    {
        return entityIdentity().classify();
    }

    template <template <typename...> typename T, typename... Args>
    [[nodiscard]] decltype(auto) as(Args&&... args) const noexcept
    {
        return hookContext.template make<T<HookContext>>(static_cast<typename T<HookContext>::RawType*>(entity), std::forward<Args>(args)...);
    }

    template <template <typename...> typename EntityType>
    [[nodiscard]] bool is() const noexcept
    {
        return entity && hookContext.entityClassifier().template entityIs<typename EntityType<HookContext>::RawType>(entity->identity->entityClass);
    }

    template <template <typename...> typename EntityType>
    [[nodiscard]] decltype(auto) cast() const noexcept
    {
        if (is<EntityType>())
            return hookContext.template make<EntityType<HookContext>>(static_cast<typename EntityType<HookContext>::RawType*>(entity));
        return hookContext.template make<EntityType<HookContext>>(nullptr);
    }

    [[nodiscard]] decltype(auto) renderComponent() const noexcept
    {
        return hookContext.template make<RenderComponent>(hookContext.patternSearchResults().template get<OffsetToRenderComponent>().of(entity).valueOr(nullptr));
    }

    [[nodiscard]] decltype(auto) gameSceneNode() const noexcept
    {
        return hookContext.template make<GameSceneNode>(hookContext.patternSearchResults().template get<OffsetToGameSceneNode>().of(entity).valueOr(nullptr));
    }

    template <typename F>
    void forEachChild(F f) const noexcept
    {
        gameSceneNode().forEachChild(invokeWithGameSceneNodeOwner(f));
    }

    [[nodiscard]] cs2::CEntityHandle handle() const noexcept
    {
        if (entity)
            return entity->identity->handle;
        return cs2::CEntityHandle{cs2::INVALID_EHANDLE_INDEX};
    }

    void applyGlowRecursively(cs2::Color color, int glowRange = 0) const noexcept
    {
        applyGlow(color, glowRange);
        forEachChild([color, glowRange](auto&& entity) { entity.applyGlow(color, glowRange); });
    }

    void applyGlow(cs2::Color color, int glowRange = 0) const noexcept
    {
        renderComponent().sceneObjectUpdaters().forEachSceneObject([this, color, glowRange](auto&& sceneObject) {
            // this will still show glow for 1 frame when switching spectators as the flags aren't updated yet
            // todo: do player glow in player scene object updater hook to fix it
            if (!sceneObject.isCulledByFirstPersonView().valueOr(false) && !sceneObject.isPartOfViewmodel().valueOr(false)) {
                auto&& glowSceneObject = hookContext.template make<GlowSceneObjects>().getGlowSceneObject(sceneObject);
                glowSceneObject.apply(sceneObject, color, glowRange);
                glowSceneObject.setGlowEntity(*this);
            }
        });
    }

    void applySpawnProtectionEffect(cs2::Color color) const noexcept
    {
        renderComponent().sceneObjectUpdaters().forEachSceneObject([color](auto&& sceneObject) {
            if (!sceneObject.isCulledByFirstPersonView().valueOr(false) && !sceneObject.isPartOfViewmodel().valueOr(false)) {
                auto&& sceneObjectAttributes = sceneObject.attributes();
                sceneObjectAttributes.setAttributeFloat(cs2::scene_object_attribute::kSpawnInvulnerabilityHash, 1.0f);
                sceneObjectAttributes.setAttributeColor3(cs2::scene_object_attribute::kInvulnerabilityColorHash, color);
            }
        });
    }

    void removeSpawnProtectionEffect() const noexcept
    {
        renderComponent().sceneObjectUpdaters().forEachSceneObject([](auto&& sceneObject) {
            sceneObject.attributes().setAttributeFloat(cs2::scene_object_attribute::kSpawnInvulnerabilityHash, 0.0f);
        });
    }

    void applySpawnProtectionEffectRecursively(cs2::Color color) const noexcept
    {
        applySpawnProtectionEffect(color);
        forEachChild([color](auto&& entity) { entity.applySpawnProtectionEffect(color); });
    }

    void removeSpawnProtectionEffectRecursively() const noexcept
    {
        removeSpawnProtectionEffect();
        forEachChild([](auto&& entity) { entity.removeSpawnProtectionEffect(); });
    }

    [[nodiscard]] auto hasOwner() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToOwnerEntity>().of(entity).toOptional().notEqual(cs2::CEntityHandle{cs2::INVALID_EHANDLE_INDEX});
    }

    [[nodiscard]] TeamNumber teamNumber() const noexcept
    {
        return TeamNumber{hookContext.patternSearchResults().template get<OffsetToTeamNumber>().of(entity).valueOr({})};
    }

    [[nodiscard]] auto vData() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToVData>().of(entity).toOptional();
    }

    [[nodiscard]] auto health() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToHealth>().of(entity).toOptional();
    }

    [[nodiscard]] std::optional<bool> isAlive() const noexcept
    {
        const auto lifestate = hookContext.patternSearchResults().template get<OffsetToLifeState>().of(entity).get();
        if (lifestate)
            return LifeState{*lifestate} == LifeState::Alive;
        return {};
    }

    operator cs2::C_BaseEntity*() const noexcept
    {
        return entity;
    }

private:
    [[nodiscard]] auto invokeWithGameSceneNodeOwner(auto& f) const noexcept
    {
        return [&f](auto&& gameSceneNode) { f(gameSceneNode.owner()); };
    }

    HookContext& hookContext;
    cs2::C_BaseEntity* entity;
};

```

`Source/GameClient/Entities/BaseModelEntity.h`:

```h
#pragma once

#include <CS2/Classes/Entities/C_BaseModelEntity.h>
#include <GameClient/Entities/BaseEntity.h>
#include <MemoryPatterns/PatternTypes/BaseModelEntityPatternTypes.h>

#include "GlowProperty.h"

template <typename HookContext>
class BaseModelEntity {
public:
    using RawType = cs2::C_BaseModelEntity;

    BaseModelEntity(HookContext& hookContext, cs2::C_BaseModelEntity* baseModelEntity) noexcept
        : hookContext{hookContext}
        , baseModelEntity{baseModelEntity}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntity>(baseModelEntity);
    }

    template <template <typename...> typename T>
    [[nodiscard]] decltype(auto) as() const noexcept
    {
        return hookContext.template make<T<HookContext>>(static_cast<typename T<HookContext>::RawType*>(baseModelEntity));
    }

    [[nodiscard]] decltype(auto) glowProperty() const noexcept
    {
        return hookContext.template make<GlowProperty>(hookContext.patternSearchResults().template get<OffsetToGlowProperty>().of(baseModelEntity).get());
    }

private:
    HookContext& hookContext;
    cs2::C_BaseModelEntity* baseModelEntity;
};

```

`Source/GameClient/Entities/BaseWeapon.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <CS2/Classes/CCSWeaponBaseVData.h>
#include <MemoryPatterns/PatternTypes/WeaponPatternTypes.h>
#include <MemoryPatterns/PatternTypes/WeaponVDataPatternTypes.h>
#include "BaseEntity.h"
#include "EntityClassifier.h"

template <typename HookContext>
class BaseWeapon {
public:
    BaseWeapon(HookContext& hookContext, cs2::C_CSWeaponBase* baseWeapon) noexcept
        : hookContext{hookContext}
        , baseWeapon{baseWeapon}
    {
    }

    using RawType = cs2::C_CSWeaponBase;

    template <template <typename...> typename EntityType>
    [[nodiscard]] bool is() const noexcept
    {
        return baseEntity().template is<EntityType>();
    }

    template <template <typename...> typename EntityType>
    [[nodiscard]] decltype(auto) cast() const noexcept
    {
        return baseEntity().template cast<EntityType>();
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntity>(baseWeapon);
    }

    [[nodiscard]] bool isSniperRifle() const noexcept
    {
        switch (baseEntity().classify().typeIndex) {
        case EntityTypeInfo::indexOf<cs2::C_WeaponSSG08>():
        case EntityTypeInfo::indexOf<cs2::C_WeaponAWP>():
        case EntityTypeInfo::indexOf<cs2::C_WeaponG3SG1>():
        case EntityTypeInfo::indexOf<cs2::C_WeaponSCAR20>(): return true;
        default: return false;
        }
    }

    [[nodiscard]] auto bulletInaccuracy() const noexcept
    {
        return inaccuracy() + spread();
    }

    [[nodiscard]] auto getName() const noexcept
    {
        const auto vData = static_cast<cs2::CCSWeaponBaseVData*>(hookContext.template make<BaseEntity>(baseWeapon).vData().valueOr(nullptr));
        return hookContext.patternSearchResults().template get<OffsetToWeaponName>().of(vData).valueOr(nullptr);
    }

    [[nodiscard]] auto clipAmmo() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToClipAmmo>().of(baseWeapon).toOptional();
    }

    [[nodiscard]] auto getSceneObjectUpdater() const noexcept
    {
        return reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(sceneObjectUpdaterHandle() ? sceneObjectUpdaterHandle()->updaterFunction : nullptr);
    }

    void setSceneObjectUpdater(auto x) const noexcept
    {
        if (sceneObjectUpdaterHandle())
            sceneObjectUpdaterHandle()->updaterFunction = reinterpret_cast<std::uint64_t(*)(void*, void*, bool)>(x);
    }

private:
    [[nodiscard]] Optional<float> inaccuracy() const noexcept
    {
        const auto getInaccuracyFn = hookContext.patternSearchResults().template get<PointerToGetInaccuracyFunction>();
        if (baseWeapon && getInaccuracyFn)
            return getInaccuracyFn(baseWeapon, nullptr, nullptr);
        return {};
    }

    [[nodiscard]] Optional<float> spread() const noexcept
    {
        const auto getSpreadFn = hookContext.patternSearchResults().template get<PointerToGetSpreadFunction>();
        if (baseWeapon && getSpreadFn)
            return getSpreadFn(baseWeapon);
        return {};
    }

    [[nodiscard]] auto sceneObjectUpdaterHandle() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToWeaponSceneObjectUpdaterHandle>().of(baseWeapon).valueOr(nullptr);
    }

    HookContext& hookContext;
    cs2::C_CSWeaponBase* baseWeapon;
};

```

`Source/GameClient/Entities/C4.h`:

```h
#pragma once

#include <CS2/Classes/Entities/WeaponEntities.h>
#include <MemoryPatterns/PatternTypes/C4PatternTypes.h>
#include "BaseWeapon.h"

template <typename HookContext>
class C4 {
public:
    C4(HookContext& hookContext, cs2::C_C4* c4) noexcept
        : hookContext{hookContext}
        , c4{c4}
    {
    }

    [[nodiscard]] decltype(auto) baseWeapon() const noexcept
    {
        return hookContext.template make<BaseWeapon>(c4);
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return c4 != nullptr;
    }

    [[nodiscard]] decltype(auto) isBeingPlanted() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToIsBeingPlanted>().of(c4);
    }

    [[nodiscard]] decltype(auto) armingEndTime() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToArmingEndTime>().of(c4).toOptional();
    }

    [[nodiscard]] decltype(auto) nearestBombsiteIndex() const
    {
        return baseWeapon().baseEntity().absOrigin().andThen(toNearestBombsiteIndex());
    }

    [[nodiscard]] decltype(auto) timeToArmingEnd() const
    {
        return armingEndTime() - hookContext.globalVars().curtime();
    }

    using RawType = cs2::C_C4;

private:
    [[nodiscard]] auto toNearestBombsiteIndex() const noexcept
    {
        return [this](const auto& position) {
            return hookContext.playerResource().nearestBombsiteIndex(position);
        };
    }

    HookContext& hookContext;
    cs2::C_C4* c4;
};

```

`Source/GameClient/Entities/EntityClassifier.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <functional>
#include <iterator>
#include <limits>
#include <tuple>
#include <type_traits>

#include <CS2/Classes/Entities/C_BaseCSGrenadeProjectile.h>
#include <CS2/Classes/Entities/C_BaseModelEntity.h>
#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <CS2/Classes/EntitySystem/CEntityClass.h>
#include <CS2/Constants/EntityClasses.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <Utils/TypeIndex.h>

struct EntityTypeInfo {
    using Index = std::uint8_t;
    static_assert((std::numeric_limits<Index>::max)() >= std::tuple_size_v<cs2::EntityClasses>, "Index type is too small");

    Index typeIndex{(std::numeric_limits<Index>::max)()};

    [[nodiscard]] constexpr bool isWeapon() const noexcept
    {
        return EntityBaseTypeInfo<cs2::C_CSWeaponBase>::isBaseOf(typeIndex);
    }

    [[nodiscard]] constexpr bool isGrenadeProjectile() const noexcept
    {
        return EntityBaseTypeInfo<cs2::C_BaseCSGrenadeProjectile>::isBaseOf(typeIndex);
    }

    [[nodiscard]] constexpr bool isModelEntity() const noexcept
    {
        return EntityBaseTypeInfo<cs2::C_BaseModelEntity>::isBaseOf(typeIndex);
    }

    template <typename EntityType>
    [[nodiscard]] constexpr bool is() const noexcept
    {
        return typeIndex == indexOf<EntityType>();
    }

    template <typename EntityType>
    [[nodiscard]] static constexpr auto indexOf() noexcept
    {
        return utils::typeIndex<EntityType, cs2::EntityClasses>();
    }

private:
    template <typename BaseEntityType>
    struct EntityBaseTypeInfo {
        [[nodiscard]] static constexpr bool isBaseOf(Index typeIndex) noexcept
        {
            if (typeIndex < kIsBase.size())
                return kIsBase[typeIndex];
            return false;
        }

        static constexpr auto kIsBase{
            []<typename... EntityTypes>(std::type_identity<std::tuple<EntityTypes...>>) {
                return std::array<bool, sizeof...(EntityTypes)>{
                    std::is_base_of_v<BaseEntityType, EntityTypes>...
                };
            }(std::type_identity<cs2::EntityClasses>{})
        };
    };
};

class EntityClassifier {
public:
    void init(auto& hookContext) noexcept
    {
        cs2::kEntityClassNames.forEach([i = 0u, &hookContext, this](const auto typeName) mutable {
            const auto entityClass = hookContext.template make<EntitySystem>().findEntityClass(typeName);
            auto j = i;
            while (j > 0 && std::less{}(entityClass, entityClasses[j - 1])) {
                entityClasses[j] = entityClasses[j - 1];
                entityClassIndexToTypeIndex[j] = entityClassIndexToTypeIndex[j - 1];
                --j;
            }
            entityClasses[j] = entityClass;
            entityClassIndexToTypeIndex[j] = static_cast<EntityTypeInfo::Index>(i);
            ++i;
        });

        for (std::size_t i = 0; i < std::tuple_size_v<cs2::EntityClasses>; ++i)
            entityTypeIndexToClassIndex[entityClassIndexToTypeIndex[i]] = static_cast<EntityTypeInfo::Index>(i);
    }

    template <typename EntityType>
    [[nodiscard]] bool entityIs(const cs2::CEntityClass* entityClass) const noexcept
    {
        return entityClass != nullptr && entityClass == entityClasses[entityTypeIndexToClassIndex[utils::typeIndex<EntityType, cs2::EntityClasses>()]];
    }

    [[nodiscard]] EntityTypeInfo classifyEntity(const cs2::CEntityClass* entityClass) const noexcept
    {
        if (entityClass == nullptr)
            return {};

        const auto it = std::ranges::lower_bound(entityClasses, entityClass);
        if (it != entityClasses.end() && *it == entityClass)
            return EntityTypeInfo{entityClassIndexToTypeIndex[std::distance(entityClasses.begin(), it)]};
        return {};
    }

private:
    std::array<const cs2::CEntityClass*, std::tuple_size_v<cs2::EntityClasses>> entityClasses;
    std::array<EntityTypeInfo::Index, std::tuple_size_v<cs2::EntityClasses>> entityTypeIndexToClassIndex;
    std::array<EntityTypeInfo::Index, std::tuple_size_v<cs2::EntityClasses>> entityClassIndexToTypeIndex;
};

```

`Source/GameClient/Entities/GameRules.h`:

```h
#pragma once

#include <CS2/Classes/C_CSGameRules.h>
#include <MemoryPatterns/PatternTypes/GameRulesPatternTypes.h>

template <typename HookContext>
class GameRules {
public:
    GameRules(HookContext& hookContext, cs2::C_CSGameRules* gameRules) noexcept
        : hookContext{hookContext}
        , gameRules{gameRules}
    {
    }

    [[nodiscard]] auto roundStartTime() const noexcept
    {
        return hookContext.patternSearchResults().template get<RoundStartTimeOffset>().of(gameRules).toOptional();
    }

    [[nodiscard]] auto roundRestartTime() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToRoundRestartTime>().of(gameRules).toOptional();
    }

    [[nodiscard]] bool hasScheduledRoundRestart() const noexcept
    {
        return roundRestartTime().greaterThan(0.0f).valueOr(false);
    }

    [[nodiscard]] auto timeToRoundRestart() const noexcept
    {
        return roundRestartTime() - hookContext.globalVars().curtime();
    }

    [[nodiscard]] auto roundEndTime() const noexcept
    {
        return roundStartTime() + roundLength();
    }

    [[nodiscard]] auto isRoundOver() const
    {
        return roundWinStatus().notEqual(cs2::RoundWinStatus::None);
    }

private:
    [[nodiscard]] auto roundWinStatus() const
    {
        return hookContext.patternSearchResults().template get<OffsetToRoundWinStatus>().of(gameRules).toOptional();
    }

    [[nodiscard]] auto roundLength() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToRoundLength>().of(gameRules).toOptional();
    }

    HookContext& hookContext;
    cs2::C_CSGameRules* gameRules;
};

```

`Source/GameClient/Entities/GlowProperty.h`:

```h
#pragma once

#include <CS2/Classes/CGlowProperty.h>
#include <MemoryPatterns/PatternTypes/GlowPropertyPatternTypes.h>

template <typename HookContext>
class GlowProperty {
public:
    GlowProperty(HookContext& hookContext, cs2::CGlowProperty* glowProperty) noexcept
        : hookContext{hookContext}
        , glowProperty{glowProperty}
    {
    }

    [[nodiscard]] decltype(auto) isGlowing() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToIsGlowing>().of(glowProperty).toOptional();
    }

private:
    HookContext& hookContext;
    cs2::CGlowProperty* glowProperty;
};

```

`Source/GameClient/Entities/HostageServices.h`:

```h
#pragma once

#include <CS2/Classes/CCSPlayer_HostageServices.h>
#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Constants/EntityHandle.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <MemoryPatterns/PatternTypes/HostageServicesPatternTypes.h>

template <typename HookContext>
class HostageServices {
public:
    HostageServices(HookContext& hookContext, cs2::CCSPlayer_HostageServices* hostageServices) noexcept
        : hookContext{hookContext}
        , hostageServices{hostageServices}
    {
    }

    [[nodiscard]] bool hasCarriedHostage() const noexcept
    {
        return hookContext.template make<EntitySystem>().getEntityFromHandle(hookContext.patternSearchResults().template get<OffsetToCarriedHostage>().of(hostageServices).valueOr(cs2::CEntityHandle{cs2::INVALID_EHANDLE_INDEX})) != nullptr;
    }

private:
    HookContext& hookContext;
    cs2::CCSPlayer_HostageServices* hostageServices;
};

```

`Source/GameClient/Entities/LifeState.h`:

```h
#pragma once

#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Constants/LifeStateConstants.h>

enum class LifeState : cs2::C_BaseEntity::m_lifeState {
    Alive = cs2::LIFE_ALIVE
};

```

`Source/GameClient/Entities/PlantedC4.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/CPlantedC4.h>
#include <CS2/Constants/BombsiteIndex.h>
#include <CS2/Constants/EntityHandle.h>
#include <CS2/Constants/IconURLs.h>
#include <MemoryPatterns/PatternTypes/PlantedC4PatternTypes.h>

#include "BaseEntity.h"

template <typename HookContext>
class PlantedC4 {
public:
    using RawType = cs2::CPlantedC4;

    PlantedC4(HookContext& hookContext, cs2::CPlantedC4* plantedC4) noexcept
        : hookContext{hookContext}
        , plantedC4{plantedC4}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntity>(plantedC4);
    }

    [[nodiscard]] auto getTimeToExplosion() const noexcept
    {
        return blowTime() - curtime();
    }

    [[nodiscard]] auto isTicking() const noexcept
    {
        return hookContext.patternSearchResults().template get<BombTickingOffset>().of(plantedC4).toOptional();
    }

    [[nodiscard]] bool isBeingDefused() const noexcept
    {
        return defuser().valueOr(cs2::INVALID_EHANDLE_INDEX) != cs2::INVALID_EHANDLE_INDEX;
    }

    [[nodiscard]] auto canBeDefused() const noexcept
    {
        return defuseEndTime().lessThan(blowTime());
    }

    [[nodiscard]] auto getTimeToDefuseEnd() const noexcept
    {
        return defuseEndTime() - curtime();
    }

    [[nodiscard]] auto bombsiteIndex() const noexcept
    {
        return baseEntity().absOrigin().andThen(toNearestBombsiteIndex());
    }

private:
    [[nodiscard]] auto toNearestBombsiteIndex() const noexcept
    {
        return [this](const auto& position) {
            return hookContext.playerResource().nearestBombsiteIndex(position);
        };
    }

    [[nodiscard]] auto blowTime() const noexcept
    {
        return hookContext.patternSearchResults().template get<BombBlowTimeOffset>().of(plantedC4).toOptional();
    }

    [[nodiscard]] auto defuser() const noexcept
    {
        return hookContext.patternSearchResults().template get<BombDefuserOffset>().of(plantedC4);
    }

    [[nodiscard]] auto defuseEndTime() const noexcept
    {
        return hookContext.patternSearchResults().template get<BombDefuseEndTimeOffset>().of(plantedC4).toOptional();
    }

    [[nodiscard]] decltype(auto) curtime() const noexcept
    {
        return hookContext.globalVars().curtime();
    }

    HookContext& hookContext;
    cs2::CPlantedC4* plantedC4;
};

```

`Source/GameClient/Entities/PlayerController.h`:

```h
#pragma once

#include <optional>
#include <span>
#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <CS2/Constants/ColorConstants.h>
#include <GameClient/Entities/BaseEntity.h>
#include <GameClient/Entities/TeamNumber.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <MemoryPatterns/PatternTypes/PlayerControllerPatternTypes.h>
#include "PlayerPawn.h"

template <typename HookContext>
class PlayerController {
public:
    PlayerController(HookContext& hookContext, cs2::CCSPlayerController* playerControllerPointer) noexcept
        : hookContext{hookContext}
        , playerControllerPointer{playerControllerPointer}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntity>(playerControllerPointer);
    }

    [[nodiscard]] bool operator==(const PlayerController& other) const noexcept
    {
        return playerControllerPointer != nullptr && playerControllerPointer == other.playerControllerPointer;
    }

    [[nodiscard]] TeamNumber teamNumber() const noexcept
    {
        return baseEntity().teamNumber();
    }

    [[nodiscard]] decltype(auto) pawn() const noexcept
    {
        const auto playerPawnHandle = hookContext.patternSearchResults().template get<OffsetToBasePawnHandle>().of(playerControllerPointer).get();
        if (!playerPawnHandle)
            return hookContext.template make<BaseEntity>(nullptr);
        return hookContext.template make<EntitySystem>().getEntityFromHandle2(*playerPawnHandle);
    }

    [[nodiscard]] decltype(auto) playerColorIndex() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToPlayerColor>().of(playerControllerPointer).toOptional();
    }

private:
    HookContext& hookContext;
    cs2::CCSPlayerController* playerControllerPointer;
};

```

`Source/GameClient/Entities/PlayerPawn.h`:

```h
#pragma once

#include <algorithm>
#include <cstdint>
#include <optional>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <CS2/Classes/ConVarTypes.h>
#include <GameClient/Entities/TeamNumber.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <MemoryPatterns/PatternTypes/PlayerPawnPatternTypes.h>
#include <Utils/ColorUtils.h>

#include "BaseEntity.h"
#include "C4.h"
#include "HostageServices.h"
#include "WeaponServices.h"

class EntityFromHandleFinder;

template <typename HookContext>
class PlayerController;

template <typename HookContext>
class PlayerPawn {
public:
    using RawType = cs2::C_CSPlayerPawn;

    PlayerPawn(HookContext& hookContext, cs2::C_CSPlayerPawn* playerPawn) noexcept
        : hookContext{hookContext}
        , playerPawn{playerPawn}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntity>(playerPawn);
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return playerPawn != nullptr;
    }

    template <template <typename...> typename EntityType>
    [[nodiscard]] decltype(auto) cast() const noexcept
    {
        if (baseEntity().template is<EntityType>())
            return hookContext.template make<EntityType<HookContext>>(static_cast<typename EntityType<HookContext>::RawType*>(playerPawn));
        return hookContext.template make<EntityType<HookContext>>(nullptr);
    }

    [[nodiscard]] decltype(auto) weaponServices() const noexcept
    {
        return hookContext.template make<WeaponServices>(hookContext.patternSearchResults().template get<OffsetToWeaponServices>().of(playerPawn).valueOr(nullptr));
    }

    [[nodiscard]] decltype(auto) weapons() const noexcept
    {
        return weaponServices().weapons();
    }

    [[nodiscard]] TeamNumber teamNumber() const noexcept
    {
        return baseEntity().teamNumber();
    }

    [[nodiscard]] std::optional<bool> isAlive() const noexcept
    {
        return baseEntity().isAlive();
    }

    [[nodiscard]] decltype(auto) playerController() const noexcept
    {
        const auto playerControllerHandle = hookContext.patternSearchResults().template get<OffsetToPlayerController>().of(playerPawn).get();
        if (!playerControllerHandle)
            return hookContext.template make<PlayerController>(nullptr);
        return hookContext.template make<PlayerController>(static_cast<cs2::CCSPlayerController*>(hookContext.template make<EntitySystem>().getEntityFromHandle(*playerControllerHandle)));
    }

    [[nodiscard]] auto health() const noexcept
    {
        return baseEntity().health();
    }

    [[nodiscard]] auto hasImmunity() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToPlayerPawnImmunity>().of(playerPawn).toOptional();
    }

    [[nodiscard]] decltype(auto) absOrigin() const noexcept
    {
        return baseEntity().absOrigin();
    }

    [[nodiscard]] bool isControlledByLocalPlayer() const noexcept
    {
        return playerController() == hookContext.localPlayerController();
    }

    [[nodiscard]] std::optional<bool> isEnemy() const noexcept
    {
        return teamNumber() != hookContext.localPlayerController().teamNumber() || teammatesAreEnemies();
    }

    [[nodiscard]] bool isTTorCT() const noexcept
    {
        const auto _teamNumber = teamNumber();
        return _teamNumber == TeamNumber::TT || _teamNumber == TeamNumber::CT;
    }

    [[nodiscard]] auto isPickingUpHostage() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToIsPickingUpHostage>().of(playerPawn).toOptional();
    }

    [[nodiscard]] auto isDefusing() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToIsDefusing>().of(playerPawn).toOptional();
    }

    [[nodiscard]] auto isScoped() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToIsScoped>().of(playerPawn).toOptional();
    }

    [[nodiscard]] bool isRescuingHostage() const noexcept
    {
        return hostageServices().hasCarriedHostage();
    }

    [[nodiscard]] bool isCarryingC4() const noexcept
    {
        return weapons().template has<C4>();
    }

    [[nodiscard]] decltype(auto) carriedC4() const noexcept
    {
        return weapons().template get<C4>();
    }

    [[nodiscard]] float getRemainingFlashBangTime() const noexcept
    {
        const auto curTime = hookContext.globalVars().curtime();
        if (!curTime.hasValue())
            return 0.0f;
        const auto flashBangEndTime = hookContext.patternSearchResults().template get<OffsetToFlashBangEndTime>().of(playerPawn).get();
        if (!flashBangEndTime)
            return 0.0f;
        if (*flashBangEndTime <= curTime.value())
            return 0.0f;
        return *flashBangEndTime - curTime.value();
    }

    [[nodiscard]] decltype(auto) getActiveWeapon() const noexcept
    {
        return weaponServices().getActiveWeapon();
    }

    [[nodiscard]] auto getSceneObjectUpdater() const noexcept
    {
        return reinterpret_cast<std::uint64_t(*)(cs2::C_CSPlayerPawn*, void*, bool)>(sceneObjectUpdaterHandle() ? sceneObjectUpdaterHandle()->updaterFunction : nullptr);
    }

    void setSceneObjectUpdater(auto x) const noexcept
    {
        if (sceneObjectUpdaterHandle())
            sceneObjectUpdaterHandle()->updaterFunction = reinterpret_cast<std::uint64_t(*)(void*, void*, bool)>(x);
    }

    [[nodiscard]] decltype(auto) isUsingSniperRifle() const
    {
        return getActiveWeapon().isSniperRifle();
    }

private:
    [[nodiscard]] auto sceneObjectUpdaterHandle() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToPlayerPawnSceneObjectUpdaterHandle>().of(playerPawn).valueOr(nullptr);
    }

    [[nodiscard]] decltype(auto) hostageServices() const noexcept
    {
        return hookContext.template make<HostageServices>(hookContext.patternSearchResults().template get<OffsetToHostageServices>().of(playerPawn).valueOr(nullptr));
    }

    [[nodiscard]] bool teammatesAreEnemies() const noexcept
    {
        return hookContext.cvarSystem().template getConVarValue<cs2::mp_teammates_are_enemies>().value_or(true);
    }

    HookContext& hookContext;
    cs2::C_CSPlayerPawn* playerPawn;
};

```

`Source/GameClient/Entities/PlayerResource.h`:

```h
#pragma once

template <typename HookContext>
class PlayerResource {
public:
    PlayerResource(HookContext& hookContext, cs2::C_CSPlayerResource* playerResource) noexcept
        : hookContext{hookContext}
        , playerResource{playerResource}
    {
    }

    [[nodiscard]] auto nearestBombsiteIndex(const cs2::Vector& position) const
    {
        return distToBombsiteA(position).lessThan(distToBombsiteB(position)).transform(toBombsiteIndex());
    }

private:
    [[nodiscard]] auto distToBombsiteA(const cs2::Vector& position) const
    {
        return bombsiteACenter().transform(squareDistTo(position));
    }

    [[nodiscard]] auto distToBombsiteB(const cs2::Vector& position) const
    {
        return bombsiteBCenter().transform(squareDistTo(position));
    }

    [[nodiscard]] auto bombsiteACenter() const
    {
        return hookContext.patternSearchResults().template get<OffsetToBombsiteACenter>().of(playerResource).toOptional();
    }

    [[nodiscard]] auto bombsiteBCenter() const
    {
        return hookContext.patternSearchResults().template get<OffsetToBombsiteBCenter>().of(playerResource).toOptional();
    }

    [[nodiscard]] static auto toBombsiteIndex() noexcept
    {
        return [](bool isBombsiteA) {
            return isBombsiteA ? cs2::BombsiteIndex::BombsiteA : cs2::BombsiteIndex::BombsiteB;
        };
    }

    [[nodiscard]] static auto squareDistTo(const cs2::Vector& position) noexcept
    {
        return [&position](const cs2::Vector& bombsiteCenter) {
            return position.squareDistTo(bombsiteCenter);
        };
    }

    HookContext& hookContext;
    cs2::C_CSPlayerResource* playerResource;
};

```

`Source/GameClient/Entities/PlayerWeapons.h`:

```h
#pragma once

#include <CS2/Classes/CUtlVector.h>
#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <Utils/Lvalue.h>

#include "BaseEntity.h"

template <typename HookContext>
class PlayerWeapons {
public:
    PlayerWeapons(HookContext& hookContext, cs2::CUtlVector<cs2::CEntityHandle>* weaponHandles) noexcept
        : hookContext{hookContext}
        , weaponHandles{weaponHandles}
    {
    }

    template <template <typename...> typename WeaponType>
    [[nodiscard]] bool has() const noexcept
    {
        if (!weaponHandles)
            return false;

        for (int i = 0; i < weaponHandles->size; ++i) {
            auto&& weapon = hookContext.template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(hookContext.template make<EntitySystem>().getEntityFromHandle(weaponHandles->memory[i]))).template cast<WeaponType>();
            if (weapon)
                return true;
        }
        return false;
    }

    template <template <typename...> typename WeaponType>
    [[nodiscard]] decltype(auto) get() const noexcept
    {
        if (!weaponHandles)
            return hookContext.template make<WeaponType<HookContext>>(nullptr);

        for (int i = 0; i < weaponHandles->size; ++i) {
            auto&& weapon = hookContext.template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(hookContext.template make<EntitySystem>().getEntityFromHandle(weaponHandles->memory[i]))).template cast<WeaponType>();
            if (weapon)
                return utils::lvalue<decltype(weapon)>(weapon);
        }
        return hookContext.template make<WeaponType<HookContext>>(nullptr);
    }

    template <typename F>
    void forEach(F f) const noexcept
    {
        if (!weaponHandles)
            return;

        for (int i = 0; i < weaponHandles->size; ++i) {
            auto&& weaponEntity = hookContext.template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(hookContext.template make<EntitySystem>().getEntityFromHandle(weaponHandles->memory[i])));
            if (weaponEntity)
                f(weaponEntity);
        }
    }

private:
    HookContext& hookContext;
    cs2::CUtlVector<cs2::CEntityHandle>* weaponHandles;
};

```

`Source/GameClient/Entities/PreviewPlayer.h`:

```h
#pragma once

#include <CS2/Classes/Entities/C_CSGO_PreviewPlayer.h>
#include "BaseEntity.h"

template <typename HookContext>
class PreviewPlayer {
public:
    using RawType = cs2::C_CSGO_PreviewPlayer;

    PreviewPlayer(HookContext& hookContext, cs2::C_CSGO_PreviewPlayer* previewPlayer) noexcept
        : hookContext{hookContext}
        , previewPlayer{previewPlayer}
    {
    }

    [[nodiscard]] decltype(auto) baseEntity() const noexcept
    {
        return hookContext.template make<BaseEntity>(previewPlayer);
    }

    [[nodiscard]] operator cs2::C_CSGO_PreviewPlayer*() const noexcept
    {
        return previewPlayer;
    }

private:
    HookContext& hookContext;
    cs2::C_CSGO_PreviewPlayer* previewPlayer;
};

```

`Source/GameClient/Entities/RenderComponent.h`:

```h
#pragma once

#include <CS2/Classes/CRenderComponent.h>
#include <GameClient/SceneSystem/SceneObjectUpdaters.h>
#include <MemoryPatterns/PatternTypes/RenderComponentPatternTypes.h>

template <typename HookContext>
class RenderComponent {
public:
    RenderComponent(HookContext& hookContext, cs2::CRenderComponent* renderComponent) noexcept
        : hookContext{hookContext}
        , renderComponent{renderComponent}
    {
    }

    [[nodiscard]] decltype(auto) sceneObjectUpdaters() const noexcept
    {
        return hookContext.template make<SceneObjectUpdaters>(hookContext.patternSearchResults().template get<OffsetToSceneObjectUpdaters>().of(renderComponent).get());
    }

private:
    HookContext& hookContext;
    cs2::CRenderComponent* renderComponent;
};

```

`Source/GameClient/Entities/SmokeGrenadeProjectile.h`:

```h
#pragma once

#include <CS2/Classes/Entities/GrenadeProjectiles.h>
#include <MemoryPatterns/PatternTypes/SmokeGrenadeProjectilePatternTypes.h>

template <typename HookContext>
class SmokeGrenadeProjectile {
public:
    SmokeGrenadeProjectile(HookContext& hookContext, cs2::C_SmokeGrenadeProjectile* smokeGrenadeProjectile) noexcept
        : hookContext{hookContext}
        , smokeGrenadeProjectile{smokeGrenadeProjectile}
    {
    }

    using RawType = cs2::C_SmokeGrenadeProjectile;

    [[nodiscard]] auto didSmokeEffect() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToDidSmokeEffect>().of(smokeGrenadeProjectile).toOptional();
    }

private:
    HookContext& hookContext;
    cs2::C_SmokeGrenadeProjectile* smokeGrenadeProjectile;
};

```

`Source/GameClient/Entities/TeamNumber.h`:

```h
#pragma once

#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Constants/TeamNumberConstants.h>

enum class TeamNumber : cs2::C_BaseEntity::m_iTeamNum {
    TT = cs2::TEAM_TERRORIST,
    CT = cs2::TEAM_CT
};

```

`Source/GameClient/Entities/WeaponServices.h`:

```h
#pragma once

#include <CS2/Classes/CCSPlayer_WeaponServices.h>
#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Constants/EntityHandle.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <MemoryPatterns/PatternTypes/WeaponServicesPatternTypes.h>
#include "BaseWeapon.h"
#include "PlayerWeapons.h"

template <typename HookContext>
class WeaponServices {
public:
    WeaponServices(HookContext& hookContext, cs2::CCSPlayer_WeaponServices* weaponServices) noexcept
        : hookContext{hookContext}
        , weaponServices{weaponServices}
    {
    }

    [[nodiscard]] decltype(auto) weapons() const noexcept
    {
        return hookContext.template make<PlayerWeapons>(hookContext.patternSearchResults().template get<OffsetToWeapons>().of(weaponServices).get());
    }

    [[nodiscard]] auto getActiveWeapon() const noexcept
    {
        return hookContext.template make<BaseWeapon>(static_cast<cs2::C_CSWeaponBase*>(hookContext.template make<EntitySystem>().getEntityFromHandle(hookContext.patternSearchResults().template get<OffsetToActiveWeapon>().of(weaponServices).valueOr(cs2::CEntityHandle{cs2::INVALID_EHANDLE_INDEX}))));
    }

private:
    HookContext& hookContext;
    cs2::CCSPlayer_WeaponServices* weaponServices;
};

```

`Source/GameClient/EntitySystem/EntityHandle.h`:

```h
#pragma once

#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <Utils/Lvalue.h>

template <typename HookContext>
class EntityHandle {
public:
    EntityHandle(HookContext& hookContext, cs2::CEntityHandle& handle)
        : hookContext{hookContext}
        , handle{handle}
    {
    }

    [[nodiscard]] decltype(auto) getOrInit(auto&& onGet, auto&& init)
    {
        if (auto&& entity = hookContext.template make<EntitySystem>().getEntityFromHandle2(handle)) {
            onGet();
            return utils::lvalue<decltype(entity)>(entity);
        }

        handle = init();
        auto&& entity = hookContext.template make<EntitySystem>().getEntityFromHandle2(handle);
        if (entity)
            onGet();
        return utils::lvalue<decltype(entity)>(entity);
    }

private:
    HookContext& hookContext;
    cs2::CEntityHandle& handle;
};

```

`Source/GameClient/EntitySystem/EntityIdentity.h`:

```h
#pragma once

#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Classes/EntitySystem/CEntityIdentity.h>

template <typename HookContext>
class BaseEntity;

template <typename HookContext>
class EntityIdentity {
public:
    EntityIdentity(HookContext& hookContext, cs2::CEntityIdentity* identity) noexcept
        : hookContext{hookContext}
        , identity{identity}
    {
    }

    template <typename RawEntityType>
    [[nodiscard]] bool is() const noexcept
    {
        if (identity)
            return hookContext.entityClassifier().template entityIs<RawEntityType>(identity->entityClass);
        return false;
    }

    [[nodiscard]] decltype(auto) classify() const noexcept
    {
        return hookContext.entityClassifier().classifyEntity(identity ? identity->entityClass : nullptr);
    }

    [[nodiscard]] decltype(auto) entity() const noexcept
    {
        return hookContext.template make<BaseEntity>(identity ? static_cast<cs2::C_BaseEntity*>(identity->entity) : nullptr);
    }

private:
    HookContext& hookContext;
    cs2::CEntityIdentity* identity;
};

```

`Source/GameClient/EntitySystem/EntitySystem.h`:

```h
#pragma once

#include <cstring>

#include <CS2/Classes/Entities/CEntityInstance.h>
#include <CS2/Classes/EntitySystem/CConcreteEntityList.h>
#include <CS2/Classes/EntitySystem/CEntityClass.h>
#include <CS2/Classes/EntitySystem/CEntityHandle.h>
#include <CS2/Classes/EntitySystem/CEntityIdentity.h>
#include <CS2/Classes/EntitySystem/CEntityIndex.h>
#include <CS2/Classes/EntitySystem/CGameEntitySystem.h>
#include <GameClient/EntitySystem/EntityIdentity.h>
#include <MemoryPatterns/PatternTypes/EntitySystemPatternTypes.h>

template <typename HookContext>
class EntitySystem {
public:
    explicit EntitySystem(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) getEntityIdentityFromHandle(cs2::CEntityHandle handle) const noexcept
    {
        return hookContext.template make<EntityIdentity>(getRawEntityIdentityFromHandle(handle));
    }

    [[nodiscard]] cs2::CEntityInstance* getEntityFromHandle(cs2::CEntityHandle handle) const noexcept
    {
        if (const auto entityIdentity = getRawEntityIdentityFromHandle(handle))
            return entityIdentity->entity;
        return nullptr;
    }

    [[nodiscard]] decltype(auto) getEntityFromHandle2(cs2::CEntityHandle handle) const noexcept
    {
        return hookContext.template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(getEntityFromHandle(handle)));
    }
    
    template <typename F>
    void forEachNetworkableEntityIdentity(F&& f) const noexcept
    {
        const auto entityList = getEntityList();
        if (!entityList)
            return;

        for (auto chunkIndex = 0; chunkIndex < cs2::CConcreteEntityList::kNumberOfNetworkableEntityChunks; ++chunkIndex) {
            const auto* const chunk = entityList->chunks[chunkIndex];
            if (!chunk)
                continue;

            for (auto indexInChunk = 0; indexInChunk < cs2::CConcreteEntityList::kNumberOfIdentitiesPerChunk; ++indexInChunk) {
                if (const auto& entityIdentity = (*chunk)[indexInChunk]; entityIdentity.entity)
                    f(entityIdentity);
            }
        }
    }

    [[nodiscard]] cs2::CEntityClass* findEntityClass(const char* className) const noexcept
    {
        const auto entityClasses = getEntityClasses();
        if (!entityClasses)
            return nullptr;

        for (int i = 0; i < entityClasses->numElements; ++i) {
            if (std::strcmp(entityClasses->memory[i].key, className) == 0)
                return entityClasses->memory[i].value;
        }
        return nullptr;
    }

private:
    [[nodiscard]] cs2::CEntityIdentity* getRawEntityIdentityFromHandle(cs2::CEntityHandle handle) const noexcept
    {
        const auto entityIndex = handle.index();
        if (!entityIndex.isValid())
            return nullptr;

        const auto entityList = getEntityList();
        if (!entityList)
            return nullptr;

        const auto chunkIndex = entityIndex.value / cs2::CConcreteEntityList::kNumberOfIdentitiesPerChunk;
        if (auto* const chunk = entityList->chunks[chunkIndex]) {
            const auto indexInChunk = entityIndex.value % cs2::CConcreteEntityList::kNumberOfIdentitiesPerChunk;
            if (auto& entityIndentity = (*chunk)[indexInChunk]; entityIndentity.handle == handle)
                return &entityIndentity;
        }
        return nullptr;
    }

    [[nodiscard]] cs2::CGameEntitySystem* entitySystem() const noexcept
    {
        if (hookContext.patternSearchResults().template get<EntitySystemPointer>())
            return *hookContext.patternSearchResults().template get<EntitySystemPointer>();
        return nullptr;
    }

    [[nodiscard]] auto getEntityList() const noexcept
    {
        return hookContext.patternSearchResults().template get<EntityListOffset>().of(entitySystem()).get();
    }

    [[nodiscard]] auto getEntityClasses() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToEntityClasses>().of(entitySystem()).get();
    }

    HookContext& hookContext;
};

```

`Source/GameClient/FileNameSymbolTable.h`:

```h
#pragma once

#include <span>

#include <CS2/Classes/CUtlFilenameSymbolTable.h>

template <typename HookContext>
class FileNameSymbolTable {
public:
    explicit FileNameSymbolTable(HookContext& hookContext, cs2::CUtlFilenameSymbolTable* thisptr) noexcept
        : hookContext{hookContext}
        , thisptr{thisptr}
    {
    }

    explicit operator bool() const noexcept
    {
        return thisptr != nullptr;
    }

    void getString(cs2::FileNameHandle_t handle, std::span<char> buffer) const noexcept
    {
        if (thisptr && deps().string)
            deps().string(thisptr, &handle, buffer.data(), static_cast<int>(buffer.size()));
    }

private:
    [[nodiscard]] const auto& deps() const noexcept
    {
        return hookContext.fileNameSymbolTableState();
    }

    HookContext& hookContext;
    cs2::CUtlFilenameSymbolTable* thisptr;
};

```

`Source/GameClient/FileNameSymbolTableState.h`:

```h
#pragma once

#include <CS2/Classes/CUtlFilenameSymbolTable.h>
#include <GameClient/DLLs/Tier0Dll.h>

struct FileNameSymbolTableState {
    explicit FileNameSymbolTableState(Tier0Dll tier0Dll) noexcept
        : string{tier0Dll.filenameSymbolTableString()}
    {
    }

    cs2::CUtlFilenameSymbolTable::String* string;
};

```

`Source/GameClient/FileSystem.h`:

```h
#pragma once

#include <CS2/Classes/FileSystem.h>
#include <MemoryPatterns/PatternTypes/FileSystemPatternTypes.h>
#include "FileNameSymbolTable.h"

template <typename HookContext>
class FileSystem {
public:
    explicit FileSystem(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) fileNames() const noexcept
    {
        return hookContext.template make<FileNameSymbolTable>(hookContext.patternSearchResults().template get<FileNamesOffset>().of(fileSystem()).get());
    }

private:
    [[nodiscard]] cs2::CBaseFileSystem* fileSystem() const noexcept
    {
        if (const auto fileSystemPointer = hookContext.patternSearchResults().template get<FileSystemPointer>())
            return *fileSystemPointer;
        return nullptr;
    }

    HookContext& hookContext;
};

```

`Source/GameClient/GameSceneNode.h`:

```h
#pragma once

#include <CS2/Classes/CGameSceneNode.h>
#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <MemoryPatterns/PatternTypes/GameSceneNodePatternTypes.h>

template <typename HookContext>
class BaseEntity;

template <typename HookContext>
class GameSceneNode {
public:
    GameSceneNode(HookContext& hookContext, cs2::CGameSceneNode* gameSceneNode) noexcept
        : hookContext{&hookContext}
        , gameSceneNode{gameSceneNode}
    {
    }

    explicit operator bool() const noexcept
    {
        return gameSceneNode != nullptr;
    }

    [[nodiscard]] decltype(auto) owner() const noexcept
    {
        return hookContext->template make<BaseEntity>(static_cast<cs2::C_BaseEntity*>(hookContext->patternSearchResults().template get<OffsetToGameSceneNodeOwner>().of(gameSceneNode).valueOr(nullptr)));
    }

    template <typename F>
    void forEachChild(F f) const noexcept
    {
        for (auto&& child = this->child(); child; child = child.nextSibling())
            f(child);
    }

private:
    [[nodiscard]] decltype(auto) child() const noexcept
    {
        return hookContext->template make<GameSceneNode<HookContext>>(hookContext->patternSearchResults().template get<OffsetToChildGameSceneNode>().of(gameSceneNode).valueOr(nullptr));
    }

    [[nodiscard]] decltype(auto) nextSibling() const noexcept
    {
        return hookContext->template make<GameSceneNode<HookContext>>(hookContext->patternSearchResults().template get<OffsetToNextSiblingGameSceneNode>().of(gameSceneNode).valueOr(nullptr));
    }

    HookContext* hookContext;
    cs2::CGameSceneNode* gameSceneNode;
};

```

`Source/GameClient/GlobalVars.h`:

```h
#pragma once

#include <CS2/Classes/GlobalVars.h>
#include <Utils/Optional.h>

template <typename HookContext>
struct GlobalVars {
    [[nodiscard]] Optional<float> curtime() const noexcept
    {
        if (globalVars)
            return globalVars->curtime;
        return {};
    }

    [[nodiscard]] Optional<float> frametime() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToFrametime>().of(globalVars).toOptional();
    }

    HookContext& hookContext;
    cs2::GlobalVars* globalVars;
};

```

`Source/GameClient/Hud/BombStatus/BombStatusPanel.h`:

```h
#pragma once

#include <utility>

#include <Common/Visibility.h>
#include "BombStatusPanelContext.h"

template <typename HookContext, typename Context = BombStatusPanelContext<HookContext>>
struct BombStatusPanel {
    template <typename... Args>
    explicit BombStatusPanel(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void hide() noexcept
    {
        changeVisibility(Visibility::Hidden, [this] { context.bombStatusPanel().setParent(context.invisiblePanel()); });
    }

    void restore() noexcept
    {
        changeVisibility(Visibility::Visible, [this] { context.bombStatusPanel().setParent(context.scoreAndTimeAndBombPanel()); });
    }

    void onUnload() noexcept
    {
        restore();
        context.hookContext.template make<PanoramaUiEngine>().deletePanelByHandle(context.hookContext.bombStatusPanelState().invisiblePanelHandle);
    }

private:
    void changeVisibility(Visibility targetVisibility, auto performVisibilityChange) noexcept
    {
        if (auto& visibility = context.visibility(); visibility != targetVisibility) {
            performVisibilityChange();
            visibility = targetVisibility;
        }
    }
    
    Context context;
};

```

`Source/GameClient/Hud/BombStatus/BombStatusPanelContext.h`:

```h
#pragma once

#include <GameClient/Panorama/PanelHandle.h>

template <typename HookContext>
struct BombStatusPanelContext {
    explicit BombStatusPanelContext(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) bombStatusPanel() const noexcept
    {
        return hookContext.hud().bombStatus();
    }

    [[nodiscard]] decltype(auto) scoreAndTimeAndBombPanel() const noexcept
    {
        return hookContext.hud().scoreAndTimeAndBomb();
    }

    [[nodiscard]] decltype(auto) invisiblePanel() const noexcept
    {
        return invisiblePanelHandle().getOrInit(createInvisiblePanel());
    }

    [[nodiscard]] auto& visibility() const noexcept
    {
        return state().visibility;
    }

    HookContext& hookContext;

private:
    [[nodiscard]] decltype(auto) state() const noexcept
    {
        return hookContext.bombStatusPanelState();
    }

    [[nodiscard]] decltype(auto) invisiblePanelHandle() const noexcept
    {
        return hookContext.template make<PanelHandle>(state().invisiblePanelHandle);
    }

    [[nodiscard]] decltype(auto) createInvisiblePanel() const noexcept
    {
        return [this] {
            auto&& invisiblePanel = hookContext.panelFactory().createPanel(scoreAndTimeAndBombPanel()).uiPanel();
            invisiblePanel.setVisible(false);
            return invisiblePanel;
        };
    }
};

```

`Source/GameClient/Hud/BombStatus/BombStatusPanelManager.h`:

```h
#pragma once

#include <utility>

#include "BombStatusPanelManagerContext.h"
#include <Common/Visibility.h>

template <typename HookContext, typename Context = BombStatusPanelManagerContext<HookContext>>
class BombStatusPanelManager {
public:
    template <typename... Args>
    BombStatusPanelManager(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    void run() const noexcept
    {
        if (updateFeaturesReplacingBombStatusPanel() == Visibility::Visible)
            context.bombStatusPanel().hide();
        else
            context.bombStatusPanel().restore();
    }

private:
    [[nodiscard]] Visibility updateFeaturesReplacingBombStatusPanel() const noexcept
    {
        if (context.postRoundTimer().update() == Visibility::Visible) {
            context.bombTimer().forceHide();
            return Visibility::Visible;
        }
        return context.bombTimer().update();
    }

    Context context;
};

```

`Source/GameClient/Hud/BombStatus/BombStatusPanelManagerContext.h`:

```h
#pragma once

#include <Features/Hud/BombTimer/BombTimer.h>
#include <Features/Hud/PostRoundTimer/PostRoundTimer.h>

#include "BombStatusPanel.h"

template <typename HookContext>
struct BombStatusPanelManagerContext {
    explicit BombStatusPanelManagerContext(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) bombStatusPanel() const noexcept
    {
        return hookContext.template make<BombStatusPanel>();
    }

    [[nodiscard]] decltype(auto) postRoundTimer() const noexcept
    {
        return hookContext.template make<PostRoundTimer>();
    }

    [[nodiscard]] decltype(auto) bombTimer() const noexcept
    {
        return hookContext.template make<BombTimer>();
    }

private:
    HookContext& hookContext;
};


```

`Source/GameClient/Hud/BombStatus/BombStatusPanelState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>
#include <Common/Visibility.h>

struct BombStatusPanelState {
    cs2::PanelHandle invisiblePanelHandle;
    Visibility visibility{Visibility::Visible};

    void resetVisibility() noexcept
    {
        visibility = Visibility::Visible;
    }
};

```

`Source/GameClient/Hud/DeathNotice.h`:

```h
#pragma once

#include <cstdint>
#include <utility>

#include <Utils/StringBuilder.h>
#include <Utils/StringParser.h>

#include "DeathNoticeContext.h"

template <typename HookContext, typename Context = DeathNoticeContext<HookContext>>
class DeathNotice {
public:
    template <typename... Args>
    explicit DeathNotice(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    [[nodiscard]] bool isLocalPlayerKiller() const noexcept
    {
        return context.panel().hasClass(context.panoramaSymbols().deathNoticeKillerSymbol);
    }

    [[nodiscard]] auto wasSpawnedThisRound() const noexcept
    {
        return context.gameRules().roundStartTime().lessEqual(getSpawnTime());
    }

    [[nodiscard]] float getSpawnTime() const noexcept
    {
        float spawnTime = 0.0f;
        if (const auto spawnTimeString = context.panel().getAttributeString(context.panoramaSymbols().spawnTimeSymbol, ""))
            StringParser{spawnTimeString}.parseFloat(spawnTime);
        return spawnTime;
    }

    void markAsJustSpawned() const noexcept
    {
        if (const auto curtime = context.globalVars().curtime(); curtime.hasValue())
            setSpawnTime(curtime.value());
    }

    void setSpawnTime(float spawnTime) const noexcept
    {
        context.panel().setAttributeString(context.panoramaSymbols().spawnTimeSymbol,
            StringBuilderStorage<20>{}.builder().put(static_cast<std::uint64_t>(spawnTime), '.', '0').cstring());
    }

private:
    Context context;
};

```

`Source/GameClient/Hud/DeathNoticeContext.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
struct DeathNoticeContext {
    DeathNoticeContext(HookContext& hookContext, cs2::CUIPanel* panel) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
    {
    }

    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

    [[nodiscard]] decltype(auto) panoramaSymbols() const noexcept
    {
        return _hookContext.panoramaSymbols();
    }

    [[nodiscard]] decltype(auto) gameRules() const noexcept
    {
        return _hookContext.gameRules();
    }

    [[nodiscard]] decltype(auto) globalVars() const noexcept
    {
        return _hookContext.globalVars();
    }

private:
    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/GameClient/Hud/DeathNotices.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>
#include "DeathNotice.h"

template <typename HookContext>
struct DeathNotices {
    DeathNotices(HookContext& hookContext, cs2::CUIPanel* panel) noexcept
        : _hookContext{hookContext}
        , _panel{panel}
    {
    }

    template <typename F>
    void forEach(F&& f) noexcept
    {
        panel().children().forEach([&f](auto&& panel) { f(panel.template as<DeathNotice>()); });
    }

private:
    [[nodiscard]] decltype(auto) panel() noexcept
    {
        return _hookContext.template make<PanoramaUiPanel>(_panel);
    }

    HookContext& _hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/GameClient/Hud/Hud.h`:

```h
#pragma once

#include <CS2/Constants/PanelIDs.h>

#include "DeathNotices.h"

template <typename Context>
struct Hud {
    explicit Hud(Context context) noexcept
        : context{context}
    {
    }

    [[nodiscard]] decltype(auto) deathNotices() noexcept
    {
        return context.deathNoticesPanelHandle().getOrInit(findVisibleDeathNoticesPanel()).template as<DeathNotices>();
    }

    [[nodiscard]] decltype(auto) timerTextPanel() noexcept
    {
        return context.timerTextPanelHandle().getOrInit(findTimerTextPanel());
    }

    [[nodiscard]] decltype(auto) getHudReticle() noexcept
    {
        return context.panel().findChildInLayoutFile(cs2::panel_id::HudReticle);
    }

    [[nodiscard]] decltype(auto) scoreAndTimeAndBomb() noexcept
    {
        return context.scoreAndTimeAndBombPanelHandle().getOrInit(findScoreAndTimeAndBombPanel());
    }

    [[nodiscard]] decltype(auto) bombStatus() noexcept
    {
        return context.bombStatusPanelHandle().getOrInit(findBombStatusPanel());
    }

    [[nodiscard]] decltype(auto) hudTeamCounter() noexcept
    {
        return context.panel().findChildInLayoutFile(cs2::panel_id::HudTeamCounter);
    }

    [[nodiscard]] decltype(auto) bombPlantedPanel() noexcept
    {
        return context.bombPlantedPanelHandle().getOrInit(findBombPlantedPanel());
    }

private:
    [[nodiscard]] decltype(auto) hudDeathNotice() noexcept
    {
        return context.panel().findChildInLayoutFile(cs2::panel_id::HudDeathNotice);
    }

    [[nodiscard]] auto findVisibleDeathNoticesPanel() noexcept
    {
        return [this] { 
            return hudDeathNotice().findChildInLayoutFile(cs2::panel_id::VisibleNotices);
        };
    }

    [[nodiscard]] auto findBombStatusPanel() noexcept
    {
        return [this] {
            context.resetBombStatusVisibility();
            return scoreAndTimeAndBomb().findChildInLayoutFile(cs2::panel_id::BombStatus);
        };
    }

    [[nodiscard]] auto findBombPlantedPanel() noexcept
    {
        return [this] {
            return bombStatus().findChildInLayoutFile(cs2::panel_id::BombPlanted);
        };
    }

    [[nodiscard]] auto findScoreAndTimeAndBombPanel() noexcept
    {
        return [this] {
            return hudTeamCounter().findChildInLayoutFile(cs2::panel_id::ScoreAndTimeAndBomb);
        };
    }

    [[nodiscard]] auto findTimerTextPanel() noexcept
    {
        return [this] {
            return scoreAndTimeAndBomb().findChildInLayoutFile(cs2::panel_id::TimerText);
        };
    }

    Context context;
};

```

`Source/GameClient/Hud/HudContext.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <GameClient/Panorama/PanelHandle.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>

template <typename HookContext>
struct HudContext {
    explicit HudContext(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] auto panel() noexcept
    {
        auto&& hud = hookContext.patternSearchResults().template get<HudPanelPointer>();
        if (hud && *hud)
            return hookContext.template make<PanoramaUiPanel>((*hud)->uiPanel);
        return hookContext.template make<PanoramaUiPanel>(nullptr);
    }

    [[nodiscard]] auto deathNoticesPanelHandle() noexcept
    {
        return hookContext.template make<PanelHandle>(hookContext.hudState().deathNoticesPanelHandle);
    }

    [[nodiscard]] auto scoreAndTimeAndBombPanelHandle() noexcept
    {
        return hookContext.template make<PanelHandle>(hookContext.hudState().scoreAndTimeAndBombPanelHandle);
    }

    [[nodiscard]] auto bombStatusPanelHandle() noexcept
    {
        return hookContext.template make<PanelHandle>(hookContext.hudState().bombStatusPanelHandle);
    }

    [[nodiscard]] auto bombPlantedPanelHandle() noexcept
    {
        return hookContext.template make<PanelHandle>(hookContext.hudState().bombPlantedPanelHandle);
    }

    [[nodiscard]] auto timerTextPanelHandle() noexcept
    {
        return hookContext.template make<PanelHandle>(hookContext.hudState().timerTextPanelHandle);
    }

    void resetBombStatusVisibility() noexcept
    {
        hookContext.bombStatusPanelState().resetVisibility();
    }
    
private:
    HookContext& hookContext;
};

```

`Source/GameClient/Hud/HudState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>

struct HudState {
    cs2::PanelHandle deathNoticesPanelHandle;
    cs2::PanelHandle scoreAndTimeAndBombPanelHandle;
    cs2::PanelHandle bombStatusPanelHandle;
    cs2::PanelHandle bombPlantedPanelHandle;
    cs2::PanelHandle timerTextPanelHandle;
};

```

`Source/GameClient/MemAlloc.h`:

```h
#pragma once

#include <cstddef>

#include <MemoryPatterns/PatternTypes/MemAllocPatternTypes.h>
#include <Platform/Macros/FunctionAttributes.h>

template <typename HookContext>
class MemAlloc {
public:
    explicit MemAlloc(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }
    
    [[nodiscard]] [[NOINLINE]] void* allocate(std::size_t size) const noexcept
    {
        if (!deps().thisptr || !*deps().thisptr)
            return nullptr;

        if (const auto fn = hookContext.patternSearchResults().template get<OffsetAllocVirtualMethod>().of((*deps().thisptr)->vmt).get())
            return (*fn)(*deps().thisptr, size);
        
        return nullptr;
    }

private:
    [[nodiscard]] const auto& deps() const noexcept
    {
        return hookContext.memAllocState();
    }

    HookContext& hookContext;
};

```

`Source/GameClient/MemAllocState.h`:

```h
#pragma once

#include <CS2/Classes/IMemAlloc.h>
#include <GameClient/DLLs/Tier0Dll.h>

struct MemAllocState {
    MemAllocState(Tier0Dll tier0Dll) noexcept
        : thisptr{tier0Dll.memAlloc()}
    {
    }

    cs2::IMemAlloc** thisptr;
};

```

`Source/GameClient/Panorama/ClientPanel.h`:

```h
#pragma once

#include <CS2/Panorama/CPanel2D.h>
#include <CS2/Panorama/CUIPanel.h>

template <typename HookContext>
struct ClientPanel {
    ClientPanel(HookContext& hookContext, cs2::CPanel2D* panel) noexcept
        : hookContext{hookContext}
        , panel{panel}
    {
    }

    [[nodiscard]] operator cs2::CPanel2D*() const noexcept
    {
        return panel;
    }

    [[nodiscard]] decltype(auto) uiPanel() const noexcept
    {
        return hookContext.uiPanel(uiPanelPointer());
    }

    template <template <typename...> typename T>
    [[nodiscard]] decltype(auto) as() const noexcept
    {
        return hookContext.template make<T>(static_cast<T<HookContext>::RawType*>(panel));
    }

private:
    [[nodiscard]] cs2::CUIPanel* uiPanelPointer() const noexcept
    {
        if (panel)
            return panel->uiPanel;
        return nullptr;
    }

    HookContext& hookContext;
    cs2::CPanel2D* panel;
};

```

`Source/GameClient/Panorama/ImagePanel.h`:

```h
#pragma once

#include <bit>
#include <cstddef>
#include <optional>
#include <string_view>
#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Panorama/CImagePanel.h>
#include <MemoryPatterns/PatternTypes/PanoramaImagePanelPatternTypes.h>

struct SvgImageParams {
    const char* imageUrl;
    int textureHeight{-1};
    std::optional<cs2::Color> fillColor{};
};

template <typename HookContext>
class ImagePanel {
public:
    using RawType = cs2::CImagePanel;

    ImagePanel(HookContext& hookContext, cs2::CImagePanel* panel) noexcept
        : hookContext{hookContext}
        , panel{panel}
    {
    }

    [[nodiscard]] decltype(auto) uiPanel() const noexcept
    {
        return hookContext.uiPanel(panel ? panel->uiPanel : nullptr);
    }

    [[nodiscard]] cs2::ImageProperties* getImageProperties() const noexcept
    {
        return hookContext.patternSearchResults().template get<ImagePropertiesOffset>().of(panel).get();
    }

    [[nodiscard]] std::string_view getImagePath() const noexcept
    {
        if (auto&& imagePath = hookContext.patternSearchResults().template get<OffsetToImagePath>().of(panel).get(); imagePath && imagePath->m_pString)
            return imagePath->m_pString;
        return {};
    }

    void setImageSvg(const char* imageUrl, int textureHeight = -1) const noexcept
    {
        setImageSvg(SvgImageParams{.imageUrl = imageUrl, .textureHeight = textureHeight});
    }

    void setImageSvg(const SvgImageParams& params) const noexcept
    {
        const auto properties{getImageProperties()};
        if (!properties)
            return;

        properties->scale = uiScaleFactor();
        properties->textureHeight = params.textureHeight;

        if (params.fillColor.has_value()) {
            properties->svgAttributes[static_cast<std::size_t>(cs2::SvgAttributeType::FillColor)] = std::bit_cast<cs2::SvgAttribute>(*params.fillColor);
            properties->presentSvgAttributes |= 1 << static_cast<std::size_t>(cs2::SvgAttributeType::FillColor);
        }

        if (hookContext.patternSearchResults().template get<SetImageFunctionPointer>())
            hookContext.patternSearchResults().template get<SetImageFunctionPointer>()(panel, params.imageUrl, nullptr, properties);
    }

private:
    [[nodiscard]] decltype(auto) uiScaleFactor() const
    {
        const auto scale = uiPanel().getUiScaleFactor().valueOr(1.0f);
        assert(scale >= 0.1f && scale <= 10.0f && "Invalid UI scale factor");
        return scale;
    }

    HookContext& hookContext;
    cs2::CImagePanel* panel;
};

```

`Source/GameClient/Panorama/PanelAlignmentParams.h`:

```h
#pragma once

#include <CS2/Panorama/StyleEnums.h>

struct PanelAlignmentParams {
    cs2::EHorizontalAlignment horizontalAlignment{cs2::k_EHorizontalAlignmentUnset};
    cs2::EVerticalAlignment verticalAlignment{cs2::k_EVerticalAlignmentUnset};
};

```

`Source/GameClient/Panorama/PanelFactory.h`:

```h
#pragma once

#include <CS2/Panorama/CImagePanel.h>
#include <CS2/Panorama/CLabel.h>
#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/MemAlloc.h>
#include <MemoryPatterns/PatternTypes/PanelPatternTypes.h>
#include <MemoryPatterns/PatternTypes/PanoramaImagePanelPatternTypes.h>
#include <MemoryPatterns/PatternTypes/PanoramaLabelPatternTypes.h>
#include <GameClient/Panorama/ClientPanel.h>
#include <GameClient/Panorama/ImagePanel.h>

template <typename HookContext>
struct PanelFactory {
    explicit PanelFactory(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) createPanel(cs2::CUIPanel* parentPanel, const char* id = "") noexcept
    {
        if (parentPanel && panelConstructor())
            return hookContext.template make<ClientPanel>(panelConstructor()(id, parentPanel->clientPanel));
        return hookContext.template make<ClientPanel>(nullptr);
    }

    [[nodiscard]] decltype(auto) createLabelPanel(cs2::CUIPanel* parentPanel, const char* id = "") const noexcept
    {
        if (!parentPanel || !labelPanelConstructor() || !labelPanelSize())
            return hookContext.template make<ClientPanel>(nullptr);

        const auto memory{static_cast<cs2::CLabel*>(hookContext.template make<MemAlloc>().allocate(labelPanelSize()))};
        if (memory)
            labelPanelConstructor()(memory, parentPanel->clientPanel, id);
        return hookContext.template make<ClientPanel>(memory);
    }

    [[nodiscard]] decltype(auto) createImagePanel(cs2::CUIPanel* parentPanel, const char* id = "") noexcept
    {
        if (!parentPanel || !imagePanelConstructor() || !imagePanelSize())
            return hookContext.template make<ClientPanel>(nullptr).template as<ImagePanel>();

        const auto memory{static_cast<cs2::CImagePanel*>(hookContext.template make<MemAlloc>().allocate(imagePanelSize()))};
        if (memory)
            imagePanelConstructor()(memory, parentPanel->clientPanel, id);
        return hookContext.template make<ClientPanel>(memory).template as<ImagePanel>();
    }

private:
    [[nodiscard]] auto panelConstructor() const noexcept
    {
        return hookContext.patternSearchResults().template get<PanelConstructorPointer>();
    }

    [[nodiscard]] auto imagePanelConstructor() const noexcept
    {
        return hookContext.patternSearchResults().template get<ImagePanelConstructorPointer>();
    }

    [[nodiscard]] auto imagePanelSize() const noexcept
    {
        return hookContext.patternSearchResults().template get<ImagePanelClassSize>();
    }

    [[nodiscard]] auto labelPanelConstructor() const noexcept
    {
        return hookContext.patternSearchResults().template get<LabelPanelConstructorPointer>();
    }

    [[nodiscard]] auto labelPanelSize() const noexcept
    {
        return hookContext.patternSearchResults().template get<LabelPanelObjectSize>();
    }

    HookContext& hookContext;
};

```

`Source/GameClient/Panorama/PanelFontParams.h`:

```h
#pragma once

#include <string_view>

#include <CS2/Panorama/StyleEnums.h>

struct PanelFontParams {
    std::string_view fontFamily;
    float fontSize;
    cs2::EFontWeight fontWeight{cs2::EFontWeight::k_EFontWeightUnset};
};

```

`Source/GameClient/Panorama/PanelHandle.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>
#include <GameClient/Panorama/PanoramaUiEngine.h>
#include <Utils/Lvalue.h>

#include <utility>

template <typename HookContext>
struct PanelHandle {
    PanelHandle(HookContext& hookContext, cs2::PanelHandle& handle) noexcept
        : hookContext{hookContext}
        , handle{handle}
    {
    }

    [[nodiscard]] decltype(auto) get() noexcept
    {
        return hookContext.template make<PanoramaUiEngine>().getPanelFromHandle(std::as_const(handle));
    }

    template <typename F>
    [[nodiscard]] decltype(auto) getOrInit(F&& f) noexcept
    {
        if (auto&& panel = get())
            return utils::lvalue<decltype(panel)>(panel);

        auto&& panel = std::forward<F>(f)();
        handle = panel.getHandle();
        return utils::lvalue<decltype(panel)>(panel);
    }

    [[nodiscard]] bool panelExists() noexcept
    {
        return handle.isValid() && static_cast<bool>(get());
    }

private:
    HookContext& hookContext;
    cs2::PanelHandle& handle;
};

```

`Source/GameClient/Panorama/PanelMarginParams.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>

struct PanelMarginParams {
    cs2::CUILength marginLeft{cs2::CUILength::pixels(0)};
    cs2::CUILength marginTop{cs2::CUILength::pixels(0)};
    cs2::CUILength marginRight{cs2::CUILength::pixels(0)};
    cs2::CUILength marginBottom{cs2::CUILength::pixels(0)};
};

```

`Source/GameClient/Panorama/PanelShadowParams.h`:

```h
#pragma once

#include <CS2/Classes/Color.h>
#include <CS2/Panorama/CUILength.h>

struct PanelShadowParams {
    cs2::CUILength horizontalOffset;
    cs2::CUILength verticalOffset;
    cs2::CUILength blurRadius;
    float strength;
    cs2::Color color;
};

```

`Source/GameClient/Panorama/PanelStylePropertyFactory.h`:

```h
#pragma once

#include <cstring>
#include <optional>
#include <utility>

#include <CS2/Classes/CUtlString.h>
#include <CS2/Classes/Color.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/StyleEnums.h>

#include <CS2/Panorama/StyleProperties.h>
#include <GameClient/MemAlloc.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>

#include "PanelShadowParams.h"
#include "StylePropertiesSymbolsAndVMTs.h"

template <typename HookContext>
struct PanelStylePropertyFactory {
    PanelStylePropertyFactory(HookContext& hookContext, const StylePropertiesSymbolsAndVMTs& symbolsAndVMTs) noexcept
        : hookContext{hookContext}
        , symbolsAndVMTs{symbolsAndVMTs}
    {
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyWidth> width(cs2::CUILength width) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyWidth>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyWidth>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyWidth{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_Length = width
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyOpacity> opacity(float opacity) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyOpacity>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyOpacity>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyOpacity{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .opacity = opacity
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyZIndex> zIndex(float zIndex) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyZIndex>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyZIndex>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyZIndex{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .zindex = zIndex
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyHeight> height(cs2::CUILength height) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyHeight>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyHeight>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyHeight{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_Height = height
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyImageShadow> imageShadow(const PanelShadowParams& params) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyImageShadow>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyImageShadow>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyImageShadow{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .fullySet = true,
                .horizontalOffset = params.horizontalOffset,
                .verticalOffset = params.verticalOffset,
                .blurRadius = params.blurRadius,
                .strength = params.strength,
                .color = params.color
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyPosition> position(cs2::CUILength x, cs2::CUILength y) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyPosition>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyPosition>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyPosition{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .x = x,
                .y = y,
                .z = cs2::CUILength::pixels(0)
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyTransformOrigin> transformOrigin(cs2::CUILength x, cs2::CUILength y) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyTransformOrigin>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyTransformOrigin>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyTransformOrigin{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .x = x,
                .y = y,
                .m_bParentRelative = false
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyAlign> align(const PanelAlignmentParams& params) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyAlign>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyAlign>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyAlign{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_eHorizontalAlignment = params.horizontalAlignment,
                .m_eVerticalAlignment = params.verticalAlignment
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyWashColor> washColor(cs2::Color color) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyWashColor>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyWashColor>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyWashColor{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .color = color,
                .fullySet = true
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyFlowChildren> flowChildren(cs2::EFlowDirection flowDirection) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyFlowChildren>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyFlowChildren>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyFlowChildren{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_eFlowDirection = flowDirection
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyFont> font(const PanelFontParams& params) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyFont>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyFont>();
        if (vmt && symbol.isValid()) {
            cs2::CUtlString fontFamilyString{nullptr};
            if (params.fontFamily.length() > 0) {
                if ((fontFamilyString.m_pString = static_cast<char*>(hookContext.template make<MemAlloc>().allocate(params.fontFamily.length() + 1))) != nullptr) {
                    std::memcpy(fontFamilyString.m_pString, params.fontFamily.data(), params.fontFamily.length());
                    fontFamilyString.m_pString[params.fontFamily.length()] = '\0';
                }
            }
            return cs2::CStylePropertyFont{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_strFontFamily = fontFamilyString,
                .m_flFontSize = params.fontSize,
                .m_eFontStyle = cs2::k_EFontStyleUnset,
                .m_eFontWeight = params.fontWeight,
                .m_eFontStretch = cs2::k_EFontStretchUnset
            };
        }
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyTextShadow> textShadow(const PanelShadowParams& params) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyTextShadow>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyTextShadow>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyTextShadow{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .fullySet = true, 
                .horizontalOffset = params.horizontalOffset, 
                .verticalOffset = params.verticalOffset,
                .blurRadius = params.blurRadius,
                .strength = params.strength,
                .color = params.color
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyMargin> margin(const PanelMarginParams& params) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyMargin>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyMargin>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyMargin{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_left = params.marginLeft,
                .m_top = params.marginTop,
                .m_right = params.marginRight,
                .m_bottom = params.marginBottom
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyMixBlendMode> mixBlendMode(cs2::EMixBlendMode mode) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyMixBlendMode>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyMixBlendMode>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyMixBlendMode{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_eMixBlendMode = mode,
                .m_bSet = true
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyTextAlign> textAlign(cs2::ETextAlign textAlign) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyTextAlign>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyTextAlign>();
        if (vmt && symbol.isValid())
            return cs2::CStylePropertyTextAlign{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_eAlign = textAlign
            };
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyForegroundColor> foregroundColor(cs2::Color color) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyForegroundColor>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyForegroundColor>();
        if (vmt && symbol.isValid()) {
            return cs2::CStylePropertyForegroundColor{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .fillBrushes{
                    .numberOfElements = 1,
                    .growSize = 1,
                    .element{
                        .type = cs2::k_EStrokeTypeFillColor,
                        .fillColor = color,
                        .opacity = 1.0f
                    }
                }
            };
        }
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyBackgroundColor> backgroundColor(cs2::Color color) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyBackgroundColor>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyBackgroundColor>();
        if (vmt && symbol.isValid()) {
            return cs2::CStylePropertyBackgroundColor{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .fillBrushes{
                    .numberOfElements = 1,
                    .growSize = 1,
                    .element{
                        .type = cs2::k_EStrokeTypeFillColor,
                        .fillColor = color,
                        .opacity = 1.0f
                    },
                },
                .opacity = -1.0f
            };
        }
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyTransform3D> transform3D(std::span<cs2::CTransform3D*> transforms) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyTransform3D>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyTransform3D>();
        if (vmt && symbol.isValid()) {
            return cs2::CStylePropertyTransform3D{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .transforms{createTransformVector(transforms)},
                .cachedParentWidth = 0.0f,
                .cachedParentHeight = 0.0f,
                .dirty = true,
                .matrix = cs2::VMatrix::identity(),
                .interpolated = false,
                .fullySet = true
            };
        }
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyBorder> border(cs2::CUILength width, cs2::Color color) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyBorder>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyBorder>();
        if (vmt && symbol.isValid()) {
            return cs2::CStylePropertyBorder{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_rgBorderStyle{cs2::k_EBorderStyleSolid, cs2::k_EBorderStyleSolid, cs2::k_EBorderStyleSolid, cs2::k_EBorderStyleSolid},
                .m_rgBorderWidth{width, width, width, width},
                .m_rgColorsSet{true, true, true, true},
                .m_rgBorderColor{color, color, color, color}
            };
        }
        return {};
    }

    [[nodiscard]] std::optional<cs2::CStylePropertyBorderRadius> borderRadius(cs2::CUILength radius) const noexcept
    {
        const auto vmt = symbolsAndVMTs.getVmt<cs2::CStylePropertyBorderRadius>();
        const auto symbol = symbolsAndVMTs.getSymbol<cs2::CStylePropertyBorderRadius>();
        if (vmt && symbol.isValid()) {
            return cs2::CStylePropertyBorderRadius{
                .vmt = vmt,
                .m_symPropertyName = symbol,
                .m_bDisallowTransition = false,
                .m_rgCornerRaddi{
                    {.horizontalRadius = radius, .verticalRadius = radius},
                    {.horizontalRadius = radius, .verticalRadius = radius},
                    {.horizontalRadius = radius, .verticalRadius = radius},
                    {.horizontalRadius = radius, .verticalRadius = radius}
                }
            };
        }
        return {};
    }

private:
    [[nodiscard]] auto createTransformVector(std::span<cs2::CTransform3D*> transforms) const
    {
        cs2::CUtlVector<cs2::CTransform3D*> vec{};
        vec.memory = static_cast<cs2::CTransform3D**>(hookContext.template make<MemAlloc>().allocate(sizeof(cs2::CTransform3D*) * transforms.size()));
        if (vec.memory) {
            std::memcpy(vec.memory, transforms.data(), transforms.size() * sizeof(cs2::CTransform3D*));
            vec.allocationCount = static_cast<int>(transforms.size());
            vec.size = static_cast<int>(transforms.size());
        }
        vec.growSize = 1;
        return vec;
    }

    HookContext& hookContext;
    const StylePropertiesSymbolsAndVMTs& symbolsAndVMTs;
};

```

`Source/GameClient/Panorama/PanoramaDropDown.h`:

```h
#pragma once

#include <CS2/Panorama/CDropDown.h>
#include <MemoryPatterns/PatternTypes/PanoramaDropDownPatternTypes.h>

template <typename HookContext>
class DropdownMenu {
public:
    DropdownMenu(HookContext& hookContext, cs2::CDropDownMenu* dropdownMenu) noexcept
        : hookContext{hookContext}
        , dropdownMenu{dropdownMenu}
    {
    }

    using RawType = cs2::CDropDownMenu;

    [[nodiscard]] int getSelectedIndex() const
    {
        const auto selectedOption = getSelected();
        if (!selectedOption)
            return -1;

        int i = 0;
        for (auto&& child : uiPanel().children()) {
            if (child == selectedOption)
                return i;
            ++i;
        }
        return -1;
    }

private:
    [[nodiscard]] cs2::CUIPanel* getSelected() const
    {
        return hookContext.template make<ClientPanel>(dropdownMenu ? dropdownMenu->selectedChild : nullptr).uiPanel();
    }

    [[nodiscard]] decltype(auto) uiPanel() const
    {
        return hookContext.uiPanel(dropdownMenu ? dropdownMenu->uiPanel : nullptr);
    }

    HookContext& hookContext;
    cs2::CDropDownMenu* dropdownMenu;
};

template <typename HookContext>
class PanoramaDropDown {
public:
    PanoramaDropDown(HookContext& hookContext, cs2::CDropDown* dropDown) noexcept
        : hookContext{hookContext}
        , dropDown{dropDown}
    {
    }

    using RawType = cs2::CDropDown;

    [[nodiscard]] int getSelectedIndex() const
    {
        return dropdownMenu().getSelectedIndex();
    }

    void setSelectedIndex(int index) const noexcept
    {
        const auto setSelectedIndexFn = hookContext.patternSearchResults().template get<SetSelectedIndexFunctionPointer>();
        if (dropDown && setSelectedIndexFn)
            setSelectedIndexFn(dropDown, index);
    }

    void registerSelectionChangedHandler(cs2::CDropDown::DropDownSelectionChangedHandler* func)
    {
        auto&& uiEngine = hookContext.template make<PanoramaUiEngine>();
        uiEngine.registerEventHandler(
            uiEngine.makeSymbol(0, "DropDownSelectionChanged"),
            uiPanel(),
            cs2::CUtlAbstractDelegate{func}
        );
    }

private:
    [[nodiscard]] decltype(auto) dropdownMenu() const
    {
        if (dropDown)
            return hookContext.template make<PanoramaUiEngine>().getPanelFromHandle(dropDown->dropdownMenu).clientPanel().template as<DropdownMenu>();
        return hookContext.template make<DropdownMenu>(nullptr);
    }

    [[nodiscard]] decltype(auto) uiPanel() const
    {
        return hookContext.uiPanel(dropDown ? dropDown->uiPanel : nullptr);
    }

    HookContext& hookContext;
    cs2::CDropDown* dropDown;
};

```

`Source/GameClient/Panorama/PanoramaLabel.h`:

```h
#pragma once

#include <CS2/Panorama/CLabel.h>
#include <CS2/Panorama/CPanel2D.h>
#include <MemoryPatterns/PatternTypes/PanoramaLabelPatternTypes.h>

#include "PanoramaUiPanel.h"

template <typename HookContext>
struct PanoramaLabel {
    using RawType = cs2::CLabel;

    PanoramaLabel(HookContext& hookContext, cs2::CPanel2D* panel) noexcept
        : hookContext{hookContext}
        , panel{static_cast<cs2::CLabel*>(panel)}
    {
    }

    [[nodiscard]] decltype(auto) uiPanel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(panel ? panel->uiPanel : nullptr);
    }

    void setText(const char* value) const noexcept
    {
        setTextInternal(value, 0, true);
    }

    void setTextInternal(const char* value, int textType, bool trustedSource) const noexcept
    {
        if (panel && setTextInternalFunction())
            setTextInternalFunction()(panel, value, textType, trustedSource);
    }

private:
    [[nodiscard]] auto setTextInternalFunction() const noexcept
    {
        return hookContext.patternSearchResults().template get<SetLabelTextFunctionPointer>();
    }

    HookContext& hookContext;
    cs2::CLabel* panel;
};

```

`Source/GameClient/Panorama/PanoramaSymbols.h`:

```h
#pragma once

#include <CS2/Panorama/CPanoramaSymbol.h>
#include <GameClient/Panorama/PanoramaUiEngine.h>

struct PanoramaSymbols {
    template <typename HookContext>
    PanoramaSymbols(HookContext& hookContext) noexcept
        : deathNoticeKillerSymbol{hookContext.template make<PanoramaUiEngine>().makeSymbol(0, "DeathNotice_Killer")}
        , spawnTimeSymbol{hookContext.template make<PanoramaUiEngine>().makeSymbol(0, "SpawnTime")}
    {
    }

    cs2::CPanoramaSymbol deathNoticeKillerSymbol;
    cs2::CPanoramaSymbol spawnTimeSymbol;
};

```

`Source/GameClient/Panorama/PanoramaTransformFactory.h`:

```h
#pragma once

#include <utility>
#include <type_traits>

#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/Transform3D.h>
#include <GameClient/MemAlloc.h>

template <typename HookContext>
struct PanoramaTransformFactory {
    explicit PanoramaTransformFactory(HookContext& hookContext, const void* transformTranslate3dVmt, const void* transformScale3dVmt) noexcept
        : hookContext{hookContext}
        , transformTranslate3dVmt{transformTranslate3dVmt}
        , transformScale3dVmt{transformScale3dVmt}
    {
    }

    [[nodiscard]] cs2::CTransform3D* scale(float scale) const noexcept
    {
        return create<cs2::CTransformScale3D>(scale, scale, 1.0f);
    }

    [[nodiscard]] cs2::CTransform3D* scale(float scaleX, float scaleY) const noexcept
    {
        return create<cs2::CTransformScale3D>(scaleX, scaleY, 1.0f);
    }

    [[nodiscard]] cs2::CTransform3D* translate(cs2::CUILength x, cs2::CUILength y) const noexcept
    {
        return create<cs2::CTransformTranslate3D>(x, y, cs2::CUILength{ 0.0f, cs2::CUILength::k_EUILengthLength });
    }

private:
    template <typename T, typename... Args>
    [[nodiscard]] T* create(Args&&... args) const noexcept
    {
        if (const auto vmt = getVmt<T>()) {
            if (const auto memory = hookContext.template make<MemAlloc>().allocate(sizeof(T)))
                return new (memory) T{ vmt, std::forward<Args>(args)... };
        }
        return nullptr;
    }

    template <typename T>
    [[nodiscard]] const void* getVmt() const noexcept
    {
        if constexpr (std::is_same_v<T, cs2::CTransformTranslate3D>)
            return transformTranslate3dVmt;
        else if constexpr (std::is_same_v<T, cs2::CTransformScale3D>)
            return transformScale3dVmt;
        else
            static_assert(!std::is_same_v<T, T>, "Unsupported type");
    }

    HookContext& hookContext;
    const void* transformTranslate3dVmt;
    const void* transformScale3dVmt;
};

```

`Source/GameClient/Panorama/PanoramaTransformations.h`:

```h
#pragma once

#include <array>
#include <cstddef>

#include <CS2/Classes/CUtlVector.h>
#include <CS2/Panorama/Transform3D.h>

template <std::size_t N>
struct PanoramaTransformations {
    void applyTo(auto&& panel) noexcept
    {
        panel.setTransform3D(transformations);
    }

    std::array<cs2::CTransform3D*, N> transformations;
};

template <typename... Args>
PanoramaTransformations(Args...) -> PanoramaTransformations<sizeof...(Args)>;

```

`Source/GameClient/Panorama/PanoramaUiEngine.h`:

```h
#pragma once

#include <Platform/Macros/FunctionAttributes.h>
#include <Platform/Macros/IsPlatform.h>
#include <MemoryPatterns/PatternTypes/UiEnginePatternTypes.h>

template <typename HookContext>
class PanoramaUiEngine {
public:
    explicit PanoramaUiEngine(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void runScript(cs2::CUIPanel* contextPanel, const char* scriptSource) noexcept
    {
        // Game update on 3 October 2024 added panorama script caching (panorama_script_cache_enabled convar)
        // By setting 'line' to non-zero value we disable caching so we don't have to specify different file path for different scripts
        constexpr auto originFile{'\0'};
        constexpr auto line{1};
        if (hookContext.patternSearchResults().template get<RunScriptFunctionPointer>() && thisptr())
            hookContext.patternSearchResults().template get<RunScriptFunctionPointer>()(*thisptr(), contextPanel, scriptSource, &originFile, line);
    }

    [[nodiscard]] decltype(auto) getPanelFromHandle(cs2::PanelHandle handle) noexcept
    {
        if (hookContext.patternSearchResults().template get<GetPanelPointerFunctionPointer>() && thisptr())
            return hookContext.uiPanel(hookContext.patternSearchResults().template get<GetPanelPointerFunctionPointer>()(*thisptr(), &handle));
        return hookContext.uiPanel(nullptr);
    }

    [[NOINLINE]] void deletePanelByHandle(cs2::PanelHandle handle) noexcept
    {
        if (handle.isValid())
            onDeletePanel(handle);
    }

    [[nodiscard]] cs2::CPanoramaSymbol makeSymbol(int type, const char* text) noexcept
    {
        if (hookContext.patternSearchResults().template get<MakeSymbolFunctionPointer>() && thisptr())
            return hookContext.patternSearchResults().template get<MakeSymbolFunctionPointer>()(*thisptr(), type, text);
        return -1;
    }

    void registerEventHandler(cs2::CPanoramaSymbol symbol, cs2::CUIPanel* panel, cs2::CUtlAbstractDelegate handler) noexcept
    {
        if (hookContext.patternSearchResults().template get<RegisterEventHandlerFunctionPointer>() && thisptr())
            hookContext.patternSearchResults().template get<RegisterEventHandlerFunctionPointer>()(*thisptr(), symbol, panel, &handler);
    }

private:
    [[nodiscard]] auto thisptr() const noexcept
    {
        return hookContext.patternSearchResults().template get<UiEnginePointer>();
    }

    void onDeletePanel(cs2::PanelHandle panelHandle) noexcept
    {
        cs2::CPanel2D* clientPanel = getPanelFromHandle(panelHandle).clientPanel();
        if (clientPanel && hookContext.patternSearchResults().template get<OnDeletePanelFunctionPointer>() && thisptr())
            hookContext.patternSearchResults().template get<OnDeletePanelFunctionPointer>()(*thisptr(), clientPanel);
    }

    HookContext& hookContext;
};

```

`Source/GameClient/Panorama/PanoramaUiPanel.h`:

```h
#pragma once

#include <string_view>
#include <utility>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/CUtlVector.h>
#include <CS2/Panorama/CPanelStyle.h>
#include <CS2/Panorama/CPanoramaSymbol.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/CUIPanel.h>
#include <CS2/Panorama/StyleEnums.h>
#include <CS2/Panorama/StyleProperties.h>
#include <CS2/Panorama/Transform3D.h>
#include <GameClient/Panorama/PanelAlignmentParams.h>
#include <GameClient/Panorama/PanelFontParams.h>
#include <GameClient/Panorama/PanelMarginParams.h>
#include <GameClient/Panorama/PanelShadowParams.h>
#include <MemoryPatterns/PatternTypes/PanelStylePatternTypes.h>
#include <MemoryPatterns/PatternTypes/UiPanelPatternTypes.h>
#include <Utils/Lvalue.h>

#include "ClientPanel.h"
#include "PanelStylePropertyFactory.h"
#include "PanoramaUiPanelChildPanels.h"
#include "PanoramaUiPanelClasses.h"
#include "PanoramaUiPanelMethodInvoker.h"
#include "TopLevelWindow.h"

template <typename HookContext>
class PanoramaUiPanel {
public:
    PanoramaUiPanel(HookContext& hookContext, cs2::CUIPanel* panel) noexcept
        : hookContext{hookContext}
        , panel{panel}
    {
    }

    template <template <typename...> typename T, typename... Args>
    [[nodiscard]] decltype(auto) as(Args&&... args) const noexcept
    {
        return hookContext.template make<T>(panel, std::forward<Args>(args)...);
    }

    [[nodiscard]] decltype(auto) getHandle() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToPanelHandle>().of(panel).valueOr(cs2::PanelHandle{});
    }

    [[nodiscard]] decltype(auto) clientPanel() const noexcept
    {
        return hookContext.template make<ClientPanel>(clientPanelPointer());
    }

    void setParent(cs2::CUIPanel* parent) const noexcept
    {
        if (parent) {
            if (auto&& setParentFn = setParent())
                setParentFn(parent);
        }
    }

    void fitParent() const noexcept
    {
        setWidth(cs2::CUILength{100.0f, cs2::CUILength::k_EUILengthPercent});
        setHeight(cs2::CUILength{100.0f, cs2::CUILength::k_EUILengthPercent});
    }

    void show() const noexcept
    {
        setVisible(true);
    }

    void hide() const noexcept
    {
        setVisible(false);
    }

    void setVisible(bool visible) const noexcept
    {
        if (isVisible() != visible) {
            if (auto&& setVisibleFn = setVisible())
                setVisibleFn(visible);
        }
    }

    [[nodiscard]] decltype(auto) findChildInLayoutFile(const char* childId) const noexcept
    {
        auto&& childPanels = children();

        for (auto&& childPanel : childPanels) {
            if (std::strcmp(childPanel.getId(), childId) == 0)
                return utils::lvalue<decltype(childPanel)>(childPanel);
        }

        for (auto&& childPanel : childPanels) {
            if (!childPanel.hasOwnLayoutFile().valueOr(true)) {
                if (auto&& foundPanel = childPanel.findChildInLayoutFile(childId))
                    return utils::lvalue<decltype(foundPanel)>(foundPanel);
            }
        }

        return hookContext.template make<PanoramaUiPanel<HookContext>>(nullptr);
    }

    [[nodiscard]] const char* getAttributeString(cs2::CPanoramaSymbol attributeName, const char* defaultValue) const noexcept
    {
        if (auto&& getAttributeStringFn = getAttributeString())
            return getAttributeStringFn(attributeName, defaultValue);
        return defaultValue;
    }

    void setAttributeString(cs2::CPanoramaSymbol attributeName, const char* value) const noexcept
    {
        if (auto&& setAttributeStringFn = setAttributeString())
            return setAttributeStringFn(attributeName, value);
    }

    [[nodiscard]] bool hasClass(cs2::CPanoramaSymbol className) const noexcept
    {
        return classes().hasClass(className);
    }

    [[nodiscard]] auto hasOwnLayoutFile() const noexcept
    {
        return hasFlag(cs2::k_EPanelFlag_HasOwnLayoutFile);
    }

    [[nodiscard]] auto isVisible() const noexcept
    {
        return hasFlag(cs2::k_EPanelFlag_IsVisible);
    }

    [[nodiscard]] decltype(auto) children() const noexcept
    {
        return PanoramaUiPanelChildPanels{hookContext, hookContext.patternSearchResults().template get<ChildPanelsVectorOffset>().of(panel).get()};
    }

    explicit(false) operator cs2::CUIPanel*() const noexcept
    {
        return panel;
    }

    explicit operator bool() const noexcept
    {
        return panel != nullptr;
    }

    void setOpacity(float opacity) const noexcept
    {
        setStyleProperty(propertyFactory().opacity(opacity));
    }

    void setWidth(cs2::CUILength width) const noexcept
    {
        setStyleProperty(propertyFactory().width(width));
    }

    void setHeight(cs2::CUILength height) const noexcept
    {
        setStyleProperty(propertyFactory().height(height));
    }

    void setZIndex(float zIndex) const noexcept
    {
        setStyleProperty(propertyFactory().zIndex(zIndex));
    }

    void setImageShadow(const PanelShadowParams& params) const noexcept
    {
        setStyleProperty(propertyFactory().imageShadow(params));
    }

    void setPosition(cs2::CUILength x, cs2::CUILength y) const noexcept
    {
        setStyleProperty(propertyFactory().position(x, y));
    }

    void setTransformOrigin(cs2::CUILength x, cs2::CUILength y) const noexcept
    {
        setStyleProperty(propertyFactory().transformOrigin(x, y));
    }

    void setAlign(const PanelAlignmentParams& params) const noexcept
    {
        setStyleProperty(propertyFactory().align(params));
    }

    void setWashColor(cs2::Color color) const noexcept
    {
        setStyleProperty(propertyFactory().washColor(color));
    }

    void setFlowChildren(cs2::EFlowDirection flowDirection) const noexcept
    {
        setStyleProperty(propertyFactory().flowChildren(flowDirection));
    }

    void setFont(const PanelFontParams& params) const noexcept
    {
        setStyleProperty(propertyFactory().font(params));
    }

    void setTextShadow(const PanelShadowParams& params) const noexcept
    {
        setStyleProperty(propertyFactory().textShadow(params));
    }

    void setMargin(const PanelMarginParams& params) const noexcept
    {
        setStyleProperty(propertyFactory().margin(params));
    }

    void setMixBlendMode(cs2::EMixBlendMode mode) const noexcept
    {
        setStyleProperty(propertyFactory().mixBlendMode(mode));
    }

    void setTextAlign(cs2::ETextAlign textAlign) const noexcept
    {
        setStyleProperty(propertyFactory().textAlign(textAlign));
    }

    void setColor(cs2::Color color) const noexcept
    {
        setStyleProperty(propertyFactory().foregroundColor(color));
    }
    
    void setBackgroundColor(cs2::Color color) const noexcept
    {
        setStyleProperty(propertyFactory().backgroundColor(color));
    }

    void setTransform3D(std::span<cs2::CTransform3D*> transforms) const noexcept
    {
        setStyleProperty(propertyFactory().transform3D(transforms));
    }

    void setBorder(cs2::CUILength width, cs2::Color color) const noexcept
    {
        setStyleProperty(propertyFactory().border(width, color));
    }

    void setBorderRadius(cs2::CUILength radius) const noexcept
    {
        setStyleProperty(propertyFactory().borderRadius(radius));
    }

    [[nodiscard]] decltype(auto) getUiScaleFactor() const noexcept
    {
        return getParentWindow().getUiScaleFactor();
    }

private:
    template <typename StyleProperty>
    void setStyleProperty(std::optional<StyleProperty> styleProperty) const
    {
        if (styleProperty.has_value())
            setProperty(&*styleProperty);
    }

    void setProperty(cs2::CStyleProperty* styleProperty) const noexcept
    {
        if (!styleProperty)
            return;

        const auto style = getStyle();
        if (!style)
            return;

        if (const auto setPropertyFn{hookContext.patternSearchResults().template get<SetPanelStylePropertyFunctionPointer>()})
            setPropertyFn(style, styleProperty, true);
    }

    [[nodiscard]] PanoramaUiPanelClasses classes() const noexcept
    {
        return PanoramaUiPanelClasses{hookContext.patternSearchResults().template get<PanelClassesVectorOffset>().of(panel).get()};
    }

    [[nodiscard]] decltype(auto) getParentWindow() const noexcept
    {
        return hookContext.template make<TopLevelWindow>(hookContext.patternSearchResults().template get<ParentWindowOffset>().of(panel).valueOr(nullptr));
    }

    [[nodiscard]] Optional<bool> hasFlag(cs2::EPanelFlag flag) const noexcept
    {
        return (hookContext.patternSearchResults().template get<OffsetToPanelFlags>().of(panel).toOptional() & flag) != 0;
    }

    [[nodiscard]] auto setParent() const noexcept
    {
        return PanoramaUiPanelMethodInvoker{panel, hookContext.patternSearchResults().template get<SetParentFunctionOffset>()};
    }

    [[nodiscard]] auto setVisible() const noexcept
    {
        return PanoramaUiPanelMethodInvoker{panel, hookContext.patternSearchResults().template get<SetVisibleFunctionOffset>()};
    }

    [[nodiscard]] auto getAttributeString() const noexcept
    {
        return PanoramaUiPanelMethodInvoker{panel, hookContext.patternSearchResults().template get<GetAttributeStringFunctionOffset>()};
    }

    [[nodiscard]] auto setAttributeString() const noexcept
    {
        return PanoramaUiPanelMethodInvoker{panel, hookContext.patternSearchResults().template get<SetAttributeStringFunctionOffset>()};
    }

    [[nodiscard]] auto propertyFactory() const noexcept
    {
        return hookContext.template make<PanelStylePropertyFactory>(hookContext.stylePropertySymbolsAndVMTs());
    }

    [[nodiscard]] cs2::CPanel2D* clientPanelPointer() const noexcept
    {
        if (panel)
            return panel->clientPanel;
        return nullptr;
    }

    [[nodiscard]] cs2::CPanelStyle* getStyle() const noexcept
    {
        return hookContext.patternSearchResults().template get<PanelStyleOffset>().of(panel).get();
    }

    [[nodiscard]] const char* getId() const noexcept
    {
        if (const auto id = hookContext.patternSearchResults().template get<OffsetToPanelId>().of(panel).get(); id && id->m_pString)
            return id->m_pString;
        return "";
    }

    HookContext& hookContext;
    cs2::CUIPanel* panel;
};

```

`Source/GameClient/Panorama/PanoramaUiPanelChildPanels.h`:

```h
#pragma once

#include <cstddef>
#include <utility>

#include <CS2/Classes/CUtlVector.h>
#include <CS2/Panorama/CUIPanel.h>

#include "PanoramaUiPanelIterator.h"

template <typename HookContext>
struct PanoramaUiPanelChildPanels {
    PanoramaUiPanelChildPanels(HookContext& hookContext, cs2::CUtlVector<cs2::CUIPanel*>* vector) noexcept
        : hookContext{hookContext}
        , vector{vector}
    {
    }

    [[nodiscard]] decltype(auto) begin() noexcept
    {
        if (vector && vector->memory)
            return hookContext.template make<PanoramaUiPanelIterator>(vector->memory);
        return hookContext.template make<PanoramaUiPanelIterator>(nullptr);
    }

    [[nodiscard]] decltype(auto) end() noexcept
    {
        if (vector && vector->memory)
            return hookContext.template make<PanoramaUiPanelIterator>(vector->memory + vector->size);
        return hookContext.template make<PanoramaUiPanelIterator>(nullptr);
    }

    [[nodiscard]] decltype(auto) operator[](std::size_t index) noexcept
    {
        if (vector && std::cmp_less(index, vector->size))
            return hookContext.uiPanel(vector->memory[index]);
        return hookContext.uiPanel(nullptr);
    }

    template <typename F>
    void forEach(F&& f) noexcept
    {
        if (!vector)
            return;

        for (int i = 0; i < vector->size; ++i)
            f(hookContext.uiPanel(vector->memory[i]));
    }

    HookContext& hookContext;
    cs2::CUtlVector<cs2::CUIPanel*>* vector;
};

```

`Source/GameClient/Panorama/PanoramaUiPanelClasses.h`:

```h
#pragma once

#include <CS2/Panorama/CPanoramaSymbol.h>
#include <CS2/Panorama/CUIPanel.h>

struct PanoramaUiPanelClasses {
    [[nodiscard]] bool hasClass(cs2::CPanoramaSymbol className) const noexcept
    {
        if (!classes)
            return false;

        for (int i = 0; i < classes->size; ++i) {
            if (classes->memory[i] == className)
                return true;
        }
        return false;
    }

    const cs2::CUIPanel::classesVector* classes;
};

```

`Source/GameClient/Panorama/PanoramaUiPanelIterator.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>

template <typename HookContext>
struct PanoramaUiPanelIterator {
    PanoramaUiPanelIterator(HookContext& hookContext, cs2::CUIPanel** panel) noexcept
        : hookContext{hookContext}
        , panel{panel}
    {
    }

    [[nodiscard]] friend bool operator==(const PanoramaUiPanelIterator& lhs, const PanoramaUiPanelIterator& rhs) noexcept
    {
        return lhs.panel == rhs.panel;
    }

    PanoramaUiPanelIterator& operator++() noexcept
    {
        ++panel;
        return *this;
    }

    [[nodiscard]] auto operator*() const noexcept
    {
        return hookContext.uiPanel(*panel);
    }

    HookContext& hookContext;
    cs2::CUIPanel** panel;
};

```

`Source/GameClient/Panorama/PanoramaUiPanelMethodInvoker.h`:

```h
#pragma once

#include <utility>

#include <CS2/Panorama/CUIPanel.h>

template <typename OffsetType>
struct PanoramaUiPanelMethodInvoker {
    PanoramaUiPanelMethodInvoker(cs2::CUIPanel* panel, OffsetType offsetToFunction)
        : panel{panel}
        , function{panel ? offsetToFunction.of(panel->vmt).get() : nullptr}
    {
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return panel != nullptr && function != nullptr;
    }

    template <typename... Args>
    decltype(auto) operator()(Args&&... args) const noexcept
    {
        return (*function)(panel, std::forward<Args>(args)...);
    }

    cs2::CUIPanel* panel;
    typename OffsetType::FieldType* function;
};

```

`Source/GameClient/Panorama/Slider.h`:

```h
#pragma once

#include <CS2/Panorama/CSlider.h>
#include <MemoryPatterns/PatternTypes/SliderPatternTypes.h>

template <typename HookContext>
class Slider {
public:
    using RawType = cs2::CSlider;

    Slider(HookContext& hookContext, cs2::CSlider* slider) noexcept
        : hookContext{hookContext}
        , slider{slider}
    {
    }

    void setValue(float value) noexcept
    {
        if (slider && setValueFunction())
            setValueFunction()(slider, value);
    }

private:
    [[nodiscard]] decltype(auto) setValueFunction() const noexcept
    {
        return hookContext.patternSearchResults().template get<SliderSetValueFunction>();
    }

    HookContext& hookContext;
    cs2::CSlider* slider;
};

```

`Source/GameClient/Panorama/StylePropertiesSymbolsAndVMTs.h`:

```h
#pragma once

#include <array>
#include <tuple>

#include <CS2/Constants/StylePropertySymbolNames.h>
#include <CS2/Constants/StylePropertyTypeNames.h>
#include <CS2/Panorama/CStyleSymbol.h>
#include <Platform/VmtFinder.h>
#include <Utils/TypeIndex.h>

#include "StylePropertySymbolMap.h"

struct StylePropertiesSymbolsAndVMTs {
    StylePropertiesSymbolsAndVMTs() = default;

    StylePropertiesSymbolsAndVMTs(StylePropertySymbolMap symbolMap, const VmtFinder& panoramaVmtFinder) noexcept
    {
        cs2::kStylePropertySymbolNames.forEach([i = 0u, &symbolMap, this](const auto typeName) mutable { symbols[i++] = symbolMap.findSymbol(typeName); });
        cs2::kStylePropertyTypeNames.forEach([i = 0u, &panoramaVmtFinder, this](const auto typeName) mutable { vmts[i++] = panoramaVmtFinder.findVmt(typeName); });
    }

    template <typename StyleProperty>
    [[nodiscard]] cs2::CStyleSymbol getSymbol() const noexcept
    {
        return symbols[utils::typeIndex<StyleProperty, StyleProperties>()];
    }

    template <typename StyleProperty>
    [[nodiscard]] const void* getVmt() const noexcept
    {
        return vmts[utils::typeIndex<StyleProperty, StyleProperties>()];
    }

private:
    using StyleProperties = decltype(cs2::kStylePropertySymbolNames)::TypeList;

    std::array<cs2::CStyleSymbol, std::tuple_size_v<StyleProperties>> symbols;
    std::array<const void*, std::tuple_size_v<StyleProperties>> vmts;
};

```

`Source/GameClient/Panorama/StylePropertySymbolMap.h`:

```h
#pragma once

#include <cstring>

#include <CS2/Panorama/CPanelStyle.h>
#include <CS2/Panorama/CStyleSymbol.h>
#include <Platform/Macros/FunctionAttributes.h>

struct StylePropertySymbolMap {
    [[nodiscard]] [[NOINLINE]] cs2::CStyleSymbol findSymbol(const char* stylePropertyName) const noexcept
    {
        if (!symbols)
            return {};

        for (int i = 0; i < symbols->numElements; ++i) {
            if (std::strcmp(symbols->memory[i].key.m_pString, stylePropertyName) == 0)
                return symbols->memory[i].value;
        }
        return {};
    }

    const cs2::CPanelStyle::StylePropertySymbols* symbols;
};

```

`Source/GameClient/Panorama/TextEntry.h`:

```h
#pragma once

#include <CS2/Panorama/CTextEntry.h>
#include <MemoryPatterns/PatternTypes/TextEntryPatternTypes.h>

template <typename HookContext>
class TextEntry {
public:
    using RawType = cs2::CTextEntry;

    TextEntry(HookContext& hookContext, cs2::CTextEntry* textEntry) noexcept
        : hookContext{hookContext}
        , textEntry{textEntry}
    {
    }

    void setText(const char* text) noexcept
    {
        if (textEntry && setTextFunction())
            setTextFunction()(textEntry, text);
    }

private:
    [[nodiscard]] decltype(auto) setTextFunction() const noexcept
    {
        return hookContext.patternSearchResults().template get<TextEntrySetTextFunction>();
    }

    HookContext& hookContext;
    cs2::CTextEntry* textEntry;
};

```

`Source/GameClient/Panorama/TopLevelWindow.h`:

```h
#pragma once

#include <CS2/Panorama/CTopLevelWindow.h>
#include <MemoryPatterns/PatternTypes/TopLevelWindowPatternTypes.h>

template <typename HookContext>
class TopLevelWindow {
public:
    explicit TopLevelWindow(HookContext& hookContext, cs2::CTopLevelWindow* topLevelWindow) noexcept
        : hookContext{hookContext}
        , topLevelWindow{topLevelWindow}
    {
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return topLevelWindow != nullptr;
    }

    [[nodiscard]] auto getUiScaleFactor() const noexcept
    {
        return hookContext.patternSearchResults().template get<UiScaleFactorOffset>().of(topLevelWindow).toOptional();
    }

private:
    HookContext& hookContext;
    cs2::CTopLevelWindow* topLevelWindow;
};

```

`Source/GameClient/Panorama/Ui3dPanel.h`:

```h
#pragma once

#include <CS2/Panorama/CUI_3dPanel.h>
#include <GameClient/PortraitWorld.h>
#include <MemoryPatterns/PatternTypes/Ui3dPanelPatternTypes.h>

template <typename HookContext>
class Ui3dPanel {
public:
    Ui3dPanel(HookContext& hookContext, cs2::CUI_3dPanel* ui3dPanel) noexcept
        : hookContext{hookContext}
        , ui3dPanel{ui3dPanel}
    {
    }

    using RawType = cs2::CUI_3dPanel;

    [[nodiscard]] decltype(auto) portraitWorld() const noexcept
    {
        return hookContext.template make<PortraitWorld>(portraitWorldPointer());
    }

    void setFov(float fov) const noexcept
    {
        hookContext.patternSearchResults().template get<OffsetTo3dPanelFovWeight>().of(ui3dPanel) = 1.0f;
        hookContext.patternSearchResults().template get<OffsetTo3dPanelFov>().of(ui3dPanel) = fov;
    }

    template <template <typename...> typename T>
    [[nodiscard]] decltype(auto) as() const noexcept
    {
        return hookContext.template make<T>(static_cast<T<HookContext>::RawType*>(ui3dPanel));
    }

private:
    [[nodiscard]] decltype(auto) portraitWorldPointer() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToPortraitWorld>().of(ui3dPanel).valueOr(nullptr);
    }

    HookContext& hookContext;
    cs2::CUI_3dPanel* ui3dPanel;
};

```

`Source/GameClient/Panorama/UiItem3dPanel.h`:

```h
#pragma once

#include <CS2/Panorama/CUI_Item3dPanel.h>
#include <MemoryPatterns/PatternTypes/UiItem3dPanelPatternTypes.h>

template <typename HookContext>
class UiItem3dPanel {
public:
    UiItem3dPanel(HookContext& hookContext, cs2::CUI_Item3dPanel* uiItem3dPanel) noexcept
        : hookContext{hookContext}
        , uiItem3dPanel{uiItem3dPanel}
    {
    }

    using RawType = cs2::CUI_Item3dPanel;

    void createItem(cs2::ItemId itemId) const noexcept
    {
        forceItemEntityToBeCreated();
        setItemId(itemId);
        assert(unknownFieldHasDefaultValue());
    }

    void startWeaponLookAt() const noexcept
    {
        hookContext.patternSearchResults().template get<OffsetToStartWeaponLookAt>().of(uiItem3dPanel) = true;
    }

private:
    void forceItemEntityToBeCreated() const noexcept
    {
        assert(unknownFieldHasDefaultValue());
        unknownField() = 0;
    }

    void setItemId(cs2::ItemId itemId) const noexcept
    {
        if (const auto setItemItemIdFunction = hookContext.patternSearchResults().template get<SetItemItemIdFunction>(); setItemItemIdFunction && uiItem3dPanel)
            setItemItemIdFunction(uiItem3dPanel, itemId, "");
    }

    [[nodiscard]] [[maybe_unused]] bool unknownFieldHasDefaultValue() const noexcept
    {
        constexpr auto kDefaultValue = -1;
        return unknownField().valueOr(kDefaultValue) == kDefaultValue;
    }

    [[nodiscard]] decltype(auto) unknownField() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToItem3dPanelUnknownField>().of(properties());
    }

    [[nodiscard]] decltype(auto) properties() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToItem3dPanelProperties>().of(uiItem3dPanel).get();
    }

    HookContext& hookContext;
    cs2::CUI_Item3dPanel* uiItem3dPanel;
};

```

`Source/GameClient/PortraitWorld.h`:

```h
#pragma once

#include <CS2/Classes/CCS_PortraitWorld.h>
#include <CS2/Classes/Entities/C_CSGO_PreviewPlayer.h>
#include <GameClient/Entities/BaseWeapon.h>
#include <GameClient/Entities/PreviewPlayer.h>
#include <GameClient/EntitySystem/EntitySystem.h>
#include <MemoryPatterns/PatternTypes/PortraitWorldPatternTypes.h>

template <typename HookContext>
class PortraitWorld {
public:
    PortraitWorld(HookContext& hookContext, cs2::CCS_PortraitWorld* portraitWorld) noexcept
        : hookContext{hookContext}
        , portraitWorld{portraitWorld}
    {
    }

    [[nodiscard]] decltype(auto) findPreviewPlayer() const
    {
        return findEntity([](auto&& entityIdentity) { return entityIdentity.template is<cs2::C_CSGO_PreviewPlayer>(); }).template as<PreviewPlayer>();
    }

    [[nodiscard]] decltype(auto) findPreviewWeapon() const
    {
        return findEntity([](auto&& entityIdentity) { return entityIdentity.classify().isWeapon(); }).template as<BaseWeapon>();
    }

    [[nodiscard]] bool isMapLoaded() const
    {
        const auto entityHandles = hookContext.patternSearchResults().template get<OffsetToPortraitWorldMapEntities>().of(portraitWorld).get();
        return entityHandles && entityHandles->size > 0;
    }

private:
    [[nodiscard]] decltype(auto) findEntity(auto&& predicate) const
    {
        const auto entityHandles = hookContext.patternSearchResults().template get<OffsetToPortraitWorldEntities>().of(portraitWorld).get();
        if (!entityHandles)
            return hookContext.template make<BaseEntity>(nullptr);

        for (int i = 0; i < entityHandles->size; ++i) {
            auto&& entityIdentity = hookContext.template make<EntitySystem>().getEntityIdentityFromHandle(entityHandles->memory[i]);
            if (predicate(entityIdentity))
                return entityIdentity.entity();
        }
        return hookContext.template make<BaseEntity>(nullptr);
    }

    HookContext& hookContext;
    cs2::CCS_PortraitWorld* portraitWorld;
};

```

`Source/GameClient/SceneSystem/SceneObject.h`:

```h
#pragma once

#include <CS2/Classes/CSceneObject.h>
#include <MemoryPatterns/PatternTypes/SceneObjectPatternTypes.h>

#include "SceneObjectAttributes.h"
#include "SceneSystem.h"

template <typename HookContext>
class SceneObject {
public:
    SceneObject(HookContext& hookContext, cs2::CSceneObject* sceneObject) noexcept
        : hookContext{hookContext}
        , sceneObject{sceneObject}
    {
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return sceneObject != nullptr;
    }

    [[nodiscard]] operator cs2::CSceneObject*() const noexcept
    {
        return sceneObject;
    }

    [[nodiscard]] auto objectClass() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToSceneObjectClass>().of(sceneObject).toOptional();
    }

    [[nodiscard]] auto attributes() const noexcept
    {
        hookContext.template make<SceneSystem>().allocateAttributeList(sceneObject);
        return hookContext.template make<SceneObjectAttributes>(hookContext.patternSearchResults().template get<OffsetToSceneObjectAttributes>().of(sceneObject).valueOr(nullptr));
    }

    [[nodiscard]] auto isCulledByFirstPersonView() const noexcept
    {
        // set when camera is inside the upper body e.g. when spectating in first person
        return (renderableFlags() & cs2::SCENEOBJECTFLAG_PIPELINE_SPECIFIC_2).notEqual(0);
    }

    [[nodiscard]] auto isPartOfViewmodel() const noexcept
    {
        return (renderableFlags() & cs2::SCENEOBJECTFLAG_VIEWMODEL_LAYER).notEqual(0);
    }

private:
    [[nodiscard]] auto renderableFlags() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToSceneObjectRenderableFlags>().of(sceneObject).toOptional();
    }

    HookContext& hookContext;
    cs2::CSceneObject* sceneObject;
};

```

`Source/GameClient/SceneSystem/SceneObjectAttributes.h`:

```h
#pragma once

#include <cstring>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/CSceneObject.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <Platform/Macros/IsPlatform.h>

template <typename HookContext>
class SceneObjectAttributes {
public:
    SceneObjectAttributes(HookContext& hookContext, cs2::SceneObjectAttributes* attributes) noexcept
        : hookContext{hookContext}
        , attributes{attributes}
    {
    }

    void setAttributeFloat(unsigned int attributeNameHash, float value) const noexcept
    {
        if (!attributes)
            return;

        float float4[]{value, value, value, value};
#if IS_WIN64()
        hookContext.patternSearchResults().template get<SetSceneObjectAttributeFloat4>()(&attributes->floatAttributes, attributeNameHash, float4);
#elif IS_LINUX()
        double temp[2];
        static_assert(sizeof(float4) == sizeof(temp));
        std::memcpy(&temp, &float4, sizeof(float4));
        hookContext.patternSearchResults().template get<SetSceneObjectAttributeFloat4>()(&attributes->floatAttributes, attributeNameHash, temp[0], temp[1]);
#endif
    }

    void setAttributeColor3(unsigned int attributeNameHash, cs2::Color color) const noexcept
    {
        if (!attributes)
            return;

        float colorFloat[]{color.r() / 255.0f, color.g() / 255.0f, color.b() / 255.0f, 0.0f};
#if IS_WIN64()
        hookContext.patternSearchResults().template get<SetSceneObjectAttributeFloat4>()(&attributes->floatAttributes, attributeNameHash, colorFloat);
#elif IS_LINUX()
        double temp[2];
        static_assert(sizeof(colorFloat) == sizeof(temp));
        std::memcpy(&temp, &colorFloat, sizeof(colorFloat));
        hookContext.patternSearchResults().template get<SetSceneObjectAttributeFloat4>()(&attributes->floatAttributes, attributeNameHash, temp[0], temp[1]);
#endif
    }

private:
    HookContext& hookContext;
    cs2::SceneObjectAttributes* attributes;
};

```

`Source/GameClient/SceneSystem/SceneObjectUpdater.h`:

```h
#pragma once

#include <CS2/Classes/SceneObjectUpdaterHandle_t.h>
#include <MemoryPatterns/PatternTypes/SceneObjectUpdaterPatternTypes.h>

#include "SceneObject.h"

template <typename HookContext>
class SceneObjectUpdater {
public:
    SceneObjectUpdater(HookContext& hookContext, cs2::SceneObjectUpdaterHandle_t* updater) noexcept
        : hookContext{hookContext}
        , updater{updater}
    {
    }

    [[nodiscard]] decltype(auto) sceneObject() const noexcept
    {
        return hookContext.template make<SceneObject>(hookContext.patternSearchResults().template get<OffsetToSceneObject>().of(updater).valueOr(nullptr));
    }

private:
    HookContext& hookContext;
    cs2::SceneObjectUpdaterHandle_t* updater;
};

```

`Source/GameClient/SceneSystem/SceneObjectUpdaters.h`:

```h
#pragma once

#include <cstddef>
#include <utility>

#include <CS2/Classes/CRenderComponent.h>
#include <CS2/Classes/SceneObjectUpdaterHandle_t.h>

#include "SceneObjectUpdater.h"

template <typename HookContext>
class SceneObjectUpdaters {
public:
    SceneObjectUpdaters(HookContext& hookContext, cs2::CRenderComponent::sceneObjectUpdaters* updaters) noexcept
        : hookContext{hookContext}
        , updaters{updaters}
    {
    }

    [[nodiscard]] decltype(auto) operator[](std::size_t index) const noexcept
    {
        return hookContext.template make<SceneObjectUpdater>(get(index));
    }

    template <typename F>
    void forEachSceneObject(F f) const noexcept
    {
        if (!updaters)
            return;

        for (int i = 0; i < updaters->size; ++i) {
            auto&& sceneObject = hookContext.template make<SceneObjectUpdater>(updaters->memory[i]).sceneObject();
            if (sceneObject)
                f(sceneObject);
        }
    }

private:
    [[nodiscard]] cs2::SceneObjectUpdaterHandle_t* get(std::size_t index) const noexcept
    {
        if (updaters && std::cmp_less(index, updaters->size))
            return updaters->memory[index];
        return nullptr;
    }
    
    HookContext& hookContext;
    cs2::CRenderComponent::sceneObjectUpdaters* updaters;
};

```

`Source/GameClient/SceneSystem/SceneSystem.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneSystemPatternTypes.h>

template <typename HookContext>
class SceneSystem {
public:
    explicit SceneSystem(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void deleteSceneObject(auto&& sceneObject) const noexcept
    {
        if (sceneObject && sceneSystem() && deleteSceneObjectFn()) {
            deleteSceneObjectFn()(sceneSystem(), sceneObject);
        }
    }

    void allocateAttributeList(auto&& sceneObject) const noexcept
    {
        if (sceneObject && sceneSystem() && allocateAttributeListFn()) {
            allocateAttributeListFn()(sceneSystem(), sceneObject);
        }
    }

private:
    [[nodiscard]] auto sceneSystem() const noexcept
    {
        return hookContext.patternSearchResults().template get<SceneSystemPointer>();
    }

    [[nodiscard]] auto deleteSceneObjectFn() const noexcept
    {
        return hookContext.patternSearchResults().template get<DeleteSceneObjectFunctionPointer>();
    }

    [[nodiscard]] auto allocateAttributeListFn() const noexcept
    {
        return hookContext.patternSearchResults().template get<AllocateAttributeListFunctionPointer>();
    }

    HookContext& hookContext;
};

```

`Source/GameClient/WorldToScreen/ClipSpaceCoordinates.h`:

```h
#pragma once

#include <cassert>

#include "NormalizedDeviceCoordinates.h"

struct ClipSpaceCoordinates {
    [[nodiscard]] bool onScreen() const noexcept
    {
        return w >= 0.001f;
    }

    [[nodiscard]] NormalizedDeviceCoordinates toNormalizedDeviceCoordinates() const noexcept
    {
        assert(onScreen());
        const auto inverseW = 1.0f / w;
        return NormalizedDeviceCoordinates{ x * inverseW, y * inverseW };
    }

    float x;
    float y;
    float z;
    float w;
};

```

`Source/GameClient/WorldToScreen/NormalizedDeviceCoordinates.h`:

```h
#pragma once

#include <CS2/Panorama/CUILength.h>

struct NormalizedDeviceCoordinates {
    NormalizedDeviceCoordinates(float x, float y) noexcept
        : x{ x }, y{ y }
    {
    }

    [[nodiscard]] cs2::CUILength getX() const noexcept
    {
        return cs2::CUILength{ (x + 1.0f) * 0.5f * 100.0f, cs2::CUILength::k_EUILengthPercent };
    }

    [[nodiscard]] cs2::CUILength getY() const noexcept
    {
        return cs2::CUILength{ (1.0f - y) * 0.5f * 100.0f, cs2::CUILength::k_EUILengthPercent };
    }

private:
    float x;
    float y;
};

```

`Source/GameClient/WorldToScreen/ViewToProjectionMatrix.h`:

```h
#pragma once

#include <CS2/Classes/VMatrix.h>
#include <CS2/Constants/AspectRatio.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>

template <typename HookContext>
class ViewToProjectionMatrix {
public:
    explicit ViewToProjectionMatrix(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] float getFovScale() const noexcept
    {
        if (matrix())
            return matrix()->m[1][1] / cs2::kDefaultAspectRatio;
        return 1.0f;
    }

    [[nodiscard]] std::optional<float> transformY(float yInViewSpace) const noexcept
    {
        if (matrix())
            return yInViewSpace * matrix()->m[1][1];
        return {};
    }

private:
    [[nodiscard]] decltype(auto) matrix() const
    {
        return hookContext.patternSearchResults().template get<ViewToProjectionMatrixPointer>();
    }

    HookContext& hookContext;
};

```

`Source/GameClient/WorldToScreen/WorldToClipSpaceConverter.h`:

```h
#pragma once

#include "ClipSpaceCoordinates.h"
#include <CS2/Classes/Vector.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>

template <typename HookContext>
struct WorldToClipSpaceConverter {
    explicit WorldToClipSpaceConverter(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] ClipSpaceCoordinates toClipSpace(const cs2::Vector& worldPosition) const noexcept
    {
        if (worldToProjectionMatrix()) {
            const auto& matrix = *worldToProjectionMatrix();
            return ClipSpaceCoordinates{
                .x = matrix.m[0][0] * worldPosition.x + matrix.m[0][1] * worldPosition.y + matrix.m[0][2] * worldPosition.z + matrix.m[0][3],
                .y = matrix.m[1][0] * worldPosition.x + matrix.m[1][1] * worldPosition.y + matrix.m[1][2] * worldPosition.z + matrix.m[1][3],
                .z = matrix.m[2][0] * worldPosition.x + matrix.m[2][1] * worldPosition.y + matrix.m[2][2] * worldPosition.z + matrix.m[2][3],
                .w = matrix.m[3][0] * worldPosition.x + matrix.m[3][1] * worldPosition.y + matrix.m[3][2] * worldPosition.z + matrix.m[3][3]
            };
        }
        return ClipSpaceCoordinates{.x = 0.0f, .y = 0.0f, .z = 0.0f, .w = 0.0f};
    }

private:
    [[nodiscard]] auto worldToProjectionMatrix() const noexcept
    {
        return hookContext.patternSearchResults().template get<WorldToProjectionMatrixPointer>();
    }

    HookContext& hookContext;
};

```

`Source/GlobalContext/DeferredCompleteObject.h`:

```h
#pragma once

#include <cassert>
#include <new>
#include <utility>

template <typename Partial, typename Complete>
class DeferredCompleteObject {
public:
    template <typename... Args>
    DeferredCompleteObject(Args&&... args) noexcept
        : partialObject{std::forward<Args>(args)...}
    {
    }

    DeferredCompleteObject(const DeferredCompleteObject&) = delete;
    DeferredCompleteObject(DeferredCompleteObject&&) = delete;
    DeferredCompleteObject& operator=(const DeferredCompleteObject&) = delete;
    DeferredCompleteObject& operator=(DeferredCompleteObject&&) = delete;

    [[nodiscard]] bool isComplete() const noexcept
    {
        return hasCompleteObject;
    }

    [[nodiscard]] Partial& partial() noexcept
    {
        assert(!isComplete());
        return partialObject;
    }

    [[nodiscard]] Complete& complete() noexcept
    {
        assert(isComplete());
        return completeObject;
    }

    template <typename... Args>
    void makeComplete(Args&&... args) noexcept
    {
        assert(!isComplete());
        partialObject.~Partial();
        new (&completeObject) Complete{std::forward<Args>(args)...};
        hasCompleteObject = true;
    }

    ~DeferredCompleteObject() noexcept
    {
        if (isComplete())
            completeObject.~Complete();
        else
            partialObject.~Partial();
    }

private:
    union {
        Partial partialObject;
        Complete completeObject;
    };

    bool hasCompleteObject{false};
};

```

`Source/GlobalContext/FullGlobalContext.h`:

```h
#pragma once

#include <Config/ConfigState.h>
#include <CS2/Classes/CLoopModeGame.h>
#include <GameClient/ConVars/ConVarsBase.h>
#include <GameClient/FileNameSymbolTableState.h>
#include <GameClient/Hud/HudState.h>
#include <GameClient/MemAllocState.h>
#include <GameClient/Panorama/PanoramaSymbols.h>
#include <OutlineGlow/GlowSceneObjectState.h>
#include <GameClient/DLLs/Tier0Dll.h>
#include <GameClient/Entities/EntityClassifier.h>
#include <Features/Common/RenderingHookEntityLoop.h>
#include <Features/Sound/Details/SoundWatcher.h>
#include <Features/Common/InWorldPanelsState.h>
#include <Features/FeaturesStates.h>
#include <Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreviewState.h>
#include <Features/Visuals/ModelGlow/Preview/WeaponModelGlowPreviewState.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCacheState.h>
#include <MemoryPatterns/AllMemoryPatternSearchResults.h>
#include <MemoryPatterns/MemoryPatterns.h>
#include <MemorySearch/PatternNotFoundLogger.h>
#include "UnloadFlag.h"
#include <Hooks/Hooks.h>
#include <Hooks/PeepEventsHook.h>
#include <GameClient/Hud/BombStatus/BombStatusPanelManager.h>
#include <GameClient/Hud/BombStatus/BombStatusPanelManagerContext.h>
#include <GameClient/Hud/BombStatus/BombStatusPanelState.h>
#include <MemorySearch/PatternFinder.h>
#include <MemorySearch/PatternSearchResults.h>
#include <UI/Panorama/PanoramaGUI.h>
#include <UI/Panorama/PanoramaGuiState.h>
#include <OutlineGlow/GlowSceneObjectsState.h>
#include <Platform/DynamicLibrary.h>
#include <Platform/VmtFinder.h>
#include <Vmt/VmtLengthCalculator.h>

#include "OsirisDirectoryPath.h"

#include <CS2/Classes/ConVarTypes.h>

struct FullGlobalContext {
    FullGlobalContext(PeepEventsHook peepEventsHook, DynamicLibrary clientDLL, DynamicLibrary panoramaDLL, const MemoryPatterns& memoryPatterns, Tier0Dll tier0Dll) noexcept
        : patternSearchResults{memoryPatterns}
        , fileNameSymbolTableState{tier0Dll}
        , memAllocState{tier0Dll}
        , stylePropertySymbolsAndVMTs{StylePropertySymbolMap{memoryPatterns.panelStylePatterns().stylePropertiesSymbols()}, VmtFinder{panoramaDLL.getVmtFinderParams()}}
        , hooks{
            peepEventsHook,
            patternSearchResults.get<ViewRenderPointer>(),
            VmtLengthCalculator{clientDLL.getCodeSection(), clientDLL.getVmtSection()}}
    {
    }

    OsirisDirectoryPath osirisDirectoryPath;
    ConfigState configState;
    AllMemoryPatternSearchResults patternSearchResults;
    FileNameSymbolTableState fileNameSymbolTableState;
    GlowSceneObjectState glowSceneObjectState;
    HudState hudState;
    MemAllocState memAllocState;
    StylePropertiesSymbolsAndVMTs stylePropertySymbolsAndVMTs;
    std::optional<ConVarsBase> conVars;
    std::optional<PanoramaSymbols> panoramaSymbols;
    Hooks hooks;
    SoundWatcherState soundWatcherState;
    FeaturesStates featuresStates;
    PanoramaGuiState panoramaGuiState;
    BombStatusPanelState bombStatusPanelState;
    InWorldPanelsState inWorldPanelsState;
    GlowSceneObjectsState glowSceneObjectsState;
    EntityClassifier entityClassifier;
    PlayerInfoPanelCacheState playerInfoPanelCacheState;
    PlayerModelGlowPreviewState playerModelGlowPreviewState;
    WeaponModelGlowPreviewState weaponModelGlowPreviewState;
};

```

`Source/GlobalContext/GlobalContext.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <span>

#include <BuildConfig.h>
#include <CS2/Classes/CViewRender.h>
#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <CS2/Constants/DllNames.h>
#include <GameClient/Entities/BaseEntity.h>
#include <GameClient/Entities/BaseWeapon.h>
#include <GameClient/Entities/PlayerPawn.h>
#include <GameClient/Entities/PreviewPlayer.h>
#include <Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVis.h>
#include <Features/Hud/DefusingAlert/DefusingAlert.h>
#include <Features/Hud/KillfeedPreserver/KillfeedPreserver.h>
#include <Features/Sound/SoundFeatures.h>
#include <Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreview.h>
#include <Features/Visuals/ViewmodelMod/ViewmodelMod.h>
#include <MemorySearch/PatternNotFoundLogger.h>
#include <MemoryAllocation/FreeMemoryRegionList.h>
#include <MemorySearch/PatternFinder.h>
#include <Platform/DynamicLibrary.h>
#include <Platform/Macros/FunctionAttributes.h>
#include <SDL/SdlDll.h>

#include "DeferredCompleteObject.h"
#include "FullGlobalContext.h"
#include "PartialGlobalContext.h"
#include "HookContext/HookContext.h"
#include <Hooks/ClientModeHooks.h>

class GlobalContext {
public:
    explicit GlobalContext(std::span<std::byte> memoryStorage, DynamicLibrary clientDLL, DynamicLibrary panoramaDLL, SdlDll sdlDll) noexcept
        : _freeRegionList{memoryStorage}
        , deferredCompleteContext{clientDLL, panoramaDLL, sdlDll}
    {
    }

    using Complete = FullGlobalContext;

    static void initializeInstance() noexcept
    {
        if (!globalContext.isInitialized()) {
            alignas(FreeMemoryRegionList::minimumAlignment()) static constinit std::byte storage[build::MEMORY_CAPACITY];
            globalContext.initialize(storage, DynamicLibrary{cs2::CLIENT_DLL}, DynamicLibrary{cs2::PANORAMA_DLL}, SdlDll{});
            globalContext->deferredCompleteContext.partial().enableIfValid();
        }
    }

    [[nodiscard]] static GlobalContext& instance() noexcept
    {
        return *globalContext;
    }

    static void destroyInstance() noexcept
    {
        globalContext.destroy();
    }

    [[nodiscard]] FreeMemoryRegionList& freeRegionList() noexcept
    {
        return _freeRegionList;
    }

    [[nodiscard]] FullGlobalContext& fullContext() noexcept
    {
        return deferredCompleteContext.complete();
    }

    [[nodiscard]] bool isComplete() noexcept
    {
        return deferredCompleteContext.isComplete();
    }

    [[NOINLINE]] void initCompleteContextFromGameThread() noexcept
    {
        const auto partialContext = deferredCompleteContext.partial();
        deferredCompleteContext.makeComplete(
            partialContext.peepEventsHook,
            partialContext.clientDLL,
            partialContext.panoramaDLL,
            MemoryPatterns{partialContext.patternFinders},
            Tier0Dll{}
        );
    }

private:
    FreeMemoryRegionList _freeRegionList;
    DeferredCompleteObject<PartialGlobalContext, FullGlobalContext> deferredCompleteContext;

    static constinit ManuallyDestructible<GlobalContext> globalContext;
};

```

`Source/GlobalContext/OsirisDirectoryPath.h`:

```h
#pragma once

#include <algorithm>
#include <cstddef>
#include <memory>
#include <string_view>

#include <MemoryAllocation/UniquePtr.h>
#include <Platform/PlatformPath.h>

#if IS_WIN64()
#include <Platform/Windows/DLLs/Shell32Dll.h>
#include <Platform/Windows/CoTaskMemDeleter.h>
#include <Utils/Wcslen.h>
#elif IS_LINUX()
#include <Platform/Linux/LinuxPlatformApi.h>
#endif

class OsirisDirectoryPath {
public:
    OsirisDirectoryPath() noexcept
    {
#if IS_WIN64()
        wchar_t* appDataPathRaw = nullptr;
        const auto getKnownFolderPath = Shell32Dll{}.SHGetKnownFolderPath();
        if (!getKnownFolderPath)
            return;
        const auto gotAppDataPath = getKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &appDataPathRaw);
        std::unique_ptr<wchar_t[], CoTaskMemDeleter> appDataPathMemory{appDataPathRaw};
        if (gotAppDataPath != S_OK)
            return;

        const std::wstring_view appDataPath{appDataPathRaw, utils::wcslen(appDataPathRaw)};
        constexpr std::wstring_view ntPathPrefix{L"\\??\\"};
        constexpr auto kPathSeparatorLength{1};
        constexpr auto kNullTerminatorLength{1};

        pathString = mem::makeUniqueForOverwrite<wchar_t[]>(ntPathPrefix.length() + appDataPath.length() + kPathSeparatorLength + build::kOsirisDirectoryName.length() + kNullTerminatorLength);
        if (!pathString)
            return;

        std::size_t writeIndex{0};
        std::ranges::copy(ntPathPrefix, pathString.get() + writeIndex);
        writeIndex += ntPathPrefix.length();
        std::ranges::copy(appDataPath, pathString.get() + writeIndex);
        writeIndex += appDataPath.length();
        pathString.get()[writeIndex++] = L'\\';
        std::ranges::copy(build::kOsirisDirectoryName, pathString.get() + writeIndex);
        writeIndex += build::kOsirisDirectoryName.length();
        pathString.get()[writeIndex++] = L'\0';
#elif IS_LINUX()
        const auto home = LinuxPlatformApi::getenv("HOME");
        if (!home)
            return;

        const std::string_view homePath{home};
        constexpr auto kPathSeparatorLength{1};
        constexpr auto kNullTerminatorLength{1};
        pathString = mem::makeUniqueForOverwrite<char[]>(homePath.length() + kPathSeparatorLength + build::kOsirisDirectoryName.length() + kNullTerminatorLength);
        if (!pathString)
            return;

        std::size_t writeIndex{0};
        std::ranges::copy(homePath, pathString.get());
        writeIndex += homePath.length();
        pathString.get()[writeIndex++] = '/';
        std::ranges::copy(build::kOsirisDirectoryName, pathString.get() + writeIndex);
        writeIndex += build::kOsirisDirectoryName.length();
        pathString.get()[writeIndex++] = '\0';
#endif
    }

    [[nodiscard]] platform::PathCharType* get() const noexcept
    {
        return pathString.get();
    }

private:
    UniquePtr<platform::PathCharType[]> pathString;
};

```

`Source/GlobalContext/PartialGlobalContext.h`:

```h
#pragma once

#include <CS2/Constants/DllNames.h>
#include <Hooks/PeepEventsHook.h>
#include <MemoryPatterns/MemoryPatterns.h>
#include <MemoryPatterns/PatternFinders.h>
#include <MemorySearch/PatternFinder.h>
#include <MemorySearch/PatternNotFoundLogger.h>
#include <Platform/DynamicLibrary.h>
#include <SDL/SdlDll.h>

struct PartialGlobalContext {
    explicit PartialGlobalContext(DynamicLibrary clientDLL, DynamicLibrary panoramaDLL, SdlDll sdlDLL) noexcept
        : patternFinders{
            PatternFinder<PatternNotFoundLogger>{clientDLL.getCodeSection().raw()},
            PatternFinder<PatternNotFoundLogger>{DynamicLibrary{cs2::TIER0_DLL}.getCodeSection().raw()},
            PatternFinder<PatternNotFoundLogger>{DynamicLibrary{cs2::SOUNDSYSTEM_DLL}.getCodeSection().raw()},
            PatternFinder<PatternNotFoundLogger>{DynamicLibrary{cs2::FILESYSTEM_DLL}.getCodeSection().raw()},
            PatternFinder<PatternNotFoundLogger>{panoramaDLL.getCodeSection().raw()},
            PatternFinder<PatternNotFoundLogger>{sdlDLL.getCodeSection().raw()},
            PatternFinder<PatternNotFoundLogger>{DynamicLibrary{cs2::SCENESYSTEM_DLL}.getCodeSection().raw()}}
        , clientDLL{clientDLL}
        , panoramaDLL{panoramaDLL}
        , peepEventsHook{MemoryPatterns{patternFinders}.sdlPatterns().peepEventsPointer(sdlDLL.peepEvents())}
    {
    }

    PatternFinders patternFinders;
    DynamicLibrary clientDLL;
    DynamicLibrary panoramaDLL;
    PeepEventsHook peepEventsHook;

    void enableIfValid() noexcept
    {
        if (peepEventsHook.isValid())
            peepEventsHook.enable();
    }
};

```

`Source/GlobalContext/UnloadFlag.h`:

```h
#pragma once

struct UnloadFlag {
    void set() noexcept
    {
        unload = true;
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return unload;
    }

private:
    bool unload{ false };
};

```

`Source/HookContext/HookContext.h`:

```h
#pragma once

#include <CS2/Classes/CCvar.h>
#include <Config/Config.h>
#include <GameClient/Entities/GameRules.h>
#include <GameClient/Entities/PlantedC4.h>
#include <GameClient/Entities/PlayerController.h>
#include <Features/Common/InWorldPanelsPerHookState.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoPanelCachePerHookState.h>
#include <GameClient/ConVars/CvarSystem.h>
#include <GameClient/Entities/PlayerResource.h>
#include <GameClient/FileSystem.h>
#include <GameClient/Hud/Hud.h>
#include <GameClient/Hud/HudContext.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <MemoryPatterns/PatternTypes/CvarPatternTypes.h>
#include <MemoryPatterns/PatternTypes/GameRulesPatternTypes.h>
#include <MemoryPatterns/PatternTypes/PlantedC4PatternTypes.h>
#include <GameClient/Panorama/PanelFactory.h>
#include <GameClient/GlobalVars.h>
#include <GameClient/Panorama/PanoramaTransformFactory.h>

struct BombStatusPanelState;
struct FeaturesStates;
struct PanoramaGuiState;
struct GlowSceneObjectsState;
struct Hooks;
class EntityClassifier;

template <typename GlobalContext>
struct HookContext {
    HookContext() noexcept
        : fullGlobalContext{GlobalContext::instance().fullContext()}
    {
    }

    [[nodiscard]] static bool isGlobalContextComplete() noexcept
    {
        return GlobalContext::instance().isComplete();
    }

    static void initCompleteGlobalContextFromGameThread() noexcept
    {
        GlobalContext::instance().initCompleteContextFromGameThread();
    }

    static void destroyGlobalContext() noexcept
    {
        GlobalContext::destroyInstance();
    }

    [[nodiscard]] SoundWatcherState& soundWatcherState() const noexcept
    {
        return fullGlobalContext.soundWatcherState;
    }

    [[nodiscard]] BombStatusPanelState& bombStatusPanelState() const noexcept
    {
        return fullGlobalContext.bombStatusPanelState;
    }

    [[nodiscard]] InWorldPanelsState& inWorldPanelsState() const noexcept
    {
        return fullGlobalContext.inWorldPanelsState;
    }

    [[nodiscard]] InWorldPanelsPerHookState& inWorldPanelsPerHookState() noexcept
    {
        return _inWorldPanelsPerHookState;
    }

    [[nodiscard]] PlayerInfoPanelCacheState& playerInfoPanelCacheState() const noexcept
    {
        return fullGlobalContext.playerInfoPanelCacheState;
    }

    [[nodiscard]] PlayerInfoPanelCachePerHookState& playerInfoPanelCachePerHookState() noexcept
    {
        return _playerInfoPanelCachePerHookState;
    }

    [[nodiscard]] PanoramaGuiState& panoramaGuiState() const noexcept
    {
        return fullGlobalContext.panoramaGuiState;
    }

    [[nodiscard]] FeaturesStates& featuresStates() const noexcept
    {
        return fullGlobalContext.featuresStates;
    }

    [[nodiscard]] GlowSceneObjectsState& glowSceneObjectsState() const noexcept
    {
        return fullGlobalContext.glowSceneObjectsState;
    }

    [[nodiscard]] EntityClassifier& entityClassifier() const noexcept
    {
        return fullGlobalContext.entityClassifier;
    }

    [[nodiscard]] auto& playerModelGlowPreviewState() const noexcept
    {
        return fullGlobalContext.playerModelGlowPreviewState;
    }

    [[nodiscard]] auto& weaponModelGlowPreviewState() const noexcept
    {
        return fullGlobalContext.weaponModelGlowPreviewState;
    }

    [[nodiscard]] Hooks& hooks() const noexcept
    {
        return fullGlobalContext.hooks;
    }

    [[nodiscard]] auto hud() noexcept
    {
        return Hud{HudContext{*this}};
    }

    [[nodiscard]] auto localPlayerController() noexcept
    {
        if (fullGlobalContext.patternSearchResults.template get<LocalPlayerControllerPointer>())
            return PlayerController{*this, *fullGlobalContext.patternSearchResults.template get<LocalPlayerControllerPointer>()};
        return PlayerController{*this, nullptr};
    }

    [[nodiscard]] auto globalVars() noexcept
    {
        if (fullGlobalContext.patternSearchResults.template get<GlobalVarsPointer>())
            return GlobalVars{*this, *fullGlobalContext.patternSearchResults.template get<GlobalVarsPointer>()};
        return GlobalVars{*this, nullptr};
    }

    [[nodiscard]] auto gameRules() noexcept
    {
        if (fullGlobalContext.patternSearchResults.template get<GameRulesPointer>())
            return GameRules{*this, *fullGlobalContext.patternSearchResults.template get<GameRulesPointer>()};
        return GameRules{*this, nullptr};
    }

    [[nodiscard]] auto plantedC4() noexcept
    {
        return std::optional{make<PlantedC4<HookContext>>(getPlantedC4())};
    }

    [[nodiscard]] auto cvarSystem() noexcept
    {
        return CvarSystem{*this};
    }

    [[nodiscard]] const auto& getConVarsBase() noexcept
    {
        if (!fullGlobalContext.conVars.has_value())
            fullGlobalContext.conVars.emplace(CvarSystem{*this});
        return *fullGlobalContext.conVars;
    }

    template <typename T, typename... Args>
    [[nodiscard]] auto make(Args&&... args) noexcept
    {
        return T{*this, std::forward<Args>(args)...};
    }

    template <template <typename...> typename T, typename... Args>
    [[nodiscard]] auto make(Args&&... args) noexcept
    {
        return T<HookContext>{*this, std::forward<Args>(args)...};
    }

    [[nodiscard]] auto panelFactory() noexcept
    {
        return PanelFactory{*this};
    }

    [[nodiscard]] auto panoramaTransformFactory() noexcept
    {
        return PanoramaTransformFactory{*this, fullGlobalContext.patternSearchResults.template get<TransformTranslate3dVMT>(), fullGlobalContext.patternSearchResults.template get<TransformScale3dVMT>()};
    }

    [[nodiscard]] const auto& panoramaSymbols() noexcept
    {
        auto& symbols = fullGlobalContext.panoramaSymbols;
        if (!symbols.has_value())
            symbols.emplace(*this);
        return *symbols;
    }

    [[nodiscard]] const auto& patternSearchResults() noexcept
    {
        return fullGlobalContext.patternSearchResults;
    }

    [[nodiscard]] auto& hudState() noexcept
    {
        return fullGlobalContext.hudState;
    }

    [[nodiscard]] auto& fileNameSymbolTableState() noexcept
    {
        return fullGlobalContext.fileNameSymbolTableState;
    }

    [[nodiscard]] auto& memAllocState() noexcept
    {
        return fullGlobalContext.memAllocState;
    }

    [[nodiscard]] auto& glowSceneObjectState() noexcept
    {
        return fullGlobalContext.glowSceneObjectState;
    }

    [[nodiscard]] auto& stylePropertySymbolsAndVMTs() noexcept
    {
        return fullGlobalContext.stylePropertySymbolsAndVMTs;
    }

    [[nodiscard]] auto config() noexcept
    {
        return Config{*this};
    }

    [[nodiscard]] auto& configState() noexcept
    {
        return fullGlobalContext.configState;
    }

    [[nodiscard]] auto gui() noexcept
    {
        return PanoramaGUI{*this};
    }

    [[nodiscard]] const auto& osirisDirectoryPath() noexcept
    {
        return fullGlobalContext.osirisDirectoryPath;
    }

    [[nodiscard]] auto soundWatcher() noexcept
    {
        return SoundWatcher<HookContext>{fullGlobalContext.soundWatcherState, *this};
    }

    [[nodiscard]] auto uiPanel(cs2::CUIPanel* panel) noexcept
    {
        return PanoramaUiPanel<HookContext>{*this, panel};
    }

    [[nodiscard]] decltype(auto) activeLocalPlayerPawn() noexcept
    {
        return localPlayerController().pawn().template cast<PlayerPawn>();
    }

    [[nodiscard]] decltype(auto) localPlayerBulletInaccuracy() noexcept
    {
        return activeLocalPlayerPawn().getActiveWeapon().bulletInaccuracy();
    }

    [[nodiscard]] decltype(auto) playerResource()
    {
        if (fullGlobalContext.patternSearchResults.template get<PointerToPlayerResource>())
            return PlayerResource{*this, *fullGlobalContext.patternSearchResults.template get<PointerToPlayerResource>()};
        return PlayerResource{*this, nullptr};
    }

private:
    [[nodiscard]] cs2::CPlantedC4* getPlantedC4() const noexcept
    {
        const auto* const plantedC4s = fullGlobalContext.patternSearchResults.template get<PlantedC4sPointer>();
        if (plantedC4s && plantedC4s->size > 0)
            return plantedC4s->memory[0];
        return nullptr;
    }

    GlobalContext::Complete& fullGlobalContext;
    InWorldPanelsPerHookState _inWorldPanelsPerHookState;
    PlayerInfoPanelCachePerHookState _playerInfoPanelCachePerHookState;
};

```

`Source/HookContext/HookContextMacros.h`:

```h
#pragma once

#define GET_CONFIG_VAR(name) hookContext.config().template getVariable<name>()
#define SET_CONFIG_VAR(name, value) hookContext.config().template setVariable<name>(value)
#define GET_CONVAR_VALUE(name) hookContext.cvarSystem().template getConVarValue<name>()

```

`Source/Hooks/ClientModeHooks.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/ClientModeCSNormal.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <Vmt/VmtLengthCalculator.h>
#include <Vmt/VmtSwapper.h>

float ClientModeHook_getViewmodelFov(cs2::ClientModeCSNormal* thisptr) noexcept;

template <typename HookContext>
class ClientModeHooks {
public:
    explicit ClientModeHooks(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] cs2::ClientModeCSNormal::GetViewmodelFov* originalGetViewmodelFov() const noexcept
    {
        return hookContext.hooks().originalGetViewmodelFov;
    }

    void hookGetViewmodelFov() const noexcept
    {
        const auto vmt = clientModeInstanceVmtPointer();
        if (vmt && hook().install(hookContext.hooks().clientVmtLengthCalculator, *vmt)) {
            hookContext.hooks().originalGetViewmodelFov = hook().hook(WIN64_LINUX(27, 28), &ClientModeHook_getViewmodelFov);
        }
    }

    void restoreGetViewmodelFov() const noexcept
    {
        if (!hook().wasEverInstalled())
            return;

        if (const auto vmt = clientModeInstanceVmtPointer())
            hook().uninstall(*vmt);
    }

private:
    [[nodiscard]] std::uintptr_t** clientModeInstanceVmtPointer() const
    {
        if (const auto clientMode = hookContext.patternSearchResults().template get<PointerToClientMode>())
            return reinterpret_cast<std::uintptr_t**>(clientMode);
        return nullptr;
    }

    [[nodiscard]] auto& hook() const
    {
        return hookContext.hooks().clientModeVmtSwapper;
    }

    HookContext& hookContext;
};

```

`Source/Hooks/Hooks.h`:

```h
#pragma once

#include "PeepEventsHook.h"
#include "ViewRenderHook.h"

#include <CS2/Classes/CViewRender.h>
#include <Vmt/VmtLengthCalculator.h>

struct Hooks {
    Hooks(PeepEventsHook peepEventsHook, cs2::CViewRender** viewRender, const VmtLengthCalculator& clientVmtLengthCalculator) noexcept
        : clientVmtLengthCalculator{clientVmtLengthCalculator}
        , peepEventsHook{peepEventsHook}
        , viewRenderHook{viewRender, clientVmtLengthCalculator}
    {
    }

    VmtLengthCalculator clientVmtLengthCalculator;
    VmtSwapper clientModeVmtSwapper;
    cs2::ClientModeCSNormal::GetViewmodelFov* originalGetViewmodelFov{nullptr};
    PeepEventsHook peepEventsHook;
    ViewRenderHook viewRenderHook;
};

```

`Source/Hooks/PeepEventsHook.h`:

```h
#pragma once

#include <cassert>

#include <SDL/SdlFunctions.h>

int SDLHook_PeepEvents(void* events, int numevents, int action, unsigned minType, unsigned maxType) noexcept;

class PeepEventsHook {
public:
    explicit PeepEventsHook(sdl3::SDL_PeepEvents** peepEvents) noexcept
        : peepEventsPointer{peepEvents}
    {
    }

    [[nodiscard]] bool isValid() const noexcept
    {
        return peepEventsPointer != nullptr;
    }

    void enable() noexcept
    {
        assert(isValid());
        original = *peepEventsPointer;
        *peepEventsPointer = &SDLHook_PeepEvents;
    }

    void disable() const noexcept
    {
        assert(isValid());
        *peepEventsPointer = original;
    }

    sdl3::SDL_PeepEvents** peepEventsPointer{nullptr};
    sdl3::SDL_PeepEvents* original{nullptr};
};

```

`Source/Hooks/ViewRenderHook.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CViewRender.h>
#include <Vmt/VmtLengthCalculator.h>
#include <Vmt/VmtSwapper.h>

void ViewRenderHook_onRenderStart(cs2::CViewRender* thisptr) noexcept;

class ViewRenderHook {
public:
    ViewRenderHook(cs2::CViewRender** viewRender, const VmtLengthCalculator& vmtLengthCalculator) noexcept
        : viewRender{viewRender}
        , vmtLengthCalculator{vmtLengthCalculator}
    {
    }

    [[nodiscard]] cs2::CViewRender::OnRenderStart* getOriginalOnRenderStart() const noexcept
    {
        return originalOnRenderStart;
    }

    void uninstall() const noexcept
    {
        if (viewRender && *viewRender)
            hook.uninstall(*reinterpret_cast<std::uintptr_t**>(*viewRender));
    }

    [[nodiscard]] bool isInstalled() const noexcept
    {
        return hook.wasEverInstalled() && viewRender && *viewRender && hook.isInstalled(*reinterpret_cast<std::uintptr_t**>(*viewRender));
    }

    void install() noexcept
    {
        if (viewRender && *viewRender && hook.install(vmtLengthCalculator, *reinterpret_cast<std::uintptr_t**>(*viewRender))) {
            originalOnRenderStart = hook.hook(4, &ViewRenderHook_onRenderStart);
        }
    }

    cs2::CViewRender** viewRender;
    VmtLengthCalculator vmtLengthCalculator;
    VmtSwapper hook;
    cs2::CViewRender::OnRenderStart* originalOnRenderStart{ nullptr };
};

```

`Source/MemoryAllocation/FreeMemoryRegion.h`:

```h
#pragma once

#include <cstddef>
#include <functional>
#include <new>
#include <span>

class FreeMemoryRegion {
public:
    FreeMemoryRegion(const FreeMemoryRegion&) = delete;
    FreeMemoryRegion(FreeMemoryRegion&&) = delete;
    FreeMemoryRegion& operator=(const FreeMemoryRegion&) = delete;
    FreeMemoryRegion& operator=(FreeMemoryRegion&&) = delete;

    [[nodiscard]] static FreeMemoryRegion* create(std::span<std::byte> region) noexcept
    {
        return new (region.data()) FreeMemoryRegion{ region.size(), nullptr };
    }

    [[nodiscard]] std::size_t getSize() const noexcept
    {
        return size;
    }

    [[nodiscard]] FreeMemoryRegion* getNextFreeRegion() const noexcept
    {
        return nextFreeRegion;
    }

    [[nodiscard]] FreeMemoryRegion* addFreeRegion(std::span<std::byte> region) noexcept
    {
        if (shouldPrepend(region.data()))
            return prependRegion(region);
        findRegionToAppendTo(region.data()).appendRegion(region);
        return this;
    }

    struct MemoryClaimResult {
        FreeMemoryRegion* claimedRegion{nullptr};
        FreeMemoryRegion* regionToReplaceClaimed{nullptr};
    };

    [[nodiscard]] MemoryClaimResult claimMemory(std::size_t claimSize) noexcept
    {
        if (claimMemoryFromSelf(claimSize))
            return MemoryClaimResult{ .claimedRegion = this, .regionToReplaceClaimed = nextFreeRegion };

        for (FreeMemoryRegion* region = this; region->nextFreeRegion != nullptr; region = region->nextFreeRegion) {
            if (region->nextFreeRegion->claimMemoryFromSelf(claimSize)) {
                const auto claimedRegion = region->nextFreeRegion;
                region->nextFreeRegion = claimedRegion->nextFreeRegion;
                return MemoryClaimResult{ .claimedRegion = claimedRegion, .regionToReplaceClaimed = region->nextFreeRegion };
            }
        }

        return {};
    }

private:
    [[nodiscard]] bool claimMemoryFromSelf(std::size_t allocationSize) noexcept
    {
        if (size == allocationSize) {
           return true;
        } else if (size > allocationSize && size - allocationSize >= sizeof(FreeMemoryRegion)) {
            nextFreeRegion = new (reinterpret_cast<std::byte*>(this) + allocationSize) FreeMemoryRegion{ size - allocationSize, nextFreeRegion };
            return true;
        }
        return false;
    }

    [[nodiscard]] FreeMemoryRegion* prependRegion(std::span<std::byte> region) noexcept
    {
        if (region.data() + region.size() == reinterpret_cast<std::byte*>(this))
            return new (region.data()) FreeMemoryRegion{ region.size() + size, nextFreeRegion };
        else
            return new (region.data()) FreeMemoryRegion{ region.size(), this };
    }

    void appendRegion(std::span<std::byte> region) noexcept
    {
        if (reinterpret_cast<std::byte*>(this) + size == region.data()) {
            size += region.size();
            tryMergeWithNextRegion();
        } else {
            nextFreeRegion = new (region.data()) FreeMemoryRegion{ region.size(), nextFreeRegion};
            nextFreeRegion->tryMergeWithNextRegion();
        }
    }

    [[nodiscard]] FreeMemoryRegion& findRegionToAppendTo(std::byte* newRegionPointer) noexcept
    {
        FreeMemoryRegion* region = this;
        while (region != nullptr && region->getNextFreeRegion() != nullptr && std::less{}(reinterpret_cast<std::byte*>(region->getNextFreeRegion()), newRegionPointer))
            region = region->getNextFreeRegion();
        return *region;
    }

    [[nodiscard]] bool shouldPrepend(const std::byte* newRegionPointer) const noexcept
    {
        return std::less{}(newRegionPointer, reinterpret_cast<const std::byte*>(this));
    }

    void tryMergeWithNextRegion() noexcept
    {
        if (reinterpret_cast<std::byte*>(this) + size == reinterpret_cast<std::byte*>(nextFreeRegion)) {
            size += nextFreeRegion->size;
            nextFreeRegion = nextFreeRegion->nextFreeRegion;
        }
    }

    FreeMemoryRegion(std::size_t size, FreeMemoryRegion* nextFreeRegion) noexcept
        : size{ size }, nextFreeRegion{ nextFreeRegion }
    {
    }

    std::size_t size;
    FreeMemoryRegion* nextFreeRegion;
};

```

`Source/MemoryAllocation/FreeMemoryRegionList.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <span>

#include "FreeMemoryRegion.h"

#ifndef NDEBUG
#include <Utils/MemorySection.h>
#endif

class FreeMemoryRegionList {
public:
    explicit FreeMemoryRegionList(std::span<std::byte> memory) noexcept
        : firstFreeRegion{ createInitialFreeRegion(memory) }
#ifndef NDEBUG
        , memory{ memory }
#endif
    {
    }

    FreeMemoryRegionList(const FreeMemoryRegionList&) = delete;
    FreeMemoryRegionList(FreeMemoryRegionList&&) = delete;
    FreeMemoryRegionList& operator=(const FreeMemoryRegionList&) = delete;
    FreeMemoryRegionList& operator=(FreeMemoryRegionList&&) = delete;

    [[nodiscard]] static constexpr std::size_t minimumAlignment() noexcept
    {
        return alignof(FreeMemoryRegion);
    }

    [[nodiscard]] static constexpr std::size_t minimumAllocationSize() noexcept
    {
        return sizeof(FreeMemoryRegion);
    }

#ifndef NDEBUG
    ~FreeMemoryRegionList() noexcept
    {
        assert(firstFreeRegion != nullptr && firstFreeRegion->getSize() == memory.size() && firstFreeRegion->getNextFreeRegion() == nullptr && "Memory leak detected");
    }
#endif

    [[nodiscard]] std::byte* allocate(std::size_t size) noexcept
    {
        assert(size >= minimumAllocationSize());
        assert(size % minimumAlignment() == 0);

        if (firstFreeRegion == nullptr) [[unlikely]]
            return nullptr;

        const auto [claimedRegion, regionToReplaceClaimed] = firstFreeRegion->claimMemory(size);
        if (claimedRegion == firstFreeRegion)
            firstFreeRegion = regionToReplaceClaimed;
        return reinterpret_cast<std::byte*>(claimedRegion);
    }

    void deallocate(std::byte* pointer, std::size_t size) noexcept
    {
        assert(MemorySection{ memory }.contains(reinterpret_cast<std::uintptr_t>(pointer), size) && "Invalid pointer or size provided for deallocation");
        firstFreeRegion = createOrAddRegion({ pointer, size });
    }

    [[nodiscard]] std::size_t getFreeSpace() const noexcept
    {
        std::size_t freeSpace = 0;
        for (const FreeMemoryRegion* region = firstFreeRegion; region != nullptr; region = region->getNextFreeRegion())
            freeSpace += region->getSize();
        return freeSpace;
    }

private:
    [[nodiscard]] FreeMemoryRegion* createOrAddRegion(std::span<std::byte> region) const noexcept
    {
        if (firstFreeRegion == nullptr) [[unlikely]] {
            return FreeMemoryRegion::create(region);
        } else {
            return firstFreeRegion->addFreeRegion(region);
        }
    }

    [[nodiscard]] static FreeMemoryRegion* createInitialFreeRegion(std::span<std::byte> memory) noexcept
    {
        assert(memory.size() >= minimumAllocationSize());
        assert(std::uintptr_t(memory.data()) % minimumAlignment() == 0);
        return FreeMemoryRegion::create(memory);
    }

    FreeMemoryRegion* firstFreeRegion;
#ifndef NDEBUG
    std::span<std::byte> memory;
#endif
};

```

`Source/MemoryAllocation/MemoryAllocator.h`:

```h
#pragma once

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <type_traits>

#include <Utils/Align.h>

#include "FreeMemoryRegionList.h"
#include "MemoryAllocatorBase.h"

template <typename T>
struct MemoryAllocator {
    [[nodiscard]] static std::byte* allocate() noexcept
    {
        return MemoryAllocatorBase::allocate(memoryFor());
    }

    static void deallocate(T* memory) noexcept
    {
        MemoryAllocatorBase::deallocate(reinterpret_cast<std::byte*>(memory), memoryFor());
    }

private:
    [[nodiscard]] static auto memoryFor() noexcept
    {
        static_assert(alignof(T) <= FreeMemoryRegionList::minimumAlignment(), "Unsupported alignment");
        return (std::max)(utils::align<sizeof(T), FreeMemoryRegionList::minimumAlignment()>(), FreeMemoryRegionList::minimumAllocationSize());
    }
};

template <typename T>
struct MemoryAllocator<T[]> {
    [[nodiscard]] static std::byte* allocate(std::size_t numberOfElements) noexcept
    {
        return MemoryAllocatorBase::allocate(memoryFor(numberOfElements));
    }

    static void deallocate(T* memory, std::size_t numberOfElements) noexcept
    {
        MemoryAllocatorBase::deallocate(reinterpret_cast<std::byte*>(memory), memoryFor(numberOfElements));
    }

private:
    [[nodiscard]] static auto memoryFor(std::size_t numberOfElements) noexcept
    {
        static_assert(alignof(T) <= FreeMemoryRegionList::minimumAlignment(), "Unsupported alignment");
        assert(numberOfElements <= (std::numeric_limits<std::size_t>::max)() / sizeof(std::remove_extent_t<T>));
        return (std::max)(utils::align(numberOfElements * sizeof(std::remove_extent_t<T>), FreeMemoryRegionList::minimumAlignment()), FreeMemoryRegionList::minimumAllocationSize());
    }
};

```

`Source/MemoryAllocation/MemoryAllocatorBase.h`:

```h
#pragma once

#include <cstddef>

struct MemoryAllocatorBase {
    [[nodiscard]] static std::byte* allocate(std::size_t size) noexcept;
    static void deallocate(std::byte* memory, std::size_t size) noexcept;
};

```

`Source/MemoryAllocation/MemoryAllocatorBaseImpl.h`:

```h
#pragma once

#include <cstddef>

#include <GlobalContext/GlobalContext.h>
#include "FreeMemoryRegionList.h"
#include "MemoryAllocatorBase.h"

std::byte* MemoryAllocatorBase::allocate(std::size_t size) noexcept
{
    return GlobalContext::instance().freeRegionList().allocate(size);
}

void MemoryAllocatorBase::deallocate(std::byte* memory, std::size_t size) noexcept
{
    return GlobalContext::instance().freeRegionList().deallocate(memory, size);
}

```

`Source/MemoryAllocation/MemoryDeleter.h`:

```h
#pragma once

#include <cstddef>
#include <memory>

#include "MemoryAllocator.h"

template <typename T>
struct MemoryDeleter {
    void operator()(T* memory) const noexcept
    {
        if (memory) {
            std::destroy_at(memory);
            MemoryAllocator<T>::deallocate(memory);
        }
    }
};

template <typename T>
struct MemoryDeleter<T[]> {
    explicit MemoryDeleter(std::size_t numberOfElements) noexcept
        : numberOfElements{ numberOfElements }
    {
    }

    MemoryDeleter() = default;

    void operator()(T* memory) const noexcept
    {
        if (memory) {
            std::destroy_n(memory, numberOfElements);
            MemoryAllocator<T[]>::deallocate(memory, numberOfElements);
        }
    }

    [[nodiscard]] std::size_t getNumberOfElements() const noexcept
    {
        return numberOfElements;
    }

private:
    std::size_t numberOfElements = 0;
};

```

`Source/MemoryAllocation/UniquePtr.h`:

```h
#pragma once

#include <cstddef>
#include <memory>
#include <type_traits>

#include "MemoryAllocator.h"
#include "MemoryDeleter.h"

template <typename T>
using UniquePtr = std::unique_ptr<T, MemoryDeleter<T>>;

namespace mem
{

template <typename T>
    requires (!std::is_array_v<T>)
[[nodiscard]] auto makeUniqueForOverwrite() noexcept
{
    return UniquePtr<T>{ new (MemoryAllocator<T>::allocate()) T };
}

template <typename T>
    requires std::is_unbounded_array_v<T>
[[nodiscard]] auto makeUniqueForOverwrite(std::size_t size) noexcept
{
    return UniquePtr<T>{ new (MemoryAllocator<T>::allocate(size)) std::remove_extent_t<T>[size], MemoryDeleter<T>{ size } };
}

template <typename T, typename... Args>
    requires std::is_bounded_array_v<T>
void makeUniqueForOverwrite(Args&&...) = delete;

}

```

`Source/MemoryPatterns/AllMemoryPatternSearchResults.h`:

```h
#pragma once

#include <MemoryPatterns/MemoryPatterns.h>
#include <MemorySearch/PatternSearchResults.h>

struct AllMemoryPatternSearchResults {
    explicit AllMemoryPatternSearchResults(const MemoryPatterns& memoryPatterns)
        : clientPatternSearchResults{memoryPatterns.patternFinders.clientPatternFinder.findPatterns(kClientPatterns)}
        , sceneSystemPatternSearchResults{memoryPatterns.patternFinders.sceneSystemPatternFinder.findPatterns(kSceneSystemPatterns)}
        , tier0PatternSearchResults{memoryPatterns.patternFinders.tier0PatternFinder.findPatterns(kTier0Patterns)}
        , fileSystemPatternSearchResults{memoryPatterns.patternFinders.fileSystemPatternFinder.findPatterns(kFileSystemPatterns)}
        , soundSystemPatternSearchResults{memoryPatterns.patternFinders.soundSystemPatternFinder.findPatterns(kSoundSystemPatterns)}
        , panoramaPatternSearchResults{memoryPatterns.patternFinders.panoramaPatternFinder.findPatterns(kPanoramaPatterns)}
    {
    }

    template <typename PatternType>
    [[nodiscard]] auto get() const noexcept
    {
        if constexpr (decltype(kClientPatterns)::PatternPool::PatternTypes::template contains<PatternType>())
            return clientPatternSearchResults.get<PatternType>();
        else if constexpr (decltype(kSceneSystemPatterns)::PatternPool::PatternTypes::template contains<PatternType>())
            return sceneSystemPatternSearchResults.get<PatternType>();
        else if constexpr (decltype(kTier0Patterns)::PatternPool::PatternTypes::template contains<PatternType>())
            return tier0PatternSearchResults.get<PatternType>();
        else if constexpr (decltype(kFileSystemPatterns)::PatternPool::PatternTypes::template contains<PatternType>())
            return fileSystemPatternSearchResults.get<PatternType>();
        else if constexpr (decltype(kSoundSystemPatterns)::PatternPool::PatternTypes::template contains<PatternType>())
            return soundSystemPatternSearchResults.get<PatternType>();
        else if constexpr (decltype(kPanoramaPatterns)::PatternPool::PatternTypes::template contains<PatternType>())
            return panoramaPatternSearchResults.get<PatternType>();
    }

    PatternSearchResults<decltype(kClientPatterns)> clientPatternSearchResults;
    PatternSearchResults<decltype(kSceneSystemPatterns)> sceneSystemPatternSearchResults;
    PatternSearchResults<decltype(kTier0Patterns)> tier0PatternSearchResults;
    PatternSearchResults<decltype(kFileSystemPatterns)> fileSystemPatternSearchResults;
    PatternSearchResults<decltype(kSoundSystemPatterns)> soundSystemPatternSearchResults;
    PatternSearchResults<decltype(kPanoramaPatterns)> panoramaPatternSearchResults;
};

```

`Source/MemoryPatterns/Linux/BaseModelEntityPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/BaseModelEntityPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct BaseModelEntityPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToGlowProperty, CodePattern{"90 ? ? ? ? 4C 89 E6 48 8D B8 ? ? ? ?"}.add(11).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/C4PatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/C4PatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct C4Patterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToIsBeingPlanted, CodePattern{"? ? ? ? 00 75 ? 48 63 87 ? ? ? ? 48"}.read()>()
            .template addPattern<OffsetToArmingEndTime, CodePattern{"? ? ? ? 00 00 00 00 66 89 ? ? ? ? ? 48 89 83 ? ? ? ? C6"}.read()>();
    }
};

```

`Source/MemoryPatterns/Linux/ClientPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct ClientPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<MainMenuPanelPointer, CodePattern{"E5 53 48 83 EC ? 48 8D 1D ? ? ? ? 48 8B 03 48 8B 78 ? 48 8B"}.add(9).abs()>()
            .template addPattern<HudPanelPointer, CodePattern{"05 ? ? ? ? 48 85 C0 0F 84 ? ? ? ? 40"}.add(1).abs()>()
            .template addPattern<GlobalVarsPointer, CodePattern{"8D ? ? ? ? ? 48 89 35 ? ? ? ? 48 89 ? ? C3"}.add(9).abs()>()
            .template addPattern<TransformTranslate3dVMT, CodePattern{"48 8D 0D ? ? ? ? 48 89 08 48 89 50 08 48 8B 53 10"}.add(3).abs()>()
            .template addPattern<TransformScale3dVMT, CodePattern{"48 8B 53 08 48 8D 0D ? ? ? ? F3 0F 10 43"}.add(7).abs()>()
            .template addPattern<WorldToProjectionMatrixPointer, CodePattern{"01 4C 8D 05 ? ? ? ? 4C 89 EE"}.add(4).abs()>()
            .template addPattern<ViewToProjectionMatrixPointer, CodePattern{"EE 48 8D 0D ? ? ? ? 48 8D 15 ? ? ? ? 48"}.add(4).abs()>()
            .template addPattern<ViewRenderPointer, CodePattern{"48 8D 05 ? ? ? ? 48 89 38 48 85"}.add(3).abs()>()
            .template addPattern<LocalPlayerControllerPointer, CodePattern{"48 83 3D ? ? ? ? ? 0F 95 C0 C3"}.add(3).abs(5)>()
            .template addPattern<ManageGlowSceneObjectPointer, CodePattern{"55 66 48 0F 7E C8"}>()
            .template addPattern<SetSceneObjectAttributeFloat4, CodePattern{"55 66 0F 6E D6 48 89 E5 53 48"}>()
            .template addPattern<PointerToClientMode, CodePattern{"05 ? ? ? ? ? 89 ? 48 89 05 ? ? ? ? E8 ? ? ? ? ? 8B ? ? C9"}.add(1).abs()>();
    }
};

```

`Source/MemoryPatterns/Linux/ConVarPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/ConVarPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct ConVarPatterns {
    [[nodiscard]] static consteval auto addTier0Patterns(auto tier0Patterns) noexcept
    {
        return tier0Patterns
            .template addPattern<OffsetToConVarValueType, CodePattern{"? C1 E0 ? 83 C0 ? 48 98 ? 8D 04 ? 48 39 C7 74"}.read()>()
            .template addPattern<OffsetToConVarValue, CodePattern{"F6 49 89 ? 48 8D 40 ?"}.add(7).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/CvarPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/CvarPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct CvarPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<CvarPointer, CodePattern{"48 89 E5 41 54 53 ? 8D ? ? 48 83 EC ? 48 8D 05 ? ? ? ? 48 8B 38 48 8B 07 FF 50 ? BA"}.add(17).abs()>();
    }

    [[nodiscard]] static consteval auto addTier0Patterns(auto tier0Patterns) noexcept
    {
        return tier0Patterns
            .template addPattern<OffsetToConVarList, CodePattern{"53 ? 45 0F B7 E4"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/EntityPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/EntityPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct EntityPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToGameSceneNode, CodePattern{"2C E0 49 8B 85 ? ? ? ?"}.add(5).read()>()
            .template addPattern<OffsetToHealth, CodePattern{"C7 87 ? ? ? ? 00 00 00 00 48 8D 35"}.add(2).read()>()
            .template addPattern<OffsetToLifeState, CodePattern{"0F B6 97 ? ? ? ? 39 F2"}.add(3).read()>()
            .template addPattern<OffsetToTeamNumber, CodePattern{"? ? ? ? 02 48 8D 05 ? ? ? ? 74 ? 48"}.read()>()
            .template addPattern<OffsetToVData, CodePattern{"? ? ? ? 5A 59 48 85 C0 74 ? 4C"}.read()>()
            .template addPattern<OffsetToRenderComponent, CodePattern{"49 8B BC 24 ? ? ? ? 48 85 FF 74 ? 8B 47"}.add(4).read()>()
            .template addPattern<OffsetToOwnerEntity, CodePattern{"8B BF ? ? ? ? 8B 8F ? ? ? ?"}.add(8).read()>()
            .template addPattern<GetAbsOriginFunction, CodePattern{"4C 8B ? E8 ? ? ? ? F3 0F 10 05"}.add(4).abs()>();
    }
};

```

`Source/MemoryPatterns/Linux/EntitySystemPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/EntitySystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct EntitySystemPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<EntitySystemPointer, CodePattern{"4C 63 ? ? ? ? ? 48 89 1D ? ? ? ?"}.add(10).abs()>()
            .template addPattern<EntityListOffset, CodePattern{"4C 8D 6F ? 41 54 53 48 89 FB 48 83 EC ? 48 89 07 48"}.add(3).read()>()
            .template addPattern<OffsetToEntityClasses, CodePattern{"49 8B 8F ? ? ? ? 0F B7"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/FileSystemPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/FileSystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct FileSystemPatterns {
    [[nodiscard]] static consteval auto addSoundSystemPatterns(auto soundSystemPatterns) noexcept
    {
        return soundSystemPatterns
            .template addPattern<FileSystemPointer, CodePattern{"3D ? ? ? ? 48 8B 07 31"}.add(1).abs()>();
    }

    [[nodiscard]] static consteval auto addFileSystemPatterns(auto fileSystemPatterns) noexcept
    {
        return fileSystemPatterns
            .template addPattern<FileNamesOffset, CodePattern{"8D BE ? ? ? ? E8 ? ? ? ? 41 8B"}.add(2).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/GameRulesPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GameRulesPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GameRulesPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<GameRulesPointer, CodePattern{"FF 53 ? 48 83 3D ? ? ? ? 00 74"}.add(6).abs(5)>()
            .template addPattern<RoundStartTimeOffset, CodePattern{"EC ? 8B 5F ? ? DA"}.add(4).read()>()
            .template addPattern<OffsetToRoundRestartTime, CodePattern{"8D 15 ? ? ? ? F3 0F 10 57 ?"}.add(10).read()>()
            .template addPattern<OffsetToRoundLength, CodePattern{"0F 2A 43 ? 48 8B 5D"}.add(3).read()>()
            .template addPattern<OffsetToRoundWinStatus, CodePattern{"B8 ? ? ? ? 00 0F 85 ? ? ? ? BA"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/GameSceneNodePatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GameSceneNodePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GameSceneNodePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToAbsOrigin, CodePattern{"BB ? ? ? ? F3 0F 11 ? ? E8 ? ? ? ? F3 0F 10 ? ? ? ? ? F3 0F 10 ? ? 0F 29 43 ? F3 0F 10 83 ? ? ? ?"}.add(36).read()>()
            .template addPattern<OffsetToGameSceneNodeOwner, CodePattern{"85 ? ? ? ? 48 8B 43 ? 31 D2"}.add(8).read()>()
            .template addPattern<OffsetToChildGameSceneNode, CodePattern{"24 ? 48 85 DB 74 ? 48 89 DF E8 ? ? ? ? 48 8B"}.add(1).read()>()
            .template addPattern<OffsetToNextSiblingGameSceneNode, CodePattern{"? 48 85 DB 75 ? 49 8B 04 24 4C 89 E7 FF 50"}.read()>();
    }
};

```

`Source/MemoryPatterns/Linux/GlobalVarsPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GlobalVarsPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GlobalVarsPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToFrametime, CodePattern{"28 CF F3 0F 10 40 ?"}.add(6).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/GlowPropertyPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GlowPropertyPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GlowPropertyPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToIsGlowing, CodePattern{"43 ? 00 48 85 FF 74 05"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/GlowSceneObjectPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GlowSceneObjectPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GlowSceneObjectPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToGlowSceneObjectEntity, CodePattern{"85 ? ? ? ? 4C 8B A6 ? ? ? ? 48 89"}.add(8).read()>()
            .template addPattern<OffsetToGlowSceneObjectAttachedSceneObject, CodePattern{"00 48 8B 07 FF 50 ? ? 89 ? ? 89 ? ? ? ? ? ? 8B"}.add(13).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/HostageServicesPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/HostageServicesPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct HostageServicesPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToCarriedHostage, CodePattern{"07 C7 47 ? FF FF FF FF C3"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/LinuxPatterns.h`:

```h
#pragma once

#include "BaseModelEntityPatternsLinux.h"
#include "C4PatternsLinux.h"
#include "ClientPatternsLinux.h"
#include "ConVarPatternsLinux.h"
#include "CvarPatternsLinux.h"
#include "EntityPatternsLinux.h"
#include "EntitySystemPatternsLinux.h"
#include "FileSystemPatternsLinux.h"
#include "GameRulesPatternsLinux.h"
#include "GameSceneNodePatternsLinux.h"
#include "GlobalVarsPatternsLinux.h"
#include "GlowPropertyPatternsLinux.h"
#include "GlowSceneObjectPatternsLinux.h"
#include "HostageServicesPatternsLinux.h"
#include "MemAllocPatternsLinux.h"
#include "PanelPatternsLinux.h"
#include "PanelStylePatternsLinux.h"
#include "PanoramaDropDownPatternsLinux.h"
#include "PanoramaImagePanelPatternsLinux.h"
#include "PanoramaLabelPatternsLinux.h"
#include "PanoramaUiEnginePatternsLinux.h"
#include "PanoramaUiPanelPatternsLinux.h"
#include "PlantedC4PatternsLinux.h"
#include "PlayerControllerPatternsLinux.h"
#include "PlayerPawnPatternsLinux.h"
#include "PlayerResourcePatternsLinux.h"
#include "PortraitWorldPatternsLinux.h"
#include "RenderComponentPatternsLinux.h"
#include "SceneObjectPatternsLinux.h"
#include "SceneObjectUpdaterPatternsLinux.h"
#include "SceneSystemPatternsLinux.h"
#include "SdlPatternsLinux.h"
#include "SliderPatternsLinux.h"
#include "SmokeGrenadeProjectilePatternsLinux.h"
#include "SoundSystemPatternsLinux.h"
#include "TextEntryPatternsLinux.h"
#include "TopLevelWindowPatternsLinux.h"
#include "Ui3dPanelPatternsLinux.h"
#include "UiItem3dPanelPatternsLinux.h"
#include "WeaponPatternsLinux.h"
#include "WeaponServicesPatternsLinux.h"
#include "WeaponVDataPatternsLinux.h"

```

`Source/MemoryPatterns/Linux/MemAllocPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/MemAllocPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct MemAllocPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetAllocVirtualMethod, CodePattern{"04 00 00 00 49 8B 3C 24 48 8B 07 FF 50 ?"}.add(13).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PanelPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<PanelConstructorPointer, CodePattern{"55 48 89 E5 41 55 49 89 FD BF ? ? ? ? 41 54 49 89 F4 53 48 83 EC ? E8 ? ? ? ? 4C 89 E9"}>();
    }
};

```

`Source/MemoryPatterns/Linux/PanelStylePatternsLinux.h`:

```h
#pragma once

#include <CS2/Panorama/CPanelStyle.h>
#include <MemoryPatterns/PatternTypes/PanelStylePatternTypes.h>
#include <MemorySearch/BytePatternLiteral.h>
#include <MemorySearch/CodePattern.h>

struct PanelStylePatterns2 {
    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<SetPanelStylePropertyFunctionPointer, CodePattern{"DF 31 D2 E8 ? ? ? ? 48 8B"}.add(4).abs()>();
    }
};

template <typename PatternFinders>
struct PanelStylePatterns {
    const PatternFinders& patternFinders;

    [[nodiscard]] cs2::CPanelStyle::StylePropertySymbols* stylePropertiesSymbols() const noexcept
    {
        return patternFinders.panoramaPatternFinder("DE 48 C7 05 ? ? ? ? 00 00 00 00 48 8D"_pat).add(4).abs(8).template as<cs2::CPanelStyle::StylePropertySymbols*>();
    }
};

```

`Source/MemoryPatterns/Linux/PanoramaDropDownPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanoramaDropDownPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaDropDownPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetSelectedIndexFunctionPointer, CodePattern{"55 48 89 E5 41 56 41 55 41 89 F5 41 54 53 48 89 FB 48 83 EC ? 8B 47 20 85"}>();
    }
};

```

`Source/MemoryPatterns/Linux/PanoramaImagePanelPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanoramaImagePanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaImagePanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetImageFunctionPointer, CodePattern{"55 48 89 E5 41 57 49 89 F7 41 56 49 89 D6 41 55 41 54 49 89 CC 53 48 89 FB 48 83"}>()
            .template addPattern<ImagePanelConstructorPointer, CodePattern{"D2 48 89 C7 48 89 85 ? ? ? ? E8 ? ? ? ? ? 8B ? ? ? ? ? ? 8D BD"}.add(12).abs()>()
            .template addPattern<ImagePanelClassSize, CodePattern{"E9 ? ? ? ? BF ? ? ? ? ? 89 ? ? ? ? ? E8 ? ? ? ? 48 8B B5 ? ? ? ? 31"}.add(6).read()>()
            .template addPattern<ImagePropertiesOffset, CodePattern{"? 48 85 D2 48 0F 44 D0 48 85 F6 48 0F 44 F0 E8 ? ? ? ? E9"}.read()>()
            .template addPattern<OffsetToImagePath, CodePattern{"48 81 C7 ? ? ? ? 53 89 F3 48 C7"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PanoramaLabelPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanoramaLabelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaLabelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<LabelPanelConstructorPointer, CodePattern{"EC ? E8 ? ? ? ? 48 8D 15 ? ? ? ? 48 89 DE 48 89 C7 49 89 C4 E8 ? ? ? ?"}.add(24).abs()>()
            .template addPattern<SetLabelTextFunctionPointer, CodePattern{"0F 85 ? ? ? ? 31 C9 E8 ? ? ? ?"}.add(9).abs()>()
            .template addPattern<LabelPanelObjectSize, CodePattern{"? ? ? ? 48 83 EC ? E8 ? ? ? ? 48 8D 15 ? ? ? ? 48 89 DE"}.read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PanoramaUiEnginePatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/UiEnginePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaUiEnginePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<UiEnginePointer, CodePattern{"48 89 3D ? ? ? ? E8 ? ? ? ? 48 8B 3D ? ? ? ? E8 ? ? ? ? 48"}.add(3).abs()>();
    }

    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<GetPanelPointerFunctionPointer, CodePattern{"8B 16 31 C9"}>()
            .template addPattern<RunScriptFunctionPointer, CodePattern{"55 48 8D 05 ? ? ? ? 48 89 E5 41 57 49 89 D7 41 56 49"}>()
            .template addPattern<MakeSymbolFunctionPointer, CodePattern{"55 48 89 E5 41 57 41 56 41 55 41 54 53 48 83 EC ? 48 85 D2"}>()
            .template addPattern<OnDeletePanelFunctionPointer, CodePattern{"48 85 F6 0F 84 ? ? ? ? 55 48 89 E5 41 56 41 55 41 54 49 89 F4 53 48 8B 06 48 89 FB 48 89 F7 FF 10"}>()
            .template addPattern<RegisterEventHandlerFunctionPointer, CodePattern{"55 48 8D 05 ? ? ? ? 48 89 E5 41 57 41 56 49 89 FE 41 55 48 8D 3D ? ? ? ? 49 89 CD"}>();
    }
};

```

`Source/MemoryPatterns/Linux/PanoramaUiPanelPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/UiPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaUiPanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetParentFunctionOffset, CodePattern{"48 8B 90 ? ? ? ? 48 85 F6 74 16"}.add(3).read()>()
            .template addPattern<SetVisibleFunctionOffset, CodePattern{"49 8B 84 24 ? ? ? ? 31 F6 48 8B 78 ? 48 8B 07 FF 90 ? ? ? ? 4C 89 F7 E8"}.add(19).read()>()
            .template addPattern<GetAttributeStringFunctionOffset, CodePattern{"FF 90 ? ? ? ? 80 BB 90 ? ? ? ? 48 89 C2"}.add(2).read()>()
            .template addPattern<SetAttributeStringFunctionOffset, CodePattern{"78 ? 48 8B 07 FF 90 ? ? ? ? 44 8B 8D"}.add(7).read()>();
    }

    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<ChildPanelsVectorOffset, CodePattern{"A8 ? 0F 85 ? ? ? ? 8B ? ? 85 D2"}.add(10).read()>()
            .template addPattern<PanelClassesVectorOffset, CodePattern{"97 ? ? ? ? 85 D2 7E ? 48 8B 87"}.add(1).read()>()
            .template addPattern<PanelStyleOffset, CodePattern{"E8 ? ? ? ? 48 8D 43 ? 48 8B"}.add(8).read()>()
            .template addPattern<ParentWindowOffset, CodePattern{"? 48 85 D2 74 ? 48 89 53"}.read()>()
            .template addPattern<OffsetToPanelId, CodePattern{"E7 E8 ? ? ? ? 48 83 7B ? 00 0F"}.add(9).read()>()
            .template addPattern<OffsetToPanelFlags, CodePattern{"3E 41 F6 87 ? ? ? ?"}.add(4).read()>()
            .template addPattern<OffsetToPanelHandle, CodePattern{"48 8B 86 ? ? ? ? C3"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PlantedC4PatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlantedC4PatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlantedC4Patterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<PlantedC4sPointer, CodePattern{"80 BF ? ? ? ? 00 0F 84 ? ? ? ? 48 8D 05 ? ? ? ? 8B 10"}.add(16).abs()>()
            .template addPattern<BombSiteOffset, CodePattern{"83 BF ? ? ? ? 01 0F 94 C0 C3"}.add(2).read()>()
            .template addPattern<BombTickingOffset, CodePattern{"B6 00 84 C0 74 ? 80 BB ? ? ? ? 00 74 ? 80"}.add(8).read()>()
            .template addPattern<BombBlowTimeOffset, CodePattern{"F3 0F 10 83 ? ? ? ? F3 0F 5C C1 0F 2F E0"}.add(4).read()>()
            .template addPattern<BombDefuserOffset, CodePattern{"EC ? ? ? ? E8 ? ? ? ? 48 8D BB ? ? ? ? E8 ? ? ? ? 48"}.add(13).read()>()
            .template addPattern<BombDefuseEndTimeOffset, CodePattern{"74 ? F3 41 0F 10 84 24 ? ? ? ? 4C 8D"}.add(8).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PlayerControllerPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlayerControllerPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlayerControllerPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToBasePawnHandle, CodePattern{"84 C0 75 ? 8B 8F ? ? ? ?"}.add(6).read()>()
            .template addPattern<OffsetToPlayerColor, CodePattern{"E8 ? ? ? ? 84 C0 74 ? 8B 83 ? ? ? ? 48 8B"}.add(11).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PlayerPawnPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlayerPawnPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlayerPawnPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToPlayerPawnImmunity, CodePattern{"75 ? 0F B6 83 ? ? ? ? 5B 41"}.add(5).read()>()
            .template addPattern<OffsetToWeaponServices, CodePattern{"48 8B BE ? ? ? ? 48 8D 35 ? ? ? ? E8 ? ? ? ? 48 89 C2"}.add(3).read()>()
            .template addPattern<OffsetToPlayerController, CodePattern{"D0 89 87 ? ? ? ? 48 8B 07"}.add(3).read()>()
            .template addPattern<OffsetToIsDefusing, CodePattern{"? ? ? ? 00 75 ? 41 C6 ? ? ? ? ? 01 80"}.read()>()
            .template addPattern<OffsetToIsPickingUpHostage, CodePattern{"? ? ? ? 00 74 ? C6 86 ? ? ? ? 00 4C"}.read()>()
            .template addPattern<OffsetToHostageServices, CodePattern{"8B BB ? ? ? ? 31 F6 E8 ? ? ? ? ? 89 ? 4C"}.add(2).read()>()
            .template addPattern<OffsetToFlashBangEndTime, CodePattern{"41 0F 10 ? ? ? ? ? F3 0F 5C 05"}.add(4).read()>()
            .template addPattern<OffsetToPlayerPawnSceneObjectUpdaterHandle, CodePattern{"89 83 ? ? ? ? 48 8B BB ? ? ? ? 48 8B"}.add(2).read()>()
            .template addPattern<OffsetToIsScoped, CodePattern{"BB ? ? ? ? 00 F3 0F 11 45"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PlayerResourcePatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlayerResourcePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlayerResourcePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<PointerToPlayerResource, CodePattern{"C5 48 8D 05 ? ? ? ? 48 83 38 00 0F"}.add(4).abs()>()
            .template addPattern<OffsetToBombsiteACenter, CodePattern{"FF 48 C7 80 ? ? ? ? 00 00 00 00 0F 11 80 ? ? ? ?"}.add(15).read()>()
            .template addPattern<OffsetToBombsiteBCenter, CodePattern{"FF 48 C7 80 ? ? ? ? 00 00 00 00 0F 11 80"}.add(4).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/PortraitWorldPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PortraitWorldPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PortraitWorldPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToPortraitWorldEntities, CodePattern{"48 89 FB 48 83 EC ? 4C 63 6F ? 48"}.add(10).read()>()
            .template addPattern<OffsetToPortraitWorldMapEntities, CodePattern{"4D 63 A6 ? ? ? ? 45"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/RenderComponentPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/RenderComponentPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct RenderComponentPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToSceneObjectUpdaters, CodePattern{"? ? ? 48 8B 47 ? 48 63 F6 48 8B 34"}.read()>();
    }
};

```

`Source/MemoryPatterns/Linux/SceneObjectPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneObjectPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SceneObjectPatterns {
    [[nodiscard]] static consteval auto addSceneSystemPatterns(auto sceneSystemPatterns) noexcept
    {
        return sceneSystemPatterns
            .template addPattern<OffsetToSceneObjectFlags, CodePattern{"84 06 ? ? ? ? ? 0F 85 ? ? ? ? F6 ? ? ? ? ?"}.add(15).read()>()
            .template addPattern<OffsetToSceneObjectClass, CodePattern{"0F B6 ? ? ? ? ? 48 05"}.add(3).read()>()
            .template addPattern<OffsetToSceneObjectAttributes, CodePattern{"89 9C 24 ? ? ? ? 48 83"}.add(3).read()>()
            .template addPattern<OffsetToSceneObjectRenderableFlags, CodePattern{"DE 48 89 53 ?"}.add(4).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/SceneObjectUpdaterPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneObjectUpdaterPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SceneObjectUpdaterPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToSceneObject, CodePattern{"74 ? 48 8B 46 ? C3"}.add(5).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/SceneSystemPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneSystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SceneSystemPatterns {
    [[nodiscard]] static consteval auto addSceneSystemPatterns(auto sceneSystemPatterns) noexcept
    {
        return sceneSystemPatterns
            .template addPattern<SceneSystemPointer, CodePattern{"? ? ? ? F6 84 02 ? ? ? ? ? 75 ? 66"}.abs()>()
            .template addPattern<DeleteSceneObjectFunctionPointer, CodePattern{"48 85 F6 0F 84 ? ? ? ? 55 48 89 E5 41 56 49"}>()
            .template addPattern<AllocateAttributeListFunctionPointer, CodePattern{"C3 48 8B 3D ? ? ? ? 48 8D 15 ? ? ? ? 66"}.add(11).abs()>();
    }
};

```

`Source/MemoryPatterns/Linux/SdlPatternsLinux.h`:

```h
#pragma once

#include <MemorySearch/BytePatternLiteral.h>
#include <SDL/SdlFunctions.h>

template <typename PatternFinders>
struct SdlPatterns {
    const PatternFinders& patternFinders;

    [[nodiscard]] sdl3::SDL_PeepEvents** peepEventsPointer(sdl3::SDL_PeepEvents* peepEvents) const noexcept
    {
        return patternFinders.sdlPatternFinder.matchPatternAtAddress((void*)peepEvents, "FF 25 ? ? ? ?"_pat).add(2).abs().template as<sdl3::SDL_PeepEvents**>();
    }
};

```

`Source/MemoryPatterns/Linux/SliderPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SliderPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SliderPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SliderSetValueFunction, CodePattern{"FF 50 ? F3 0F 10 45 ? 48 83 C4 ? 48 89 DF 5B 41 5C 41 5D 41 5E 41 5F 5D E9 ? ? ? ?"}.add(26).abs()>();
    }
};

```

`Source/MemoryPatterns/Linux/SmokeGrenadeProjectilePatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SmokeGrenadeProjectilePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SmokeGrenadeProjectilePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToDidSmokeEffect, CodePattern{"85 F6 75 ? 80 BF ? ? ? ?"}.add(6).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/SoundSystemPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SoundSystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SoundSystemPatterns {
    [[nodiscard]] static consteval auto addSoundSystemPatterns(auto soundSystemPatterns) noexcept
    {
        return soundSystemPatterns
            .template addPattern<SoundChannelsPointer, CodePattern{"B8 ? ? ? ? 00 0F 84 ? ? ? ? ? ? ? ? ? ? ? 48 B8"}.add(15).abs()>();
    }
};

```

`Source/MemoryPatterns/Linux/TextEntryPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/TextEntryPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct TextEntryPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<TextEntrySetTextFunction, CodePattern{"8B BF ? ? ? ? E8 ? ? ? ? B8"}.add(7).abs()>();
    }
};

```

`Source/MemoryPatterns/Linux/TopLevelWindowPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/TopLevelWindowPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct TopLevelWindowPatterns {
    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<UiScaleFactorOffset, CodePattern{"F3 0F 11 47 ? 48 8B"}.add(4).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/Ui3dPanelPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/Ui3dPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct Ui3dPanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToPortraitWorld, CodePattern{"84 ? ? ? ? 49 8B ? ? 8B B0 ? ? ? ? 48"}.add(8).read()>()
            .template addPattern<OffsetTo3dPanelFov, CodePattern{"2E 83 ? ? ? ? C6 83 ? ? ? ? ? 7A"}.add(2).read()>()
            .template addPattern<OffsetTo3dPanelFovWeight, CodePattern{"84 ? ? ? ? C7 83 ? ? ? ? 00 00 00 00 F3 0F 11"}.add(7).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/UiItem3dPanelPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/UiItem3dPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct UiItem3dPanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetItemItemIdFunction, CodePattern{"48 0F 44 D1 E9 ? ? ? ?"}.add(5).abs()>()
            .template addPattern<OffsetToItem3dPanelUnknownField, CodePattern{"41 39 44 24 ? 44"}.add(4).read()>()
            .template addPattern<OffsetToStartWeaponLookAt, CodePattern{"B8 01 00 00 00 66 89 87 ? ? ? ? C3"}.add(8).read()>()
            .template addPattern<OffsetToItem3dPanelProperties, CodePattern{"48 8D 8B ? ? ? ? 4C 89 F7"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/WeaponPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/WeaponPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct WeaponPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToClipAmmo, CodePattern{"? ? ? ? 85 C0 7E ? 85 C0 ? 8B"}.read()>()
            .template addPattern<OffsetToWeaponSceneObjectUpdaterHandle, CodePattern{"48 89 83 ? ? ? ? BE ? ? ? ? 48 89 DF"}.add(3).read()>()
            .template addPattern<PointerToGetInaccuracyFunction, CodePattern{"55 48 89 E5 41 57 41 56 49 89 ? 41 55 49 89 ? 41 54 53 48 89 FB 48 83 EC ? E8"}>()
            .template addPattern<PointerToGetSpreadFunction, CodePattern{"55 48 89 E5 48 83 EC ? 48 63"}>();
    }
};

```

`Source/MemoryPatterns/Linux/WeaponServicesPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/WeaponServicesPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct WeaponServicesPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToActiveWeapon, CodePattern{"B7 4B ? 48 89 C8"}.add(2).read()>()
            .template addPattern<OffsetToWeapons, CodePattern{"8B 57 ? 48 8B 4F ? 8D"}.add(2).read()>();
    }
};

```

`Source/MemoryPatterns/Linux/WeaponVDataPatternsLinux.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/WeaponVDataPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct WeaponVDataPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToWeaponName, CodePattern{"B8 ? ? ? ? 48 8D 05 ? ? ? ? 48 85 FF 48 0F 44 F8 F3"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/MemoryPatterns.h`:

```h
#pragma once

#if IS_WIN64()
#include "Windows/WindowsPatterns.h"
#elif IS_LINUX()
#include "Linux/LinuxPatterns.h"
#endif

#include "PatternFinders.h"

#include <MemorySearch/PatternPool.h>
#include <MemorySearch/TempPatternPool.h>

struct MemoryPatterns {
    const PatternFinders& patternFinders;

#define MEMORY_PATTERNS(type, name) \
[[nodiscard]] auto name() const noexcept \
{ \
    return type<PatternFinders>{patternFinders}; \
}

    MEMORY_PATTERNS(PanelStylePatterns, panelStylePatterns)
    MEMORY_PATTERNS(SdlPatterns, sdlPatterns)

#undef MEMORY_PATTERNS
};

constexpr auto kClientPatterns = []() consteval {
#define ADD_PATTERNS(patterns) addPatterns([](auto patternPool) consteval { return patterns::addClientPatterns(patternPool); })
    constexpr auto builder = PatternPoolBuilder<TempPatternPool<2000, 100>>{}
        .ADD_PATTERNS(BaseModelEntityPatterns)
        .ADD_PATTERNS(C4Patterns)
        .ADD_PATTERNS(ClientPatterns)
        .ADD_PATTERNS(CvarPatterns)
        .ADD_PATTERNS(EntityPatterns)
        .ADD_PATTERNS(EntitySystemPatterns)
        .ADD_PATTERNS(GameRulesPatterns)
        .ADD_PATTERNS(GameSceneNodePatterns)
        .ADD_PATTERNS(GlobalVarsPatterns)
        .ADD_PATTERNS(HostageServicesPatterns)
        .ADD_PATTERNS(GlowPropertyPatterns)
        .ADD_PATTERNS(GlowSceneObjectPatterns)
        .ADD_PATTERNS(MemAllocPatterns)
        .ADD_PATTERNS(PanelPatterns)
        .ADD_PATTERNS(PanoramaDropDownPatterns)
        .ADD_PATTERNS(PanoramaImagePanelPatterns)
        .ADD_PATTERNS(PanoramaLabelPatterns)
        .ADD_PATTERNS(PanoramaUiEnginePatterns)
        .ADD_PATTERNS(PanoramaUiPanelPatterns)
        .ADD_PATTERNS(PlantedC4Patterns)
        .ADD_PATTERNS(PlayerControllerPatterns)
        .ADD_PATTERNS(PlayerPawnPatterns)
        .ADD_PATTERNS(PlayerResourcePatterns)
        .ADD_PATTERNS(PortraitWorldPatterns)
        .ADD_PATTERNS(RenderComponentPatterns)
        .ADD_PATTERNS(SceneObjectUpdaterPatterns)
        .ADD_PATTERNS(SliderPatterns)
        .ADD_PATTERNS(SmokeGrenadeProjectilePatterns)
        .ADD_PATTERNS(TextEntryPatterns)
        .ADD_PATTERNS(Ui3dPanelPatterns)
        .ADD_PATTERNS(UiItem3dPanelPatterns)
        .ADD_PATTERNS(WeaponPatterns)
        .ADD_PATTERNS(WeaponServicesPatterns)
        .ADD_PATTERNS(WeaponVDataPatterns);
#undef ADD_PATTERNS
    return PatternPool<>::from<builder>();
}();

constexpr auto kSceneSystemPatterns = []() consteval {
#define ADD_PATTERNS(patterns) addPatterns([](auto patternPool) consteval { return patterns::addSceneSystemPatterns(patternPool); })
    constexpr auto builder = PatternPoolBuilder<TempPatternPool<1500, 100>>{}
        .ADD_PATTERNS(SceneObjectPatterns)
        .ADD_PATTERNS(SceneSystemPatterns);
#undef ADD_PATTERNS
    return PatternPool<>::from<builder>();
}();

constexpr auto kTier0Patterns = []() consteval {
#define ADD_PATTERNS(patterns) addPatterns([](auto patternPool) consteval { return patterns::addTier0Patterns(patternPool); })
    constexpr auto builder = PatternPoolBuilder<TempPatternPool<1500, 100>>{}
        .ADD_PATTERNS(ConVarPatterns)
        .ADD_PATTERNS(CvarPatterns);
#undef ADD_PATTERNS
    return PatternPool<>::from<builder>();
}();

constexpr auto kFileSystemPatterns = []() consteval {
#define ADD_PATTERNS(patterns) addPatterns([](auto patternPool) consteval { return patterns::addFileSystemPatterns(patternPool); })
    constexpr auto builder = PatternPoolBuilder<TempPatternPool<1500, 100>>{}
        .ADD_PATTERNS(FileSystemPatterns);
#undef ADD_PATTERNS
    return PatternPool<>::from<builder>();
}();

constexpr auto kSoundSystemPatterns = []() consteval {
#define ADD_PATTERNS(patterns) addPatterns([](auto patternPool) consteval { return patterns::addSoundSystemPatterns(patternPool); })
    constexpr auto builder = PatternPoolBuilder<TempPatternPool<1500, 100>>{}
        .ADD_PATTERNS(FileSystemPatterns)
        .ADD_PATTERNS(SoundSystemPatterns);
#undef ADD_PATTERNS
    return PatternPool<>::from<builder>();
}();

constexpr auto kPanoramaPatterns = []() consteval {
#define ADD_PATTERNS(patterns) addPatterns([](auto patternPool) consteval { return patterns::addPanoramaPatterns(patternPool); })
    constexpr auto builder = PatternPoolBuilder<TempPatternPool<1500, 100>>{}
        .ADD_PATTERNS(PanelStylePatterns2)
        .ADD_PATTERNS(PanoramaUiEnginePatterns)
        .ADD_PATTERNS(PanoramaUiPanelPatterns)
        .ADD_PATTERNS(TopLevelWindowPatterns);
#undef ADD_PATTERNS
    return PatternPool<>::from<builder>();
}();

```

`Source/MemoryPatterns/PatternFinders.h`:

```h
#pragma once

#include <MemorySearch/PatternFinder.h>
#include <MemorySearch/PatternNotFoundLogger.h>

struct PatternFinders {
    PatternFinder<PatternNotFoundLogger> clientPatternFinder;
    PatternFinder<PatternNotFoundLogger> tier0PatternFinder;
    PatternFinder<PatternNotFoundLogger> soundSystemPatternFinder;
    PatternFinder<PatternNotFoundLogger> fileSystemPatternFinder;
    PatternFinder<PatternNotFoundLogger> panoramaPatternFinder;
    PatternFinder<PatternNotFoundLogger> sdlPatternFinder;
    PatternFinder<PatternNotFoundLogger> sceneSystemPatternFinder;
};

```

`Source/MemoryPatterns/PatternTypes/BaseModelEntityPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/C_BaseModelEntity.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using BaseModelEntityOffset = FieldOffset<cs2::C_BaseModelEntity, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToGlowProperty, BaseModelEntityOffset<cs2::C_BaseModelEntity::m_Glow, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/C4PatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/WeaponEntities.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using C4Offset = FieldOffset<cs2::C_C4, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToIsBeingPlanted, C4Offset<cs2::C_C4::m_bStartedArming, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToArmingEndTime, C4Offset<cs2::C_C4::m_fArmedTime, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/ClientPatternTypes.h`:

```h
#pragma once

#include <CS2/Classes/GlobalVars.h>
#include <CS2/Classes/ClientModeCSNormal.h>
#include <CS2/Classes/CSceneObject.h>
#include <CS2/Classes/CViewRender.h>
#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <CS2/Classes/Glow.h>
#include <CS2/Classes/VMatrix.h>
#include <CS2/Panorama/CPanel2D.h>
#include <Platform/Macros/IsPlatform.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(MainMenuPanelPointer, cs2::CPanel2D**);
STRONG_TYPE_ALIAS(HudPanelPointer, cs2::CPanel2D**);
STRONG_TYPE_ALIAS(GlobalVarsPointer, cs2::GlobalVars**);
STRONG_TYPE_ALIAS(TransformTranslate3dVMT, const void*);
STRONG_TYPE_ALIAS(TransformScale3dVMT, const void*);
STRONG_TYPE_ALIAS(WorldToProjectionMatrixPointer, cs2::VMatrix*);
STRONG_TYPE_ALIAS(ViewToProjectionMatrixPointer, cs2::VMatrix*);
STRONG_TYPE_ALIAS(ViewRenderPointer, cs2::CViewRender**);
STRONG_TYPE_ALIAS(LocalPlayerControllerPointer, cs2::CCSPlayerController**);
STRONG_TYPE_ALIAS(ManageGlowSceneObjectPointer, cs2::ManageGlowSceneObject*);
STRONG_TYPE_ALIAS(PointerToClientMode, cs2::ClientModeCSNormal*);

#if IS_WIN64()
STRONG_TYPE_ALIAS(SetSceneObjectAttributeFloat4, void(*)(cs2::SceneObjectAttributes::FloatAttributes* attributes, unsigned int attributeNameHash, float value[4]));
#else
STRONG_TYPE_ALIAS(SetSceneObjectAttributeFloat4, void(*)(cs2::SceneObjectAttributes::FloatAttributes* attributes, unsigned int attributeNameHash, double value1, double value2));
#endif

```

`Source/MemoryPatterns/PatternTypes/ConVarPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/ConVar.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using ConVarOffset = FieldOffset<cs2::ConVar, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToConVarValueType, ConVarOffset<cs2::ConVar::ValueType, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToConVarValue, ConVarOffset<cs2::ConVar::Value, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/CvarPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CCvar.h>
#include <Utils/FieldFieldOffset.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(OffsetToConVarList, FieldFieldOffset<cs2::CCvar, cs2::CCvar::ConVarList, std::int8_t, offsetof(cs2::CCvar::ConVarList, memory)>);
STRONG_TYPE_ALIAS(CvarPointer, cs2::CCvar**);

```

`Source/MemoryPatterns/PatternTypes/EntityPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/C_BaseEntity.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using EntityOffset = FieldOffset<cs2::C_BaseEntity, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToGameSceneNode, EntityOffset<cs2::C_BaseEntity::m_pGameSceneNode, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToHealth, EntityOffset<cs2::C_BaseEntity::m_iHealth, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToLifeState, EntityOffset<cs2::C_BaseEntity::m_lifeState, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToTeamNumber, EntityOffset<cs2::C_BaseEntity::m_iTeamNum, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToVData, EntityOffset<cs2::C_BaseEntity::m_pSubclassVData, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToRenderComponent, EntityOffset<cs2::C_BaseEntity::m_pRenderComponent, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToOwnerEntity, EntityOffset<cs2::C_BaseEntity::m_hOwnerEntity, std::int32_t>);
STRONG_TYPE_ALIAS(GetAbsOriginFunction, cs2::C_BaseEntity::GetAbsOrigin*);

```

`Source/MemoryPatterns/PatternTypes/EntitySystemPatternTypes.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include <CS2/Classes/EntitySystem/CEntityIndex.h>
#include <CS2/Classes/EntitySystem/CConcreteEntityList.h>
#include <CS2/Classes/EntitySystem/CGameEntitySystem.h>
#include <Utils/FieldFieldOffset.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using EntitySystemOffset = FieldOffset<cs2::CGameEntitySystem, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(EntitySystemPointer, cs2::CGameEntitySystem**);
STRONG_TYPE_ALIAS(HighestEntityIndexOffset, EntitySystemOffset<cs2::CEntityIndex, std::int32_t>);
STRONG_TYPE_ALIAS(EntityListOffset, EntitySystemOffset<cs2::CConcreteEntityList, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToEntityClasses, FieldFieldOffset<cs2::CGameEntitySystem, cs2::CGameEntitySystem::EntityClasses, std::int32_t, offsetof(cs2::CGameEntitySystem::EntityClasses, memory)>);

```

`Source/MemoryPatterns/PatternTypes/FileSystemPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/FileSystem.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using FileSystemOffset = FieldOffset<cs2::CBaseFileSystem, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(FileSystemPointer, cs2::CBaseFileSystem**);
STRONG_TYPE_ALIAS(FileNamesOffset, FileSystemOffset<cs2::CBaseFileSystem::m_FileNames, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/GameRulesPatternTypes.h`:

```h
#pragma once

#include <cstdint>
#include <CS2/Classes/C_CSGameRules.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using GameRulesOffset = FieldOffset<cs2::C_CSGameRules, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(GameRulesPointer, cs2::C_CSGameRules**);
STRONG_TYPE_ALIAS(RoundStartTimeOffset, GameRulesOffset<cs2::C_CSGameRules::m_fRoundStartTime, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToRoundRestartTime, GameRulesOffset<cs2::C_CSGameRules::m_flRestartRoundTime, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToRoundLength, GameRulesOffset<cs2::C_CSGameRules::m_iRoundTime, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToRoundWinStatus, GameRulesOffset<cs2::C_CSGameRules::m_iRoundWinStatus, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/GameSceneNodePatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CGameSceneNode.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using GameSceneNodeOffset = FieldOffset<cs2::CGameSceneNode, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToAbsOrigin, GameSceneNodeOffset<cs2::CGameSceneNode::m_vecAbsOrigin, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToGameSceneNodeOwner, GameSceneNodeOffset<cs2::CGameSceneNode::m_pOwner, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToChildGameSceneNode, GameSceneNodeOffset<cs2::CGameSceneNode::m_pChild, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToNextSiblingGameSceneNode, GameSceneNodeOffset<cs2::CGameSceneNode::m_pNextSibling, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/GlobalVarsPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/GlobalVars.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using GlobalVarsOffset = FieldOffset<cs2::GlobalVars, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToFrametime, GlobalVarsOffset<cs2::GlobalVars::frametime, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/GlowPropertyPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CGlowProperty.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using GlowPropertyOffset = FieldOffset<cs2::CGlowProperty, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToIsGlowing, GlowPropertyOffset<cs2::CGlowProperty::m_bGlowing, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/GlowSceneObjectPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Glow.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using GlowSceneObjectOffset = FieldOffset<cs2::CGlowHelperSceneObject, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToGlowSceneObjectEntity, GlowSceneObjectOffset<cs2::CGlowHelperSceneObject::entity, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToGlowSceneObjectAttachedSceneObject, GlowSceneObjectOffset<cs2::CGlowHelperSceneObject::attachedSceneObject, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/HostageServicesPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CCSPlayer_HostageServices.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using HostageServicesOffset = FieldOffset<cs2::CCSPlayer_HostageServices, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToCarriedHostage, HostageServicesOffset<cs2::CCSPlayer_HostageServices::m_hCarriedHostage, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/MemAllocPatternTypes.h`:

```h
#pragma once

#include <cstdint>
#include <CS2/Classes/IMemAlloc.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(OffsetAllocVirtualMethod, FieldOffset<const void, cs2::IMemAlloc::Alloc*, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/PanelPatternTypes.h`:

```h
#pragma once

#include <CS2/Panorama/CPanel2D.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(PanelConstructorPointer, cs2::CPanel2D::Create*);

```

`Source/MemoryPatterns/PatternTypes/PanelStylePatternTypes.h`:

```h
#pragma once

#include <CS2/Panorama/CPanelStyle.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(SetPanelStylePropertyFunctionPointer, cs2::CPanelStyle::SetProperty*);

```

`Source/MemoryPatterns/PatternTypes/PanoramaDropDownPatternTypes.h`:

```h
#pragma once

#include <CS2/Panorama/CDropDown.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(SetSelectedIndexFunctionPointer, cs2::CDropDown::SetSelectedIndex*);

```

`Source/MemoryPatterns/PatternTypes/PanoramaImagePanelPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Panorama/CImagePanel.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using PanoramaImagePanelOffset = FieldOffset<cs2::CImagePanel, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(ImagePropertiesOffset, PanoramaImagePanelOffset<cs2::ImageProperties, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToImagePath, PanoramaImagePanelOffset<cs2::CImagePanel::m_strSource, std::int32_t>);
STRONG_TYPE_ALIAS(SetImageFunctionPointer, cs2::CImagePanel::SetImage*);
STRONG_TYPE_ALIAS(ImagePanelConstructorPointer, cs2::CImagePanel::Constructor*);
STRONG_TYPE_ALIAS(ImagePanelClassSize, std::uint32_t);

```

`Source/MemoryPatterns/PatternTypes/PanoramaLabelPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Panorama/CLabel.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(LabelPanelConstructorPointer, cs2::CLabel::Constructor*);
STRONG_TYPE_ALIAS(SetLabelTextFunctionPointer, cs2::CLabel::setTextInternal);
STRONG_TYPE_ALIAS(LabelPanelObjectSize, std::uint32_t);

```

`Source/MemoryPatterns/PatternTypes/PlantedC4PatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CPlantedC4.h>
#include <CS2/Classes/CUtlVector.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using PlantedC4Offset = FieldOffset<cs2::CPlantedC4, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(PlantedC4sPointer, cs2::CUtlVector<cs2::CPlantedC4*>*);
STRONG_TYPE_ALIAS(BombSiteOffset, PlantedC4Offset<cs2::CPlantedC4::m_nBombSite, std::int32_t>);
STRONG_TYPE_ALIAS(BombTickingOffset, PlantedC4Offset<cs2::CPlantedC4::m_bBombTicking, std::int32_t>);
STRONG_TYPE_ALIAS(BombBlowTimeOffset, PlantedC4Offset<cs2::CPlantedC4::m_flC4Blow, std::int32_t>);
STRONG_TYPE_ALIAS(BombDefuserOffset, PlantedC4Offset<cs2::CPlantedC4::m_hBombDefuser, std::int32_t>);
STRONG_TYPE_ALIAS(BombDefuseEndTimeOffset, PlantedC4Offset<cs2::CPlantedC4::m_flDefuseCountDown, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/PlayerControllerPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using PlayerControllerOffset = FieldOffset<cs2::CCSPlayerController, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToBasePawnHandle, PlayerControllerOffset<cs2::CCSPlayerController::m_hPawn, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToPlayerColor, PlayerControllerOffset<cs2::CCSPlayerController::m_iCompTeammateColor, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/PlayerPawnPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/C_CSPlayerPawn.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using PlayerPawnOffset = FieldOffset<cs2::C_CSPlayerPawn, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToPlayerPawnImmunity, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_bGunGameImmunity, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToWeaponServices, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_pWeaponServices, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToPlayerController, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_hController, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToIsDefusing, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_bIsDefusing, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToIsPickingUpHostage, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_bIsGrabbingHostage, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToHostageServices, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_pHostageServices, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToFlashBangEndTime, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_flFlashBangTime, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToPlayerPawnSceneObjectUpdaterHandle, PlayerPawnOffset<cs2::C_CSPlayerPawn::sceneObjectUpdaterHandle, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToIsScoped, PlayerPawnOffset<cs2::C_CSPlayerPawn::m_bIsScoped, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/PlayerResourcePatternTypes.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <CS2/Classes/Entities/C_CSPlayerResource.h>
#include <Platform/Macros/IsPlatform.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using PlayerResourceOffset = FieldOffset<cs2::C_CSPlayerResource, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(PointerToPlayerResource, cs2::C_CSPlayerResource**);
STRONG_TYPE_ALIAS(OffsetToBombsiteACenter, PlayerResourceOffset<cs2::C_CSPlayerResource::m_bombsiteCenterA, std::int32_t>);
#if IS_WIN64()
STRONG_TYPE_ALIAS(OffsetToBombsiteBCenter, PlayerResourceOffset<cs2::C_CSPlayerResource::m_bombsiteCenterB, std::int32_t>);
#elif IS_LINUX()
STRONG_TYPE_ALIAS(OffsetToBombsiteBCenter, FieldFieldOffset<cs2::C_CSPlayerResource, cs2::C_CSPlayerResource::m_bombsiteCenterB, std::int32_t, offsetof(cs2::C_CSPlayerResource::m_bombsiteCenterB, y)>);
#endif

```

`Source/MemoryPatterns/PatternTypes/PortraitWorldPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CCS_PortraitWorld.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(OffsetToPortraitWorldEntities, FieldOffset<cs2::CCS_PortraitWorld, cs2::CCS_PortraitWorld::DynamicEntityHandles, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToPortraitWorldMapEntities, FieldOffset<cs2::CCS_PortraitWorld, cs2::CCS_PortraitWorld::MapEntityHandles, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/RenderComponentPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CRenderComponent.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using RenderComponentOffset = FieldOffset<cs2::CRenderComponent, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToSceneObjectUpdaters, RenderComponentOffset<cs2::CRenderComponent::sceneObjectUpdaters, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/SceneObjectPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CSceneObject.h>
#include <Platform/Macros/PlatformSpecific.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using SceneObjectOffset = FieldOffset<cs2::CSceneObject, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToSceneObjectFlags, SceneObjectOffset<cs2::CSceneObject::flags, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToSceneObjectClass, SceneObjectOffset<cs2::CSceneObject::m_nObjectClass, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToSceneObjectAttributes, SceneObjectOffset<cs2::CSceneObject::attributes, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToSceneObjectRenderableFlags, SceneObjectOffset<cs2::CSceneObject::m_nRenderableFlags, WIN64_LINUX(std::int32_t, std::int8_t)>);

```

`Source/MemoryPatterns/PatternTypes/SceneObjectUpdaterPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/SceneObjectUpdaterHandle_t.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using SceneObjectUpdaterOffset = FieldOffset<cs2::SceneObjectUpdaterHandle_t, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToSceneObject, SceneObjectUpdaterOffset<cs2::SceneObjectUpdaterHandle_t::sceneObject, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/SceneSystemPatternTypes.h`:

```h
#pragma once

#include <CS2/Classes/CSceneSystem.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(SceneSystemPointer, cs2::CSceneSystem*);
STRONG_TYPE_ALIAS(DeleteSceneObjectFunctionPointer, cs2::CSceneSystem::DeleteSceneObject*);
STRONG_TYPE_ALIAS(AllocateAttributeListFunctionPointer, cs2::CSceneSystem::AllocateAttributeList*);

```

`Source/MemoryPatterns/PatternTypes/SliderPatternTypes.h`:

```h
#pragma once

#include <CS2/Panorama/CSlider.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(SliderSetValueFunction, cs2::CSlider::SetValue*);

```

`Source/MemoryPatterns/PatternTypes/SmokeGrenadeProjectilePatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/GrenadeProjectiles.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using SmokeGrenadeProjectileOffset = FieldOffset<cs2::C_SmokeGrenadeProjectile, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToDidSmokeEffect, SmokeGrenadeProjectileOffset<cs2::C_SmokeGrenadeProjectile::m_bDidSmokeEffect, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/SoundSystemPatternTypes.h`:

```h
#pragma once

#include <CS2/Classes/Sound.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(SoundChannelsPointer, cs2::SoundChannels**);

```

`Source/MemoryPatterns/PatternTypes/TextEntryPatternTypes.h`:

```h
#pragma once

#include <CS2/Panorama/CTextEntry.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(TextEntrySetTextFunction, cs2::CTextEntry::SetText*);

```

`Source/MemoryPatterns/PatternTypes/TopLevelWindowPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Panorama/CTopLevelWindow.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using TopLevelWindowOffset = FieldOffset<cs2::CTopLevelWindow, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(UiScaleFactorOffset, TopLevelWindowOffset<cs2::CTopLevelWindow::m_flScaleFactor, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/Ui3dPanelPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Panorama/CUI_3dPanel.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(OffsetToPortraitWorld, FieldOffset<cs2::CUI_3dPanel, cs2::CUI_3dPanel::PortraitWorld, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetTo3dPanelFov, FieldOffset<cs2::CUI_3dPanel, cs2::CUI_3dPanel::Fov, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetTo3dPanelFovWeight, FieldOffset<cs2::CUI_3dPanel, cs2::CUI_3dPanel::FovWeight, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/UiEnginePatternTypes.h`:

```h
#pragma once

#include <CS2/Panorama/CUIEngine.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(UiEnginePointer, cs2::CUIEngine**);
STRONG_TYPE_ALIAS(GetPanelPointerFunctionPointer, cs2::CUIEngine::getPanelPointer);
STRONG_TYPE_ALIAS(RunScriptFunctionPointer, cs2::CUIEngine::runScript);
STRONG_TYPE_ALIAS(MakeSymbolFunctionPointer, cs2::CUIEngine::makeSymbol);
STRONG_TYPE_ALIAS(OnDeletePanelFunctionPointer, cs2::CUIEngine::onDeletePanel);
STRONG_TYPE_ALIAS(RegisterEventHandlerFunctionPointer, cs2::CUIEngine::RegisterEventHandler);

```

`Source/MemoryPatterns/PatternTypes/UiItem3dPanelPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Panorama/CUI_Item3dPanel.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

STRONG_TYPE_ALIAS(SetItemItemIdFunction, cs2::CUI_Item3dPanel::SetItemItemId*);
STRONG_TYPE_ALIAS(OffsetToItem3dPanelProperties, FieldOffset<cs2::CUI_Item3dPanel, cs2::CUI_Item3dPanel::Properties, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToItem3dPanelUnknownField, FieldOffset<cs2::CUI_Item3dPanel::Properties, cs2::CUI_Item3dPanel::Properties::UnknownField, std::int8_t>); // fixme: rename, looks like it is "keychain slot 0 id" of the item in the panel
STRONG_TYPE_ALIAS(OffsetToStartWeaponLookAt, FieldOffset<cs2::CUI_Item3dPanel, cs2::CUI_Item3dPanel::StartWeaponLookAt, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/UiPanelPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Panorama/CPanelStyle.h>
#include <CS2/Panorama/CTopLevelWindow.h>
#include <CS2/Panorama/CUIPanel.h>
#include <CS2/Panorama/PanelHandle.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using PanoramaUiPanelOffset = FieldOffset<cs2::CUIPanel, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(SetParentFunctionOffset, FieldOffset<const void, cs2::CUIPanel::setParent, std::int32_t>);
STRONG_TYPE_ALIAS(SetVisibleFunctionOffset, FieldOffset<const void, cs2::CUIPanel::setVisible, std::int32_t>);
STRONG_TYPE_ALIAS(GetAttributeStringFunctionOffset, FieldOffset<const void, cs2::CUIPanel::getAttributeString, std::int32_t>);
STRONG_TYPE_ALIAS(SetAttributeStringFunctionOffset, FieldOffset<const void, cs2::CUIPanel::setAttributeString, std::int32_t>);

STRONG_TYPE_ALIAS(ChildPanelsVectorOffset, PanoramaUiPanelOffset<cs2::CUIPanel::childrenVector, std::int8_t>);
STRONG_TYPE_ALIAS(PanelClassesVectorOffset, PanoramaUiPanelOffset<cs2::CUIPanel::classesVector, std::int32_t>);
STRONG_TYPE_ALIAS(PanelStyleOffset, PanoramaUiPanelOffset<cs2::CPanelStyle, std::int8_t>);
STRONG_TYPE_ALIAS(ParentWindowOffset, PanoramaUiPanelOffset<cs2::CTopLevelWindow*, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToPanelId, PanoramaUiPanelOffset<cs2::CUIPanel::m_pchID, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToPanelFlags, PanoramaUiPanelOffset<cs2::CUIPanel::PanelFlags, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToPanelHandle, PanoramaUiPanelOffset<cs2::PanelHandle, std::int32_t>);

```

`Source/MemoryPatterns/PatternTypes/WeaponPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Entities/C_CSWeaponBase.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using WeaponOffset = FieldOffset<cs2::C_CSWeaponBase, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToClipAmmo, WeaponOffset<cs2::C_CSWeaponBase::m_iClip1, std::int32_t>);
STRONG_TYPE_ALIAS(OffsetToWeaponSceneObjectUpdaterHandle, WeaponOffset<cs2::C_CSWeaponBase::sceneObjectUpdaterHandle, std::int32_t>);
STRONG_TYPE_ALIAS(PointerToGetInaccuracyFunction, cs2::C_CSWeaponBase::GetInaccuracy*);
STRONG_TYPE_ALIAS(PointerToGetSpreadFunction, cs2::C_CSWeaponBase::GetSpread*);

```

`Source/MemoryPatterns/PatternTypes/WeaponServicesPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CCSPlayer_WeaponServices.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using WeaponServicesOffset = FieldOffset<cs2::CCSPlayer_WeaponServices, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToActiveWeapon, WeaponServicesOffset<cs2::CCSPlayer_WeaponServices::m_hActiveWeapon, std::int8_t>);
STRONG_TYPE_ALIAS(OffsetToWeapons, WeaponServicesOffset<cs2::CCSPlayer_WeaponServices::m_hMyWeapons, std::int8_t>);

```

`Source/MemoryPatterns/PatternTypes/WeaponVDataPatternTypes.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/CCSWeaponBaseVData.h>
#include <Utils/FieldOffset.h>
#include <Utils/StrongTypeAlias.h>

template <typename FieldType, typename OffsetType>
using WeaponVDataOffset = FieldOffset<cs2::CCSWeaponBaseVData, FieldType, OffsetType>;

STRONG_TYPE_ALIAS(OffsetToWeaponName, WeaponVDataOffset<cs2::CCSWeaponBaseVData::m_szName, std::int32_t>);

```

`Source/MemoryPatterns/Windows/BaseModelEntityPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/BaseModelEntityPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct BaseModelEntityPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToGlowProperty, CodePattern{"90 ? ? ? ? ? 8B ? 48 8D 88 ? ? ? ?"}.add(11).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/C4PatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/C4PatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct C4Patterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToIsBeingPlanted, CodePattern{"? ? ? ? 00 74 ? F3 0F 10 05 ? ? ? ? C3"}.read()>()
            .template addPattern<OffsetToArmingEndTime, CodePattern{"05 ? ? ? ? F3 0F 11 87 ? ? ? ? 44"}.add(9).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/ClientPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct ClientPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<MainMenuPanelPointer, CodePattern{"48 83 EC ? 48 8B 05 ? ? ? ? 48 8D 15"}.add(7).abs()>()
            .template addPattern<HudPanelPointer, CodePattern{"48 89 35 ? ? ? ? E8 ? ? ? ? 48 85"}.add(3).abs()>()
            .template addPattern<GlobalVarsPointer, CodePattern{"48 8B 05 ? ? ? ? 0F 57 C0 8B 48"}.add(3).abs()>()
            .template addPattern<TransformTranslate3dVMT, CodePattern{"00 00 80 00 48 8D 05 ? ? ? ? 48 C7 42 ? 00"}.add(7).abs()>()
            .template addPattern<TransformScale3dVMT, CodePattern{"48 8D 0D ? ? ? ? F3 0F 10 4B ? F3 0F 10 43"}.add(3).abs()>()
            .template addPattern<WorldToProjectionMatrixPointer, CodePattern{"48 8D 0D ? ? ? ? 48 C1 E0 06"}.add(3).abs()>()
            .template addPattern<ViewToProjectionMatrixPointer, CodePattern{"48 89 4C 24 ? 4C 8D 0D ? ? ? ? 48 8B 0D"}.add(8).abs()>()
            .template addPattern<ViewRenderPointer, CodePattern{"48 89 05 ? ? ? ? 48 8B C8 48 85 C0"}.add(3).abs()>()
            .template addPattern<LocalPlayerControllerPointer, CodePattern{"48 83 3D ? ? ? ? 00 0F 95"}.add(3).abs(5)>()
            .template addPattern<ManageGlowSceneObjectPointer, CodePattern{"E8 ? ? ? ? 48 8B 4F ? 0F 28 7C"}.add(1).abs()>()
            .template addPattern<SetSceneObjectAttributeFloat4, CodePattern{"E8 ? ? ? ? FF C6 48 83 C3 ? 49 3B"}.add(1).abs()>()
            .template addPattern<PointerToClientMode, CodePattern{"57 48 83 EC ? 33 DB 48 8D 3D ? ? ? ? 48 8D"}.add(10).abs()>();
    }
};

```

`Source/MemoryPatterns/Windows/ConVarPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/ConVarPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct ConVarPatterns {
    [[nodiscard]] static consteval auto addTier0Patterns(auto tier0Patterns) noexcept
    {
        return tier0Patterns
            .template addPattern<OffsetToConVarValueType, CodePattern{"E4 74 ? 41 0F B7 ? ?"}.add(7).read()>()
            .template addPattern<OffsetToConVarValue, CodePattern{"AF ? 48 8B CE 8D ? ?"}.add(7).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/CvarPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/CvarPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct CvarPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<CvarPointer, CodePattern{"48 83 EC ? ? 8B ? ? ? ? ? 48 8D 54 ? ? 4C"}.add(7).abs()>();
    }

    [[nodiscard]] static consteval auto addTier0Patterns(auto tier0Patterns) noexcept
    {
        return tier0Patterns
            .template addPattern<OffsetToConVarList, CodePattern{"48 8B ? ? 0F B7 ? 48 03 ? ? 8B ? ? ? 8B 46"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/EntityPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/EntityPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct EntityPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToGameSceneNode, CodePattern{"89 B4 24 ? ? ? ? 48 8B 98 ? ? ? ?"}.add(10).read()>()
            .template addPattern<OffsetToHealth, CodePattern{"D9 ? ? C7 81 ? ? ? ? 00 00 00 00 48 8D 15"}.add(5).read()>()
            .template addPattern<OffsetToLifeState, CodePattern{"0F B6 81 ? ? ? ? 3B C2"}.add(3).read()>()
            .template addPattern<OffsetToTeamNumber, CodePattern{"44 0F B6 89 ? ? ? ? 41 3B"}.add(4).read()>()
            .template addPattern<OffsetToVData, CodePattern{"89 ? ? ? ? 48 85 C9 74 ? 48 8B 49 ? 48 8D"}.add(1).read()>()
            .template addPattern<OffsetToRenderComponent, CodePattern{"8B ? ? ? ? ? 48 85 C0 74 ? 39 ? ? 7E"}.add(2).read()>()
            .template addPattern<OffsetToOwnerEntity, CodePattern{"8B 81 ? ? ? ? 4C 8B DA"}.add(2).read()>()
            .template addPattern<GetAbsOriginFunction, CodePattern{"F8 ? 75 ? E8 ? ? ? ? F3"}.add(5).abs()>();
    }
};

```

`Source/MemoryPatterns/Windows/EntitySystemPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/EntitySystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct EntitySystemPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<EntitySystemPointer, CodePattern{"48 89 ? ? ? ? ? 4C 63 ? ? ? ? ? 44 3B ? ? ? ? ? 0F"}.add(3).abs()>()
            .template addPattern<EntityListOffset, CodePattern{"48 8D ? ? E8 ? ? ? ? 8D 85"}.add(3).read()>()
            .template addPattern<OffsetToEntityClasses, CodePattern{"8B 86 ? ? ? ? ? 8B ? ? ? FF 15"}.add(2).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/FileSystemPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/FileSystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct FileSystemPatterns {
    [[nodiscard]] static consteval auto addSoundSystemPatterns(auto soundSystemPatterns) noexcept
    {
        return soundSystemPatterns
            .template addPattern<FileSystemPointer, CodePattern{"83 3D ? ? ? ? 00 75 ? 48 8D"}.add(2).abs(5)>();
    }

    [[nodiscard]] static consteval auto addFileSystemPatterns(auto fileSystemPatterns) noexcept
    {
        return fileSystemPatterns
            .template addPattern<FileNamesOffset, CodePattern{"? ? ? ? FF 15 ? ? ? ? 8B ? ? ? ? ? 83 E8"}.read()>();
    }
};

```

`Source/MemoryPatterns/Windows/GameRulesPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GameRulesPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GameRulesPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<GameRulesPointer, CodePattern{"F6 ? ? 0F 85 ? ? ? ? ? 8B ? ? ? ? ? ? 85 ? 0F"}.add(12).abs()>()
            .template addPattern<RoundStartTimeOffset, CodePattern{"41 ? 48 8B C2 F3 0F 11"}.add(1).read()>()
            .template addPattern<OffsetToRoundRestartTime, CodePattern{"0F 84 ? ? ? ? F3 0F 10 43 ? 48 8D 55 ? F3"}.add(10).read()>()
            .template addPattern<OffsetToRoundLength, CodePattern{"43 ? 0F 5B C0 48"}.add(1).read()>()
            .template addPattern<OffsetToRoundWinStatus, CodePattern{"8D 35 ? ? ? ? 8B ? ? ? ? ? EB"}.add(8).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/GameSceneNodePatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GameSceneNodePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GameSceneNodePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToAbsOrigin, CodePattern{"F3 0F 11 97 ? ? ? ? 0F 28 C2"}.add(4).read()>()
            .template addPattern<OffsetToGameSceneNodeOwner, CodePattern{"44 39 ? ? ? ? ? 75 ? 48 8B ? ? EB 03"}.add(12).read()>()
            .template addPattern<OffsetToChildGameSceneNode, CodePattern{"75 04 85 F6 74 ? ? 8B ? ? 48"}.add(9).read()>()
            .template addPattern<OffsetToNextSiblingGameSceneNode, CodePattern{"09 48 8B ? 48 8B ? FF 50 ? 48 8B ? ? 48 85 ? 75"}.add(13).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/GlobalVarsPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GlobalVarsPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GlobalVarsPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToFrametime, CodePattern{"0F 10 ? ? 39 ? ? ? ? ? 75 ? 48"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/GlowPropertyPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GlowPropertyPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GlowPropertyPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToIsGlowing, CodePattern{"43 ? 00 48 85 C9 74 ? E8 ? ? ? ? 48 8B"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/GlowSceneObjectPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/GlowSceneObjectPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct GlowSceneObjectPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToGlowSceneObjectEntity, CodePattern{"48 89 B0 ? ? ? ? 48 8B ? ? 48 85"}.add(3).read()>()
            .template addPattern<OffsetToGlowSceneObjectAttachedSceneObject, CodePattern{"48 89 ? 48 89 ? ? ? ? ? 48 8B ? 48 8B ? ? ? ? ? 48"}.add(6).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/HostageServicesPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/HostageServicesPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct HostageServicesPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToCarriedHostage, CodePattern{"C1 44 89 47 ? 48 8B ? ? ? ? ? 41"}.add(4).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/MemAllocPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/MemAllocPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct MemAllocPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetAllocVirtualMethod, CodePattern{"D6 48 8B 08 48 8B 01 FF 50 ? 48 89 43"}.add(9).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PanelPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<PanelConstructorPointer, CodePattern{"48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC 30 48 8B F1 48 8B FA B9 ? ? ? ? E8 ? ? ? ? 48 8B D8 48 85 C0 74 ? 48"}>();
    }
};

```

`Source/MemoryPatterns/Windows/PanelStylePatternsWindows.h`:

```h
#pragma once

#include <cstddef>

#include <CS2/Panorama/CPanelStyle.h>
#include <MemoryPatterns/PatternTypes/PanelStylePatternTypes.h>
#include <MemorySearch/BytePatternLiteral.h>
#include <MemorySearch/CodePattern.h>

struct PanelStylePatterns2 {
    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<SetPanelStylePropertyFunctionPointer, CodePattern{"E8 ? ? ? ? 48 8D 05 ? ? ? ? 48 89 45 ? EB"}.add(1).abs()>();
    }
};

template <typename PatternFinders>
struct PanelStylePatterns {
    const PatternFinders& patternFinders;

    [[nodiscard]] cs2::CPanelStyle::StylePropertySymbols* stylePropertiesSymbols() const noexcept
    {
        if (const auto pointerToStylePropertySymbolsMemory{patternFinders.panoramaPatternFinder("48 8D 0D ? ? ? ? 48 8D 45"_pat).add(3).abs().template as<std::byte*>()})
            return reinterpret_cast<cs2::CPanelStyle::StylePropertySymbols*>(pointerToStylePropertySymbolsMemory);
        return nullptr;
    }
};

```

`Source/MemoryPatterns/Windows/PanoramaDropDownPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanoramaDropDownPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaDropDownPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetSelectedIndexFunctionPointer, CodePattern{"48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC ? 48 8B F1 8B DA 48 83"}>();
    }
};

```

`Source/MemoryPatterns/Windows/PanoramaImagePanelPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanoramaImagePanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaImagePanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetImageFunctionPointer, CodePattern{"CF E8 ? ? ? ? 41 0F B6 C5"}.add(2).abs()>()
            .template addPattern<ImagePanelConstructorPointer, CodePattern{"? ? ? ? 48 8B C8 EB 03 49 8B ? 48 89"}.abs()>()
            .template addPattern<ImagePanelClassSize, CodePattern{"90 ? ? ? ? B9 ? ? ? ? E8 ? ? ? ? 48 85 C0 74 ? 48 8B"}.add(6).read()>()
            .template addPattern<ImagePropertiesOffset, CodePattern{"EB 08 41 C7 47 ? 00 00 80 BF ? 8D ? ?"}.add(13).read()>()
            .template addPattern<OffsetToImagePath, CodePattern{"B6 DA 48 81 C1 ? ? ? ?"}.add(5).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PanoramaLabelPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PanoramaLabelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaLabelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<LabelPanelConstructorPointer, CodePattern{"C8 E8 ? ? ? ? 48 8B F0 48 8B 57"}.add(2).abs()>()
            .template addPattern<SetLabelTextFunctionPointer, CodePattern{"41 B1 01 41 B8 ? ? ? ? E9 ? ? ? ?"}.add(10).abs()>()
            .template addPattern<LabelPanelObjectSize, CodePattern{"66 0F 6E F6 B9 ? ? ? ?"}.add(5).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PanoramaUiEnginePatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/UiPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaUiEnginePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<UiEnginePointer, CodePattern{"48 89 78 ? 48 89 0D ? ? ? ?"}.add(7).abs()>();
    }

    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<GetPanelPointerFunctionPointer, CodePattern{"4C 63 0A 4C 8B DA"}>()
            .template addPattern<RunScriptFunctionPointer, CodePattern{"48 89 5C 24 ? 4C 89 4C 24 ? 48 89 54 24 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D"}>()
            .template addPattern<MakeSymbolFunctionPointer, CodePattern{"40 55 56 48 83 EC ? 48 63"}>()
            .template addPattern<OnDeletePanelFunctionPointer, CodePattern{"48 85 D2 0F 84 ? ? ? ? 48 89 5C 24 ? 57 48 83 EC ? 48"}>()
            .template addPattern<RegisterEventHandlerFunctionPointer, CodePattern{"48 89 5C 24 ? 66 89 54 24 ? 55 56 57 41 56 41 57 48 83 EC ? 48 8D 05 ? ? ? ? 48 C7 44 24 28 ? ? ? ? 48 89 44 24 ? 4D"}>();
    }
};

```

`Source/MemoryPatterns/Windows/PanoramaUiPanelPatternsWindows.h`:

```h
#pragma once

#include <cstdint>

#include <MemoryPatterns/PatternTypes/UiPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PanoramaUiPanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetParentFunctionOffset, CodePattern{"59 ? 48 8B 03 48 8B B8 ? ? ? ? 48 85 D2"}.add(8).read()>()
            .template addPattern<SetVisibleFunctionOffset, CodePattern{"01 FF 90 ? ? ? ? 45 33 C0 33 D2 ? 8B ? E8"}.add(3).read()>()
            .template addPattern<GetAttributeStringFunctionOffset, CodePattern{"12 48 8B 01 FF 90 ? ? ? ? 48 8B ? 48 85 C0 74 ? 80 38 00 74 ? 48 8D 4C"}.add(6).read()>()
            .template addPattern<SetAttributeStringFunctionOffset, CodePattern{"FF 90 ? ? ? ? 48 83 C6 ? 48 3B ? 75 ? 4C"}.add(2).read()>();
    }

    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<ChildPanelsVectorOffset, CodePattern{"83 ? ? 00 0F 84 ? ? ? ? 48 8B ? ? 0C ? 88"}.add(2).read()>()
            .template addPattern<PanelClassesVectorOffset, CodePattern{"48 63 88 ? ? ? ? 45 33 C0"}.add(3).read()>()
            .template addPattern<PanelStyleOffset, CodePattern{"D2 E8 ? ? ? ? 48 8D 43 ? 48"}.add(9).read()>()
            .template addPattern<ParentWindowOffset, CodePattern{"48 89 ? ? 48 85 ? 75 ? 48 85"}.add(3).read()>()
            .template addPattern<OffsetToPanelId, CodePattern{"48 39 77 ? 48 8D 4F"}.add(3).read()>()
            .template addPattern<OffsetToPanelFlags, CodePattern{"8B 4E ? 48 85 C9 74 ? F6 81 ? ? ? ? ? 75 ? ? 8B"}.add(10).read()>()
            .template addPattern<OffsetToPanelHandle, CodePattern{"49 8B 80 ? ? ? ? 48 89"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PlantedC4PatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlantedC4PatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlantedC4Patterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<PlantedC4sPointer, CodePattern{"0F ? ? ? ? ? 39 ? ? ? ? ? 7E ? 48 8B 0D"}.add(8).abs()>()
            .template addPattern<BombSiteOffset, CodePattern{"83 B9 ? ? ? ? 01 0F 94 C0 C3"}.add(2).read()>()
            .template addPattern<BombTickingOffset, CodePattern{"74 ? 44 38 AE ? ? ? ? 74 ? 49"}.add(5).read()>()
            .template addPattern<BombBlowTimeOffset, CodePattern{"BB ? ? ? ? 48 8B CF 48 8D 55"}.add(1).read()>()
            .template addPattern<BombDefuserOffset, CodePattern{"EC ? ? ? ? 48 8B ? E8 ? ? ? ? 8B ? ? ? ? ? 45 33 ? 4C"}.add(15).read()>()
            .template addPattern<BombDefuseEndTimeOffset, CodePattern{"8D 3D ? ? ? ? 48 8D 8B ? ? ? ?"}.add(9).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PlayerControllerPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlayerControllerPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlayerControllerPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToBasePawnHandle, CodePattern{"0F B6 81 ? ? ? ? 84 C0 75 ? 8B ? ? ? ? ?"}.add(13).read()>()
            .template addPattern<OffsetToPlayerColor, CodePattern{"E8 ? ? ? ? 84 C0 74 ? 41 8B ? ? ? ? ? EB"}.add(12).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PlayerPawnPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlayerPawnPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlayerPawnPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToPlayerPawnImmunity, CodePattern{"0F B6 83 ? ? ? ? 84 C0 75 ? ? 80"}.add(3).read()>()
            .template addPattern<OffsetToWeaponServices, CodePattern{"48 8B 88 ? ? ? ? 48 8D 15 ? ? ? ? E8 ? ? ? ? 48"}.add(3).read()>()
            .template addPattern<OffsetToPlayerController, CodePattern{"8B 8B ? ? ? ? 44 88 7C"}.add(2).read()>()
            .template addPattern<OffsetToIsDefusing, CodePattern{"00 75 ? 80 BF ? ? ? ? 00 75 ? 48"}.add(5).read()>()
            .template addPattern<OffsetToIsPickingUpHostage, CodePattern{"86 ? ? ? ? ? ? ? ? 80 BF ? ? ? ?"}.add(11).read()>()
            .template addPattern<OffsetToHostageServices, CodePattern{"0F 87 ? ? ? ? 48 8B 87 ? ? ? ?"}.add(9).read()>()
            .template addPattern<OffsetToFlashBangEndTime, CodePattern{"10 87 ? ? ? ? 0F 2F ? ? 0F 86"}.add(2).read()>()
            .template addPattern<OffsetToPlayerPawnSceneObjectUpdaterHandle, CodePattern{"E8 ? ? ? ? 48 8B 8B ? ? ? ? 33 FF 48 85 C9 74 18 48 8B 93 ? ? ? ?"}.add(22).read()>()
            .template addPattern<OffsetToIsScoped, CodePattern{"88 B0 ? ? ? ? 0F 57 DB"}.add(2).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PlayerResourcePatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PlayerResourcePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PlayerResourcePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<PointerToPlayerResource, CodePattern{"80 8F ? ? ? ? ? 48 83 3D ? ? ? ?"}.add(10).abs(5)>()
            .template addPattern<OffsetToBombsiteACenter, CodePattern{"03 48 8D 8B ? ? ? ? 0F"}.add(4).read()>()
            .template addPattern<OffsetToBombsiteBCenter, CodePattern{"11 83 ? ? ? ? E8 ? ? ? ? 48 8D 8B ? ? ? ?"}.add(14).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/PortraitWorldPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/PortraitWorldPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct PortraitWorldPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToPortraitWorldEntities, CodePattern{"48 63 ? ? 45 33 ED 4D"}.add(3).read()>()
            .template addPattern<OffsetToPortraitWorldMapEntities, CodePattern{"4C 63 ? ? ? ? ? 42 8B 1C"}.add(3).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/RenderComponentPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/RenderComponentPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct RenderComponentPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToSceneObjectUpdaters, CodePattern{"? 7C 03 33 C0 C3 48 8B 41"}.read()>();
    }
};

```

`Source/MemoryPatterns/Windows/SceneObjectPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneObjectPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SceneObjectPatterns {
    [[nodiscard]] static consteval auto addSceneSystemPatterns(auto sceneSystemPatterns) noexcept
    {
        return sceneSystemPatterns
            .template addPattern<OffsetToSceneObjectFlags, CodePattern{"CC F6 83 ? ? ? ?"}.add(3).read()>()
            .template addPattern<OffsetToSceneObjectClass, CodePattern{"48 83 EC ? 0F B6 82 ? ? ? ?"}.add(7).read()>()
            .template addPattern<OffsetToSceneObjectAttributes, CodePattern{"BA ? ? ? ? 00 48 8B EA 0F"}.add(1).read()>()
            .template addPattern<OffsetToSceneObjectRenderableFlags, CodePattern{"75 ? 48 8B 83 ? ? ? ? 48 C1"}.add(5).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/SceneObjectUpdaterPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneObjectUpdaterPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SceneObjectUpdaterPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToSceneObject, CodePattern{"C3 48 8B 42 ? C3"}.add(4).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/SceneSystemPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SceneSystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SceneSystemPatterns {
    [[nodiscard]] static consteval auto addSceneSystemPatterns(auto sceneSystemPatterns) noexcept
    {
        return sceneSystemPatterns
            .template addPattern<SceneSystemPointer, CodePattern{"72 ? ? 8B ? ? ? ? ? 48 8D 0D ? ? ? ? 48"}.add(12).abs()>()
            .template addPattern<DeleteSceneObjectFunctionPointer, CodePattern{"48 85 D2 0F 84 ? ? ? ? 48 89 54 24 ? 53"}>()
            .template addPattern<AllocateAttributeListFunctionPointer, CodePattern{"40 55 48 83 EC ? 48 83 BA"}>();
    }
};

```

`Source/MemoryPatterns/Windows/SdlPatternWindows.h`:

```h
#pragma once

#include <MemorySearch/BytePatternLiteral.h>
#include <SDL/SdlFunctions.h>

template <typename PatternFinders>
struct SdlPatterns {
    const PatternFinders& patternFinders;

    [[nodiscard]] sdl3::SDL_PeepEvents** peepEventsPointer(sdl3::SDL_PeepEvents* peepEvents) const noexcept
    {
        return patternFinders.sdlPatternFinder.matchPatternAtAddress((void*)peepEvents, "48 FF 25 ? ? ? ?"_pat).add(3).abs().template as<sdl3::SDL_PeepEvents**>();
    }
};

```

`Source/MemoryPatterns/Windows/SliderPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SliderPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SliderPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SliderSetValueFunction, CodePattern{"CF E8 ? ? ? ? 0F 28 74 24 ? 48 8B 74"}.add(2).abs()>();
    }
};

```

`Source/MemoryPatterns/Windows/SmokeGrenadeProjectilePatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SmokeGrenadeProjectilePatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SmokeGrenadeProjectilePatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToDidSmokeEffect, CodePattern{"85 D2 75 ? 38 91 ? ? ? ?"}.add(6).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/SoundSystemPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/SoundSystemPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct SoundSystemPatterns {
    [[nodiscard]] static consteval auto addSoundSystemPatterns(auto soundSystemPatterns) noexcept
    {
        return soundSystemPatterns
            .template addPattern<SoundChannelsPointer, CodePattern{"8B 3D ? ? ? ? 48 89 58"}.add(2).abs()>();
    }
};

```

`Source/MemoryPatterns/Windows/TextEntryPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/TextEntryPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct TextEntryPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<TextEntrySetTextFunction, CodePattern{"8B 89 ? ? ? ? E8 ? ? ? ? B0"}.add(7).abs()>();
    }
};

```

`Source/MemoryPatterns/Windows/TopLevelWindowPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/TopLevelWindowPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct TopLevelWindowPatterns {
    [[nodiscard]] static consteval auto addPanoramaPatterns(auto panoramaPatterns) noexcept
    {
        return panoramaPatterns
            .template addPattern<UiScaleFactorOffset, CodePattern{"F3 0F 11 49 ? 48 8B F9"}.add(4).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/Ui3dPanelPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/Ui3dPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct Ui3dPanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToPortraitWorld, CodePattern{"56 ? 8B 92"}.add(1).read()>()
            .template addPattern<OffsetTo3dPanelFov, CodePattern{"0F 2E 83 ? ? ? ? C6"}.add(3).read()>()
            .template addPattern<OffsetTo3dPanelFovWeight, CodePattern{"0E F3 0F 11 83 ? ? ? ? 89 ? ? ? ? ?"}.add(11).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/UiItem3dPanelPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/UiItem3dPanelPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct UiItem3dPanelPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<SetItemItemIdFunction, CodePattern{"CF 48 8B D0 48 8B 5C 24 ? 48 83 C4 ? 5F E9 ? ? ? ?"}.add(15).abs()>()
            .template addPattern<OffsetToItem3dPanelUnknownField, CodePattern{"7E ? 75 28"}.add(1).read()>()
            .template addPattern<OffsetToStartWeaponLookAt, CodePattern{"81 ? ? ? ? 01 00 C3"}.add(1).read()>()
            .template addPattern<OffsetToItem3dPanelProperties, CodePattern{"8E ? ? ? ? 48 8D 45 ? C6"}.add(1).read()>();
    }
};

```

`Source/MemoryPatterns/Windows/WeaponPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/WeaponPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct WeaponPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToClipAmmo, CodePattern{"74 ? 83 ? ? ? ? ? 00 7C ? 8B"}.add(4).read()>()
            .template addPattern<OffsetToWeaponSceneObjectUpdaterHandle, CodePattern{"54 24 ? 48 8B ? E8 ? ? ? ? 48 89 ? ? ? ? ? B2"}.add(14).read()>()
            .template addPattern<PointerToGetInaccuracyFunction, CodePattern{"48 89 5C 24 ? 55 56 57 48 81 EC ? ? ? ? 44"}>()
            .template addPattern<PointerToGetSpreadFunction, CodePattern{"48 83 EC ? 48 63 91"}>();
    }
};

```

`Source/MemoryPatterns/Windows/WeaponServicesPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/WeaponServicesPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct WeaponServicesPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToActiveWeapon, CodePattern{"C0 0F 85 ? ? ? ? 8B 4F ? 83"}.add(9).read()>()
            .template addPattern<OffsetToWeapons, CodePattern{"? 4C 8B 49 ? C1"}.read()>();
    }
};

```

`Source/MemoryPatterns/Windows/WeaponVDataPatternsWindows.h`:

```h
#pragma once

#include <MemoryPatterns/PatternTypes/WeaponVDataPatternTypes.h>
#include <MemorySearch/CodePattern.h>

struct WeaponVDataPatterns {
    [[nodiscard]] static consteval auto addClientPatterns(auto clientPatterns) noexcept
    {
        return clientPatterns
            .template addPattern<OffsetToWeaponName, CodePattern{"? ? ? ? 48 85 C9 48 0F 45 D9 BA"}.read()>();
    }
};

```

`Source/MemoryPatterns/Windows/WindowsPatterns.h`:

```h
#pragma once

#include "BaseModelEntityPatternsWindows.h"
#include "C4PatternsWindows.h"
#include "ClientPatternsWindows.h"
#include "ConVarPatternsWindows.h"
#include "CvarPatternsWindows.h"
#include "EntityPatternsWindows.h"
#include "EntitySystemPatternsWindows.h"
#include "FileSystemPatternsWindows.h"
#include "HostageServicesPatternsWindows.h"
#include "GameRulesPatternsWindows.h"
#include "GameSceneNodePatternsWindows.h"
#include "GlobalVarsPatternsWindows.h"
#include "GlowPropertyPatternsWindows.h"
#include "GlowSceneObjectPatternsWindows.h"
#include "MemAllocPatternsWindows.h"
#include "PanelPatternsWindows.h"
#include "PanelStylePatternsWindows.h"
#include "PanoramaDropDownPatternsWindows.h"
#include "PanoramaImagePanelPatternsWindows.h"
#include "PanoramaLabelPatternsWindows.h"
#include "PanoramaUiEnginePatternsWindows.h"
#include "PanoramaUiPanelPatternsWindows.h"
#include "PlantedC4PatternsWindows.h"
#include "PlayerControllerPatternsWindows.h"
#include "PlayerPawnPatternsWindows.h"
#include "PlayerResourcePatternsWindows.h"
#include "PortraitWorldPatternsWindows.h"
#include "RenderComponentPatternsWindows.h"
#include "SceneObjectPatternsWindows.h"
#include "SceneObjectUpdaterPatternsWindows.h"
#include "SceneSystemPatternsWindows.h"
#include "SdlPatternWindows.h"
#include "SliderPatternsWindows.h"
#include "SmokeGrenadeProjectilePatternsWindows.h"
#include "SoundSystemPatternsWindows.h"
#include "TextEntryPatternsWindows.h"
#include "TopLevelWindowPatternsWindows.h"
#include "Ui3dPanelPatternsWindows.h"
#include "UiItem3dPanelPatternsWindows.h"
#include "WeaponPatternsWindows.h"
#include "WeaponServicesPatternsWindows.h"
#include "WeaponVDataPatternsWindows.h"

```

`Source/MemorySearch/BytePattern.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <optional>
#include <span>
#include <string_view>

class BytePattern {
public:
    constexpr BytePattern(std::string_view pattern, std::optional<char> wildcardChar = {}) noexcept
        : pattern{pattern}
        , wildcardChar{wildcardChar}
    {
    }

    template <typename T>
    [[nodiscard]] static BytePattern ofObject(const T& object) noexcept
    {
        return BytePattern{std::string_view{reinterpret_cast<const char*>(&object), sizeof(T)}};
    }

    template <typename T>
    static BytePattern ofObject(const T&&) = delete;

    [[nodiscard]] std::size_t indexOfFirstNonWildcardChar() const noexcept
    {
        if (wildcardChar)
            return pattern.find_first_not_of(*wildcardChar);
        return 0;
    }

    [[nodiscard]] std::size_t indexOfLastNonWildcardChar() const noexcept
    {
        if (wildcardChar)
            return pattern.find_last_not_of(*wildcardChar);
        return pattern.size() - 1;
    }

    [[nodiscard]] std::size_t length() const noexcept
    {
        return pattern.length();
    }

    [[nodiscard]] char front() const noexcept
    {
        return pattern.front();
    }

    [[nodiscard]] char back() const noexcept
    {
        return pattern.back();
    }

    [[nodiscard]] std::string_view raw() const noexcept
    {
        return pattern;
    }

    [[nodiscard]] bool matches(std::span<const std::byte> bytes) const noexcept
    {
        assert(bytes.size() == pattern.size());

        for (std::size_t i = 0; i < bytes.size(); ++i) {
            if (std::to_integer<char>(bytes[i]) != pattern[i] && pattern[i] != wildcardChar)
                return false;
        }
        return true;
    }

    [[nodiscard]] std::optional<char> getWildcardChar() const noexcept
    {
        return wildcardChar;
    }

private:
    std::string_view pattern;
    std::optional<char> wildcardChar;
};

```

`Source/MemorySearch/BytePatternConverter.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cassert>
#include <cstddef>
#include <optional>
#include <string_view>
#include <utility>

#include "PatternStringWildcard.h"
#include <Utils/HexChars.h>

enum class BytePatternConverterError {
    NoError,
    WildcardUsedAsByte,
    UnexpectedChar
};

template <std::size_t N>
    requires (N > 0)
struct BytePatternConverter {
    explicit constexpr BytePatternConverter(const char(&patternString)[N])
    {
        std::ranges::copy(patternString, buffer.begin());
    }

    using Error = BytePatternConverterError;

    [[nodiscard]] constexpr std::pair<std::string_view, Error> operator()()
    {
        while (canConvert())
            convertNextSequence();
        return conversionResult();
    }

private:
    [[nodiscard]] constexpr bool canConvert() noexcept
    {
        return hasCharsToConvert() && noErrorOccured();
    }

    [[nodiscard]] constexpr bool noErrorOccured() const noexcept
    {
        return error == Error::NoError;
    }

    [[nodiscard]] constexpr std::pair<std::string_view, Error> conversionResult()
    {
        return { converted(), error };
    }

    constexpr void convertNextSequence()
    {
        spaceExpected ? convertSpace() : convertByteOrWildcard();
        toggleSpaceExpected();
    }

    constexpr void toggleSpaceExpected() noexcept
    {
        spaceExpected = !spaceExpected;
    }

    constexpr void convertByteOrWildcard()
    {
        isNextCharWildcard() ? convertWildcard() : convertByte();
    }

    [[nodiscard]] constexpr std::string_view converted() const
    {
        return std::string_view{ buffer.data(), writePosition };
    }

    [[nodiscard]] static constexpr bool isWildcardChar(char c) noexcept
    {
        return c == kPatternStringWildcard;
    }

    [[nodiscard]] constexpr bool isNextCharWildcard() const
    {
        return isWildcardChar(peekNextChar());
    }

    [[nodiscard]] constexpr bool isNextCharSpace() const
    {
        return isWhitespace(peekNextChar());
    }

    [[nodiscard]] static constexpr bool isWhitespace(char c) noexcept
    {
        return c == ' ' || c == '\0';
    }

    constexpr void setUnexpectedCharError() noexcept
    {
        error = Error::UnexpectedChar;
    }

    constexpr void setWildcardUsedAsByteError() noexcept
    {
        error = Error::WildcardUsedAsByte;
    }

    constexpr void convertSpace() noexcept
    {
        isNextCharSpace() ? advanceReadPosition() : setUnexpectedCharError();
    }

    [[nodiscard]] constexpr std::optional<char> readAndConvertByte() noexcept
    {
        const auto read = readNextByte();
        return hexCharsToByte({ read[0], read[1] });
    }

    constexpr void convertByte() noexcept
    {
        canConvertByte() ? performByteConversion() : setUnexpectedCharError();
    }

    constexpr void performByteConversion()
    {
        const auto convertedByte = readAndConvertByte(); 
        convertedByte.has_value() ? handleConvertedByte(*convertedByte) : setUnexpectedCharError();
    }

    constexpr void handleConvertedByte(char convertedByte)
    {
        !isWildcardChar(convertedByte) ? putChar(convertedByte) : setWildcardUsedAsByteError();
    }

    constexpr void convertWildcard()
    {
        assert(isNextCharWildcard());

        advanceReadPosition();
        putChar(kPatternStringWildcard);
    }

    [[nodiscard]] constexpr bool canConvertByte() const noexcept
    {
        return charsToConvert() >= hexCharsInByte;
    }

    [[nodiscard]] constexpr std::size_t charsToConvert() const noexcept
    {
        return buffer.size() - readPosition;
    }

    [[nodiscard]] constexpr bool hasCharsToConvert() const noexcept
    {
        return charsToConvert() > 0;
    }

    [[nodiscard]] constexpr std::string_view readNextByte() noexcept
    {
        const std::string_view nextByte{ buffer.data() + readPosition, hexCharsInByte };
        readPosition += hexCharsInByte;
        return nextByte;
    }

    [[nodiscard]] constexpr char peekNextChar() const noexcept
    {
        assert(hasCharsToConvert());
        return buffer[readPosition];
    }

    constexpr void advanceReadPosition() noexcept
    {
        ++readPosition;
    }
    
    constexpr void putChar(char convertedChar) noexcept
    {
        buffer[writePosition] = convertedChar;
        ++writePosition;
    }

    std::array<char, N> buffer;
    std::size_t readPosition = 0;
    std::size_t writePosition = 0;
    bool spaceExpected = false;
    Error error = Error::NoError;
};

```

`Source/MemorySearch/BytePatternLiteral.h`:

```h
#pragma once

#include <array>

#include "BytePatternStorage.h"
#include "BytePatternView.h"

template <BytePatternStorage Storage>
auto operator ""_pat()
{
    static constexpr std::array<char, Storage.size> pattern{[]{
        std::array<char, Storage.size> truncatedPattern;
        std::copy_n(Storage.pattern.begin(), Storage.size, truncatedPattern.begin());
        return truncatedPattern;
    }()};

    return BytePatternView<Storage.size>{pattern};
}

```

`Source/MemorySearch/BytePatternStorage.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cstddef>

#include "BytePatternConverter.h"

template <std::size_t Capacity>
struct BytePatternStorage {
    explicit(false) consteval BytePatternStorage(const char (&patternString)[Capacity])
    {
        BytePatternConverter converter{patternString};
        const auto [convertedPattern, error] = converter();
        if (error == BytePatternConverterError::NoError) {
            std::ranges::copy(convertedPattern, pattern.begin());
            size = convertedPattern.size();
        } else {
            errorOccured();
        }
    }

    std::array<char, Capacity> pattern{};
    std::size_t size{0};

private:
    void errorOccured();
};

```

`Source/MemorySearch/BytePatternView.h`:

```h
#pragma once

#include <cstddef>
#include <span>

template <std::size_t Length>
using BytePatternView = std::span<const char, Length>;

```

`Source/MemorySearch/CodePattern.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include "BytePatternStorage.h"
#include "CodePatternOperation.h"

template <std::size_t N>
struct CodePattern {
    consteval CodePattern(const char (&patternString)[N]) noexcept
        : storage{patternString}
    {
    }

    [[nodiscard]] consteval auto add(std::uint8_t offsetToAdd) noexcept
    {
        offset = offsetToAdd;
        return *this;
    }

    [[nodiscard]] consteval auto abs(std::uint8_t offsetToNextInstruction = 4) noexcept
    {
        switch (offsetToNextInstruction) {
        case 4: operation = CodePatternOperation::Abs4; break;
        case 5: operation = CodePatternOperation::Abs5; break;
        default: error("unsupported offset");
        }
        return *this;
    }

    [[nodiscard]] consteval auto read() noexcept
    {
        operation = CodePatternOperation::Read;
        return *this;
    }

    BytePatternStorage<N> storage;
    std::uint8_t offset{};
    CodePatternOperation operation{CodePatternOperation::None};

private:
    void error(const char*);
};

```

`Source/MemorySearch/CodePatternOperation.h`:

```h
#pragma once

#include <cstdint>

enum class CodePatternOperation : std::uint8_t {
    None,
    Abs4,
    Abs5,
    Read
};

```

`Source/MemorySearch/HybridPatternFinder.h`:

```h
#pragma once

#include <cstddef>
#include <span>

#include <Platform/Macros/FunctionAttributes.h>

#include "BytePattern.h"
#include "PatternFinderScalar.h"
#include "PatternFinderSIMD.h"

class HybridPatternFinder {
public:
    HybridPatternFinder(std::span<const std::byte> bytes, BytePattern pattern) noexcept
        : bytes{ bytes }, pattern{ pattern }
    {
    }

    [[nodiscard]] [[NOINLINE]] const std::byte* findNextOccurrence() noexcept
    {
        PatternFinderSIMD simdFinder{bytes, pattern};
        if (const auto foundSIMD = simdFinder()) {
            updateRemainingBytes(foundSIMD);
            return foundSIMD;
        }
        
        if (const auto foundScalar{PatternFinderScalar{simdFinder.getNotCheckedBytes(), pattern}()}) {
            updateRemainingBytes(foundScalar);
            return foundScalar;
        }

        return nullptr;
    }

private:
    void updateRemainingBytes(const std::byte* foundPosition) noexcept
    {
        bytes = {foundPosition + 1, bytes.data() + bytes.size()};
    }

    std::span<const std::byte> bytes;
    BytePattern pattern;
};

```

`Source/MemorySearch/PatternFinder.h`:

```h
#pragma once

#include <array>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <span>
#include <type_traits>

#include <MemorySearch/PatternSearchResult.h>
#include <Platform/Macros/FunctionAttributes.h>
#include <Utils/MemorySection.h>
#include <Utils/GenericPointer.h>
#include <Utils/SpanSlice.h>

#include "BytePattern.h"
#include "BytePatternView.h"
#include "CodePatternOperation.h"
#include "HybridPatternFinder.h"
#include "PatternPoolView.h"
#include "PatternSearchResults.h"
#include "PatternSearchResultsView.h"
#include "PatternStringWildcard.h"

template <typename NotFoundHandler>
struct PatternFinder {
public:
    explicit PatternFinder(std::span<const std::byte> bytes) noexcept
        : bytes{bytes}
    {
    }

    template <std::size_t PatternLength>
    [[nodiscard]] PatternSearchResult operator()(BytePatternView<PatternLength> patternView) const noexcept
    {
        return operator()(patternView.data(), PatternLength);
    }

    [[nodiscard]] auto findPatterns(const auto& patterns) const noexcept
    {
        PatternSearchResults<std::remove_reference_t<decltype(patterns)>> results;
        findPatterns(patterns.getView(), results.getView());
        return results;
    }

    [[NOINLINE]] void findPatterns(PatternPoolView patterns, PatternSearchResultsView results) const noexcept
    {
        patterns.forEach([patternIndex = std::size_t{0}, results, this](BytePattern pattern, std::uint8_t offset, CodePatternOperation operation) mutable {
            auto result = operator()(pattern);
            result.add(offset);

            std::array<std::byte, 8> resultToStore{};
            if (operation == CodePatternOperation::None) {
                resultToStore = result.get();
            } else if (operation == CodePatternOperation::Abs4 || operation == CodePatternOperation::Abs5) {
                resultToStore = result.abs2(operation == CodePatternOperation::Abs4 ? 4 : 5);
            } else if (operation == CodePatternOperation::Read) {
                resultToStore = result.read();
            }
            results.store(patternIndex, resultToStore);
            ++patternIndex;
        });
    }

    [[nodiscard]] [[NOINLINE]] PatternSearchResult operator()(BytePattern pattern) const noexcept
    {
        auto patternFinder = HybridPatternFinder{bytes, pattern};
        const auto found = patternFinder.findNextOccurrence();
        assert(patternFinder.findNextOccurrence() == nullptr && "Pattern should be unique!");
        if (!found)
            NotFoundHandler::onPatternNotFound(pattern);
        return makeResult(found, pattern.length());
    }

    template <std::size_t PatternLength>
    [[nodiscard]] PatternSearchResult matchPatternAtAddress(GenericPointer address, BytePatternView<PatternLength> patternView) const noexcept
    {
        return matchPatternAtAddress(address, BytePattern{{patternView.data(), PatternLength}, kPatternStringWildcard});
    }

    [[nodiscard]] PatternSearchResult matchPatternAtAddress(GenericPointer address, BytePattern pattern) const noexcept
    {
        if (matchesPatternAtAddress(address, pattern))
            return makeResult(address.as<const std::byte*>(), pattern.length());
        return makeResult(nullptr, pattern.length());
    }

private:
    [[nodiscard]] [[NOINLINE]] PatternSearchResult operator()(const char* pattern, std::size_t size) const noexcept
    {
        return operator()(BytePattern{{pattern, size}, kPatternStringWildcard});
    }

    [[nodiscard]] bool matchesPatternAtAddress(GenericPointer address, BytePattern pattern) const noexcept
    {
        if (MemorySection{bytes}.contains(address.as<std::uintptr_t>(), pattern.length()))
            return pattern.matches(std::span{address.as<const std::byte*>(), pattern.length()});
        return false;
    }

    [[nodiscard]] PatternSearchResult makeResult(const std::byte* address, std::size_t patternLength) const noexcept
    {
        if (address)
            return PatternSearchResult{bytes.data(), static_cast<std::size_t>(address - bytes.data()), std::span{address, patternLength}};
        return {};
    }

    std::span<const std::byte> bytes;
};

```

`Source/MemorySearch/PatternFinderSIMD.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <emmintrin.h>
#include <span>
#include <string_view>

#include "BytePattern.h"

#include <Utils/Bits.h>

class PatternFinderSIMD {
public:
    PatternFinderSIMD(std::span<const std::byte> bytes, BytePattern pattern) noexcept
        : bytes{bytes}, pattern{pattern}
    {
    }

    const std::byte* operator()() noexcept
    {
        // http://0x80.pl/articles/simd-strfind.html

        const auto indexOfFirstNonWildcardChar{pattern.indexOfFirstNonWildcardChar()};
        if (indexOfFirstNonWildcardChar >= pattern.length()) {
            if (bytes.size() >= pattern.length())
                return bytes.data();
            return nullptr;
        }

        const auto indexOfLastNonWildcardChar{pattern.indexOfLastNonWildcardChar()};

        const auto firstCharMask{_mm_set1_epi8(pattern.raw()[indexOfFirstNonWildcardChar])};
        const auto lastCharMask{_mm_set1_epi8(pattern.raw()[indexOfLastNonWildcardChar])};

        const BytePattern patternWithoutLeadingAndTrailingWildcardsWithoutFirstAndLastChar{std::string_view{pattern.raw().data() + indexOfFirstNonWildcardChar + 1, indexOfLastNonWildcardChar - indexOfFirstNonWildcardChar}, pattern.getWildcardChar()};

        for (; canDoAnotherIteration(); currentPos += sizeof(__m128i)) {
            const auto possibleFirstChars{_mm_loadu_si128(reinterpret_cast<const __m128i*>(&bytes[currentPos + indexOfFirstNonWildcardChar]))};
            const auto possibleLastChars{_mm_loadu_si128(reinterpret_cast<const __m128i*>(&bytes[currentPos + indexOfLastNonWildcardChar]))};

            const auto firstCharMatchPositions{_mm_cmpeq_epi8(firstCharMask, possibleFirstChars)};
            const auto lastCharMatchPositions{_mm_cmpeq_epi8(lastCharMask, possibleLastChars)};

            auto mask{static_cast<std::uint16_t>(_mm_movemask_epi8(_mm_and_si128(firstCharMatchPositions, lastCharMatchPositions)))};
            while (mask != 0) {
                if (const auto bitPos = bits::countrZero(mask); patternWithoutLeadingAndTrailingWildcardsWithoutFirstAndLastChar.matches(bytes.subspan(currentPos + bitPos + indexOfFirstNonWildcardChar + 1, patternWithoutLeadingAndTrailingWildcardsWithoutFirstAndLastChar.length()))) {
                    return &bytes[currentPos + bitPos];
                }

                mask = bits::clearRightmostSetBit(mask);
            }
        }
        return nullptr;
    }

    [[nodiscard]] std::span<const std::byte> getNotCheckedBytes() const noexcept
    {
        return bytes.subspan(currentPos);
    }

private:
    [[nodiscard]] std::size_t remainingBytes() const noexcept
    {
        return bytes.size() - currentPos;
    }

    [[nodiscard]] std::size_t indexOfLastPatternChar() const noexcept
    {
        return pattern.length() - 1;
    }

    [[nodiscard]] std::size_t byteSpanPerIteration() const noexcept
    {
        return indexOfLastPatternChar() + sizeof(__m128i);
    }

    [[nodiscard]] bool canDoAnotherIteration() const noexcept
    {
        return remainingBytes() >= byteSpanPerIteration();
    }

    std::size_t currentPos = 0;
    std::span<const std::byte> bytes;
    BytePattern pattern;
};

```

`Source/MemorySearch/PatternFinderScalar.h`:

```h
#pragma once

#include <cstddef>
#include <span>

#include "BytePattern.h"

class PatternFinderScalar {
public:
    PatternFinderScalar(std::span<const std::byte> bytes, BytePattern pattern)
        : bytes{ bytes }, pattern{ pattern }
    {
    }

    const std::byte* operator()() noexcept
    {
        while (remainingBytes() >= pattern.length()) {
            if (pattern.matches(bytes.subspan(currentPos, pattern.length())))
                return &bytes[currentPos];
            ++currentPos;
        }
        return nullptr;
    }

private:
    [[nodiscard]] std::size_t remainingBytes() const noexcept
    {
        return bytes.size() - currentPos;
    }

    std::size_t currentPos = 0;
    std::span<const std::byte> bytes;
    BytePattern pattern;
};


```

`Source/MemorySearch/PatternNotFoundLogger.h`:

```h
#pragma once

#include <cassert>

#include <MemorySearch/BytePattern.h>
#include <Utils/StringBuilder.h>
#include <Platform/SimpleMessageBox.h>

struct PatternNotFoundLogger {
    static void onPatternNotFound(BytePattern pattern) noexcept
    {
        StringBuilderStorage<500> storage;
        auto builder = storage.builder();

        assert(false && "Pattern needs to be updated!");

        builder.put("Failed to find pattern ");

        bool printedFirst = false;
        const auto wildcardChar{pattern.getWildcardChar()};
        for (const auto byte : pattern.raw()) {
            if (printedFirst)
                builder.put(' ');
            if (byte != wildcardChar) {
                if ((byte & 0xF0) == 0)
                    builder.put('0');
                builder.putHex(static_cast<unsigned char>(byte));
            } else {
                builder.put(byte);
            }

            printedFirst = true;
        }

        builder.put('\n');

        SimpleMessageBox{}.showWarning("Osiris", builder.cstring());
    }
};

```

`Source/MemorySearch/PatternPool.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <numeric>

#include <Utils/Meta.h>
#include <Utils/StrongTypeAlias.h>
#include <Utils/TypeList.h>

#include "CodePatternOperation.h"
#include "PatternPoolBuilder.h"
#include "PatternPoolView.h"

template <std::size_t BufferSize = 0, std::size_t NumberOfPatterns = 0, typename PatternTypesList = TypeList<>>
class PatternPool {
public:
    template <PatternPoolBuilder builder>
    [[nodiscard]] static consteval auto from() noexcept
    {
        using SortedPatternTypes = typename decltype(builder)::PatternTypes::template sortBy<Projected<UnpackStrongTypeAlias, SizeOf>::Value>;
        PatternPool<builder.tempPool.bufferSize, builder.tempPool.numberOfPatterns, SortedPatternTypes> pool;
        copyPatterns(builder.tempPool, pool, typename decltype(builder)::PatternTypes{}, SortedPatternTypes{});
        return pool;
    }

    using PatternTypes = PatternTypesList;

    [[nodiscard]] PatternPoolView getView() const noexcept
    {
        return {NumberOfPatterns, buffer.data(), patternLengths.data(), patternOffsets.data(), operations.data()};
    }

private:
    template <typename... SourceTypes, typename... DestTypes>
    static consteval void copyPatterns(const auto& tempPatternPool, auto& pool, TypeList<SourceTypes...>, TypeList<DestTypes...>) noexcept
    {
        std::size_t outPatternIndex{0}, outBufferIndex{0};
        (copyPattern(TypeList<SourceTypes...>::template indexOf<DestTypes>(), outPatternIndex, outBufferIndex, tempPatternPool, pool), ...);
    }

    static consteval void copyPattern(std::size_t patternIndex, std::size_t& outIndex, std::size_t& outBuffer, const auto& tempPool, auto& pool) noexcept
    {
        const auto patternBufferIndex = std::accumulate(tempPool.patternLengths.begin(), tempPool.patternLengths.begin() + patternIndex, 0);
        std::ranges::copy_n(tempPool.buffer.begin() + patternBufferIndex, tempPool.patternLengths[patternIndex], pool.buffer.begin() + outBuffer);
        outBuffer += tempPool.patternLengths[patternIndex];
        pool.patternLengths[outIndex] = tempPool.patternLengths[patternIndex];
        pool.patternOffsets[outIndex] = tempPool.patternOffsets[patternIndex];
        pool.operations[outIndex] = tempPool.operations[patternIndex];
        ++outIndex;
    }

    template <std::size_t, std::size_t, typename>
    friend class PatternPool;

    std::array<char, BufferSize> buffer{};
    std::array<std::uint8_t, NumberOfPatterns> patternLengths{};
    std::array<std::uint8_t, NumberOfPatterns> patternOffsets{};
    std::array<CodePatternOperation, NumberOfPatterns> operations{};
};

```

`Source/MemorySearch/PatternPoolBuilder.h`:

```h
#pragma once

#include <Utils/StrongTypeAlias.h>
#include <Utils/TypeList.h>

#include "CodePattern.h"
#include "CodePatternOperation.h"
#include "PatternStringWildcard.h"

template <typename TempPatternPool, typename PatternTypesList = TypeList<>>
class PatternPoolBuilder {
public:
    TempPatternPool tempPool;

    using PatternTypes = PatternTypesList;

    [[nodiscard]] consteval auto addPatterns(auto f) noexcept
    {
        return f(*this);
    }

    template <typename PatternType, CodePattern Pattern>
    [[nodiscard]] consteval auto addPattern() noexcept
    {
        static_assert(sizeof(UnpackStrongTypeAliasT<PatternType>) == 8 || Pattern.operation == CodePatternOperation::Read, "Incorrect result size, missing .read() in pattern declaration?");
        static_assert(hasWildcardsAtReadOffset(Pattern, sizeof(UnpackStrongTypeAliasT<PatternType>)), "Pattern does not have wildcards at the offset to read, incorrect offset in .add() ?");
        tempPool.template addPattern<Pattern>();
        return PatternPoolBuilder<TempPatternPool, typename PatternTypesList::template add<PatternType>>{tempPool};
    }

private:
    [[nodiscard]] static constexpr bool hasWildcardsAtReadOffset(const auto& pattern, std::size_t typeSize)
    {
        if (pattern.operation != CodePatternOperation::Read)
            return true;

        for (std::size_t i = 0; i < typeSize; ++i) {
            if (pattern.storage.pattern[pattern.offset + i] != kPatternStringWildcard)
                return false;
        }
        return true;
    }
};

```

`Source/MemorySearch/PatternPoolView.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include "BytePattern.h"
#include "CodePatternOperation.h"
#include "PatternStringWildcard.h"

struct PatternPoolView {
    void forEach(auto f) const noexcept
    {
        std::size_t patternStartIndex = 0;
        for (std::size_t i = 0; i < numberOfPatterns; ++i) {
            f(BytePattern{{buffer + patternStartIndex, patternLengths[i]}, kPatternStringWildcard}, patternOffsets[i], operations[i]);
            patternStartIndex += patternLengths[i];
        }
    }

    std::size_t numberOfPatterns;
    const char* buffer;
    const std::uint8_t* patternLengths;
    const std::uint8_t* patternOffsets;
    const CodePatternOperation* operations;
};

```

`Source/MemorySearch/PatternSearchResult.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <span>

#include <Utils/GenericPointer.h>

class PatternSearchResult {
public:
    PatternSearchResult(GenericPointer base, std::size_t patternFoundOffset, std::span<const std::byte> foundPatternBytes) noexcept
        : base{base}
        , patternFoundOffset{patternFoundOffset}
        , foundPatternBytes{foundPatternBytes}
    {
        assert(base);
    }

    PatternSearchResult() = default;

    PatternSearchResult& add(std::size_t offset) noexcept
    {
        if (base) {
            extraOffset += offset;
            assert(extraOffset < foundPatternBytes.size());
        }
        return *this;
    }

    [[nodiscard]] GenericPointer abs(std::size_t offsetToNextInstruction = 4) const noexcept
    {
        if (base) {
            using OffsetType = std::int32_t;
            OffsetType offset;
            assert(offsetToNextInstruction >= sizeof(OffsetType));
            assert(foundPatternBytes.size() - extraOffset >= sizeof(OffsetType));
            std::memcpy(&offset, foundPatternBytes.data() + extraOffset, sizeof(OffsetType));
            return base.as<const std::byte*>() + patternFoundOffset + extraOffset + offsetToNextInstruction + offset;
        }
        return {};
    }

    template <typename FieldOffsetType>
    [[nodiscard]] FieldOffsetType readOffset() const noexcept
    {
        if (base) {
            typename FieldOffsetType::OffsetType result;
            assert(foundPatternBytes.size() - extraOffset >= sizeof(result));
            std::memcpy(&result, foundPatternBytes.data() + extraOffset, sizeof(result));
            return FieldOffsetType{result};
        }
        return {};
    }

    template <typename T>
    [[nodiscard]] T as() const noexcept
    {
        if (base)
            return T(base.as<const std::byte*>() + patternFoundOffset + extraOffset);
        return T(base.as<void*>());
    }

    [[nodiscard]] std::array<std::byte, 8> read() const noexcept
    {
        std::array<std::byte, 8> result{};
        if (base)
            std::memcpy(result.data(), foundPatternBytes.data() + extraOffset, (std::min)(foundPatternBytes.size() - extraOffset, std::size_t{8}));
        return result;
    }

    [[nodiscard]] std::array<std::byte, 8> get() const noexcept
    {
        std::array<std::byte, 8> result{};
        if (base) {
            const auto pointer = base.as<const std::byte*>() + patternFoundOffset + extraOffset;
            static_assert(sizeof(pointer) == sizeof(result));
            std::memcpy(result.data(), &pointer, 8);
        }    
        return result;
    }
    
    [[nodiscard]] std::array<std::byte, 8> abs2(std::size_t offsetToNextInstruction = 4) const noexcept
    {
        std::array<std::byte, 8> result{};
        if (base) {
            using OffsetType = std::int32_t;
            OffsetType offset;
            assert(offsetToNextInstruction >= sizeof(OffsetType));
            assert(foundPatternBytes.size() - extraOffset >= sizeof(OffsetType));
            std::memcpy(&offset, foundPatternBytes.data() + extraOffset, sizeof(OffsetType));
            const auto pointer = base.as<const std::byte*>() + patternFoundOffset + extraOffset + offsetToNextInstruction + offset;
            static_assert(sizeof(pointer) == sizeof(result));
            std::memcpy(result.data(), &pointer, 8);
        }
        return result;
    }

private:
    GenericPointer base{};
    std::size_t patternFoundOffset;
    std::span<const std::byte> foundPatternBytes;
    std::size_t extraOffset{0};
};

```

`Source/MemorySearch/PatternSearchResults.h`:

```h
#pragma once

#include <array>
#include <bit>
#include <cstddef>

#include <Utils/Meta.h>
#include <Utils/StrongTypeAlias.h>

#include "PatternSearchResultsView.h"

template <typename PatternPool>
class PatternSearchResults {
private:
    using OneBytePatternTypes = typename PatternPool::PatternTypes::template filter<Projected<UnpackStrongTypeAlias, WithSizeOf<1>::Equal>::Value>;
    using FourBytePatternTypes = typename PatternPool::PatternTypes::template filter<Projected<UnpackStrongTypeAlias, WithSizeOf<4>::Equal>::Value>;
    using EightBytePatternTypes = typename PatternPool::PatternTypes::template filter<Projected<UnpackStrongTypeAlias, WithSizeOf<8>::Equal>::Value>;

    static_assert(OneBytePatternTypes::size() + FourBytePatternTypes::size() + EightBytePatternTypes::size() == PatternPool::PatternTypes::size());
public:
    template <typename T>
    [[nodiscard]] auto get() const noexcept
    {
        using UnpackedType = UnpackStrongTypeAliasT<T>;
        if constexpr (OneBytePatternTypes::template contains<T>())
            return std::bit_cast<UnpackedType>(oneByteResults[OneBytePatternTypes::template indexOf<T>()]);
        else if constexpr (FourBytePatternTypes::template contains<T>())
            return std::bit_cast<UnpackedType>(fourByteResults[FourBytePatternTypes::template indexOf<T>()]);
        else if constexpr (EightBytePatternTypes::template contains<T>())
            return std::bit_cast<UnpackedType>(eightByteResults[EightBytePatternTypes::template indexOf<T>()]);
        else
            static_assert(!std::is_same_v<T, T>, "Unknown type");
    }

    [[nodiscard]] PatternSearchResultsView getView() noexcept
    {
        return {oneByteResults, fourByteResults, eightByteResults};
    }

private:
    std::array<std::byte, OneBytePatternTypes::size()> oneByteResults;
    std::array<std::byte[4], FourBytePatternTypes::size()> fourByteResults;
    std::array<std::byte[8], EightBytePatternTypes::size()> eightByteResults;
};

```

`Source/MemorySearch/PatternSearchResultsView.h`:

```h
#pragma once

#include <array>
#include <cassert>
#include <cstddef>
#include <cstring>
#include <span>

struct PatternSearchResultsView {
    void store(std::size_t patternIndex, std::array<std::byte, 8> value) noexcept
    {
        if (patternIndex < oneByteResults.size()) {
            std::memcpy(&oneByteResults[patternIndex], value.data(), 1);
            return;
        }
        patternIndex -= oneByteResults.size();

        if (patternIndex < fourByteResults.size()) {
            std::memcpy(&fourByteResults[patternIndex], value.data(), 4);
            return;
        }
        patternIndex -= fourByteResults.size();

        if (patternIndex < eightByteResults.size()) {
            std::memcpy(&eightByteResults[patternIndex], value.data(), 8);
            return;
        }

        assert(false);
    }

    std::span<std::byte> oneByteResults;
    std::span<std::byte[4]> fourByteResults;
    std::span<std::byte[8]> eightByteResults;
};

```

`Source/MemorySearch/PatternStringWildcard.h`:

```h
#pragma once

constexpr auto kPatternStringWildcard{'?'};

```

`Source/MemorySearch/TempPatternPool.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <limits>

#include "CodePattern.h"
#include "CodePatternOperation.h"

template <std::size_t BufferCapacity, std::size_t MaxNumberOfPatterns>
class TempPatternPool {
    void error(const char*);
public:
    template <CodePattern Pattern>
    consteval void addPattern() noexcept
    {
        static_assert(Pattern.storage.size <= (std::numeric_limits<std::uint8_t>::max)());

        if (BufferCapacity - bufferSize < Pattern.storage.size)
            error("Not enough space in pattern buffer");

        if (numberOfPatterns == MaxNumberOfPatterns)
            error("Reached max number of patterns");

        std::ranges::copy_n(Pattern.storage.pattern.begin(), Pattern.storage.size, buffer.begin() + bufferSize);
        bufferSize += Pattern.storage.size;

        patternLengths[numberOfPatterns] = static_cast<std::uint8_t>(Pattern.storage.size);
        patternOffsets[numberOfPatterns] = Pattern.offset;
        operations[numberOfPatterns] = Pattern.operation;
        ++numberOfPatterns;
    }

    std::array<char, BufferCapacity> buffer{};
    std::array<std::uint8_t, MaxNumberOfPatterns> patternLengths{};
    std::array<std::uint8_t, MaxNumberOfPatterns> patternOffsets{};
    std::array<CodePatternOperation, MaxNumberOfPatterns> operations{};
    std::size_t bufferSize{0};
    std::size_t numberOfPatterns{0};
};

```

`Source/Osiris.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="BuildConfig.h" />
    <ClInclude Include="Common\Visibility.h" />
    <ClInclude Include="Config\Config.h" />
    <ClInclude Include="Config\ConfigFileOperation.h" />
    <ClInclude Include="Config\ConfigFromString.h" />
    <ClInclude Include="Config\ConfigParams.h" />
    <ClInclude Include="Config\ConfigSchema.h" />
    <ClInclude Include="Config\ConfigState.h" />
    <ClInclude Include="Config\ConfigStringConversionState.h" />
    <ClInclude Include="Config\ConfigToString.h" />
    <ClInclude Include="Config\ConfigVariable.h" />
    <ClInclude Include="Config\ConfigVariableChangeHandler.h" />
    <ClInclude Include="Config\ConfigVariables.h" />
    <ClInclude Include="Config\ConfigVariableTypes.h" />
    <ClInclude Include="Config\RangeConstrainedVariableParams.h" />
    <ClInclude Include="CS2\Classes\CCSPlayer_HostageServices.h" />
    <ClInclude Include="CS2\Classes\CCSPlayer_WeaponServices.h" />
    <ClInclude Include="CS2\Classes\CCSWeaponBaseVData.h" />
    <ClInclude Include="CS2\Classes\CCS_PortraitWorld.h" />
    <ClInclude Include="CS2\Classes\CCvar.h" />
    <ClInclude Include="CS2\Classes\CEntitySubclassVDataBase.h" />
    <ClInclude Include="CS2\Classes\CGameSceneNode.h" />
    <ClInclude Include="CS2\Classes\CGlowProperty.h" />
    <ClInclude Include="CS2\Classes\ClientModeCSNormal.h" />
    <ClInclude Include="CS2\Classes\CLoopModeGame.h" />
    <ClInclude Include="CS2\Classes\Color.h" />
    <ClInclude Include="CS2\Classes\ConVar.h" />
    <ClInclude Include="CS2\Classes\ConVarTypes.h" />
    <ClInclude Include="CS2\Classes\CPlantedC4.h" />
    <ClInclude Include="CS2\Classes\CRenderComponent.h" />
    <ClInclude Include="CS2\Classes\CSceneObject.h" />
    <ClInclude Include="CS2\Classes\CSceneSystem.h" />
    <ClInclude Include="CS2\Classes\CUtlAbstractDelegate.h" />
    <ClInclude Include="CS2\Classes\CUtlFilenameSymbolTable.h" />
    <ClInclude Include="CS2\Classes\CUtlLinkedList.h" />
    <ClInclude Include="CS2\Classes\CUtlMap.h" />
    <ClInclude Include="CS2\Classes\CUtlString.h" />
    <ClInclude Include="CS2\Classes\CUtlVector.h" />
    <ClInclude Include="CS2\Classes\CViewRender.h" />
    <ClInclude Include="CS2\Classes\C_CSGameRules.h" />
    <ClInclude Include="CS2\Classes\Entities\CBaseAnimGraph.h" />
    <ClInclude Include="CS2\Classes\Entities\CCSPlayerController.h" />
    <ClInclude Include="CS2\Classes\Entities\CEntityInstance.h" />
    <ClInclude Include="CS2\Classes\Entities\C_BaseCSGrenadeProjectile.h" />
    <ClInclude Include="CS2\Classes\Entities\C_BaseEntity.h" />
    <ClInclude Include="CS2\Classes\Entities\C_BaseModelEntity.h" />
    <ClInclude Include="CS2\Classes\Entities\C_CSGO_PreviewPlayer.h" />
    <ClInclude Include="CS2\Classes\Entities\C_CSPlayerPawn.h" />
    <ClInclude Include="CS2\Classes\Entities\C_CSPlayerResource.h" />
    <ClInclude Include="CS2\Classes\Entities\C_CSWeaponBase.h" />
    <ClInclude Include="CS2\Classes\Entities\C_Hostage.h" />
    <ClInclude Include="CS2\Classes\Entities\GrenadeProjectiles.h" />
    <ClInclude Include="CS2\Classes\Entities\WeaponEntities.h" />
    <ClInclude Include="CS2\Classes\EntitySystem\CConcreteEntityList.h" />
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityClass.h" />
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityHandle.h" />
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityIdentity.h" />
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityIndex.h" />
    <ClInclude Include="CS2\Classes\EntitySystem\CGameEntitySystem.h" />
    <ClInclude Include="CS2\Classes\FileSystem.h" />
    <ClInclude Include="CS2\Classes\GlobalVars.h" />
    <ClInclude Include="CS2\Classes\Glow.h" />
    <ClInclude Include="CS2\Classes\IMemAlloc.h" />
    <ClInclude Include="CS2\Classes\SceneObjectUpdaterHandle_t.h" />
    <ClInclude Include="CS2\Classes\Sound.h" />
    <ClInclude Include="CS2\Classes\Vector.h" />
    <ClInclude Include="CS2\Classes\VMatrix.h" />
    <ClInclude Include="CS2\Constants\AspectRatio.h" />
    <ClInclude Include="CS2\Constants\BombsiteIndex.h" />
    <ClInclude Include="CS2\Constants\ColorConstants.h" />
    <ClInclude Include="CS2\Constants\CrosshairColorIndex.h" />
    <ClInclude Include="CS2\Constants\DllNames.h" />
    <ClInclude Include="CS2\Constants\EntityHandle.h" />
    <ClInclude Include="CS2\Constants\EntityClasses.h" />
    <ClInclude Include="CS2\Constants\IconURLs.h" />
    <ClInclude Include="CS2\Constants\LifeStateConstants.h" />
    <ClInclude Include="CS2\Constants\PanelIDs.h" />
    <ClInclude Include="CS2\Constants\RoundWinStatus.h" />
    <ClInclude Include="CS2\Constants\SceneObjectAttributeNames.h" />
    <ClInclude Include="CS2\Constants\SoundNames.h" />
    <ClInclude Include="CS2\Constants\StylePropertySymbolNames.h" />
    <ClInclude Include="CS2\Constants\StylePropertyTypeNames.h" />
    <ClInclude Include="CS2\Constants\TeamNumberConstants.h" />
    <ClInclude Include="CS2\Econ\ItemDefinitionIndex.h" />
    <ClInclude Include="CS2\Econ\ItemId.h" />
    <ClInclude Include="CS2\Econ\PaintKitIndex.h" />
    <ClInclude Include="CS2\Panorama\CDropDown.h" />
    <ClInclude Include="CS2\Panorama\CImagePanel.h" />
    <ClInclude Include="CS2\Panorama\CLabel.h" />
    <ClInclude Include="CS2\Panorama\CPanel2D.h" />
    <ClInclude Include="CS2\Panorama\CPanelStyle.h" />
    <ClInclude Include="CS2\Panorama\CPanoramaSymbol.h" />
    <ClInclude Include="CS2\Panorama\CSlider.h" />
    <ClInclude Include="CS2\Panorama\CStyleSymbol.h" />
    <ClInclude Include="CS2\Panorama\CTextEntry.h" />
    <ClInclude Include="CS2\Panorama\CTopLevelWindow.h" />
    <ClInclude Include="CS2\Panorama\CUIEngine.h" />
    <ClInclude Include="CS2\Panorama\CUILength.h" />
    <ClInclude Include="CS2\Panorama\CUIPanel.h" />
    <ClInclude Include="CS2\Panorama\CUI_3dPanel.h" />
    <ClInclude Include="CS2\Panorama\CUI_Item3dPanel.h" />
    <ClInclude Include="CS2\Panorama\PanelHandle.h" />
    <ClInclude Include="CS2\Panorama\StyleEnums.h" />
    <ClInclude Include="CS2\Panorama\StyleProperties.h" />
    <ClInclude Include="CS2\Panorama\Transform3D.h" />
    <ClInclude Include="EntryPoints\EntryPoints.h" />
    <ClInclude Include="EntryPoints\GuiEntryPoints.h" />
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVis.h" />
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVisConfigVariables.h" />
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVisParams.h" />
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVisState.h" />
    <ClInclude Include="Features\Common\FeatureToggle.h" />
    <ClInclude Include="Features\Common\InWorldPanelIndex.h" />
    <ClInclude Include="Features\Common\InWorldPanelListEntry.h" />
    <ClInclude Include="Features\Common\InWorldPanels.h" />
    <ClInclude Include="Features\Common\InWorldPanelsPerHookState.h" />
    <ClInclude Include="Features\Common\InWorldPanelsState.h" />
    <ClInclude Include="Features\Common\RenderingHookEntityLoop.h" />
    <ClInclude Include="Features\FeaturesStates.h" />
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlert.h" />
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertConfigVariables.h" />
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertPanelFactory.h" />
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertPanelParams.h" />
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertParams.h" />
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertState.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombSiteIconPanel.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimer.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerCondition.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerConfigVariables.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerContext.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerPanel.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerPanelFactory.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerPanelParams.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerState.h" />
    <ClInclude Include="Features\Hud\BombTimer\BombTimerTextPanel.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlert.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertCondition.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertConfigVariables.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertContext.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertPanel.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertPanelParams.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertState.h" />
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingCountdownTextPanel.h" />
    <ClInclude Include="Features\Hud\HudFeaturesStates.h" />
    <ClInclude Include="Features\Hud\KillfeedPreserver\KillfeedPreserver.h" />
    <ClInclude Include="Features\Hud\KillfeedPreserver\KillfeedPreserverConfigVariables.h" />
    <ClInclude Include="Features\Hud\KillfeedPreserver\KillfeedPreserverContext.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimer.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerCondition.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerConfigVariables.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerContext.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerPanel.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerPanelFactory.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerPanelParams.h" />
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerState.h" />
    <ClInclude Include="Features\Sound\BombBeepVisualizer.h" />
    <ClInclude Include="Features\Sound\BombDefuseVisualizer.h" />
    <ClInclude Include="Features\Sound\BombPlantVisualizer.h" />
    <ClInclude Include="Features\Sound\Details\BombBeepSound.h" />
    <ClInclude Include="Features\Sound\Details\BombDefuseSound.h" />
    <ClInclude Include="Features\Sound\Details\BombPlantSound.h" />
    <ClInclude Include="Features\Sound\Details\FootstepSound.h" />
    <ClInclude Include="Features\Sound\Details\PlayedSound.h" />
    <ClInclude Include="Features\Sound\Details\SoundExpiryChecker.h" />
    <ClInclude Include="Features\Sound\Details\SoundVisualization.h" />
    <ClInclude Include="Features\Sound\Details\SoundVisualizationFeature.h" />
    <ClInclude Include="Features\Sound\Details\SoundVisualizationPanelFactory.h" />
    <ClInclude Include="Features\Sound\Details\SoundVisualizationPanelProperties.h" />
    <ClInclude Include="Features\Sound\Details\SoundWatcher.h" />
    <ClInclude Include="Features\Sound\Details\SoundWatcherImpl.h" />
    <ClInclude Include="Features\Sound\Details\SoundWatcherImplState.h" />
    <ClInclude Include="Features\Sound\Details\SoundWatcherState.h" />
    <ClInclude Include="Features\Sound\Details\WatchedSounds.h" />
    <ClInclude Include="Features\Sound\Details\WeaponReloadSound.h" />
    <ClInclude Include="Features\Sound\Details\WeaponScopeSound.h" />
    <ClInclude Include="Features\Sound\FootstepVisualizer.h" />
    <ClInclude Include="Features\Sound\SoundFeatures.h" />
    <ClInclude Include="Features\Sound\SoundVisualizationConfigVariables.h" />
    <ClInclude Include="Features\Sound\SoundVisualizationPanelTypes.h" />
    <ClInclude Include="Features\Sound\WeaponReloadVisualizer.h" />
    <ClInclude Include="Features\Sound\WeaponScopeVisualizer.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\DefuseKitModelGlow\DefuseKitModelGlow.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\DroppedBombModelGlow\DroppedBombModelGlow.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\GrenadeProjectileModelGlow\GrenadeProjectileModelGlow.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlow.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowConfigVariables.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowDeactivationFlags.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowParams.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowState.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\PlayerModelGlow\PlayerModelGlow.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\BaseEntityForModelGlowPreview.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\EnemyTeam.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerControllerForModelGlowPreview.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreview.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreviewColorMode.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreviewParams.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreviewState.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerPawnForModelGlowPreview.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\WeaponModelGlowPreview.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\WeaponModelGlowPreviewState.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\TickingBombModelGlow\TickingBombModelGlow.h" />
    <ClInclude Include="Features\Visuals\ModelGlow\WeaponModelGlow\WeaponModelGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\DefuseKitOutlineGlow\DefuseKitOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\DroppedBombOutlineGlow\DroppedBombOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\GrenadeProjectileOutlineGlow\GrenadeProjectileOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\HostageOutlineGlow\HostageOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\OutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\OutlineGlowConfigVariables.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\OutlineGlowParams.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\PlayerOutlineGlow\PlayerOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\PlayerOutlineGlow\PlayerOutlineGlowColorType.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\TickingBombOutlineGlow\TickingBombOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\OutlineGlow\WeaponOutlineGlow\WeaponOutlineGlow.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo\ActiveWeaponAmmoPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo\PlayerActiveWeaponAmmoPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo\PlayerActiveWeaponAmmoPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth\PlayerHealthPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth\PlayerHealthPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth\PlayerHealthPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoContainerPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorld.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldCondition.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldConfigVariables.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldPanelFactory.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldState.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCache.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCacheEntry.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCachePerHookState.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCacheState.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelTypes.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowColorType.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsToShow.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon\ActiveWeaponIconPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon\PlayerActiveWeaponIconPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon\PlayerActiveWeaponIconPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon\PlayerBombIconPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon\PlayerBombIconPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon\PlayerBombIconPanelParams.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\PlayerWeaponIconPanel.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\PlayerWeaponIconPanelContext.h" />
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\PlayerWeaponIconPanelParams.h" />
    <ClInclude Include="Features\Visuals\ViewmodelMod\ViewmodelMod.h" />
    <ClInclude Include="Features\Visuals\ViewmodelMod\ViewmodelModConfigVariables.h" />
    <ClInclude Include="Features\Visuals\ViewmodelMod\ViewmodelModParams.h" />
    <ClInclude Include="Features\Visuals\VisualFeaturesStates.h" />
    <ClInclude Include="GameClient\ConVars\ConVarsBase.h" />
    <ClInclude Include="GameClient\ConVars\ConVarTypes.h" />
    <ClInclude Include="GameClient\ConVars\CvarSystem.h" />
    <ClInclude Include="GameClient\Crosshair.h" />
    <ClInclude Include="GameClient\DLLs\Tier0Dll.h" />
    <ClInclude Include="GameClient\Econ\FauxItemId.h" />
    <ClInclude Include="GameClient\Entities\BaseEntity.h" />
    <ClInclude Include="GameClient\Entities\BaseModelEntity.h" />
    <ClInclude Include="GameClient\Entities\BaseWeapon.h" />
    <ClInclude Include="GameClient\Entities\C4.h" />
    <ClInclude Include="GameClient\Entities\EntityClassifier.h" />
    <ClInclude Include="GameClient\Entities\GameRules.h" />
    <ClInclude Include="GameClient\Entities\GlowProperty.h" />
    <ClInclude Include="GameClient\Entities\HostageServices.h" />
    <ClInclude Include="GameClient\Entities\LifeState.h" />
    <ClInclude Include="GameClient\Entities\PlantedC4.h" />
    <ClInclude Include="GameClient\Entities\PlayerController.h" />
    <ClInclude Include="GameClient\Entities\PlayerPawn.h" />
    <ClInclude Include="GameClient\Entities\PlayerResource.h" />
    <ClInclude Include="GameClient\Entities\PlayerWeapons.h" />
    <ClInclude Include="GameClient\Entities\PreviewPlayer.h" />
    <ClInclude Include="GameClient\Entities\RenderComponent.h" />
    <ClInclude Include="GameClient\Entities\SmokeGrenadeProjectile.h" />
    <ClInclude Include="GameClient\Entities\TeamNumber.h" />
    <ClInclude Include="GameClient\Entities\WeaponServices.h" />
    <ClInclude Include="GameClient\EntitySystem\EntityHandle.h" />
    <ClInclude Include="GameClient\EntitySystem\EntityIdentity.h" />
    <ClInclude Include="GameClient\EntitySystem\EntitySystem.h" />
    <ClInclude Include="GameClient\FileNameSymbolTable.h" />
    <ClInclude Include="GameClient\FileNameSymbolTableState.h" />
    <ClInclude Include="GameClient\FileSystem.h" />
    <ClInclude Include="GameClient\GameSceneNode.h" />
    <ClInclude Include="GameClient\GlobalVars.h" />
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanel.h" />
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelContext.h" />
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelManager.h" />
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelManagerContext.h" />
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelState.h" />
    <ClInclude Include="GameClient\Hud\DeathNotice.h" />
    <ClInclude Include="GameClient\Hud\DeathNoticeContext.h" />
    <ClInclude Include="GameClient\Hud\DeathNotices.h" />
    <ClInclude Include="GameClient\Hud\Hud.h" />
    <ClInclude Include="GameClient\Hud\HudContext.h" />
    <ClInclude Include="GameClient\Hud\HudState.h" />
    <ClInclude Include="GameClient\MemAlloc.h" />
    <ClInclude Include="GameClient\MemAllocState.h" />
    <ClInclude Include="GameClient\Panorama\ClientPanel.h" />
    <ClInclude Include="GameClient\Panorama\ImagePanel.h" />
    <ClInclude Include="GameClient\Panorama\Ui3dPanel.h" />
    <ClInclude Include="GameClient\Panorama\PanelAlignmentParams.h" />
    <ClInclude Include="GameClient\Panorama\PanelFactory.h" />
    <ClInclude Include="GameClient\Panorama\PanelFontParams.h" />
    <ClInclude Include="GameClient\Panorama\PanelHandle.h" />
    <ClInclude Include="GameClient\Panorama\PanelMarginParams.h" />
    <ClInclude Include="GameClient\Panorama\PanelShadowParams.h" />
    <ClInclude Include="GameClient\Panorama\PanelStylePropertyFactory.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaDropDown.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaLabel.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaSymbols.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaTransformations.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaTransformFactory.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaUiEngine.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanel.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelChildPanels.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelClasses.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelIterator.h" />
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelMethodInvoker.h" />
    <ClInclude Include="GameClient\Panorama\Slider.h" />
    <ClInclude Include="GameClient\Panorama\StylePropertiesSymbolsAndVMTs.h" />
    <ClInclude Include="GameClient\Panorama\StylePropertySymbolMap.h" />
    <ClInclude Include="GameClient\Panorama\TextEntry.h" />
    <ClInclude Include="GameClient\Panorama\TopLevelWindow.h" />
    <ClInclude Include="GameClient\Panorama\UiItem3dPanel.h" />
    <ClInclude Include="GameClient\PortraitWorld.h" />
    <ClInclude Include="GameClient\SceneSystem\SceneObject.h" />
    <ClInclude Include="GameClient\SceneSystem\SceneObjectAttributes.h" />
    <ClInclude Include="GameClient\SceneSystem\SceneObjectUpdater.h" />
    <ClInclude Include="GameClient\SceneSystem\SceneObjectUpdaters.h" />
    <ClInclude Include="GameClient\SceneSystem\SceneSystem.h" />
    <ClInclude Include="GameClient\WorldToScreen\ClipSpaceCoordinates.h" />
    <ClInclude Include="GameClient\WorldToScreen\NormalizedDeviceCoordinates.h" />
    <ClInclude Include="GameClient\WorldToScreen\ViewToProjectionMatrix.h" />
    <ClInclude Include="GameClient\WorldToScreen\WorldToClipSpaceConverter.h" />
    <ClInclude Include="GlobalContext\DeferredCompleteObject.h" />
    <ClInclude Include="GlobalContext\FullGlobalContext.h" />
    <ClInclude Include="GlobalContext\GlobalContext.h" />
    <ClInclude Include="GlobalContext\OsirisDirectoryPath.h" />
    <ClInclude Include="GlobalContext\PartialGlobalContext.h" />
    <ClInclude Include="GlobalContext\UnloadFlag.h" />
    <ClInclude Include="HookContext\HookContext.h" />
    <ClInclude Include="HookContext\HookContextMacros.h" />
    <ClInclude Include="Hooks\ClientModeHooks.h" />
    <ClInclude Include="Hooks\Hooks.h" />
    <ClInclude Include="Hooks\PeepEventsHook.h" />
    <ClInclude Include="Hooks\ViewRenderHook.h" />
    <ClInclude Include="MemoryAllocation\FreeMemoryRegion.h" />
    <ClInclude Include="MemoryAllocation\FreeMemoryRegionList.h" />
    <ClInclude Include="MemoryAllocation\MemoryAllocator.h" />
    <ClInclude Include="MemoryAllocation\MemoryAllocatorBase.h" />
    <ClInclude Include="MemoryAllocation\MemoryAllocatorBaseImpl.h" />
    <ClInclude Include="MemoryAllocation\MemoryDeleter.h" />
    <ClInclude Include="MemoryAllocation\UniquePtr.h" />
    <ClInclude Include="MemoryPatterns\AllMemoryPatternSearchResults.h" />
    <ClInclude Include="MemoryPatterns\MemoryPatterns.h" />
    <ClInclude Include="MemoryPatterns\PatternFinders.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\BaseModelEntityPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\C4PatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\ClientPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\ConVarPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\CvarPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\EntityPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\EntitySystemPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\FileSystemPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\GameRulesPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\GameSceneNodePatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\GlobalVarsPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\GlowPropertyPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\GlowSceneObjectPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\HostageServicesPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\MemAllocPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PanelPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PanelStylePatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PanoramaDropDownPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PanoramaImagePanelPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PanoramaLabelPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PlantedC4PatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PlayerControllerPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PlayerPawnPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PlayerResourcePatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\PortraitWorldPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\RenderComponentPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\SceneObjectPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\SceneObjectUpdaterPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\SceneSystemPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\SliderPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\SmokeGrenadeProjectilePatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\SoundSystemPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\TextEntryPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\TopLevelWindowPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\Ui3dPanelPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\UiEnginePatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\UiItem3dPanelPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\UiPanelPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\WeaponPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\WeaponServicesPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\PatternTypes\WeaponVDataPatternTypes.h" />
    <ClInclude Include="MemoryPatterns\Windows\BaseModelEntityPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\C4PatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\ClientPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\ConVarPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\CvarPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\EntityPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\EntitySystemPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\FileSystemPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\GameRulesPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\GameSceneNodePatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\GlobalVarsPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\GlowPropertyPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\GlowSceneObjectPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\HostageServicesPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PlayerResourcePatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PortraitWorldPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\MemAllocPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanelPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanelStylePatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanoramaDropDownPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanoramaImagePanelPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanoramaLabelPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanoramaUiEnginePatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PanoramaUiPanelPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PlantedC4PatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PlayerControllerPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\PlayerPawnPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\RenderComponentPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SceneObjectPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SceneObjectUpdaterPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SceneSystemPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SdlPatternWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SliderPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SmokeGrenadeProjectilePatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\SoundSystemPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\TextEntryPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\TopLevelWindowPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\Ui3dPanelPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\UiItem3dPanelPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\WeaponPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\WeaponServicesPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\WeaponVDataPatternsWindows.h" />
    <ClInclude Include="MemoryPatterns\Windows\WindowsPatterns.h" />
    <ClInclude Include="MemorySearch\BytePattern.h" />
    <ClInclude Include="MemorySearch\BytePatternConverter.h" />
    <ClInclude Include="MemorySearch\BytePatternLiteral.h" />
    <ClInclude Include="MemorySearch\BytePatternStorage.h" />
    <ClInclude Include="MemorySearch\CodePattern.h" />
    <ClInclude Include="MemorySearch\CodePatternOperation.h" />
    <ClInclude Include="MemorySearch\HybridPatternFinder.h" />
    <ClInclude Include="MemorySearch\PatternFinder.h" />
    <ClInclude Include="MemorySearch\PatternFinderScalar.h" />
    <ClInclude Include="MemorySearch\PatternFinderSIMD.h" />
    <ClInclude Include="MemorySearch\PatternNotFoundLogger.h" />
    <ClInclude Include="MemorySearch\PatternPool.h" />
    <ClInclude Include="MemorySearch\PatternPoolBuilder.h" />
    <ClInclude Include="MemorySearch\PatternPoolView.h" />
    <ClInclude Include="MemorySearch\PatternSearchResult.h" />
    <ClInclude Include="MemorySearch\PatternSearchResults.h" />
    <ClInclude Include="MemorySearch\PatternSearchResultsView.h" />
    <ClInclude Include="MemorySearch\PatternStringWildcard.h" />
    <ClInclude Include="MemorySearch\BytePatternView.h" />
    <ClInclude Include="MemorySearch\TempPatternPool.h" />
    <ClInclude Include="OutlineGlow\GlowSceneObject.h" />
    <ClInclude Include="OutlineGlow\GlowSceneObjectContext.h" />
    <ClInclude Include="OutlineGlow\GlowSceneObjectPointer.h" />
    <ClInclude Include="OutlineGlow\GlowSceneObjects.h" />
    <ClInclude Include="OutlineGlow\GlowSceneObjectsState.h" />
    <ClInclude Include="OutlineGlow\GlowSceneObjectState.h" />
    <ClInclude Include="Platform\DynamicLibrary.h" />
    <ClInclude Include="Platform\Macros\CallingConventions.h" />
    <ClInclude Include="Platform\Macros\CallStack.h" />
    <ClInclude Include="Platform\Macros\FunctionAttributes.h" />
    <ClInclude Include="Platform\Macros\IsCompiler.h" />
    <ClInclude Include="Platform\Macros\IsPlatform.h" />
    <ClInclude Include="Platform\Macros\PlatformSpecific.h" />
    <ClInclude Include="Platform\PlatformApi.h" />
    <ClInclude Include="Platform\PlatformPath.h" />
    <ClInclude Include="Platform\SimpleMessageBox.h" />
    <ClInclude Include="Platform\TypeInfoPrecedingVmt.h" />
    <ClInclude Include="Platform\VmtFinder.h" />
    <ClInclude Include="Platform\Windows\CoTaskMemDeleter.h" />
    <ClInclude Include="Platform\Windows\DLLs\CombaseDll.h" />
    <ClInclude Include="Platform\Windows\DLLs\Shell32Dll.h" />
    <ClInclude Include="Platform\Windows\FileSystem\WindowsFileSystem.h" />
    <ClInclude Include="Platform\Windows\FileSystem\WindowsInputFile.h" />
    <ClInclude Include="Platform\Windows\NtHandle.h" />
    <ClInclude Include="Platform\Windows\PebLdr.h" />
    <ClInclude Include="Platform\Windows\PortableExecutable.h" />
    <ClInclude Include="Platform\Windows\RTTI\RttiCompleteObjectLocator.h" />
    <ClInclude Include="Platform\Windows\RTTI\RttiCompleteObjectLocatorFinder.h" />
    <ClInclude Include="Platform\Windows\RTTI\RttiTypeDescriptor.h" />
    <ClInclude Include="Platform\Windows\RTTI\RttiTypeDescriptorFinder.h" />
    <ClInclude Include="Platform\Windows\RTTI\ToRvaConverter.h" />
    <ClInclude Include="Platform\Windows\Syscalls\SyscallParams.h" />
    <ClInclude Include="Platform\Windows\Syscalls\WindowsSyscallIndex.h" />
    <ClInclude Include="Platform\Windows\Syscalls\WindowsSyscalls.h" />
    <ClInclude Include="Platform\Windows\UserDocumentsFolderPath.h" />
    <ClInclude Include="Platform\Windows\Win.h" />
    <ClInclude Include="Platform\Windows\WindowsDynamicLibrary.h" />
    <ClInclude Include="Platform\Windows\WindowsMessageBox.h" />
    <ClInclude Include="Platform\Windows\WindowsPlatformApi.h" />
    <ClInclude Include="Platform\Windows\WindowsPlatformApiImpl.h" />
    <ClInclude Include="Platform\Windows\WindowsVmtFinder.h" />
    <ClInclude Include="Platform\Windows\WindowsVmtFinderParams.h" />
    <ClInclude Include="SDL\SdlConstants.h" />
    <ClInclude Include="SDL\SdlDll.h" />
    <ClInclude Include="SDL\SdlFunctions.h" />
    <ClInclude Include="UI\Panorama\CombatTab.h" />
    <ClInclude Include="UI\Panorama\HudTab.h" />
    <ClInclude Include="UI\Panorama\OnOffDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\PanoramaCommandDispatcher.h" />
    <ClInclude Include="UI\Panorama\PanoramaGUI.h" />
    <ClInclude Include="UI\Panorama\PanoramaGuiState.h" />
    <ClInclude Include="UI\Panorama\SetCommandHandler.h" />
    <ClInclude Include="UI\Panorama\SoundTab.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\HueSlider.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\IntSlider.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerInfoInWorldDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerModelGlowColorModeDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerModelGlowDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerOutlineGlowColorModeDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerOutlineGlowDropdownSelectionChangeHandler.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\ViewmodelModPreviewPanel.h" />
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\ViewmodelModPreviewPanelState.h" />
    <ClInclude Include="UI\Panorama\VisualsTab.h" />
    <ClInclude Include="Utils\Align.h" />
    <ClInclude Include="Utils\BitFlags.h" />
    <ClInclude Include="Utils\Bits.h" />
    <ClInclude Include="Utils\CharUtils.h" />
    <ClInclude Include="Utils\ColorUtils.h" />
    <ClInclude Include="Utils\CString.h" />
    <ClInclude Include="Utils\DynamicArray.h" />
    <ClInclude Include="Utils\EnumFlags.h" />
    <ClInclude Include="Utils\FieldFieldOffset.h" />
    <ClInclude Include="Utils\FieldOffset.h" />
    <ClInclude Include="Utils\FileSlice.h" />
    <ClInclude Include="Utils\FlagsBuilder.h" />
    <ClInclude Include="Utils\GenericFunctionPointer.h" />
    <ClInclude Include="Utils\GenericPointer.h" />
    <ClInclude Include="Utils\HexChars.h" />
    <ClInclude Include="Utils\IdentityMacro.h" />
    <ClInclude Include="Utils\InRange.h" />
    <ClInclude Include="Utils\LazyInitialized.h" />
    <ClInclude Include="Utils\Lvalue.h" />
    <ClInclude Include="Utils\ManuallyDestructible.h" />
    <ClInclude Include="Utils\MemorySection.h" />
    <ClInclude Include="Utils\Meta.h" />
    <ClInclude Include="Utils\Optional.h" />
    <ClInclude Include="Utils\OptionalPointee.h" />
    <ClInclude Include="Utils\Pad.h" />
    <ClInclude Include="Utils\PrivateTag.h" />
    <ClInclude Include="Utils\RefCountedHook.h" />
    <ClInclude Include="Utils\ReturnAddress.h" />
    <ClInclude Include="Utils\SpanSlice.h" />
    <ClInclude Include="Utils\StringBuilder.h" />
    <ClInclude Include="Utils\StringParser.h" />
    <ClInclude Include="Utils\StrongTypeAlias.h" />
    <ClInclude Include="Utils\TemplateParameterCstring.h" />
    <ClInclude Include="Utils\ToUnderlying.h" />
    <ClInclude Include="Utils\TypeBitFlags.h" />
    <ClInclude Include="Utils\TypedStaticStringPool.h" />
    <ClInclude Include="Utils\TypeIndex.h" />
    <ClInclude Include="Utils\TypeList.h" />
    <ClInclude Include="Utils\Wcslen.h" />
    <ClInclude Include="Verification\Verifier.h" />
    <ClInclude Include="Verification\VerifyMacros.h" />
    <ClInclude Include="Vmt\VmtCopy.h" />
    <ClInclude Include="Vmt\VmtLength.h" />
    <ClInclude Include="Vmt\VmtLengthCalculator.h" />
    <ClInclude Include="Vmt\VmtSwapper.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="UI\Panorama\CreateGUI.js" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Platform\Windows\CRTWindows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Platform\Windows\Syscalls\WindowsSyscall.asm" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{dd077013-2b61-4122-970e-63e63055eaa8}</ProjectGuid>
    <RootNamespace>Osiris</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(ProjectDir);$(IncludePath)</IncludePath>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;OSIRIS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_USE_STD_VECTOR_ALGORITHMS=0;NDEBUG;OSIRIS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <RuntimeLibrary />
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Source/Osiris.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="CS2">
      <UniqueIdentifier>{fe899935-4774-4b30-ac9c-b1a6055666e5}</UniqueIdentifier>
    </Filter>
    <Filter Include="CS2\Classes">
      <UniqueIdentifier>{5f3eb65d-765c-423a-81bb-84527b157b71}</UniqueIdentifier>
    </Filter>
    <Filter Include="CS2\Constants">
      <UniqueIdentifier>{d999d684-295e-4c04-b949-35386439cd84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features">
      <UniqueIdentifier>{bdcd13b6-e67e-43e7-b6b5-9898375770d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Hud">
      <UniqueIdentifier>{d08ceb16-76e5-49ed-865a-f74883b720c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals">
      <UniqueIdentifier>{3ee30a31-8dbf-4608-8064-4c996ce05980}</UniqueIdentifier>
    </Filter>
    <Filter Include="Hooks">
      <UniqueIdentifier>{1ee84f1c-3411-4068-816f-186260cb390d}</UniqueIdentifier>
    </Filter>
    <Filter Include="MemoryAllocation">
      <UniqueIdentifier>{a7c6f0cc-33af-4b84-bc2e-b475218c32db}</UniqueIdentifier>
    </Filter>
    <Filter Include="MemoryPatterns">
      <UniqueIdentifier>{7ab4346b-d402-48a8-9590-aca3b0f0be40}</UniqueIdentifier>
    </Filter>
    <Filter Include="MemoryPatterns\Windows">
      <UniqueIdentifier>{cf6b4008-917e-4941-ba38-2e6810674d66}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform">
      <UniqueIdentifier>{5d3b276e-b98d-470f-be8c-733cb1e03f76}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform\Windows">
      <UniqueIdentifier>{151d7c38-8452-494d-aef9-a83eb5c3e654}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform\Windows\DLLs">
      <UniqueIdentifier>{f55814bc-f553-43fb-9618-c44c4123147c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform\Macros">
      <UniqueIdentifier>{b9abe2b4-4d35-4caa-9dc3-048c23269180}</UniqueIdentifier>
    </Filter>
    <Filter Include="UI">
      <UniqueIdentifier>{2bc1aec8-532c-4e08-91ab-fef64934fdcd}</UniqueIdentifier>
    </Filter>
    <Filter Include="UI\Panorama">
      <UniqueIdentifier>{dc1b255e-c46b-4a72-a232-f6fdcc600f74}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils">
      <UniqueIdentifier>{db8414f0-eeaf-42ef-86d3-9f0ae024684a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Verification">
      <UniqueIdentifier>{16a25d9c-a41e-4392-919b-8705cd5259cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Vmt">
      <UniqueIdentifier>{55a59ab3-797b-4ca6-b4aa-307861d4ae1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="MemorySearch">
      <UniqueIdentifier>{28ecac3b-05f9-44d1-86cb-50d8fe91ff36}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Sound">
      <UniqueIdentifier>{432df53f-506f-470e-af2c-7155e3d4f03c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform\Windows\RTTI">
      <UniqueIdentifier>{3908a784-03e1-437a-97b7-7479673278cc}</UniqueIdentifier>
    </Filter>
    <Filter Include="GlobalContext">
      <UniqueIdentifier>{f7503469-198c-4672-8e52-aa5473f130ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="CS2\Classes\EntitySystem">
      <UniqueIdentifier>{debf5712-df61-49be-b7b5-69adf565d500}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform\Windows\Syscalls">
      <UniqueIdentifier>{47030bf1-e7cd-4f68-936f-1481aa0916d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Sound\Details">
      <UniqueIdentifier>{9420a2f8-4f10-4cfc-9196-5f3290dd58eb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Platform\Windows\FileSystem">
      <UniqueIdentifier>{a12f576a-08be-49f6-9ed7-10f1fe8a4737}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDL">
      <UniqueIdentifier>{23614f08-44a8-4cb7-a21a-13d32b93bd86}</UniqueIdentifier>
    </Filter>
    <Filter Include="CS2\Classes\Entities">
      <UniqueIdentifier>{ac0c1599-a345-44a2-8521-ea4eb53655df}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Hud\BombTimer">
      <UniqueIdentifier>{bbb4bb7f-d544-416a-96ea-1699bcd868de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Hud\DefusingAlert">
      <UniqueIdentifier>{723cc05a-4e0a-4dc5-98cb-37955a0c998d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Hud\KillfeedPreserver">
      <UniqueIdentifier>{f7a2da12-9a16-4ded-af46-6bfc1d06d05a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Common">
      <UniqueIdentifier>{deb809e0-b2a4-445d-a8a8-bc33739388a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Hud\PostRoundTimer">
      <UniqueIdentifier>{d23198a3-b135-45ab-b465-650de2aca753}</UniqueIdentifier>
    </Filter>
    <Filter Include="CS2\Panorama">
      <UniqueIdentifier>{48fe0d05-e9dd-4f7e-af70-ea21d217fc88}</UniqueIdentifier>
    </Filter>
    <Filter Include="OutlineGlow">
      <UniqueIdentifier>{f481aa89-278f-4f75-84c3-d31cf67e6e8c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow">
      <UniqueIdentifier>{d02b33b5-48ee-44d3-b1ea-4006a288c236}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\WeaponOutlineGlow">
      <UniqueIdentifier>{15f90b05-4e91-46a0-9a30-9586fe330745}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\PlayerOutlineGlow">
      <UniqueIdentifier>{8c999ef8-d7ae-4f2b-bc29-f9ed28e806db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\DefuseKitOutlineGlow">
      <UniqueIdentifier>{ab8f4d2e-4353-44f9-ac25-425ae8cbe905}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\GrenadeProjectileOutlineGlow">
      <UniqueIdentifier>{88aa3de7-03b7-49bc-a280-76714e28a62a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\DroppedBombOutlineGlow">
      <UniqueIdentifier>{4cacd578-512d-4917-912c-c98f07a6d19b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\TickingBombOutlineGlow">
      <UniqueIdentifier>{845ab4cc-9e82-4b6d-8e55-170788a073b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\OutlineGlow\HostageOutlineGlow">
      <UniqueIdentifier>{ae772213-696b-492e-be38-31b9e68b96f5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld">
      <UniqueIdentifier>{69cf9e50-a22f-4806-9442-b42a9d93477f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo">
      <UniqueIdentifier>{53821f70-6dfc-4015-8258-43d6e569aa85}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth">
      <UniqueIdentifier>{aaa54ab8-0b96-4aea-ac80-1c6d8b99db33}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow">
      <UniqueIdentifier>{493cc1c2-cf19-4f01-ba45-f67ce322f2a4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons">
      <UniqueIdentifier>{1f051e0c-294a-4e2a-ada8-ba670238c925}</UniqueIdentifier>
    </Filter>
    <Filter Include="MemoryPatterns\PatternTypes">
      <UniqueIdentifier>{0ebb425e-7ad9-482e-87e1-b2752da9f4a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon">
      <UniqueIdentifier>{fc66b76a-4e43-487c-bfab-8a725901e0f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon">
      <UniqueIdentifier>{e71a226e-32a1-4b79-9680-2035deb5cb49}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon">
      <UniqueIdentifier>{de68756a-3078-4f12-a335-d650318aa7da}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow">
      <UniqueIdentifier>{47384024-831e-4229-8068-9acea325ff0f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\PlayerModelGlow">
      <UniqueIdentifier>{a681c408-258d-4c5d-be1d-6b1d0202f9cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\WeaponModelGlow">
      <UniqueIdentifier>{2b885594-9008-4ffe-940f-f39deae620bc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\DroppedBombModelGlow">
      <UniqueIdentifier>{ab1b2ea3-e7a3-485d-820c-1a4985799676}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Common">
      <UniqueIdentifier>{514d588e-9075-46df-a4c7-7eab59b608ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\TickingBombModelGlow">
      <UniqueIdentifier>{ea04385e-4e37-4d1d-b6ac-d6ca160ee866}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\DefuseKitModelGlow">
      <UniqueIdentifier>{798917e9-2237-40b5-aed0-5bb6cbe417c5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\GrenadeProjectileModelGlow">
      <UniqueIdentifier>{82eb31ee-3f3f-44ea-8c75-0f9a591f78a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ModelGlow\Preview">
      <UniqueIdentifier>{34c6b5fe-cc1f-4d35-97f4-fa7228496d57}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient">
      <UniqueIdentifier>{6c819c21-9a6b-4492-bca3-e8e3128123ac}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\ConVars">
      <UniqueIdentifier>{5aed48bb-e1d1-4d60-815a-3ae885c1d1ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\Entities">
      <UniqueIdentifier>{574b797e-f5ef-47fe-9747-b268a82ec727}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\EntitySystem">
      <UniqueIdentifier>{f962b6df-d7ad-4ade-b2b8-80d1609e9985}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\Hud">
      <UniqueIdentifier>{a4991d7e-dbb1-4827-a7ab-0162141377af}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\Hud\BombStatus">
      <UniqueIdentifier>{46a02b7d-493f-4369-a52a-f62790248b13}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\Panorama">
      <UniqueIdentifier>{e249f930-0688-4e10-ab0e-39849dd73dc3}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\SceneSystem">
      <UniqueIdentifier>{49e92197-ff69-4f53-a239-082b2970ef81}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\WorldToScreen">
      <UniqueIdentifier>{d5b0dc97-9711-4ee8-95d8-8aa49b006817}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\DLLs">
      <UniqueIdentifier>{7257d8ed-91d1-47d9-a078-063c2664dfb3}</UniqueIdentifier>
    </Filter>
    <Filter Include="HookContext">
      <UniqueIdentifier>{64e2a5d8-cdec-4e92-88c3-d2be92a01410}</UniqueIdentifier>
    </Filter>
    <Filter Include="Config">
      <UniqueIdentifier>{5526912e-3dfb-467b-a785-3785aea27537}</UniqueIdentifier>
    </Filter>
    <Filter Include="UI\Panorama\Tabs">
      <UniqueIdentifier>{6429d97e-346b-4c1e-9e55-6cd200fbf6fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="UI\Panorama\Tabs\VisualsTab">
      <UniqueIdentifier>{1ee66c40-65ad-4c05-8631-2f3aa7159640}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Visuals\ViewmodelMod">
      <UniqueIdentifier>{63f981c9-ffe5-426e-8a58-569a43712e91}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Combat">
      <UniqueIdentifier>{a7e69fbf-3ca6-470a-abde-6380959510c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Combat\SniperRifles">
      <UniqueIdentifier>{4abe2bc9-1abb-4667-8119-82968a9df3d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis">
      <UniqueIdentifier>{41ddf56e-4385-4ce4-9df4-99654e07fac9}</UniqueIdentifier>
    </Filter>
    <Filter Include="CS2\Econ">
      <UniqueIdentifier>{d789bb17-c27a-4136-aee2-4543b073ba4e}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameClient\Econ">
      <UniqueIdentifier>{35bace02-0818-4944-bcb2-9e49c247e922}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Hud\BombPlantAlert">
      <UniqueIdentifier>{93348815-91fe-4209-910f-aba93d67345a}</UniqueIdentifier>
    </Filter>
    <Filter Include="EntryPoints">
      <UniqueIdentifier>{95ddae8d-0dcc-4c4c-a44b-04135f59fdc5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CS2\Classes\C_CSGameRules.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\ClientModeCSNormal.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CLoopModeGame.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Color.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CPlantedC4.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CUtlVector.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\GlobalVars.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\DllNames.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\EntityHandle.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\PanelIDs.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Hooks\PeepEventsHook.h">
      <Filter>Hooks</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\FreeMemoryRegion.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\FreeMemoryRegionList.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\MemoryAllocator.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\MemoryAllocatorBase.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\MemoryDeleter.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\UniquePtr.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\ClientPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\GameRulesPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanoramaImagePanelPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanoramaLabelPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanoramaUiEnginePatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanoramaUiPanelPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PlantedC4PatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\WindowsPatterns.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\CoTaskMemDeleter.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\PebLdr.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\PortableExecutable.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\UserDocumentsFolderPath.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\Win.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\WindowsDynamicLibrary.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\WindowsMessageBox.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\WindowsPlatformApi.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\DLLs\CombaseDll.h">
      <Filter>Platform\Windows\DLLs</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\DLLs\Shell32Dll.h">
      <Filter>Platform\Windows\DLLs</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Macros\CallingConventions.h">
      <Filter>Platform\Macros</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Macros\CallStack.h">
      <Filter>Platform\Macros</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Macros\IsPlatform.h">
      <Filter>Platform\Macros</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Macros\PlatformSpecific.h">
      <Filter>Platform\Macros</Filter>
    </ClInclude>
    <ClInclude Include="Platform\DynamicLibrary.h">
      <Filter>Platform</Filter>
    </ClInclude>
    <ClInclude Include="Platform\PlatformApi.h">
      <Filter>Platform</Filter>
    </ClInclude>
    <ClInclude Include="Platform\SimpleMessageBox.h">
      <Filter>Platform</Filter>
    </ClInclude>
    <ClInclude Include="Platform\TypeInfoPrecedingVmt.h">
      <Filter>Platform</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\PanoramaCommandDispatcher.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\PanoramaGUI.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\SetCommandHandler.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Align.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\CharUtils.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\FieldOffset.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\FlagsBuilder.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\GenericFunctionPointer.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\HexChars.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\ManuallyDestructible.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\MemorySection.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Pad.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\RefCountedHook.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\ReturnAddress.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\SpanSlice.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\StringBuilder.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\StringParser.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Verification\Verifier.h">
      <Filter>Verification</Filter>
    </ClInclude>
    <ClInclude Include="Verification\VerifyMacros.h">
      <Filter>Verification</Filter>
    </ClInclude>
    <ClInclude Include="Vmt\VmtCopy.h">
      <Filter>Vmt</Filter>
    </ClInclude>
    <ClInclude Include="Vmt\VmtLength.h">
      <Filter>Vmt</Filter>
    </ClInclude>
    <ClInclude Include="Vmt\VmtLengthCalculator.h">
      <Filter>Vmt</Filter>
    </ClInclude>
    <ClInclude Include="Vmt\VmtSwapper.h">
      <Filter>Vmt</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Macros\IsCompiler.h">
      <Filter>Platform\Macros</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Macros\FunctionAttributes.h">
      <Filter>Platform\Macros</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\BytePattern.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\BytePatternConverter.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\BytePatternLiteral.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\BytePatternStorage.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\HybridPatternFinder.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternFinder.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternFinderScalar.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternFinderSIMD.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="BuildConfig.h" />
    <ClInclude Include="CS2\Classes\IMemAlloc.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\MemAllocPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CViewRender.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\VMatrix.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Vector.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Hooks\ViewRenderHook.h">
      <Filter>Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Hooks\Hooks.h">
      <Filter>Hooks</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CUtlFilenameSymbolTable.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\FileSystem.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\FileSystemPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Sound.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SoundSystemPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\SoundNames.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\FootstepVisualizer.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\SoundFeatures.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="Utils\LazyInitialized.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\DynamicArray.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\BitFlags.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\BombPlantVisualizer.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanelPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Utils\TypeBitFlags.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\TypeIndex.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\BombBeepVisualizer.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\BombDefuseVisualizer.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\WeaponScopeVisualizer.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\AspectRatio.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternStringWildcard.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\RTTI\RttiCompleteObjectLocatorFinder.h">
      <Filter>Platform\Windows\RTTI</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\RTTI\RttiTypeDescriptor.h">
      <Filter>Platform\Windows\RTTI</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\RTTI\RttiTypeDescriptorFinder.h">
      <Filter>Platform\Windows\RTTI</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\RTTI\ToRvaConverter.h">
      <Filter>Platform\Windows\RTTI</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\RTTI\RttiCompleteObjectLocator.h">
      <Filter>Platform\Windows\RTTI</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanelStylePatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CUtlString.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CUtlMap.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\WindowsVmtFinder.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\WindowsVmtFinderParams.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\VmtFinder.h">
      <Filter>Platform</Filter>
    </ClInclude>
    <ClInclude Include="GlobalContext\FullGlobalContext.h">
      <Filter>GlobalContext</Filter>
    </ClInclude>
    <ClInclude Include="GlobalContext\GlobalContext.h">
      <Filter>GlobalContext</Filter>
    </ClInclude>
    <ClInclude Include="GlobalContext\PartialGlobalContext.h">
      <Filter>GlobalContext</Filter>
    </ClInclude>
    <ClInclude Include="Features\FeaturesStates.h">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\EntitySystem\CConcreteEntityList.h">
      <Filter>CS2\Classes\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityIdentity.h">
      <Filter>CS2\Classes\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityHandle.h">
      <Filter>CS2\Classes\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\EntitySystem\CGameEntitySystem.h">
      <Filter>CS2\Classes\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityIndex.h">
      <Filter>CS2\Classes\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\EntitySystemPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\Syscalls\SyscallParams.h">
      <Filter>Platform\Windows\Syscalls</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\BombBeepSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\BombDefuseSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\BombPlantSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\FootstepSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundVisualization.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundVisualizationFeature.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\WeaponReloadSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\WeaponScopeSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\WindowsPlatformApiImpl.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\Syscalls\WindowsSyscallIndex.h">
      <Filter>Platform\Windows\Syscalls</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\Syscalls\WindowsSyscalls.h">
      <Filter>Platform\Windows\Syscalls</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\FileSystem\WindowsFileSystem.h">
      <Filter>Platform\Windows\FileSystem</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\FileSystem\WindowsInputFile.h">
      <Filter>Platform\Windows\FileSystem</Filter>
    </ClInclude>
    <ClInclude Include="Platform\Windows\NtHandle.h">
      <Filter>Platform\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternSearchResult.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="SDL\SdlConstants.h">
      <Filter>SDL</Filter>
    </ClInclude>
    <ClInclude Include="SDL\SdlFunctions.h">
      <Filter>SDL</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SdlPatternWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="SDL\SdlDll.h">
      <Filter>SDL</Filter>
    </ClInclude>
    <ClInclude Include="Utils\GenericPointer.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\TopLevelWindowPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundVisualizationPanelFactory.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundVisualizationPanelProperties.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\WeaponReloadVisualizer.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\CCSPlayerController.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PlayerControllerPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\EntityPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CGameSceneNode.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\GameSceneNodePatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_BaseEntity.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_CSPlayerPawn.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\CEntityInstance.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\TeamNumberConstants.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PlayerPawnPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="GlobalContext\DeferredCompleteObject.h">
      <Filter>GlobalContext</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\WeaponServicesPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\WeaponVDataPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Utils\CString.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CCSPlayer_WeaponServices.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CCSWeaponBaseVData.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CEntitySubclassVDataBase.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\BytePatternView.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="Utils\ColorUtils.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\InRange.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\CvarPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CUtlLinkedList.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\ConVar.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CCvar.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\ConVarTypes.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\ConVarPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\LifeStateConstants.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\ColorConstants.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\VisualFeaturesStates.h">
      <Filter>Features\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CCSPlayer_HostageServices.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\HostageServicesPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\MemoryPatterns.h">
      <Filter>MemoryPatterns</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternFinders.h">
      <Filter>MemoryPatterns</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_CSWeaponBase.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\WeaponPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Utils\PrivateTag.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerPanel.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombSiteIconPanel.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerTextPanel.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerState.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerContext.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimer.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlert.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertPanel.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerCondition.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertContext.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertState.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingCountdownTextPanel.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\KillfeedPreserver\KillfeedPreserver.h">
      <Filter>Features\Hud\KillfeedPreserver</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\KillfeedPreserver\KillfeedPreserverContext.h">
      <Filter>Features\Hud\KillfeedPreserver</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\IconURLs.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertCondition.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\HudFeaturesStates.h">
      <Filter>Features\Hud</Filter>
    </ClInclude>
    <ClInclude Include="MemoryAllocation\MemoryAllocatorBaseImpl.h">
      <Filter>MemoryAllocation</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Lvalue.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Common\Visibility.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimer.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerCondition.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerContext.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerPanel.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerPanelFactory.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerState.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CImagePanel.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CLabel.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CPanel2D.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CPanelStyle.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CPanoramaSymbol.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CStyleSymbol.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CTopLevelWindow.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CUIEngine.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CUILength.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CUIPanel.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\PanelHandle.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\StyleEnums.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\StyleProperties.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\Transform3D.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerPanelFactory.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerPanelParams.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\PanoramaGuiState.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="OutlineGlow\GlowSceneObject.h">
      <Filter>OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="OutlineGlow\GlowSceneObjectPointer.h">
      <Filter>OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="OutlineGlow\GlowSceneObjects.h">
      <Filter>OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="OutlineGlow\GlowSceneObjectsState.h">
      <Filter>OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\RenderComponentPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CRenderComponent.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CSceneObject.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CSceneSystem.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Glow.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\SceneObjectUpdaterHandle_t.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\GlowSceneObjectPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SceneObjectUpdaterPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SceneSystemPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="OutlineGlow\GlowSceneObjectContext.h">
      <Filter>OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Optional.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\OutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\WeaponOutlineGlow\WeaponOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\WeaponOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\PlayerOutlineGlow\PlayerOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\PlayerOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\PlayerOutlineGlow\PlayerOutlineGlowColorType.h">
      <Filter>Features\Visuals\OutlineGlow\PlayerOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\WeaponEntities.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\CBaseAnimGraph.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\DefuseKitOutlineGlow\DefuseKitOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\DefuseKitOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_BaseCSGrenadeProjectile.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\GrenadeProjectiles.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\GrenadeProjectileOutlineGlow\GrenadeProjectileOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\GrenadeProjectileOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SmokeGrenadeProjectilePatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\DroppedBombOutlineGlow\DroppedBombOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\DroppedBombOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Utils\TypedStaticStringPool.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\StylePropertySymbolNames.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\StylePropertyTypeNames.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\TickingBombOutlineGlow\TickingBombOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\TickingBombOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\HostageOutlineGlow\HostageOutlineGlow.h">
      <Filter>Features\Visuals\OutlineGlow\HostageOutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_Hostage.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoContainerPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorld.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldCondition.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldPanelFactory.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldState.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo\ActiveWeaponAmmoPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo\PlayerActiveWeaponAmmoPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo\PlayerActiveWeaponAmmoPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\ActiveWeaponAmmo</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth\PlayerHealthPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerHealth</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth\PlayerHealthPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerHealth</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerHealth\PlayerHealthPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerHealth</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowColorType.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow\PlayerPositionArrowPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerPositionArrow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerStateIcons</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerStateIcons</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerStateIcons</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerStateIcons\PlayerStateIconsToShow.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerStateIcons</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelTypes.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\ClientPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\EntityPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\EntitySystemPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\GameRulesPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\GameSceneNodePatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\GlowSceneObjectPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\HostageServicesPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\MemAllocPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="Utils\TypeList.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternPool.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternSearchResults.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\CodePattern.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\CodePatternOperation.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\CvarPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\UiEnginePatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\UiPanelPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\TempPatternPool.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternPoolBuilder.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\ConVarPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\FileSystemPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PanelPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PanelStylePatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PanoramaImagePanelPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PanoramaLabelPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PlantedC4PatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PlayerControllerPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PlayerPawnPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\RenderComponentPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\SceneObjectPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\SceneObjectUpdaterPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\SceneSystemPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\SmokeGrenadeProjectilePatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\SoundSystemPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\TopLevelWindowPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\WeaponPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\WeaponServicesPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\WeaponVDataPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternPoolView.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternSearchResultsView.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Meta.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\StrongTypeAlias.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\C4PatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\C4PatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_BaseModelEntity.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CGlowProperty.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\BaseModelEntityPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\GlowPropertyPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\BaseModelEntityPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\GlowPropertyPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon\ActiveWeaponIconPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon\PlayerActiveWeaponIconPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon\PlayerActiveWeaponIconPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\ActiveWeaponIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon\PlayerBombIconPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon\PlayerBombIconPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\PlayerWeaponIconPanel.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\PlayerWeaponIconPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon\PlayerBombIconPanelParams.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\BombIcon</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon\PlayerWeaponIconPanelContext.h">
      <Filter>Features\Visuals\PlayerInfoInWorld\PlayerWeaponIcon</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\SceneObjectAttributeNames.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlow.h">
      <Filter>Features\Visuals\ModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowState.h">
      <Filter>Features\Visuals\ModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SceneObjectPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\PlayerModelGlow\PlayerModelGlow.h">
      <Filter>Features\Visuals\ModelGlow\PlayerModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\WeaponModelGlow\WeaponModelGlow.h">
      <Filter>Features\Visuals\ModelGlow\WeaponModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\DroppedBombModelGlow\DroppedBombModelGlow.h">
      <Filter>Features\Visuals\ModelGlow\DroppedBombModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\InWorldPanelIndex.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\InWorldPanelListEntry.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\InWorldPanels.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\InWorldPanelsPerHookState.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\InWorldPanelsState.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\SoundVisualizationPanelTypes.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\TickingBombModelGlow\TickingBombModelGlow.h">
      <Filter>Features\Visuals\ModelGlow\TickingBombModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\DefuseKitModelGlow\DefuseKitModelGlow.h">
      <Filter>Features\Visuals\ModelGlow\DefuseKitModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCache.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCacheEntry.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCachePerHookState.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoPanelCacheState.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\GrenadeProjectileModelGlow\GrenadeProjectileModelGlow.h">
      <Filter>Features\Visuals\ModelGlow\GrenadeProjectileModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowParams.h">
      <Filter>Features\Visuals\ModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Utils\OptionalPointee.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\OutlineGlowParams.h">
      <Filter>Features\Visuals\OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Utils\FieldFieldOffset.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\EntityClasses.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\EntitySystem\CEntityClass.h">
      <Filter>CS2\Classes\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PanoramaDropDownPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CDropDown.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\VisualsTab.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\HudTab.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\SoundTab.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertPanelParams.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_CSGO_PreviewPlayer.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\BaseEntityForModelGlowPreview.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerControllerForModelGlowPreview.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreview.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreviewColorMode.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreviewParams.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerModelGlowPreviewState.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\PlayerPawnForModelGlowPreview.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PortraitWorldPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="GlobalContext\UnloadFlag.h">
      <Filter>GlobalContext</Filter>
    </ClInclude>
    <ClInclude Include="MemorySearch\PatternNotFoundLogger.h">
      <Filter>MemorySearch</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Bits.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\FeatureToggle.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Common\RenderingHookEntityLoop.h">
      <Filter>Features\Common</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\PlayedSound.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundExpiryChecker.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundWatcher.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundWatcherImpl.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundWatcherImplState.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\SoundWatcherState.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\Details\WatchedSounds.h">
      <Filter>Features\Sound\Details</Filter>
    </ClInclude>
    <ClInclude Include="Utils\FileSlice.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\ConVars\ConVarsBase.h">
      <Filter>GameClient\ConVars</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\BaseEntity.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\BaseModelEntity.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\BaseWeapon.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\C4.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\EntityClassifier.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\GameRules.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\GlowProperty.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\HostageServices.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\LifeState.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\PlantedC4.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\PlayerController.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\PlayerPawn.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\PlayerWeapons.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\PreviewPlayer.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\RenderComponent.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\SmokeGrenadeProjectile.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\TeamNumber.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\WeaponServices.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\EntitySystem\EntityIdentity.h">
      <Filter>GameClient\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\EntitySystem\EntitySystem.h">
      <Filter>GameClient\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\DeathNotice.h">
      <Filter>GameClient\Hud</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\DeathNoticeContext.h">
      <Filter>GameClient\Hud</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\DeathNotices.h">
      <Filter>GameClient\Hud</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\Hud.h">
      <Filter>GameClient\Hud</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\HudContext.h">
      <Filter>GameClient\Hud</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanel.h">
      <Filter>GameClient\Hud\BombStatus</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelContext.h">
      <Filter>GameClient\Hud\BombStatus</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelManager.h">
      <Filter>GameClient\Hud\BombStatus</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelManagerContext.h">
      <Filter>GameClient\Hud\BombStatus</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\BombStatus\BombStatusPanelState.h">
      <Filter>GameClient\Hud\BombStatus</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\ClientPanel.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelAlignmentParams.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelFactory.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelFontParams.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelHandle.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelMarginParams.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelShadowParams.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanelStylePropertyFactory.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaDropDown.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaLabel.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaSymbols.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaTransformations.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaTransformFactory.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaUiEngine.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanel.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelChildPanels.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelClasses.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelIterator.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\PanoramaUiPanelMethodInvoker.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\StylePropertiesSymbolsAndVMTs.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\StylePropertySymbolMap.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\TopLevelWindow.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\SceneSystem\SceneObject.h">
      <Filter>GameClient\SceneSystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\SceneSystem\SceneObjectAttributes.h">
      <Filter>GameClient\SceneSystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\SceneSystem\SceneObjectUpdater.h">
      <Filter>GameClient\SceneSystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\SceneSystem\SceneObjectUpdaters.h">
      <Filter>GameClient\SceneSystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\SceneSystem\SceneSystem.h">
      <Filter>GameClient\SceneSystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\WorldToScreen\ClipSpaceCoordinates.h">
      <Filter>GameClient\WorldToScreen</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\WorldToScreen\NormalizedDeviceCoordinates.h">
      <Filter>GameClient\WorldToScreen</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\WorldToScreen\ViewToProjectionMatrix.h">
      <Filter>GameClient\WorldToScreen</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\WorldToScreen\WorldToClipSpaceConverter.h">
      <Filter>GameClient\WorldToScreen</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\FileNameSymbolTable.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\FileSystem.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\GameSceneNode.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\GlobalVars.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\MemAlloc.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\DLLs\Tier0Dll.h">
      <Filter>GameClient\DLLs</Filter>
    </ClInclude>
    <ClInclude Include="OutlineGlow\GlowSceneObjectState.h">
      <Filter>OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Hud\HudState.h">
      <Filter>GameClient\Hud</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\MemAllocState.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\FileNameSymbolTableState.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="HookContext\HookContext.h">
      <Filter>HookContext</Filter>
    </ClInclude>
    <ClInclude Include="Config\Config.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigFileOperation.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigParams.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigState.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigFromString.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigSchema.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigStringConversionState.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigToString.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="GlobalContext\OsirisDirectoryPath.h">
      <Filter>GlobalContext</Filter>
    </ClInclude>
    <ClInclude Include="Platform\PlatformPath.h">
      <Filter>Platform</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Wcslen.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\PlayerInfoInWorld\PlayerInfoInWorldConfigVariables.h">
      <Filter>Features\Visuals\PlayerInfoInWorld</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigVariables.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigVariable.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigVariableChangeHandler.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Config\ConfigVariableTypes.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombTimer\BombTimerConfigVariables.h">
      <Filter>Features\Hud\BombTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\DefusingAlert\DefusingAlertConfigVariables.h">
      <Filter>Features\Hud\DefusingAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\KillfeedPreserver\KillfeedPreserverConfigVariables.h">
      <Filter>Features\Hud\KillfeedPreserver</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerConfigVariables.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\PostRoundTimer\PostRoundTimerPanelParams.h">
      <Filter>Features\Hud\PostRoundTimer</Filter>
    </ClInclude>
    <ClInclude Include="Features\Sound\SoundVisualizationConfigVariables.h">
      <Filter>Features\Sound</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowConfigVariables.h">
      <Filter>Features\Visuals\ModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\OutlineGlow\OutlineGlowConfigVariables.h">
      <Filter>Features\Visuals\OutlineGlow</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\WeaponModelGlowPreview.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\WeaponModelGlowPreviewState.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\Ui3dPanel.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\Preview\EnemyTeam.h">
      <Filter>Features\Visuals\ModelGlow\Preview</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CSlider.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\SliderPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\SliderPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\Slider.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CTextEntry.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\TextEntry.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\TextEntryPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\TextEntryPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="Utils\IdentityMacro.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CUI_3dPanel.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CCS_PortraitWorld.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\Ui3dPanelPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\PortraitWorld.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Panorama\CUI_Item3dPanel.h">
      <Filter>CS2\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\EntitySystem\EntityHandle.h">
      <Filter>GameClient\EntitySystem</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\UiItem3dPanel.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PanoramaDropDownPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PortraitWorldPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\Ui3dPanelPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\UiItem3dPanelPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\UiItem3dPanelPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\AllMemoryPatternSearchResults.h">
      <Filter>MemoryPatterns</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\GlobalVarsPatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\GlobalVarsPatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\ConVars\CvarSystem.h">
      <Filter>GameClient\ConVars</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\HueSlider.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\IntSlider.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\ViewmodelModPreviewPanel.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="Hooks\ClientModeHooks.h">
      <Filter>Hooks</Filter>
    </ClInclude>
    <ClInclude Include="HookContext\HookContextMacros.h">
      <Filter>HookContext</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\ConVars\ConVarTypes.h">
      <Filter>GameClient\ConVars</Filter>
    </ClInclude>
    <ClInclude Include="Config\RangeConstrainedVariableParams.h">
      <Filter>Config</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ViewmodelMod\ViewmodelMod.h">
      <Filter>Features\Visuals\ViewmodelMod</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ViewmodelMod\ViewmodelModConfigVariables.h">
      <Filter>Features\Visuals\ViewmodelMod</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ViewmodelMod\ViewmodelModParams.h">
      <Filter>Features\Visuals\ViewmodelMod</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\ViewmodelModPreviewPanelState.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\CrosshairColorIndex.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVis.h">
      <Filter>Features\Combat\SniperRifles\NoScopeInaccuracyVis</Filter>
    </ClInclude>
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVisConfigVariables.h">
      <Filter>Features\Combat\SniperRifles\NoScopeInaccuracyVis</Filter>
    </ClInclude>
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVisParams.h">
      <Filter>Features\Combat\SniperRifles\NoScopeInaccuracyVis</Filter>
    </ClInclude>
    <ClInclude Include="Features\Combat\SniperRifles\NoScopeInaccuracyVis\NoScopeInaccuracyVisState.h">
      <Filter>Features\Combat\SniperRifles\NoScopeInaccuracyVis</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Crosshair.h">
      <Filter>GameClient</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\CombatTab.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Econ\ItemDefinitionIndex.h">
      <Filter>CS2\Econ</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Econ\ItemId.h">
      <Filter>CS2\Econ</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Econ\PaintKitIndex.h">
      <Filter>CS2\Econ</Filter>
    </ClInclude>
    <ClInclude Include="Utils\ToUnderlying.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Econ\FauxItemId.h">
      <Filter>GameClient\Econ</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\Entities\C_CSPlayerResource.h">
      <Filter>CS2\Classes\Entities</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\BombsiteIndex.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Entities\PlayerResource.h">
      <Filter>GameClient\Entities</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\PatternTypes\PlayerResourcePatternTypes.h">
      <Filter>MemoryPatterns\PatternTypes</Filter>
    </ClInclude>
    <ClInclude Include="MemoryPatterns\Windows\PlayerResourcePatternsWindows.h">
      <Filter>MemoryPatterns\Windows</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Constants\RoundWinStatus.h">
      <Filter>CS2\Constants</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlert.h">
      <Filter>Features\Hud\BombPlantAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertConfigVariables.h">
      <Filter>Features\Hud\BombPlantAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertPanelFactory.h">
      <Filter>Features\Hud\BombPlantAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertPanelParams.h">
      <Filter>Features\Hud\BombPlantAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertParams.h">
      <Filter>Features\Hud\BombPlantAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Hud\BombPlantAlert\BombPlantAlertState.h">
      <Filter>Features\Hud\BombPlantAlert</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ModelGlow\ModelGlowDeactivationFlags.h">
      <Filter>Features\Visuals\ModelGlow</Filter>
    </ClInclude>
    <ClInclude Include="Utils\EnumFlags.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="GameClient\Panorama\ImagePanel.h">
      <Filter>GameClient\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="CS2\Classes\CUtlAbstractDelegate.h">
      <Filter>CS2\Classes</Filter>
    </ClInclude>
    <ClInclude Include="EntryPoints\GuiEntryPoints.h">
      <Filter>EntryPoints</Filter>
    </ClInclude>
    <ClInclude Include="Utils\TemplateParameterCstring.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="EntryPoints\EntryPoints.h">
      <Filter>EntryPoints</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\OnOffDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerInfoInWorldDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerModelGlowColorModeDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerModelGlowDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerOutlineGlowColorModeDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
    <ClInclude Include="UI\Panorama\Tabs\VisualsTab\PlayerOutlineGlowDropdownSelectionChangeHandler.h">
      <Filter>UI\Panorama\Tabs\VisualsTab</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="UI\Panorama\CreateGUI.js">
      <Filter>UI\Panorama</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="Platform\Windows\CRTWindows.cpp">
      <Filter>Platform\Windows</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Platform\Windows\Syscalls\WindowsSyscall.asm">
      <Filter>Platform\Windows\Syscalls</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Source/OutlineGlow/GlowSceneObject.h`:

```h
#pragma once

#include <utility>

#include <CS2/Classes/Color.h>
#include "GlowSceneObjectContext.h"

template <typename HookContext, typename Context = GlowSceneObjectContext<HookContext>>
class GlowSceneObject {
public:
    template <typename... Args>
    GlowSceneObject(Args&&... args) noexcept
        : context{std::forward<Args>(args)...}
    {
    }

    [[nodiscard]] decltype(auto) baseSceneObject() const noexcept
    {
        return context.baseSceneObject();
    }

    void apply(auto&& sceneObject, cs2::Color color, int glowRange = 0) const noexcept
    {
        context.applyGlow(sceneObject, color, glowRange);
        storeGlowSceneObjectClass();
    }

    void setGlowEntity(auto&& entity) const noexcept
    {
        context.glowEntity() = entity;
    }

    [[nodiscard]] decltype(auto) getAttachedSceneObject() const noexcept
    {
        return context.attachedSceneObject().valueOr(nullptr);
    }

    [[nodiscard]] auto isValidGlowSceneObject() const noexcept
    {
        return baseSceneObject().objectClass().equal(context.storedGlowSceneObjectClass());
    }

private:
    void storeGlowSceneObjectClass() const noexcept
    {
        if (auto& storedGlowSceneObjectClass = context.storedGlowSceneObjectClass(); storedGlowSceneObjectClass == 0xFF) {
            if (const auto objectClass = baseSceneObject().objectClass(); objectClass.hasValue())
                storedGlowSceneObjectClass = objectClass.value();
        }
    }

    Context context;
};

```

`Source/OutlineGlow/GlowSceneObjectContext.h`:

```h
#pragma once

#include <cstring>

#include <CS2/Classes/Color.h>
#include <CS2/Classes/Glow.h>
#include <GameClient/SceneSystem/SceneObject.h>
#include <MemoryPatterns/PatternTypes/ClientPatternTypes.h>
#include <MemoryPatterns/PatternTypes/GlowSceneObjectPatternTypes.h>
#include <Platform/Macros/IsPlatform.h>

#include "GlowSceneObjectPointer.h"

template <typename HookContext>
class GlowSceneObjectContext {
public:
    GlowSceneObjectContext(HookContext& hookContext, GlowSceneObjectPointer* glowSceneObjectPointer) noexcept
        : hookContext{hookContext}
        , glowSceneObjectPointer{glowSceneObjectPointer}
    {
    }

    [[nodiscard]] decltype(auto) baseSceneObject() const noexcept
    {
        return hookContext.template make<SceneObject>(glowSceneObject());
    }

    void applyGlow(auto&& sceneObject, cs2::Color color, int glowRange) const noexcept
    {
        if (!sceneObject || !glowSceneObjectPointer)
            return;

        if (const auto manageGlowSceneObject = hookContext.patternSearchResults().template get<ManageGlowSceneObjectPointer>()) {
            cs2::CGlowHelperSceneObject* tempGlowSceneObject{glowSceneObject()};
            cs2::CGlowHelperSceneObject* dummy{nullptr};
            float colorFloat[4]{color.r() / 255.0f, color.g() / 255.0f, color.b() / 255.0f, color.a() / 255.0f};

#if IS_WIN64()
            manageGlowSceneObject(&tempGlowSceneObject, &dummy, sceneObject, colorFloat, 0, static_cast<float>(glowRange), 3, 1.0f);
#elif IS_LINUX()
            double colorDouble[2];
            static_assert(sizeof(colorFloat) == sizeof(colorDouble));
            std::memcpy(colorDouble, colorFloat, sizeof(colorFloat));
            manageGlowSceneObject(&tempGlowSceneObject, &dummy, sceneObject, 3, colorDouble[0], colorDouble[1], 0.0f, static_cast<float>(glowRange), 1.0f);
#endif
            glowSceneObjectPointer->setValue(tempGlowSceneObject);
        }
    }

    [[nodiscard]] decltype(auto) glowEntity() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToGlowSceneObjectEntity>().of(glowSceneObject());
    }

    [[nodiscard]] decltype(auto) attachedSceneObject() const noexcept
    {
        return hookContext.patternSearchResults().template get<OffsetToGlowSceneObjectAttachedSceneObject>().of(glowSceneObject());
    }

    [[nodiscard]] auto& storedGlowSceneObjectClass() const noexcept
    {
        return hookContext.glowSceneObjectState().glowSceneObjectClass;
    }

private:
    [[nodiscard]] cs2::CGlowHelperSceneObject* glowSceneObject() const noexcept
    {
        if (glowSceneObjectPointer)
            return glowSceneObjectPointer->value();
        return nullptr;
    }

    HookContext& hookContext;
    GlowSceneObjectPointer* glowSceneObjectPointer;
};

```

`Source/OutlineGlow/GlowSceneObjectPointer.h`:

```h
#pragma once

#include <cassert>
#include <cstdint>

#include <CS2/Classes/Glow.h>

class GlowSceneObjectPointer {
public:
    explicit(false) GlowSceneObjectPointer(cs2::CGlowHelperSceneObject* pointer) noexcept
        : pointer{pointer}
    {
        assert(tagBit(pointer) == 0);
    }

    [[nodiscard]] auto value() const noexcept
    {
        return untaggedPointer();
    }

    void setValue(cs2::CGlowHelperSceneObject* newPointer) noexcept
    {
        assert(tagBit(newPointer) == 0);
        pointer = toPointer(toAddress(newPointer) | tagBit(pointer));
    }

    [[nodiscard]] bool isReferenced() const noexcept
    {
        return tagBit(pointer) != 0;
    }

    void markReferenced() noexcept
    {
        pointer = taggedPointer();
    }

    void clearReferenced() noexcept
    {
        pointer = untaggedPointer();
    }

private:
    [[nodiscard]] cs2::CGlowHelperSceneObject* taggedPointer() const noexcept
    {
        return toPointer(toAddress(pointer) | 1);
    }

    [[nodiscard]] cs2::CGlowHelperSceneObject* untaggedPointer() const noexcept
    {
        return toPointer(toAddress(pointer) & ~1);
    }

    [[nodiscard]] static cs2::CGlowHelperSceneObject* toPointer(std::uintptr_t address) noexcept
    {
        return reinterpret_cast<cs2::CGlowHelperSceneObject*>(address);
    }

    [[nodiscard]] static std::uintptr_t toAddress(cs2::CGlowHelperSceneObject* pointer) noexcept
    {
        return reinterpret_cast<std::uintptr_t>(pointer);
    }

    [[nodiscard]] static int tagBit(cs2::CGlowHelperSceneObject* pointer) noexcept
    {
        return toAddress(pointer) & 1;
    }

    cs2::CGlowHelperSceneObject* pointer;
};

```

`Source/OutlineGlow/GlowSceneObjectState.h`:

```h
#pragma once

#include <CS2/Classes/CSceneObject.h>

struct GlowSceneObjectState {
    cs2::CSceneObject::m_nObjectClass glowSceneObjectClass{0xFF};
};

```

`Source/OutlineGlow/GlowSceneObjects.h`:

```h
#pragma once

#include <cstring>

#include <CS2/Classes/CSceneObject.h>
#include <GameClient/SceneSystem/SceneSystem.h>
#include <MemoryAllocation/MemoryAllocator.h>

#include "GlowSceneObject.h"
#include "GlowSceneObjectPointer.h"
#include "GlowSceneObjectsState.h"

template <typename HookContext>
class GlowSceneObjects {
public:
    explicit GlowSceneObjects(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    [[nodiscard]] decltype(auto) getGlowSceneObject(cs2::CSceneObject* sceneObject) const noexcept
    {
        return hookContext.template make<GlowSceneObject>(glowSceneObjectByIndex(findOrInsertGlowSceneObject(sceneObject)));
    }

    void removeUnreferencedObjects() const noexcept
    {
        auto writeIndex = findFirstUnreferencedObject();
        for (auto readIndex = writeIndex; readIndex < state().size; ++readIndex) {
            auto sceneObjectPointer = state().glowSceneObjects[readIndex];
            if (!sceneObjectPointer.isReferenced()) {
                deleteSceneObject(hookContext.template make<GlowSceneObject>(&sceneObjectPointer));
            } else {
                sceneObjectPointer.clearReferenced();
                state().glowSceneObjects[writeIndex] = sceneObjectPointer;
                ++writeIndex;
            }
        }

        if (writeIndex < state().size)
            state().size = writeIndex;
    }

    void clearObjects() const noexcept
    {
        for (GlowSceneObjectsState::SizeType i = 0; i < state().size; ++i)
            deleteSceneObject(hookContext.template make<GlowSceneObject>(&state().glowSceneObjects[i]));

        state().size = 0;

        if (state().capacity > 0) {
            MemoryAllocator<GlowSceneObjectPointer[]>::deallocate(state().glowSceneObjects, state().capacity);
            state().capacity = 0;
        }
    }

private:
    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.glowSceneObjectsState();
    }

    [[nodiscard]] GlowSceneObjectPointer* glowSceneObjectByIndex(GlowSceneObjectsState::SizeType index) const noexcept
    {
        if (index < state().size) {
            auto& glowSceneObjectPointer = state().glowSceneObjects[index];
            glowSceneObjectPointer.markReferenced();
            return &glowSceneObjectPointer;
        }
        return nullptr;
    }

    [[nodiscard]] auto findOrInsertGlowSceneObject(cs2::CSceneObject* sceneObject) const noexcept
    {
        if (const auto index = findAttachedSceneObject(sceneObject); index != GlowSceneObjectsState::kInvalidIndex)
            return index;
        return insertGlowSceneObject();
    }

    [[nodiscard]] auto findAttachedSceneObject(cs2::CSceneObject* sceneObject) const noexcept
    {
        for (GlowSceneObjectsState::SizeType i = 0; i < state().size; ++i) {
            if (hookContext.template make<GlowSceneObject>(&state().glowSceneObjects[i]).getAttachedSceneObject() == sceneObject)
                return i;
        }
        return GlowSceneObjectsState::kInvalidIndex;
    }

    [[nodiscard]] auto insertGlowSceneObject() const noexcept
    {
        if (state().size < state().capacity) {
            const auto index = state().size;
            state().glowSceneObjects[index] = nullptr;
            ++state().size;
            return index;
        } else {
            const auto newCapacity = static_cast<GlowSceneObjectsState::SizeType>(state().capacity + 10);
            const auto newGlowSceneObjects = reinterpret_cast<GlowSceneObjectPointer*>(MemoryAllocator<GlowSceneObjectPointer[]>::allocate(newCapacity));
            if (newGlowSceneObjects) {
                if (state().size > 0)
                    std::memcpy(newGlowSceneObjects, state().glowSceneObjects, state().size * sizeof(GlowSceneObjectPointer));

                if (state().capacity > 0)
                    MemoryAllocator<GlowSceneObjectPointer[]>::deallocate(state().glowSceneObjects, state().capacity);

                state().capacity = newCapacity;
                state().glowSceneObjects = newGlowSceneObjects;
                const auto index = state().size;
                state().glowSceneObjects[index] = nullptr;
                ++state().size;
                return index;
            }
        }
        return GlowSceneObjectsState::kInvalidIndex;
    }

    [[nodiscard]] auto findFirstUnreferencedObject() const noexcept
    {
        for (GlowSceneObjectsState::SizeType i = 0; i < state().size; ++i) {
            if (auto& sceneObjectPointer = state().glowSceneObjects[i]; sceneObjectPointer.isReferenced())
                sceneObjectPointer.clearReferenced();
            else
                return i;
        }
        return GlowSceneObjectsState::kInvalidIndex;
    }

    void deleteSceneObject(auto&& glowSceneObject) const noexcept
    {
        if (glowSceneObject.isValidGlowSceneObject().valueOr(true))
            hookContext.template make<SceneSystem>().deleteSceneObject(glowSceneObject.baseSceneObject());
    }

    HookContext& hookContext;
};

```

`Source/OutlineGlow/GlowSceneObjectsState.h`:

```h
#pragma once

#include <cstdint>

#include "GlowSceneObjectPointer.h"

struct GlowSceneObjectsState {
    using SizeType = std::uint16_t;
    static constexpr auto kInvalidIndex = static_cast<SizeType>(-1);

    GlowSceneObjectPointer* glowSceneObjects{nullptr};
    SizeType size{0};
    SizeType capacity{0};
};

```

`Source/Platform/DynamicLibrary.h`:

```h
#pragma once

#include "Macros/IsPlatform.h"

#if IS_WIN64()

#include "Windows/WindowsDynamicLibrary.h"

using DynamicLibrary = WindowsDynamicLibrary;

#elif IS_LINUX()

#include "Linux/LinuxDynamicLibrary.h"

using DynamicLibrary = LinuxDynamicLibrary;

#endif

```

`Source/Platform/Linux/FileSystem/FileDescriptor.h`:

```h
#pragma once

#include <Platform/Linux/LinuxPlatformApi.h>

struct FileDescriptor {
    explicit FileDescriptor(int fileDescriptor) noexcept
        : fileDescriptor{fileDescriptor}
    {
    }

    FileDescriptor(const FileDescriptor&) = delete;
    FileDescriptor(FileDescriptor&&) = delete;
    FileDescriptor& operator=(const FileDescriptor&) = delete;
    FileDescriptor& operator=(FileDescriptor&&) = delete;

    [[nodiscard]] int get() const noexcept
    {
        return fileDescriptor;
    }

    [[nodiscard]] bool isValid() const noexcept
    {
        return fileDescriptor >= 0;
    }

    ~FileDescriptor() noexcept
    {
        if (isValid())
            LinuxPlatformApi::close(fileDescriptor);
    }

private:
    int fileDescriptor;
};

```

`Source/Platform/Linux/FileSystem/LinuxInputFile.h`:

```h
#pragma once

#include <cstddef>
#include <span>

#include "FileDescriptor.h"
#include <Platform/Linux/LinuxPlatformApi.h>

struct LinuxInputFile {
    explicit LinuxInputFile(const char* path) noexcept
        : fileDescriptor{LinuxPlatformApi::open(path, O_RDONLY)}
    {
    }

    [[nodiscard]] std::size_t read(std::size_t fileOffset, std::span<std::byte> buffer) const noexcept
    {
        const auto readBytes{LinuxPlatformApi::pread(fileDescriptor.get(), buffer.data(), buffer.size(), fileOffset)};
        if (readBytes > 0)
            return readBytes;
        return 0;
    }

private:
    FileDescriptor fileDescriptor;
};

```

`Source/Platform/Linux/LinuxDynamicLibrary.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <span>

#include <dlfcn.h>
#include <elf.h>
#include <fcntl.h>
#include <link.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <Platform/Macros/FunctionAttributes.h>
#include <Utils/GenericPointer.h>
#include <Utils/MemorySection.h>

#include "LinuxPlatformApi.h"
#include "LinuxVmtFinderParams.h"

class LinuxDynamicLibrary {
public:
    LinuxDynamicLibrary(const char* libraryName)
        : handle{ getModuleHandle(libraryName) } {}

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return handle != nullptr;
    }

    [[nodiscard]] GenericPointer getFunctionAddress(const char* functionName) const noexcept
    {
        if (handle)
            return LinuxPlatformApi::dlsym(handle, functionName);
        return {};
    }

    [[nodiscard]] link_map* getLinkMap() const noexcept
    {
        link_map* map = nullptr;
        if (handle)
            LinuxPlatformApi::dlinfo(handle, RTLD_DI_LINKMAP, &map);
        return map;
    }

    [[nodiscard]] MemorySection getCodeSection() const noexcept
    {
        return getSection(".text");
    }

    [[nodiscard]] MemorySection getVmtSection() const noexcept
    {
        return getSection(".data.rel.ro");
    }

    [[nodiscard]] LinuxVmtFinderParams getVmtFinderParams() const noexcept
    {
        return {getSection(".rodata"), getSection(".data.rel.ro")};
    }

private:
    [[nodiscard]] [[NOINLINE]] MemorySection getSection(const char* sectionName) const noexcept
    {
        void* base = nullptr;
        std::size_t size = 0;

        const auto linkMap = getLinkMap();
        if (linkMap) {
            if (const auto fd = LinuxPlatformApi::open(linkMap->l_name, O_RDONLY); fd >= 0) {
                if (struct stat st; LinuxPlatformApi::fstat(fd, &st) == 0) {
                    if (const auto map = LinuxPlatformApi::mmap(nullptr, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0); map != MAP_FAILED) {
                        const auto ehdr = (ElfW(Ehdr)*)map;
                        const auto shdrs = (ElfW(Shdr)*)(std::uintptr_t(ehdr) + ehdr->e_shoff);
                        const auto strTab = (const char*)(std::uintptr_t(ehdr) + shdrs[ehdr->e_shstrndx].sh_offset);

                        for (auto i = 0; i < ehdr->e_shnum; ++i) {
                            const auto shdr = (ElfW(Shdr)*)(std::uintptr_t(shdrs) + i * ehdr->e_shentsize);

                            if (std::strcmp(strTab + shdr->sh_name, sectionName) != 0)
                                continue;

                            base = (void*)(linkMap->l_addr + shdr->sh_addr);
                            size = shdr->sh_size;
                            LinuxPlatformApi::munmap(map, st.st_size);
                            LinuxPlatformApi::close(fd);
                            break;
                        }
                        LinuxPlatformApi::munmap(map, st.st_size);
                    }
                }
                LinuxPlatformApi::close(fd);
            }
        }
        return MemorySection{ std::span{ reinterpret_cast<const std::byte*>(base), size } };
    }

    [[nodiscard]] void* getModuleHandle(const char* libraryName)
    {
        const auto handle = LinuxPlatformApi::dlopen(libraryName, RTLD_LAZY | RTLD_NOLOAD);
        if (handle)
            LinuxPlatformApi::dlclose(handle);
        return handle;
    }

    void* handle = nullptr;
};

```

`Source/Platform/Linux/LinuxMessageBox.h`:

```h
#pragma once

#include <SDL/SdlConstants.h>
#include <SDL/SdlDll.h>
#include <SDL/SdlFunctions.h>

class LinuxMessageBox {
public:
    void showWarning(const char* title, const char* message) const noexcept
    {
        showMessageBox(title, message, sdl3::SDL_MESSAGEBOX_WARNING);
    }

    void showError(const char* title, const char* message) const noexcept
    {
        showMessageBox(title, message, sdl3::SDL_MESSAGEBOX_ERROR);
    }

private:
    void showMessageBox(const char* title, const char* message, unsigned int flags) const noexcept
    {
        if (showSimpleMessageBox)
            showSimpleMessageBox(flags, title, message, nullptr);
    }

    sdl3::SDL_ShowSimpleMessageBox* showSimpleMessageBox{SdlDll{}.showSimpleMessageBox()};
};

```

`Source/Platform/Linux/LinuxPlatformApi.h`:

```h
#pragma once

#include <dlfcn.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

struct LinuxPlatformApi {
    static void* dlopen(const char* file, int mode) noexcept;
    static void* dlsym(void* handle, const char* name) noexcept;
    static int dlclose(void* handle) noexcept;
    static int dlinfo(void* handle, int request, void* info) noexcept;

    static int open(const char* pathname, int flags, mode_t mode = 0777) noexcept;
    static ssize_t pread(int fd, void* buf, size_t count, off_t offset) noexcept;
    static ssize_t write(int fd, const void* buf, size_t count) noexcept;
    static int close(int fd) noexcept;
    static int fstat(int fd, struct stat* buf) noexcept;

    static void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) noexcept;
    static int munmap(void* addr, size_t length) noexcept;

    static void debugBreak() noexcept;

    static char* getenv(const char* name) noexcept;
};

```

`Source/Platform/Linux/LinuxPlatformApiImpl.h`:

```h
#pragma once

#include <dlfcn.h>
#include <link.h>
#include <signal.h>
#include <sys/mman.h>
#include <stdlib.h>

#include "LinuxPlatformApi.h"

void* LinuxPlatformApi::dlopen(const char* file, int mode) noexcept
{
    return ::dlopen(file, mode);
}

void* LinuxPlatformApi::dlsym(void* handle, const char* name) noexcept
{
    return ::dlsym(handle, name);
}

int LinuxPlatformApi::dlclose(void* handle) noexcept
{
    return ::dlclose(handle);
}

int LinuxPlatformApi::dlinfo(void* handle, int request, void* info) noexcept
{
    return ::dlinfo(handle, request, info);
}

int LinuxPlatformApi::open(const char* pathname, int flags, mode_t mode) noexcept
{
    return ::open(pathname, flags, mode);
}

ssize_t LinuxPlatformApi::pread(int fd, void* buf, size_t count, off_t offset) noexcept
{
    return ::pread(fd, buf, count, offset);
}

ssize_t LinuxPlatformApi::write(int fd, const void* buf, size_t count) noexcept
{
    return ::write(fd, buf, count);
}

int LinuxPlatformApi::close(int fd) noexcept
{
    return ::close(fd);
}

int LinuxPlatformApi::fstat(int fd, struct stat* buf) noexcept
{
    return ::fstat(fd, buf);
}

void* LinuxPlatformApi::mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) noexcept
{
    return ::mmap(addr, length, prot, flags, fd, offset);
}

int LinuxPlatformApi::munmap(void* addr, size_t length) noexcept
{
    return ::munmap(addr, length);
}

void LinuxPlatformApi::debugBreak() noexcept
{
    (void)raise(SIGTRAP);
}

char* LinuxPlatformApi::getenv(const char* name) noexcept
{
    return ::getenv(name);
}

```

`Source/Platform/Linux/LinuxVmt.h`:

```h
#pragma once

struct LinuxVmt {
    static constexpr auto offsetOfOffsetFromTop{0};
    static constexpr auto offsetOfTypeDescriptorPointer{8};
    static constexpr auto offsetOfFirstMethodPointer{16};
};

```

`Source/Platform/Linux/LinuxVmtFinder.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <string_view>

#include <MemorySearch/BytePattern.h>
#include <MemorySearch/HybridPatternFinder.h>
#include <Utils/MemorySection.h>

#include "RTTI/LinuxRttiTypeDescriptor.h"
#include "RTTI/LinuxRttiTypeDescriptorFinder.h"

#include "LinuxVmt.h"
#include "LinuxVmtFinderParams.h"

class LinuxVmtFinder {
public:
    LinuxVmtFinder(const LinuxVmtFinderParams& params) noexcept
        : rodataSection{params.rodataSection}
        , dataRelRoSection{params.dataRelRoSection}
    {
    }

    [[nodiscard]] const void* findVmt(std::string_view mangledTypeName) const noexcept
    {
        const auto typeDescriptor{findTypeDescriptor(mangledTypeName)};
        if (!typeDescriptor) {
            assert(typeDescriptor != nullptr && "Failed to find type descriptor!");
            return nullptr;
        }

        HybridPatternFinder typeDescriptorCrossReferenceFinder{dataRelRoSection.raw(), BytePattern::ofObject(typeDescriptor)};

        auto typeDescriptorReference{typeDescriptorCrossReferenceFinder.findNextOccurrence()};
        while (typeDescriptorReference && (!canPrecedeVmt(reinterpret_cast<std::uintptr_t>(typeDescriptorReference)) || !isPrecedingVmtOfCompleteClass(typeDescriptorReference)))
            typeDescriptorReference = typeDescriptorCrossReferenceFinder.findNextOccurrence();

        if (typeDescriptorReference)
            return typeDescriptorReference - LinuxVmt::offsetOfTypeDescriptorPointer + LinuxVmt::offsetOfFirstMethodPointer;

        assert(false && "Failed to find VMT!");
        return nullptr;
    }

private:
    [[nodiscard]] const LinuxRttiTypeDescriptor* findTypeDescriptor(std::string_view mangledTypeName) const noexcept
    {
        return LinuxRttiTypeDescriptorFinder{rodataSection, dataRelRoSection}.findTypeDescriptor(mangledTypeName);
    }

    [[nodiscard]] bool canPrecedeVmt(std::uintptr_t typeDescriptorReference) const noexcept
    {
        return dataRelRoSection.offsetOf(typeDescriptorReference) >= LinuxVmt::offsetOfTypeDescriptorPointer;
    }

    [[nodiscard]] bool isPrecedingVmtOfCompleteClass(const std::byte* typeDescriptorReference) const noexcept
    {
        std::size_t offsetFromTop;
        std::memcpy(&offsetFromTop, typeDescriptorReference - LinuxVmt::offsetOfTypeDescriptorPointer + LinuxVmt::offsetOfOffsetFromTop, sizeof(std::size_t));
        return offsetFromTop == 0;
    }

    MemorySection rodataSection;
    MemorySection dataRelRoSection;
};

```

`Source/Platform/Linux/LinuxVmtFinderParams.h`:

```h
#pragma once

#include <Utils/MemorySection.h>

struct LinuxVmtFinderParams {
    MemorySection rodataSection;
    MemorySection dataRelRoSection;
};

```

`Source/Platform/Linux/RTTI/LinuxRttiTypeDescriptor.h`:

```h
#pragma once

struct LinuxRttiTypeDescriptor {
    static constexpr auto kOffsetOfNamePointer{8};
};

```

`Source/Platform/Linux/RTTI/LinuxRttiTypeDescriptorFinder.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <string_view>

#include <MemorySearch/BytePattern.h>
#include <MemorySearch/HybridPatternFinder.h>
#include <Utils/MemorySection.h>

#include "LinuxRttiTypeDescriptor.h"

class LinuxRttiTypeDescriptorFinder {
public:
    LinuxRttiTypeDescriptorFinder(MemorySection rodataSection, MemorySection dataRelRoSection) noexcept
        : rodataSection{rodataSection}
        , dataRelRoSection{dataRelRoSection}
    {
    }

    [[nodiscard]] const LinuxRttiTypeDescriptor* findTypeDescriptor(std::string_view mangledTypeName) const noexcept
    {
        if (const auto typeDescriptorName{findTypeDescriptorName(mangledTypeName)}; isPartOfTypeDescriptor(typeDescriptorName))
            return toTypeDescriptorPointer(typeDescriptorName);
        return nullptr;
    }

private:
    [[nodiscard]] const std::byte* findTypeDescriptorName(std::string_view mangledTypeName) const noexcept
    {
        HybridPatternFinder typeNameFinder{rodataSection.raw(), BytePattern{mangledTypeName}};
        auto typeNameAddress = typeNameFinder.findNextOccurrence();
        while (typeNameAddress) {
            const auto typeNameReference = HybridPatternFinder{dataRelRoSection.raw(), BytePattern::ofObject(typeNameAddress)}.findNextOccurrence();
            if (typeNameReference && reinterpret_cast<std::uintptr_t>(typeNameReference) % alignof(void*) == 0)
                return typeNameReference;
            typeNameAddress = typeNameFinder.findNextOccurrence();
        }
        return nullptr;
    }

    [[nodiscard]] bool isPartOfTypeDescriptor(const std::byte* typeDescriptorName) const noexcept
    {
        return typeDescriptorName && dataRelRoSection.offsetOf(reinterpret_cast<std::uintptr_t>(typeDescriptorName)) >= LinuxRttiTypeDescriptor::kOffsetOfNamePointer;
    }

    [[nodiscard]] static const LinuxRttiTypeDescriptor* toTypeDescriptorPointer(const std::byte* typeDescriptorName) noexcept
    {
        return reinterpret_cast<const LinuxRttiTypeDescriptor*>(typeDescriptorName - LinuxRttiTypeDescriptor::kOffsetOfNamePointer);
    }

    MemorySection rodataSection;
    MemorySection dataRelRoSection;
};

```

`Source/Platform/Linux/UserHomeFolderPath.h`:

```h
#pragma once

#include <string_view>

#include <Helpers/ConstString.h>
#include "LinuxPlatformApi.h"

struct UserHomeFolderPath {
    [[nodiscard]] std::string_view get() const noexcept
    {
        return homePath.get();
    }

private:
    [[nodiscard]] static ConstString getHomePath() noexcept
    {
        if (const auto home = LinuxPlatformApi::getenv("HOME"))
            return ConstString{ home };
        return {};
    }

    ConstString homePath = getHomePath();
};

```

`Source/Platform/Macros/CallStack.h`:

```h
#pragma once

#include <cstdint>

#include "IsPlatform.h"
#include <Utils/ReturnAddress.h>

#if IS_WIN64()

#include <intrin.h>

#define RETURN_ADDRESS() ReturnAddress{_ReturnAddress()}
#define FRAME_ADDRESS() (std::uintptr_t(_AddressOfReturnAddress()) - sizeof(std::uintptr_t))

#elif IS_LINUX()

#define RETURN_ADDRESS() ReturnAddress{__builtin_return_address(0)}
#define FRAME_ADDRESS() std::uintptr_t(__builtin_frame_address(0))

#else

#define RETURN_ADDRESS()
#define FRAME_ADDRESS()

#endif

```

`Source/Platform/Macros/CallingConventions.h`:

```h
#pragma once

#include "PlatformSpecific.h"

#define THISCALL_CONV WIN64_ONLY(__thiscall)
#define FASTCALL_CONV WIN64_ONLY(__fastcall)
#define CDECL_CONV    WIN64_ONLY(__cdecl)
#define STDCALL_CONV  WIN64_ONLY(__stdcall)

```

`Source/Platform/Macros/FunctionAttributes.h`:

```h
#pragma once

#include "IsCompiler.h"

#if defined(GCC)
    #define NOINLINE gnu::noinline
#elif defined(CLANG)
    #define NOINLINE clang::noinline
#elif defined(MSVC)
    #define NOINLINE msvc::noinline
#else
    #define NOINLINE
#endif

```

`Source/Platform/Macros/IsCompiler.h`:

```h
#pragma once

#if defined(__clang__)
    #define CLANG
#elif defined(__GNUC__)
    #define GCC
#elif defined(_MSC_VER)
    #define MSVC
#endif

```

`Source/Platform/Macros/IsPlatform.h`:

```h
#pragma once

#if defined(_WIN64) && defined(__linux__)
    #error "Conflicting platform macros defined"
#endif

#if defined(_WIN64)
    #define IS_WIN64() true
    #define IS_LINUX() false
#elif defined(__linux__)
    #define IS_WIN64() false
    #define IS_LINUX() true
#else
    #define IS_WIN64() false
    #define IS_LINUX() false
#endif

```

`Source/Platform/Macros/PlatformSpecific.h`:

```h
#pragma once

#include "IsPlatform.h"

#if IS_WIN64()

#define WIN64_ONLY(...) __VA_ARGS__
#define LINUX_ONLY(...)
#define WIN64_LINUX(win64, linux) win64

#elif IS_LINUX()

#define WIN64_ONLY(...)
#define LINUX_ONLY(...) __VA_ARGS__
#define WIN64_LINUX(win64, linux) linux

#else

#error "Unsupported platform"

#endif

```

`Source/Platform/PlatformApi.h`:

```h
#pragma once

#include "Macros/IsPlatform.h"

#if IS_WIN64()

#include "Windows/WindowsPlatformApi.h"

using PlatformApi = WindowsPlatformApi;

#elif IS_LINUX()

#include "Linux/LinuxPlatformApi.h"

using PlatformApi = LinuxPlatformApi;

#endif

```

`Source/Platform/PlatformPath.h`:

```h
#pragma once

#include "Macros/PlatformSpecific.h"

namespace platform
{

using PathCharType = WIN64_LINUX(wchar_t, char);

constexpr PathCharType kPathSeparator = WIN64_LINUX(L'\\', '/');

}

```

`Source/Platform/SimpleMessageBox.h`:

```h
#pragma once

#include "Macros/IsPlatform.h"

#if IS_WIN64()

#include "Windows/WindowsMessageBox.h"

using SimpleMessageBox = WindowsMessageBox;

#elif IS_LINUX()

#include "Linux/LinuxMessageBox.h"

using SimpleMessageBox = LinuxMessageBox;

#endif

```

`Source/Platform/TypeInfoPrecedingVmt.h`:

```h
#pragma once

#include "Macros/PlatformSpecific.h"

namespace platform
{
    constexpr auto lengthOfTypeInfoPrecedingVmt = WIN64_LINUX(1, 2);
}

```

`Source/Platform/VmtFinder.h`:

```h
#pragma once

#include "Macros/IsPlatform.h"

#if IS_WIN64()

#include "Windows/WindowsVmtFinder.h"

using VmtFinder = WindowsVmtFinder;

#elif IS_LINUX()

#include "Linux/LinuxVmtFinder.h"

using VmtFinder = LinuxVmtFinder;

#endif

```

`Source/Platform/Windows/CRTWindows.cpp`:

```cpp
#include <cstddef>
#include <cstring>
#include <intrin.h>

extern "C" int _fltused{ 0x9875 };

namespace crt
{

[[nodiscard]] inline int memcmp(const unsigned char* lhs, const unsigned char* rhs, std::size_t count) noexcept
{
    for (std::size_t i = 0; i < count; ++i) {
        if (lhs[i] != rhs[i])
            return lhs[i] < rhs[i] ? -1 : 1;
    }
    return 0;
}

inline std::byte* memcpy(std::byte* dest, const std::byte* src, std::size_t count) noexcept
{
    __movsb(reinterpret_cast<unsigned char*>(dest), reinterpret_cast<const unsigned char*>(src), count);
    return dest;
}

inline unsigned char* memset(unsigned char* const dest, unsigned char ch, std::size_t count) noexcept
{
    for (std::size_t i = 0; i < count; ++i)
        dest[i] = ch;
    return dest;
}

[[nodiscard]] inline int strcmp(const unsigned char* s1, const unsigned char* s2) noexcept
{
    while (*s1 == *s2) {
        if (*s1 == '\0')
            return 0;
        ++s1;
        ++s2;
    }

    return *s1 - *s2;
}

inline unsigned char* memmove(unsigned char* dest, const unsigned char* src, std::size_t count) noexcept
{
    if (dest < src) {
        for (std::size_t i = 0; i < count; ++i)
            dest[i] = src[i];
    } else {
        for (std::size_t i = count; i > 0; --i)
            dest[i - 1] = src[i - 1];
    }
    return dest;
}

inline std::size_t strlen(const char* str) noexcept
{
    std::size_t length = 0;
    while (*str) {
        ++length;
        ++str;
    }
    return length;
}

inline const unsigned char* memchr(const unsigned char* ptr, unsigned char ch, std::size_t count) noexcept
{
    for (std::size_t i = 0; i < count; ++i) {
        if (ptr[i] == ch)
            return &ptr[i];
    }
    return nullptr;
}

}

#pragma function(memcpy)
void* memcpy(void* dest, const void* src, size_t count)
{
    return crt::memcpy(static_cast<std::byte*>(dest), static_cast<const std::byte*>(src), count);
}

#pragma function(memmove)
void* memmove(void* dest, const void* src, size_t count)
{
    return crt::memmove(static_cast<unsigned char*>(dest), static_cast<const unsigned char*>(src), count);
}

#pragma function(memcmp)
int memcmp(const void* s1, const void* s2, std::size_t n)
{
    return crt::memcmp(static_cast<const unsigned char*>(s1), static_cast<const unsigned char*>(s2), n);
}

#pragma function(memset)
void* memset(void* dest, int ch, size_t count)
{
    return crt::memset(static_cast<unsigned char*>(dest), static_cast<unsigned char>(ch), count);
}

#pragma function(strcmp)
int strcmp(const char* s1, const char* s2)
{
    return crt::strcmp(reinterpret_cast<const unsigned char*>(s1), reinterpret_cast<const unsigned char*>(s2));
}

#pragma function(strlen)
std::size_t strlen(const char* str)
{
    return crt::strlen(str);
}

#pragma function(memchr)
const void* memchr(const void* ptr, int ch, std::size_t count)
{
    return crt::memchr(reinterpret_cast<const unsigned char*>(ptr), static_cast<unsigned char>(ch), count);
}

#ifndef _DLL

#pragma function(wcslen)
std::size_t wcslen(const wchar_t* str)
{
    std::size_t length = 0;
    while (*str) {
        ++length;
        ++str;
    }
    return length;
}

#endif

```

`Source/Platform/Windows/CoTaskMemDeleter.h`:

```h
#pragma once

#include "DLLs/CombaseDll.h"

struct CoTaskMemDeleter {
    void operator()(void* ptr) const noexcept
    {
        if (const auto coTaskMemFree = CombaseDll{}.CoTaskMemFree())
            coTaskMemFree(ptr);
    }
};

```

`Source/Platform/Windows/DLLs/CombaseDll.h`:

```h
#pragma once

#include <combaseapi.h>

#include <Platform/Windows/WindowsDynamicLibrary.h>

struct CombaseDll : WindowsDynamicLibrary {
    CombaseDll() : WindowsDynamicLibrary{ "combase.dll" }
    {
    }

    [[nodiscard]] auto CoTaskMemFree() const noexcept
    {
        return getFunctionAddress("CoTaskMemFree").as<decltype(&::CoTaskMemFree)>();
    }
};

```

`Source/Platform/Windows/DLLs/Shell32Dll.h`:

```h
#pragma once

#include <ShlObj_core.h>

#include <Platform/Windows/WindowsDynamicLibrary.h>

struct Shell32Dll : WindowsDynamicLibrary {
    Shell32Dll() : WindowsDynamicLibrary{ "shell32.dll" }
    {
    }

    [[nodiscard]] auto SHGetKnownFolderPath() const noexcept
    {
        return getFunctionAddress("SHGetKnownFolderPath").as<decltype(&::SHGetKnownFolderPath)>();
    }
};

```

`Source/Platform/Windows/FileSystem/WindowsFileSystem.h`:

```h
#pragma once

#include <cstddef>
#include <span>
#include <Windows.h>
#include <winternl.h>

#include <Platform/Windows/Syscalls/WindowsSyscalls.h>
#include <Utils/Wcslen.h>

struct WindowsFileSystem {
    static HANDLE openFileForReading(UNICODE_STRING fileName) noexcept
    {
        HANDLE handle;
        IO_STATUS_BLOCK statusBlock{};
        OBJECT_ATTRIBUTES objectAttributes{
            .Length = sizeof(OBJECT_ATTRIBUTES),
            .RootDirectory = nullptr,
            .ObjectName = &fileName,
            .Attributes = OBJ_CASE_INSENSITIVE,
            .SecurityDescriptor = nullptr,
            .SecurityQualityOfService = nullptr
        };
        if (NT_SUCCESS(WindowsSyscalls::NtCreateFile(&handle, FILE_GENERIC_READ, &objectAttributes, &statusBlock, nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, nullptr, 0)))
            return handle;
        return INVALID_HANDLE_VALUE;
    }

    static HANDLE createFileForOverwrite(const wchar_t* ntPath) noexcept
    {
        HANDLE handle;
        IO_STATUS_BLOCK statusBlock{};
        const auto pathLength = utils::wcslen(ntPath);
        UNICODE_STRING fileName{
            .Length = static_cast<USHORT>(pathLength * sizeof(wchar_t)),
            .MaximumLength = static_cast<USHORT>(pathLength * sizeof(wchar_t)),
            .Buffer = const_cast<wchar_t*>(ntPath)
        };
        OBJECT_ATTRIBUTES objectAttributes{
            .Length = sizeof(OBJECT_ATTRIBUTES),
            .RootDirectory = nullptr,
            .ObjectName = &fileName,
            .Attributes = OBJ_CASE_INSENSITIVE,
            .SecurityDescriptor = nullptr,
            .SecurityQualityOfService = nullptr
        };
        if (NT_SUCCESS(WindowsSyscalls::NtCreateFile(&handle, FILE_GENERIC_WRITE | DELETE, &objectAttributes, &statusBlock, nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_SUPERSEDE, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, nullptr, 0)))
            return handle;
        return INVALID_HANDLE_VALUE;
    }

    static void createDirectory(const wchar_t* ntPath) noexcept
    {
        IO_STATUS_BLOCK statusBlock{};
        const auto pathLength = utils::wcslen(ntPath);
        UNICODE_STRING directoryName{
            .Length = static_cast<USHORT>(pathLength * sizeof(wchar_t)),
            .MaximumLength = static_cast<USHORT>(pathLength * sizeof(wchar_t)),
            .Buffer = const_cast<wchar_t*>(ntPath)
        };
        OBJECT_ATTRIBUTES objectAttributes{
            .Length = sizeof(OBJECT_ATTRIBUTES),
            .RootDirectory = nullptr,
            .ObjectName = &directoryName,
            .Attributes = OBJ_CASE_INSENSITIVE,
            .SecurityDescriptor = nullptr,
            .SecurityQualityOfService = nullptr
        };

        if (HANDLE handle; NT_SUCCESS(WindowsSyscalls::NtCreateFile(&handle, FILE_LIST_DIRECTORY | SYNCHRONIZE, &objectAttributes, &statusBlock, nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT, nullptr, 0)))
            WindowsSyscalls::NtClose(handle);
    }

    static std::size_t readFile(HANDLE fileHandle, std::size_t fileOffset, void* buffer, std::size_t bufferSize) noexcept
    {
        IO_STATUS_BLOCK statusBlock{};
        LARGE_INTEGER offset{.QuadPart = static_cast<LONGLONG>(fileOffset)};
        if (NT_SUCCESS(WindowsSyscalls::NtReadFile(fileHandle, nullptr, nullptr, nullptr, &statusBlock, buffer, static_cast<ULONG>(bufferSize), &offset, nullptr)) && statusBlock.Information <= bufferSize) {
            return statusBlock.Information;
        }
        return 0;
    }

    static std::size_t writeFile(HANDLE fileHandle, std::size_t fileOffset, void* buffer, std::size_t bufferSize) noexcept
    {
        IO_STATUS_BLOCK statusBlock{};
        LARGE_INTEGER offset{.QuadPart = static_cast<LONGLONG>(fileOffset)};
        if (NT_SUCCESS(WindowsSyscalls::NtWriteFile(fileHandle, nullptr, nullptr, nullptr, &statusBlock, buffer, static_cast<ULONG>(bufferSize), &offset, nullptr)) && statusBlock.Information <= bufferSize) {
            return statusBlock.Information;
        }
        return 0;
    }

    static void renameFile(HANDLE fileHandle, const wchar_t* newFilePath) noexcept
    {
        IO_STATUS_BLOCK statusBlock{};

        const auto pathLength = utils::wcslen(newFilePath);

        constexpr auto kMaxPathLength{200};
        if (pathLength > kMaxPathLength) {
            assert(false);
            return;
        }

        alignas(FILE_RENAME_INFO) std::byte buffer[sizeof(FILE_RENAME_INFO) + kMaxPathLength * sizeof(wchar_t)];

        FILE_RENAME_INFO* info = new (&buffer) FILE_RENAME_INFO{};
        info->ReplaceIfExists = TRUE;
        info->FileNameLength = static_cast<DWORD>(pathLength * sizeof(wchar_t));
        std::memcpy(&info->FileName, newFilePath, pathLength * sizeof(wchar_t));
        constexpr wchar_t kNullTerminator{L'\0'};
        std::memcpy(reinterpret_cast<std::byte*>(&info->FileName) + pathLength * sizeof(wchar_t), &kNullTerminator, sizeof(kNullTerminator));

        constexpr std::underlying_type_t<FILE_INFORMATION_CLASS> fileRenameInformationClass{10};
        FILE_INFORMATION_CLASS fileRenameInformationClassEnum{};
        std::memcpy(&fileRenameInformationClassEnum, &fileRenameInformationClass, sizeof(fileRenameInformationClass));
        WindowsSyscalls::NtSetInformationFile(fileHandle, &statusBlock, info, sizeof(FILE_RENAME_INFO) + kMaxPathLength * sizeof(wchar_t), fileRenameInformationClassEnum);
    }
};

```

`Source/Platform/Windows/FileSystem/WindowsInputFile.h`:

```h
#pragma once

#include <cstddef>
#include <span>
#include <Windows.h>
#include <winternl.h>

#include <Platform/Windows/NtHandle.h>
#include "WindowsFileSystem.h"

struct WindowsInputFile {
    explicit WindowsInputFile(UNICODE_STRING fileName) noexcept
        : handle{WindowsFileSystem::openFileForReading(fileName)}
    {
    }

    [[nodiscard]] std::size_t read(std::size_t fileOffset, std::span<std::byte> buffer) const noexcept
    {
        return WindowsFileSystem::readFile(handle.get(), fileOffset, buffer);
    }

private:
    NtHandle handle;
};

```

`Source/Platform/Windows/NtHandle.h`:

```h
#pragma once

#include <memory>
#include <Windows.h>

#include "Syscalls/WindowsSyscalls.h"

struct NtHandleDeleter {
    void operator()(HANDLE handle) const noexcept
    {
        if (handle)
            WindowsSyscalls::NtClose(handle);
    }
};

using NtHandle = std::unique_ptr<void, NtHandleDeleter>;

```

`Source/Platform/Windows/PebLdr.h`:

```h
#pragma once

#include <Windows.h>

#include "Win.h"

class PebLdr {
public:
    explicit PebLdr(win::PebLdrData* ldr)
        : ldr{ ldr }
    {
    }

    [[nodiscard]] HMODULE getModuleHandle(const char* moduleName) const noexcept
    {
        const auto head = getInLoadOrderModuleListHead();
        for (auto currentLink = head->fLink; currentLink != head; currentLink = currentLink->fLink) {
            const auto& entry = *CONTAINING_RECORD(currentLink, win::LdrDataTableEntry, inLoadOrderLinks);

            if (entry.baseDllName.equalsCaseInsensitive(moduleName))
                return HMODULE(entry.dllBase);
        }
        return {};
    }

private:
    [[nodiscard]] win::ListEntry* getInLoadOrderModuleListHead() const noexcept
    {
        return &ldr->inLoadOrderModuleList;
    }

    win::PebLdrData* ldr;
};

```

`Source/Platform/Windows/PortableExecutable.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <cstring>
#include <span>

#include <Windows.h>

#include <Utils/GenericPointer.h>
#include <Utils/MemorySection.h>

class PortableExecutable {
public:
    explicit PortableExecutable(const std::byte* base)
        : base{ base }
    {
        assert(base);
    }

    [[nodiscard]] MemorySection getCodeSection() const noexcept
    {
        for (const auto& section : getSectionHeaders()) {
            if ((section.Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0 && std::memcmp(section.Name, ".text", 5) == 0)
                return MemorySection{ std::span{ base + section.VirtualAddress, section.Misc.VirtualSize } };
        }
        return {};
    }

    [[nodiscard]] MemorySection getVmtSection() const noexcept
    {
        for (const auto& section : getSectionHeaders()) {
            if ((section.Characteristics & IMAGE_SCN_MEM_READ) != 0 && std::memcmp(section.Name, ".rdata", 6) == 0)
                return MemorySection{ std::span{ base + section.VirtualAddress, section.Misc.VirtualSize } };
        }
        return {};
    }

    [[nodiscard]] MemorySection getDataSection() const noexcept
    {
        for (const auto& section : getSectionHeaders()) {
            if ((section.Characteristics & IMAGE_SCN_MEM_READ) != 0 && std::memcmp(section.Name, ".data", 5) == 0)
                return MemorySection{std::span{ base + section.VirtualAddress, section.Misc.VirtualSize }};
        }
        return {};
    }

    [[nodiscard]] GenericPointer getExport(const char* name) const noexcept
    {
        const auto exportDataDirectory = getExportDataDirectory();
        if (!exportDataDirectory)
            return {};

        const auto exportDirectory = reinterpret_cast<const IMAGE_EXPORT_DIRECTORY*>(base + exportDataDirectory->VirtualAddress);

        for (DWORD i = 0; i < exportDirectory->NumberOfNames; ++i) {
            const auto exportName = reinterpret_cast<const char*>(base + reinterpret_cast<const DWORD*>(base + exportDirectory->AddressOfNames)[i]);
            if (std::strcmp(exportName, name) == 0) {
                const auto nameOrdinals = reinterpret_cast<const WORD*>(base + exportDirectory->AddressOfNameOrdinals);
                const auto functions = reinterpret_cast<const DWORD*>(base + exportDirectory->AddressOfFunctions);
                const auto functionRva = functions[nameOrdinals[i]];
                if (isForwardedExport(functionRva, *exportDataDirectory)) {
                    assert(false && "Forwarded exports are not supported yet!");
                    return {};
                }
                return base + functionRva;
            }
        }

        return {};
    }

private:
    [[nodiscard]] static bool isForwardedExport(DWORD functionRva, const IMAGE_DATA_DIRECTORY& exportDataDirectory) noexcept
    {
        return functionRva >= exportDataDirectory.VirtualAddress && functionRva - exportDataDirectory.VirtualAddress < exportDataDirectory.Size;
    }

    [[nodiscard]] std::span<const IMAGE_SECTION_HEADER> getSectionHeaders() const noexcept
    {
        if (const auto ntHeaders = getNtHeaders())
            return { reinterpret_cast<const IMAGE_SECTION_HEADER*>(reinterpret_cast<const std::byte*>(&ntHeaders->OptionalHeader) + ntHeaders->FileHeader.SizeOfOptionalHeader),
                     ntHeaders->FileHeader.NumberOfSections };
        return {};
    }

    [[nodiscard]] const IMAGE_DATA_DIRECTORY* getExportDataDirectory() const noexcept
    {
        return getDataDirectory(IMAGE_DIRECTORY_ENTRY_EXPORT);
    }

    [[nodiscard]] const IMAGE_DATA_DIRECTORY* getDataDirectory(std::uint8_t entry) const noexcept
    {
        if (const auto optionalHeader = getOptionalHeader(); optionalHeader && optionalHeader->NumberOfRvaAndSizes > entry)
            return &optionalHeader->DataDirectory[entry];
        return nullptr;
    }

    [[nodiscard]] const IMAGE_OPTIONAL_HEADER* getOptionalHeader() const noexcept
    {
        if (const auto ntHeaders = getNtHeaders(); ntHeaders && ntHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC)
            return &ntHeaders->OptionalHeader;
        return nullptr;
    }

    [[nodiscard]] const IMAGE_NT_HEADERS* getNtHeaders() const noexcept
    {
        if (const auto dosHeader = getDosHeader())
            return getNtHeaders(*dosHeader);
        return nullptr;
    }

    [[nodiscard]] const IMAGE_NT_HEADERS* getNtHeaders(const IMAGE_DOS_HEADER& dosHeader) const noexcept
    {
        constexpr auto peSignature = 0x4550;
        if (const auto ntHeaders = reinterpret_cast<const IMAGE_NT_HEADERS*>(base + dosHeader.e_lfanew); ntHeaders->Signature == peSignature)
            return ntHeaders;
        return nullptr;
    }

    [[nodiscard]] const IMAGE_DOS_HEADER* getDosHeader() const noexcept
    {
        if (const auto dosHeader = reinterpret_cast<const IMAGE_DOS_HEADER*>(base); dosHeader->e_magic == IMAGE_DOS_SIGNATURE)
            return dosHeader;
        return nullptr;
    }

    const std::byte* base;
};

```

`Source/Platform/Windows/RTTI/RttiCompleteObjectLocator.h`:

```h
#pragma once

struct RttiCompleteObjectLocator {
    static constexpr auto kOffsetOfOffsetInCompleteClass{4};
    static constexpr auto kOffsetOfTypeDescriptorRva{12};
};

```

`Source/Platform/Windows/RTTI/RttiCompleteObjectLocatorFinder.h`:

```h
#pragma once

#include <cstdint>
#include <cstring>

#include "RttiCompleteObjectLocator.h"
#include "ToRvaConverter.h"
#include <Utils/MemorySection.h>

struct RttiTypeDescriptor;

class RttiCompleteObjectLocatorFinder {
public:
    RttiCompleteObjectLocatorFinder(MemorySection rdataSection, ToRvaConverter toRvaConverter) noexcept
        : rdataSection{rdataSection}
        , toRvaConverter{toRvaConverter}
    {
    }
    
    [[nodiscard]] const RttiCompleteObjectLocator* findCompleteObjectLocator(const RttiTypeDescriptor* typeDescriptor) const noexcept
    {
        const auto typeDescriptorRva{toRvaConverter.toRva(reinterpret_cast<std::uintptr_t>(typeDescriptor))};
        HybridPatternFinder typeDescriptorCrossReferenceFinder{rdataSection.raw(), BytePattern::ofObject(typeDescriptorRva)};

        auto typeDescriptorReference{typeDescriptorCrossReferenceFinder.findNextOccurrence()};
        while (typeDescriptorReference && (!isCompleteObjectLocator(reinterpret_cast<std::uintptr_t>(typeDescriptorReference)) || !isCompleteObjectLocatorOfCompleteClass(typeDescriptorReference)))
            typeDescriptorReference = typeDescriptorCrossReferenceFinder.findNextOccurrence();

        if (typeDescriptorReference)
            return reinterpret_cast<const RttiCompleteObjectLocator*>(typeDescriptorReference - RttiCompleteObjectLocator::kOffsetOfTypeDescriptorRva);

        return nullptr;
    }

private:
    [[nodiscard]] bool isCompleteObjectLocatorOfCompleteClass(const std::byte* typeDescriptorReference) const noexcept
    {
        std::uint32_t offsetInCompleteClass;
        std::memcpy(&offsetInCompleteClass, typeDescriptorReference - RttiCompleteObjectLocator::kOffsetOfTypeDescriptorRva + RttiCompleteObjectLocator::kOffsetOfOffsetInCompleteClass, sizeof(std::uint32_t));
        return offsetInCompleteClass == 0;
    }

    [[nodiscard]] bool isCompleteObjectLocator(std::uintptr_t typeDescriptorReference) const noexcept
    {
        const auto rva{toRvaConverter.toRva(typeDescriptorReference)};
        return hasNoCrossReferences(BytePattern::ofObject(rva)) && rdataSection.offsetOf(typeDescriptorReference) >= RttiCompleteObjectLocator::kOffsetOfTypeDescriptorRva;
    }

    [[nodiscard]] bool hasNoCrossReferences(BytePattern pattern) const noexcept
    {
        return HybridPatternFinder{rdataSection.raw(), pattern}.findNextOccurrence() == nullptr;
    }

    MemorySection rdataSection;
    ToRvaConverter toRvaConverter;
};

```

`Source/Platform/Windows/RTTI/RttiTypeDescriptor.h`:

```h
#pragma once

struct RttiTypeDescriptor {
    static constexpr auto kOffsetOfName{16};
};

```

`Source/Platform/Windows/RTTI/RttiTypeDescriptorFinder.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>
#include <string_view>

#include <MemorySearch/HybridPatternFinder.h>
#include "RttiTypeDescriptor.h"
#include <Utils/MemorySection.h>

class RttiTypeDescriptorFinder {
public:
    RttiTypeDescriptorFinder(MemorySection dataSection) noexcept
        : dataSection{dataSection}
    {
    }

    [[nodiscard]] const RttiTypeDescriptor* findTypeDescriptor(std::string_view mangledTypeName) const noexcept
    {
        if (const auto typeDescriptorName{findTypeDescriptorName(mangledTypeName)}; canBePartOfTypeDescriptor(typeDescriptorName))
            return toTypeDescriptorPointer(typeDescriptorName);
        return nullptr;
    }

private:
    [[nodiscard]] const std::byte* findTypeDescriptorName(std::string_view typeDescriptorName) const noexcept
    {
        return HybridPatternFinder{dataSection.raw(), BytePattern{typeDescriptorName}}.findNextOccurrence();
    }

    [[nodiscard]] bool canBePartOfTypeDescriptor(const std::byte* typeDescriptorName) const noexcept
    {
        return typeDescriptorName && dataSection.offsetOf(reinterpret_cast<std::uintptr_t>(typeDescriptorName)) >= RttiTypeDescriptor::kOffsetOfName;
    }

    [[nodiscard]] static const RttiTypeDescriptor* toTypeDescriptorPointer(const std::byte* typeDescriptorName) noexcept
    {
        return reinterpret_cast<const RttiTypeDescriptor*>(typeDescriptorName - RttiTypeDescriptor::kOffsetOfName);
    }

    MemorySection dataSection;
};

```

`Source/Platform/Windows/RTTI/ToRvaConverter.h`:

```h
#pragma once

#include <cassert>
#include <cstdint>

struct ToRvaConverter {
    [[nodiscard]] std::uint32_t toRva(std::uintptr_t address) const noexcept
    {
        assert(address >= baseAddress);
        return static_cast<std::uint32_t>(address - baseAddress);
    }

    std::uintptr_t baseAddress;
};

```

`Source/Platform/Windows/Syscalls/SyscallParams.h`:

```h
#pragma once

#include <cstdint>
#include <type_traits>

#include "WindowsSyscallIndex.h"

struct SyscallParams {
    WindowsSyscallIndex syscallIndex;
    std::uintptr_t firstParam;
};

static_assert(
    sizeof(std::declval<SyscallParams>().syscallIndex) == 8 &&
    sizeof(std::declval<SyscallParams>().firstParam) == 8 &&
    offsetof(SyscallParams, syscallIndex) == 0 &&
    offsetof(SyscallParams, firstParam) == 8,
    "Must match assembly");

```

`Source/Platform/Windows/Syscalls/WindowsSyscall.asm`:

```asm
.CODE

systemCall PROC
    mov rax, [rcx] ; load syscall index into rax
    mov r10, [rcx+8] ; load first parameter into r10
    syscall
    ret
systemCall ENDP

END

```

`Source/Platform/Windows/Syscalls/WindowsSyscallIndex.h`:

```h
#pragma once

#include <cstddef>

namespace win
{

enum class SyscallIndexWindows10and11 : std::size_t {
    NtReadFile = 6,
    NtWriteFile = 8,
    NtClose = 15,
    NtSetInformationFile = 39,
    NtCreateFile = 85
};

}

using WindowsSyscallIndex = win::SyscallIndexWindows10and11;

```

`Source/Platform/Windows/Syscalls/WindowsSyscalls.h`:

```h
#pragma once

#include <Windows.h>
#include <winternl.h>

#include "SyscallParams.h"
#include "WindowsSyscallIndex.h"

extern "C" std::size_t systemCall(const SyscallParams* params, ...);

struct IO_APC_ROUTINE;

struct WindowsSyscalls {
    static NTSTATUS NtCreateFile(
        HANDLE* fileHandle,
        ACCESS_MASK desiredAccess,
        OBJECT_ATTRIBUTES* objectAttributes,
        IO_STATUS_BLOCK* ioStatusBlock,
        LARGE_INTEGER* allocationSize,
        ULONG fileAttributes,
        ULONG shareAccess,
        ULONG createDisposition,
        ULONG createOptions,
        void* eaBuffer,
        ULONG eaLength) noexcept
    {
        const SyscallParams params{WindowsSyscallIndex::NtCreateFile, reinterpret_cast<std::uintptr_t>(fileHandle)};
        return static_cast<NTSTATUS>(systemCall(&params, desiredAccess, objectAttributes, ioStatusBlock, allocationSize, fileAttributes, shareAccess, createDisposition, createOptions, eaBuffer, eaLength));
    }

    static NTSTATUS NtReadFile(HANDLE fileHandle, HANDLE event, IO_APC_ROUTINE* apcRoutine, void* apcContext, IO_STATUS_BLOCK* ioStatusBlock, void* buffer, ULONG length, LARGE_INTEGER* byteOffset, ULONG* key) noexcept
    {
        const SyscallParams params{WindowsSyscallIndex::NtReadFile, reinterpret_cast<std::uintptr_t>(fileHandle)};
        return static_cast<NTSTATUS>(systemCall(&params, event, apcRoutine, apcContext, ioStatusBlock, buffer, length, byteOffset, key));
    }

    static NTSTATUS NtWriteFile(HANDLE fileHandle, HANDLE event, IO_APC_ROUTINE* apcRoutine, void* apcContext, IO_STATUS_BLOCK* ioStatusBlock, void* buffer, ULONG length, LARGE_INTEGER* byteOffset, ULONG* key) noexcept
    {
        const SyscallParams params{WindowsSyscallIndex::NtWriteFile, reinterpret_cast<std::uintptr_t>(fileHandle)};
        return static_cast<NTSTATUS>(systemCall(&params, event, apcRoutine, apcContext, ioStatusBlock, buffer, length, byteOffset, key));
    }

    static NTSTATUS NtSetInformationFile(HANDLE fileHandle, IO_STATUS_BLOCK* ioStatusBlock, void* fileInformation, ULONG length, FILE_INFORMATION_CLASS fileInformationClass) noexcept
    {
        const SyscallParams params{WindowsSyscallIndex::NtSetInformationFile, reinterpret_cast<std::uintptr_t>(fileHandle)};
        return static_cast<NTSTATUS>(systemCall(&params, ioStatusBlock, fileInformation, length, fileInformationClass));
    }

    static NTSTATUS NtClose(HANDLE handle) noexcept
    {
        const SyscallParams params{WindowsSyscallIndex::NtClose, reinterpret_cast<std::uintptr_t>(handle)};
        return static_cast<NTSTATUS>(systemCall(&params));
    }
};

```

`Source/Platform/Windows/UserDocumentsFolderPath.h`:

```h
#pragma once

#include <memory>
#include <ShlObj_core.h>

#include "CoTaskMemDeleter.h"
#include "DLLs/Shell32Dll.h"

struct UserDocumentsFolderPath {
    [[nodiscard]] const wchar_t* get() const noexcept
    {
        return path.get() ? path.get() : L"";
    }

private:
    using PathPointer = std::unique_ptr<wchar_t[], CoTaskMemDeleter>;

    [[nodiscard]] static PathPointer getUserDocumentsFolderPath() noexcept
    {
        wchar_t* path = nullptr;
        if (const auto getKnownFolderPath = Shell32Dll{}.SHGetKnownFolderPath())
            getKnownFolderPath(FOLDERID_Documents, 0, nullptr, &path);
        return PathPointer{ path };
    }

    PathPointer path = getUserDocumentsFolderPath();
};

```

`Source/Platform/Windows/Win.h`:

```h
#pragma once

#include <Platform/Macros/IsPlatform.h>
#include <Utils/CharUtils.h>
#include <Utils/Pad.h>

namespace win
{

struct ListEntry {
    ListEntry* fLink;
    ListEntry* bLink;
};

static_assert(IS_WIN64());

struct PebLdrData {
    PAD(0x10);
    ListEntry inLoadOrderModuleList;
};

struct Peb {
    PAD(0x18);
    PebLdrData* ldr;
};

struct UnicodeString {
    unsigned short length;
    unsigned short maximumLength;
    wchar_t* buffer;

    [[nodiscard]] unsigned short lengthInChars() const noexcept
    {
        return length / sizeof(wchar_t);
    }

    [[nodiscard]] bool equalsCaseInsensitive(const char* otherString) const noexcept
    {
        for (std::size_t i = 0; i < lengthInChars(); ++i) {
            if (utils::toUpper(buffer[i]) != utils::toUpper(otherString[i]) || otherString[i] == '\0')
                return false;
        }
        return true;
    }
};

struct LdrDataTableEntry {
    ListEntry inLoadOrderLinks;
    ListEntry inMemoryOrderLinks;
    ListEntry inInitializationOrderLinks;
    void* dllBase;
    void* entryPoint;
    unsigned long sizeOfImage;
    UnicodeString fullDllName;
    UnicodeString baseDllName;
};

}

```

`Source/Platform/Windows/WindowsDynamicLibrary.h`:

```h
#pragma once

#include <Windows.h>

#include "PebLdr.h"
#include "PortableExecutable.h"
#include <Utils/GenericPointer.h>
#include <Utils/MemorySection.h>
#include "WindowsPlatformApi.h"
#include "WindowsVmtFinderParams.h"

class WindowsDynamicLibrary {
public:
    explicit WindowsDynamicLibrary(const char* libraryName)
        : handle{ PebLdr{ WindowsPlatformApi::getPeb()->ldr }.getModuleHandle(libraryName) }
    {
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return handle != nullptr;
    }

    [[nodiscard]] GenericPointer getFunctionAddress(const char* functionName) const noexcept
    {
        if (handle)
            return portableExecutable().getExport(functionName);
        return {};
    }

    [[nodiscard]] MemorySection getCodeSection() const noexcept
    {
        if (handle)
            return portableExecutable().getCodeSection();
        return {};
    }

    [[nodiscard]] MemorySection getVmtSection() const noexcept
    {
        if (handle)
            return portableExecutable().getVmtSection();
        return {};
    }

    [[nodiscard]] MemorySection getDataSection() const noexcept
    {
        if (handle)
            return portableExecutable().getDataSection();
        return {};
    }

    [[nodiscard]] WindowsVmtFinderParams getVmtFinderParams() const noexcept
    {
        return {getDataSection(), getVmtSection(), handle};
    }

    [[nodiscard]] HMODULE getHandle() const noexcept
    {
        return handle;
    }

private:
    [[nodiscard]] PortableExecutable portableExecutable() const noexcept
    {
        return PortableExecutable{ reinterpret_cast<const std::byte*>(handle) };
    }

    HMODULE handle;
};

```

`Source/Platform/Windows/WindowsMessageBox.h`:

```h
#pragma once

#include <Windows.h>

#include "WindowsDynamicLibrary.h"

class WindowsMessageBox {
public:
    void showWarning(const char* title, const char* message) const noexcept
    {
        showMessageBox(title, message, MB_ICONWARNING);
    }

    void showError(const char* title, const char* message) const noexcept
    {
        showMessageBox(title, message, MB_ICONERROR);
    }

private:
    void showMessageBox(const char* title, const char* message, unsigned int extraFlags) const noexcept
    {
        if (messageBoxA)
            messageBoxA(nullptr, message, title, MB_OK | extraFlags);
    }

    decltype(&MessageBoxA) messageBoxA = WindowsDynamicLibrary{ "USER32.dll" }.getFunctionAddress("MessageBoxA").as<decltype(&MessageBoxA)>();
};

```

`Source/Platform/Windows/WindowsPlatformApi.h`:

```h
#pragma once

namespace win { struct Peb; }

struct WindowsPlatformApi {
    [[nodiscard]] static win::Peb* getPeb() noexcept;
    static void debugBreak() noexcept;
};

```

`Source/Platform/Windows/WindowsPlatformApiImpl.h`:

```h
#pragma once

#include <bit>
#include <intrin.h>

#include <Platform/Macros/IsPlatform.h>

#include "WindowsPlatformApi.h"

win::Peb* WindowsPlatformApi::getPeb() noexcept
{
    static_assert(IS_WIN64());
    return std::bit_cast<win::Peb*>(__readgsqword(0x60));
}

void WindowsPlatformApi::debugBreak() noexcept
{
    __debugbreak();
}

```

`Source/Platform/Windows/WindowsVmtFinder.h`:

```h
#pragma once

#include <string_view>

#include <MemorySearch/HybridPatternFinder.h>
#include <Utils/MemorySection.h>

#include "RTTI/RttiCompleteObjectLocatorFinder.h"
#include "RTTI/RttiTypeDescriptorFinder.h"
#include "WindowsVmtFinderParams.h"

class WindowsVmtFinder {
public:
    explicit WindowsVmtFinder(const WindowsVmtFinderParams& params) noexcept
        : dataSection{params.dataSection}
        , vmtSection{params.rdataSection}
        , dllBase{params.dllBase}
    {
    }

    [[nodiscard]] const void* findVmt(std::string_view mangledTypeName) const noexcept
    {
        static constexpr auto kOffsetToVmt{8};

        const auto completeObjectLocatorPrecedingVmt{findCompleteObjectLocatorPrecedingVmt(mangledTypeName)};
        if (vmtSection.contains(reinterpret_cast<std::uintptr_t>(completeObjectLocatorPrecedingVmt), kOffsetToVmt))
            return completeObjectLocatorPrecedingVmt + kOffsetToVmt;
        return nullptr;
    }

private:
    [[nodiscard]] const std::byte* findCompleteObjectLocatorPrecedingVmt(std::string_view mangledTypeName) const noexcept
    {
        return findCompleteObjectLocatorReference(findCompleteObjectLocator(findTypeDescriptor(mangledTypeName)));
    }

    [[nodiscard]] const RttiTypeDescriptor* findTypeDescriptor(std::string_view mangledTypeName) const noexcept
    {
        return RttiTypeDescriptorFinder{dataSection}.findTypeDescriptor(mangledTypeName);
    }

    [[nodiscard]] const RttiCompleteObjectLocator* findCompleteObjectLocator(const RttiTypeDescriptor* typeDescriptor) const noexcept
    {
        if (typeDescriptor)
            return RttiCompleteObjectLocatorFinder{vmtSection, ToRvaConverter{reinterpret_cast<std::uintptr_t>(dllBase)}}.findCompleteObjectLocator(typeDescriptor);
        return nullptr;
    }

    [[nodiscard]] const std::byte* findCompleteObjectLocatorReference(const RttiCompleteObjectLocator* completeObjectLocator) const noexcept
    {
        if (completeObjectLocator)
            return HybridPatternFinder{vmtSection.raw(), BytePattern::ofObject(completeObjectLocator)}.findNextOccurrence();
        return nullptr;
    }

    MemorySection dataSection;
    MemorySection vmtSection;
    const void* dllBase;
};

```

`Source/Platform/Windows/WindowsVmtFinderParams.h`:

```h
#pragma once

#include <Utils/MemorySection.h>

struct WindowsVmtFinderParams {
    MemorySection dataSection;
    MemorySection rdataSection;
    const void* dllBase;
};

```

`Source/SDL/SdlConstants.h`:

```h
#pragma once

namespace sdl3
{

constexpr auto SDL_MESSAGEBOX_ERROR{0x10};
constexpr auto SDL_MESSAGEBOX_WARNING{0x20};

}

```

`Source/SDL/SdlDll.h`:

```h
#pragma once

#include <CS2/Constants/DllNames.h>
#include <Platform/DynamicLibrary.h>
#include <SDL/SdlFunctions.h>

struct SdlDll : DynamicLibrary {
    SdlDll() noexcept
        : DynamicLibrary{cs2::SDL_DLL}
    {
    }

    [[nodiscard]] sdl3::SDL_PeepEvents* peepEvents() const noexcept
    {
        return getFunctionAddress("SDL_PeepEvents").as<sdl3::SDL_PeepEvents*>();
    }

    [[nodiscard]] sdl3::SDL_ShowSimpleMessageBox* showSimpleMessageBox() const noexcept
    {
        return getFunctionAddress("SDL_ShowSimpleMessageBox").as<sdl3::SDL_ShowSimpleMessageBox*>();
    }
};

```

`Source/SDL/SdlFunctions.h`:

```h
#pragma once

#include <cstdint>

namespace sdl3
{

struct SDL_Window;
using SDL_ShowSimpleMessageBox = int(std::uint32_t flags, const char* title, const char* message, SDL_Window* window);
using SDL_PeepEvents = int(void* events, int numevents, int action, unsigned minType, unsigned maxType);

}

```

`Source/UI/Panorama/CombatTab.h`:

```h
#pragma once

#include <GameClient/Panorama/PanoramaDropDown.h>
#include <EntryPoints/GuiEntryPoints.h>
#include <Platform/Macros/FunctionAttributes.h>
#include "OnOffDropdownSelectionChangeHandler.h"

template <typename HookContext>
class CombatTab {
public:
    explicit CombatTab(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void init(auto&& guiPanel) const
    {
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, no_scope_inaccuracy_vis_vars::Enabled>>(guiPanel, "no_scope_inacc_vis");
    }

    void updateFromConfig(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "no_scope_inacc_vis", !GET_CONFIG_VAR(no_scope_inaccuracy_vis_vars::Enabled));
    }

private:
    template <typename Handler>
    void initDropDown(auto&& guiPanel, const char* panelId) const
    {
        auto&& dropDown = guiPanel.findChildInLayoutFile(panelId).clientPanel().template as<PanoramaDropDown>();
        dropDown.registerSelectionChangedHandler(&GuiEntryPoints<HookContext>::template dropDownSelectionChanged<Handler>);
    }

    [[NOINLINE]] void setDropDownSelectedIndex(auto&& mainMenu, const char* dropDownId, int selectedIndex) const noexcept
    {
        mainMenu.findChildInLayoutFile(dropDownId).clientPanel().template as<PanoramaDropDown>().setSelectedIndex(selectedIndex);
    }

    HookContext& hookContext;
};

```

`Source/UI/Panorama/CreateGUI.js`:

```js
u8R"(
$.Osiris = (function () {
  var activeTab;
  var activeSubTab = {};

  return {
    rootPanel: (function () {
      const rootPanel = $.CreatePanel('Panel', $.GetContextPanel(), 'OsirisMenuTab', {
        class: "mainmenu-content__container",
        useglobalcontext: "true"
      });

      rootPanel.visible = false;
      rootPanel.SetReadyForDisplay(false);
      rootPanel.RegisterForReadyEvents(true);
      $.RegisterEventHandler('PropertyTransitionEnd', rootPanel, function (panelName, propertyName) {
        if (rootPanel.id === panelName && propertyName === 'opacity') {
          if (rootPanel.visible === true && rootPanel.BIsTransparent()) {
            rootPanel.visible = false;
            rootPanel.SetReadyForDisplay(false);
            return true;
          } else if (newPanel.visible === true) {
            $.DispatchEvent('MainMenuTabShown', 'OsirisMenuTab');
          }
        }
        return false;
      });

      return rootPanel;
    })(),
    goHome: function () {
      $.DispatchEvent('Activated', this.rootPanel.GetParent().GetParent().GetParent().FindChildInLayoutFile("MainMenuNavBarHome"), 'mouse');
    },
    addCommand: function (command, value = '') {
      var existingCommands = this.rootPanel.GetAttributeString('cmd', '');
      this.rootPanel.SetAttributeString('cmd', existingCommands + command + ' ' + value);
    },
    navigateToTab: function (tabID) {
      if (activeTab === tabID)
        return;

      if (activeTab) {
        var panelToHide = this.rootPanel.FindChildInLayoutFile(activeTab);
        panelToHide.RemoveClass('Active');
      }

      this.rootPanel.FindChildInLayoutFile(tabID + '_button').checked = true;

      activeTab = tabID;
      var activePanel = this.rootPanel.FindChildInLayoutFile(tabID);
      activePanel.AddClass('Active');
      activePanel.visible = true;
      activePanel.SetReadyForDisplay(true);
    },
    navigateToSubTab: function (tabID, subTabID) {
      if (activeSubTab[tabID] === subTabID)
        return;

      if (activeSubTab[tabID]) {
        var panelToHide = this.rootPanel.FindChildInLayoutFile(activeSubTab[tabID]);
        panelToHide.RemoveClass('Active');
      }

      this.rootPanel.FindChildInLayoutFile(subTabID + '_button').checked = true;

      activeSubTab[tabID] = subTabID;
      var activePanel = this.rootPanel.FindChildInLayoutFile(subTabID);
      activePanel.AddClass('Active');
      activePanel.visible = true;
      activePanel.SetReadyForDisplay(true);
    },
    sliderUpdated: function (tabID, sliderID, slider) {
      this.addCommand('set', tabID + '/' + sliderID + '/' + Math.floor(slider.value));
    },
    sliderTextEntryUpdated: function (tabID, sliderID, panel) {
      this.addCommand('set', tabID + '/' + sliderID + '/' + panel.text);
    }
  };
})();

(function () {
  var createNavbar = function () {
    var navbar = $.CreatePanel('Panel', $.Osiris.rootPanel, '', {
      class: "content-navbar__tabs content-navbar__tabs--noflow"
    });

    var leftContainer = $.CreatePanel('Panel', navbar, '', {
      style: "horizontal-align: left; flow-children: right; height: 100%; margin-left: 15px;"
    });

    var activeCfgNameLabel = $.CreatePanel('Label', leftContainer, 'ActiveConfigName', {
      text: "default.cfg"
    });

    activeCfgNameLabel.SetPanelEvent('onmouseover', function () { UiToolkitAPI.ShowTextTooltip('ActiveConfigName', 'Active config file. Changes are saved automatically.'); });
    activeCfgNameLabel.SetPanelEvent('onmouseout', function () { UiToolkitAPI.HideTextTooltip(); });

    var restoreDefaultsButton = $.CreatePanel('Button', leftContainer, 'RestoreDefaultsButton', {
      class: "content-navbar__tabs__btn",
      style: "margin-left: 5px;",
      onactivate: "UiToolkitAPI.ShowGenericPopupOneOptionCustomCancelBgStyle('Restore Defaults', 'Are you sure you want to restore default settings in the active config file (default.cfg)?', '', 'RESTORE DEFAULTS', function() { $.Osiris.addCommand('restore_defaults'); }, 'RETURN', function() {}, 'dim');"
    });

    restoreDefaultsButton.SetPanelEvent('onmouseover', function () { UiToolkitAPI.ShowTextTooltip('RestoreDefaultsButton', 'Restore defaults'); });
    restoreDefaultsButton.SetPanelEvent('onmouseout', function () { UiToolkitAPI.HideTextTooltip(); });

    $.CreatePanel('Image', restoreDefaultsButton, '', {
      src: "s2r://panorama/images/icons/ui/recent.vsvg",
      texturewidth: "24"
    });
  
    var centerContainer = $.CreatePanel('Panel', navbar, '', {
      class: "content-navbar__tabs__center-container",
    });

    var combatTabButton = $.CreatePanel('RadioButton', centerContainer, 'combat_button', {
      group: "SettingsNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToTab('combat');"
    });

    $.CreatePanel('Label', combatTabButton, '', { text: "Combat" });

    var hudTabButton = $.CreatePanel('RadioButton', centerContainer, 'hud_button', {
      group: "SettingsNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToTab('hud');"
    });

    $.CreatePanel('Label', hudTabButton, '', { text: "HUD" });

    var visualsTabButton = $.CreatePanel('RadioButton', centerContainer, 'visuals_button', {
      group: "SettingsNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToTab('visuals');"
    });

    $.CreatePanel('Label', visualsTabButton, '', { text: "Visuals" });
    
    var soundTabButton = $.CreatePanel('RadioButton', centerContainer, 'sound_button', {
      group: "SettingsNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToTab('sound');"
    });

    $.CreatePanel('Label', soundTabButton, '', { text: "Sound" });

    var rightContainer = $.CreatePanel('Panel', navbar, '', {
        style: "horizontal-align: right; flow-children: right; height: 100%; margin-right: 70px;"
    });

    var unloadButton = $.CreatePanel('Button', rightContainer, 'UnloadButton', {
        class: "content-navbar__tabs__btn",
        onactivate: "UiToolkitAPI.ShowGenericPopupOneOptionCustomCancelBgStyle('Unload Osiris', 'Are you sure you want to unload Osiris?', '', 'UNLOAD', function() { $.Osiris.goHome(); $.Osiris.addCommand('unload'); }, 'RETURN', function() {}, 'dim');"
    });

    unloadButton.SetPanelEvent('onmouseover', function () { UiToolkitAPI.ShowTextTooltip('UnloadButton', 'Unload'); });
    unloadButton.SetPanelEvent('onmouseout', function () { UiToolkitAPI.HideTextTooltip(); });

    $.CreatePanel('Image', unloadButton, '', {
        src: "s2r://panorama/images/icons/ui/cancel.vsvg",
        texturewidth: "24",
        class: "negativeColor"
    });
  };

  var createVisualsNavbar = function () {
    var navbar = $.CreatePanel('Panel', $.Osiris.rootPanel.FindChildInLayoutFile('visuals'), '', {
      class: "content-navbar__tabs content-navbar__tabs--dark content-navbar__tabs--noflow"
    });

    var centerContainer = $.CreatePanel('Panel', navbar, '', {
      class: "content-navbar__tabs__center-container",
    });

    var playerInfoTabButton = $.CreatePanel('RadioButton', centerContainer, 'player_info_button', {
      group: "VisualsNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToSubTab('visuals', 'player_info');"
    });

    $.CreatePanel('Label', playerInfoTabButton, '', { text: "Player Info In World" });

    var outlineGlowTabButton = $.CreatePanel('RadioButton', centerContainer, 'outline_glow_button', {
      group: "VisualsNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToSubTab('visuals', 'outline_glow');"
    });

    $.CreatePanel('Label', outlineGlowTabButton, '', { text: "Outline Glow" });

    var modelGlowTabButton = $.CreatePanel('RadioButton', centerContainer, 'model_glow_button', {
        group: "VisualsNavBar",
        class: "content-navbar__tabs__btn",
        onactivate: "$.Osiris.navigateToSubTab('visuals', 'model_glow');"
    });

    $.CreatePanel('Label', modelGlowTabButton, '', { text: "Model Glow" });
  
    var viewmodelTabButton = $.CreatePanel('RadioButton', centerContainer, 'viewmodel_button', {
        group: "VisualsNavBar",
        class: "content-navbar__tabs__btn",
        onactivate: "$.Osiris.navigateToSubTab('visuals', 'viewmodel');"
    });

    $.CreatePanel('Label', viewmodelTabButton, '', { text: "Viewmodel" });
  };

  var createCombatNavbar = function () {
    var navbar = $.CreatePanel('Panel', $.Osiris.rootPanel.FindChildInLayoutFile('combat'), '', {
      class: "content-navbar__tabs content-navbar__tabs--dark content-navbar__tabs--noflow"
    });

    var centerContainer = $.CreatePanel('Panel', navbar, '', {
      class: "content-navbar__tabs__center-container",
    });

    var sniperRiflesTabButton = $.CreatePanel('RadioButton', centerContainer, 'sniper_rifles_button', {
      group: "CombatNavBar",
      class: "content-navbar__tabs__btn",
      onactivate: "$.Osiris.navigateToSubTab('combat', 'sniper_rifles');"
    });

    $.CreatePanel('Label', sniperRiflesTabButton, '', { text: "Sniper rifles" });
  };

  createNavbar();

  var settingContent = $.CreatePanel('Panel', $.Osiris.rootPanel, 'SettingsMenuContent', {
    class: "full-width full-height"
  });

  var createTab = function(tabName) {
    var tab = $.CreatePanel('Panel', settingContent, tabName, {
      useglobalcontext: "true",
      class: "SettingsMenuTab"
    });

    var content = $.CreatePanel('Panel', tab, '', {
      class: "SettingsMenuTabContent vscroll"
    });
  
    return content;
  };

  var createVisualsTab = function() {
    var tab = $.CreatePanel('Panel', settingContent, 'visuals', {
      useglobalcontext: "true",
      class: "SettingsMenuTab"
    });

    createVisualsNavbar();

    var content = $.CreatePanel('Panel', tab, '', {
      class: "full-width full-height"
    });
  
    return content;
  };

  var createCombatTab = function() {
    var tab = $.CreatePanel('Panel', settingContent, 'combat', {
      useglobalcontext: "true",
      class: "SettingsMenuTab"
    });

    createCombatNavbar();

    var content = $.CreatePanel('Panel', tab, '', {
      class: "full-width full-height"
    });
  
    return content;
  };

  var createSubTab = function(tab, subTabName) {
    var subTab = $.CreatePanel('Panel', tab, subTabName, {
      useglobalcontext: "true",
      class: "SettingsMenuTab"
    });

    var content = $.CreatePanel('Panel', subTab, '', {
      class: "SettingsMenuTabContent vscroll"
    });
    return content;
  };

  var createSection = function(tab, sectionName) {
    var background = $.CreatePanel('Panel', tab, '', {
      class: "SettingsBackground"
    });

    var titleContainer = $.CreatePanel('Panel', background, '', {
      class: "SettingsSectionTitleContianer"
    });

    $.CreatePanel('Label', titleContainer, '', {
      class: "SettingsSectionTitleLabel",
      text: sectionName
    });

    var content = $.CreatePanel('Panel', background, '', {
      class: "top-bottom-flow full-width"
    });

    return content;
  };

  var createDropDown = function (parent, labelText, section, feature, options) {
    var container = $.CreatePanel('Panel', parent, '', {
      class: "SettingsMenuDropdownContainer"
    });

    $.CreatePanel('Label', container, '', {
      class: "half-width",
      text: labelText
    });

    var dropdown = $.CreatePanel('CSGOSettingsEnumDropDown', container, feature, { class: "PopupButton White" });

    for (let i = 0; i < options.length; ++i) {
      dropdown.AddOption($.CreatePanel('Label', dropdown, i, {
      value: i,
      text: options[i]
      }));
    }
  };

  var createOnOffDropDown = function (parent, labelText, section, feature) {
    createDropDown(parent, labelText, section, feature, ["On", "Off"]);
  };

  var createYesNoDropDown = function (parent, labelText, section, feature) {
    createDropDown(parent, labelText, section, feature, ["Yes", "No"]);
  };

  var separator = function (parent) {
    $.CreatePanel('Panel', parent, '', { class: "horizontal-separator" });
  };

  var makeFauxItemId = function (defIndex, paintKitId) {
    return (BigInt(0xF000000000000000) | BigInt(paintKitId << 16) | BigInt(defIndex))
  };

  var createPlayerModelGlowPreview = function (parent, id, labelId, playerModel, itemId) {
    var container = $.CreatePanel('Panel', parent, '', { style: 'flow-children: none;' });
    var previewPanel = $.CreatePanel('MapPlayerPreviewPanel', container, id, {
      map: "ui/buy_menu",
      camera: "cam_loadoutmenu_ct",
      "require-composition-layer": true,
      playermodel: playerModel,
      playername: "vanity_character",
      animgraphcharactermode: "buy-menu",
      player: true,
      mouse_rotate: false,
      sync_spawn_addons: true,
      "transparent-background": true,
      "pin-fov": "vertical",
      csm_split_plane0_distance_override: "250.0",
      style: "y: 5px; vertical-align: top; width: 300px; height: 300px; horizontal-align: center;"
    });
    previewPanel.EquipPlayerWithItem(itemId);
    $.CreatePanel('Label', container, labelId, { style: 'vertical-align: top; horizontal-align: center;' });
  };

  var createGrenadeModelGlowPreview = function (parent, id, defIndex) {
    var container = $.CreatePanel('Panel', parent, '', { style: 'width: 80px; overflow: clip;' });
    var panel = $.CreatePanel('MapItemPreviewPanel', container, id, {
      map: "ui/xpshop_item",
      camera: "camera_weapon_4",
      "require-composition-layer": true,
      player: false,
      initial_entity: "item",
      mouse_rotate: false,
      sync_spawn_addons: true,
      "transparent-background": true,
      "pin-fov": "vertical",
      style: "x: -10px; horizontal-align: center; width: 200px; height: 80px;"
    });
    panel.SetItemItemId(makeFauxItemId(defIndex, 0), {});
  };
)"
// split the string literal because MSVC does not support string literals longer than 16k chars - error C2026
u8R"(
  var createSlider = function (parent, name, id, min, max) {
    var container = $.CreatePanel('Panel', parent, '', {
      class: "SettingsMenuDropdownContainer"
    });

    $.CreatePanel('Label', container, '', {
      class: "half-width",
      text: name
    });

    var sliderContainer = $.CreatePanel('Panel', container, id, {
      style: "vertical-align: center; horizontal-align: right; flow-children: right; margin-right: 8px;"
    });

    var slider = $.CreatePanel('Slider', sliderContainer, '', {
      class: "HorizontalSlider",
      style: "width: 200px; vertical-align: center;",
      direction: "horizontal"
    });

    slider.SetPanelEvent('onvaluechanged', function () { $.Osiris.sliderUpdated('visuals', id, slider); });
    slider.min = min;
    slider.max = max;
    slider.increment = 1.0;

    var textEntry = $.CreatePanel('TextEntry', sliderContainer, id + '_text', {
      maxchars: "3",
      textmode: "numeric",
      style: "width: 75px; margin-left: 10px; padding-left: 10px; text-align: center; font-size: 20px; color: #ccccccff; font-weight: bold; font-family: Stratum2, notosans, 'Arial Unicode MS'; border: 2px solid #cccccc15;"
    });

    textEntry.SetPanelEvent('ontextentrysubmit', function () { $.Osiris.sliderTextEntryUpdated('visuals', `${id}_text`, textEntry); });
    textEntry.SetPanelEvent('onfocus', function () { textEntry.style.backgroundColor = 'gradient(linear, 100% 0%, 0% 0%, from(#00000080), color-stop(0, #00000060), to(#00000080))'; });
    textEntry.SetPanelEvent('onblur', function () { textEntry.style.backgroundColor = 'none'; });
    textEntry.SetPanelEvent('onmouseover', function () { if (!textEntry.BHasKeyFocus()) textEntry.style.backgroundColor = 'gradient(linear, 100% 0%, 0% 0%, from(#000000ff), color-stop(0, #00000000), to(#00000050));'; });
    textEntry.SetPanelEvent('onmouseout', function () { if (!textEntry.BHasKeyFocus()) textEntry.style.backgroundColor = 'none'; });
  }

  var createHueSlider = function (parent, name, id, min, max) {
    var container = $.CreatePanel('Panel', parent, '', {
      class: "SettingsMenuDropdownContainer"
    });

    $.CreatePanel('Label', container, '', {
      class: "half-width",
      text: name
    });

    var sliderContainer = $.CreatePanel('Panel', container, id, {
      style: "vertical-align: center; horizontal-align: right; flow-children: right; margin-right: 8px;"
    });

    var slider = $.CreatePanel('Slider', sliderContainer, '', {
      class: "HorizontalSlider",
      style: "width: 200px; vertical-align: center;",
      direction: "horizontal"
    });

    slider.min = min;
    slider.max = max;
    slider.increment = 1.0;

    var textEntry = $.CreatePanel('TextEntry', sliderContainer, id + '_text', {
      maxchars: "3",
      textmode: "numeric",
      style: "width: 75px; margin-left: 10px; padding-left: 10px; text-align: center; font-size: 20px; color: #ccccccff; font-weight: bold; font-family: Stratum2, notosans, 'Arial Unicode MS'; border: 2px solid #cccccc15;"
    });

    textEntry.SetPanelEvent('onfocus', function () { textEntry.style.backgroundColor = 'gradient(linear, 100% 0%, 0% 0%, from(#00000080), color-stop(0, #00000060), to(#00000080))'; });
    textEntry.SetPanelEvent('onblur', function () { textEntry.style.backgroundColor = 'none'; });
    textEntry.SetPanelEvent('onmouseover', function () { if (!textEntry.BHasKeyFocus()) textEntry.style.backgroundColor = 'gradient(linear, 100% 0%, 0% 0%, from(#000000ff), color-stop(0, #00000000), to(#00000050));'; });
    textEntry.SetPanelEvent('onmouseout', function () { if (!textEntry.BHasKeyFocus()) textEntry.style.backgroundColor = 'none'; });

    $.CreatePanel('Panel', sliderContainer, id + '_color', {
        style: "border: 2px solid #000000a0; border-radius: 5px; margin-left: 10px; width: 25px; vertical-align: center; height: 25px;"
    });
  }
)"
// split the string literal because MSVC does not support string literals longer than 16k chars - error C2026
u8R"(
  var combat = createCombatTab();
  var sniperRiflesTab = createSubTab(combat, 'sniper_rifles');
  var noScope = createSection(sniperRiflesTab, 'No scope');
  separator(noScope);
  createYesNoDropDown(noScope, "Visualize Inaccuracy When Not Using a Scope", 'combat', 'no_scope_inacc_vis');

  $.Osiris.navigateToSubTab('combat', 'sniper_rifles');

  var hud = createTab('hud');
  
  var bomb = createSection(hud, 'Bomb');
  createYesNoDropDown(bomb, "Show Bomb Explosion Countdown And Site", 'hud', 'bomb_timer');
  separator(bomb);
  createYesNoDropDown(bomb, "Show Bomb Defuse Countdown", 'hud', 'defusing_alert');
  separator(bomb);
  createYesNoDropDown(bomb, "Show Bomb Plant Alert", 'hud', 'bomb_plant_alert');

  var killfeed = createSection(hud, 'Killfeed');
  separator(killfeed);
  createYesNoDropDown(killfeed, "Preserve My Killfeed During The Round", 'hud', 'preserve_killfeed');

  var time = createSection(hud, 'Time');
  separator(time);
  createYesNoDropDown(time, "Show Post-round Timer", 'hud', 'postround_timer');

  var visuals = createVisualsTab();

  var playerInfoTab = createSubTab(visuals, 'player_info');

  var playerInfo = createSection(playerInfoTab, 'Player Info In World');
  createDropDown(playerInfo, "Master Switch", 'visuals', 'player_information_through_walls', ['Enemies', 'All Players', 'Off']);

  var playerPosition = createSection(playerInfoTab, 'Player Position');
  createYesNoDropDown(playerPosition, "Show Player Position Arrow", 'visuals', 'player_info_position');
  separator(playerPosition);
  createDropDown(playerPosition, "Player Position Arrow Color", 'visuals', 'player_info_position_color', ['Player / Team Color', 'Team Color']);

  var playerHealth = createSection(playerInfoTab, 'Player Health');
  createYesNoDropDown(playerHealth, "Show Player Health", 'visuals', 'player_info_health');
  separator(playerHealth);
  createDropDown(playerHealth, "Player Health Text Color", 'visuals', 'player_info_health_color', ['Health-based', 'White']);

  var playerWeapon = createSection(playerInfoTab, 'Player Weapon');
  createYesNoDropDown(playerWeapon, "Show Player Active Weapon Icon", 'visuals', 'player_info_weapon');
  separator(playerWeapon);
  createYesNoDropDown(playerWeapon, "Show Player Active Weapon Ammo", 'visuals', 'player_info_weapon_clip');
  separator(playerWeapon);
  createYesNoDropDown(playerWeapon, 'Show Bomb Carrier Icon', 'visuals', 'player_info_bomb_carrier');
  separator(playerWeapon);
  createYesNoDropDown(playerWeapon, 'Show Bomb Planting Icon', 'visuals', 'player_info_bomb_planting');

  var playerIcons = createSection(playerInfoTab, 'Icons');
  createYesNoDropDown(playerIcons, "Show Defuse Icon", 'visuals', 'player_info_defuse');
  separator(playerIcons);
  createYesNoDropDown(playerIcons, 'Show Picking Up Hostage Icon', 'visuals', 'player_info_hostage_pickup');
  separator(playerIcons);
  createYesNoDropDown(playerIcons, 'Show Rescuing Hostage Icon', 'visuals', 'player_info_hostage_rescue');
  separator(playerIcons);
  createYesNoDropDown(playerIcons, 'Show Blinded By Flashbang Icon', 'visuals', 'player_info_blinded');

  var outlineGlowTab = createSubTab(visuals, 'outline_glow');

  var outlineGlow = createSection(outlineGlowTab, 'Outline Glow');
  createOnOffDropDown(outlineGlow, "Master Switch", 'visuals', 'outline_glow_enable');

  var playerOutlineGlow = createSection(outlineGlowTab, 'Players');
  createDropDown(playerOutlineGlow, "Glow Players", 'visuals', 'player_outline_glow', ['Enemies', 'All Players', 'Off']);
  separator(playerOutlineGlow);
  createDropDown(playerOutlineGlow, "Player Glow Color", 'visuals', 'player_outline_glow_color', ['Player / Team Color', 'Team Color', 'Health-based', 'Enemy / Ally']);
  separator(playerOutlineGlow);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Player Blue Hue", 'player_outline_glow_blue_hue', 191, 240);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Player Green Hue", 'player_outline_glow_green_hue', 110, 140);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Player Yellow Hue", 'player_outline_glow_yellow_hue', 47, 60);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Player Orange Hue", 'player_outline_glow_orange_hue', 11, 20);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Player Purple Hue", 'player_outline_glow_purple_hue', 250, 280);
  separator(playerOutlineGlow);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Team T Hue", 'player_outline_glow_t_hue', 30, 40);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Team CT Hue", 'player_outline_glow_ct_hue', 210, 230);
  separator(playerOutlineGlow);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "High Health Hue", 'player_outline_glow_high_hp_hue', 0, 359);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Low Health Hue", 'player_outline_glow_low_hp_hue', 0, 359);
  separator(playerOutlineGlow);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Enemy Hue", 'player_outline_glow_enemy_hue', 0, 359);
  separator(playerOutlineGlow);
  createHueSlider(playerOutlineGlow, "Ally Hue", 'player_outline_glow_ally_hue', 0, 359);

  var weaponOutlineGlow = createSection(outlineGlowTab, 'Weapons');
  createYesNoDropDown(weaponOutlineGlow, "Glow Weapons on Ground Nearby", 'visuals', 'weapon_outline_glow');
  separator(weaponOutlineGlow);
  createYesNoDropDown(weaponOutlineGlow, "Glow Grenade Projectiles", 'visuals', 'grenade_proj_outline_glow');
  separator(weaponOutlineGlow);
  separator(weaponOutlineGlow);
  createHueSlider(weaponOutlineGlow, "Flashbang Hue", 'outline_glow_flashbang_hue', 191, 250);
  separator(weaponOutlineGlow);
  createHueSlider(weaponOutlineGlow, "HE Grenade Hue", 'outline_glow_hegrenade_hue', 300, 359);
  separator(weaponOutlineGlow);
  createHueSlider(weaponOutlineGlow, "Smoke Grenade Hue", 'outline_glow_smoke_hue', 110, 140);
  separator(weaponOutlineGlow);
  createHueSlider(weaponOutlineGlow, "Molotov / Incendiary Grenade Hue", 'outline_glow_molotov_hue', 20, 60);

  var bombAndDefuseKitOutlineGlow = createSection(outlineGlowTab, 'Bomb & Defuse Kit');
  createYesNoDropDown(bombAndDefuseKitOutlineGlow, "Glow Dropped Bomb", 'visuals', 'dropped_bomb_outline_glow');
  separator(bombAndDefuseKitOutlineGlow);
  createYesNoDropDown(bombAndDefuseKitOutlineGlow, "Glow Ticking Bomb", 'visuals', 'ticking_bomb_outline_glow');
  separator(bombAndDefuseKitOutlineGlow);
  createYesNoDropDown(bombAndDefuseKitOutlineGlow, "Glow Defuse Kits on Ground Nearby", 'visuals', 'defuse_kit_outline_glow');
  separator(bombAndDefuseKitOutlineGlow);
  separator(bombAndDefuseKitOutlineGlow);
  createHueSlider(bombAndDefuseKitOutlineGlow, "Dropped Bomb Hue", 'outline_glow_dropped_bomb_hue', 0, 359);
  separator(bombAndDefuseKitOutlineGlow);
  createHueSlider(bombAndDefuseKitOutlineGlow, "Ticking Bomb Hue", 'outline_glow_ticking_bomb_hue', 0, 359);
  separator(bombAndDefuseKitOutlineGlow);
  createHueSlider(bombAndDefuseKitOutlineGlow, "Defuse Kit Hue", 'outline_glow_defuse_kit_hue', 0, 359);

  var hostageOutlineGlow = createSection(outlineGlowTab, 'Hostages');
  createYesNoDropDown(hostageOutlineGlow, "Glow Hostages", 'visuals', 'hostage_outline_glow');
  separator(hostageOutlineGlow);
  createHueSlider(hostageOutlineGlow, "Hostage Hue", 'outline_glow_hostage_hue', 0, 359);

  var _modelGlowTab = createSubTab(visuals, 'model_glow');
  _modelGlowTab.style.overflow = 'squish squish';
  _modelGlowTab.style.flowChildren = 'right';

  var modelGlowPreview = $.CreatePanel('Panel', _modelGlowTab, '', { style: 'flow-children: down;' });
  $.CreatePanel('Label', modelGlowPreview, '', { style: 'vertical-align: top; horizontal-align: center; font-size: 40;', text: 'Preview' });
  var playerModelGlowPreview = $.CreatePanel('Panel', modelGlowPreview, '', { style: 'flow-children: right; margin-top: 20px;' });
  createPlayerModelGlowPreview(playerModelGlowPreview, 'ModelGlowPreviewPlayerTT', 'ModelGlowPreviewPlayerTTLabel', 'characters/models/tm_professional/tm_professional_varf.vmdl', makeFauxItemId(7, 921));
  createPlayerModelGlowPreview(playerModelGlowPreview, 'ModelGlowPreviewPlayerCT', 'ModelGlowPreviewPlayerCTLabel', 'characters/models/ctm_st6/ctm_st6_variante.vmdl', makeFauxItemId(9, 819));

  $.CreatePanel('Label', modelGlowPreview, '', { style: 'horizontal-align: center; margin-top: 20px;', text: 'Weapons on the Ground' });

  var weaponModelGlowPreview = $.CreatePanel('Panel', modelGlowPreview, '', { style: 'flow-children: right;' });

  var modelGlowPreviewWeapon = $.CreatePanel('MapItemPreviewPanel', weaponModelGlowPreview, 'ModelGlowPreviewWeapon', {
    map: "ui/xpshop_item",
    camera: "camera_weapon_0",
    "require-composition-layer": true,
    player: false,
    initial_entity: "item",
    mouse_rotate: false,
    sync_spawn_addons: true,
    "transparent-background": true,
    "pin-fov": "vertical",
    style: "width: 400px; height: 160px;"
  });
  modelGlowPreviewWeapon.SetItemItemId(makeFauxItemId(16, 255), {});

  var grenadeModelGlowPreview = $.CreatePanel('Panel', weaponModelGlowPreview, '', { style: 'flow-children: down;' });

  var grenadeModelGlowPreviewRow1 = $.CreatePanel('Panel', grenadeModelGlowPreview, '', { style: 'flow-children: right;' });
  createGrenadeModelGlowPreview(grenadeModelGlowPreviewRow1, 'ModelGlowPreviewFlashbang', 43);
  createGrenadeModelGlowPreview(grenadeModelGlowPreviewRow1, 'ModelGlowPreviewHEGrenade', 44);

  var grenadeModelGlowPreviewRow2 = $.CreatePanel('Panel', grenadeModelGlowPreview, '', { style: 'flow-children: right;' });
  createGrenadeModelGlowPreview(grenadeModelGlowPreviewRow2, 'ModelGlowPreviewSmoke', 45);
  createGrenadeModelGlowPreview(grenadeModelGlowPreviewRow2, 'ModelGlowPreviewIncendiary', 48);

  var modelGlowTab = $.CreatePanel('Panel', _modelGlowTab, '', { style: 'flow-children: down; margin-right: 40px; overflow: squish scroll;' });

  var modelGlow = createSection(modelGlowTab, 'Model Glow');
  createOnOffDropDown(modelGlow, "Master Switch", 'visuals', 'model_glow_enable');

  var playerModelGlow = createSection(modelGlowTab, 'Players');
  createDropDown(playerModelGlow, "Glow Player Models", 'visuals', 'player_model_glow', ['Enemies', 'All Players', 'Off']);
  separator(playerModelGlow);
  createDropDown(playerModelGlow, "Player Model Glow Color Mode", 'visuals', 'player_model_glow_color', ['Player / Team Color', 'Team Color', 'Health-based', 'Enemy / Ally']);
  separator(playerModelGlow);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Player Blue Hue", 'player_model_glow_blue_hue', 191, 240);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Player Green Hue", 'player_model_glow_green_hue', 110, 140);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Player Yellow Hue", 'player_model_glow_yellow_hue', 47, 60);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Player Orange Hue", 'player_model_glow_orange_hue', 11, 20);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Player Purple Hue", 'player_model_glow_purple_hue', 250, 280);
  separator(playerModelGlow);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Team T Hue", 'player_model_glow_t_hue', 30, 40);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Team CT Hue", 'player_model_glow_ct_hue', 210, 230);
  separator(playerModelGlow);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "High Health Hue", 'player_model_glow_high_hp_hue', 0, 359);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Low Health Hue", 'player_model_glow_low_hp_hue', 0, 359);
  separator(playerModelGlow);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Enemy Hue", 'player_model_glow_enemy_hue', 0, 359);
  separator(playerModelGlow);
  createHueSlider(playerModelGlow, "Ally Hue", 'player_model_glow_ally_hue', 0, 359);
)"
// split the string literal because MSVC does not support string literals longer than 16k chars - error C2026
u8R"(
  var weaponModelGlow = createSection(modelGlowTab, 'Weapons');
  createYesNoDropDown(weaponModelGlow, "Glow Weapon Models on Ground", 'visuals', 'weapon_model_glow');
  separator(weaponModelGlow);
  createYesNoDropDown(weaponModelGlow, "Glow Grenade Projectile Models", 'visuals', 'grenade_proj_model_glow');
  separator(weaponModelGlow);
  separator(weaponModelGlow);
  createHueSlider(weaponModelGlow, "Flashbang Hue", 'model_glow_flashbang_hue', 191, 250);
  separator(weaponModelGlow);
  createHueSlider(weaponModelGlow, "HE Grenade Hue", 'model_glow_hegrenade_hue', 300, 359);
  separator(weaponModelGlow);
  createHueSlider(weaponModelGlow, "Smoke Grenade Hue", 'model_glow_smoke_hue', 110, 140);
  separator(weaponModelGlow);
  createHueSlider(weaponModelGlow, "Molotov / Incendiary Grenade Hue", 'model_glow_molotov_hue', 20, 60);

  var bombModelGlow = createSection(modelGlowTab, 'Bomb & Defuse Kit');
  createYesNoDropDown(bombModelGlow, "Glow Dropped Bomb Model", 'visuals', 'dropped_bomb_model_glow');
  separator(bombModelGlow);
  createYesNoDropDown(bombModelGlow, "Glow Ticking Bomb Model", 'visuals', 'ticking_bomb_model_glow');
  separator(bombModelGlow);
  createYesNoDropDown(bombModelGlow, "Glow Defuse Kit Models on Ground", 'visuals', 'defuse_kit_model_glow');
  separator(bombModelGlow);
  separator(bombModelGlow);
  createHueSlider(bombModelGlow, "Dropped Bomb Hue", 'model_glow_dropped_bomb_hue', 0, 359);
  separator(bombModelGlow);
  createHueSlider(bombModelGlow, "Ticking Bomb Hue", 'model_glow_ticking_bomb_hue', 0, 359);
  separator(bombModelGlow);
  createHueSlider(bombModelGlow, "Defuse Kit Hue", 'model_glow_defuse_kit_hue', 0, 359);

  var _viewmodelTab = createSubTab(visuals, 'viewmodel');
  _viewmodelTab.style.overflow = 'squish squish';
  _viewmodelTab.style.flowChildren = 'right';

  var viewmodelPreviewContainer = $.CreatePanel('Panel', _viewmodelTab, '', { style: 'flow-children: down;' });
  $.CreatePanel('Label', viewmodelPreviewContainer, '', { style: 'vertical-align: top; horizontal-align: center; font-size: 40;', text: 'Preview' });

  var viewmodelPreview = $.CreatePanel('MapItemPreviewPanel', viewmodelPreviewContainer, 'ViewmodelPreview', {
    map: "ui/xpshop_item",
    camera: "camera_weapon_0",
    "require-composition-layer": true,
    player: false,
    initial_entity: "item",
    mouse_rotate: false,
    sync_spawn_addons: true,
    "transparent-background": true,
    "pin-fov": "vertical",
    style: "width: 700px; height: 400px;"
  });
  viewmodelPreview.SetHideStaticGeometry(true);

  var viewmodelTab = $.CreatePanel('Panel', _viewmodelTab, '', { style: 'flow-children: down; margin-right: 40px; overflow: squish scroll;' });

  var viewmodelModification = createSection(viewmodelTab, 'Viewmodel Modification');
  createOnOffDropDown(viewmodelModification, "Master Switch", 'visuals', 'viewmodel_mod');

  var viewmodelFov = createSection(viewmodelTab, 'Viewmodel Fov');
  createYesNoDropDown(viewmodelFov, "Modify Viewmodel Fov", 'visuals', 'viewmodel_fov_mod');
  separator(viewmodelFov);
  createSlider(viewmodelFov, "Fov", 'viewmodel_fov', 40, 90);

  $.Osiris.navigateToSubTab('visuals', 'player_info');

  var sound = createTab('sound');
  
  var playerSoundVisualization = createSection(sound, 'Player Sound Visualization');
  separator(playerSoundVisualization);
  createYesNoDropDown(playerSoundVisualization, "Visualize Player Footstep Sound", 'sound', 'visualize_player_footsteps');

  var bombSoundVisualization = createSection(sound, 'Bomb Sound Visualization');
  createYesNoDropDown(bombSoundVisualization, "Visualize Bomb Plant Sound", 'sound', 'visualize_bomb_plant');
  separator(bombSoundVisualization);
  createYesNoDropDown(bombSoundVisualization, "Visualize Bomb Beep Sound", 'sound', 'visualize_bomb_beep');
  separator(bombSoundVisualization);
  createYesNoDropDown(bombSoundVisualization, "Visualize Bomb Defuse Sound", 'sound', 'visualize_bomb_defuse');

  var weaponSoundVisualization = createSection(sound, 'Weapon Sound Visualization');
  createYesNoDropDown(weaponSoundVisualization, "Visualize Weapon Scope Sound", 'sound', 'visualize_scope_sound');
  separator(weaponSoundVisualization);
  createYesNoDropDown(weaponSoundVisualization, "Visualize Weapon Reload Sound", 'sound', 'visualize_reload_sound');

  $.Osiris.navigateToTab('hud');
})();
)"

```

`Source/UI/Panorama/HudTab.h`:

```h
#pragma once

#include <GameClient/Panorama/PanoramaDropDown.h>
#include <Platform/Macros/FunctionAttributes.h>

template <typename HookContext>
class HudTab {
public:
    explicit HudTab(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void init(auto&& guiPanel) const
    {
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, BombTimerEnabled>>(guiPanel, "bomb_timer");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, DefusingAlertEnabled>>(guiPanel, "defusing_alert");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, KillfeedPreserverEnabled>>(guiPanel, "preserve_killfeed");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, PostRoundTimerEnabled>>(guiPanel, "postround_timer");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, BombPlantAlertEnabled>>(guiPanel, "bomb_plant_alert");
    }

    void updateFromConfig(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "bomb_timer", !GET_CONFIG_VAR(BombTimerEnabled));
        setDropDownSelectedIndex(mainMenu, "defusing_alert", !GET_CONFIG_VAR(DefusingAlertEnabled));
        setDropDownSelectedIndex(mainMenu, "preserve_killfeed", !GET_CONFIG_VAR(KillfeedPreserverEnabled));
        setDropDownSelectedIndex(mainMenu, "postround_timer", !GET_CONFIG_VAR(PostRoundTimerEnabled));
        setDropDownSelectedIndex(mainMenu, "bomb_plant_alert", !GET_CONFIG_VAR(BombPlantAlertEnabled));
    }

private:
    [[NOINLINE]] void setDropDownSelectedIndex(auto&& mainMenu, const char* dropDownId, int selectedIndex) const noexcept
    {
        mainMenu.findChildInLayoutFile(dropDownId).clientPanel().template as<PanoramaDropDown>().setSelectedIndex(selectedIndex);
    }

    template <typename Handler>
    void initDropDown(auto&& guiPanel, const char* panelId) const
    {
        auto&& dropDown = guiPanel.findChildInLayoutFile(panelId).clientPanel().template as<PanoramaDropDown>();
        dropDown.registerSelectionChangedHandler(&GuiEntryPoints<HookContext>::template dropDownSelectionChanged<Handler>);
    }

    HookContext& hookContext;
};

```

`Source/UI/Panorama/OnOffDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <HookContext/HookContextMacros.h>

template <typename HookContext, typename ConfigVariable>
struct OnOffDropdownSelectionChangeHandler {
    explicit OnOffDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        bool isOn;
        switch (selectedIndex) {
        case 0: isOn = true; break;
        case 1: isOn = false; break;
        default: return;
        }
        SET_CONFIG_VAR(ConfigVariable, isOn);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/PanoramaCommandDispatcher.h`:

```h
#pragma once

#include <string_view>

#include <GlobalContext/UnloadFlag.h>
#include <Utils/StringParser.h>

#include "SetCommandHandler.h"

template <typename HookContext>
struct PanoramaCommandDispatcher {
    PanoramaCommandDispatcher(const char* commandline, UnloadFlag& unloadFlag, HookContext& hookContext) noexcept
        : parser{commandline}
        , unloadFlag{unloadFlag}
        , hookContext{hookContext}
    {
    }

    void operator()() noexcept
    {
        std::string_view command{ parseNextCommand() };
        while (!command.empty()) {
            handleCommand(command);
            command = parseNextCommand();
        }
    }

private:
    [[nodiscard]] std::string_view parseNextCommand() noexcept
    {
        return parser.getLine(' ');
    }

    void handleCommand(std::string_view command) noexcept
    {
        if (command == "unload") {
            unloadFlag.set();
        } else if (command == "set") {
            SetCommandHandler{parser, hookContext}();
        } else if (command == "restore_defaults") {
            hookContext.config().restoreDefaults();
        }
    }

    StringParser parser;
    UnloadFlag& unloadFlag;
    HookContext& hookContext;
};

```

`Source/UI/Panorama/PanoramaGUI.h`:

```h
#pragma once

#include <CS2/Panorama/CUIPanel.h>
#include <GameClient/Entities/PreviewPlayer.h>
#include <Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreview.h>
#include <Features/Visuals/ModelGlow/Preview/PlayerModelGlowPreviewColorMode.h>
#include <Features/Visuals/ModelGlow/Preview/WeaponModelGlowPreview.h>
#include <GameClient/Entities/TeamNumber.h>
#include <GlobalContext/UnloadFlag.h>
#include <GameClient/Panorama/PanoramaLabel.h>
#include <GameClient/Panorama/PanoramaUiEngine.h>
#include <GameClient/Panorama/PanoramaUiPanel.h>
#include <GameClient/Panorama/Ui3dPanel.h>
#include <Utils/StringBuilder.h>

#include "PanoramaCommandDispatcher.h"
#include "CombatTab.h"
#include "HudTab.h"
#include "SoundTab.h"
#include "VisualsTab.h"
#include "Tabs/VisualsTab/ViewmodelModPreviewPanel.h"

template <typename HookContext>
class PlayerModelGlowPreviewPanel {
public:
    PlayerModelGlowPreviewPanel(HookContext& hookContext, cs2::CUIPanel* panel, TeamNumber teamNumber) noexcept
        : hookContext{hookContext}
        , panel{panel}
        , teamNumber{teamNumber}
    {
    }

    void update() const noexcept
    {
        if (!state().shouldUpdatePanel)
            return;

        StringBuilderStorage<100> storage;
        auto builder = storage.builder();
        builder.put(playerName(), ' ', teamName());

        if (state().colorMode == PlayerModelGlowPreviewColorMode::PlayerOrTeamColor) {
            if (const auto colorString = colorIndexToString()) {
                builder.put(" - ");
                builder.put(colorString);
            }
        } else if (state().colorMode == PlayerModelGlowPreviewColorMode::HealthBased) {
            builder.put(" - ", state().previewPlayerHealth, " HP");
        }

        labelPanel().setText(builder.cstring());
    }

private:
    [[nodiscard]] const char* playerName() const noexcept
    {
        switch (state().enemyTeam) {
        case EnemyTeam::Both: return "Enemy";
        case EnemyTeam::CT: return teamNumber == TeamNumber::CT ? "Enemy" : "Ally";
        case EnemyTeam::T: return teamNumber == TeamNumber::TT ? "Enemy" : "Ally";
        default: return "Player";
        }
    }

    [[nodiscard]] const char* teamName() const noexcept
    {
        return teamNumber == TeamNumber::TT ? "T" : "CT";
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.playerModelGlowPreviewState();
    }

    [[nodiscard]] decltype(auto) labelPanel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(panel).clientPanel().template as<PanoramaLabel>();
    }

    [[nodiscard]] const char* colorIndexToString() const noexcept
    {
        switch (state().previewPlayerColorIndex) {
        using enum cs2::PlayerColorIndex;
        case Blue: return "Blue";
        case Green: return "Green";
        case Yellow: return "Yellow";
        case Orange: return "Orange";
        case Purple: return "Purple";
        default: return nullptr;
        }
    }

    HookContext& hookContext;
    cs2::CUIPanel* panel;
    TeamNumber teamNumber;
};

template <typename HookContext>
class PanoramaGUI {
public:
    explicit PanoramaGUI(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void init(auto&& mainMenu) noexcept
    {
        if (!mainMenu)
            return;

        // ensure settings tab is loaded because we use CSS classes from settings
        // TODO: replace use of settings CSS classes with raw style properties
        uiEngine().runScript(mainMenu, "if (!$('#JsSettings')) MainMenu.NavigateToTab('JsSettings', 'settings/settings');");

        const auto settings = mainMenu.findChildInLayoutFile("JsSettings");
        if (settings)
            state().settingsPanelHandle = settings.getHandle();

        uiEngine().runScript(settings, reinterpret_cast<const char*>(
#include "CreateGUI.js"
));

        uiEngine().runScript(mainMenu, R"(
(function () {
  $('#JsSettings').FindChildInLayoutFile('OsirisMenuTab').SetParent($('#JsMainMenuContent'));

  var openMenuButton = $.CreatePanel('RadioButton', $.GetContextPanel().FindChildTraverse('MainMenuNavBarSettings').GetParent(), 'OsirisOpenMenuButton', {
    class: "mainmenu-top-navbar__radio-iconbtn",
    group: "NavBar",
    onactivate: "MainMenu.NavigateToTab('OsirisMenuTab', '');"
  });

  $.CreatePanel('Image', openMenuButton, '', {
    class: "mainmenu-top-navbar__radio-btn__icon",
    src: "s2r://panorama/images/icons/ui/bug.vsvg"
  });

  $.DispatchEvent('Activated', $.GetContextPanel().FindChildTraverse("MainMenuNavBarHome"), 'mouse');
})();
)");

        if (const auto guiButtonPanel = mainMenu.findChildInLayoutFile("OsirisOpenMenuButton"))
            state().guiButtonHandle = guiButtonPanel.getHandle();

        if (const auto guiPanel = mainMenu.findChildInLayoutFile("OsirisMenuTab")) {
            state().guiPanelHandle = guiPanel.getHandle();
            state().modelGlowPreviewPlayerLabelHandleTT = guiPanel.findChildInLayoutFile("ModelGlowPreviewPlayerTTLabel").getHandle();
            state().modelGlowPreviewPlayerLabelHandleCT = guiPanel.findChildInLayoutFile("ModelGlowPreviewPlayerCTLabel").getHandle();
            state().viewmodelPreviewPanelHandle = guiPanel.findChildInLayoutFile("ViewmodelPreview").getHandle();

            hookContext.template make<CombatTab>().init(guiPanel);
            hookContext.template make<HudTab>().init(guiPanel);
            hookContext.template make<VisualsTab>().init(guiPanel);
            hookContext.template make<SoundTab>().init(guiPanel);
        }

        updateFromConfig();
    }

    template <typename ConfigVariable>
    void onHueSliderValueChanged(const char* panelId, float value) const
    {
        const auto newVariableValue = handleHueSlider(panelId, value, ConfigVariable::ValueType::kMin, ConfigVariable::ValueType::kMax, GET_CONFIG_VAR(ConfigVariable));
        hookContext.config().template setVariable<ConfigVariable>(typename ConfigVariable::ValueType{newVariableValue});
    }

    template <typename ConfigVariable>
    void onHueSliderTextEntrySubmit(const char* panelId, const char* value) const noexcept
    {
        const auto newVariableValue = handleHueTextEntry(panelId, value, ConfigVariable::ValueType::kMin, ConfigVariable::ValueType::kMax, GET_CONFIG_VAR(ConfigVariable));
        hookContext.config().template setVariable<ConfigVariable>(typename ConfigVariable::ValueType{newVariableValue});
    }

    [[nodiscard]] decltype(auto) modelGlowPreviewPanel(const char* panelId) const noexcept
    {
        auto&& guiPanel = uiEngine().getPanelFromHandle(state().guiPanelHandle);
        return guiPanel.findChildInLayoutFile(panelId).clientPanel().template as<Ui3dPanel>();
    }

    void run(UnloadFlag& unloadFlag) const noexcept
    {
        auto&& guiPanel = uiEngine().getPanelFromHandle(state().guiPanelHandle);
        if (!guiPanel)
            return;

        auto&& playerModelGlowPreview = hookContext.template make<PlayerModelGlowPreview>();
        if (!playerModelGlowPreview.isPreviewPlayerSetTT())
            playerModelGlowPreview.setPreviewPlayerTT(guiPanel.findChildInLayoutFile("ModelGlowPreviewPlayerTT").clientPanel().template as<Ui3dPanel>().portraitWorld().findPreviewPlayer());
        if (!playerModelGlowPreview.isPreviewPlayerSetCT())
            playerModelGlowPreview.setPreviewPlayerCT(guiPanel.findChildInLayoutFile("ModelGlowPreviewPlayerCT").clientPanel().template as<Ui3dPanel>().portraitWorld().findPreviewPlayer());

        const auto cmdSymbol = uiEngine().makeSymbol(0, "cmd");
        const auto cmd = guiPanel.getAttributeString(cmdSymbol, "");
        PanoramaCommandDispatcher{cmd, unloadFlag, hookContext}();
        guiPanel.setAttributeString(cmdSymbol, "");

        hookContext.template make<PlayerModelGlowPreview>().update();
        hookContext.template make<PlayerModelGlowPreview>().hookPreviewPlayersSceneObjectUpdaters();

        hookContext.template make<WeaponModelGlowPreview>().updateSceneObjectUpdaterHooks();

        auto&& viewmodelModPreviewPanel = uiEngine().getPanelFromHandle(state().viewmodelPreviewPanelHandle).clientPanel().template as<ViewmodelModPreviewPanel>();
        viewmodelModPreviewPanel.setupPreviewModel();
        viewmodelModPreviewPanel.setFov();

        hookContext.template make<PlayerModelGlowPreviewPanel>(uiEngine().getPanelFromHandle(state().modelGlowPreviewPlayerLabelHandleTT), TeamNumber::TT).update();
        hookContext.template make<PlayerModelGlowPreviewPanel>(uiEngine().getPanelFromHandle(state().modelGlowPreviewPlayerLabelHandleCT), TeamNumber::CT).update();
    }

    void updateFromConfig() noexcept
    {
        const auto mainMenuPointer = hookContext.patternSearchResults().template get<MainMenuPanelPointer>();
        auto&& mainMenu = hookContext.template make<ClientPanel>(mainMenuPointer ? *mainMenuPointer : nullptr).uiPanel();
        hookContext.template make<CombatTab>().updateFromConfig(mainMenu);
        hookContext.template make<HudTab>().updateFromConfig(mainMenu);
        hookContext.template make<VisualsTab>().updateFromConfig(mainMenu);
        hookContext.template make<SoundTab>().updateFromConfig(mainMenu);
    }

    void onUnload() const noexcept
    {
        uiEngine().deletePanelByHandle(state().guiButtonHandle);
        uiEngine().deletePanelByHandle(state().guiPanelHandle);

        if (auto&& settingsPanel = uiEngine().getPanelFromHandle(state().settingsPanelHandle))
            uiEngine().runScript(settingsPanel, "delete $.Osiris");
    }

private:
    [[nodiscard]] decltype(auto) getHueSlider(const char* sliderId) const noexcept
    {
        auto&& guiPanel = uiEngine().getPanelFromHandle(state().guiPanelHandle);
        return hookContext.template make<HueSlider>(guiPanel.findChildInLayoutFile(sliderId));
    }

    [[nodiscard]] color::HueInteger handleHueTextEntry(const char* sliderId, const char* value, color::HueInteger min, color::HueInteger max, color::HueInteger current) const noexcept
    {
        auto&& hueSlider = getHueSlider(sliderId);
        color::HueInteger::UnderlyingType hueIntegral;
        if (!StringParser{value}.parseInt(hueIntegral) || hueIntegral < min || hueIntegral > max) {
            hueSlider.updateTextEntry(current);
            return current;
        }

        if (hueIntegral == current)
            return current;

        const color::HueInteger hue{hueIntegral};
        hueSlider.updateSlider(hue);
        hueSlider.updateColorPreview(hue);
        return hue;
    }

    [[nodiscard]] color::HueInteger handleHueSlider(const char* sliderId, float value, color::HueInteger min, color::HueInteger max, color::HueInteger current) const noexcept
    {
        const auto hueIntegral = static_cast<color::HueInteger::UnderlyingType>(value);
        if (hueIntegral < min || hueIntegral > max || hueIntegral == current)
            return current;

        const auto hue = color::HueInteger{hueIntegral};
        auto&& hueSlider = getHueSlider(sliderId);
        hueSlider.updateTextEntry(hue);
        hueSlider.updateColorPreview(hue);
        return hue;
    }

    [[nodiscard]] decltype(auto) uiEngine() const noexcept
    {
        return hookContext.template make<PanoramaUiEngine>();
    }

    [[nodiscard]] auto& state() const noexcept
    {
        return hookContext.panoramaGuiState();
    }

    HookContext& hookContext;
};

```

`Source/UI/Panorama/PanoramaGuiState.h`:

```h
#pragma once

#include <CS2/Panorama/PanelHandle.h>
#include "Tabs/VisualsTab/ViewmodelModPreviewPanelState.h"

struct PanoramaGuiState {
    cs2::PanelHandle guiPanelHandle;
    cs2::PanelHandle guiButtonHandle;
    cs2::PanelHandle settingsPanelHandle;
    cs2::PanelHandle modelGlowPreviewPlayerLabelHandleTT;
    cs2::PanelHandle modelGlowPreviewPlayerLabelHandleCT;
    cs2::PanelHandle viewmodelPreviewPanelHandle;
    ViewmodelModPreviewPanelState viewmodelModPreviewPanelState;
};

```

`Source/UI/Panorama/SetCommandHandler.h`:

```h
#pragma once

#include <Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVisConfigVariables.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorld.h>
#include <GameClient/Panorama/Slider.h>
#include <GameClient/Panorama/TextEntry.h>
#include <Platform/Macros/FunctionAttributes.h>
#include <Utils/StringParser.h>
#include "Tabs/VisualsTab/HueSlider.h"
#include "Tabs/VisualsTab/IntSlider.h"

template <typename HookContext>
struct SetCommandHandler {
    SetCommandHandler(StringParser& parser, HookContext& hookContext) noexcept
        : parser{parser}
        , hookContext{hookContext}
    {
    }

    void operator()() noexcept
    {
        if (const auto section = parser.getLine('/'); section == "combat") {
            handleCombatSection();
        } else if (section == "hud") {
            handleHudSection();
        } else if (section == "visuals") {
            handleVisualsSection();
        } else if (section == "sound") {
            handleSoundSection();
        }
    }

private:
    void handleCombatSection() noexcept
    {
    }

    void handleHudSection() const noexcept
    {
    }

    void handleSoundSection() const noexcept
    {
    }

    void handleVisualsSection() const noexcept
    {
        if (const auto feature = parser.getLine('/'); feature == "viewmodel_fov") {
            handleIntSlider<viewmodel_mod_vars::Fov>("viewmodel_fov");
        } else if (feature == "viewmodel_fov_text") {
            handleIntSliderTextEntry<viewmodel_mod_vars::Fov>("viewmodel_fov");
        }
    }

    template <typename ConfigVariable>
    void handleIntSlider(const char* sliderId) const noexcept
    {
        const auto newVariableValue = handleIntSlider(sliderId, ConfigVariable::ValueType::kMin, ConfigVariable::ValueType::kMax, GET_CONFIG_VAR(ConfigVariable));
        hookContext.config().template setVariable<ConfigVariable>(typename ConfigVariable::ValueType{newVariableValue});
    }

    [[nodiscard]] std::uint8_t handleIntSlider(const char* sliderId, std::uint8_t min, std::uint8_t max, std::uint8_t current) const noexcept
    {
        std::uint8_t value{};
        if (!parser.parseInt(value) || value == current || value < min || value > max)
            return current;

        auto&& hueSlider = getIntSlider(sliderId);
        hueSlider.updateTextEntry(value);
        return value;
    }

    template <typename ConfigVariable>
    void handleIntSliderTextEntry(const char* sliderId) const noexcept
    {
        const auto newVariableValue = handleIntSliderTextEntry(sliderId, ConfigVariable::ValueType::kMin, ConfigVariable::ValueType::kMax, GET_CONFIG_VAR(ConfigVariable));
        hookContext.config().template setVariable<ConfigVariable>(typename ConfigVariable::ValueType{newVariableValue});
    }

    [[nodiscard]] std::uint8_t handleIntSliderTextEntry(const char* sliderId, std::uint8_t min, std::uint8_t max, std::uint8_t current) const noexcept
    {
        auto&& slider = getIntSlider(sliderId);
        std::uint8_t value{};
        if (!parser.parseInt(value) || value < min || value > max) {
            slider.updateTextEntry(current);
            return current;
        }

        if (value == current)
            return current;

        slider.updateSlider(value);
        return value;
    }

    [[nodiscard]] decltype(auto) getIntSlider(const char* sliderId) const noexcept
    {
        const auto mainMenuPointer = hookContext.patternSearchResults().template get<MainMenuPanelPointer>();
        auto&& mainMenu = hookContext.template make<ClientPanel>(mainMenuPointer ? *mainMenuPointer : nullptr).uiPanel();
        return hookContext.template make<IntSlider>(mainMenu.findChildInLayoutFile(sliderId));
    }

    StringParser& parser;
    HookContext& hookContext;
};

```

`Source/UI/Panorama/SoundTab.h`:

```h
#pragma once

#include <GameClient/Panorama/PanoramaDropDown.h>
#include <Platform/Macros/FunctionAttributes.h>

template <typename HookContext>
class SoundTab {
public:
    explicit SoundTab(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void init(auto&& guiPanel) const
    {
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, FootstepSoundVisualizationEnabled>>(guiPanel, "visualize_player_footsteps");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, BombPlantSoundVisualizationEnabled>>(guiPanel, "visualize_bomb_plant");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, BombBeepSoundVisualizationEnabled>>(guiPanel, "visualize_bomb_beep");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, BombDefuseSoundVisualizationEnabled>>(guiPanel, "visualize_bomb_defuse");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, WeaponScopeSoundVisualizationEnabled>>(guiPanel, "visualize_scope_sound");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, WeaponReloadSoundVisualizationEnabled>>(guiPanel, "visualize_reload_sound");
    }

    void updateFromConfig(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "visualize_player_footsteps", !GET_CONFIG_VAR(FootstepSoundVisualizationEnabled));
        setDropDownSelectedIndex(mainMenu, "visualize_bomb_plant", !GET_CONFIG_VAR(BombPlantSoundVisualizationEnabled));
        setDropDownSelectedIndex(mainMenu, "visualize_bomb_beep", !GET_CONFIG_VAR(BombBeepSoundVisualizationEnabled));
        setDropDownSelectedIndex(mainMenu, "visualize_bomb_defuse", !GET_CONFIG_VAR(BombDefuseSoundVisualizationEnabled));
        setDropDownSelectedIndex(mainMenu, "visualize_scope_sound", !GET_CONFIG_VAR(WeaponScopeSoundVisualizationEnabled));
        setDropDownSelectedIndex(mainMenu, "visualize_reload_sound", !GET_CONFIG_VAR(WeaponReloadSoundVisualizationEnabled));
    }

private:
    [[NOINLINE]] void setDropDownSelectedIndex(auto&& mainMenu, const char* dropDownId, int selectedIndex) const noexcept
    {
        mainMenu.findChildInLayoutFile(dropDownId).clientPanel().template as<PanoramaDropDown>().setSelectedIndex(selectedIndex);
    }

    template <typename Handler>
    void initDropDown(auto&& guiPanel, const char* panelId) const
    {
        auto&& dropDown = guiPanel.findChildInLayoutFile(panelId).clientPanel().template as<PanoramaDropDown>();
        dropDown.registerSelectionChangedHandler(&GuiEntryPoints<HookContext>::template dropDownSelectionChanged<Handler>);
    }

    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/HueSlider.h`:

```h
#pragma once

#include <GameClient/Panorama/PanoramaUiPanel.h>
#include <GameClient/Panorama/Slider.h>
#include <Utils/ColorUtils.h>
#include <Utils/StringBuilder.h>

template <typename HookContext>
class HueSlider {
public:
    HueSlider(HookContext& hookContext, cs2::CUIPanel* _panel) noexcept
        : hookContext{hookContext}
        , _panel{_panel}
    {
    }

    void updateSlider(color::HueInteger hue) const noexcept
    {
        panel().children()[0].clientPanel().template as<Slider>().setValue(hue);
    }

    void updateTextEntry(color::HueInteger hue) const noexcept
    {
        panel().children()[1].clientPanel().template as<TextEntry>()
            .setText(StringBuilderStorage<100>{}.builder().put(static_cast<color::HueInteger::UnderlyingType>(hue)).cstring());
    }

    void updateColorPreview(color::HueInteger hue) const noexcept
    {
        panel().children()[2].setBackgroundColor(color::HSBtoRGB(hue, color::Saturation{0.7f}, color::Brightness{0.9f}));
    }

    void registerSliderValueChangedHandler(cs2::CSlider::SliderValueChangedEventHandler* func)
    {
        auto&& uiEngine = hookContext.template make<PanoramaUiEngine>();
        uiEngine.registerEventHandler(
            uiEngine.makeSymbol(0, "SliderValueChanged"),
            panel().children()[0],
            cs2::CUtlAbstractDelegate{func}
        );
    }

    void registerTextEntrySubmitHandler(cs2::CTextEntry::TextEntrySubmitEventHandler* func)
    {
        auto&& uiEngine = hookContext.template make<PanoramaUiEngine>();
        uiEngine.registerEventHandler(
            uiEngine.makeSymbol(0, "TextEntrySubmit"),
            panel().children()[1],
            cs2::CUtlAbstractDelegate{func}
        );
    }

private:
    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(_panel);
    }

    HookContext& hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/IntSlider.h`:

```h
#pragma once

#include <GameClient/Panorama/PanoramaUiPanel.h>
#include <GameClient/Panorama/Slider.h>
#include <Utils/StringBuilder.h>

template <typename HookContext>
class IntSlider {
public:
    IntSlider(HookContext& hookContext, cs2::CUIPanel* _panel) noexcept
        : hookContext{hookContext}
        , _panel{_panel}
    {
    }

    void updateSlider(std::uint8_t value) const noexcept
    {
        panel().children()[0].clientPanel().template as<Slider>().setValue(value);
    }

    void updateTextEntry(std::uint8_t value) const noexcept
    {
        panel().children()[1].clientPanel().template as<TextEntry>()
            .setText(StringBuilderStorage<100>{}.builder().put(value).cstring());
    }

private:
    [[nodiscard]] decltype(auto) panel() const noexcept
    {
        return hookContext.template make<PanoramaUiPanel>(_panel);
    }

    HookContext& hookContext;
    cs2::CUIPanel* _panel;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerInfoInWorldDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <optional>
#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerInfoInWorldDropdownSelectionChangeHandler {
    explicit PlayerInfoInWorldDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        bool enabled;
        std::optional<bool> onlyEnemies;

        switch (selectedIndex) {
        case 0: enabled = true; onlyEnemies = true; break;
        case 1: enabled = true; onlyEnemies = false; break;
        case 2: enabled = false; break;
        default: return;
        }

        SET_CONFIG_VAR(player_info_vars::Enabled, enabled);
        if (onlyEnemies.has_value())
            SET_CONFIG_VAR(player_info_vars::OnlyEnemies, *onlyEnemies);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler {
    explicit PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        PlayerHealthTextColor colorMode;
        switch (selectedIndex) {
        case 0: colorMode = PlayerHealthTextColor::HealthBased; break;
        case 1: colorMode = PlayerHealthTextColor::White; break;
        default: return;
        }

        SET_CONFIG_VAR(player_info_vars::PlayerHealthColorMode, colorMode);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <Features/Visuals/PlayerInfoInWorld/PlayerInfoInWorldConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler {
    explicit PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        PlayerPositionArrowColorType colorMode;
        switch (selectedIndex) {
        case 0: colorMode = PlayerPositionArrowColorType::PlayerOrTeamColor; break;
        case 1: colorMode = PlayerPositionArrowColorType::TeamColor; break;
        default: return;
        }

        SET_CONFIG_VAR(player_info_vars::PlayerPositionArrowColorMode, colorMode);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerModelGlowColorModeDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerModelGlowColorModeDropdownSelectionChangeHandler {
    explicit PlayerModelGlowColorModeDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        PlayerModelGlowColorType colorMode;
        switch (selectedIndex) {
        case 0: colorMode = PlayerModelGlowColorType::PlayerOrTeamColor; break;
        case 1: colorMode = PlayerModelGlowColorType::TeamColor; break;
        case 2: colorMode = PlayerModelGlowColorType::HealthBased; break;
        case 3: colorMode = PlayerModelGlowColorType::EnemyAlly; break;
        default: return;
        }

        SET_CONFIG_VAR(model_glow_vars::PlayerGlowColorMode, colorMode);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerModelGlowDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <optional>
#include <Features/Visuals/ModelGlow/ModelGlowConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerModelGlowDropdownSelectionChangeHandler {
    explicit PlayerModelGlowDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        bool glowPlayers;
        std::optional<bool> glowOnlyEnemies;

        switch (selectedIndex) {
        case 0: glowPlayers = true; glowOnlyEnemies = true; break;
        case 1: glowPlayers = true; glowOnlyEnemies = false; break;
        case 2: glowPlayers = false; break;
        default: return;
        }

        SET_CONFIG_VAR(model_glow_vars::GlowPlayers, glowPlayers);
        if (glowOnlyEnemies.has_value())
            SET_CONFIG_VAR(model_glow_vars::GlowOnlyEnemies, *glowOnlyEnemies);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerOutlineGlowColorModeDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerOutlineGlowColorModeDropdownSelectionChangeHandler {
    explicit PlayerOutlineGlowColorModeDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        PlayerOutlineGlowColorType colorMode;

        switch (selectedIndex) {
        case 0: colorMode = PlayerOutlineGlowColorType::PlayerOrTeamColor; break;
        case 1: colorMode = PlayerOutlineGlowColorType::TeamColor; break;
        case 2: colorMode = PlayerOutlineGlowColorType::HealthBased; break;
        case 3: colorMode = PlayerOutlineGlowColorType::EnemyAlly; break;
        default: return;
        }

        SET_CONFIG_VAR(outline_glow_vars::PlayerGlowColorMode, colorMode);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/PlayerOutlineGlowDropdownSelectionChangeHandler.h`:

```h
#pragma once

#include <optional>
#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <HookContext/HookContextMacros.h>

template <typename HookContext>
struct PlayerOutlineGlowDropdownSelectionChangeHandler {
    explicit PlayerOutlineGlowDropdownSelectionChangeHandler(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void onSelectionChanged(int selectedIndex)
    {
        bool glowPlayers;
        std::optional<bool> glowOnlyEnemies;

        switch (selectedIndex) {
        case 0: glowPlayers = true; glowOnlyEnemies = true; break;
        case 1: glowPlayers = true; glowOnlyEnemies = false; break;
        case 2: glowPlayers = false; break;
        default: return;
        }

        SET_CONFIG_VAR(outline_glow_vars::GlowPlayers, glowPlayers);
        if (glowOnlyEnemies.has_value())
            SET_CONFIG_VAR(outline_glow_vars::GlowOnlyEnemies, *glowOnlyEnemies);
    }

private:
    HookContext& hookContext;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/ViewmodelModPreviewPanel.h`:

```h
#pragma once

#include <GameClient/Econ/FauxItemId.h>

template <typename HookContext>
class ViewmodelModPreviewPanel {
public:
    using RawType = cs2::CUI_Item3dPanel;

    ViewmodelModPreviewPanel(HookContext& hookContext, cs2::CUI_Item3dPanel* item3dPanel) noexcept
        : hookContext{hookContext}
        , item3dPanel{item3dPanel}
    {
    }

    void setupPreviewModel() const
    {
        auto&& previewPanel = panel();
        if (hookContext.template make<EntitySystem>().getEntityFromHandle2(state().previewWeaponHandle)) {
            state().hadPreviewWeaponHandle = true;
            if (state().recreatedPreviewWeapon) {
                previewPanel.template as<UiItem3dPanel>().startWeaponLookAt();
                state().recreatedPreviewWeapon = false;
            }
            return;
        }

        auto&& portraitWorld = previewPanel.portraitWorld();
        if (state().hadPreviewWeaponHandle && portraitWorld.isMapLoaded()) {
            previewPanel.template as<UiItem3dPanel>().createItem(FauxItemId{cs2::ItemDefinitionIndex::M9Bayonet, cs2::PaintKitIndex::MarbleFade});
            state().hadPreviewWeaponHandle = false;
            state().recreatedPreviewWeapon = true;
        }
        state().previewWeaponHandle = portraitWorld.findPreviewWeapon().baseEntity().handle();
    }

    void setFov() const
    {
        panel().setFov(fovForPreview());
    }

private:
    [[nodiscard]] decltype(auto) panel() const
    {
        return hookContext.template make<Ui3dPanel>(item3dPanel);
    }

    [[nodiscard]] float fovForPreview() const
    {
        auto&& viewmodelMod = hookContext.template make<ViewmodelMod>();
        if (viewmodelMod.fovModificationActive())
            return viewmodelMod.viewmodelFov();
        return viewmodelFovFromConVar();
    }

    [[nodiscard]] float viewmodelFovFromConVar() const
    {
        return GET_CONVAR_VALUE(cs2::viewmodel_fov).value_or(viewmodel_mod_params::kPreviewFallbackFov);
    }

    [[nodiscard]] auto& state() const
    {
        return hookContext.panoramaGuiState().viewmodelModPreviewPanelState;
    }

    HookContext& hookContext;
    cs2::CUI_Item3dPanel* item3dPanel;
};

```

`Source/UI/Panorama/Tabs/VisualsTab/ViewmodelModPreviewPanelState.h`:

```h
#pragma once

#include <CS2/Constants/EntityHandle.h>
#include <CS2/Panorama/PanelHandle.h>

struct ViewmodelModPreviewPanelState {
    bool hadPreviewWeaponHandle{true};
    bool recreatedPreviewWeapon{false};
    cs2::CEntityHandle previewWeaponHandle{cs2::INVALID_EHANDLE_INDEX};
};

```

`Source/UI/Panorama/VisualsTab.h`:

```h
#pragma once

#include <Features/Visuals/ModelGlow/ModelGlowState.h>
#include <Features/Visuals/PlayerInfoInWorld/PlayerStateIcons/PlayerStateIconsToShow.h>
#include <GameClient/Panorama/PanoramaDropDown.h>
#include <GameClient/Panorama/Slider.h>
#include <GameClient/Panorama/TextEntry.h>
#include <Platform/Macros/FunctionAttributes.h>
#include <EntryPoints/GuiEntryPoints.h>

#include "Tabs/VisualsTab/PlayerInfoInWorldDropdownSelectionChangeHandler.h"
#include "Tabs/VisualsTab/PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler.h"
#include "Tabs/VisualsTab/PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler.h"
#include "Tabs/VisualsTab/PlayerModelGlowColorModeDropdownSelectionChangeHandler.h"
#include "Tabs/VisualsTab/PlayerModelGlowDropdownSelectionChangeHandler.h"
#include "Tabs/VisualsTab/PlayerOutlineGlowColorModeDropdownSelectionChangeHandler.h"
#include "Tabs/VisualsTab/PlayerOutlineGlowDropdownSelectionChangeHandler.h"

template <typename HookContext>
class VisualsTab {
public:
    explicit VisualsTab(HookContext& hookContext) noexcept
        : hookContext{hookContext}
    {
    }

    void init(auto&& guiPanel) const noexcept
    {
        initPlayerInfoInWorldTab(guiPanel);
        initModelGlowTab(guiPanel);
        initOutlineGlowTab(guiPanel);
        initViewmodelTab(guiPanel);
    }

    void updateFromConfig(auto&& mainMenu) const noexcept
    {
        updatePlayerInfoInWorldTab(mainMenu);
        updateOutlineGlowTab(mainMenu);
        updateModelGlowTab(mainMenu);
        updateViewmodelTab(mainMenu);
    }

private:
    void initPlayerInfoInWorldTab(auto&& guiPanel) const
    {
        initDropDown<PlayerInfoInWorldDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_information_through_walls");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::PlayerPositionArrowEnabled>>(guiPanel, "player_info_position");
        initDropDown<PlayerInfoInWorldPlayerPositionArrowColorModeDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_info_position_color");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::PlayerHealthEnabled>>(guiPanel, "player_info_health");
        initDropDown<PlayerInfoInWorldPlayerHealthColorModeDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_info_health_color");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::ActiveWeaponIconEnabled>>(guiPanel, "player_info_weapon");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::ActiveWeaponAmmoEnabled>>(guiPanel, "player_info_weapon_clip");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::BombDefuseIconEnabled>>(guiPanel, "player_info_defuse");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::HostagePickupIconEnabled>>(guiPanel, "player_info_hostage_pickup");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::HostageRescueIconEnabled>>(guiPanel, "player_info_hostage_rescue");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::BlindedIconEnabled>>(guiPanel, "player_info_blinded");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::BombCarrierIconEnabled>>(guiPanel, "player_info_bomb_carrier");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, player_info_vars::BombPlantIconEnabled>>(guiPanel, "player_info_bomb_planting");
    }

    void initModelGlowTab(auto&& guiPanel) const
    {
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, model_glow_vars::Enabled>>(guiPanel, "model_glow_enable");
        initDropDown<PlayerModelGlowDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_model_glow");
        initDropDown<PlayerModelGlowColorModeDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_model_glow_color");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, model_glow_vars::GlowWeapons>>(guiPanel, "weapon_model_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, model_glow_vars::GlowDroppedBomb>>(guiPanel, "dropped_bomb_model_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, model_glow_vars::GlowTickingBomb>>(guiPanel, "ticking_bomb_model_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, model_glow_vars::GlowDefuseKits>>(guiPanel, "defuse_kit_model_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, model_glow_vars::GlowGrenadeProjectiles>>(guiPanel, "grenade_proj_model_glow");

        registerHueSliderUpdateHandler<model_glow_vars::PlayerBlueHue, "player_model_glow_blue_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::PlayerGreenHue, "player_model_glow_green_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::PlayerYellowHue, "player_model_glow_yellow_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::PlayerOrangeHue, "player_model_glow_orange_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::PlayerPurpleHue, "player_model_glow_purple_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::TeamTHue, "player_model_glow_t_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::TeamCTHue, "player_model_glow_ct_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::LowHealthHue, "player_model_glow_low_hp_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::HighHealthHue, "player_model_glow_high_hp_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::EnemyHue, "player_model_glow_enemy_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::AllyHue, "player_model_glow_ally_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::MolotovHue, "model_glow_molotov_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::FlashbangHue, "model_glow_flashbang_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::HEGrenadeHue, "model_glow_hegrenade_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::SmokeGrenadeHue, "model_glow_smoke_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::DroppedBombHue, "model_glow_dropped_bomb_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::TickingBombHue, "model_glow_ticking_bomb_hue">(guiPanel);
        registerHueSliderUpdateHandler<model_glow_vars::DefuseKitHue, "model_glow_defuse_kit_hue">(guiPanel);
    }

    void initOutlineGlowTab(auto&& guiPanel) const
    {
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::Enabled>>(guiPanel, "outline_glow_enable");
        initDropDown<PlayerOutlineGlowDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_outline_glow");
        initDropDown<PlayerOutlineGlowColorModeDropdownSelectionChangeHandler<HookContext>>(guiPanel, "player_outline_glow_color");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::GlowWeapons>>(guiPanel, "weapon_outline_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::GlowDefuseKits>>(guiPanel, "defuse_kit_outline_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::GlowGrenadeProjectiles>>(guiPanel, "grenade_proj_outline_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::GlowDroppedBomb>>(guiPanel, "dropped_bomb_outline_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::GlowTickingBomb>>(guiPanel, "ticking_bomb_outline_glow");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, outline_glow_vars::GlowHostages>>(guiPanel, "hostage_outline_glow");

        registerHueSliderUpdateHandler<outline_glow_vars::PlayerBlueHue, "player_outline_glow_blue_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::PlayerGreenHue, "player_outline_glow_green_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::PlayerYellowHue, "player_outline_glow_yellow_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::PlayerOrangeHue, "player_outline_glow_orange_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::PlayerPurpleHue, "player_outline_glow_purple_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::TeamTHue, "player_outline_glow_t_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::TeamCTHue, "player_outline_glow_ct_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::LowHealthHue, "player_outline_glow_low_hp_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::HighHealthHue, "player_outline_glow_high_hp_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::EnemyHue, "player_outline_glow_enemy_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::AllyHue, "player_outline_glow_ally_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::MolotovHue, "outline_glow_molotov_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::FlashbangHue, "outline_glow_flashbang_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::HEGrenadeHue, "outline_glow_hegrenade_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::SmokeGrenadeHue, "outline_glow_smoke_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::DroppedBombHue, "outline_glow_dropped_bomb_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::TickingBombHue, "outline_glow_ticking_bomb_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::DefuseKitHue, "outline_glow_defuse_kit_hue">(guiPanel);
        registerHueSliderUpdateHandler<outline_glow_vars::HostageHue, "outline_glow_hostage_hue">(guiPanel);
    }

    void initViewmodelTab(auto&& guiPanel) const
    {
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, viewmodel_mod_vars::Enabled>>(guiPanel, "viewmodel_mod");
        initDropDown<OnOffDropdownSelectionChangeHandler<HookContext, viewmodel_mod_vars::ModifyFov>>(guiPanel, "viewmodel_fov_mod");
    }

    template <typename Handler>
    void initDropDown(auto&& guiPanel, const char* panelId) const
    {
        auto&& dropDown = guiPanel.findChildInLayoutFile(panelId).clientPanel().template as<PanoramaDropDown>();
        dropDown.registerSelectionChangedHandler(&GuiEntryPoints<HookContext>::template dropDownSelectionChanged<Handler>);
    }

    template <typename ConfigVariable, TemplateParameterCstring kPanelId>
    void registerHueSliderUpdateHandler(auto&& guiPanel) const
    {
        auto&& hueSlider = hookContext.template make<HueSlider>(guiPanel.findChildInLayoutFile(kPanelId));
        hueSlider.registerSliderValueChangedHandler(&GuiEntryPoints<HookContext>::template hueSliderValueChanged<ConfigVariable, kPanelId>);
        hueSlider.registerTextEntrySubmitHandler(&GuiEntryPoints<HookContext>::template hueSliderTextEntrySubmit<ConfigVariable, kPanelId>);
    }

    void updatePlayerInfoInWorldTab(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "player_information_through_walls", playerInfoDropDownIndex());
        setDropDownSelectedIndex(mainMenu, "player_info_position", !GET_CONFIG_VAR(player_info_vars::PlayerPositionArrowEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_position_color", static_cast<int>(GET_CONFIG_VAR(player_info_vars::PlayerPositionArrowColorMode)));
        setDropDownSelectedIndex(mainMenu, "player_info_health", !GET_CONFIG_VAR(player_info_vars::PlayerHealthEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_health_color", static_cast<int>(GET_CONFIG_VAR(player_info_vars::PlayerHealthColorMode)));
        setDropDownSelectedIndex(mainMenu, "player_info_weapon", !GET_CONFIG_VAR(player_info_vars::ActiveWeaponIconEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_weapon_clip", !GET_CONFIG_VAR(player_info_vars::ActiveWeaponAmmoEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_bomb_carrier", !GET_CONFIG_VAR(player_info_vars::BombCarrierIconEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_bomb_planting", !GET_CONFIG_VAR(player_info_vars::BombPlantIconEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_defuse", !GET_CONFIG_VAR(player_info_vars::BombDefuseIconEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_hostage_pickup", !GET_CONFIG_VAR(player_info_vars::HostagePickupIconEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_hostage_rescue", !GET_CONFIG_VAR(player_info_vars::HostageRescueIconEnabled));
        setDropDownSelectedIndex(mainMenu, "player_info_blinded", !GET_CONFIG_VAR(player_info_vars::BlindedIconEnabled));
    }

    void updateOutlineGlowTab(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "outline_glow_enable", !GET_CONFIG_VAR(outline_glow_vars::Enabled));
        setDropDownSelectedIndex(mainMenu, "player_outline_glow", playerOutlineGlowDropDownIndex());
        setDropDownSelectedIndex(mainMenu, "player_outline_glow_color", static_cast<int>(GET_CONFIG_VAR(outline_glow_vars::PlayerGlowColorMode)));
        setDropDownSelectedIndex(mainMenu, "weapon_outline_glow", !GET_CONFIG_VAR(outline_glow_vars::GlowWeapons));
        setDropDownSelectedIndex(mainMenu, "grenade_proj_outline_glow", !GET_CONFIG_VAR(outline_glow_vars::GlowWeapons));
        setDropDownSelectedIndex(mainMenu, "dropped_bomb_outline_glow", !GET_CONFIG_VAR(outline_glow_vars::GlowDroppedBomb));
        setDropDownSelectedIndex(mainMenu, "ticking_bomb_outline_glow", !GET_CONFIG_VAR(outline_glow_vars::GlowTickingBomb));
        setDropDownSelectedIndex(mainMenu, "defuse_kit_outline_glow", !GET_CONFIG_VAR(outline_glow_vars::GlowDefuseKits));
        setDropDownSelectedIndex(mainMenu, "hostage_outline_glow", !GET_CONFIG_VAR(outline_glow_vars::GlowHostages));
        updateHueSlider<outline_glow_vars::PlayerBlueHue>(mainMenu, "player_outline_glow_blue_hue");
        updateHueSlider<outline_glow_vars::PlayerGreenHue>(mainMenu, "player_outline_glow_green_hue");
        updateHueSlider<outline_glow_vars::PlayerYellowHue>(mainMenu, "player_outline_glow_yellow_hue");
        updateHueSlider<outline_glow_vars::PlayerOrangeHue>(mainMenu, "player_outline_glow_orange_hue");
        updateHueSlider<outline_glow_vars::PlayerPurpleHue>(mainMenu, "player_outline_glow_purple_hue");
        updateHueSlider<outline_glow_vars::TeamTHue>(mainMenu, "player_outline_glow_t_hue");
        updateHueSlider<outline_glow_vars::TeamCTHue>(mainMenu, "player_outline_glow_ct_hue");
        updateHueSlider<outline_glow_vars::LowHealthHue>(mainMenu, "player_outline_glow_low_hp_hue");
        updateHueSlider<outline_glow_vars::HighHealthHue>(mainMenu, "player_outline_glow_high_hp_hue");
        updateHueSlider<outline_glow_vars::AllyHue>(mainMenu, "player_outline_glow_ally_hue");
        updateHueSlider<outline_glow_vars::EnemyHue>(mainMenu, "player_outline_glow_enemy_hue");
        updateHueSlider<outline_glow_vars::MolotovHue>(mainMenu, "outline_glow_molotov_hue");
        updateHueSlider<outline_glow_vars::FlashbangHue>(mainMenu, "outline_glow_flashbang_hue");
        updateHueSlider<outline_glow_vars::HEGrenadeHue>(mainMenu, "outline_glow_hegrenade_hue");
        updateHueSlider<outline_glow_vars::SmokeGrenadeHue>(mainMenu, "outline_glow_smoke_hue");
        updateHueSlider<outline_glow_vars::DroppedBombHue>(mainMenu, "outline_glow_dropped_bomb_hue");
        updateHueSlider<outline_glow_vars::TickingBombHue>(mainMenu, "outline_glow_ticking_bomb_hue");
        updateHueSlider<outline_glow_vars::DefuseKitHue>(mainMenu, "outline_glow_defuse_kit_hue");
        updateHueSlider<outline_glow_vars::HostageHue>(mainMenu, "outline_glow_hostage_hue");
    }

    void updateModelGlowTab(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "model_glow_enable", !GET_CONFIG_VAR(model_glow_vars::Enabled));
        setDropDownSelectedIndex(mainMenu, "player_model_glow", playerModelGlowDropDownIndex());
        setDropDownSelectedIndex(mainMenu, "player_model_glow_color", static_cast<int>(GET_CONFIG_VAR(model_glow_vars::PlayerGlowColorMode)));
        setDropDownSelectedIndex(mainMenu, "weapon_model_glow", !GET_CONFIG_VAR(model_glow_vars::GlowWeapons));
        setDropDownSelectedIndex(mainMenu, "grenade_proj_model_glow", !GET_CONFIG_VAR(model_glow_vars::GlowGrenadeProjectiles));
        setDropDownSelectedIndex(mainMenu, "dropped_bomb_model_glow", !GET_CONFIG_VAR(model_glow_vars::GlowDroppedBomb));
        setDropDownSelectedIndex(mainMenu, "ticking_bomb_model_glow", !GET_CONFIG_VAR(model_glow_vars::GlowTickingBomb));
        setDropDownSelectedIndex(mainMenu, "defuse_kit_model_glow", !GET_CONFIG_VAR(model_glow_vars::GlowDefuseKits));
        updateHueSlider<model_glow_vars::PlayerBlueHue>(mainMenu, "player_model_glow_blue_hue");
        updateHueSlider<model_glow_vars::PlayerGreenHue>(mainMenu, "player_model_glow_green_hue");
        updateHueSlider<model_glow_vars::PlayerYellowHue>(mainMenu, "player_model_glow_yellow_hue");
        updateHueSlider<model_glow_vars::PlayerOrangeHue>(mainMenu, "player_model_glow_orange_hue");
        updateHueSlider<model_glow_vars::PlayerPurpleHue>(mainMenu, "player_model_glow_purple_hue");
        updateHueSlider<model_glow_vars::TeamTHue>(mainMenu, "player_model_glow_t_hue");
        updateHueSlider<model_glow_vars::TeamCTHue>(mainMenu, "player_model_glow_ct_hue");
        updateHueSlider<model_glow_vars::LowHealthHue>(mainMenu, "player_model_glow_low_hp_hue");
        updateHueSlider<model_glow_vars::HighHealthHue>(mainMenu, "player_model_glow_high_hp_hue");
        updateHueSlider<model_glow_vars::AllyHue>(mainMenu, "player_model_glow_ally_hue");
        updateHueSlider<model_glow_vars::EnemyHue>(mainMenu, "player_model_glow_enemy_hue");
        updateHueSlider<model_glow_vars::MolotovHue>(mainMenu, "model_glow_molotov_hue");
        updateHueSlider<model_glow_vars::FlashbangHue>(mainMenu, "model_glow_flashbang_hue");
        updateHueSlider<model_glow_vars::HEGrenadeHue>(mainMenu, "model_glow_hegrenade_hue");
        updateHueSlider<model_glow_vars::SmokeGrenadeHue>(mainMenu, "model_glow_smoke_hue");
        updateHueSlider<model_glow_vars::DroppedBombHue>(mainMenu, "model_glow_dropped_bomb_hue");
        updateHueSlider<model_glow_vars::TickingBombHue>(mainMenu, "model_glow_ticking_bomb_hue");
        updateHueSlider<model_glow_vars::DefuseKitHue>(mainMenu, "model_glow_defuse_kit_hue");
    }

    void updateViewmodelTab(auto&& mainMenu) const noexcept
    {
        setDropDownSelectedIndex(mainMenu, "viewmodel_mod", !GET_CONFIG_VAR(viewmodel_mod_vars::Enabled));
        setDropDownSelectedIndex(mainMenu, "viewmodel_fov_mod", !GET_CONFIG_VAR(viewmodel_mod_vars::ModifyFov));
        updateSlider<viewmodel_mod_vars::Fov>(mainMenu, "viewmodel_fov");
    }

    template <typename ConfigVariable>
    void updateSlider(auto&& mainMenu, const char* sliderId) const noexcept
    {
        updateSlider(mainMenu, sliderId, GET_CONFIG_VAR(ConfigVariable));
    }

    void updateSlider(auto&& mainMenu, const char* sliderId, std::uint8_t value) const noexcept
    {
        auto&& slider = hookContext.template make<IntSlider>(mainMenu.findChildInLayoutFile(sliderId));
        slider.updateSlider(value);
        slider.updateTextEntry(value);
    }

    template <typename ConfigVariable>
    void updateHueSlider(auto&& mainMenu, const char* sliderId) const noexcept
    {
        updateHueSlider(mainMenu, sliderId, GET_CONFIG_VAR(ConfigVariable));
    }

    void updateHueSlider(auto&& mainMenu, const char* sliderId, color::HueInteger hue) const noexcept
    {
        auto&& hueSlider = hookContext.template make<HueSlider>(mainMenu.findChildInLayoutFile(sliderId));
        hueSlider.updateSlider(hue);
        hueSlider.updateTextEntry(hue);
        hueSlider.updateColorPreview(hue);
    }

    [[NOINLINE]] void setDropDownSelectedIndex(auto&& mainMenu, const char* dropDownId, int selectedIndex) const noexcept
    {
        mainMenu.findChildInLayoutFile(dropDownId).clientPanel().template as<PanoramaDropDown>().setSelectedIndex(selectedIndex);
    }

    [[nodiscard]] int playerInfoDropDownIndex() const noexcept
    {
        if (GET_CONFIG_VAR(player_info_vars::Enabled))
            return GET_CONFIG_VAR(player_info_vars::OnlyEnemies) ? 0 : 1;
        return 2;
    }

    [[nodiscard]] int playerOutlineGlowDropDownIndex() const noexcept
    {
        if (GET_CONFIG_VAR(outline_glow_vars::GlowPlayers))
            return GET_CONFIG_VAR(outline_glow_vars::GlowOnlyEnemies) ? 0 : 1;
        return 2;
    }

    [[nodiscard]] int playerModelGlowDropDownIndex() const noexcept
    {
        if (GET_CONFIG_VAR(model_glow_vars::GlowPlayers))
            return GET_CONFIG_VAR(model_glow_vars::GlowOnlyEnemies) ? 0 : 1;
        return 2;
    }

    HookContext& hookContext;
};

```

`Source/Utils/Align.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <limits>

namespace utils
{

template <std::size_t Size, std::size_t Alignment>
consteval std::size_t align() noexcept
{
    if constexpr (constexpr auto offset = Alignment - Size % Alignment; offset != Alignment) {
        static_assert(Size <= (std::numeric_limits<std::size_t>::max)() - offset, "Size is too large to align");
        return Size + offset;
    }
    return Size;
}

[[nodiscard]] inline std::size_t align(std::size_t size, std::size_t alignment) noexcept
{
    if (const auto offset = alignment - size % alignment; offset != alignment) {
        assert(size <= (std::numeric_limits<std::size_t>::max)() - offset && "Size is too large to align");
        return size + offset;
    }
    return size;
}

}

```

`Source/Utils/BitFlags.h`:

```h
#pragma once

#include <concepts>
#include <limits>
#include <type_traits>

template <typename Flag, std::integral StorageType>
    requires std::is_enum_v<Flag>
class BitFlags {
public:
    template <Flag flag>
    constexpr void set() noexcept
    {
        flags |= toMask<flag>();
    }

    template <Flag flag>
    constexpr void unset() noexcept
    {
        flags &= ~toMask<flag>();
    }

    template <Flag flag>
    [[nodiscard]] constexpr bool has() const noexcept
    {
        return (flags & toMask<flag>()) != 0;
    }

    [[nodiscard]] explicit constexpr operator bool() const noexcept
    {
        return flags != 0;
    }

private:
    template <Flag flag>
    static constexpr auto toMask() noexcept
    {
        static_assert(static_cast<std::underlying_type_t<Flag>>(flag) >= 0);
        static_assert(static_cast<std::underlying_type_t<Flag>>(flag) < std::numeric_limits<StorageType>::digits);
        return 1 << static_cast<std::underlying_type_t<Flag>>(flag);
    }

    StorageType flags{0};
};

```

`Source/Utils/Bits.h`:

```h
#pragma once

#include <cassert>
#include <concepts>

#include <Platform/Macros/IsPlatform.h>

#if IS_WIN64()
#include <intrin.h>
#endif

namespace bits
{

[[nodiscard]] inline int countrZero(unsigned int x) noexcept
{
    assert(x != 0 && "x must be non-zero");
#if IS_WIN64()
    unsigned long result;
    _BitScanForward(&result, x);
    return static_cast<int>(result);
#elif IS_LINUX()
    return __builtin_ctz(x);
#endif
}

template <std::unsigned_integral T>
[[nodiscard]] constexpr T clearRightmostSetBit(T value) noexcept
{
    return value & (value - 1);
}

}

```

`Source/Utils/CString.h`:

```h
#pragma once

struct CString {
    bool skipPrefix(const char* prefix) noexcept
    {
        while (*string == *prefix && *prefix != '\0') {
            ++string;
            ++prefix;
        }
        return *prefix == '\0';
    }

    const char* string;
};

```

`Source/Utils/CharUtils.h`:

```h
#pragma once

namespace utils
{

[[nodiscard]] constexpr wchar_t toUpper(wchar_t c) noexcept
{
    if (c >= L'a' && c <= L'z')
        return c - L'a' + L'A';
    return c;
}

}

```

`Source/Utils/ColorUtils.h`:

```h
#pragma once

#include <cstdint>

#include <CS2/Classes/Color.h>

#include "InRange.h"

namespace color
{

using Hue = InRange<float, 0.0f, 1.0f>;
using Saturation = InRange<float, 0.0f, 1.0f>;
using Brightness = InRange<float, 0.0f, 1.0f>;

struct HueInteger {
    using UnderlyingType = std::uint16_t;
    static constexpr UnderlyingType kMin{0};
    static constexpr UnderlyingType kMax{360};

    explicit constexpr HueInteger(UnderlyingType value) noexcept
        : value{value}
    {
    }

    [[nodiscard]] constexpr bool operator==(const HueInteger&) const = default;

    [[nodiscard]] constexpr operator UnderlyingType() const noexcept
    {
        return value;
    }

    [[nodiscard]] constexpr Hue toHueFloat() const noexcept
    {
        return Hue{value / 360.0f};
    }

private:
    InRange<UnderlyingType, kMin, kMax> value;
};

constexpr Hue kGreenHue{120.0f / 360.0f};
constexpr Hue kRedHue{0.0f / 360.0f};

[[nodiscard]] constexpr cs2::Color HSBtoRGB(Hue hue, Saturation saturation, Brightness brightness) noexcept
{
    constexpr auto kNumberOfHueSegments = 6;

    const auto huePosition = hue * kNumberOfHueSegments;
    const auto hueSegment = static_cast<int>(huePosition);
    const auto hueFractionInSegment = huePosition - hueSegment;

    const auto chroma = brightness * saturation;
    const auto max = brightness;
    const auto min = max - chroma;
    const auto midDescending = max - chroma * hueFractionInSegment;
    const auto midAscending = min + chroma * hueFractionInSegment;

    float r, g, b;
    switch (hueSegment) {
    case 0: r = max; g = midAscending; b = min; break;
    case 1: r = midDescending; g = max; b = min; break;
    case 2: r = min; g = max; b = midAscending; break;
    case 3: r = min; g = midDescending; b = max; break;
    case 4: r = midAscending; g = min; b = max; break;
    case 5: default: r = max; g = min; b = midDescending; break;
    }

    return cs2::Color{static_cast<std::uint8_t>(r * 255), static_cast<std::uint8_t>(g * 255), static_cast<std::uint8_t>(b * 255)};
}

[[nodiscard]] constexpr cs2::Color HSBtoRGB(HueInteger hue, Saturation saturation, Brightness brightness) noexcept
{
    return HSBtoRGB(hue.toHueFloat(), saturation, brightness);
}

}

```

`Source/Utils/DynamicArray.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <cstring>
#include <memory>
#include <type_traits>

#include <MemoryAllocation/MemoryAllocator.h>
#include <MemoryAllocation/MemoryDeleter.h>
#include <MemoryAllocation/UniquePtr.h>

template <typename T>
    requires std::is_trivially_copyable_v<T>
class DynamicArray {
public:
    DynamicArray() = default;
    DynamicArray(DynamicArray&&) = delete;
    DynamicArray(const DynamicArray&) = delete;
    DynamicArray& operator=(DynamicArray&&) = delete;
    DynamicArray& operator=(const DynamicArray&) = delete;

    [[nodiscard]] T* begin() noexcept
    {
        return memory.get();
    }

    [[nodiscard]] T* end() noexcept
    {
        return memory.get() + size;
    }

    [[nodiscard]] const T* begin() const noexcept
    {
        return memory.get();
    }

    [[nodiscard]] const T* end() const noexcept
    {
        return memory.get() + size;
    }

    [[nodiscard]] std::size_t getCapacity() const noexcept
    {
        return memory.get_deleter().getNumberOfElements();
    }

    [[nodiscard]] std::size_t getSize() const noexcept
    {
        return size;
    }

    [[nodiscard]] T& operator[](std::size_t index) noexcept
    {
        return elementAt(index);
    }

    [[nodiscard]] const T& operator[](std::size_t index) const noexcept
    {
        return elementAt(index);
    }

    bool pushBack(const T& value) noexcept
    {
        if (ensureCapacityForNewElement()) [[likely]] {
            new (memory.get() + size) T{ value };
            ++size;
            return true;
        }
        return false;
    }

    [[nodiscard]] T& back() noexcept
    {
        assert(size > 0);
        return elementAt(size - 1);
    }

    void popBack() noexcept
    {
        assert(size > 0);
        std::destroy_at(&back());
        --size;
    }

    void fastRemoveAt(std::size_t index) noexcept
    {
        elementAt(index) = back();
        popBack();
    }
    
    void clear() noexcept
    {
        std::destroy_n(memory.get(), size);
        size = 0;
    }

private:
    [[nodiscard]] static std::size_t calculateNewCapacity(std::size_t currentCapacity) noexcept
    {
        return currentCapacity + currentCapacity / 2 + 1;
    }

    [[nodiscard]] T& elementAt(std::size_t index) noexcept
    {
        assert(index < size);
        return memory.get()[index];
    }

    [[nodiscard]] const T& elementAt(std::size_t index) const noexcept
    {
        assert(index < size);
        return memory.get()[index];
    }

    [[nodiscard]] std::size_t calculateNewCapacity() const noexcept
    {
        return calculateNewCapacity(getCapacity());
    }

    [[nodiscard]] bool ensureCapacityForNewElement() noexcept
    {
        return size < getCapacity() || growMemory(calculateNewCapacity());
    }

    [[nodiscard]] bool growMemory(std::size_t newCapacity) noexcept
    {
        assert(newCapacity > getCapacity());
        if (const auto newMemory = createNewMemory(newCapacity)) {
            memory.reset(newMemory);
            memory.get_deleter() = MemoryDeleter<T[]>(newCapacity);
            return true;
        }
        return false;
    }

    [[nodiscard]] T* createNewMemory(std::size_t newCapacity) const noexcept
    {
        if (const auto newMemory = MemoryAllocator<T[]>::allocate(newCapacity)) {
            copyMemoryTo(newMemory);
            return reinterpret_cast<T*>(newMemory);
        }
        return nullptr;
    }

    void copyMemoryTo(std::byte* newMemory) const noexcept
    {
        if (size > 0)
            std::memcpy(newMemory, memory.get(), size * sizeof(T));
    }

    UniquePtr<T[]> memory;
    std::size_t size{0};
};

```

`Source/Utils/EnumFlags.h`:

```h
#pragma once

#include <type_traits>
#include "ToUnderlying.h"

template <typename Enum>
    requires std::is_enum_v<Enum> && (!std::is_same_v<std::underlying_type_t<Enum>, bool>)
class EnumFlags {
public:
    [[nodiscard]] constexpr bool has(Enum flag) const noexcept
    {
        return (value & toUnderlying(flag)) != 0;
    }

    [[nodiscard]] constexpr bool hasAny() const noexcept
    {
        return value != 0;
    }

    constexpr void set(Enum flag) noexcept
    {
        value |= toUnderlying(flag);
    }

    constexpr void setAll() noexcept
    {
        value = ~0;
    }

    constexpr void clear() noexcept
    {
        value = 0;
    }

private:
    std::underlying_type_t<Enum> value{0};
};

```

`Source/Utils/FieldFieldOffset.h`:

```h
#pragma once

#include <concepts>
#include <cstddef>

#include "OptionalPointee.h"

template <typename ClassType, typename TField, std::integral TOffset, std::size_t offsetFromField>
class FieldFieldOffset {
public:
    using OffsetType = TOffset;
    using FieldType = TField;

    explicit FieldFieldOffset(OffsetType offset) noexcept
        : offset{offset}
    {
    }

    [[nodiscard]] OptionalPointee<FieldType> of(ClassType* thisptr) const noexcept
    {
        using BytePointer = std::byte*;
        using FieldPointer = FieldType*;
        if (thisptr != nullptr && offset != OffsetType{})
            return OptionalPointee{FieldPointer(BytePointer(thisptr) + offset - offsetFromField)};
        return {};
    }

private:
    OffsetType offset{};
};

```

`Source/Utils/FieldOffset.h`:

```h
#pragma once

#include <cstddef>
#include <concepts>

#include "OptionalPointee.h"

template <typename ClassType, typename TField, std::integral TOffset>
struct FieldOffset {
    using OffsetType = TOffset;
    using FieldType = TField;

    FieldOffset() = default;

    explicit FieldOffset(const OffsetType* offsetPtr) noexcept
        : offset{offsetPtr ? *offsetPtr : OffsetType{}}
    {
    }

    explicit FieldOffset(OffsetType offset) noexcept
        : offset{offset}
    {
    }

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return offset > 0;
    }

    [[nodiscard]] OptionalPointee<FieldType> of(ClassType* thisptr) const noexcept
    {
        using BytePointer = std::byte*;
        using FieldPointer = FieldType*;
        if (thisptr != nullptr && offset > 0)
            return OptionalPointee{ FieldPointer(BytePointer(thisptr) + offset) };
        return {};
    }

private:
    OffsetType offset{};
};

```

`Source/Utils/FileSlice.h`:

```h
#pragma once

#include <cstddef>

struct FileSlice {
    [[nodiscard]] constexpr bool contains(FileSlice slice) const noexcept
    {
        return slice.startOffset >= startOffset && slice.length <= length && (slice.startOffset - startOffset) <= length - slice.length;
    }

    std::size_t startOffset{0};
    std::size_t length{0};
};

```

`Source/Utils/FlagsBuilder.h`:

```h
#pragma once

#include <concepts>
#include <type_traits>
#include <utility>

template <std::integral T, typename Flag>
class FlagsBuilder {
public:
    template <Flag flag>
    constexpr FlagsBuilder& set(bool b) noexcept
    {
        static_assert(std::in_range<T>(rawType<flag>()));
        if (b)
            flags |= static_cast<T>(flag);
        return *this;
    }

    [[nodiscard]] T get() noexcept
    {
        return flags;
    }

private:
    template <Flag flag>
    static constexpr auto rawType() noexcept
    {
        if constexpr (std::is_enum_v<Flag>)
            return static_cast<std::underlying_type_t<Flag>>(flag);
        else
            return flag;
    }

    T flags{};
};

```

`Source/Utils/GenericFunctionPointer.h`:

```h
#pragma once

#include <type_traits>

struct GenericFunctionPointer {
    template <typename FunctionPointer>
        requires std::is_pointer_v<FunctionPointer> && std::is_function_v<std::remove_pointer_t<FunctionPointer>>
    explicit(false) GenericFunctionPointer(FunctionPointer function) noexcept
        : value{ reinterpret_cast<void(*)()>(function) }
    {
    }

    template <typename FunctionPointer>
        requires std::is_pointer_v<FunctionPointer> && std::is_function_v<std::remove_pointer_t<FunctionPointer>>
    explicit(false) operator FunctionPointer() noexcept
    {
        return reinterpret_cast<FunctionPointer>(value);
    }

private:
    void (*value)();
};

```

`Source/Utils/GenericPointer.h`:

```h
#pragma once

struct GenericPointer {
    template <typename T>
    explicit(false) GenericPointer(T* pointer) noexcept
        : value{(void*)pointer}
    {
    }

    GenericPointer() = default;

    [[nodiscard]] explicit operator bool() const noexcept
    {
        return value != nullptr;
    }

    template <typename T>
    [[nodiscard]] T as() const noexcept
    {
        return T(value);
    }

private:
    void* value{};
};

```

`Source/Utils/HexChars.h`:

```h
#pragma once

#include <array>
#include <cstdint>
#include <optional>

[[nodiscard]] constexpr std::uint8_t hexDigitToDecimal(char hexDigit) noexcept
{
    if (hexDigit >= '0' && hexDigit <= '9')
        return hexDigit - '0';
    if (hexDigit >= 'A' && hexDigit <= 'F')
        return hexDigit - 'A' + 10;
    return 0xFF;
}

[[nodiscard]] constexpr bool isValidOneDigitHexNumber(std::uint8_t number) noexcept
{
    return (number & 0xF0) == 0;
}

constexpr auto hexCharsInByte = 2;

[[nodiscard]] constexpr std::optional<char> hexCharsToByte(std::array<char, hexCharsInByte> chars)
{
    const auto highFourBits = hexDigitToDecimal(chars[0]);
    const auto lowFourBits = hexDigitToDecimal(chars[1]);

    if (isValidOneDigitHexNumber(highFourBits) && isValidOneDigitHexNumber(lowFourBits))
        return static_cast<char>(highFourBits << 4 | lowFourBits);
    return {};
}

```

`Source/Utils/IdentityMacro.h`:

```h
#pragma once

#define IDENTITY(...) __VA_ARGS__

```

`Source/Utils/InRange.h`:

```h
#pragma once

#include <array>
#include <bit>
#include <cassert>
#include <cstddef>
#include <type_traits>

// workaround for clang < 18 not supporting float non-type template parameters
template <typename T>
struct BinaryRepresentationTemplateParameter {
    std::array<std::byte, sizeof(T)> binaryRepresentation;

    explicit(false) constexpr BinaryRepresentationTemplateParameter(T value) noexcept
        : binaryRepresentation{std::bit_cast<decltype(binaryRepresentation)>(value)}
    {
    }

    constexpr operator T() const noexcept
    {
        return std::bit_cast<T>(binaryRepresentation);
    }
};

template <typename T, BinaryRepresentationTemplateParameter<T> min, BinaryRepresentationTemplateParameter<T> max>
    requires (static_cast<T>(min) < static_cast<T>(max))
struct InRange {
    static constexpr auto kMin{static_cast<T>(min)};
    static constexpr auto kMax{static_cast<T>(max)};

    using ValueType = T;

    explicit constexpr InRange(T value) noexcept
        : value{value}
    {
        if (std::is_constant_evaluated()) {
            if (value < kMin || value > kMax)
                fail("Value out of range");
        } else {
            assert(value >= kMin);
            assert(value <= kMax);
        }
    }

    [[nodiscard]] constexpr bool operator==(const InRange&) const = default;

    [[nodiscard]] constexpr operator const T&() const noexcept
    {
        return value;
    }

private:
    void fail(const char*) {}

    T value;
};

template <typename T>
struct IsRangeConstrained : std::false_type {};

template <typename T, BinaryRepresentationTemplateParameter<T> min, BinaryRepresentationTemplateParameter<T> max>
struct IsRangeConstrained<InRange<T, min, max>> : std::true_type {};

```

`Source/Utils/LazyInitialized.h`:

```h
#pragma once

#include <cassert>
#include <utility>

template <typename T>
struct LazyInitialized {
    LazyInitialized() noexcept
        : empty{}
    {
    }

    LazyInitialized(const LazyInitialized&) = delete;
    LazyInitialized(LazyInitialized&&) = delete;
    LazyInitialized& operator=(const LazyInitialized&) = delete;
    LazyInitialized& operator=(LazyInitialized&&) = delete;

    template <typename... Args>
    void init(Args&&... args) noexcept
    {
        assert(!initialized);
        new (&value) T{ std::forward<Args>(args)... };
        initialized = true;
    }

    [[nodiscard]] T* operator->() noexcept
    {
        assert(initialized);
        return &value;
    }

    [[nodiscard]] T& operator*() noexcept
    {
        assert(initialized);
        return value;
    }

    ~LazyInitialized() noexcept
    {
        if (initialized)
            value.~T();
    }

private:
    struct Empty {};

    union {
        Empty empty;
        T value;
    };
    bool initialized = false;
};

```

`Source/Utils/Lvalue.h`:

```h
#pragma once

#include <type_traits>

namespace utils
{

template <typename T>
[[nodiscard]] decltype(auto) lvalue(std::remove_reference_t<T>& t) noexcept
{
    if constexpr (std::is_rvalue_reference_v<T>)
        return static_cast<std::remove_reference_t<T>>(t);
    else
        return t;
}

}

```

`Source/Utils/ManuallyDestructible.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <new>
#include <utility>

template <typename T>
struct ManuallyDestructible {
    ManuallyDestructible() = default;
    ManuallyDestructible(const ManuallyDestructible&) = delete;
    ManuallyDestructible(ManuallyDestructible&&) = delete;
    ManuallyDestructible& operator=(const ManuallyDestructible&) = delete;
    ManuallyDestructible& operator=(ManuallyDestructible&&) = delete;

    template <typename... Args>
    void initialize(Args&&... args) noexcept
    {
        assert(!isInitialized());
        object = new (&storage) T(std::forward<Args>(args)...);
    }

    [[nodiscard]] T* operator->() noexcept
    {
        assert(isInitialized());
        return object;
    }

    [[nodiscard]] T& operator*() noexcept
    {
        assert(isInitialized());
        return *object;
    }

    void destroy() noexcept
    {
        assert(isInitialized());
        object->~T();
        object = nullptr;
    }

    [[nodiscard]] bool isInitialized() const noexcept
    {
        return object != nullptr;
    }

private:
    T* object{nullptr};
    alignas(alignof(T)) std::byte storage[sizeof(T)]{};
};

```

`Source/Utils/MemorySection.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <span>

struct MemorySection {
    MemorySection() = default;

    explicit MemorySection(std::span<const std::byte> section) noexcept
        : base{reinterpret_cast<std::uintptr_t>(section.data())}
        , size{section.size()}
    {
    }

    [[nodiscard]] std::span<const std::byte> raw() const noexcept
    {
        return {reinterpret_cast<const std::byte*>(base), size};
    }

    [[nodiscard]] bool contains(std::uintptr_t address, std::size_t objectSize) const noexcept
    {
        return address >= base && size >= objectSize && (address - base) <= size - objectSize;
    }

    [[nodiscard]] bool contains(std::uintptr_t address) const noexcept
    {
        return address >= base && address - base < size;
    }

    [[nodiscard]] std::size_t offsetOf(std::uintptr_t address) const noexcept
    {
        assert(contains(address));
        return address - base;
    }

private:
    std::uintptr_t base{0};
    std::size_t size{0};
};

```

`Source/Utils/Meta.h`:

```h
#pragma once

#include <cstddef>

template <template <typename> typename ValueOfType, auto Value>
struct WithValue {
    template <typename T>
    struct Equal {
        static constexpr auto value = (ValueOfType<T>::value == Value);
    };

    template <typename T>
    struct LowerEqual {
        static constexpr auto value = (ValueOfType<T>::value <= Value);
    };

    template <typename T>
    struct Greater {
        static constexpr auto value = (ValueOfType<T>::value > Value);
    };
};

template <typename T>
struct SizeOf {
    static constexpr auto value = sizeof(T);
};

template <std::size_t N>
using WithSizeOf = WithValue<SizeOf, N>;

template <template <typename> typename TypeProjection, template <typename> typename ValueOfType>
struct Projected {
    template <typename T>
    struct Value {
        static constexpr auto value = ValueOfType<typename TypeProjection<T>::type>::value;
    };
};

```

`Source/Utils/Optional.h`:

```h
#pragma once

#include <cstdint>
#include <functional>
#include <optional>
#include <utility>

template <typename T>
class Optional;

template <>
class Optional<bool> {
public:
    Optional() = default;

    Optional(std::nullopt_t) noexcept
        : _value{Value::Unknown}
    {
    }

    Optional(bool value) noexcept
        : _value{value ? Value::True : Value::False}
    {
    }

    constexpr bool operator==(const Optional&) const = default;

    [[nodiscard]] bool hasValue() const noexcept
    {
        return _value != Value::Unknown;
    }

    [[nodiscard]] bool value() const noexcept
    {
        return _value == Value::True;
    }

    [[nodiscard]] bool valueOr(bool defaultValue) const noexcept
    {
        if (_value != Value::Unknown)
            return _value == Value::True;
        return defaultValue;
    }

    template <typename F>
    [[nodiscard]] auto transform(F&& f) const -> Optional<decltype(f(value()))>
    {
        if (hasValue())
            return f(value());
        return {};
    }

private:
    enum class Value : std::uint8_t {
        Unknown,
        False,
        True
    };

    Value _value{Value::Unknown};
};

template <typename T>
class Optional {
public:
    Optional() = default;

    Optional(std::nullopt_t) noexcept
        : optional{std::nullopt}
    {
    }

    template <typename U>
        requires std::is_constructible_v<std::optional<T>, U&&>
    explicit(!std::is_convertible_v<U, T>) Optional(U&& value) noexcept
        : optional{std::forward<U>(value)}
    {
    }

    constexpr bool operator==(const Optional&) const = default;

    [[nodiscard]] bool hasValue() const noexcept
    {
        return optional.has_value();
    }

    [[nodiscard]] const T& value() const noexcept
    {
        return *optional;
    }

    template <typename... Args>
    [[nodiscard]] T valueOr(Args&&... args) const noexcept
    {
        return optional.value_or(std::forward<Args>(args)...);
    }

    template <typename U>
    [[nodiscard]] Optional<bool> equal(const U& other) const noexcept
    {
        return compare(other, std::equal_to{});
    }

    template <typename U>
    [[nodiscard]] Optional<bool> notEqual(const U& other) const noexcept
    {
        return compare(other, std::not_equal_to{});
    }

    template <typename U>
    [[nodiscard]] Optional<bool> lessThan(const U& other) const noexcept
    {
        return compare(other, std::less{});
    }

    template <typename U>
    [[nodiscard]] Optional<bool> greaterThan(const U& other) const noexcept
    {
        return compare(other, std::greater{});
    }

    template <typename U>
    [[nodiscard]] Optional<bool> lessEqual(const U& other) const noexcept
    {
        return compare(other, std::less_equal{});
    }

    template <typename F>
    [[nodiscard]] auto transform(F&& f) const -> Optional<decltype(f(value()))>
    {
        if (hasValue())
            return f(value());
        return {};
    }

    template <typename F>
    [[nodiscard]] auto andThen(F&& f) const -> decltype(f(value()))
    {
        if (hasValue())
            return f(value());
        return {};
    }

private:
    template <typename U, typename Comparator>
    [[nodiscard]] Optional<bool> compare(const U& value, Comparator comparator) const noexcept
    {
        if (this->hasValue())
            return comparator(this->value(), value);
        return {};
    }

    template <typename U, typename Comparator>
    [[nodiscard]] Optional<bool> compare(const Optional<U>& other, Comparator comparator) const noexcept
    {
        if (hasValue() && other.hasValue())
            return comparator(value(), other.value());
        return {};
    }

    std::optional<T> optional;
};

template <typename T, typename U>
[[nodiscard]] auto operator+(const Optional<T>& lhs, const Optional<U>& rhs) noexcept -> Optional<decltype(lhs.value() + rhs.value())> 
{
    if (lhs.hasValue() && rhs.hasValue())
        return lhs.value() + rhs.value();
    return {};
}

template <typename T, typename U>
[[nodiscard]] auto operator+(const Optional<T>& optional, const U& value) noexcept -> Optional<decltype(optional.value() + value)>
{
    if (optional.hasValue())
        return optional.value() + value;
    return {};
}

template <typename T, typename U>
[[nodiscard]] auto operator-(const Optional<T>& lhs, const Optional<U>& rhs) noexcept -> Optional<decltype(lhs.value() - rhs.value())> 
{
    if (lhs.hasValue() && rhs.hasValue())
        return lhs.value() - rhs.value();
    return {};
}

template <typename T, typename U>
[[nodiscard]] auto operator-(const Optional<T>& optional, const U& value) noexcept -> Optional<decltype(optional.value() - value)>
{
    if (optional.hasValue())
        return optional.value() - value;
    return {};
}

template <typename T, typename U>
[[nodiscard]] auto operator&(const Optional<T>& lhs, const Optional<U>& rhs) noexcept -> Optional<decltype(lhs.value() & rhs.value())> 
{
    if (lhs.hasValue() && rhs.hasValue())
        return lhs.value() & rhs.value();
    return {};
}

template <typename T, typename U>
[[nodiscard]] auto operator&(const Optional<T>& optional, const U& value) noexcept -> Optional<decltype(optional.value() & value)>
{
    if (optional.hasValue())
        return optional.value() & value;
    return {};
}

```

`Source/Utils/OptionalPointee.h`:

```h
#pragma once

#include "Optional.h"

template <typename ValueType>
class OptionalPointee {
public:
    OptionalPointee() = default;

    explicit OptionalPointee(ValueType* pointer) noexcept
        : pointer{pointer}
    {
    }

    [[nodiscard]] ValueType* get() const noexcept
    {
        return pointer;
    }

    [[nodiscard]] Optional<ValueType> toOptional() const noexcept
    {
        if (pointer)
            return *pointer;
        return {};
    }

    [[nodiscard]] ValueType valueOr(const ValueType& defaultValue) const noexcept
    {
        if (pointer)
            return *pointer;
        return defaultValue;
    }

    void operator=(const ValueType& value) const noexcept
    {
        if (pointer)
            *pointer = value;
    }

private:
    ValueType* pointer{nullptr};
};

template <>
class OptionalPointee<void> {
public:
    OptionalPointee() = default;

    explicit OptionalPointee(void* pointer) noexcept
        : pointer{pointer}
    {
    }

    [[nodiscard]] void* get() const noexcept
    {
        return pointer;
    }

private:
    void* pointer{nullptr};
};

```

`Source/Utils/Pad.h`:

```h
#pragma once

#include <cstddef>

#define CONCAT(a, b) a##b
#define PAD_NAME(n) CONCAT(pad, n)

#define PAD(size) std::byte PAD_NAME(__LINE__) [size]

```

`Source/Utils/PrivateTag.h`:

```h
#pragma once

template <typename T>
class PrivateTag {
    PrivateTag() = default;
    friend T;
};

```

`Source/Utils/RefCountedHook.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <limits>

template <typename Hook>
class RefCountedHook {
public:
    void incrementReferenceCount() noexcept
    {
        assert(referenceCount < (std::numeric_limits<std::size_t>::max)());
        ++referenceCount;
    }

    void decrementReferenceCount() noexcept
    {
        assert(referenceCount > 0);
        --referenceCount;
    }

    void update() noexcept
    {
        if (isHooked()) {
            if (referenceCount == 0)
                static_cast<Hook&>(*this).uninstall();
        } else if (referenceCount > 0) {
            static_cast<Hook&>(*this).install();
        }
    }

    void forceUninstall() noexcept
    {
        if (isHooked())
            static_cast<Hook&>(*this).uninstall();
    }

private:
    [[nodiscard]] bool isHooked() const noexcept
    {
        return static_cast<const Hook&>(*this).isInstalled();
    }

    RefCountedHook() = default;
    friend Hook;

    std::size_t referenceCount{0};
};

```

`Source/Utils/ReturnAddress.h`:

```h
#pragma once

struct ReturnAddress {
    explicit ReturnAddress(const void* returnAddress) noexcept
        : returnAddress{ returnAddress }
    {
    }

    bool operator==(const ReturnAddress&) const = default;

private:
    const void* returnAddress;
};

```

`Source/Utils/SpanSlice.h`:

```h
#pragma once

#include <algorithm>
#include <cstddef>
#include <span>

template <std::size_t Size, typename T>
class SpanSlice {
public:
    SpanSlice(std::span<T> span, std::size_t centerOffset) noexcept
        : span{ span }, centerOffset{ centerOffset }
    {
    }

    [[nodiscard]] std::span<T> operator()() const noexcept
    {
        return span.subspan(getSliceStartOffset(), getSliceSize());
    }

private:
    [[nodiscard]] constexpr std::size_t getSliceSize() const noexcept
    {
        return (std::min)(span.size(), Size);
    }

    [[nodiscard]] constexpr std::size_t getSliceStartOffset() const noexcept
    {
        if (centerOffset < getSliceSize() / 2)
            return 0;
        if (centerOffset > span.size() - getSliceSize() / 2)
            return span.size() - getSliceSize();
        return centerOffset - getSliceSize() / 2;
    }

    std::span<T> span;
    std::size_t centerOffset;
};

```

`Source/Utils/StringBuilder.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cassert>
#include <charconv>
#include <concepts>
#include <cstddef>
#include <cstdint>
#include <system_error>
#include <span>
#include <string_view>
#include <utility>

class StringBuilder {
public:
    explicit StringBuilder(std::span<char> buffer)
        : buffer{ buffer }
    {
        assert(!buffer.empty());
    }

    template <typename... Args>
    StringBuilder& put(Args&&... args)
    {
        (putSingle(std::forward<Args>(args)), ...);
        return *this;
    }

    StringBuilder& putPointer(const void* pointer)
    {
        putSingleWithBase(reinterpret_cast<std::uintptr_t>(pointer), 16);
        return *this;
    }

    StringBuilder& putHex(std::integral auto value)
    {
        putSingleWithBase(value, 16);
        return *this;
    }

    [[nodiscard]] std::string_view string() const noexcept
    {
        return std::string_view{ buffer.data(), writePosition };
    }

    [[nodiscard]] const char* cstring() noexcept
    {
        *writePosition = '\0';
        return buffer.data();
    }

private:
    template <std::invocable<StringBuilder&> Invocable>
    void putSingle(Invocable invocable)
    {
        invocable(*this);
    }

    void putSingle(const char* str)
    {
        while (writePosition != writeEndPosition() && *str != '\0')
            *writePosition++ = *str++;
    }

    template <typename T>
    void putSingle(const T* pointer)
    {
        putPointer(pointer);
    }

    void putSingle(std::integral auto value)
    {
        putSingleWithBase(value, 10);
    }

    void putSingleWithBase(std::integral auto value, int base)
    {
        const auto result = std::to_chars(writePosition, writeEndPosition(), value, base);
        if (result.ec == std::errc{})
            writePosition = result.ptr;
    }

    void putSingle(char c)
    {
        if (writePosition != writeEndPosition()) {
            *writePosition = c;
            ++writePosition;
        }
    }

    void putSingle(std::string_view str)
    {
        const auto sizeToCopy = (std::min)(str.size(), unusedSpace());
        writePosition = std::copy_n(str.data(), sizeToCopy, writePosition);
    }

    [[nodiscard]] char* writeEndPosition() noexcept
    {
        return &buffer[capacityExcludingNullTerminator()];
    }

    [[nodiscard]] std::size_t unusedSpace() noexcept
    {
        return writeEndPosition() - writePosition;
    }

    [[nodiscard]] std::size_t capacityExcludingNullTerminator() const noexcept
    {
        return buffer.size() - 1;
    }

    std::span<char> buffer;
    char* writePosition = buffer.data();
};

template <std::size_t Capacity>
struct StringBuilderStorage {
    StringBuilderStorage()
    {
        // prevents zeroing the buffer in zero initialization
    }

    StringBuilder builder()
    {
        return StringBuilder{ buffer };
    }

private:
    std::array<char, Capacity> buffer;
};

```

`Source/Utils/StringParser.h`:

```h
#pragma once

#include <concepts>
#include <cstddef>
#include <limits>
#include <string_view>

class StringParser {
public:
    explicit StringParser(const char* string) noexcept
        : string{ string }
    {
    }

    [[nodiscard]] std::string_view getLine(char delimiter) noexcept
    {
        const auto begin = string;
        std::size_t length = 0;
        while (*string != '\0' && *string++ != delimiter)
            ++length;
        return { begin, length };
    }

    [[nodiscard]] char getChar() noexcept
    {
        if (*string != '\0')
            return *string++;
        return '\0';
    }

    template <std::integral IntegralType>
    bool parseInt(IntegralType& result) noexcept
    {
        static_assert(std::is_unsigned_v<IntegralType>);

        IntegralType parsedInteger{};
        bool parseSuccessful = false;

        std::size_t currentDigit = 0;
        while (*string >= '0' && *string <= '9') {
            if (currentDigit < std::numeric_limits<IntegralType>::digits10) {
                parsedInteger *= 10;
                parsedInteger += (*string - '0');
                ++currentDigit;
                parseSuccessful = true;
            } else {
                parseSuccessful = false;
            }

            ++string;
        }

        if (parseSuccessful)
            result = parsedInteger;

        return parseSuccessful;
    }

    template <std::floating_point FloatType>
    bool parseFloat(FloatType& result) noexcept
    {
        FloatType parsedFloat{};
        bool parseSuccessful = false;

        if (*string == '-') {
            // unsupported
            return false;
        }

        while (*string >= '0' && *string <= '9') {
            parsedFloat *= 10.0f;
            parsedFloat += static_cast<FloatType>(*string - '0');
            parseSuccessful = true;
            ++string;
        }

        if (*string == '.')
            ++string;

        FloatType fraction = 1.0f;
        while (*string >= '0' && *string <= '9') {
            fraction /= 10.0f;
            parsedFloat += static_cast<FloatType>(*string - '0') * fraction;
            parseSuccessful = true;
            ++string;
        }

        if (parseSuccessful)
            result = parsedFloat;

        return parseSuccessful;
    }

private:
    const char* string;
};

```

`Source/Utils/StrongTypeAlias.h`:

```h
#pragma once

#define STRONG_TYPE_ALIAS(name, ...) \
struct name { using type = __VA_ARGS__; };

template <typename StrongTypeAlias>
struct UnpackStrongTypeAlias {
    using type = typename StrongTypeAlias::type;
};

template <typename StrongTypeAlias>
using UnpackStrongTypeAliasT = typename UnpackStrongTypeAlias<StrongTypeAlias>::type;

```

`Source/Utils/TemplateParameterCstring.h`:

```h
#pragma once

#include <array>
#include <cstddef>
#include <ranges>

template <std::size_t N>
struct TemplateParameterCstring {
    consteval TemplateParameterCstring(const char (&str)[N]) noexcept
    {
        std::ranges::copy(str, storage.begin());
    }

    [[nodiscard]] constexpr operator const char*() const noexcept
    {
        return storage.data();
    }

    std::array<char, N> storage;
};

```

`Source/Utils/ToUnderlying.h`:

```h
#pragma once

#include <type_traits>

template <typename Enum>
constexpr auto toUnderlying(Enum e) noexcept
{
    return static_cast<std::underlying_type_t<Enum>>(e);
}

```

`Source/Utils/TypeBitFlags.h`:

```h
#pragma once

#include <cstdint>
#include <limits>
#include <tuple>
#include <type_traits>

#include "TypeIndex.h"

template <typename... Types>
    requires (sizeof...(Types) <= std::numeric_limits<std::uint32_t>::digits)
class TypeBitFlags {
public:
    TypeBitFlags() = default;

    template <typename T>
    constexpr TypeBitFlags& set() noexcept
    {
        flags |= toMask<T>();
        return *this;
    }

    template <typename T>
    constexpr void unset() noexcept
    {
        flags &= ~toMask<T>();
    }

    template <typename T>
    [[nodiscard]] constexpr bool has() const noexcept
    {
        return (flags & toMask<T>()) != 0;
    }

    constexpr TypeBitFlags& operator|=(TypeBitFlags other) noexcept
    {
        flags |= other.flags;
        return *this;
    }

    [[nodiscard]] constexpr friend TypeBitFlags operator|(TypeBitFlags a, TypeBitFlags b) noexcept
    {
        return TypeBitFlags{static_cast<UnderlyingType>(a.flags | b.flags)};
    }

    [[nodiscard]] constexpr TypeBitFlags difference(TypeBitFlags other) const noexcept
    {
        return TypeBitFlags{static_cast<UnderlyingType>(flags & ~other.flags)};
    }

    [[nodiscard]] constexpr bool contains(TypeBitFlags other) const noexcept
    {
        return (flags & other.flags) == other.flags;
    }

    [[nodiscard]] explicit constexpr operator bool() const noexcept
    {
        return flags != 0;
    }

private:
    using UnderlyingType = 
        std::conditional_t<sizeof...(Types) <= std::numeric_limits<std::uint8_t>::digits,
            std::uint8_t,
            std::conditional_t<sizeof...(Types) <= std::numeric_limits<std::uint16_t>::digits,
                std::uint16_t,
                std::uint32_t
            >
        >;

    explicit constexpr TypeBitFlags(UnderlyingType flags) noexcept
        : flags{flags}
    {
    }

    template <typename T>
    static constexpr auto toMask() noexcept
    {
        return 1 << utils::typeIndex<T, std::tuple<Types...>>();
    }

    UnderlyingType flags{0};
};

```

`Source/Utils/TypeIndex.h`:

```h
#pragma once

#include <cstddef>
#include <tuple>
#include <type_traits>

namespace utils
{

template <typename T, typename Tuple, std::size_t I = 0>
[[nodiscard]] consteval std::size_t typeIndex() noexcept
{
    static_assert(I < std::tuple_size_v<Tuple>, "T does not exist in Tuple");

    if constexpr (std::is_same_v<T, std::tuple_element_t<I, Tuple>>)
        return I;
    else
        return typeIndex<T, Tuple, I + 1>();
}

}

```

`Source/Utils/TypeList.h`:

```h
#pragma once

#include <cstddef>
#include <tuple>
#include <type_traits>
#include <utility>

#include "Meta.h"
#include "TypeIndex.h"

template <typename... Types>
struct TypeList {
    template <typename... OtherTypes>
    static TypeList<OtherTypes...> typeListFromTuple(std::tuple<OtherTypes...>);

    using TypesTuple = std::tuple<Types...>;

    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Types);
    }

    template <typename T>
    static constexpr std::size_t indexOf() noexcept
    {
        return utils::typeIndex<T, std::tuple<Types...>>();
    }

    template <typename T>
    static constexpr bool contains() noexcept
    {
        return (std::is_same_v<T, Types> || ...);
    }

    template <template <typename> typename ValueOfType>
    static constexpr auto (min)() noexcept
    {
        return (std::min)({ValueOfType<Types>::value...});
    }

    template <template <typename> typename ValueOfType>
    static constexpr auto (max)() noexcept
    {
        return (std::max)({ValueOfType<Types>::value...});
    }

    template <template <typename> typename Predicate>
    using filter = decltype(typeListFromTuple(std::tuple_cat(std::declval<std::conditional_t<Predicate<Types>::value, std::tuple<Types>, std::tuple<>>>()...)));

    template <typename T>
    using add = TypeList<Types..., T>;

    template <typename OtherTypeList>
    using concat = decltype(typeListFromTuple(std::tuple_cat(std::declval<std::tuple<Types...>>(), std::declval<typename OtherTypeList::TypesTuple>())));

    template <template <typename> typename ValueOfType>
    struct Sorter {
        template <decltype(min<ValueOfType>())... Values>
        static auto sorted(std::integer_sequence<decltype(min<ValueOfType>()), Values...>) -> decltype(std::tuple_cat(std::declval<typename filter<WithValue<ValueOfType, Values + min<ValueOfType>()>::template Equal>::TypesTuple>()...));
    };

    template <template <typename> typename ValueOfType>
    using sortBy = decltype(typeListFromTuple(std::declval<decltype(Sorter<ValueOfType>::template sorted<>(std::make_integer_sequence<decltype(min<ValueOfType>()), max<ValueOfType>() - min<ValueOfType>() + 1>{}))>()));

    static constexpr void forEach(auto&& callable) noexcept
    {
        (callable(std::type_identity<Types>{}), ...);
    }
};

```

`Source/Utils/TypedStaticStringPool.h`:

```h
#pragma once

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <tuple>

template <std::size_t BufferSize = 0, std::size_t NumberOfStrings = 0, typename... Types>
class TypedStaticStringPool {
public:
    using TypeList = std::tuple<Types...>;

    template <typename T, std::uint8_t N>
    [[nodiscard]] consteval auto add(const char(&str)[N]) const noexcept
    {
        if (str[N - 1] != '\0')
            error("string must be null-terminated");

        TypedStaticStringPool<BufferSize + N, NumberOfStrings + 1, Types..., T> newPool;
        std::ranges::copy(buffer, newPool.buffer.begin());
        std::ranges::copy(str, newPool.buffer.begin() + buffer.size());
        std::ranges::copy(stringLengths, newPool.stringLengths.begin());
        newPool.stringLengths.back() = N;
        return newPool;
    }

    template <typename F>
    void forEach(F f) const noexcept
    {
        std::size_t index = 0;
        for (const auto stringLength : stringLengths) {
            const auto str = buffer.data() + index;
            f(str);
            index += stringLength;
        }
    }

private:
    static void error(const char*);

    template <std::size_t, std::size_t, typename...>
    friend class TypedStaticStringPool;

    std::array<char, BufferSize> buffer{};
    std::array<std::uint8_t, NumberOfStrings> stringLengths{};
};

```

`Source/Utils/Wcslen.h`:

```h
#pragma once

#include <cstddef>

namespace utils
{

[[nodiscard]] std::size_t wcslen(const wchar_t* str) noexcept
{
    std::size_t length = 0;
    while (*str) {
        ++length;
        ++str;
    }
    return length;
}

}

```

`Source/Verification/Verifier.h`:

```h
#pragma once

#include <source_location>

#include <Platform/PlatformApi.h>
#include <Platform/SimpleMessageBox.h>
#include <Utils/StringBuilder.h>

template <typename Lhs, typename Rhs>
class Verifier {
public:
    // TODO: do not use std::source_location as its unsupported on clang-cl and clang < 16
    Verifier(const std::source_location& location, const char* message, const char* lhsString, const char* rhsString, const Lhs& lhs, const Rhs& rhs) noexcept
        : location{ location }, message{ message }, lhsString{ lhsString }, rhsString{ rhsString }, lhs{ lhs }, rhs{ rhs }
    {
    }

    bool verifyEqual() noexcept
    {
        return verify(lhs == rhs, "==");
    }

    bool verifyNotEqual() noexcept
    {
        return verify(lhs != rhs, "!=");
    }

    bool verifyGreaterOrEqual() noexcept
    {
        return verify(lhs >= rhs, ">=");
    }

    bool verifyGreater() noexcept
    {
        return verify(lhs > rhs, ">");
    }

private:
    [[nodiscard]] bool verify(bool comparisonSucceeded, const char* comparator) noexcept
    {
        return comparisonSucceeded || comparisonFailed(comparator);
    }

    [[nodiscard]] bool comparisonFailed(const char* comparator) noexcept
    {
        showFailureMessageBox(comparator);
        PlatformApi::debugBreak();
        return false;
    }

    void showFailureMessageBox(const char* comparator) noexcept
    {
        SimpleMessageBox{}.showError("Osiris verification failure", buildFailureMessage(comparator));
    }

    [[nodiscard]] const char* buildFailureMessage(const char* comparator) noexcept
    {
        auto builder = storage.builder();
        builder.put(location.file_name(), '(', location.line(), "): ", message);
        builder.put('\n', '\n');
        builder.put(lhsString, ' ', comparator, ' ', rhsString, '\n', lhs, ' ', comparator, ' ', rhs);
        return builder.cstring();
    }

    std::source_location location;
    const char* message;
    const char* lhsString;
    const char* rhsString;
    const Lhs& lhs;
    const Rhs& rhs;
    StringBuilderStorage<1'000> storage;
};

```

`Source/Verification/VerifyMacros.h`:

```h
#pragma once

#ifndef VERIFY

#ifndef NDEBUG
#define VERIFY() true
#else
#define VERIFY() false
#endif

#endif

#if VERIFY()

#include <source_location>
#include "Verifier.h"

#define STRINGIFY(arg) #arg
#define VERIFY_COMPARISON(message, lhs, rhs, comparator) Verifier{ std::source_location::current(), message, STRINGIFY(lhs), STRINGIFY(rhs), lhs, rhs }.verify ## comparator()

#define VERIFY_EQ(message, lhs, rhs) VERIFY_COMPARISON(message, lhs, rhs, Equal)
#define VERIFY_NE(message, lhs, rhs) VERIFY_COMPARISON(message, lhs, rhs, NotEqual)
#define VERIFY_GE(message, lhs, rhs) VERIFY_COMPARISON(message, lhs, rhs, GreaterOrEqual)
#define VERIFY_GT(message, lhs, rhs) VERIFY_COMPARISON(message, lhs, rhs, Greater)
#define VERIFY_IF(shouldVerify, verifier) do { if (shouldVerify) { verifier; } } while (false)

#else

#define VERIFY_EQ(message, lhs, rhs)
#define VERIFY_NE(message, lhs, rhs)
#define VERIFY_GE(message, lhs, rhs)
#define VERIFY_GT(message, lhs, rhs)
#define VERIFY_IF(shouldVerify, verifier)

#endif


```

`Source/Vmt/VmtCopy.h`:

```h
#pragma once

#include <algorithm>
#include <cstdint>
#include <cstddef>

#include <MemoryAllocation/UniquePtr.h>
#include <Platform/TypeInfoPrecedingVmt.h>
#include "VmtLength.h"

class VmtCopy {
public:
    VmtCopy(std::uintptr_t* vmt, VmtLength length) noexcept
        : originalVmt{ vmt }
        , replacementVmtWithTypeInfo{ mem::makeUniqueForOverwrite<std::uintptr_t[]>(static_cast<std::size_t>(length) + platform::lengthOfTypeInfoPrecedingVmt) }
    {
        copyOriginalVmt();
    }

    [[nodiscard]] std::uintptr_t* getReplacementVmt() const noexcept
    {
        if (replacementVmtWithTypeInfo) [[likely]]
            return replacementVmtWithTypeInfo.get() + platform::lengthOfTypeInfoPrecedingVmt;
        return nullptr;
    }

    [[nodiscard]] std::uintptr_t* getOriginalVmt() const noexcept
    {
        return originalVmt;
    }

private:
    void copyOriginalVmt() const noexcept
    {
        if (replacementVmtWithTypeInfo) [[likely]]
            std::copy_n(originalVmt - platform::lengthOfTypeInfoPrecedingVmt, lengthWithTypeInfo(), replacementVmtWithTypeInfo.get());
    }

    [[nodiscard]] std::size_t lengthWithTypeInfo() const noexcept
    {
        return replacementVmtWithTypeInfo.get_deleter().getNumberOfElements();
    }

    std::uintptr_t* originalVmt;
    UniquePtr<std::uintptr_t[]> replacementVmtWithTypeInfo;
};

```

`Source/Vmt/VmtLength.h`:

```h
#pragma once

#include <cstddef>

enum class VmtLength : std::size_t {};

```

`Source/Vmt/VmtLengthCalculator.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

#include "VmtLength.h"
#include <Utils/MemorySection.h>

struct VmtLengthCalculator {
    explicit VmtLengthCalculator(MemorySection codeSection, MemorySection vmtSection)
        : codeSection{ codeSection }, vmtSection{ vmtSection }
    {
    }

    [[nodiscard]] VmtLength operator()(const std::uintptr_t* vmt) const noexcept
    {
        std::size_t length = 0;
        while (isVmtEntry(vmt + length))
            ++length;
        return VmtLength{ length };
    }

private:
    [[nodiscard]] bool isVmtEntry(const std::uintptr_t* pointer) const noexcept
    {
        return vmtSection.contains(std::uintptr_t(pointer), sizeof(std::uintptr_t)) && codeSection.contains(*pointer);
    }

    MemorySection codeSection;
    MemorySection vmtSection;
};

```

`Source/Vmt/VmtSwapper.h`:

```h
#pragma once

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <optional>

#include "VmtCopy.h"
#include "VmtLengthCalculator.h"

#include <Utils/GenericFunctionPointer.h>

class VmtSwapper {
public:
    [[nodiscard]] bool wasEverInstalled() const noexcept
    {
        return vmtCopy.has_value();
    }

    [[nodiscard]] bool isInstalled(const std::uintptr_t* vmt) const noexcept
    {
        assert(wasEverInstalled());
        return vmt == vmtCopy->getReplacementVmt();
    }

    bool install(const VmtLengthCalculator& vmtLengthCalculator, std::uintptr_t*& vmt) noexcept
    {
        const auto justInitialized = initializeVmtCopy(vmtLengthCalculator, vmt);
        if (const auto replacementVmt = vmtCopy->getReplacementVmt())
            vmt = replacementVmt;
        return justInitialized;
    }

    void uninstall(std::uintptr_t*& vmt) const noexcept
    {
        assert(wasEverInstalled());
        vmt = vmtCopy->getOriginalVmt();
    }

    [[nodiscard]] GenericFunctionPointer hook(std::size_t index, GenericFunctionPointer replacementFunction) const noexcept
    {
        assert(wasEverInstalled());
        if (const auto replacementVmt = vmtCopy->getReplacementVmt())
            replacementVmt[index] = std::uintptr_t(static_cast<void(*)()>(replacementFunction));
        return reinterpret_cast<void(*)()>(vmtCopy->getOriginalVmt()[index]);
    }

private:
    [[nodiscard]] bool initializeVmtCopy(const VmtLengthCalculator& vmtLengthCalculator, std::uintptr_t* vmt) noexcept
    {
        if (!vmtCopy.has_value()) {
            vmtCopy.emplace(vmt, vmtLengthCalculator(vmt));
            return true;
        }
        return false;
    }

    std::optional<VmtCopy> vmtCopy;
};

```

`Source/dllmain.cpp`:

```cpp
#include "Utils/ManuallyDestructible.h"
#include "Platform/Macros/IsPlatform.h"

#include "GlobalContext/GlobalContext.h"
#include "MemoryAllocation/MemoryAllocatorBaseImpl.h"

constinit ManuallyDestructible<GlobalContext> GlobalContext::globalContext;

#include "EntryPoints/EntryPoints.h"

#if IS_WIN64()
#include "BuildConfig.h"
#include "MemoryPatterns/Windows/WindowsPatterns.h"
#include "Platform/Windows/WindowsPlatformApiImpl.h"

#include <Windows.h>

void operator delete(void*, std::size_t) noexcept
{
    // for 'placement new' to work
}

extern "C" std::size_t DllMain(HMODULE, DWORD reason, LPVOID) noexcept
{
    if (reason == DLL_PROCESS_ATTACH)
        GlobalContext::initializeInstance();
    return TRUE;
}

#elif IS_LINUX()

#include "MemoryPatterns/Linux/LinuxPatterns.h"
#include "Platform/Linux/LinuxPlatformApiImpl.h"

void __attribute__((constructor)) DllEntryPoint()
{
    GlobalContext::initializeInstance();
}

#endif

```

`Tests/CMakeLists.txt`:

```txt
if("unit" IN_LIST ENABLE_TESTS OR "functional" IN_LIST ENABLE_TESTS)
  set(THREADS_PREFER_PTHREAD_FLAG ON)
  find_package(Threads REQUIRED)

  include(FetchContent)
  FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG fa8438ae6b70c57010177de47a9f13d7041a6328 # v1.17.0 with fix for Clang 21 warning -Wcharacter-conversion
    # GIT_SHALLOW TRUE # re-enable when new gtest release tag (not just a commit hash) is used above (https://gitlab.kitware.com/cmake/cmake/-/issues/23379)
  )
  FetchContent_MakeAvailable(googletest)

  include(GoogleTest)
endif()

if("unit" IN_LIST ENABLE_TESTS)
  add_subdirectory(UnitTests)
endif()

if("functional" IN_LIST ENABLE_TESTS)
  add_subdirectory(FunctionalTests)
endif()

```

`Tests/Configs/config_current.cfg`:

```cfg
{"Combat":{"NoScopeInaccuracyVis":{"Enabled":true}},"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true},"BombPlantAlert":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116,"DroppedBomb":69,"TickingBomb":303,"DefuseKit":227}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":200,"PlayerGreen":134,"PlayerYellow":57,"PlayerOrange":12,"PlayerPurple":256,"TeamT":37,"TeamCT":227,"LowHealth":287,"HighHealth":171,"Enemy":304,"Ally":103,"Molotov":60,"Flashbang":250,"HEGrenade":300,"SmokeGrenade":140,"DroppedBomb":302,"TickingBomb":26,"DefuseKit":160,"Hostage":334}},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true},"ViewmodelMod":{"Enabled":true,"ModifyFov":true,"Fov":90}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v1.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v2.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v3.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v4.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v5.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116,"DroppedBomb":69,"TickingBomb":303,"DefuseKit":227}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v6.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116,"DroppedBomb":69,"TickingBomb":303,"DefuseKit":227}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":200,"PlayerGreen":134,"PlayerYellow":57,"PlayerOrange":12,"PlayerPurple":256,"TeamT":37,"TeamCT":227,"LowHealth":287,"HighHealth":171,"Enemy":304,"Ally":103,"Molotov":60,"Flashbang":250,"HEGrenade":300,"SmokeGrenade":140,"DroppedBomb":302,"TickingBomb":26,"DefuseKit":160}},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v7.cfg`:

```cfg
{"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116,"DroppedBomb":69,"TickingBomb":303,"DefuseKit":227}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":200,"PlayerGreen":134,"PlayerYellow":57,"PlayerOrange":12,"PlayerPurple":256,"TeamT":37,"TeamCT":227,"LowHealth":287,"HighHealth":171,"Enemy":304,"Ally":103,"Molotov":60,"Flashbang":250,"HEGrenade":300,"SmokeGrenade":140,"DroppedBomb":302,"TickingBomb":26,"DefuseKit":160}},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true},"ViewmodelMod":{"Enabled":true,"ModifyFov":true,"Fov":90}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v8.cfg`:

```cfg
{"Combat":{"NoScopeInaccuracyVis":{"Enabled":true}},"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116,"DroppedBomb":69,"TickingBomb":303,"DefuseKit":227}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":200,"PlayerGreen":134,"PlayerYellow":57,"PlayerOrange":12,"PlayerPurple":256,"TeamT":37,"TeamCT":227,"LowHealth":287,"HighHealth":171,"Enemy":304,"Ally":103,"Molotov":60,"Flashbang":250,"HEGrenade":300,"SmokeGrenade":140,"DroppedBomb":302,"TickingBomb":26,"DefuseKit":160}},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true},"ViewmodelMod":{"Enabled":true,"ModifyFov":true,"Fov":90}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/Configs/config_v9.cfg`:

```cfg
{"Combat":{"NoScopeInaccuracyVis":{"Enabled":true}},"Hud":{"BombTimer":{"Enabled":true},"BombDefuseAlert":{"Enabled":true},"PreserveKillfeed":{"Enabled":true},"PostRoundTimer":{"Enabled":true}},"Visuals":{"ModelGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":true,"ColorMode":0},"Weapons":true,"DroppedBomb":false,"TickingBomb":false,"DefuseKits":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":203,"PlayerGreen":133,"PlayerYellow":48,"PlayerOrange":13,"PlayerPurple":269,"TeamT":30,"TeamCT":220,"LowHealth":311,"HighHealth":256,"Enemy":353,"Ally":74,"Molotov":37,"Flashbang":205,"HEGrenade":333,"SmokeGrenade":116,"DroppedBomb":69,"TickingBomb":303,"DefuseKit":227}},"OutlineGlow":{"Enabled":true,"Players":{"Enabled":true,"OnlyEnemies":false,"ColorMode":2},"Weapons":true,"DroppedBomb":true,"TickingBomb":false,"DefuseKits":true,"Hostages":true,"GrenadeProjectiles":true,"Hues":{"PlayerBlue":200,"PlayerGreen":134,"PlayerYellow":57,"PlayerOrange":12,"PlayerPurple":256,"TeamT":37,"TeamCT":227,"LowHealth":287,"HighHealth":171,"Enemy":304,"Ally":103,"Molotov":60,"Flashbang":250,"HEGrenade":300,"SmokeGrenade":140,"DroppedBomb":302,"TickingBomb":26,"DefuseKit":160,"Hostage":334}},"PlayerInfoInWorld":{"Enabled":true,"OnlyEnemies":true,"PlayerPositionArrow":{"Enabled":true,"ColorMode":0},"Health":{"Enabled":true,"ColorMode":0},"ActiveWeaponIcon":true,"BombCarrierIcon":true,"BombPlantIcon":true,"ActiveWeaponAmmo":false,"BombDefuseIcon":true,"HostagePickupIcon":true,"HostageRescueIcon":true,"BlindedIcon":true},"ViewmodelMod":{"Enabled":true,"ModifyFov":true,"Fov":90}},"Sound":{"Visualizations":{"Footsteps":{"Enabled":true},"BombPlant":{"Enabled":true},"BombBeep":{"Enabled":true},"BombDefuse":{"Enabled":true},"WeaponScope":{"Enabled":true},"WeaponReload":{"Enabled":true}}}}
```

`Tests/FunctionalTests/CMakeLists.txt`:

```txt
add_executable(FunctionalTests Config/ConfigCompatibilityTests.cpp)

target_include_directories(FunctionalTests PRIVATE "${CMAKE_SOURCE_DIR}/Tests" "${CMAKE_SOURCE_DIR}/Source")
target_compile_definitions(FunctionalTests PRIVATE TEST_CONFIGS_PATH="${CMAKE_SOURCE_DIR}/Tests/Configs")
target_link_libraries(FunctionalTests gtest_main gmock Threads::Threads)
set_target_properties(FunctionalTests PROPERTIES OUTPUT_NAME FunctionalTestsBin)
gtest_discover_tests(FunctionalTests DISCOVERY_TIMEOUT 60 TEST_PREFIX Functional_)

```

`Tests/FunctionalTests/Config/ConfigCompatibilityTests.cpp`:

```cpp
#include <filesystem>
#include <fstream>

#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include <Config/Config.h>
#include <Config/ConfigState.h>
#include <Config/ConfigVariableTypes.h>
#include <GlobalContext/OsirisDirectoryPath.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockGui.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockMemoryAllocator.h>

class ConfigCompatibilityTest : public testing::Test {
protected:
    ConfigCompatibilityTest()
    {
        EXPECT_CALL(mockHookContext, configState()).Times(testing::AtLeast(1)).WillRepeatedly(testing::ReturnRef(configState));
        EXPECT_CALL(mockHookContext, config()).Times(testing::AtLeast(1)).WillRepeatedly(testing::ReturnRef(mockConfig));
    }

    [[nodiscard]] static auto readConfigFile(const char* filename)
    {
        std::ifstream file{std::filesystem::path{TEST_CONFIGS_PATH} / filename, std::ios::binary};
        return std::vector<char8_t>{std::istreambuf_iterator<char>{file}, {}};
    }

    template <typename ConfigVariable>
    [[nodiscard]] auto& get()
    {
        return expectedVariableValues[ConfigVariableTypes::indexOf<ConfigVariable>()];
    }

    void setVariableExpectationsV1()
    {
        get<BombTimerEnabled>() = true;
        get<DefusingAlertEnabled>() = true;
        get<KillfeedPreserverEnabled>() = true;
        get<PostRoundTimerEnabled>() = true;

        get<model_glow_vars::Enabled>() = true;
        get<model_glow_vars::GlowPlayers>() = true;
        get<model_glow_vars::GlowOnlyEnemies>() = true;
        get<model_glow_vars::PlayerGlowColorMode>() = PlayerModelGlowColorType::PlayerOrTeamColor;
        get<model_glow_vars::GlowWeapons>() = true;
        get<model_glow_vars::GlowDroppedBomb>() = false;
        get<model_glow_vars::GlowTickingBomb>() = false;
        get<model_glow_vars::GlowDefuseKits>() = true;
        get<model_glow_vars::GlowGrenadeProjectiles>() = true;

        get<outline_glow_vars::Enabled>() = true;
        get<outline_glow_vars::GlowPlayers>() = true;
        get<outline_glow_vars::GlowOnlyEnemies>() = false;
        get<outline_glow_vars::PlayerGlowColorMode>() = PlayerOutlineGlowColorType::HealthBased;
        get<outline_glow_vars::GlowWeapons>() = true;
        get<outline_glow_vars::GlowDroppedBomb>() = true;
        get<outline_glow_vars::GlowTickingBomb>() = false;
        get<outline_glow_vars::GlowDefuseKits>() = true;
        get<outline_glow_vars::GlowHostages>() = true;
        get<outline_glow_vars::GlowGrenadeProjectiles>() = true;

        get<player_info_vars::Enabled>() = true;
        get<player_info_vars::OnlyEnemies>() = true;
        get<player_info_vars::PlayerPositionArrowEnabled>() = true;
        get<player_info_vars::PlayerPositionArrowColorMode>() = PlayerPositionArrowColorType::PlayerOrTeamColor;
        get<player_info_vars::PlayerHealthEnabled>() = true;
        get<player_info_vars::PlayerHealthColorMode>() = PlayerHealthTextColor::HealthBased;
        get<player_info_vars::ActiveWeaponIconEnabled>() = true;
        get<player_info_vars::BombCarrierIconEnabled>() = true;
        get<player_info_vars::BombPlantIconEnabled>() = true;
        get<player_info_vars::ActiveWeaponAmmoEnabled>() = false;
        get<player_info_vars::BombDefuseIconEnabled>() = true;
        get<player_info_vars::HostagePickupIconEnabled>() = true;
        get<player_info_vars::HostageRescueIconEnabled>() = true;
        get<player_info_vars::BlindedIconEnabled>() = true;

        get<BombBeepSoundVisualizationEnabled>() = true;
        get<BombDefuseSoundVisualizationEnabled>() = true;
        get<BombPlantSoundVisualizationEnabled>() = true;
        get<FootstepSoundVisualizationEnabled>() = true;
        get<WeaponReloadSoundVisualizationEnabled>() = true;
        get<WeaponScopeSoundVisualizationEnabled>() = true;
    }

    void setVariableExpectationsV2()
    {
        setVariableExpectationsV1();
        get<model_glow_vars::PlayerBlueHue>() = model_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{203}};
        get<model_glow_vars::PlayerGreenHue>() = model_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{133}};
        get<model_glow_vars::PlayerYellowHue>() = model_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{48}};
        get<model_glow_vars::PlayerOrangeHue>() = model_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{13}};
        get<model_glow_vars::PlayerPurpleHue>() = model_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{269}};
    }

    void setVariableExpectationsV3()
    {
        setVariableExpectationsV2();
        get<model_glow_vars::TeamTHue>() = model_glow_vars::TeamTHue::ValueType{color::HueInteger{30}};
        get<model_glow_vars::TeamCTHue>() = model_glow_vars::TeamCTHue::ValueType{color::HueInteger{220}};
        get<model_glow_vars::LowHealthHue>() = model_glow_vars::LowHealthHue::ValueType{color::HueInteger{311}};
        get<model_glow_vars::HighHealthHue>() = model_glow_vars::HighHealthHue::ValueType{color::HueInteger{256}};
        get<model_glow_vars::EnemyHue>() = model_glow_vars::EnemyHue::ValueType{color::HueInteger{353}};
        get<model_glow_vars::AllyHue>() = model_glow_vars::EnemyHue::ValueType{color::HueInteger{74}};
    }

    void setVariableExpectationsV4()
    {
        setVariableExpectationsV3();
        get<model_glow_vars::MolotovHue>() = model_glow_vars::MolotovHue::ValueType{color::HueInteger{37}};
        get<model_glow_vars::FlashbangHue>() = model_glow_vars::FlashbangHue::ValueType{color::HueInteger{205}};
        get<model_glow_vars::HEGrenadeHue>() = model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{333}};
        get<model_glow_vars::SmokeGrenadeHue>() = model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{116}};
    }

    void setVariableExpectationsV5()
    {
        setVariableExpectationsV4();
        get<model_glow_vars::DroppedBombHue>() = model_glow_vars::DroppedBombHue::ValueType{color::HueInteger{69}};
        get<model_glow_vars::TickingBombHue>() = model_glow_vars::TickingBombHue::ValueType{color::HueInteger{303}};
        get<model_glow_vars::DefuseKitHue>() = model_glow_vars::DefuseKitHue::ValueType{color::HueInteger{227}};
    }

    void setVariableExpectationsV6()
    {
        setVariableExpectationsV5();
        get<outline_glow_vars::PlayerBlueHue>() = outline_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{200}};
        get<outline_glow_vars::PlayerGreenHue>() = outline_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{134}};
        get<outline_glow_vars::PlayerYellowHue>() = outline_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{57}};
        get<outline_glow_vars::PlayerOrangeHue>() = outline_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{12}};
        get<outline_glow_vars::PlayerPurpleHue>() = outline_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{256}};
        get<outline_glow_vars::TeamTHue>() = outline_glow_vars::TeamTHue::ValueType{color::HueInteger{37}};
        get<outline_glow_vars::TeamCTHue>() = outline_glow_vars::TeamCTHue::ValueType{color::HueInteger{227}};
        get<outline_glow_vars::LowHealthHue>() = outline_glow_vars::LowHealthHue::ValueType{color::HueInteger{287}};
        get<outline_glow_vars::HighHealthHue>() = outline_glow_vars::HighHealthHue::ValueType{color::HueInteger{171}};
        get<outline_glow_vars::EnemyHue>() = outline_glow_vars::EnemyHue::ValueType{color::HueInteger{304}};
        get<outline_glow_vars::AllyHue>() = outline_glow_vars::EnemyHue::ValueType{color::HueInteger{103}};
        get<outline_glow_vars::MolotovHue>() = outline_glow_vars::MolotovHue::ValueType{color::HueInteger{60}};
        get<outline_glow_vars::FlashbangHue>() = outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{250}};
        get<outline_glow_vars::HEGrenadeHue>() = outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{300}};
        get<outline_glow_vars::SmokeGrenadeHue>() = outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{140}};
        get<outline_glow_vars::DroppedBombHue>() = outline_glow_vars::DroppedBombHue::ValueType{color::HueInteger{302}};
        get<outline_glow_vars::TickingBombHue>() = outline_glow_vars::TickingBombHue::ValueType{color::HueInteger{26}};
        get<outline_glow_vars::DefuseKitHue>() = outline_glow_vars::DefuseKitHue::ValueType{color::HueInteger{160}};
    }

    void setVariableExpectationsV7()
    {
        setVariableExpectationsV6();
        get<viewmodel_mod_vars::Enabled>() = true;
        get<viewmodel_mod_vars::ModifyFov>() = true;
        get<viewmodel_mod_vars::Fov>() = viewmodel_mod_vars::Fov::ValueType{90};
    }

    void setVariableExpectationsV8()
    {
        setVariableExpectationsV7();
        get<no_scope_inaccuracy_vis_vars::Enabled>() = true;
    }

    void setVariableExpectationsV9()
    {
        setVariableExpectationsV8();
        get<outline_glow_vars::HostageHue>() = outline_glow_vars::HostageHue::ValueType{color::HueInteger{334}};
    }

    void setVariableExpectationsV10()
    {
        setVariableExpectationsV9();
        get<BombPlantAlertEnabled>() = true;
    }

    void setVariableExpectationsCurrent()
    {
        setVariableExpectationsV10();
    }

    struct VariableChecker {
        VariableChecker() = default;

        template <typename ValueType>
        explicit(false) VariableChecker(ValueType expectedValue)
            : checker{makeChecker(expectedValue)}
            , expectedValue{expectedValue}
        {
        }

        void operator()(std::size_t variableIndex, std::any actualValue)
        {
            checker(variableIndex, actualValue);
        }

        std::function<void(std::size_t, std::any)> checker{};
        std::any expectedValue{};

    private:
        template <typename ValueType>
        [[nodiscard]] decltype(auto) static makeChecker(ValueType expectedValue)
        {
            return [expectedValue](std::size_t variableIndex, std::any actualValue) {
                EXPECT_EQ(std::any_cast<ValueType>(actualValue), expectedValue) <<
                    "config variable: " << typeName(variableIndex); 
            };
        }

        [[nodiscard]] static const char* typeName(std::size_t variableIndex)
        {
            const char* typeName = "";
            ConfigVariableTypes::forEach([i = std::size_t{0}, variableIndex, &typeName] <typename ConfigVariable> (std::type_identity<ConfigVariable>) mutable {
                if (i++ == variableIndex)
                    typeName = typeid(ConfigVariable).name();
            });
            return typeName;
        }
    };

    void enableVariableExpectationsForGetting()
    {
        for (auto [variableIndex, valueChecker] : expectedVariableValues)
            EXPECT_CALL(mockConfig, getVariable(variableIndex)).WillOnce(testing::Return(valueChecker.expectedValue));
    }

    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockGui> mockGui;

    ConfigState configState;
    Config<MockHookContext> config{mockHookContext};
    std::unordered_map<std::size_t, VariableChecker> expectedVariableValues;
};

TEST_F(ConfigCompatibilityTest, ConfigCurrentFileIsUpToDate) {
    const auto currentConfigFile = readConfigFile("config_current.cfg");

    setVariableExpectationsCurrent();
    enableVariableExpectationsForGetting();

    std::array<char8_t, build::kConfigFileBufferSize> buffer;
    configState.currentFileOperation = ConfigFileOperation::None;
    configState.fileOperationBuffer = buffer.data();
    configState.autoSaveScheduled = true;
    configState.bufferUsedBytes = 0;
    config.update();

    ASSERT_EQ(configState.bufferUsedBytes, currentConfigFile.size())
        << "generated up-to-date config has different length than config_current.cfg file";

    for (std::size_t i = 0; i < configState.bufferUsedBytes; ++i)
        EXPECT_EQ(buffer.at(i), currentConfigFile.at(i)) << "at index: " << i;
}

class ConfigCompatibilityLoadTest : public ConfigCompatibilityTest {
protected:
    ConfigCompatibilityLoadTest()
    {
        EXPECT_CALL(mockHookContext, gui()).WillOnce(testing::ReturnRef(mockGui));
        EXPECT_CALL(mockGui, updateFromConfig());
    }

    void testLoadingConfigFile(const char* filename)
    {
        enableVariableExpectationsForSetting();
        auto fileContents = readConfigFile(filename);
        prepareLoadOperation(fileContents);
        config.update();
    }
    
    void enableVariableExpectationsForSetting()
    {
        for (auto [variableIndex, valueChecker] : expectedVariableValues)
            EXPECT_CALL(mockConfig, setVariableWithoutAutoSave(variableIndex, testing::_)).WillOnce(testing::Invoke(valueChecker));
    }

    void prepareLoadOperation(std::vector<char8_t>& fileContents)
    {
        configState.fileOperationBuffer = fileContents.data();
        configState.currentFileOperation = ConfigFileOperation::Load;
        configState.bufferUsedBytes = fileContents.size();
    }
};

TEST_F(ConfigCompatibilityLoadTest, ConfigV1) {
    setVariableExpectationsV1();
    testLoadingConfigFile("config_v1.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV2) {
    setVariableExpectationsV2();
    testLoadingConfigFile("config_v2.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV3) {
    setVariableExpectationsV3();
    testLoadingConfigFile("config_v3.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV4) {
    setVariableExpectationsV4();
    testLoadingConfigFile("config_v4.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV5) {
    setVariableExpectationsV5();
    testLoadingConfigFile("config_v5.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV6) {
    setVariableExpectationsV6();
    testLoadingConfigFile("config_v6.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV7) {
    setVariableExpectationsV7();
    testLoadingConfigFile("config_v7.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV8) {
    setVariableExpectationsV8();
    testLoadingConfigFile("config_v8.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigV9) {
    setVariableExpectationsV9();
    testLoadingConfigFile("config_v9.cfg");
}

TEST_F(ConfigCompatibilityLoadTest, ConfigCurrent) {
    setVariableExpectationsCurrent();
    testLoadingConfigFile("config_current.cfg");
}

```

`Tests/Matchers/Matchers.h`:

```h
#pragma once

#include <gmock/gmock.h>

MATCHER_P(PanelFontParamsEq, panelFontParams, "PanelFontParams")
{
    return testing::ExplainMatchResult(testing::AllOf(
        testing::Field("fontFamily", &PanelFontParams::fontFamily, panelFontParams.fontFamily),
        testing::Field("fontSize", &PanelFontParams::fontSize, panelFontParams.fontSize),
        testing::Field("fontWeight", &PanelFontParams::fontWeight, panelFontParams.fontWeight)
    ), arg, result_listener);
}

MATCHER_P(PanelAlignmentParamsEq, panelAlignmentParams, "PanelAlignmentParams")
{
    return testing::ExplainMatchResult(testing::AllOf(
        testing::Field("horizontalAlignment", &PanelAlignmentParams::horizontalAlignment, panelAlignmentParams.horizontalAlignment),
        testing::Field("verticalAlignment", &PanelAlignmentParams::verticalAlignment, panelAlignmentParams.verticalAlignment)
    ), arg, result_listener);
}

MATCHER_P(PanelMarginParamsEq, panelMarginParams, "PanelMarginParams")
{
    return testing::ExplainMatchResult(testing::AllOf(
        testing::Field("marginLeft", &PanelMarginParams::marginLeft, panelMarginParams.marginLeft),
        testing::Field("marginTop", &PanelMarginParams::marginTop, panelMarginParams.marginTop),
        testing::Field("marginRight", &PanelMarginParams::marginRight, panelMarginParams.marginRight),
        testing::Field("marginBottom", &PanelMarginParams::marginBottom, panelMarginParams.marginBottom)
    ), arg, result_listener);
}

```

`Tests/Mocks/BombTimerMocks/MockBombSiteIconPanel.h`:

```h
#pragma once

struct MockBombSiteIconPanel {
    MOCK_METHOD(void, setIcon, (const char* bombsiteIconUrl));
};

```

`Tests/Mocks/BombTimerMocks/MockBombTimer.h`:

```h
#pragma once

#include <gmock/gmock.h>

#include <Common/Visibility.h>

struct MockBombTimer {
    MOCK_METHOD(Visibility, update, ());
    MOCK_METHOD(void, forceHide, ());
};

```

`Tests/Mocks/BombTimerMocks/MockBombTimerCondition.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockBombTimerCondition {
    MOCK_METHOD(bool, shouldRun, ());
    MOCK_METHOD(bool, shouldShowBombTimer, ());
};

```

`Tests/Mocks/BombTimerMocks/MockBombTimerContext.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct BombTimerState;
struct MockBombSiteIconPanel;
struct MockBombTimerCondition;
struct MockBombTimerPanel;
struct MockBombTimerTextPanel;
struct MockPanel;
struct MockPlantedC4;
struct MockConfig;

struct MockBombTimerContext {
    MOCK_METHOD(MockBombTimerCondition&, bombTimerCondition, ());
    MOCK_METHOD(MockBombTimerPanel&, bombTimerPanel, ());
    MOCK_METHOD(MockPanel&, bombPlantedPanel, ());
    MOCK_METHOD(MockPanel&, bombTimerContainerPanel, ());
    MOCK_METHOD(bool, hasTickingC4, ());
    MOCK_METHOD(BombTimerState&, state, ());
    MOCK_METHOD(MockPlantedC4&, tickingC4, ());
    MOCK_METHOD(MockBombTimerTextPanel&, bombTimerTextPanel, ());
    MOCK_METHOD(MockBombSiteIconPanel&, bombSiteIconPanel, ());
    MOCK_METHOD(MockConfig&, config, ());
};

```

`Tests/Mocks/BombTimerMocks/MockBombTimerPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockBombTimerPanel {
    MOCK_METHOD(void, showAndUpdate, ());
    MOCK_METHOD(void, hide, ());
};

```

`Tests/Mocks/BombTimerMocks/MockBombTimerTextPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockBombTimerTextPanel {
    MOCK_METHOD(void, setTimeToExplosion, (float timeToExplosion));
};

```

`Tests/Mocks/DefusingAlertMocks/MockDefusingAlertCondition.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockDefusingAlertCondition {
    MOCK_METHOD(bool, shouldRun, ());
    MOCK_METHOD(bool, shouldShowDefuseAlert, ());
};

```

`Tests/Mocks/DefusingAlertMocks/MockDefusingAlertContext.h`:

```h
#pragma once

struct DefusingAlertState;
struct MockDefusingAlertCondition;
struct MockDefusingAlertPanel;
struct MockDefusingCountdownTextPanel;
struct MockPanel;
struct MockPlantedC4;
struct MockConfig;

struct MockDefusingAlertContext {
    MOCK_METHOD(MockPanel&, defusingAlertContainerPanel, ());
    MOCK_METHOD(MockDefusingCountdownTextPanel&, defusingCountdownTextPanel, ());
    MOCK_METHOD(MockPlantedC4&, c4BeingDefused, ());
    MOCK_METHOD(bool, hasC4BeingDefused, ());
    MOCK_METHOD(MockDefusingAlertCondition&, defusingAlertCondition, ());
    MOCK_METHOD(MockDefusingAlertPanel&, defusingAlertPanel, ());
    MOCK_METHOD(DefusingAlertState&, state, ());
    MOCK_METHOD(MockConfig&, config, ());
};

```

`Tests/Mocks/DefusingAlertMocks/MockDefusingAlertPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockDefusingAlertPanel {
    MOCK_METHOD(void, showAndUpdate, ());
    MOCK_METHOD(void, hide, ());
};

```

`Tests/Mocks/DefusingAlertMocks/MockDefusingCountdownTextPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <Utils/Optional.h>

struct MockDefusingCountdownTextPanel {
    MOCK_METHOD(MockDefusingCountdownTextPanel&, setTimeToDefuseEnd, (Optional<float> timeToDefuseEnd));
    MOCK_METHOD(MockDefusingCountdownTextPanel&, setCanBeDefused, (Optional<bool> canBeDefused));
};

```

`Tests/Mocks/Features/Hud/BombPlantAlert/MockBombPlantAlertPanelFactory.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockPanel;

struct MockBombPlantAlertPanelFactory {
    MOCK_METHOD(MockPanel&, createContainerPanel, (MockPanel& parent));
    MOCK_METHOD(MockPanel&, createBombsiteIconPanel, (MockPanel& container, const char* iconURL));
    MOCK_METHOD(MockPanel&, createTimerPanel, (MockPanel& container));
};

```

`Tests/Mocks/HudMocks/MockBombStatusPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockBombStatusPanel {
    MOCK_METHOD(void, hide, ());
    MOCK_METHOD(void, restore, ());
};

```

`Tests/Mocks/HudMocks/MockBombStatusPanelContext.h`:

```h
#pragma once

#include <gmock/gmock.h>

#include <Common/Visibility.h>

struct MockPanel;

struct MockBombStatusPanelContext {
    MOCK_METHOD(MockPanel&, bombStatusPanel, ());
    MOCK_METHOD(MockPanel&, scoreAndTimeAndBombPanel, ());
    MOCK_METHOD(MockPanel&, invisiblePanel, ());
    MOCK_METHOD(Visibility&, visibility, ());
};

```

`Tests/Mocks/HudMocks/MockBombStatusPanelManagerContext.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockBombStatusPanel;
struct MockBombTimer;
struct MockPostRoundTimer;

struct MockBombStatusPanelManagerContext {
    MOCK_METHOD(MockBombStatusPanel&, bombStatusPanel, ());
    MOCK_METHOD(MockPostRoundTimer&, postRoundTimer, ());
    MOCK_METHOD(MockBombTimer&, bombTimer, ());
};

```

`Tests/Mocks/HudMocks/MockDeathNotice.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <Utils/Optional.h>

struct MockDeathNotice {
    MOCK_METHOD(bool, isLocalPlayerKiller, ());
    MOCK_METHOD(Optional<bool>, wasSpawnedThisRound, ());
    MOCK_METHOD(void, markAsJustSpawned, ());
};

```

`Tests/Mocks/HudMocks/MockDeathNotices.h`:

```h
#pragma once

#include <functional>

struct MockDeathNotice;

struct MockDeathNotices {
    MOCK_METHOD(void, forEach, (const std::function<void(MockDeathNotice&)>&));
};

```

`Tests/Mocks/HudMocks/MockHud.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockDeathNotices;
struct MockPanel;

struct MockHud {
    MOCK_METHOD(MockDeathNotices&, deathNotices, ());
    MOCK_METHOD(MockPanel&, timerTextPanel, ());
    MOCK_METHOD(MockPanel&, getHudReticle, ());
    MOCK_METHOD(MockPanel&, scoreAndTimeAndBomb, ());
};

```

`Tests/Mocks/KillfeedPreserverMocks/MockKillfeedPreserverContext.h`:

```h
#pragma once

#include <functional>

#include <gmock/gmock.h>

struct KillfeedPreserverState;
struct MockDeathNotice;
struct MockDeathNotices;
struct MockConfig;

struct MockKillfeedPreserverContext {
    MOCK_METHOD(KillfeedPreserverState&, state, ());
    MOCK_METHOD(MockDeathNotices&, deathNotices, ());
    MOCK_METHOD(const std::function<void(MockDeathNotice&)>&, preserveDeathNotice, ());
    MOCK_METHOD(MockConfig&, config, ());
};

```

`Tests/Mocks/MockBaseEntity.h`:

```h
#pragma once

#include <type_traits>
#include <CS2/Classes/Color.h>
#include <GameClient/Entities/BaseModelEntity.h>
#include <GameClient/Entities/PlayerPawn.h>
#include <GameClient/Entities/SmokeGrenadeProjectile.h>
#include <Utils/Optional.h>

#include "MockPlayerPawn.h"

struct MockHookContext;
struct MockModelEntity;
struct MockSmokeGrenadeProjectile;

struct MockBaseEntity {
    MOCK_METHOD(void, applyGlowRecursively, (cs2::Color color, int range));
    MOCK_METHOD(void, applyGlowRecursively, (cs2::Color color));
    MOCK_METHOD(void, applySpawnProtectionEffectRecursively, (cs2::Color color));
    MOCK_METHOD(void, removeSpawnProtectionEffectRecursively, ());
    MOCK_METHOD(Optional<bool>, hasOwner, ());
    MOCK_METHOD(MockSmokeGrenadeProjectile&, asSmokeGrenadeProjectile, ());
    MOCK_METHOD(MockModelEntity&, asModelEntity, ());
    MOCK_METHOD(MockPlayerPawn&, castToPlayerPawn, ());
    
    auto& baseEntity()
    {
        return *this;
    }

    template <template <typename> typename EntityType>
    [[nodiscard]] decltype(auto) as()
    {
        if constexpr (std::is_same_v<EntityType<MockHookContext>, SmokeGrenadeProjectile<MockHookContext>>) {
            return asSmokeGrenadeProjectile();
        } else if constexpr (std::is_same_v<EntityType<MockHookContext>, BaseModelEntity<MockHookContext>>) {
            return asModelEntity();
        }
    }

    template <template <typename> typename EntityType>
    [[nodiscard]] decltype(auto) cast()
    {
        if constexpr (std::is_same_v<EntityType<MockHookContext>, PlayerPawn<MockHookContext>>) {
            return castToPlayerPawn();
        }
    }
};

```

`Tests/Mocks/MockBaseWeapon.h`:

```h
#pragma once

#include <gmock/gmock.h>

#include <GameClient/Entities/C4.h>

struct MockBaseEntity;
struct MockC4;
struct MockHookContext;

struct MockBaseWeapon {
    MOCK_METHOD(std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool), getSceneObjectUpdater, ());
    MOCK_METHOD(void, setSceneObjectUpdater, (std::uint64_t(*updater)(cs2::C_CSWeaponBase*, void*, bool)));
    MOCK_METHOD(MockBaseEntity&, baseEntity, ());
    MOCK_METHOD(bool, isSniperRifle, ());
    MOCK_METHOD(Optional<float>, bulletInaccuracy, ());
    MOCK_METHOD(MockC4&, castToC4, ());

    template <template <typename> typename EntityType>
    [[nodiscard]] decltype(auto) cast()
    {
        if constexpr (std::is_same_v<EntityType<MockHookContext>, C4<MockHookContext>>) {
            return castToC4();
        }
    }
};

```

`Tests/Mocks/MockC4.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <CS2/Constants/BombsiteIndex.h>
#include <Utils/Optional.h>

struct MockC4 {
    MOCK_METHOD(bool, operatorBool, ());
    MOCK_METHOD(Optional<bool>, isBeingPlanted, ());
    MOCK_METHOD(Optional<float>, timeToArmingEnd, ());
    MOCK_METHOD(Optional<float>, armingEndTime, ());
    MOCK_METHOD(Optional<cs2::BombsiteIndex>, nearestBombsiteIndex, ());

    [[nodiscard]] operator bool()
    {
        return operatorBool();
    }
};

```

`Tests/Mocks/MockClientPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <GameClient/Panorama/PanoramaLabel.h>

struct MockHookContext;
struct MockLabelPanel;
struct MockPanel;

struct MockClientPanel {
    MOCK_METHOD(MockPanel&, uiPanel, ());
    MOCK_METHOD(MockLabelPanel&, asLabel, ());
    
    template <template <typename> typename PanelType>
    [[nodiscard]] decltype(auto) as()
    {
        if constexpr (std::is_same_v<PanelType<MockHookContext>, PanoramaLabel<MockHookContext>>) {
            return asLabel();
        }
    }
};

```

`Tests/Mocks/MockConfig.h`:

```h
#pragma once

#include <any>
#include <cstddef>

#include <gmock/gmock.h>

#include <Config/ConfigVariableTypes.h>

struct MockConfig {
    MOCK_METHOD(std::any, getVariable, (std::size_t configVariableTypeIndex));
    MOCK_METHOD(void, setVariable, (std::size_t configVariableTypeIndex, std::any value));
    MOCK_METHOD(void, setVariableWithoutAutoSave, (std::size_t configVariableTypeIndex, std::any value));

    template <typename ConfigVariable>
    void expectGetVariable(ConfigVariable::ValueType expectedValue)
    {
        EXPECT_CALL(*this, getVariable(ConfigVariableTypes::indexOf<ConfigVariable>())).WillOnce(testing::Return(expectedValue));
    }

    template <typename ConfigVariable>
    [[nodiscard]] decltype(auto) expectGetVariable()
    {
        return EXPECT_CALL(*this, getVariable(ConfigVariableTypes::indexOf<ConfigVariable>()));
    }

    template <typename ConfigVariable>
    [[nodiscard]] auto getVariable()
    {
        auto&& variable = getVariable(ConfigVariableTypes::indexOf<ConfigVariable>());
        if (variable.has_value())
            return std::any_cast<typename ConfigVariable::ValueType>(variable);
        return ConfigVariable::kDefaultValue;
    }

    template <typename ConfigVariable>
    void setVariableWithoutAutoSave(ConfigVariable::ValueType value)
    {
        setVariableWithoutAutoSave(ConfigVariableTypes::indexOf<ConfigVariable>(), value);
    }
};

```

`Tests/Mocks/MockConfigConversion.h`:

```h
#pragma once

#include <cstdint>
#include <functional>

#include <gmock/gmock.h>

struct MockConfigConversion {
    MOCK_METHOD(void, beginRoot, ());
    MOCK_METHOD(void, endRoot, ());
    MOCK_METHOD(void, beginObject, (const char8_t* id));
    MOCK_METHOD(void, endObject, ());
    MOCK_METHOD(void, boolean, (const char8_t* id, std::function<void(bool)> valueSetter, std::function<bool()> valueGetter));
    MOCK_METHOD(void, uint, (const char8_t* id, std::function<void(std::uint64_t)> valueSetter, std::function<std::uint64_t()> valueGetter));
};

```

`Tests/Mocks/MockCrosshair.h`:

```h
#pragma once

#include <gmock/gmock.h>

#include <CS2/Classes/Color.h>
#include <Utils/Optional.h>

struct MockCrosshair {
    MOCK_METHOD(Optional<cs2::Color>, getColor, ());
};

```

`Tests/Mocks/MockCvarSystem.h`:

```h
#pragma once

#include <any>
#include <gmock/gmock.h>
#include <GameClient/ConVars/ConVarTypes.h>

struct MockCvarSystem {
    MOCK_METHOD(std::any, getConVarValue, (std::size_t conVarTypeIndex));

    template <typename ConVarType>
    [[nodiscard]] auto getConVarValue()
    {
        return std::any_cast<std::optional<typename ConVarType::ValueType>>(getConVarValue(ConVarTypes::indexOf<ConVarType>()));
    }
};


```

`Tests/Mocks/MockGameRules.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <Utils/Optional.h>

struct MockGameRules {
    MOCK_METHOD(bool, hasScheduledRoundRestart, ());
    MOCK_METHOD(Optional<bool>, isRoundOver, ());
    MOCK_METHOD(Optional<float>, roundEndTime, ());
};

```

`Tests/Mocks/MockGlowProperty.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <Utils/Optional.h>

struct MockGlowProperty {
    MOCK_METHOD(Optional<bool>, isGlowing, ());
};

```

`Tests/Mocks/MockGui.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockGui {
    MOCK_METHOD(void, updateFromConfig, ());
};

```

`Tests/Mocks/MockHookContext.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <Features/FeaturesStates.h>
#include <Features/Hud/BombPlantAlert/BombPlantAlertPanelFactory.h>
#include <GameClient/Panorama/PanelHandle.h>
#include <GameClient/Crosshair.h>
#include <GameClient/WorldToScreen/ViewToProjectionMatrix.h>

struct ConfigState;
struct MockConfig;
struct MockCrosshair;
struct MockCvarSystem;
struct MockGameRules;
struct MockGui;
struct MockHud;
struct MockPanelFactory;
struct MockPanelHandle;
struct MockPanoramaUiEngine;
struct MockPlayerController;
struct MockPlayerPawn;
struct MockViewToProjectionMatrix;
struct MockBombPlantAlertPanelFactory;

class OsirisDirectoryPath;

struct MockHookContext {
    MOCK_METHOD(MockHud&, hud, ());
    MOCK_METHOD(MockGameRules&, gameRules, ());
    MOCK_METHOD(MockPanelFactory&, panelFactory, ());
    MOCK_METHOD(MockConfig&, config, ());
    MOCK_METHOD(ConfigState&, configState, ());
    MOCK_METHOD(OsirisDirectoryPath&, osirisDirectoryPath, ());
    MOCK_METHOD(MockGui&, gui, ());
    MOCK_METHOD(FeaturesStates&, featuresStates, ());
    MOCK_METHOD(MockPlayerController&, localPlayerController, ());
    MOCK_METHOD(MockPanelHandle&, makePanelHandle, (cs2::PanelHandle& panelHandle));
    MOCK_METHOD(MockViewToProjectionMatrix&, makeViewToProjectionMatrix, ());
    MOCK_METHOD(MockCvarSystem&, cvarSystem, ());
    MOCK_METHOD(MockPlayerPawn&, activeLocalPlayerPawn, ());
    MOCK_METHOD(MockCrosshair&, makeCrosshair, ());
    MOCK_METHOD(MockPanoramaUiEngine&, makePanoramaUiEngine, ());
    MOCK_METHOD(MockBombPlantAlertPanelFactory&, makeBombPlantAlertPanelFactory, ());
    MOCK_METHOD(Optional<float>, localPlayerBulletInaccuracy, ());

    template <template <typename> typename T, typename... Args>
    [[nodiscard]] decltype(auto) make(Args&&... args)
    {
        if constexpr (std::is_same_v<T<MockHookContext>, PanelHandle<MockHookContext>>) {
            return makePanelHandle(std::forward<Args>(args)...);
        } else if constexpr (std::is_same_v<T<MockHookContext>, ViewToProjectionMatrix<MockHookContext>>) {
            return makeViewToProjectionMatrix(std::forward<Args>(args)...);
        } else if constexpr (std::is_same_v<T<MockHookContext>, Crosshair<MockHookContext>>) {
            return makeCrosshair(std::forward<Args>(args)...);
        } else if constexpr (std::is_same_v<T<MockHookContext>, PanoramaUiEngine<MockHookContext>>) {
            return makePanoramaUiEngine(std::forward<Args>(args)...);
        } else if constexpr (std::is_same_v<T<MockHookContext>, BombPlantAlertPanelFactory<MockHookContext>>) {
            return makeBombPlantAlertPanelFactory(std::forward<Args>(args)...);
        }
    }
};

```

`Tests/Mocks/MockImagePanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockPanel;

struct MockImagePanel {
    MOCK_METHOD(void, setImageSvg, (const char* imageUrl));
    MOCK_METHOD(void, setImageSvg, (const char* imageUrl, int textureHeight));
    MOCK_METHOD(MockPanel&, uiPanel, ());
};

```

`Tests/Mocks/MockLabelPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockPanel;

struct MockLabelPanel {
    MOCK_METHOD(void, setText, (const char* text));
    MOCK_METHOD(MockPanel&, uiPanel, ());
};

```

`Tests/Mocks/MockMemoryAllocator.h`:

```h
#pragma once

#include <cstddef>
#include <memory>

#include <gmock/gmock.h>

#include <MemoryAllocation/MemoryAllocatorBase.h>

struct MockMemoryAllocator {
    MOCK_METHOD(std::byte*, allocate, (std::size_t size), (noexcept));
    MOCK_METHOD(void, deallocate, (std::byte* memory, std::size_t size), (noexcept));

    using MockType = testing::StrictMock<MockMemoryAllocator>;
    [[nodiscard]] static std::shared_ptr<MockType> create()
    {
        if (const auto existingMock = mockMemoryAllocator.lock())
            return existingMock;

        auto mock = std::make_shared<MockMemoryAllocator::MockType>();
        mockMemoryAllocator = mock;
        return mock;
    }

    static std::byte* invokeAllocate(std::size_t size)
    {
        if (const auto mock = mockMemoryAllocator.lock())
            return mock->allocate(size);
        return nullptr;
    }

    static void invokeDeallocate(std::byte* memory, std::size_t size)
    {
        if (const auto mock = mockMemoryAllocator.lock())
            mock->deallocate(memory, size);
    }

private:
    inline static std::weak_ptr<MockMemoryAllocator::MockType> mockMemoryAllocator;
};

std::byte* MemoryAllocatorBase::allocate(std::size_t size) noexcept
{
    return MockMemoryAllocator::invokeAllocate(size);
}

void MemoryAllocatorBase::deallocate(std::byte* memory, std::size_t size) noexcept
{
    MockMemoryAllocator::invokeDeallocate(memory, size);
}

```

`Tests/Mocks/MockModelEntity.h`:

```h
#pragma once

#include <type_traits>
#include <gmock/gmock.h>

#include <Mocks/MockGlowProperty.h>
#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockPlayerPawn.h>
#include <Mocks/MockPlantedC4.h>

struct MockModelEntity {
    MOCK_METHOD(MockGlowProperty&, glowProperty, ());
    MOCK_METHOD(MockBaseEntity&, baseEntity, ());
    MOCK_METHOD(MockPlayerPawn&, asPlayerPawn, ());
    MOCK_METHOD(MockPlantedC4&, asPlantedC4, ());

    template <template <typename...> typename EntityType>
    [[nodiscard]] decltype(auto) as() noexcept
    {
        if constexpr (std::is_same_v<EntityType<MockHookContext>, PlayerPawn<MockHookContext>>)
            return asPlayerPawn();
        else if constexpr (std::is_same_v<EntityType<MockHookContext>, PlantedC4<MockHookContext>>)
            return asPlantedC4();
        else
            static_assert(!std::is_same_v<EntityType<MockHookContext>, EntityType<MockHookContext>>, "Unknown type");
    }
};

```

`Tests/Mocks/MockPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <CS2/Classes/Color.h>
#include <CS2/Panorama/CUILength.h>
#include <CS2/Panorama/PanelHandle.h>
#include <CS2/Panorama/StyleEnums.h>
#include <Utils/Optional.h>

struct MockClientPanel;
struct PanelFontParams;
struct PanelAlignmentParams;
struct PanelMarginParams;

struct MockPanel {
    MOCK_METHOD(void, setParent, (const MockPanel& parent));
    MOCK_METHOD(void, show, ());
    MOCK_METHOD(void, hide, ());
    MOCK_METHOD(Optional<bool>, isVisible, ());
    MOCK_METHOD(void, setWidth, (cs2::CUILength width));
    MOCK_METHOD(void, setHeight, (cs2::CUILength width));
    MOCK_METHOD(void, setMixBlendMode, (cs2::EMixBlendMode mode));
    MOCK_METHOD(void, setTextAlign, (cs2::ETextAlign textAlign));
    MOCK_METHOD(void, setFont, (const PanelFontParams& params));
    MOCK_METHOD(void, setVisible, (bool visible));
    MOCK_METHOD(void, setBorderRadius, (cs2::CUILength radius));
    MOCK_METHOD(void, setAlign, (const PanelAlignmentParams& alignmentParams));
    MOCK_METHOD(void, setBackgroundColor, (cs2::Color color));
    MOCK_METHOD(void, setBorder, (cs2::CUILength borderWidth, cs2::Color color));
    MOCK_METHOD(void, setColor, (cs2::Color color));
    MOCK_METHOD(void, setFlowChildren, (cs2::EFlowDirection flowDirection));
    MOCK_METHOD(void, setPosition, (cs2::CUILength x, cs2::CUILength y));
    MOCK_METHOD(void, setMargin, (const PanelMarginParams& params));
    MOCK_METHOD(cs2::PanelHandle, getHandle, ());
    MOCK_METHOD(MockClientPanel&, clientPanel, ());
};

```

`Tests/Mocks/MockPanelFactory.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockClientPanel;
struct MockImagePanel;
struct MockPanel;

struct MockPanelFactory {
    MOCK_METHOD(MockClientPanel&, createPanel, (MockPanel& parentPanel));
    MOCK_METHOD(MockClientPanel&, createPanel, (MockPanel& parentPanel, const char* id));
    MOCK_METHOD(MockClientPanel&, createLabelPanel, (MockPanel& parentPanel));
    MOCK_METHOD(MockImagePanel&, createImagePanel, (MockPanel& parentPanel));
};

```

`Tests/Mocks/MockPanelHandle.h`:

```h
#pragma once

#include <functional>
#include <gmock/gmock.h>

struct MockPanel;

struct MockPanelHandle {
    MOCK_METHOD(MockPanel&, getOrInit, (std::function<MockPanel&()>));
    MOCK_METHOD(MockPanel&, get, ());
};

```

`Tests/Mocks/MockPanoramaUiEngine.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <CS2/Panorama/PanelHandle.h>

struct MockPanel;

struct MockPanoramaUiEngine {
    MOCK_METHOD(void, deletePanelByHandle, (cs2::PanelHandle handle));
    MOCK_METHOD(MockPanel&, getPanelFromHandle, (cs2::PanelHandle handle));
    MOCK_METHOD(void, runScript, (MockPanel& contextPanel, const char* script));
};

```

`Tests/Mocks/MockPlantedC4.h`:

```h
#pragma once

#include <optional>

#include <gmock/gmock.h>
#include <CS2/Constants/BombsiteIndex.h>
#include <Utils/Optional.h>

struct MockBaseEntity;

struct MockPlantedC4 {
    MOCK_METHOD(Optional<cs2::BombsiteIndex>, bombsiteIndex, ());
    MOCK_METHOD(Optional<float>, getTimeToExplosion, ());
    MOCK_METHOD(Optional<float>, getTimeToDefuseEnd, ());
    MOCK_METHOD(Optional<bool>, canBeDefused, ());
    MOCK_METHOD(Optional<bool>, isTicking, ());
    MOCK_METHOD(MockBaseEntity&, baseEntity, ());
};

```

`Tests/Mocks/MockPlayerController.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <CS2/Classes/Entities/CCSPlayerController.h>
#include <Utils/Optional.h>

struct MockBaseEntity;

struct MockPlayerController {
    MOCK_METHOD(Optional<cs2::CCSPlayerController::m_iCompTeammateColor>, playerColorIndex, ());
    MOCK_METHOD(MockBaseEntity&, pawn, ());
};

```

`Tests/Mocks/MockPlayerPawn.h`:

```h
#pragma once

#include <optional>
#include <GameClient/Entities/TeamNumber.h>
#include <Utils/Optional.h>

struct MockBaseEntity;
struct MockBaseWeapon;
struct MockPlayerController;

struct MockPlayerPawn {
    MOCK_METHOD(MockBaseEntity&, baseEntity, ());
    MOCK_METHOD(std::optional<bool>, isAlive, ());
    MOCK_METHOD(Optional<int>, health, ());
    MOCK_METHOD(bool, isControlledByLocalPlayer, ());
    MOCK_METHOD(bool, isTTorCT, ());
    MOCK_METHOD(std::optional<bool>, isEnemy, ());
    MOCK_METHOD(TeamNumber, teamNumber, ());
    MOCK_METHOD(Optional<bool>, hasImmunity, ());
    MOCK_METHOD(MockPlayerController&, playerController, ());
    MOCK_METHOD(std::uint64_t(*)(cs2::C_CSPlayerPawn*, void*, bool), getSceneObjectUpdater, ());
    MOCK_METHOD(void, setSceneObjectUpdater, (std::uint64_t(*updater)(cs2::C_CSPlayerPawn*, void*, bool)));
    MOCK_METHOD(bool, operatorBool, (), (const));
    MOCK_METHOD(Optional<bool>, isScoped, ());
    MOCK_METHOD(MockBaseWeapon&, getActiveWeapon, ());
    MOCK_METHOD(bool, isUsingSniperRifle, ());

    [[nodiscard]] explicit operator bool() const
    {
        return operatorBool();
    }
};

```

`Tests/Mocks/MockSmokeGrenadeProjectile.h`:

```h
#pragma once

#include <gmock/gmock.h>
#include <Utils/Optional.h>

struct MockSmokeGrenadeProjectile {
    MOCK_METHOD(Optional<bool>, didSmokeEffect, ());
};

```

`Tests/Mocks/MockViewToProjectionMatrix.h`:

```h
#pragma once

#include <optional>
#include <gmock/gmock.h>

struct MockViewToProjectionMatrix {
    MOCK_METHOD(std::optional<float>, transformY, (float yInViewSpace));
};

```

`Tests/Mocks/PostRoundTimer/MockPostRoundTimer.h`:

```h
#pragma once

#include <gmock/gmock.h>

#include <Common/Visibility.h>

struct MockPostRoundTimer {
    MOCK_METHOD(Visibility, update, ());
};

```

`Tests/Mocks/PostRoundTimer/MockPostRoundTimerCondition.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockPostRoundTimerCondition {
    MOCK_METHOD(bool, shouldRun, ());
    MOCK_METHOD(bool, shouldShowPostRoundTimer, ());
};

```

`Tests/Mocks/PostRoundTimer/MockPostRoundTimerContext.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockGameRules;
struct MockPostRoundTimerCondition;
struct MockPostRoundTimerPanel;
struct PostRoundTimerState;
struct MockConfig;

struct MockPostRoundTimerContext {
    MOCK_METHOD(MockPostRoundTimerCondition&, condition, ());
    MOCK_METHOD(MockPostRoundTimerPanel&, postRoundTimerPanel, ());
    MOCK_METHOD(MockGameRules&, gameRules, ());
    MOCK_METHOD(PostRoundTimerState&, state, ());
    MOCK_METHOD(bool, isGameRoundTimeVisible, ());
    MOCK_METHOD(MockConfig&, config, ());
};

```

`Tests/Mocks/PostRoundTimer/MockPostRoundTimerPanel.h`:

```h
#pragma once

#include <gmock/gmock.h>

struct MockPostRoundTimerPanel {
    MOCK_METHOD(void, showAndUpdate, ());
    MOCK_METHOD(void, hide, ());
};

```

`Tests/UnitTests/CMakeLists.txt`:

```txt
add_executable(UnitTests)

if(MSVC)
  target_compile_options(UnitTests PRIVATE "/MP")
endif()

target_include_directories(UnitTests PRIVATE "${CMAKE_SOURCE_DIR}/Tests" "${CMAKE_SOURCE_DIR}/Source")
target_link_libraries(UnitTests gtest_main gmock Threads::Threads)
set_target_properties(UnitTests PROPERTIES OUTPUT_NAME UnitTestsBin)
gtest_discover_tests(UnitTests DISCOVERY_TIMEOUT 60 TEST_PREFIX Unit_)

add_subdirectory(Config)
add_subdirectory(Features)
add_subdirectory(GameClient)
add_subdirectory(MemorySearch)
add_subdirectory(Platform)
add_subdirectory(Utils)

```

`Tests/UnitTests/Config/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  ConfigFromStringTests.cpp
  ConfigSchemaTests.cpp
  ConfigToStringTests.cpp
  ConfigVariablesTests.cpp
)

```

`Tests/UnitTests/Config/ConfigFromStringTests.cpp`:

```cpp
#include <cstdint>
#include <string>

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Config/ConfigStringConversionState.h>
#include <Config/ConfigFromString.h>

struct MockConfigValueSetter {
    MOCK_METHOD(void, setValueBool, (std::string id, bool value));
    MOCK_METHOD(void, setValueUint, (std::string id, std::uint64_t value));

    [[nodiscard]] auto boolSetterFunctor(std::string id)
    {
        return [this, id](bool value) {
            setValueBool(id, value);
        };
    }

    [[nodiscard]] auto uintSetterFunctor(std::string id)
    {
        return [this, id](std::uint64_t value) {
            setValueUint(id, value);
        };
    }
};

struct ConfigFromStringTestParam {
    std::u8string_view bufferContent{};
    ConfigStringConversionState conversionState{};
    std::function<void(MockConfigValueSetter&)> setExpectations = [](MockConfigValueSetter&){};
    ConfigStringConversionState expectedConversionState{};
    std::size_t expectedReadBytes{};
};

using CreateConfigFromStringSchemaFunctor = std::function<void(ConfigFromString&, MockConfigValueSetter&)>;

class ConfigFromStringTest : public testing::TestWithParam<std::tuple<CreateConfigFromStringSchemaFunctor, ConfigFromStringTestParam>> {
protected:
    testing::StrictMock<MockConfigValueSetter> mockConfigValueSetter;
};

TEST_P(ConfigFromStringTest, TestStringToConfigConversion) {
    const auto& param = std::get<1>(GetParam());

    param.setExpectations(mockConfigValueSetter);

    auto conversionState = param.conversionState;
    ConfigFromString configFromString{param.bufferContent, conversionState};
    configFromString.beginRoot();
    std::get<0>(GetParam())(configFromString, mockConfigValueSetter);
    const auto result = configFromString.endRoot();

    EXPECT_EQ(result, param.expectedReadBytes);
    EXPECT_EQ(conversionState.offset, param.expectedConversionState.offset);
    EXPECT_EQ(conversionState.nestingLevel, param.expectedConversionState.nestingLevel);
    for (auto nestingLevel = 0u; nestingLevel <= param.expectedConversionState.nestingLevel; ++nestingLevel)
        EXPECT_EQ(conversionState.indexInNestingLevel[nestingLevel], param.expectedConversionState.indexInNestingLevel[nestingLevel]);
}

INSTANTIATE_TEST_SUITE_P(EmptyRoot, ConfigFromStringTest, testing::Combine(
testing::Values([](ConfigFromString&, MockConfigValueSetter&) {}),
testing::Values(
    ConfigFromStringTestParam{
        .bufferContent = u8"{}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 2
        },
        .expectedReadBytes = 2
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{0},
            .offset = 0
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 2
        },
        .expectedReadBytes = 1
    },
        ConfigFromStringTestParam{
        .bufferContent = u8" \n\t\r{\n\t\t\n}\n\n",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 10
        },
        .expectedReadBytes = 10
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n \n\r\t{\n\t \r\t",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 11
        },
        .expectedReadBytes = 11
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\r\t\n }\t\n\r ",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 11
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 16
        },
        .expectedReadBytes = 5
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{x",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"x}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}{",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{0},
            .offset = 0
        },
        .expectedReadBytes = 0
    }
)));

INSTANTIATE_TEST_SUITE_P(OneObjectInRoot, ConfigFromStringTest, testing::Combine(
testing::Values([](ConfigFromString& configFromString, MockConfigValueSetter&) {
    configFromString.beginObject(u8"Obj1");
    configFromString.endObject();
}),
testing::Values(
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Obj1\":{}}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 11
        },
        .expectedReadBytes = 11
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{0},
            .offset = 0
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Obj1\":",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Obj1\":{",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 9
        },
        .expectedReadBytes = 8
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 9
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 10
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 10
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 11
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n\r\r{\n \"Obj1\"\n\r\r:\n\n{\r\t}\t\n}\t ",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 25
        },
        .expectedReadBytes = 25
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\r\t \n{\r\n\n",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 8
        },
        .expectedReadBytes = 8
    },
    ConfigFromStringTestParam{
        .bufferContent = u8" \n\n\t\"Obj1\"\n :\t",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 8
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 12
        },
        .expectedReadBytes = 4
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Obj1\"\n :\t\n {\r\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 12
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 27
        },
        .expectedReadBytes = 15
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n\n}\r\r",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 27
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 32
        },
        .expectedReadBytes = 5
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"  } \n",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 32
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 35
        },
        .expectedReadBytes = 3
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Obj12\":{}}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 2
        },
        .expectedReadBytes = 2
    }
)));

INSTANTIATE_TEST_SUITE_P(MultipleElementsInRoot, ConfigFromStringTest, testing::Combine(
testing::Values([](ConfigFromString& configFromString, MockConfigValueSetter& mockConfigValueSetter) {
    configFromString.boolean(u8"BoolFirst", mockConfigValueSetter.boolSetterFunctor("BoolFirst"), []{ return bool{}; });
    configFromString.beginObject(u8"Obj1");
    configFromString.endObject();
    configFromString.uint(u8"UintFirst", mockConfigValueSetter.uintSetterFunctor("UintFirst"), []{ return std::uint64_t{}; });
    configFromString.boolean(u8"BoolSecond", mockConfigValueSetter.boolSetterFunctor("BoolSecond"), []{ return bool{}; });
    configFromString.beginObject(u8"Obj2");
    configFromString.endObject();
    configFromString.uint(u8"UintSecond", mockConfigValueSetter.uintSetterFunctor("UintSecond"), []{ return std::uint64_t{}; });
    configFromString.uint(u8"UintThird", mockConfigValueSetter.uintSetterFunctor("UintThird"), []{ return std::uint64_t{}; });
}),
testing::Values(
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"BoolFirst\":false,\"Obj1\":{},\"UintFirst\":0,\"BoolSecond\":true,\"Obj2\":{},\"UintSecond\":123,\"UintThird\":18446744073709551615}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintFirst", 0));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolSecond", true));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 121
        },
        .expectedReadBytes = 121
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{0},
            .offset = 0
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"BoolFirst\":fals",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"BoolFirst\":false",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 18
        },
        .expectedReadBytes = 17
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Obj1\":",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 18
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 18
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Obj1\":{",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 18
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, config_params::kInvalidObjectIndex},
            .offset = 27
        },
        .expectedReadBytes = 9
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, config_params::kInvalidObjectIndex},
            .offset = 27
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 28
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintFirst\":0",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 28
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 28
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintFirst\":0,",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 28
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintFirst", 0));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 42
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"BoolSecond\":tru",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 42
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 42
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"BoolSecond\":true",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 42
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolSecond", true));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 60
        },
        .expectedReadBytes = 18
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Obj2\":",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 60
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 60
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Obj2\":{",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 60
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 4, config_params::kInvalidObjectIndex},
            .offset = 69
        },
        .expectedReadBytes = 9
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 4, config_params::kInvalidObjectIndex},
            .offset = 69
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 70
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintSecond\":123",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 70
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 70
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintSecond\":123,",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 70
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 87
        },
        .expectedReadBytes = 17
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintThird\":18446744073709551615",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 87
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 87
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintThird\":18446744073709551615}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 87
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 121
        },
        .expectedReadBytes = 34
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n\n{\n\t\"BoolFirst\" \n\n:\t\r\n false\n\t, \"Obj1\" :\t{  } \r,  \t\"UintFirst\"\t:\t0\n,\r\"BoolSecond\"\r\r:\ntrue\n,\n\"Obj2\" : \n\n{  }\n,\r\"UintSecond\"\t:\t123\r,\n\"UintThird\" \r:\r\n18446744073709551615\n}\n",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintFirst", 0));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolSecond", true));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 170
        },
        .expectedReadBytes = 170
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n\n{\n\t\"BoolFirst\" \n\n:\t\r\n fals",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 5
        },
        .expectedReadBytes = 5
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"BoolFirst\" \n\n:\t\r\n false\n\t, \"Obj1\" :\t",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 5
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 31
        },
        .expectedReadBytes = 26
    },
    ConfigFromStringTestParam{
        .bufferContent = u8", \"Obj1\" :\t{  ",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 31
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, config_params::kInvalidObjectIndex},
            .offset = 45
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"} \r,  \t\"UintFirst\"\t:\t0",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, config_params::kInvalidObjectIndex},
            .offset = 45
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 48
        },
        .expectedReadBytes = 3
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",  \t\"UintFirst\"\t:\t0\n,\r\"BoolSecond\"\r\r:\ntru",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 48
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintFirst", 0));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 68
        },
        .expectedReadBytes = 20
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\r\"BoolSecond\"\r\r:\ntrue",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 68
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolSecond", true));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 90
        },
        .expectedReadBytes = 22
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n,\n\"Obj2\" : \n",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 90
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 91
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"Obj2\" : \n\n{  ",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 91
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 4, config_params::kInvalidObjectIndex},
            .offset = 107
        },
        .expectedReadBytes = 16
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}\n,\r\"Uint",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 4, config_params::kInvalidObjectIndex},
            .offset = 107
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 109
        },
        .expectedReadBytes = 2
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\r\"UintSecond\"\t:\t123\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 109
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 130
        },
        .expectedReadBytes = 21
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"UintThird\" \r:\r\n18446744073709551615",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 130
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 130
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"UintThird\" \r:\r\n18446744073709551615\n",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 130
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 169
        },
        .expectedReadBytes = 39
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}\n",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 169
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 170
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"UintThird\":18446744073709551615,\"UintSecond\":123,\"Obj2\":{},\"BoolSecond\":true,\"UintFirst\":0,\"Obj1\":{},\"BoolFirst\":false}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 33
        },
        .expectedReadBytes = 33
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintSecond\":123,\"Obj2\":{},\"BoolSecond\":true,\"UintFirst\":0,\"Obj1\":{},\"BoolFirst\":false}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 33
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 50
        },
        .expectedReadBytes = 17
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Obj2\":{},\"BoolSecond\":true,\"UintFirst\":0,\"Obj1\":{},\"BoolFirst\":false}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 50
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 60
        },
        .expectedReadBytes = 10
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"BoolSecond\":true,\"UintFirst\":0,\"Obj1\":{},\"BoolFirst\":false}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 60
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolSecond", true));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 78
        },
        .expectedReadBytes = 18
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"UintFirst\":0,\"Obj1\":{},\"BoolFirst\":false}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 78
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintFirst", 0));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 92
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Obj1\":{},\"BoolFirst\":false}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 92
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 102
        },
        .expectedReadBytes = 10
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"BoolFirst\":false}",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 102
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 121
        },
        .expectedReadBytes = 19
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\r\n{\t \"UintThird\"\n:\r18446744073709551615\t,\t\"UintSecond\"\n:\t123\n,\r\"Obj2\" :\n{\r}\t,\n\"BoolSecond\" : true, \"UintFirst\":\n0\t, \"Obj1\":\t{\n\n},\n\"BoolFirst\": false }\r",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 40
        },
        .expectedReadBytes = 40
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\t\"UintSecond\"\n:\t123\n,\r\"Obj2\" :\n{\r}\t,\n\"BoolSecond\" : true, \"UintFirst\":\n0\t, \"Obj1\":\t{\n\n},\n\"BoolFirst\": false }\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 40
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 61
        },
        .expectedReadBytes = 21
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\r\"Obj2\" :\n{\r}\t,\n\"BoolSecond\" : true, \"UintFirst\":\n0\t, \"Obj1\":\t{\n\n},\n\"BoolFirst\": false }\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 61
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 76
        },
        .expectedReadBytes = 15
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"BoolSecond\" : true, \"UintFirst\":\n0\t, \"Obj1\":\t{\n\n},\n\"BoolFirst\": false }\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4},
            .offset = 76
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolSecond", true));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 97
        },
        .expectedReadBytes = 21
    },
    ConfigFromStringTestParam{
        .bufferContent = u8", \"UintFirst\":\n0\t, \"Obj1\":\t{\n\n},\n\"BoolFirst\": false }\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 97
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintFirst", 0));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 114
        },
        .expectedReadBytes = 17
    },
    ConfigFromStringTestParam{
        .bufferContent = u8", \"Obj1\":\t{\n\n},\n\"BoolFirst\": false }\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 97
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 111
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"BoolFirst\": false }\r",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1},
            .offset = 111
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 133
        },
        .expectedReadBytes = 22
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"BoolFirst\":false}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 19
        },
        .expectedReadBytes = 19
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\" BoolFirst\":false}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"BoolFirst \":false}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\" BoolFirst \":false}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"\rBoolFirst\n\":false}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"\tBoolFirst\":false}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Bool First\":false}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"BoolFirst\":false+}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("BoolFirst", false));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 18
        },
        .expectedReadBytes = 18
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"UintSecond\":123}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintSecond", 123));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 18
        },
        .expectedReadBytes = 18
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"\tUintSecond\":123}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"UintSecond\t\":123}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"\tUintSecond\t\":123}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Uint Second\":123}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Obj1\":{}}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 11
        },
        .expectedReadBytes = 11
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\" Obj1\":{}}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Obj1 \":{}}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\" Obj1 \":{}}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Ob j1\":{}}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"UintThird\":18446744073709551615}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("UintThird", 18446744073709551615u));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 34
        },
        .expectedReadBytes = 34
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"UintThird\":184467440737095516155}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    }
)));

INSTANTIATE_TEST_SUITE_P(MultipleElementsInMultipleNestingLevels, ConfigFromStringTest, testing::Combine(
testing::Values([](ConfigFromString& configFromString, MockConfigValueSetter& mockConfigValueSetter) {
    configFromString.beginObject(u8"Group1");
    configFromString.beginObject(u8"Function1");
    configFromString.boolean(u8"Enabled", mockConfigValueSetter.boolSetterFunctor("Group1.Function1.Enabled"), []{ return bool{}; });
    configFromString.endObject();
    configFromString.beginObject(u8"Function2");
    configFromString.boolean(u8"Enabled", mockConfigValueSetter.boolSetterFunctor("Group1.Function2.Enabled"), []{ return bool{}; });
    configFromString.uint(u8"Mode", mockConfigValueSetter.uintSetterFunctor("Group1.Function2.Mode"), []{ return std::uint64_t{}; });
    configFromString.endObject();
    configFromString.endObject();

    configFromString.beginObject(u8"Group2");
    configFromString.beginObject(u8"Function1");
    configFromString.boolean(u8"Enabled", mockConfigValueSetter.boolSetterFunctor("Group2.Function1.Enabled"), []{ return bool{}; });
    configFromString.endObject();
    configFromString.beginObject(u8"Function2");
    configFromString.boolean(u8"Enabled", mockConfigValueSetter.boolSetterFunctor("Group2.Function2.Enabled"), []{ return bool{}; });
    configFromString.uint(u8"Mode", mockConfigValueSetter.uintSetterFunctor("Group2.Function2.Mode"), []{ return std::uint64_t{}; });
    configFromString.endObject();
    configFromString.endObject();
}),
testing::Values(
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Group1\":{\"Function1\":{\"Enabled\":true},\"Function2\":{\"Enabled\":false,\"Mode\":1024}},\"Group2\":{\"Function1\":{\"Enabled\":false},\"Function2\":{\"Enabled\":true,\"Mode\":514}}}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function1.Enabled", true));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function2.Enabled", false));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group1.Function2.Mode", 1024));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function1.Enabled", false));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function2.Enabled", true));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group2.Function2.Mode", 514));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 164
        },
        .expectedReadBytes = 164
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{0},
            .offset = 0
        },
        .expectedReadBytes = 0
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"{\"Group1\":",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Group1\":{\"Function1\":",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 1
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 11
        },
        .expectedReadBytes = 10
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Function1\":{\"Enabled\":tru",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 11
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, config_params::kInvalidObjectIndex},
            .offset = 24
        },
        .expectedReadBytes = 13
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Enabled\":true",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, config_params::kInvalidObjectIndex},
            .offset = 24
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function1.Enabled", true));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0},
            .offset = 38
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"},\"Function2\":",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0},
            .offset = 38
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0},
            .offset = 39
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Function2\":{\"Enabled\":fals",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0},
            .offset = 39
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, config_params::kInvalidObjectIndex},
            .offset = 53
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Enabled\":false,\"Mode\":1024",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, config_params::kInvalidObjectIndex},
            .offset = 53
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function2.Enabled", false));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0},
            .offset = 68
        },
        .expectedReadBytes = 15
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Mode\":1024}",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0},
            .offset = 68
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group1.Function2.Mode", 1024));
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 1},
            .offset = 81
        },
        .expectedReadBytes = 13
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"},\"Group2\":",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 1},
            .offset = 81
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 82
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Group2\":{\"Function1\":",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 82
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, config_params::kInvalidObjectIndex},
            .offset = 93
        },
        .expectedReadBytes = 11
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Function1\":{\"Enabled\":fals",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, config_params::kInvalidObjectIndex},
            .offset = 93
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, config_params::kInvalidObjectIndex},
            .offset = 106
        },
        .expectedReadBytes = 13
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Enabled\":false",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, config_params::kInvalidObjectIndex},
            .offset = 106
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function1.Enabled", false));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0},
            .offset = 121
        },
        .expectedReadBytes = 15
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0},
            .offset = 121
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0},
            .offset = 122
        },
        .expectedReadBytes = 1
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Function2\":{",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0},
            .offset = 122
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, config_params::kInvalidObjectIndex},
            .offset = 136
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\"Enabled\":true,",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, config_params::kInvalidObjectIndex},
            .offset = 136
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function2.Enabled", true));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0},
            .offset = 150
        },
        .expectedReadBytes = 14
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\"Mode\":514}",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0},
            .offset = 150
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group2.Function2.Mode", 514));
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 1},
            .offset = 162
        },
        .expectedReadBytes = 12
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}}",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 1},
            .offset = 162
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 164
        },
        .expectedReadBytes = 2
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n{\n\t\"Group1\"\n\r:\r { \"Function1\":\n{\n\"Enabled\":\ttrue\r}\n\n,\r\"Function2\": { \"Enabled\": false,\n\"Mode\":1024\n}\t\t}\r,\n\"Group2\":\t{\n\"Function1\" :{ \"Enabled\"\r:\nfalse\n},\"Function2\":{\"Enabled\":true\r\n,\r\n\"Mode\":514\n}}}",
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function1.Enabled", true));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function2.Enabled", false));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group1.Function2.Mode", 1024));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function1.Enabled", false));
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function2.Enabled", true));
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group2.Function2.Mode", 514));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 200
        },
        .expectedReadBytes = 200
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\n{\n",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 3
        },
        .expectedReadBytes = 3
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"\t\"Group1\"\n\r:\r {",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, config_params::kInvalidObjectIndex},
            .offset = 3
        },
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 18
        },
        .expectedReadBytes = 15
    },
    ConfigFromStringTestParam{
        .bufferContent = u8" \"Function1\":\n{\n\"Enabled\":\ttrue\r",
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, config_params::kInvalidObjectIndex},
            .offset = 18
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function1.Enabled", true));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0},
            .offset = 50
        },
        .expectedReadBytes = 32
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"}\n\n,\r\"Function2\": { \"Enabled\": false",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0},
            .offset = 50
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group1.Function2.Enabled", false));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0},
            .offset = 86
        },
        .expectedReadBytes = 36
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"Mode\":1024\n}\t\t}\r,",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0},
            .offset = 86
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group1.Function2.Mode", 1024));
        },
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 105
        },
        .expectedReadBytes = 19
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\n\"Group2\":\t{\n\"Function1\" :{ \"Enabled\"\r:\nfalse\n",
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0},
            .offset = 105
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function1.Enabled", false));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0},
            .offset = 152
        },
        .expectedReadBytes = 47
    },
    ConfigFromStringTestParam{
        .bufferContent = u8"},\"Function2\":{\"Enabled\":true\r\n",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0},
            .offset = 152
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueBool("Group2.Function2.Enabled", true));
        },
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0},
            .offset = 183
        },
        .expectedReadBytes = 31
    },
    ConfigFromStringTestParam{
        .bufferContent = u8",\r\n\"Mode\":514\n}}}",
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0},
            .offset = 183
        },
        .setExpectations = [](MockConfigValueSetter& mockConfigValueSetter) {
            EXPECT_CALL(mockConfigValueSetter, setValueUint("Group2.Function2.Mode", 514));
        },
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1},
            .offset = 200
        },
        .expectedReadBytes = 17
    }
)));

```

`Tests/UnitTests/Config/ConfigSchemaTests.cpp`:

```cpp
#include <cstddef>
#include <set>
#include <vector>

#include <gtest/gtest.h>

#include <Config/ConfigParams.h>
#include <Config/ConfigSchema.h>
#include <Config/ConfigVariableTypes.h>

#include <Mocks/MockConfig.h>
#include <Mocks/MockConfigConversion.h>
#include <Mocks/MockHookContext.h>

class ConfigSchemaTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfigConversion> mockConfigConversion;
    testing::StrictMock<MockConfig> mockConfig;

    ConfigSchema<MockHookContext> configSchema{mockHookContext};
    using IndexInNestingLevel = std::size_t;
    std::vector<IndexInNestingLevel> nestingLevels;
    std::set<std::size_t> configVariableIndexes;
};

TEST_F(ConfigSchemaTest, SchemaIsValid) {
    EXPECT_CALL(mockConfigConversion, beginRoot()).WillOnce(testing::Invoke([this] {
        EXPECT_EQ(nestingLevels.size(), 0);
        EXPECT_LE(nestingLevels.size(), config_params::kMaxNestingLevel);
        nestingLevels.push_back(IndexInNestingLevel{});
    }));

    EXPECT_CALL(mockConfigConversion, endRoot()).WillOnce(testing::Invoke([this] {
        EXPECT_EQ(nestingLevels.size(), 1);
        nestingLevels.clear();
    }));

    EXPECT_CALL(mockConfigConversion, beginObject(testing::_)).WillRepeatedly(testing::Invoke([this] {
        EXPECT_GT(nestingLevels.size(), 0);
        EXPECT_LE(nestingLevels.size(), config_params::kMaxNestingLevel);
        nestingLevels.push_back(IndexInNestingLevel{});
    }));

    EXPECT_CALL(mockConfigConversion, endObject()).WillRepeatedly(testing::Invoke([this] {
        EXPECT_GT(nestingLevels.size(), 1);
        nestingLevels.pop_back();
        EXPECT_LT(nestingLevels.back(), config_params::kMaxObjectIndex);
        ++nestingLevels.back();
    }));

    EXPECT_CALL(mockConfigConversion, boolean(testing::_, testing::_, testing::_)).WillRepeatedly(testing::Invoke([this] {
        EXPECT_GT(nestingLevels.size(), 0);
        EXPECT_LT(nestingLevels.back(), config_params::kMaxObjectIndex);
        ++nestingLevels.back();
    }));

    EXPECT_CALL(mockConfigConversion, uint(testing::_, testing::_, testing::_)).WillRepeatedly(testing::Invoke([this] {
        EXPECT_GT(nestingLevels.size(), 0);
        EXPECT_LT(nestingLevels.back(), config_params::kMaxObjectIndex);
        ++nestingLevels.back();
    }));

    configSchema.performConversion(mockConfigConversion);
}

TEST_F(ConfigSchemaTest, EachConfigVariableIsLoadedOnce) {
    EXPECT_CALL(mockConfigConversion, beginRoot());
    EXPECT_CALL(mockConfigConversion, endRoot());
    EXPECT_CALL(mockConfigConversion, beginObject(testing::_)).Times(testing::AnyNumber());
    EXPECT_CALL(mockConfigConversion, endObject()).Times(testing::AnyNumber());

    EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));

    EXPECT_CALL(mockConfigConversion, boolean(testing::_, testing::_, testing::_))
        .WillRepeatedly(testing::WithArg<1>(testing::Invoke([this](auto valueSetter) {
            EXPECT_CALL(mockConfig, setVariableWithoutAutoSave(testing::_, testing::_))
                .WillOnce(testing::WithArg<0>(testing::Invoke([this](std::size_t configVariableIndex) {
                    EXPECT_FALSE(configVariableIndexes.contains(configVariableIndex));
                    configVariableIndexes.insert(configVariableIndex);
                })));
            valueSetter(bool{}); 
        })));

    EXPECT_CALL(mockConfigConversion, uint(testing::_, testing::_, testing::_))
        .WillRepeatedly(testing::WithArg<1>(testing::Invoke([this](auto valueSetter) {
            EXPECT_CALL(mockConfig, setVariableWithoutAutoSave(testing::_, testing::_))
                .WillOnce(testing::WithArg<0>(testing::Invoke([this](std::size_t configVariableIndex) {
                    EXPECT_FALSE(configVariableIndexes.contains(configVariableIndex));
                    configVariableIndexes.insert(configVariableIndex);
                })));
            valueSetter(std::uint64_t{}); 
        })));

    configSchema.performConversion(mockConfigConversion);
    EXPECT_EQ(configVariableIndexes.size(), ConfigVariableTypes::size());
}

TEST_F(ConfigSchemaTest, EachConfigVariableIsSavedOnce) {
    EXPECT_CALL(mockConfigConversion, beginRoot());
    EXPECT_CALL(mockConfigConversion, endRoot());
    EXPECT_CALL(mockConfigConversion, beginObject(testing::_)).Times(testing::AnyNumber());
    EXPECT_CALL(mockConfigConversion, endObject()).Times(testing::AnyNumber());

    EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));

    EXPECT_CALL(mockConfigConversion, boolean(testing::_, testing::_, testing::_))
        .WillRepeatedly(testing::WithArg<2>(testing::Invoke([this](auto valueGetter) {
            EXPECT_CALL(mockConfig, getVariable(testing::_))
                .WillOnce(testing::WithArg<0>(testing::Invoke([this](std::size_t configVariableIndex) {
                    EXPECT_FALSE(configVariableIndexes.contains(configVariableIndex));
                    configVariableIndexes.insert(configVariableIndex);
                    return std::any{};
            })));
            valueGetter();
        })));

    EXPECT_CALL(mockConfigConversion, uint(testing::_, testing::_, testing::_))
        .WillRepeatedly(testing::WithArg<2>(testing::Invoke([this](auto valueGetter) {
            EXPECT_CALL(mockConfig, getVariable(testing::_))
                .WillOnce(testing::WithArg<0>(testing::Invoke([this](std::size_t configVariableIndex) {
                    EXPECT_FALSE(configVariableIndexes.contains(configVariableIndex));
                    configVariableIndexes.insert(configVariableIndex);
                    return std::any{};
            })));
            valueGetter(); 
        })));

    configSchema.performConversion(mockConfigConversion);
    EXPECT_EQ(configVariableIndexes.size(), ConfigVariableTypes::size());
}

```

`Tests/UnitTests/Config/ConfigToStringTests.cpp`:

```cpp
#include <array>
#include <span>
#include <stdexcept>
#include <string_view>

#include <gtest/gtest.h>

#include <Config/ConfigStringConversionState.h>
#include <Config/ConfigToString.h>

struct ConfigToStringTestParam {
    std::size_t bufferSize{};
    ConfigStringConversionState conversionState{};
    std::u8string_view expectedBufferContent{};
    ConfigStringConversionState expectedConversionState{};
};

using CreateConfigSchemaFunctor = std::function<void(ConfigToString&)>;

class ConfigToStringTest : public testing::TestWithParam<std::tuple<CreateConfigSchemaFunctor, ConfigToStringTestParam>> {
protected:
    [[nodiscard]] bool bufferEquals(std::span<const char8_t> buffer, std::u8string_view str) const
    {
        if (str.size() > buffer.size())
            return false;
        return std::ranges::equal(buffer.first(str.size()), str);
    }

    std::array<char8_t, 4096> buffer{};
};

TEST_P(ConfigToStringTest, TestConfigToStringConversion) {
    const auto& param = std::get<1>(GetParam());

    if (param.bufferSize > buffer.size())
        throw std::invalid_argument{"bufferSize param exceeds buffer size"};
    
    if (param.expectedBufferContent.size() > param.bufferSize)
        throw std::invalid_argument{"size of expected buffer content exceeds bufferSize param"};

    const auto bufferSlice = std::span{buffer}.first(param.bufferSize);
    auto conversionState = param.conversionState;
    ConfigToString configToString{bufferSlice, conversionState};
    configToString.beginRoot();
    std::get<0>(GetParam())(configToString);
    const auto writtenBytes = configToString.endRoot();

    EXPECT_TRUE(bufferEquals(bufferSlice, param.expectedBufferContent));
    std::cout << param.expectedBufferContent.size() << '\n';
    EXPECT_EQ(writtenBytes, param.expectedBufferContent.size());
    ASSERT_EQ(conversionState.nestingLevel, param.expectedConversionState.nestingLevel);
    for (auto nestingLevel = 0u; nestingLevel <= conversionState.nestingLevel; ++nestingLevel)
        EXPECT_EQ(conversionState.indexInNestingLevel[nestingLevel], param.expectedConversionState.indexInNestingLevel[nestingLevel]);
}

INSTANTIATE_TEST_SUITE_P(EmptyRoot, ConfigToStringTest, testing::Combine(
testing::Values(
    [](ConfigToString&){}
),
testing::Values(
    ConfigToStringTestParam{
        .bufferSize = 2,
        .expectedBufferContent = u8"{}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1000,
        .expectedBufferContent = u8"{}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .expectedBufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 1
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 0,
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{0}
        }
    })
));

INSTANTIATE_TEST_SUITE_P(OneObjectInRoot, ConfigToStringTest, testing::Combine(
testing::Values(
    [](ConfigToString& configToString) {
        configToString.beginObject(u8"Obj1");
        configToString.endObject();
    }
),
testing::Values(
    ConfigToStringTestParam{
        .bufferSize = 11,
        .expectedBufferContent = u8"{\"Obj1\":{}}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1000,
        .expectedBufferContent = u8"{\"Obj1\":{}}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .expectedBufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 8,
        .expectedBufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 9,
        .expectedBufferContent = u8"{\"Obj1\":{",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    })
));

INSTANTIATE_TEST_SUITE_P(MultipleElementsInRoot, ConfigToStringTest, testing::Combine(
testing::Values(
    [](ConfigToString& configToString) {
        configToString.boolean(u8"BoolFirst", [](bool){}, []{ return false; });
        configToString.beginObject(u8"Obj1");
        configToString.endObject();
        configToString.uint(u8"UintFirst", [](std::uint64_t){}, []{ return 0; });
        configToString.boolean(u8"BoolSecond", [](bool){}, []{ return true; });
        configToString.beginObject(u8"Obj2");
        configToString.endObject();
        configToString.uint(u8"UintSecond", [](std::uint64_t){}, []{ return 123; });
        configToString.uint(u8"UintThird", [](std::uint64_t){}, []{ return (std::numeric_limits<std::uint64_t>::max)(); });
    }
),
testing::Values(
    ConfigToStringTestParam{
        .bufferSize = 121,
        .expectedBufferContent = u8"{\"BoolFirst\":false,\"Obj1\":{},\"UintFirst\":0,\"BoolSecond\":true,\"Obj2\":{},\"UintSecond\":123,\"UintThird\":18446744073709551615}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1000,
        .expectedBufferContent = u8"{\"BoolFirst\":false,\"Obj1\":{},\"UintFirst\":0,\"BoolSecond\":true,\"Obj2\":{},\"UintSecond\":123,\"UintThird\":18446744073709551615}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 17,
        .expectedBufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 18,
        .expectedBufferContent = u8"{\"BoolFirst\":false",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 8,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 9,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        },
        .expectedBufferContent = u8",\"Obj1\":{",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 13,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 2}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 2}
        },
        .expectedBufferContent = u8",\"UintFirst\":0",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 3}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 17,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 3}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 3}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 18,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 3}
        },
        .expectedBufferContent = u8",\"BoolSecond\":true",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 8,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 9,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 4}
        },
        .expectedBufferContent = u8",\"Obj2\":{",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 4, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 4, 0}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 5}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 16,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 5}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 5}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 17,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 5}
        },
        .expectedBufferContent = u8",\"UintSecond\":123",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 6}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 32,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 6}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 6}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 33,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 6}
        },
        .expectedBufferContent = u8",\"UintThird\":18446744073709551615",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 7}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 7}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    }
)));

INSTANTIATE_TEST_SUITE_P(MultipleElementsInMultipleNestingLevels, ConfigToStringTest, testing::Combine(
testing::Values(
    [](ConfigToString& configToString) {
        configToString.beginObject(u8"Group1");
        configToString.beginObject(u8"Function1");
        configToString.boolean(u8"Enabled", [](bool){}, []{ return true; });
        configToString.endObject();
        configToString.beginObject(u8"Function2");
        configToString.boolean(u8"Enabled", [](bool){}, []{ return false; });
        configToString.uint(u8"Mode", [](std::uint64_t){}, []{ return 1024; });
        configToString.endObject();
        configToString.endObject();

        configToString.beginObject(u8"Group2");
        configToString.beginObject(u8"Function1");
        configToString.boolean(u8"Enabled", [](bool){}, []{ return false; });
        configToString.endObject();
        configToString.beginObject(u8"Function2");
        configToString.boolean(u8"Enabled", [](bool){}, []{ return true; });
        configToString.uint(u8"Mode", [](std::uint64_t){}, []{ return 514; });
        configToString.endObject();
        configToString.endObject();
    }
),
testing::Values(
    ConfigToStringTestParam{
        .bufferSize = 164,
        .expectedBufferContent = u8"{\"Group1\":{\"Function1\":{\"Enabled\":true},\"Function2\":{\"Enabled\":false,\"Mode\":1024}},\"Group2\":{\"Function1\":{\"Enabled\":false},\"Function2\":{\"Enabled\":true,\"Mode\":514}}}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1000,
        .expectedBufferContent = u8"{\"Group1\":{\"Function1\":{\"Enabled\":true},\"Function2\":{\"Enabled\":false,\"Mode\":1024}},\"Group2\":{\"Function1\":{\"Enabled\":false},\"Function2\":{\"Enabled\":true,\"Mode\":514}}}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .expectedBufferContent = u8"{",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 9,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 10,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 0}
        },
        .expectedBufferContent = u8"\"Group1\":{",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 12,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 13,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 0}
        },
        .expectedBufferContent = u8"\"Function1\":{",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 13,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 0}
        },
        .expectedBufferContent = u8"\"Enabled\":true",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 0, 1}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 1}
        },
        .expectedBufferContent = u8",\"Function2\":{",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 15,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 0}
        },
        .expectedBufferContent = u8"\"Enabled\":false",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 11,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 1}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 12,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 1}
        },
        .expectedBufferContent = u8",\"Mode\":1024",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 0, 1, 2}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 11,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 0, 2}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 11,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 1}
        },
        .expectedBufferContent = u8",\"Group2\":{",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 12,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 13,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 0}
        },
        .expectedBufferContent = u8"\"Function1\":{",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 15,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 0}
        },
        .expectedBufferContent = u8"\"Enabled\":false",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 0, 1}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 1}
        },
        .expectedBufferContent = u8",\"Function2\":{",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 13,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 14,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 0}
        },
        .expectedBufferContent = u8"\"Enabled\":true",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 10,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 1}
        },
        .expectedBufferContent = u8"",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 1}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 11,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 1}
        },
        .expectedBufferContent = u8",\"Mode\":514",
        .expectedConversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 3,
            .indexInNestingLevel{0, 1, 1, 2}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 2,
            .indexInNestingLevel{0, 1, 2}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 2}
        }
    },
    ConfigToStringTestParam{
        .bufferSize = 1,
        .conversionState{
            .nestingLevel = 1,
            .indexInNestingLevel{0, 2}
        },
        .expectedBufferContent = u8"}",
        .expectedConversionState{
            .nestingLevel = 0,
            .indexInNestingLevel{1}
        }
    }
)));

```

`Tests/UnitTests/Config/ConfigVariablesTests.cpp`:

```cpp
#include <type_traits>
#include <gtest/gtest.h>
#include <Config/ConfigVariables.h>

class ConfigVariablesTest : public testing::Test {
public:
    template <typename ConfigVariable>
    [[nodiscard]] static constexpr auto getNonDefaultValue()
    {
        if constexpr (std::is_same_v<typename ConfigVariable::ValueType, bool>)
            return !ConfigVariable::kDefaultValue;
        else if constexpr (std::is_enum_v<typename ConfigVariable::ValueType>)
            return typename ConfigVariable::ValueType{static_cast<std::underlying_type_t<typename ConfigVariable::ValueType>>(ConfigVariable::kDefaultValue) + 1};
        else if constexpr (IsRangeConstrained<typename ConfigVariable::ValueType>::value) {
            if (ConfigVariable::kDefaultValue != ConfigVariable::ValueType::kMin)
                return typename ConfigVariable::ValueType{ConfigVariable::ValueType::kMin};
            return typename ConfigVariable::ValueType{ConfigVariable::ValueType::kMax};
        } else
            static_assert(!std::is_same_v<ConfigVariable, ConfigVariable>, "Unsupported type");
    }

    ConfigVariables configVariables;
};

TEST_F(ConfigVariablesTest, EachVariableHasDefaultValueAfterConstruction) {
    ConfigVariableTypes::forEach([this] <typename ConfigVariable> (std::type_identity<ConfigVariable>) {
        EXPECT_EQ(configVariables.getVariableValue<ConfigVariable>(), ConfigVariable::kDefaultValue);
    });
}

TEST_F(ConfigVariablesTest, EachVariableCanBeSetToNonDefaultValue) {
    ConfigVariableTypes::forEach([this] <typename ConfigVariable> (std::type_identity<ConfigVariable>) {
        constexpr auto kNonDefaultValue{getNonDefaultValue<ConfigVariable>()};
        configVariables.storeVariableValue<ConfigVariable>(kNonDefaultValue);
        EXPECT_EQ(configVariables.getVariableValue<ConfigVariable>(), kNonDefaultValue);
    });
}

TEST_F(ConfigVariablesTest, ChangingVariableValueDoesNotAffectOtherVariables) {
    ConfigVariableTypes::forEach([this] <typename ConfigVariable> (std::type_identity<ConfigVariable>) {
        configVariables.storeVariableValue<ConfigVariable>(getNonDefaultValue<ConfigVariable>());
    });

    ConfigVariableTypes::forEach([this] <typename ConfigVariable> (std::type_identity<ConfigVariable>) {
        EXPECT_EQ(configVariables.getVariableValue<ConfigVariable>(), getNonDefaultValue<ConfigVariable>());
    });
}

```

`Tests/UnitTests/Features/CMakeLists.txt`:

```txt
add_subdirectory(Combat)
add_subdirectory(Hud)
add_subdirectory(Visuals)

```

`Tests/UnitTests/Features/Combat/CMakeLists.txt`:

```txt
add_subdirectory(SniperRifles)

```

`Tests/UnitTests/Features/Combat/SniperRifles/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE NoScopeInaccuracyVisTests.cpp)

```

`Tests/UnitTests/Features/Combat/SniperRifles/NoScopeInaccuracyVisTests.cpp`:

```cpp
#include <gtest/gtest.h>
#include <Features/Combat/SniperRifles/NoScopeInaccuracyVis/NoScopeInaccuracyVis.h>
#include <Mocks/HudMocks/MockHud.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockCrosshair.h>
#include <Mocks/MockPanel.h>
#include <Mocks/MockClientPanel.h>
#include <Mocks/MockCvarSystem.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPanelFactory.h>
#include <Mocks/MockPanelHandle.h>
#include <Mocks/MockPanoramaUiEngine.h>
#include <Mocks/MockPlayerPawn.h>
#include <Mocks/MockViewToProjectionMatrix.h>

class NoScopeInaccuracyVisTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockPanelHandle> mockPanelHandle;
    testing::StrictMock<MockPanel> mockPanel;
    testing::StrictMock<MockCrosshair> mockCrosshair;
    testing::StrictMock<MockPlayerPawn> mockLocalPlayerPawn;
    testing::StrictMock<MockViewToProjectionMatrix> mockViewToProjectionMatrix;
    testing::StrictMock<MockPanoramaUiEngine> mockPanoramaUiEngine;
    testing::StrictMock<MockHud> mockHud;
    testing::StrictMock<MockPanelFactory> mockPanelFactory;
    testing::StrictMock<MockClientPanel> mockClientPanel;
    testing::StrictMock<MockPanel> mockHudReticle;
    FeaturesStates featuresStates{};
    NoScopeInaccuracyVis<MockHookContext> noScopeInaccuracyVis{mockHookContext};
};

TEST_F(NoScopeInaccuracyVisTest, UpdateDoesNothingWhenDisabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<no_scope_inaccuracy_vis_vars::Enabled>(false);
    noScopeInaccuracyVis.update();
}

TEST_F(NoScopeInaccuracyVisTest, PanelIsHiddenOnDisable) {
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanelHandle(testing::Ref(featuresStates.noScopeInaccuracyVisState.panelHandle))).WillOnce(testing::ReturnRef(mockPanelHandle));
    EXPECT_CALL(mockPanelHandle, get()).WillOnce(testing::ReturnRef(mockPanel));
    EXPECT_CALL(mockPanel, hide());
    noScopeInaccuracyVis.onDisable();
}

TEST_F(NoScopeInaccuracyVisTest, PanelIsCreatedWhenDoesNotExist) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<no_scope_inaccuracy_vis_vars::Enabled>(true);
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanelHandle(featuresStates.noScopeInaccuracyVisState.panelHandle)).WillOnce(testing::ReturnRef(mockPanelHandle));
    EXPECT_CALL(mockHookContext, activeLocalPlayerPawn()).WillOnce(testing::ReturnRef(mockLocalPlayerPawn));
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::WithArg<0>(testing::Invoke([this](auto&& panelFactoryFunctor) -> decltype(auto) {
        EXPECT_CALL(mockHookContext, hud()).WillOnce(testing::ReturnRef(mockHud));
        EXPECT_CALL(mockHud, getHudReticle()).WillOnce(testing::ReturnRef(mockHudReticle));
        EXPECT_CALL(mockHookContext, panelFactory()).WillOnce(testing::ReturnRef(mockPanelFactory));
        EXPECT_CALL(mockPanelFactory, createPanel(testing::Ref(mockHudReticle))).WillOnce(testing::ReturnRef(mockClientPanel));
        EXPECT_CALL(mockClientPanel, uiPanel()).WillOnce(testing::ReturnRef(mockPanel));
        EXPECT_CALL(mockPanel, setWidth(cs2::CUILength::heightPercentage(100)));
        EXPECT_CALL(mockPanel, setBorderRadius(cs2::CUILength::percent(50)));
        EXPECT_CALL(mockPanel, setAlign(testing::_)).WillOnce(testing::WithArg<0>(testing::Invoke([](const auto& panelAlignmentParams) {
            EXPECT_EQ(panelAlignmentParams.horizontalAlignment, cs2::k_EHorizontalAlignmentCenter);
            EXPECT_EQ(panelAlignmentParams.verticalAlignment, cs2::k_EVerticalAlignmentCenter);
        })));
        return panelFactoryFunctor();
    })));
    EXPECT_CALL(mockLocalPlayerPawn, operatorBool()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockLocalPlayerPawn, isScoped()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockLocalPlayerPawn, isUsingSniperRifle()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockHookContext, makeViewToProjectionMatrix()).WillOnce(testing::ReturnRef(mockViewToProjectionMatrix));
    EXPECT_CALL(mockViewToProjectionMatrix, transformY(testing::_)).WillOnce(testing::Return(0.1f));
    EXPECT_CALL(mockHookContext, localPlayerBulletInaccuracy()).WillOnce(testing::Return(0.1f));
    EXPECT_CALL(mockHookContext, makeCrosshair()).WillOnce(testing::ReturnRef(mockCrosshair));
    EXPECT_CALL(mockCrosshair, getColor()).WillOnce(testing::Return(cs2::Color{255, 255, 255}));
    EXPECT_CALL(mockPanel, setVisible(true));
    EXPECT_CALL(mockPanel, setHeight(testing::_));
    EXPECT_CALL(mockPanel, setBorder(no_scope_inaccuracy_vis_params::kBorderWidth, testing::_));
    EXPECT_CALL(mockPanel, setBackgroundColor(testing::_));
    noScopeInaccuracyVis.update();
}

class NoScopeInaccuracyVisOnUnloadTest
    : public NoScopeInaccuracyVisTest,
      public testing::WithParamInterface<cs2::PanelHandle> {
};

TEST_P(NoScopeInaccuracyVisOnUnloadTest, PanelIsDeletedOnUnload) {
    EXPECT_CALL(mockHookContext, makePanoramaUiEngine()).WillOnce(testing::ReturnRef(mockPanoramaUiEngine));
    auto& panelHandle = featuresStates.noScopeInaccuracyVisState.panelHandle;
    panelHandle = GetParam();
    EXPECT_CALL(mockPanoramaUiEngine, deletePanelByHandle(panelHandle));
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    noScopeInaccuracyVis.onUnload();
}

INSTANTIATE_TEST_SUITE_P(, NoScopeInaccuracyVisOnUnloadTest, testing::Values(
    cs2::PanelHandle{.panelIndex = 123, .serialNumber = 1024},
    cs2::PanelHandle{}
));

struct NoScopeInaccuracyVisNotVisibleTestParam {
    bool hasActiveLocalPlayerPawn{};
    bool usingSniperRifle{};
    Optional<bool> scoped{};
};

class NoScopeInaccuracyVisNotVisibleTest
    : public NoScopeInaccuracyVisTest,
      public testing::WithParamInterface<NoScopeInaccuracyVisNotVisibleTestParam> {
};

TEST_P(NoScopeInaccuracyVisNotVisibleTest, PanelIsNotUpdatedWhenNotVisible) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<no_scope_inaccuracy_vis_vars::Enabled>(true);
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanelHandle(testing::Ref(featuresStates.noScopeInaccuracyVisState.panelHandle))).WillOnce(testing::ReturnRef(mockPanelHandle));
    EXPECT_CALL(mockHookContext, activeLocalPlayerPawn()).WillOnce(testing::ReturnRef(mockLocalPlayerPawn));
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::ReturnRef(mockPanel));
    EXPECT_CALL(mockLocalPlayerPawn, operatorBool()).WillRepeatedly(testing::Return(GetParam().hasActiveLocalPlayerPawn));
    EXPECT_CALL(mockLocalPlayerPawn, isScoped()).WillRepeatedly(testing::Return(GetParam().scoped));
    EXPECT_CALL(mockLocalPlayerPawn, isUsingSniperRifle()).WillRepeatedly(testing::Return(GetParam().usingSniperRifle));
    EXPECT_CALL(mockPanel, setVisible(false));
    noScopeInaccuracyVis.update();
}

INSTANTIATE_TEST_SUITE_P(, NoScopeInaccuracyVisNotVisibleTest, testing::ValuesIn(
    std::to_array<NoScopeInaccuracyVisNotVisibleTestParam>({
        {.hasActiveLocalPlayerPawn = false, .usingSniperRifle = true, .scoped{false}},
        {.hasActiveLocalPlayerPawn = true, .usingSniperRifle = false, .scoped{false}},
        {.hasActiveLocalPlayerPawn = true, .usingSniperRifle = true, .scoped{true}},
        {.hasActiveLocalPlayerPawn = true, .usingSniperRifle = true, .scoped{std::nullopt}}
    })
));

struct NoScopeInaccuracyVisColorTestParam {
    Optional<cs2::Color> crosshairColor;
    cs2::Color expectedBorderColor;
    cs2::Color expectedBackgroundColor;
};

class NoScopeInaccuracyVisColorTest
    : public NoScopeInaccuracyVisTest,
      public testing::WithParamInterface<NoScopeInaccuracyVisColorTestParam> {
};

TEST_P(NoScopeInaccuracyVisColorTest, CorrectPanelColorsAreSet) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<no_scope_inaccuracy_vis_vars::Enabled>(true);
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanelHandle(featuresStates.noScopeInaccuracyVisState.panelHandle)).WillOnce(testing::ReturnRef(mockPanelHandle));
    EXPECT_CALL(mockHookContext, activeLocalPlayerPawn()).WillOnce(testing::ReturnRef(mockLocalPlayerPawn));
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::ReturnRef(mockPanel));
    EXPECT_CALL(mockLocalPlayerPawn, operatorBool()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockLocalPlayerPawn, isScoped()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockLocalPlayerPawn, isUsingSniperRifle()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockHookContext, makeViewToProjectionMatrix()).WillOnce(testing::ReturnRef(mockViewToProjectionMatrix));
    EXPECT_CALL(mockViewToProjectionMatrix, transformY(testing::_)).WillOnce(testing::Return(0.2f));
    EXPECT_CALL(mockHookContext, localPlayerBulletInaccuracy()).WillOnce(testing::Return(0.1f));
    EXPECT_CALL(mockHookContext, makeCrosshair()).WillOnce(testing::ReturnRef(mockCrosshair));
    EXPECT_CALL(mockCrosshair, getColor()).WillOnce(testing::Return(GetParam().crosshairColor));
    EXPECT_CALL(mockPanel, setVisible(true));
    EXPECT_CALL(mockPanel, setHeight(testing::_));
    EXPECT_CALL(mockPanel, setBorder(no_scope_inaccuracy_vis_params::kBorderWidth, GetParam().expectedBorderColor));
    EXPECT_CALL(mockPanel, setBackgroundColor(GetParam().expectedBackgroundColor));
    noScopeInaccuracyVis.update();
}

static_assert(no_scope_inaccuracy_vis_params::kBorderAlpha == 255, "Update the test below");
static_assert(no_scope_inaccuracy_vis_params::kBackgroundAlpha == 30, "Update the test below");
static_assert(no_scope_inaccuracy_vis_params::kFallbackColor == cs2::Color{255, 255, 255}, "Update the test below");

INSTANTIATE_TEST_SUITE_P(, NoScopeInaccuracyVisColorTest, testing::ValuesIn(
    std::to_array<NoScopeInaccuracyVisColorTestParam>({
        {
            .crosshairColor{std::nullopt},
            .expectedBorderColor{255, 255, 255, 255},
            .expectedBackgroundColor{255, 255, 255, 30}
        },
        {
            .crosshairColor{cs2::Color{120, 50, 210}},
            .expectedBorderColor{120, 50, 210, 255},
            .expectedBackgroundColor{120, 50, 210, 30}
        },
        {
            .crosshairColor{cs2::Color{100, 50, 220, 10}},
            .expectedBorderColor{100, 50, 220, 255},
            .expectedBackgroundColor{100, 50, 220, 30}
        }
    })
));

struct NoScopeInaccuracyVisHeightTestParam {
    Optional<float> localPlayerBulletInaccuracy{};
    float expectedInaccuracyToTransform{};
    std::optional<float> transformedInaccuracy{};
    cs2::CUILength expectedHeight{};
};

class NoScopeInaccuracyVisHeightTest
    : public NoScopeInaccuracyVisTest,
      public testing::WithParamInterface<NoScopeInaccuracyVisHeightTestParam> {
};

TEST_P(NoScopeInaccuracyVisHeightTest, CorrectPanelHeightIsSet) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<no_scope_inaccuracy_vis_vars::Enabled>(true);
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanelHandle(featuresStates.noScopeInaccuracyVisState.panelHandle)).WillOnce(testing::ReturnRef(mockPanelHandle));
    EXPECT_CALL(mockHookContext, activeLocalPlayerPawn()).WillOnce(testing::ReturnRef(mockLocalPlayerPawn));
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::ReturnRef(mockPanel));
    EXPECT_CALL(mockLocalPlayerPawn, operatorBool()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockLocalPlayerPawn, isScoped()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockLocalPlayerPawn, isUsingSniperRifle()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockHookContext, makeViewToProjectionMatrix()).WillOnce(testing::ReturnRef(mockViewToProjectionMatrix));
    EXPECT_CALL(mockViewToProjectionMatrix, transformY(GetParam().expectedInaccuracyToTransform)).WillOnce(testing::Return(GetParam().transformedInaccuracy));
    EXPECT_CALL(mockHookContext, localPlayerBulletInaccuracy()).WillOnce(testing::Return(GetParam().localPlayerBulletInaccuracy));
    EXPECT_CALL(mockHookContext, makeCrosshair()).WillOnce(testing::ReturnRef(mockCrosshair));
    EXPECT_CALL(mockCrosshair, getColor()).WillOnce(testing::Return(cs2::Color{255, 255, 255}));
    EXPECT_CALL(mockPanel, setVisible(true));
    EXPECT_CALL(mockPanel, setHeight(GetParam().expectedHeight));
    EXPECT_CALL(mockPanel, setBorder(no_scope_inaccuracy_vis_params::kBorderWidth, testing::_));
    EXPECT_CALL(mockPanel, setBackgroundColor(testing::_));
    noScopeInaccuracyVis.update();
}

INSTANTIATE_TEST_SUITE_P(, NoScopeInaccuracyVisHeightTest, testing::ValuesIn(
    std::to_array<NoScopeInaccuracyVisHeightTestParam>({
        {
            .localPlayerBulletInaccuracy{std::nullopt},
            .expectedInaccuracyToTransform = 0.0f,
            .transformedInaccuracy{std::nullopt},
            .expectedHeight{cs2::CUILength::percent(0)}
        },
        {
            .localPlayerBulletInaccuracy{0.1f},
            .expectedInaccuracyToTransform = 0.1f,
            .transformedInaccuracy{std::nullopt},
            .expectedHeight{cs2::CUILength::percent(0)}
        },
        {
            .localPlayerBulletInaccuracy{0.1f},
            .expectedInaccuracyToTransform = 0.1f,
            .transformedInaccuracy{0.133f},
            .expectedHeight{cs2::CUILength::percent(13.3f)}
        },
        {
            .localPlayerBulletInaccuracy{1.0f},
            .expectedInaccuracyToTransform = 1.0f,
            .transformedInaccuracy{1.33f},
            .expectedHeight{cs2::CUILength::percent(133.0f)}
        }
    })
));

```

`Tests/UnitTests/Features/Hud/BombPlantAlert/BombPlantAlertPanelFactoryTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <CS2/Constants/IconURLs.h>
#include <Features/Hud/BombPlantAlert/BombPlantAlertPanelFactory.h>
#include <Matchers/Matchers.h>
#include <Mocks/MockClientPanel.h>
#include <Mocks/MockImagePanel.h>
#include <Mocks/MockPanel.h>
#include <Mocks/MockPanoramaUiEngine.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPanelFactory.h>

class BombPlantAlertPanelFactoryTest : public testing::Test {
protected:
    testing::StrictMock<MockPanelFactory> mockPanelFactory;
    testing::StrictMock<MockPanoramaUiEngine> mockPanoramaUiEngine;
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockPanel> mockParentPanel;
    testing::StrictMock<MockPanel> mockPanel;
    testing::StrictMock<MockImagePanel> mockImagePanel;
    testing::StrictMock<MockClientPanel> mockClientPanel;
    BombPlantAlertPanelFactory<MockHookContext> bombPlantAlertPanelFactory{mockHookContext};
};

TEST_F(BombPlantAlertPanelFactoryTest, ContainerPanelIsSetUpCorrectly) {
    EXPECT_CALL(mockHookContext, panelFactory()).WillOnce(testing::ReturnRef(mockPanelFactory));
    EXPECT_CALL(mockPanelFactory, createPanel(testing::Ref(mockParentPanel), testing::_)).WillOnce(testing::ReturnRef(mockClientPanel));
    EXPECT_CALL(mockClientPanel, uiPanel()).WillOnce(testing::ReturnRef(mockPanel));
    namespace panel_params = bomb_plant_alert_panel_params::container_panel_params;
    EXPECT_CALL(mockPanel, setFlowChildren(panel_params::kChildrenFlow));
    EXPECT_CALL(mockPanel, setWidth(panel_params::kWidth));
    EXPECT_CALL(mockPanel, setHeight(panel_params::kHeight));
    EXPECT_CALL(mockPanel, setPosition(panel_params::kPositionX, panel_params::kPositionY));
    EXPECT_CALL(mockPanel, setBorderRadius(panel_params::kBorderRadius));
    EXPECT_CALL(mockHookContext, makePanoramaUiEngine()).WillOnce(testing::ReturnRef(mockPanoramaUiEngine));
    EXPECT_CALL(mockPanoramaUiEngine, runScript(testing::Ref(mockParentPanel), testing::_));

    bombPlantAlertPanelFactory.createContainerPanel(mockParentPanel);
}

TEST_F(BombPlantAlertPanelFactoryTest, TimerPanelIsSetUpCorrectly) {
    EXPECT_CALL(mockHookContext, panelFactory()).WillOnce(testing::ReturnRef(mockPanelFactory));
    EXPECT_CALL(mockPanelFactory, createLabelPanel(testing::Ref(mockParentPanel))).WillOnce(testing::ReturnRef(mockClientPanel));
    EXPECT_CALL(mockClientPanel, uiPanel()).WillOnce(testing::ReturnRef(mockPanel));
    namespace panel_params = bomb_plant_alert_panel_params::timer_panel_params;
    EXPECT_CALL(mockPanel, setWidth(panel_params::kWidth));
    EXPECT_CALL(mockPanel, setFont(PanelFontParamsEq(panel_params::kFont)));
    EXPECT_CALL(mockPanel, setMixBlendMode(panel_params::kMixBlendMode));
    EXPECT_CALL(mockPanel, setAlign(PanelAlignmentParamsEq(panel_params::kAlignment)));
    EXPECT_CALL(mockPanel, setMargin(PanelMarginParamsEq(panel_params::kMargin)));
    EXPECT_CALL(mockPanel, setTextAlign(panel_params::kTextAlign));

    bombPlantAlertPanelFactory.createTimerPanel(mockParentPanel);
}

class BombPlantAlertPanelFactoryBombsiteIconTest
    : public BombPlantAlertPanelFactoryTest,
      public testing::WithParamInterface<const char*> {
};

TEST_P(BombPlantAlertPanelFactoryBombsiteIconTest, BombsiteIconPanelIsSetUpCorrectly) {
    EXPECT_CALL(mockHookContext, panelFactory()).WillOnce(testing::ReturnRef(mockPanelFactory));
    EXPECT_CALL(mockPanelFactory, createImagePanel(testing::Ref(mockParentPanel))).WillOnce(testing::ReturnRef(mockImagePanel));
    EXPECT_CALL(mockImagePanel, uiPanel()).WillOnce(testing::ReturnRef(mockPanel));
    namespace panel_params = bomb_plant_alert_panel_params::bombsite_icon_panel_params;
    EXPECT_CALL(mockImagePanel, setImageSvg(testing::StrEq(GetParam()), panel_params::kTextureHeight));
    EXPECT_CALL(mockPanel, setAlign(PanelAlignmentParamsEq(panel_params::kAlignment)));
    EXPECT_CALL(mockPanel, setMargin(PanelMarginParamsEq(panel_params::kMargin)));

    bombPlantAlertPanelFactory.createBombsiteIconPanel(mockParentPanel, GetParam());
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertPanelFactoryBombsiteIconTest, testing::Values(
    cs2::kBombsiteAPlantingIconUrl,
    cs2::kBombsiteBPlantingIconUrl
));

```

`Tests/UnitTests/Features/Hud/BombPlantAlert/BombPlantAlertTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/BombPlantAlert/BombPlantAlert.h>
#include <Mocks/Features/Hud/BombPlantAlert/MockBombPlantAlertPanelFactory.h>
#include <Mocks/HudMocks/MockHud.h>
#include <Mocks/MockBaseWeapon.h>
#include <Mocks/MockClientPanel.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockC4.h>
#include <Mocks/MockGameRules.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockLabelPanel.h>
#include <Mocks/MockPanel.h>
#include <Mocks/MockPanelHandle.h>
#include <Mocks/MockPanoramaUiEngine.h>
#include <Mocks/MockPlayerPawn.h>

class BombPlantAlertTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockPlayerPawn> mockPlayerPawn;
    testing::StrictMock<MockBaseWeapon> mockBaseWeapon;
    testing::StrictMock<MockC4> mockC4;
    testing::StrictMock<MockGameRules> mockGameRules;
    testing::StrictMock<MockPanelHandle> mockPanelHandle;
    testing::StrictMock<MockPanel> mockContainerPanel;
    testing::StrictMock<MockPanel> mockBombsiteAIconPanel;
    testing::StrictMock<MockPanel> mockBombsiteBIconPanel;
    testing::StrictMock<MockPanel> mockTimerPanel;
    testing::StrictMock<MockClientPanel> mockClientPanel;
    testing::StrictMock<MockLabelPanel> mockLabelPanel;
    testing::StrictMock<MockPanoramaUiEngine> mockPanoramaUiEngine;
    testing::StrictMock<MockBombPlantAlertPanelFactory> mockBombPlantAlertPanelFactory;
    testing::StrictMock<MockHud> mockHud;
    FeaturesStates featuresStates{};
    BombPlantAlert<MockHookContext> bombPlantAlert{mockHookContext};
};

TEST_F(BombPlantAlertTest, HideDoesNothingWhenFeatureNotEnabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<BombPlantAlertEnabled>(false);
    bombPlantAlert.hide();
}

class BombPlantAlertPanelHandleTest
    : public BombPlantAlertTest,
      public testing::WithParamInterface<cs2::PanelHandle> {
};

TEST_P(BombPlantAlertPanelHandleTest, HideMethodHidesPanelWhenFeatureEnabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanoramaUiEngine()).WillOnce(testing::ReturnRef(mockPanoramaUiEngine));
    EXPECT_CALL(mockPanoramaUiEngine, getPanelFromHandle(GetParam())).WillOnce(testing::ReturnRef(mockContainerPanel));
    EXPECT_CALL(mockContainerPanel, setVisible(false));

    mockConfig.expectGetVariable<BombPlantAlertEnabled>(true);
    featuresStates.hudFeaturesStates.bombPlantAlertState.containerPanelHandle = GetParam();
    bombPlantAlert.hide();
}

TEST_P(BombPlantAlertPanelHandleTest, PanelIsHiddenOnFeatureDisable) {
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanoramaUiEngine()).WillOnce(testing::ReturnRef(mockPanoramaUiEngine));
    EXPECT_CALL(mockPanoramaUiEngine, getPanelFromHandle(GetParam())).WillOnce(testing::ReturnRef(mockContainerPanel));    
    EXPECT_CALL(mockContainerPanel, setVisible(false));

    featuresStates.hudFeaturesStates.bombPlantAlertState.containerPanelHandle = GetParam();
    bombPlantAlert.onDisable();
}

TEST_P(BombPlantAlertPanelHandleTest, PanelIsDeletedOnUnload) {
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_CALL(mockHookContext, makePanoramaUiEngine()).WillOnce(testing::ReturnRef(mockPanoramaUiEngine));
    EXPECT_CALL(mockPanoramaUiEngine, deletePanelByHandle(GetParam()));
    featuresStates.hudFeaturesStates.bombPlantAlertState.containerPanelHandle = GetParam();
    bombPlantAlert.onUnload();
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertPanelHandleTest, testing::Values(
    cs2::PanelHandle{},
    cs2::PanelHandle{.panelIndex = 123, .serialNumber = 999}
));

struct BombPlantAlertNotVisibleTestParam {
    bool featureEnabled{};
    bool playerIsHoldingBomb{};
    Optional<bool> bombIsBeingPlanted{};
    Optional<float> timeToBombArmingEnd{};
};

class BombPlantAlertNotVisibleTest
    : public BombPlantAlertTest,
      public testing::WithParamInterface<BombPlantAlertNotVisibleTestParam> {
};

TEST_P(BombPlantAlertNotVisibleTest, BombPlantAlertIsNotShown) {
    mockConfig.expectGetVariable<BombPlantAlertEnabled>(GetParam().featureEnabled);

    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    EXPECT_CALL(mockPlayerPawn, getActiveWeapon()).WillRepeatedly(testing::ReturnRef(mockBaseWeapon));
    EXPECT_CALL(mockBaseWeapon, castToC4()).WillRepeatedly(testing::ReturnRef(mockC4));
    EXPECT_CALL(mockC4, operatorBool()).WillRepeatedly(testing::Return(GetParam().playerIsHoldingBomb));
    EXPECT_CALL(mockC4, isBeingPlanted()).WillRepeatedly(testing::Return(GetParam().bombIsBeingPlanted));
    EXPECT_CALL(mockC4, timeToArmingEnd()).WillRepeatedly(testing::Return(GetParam().timeToBombArmingEnd));

    EXPECT_EQ(bombPlantAlert.show(mockPlayerPawn), Visibility::Hidden);
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertNotVisibleTest, testing::ValuesIn(
    std::to_array<BombPlantAlertNotVisibleTestParam>({
        {.featureEnabled = false, .playerIsHoldingBomb = true, .bombIsBeingPlanted{true}, .timeToBombArmingEnd{1.5f}},
        {.featureEnabled = true, .playerIsHoldingBomb = false, .bombIsBeingPlanted{true}, .timeToBombArmingEnd{1.5f}},
        {.featureEnabled = true, .playerIsHoldingBomb = true, .bombIsBeingPlanted{std::nullopt}, .timeToBombArmingEnd{1.5f}},
        {.featureEnabled = true, .playerIsHoldingBomb = true, .bombIsBeingPlanted{false}, .timeToBombArmingEnd{1.5f}},
        {.featureEnabled = true, .playerIsHoldingBomb = true, .bombIsBeingPlanted{true}, .timeToBombArmingEnd{0.0f}},
        {.featureEnabled = true, .playerIsHoldingBomb = true, .bombIsBeingPlanted{true}, .timeToBombArmingEnd{-0.1f}},
        {.featureEnabled = true, .playerIsHoldingBomb = true, .bombIsBeingPlanted{true}, .timeToBombArmingEnd{std::nullopt}}
    })
));

struct BombPlantAlertBombsiteIconTestParam {
    Optional<cs2::BombsiteIndex> bombsiteIndex{};
    bool expectBombsiteAIconVisible{};
    bool expectBombsiteBIconVisible{};
};

class BombPlantAlertVisibleTest : public BombPlantAlertTest {
protected:
    virtual void setUpState()
    {
        auto& state = featuresStates.hudFeaturesStates.bombPlantAlertState;
        state.containerPanelHandle = cs2::PanelHandle{.panelIndex = 123, .serialNumber = 500};
        state.bombsiteAIconPanelHandle = cs2::PanelHandle{.panelIndex = 124, .serialNumber = 501};
        state.bombsiteBIconPanelHandle = cs2::PanelHandle{.panelIndex = 125, .serialNumber = 502};
        state.timerPanelHandle = cs2::PanelHandle{.panelIndex = 126, .serialNumber = 503};
    }

    void SetUp() override
    {
        mockConfig.expectGetVariable<BombPlantAlertEnabled>(true);
        setUpState();
        auto& state = featuresStates.hudFeaturesStates.bombPlantAlertState;
        EXPECT_CALL(mockHookContext, featuresStates()).WillRepeatedly(testing::ReturnRef(featuresStates));
        EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
        EXPECT_CALL(mockHookContext, gameRules()).WillOnce(testing::ReturnRef(mockGameRules));
        EXPECT_CALL(mockHookContext, makePanelHandle(testing::Ref(state.containerPanelHandle))).WillOnce(testing::ReturnRef(mockPanelHandle));
        EXPECT_CALL(mockHookContext, makePanoramaUiEngine()).WillRepeatedly(testing::ReturnRef(mockPanoramaUiEngine));
        EXPECT_CALL(mockPanoramaUiEngine, getPanelFromHandle(testing::Eq(std::ref(state.bombsiteAIconPanelHandle)))).WillOnce(testing::ReturnRef(mockBombsiteAIconPanel));
        EXPECT_CALL(mockPanoramaUiEngine, getPanelFromHandle(testing::Eq(std::ref(state.bombsiteBIconPanelHandle)))).WillOnce(testing::ReturnRef(mockBombsiteBIconPanel));
        EXPECT_CALL(mockPanoramaUiEngine, getPanelFromHandle(testing::Eq(std::ref(state.timerPanelHandle)))).WillOnce(testing::ReturnRef(mockTimerPanel));
        EXPECT_CALL(mockTimerPanel, clientPanel()).WillOnce(testing::ReturnRef(mockClientPanel));
        EXPECT_CALL(mockClientPanel, asLabel()).WillOnce(testing::ReturnRef(mockLabelPanel));
        EXPECT_CALL(mockC4, operatorBool()).WillOnce(testing::Return(true));
        EXPECT_CALL(mockPlayerPawn, getActiveWeapon()).WillOnce(testing::ReturnRef(mockBaseWeapon));
        EXPECT_CALL(mockBaseWeapon, castToC4()).WillOnce(testing::ReturnRef(mockC4));
    }
};

class BombPlantAlertBombsiteIconTest
    : public BombPlantAlertVisibleTest,
      public testing::WithParamInterface<BombPlantAlertBombsiteIconTestParam> {
};

TEST_P(BombPlantAlertBombsiteIconTest, CorrectBombIconIsShown) {
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::ReturnRef(mockContainerPanel));
    EXPECT_CALL(mockGameRules, isRoundOver()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockGameRules, roundEndTime()).WillOnce(testing::Return(123.0f));
    EXPECT_CALL(mockC4, isBeingPlanted()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockC4, timeToArmingEnd()).WillRepeatedly(testing::Return(0.5f));
    EXPECT_CALL(mockC4, armingEndTime()).WillOnce(testing::Return(122.0f));
    EXPECT_CALL(mockC4, nearestBombsiteIndex()).WillOnce(testing::Return(GetParam().bombsiteIndex));
    EXPECT_CALL(mockContainerPanel, setVisible(true));
    EXPECT_CALL(mockContainerPanel, setBackgroundColor(bomb_plant_alert_params::kPositiveBackgroundColor));
    EXPECT_CALL(mockBombsiteAIconPanel, setVisible(GetParam().expectBombsiteAIconVisible));
    EXPECT_CALL(mockBombsiteBIconPanel, setVisible(GetParam().expectBombsiteBIconVisible));
    EXPECT_CALL(mockTimerPanel, setColor(bomb_plant_alert_params::kPositiveTimerColor));
    EXPECT_CALL(mockLabelPanel, setText(testing::StrEq("0.5")));

    EXPECT_EQ(bombPlantAlert.show(mockPlayerPawn), Visibility::Visible);
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertBombsiteIconTest, testing::ValuesIn(
    std::to_array<BombPlantAlertBombsiteIconTestParam>({
        {.bombsiteIndex{std::nullopt}, .expectBombsiteAIconVisible = false, .expectBombsiteBIconVisible = false},
        {.bombsiteIndex{cs2::BombsiteIndex::BombsiteA}, .expectBombsiteAIconVisible = true, .expectBombsiteBIconVisible = false},
        {.bombsiteIndex{cs2::BombsiteIndex::BombsiteB}, .expectBombsiteAIconVisible = false, .expectBombsiteBIconVisible = true}
    })
));

struct BombPlantAlertColorTestParam {
    Optional<float> armingEndTime{};
    Optional<float> roundEndTime{};
    Optional<bool> isRoundOver{};
    cs2::Color expectedBackgroundColor;
    cs2::Color expectedTimerTextColor;
};

class BombPlantAlertColorTest
    : public BombPlantAlertVisibleTest,
      public testing::WithParamInterface<BombPlantAlertColorTestParam> {
};

TEST_P(BombPlantAlertColorTest, CorrectColorsAreUsed) {
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::ReturnRef(mockContainerPanel));
    EXPECT_CALL(mockGameRules, isRoundOver()).WillOnce(testing::Return(GetParam().isRoundOver));
    EXPECT_CALL(mockGameRules, roundEndTime()).WillRepeatedly(testing::Return(GetParam().roundEndTime));
    EXPECT_CALL(mockC4, isBeingPlanted()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockC4, timeToArmingEnd()).WillRepeatedly(testing::Return(0.5f));
    EXPECT_CALL(mockC4, armingEndTime()).WillRepeatedly(testing::Return(GetParam().armingEndTime));
    EXPECT_CALL(mockC4, nearestBombsiteIndex()).WillOnce(testing::Return(cs2::BombsiteIndex::BombsiteA));
    EXPECT_CALL(mockContainerPanel, setVisible(true));
    EXPECT_CALL(mockContainerPanel, setBackgroundColor(GetParam().expectedBackgroundColor));
    EXPECT_CALL(mockBombsiteAIconPanel, setVisible(true));
    EXPECT_CALL(mockBombsiteBIconPanel, setVisible(false));
    EXPECT_CALL(mockTimerPanel, setColor(GetParam().expectedTimerTextColor));
    EXPECT_CALL(mockLabelPanel, setText(testing::StrEq("0.5")));

    EXPECT_EQ(bombPlantAlert.show(mockPlayerPawn), Visibility::Visible);
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertColorTest, testing::ValuesIn(
    std::to_array<BombPlantAlertColorTestParam>({
        {
            .armingEndTime{10.5f}, 
            .roundEndTime{10.6f},
            .isRoundOver{false},
            .expectedBackgroundColor{bomb_plant_alert_params::kPositiveBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kPositiveTimerColor}
        },
        {
            .armingEndTime{23.001f}, 
            .roundEndTime{23.0f},
            .isRoundOver{false},
            .expectedBackgroundColor{bomb_plant_alert_params::kNegativeBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kNegativeTimerColor}
        },
        {
            .armingEndTime{10.5f}, 
            .roundEndTime{10.6f},
            .isRoundOver{std::nullopt},
            .expectedBackgroundColor{bomb_plant_alert_params::kPositiveBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kPositiveTimerColor}
        },
        {
            .armingEndTime{23.001f}, 
            .roundEndTime{23.0f},
            .isRoundOver{std::nullopt},
            .expectedBackgroundColor{bomb_plant_alert_params::kNegativeBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kNegativeTimerColor}
        },
        {
            .armingEndTime{10.5f}, 
            .roundEndTime{10.6f},
            .isRoundOver{true},
            .expectedBackgroundColor{bomb_plant_alert_params::kNegativeBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kNegativeTimerColor}
        },
        {
            .armingEndTime{23.001f}, 
            .roundEndTime{23.0f},
            .isRoundOver{true},
            .expectedBackgroundColor{bomb_plant_alert_params::kNegativeBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kNegativeTimerColor}
        },
        {
            .armingEndTime{std::nullopt}, 
            .roundEndTime{10.6f},
            .isRoundOver{false},
            .expectedBackgroundColor{bomb_plant_alert_params::kFallbackBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kFallbackTimerColor}
        },
        {
            .armingEndTime{10.0f}, 
            .roundEndTime{std::nullopt},
            .isRoundOver{false},
            .expectedBackgroundColor{bomb_plant_alert_params::kFallbackBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kFallbackTimerColor}
        },
        {
            .armingEndTime{std::nullopt}, 
            .roundEndTime{std::nullopt},
            .isRoundOver{false},
            .expectedBackgroundColor{bomb_plant_alert_params::kFallbackBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kFallbackTimerColor}
        },
        {
            .armingEndTime{std::nullopt}, 
            .roundEndTime{std::nullopt},
            .isRoundOver{std::nullopt},
            .expectedBackgroundColor{bomb_plant_alert_params::kFallbackBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kFallbackTimerColor}
        },
        {
            .armingEndTime{std::nullopt}, 
            .roundEndTime{std::nullopt},
            .isRoundOver{true},
            .expectedBackgroundColor{bomb_plant_alert_params::kNegativeBackgroundColor},
            .expectedTimerTextColor{bomb_plant_alert_params::kNegativeTimerColor}
        }
    })
));

struct BombPlantAlertTimerTextTestParam {
    float timeToArmingEnd{};
    const char* expectedTimerText{};
};

class BombPlantAlertTimerTextTest
    : public BombPlantAlertVisibleTest,
      public testing::WithParamInterface<BombPlantAlertTimerTextTestParam> {
};

TEST_P(BombPlantAlertTimerTextTest, CorrectTimerTextIsSet) {
    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::ReturnRef(mockContainerPanel));
    EXPECT_CALL(mockGameRules, isRoundOver()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockGameRules, roundEndTime()).WillOnce(testing::Return(123.0f));
    EXPECT_CALL(mockC4, isBeingPlanted()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockC4, timeToArmingEnd()).WillRepeatedly(testing::Return(GetParam().timeToArmingEnd));
    EXPECT_CALL(mockC4, armingEndTime()).WillOnce(testing::Return(122.0f));
    EXPECT_CALL(mockC4, nearestBombsiteIndex()).WillOnce(testing::Return(cs2::BombsiteIndex::BombsiteA));
    EXPECT_CALL(mockContainerPanel, setVisible(true));
    EXPECT_CALL(mockContainerPanel, setBackgroundColor(bomb_plant_alert_params::kPositiveBackgroundColor));
    EXPECT_CALL(mockBombsiteAIconPanel, setVisible(true));
    EXPECT_CALL(mockBombsiteBIconPanel, setVisible(false));
    EXPECT_CALL(mockTimerPanel, setColor(bomb_plant_alert_params::kPositiveTimerColor));
    EXPECT_CALL(mockLabelPanel, setText(testing::StrEq(GetParam().expectedTimerText)));

    EXPECT_EQ(bombPlantAlert.show(mockPlayerPawn), Visibility::Visible);
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertTimerTextTest, testing::ValuesIn(
    std::to_array<BombPlantAlertTimerTextTestParam>({
        {.timeToArmingEnd = 0.05f, .expectedTimerText = "0.0"},
        {.timeToArmingEnd = 0.1f, .expectedTimerText = "0.1"},
        {.timeToArmingEnd = 0.19f, .expectedTimerText = "0.1"},
        {.timeToArmingEnd = 3.0f, .expectedTimerText = "3.0"},
        {.timeToArmingEnd = 5.55f, .expectedTimerText = "5.5"}
    })
));

struct BombPlantAlertPanelCreationTestParam {
    bool handlesInitiallyInvalid{true};
    cs2::PanelHandle containerPanelHandle{};
    cs2::PanelHandle bombsiteAIconPanelHandle{};
    cs2::PanelHandle bombsiteBIconPanelHandle{};
    cs2::PanelHandle timerPanelHandle{};
};

class BombPlantAlertPanelCreationTest
    : public BombPlantAlertVisibleTest,
      public testing::WithParamInterface<BombPlantAlertPanelCreationTestParam> {
    void setUpState() override
    {
        if (GetParam().handlesInitiallyInvalid)
            featuresStates.hudFeaturesStates.bombPlantAlertState = {};
    }
};

TEST_P(BombPlantAlertPanelCreationTest, PanelIsCreatedCorrectly) {
    EXPECT_CALL(mockGameRules, isRoundOver()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockGameRules, roundEndTime()).WillOnce(testing::Return(123.0f));
    EXPECT_CALL(mockC4, isBeingPlanted()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockC4, timeToArmingEnd()).WillRepeatedly(testing::Return(0.5f));
    EXPECT_CALL(mockC4, armingEndTime()).WillOnce(testing::Return(122.0f));
    EXPECT_CALL(mockC4, nearestBombsiteIndex()).WillOnce(testing::Return(cs2::BombsiteIndex::BombsiteA));
    EXPECT_CALL(mockContainerPanel, setVisible(true));
    EXPECT_CALL(mockContainerPanel, setBackgroundColor(bomb_plant_alert_params::kPositiveBackgroundColor));
    EXPECT_CALL(mockBombsiteAIconPanel, setVisible(true));
    EXPECT_CALL(mockBombsiteBIconPanel, setVisible(false));
    EXPECT_CALL(mockTimerPanel, setColor(bomb_plant_alert_params::kPositiveTimerColor));
    EXPECT_CALL(mockLabelPanel, setText(testing::StrEq("0.5")));

    EXPECT_CALL(mockPanelHandle, getOrInit(testing::_)).WillOnce(testing::WithArg<0>(testing::Invoke(
        [this](auto&& f) -> decltype(auto) {
            EXPECT_CALL(mockHookContext, makeBombPlantAlertPanelFactory()).WillOnce(testing::ReturnRef(mockBombPlantAlertPanelFactory));
            EXPECT_CALL(mockHookContext, hud()).WillOnce(testing::ReturnRef(mockHud));
            testing::StrictMock<MockPanel> mockPanel;
            EXPECT_CALL(mockHud, scoreAndTimeAndBomb()).WillOnce(testing::ReturnRef(mockPanel));

            {
                testing::InSequence s;
                EXPECT_CALL(mockBombPlantAlertPanelFactory, createContainerPanel(testing::Ref(mockPanel))).WillOnce(testing::ReturnRef(mockContainerPanel));
                EXPECT_CALL(mockBombPlantAlertPanelFactory, createBombsiteIconPanel(testing::Ref(mockContainerPanel), cs2::kBombsiteAPlantingIconUrl)).WillOnce(testing::ReturnRef(mockBombsiteAIconPanel));
                EXPECT_CALL(mockBombPlantAlertPanelFactory, createBombsiteIconPanel(testing::Ref(mockContainerPanel), cs2::kBombsiteBPlantingIconUrl)).WillOnce(testing::ReturnRef(mockBombsiteBIconPanel));
                EXPECT_CALL(mockBombPlantAlertPanelFactory, createTimerPanel(testing::Ref(mockContainerPanel))).WillOnce(testing::ReturnRef(mockTimerPanel));
            }

            EXPECT_CALL(mockContainerPanel, getHandle()).WillOnce(testing::Return(GetParam().containerPanelHandle));
            EXPECT_CALL(mockBombsiteAIconPanel, getHandle()).WillOnce(testing::Return(GetParam().bombsiteAIconPanelHandle));
            EXPECT_CALL(mockBombsiteBIconPanel, getHandle()).WillOnce(testing::Return(GetParam().bombsiteBIconPanelHandle));
            EXPECT_CALL(mockTimerPanel, getHandle()).WillOnce(testing::Return(GetParam().timerPanelHandle));

            auto& container = f();
            EXPECT_THAT(container, testing::Ref(mockContainerPanel));

            auto& state = featuresStates.hudFeaturesStates.bombPlantAlertState;
            EXPECT_EQ(state.containerPanelHandle, GetParam().containerPanelHandle);
            EXPECT_EQ(state.bombsiteAIconPanelHandle, GetParam().bombsiteAIconPanelHandle);
            EXPECT_EQ(state.bombsiteBIconPanelHandle, GetParam().bombsiteBIconPanelHandle);
            EXPECT_EQ(state.timerPanelHandle, GetParam().timerPanelHandle);

            return container;
        }
    )));
    EXPECT_EQ(bombPlantAlert.show(mockPlayerPawn), Visibility::Visible);
}

INSTANTIATE_TEST_SUITE_P(, BombPlantAlertPanelCreationTest, testing::ValuesIn(
    std::to_array<BombPlantAlertPanelCreationTestParam>({
        {
            .handlesInitiallyInvalid = true,
            .containerPanelHandle = cs2::PanelHandle{.panelIndex = 123, .serialNumber = 500},
            .bombsiteAIconPanelHandle = cs2::PanelHandle{.panelIndex = 124, .serialNumber = 501},
            .bombsiteBIconPanelHandle = cs2::PanelHandle{.panelIndex = 125, .serialNumber = 502},
            .timerPanelHandle = cs2::PanelHandle{.panelIndex = 126, .serialNumber = 503}
        },
        {
            .handlesInitiallyInvalid = false,
            .containerPanelHandle = cs2::PanelHandle{.panelIndex = 22233344, .serialNumber = 9999990},
            .bombsiteAIconPanelHandle = cs2::PanelHandle{.panelIndex = 22233345, .serialNumber = 9999991},
            .bombsiteBIconPanelHandle = cs2::PanelHandle{.panelIndex = 22233346, .serialNumber = 9999992},
            .timerPanelHandle = cs2::PanelHandle{.panelIndex = 22233347, .serialNumber = 9999993}
        }
    })
));

```

`Tests/UnitTests/Features/Hud/BombPlantAlert/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  BombPlantAlertPanelFactoryTests.cpp
  BombPlantAlertTests.cpp
)

```

`Tests/UnitTests/Features/Hud/BombTimer/BombSiteIconPanelTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <CS2/Constants/IconURLs.h>
#include <Features/Hud/BombTimer/BombSiteIconPanel.h>
#include <Mocks/MockImagePanel.h>

class BombSiteIconPanelTest : public testing::Test {
protected:
    testing::StrictMock<MockImagePanel> mockImagePanel;
    BombSiteIconPanel<MockImagePanel&> bombSiteIconPanel{mockImagePanel};
};

TEST_F(BombSiteIconPanelTest, DoesNotSetImageIfUrlIsNullptr) {
    EXPECT_CALL(mockImagePanel, setImageSvg(testing::_)).Times(0);
    bombSiteIconPanel.setIcon(nullptr);
}

class BombSiteIconPanelTestWithParam : public BombSiteIconPanelTest, public testing::WithParamInterface<const char*> {
};

TEST_P(BombSiteIconPanelTestWithParam, SetsCorrectImageUrl) {
    EXPECT_CALL(mockImagePanel, setImageSvg(GetParam()));
    bombSiteIconPanel.setIcon(GetParam());
}

INSTANTIATE_TEST_SUITE_P(, BombSiteIconPanelTestWithParam,
    testing::Values(cs2::kBombSiteAIconUrl, cs2::kBombSiteBIconUrl));

```

`Tests/UnitTests/Features/Hud/BombTimer/BombTimerConditionTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/BombTimer/BombTimerCondition.h>
#include <Features/Hud/BombTimer/BombTimerState.h>
#include <Mocks/BombTimerMocks/MockBombTimerContext.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockPanel.h>
#include <Utils/Optional.h>

class BombTimerConditionTest : public testing::Test {
protected:
    testing::StrictMock<MockBombTimerContext> mockBombTimerContext;
    testing::StrictMock<MockConfig> mockConfig;
    BombTimerCondition<MockBombTimerContext&> bombTimerCondition{mockBombTimerContext};
};

TEST_F(BombTimerConditionTest, ShouldRunIfEnabled) {
    EXPECT_CALL(mockBombTimerContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<BombTimerEnabled>(true);

    EXPECT_EQ(bombTimerCondition.shouldRun(), true);
}

TEST_F(BombTimerConditionTest, ShouldNotRunIfNotEnabled) {
    EXPECT_CALL(mockBombTimerContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<BombTimerEnabled>(false);

    EXPECT_EQ(bombTimerCondition.shouldRun(), false);
}

struct BombTimerConditionTestParam {
    Optional<bool> bombPlantedPanelVisible{};
    bool hasTickingC4{};
    bool expectedShouldShow{};
};

class BombTimerConditionTestWithParam : public BombTimerConditionTest, public testing::WithParamInterface<BombTimerConditionTestParam> {
protected:
    testing::StrictMock<MockPanel> mockBombPlantedPanel;
};

TEST_P(BombTimerConditionTestWithParam, ShouldShowBombTimer) {
    EXPECT_CALL(mockBombTimerContext, bombPlantedPanel()).Times(testing::AtMost(1)).WillRepeatedly(testing::ReturnRef(mockBombPlantedPanel));

    EXPECT_CALL(mockBombTimerContext, hasTickingC4()).Times(testing::AtMost(1)).WillRepeatedly(testing::Return(GetParam().hasTickingC4));
    EXPECT_CALL(mockBombPlantedPanel, isVisible()).Times(testing::AtMost(1)).WillRepeatedly(testing::Return(GetParam().bombPlantedPanelVisible));

    EXPECT_EQ(bombTimerCondition.shouldShowBombTimer(), GetParam().expectedShouldShow);
}

INSTANTIATE_TEST_SUITE_P(, BombTimerConditionTestWithParam, testing::Values(
    BombTimerConditionTestParam{.bombPlantedPanelVisible = std::nullopt, .hasTickingC4 = true, .expectedShouldShow = true},
    BombTimerConditionTestParam{.bombPlantedPanelVisible = true, .hasTickingC4 = true, .expectedShouldShow = true},
    BombTimerConditionTestParam{.bombPlantedPanelVisible = false, .hasTickingC4 = true, .expectedShouldShow = false},
    BombTimerConditionTestParam{.bombPlantedPanelVisible = std::nullopt, .hasTickingC4 = false, .expectedShouldShow = false},
    BombTimerConditionTestParam{.bombPlantedPanelVisible = true, .hasTickingC4 = false, .expectedShouldShow = false},
    BombTimerConditionTestParam{.bombPlantedPanelVisible = false, .hasTickingC4 = false, .expectedShouldShow = false}
));

```

`Tests/UnitTests/Features/Hud/BombTimer/BombTimerPanelTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <CS2/Constants/IconURLs.h>
#include <Features/Hud/BombTimer/BombTimerPanel.h>
#include <Mocks/BombTimerMocks/MockBombSiteIconPanel.h>
#include <Mocks/BombTimerMocks/MockBombTimerContext.h>
#include <Mocks/BombTimerMocks/MockBombTimerTextPanel.h>
#include <Mocks/MockPanel.h>
#include <Mocks/MockPlantedC4.h>

class BombTimerPanelTest : public testing::Test {
protected:
    testing::StrictMock<MockBombTimerContext> mockBombTimerContext;
    testing::StrictMock<MockPanel> mockBombTimerContainerPanel;
    testing::StrictMock<MockBombSiteIconPanel> mockBombSiteIconPanel;
    testing::StrictMock<MockBombTimerTextPanel> mockBombTimerTextPanel;
    testing::StrictMock<MockPlantedC4> mockPlantedC4;

    BombTimerPanel<MockBombTimerContext&> bombTimerPanel{mockBombTimerContext};
};

TEST_F(BombTimerPanelTest, HidesContainerPanel) {
    EXPECT_CALL(mockBombTimerContext, bombTimerContainerPanel()).WillOnce(testing::ReturnRef(mockBombTimerContainerPanel));
    EXPECT_CALL(mockBombTimerContainerPanel, hide());

    bombTimerPanel.hide();
}

struct BombTimerPanelTestParam {
    Optional<cs2::BombsiteIndex> bombsiteIndex{cs2::BombsiteIndex::BombsiteA};
    const char* expectedBombsiteIconUrl{cs2::kBombSiteAIconUrl};
    float timeToExplosion{12.0f};
};

class BombTimerPanelTestWithParam : public BombTimerPanelTest, public testing::WithParamInterface<BombTimerPanelTestParam> {
};

TEST_P(BombTimerPanelTestWithParam, ShowsContainerPanelAndSetsBombSiteIconAndTimeToExplosion) {
    EXPECT_CALL(mockBombTimerContext, bombTimerContainerPanel()).WillOnce(testing::ReturnRef(mockBombTimerContainerPanel));
    EXPECT_CALL(mockBombTimerContext, tickingC4()).WillOnce(testing::ReturnRef(mockPlantedC4));
    EXPECT_CALL(mockBombTimerContext, bombSiteIconPanel()).WillOnce(testing::ReturnRef(mockBombSiteIconPanel));
    EXPECT_CALL(mockBombTimerContext, bombTimerTextPanel()).WillOnce(testing::ReturnRef(mockBombTimerTextPanel));

    EXPECT_CALL(mockBombTimerContainerPanel, show());

    EXPECT_CALL(mockPlantedC4, bombsiteIndex()).WillOnce(testing::Return(GetParam().bombsiteIndex));
    EXPECT_CALL(mockBombSiteIconPanel, setIcon(GetParam().expectedBombsiteIconUrl));

    EXPECT_CALL(mockPlantedC4, getTimeToExplosion()).WillOnce(testing::Return(GetParam().timeToExplosion));
    EXPECT_CALL(mockBombTimerTextPanel, setTimeToExplosion(GetParam().timeToExplosion));

    bombTimerPanel.showAndUpdate();
}

INSTANTIATE_TEST_SUITE_P(, BombTimerPanelTestWithParam, testing::Values(
    BombTimerPanelTestParam{.bombsiteIndex{cs2::BombsiteIndex::BombsiteA}, .expectedBombsiteIconUrl = cs2::kBombSiteAIconUrl},
    BombTimerPanelTestParam{.bombsiteIndex{cs2::BombsiteIndex::BombsiteB}, .expectedBombsiteIconUrl = cs2::kBombSiteBIconUrl},
    BombTimerPanelTestParam{.bombsiteIndex{std::nullopt}, .expectedBombsiteIconUrl = nullptr},

    BombTimerPanelTestParam{.timeToExplosion = 40.0f},
    BombTimerPanelTestParam{.timeToExplosion = 15.234f}
));

```

`Tests/UnitTests/Features/Hud/BombTimer/BombTimerTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/BombTimer/BombTimer.h>
#include <Mocks/BombTimerMocks/MockBombTimerCondition.h>
#include <Mocks/BombTimerMocks/MockBombTimerContext.h>
#include <Mocks/BombTimerMocks/MockBombTimerPanel.h>
#include <Mocks/MockHookContext.h>

class BombTimerTest : public testing::Test {
protected:
    void shouldRun(bool b)
    {
        EXPECT_CALL(mockBombTimerCondition, shouldRun()).WillOnce(testing::Return(b));
    }

    void shouldShowBombTimer(bool b)
    {
        EXPECT_CALL(mockBombTimerCondition, shouldShowBombTimer()).WillOnce(testing::Return(b));
    }

    testing::StrictMock<MockBombTimerContext> mockBombTimerContext;
    testing::StrictMock<MockBombTimerCondition> mockBombTimerCondition;
    testing::StrictMock<MockBombTimerPanel> mockBombTimerPanel;

    BombTimer<MockHookContext, MockBombTimerContext&> bombTimer{mockBombTimerContext};
};

TEST_F(BombTimerTest, DoesNotRunIfShouldNotRun) {
    shouldRun(false);

    EXPECT_CALL(mockBombTimerContext, bombTimerCondition()).WillOnce(testing::ReturnRef(mockBombTimerCondition));
    EXPECT_CALL(mockBombTimerCondition, shouldShowBombTimer()).Times(0);
    EXPECT_CALL(mockBombTimerContext, bombTimerPanel()).Times(0);

    EXPECT_EQ(bombTimer.update(), Visibility::Hidden);
}

TEST_F(BombTimerTest, ShowsTimerWhenBombTimerShouldBeShown) {
    shouldRun(true);
    shouldShowBombTimer(true);

    EXPECT_CALL(mockBombTimerContext, bombTimerCondition()).WillOnce(testing::ReturnRef(mockBombTimerCondition));
    EXPECT_CALL(mockBombTimerContext, bombTimerPanel()).WillOnce(testing::ReturnRef(mockBombTimerPanel));
    EXPECT_CALL(mockBombTimerPanel, showAndUpdate());
    
    EXPECT_EQ(bombTimer.update(), Visibility::Visible);
}

TEST_F(BombTimerTest, HidesTimerWhenBombTimerShouldNotBeShown) {
    shouldRun(true);
    shouldShowBombTimer(false);

    EXPECT_CALL(mockBombTimerContext, bombTimerCondition()).WillOnce(testing::ReturnRef(mockBombTimerCondition));
    EXPECT_CALL(mockBombTimerContext, bombTimerPanel()).WillOnce(testing::ReturnRef(mockBombTimerPanel));
    EXPECT_CALL(mockBombTimerPanel, hide());
    
    EXPECT_EQ(bombTimer.update(), Visibility::Hidden);
}

TEST_F(BombTimerTest, ForceHidesPanelIfShouldRun) {
    shouldRun(true);

    EXPECT_CALL(mockBombTimerContext, bombTimerCondition()).WillOnce(testing::ReturnRef(mockBombTimerCondition));
    EXPECT_CALL(mockBombTimerContext, bombTimerPanel()).WillOnce(testing::ReturnRef(mockBombTimerPanel));
    EXPECT_CALL(mockBombTimerPanel, hide());
    
    bombTimer.forceHide();
}

TEST_F(BombTimerTest, DoesNotForceHidePanelIfShouldNotRun) {
    shouldRun(false);
    EXPECT_CALL(mockBombTimerContext, bombTimerCondition()).WillOnce(testing::ReturnRef(mockBombTimerCondition));
    bombTimer.forceHide();
}

TEST_F(BombTimerTest, OnDisableHidesBombTimerPanel) {
    EXPECT_CALL(mockBombTimerContext, bombTimerPanel()).WillOnce(testing::ReturnRef(mockBombTimerPanel));
    EXPECT_CALL(mockBombTimerPanel, hide());
    bombTimer.onDisable();
}

```

`Tests/UnitTests/Features/Hud/BombTimer/BombTimerTextPanelTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/BombTimer/BombTimerTextPanel.h>
#include <Mocks/MockLabelPanel.h>

struct BombTimerTextPanelTestParam {
    float timeToExplosion;
    const char* expectedString;
};

class BombTimerTextPanelTest : public testing::TestWithParam<BombTimerTextPanelTestParam> {
protected:
    testing::StrictMock<MockLabelPanel> mockLabelPanel;
    BombTimerTextPanel<MockLabelPanel&> bombTimerTextPanel{mockLabelPanel};
};

TEST_P(BombTimerTextPanelTest, TimeToExplosionIsCorrectlySetOnPanel) {
    EXPECT_CALL(mockLabelPanel, setText(testing::StrEq(GetParam().expectedString)));
    bombTimerTextPanel.setTimeToExplosion(GetParam().timeToExplosion);
}

INSTANTIATE_TEST_SUITE_P(, BombTimerTextPanelTest, testing::Values(
    BombTimerTextPanelTestParam{.timeToExplosion = 999.9f, .expectedString = "999.9"},
    BombTimerTextPanelTestParam{.timeToExplosion = 40.0f, .expectedString = "40.0"},
    BombTimerTextPanelTestParam{.timeToExplosion = 11.0f, .expectedString = "11.0"},
    BombTimerTextPanelTestParam{.timeToExplosion = 10.9999f, .expectedString = "10.9"},
    BombTimerTextPanelTestParam{.timeToExplosion = 0.2f, .expectedString = "0.2"},
    BombTimerTextPanelTestParam{.timeToExplosion = 0.19999f, .expectedString = "0.1"},
    BombTimerTextPanelTestParam{.timeToExplosion = 0.0f, .expectedString = "0.0"}
));

```

`Tests/UnitTests/Features/Hud/BombTimer/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  BombSiteIconPanelTests.cpp
  BombTimerConditionTests.cpp
  BombTimerPanelTests.cpp
  BombTimerTests.cpp
  BombTimerTextPanelTests.cpp
)

```

`Tests/UnitTests/Features/Hud/CMakeLists.txt`:

```txt
add_subdirectory(BombPlantAlert)
add_subdirectory(BombTimer)
add_subdirectory(DefusingAlert)
add_subdirectory(KillfeedPreserver)
add_subdirectory(PostRoundTimer)

```

`Tests/UnitTests/Features/Hud/DefusingAlert/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  DefusingAlertConditionTests.cpp
  DefusingAlertPanelTests.cpp
  DefusingAlertTests.cpp
  DefusingCountdownTextPanelTests.cpp
)

```

`Tests/UnitTests/Features/Hud/DefusingAlert/DefusingAlertConditionTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/DefusingAlert/DefusingAlertCondition.h>
#include <Features/Hud/DefusingAlert/DefusingAlertState.h>
#include <Mocks/DefusingAlertMocks/MockDefusingAlertContext.h>
#include <Mocks/MockConfig.h>

class DefusingAlertConditionTest : public testing::Test {
protected:
    void hasC4BeingDefused(bool b)
    {
        EXPECT_CALL(mockDefusingAlertContext, hasC4BeingDefused()).WillOnce(testing::Return(b));
    }

    testing::StrictMock<MockDefusingAlertContext> mockDefusingAlertContext;
    testing::StrictMock<MockConfig> mockConfig;
    DefusingAlertCondition<MockDefusingAlertContext&> defusingAlertCondition{mockDefusingAlertContext};
};

TEST_F(DefusingAlertConditionTest, ShouldRunIfEnabled) {
    EXPECT_CALL(mockDefusingAlertContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<DefusingAlertEnabled>(true);

    EXPECT_EQ(defusingAlertCondition.shouldRun(), true);
}

TEST_F(DefusingAlertConditionTest, ShouldNotRunIfNotEnabled) {
    EXPECT_CALL(mockDefusingAlertContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<DefusingAlertEnabled>(false);

    EXPECT_EQ(defusingAlertCondition.shouldRun(), false);
}

TEST_F(DefusingAlertConditionTest, ShouldShowDefusingAlertIfHasC4BeingDefused) {
    hasC4BeingDefused(true);
    EXPECT_EQ(defusingAlertCondition.shouldShowDefuseAlert(), true);
}

TEST_F(DefusingAlertConditionTest, ShouldNotShowDefusingAlertIfDoesNotHaveC4BeingDefused) {
    hasC4BeingDefused(false);
    EXPECT_EQ(defusingAlertCondition.shouldShowDefuseAlert(), false);
}

```

`Tests/UnitTests/Features/Hud/DefusingAlert/DefusingAlertPanelTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/DefusingAlert/DefusingAlertPanel.h>
#include <Mocks/DefusingAlertMocks/MockDefusingAlertContext.h>
#include <Mocks/DefusingAlertMocks/MockDefusingCountdownTextPanel.h>
#include <Mocks/MockPanel.h>
#include <Mocks/MockPlantedC4.h>
#include <Utils/Optional.h>

class DefusingAlertPanelTest : public testing::Test {
protected:
    testing::StrictMock<MockDefusingAlertContext> mockDefusingAlertContext;
    testing::StrictMock<MockPanel> mockDefusingAlertContainerPanel;
    testing::StrictMock<MockDefusingCountdownTextPanel> mockDefusingCountdownTextPanel;
    testing::StrictMock<MockPlantedC4> mockPlantedC4;

    DefusingAlertPanel<MockDefusingAlertContext&> defusingAlertPanel{mockDefusingAlertContext};
};

TEST_F(DefusingAlertPanelTest, HidesDefusingAlertContainerPanel) {
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertContainerPanel()).WillOnce(testing::ReturnRef(mockDefusingAlertContainerPanel));
    EXPECT_CALL(mockDefusingAlertContainerPanel, hide());

    defusingAlertPanel.hide();
}

struct DefusingAlertPanelTestParam {
    Optional<float> timeToDefuseEnd{3.34f};
    Optional<bool> canBeDefused{true};
};

class DefusingAlertPanelTestWithParam : public DefusingAlertPanelTest, public testing::WithParamInterface<DefusingAlertPanelTestParam> {
};

TEST_P(DefusingAlertPanelTestWithParam, ShowsDefusingAlertContainerPanelAndUpdatesCountdownTextPanel) {
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertContainerPanel()).WillOnce(testing::ReturnRef(mockDefusingAlertContainerPanel));
    EXPECT_CALL(mockDefusingAlertContainerPanel, show());
    
    EXPECT_CALL(mockDefusingAlertContext, defusingCountdownTextPanel()).WillOnce(testing::ReturnRef(mockDefusingCountdownTextPanel));
    EXPECT_CALL(mockDefusingCountdownTextPanel, setTimeToDefuseEnd(GetParam().timeToDefuseEnd)).WillOnce(testing::ReturnRef(mockDefusingCountdownTextPanel));
    EXPECT_CALL(mockDefusingCountdownTextPanel, setCanBeDefused(GetParam().canBeDefused)).WillOnce(testing::ReturnRef(mockDefusingCountdownTextPanel));

    EXPECT_CALL(mockDefusingAlertContext, c4BeingDefused()).WillOnce(testing::ReturnRef(mockPlantedC4));
    EXPECT_CALL(mockPlantedC4, getTimeToDefuseEnd()).WillOnce(testing::Return(GetParam().timeToDefuseEnd));
    EXPECT_CALL(mockPlantedC4, canBeDefused()).WillOnce(testing::Return(GetParam().canBeDefused));

    defusingAlertPanel.showAndUpdate();
}

INSTANTIATE_TEST_SUITE_P(, DefusingAlertPanelTestWithParam, testing::Values(
    DefusingAlertPanelTestParam{.timeToDefuseEnd = 0.0f},
    DefusingAlertPanelTestParam{.timeToDefuseEnd = 3.45f},
    DefusingAlertPanelTestParam{.timeToDefuseEnd = 10.0f},
    DefusingAlertPanelTestParam{.timeToDefuseEnd = std::nullopt},
    DefusingAlertPanelTestParam{.canBeDefused = false},
    DefusingAlertPanelTestParam{.canBeDefused = true},
    DefusingAlertPanelTestParam{.canBeDefused = std::nullopt},
    DefusingAlertPanelTestParam{.timeToDefuseEnd = std::nullopt, .canBeDefused = std::nullopt}
));

```

`Tests/UnitTests/Features/Hud/DefusingAlert/DefusingAlertTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/DefusingAlert/DefusingAlert.h>
#include <Mocks/DefusingAlertMocks/MockDefusingAlertCondition.h>
#include <Mocks/DefusingAlertMocks/MockDefusingAlertContext.h>
#include <Mocks/DefusingAlertMocks/MockDefusingAlertPanel.h>
#include <Mocks/MockHookContext.h>

class DefusingAlertTest : public testing::Test {
protected:
    void shouldRun(bool b)
    {
        EXPECT_CALL(mockDefusingAlertCondition, shouldRun()).WillOnce(testing::Return(b));
    }

    void shouldShowDefuseAlert(bool b)
    {
        EXPECT_CALL(mockDefusingAlertCondition, shouldShowDefuseAlert()).WillOnce(testing::Return(b));
    }

    testing::StrictMock<MockDefusingAlertContext> mockDefusingAlertContext;
    testing::StrictMock<MockDefusingAlertCondition> mockDefusingAlertCondition;
    testing::StrictMock<MockDefusingAlertPanel> mockDefusingAlertPanel;

    DefusingAlert<MockHookContext, MockDefusingAlertContext&> defusingAlert{mockDefusingAlertContext};
};

TEST_F(DefusingAlertTest, DoesNotRunIfShouldNotRun) {
    shouldRun(false);
    
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertCondition()).WillOnce(testing::ReturnRef(mockDefusingAlertCondition));
    EXPECT_CALL(mockDefusingAlertCondition, shouldShowDefuseAlert()).Times(0);
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertPanel()).Times(0);

    defusingAlert.run();
}

TEST_F(DefusingAlertTest, ShowsAndUpdatesDefusingAlertPanelWhenDefusingAlertShouldBeShown) {
    shouldRun(true);
    shouldShowDefuseAlert(true);

    EXPECT_CALL(mockDefusingAlertContext, defusingAlertCondition()).WillOnce(testing::ReturnRef(mockDefusingAlertCondition));
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertPanel()).WillOnce(testing::ReturnRef(mockDefusingAlertPanel));
    EXPECT_CALL(mockDefusingAlertPanel, showAndUpdate());

    defusingAlert.run();
}

TEST_F(DefusingAlertTest, HidesDefusingAlertPanelWhenDefusingAlertShouldNotBeShown) {
    shouldRun(true);
    shouldShowDefuseAlert(false);

    EXPECT_CALL(mockDefusingAlertContext, defusingAlertCondition()).WillOnce(testing::ReturnRef(mockDefusingAlertCondition));
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertPanel()).WillOnce(testing::ReturnRef(mockDefusingAlertPanel));
    EXPECT_CALL(mockDefusingAlertPanel, hide());

    defusingAlert.run();
}

TEST_F(DefusingAlertTest, OnDisableHidesDefusingAlertPanel) {
    EXPECT_CALL(mockDefusingAlertContext, defusingAlertPanel()).WillOnce(testing::ReturnRef(mockDefusingAlertPanel));
    EXPECT_CALL(mockDefusingAlertPanel, hide());

    defusingAlert.onDisable();
}

```

`Tests/UnitTests/Features/Hud/DefusingAlert/DefusingCountdownTextPanelTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <CS2/Classes/Color.h>
#include <CS2/Constants/ColorConstants.h>
#include <Features/Hud/DefusingAlert/DefusingCountdownTextPanel.h>
#include <Mocks/MockLabelPanel.h>
#include <Mocks/MockPanel.h>
#include <Utils/Optional.h>

class DefusingCountdownTextPanelTest : public testing::Test {
protected:
    testing::StrictMock<MockLabelPanel> mockLabelPanel;
    testing::StrictMock<MockPanel> mockUiPanel;
    DefusingCountdownTextPanel<MockLabelPanel&> defusingCountdownTextPanel{mockLabelPanel};
};

struct DefusingCountdownTextPanelTestTimeToDefuseEndParam {
    float timeToDefuseEnd{};
    const char* expectedString{};
};

class DefusingCountdownTextPanelTestWithTimeToDefuseEndParam : public DefusingCountdownTextPanelTest, public testing::WithParamInterface<DefusingCountdownTextPanelTestTimeToDefuseEndParam> {
};

TEST_P(DefusingCountdownTextPanelTestWithTimeToDefuseEndParam, TimeToDefuseEndIsCorrectlySet) {
    EXPECT_CALL(mockLabelPanel, setText(testing::StrEq(GetParam().expectedString)));
    EXPECT_THAT(defusingCountdownTextPanel.setTimeToDefuseEnd(GetParam().timeToDefuseEnd), testing::Ref(defusingCountdownTextPanel));
}

INSTANTIATE_TEST_SUITE_P(, DefusingCountdownTextPanelTestWithTimeToDefuseEndParam, testing::Values(
    DefusingCountdownTextPanelTestTimeToDefuseEndParam{.timeToDefuseEnd = 0.0f, .expectedString = "0.0"},
    DefusingCountdownTextPanelTestTimeToDefuseEndParam{.timeToDefuseEnd = 0.1999f, .expectedString = "0.1"},
    DefusingCountdownTextPanelTestTimeToDefuseEndParam{.timeToDefuseEnd = 2.9999f, .expectedString = "2.9"},
    DefusingCountdownTextPanelTestTimeToDefuseEndParam{.timeToDefuseEnd = 10.0f, .expectedString = "10.0"}
));

struct DefusingCountdownTextPanelTestCanBeDefusedParam {
    Optional<bool> canBeDefused{};
    cs2::Color expectedColor{cs2::kColorBlack};
};

class DefusingCountdownTextPanelTestWithCanBeDefusedParam : public DefusingCountdownTextPanelTest, public testing::WithParamInterface<DefusingCountdownTextPanelTestCanBeDefusedParam> {
};

TEST_P(DefusingCountdownTextPanelTestWithCanBeDefusedParam, PanelColorIsSetDependingOnWhetherDefuseCanSucceed) {
    EXPECT_CALL(mockLabelPanel, uiPanel()).WillOnce(testing::ReturnRef(mockUiPanel));
    EXPECT_CALL(mockUiPanel, setColor(GetParam().expectedColor));
    EXPECT_THAT(defusingCountdownTextPanel.setCanBeDefused(GetParam().canBeDefused), testing::Ref(defusingCountdownTextPanel));
}

INSTANTIATE_TEST_SUITE_P(, DefusingCountdownTextPanelTestWithCanBeDefusedParam, testing::Values(
    DefusingCountdownTextPanelTestCanBeDefusedParam{.canBeDefused{std::nullopt}, .expectedColor{cs2::kColorWhite}},
    DefusingCountdownTextPanelTestCanBeDefusedParam{.canBeDefused{true}, .expectedColor{cs2::kColorGreen}},
    DefusingCountdownTextPanelTestCanBeDefusedParam{.canBeDefused{false}, .expectedColor{cs2::kColorRed}}
));

```

`Tests/UnitTests/Features/Hud/KillfeedPreserver/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  KillfeedPreserverContextTests.cpp
  KillfeedPreserverTests.cpp
)

```

`Tests/UnitTests/Features/Hud/KillfeedPreserver/KillfeedPreserverContextTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/KillfeedPreserver/KillfeedPreserverContext.h>
#include <Mocks/HudMocks/MockDeathNotice.h>
#include <Mocks/HudMocks/MockDeathNotices.h>
#include <Mocks/HudMocks/MockHud.h>
#include <Mocks/MockHookContext.h>

class KillfeedPreserverContextTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockHud> mockHud;
    testing::StrictMock<MockDeathNotices> mockDeathNotices;

    KillfeedPreserverContext<MockHookContext&> killfeedPreserverContext{mockHookContext};
};

TEST_F(KillfeedPreserverContextTest, DeathNoticesCanBeAccessed) {
    EXPECT_CALL(mockHookContext, hud()).WillOnce(testing::ReturnRef(mockHud));
    EXPECT_CALL(mockHud, deathNotices()).WillOnce(testing::ReturnRef(mockDeathNotices));

    EXPECT_THAT(killfeedPreserverContext.deathNotices(), testing::Ref(mockDeathNotices));
}

struct KillfeedPreserverContextDeathNoticeTestParam {
    bool isLocalPlayerKiller{false};
    bool wasSpawnedThisRound{false};
    bool expectMarkAsJustSpawned{false};
};

class KillfeedPreserverContextDeathNoticeTest : public KillfeedPreserverContextTest, public testing::WithParamInterface<KillfeedPreserverContextDeathNoticeTestParam> {
protected:
    testing::StrictMock<MockDeathNotice> mockDeathNotice;
};

TEST_P(KillfeedPreserverContextDeathNoticeTest, CorrectlyMarksDeathNoticesAsJustSpawned) {
    EXPECT_CALL(mockDeathNotice, isLocalPlayerKiller()).Times(testing::AtMost(1)).WillOnce(testing::Return(GetParam().isLocalPlayerKiller));
    EXPECT_CALL(mockDeathNotice, wasSpawnedThisRound()).Times(testing::AtMost(1)).WillOnce(testing::Return(GetParam().wasSpawnedThisRound));
    EXPECT_CALL(mockDeathNotice, markAsJustSpawned()).Times(GetParam().expectMarkAsJustSpawned ? 1 : 0);

    killfeedPreserverContext.preserveDeathNotice()(mockDeathNotice);
}

INSTANTIATE_TEST_SUITE_P(, KillfeedPreserverContextDeathNoticeTest, testing::Values(
    KillfeedPreserverContextDeathNoticeTestParam{.isLocalPlayerKiller = true, .wasSpawnedThisRound = true, .expectMarkAsJustSpawned = true},
    KillfeedPreserverContextDeathNoticeTestParam{.isLocalPlayerKiller = true, .wasSpawnedThisRound = false, .expectMarkAsJustSpawned = false},
    KillfeedPreserverContextDeathNoticeTestParam{.isLocalPlayerKiller = false, .wasSpawnedThisRound = true, .expectMarkAsJustSpawned = false},
    KillfeedPreserverContextDeathNoticeTestParam{.isLocalPlayerKiller = false, .wasSpawnedThisRound = false, .expectMarkAsJustSpawned = false}
));

```

`Tests/UnitTests/Features/Hud/KillfeedPreserver/KillfeedPreserverTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/KillfeedPreserver/KillfeedPreserver.h>
#include <Mocks/KillfeedPreserverMocks/MockKillfeedPreserverContext.h>
#include <Mocks/HudMocks/MockDeathNotices.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

class KillfeedPreserverTest : public testing::Test {
protected:
    testing::StrictMock<MockKillfeedPreserverContext> mockContext;
    testing::StrictMock<MockDeathNotices> mockDeathNotices;
    testing::StrictMock<MockConfig> mockConfig;

    KillfeedPreserver<MockHookContext, MockKillfeedPreserverContext&> killfeedPreserver{mockContext};
    std::function<void(MockDeathNotice&)> preserveDeathNoticeFunctor;
};

TEST_F(KillfeedPreserverTest, DoesNotRunWhenNotEnabled) {
    EXPECT_CALL(mockContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<KillfeedPreserverEnabled>(false);
    EXPECT_CALL(mockContext, deathNotices()).Times(0);
    killfeedPreserver.run();
}

TEST_F(KillfeedPreserverTest, PreservesDeathNoticesWhenEnabled) {
    EXPECT_CALL(mockContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<KillfeedPreserverEnabled>(true);
    EXPECT_CALL(mockContext, deathNotices()).WillOnce(testing::ReturnRef(mockDeathNotices));

    EXPECT_CALL(mockContext, preserveDeathNotice()).WillOnce(testing::ReturnRef(preserveDeathNoticeFunctor));
    EXPECT_CALL(mockDeathNotices, forEach(testing::Ref(preserveDeathNoticeFunctor)));

    killfeedPreserver.run();
}

```

`Tests/UnitTests/Features/Hud/PostRoundTimer/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  PostRoundTimerConditionTests.cpp
  PostRoundTimerContextTests.cpp
  PostRoundTimerPanelFactoryTests.cpp
  PostRoundTimerTests.cpp
)

```

`Tests/UnitTests/Features/Hud/PostRoundTimer/PostRoundTimerConditionTests.cpp`:

```cpp
#include <array>

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/PostRoundTimer/PostRoundTimerCondition.h>
#include <Features/Hud/PostRoundTimer/PostRoundTimerState.h>

#include <Mocks/MockConfig.h>
#include <Mocks/MockGameRules.h>
#include <Mocks/PostRoundTimer/MockPostRoundTimerContext.h>

class PostRoundTimerConditionTest : public testing::Test {
protected:
    testing::StrictMock<MockPostRoundTimerContext> mockContext;
    PostRoundTimerCondition<MockPostRoundTimerContext&> postRoundTimerCondition{mockContext};
};

class PostRoundTimerConditionShouldRunTest : public PostRoundTimerConditionTest {
protected:
    testing::StrictMock<MockConfig> mockConfig;
};

TEST_F(PostRoundTimerConditionShouldRunTest, ShouldRunIfEnabled) {
    EXPECT_CALL(mockContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<PostRoundTimerEnabled>(true);
    EXPECT_TRUE(postRoundTimerCondition.shouldRun());
}

TEST_F(PostRoundTimerConditionShouldRunTest, ShouldNotRunIfNotEnabled) {
    EXPECT_CALL(mockContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<PostRoundTimerEnabled>(false);
    EXPECT_FALSE(postRoundTimerCondition.shouldRun());
}

struct PostRoundTimerConditionShouldShowTestParam {
    bool hasScheduledRoundRestart{};
    bool isGameRoundTimeVisible{};
    bool expectedShouldShow{};
};

class PostRoundTimerConditionShouldShowTest : public PostRoundTimerConditionTest, public testing::WithParamInterface<PostRoundTimerConditionShouldShowTestParam> {
protected:
    testing::StrictMock<MockGameRules> mockGameRules;
};

TEST_P(PostRoundTimerConditionShouldShowTest, ShouldShowPostRoundTimer) {
    EXPECT_CALL(mockContext, isGameRoundTimeVisible()).Times(testing::AtMost(1)).WillRepeatedly(testing::Return(GetParam().isGameRoundTimeVisible));
    EXPECT_CALL(mockContext, gameRules()).Times(testing::AtMost(1)).WillRepeatedly(testing::ReturnRef(mockGameRules));
    EXPECT_CALL(mockGameRules, hasScheduledRoundRestart()).Times(testing::AtMost(1)).WillRepeatedly(testing::Return(GetParam().hasScheduledRoundRestart));

    EXPECT_EQ(postRoundTimerCondition.shouldShowPostRoundTimer(), GetParam().expectedShouldShow);
}

INSTANTIATE_TEST_SUITE_P(, PostRoundTimerConditionShouldShowTest, testing::ValuesIn(
    std::to_array<PostRoundTimerConditionShouldShowTestParam>({
        {.hasScheduledRoundRestart = false, .isGameRoundTimeVisible = false, .expectedShouldShow = false},
        {.hasScheduledRoundRestart = false, .isGameRoundTimeVisible = true, .expectedShouldShow = false},
        {.hasScheduledRoundRestart = true, .isGameRoundTimeVisible = false, .expectedShouldShow = true},
        {.hasScheduledRoundRestart = true, .isGameRoundTimeVisible = true, .expectedShouldShow = false}
    })
));

```

`Tests/UnitTests/Features/Hud/PostRoundTimer/PostRoundTimerContextTests.cpp`:

```cpp
#include <array>

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/PostRoundTimer/PostRoundTimerContext.h>

#include <Mocks/HudMocks/MockHud.h>
#include <Mocks/MockGameRules.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPanel.h>
#include <Utils/Optional.h>

class PostRoundTimerContextTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    PostRoundTimerContext<MockHookContext&> postRoundTimerContext{mockHookContext};
};

TEST_F(PostRoundTimerContextTest, ReturnsGameRulesFromHookContext) {
    testing::StrictMock<MockGameRules> mockGameRules;
    EXPECT_CALL(mockHookContext, gameRules()).WillOnce(testing::ReturnRef(mockGameRules));

    EXPECT_THAT(postRoundTimerContext.gameRules(), testing::Ref(mockGameRules));
}

struct PostRoundTimerContextGameRoundTimeVisibleTestParam {
    Optional<bool> isVisible{};
    bool expectedIsVisible{};
};

class PostRoundTimerContextGameRoundTimeVisibleTest : public PostRoundTimerContextTest, public testing::WithParamInterface<PostRoundTimerContextGameRoundTimeVisibleTestParam> {
};

TEST_P(PostRoundTimerContextGameRoundTimeVisibleTest, IsGameRoundTimeVisible) {
    testing::StrictMock<MockHud> mockHud;
    testing::StrictMock<MockPanel> mockGameRoundTimePanel;
    
    EXPECT_CALL(mockHookContext, hud()).WillOnce(testing::ReturnRef(mockHud));
    EXPECT_CALL(mockHud, timerTextPanel()).WillOnce(testing::ReturnRef(mockGameRoundTimePanel));
    EXPECT_CALL(mockGameRoundTimePanel, isVisible()).WillOnce(testing::Return(GetParam().isVisible));

    EXPECT_EQ(postRoundTimerContext.isGameRoundTimeVisible(), GetParam().expectedIsVisible);
}

INSTANTIATE_TEST_SUITE_P(, PostRoundTimerContextGameRoundTimeVisibleTest, testing::ValuesIn(
    std::to_array<PostRoundTimerContextGameRoundTimeVisibleTestParam>({
        {.isVisible = std::nullopt, .expectedIsVisible = false},
        {.isVisible = false, .expectedIsVisible = false},
        {.isVisible = true, .expectedIsVisible = true}
    })
));

```

`Tests/UnitTests/Features/Hud/PostRoundTimer/PostRoundTimerPanelFactoryTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Hud/PostRoundTimer/PostRoundTimerPanelFactory.h>

#include <Mocks/MockClientPanel.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPanel.h>
#include <Mocks/MockPanelFactory.h>

class PostRoundTimerPanelFactoryTest : public testing::Test {
protected:
    PostRoundTimerPanelFactoryTest()
    {
        EXPECT_CALL(mockHookContext, panelFactory()).WillOnce(testing::ReturnRef(mockPanelFactory));
        EXPECT_CALL(mockClientPanel, uiPanel()).WillOnce(testing::ReturnRef(mockUiPanel));
    }

    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockPanelFactory> mockPanelFactory;
    testing::StrictMock<MockClientPanel> mockClientPanel;
    testing::StrictMock<MockPanel> mockParentPanel;
    testing::StrictMock<MockPanel> mockUiPanel;

    PostRoundTimerPanelFactory<MockHookContext&> postRoundTimerPanelFactory{mockHookContext};
};

TEST_F(PostRoundTimerPanelFactoryTest, ContainerPanelIsCorrectlyCreatedAndStyled) {
    EXPECT_CALL(mockPanelFactory, createPanel(testing::Ref(mockParentPanel))).WillOnce(testing::ReturnRef(mockClientPanel));
    
    using namespace post_round_timer_panel_params::container_panel_params;
    EXPECT_CALL(mockUiPanel, setWidth(kWidth));
    EXPECT_CALL(mockUiPanel, setHeight(kHeight));

    EXPECT_THAT(postRoundTimerPanelFactory.createCountdownContainerPanel(mockParentPanel), testing::Ref(mockUiPanel));
}

TEST_F(PostRoundTimerPanelFactoryTest, TextPanelIsCorrectlyCreatedAndStyled) {
    EXPECT_CALL(mockPanelFactory, createLabelPanel(testing::Ref(mockParentPanel))).WillOnce(testing::ReturnRef(mockClientPanel));

    using namespace post_round_timer_panel_params::text_panel_params;
    EXPECT_CALL(mockUiPanel, setWidth(kWidth));
    EXPECT_CALL(mockUiPanel, setMixBlendMode(kMixBlendMode));
    EXPECT_CALL(mockUiPanel, setFont(testing::Ref(kFont)));
    EXPECT_CALL(mockUiPanel, setTextAlign(kTextAlign));

    EXPECT_THAT(postRoundTimerPanelFactory.createCountdownTextPanel(mockParentPanel), testing::Ref(mockUiPanel));
}

```

`Tests/UnitTests/Features/Hud/PostRoundTimer/PostRoundTimerTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Common/Visibility.h>
#include <Features/Hud/PostRoundTimer/PostRoundTimer.h>

#include <Mocks/MockHookContext.h>
#include <Mocks/PostRoundTimer/MockPostRoundTimerCondition.h>
#include <Mocks/PostRoundTimer/MockPostRoundTimerContext.h>
#include <Mocks/PostRoundTimer/MockPostRoundTimerPanel.h>

class PostRoundTimerTest : public testing::Test {
protected:
    PostRoundTimerTest()
    {
        EXPECT_CALL(mockContext, condition()).WillOnce(testing::ReturnRef(mockCondition));
    }

    void shouldRun(bool b)
    {
        EXPECT_CALL(mockCondition, shouldRun()).WillOnce(testing::Return(b));
    }

    void shouldShowPostRoundTimer(bool b)
    {
        EXPECT_CALL(mockCondition, shouldShowPostRoundTimer()).WillOnce(testing::Return(b));
    }

    testing::StrictMock<MockPostRoundTimerContext> mockContext;
    testing::StrictMock<MockPostRoundTimerCondition> mockCondition;
    testing::StrictMock<MockPostRoundTimerPanel> mockPostRoundTimerPanel;

    PostRoundTimer<MockHookContext, MockPostRoundTimerContext&> postRoundTimer{mockContext};
};

TEST_F(PostRoundTimerTest, IsHiddenIfShouldNotRun) {
    shouldRun(false);
    EXPECT_EQ(postRoundTimer.update(), Visibility::Hidden);
}

TEST_F(PostRoundTimerTest, IsVisibleIfShouldRunAndShouldShowPostRoundTimer) {
    shouldRun(true);
    shouldShowPostRoundTimer(true);
    EXPECT_CALL(mockContext, postRoundTimerPanel()).WillOnce(testing::ReturnRef(mockPostRoundTimerPanel));
    EXPECT_CALL(mockPostRoundTimerPanel, showAndUpdate());

    EXPECT_EQ(postRoundTimer.update(), Visibility::Visible);
}

TEST_F(PostRoundTimerTest, IsHiddenIfShouldRunButShouldNotShowPostRoundTimer) {
    shouldRun(true);
    shouldShowPostRoundTimer(false);
    EXPECT_CALL(mockContext, postRoundTimerPanel()).WillOnce(testing::ReturnRef(mockPostRoundTimerPanel));
    EXPECT_CALL(mockPostRoundTimerPanel, hide());

    EXPECT_EQ(postRoundTimer.update(), Visibility::Hidden);
}

```

`Tests/UnitTests/Features/Visuals/CMakeLists.txt`:

```txt
add_subdirectory(ModelGlow)
add_subdirectory(OutlineGlow)
add_subdirectory(ViewmodelMod)

```

`Tests/UnitTests/Features/Visuals/ModelGlow/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  DefuseKitModelGlowTests.cpp
  DroppedBombModelGlowTests.cpp
  GrenadeProjectileModelGlowTests.cpp
  ModelGlowTests.cpp
  PlayerModelGlowTests.cpp
  TickingBombModelGlowTests.cpp
  WeaponModelGlowTests.cpp
)

```

`Tests/UnitTests/Features/Visuals/ModelGlow/DefuseKitModelGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/DefuseKitModelGlow/DefuseKitModelGlow.h>
#include <Features/FeaturesStates.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

class DefuseKitModelGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockConfig> mockConfig{};
    testing::StrictMock<MockHookContext> mockHookContext{};
    FeaturesStates featuresStates{};
    DefuseKitModelGlow<MockHookContext> defuseKitModelGlow{mockHookContext};
};

TEST_F(DefuseKitModelGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowDefuseKits>(false);
    EXPECT_FALSE(defuseKitModelGlow.enabled());
}

TEST_F(DefuseKitModelGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowDefuseKits>(true);
    EXPECT_TRUE(defuseKitModelGlow.enabled());
}

TEST_F(DefuseKitModelGlowTest, CorrectDeactivationFlagIsReturned) {
    EXPECT_EQ(defuseKitModelGlow.deactivationFlag(), ModelGlowDeactivationFlags::DefuseKitModelGlowDeactivating);
}

class DefuseKitModelGlowHueTest
    : public DefuseKitModelGlowTest,
      public testing::WithParamInterface<color::HueInteger> {
};

TEST_P(DefuseKitModelGlowHueTest, CorrectHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::DefuseKitHue>(model_glow_vars::DefuseKitHue::ValueType{GetParam()});
    EXPECT_EQ(defuseKitModelGlow.hue(), GetParam());
}

INSTANTIATE_TEST_SUITE_P(, DefuseKitModelGlowHueTest, testing::Values(
    model_glow_vars::DefuseKitHue::ValueType::kMin,
    model_glow_vars::DefuseKitHue::ValueType::kMax,
    model_glow_vars::DefuseKitHue::kDefaultValue
));

```

`Tests/UnitTests/Features/Visuals/ModelGlow/DroppedBombModelGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/DroppedBombModelGlow/DroppedBombModelGlow.h>
#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

std::uint64_t Weapon_sceneObjectUpdater(cs2::C_CSWeaponBase* weapon, void* unknown, bool unknownBool) noexcept
{
    return {};
}

class DroppedBombModelGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext{};
    testing::StrictMock<MockConfig> mockConfig{};
    FeaturesStates featuresStates{};
    DroppedBombModelGlow<MockHookContext> droppedBombModelGlow{mockHookContext};
};

TEST_F(DroppedBombModelGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>(false);
    EXPECT_FALSE(droppedBombModelGlow.enabled());
}

TEST_F(DroppedBombModelGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>(true);
    EXPECT_TRUE(droppedBombModelGlow.enabled());
}

TEST_F(DroppedBombModelGlowTest, CorrectDeactivationFlagIsReturned) {
    EXPECT_EQ(droppedBombModelGlow.deactivationFlag(), ModelGlowDeactivationFlags::DroppedBombModelGlowDeactivating);
}

TEST_F(DroppedBombModelGlowTest, CorrectOriginalSceneObjectUpdaterIsReturned) {
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_THAT(droppedBombModelGlow.originalSceneObjectUpdater(), testing::Ref(featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater));
}

TEST_F(DroppedBombModelGlowTest, CorrectReplacementSceneObjectUpdaterIsReturned) {
    EXPECT_EQ(droppedBombModelGlow.replacementSceneObjectUpdater(), &Weapon_sceneObjectUpdater);
}

class DroppedBombModelGlowHueTest
    : public DroppedBombModelGlowTest,
      public testing::WithParamInterface<color::HueInteger> {
};

TEST_P(DroppedBombModelGlowHueTest, CorrectHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::DroppedBombHue>(model_glow_vars::DroppedBombHue::ValueType{GetParam()});
    EXPECT_EQ(droppedBombModelGlow.hue(), GetParam());
}

INSTANTIATE_TEST_SUITE_P(, DroppedBombModelGlowHueTest, testing::Values(
    model_glow_vars::DroppedBombHue::ValueType::kMin,
    model_glow_vars::DroppedBombHue::ValueType::kMax,
    model_glow_vars::DroppedBombHue::kDefaultValue
));

struct DroppedBombModelGlowShouldApplyTestParam {
    Optional<bool> hasOwner{};
    bool shouldApplyGlow{};
};

class DroppedBombModelGlowShouldApplyTest
    : public DroppedBombModelGlowTest,
      public testing::WithParamInterface<DroppedBombModelGlowShouldApplyTestParam> {
};

TEST_P(DroppedBombModelGlowShouldApplyTest, ShouldApplyGlowIfBombIsDropped) {
    testing::StrictMock<MockBaseEntity> mockBaseEntity;
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(GetParam().hasOwner));
    EXPECT_EQ(droppedBombModelGlow.shouldApplyGlow(mockBaseEntity), GetParam().shouldApplyGlow);
}

INSTANTIATE_TEST_SUITE_P(, DroppedBombModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<DroppedBombModelGlowShouldApplyTestParam>({
        {.hasOwner{std::nullopt}, .shouldApplyGlow = false},
        {.hasOwner{true}, .shouldApplyGlow = false},
        {.hasOwner{false}, .shouldApplyGlow = true}
    })
));

```

`Tests/UnitTests/Features/Visuals/ModelGlow/GrenadeProjectileModelGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/GrenadeProjectileModelGlow/GrenadeProjectileModelGlow.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

class GrenadeProjectileModelGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext{};
    testing::StrictMock<MockConfig> mockConfig{};
    FeaturesStates featuresStates{};
    GrenadeProjectileModelGlow<MockHookContext> grenadeProjectileModelGlow{mockHookContext};
};

TEST_F(GrenadeProjectileModelGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowGrenadeProjectiles>(false);
    EXPECT_FALSE(grenadeProjectileModelGlow.enabled());
}

TEST_F(GrenadeProjectileModelGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowGrenadeProjectiles>(true);
    EXPECT_TRUE(grenadeProjectileModelGlow.enabled());
}

TEST_F(GrenadeProjectileModelGlowTest, CorrectDeactivationFlagIsReturned) {
    EXPECT_EQ(grenadeProjectileModelGlow.deactivationFlag(), ModelGlowDeactivationFlags::GrenadeProjectileModelGlowDeactivating);
}

struct GrenadeProjectileModelGlowHueTestParam {
    EntityTypeInfo entityTypeInfo{};
    std::size_t configVarIndex{};
    std::any configuredHue{};
    color::HueInteger expectedHue;
};

class GrenadeProjectileModelGlowHueTest
    : public GrenadeProjectileModelGlowTest,
      public testing::WithParamInterface<GrenadeProjectileModelGlowHueTestParam> {
};

TEST_P(GrenadeProjectileModelGlowHueTest, CorrectHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    EXPECT_CALL(mockConfig, getVariable(GetParam().configVarIndex))
        .WillOnce(testing::Return(GetParam().configuredHue));
    
    const auto hue = grenadeProjectileModelGlow.hue(GetParam().entityTypeInfo);
    ASSERT_TRUE(hue.hasValue());
    EXPECT_EQ(hue.value(), GetParam().expectedHue);
}

static_assert(model_glow_vars::FlashbangHue::ValueType::kMin == 191, "Update the test below");
static_assert(model_glow_vars::HEGrenadeHue::ValueType::kMin == 300, "Update the test below");
static_assert(model_glow_vars::MolotovHue::ValueType::kMin == 20, "Update the test below");
static_assert(model_glow_vars::SmokeGrenadeHue::ValueType::kMin == 110, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, GrenadeProjectileModelGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{191}}},
            .expectedHue = color::HueInteger{191}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{300}}},
            .expectedHue = color::HueInteger{300}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{20}}},
            .expectedHue = color::HueInteger{20}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{110}}},
            .expectedHue = color::HueInteger{110}
        }
    })
));

static_assert(model_glow_vars::FlashbangHue::ValueType::kMax == 250, "Update the test below");
static_assert(model_glow_vars::HEGrenadeHue::ValueType::kMax == 359, "Update the test below");
static_assert(model_glow_vars::MolotovHue::ValueType::kMax == 60, "Update the test below");
static_assert(model_glow_vars::SmokeGrenadeHue::ValueType::kMax == 140, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, GrenadeProjectileModelGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{250}}},
            .expectedHue = color::HueInteger{250}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = color::HueInteger{359}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{60}}},
            .expectedHue = color::HueInteger{60}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{140}}},
            .expectedHue = color::HueInteger{140}
        }
    })
));

static_assert(model_glow_vars::FlashbangHue::kDefaultValue == color::HueInteger{219}, "Update the tests below");
static_assert(model_glow_vars::HEGrenadeHue::kDefaultValue == color::HueInteger{359}, "Update the tests below");
static_assert(model_glow_vars::MolotovHue::kDefaultValue == color::HueInteger{40}, "Update the tests below");
static_assert(model_glow_vars::SmokeGrenadeHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, GrenadeProjectileModelGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{219}}},
            .expectedHue = color::HueInteger{219}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = color::HueInteger{359}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{40}}},
            .expectedHue = color::HueInteger{40}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{120}}},
            .expectedHue = color::HueInteger{120}
        }
    })
));

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, GrenadeProjectileModelGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{222}}},
            .expectedHue = color::HueInteger{222}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{333}}},
            .expectedHue = color::HueInteger{333}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{55}}},
            .expectedHue = color::HueInteger{55}
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{111}}},
            .expectedHue = color::HueInteger{111}
        }
    })
));

```

`Tests/UnitTests/Features/Visuals/ModelGlow/ModelGlowTests.cpp`:

```cpp
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/ModelGlow.h>
#include <Mocks/MockBaseWeapon.h>
#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPlantedC4.h>
#include <Mocks/MockPlayerController.h>

class ModelGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext{};
    testing::StrictMock<MockConfig> mockConfig{};
    testing::StrictMock<MockBaseEntity> mockBaseEntity{};
    testing::StrictMock<MockBaseWeapon> mockBaseWeapon{};
    testing::StrictMock<MockPlayerPawn> mockPlayerPawn{};
    testing::StrictMock<MockPlantedC4> mockPlantedC4{};
    FeaturesStates featuresStates{};
    ModelGlow<MockHookContext> modelGlow{mockHookContext};
};

TEST_F(ModelGlowTest, DisablingFlagsAreClearedAfterUpdateInMainThread) {
    auto& deactivationFlags = featuresStates.visualFeaturesStates.modelGlowState.deactivationFlags;
    deactivationFlags.setAll();

    EXPECT_CALL(mockHookContext, featuresStates()).WillRepeatedly(testing::ReturnRef(featuresStates));
    modelGlow.postUpdateInMainThread();

    EXPECT_FALSE(deactivationFlags.hasAny());
}

struct ModelGlowInactiveTestParam {
    bool modelGlowEnabled{};
    bool glowEnabled{};
};

class ModelGlowInactiveTest
    : public ModelGlowTest,
      public testing::WithParamInterface<ModelGlowInactiveTestParam> {
protected:
    ModelGlowInactiveTest()
    {
        EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
        EXPECT_CALL(mockHookContext, featuresStates()).WillRepeatedly(testing::ReturnRef(featuresStates));

        mockConfig.expectGetVariable<model_glow_vars::Enabled>(GetParam().modelGlowEnabled);
    }
};

TEST_P(ModelGlowInactiveTest, DefuseKitUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDefuseKits>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInMainThread()(
        DefuseKitModelGlow{mockHookContext},
        mockBaseEntity,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CBaseAnimGraph>()});
}

TEST_P(ModelGlowInactiveTest, DroppedBombUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInMainThread()(
        DroppedBombModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_C4>()});
}

TEST_P(ModelGlowInactiveTest, GrenadeProjectileUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowGrenadeProjectiles>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInMainThread()(
        GrenadeProjectileModelGlow{mockHookContext},
        mockBaseEntity,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()});
}

TEST_P(ModelGlowInactiveTest, PlayerUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInMainThread()(
        PlayerModelGlow{mockHookContext},
        mockPlayerPawn,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_P(ModelGlowInactiveTest, TickingBombUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowTickingBomb>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInMainThread()(
        TickingBombModelGlow{mockHookContext},
        mockPlantedC4,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CPlantedC4>()});
}

TEST_P(ModelGlowInactiveTest, WeaponUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInMainThread()(
        WeaponModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_DEagle>()});
}

TEST_P(ModelGlowInactiveTest, DroppedBombUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInSceneObjectUpdater()(
        DroppedBombModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_C4>()});
}

TEST_P(ModelGlowInactiveTest, PlayerUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInSceneObjectUpdater()(
        PlayerModelGlow{mockHookContext},
        mockPlayerPawn,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_P(ModelGlowInactiveTest, WeaponUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.updateInSceneObjectUpdater()(
        WeaponModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_DEagle>()});
}

TEST_P(ModelGlowInactiveTest, DefuseKitOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDefuseKits>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.onUnload()(DefuseKitModelGlow{mockHookContext}, mockBaseEntity);
}

TEST_P(ModelGlowInactiveTest, DroppedBombOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.onUnload()(DroppedBombModelGlow{mockHookContext}, mockBaseWeapon);
}

TEST_P(ModelGlowInactiveTest, GrenadeProjectileOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowGrenadeProjectiles>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.onUnload()(GrenadeProjectileModelGlow{mockHookContext}, mockBaseEntity);
}

TEST_P(ModelGlowInactiveTest, PlayerOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.onUnload()(PlayerModelGlow{mockHookContext}, mockPlayerPawn);
}

TEST_P(ModelGlowInactiveTest, TickingBombOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowTickingBomb>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.onUnload()(TickingBombModelGlow{mockHookContext}, mockPlantedC4);
}

TEST_P(ModelGlowInactiveTest, WeaponOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>()
        .WillRepeatedly(testing::Return(GetParam().glowEnabled));
    modelGlow.onUnload()(WeaponModelGlow{mockHookContext}, mockBaseWeapon);
}

INSTANTIATE_TEST_SUITE_P(MasterSwitchOff, ModelGlowInactiveTest, testing::ValuesIn(
    std::to_array<ModelGlowInactiveTestParam>({
        {.modelGlowEnabled = false, .glowEnabled = true},
        {.modelGlowEnabled = false, .glowEnabled = false}
    })
));

INSTANTIATE_TEST_SUITE_P(GlowSwitchOff, ModelGlowInactiveTest, testing::ValuesIn(
    std::to_array<ModelGlowInactiveTestParam>({
        {.modelGlowEnabled = true, .glowEnabled = false},
        {.modelGlowEnabled = false, .glowEnabled = false}
    })
));

class ModelGlowActiveTest : public ModelGlowTest {
protected:
    ModelGlowActiveTest()
    {
        EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
        EXPECT_CALL(mockHookContext, featuresStates()).WillRepeatedly(testing::ReturnRef(featuresStates));

        mockConfig.expectGetVariable<model_glow_vars::Enabled>()
            .WillRepeatedly(testing::Return(true));
    }
};

TEST_F(ModelGlowActiveTest, DefuseKitUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDefuseKits>()
        .WillRepeatedly(testing::Return(true));
    mockConfig.expectGetVariable<model_glow_vars::DefuseKitHue>(model_glow_vars::DefuseKitHue::ValueType{color::HueInteger{123}});
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{0, 255, 12}));
    modelGlow.updateInMainThread()(
        DefuseKitModelGlow{mockHookContext},
        mockBaseEntity,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CBaseAnimGraph>()});
}

TEST_F(ModelGlowActiveTest, DroppedBombUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>()
        .WillRepeatedly(testing::Return(true));
    EXPECT_CALL(mockBaseWeapon, baseEntity()).WillOnce(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(0x123123);
    EXPECT_CALL(mockBaseWeapon, getSceneObjectUpdater()).WillRepeatedly(testing::Return(dummySceneObjectUpdater));
    EXPECT_CALL(mockBaseWeapon, setSceneObjectUpdater(&Weapon_sceneObjectUpdater));

    modelGlow.updateInMainThread()(
        DroppedBombModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_C4>()});
    EXPECT_EQ(featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater, dummySceneObjectUpdater);
}

TEST_F(ModelGlowActiveTest, GrenadeProjectileUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowGrenadeProjectiles>()
        .WillRepeatedly(testing::Return(true));
    mockConfig.expectGetVariable<model_glow_vars::SmokeGrenadeHue>(model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{133}});
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{0, 255, 55}));
    modelGlow.updateInMainThread()(
        GrenadeProjectileModelGlow{mockHookContext},
        mockBaseEntity,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()});
}

TEST_F(ModelGlowActiveTest, PlayerUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>()
        .WillRepeatedly(testing::Return(true));
    mockConfig.expectGetVariable<model_glow_vars::GlowOnlyEnemies>(false);

    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSPlayerPawn*, void*, bool)>(0xbadc0de);
    EXPECT_CALL(mockPlayerPawn, isAlive()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(100));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, getSceneObjectUpdater()).WillRepeatedly(testing::Return(dummySceneObjectUpdater));
    EXPECT_CALL(mockPlayerPawn, setSceneObjectUpdater(&PlayerPawn_sceneObjectUpdater));

    modelGlow.updateInMainThread()(
        PlayerModelGlow{mockHookContext},
        mockPlayerPawn,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
    EXPECT_EQ(featuresStates.visualFeaturesStates.modelGlowState.originalPlayerPawnSceneObjectUpdater, dummySceneObjectUpdater);
}

TEST_F(ModelGlowActiveTest, TickingBombUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowTickingBomb>()
        .WillRepeatedly(testing::Return(true));
    mockConfig.expectGetVariable<model_glow_vars::TickingBombHue>(model_glow_vars::TickingBombHue::ValueType{color::HueInteger{255}});
    EXPECT_CALL(mockPlantedC4, isTicking()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlantedC4, baseEntity()).WillOnce(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{63, 0, 255}));
    modelGlow.updateInMainThread()(
        TickingBombModelGlow{mockHookContext},
        mockPlantedC4,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CPlantedC4>()});
}

TEST_F(ModelGlowActiveTest, WeaponUpdateInMainThread) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>()
        .WillRepeatedly(testing::Return(true));
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(0x567890abcdef);
    EXPECT_CALL(mockBaseWeapon, baseEntity()).WillOnce(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseWeapon, getSceneObjectUpdater()).WillRepeatedly(testing::Return(dummySceneObjectUpdater));
    EXPECT_CALL(mockBaseWeapon, setSceneObjectUpdater(&Weapon_sceneObjectUpdater));

    modelGlow.updateInMainThread()(
        WeaponModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_WeaponAWP>()});
    EXPECT_EQ(featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater, dummySceneObjectUpdater);
}

TEST_F(ModelGlowActiveTest, DroppedBombUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>(true);
    mockConfig.expectGetVariable<model_glow_vars::DroppedBombHue>(model_glow_vars::DroppedBombHue::ValueType{color::HueInteger{72}});
    
    EXPECT_CALL(mockBaseWeapon, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{203, 255, 0}));

    modelGlow.updateInSceneObjectUpdater()(
        DroppedBombModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_C4>()});
}

TEST_F(ModelGlowActiveTest, PlayerUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>(true);
    mockConfig.expectGetVariable<model_glow_vars::GlowOnlyEnemies>(false);
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::EnemyAlly);
    mockConfig.expectGetVariable<model_glow_vars::EnemyHue>(model_glow_vars::EnemyHue::ValueType{color::HueInteger{321}});
    
    EXPECT_CALL(mockPlayerPawn, isAlive()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, isEnemy()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(100));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, baseEntity()).WillOnce(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{255, 0, 165}));

    modelGlow.updateInSceneObjectUpdater()(
        PlayerModelGlow{mockHookContext},
        mockPlayerPawn,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_F(ModelGlowActiveTest, ImmunePlayerUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>(true);
    mockConfig.expectGetVariable<model_glow_vars::GlowOnlyEnemies>(false);
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::EnemyAlly);
    mockConfig.expectGetVariable<model_glow_vars::EnemyHue>(model_glow_vars::EnemyHue::ValueType{color::HueInteger{321}});
    
    EXPECT_CALL(mockPlayerPawn, isAlive()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, isEnemy()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(100));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, baseEntity()).WillOnce(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{255, 127, 210}));

    modelGlow.updateInSceneObjectUpdater()(
        PlayerModelGlow{mockHookContext},
        mockPlayerPawn,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_F(ModelGlowActiveTest, WeaponUpdateInSceneObjectUpdater) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>(true);
    mockConfig.expectGetVariable<model_glow_vars::MolotovHue>(model_glow_vars::MolotovHue::ValueType{color::HueInteger{43}});

    EXPECT_CALL(mockBaseWeapon, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockBaseEntity, applySpawnProtectionEffectRecursively(cs2::Color{255, 182, 0}));

    modelGlow.updateInSceneObjectUpdater()(
        WeaponModelGlow{mockHookContext},
        mockBaseWeapon,
        EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()});
}

TEST_F(ModelGlowActiveTest, DefuseKitUpdateOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDefuseKits>(true);
    EXPECT_CALL(mockBaseEntity, removeSpawnProtectionEffectRecursively());
    modelGlow.onUnload()(DefuseKitModelGlow{mockHookContext}, mockBaseEntity);
}

TEST_F(ModelGlowActiveTest, HookedDroppedBombOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>(true);
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(0x123123);
    featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater = dummySceneObjectUpdater;
    EXPECT_CALL(mockBaseWeapon, getSceneObjectUpdater()).WillOnce(testing::Return(&Weapon_sceneObjectUpdater));
    EXPECT_CALL(mockBaseWeapon, setSceneObjectUpdater(dummySceneObjectUpdater));

    modelGlow.onUnload()(DroppedBombModelGlow{mockHookContext}, mockBaseWeapon);
}

TEST_F(ModelGlowActiveTest, NotHookedDroppedBombOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowDroppedBomb>(true);
    featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater = nullptr;
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(0x123123);
    EXPECT_CALL(mockBaseWeapon, getSceneObjectUpdater()).WillOnce(testing::Return(dummySceneObjectUpdater));

    modelGlow.onUnload()(DroppedBombModelGlow{mockHookContext}, mockBaseWeapon);
}

TEST_F(ModelGlowActiveTest, GrenadeProjectileOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowGrenadeProjectiles>(true);
    EXPECT_CALL(mockBaseEntity, removeSpawnProtectionEffectRecursively());
    modelGlow.onUnload()(GrenadeProjectileModelGlow{mockHookContext}, mockBaseEntity);
}

TEST_F(ModelGlowActiveTest, HookedPlayerOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>(true);
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSPlayerPawn*, void*, bool)>(0xbadc0de);
    featuresStates.visualFeaturesStates.modelGlowState.originalPlayerPawnSceneObjectUpdater = dummySceneObjectUpdater;
    EXPECT_CALL(mockPlayerPawn, getSceneObjectUpdater()).WillOnce(testing::Return(&PlayerPawn_sceneObjectUpdater));
    EXPECT_CALL(mockPlayerPawn, setSceneObjectUpdater(dummySceneObjectUpdater));

    modelGlow.onUnload()(PlayerModelGlow{mockHookContext}, mockPlayerPawn);
}

TEST_F(ModelGlowActiveTest, NotHookedPlayerOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>(true);
    featuresStates.visualFeaturesStates.modelGlowState.originalPlayerPawnSceneObjectUpdater = nullptr;
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSPlayerPawn*, void*, bool)>(0xbadc0de);
    EXPECT_CALL(mockPlayerPawn, getSceneObjectUpdater()).WillOnce(testing::Return(dummySceneObjectUpdater));

    modelGlow.onUnload()(PlayerModelGlow{mockHookContext}, mockPlayerPawn);
}

TEST_F(ModelGlowActiveTest, TickingBombOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowTickingBomb>(true);
    EXPECT_CALL(mockPlantedC4, baseEntity()).WillOnce(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockBaseEntity, removeSpawnProtectionEffectRecursively());
    modelGlow.onUnload()(TickingBombModelGlow{mockHookContext}, mockPlantedC4);
}

TEST_F(ModelGlowActiveTest, HookedWeaponOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>(true);
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(0x567890abcdef);
    featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater = dummySceneObjectUpdater;
    EXPECT_CALL(mockBaseWeapon, getSceneObjectUpdater()).WillOnce(testing::Return(&Weapon_sceneObjectUpdater));
    EXPECT_CALL(mockBaseWeapon, setSceneObjectUpdater(dummySceneObjectUpdater));

    modelGlow.onUnload()(WeaponModelGlow{mockHookContext}, mockBaseWeapon);
}

TEST_F(ModelGlowActiveTest, NotHookedWeaponOnUnload) {
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>(true);
    featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater = nullptr;
    const auto dummySceneObjectUpdater = reinterpret_cast<std::uint64_t(*)(cs2::C_CSWeaponBase*, void*, bool)>(0x567890abcdef);
    EXPECT_CALL(mockBaseWeapon, getSceneObjectUpdater()).WillOnce(testing::Return(dummySceneObjectUpdater));

    modelGlow.onUnload()(WeaponModelGlow{mockHookContext}, mockBaseWeapon);
}


```

`Tests/UnitTests/Features/Visuals/ModelGlow/PlayerModelGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/PlayerModelGlow/PlayerModelGlow.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPlayerController.h>
#include <Mocks/MockPlayerPawn.h>

std::uint64_t PlayerPawn_sceneObjectUpdater(cs2::C_CSPlayerPawn* playerPawn, void* unknown, bool unknownBool) noexcept
{
    return 0;
}

class PlayerModelGlowTest : public testing::Test {
protected:
    PlayerModelGlowTest()
    {
        EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
    }

    testing::StrictMock<MockHookContext> mockHookContext{};
    testing::StrictMock<MockConfig> mockConfig{};
    testing::StrictMock<MockPlayerPawn> mockPlayerPawn{};
    testing::StrictMock<MockPlayerController> mockPlayerController{};
    FeaturesStates featuresStates{};
    PlayerModelGlow<MockHookContext> playerModelGlow{mockHookContext};
};

TEST_F(PlayerModelGlowTest, Disabled) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>(false);
    EXPECT_FALSE(playerModelGlow.enabled());
}

TEST_F(PlayerModelGlowTest, Enabled) {
    mockConfig.expectGetVariable<model_glow_vars::GlowPlayers>(true);
    EXPECT_TRUE(playerModelGlow.enabled());
}

TEST_F(PlayerModelGlowTest, CorrectDeactivationFlagIsReturned) {
    EXPECT_EQ(playerModelGlow.deactivationFlag(), ModelGlowDeactivationFlags::PlayerModelGlowDeactivating);
}

TEST_F(PlayerModelGlowTest, CorrectOriginalSceneObjectUpdaterIsReturned) {
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_THAT(playerModelGlow.originalSceneObjectUpdater(), testing::Ref(featuresStates.visualFeaturesStates.modelGlowState.originalPlayerPawnSceneObjectUpdater));
}

TEST_F(PlayerModelGlowTest, CorrectReplacementSceneObjectUpdaterIsReturned) {
    EXPECT_EQ(playerModelGlow.replacementSceneObjectUpdater(), &PlayerPawn_sceneObjectUpdater);
}

struct PlayerModelGlowSaturationTestParam {
    Optional<bool> playerHasImmunity{};
    color::Saturation expectedSaturation;
};

class PlayerModelGlowSaturationTest
    : public PlayerModelGlowTest,
      public testing::WithParamInterface<PlayerModelGlowSaturationTestParam> {
};

TEST_P(PlayerModelGlowSaturationTest, CorrectSaturationIsReturned) {
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(GetParam().playerHasImmunity));
    EXPECT_EQ(playerModelGlow.saturation(mockPlayerPawn), GetParam().expectedSaturation);
}

INSTANTIATE_TEST_SUITE_P(, PlayerModelGlowSaturationTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowSaturationTestParam>({
        {.playerHasImmunity{std::nullopt}, .expectedSaturation{model_glow_params::kNormalPlayerColorSaturation}},
        {.playerHasImmunity{false}, .expectedSaturation{model_glow_params::kNormalPlayerColorSaturation}},
        {.playerHasImmunity{true}, .expectedSaturation{model_glow_params::kImmunePlayerColorSaturation}}
    })
));

struct PlayerModelGlowShouldApplyTestParam {
    bool onlyEnemies{true};
    std::optional<bool> isAlive{true};
    Optional<int> health{100};
    bool isControlledByLocalPlayer{false};
    bool isTTorCT{true};
    std::optional<bool> isEnemy{true};
    bool expectPlayerPawnAccess{true};
    bool expectEnemyCheck{true};
    bool expectGlowApplied{true};
};

class PlayerModelGlowShouldApplyTest
    : public PlayerModelGlowTest,
      public testing::WithParamInterface<PlayerModelGlowShouldApplyTestParam> {
};

TEST_P(PlayerModelGlowShouldApplyTest, GlowIsAppliedWhenExpected) {
    EXPECT_CALL(mockConfig, getVariable(ConfigVariableTypes::indexOf<model_glow_vars::GlowOnlyEnemies>()))
        .WillRepeatedly(testing::Return(GetParam().onlyEnemies));

    if (GetParam().expectPlayerPawnAccess) {
        EXPECT_CALL(mockPlayerPawn, isAlive()).WillRepeatedly(testing::Return(GetParam().isAlive));
        EXPECT_CALL(mockPlayerPawn, health()).WillRepeatedly(testing::Return(GetParam().health));
        EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillRepeatedly(testing::Return(GetParam().isControlledByLocalPlayer));
        EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillRepeatedly(testing::Return(GetParam().isTTorCT));

        if (GetParam().expectEnemyCheck)
            EXPECT_CALL(mockPlayerPawn, isEnemy()).WillRepeatedly(testing::Return(GetParam().isEnemy));
    }

    EXPECT_EQ(playerModelGlow.shouldApplyGlow(mockPlayerPawn), GetParam().expectGlowApplied);
}

INSTANTIATE_TEST_SUITE_P(OnlyEnemies, PlayerModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowShouldApplyTestParam>({
        {
            .onlyEnemies = true,
            .isEnemy{true},
            .expectEnemyCheck = true,
            .expectGlowApplied = true
        },
        {
            .onlyEnemies = true,
            .isEnemy{false},
            .expectEnemyCheck = true,
            .expectGlowApplied = false
        },
        {
            .onlyEnemies = true,
            .isEnemy{std::nullopt},
            .expectEnemyCheck = true,
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(NotOnlyEnemies, PlayerModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowShouldApplyTestParam>({
        {
            .onlyEnemies = false,
            .isEnemy{true},
            .expectEnemyCheck = false,
            .expectGlowApplied = true
        },
        {
            .onlyEnemies = false,
            .isEnemy{false},
            .expectEnemyCheck = false,
            .expectGlowApplied = true
        },
        {
            .onlyEnemies = false,
            .isEnemy{std::nullopt},
            .expectEnemyCheck = false,
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(IsAlive, PlayerModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowShouldApplyTestParam>({
        {
            .isAlive{true},
            .expectGlowApplied = true
        },
        {
            .isAlive{false},
            .expectGlowApplied = false
        },
        {
            .isAlive{std::nullopt},
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(Health, PlayerModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowShouldApplyTestParam>({
        {
            .health{100},
            .expectGlowApplied = true
        },
        {
            .health{120},
            .expectGlowApplied = true
        },
        {
            .health{0},
            .expectGlowApplied = false
        },
        {
            .health{std::nullopt},
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(IsControlledByLocalPlayer, PlayerModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowShouldApplyTestParam>({
        {
            .isControlledByLocalPlayer = false,
            .expectGlowApplied = true
        },
        {
            .isControlledByLocalPlayer = true,
            .expectGlowApplied = false
        }
    })
));

INSTANTIATE_TEST_SUITE_P(IsTTorCT, PlayerModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<PlayerModelGlowShouldApplyTestParam>({
        {
            .isTTorCT = true,
            .expectGlowApplied = true
        },
        {
            .isTTorCT = false,
            .expectGlowApplied = false
        }
    })
));

struct PlayerModelGlowHealthBasedHueConfigVariables {
    color::HueInteger::UnderlyingType lowHealthHue;
    color::HueInteger::UnderlyingType highHealthHue;
};

struct PlayerModelGlowHealthBasedHueParam {
    Optional<int> health{100};
    Optional<color::Hue::ValueType> expectedHue{};
};

class PlayerModelGlowHealthBasedHueTest
    : public PlayerModelGlowTest,
      public testing::WithParamInterface<std::tuple<PlayerModelGlowHealthBasedHueConfigVariables, PlayerModelGlowHealthBasedHueParam>> {
};

TEST_P(PlayerModelGlowHealthBasedHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::HealthBased);

    const auto [configVariables, param] = GetParam();
    EXPECT_CALL(mockConfig, getVariable(ConfigVariableTypes::indexOf<model_glow_vars::LowHealthHue>()))
        .WillRepeatedly(testing::Return(model_glow_vars::LowHealthHue::ValueType{color::HueInteger{configVariables.lowHealthHue}}));
    EXPECT_CALL(mockConfig, getVariable(ConfigVariableTypes::indexOf<model_glow_vars::HighHealthHue>()))
        .WillRepeatedly(testing::Return(model_glow_vars::HighHealthHue::ValueType{color::HueInteger{configVariables.highHealthHue}}));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(param.health));

    const auto hue = playerModelGlow.hue(mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), param.expectedHue.hasValue());
    if (hue.hasValue() && param.expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), param.expectedHue.value());
}

static_assert(model_glow_vars::LowHealthHue::ValueType::kMin == 0, "Update the tests below");
static_assert(model_glow_vars::LowHealthHue::ValueType::kMax == 359, "Update the tests below");
static_assert(model_glow_vars::HighHealthHue::ValueType::kMin == 0, "Update the tests below");
static_assert(model_glow_vars::HighHealthHue::ValueType::kMax == 359, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(MinMax, PlayerModelGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerModelGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 0,
        .highHealthHue = 359}),
    testing::ValuesIn(std::to_array<PlayerModelGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.0f}},
        {.health{1}, .expectedHue{0.0f}},
        {.health{25}, .expectedHue{0.2417508f}},
        {.health{75}, .expectedHue{0.7453984f}},
        {.health{100}, .expectedHue{0.997222f}},
        {.health{120}, .expectedHue{0.997222f}}}))
));

INSTANTIATE_TEST_SUITE_P(MaxMin, PlayerModelGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerModelGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 359,
        .highHealthHue = 0}),
    testing::ValuesIn(std::to_array<PlayerModelGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.997222f}},
        {.health{1}, .expectedHue{0.997222f}},
        {.health{25}, .expectedHue{0.75547138f}},
        {.health{75}, .expectedHue{0.25182379f}},
        {.health{100}, .expectedHue{0.0f}},
        {.health{120}, .expectedHue{0.0f}}
    }))
));

INSTANTIATE_TEST_SUITE_P(MinMin, PlayerModelGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerModelGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 0,
        .highHealthHue = 0}),
    testing::ValuesIn(std::to_array<PlayerModelGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.0f}},
        {.health{1}, .expectedHue{0.0f}},
        {.health{25}, .expectedHue{0.0f}},
        {.health{75}, .expectedHue{0.0f}},
        {.health{100}, .expectedHue{0.0f}},
        {.health{120}, .expectedHue{0.0f}}
    }))
));

INSTANTIATE_TEST_SUITE_P(MaxMax, PlayerModelGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerModelGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 359,
        .highHealthHue = 359}),
    testing::ValuesIn(std::to_array<PlayerModelGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.997222f}},
        {.health{1}, .expectedHue{0.997222f}},
        {.health{25}, .expectedHue{0.997222f}},
        {.health{75}, .expectedHue{0.997222f}},
        {.health{100}, .expectedHue{0.997222f}},
        {.health{120}, .expectedHue{0.997222f}}
    }))
));

static_assert(model_glow_vars::LowHealthHue::kDefaultValue == color::HueInteger{0}, "Update the tests below");
static_assert(model_glow_vars::HighHealthHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(Default, PlayerModelGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerModelGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 0,
        .highHealthHue = 120}),
    testing::ValuesIn(std::to_array<PlayerModelGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.0f}},
        {.health{1}, .expectedHue{0.0f}},
        {.health{25}, .expectedHue{0.08080808f}},
        {.health{75}, .expectedHue{0.24915824f}},
        {.health{100}, .expectedHue{0.33333333f}},
        {.health{120}, .expectedHue{0.33333333f}}
    }))
));

INSTANTIATE_TEST_SUITE_P(NonDefault, PlayerModelGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerModelGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 220,
        .highHealthHue = 280}),
    testing::ValuesIn(std::to_array<PlayerModelGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.61111111f}},
        {.health{1}, .expectedHue{0.61111111f}},
        {.health{25}, .expectedHue{0.65151515f}},
        {.health{75}, .expectedHue{0.73569023f}},
        {.health{100}, .expectedHue{0.77777777f}},
        {.health{120}, .expectedHue{0.77777777f}}
    }))
));

struct PlayerModelGlowPlayerColorIndexHueTestParam {
    cs2::CCSPlayerController::m_iCompTeammateColor playerColorIndex{};
    std::size_t configVariableIndex{};
    std::any configuredHue{};
    color::Hue::ValueType expectedHue{};
};

class PlayerModelGlowPlayerColorIndexHueTest
    : public PlayerModelGlowTest,
      public testing::WithParamInterface<PlayerModelGlowPlayerColorIndexHueTestParam> {
};

TEST_P(PlayerModelGlowPlayerColorIndexHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::PlayerOrTeamColor);

    EXPECT_CALL(mockConfig, getVariable(GetParam().configVariableIndex))
        .WillRepeatedly(testing::Return(GetParam().configuredHue));

    EXPECT_CALL(mockPlayerPawn, playerController()).WillOnce(testing::ReturnRef(mockPlayerController));
    EXPECT_CALL(mockPlayerController, playerColorIndex()).WillOnce(testing::Return(GetParam().playerColorIndex));

    const auto hue = playerModelGlow.hue(mockPlayerPawn);
    ASSERT_TRUE(hue.hasValue());
    EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue);
}

static_assert(model_glow_vars::PlayerBlueHue::ValueType::kMin == 191, "Update the test below");
static_assert(model_glow_vars::PlayerGreenHue::ValueType::kMin == 110, "Update the test below");
static_assert(model_glow_vars::PlayerYellowHue::ValueType::kMin == 47, "Update the test below");
static_assert(model_glow_vars::PlayerOrangeHue::ValueType::kMin == 11, "Update the test below");
static_assert(model_glow_vars::PlayerPurpleHue::ValueType::kMin == 250, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, PlayerModelGlowPlayerColorIndexHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowPlayerColorIndexHueTestParam>({
        {
            .playerColorIndex = cs2::PlayerColorIndex::Blue,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerBlueHue>(),
            .configuredHue{model_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{191}}},
            .expectedHue = 0.53055555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Green,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerGreenHue>(),
            .configuredHue{model_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{110}}},
            .expectedHue = 0.30555555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Yellow,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerYellowHue>(),
            .configuredHue{model_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{47}}},
            .expectedHue = 0.13055555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Orange,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerOrangeHue>(),
            .configuredHue{model_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{11}}},
            .expectedHue = 0.03055555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Purple,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerPurpleHue>(),
            .configuredHue{model_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{250}}},
            .expectedHue = 0.69444444f
        }
    })
));

static_assert(model_glow_vars::PlayerBlueHue::ValueType::kMax == 240, "Update the test below");
static_assert(model_glow_vars::PlayerGreenHue::ValueType::kMax == 140, "Update the test below");
static_assert(model_glow_vars::PlayerYellowHue::ValueType::kMax == 60, "Update the test below");
static_assert(model_glow_vars::PlayerOrangeHue::ValueType::kMax == 20, "Update the test below");
static_assert(model_glow_vars::PlayerPurpleHue::ValueType::kMax == 280, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, PlayerModelGlowPlayerColorIndexHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowPlayerColorIndexHueTestParam>({
        {
            .playerColorIndex = cs2::PlayerColorIndex::Blue,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerBlueHue>(),
            .configuredHue{model_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{240}}},
            .expectedHue = 0.66666666f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Green,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerGreenHue>(),
            .configuredHue{model_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{140}}},
            .expectedHue = 0.38888888f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Yellow,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerYellowHue>(),
            .configuredHue{model_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 0.16666666f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Orange,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerOrangeHue>(),
            .configuredHue{model_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 0.05555555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Purple,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerPurpleHue>(),
            .configuredHue{model_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{280}}},
            .expectedHue = 0.77777777f
        }
    })
));

static_assert(model_glow_vars::PlayerBlueHue::kDefaultValue == color::HueInteger{215}, "Update the test below");
static_assert(model_glow_vars::PlayerGreenHue::kDefaultValue == color::HueInteger{125}, "Update the test below");
static_assert(model_glow_vars::PlayerYellowHue::kDefaultValue == color::HueInteger{53}, "Update the test below");
static_assert(model_glow_vars::PlayerOrangeHue::kDefaultValue == color::HueInteger{15}, "Update the test below");
static_assert(model_glow_vars::PlayerPurpleHue::kDefaultValue == color::HueInteger{265}, "Update the test below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, PlayerModelGlowPlayerColorIndexHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowPlayerColorIndexHueTestParam>({
        {
            .playerColorIndex = cs2::PlayerColorIndex::Blue,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerBlueHue>(),
            .configuredHue{model_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{215}}},
            .expectedHue = 0.59722222f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Green,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerGreenHue>(),
            .configuredHue{model_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{125}}},
            .expectedHue = 0.34722222f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Yellow,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerYellowHue>(),
            .configuredHue{model_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{53}}},
            .expectedHue = 0.14722222f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Orange,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerOrangeHue>(),
            .configuredHue{model_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{15}}},
            .expectedHue = 0.04166666f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Purple,
            .configVariableIndex = ConfigVariableTypes::indexOf<model_glow_vars::PlayerPurpleHue>(),
            .configuredHue{model_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{265}}},
            .expectedHue = 0.73611111f
        }
    })
));

struct PlayerModelGlowTeamHueTestParam {
    TeamNumber teamNumber{};
    Optional<color::HueInteger::UnderlyingType> teamTHue{};
    Optional<color::HueInteger::UnderlyingType> teamCTHue{};
    Optional<color::Hue::ValueType> expectedHue{};
};

class PlayerModelGlowTeamHueTest
    : public PlayerModelGlowTest,
      public testing::WithParamInterface<PlayerModelGlowTeamHueTestParam> {
};

TEST_P(PlayerModelGlowTeamHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::TeamColor);

    if (GetParam().teamTHue.hasValue())
        mockConfig.expectGetVariable<model_glow_vars::TeamTHue>(model_glow_vars::TeamTHue::ValueType{color::HueInteger{GetParam().teamTHue.value()}});

    if (GetParam().teamCTHue.hasValue())
        mockConfig.expectGetVariable<model_glow_vars::TeamCTHue>(model_glow_vars::TeamCTHue::ValueType{color::HueInteger{GetParam().teamCTHue.value()}});

    EXPECT_CALL(mockPlayerPawn, teamNumber()).WillRepeatedly(testing::Return(GetParam().teamNumber));

    const auto hue = playerModelGlow.hue(mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), GetParam().expectedHue.hasValue());
    if (hue.hasValue() && GetParam().expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue.value());
}

TEST_P(PlayerModelGlowTeamHueTest, CorrectHueIsReturnedAsFallbackWhenInvalidPlayerColorIndex) {
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::PlayerOrTeamColor);

    if (GetParam().teamTHue.hasValue())
        mockConfig.expectGetVariable<model_glow_vars::TeamTHue>(model_glow_vars::TeamTHue::ValueType{color::HueInteger{GetParam().teamTHue.value()}});

    if (GetParam().teamCTHue.hasValue())
        mockConfig.expectGetVariable<model_glow_vars::TeamCTHue>(model_glow_vars::TeamCTHue::ValueType{color::HueInteger{GetParam().teamCTHue.value()}});

    EXPECT_CALL(mockPlayerPawn, teamNumber()).WillRepeatedly(testing::Return(GetParam().teamNumber));
    EXPECT_CALL(mockPlayerPawn, playerController()).WillRepeatedly(testing::ReturnRef(mockPlayerController));
    EXPECT_CALL(mockPlayerController, playerColorIndex()).WillRepeatedly(testing::Return(cs2::PlayerColorIndex{-1}));

    const auto hue = playerModelGlow.hue(mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), GetParam().expectedHue.hasValue());
    if (hue.hasValue() && GetParam().expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue.value());
}

INSTANTIATE_TEST_SUITE_P(InvalidTeam, PlayerModelGlowTeamHueTest,
    testing::Values(PlayerModelGlowTeamHueTestParam{.teamNumber{}, .expectedHue{std::nullopt}}));

static_assert(model_glow_vars::TeamTHue::ValueType::kMin == 30, "Update the test below");
static_assert(model_glow_vars::TeamCTHue::ValueType::kMin == 210, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, PlayerModelGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 30, .expectedHue{0.08333333f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 210, .expectedHue{0.58333333f}}
    }))
);

static_assert(model_glow_vars::TeamTHue::ValueType::kMax == 40, "Update the test below");
static_assert(model_glow_vars::TeamCTHue::ValueType::kMax == 230, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, PlayerModelGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 40, .expectedHue{0.11111111f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 230, .expectedHue{0.63888888f}}
    }))
);

static_assert(model_glow_vars::TeamTHue::kDefaultValue == color::HueInteger{35}, "Update the tests below");
static_assert(model_glow_vars::TeamCTHue::kDefaultValue == color::HueInteger{220}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, PlayerModelGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 35, .expectedHue{0.09722222f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 220, .expectedHue{0.61111111f}}
    }))
);

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, PlayerModelGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 37, .expectedHue{0.10277777f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 229, .expectedHue{0.63611111f}}
    }))
);

struct PlayerModelGlowEnemyHueTestParam {
    std::optional<bool> isEnemy;
    Optional<color::HueInteger::UnderlyingType> enemyHue{};
    Optional<color::HueInteger::UnderlyingType> allyHue{};
    Optional<color::Hue::ValueType> expectedHue{};
};

class PlayerModelGlowEnemyHueTest
    : public PlayerModelGlowTest,
      public testing::WithParamInterface<PlayerModelGlowEnemyHueTestParam> {
};

TEST_P(PlayerModelGlowEnemyHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<model_glow_vars::PlayerGlowColorMode>(PlayerModelGlowColorType::EnemyAlly);

    if (GetParam().enemyHue.hasValue())
        mockConfig.expectGetVariable<model_glow_vars::EnemyHue>(model_glow_vars::EnemyHue::ValueType{color::HueInteger{GetParam().enemyHue.value()}});
    if (GetParam().allyHue.hasValue())
        mockConfig.expectGetVariable<model_glow_vars::AllyHue>(model_glow_vars::AllyHue::ValueType{color::HueInteger{GetParam().allyHue.value()}});

    EXPECT_CALL(mockPlayerPawn, isEnemy()).WillOnce(testing::Return(GetParam().isEnemy));

    const auto hue = playerModelGlow.hue(mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), GetParam().expectedHue.hasValue());
    if (hue.hasValue() && GetParam().expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue.value());
}

INSTANTIATE_TEST_SUITE_P(UnknownIfIsEnemy, PlayerModelGlowEnemyHueTest,
    testing::Values(PlayerModelGlowEnemyHueTestParam{.isEnemy{std::nullopt}, .expectedHue{std::nullopt}}));

static_assert(model_glow_vars::EnemyHue::ValueType::kMin == 0, "Update the test below");
static_assert(model_glow_vars::AllyHue::ValueType::kMin == 0, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, PlayerModelGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{0}, .expectedHue{0.0f}},
        {.isEnemy{false}, .allyHue{0}, .expectedHue{0.0f}}
    }))
);

static_assert(model_glow_vars::EnemyHue::ValueType::kMax == 359, "Update the test below");
static_assert(model_glow_vars::AllyHue::ValueType::kMax == 359, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, PlayerModelGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{359}, .expectedHue{0.99722222f}},
        {.isEnemy{false}, .allyHue{359}, .expectedHue{0.99722222f}}
    }))
);

static_assert(model_glow_vars::EnemyHue::kDefaultValue == color::HueInteger{0}, "Update the tests below");
static_assert(model_glow_vars::AllyHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, PlayerModelGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{0}, .expectedHue{0.0f}},
        {.isEnemy{false}, .allyHue{120}, .expectedHue{0.33333333f}}
    }))
);

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, PlayerModelGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerModelGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{123}, .expectedHue{0.34166666f}},
        {.isEnemy{false}, .allyHue{234}, .expectedHue{0.65f}}
    }))
);

```

`Tests/UnitTests/Features/Visuals/ModelGlow/TickingBombModelGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/TickingBombModelGlow/TickingBombModelGlow.h>
#include <Features/FeaturesStates.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPlantedC4.h>

class TickingBombModelGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockConfig> mockConfig{};
    testing::StrictMock<MockHookContext> mockHookContext{};
    FeaturesStates featuresStates{};
    TickingBombModelGlow<MockHookContext> tickingBombModelGlow{mockHookContext};
};

TEST_F(TickingBombModelGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowTickingBomb>(false);
    EXPECT_FALSE(tickingBombModelGlow.enabled());
}

TEST_F(TickingBombModelGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowTickingBomb>(true);
    EXPECT_TRUE(tickingBombModelGlow.enabled());
}

TEST_F(TickingBombModelGlowTest, CorrectDeactivationFlagIsReturned) {
    EXPECT_EQ(tickingBombModelGlow.deactivationFlag(), ModelGlowDeactivationFlags::TickingBombModelGlowDeactivating);
}

class TickingBombModelGlowHueTest
    : public TickingBombModelGlowTest,
      public testing::WithParamInterface<color::HueInteger> {
};

TEST_P(TickingBombModelGlowHueTest, CorrectHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::TickingBombHue>(model_glow_vars::TickingBombHue::ValueType{GetParam()});
    EXPECT_EQ(tickingBombModelGlow.hue(), GetParam());
}

INSTANTIATE_TEST_SUITE_P(, TickingBombModelGlowHueTest, testing::Values(
    model_glow_vars::TickingBombHue::ValueType::kMin,
    model_glow_vars::TickingBombHue::ValueType::kMax,
    model_glow_vars::TickingBombHue::kDefaultValue
));

struct TickingBombModelGlowShouldApplyTestParam {
    Optional<bool> isTicking{};
    bool shouldApplyGlow{};
};

class TickingBombModelGlowShouldApplyTest
    : public TickingBombModelGlowTest,
      public testing::WithParamInterface<TickingBombModelGlowShouldApplyTestParam> {
};

TEST_P(TickingBombModelGlowShouldApplyTest, ShouldApplyGlowIfBombIsTicking) {
    testing::StrictMock<MockPlantedC4> mockPlantedC4;
    EXPECT_CALL(mockPlantedC4, isTicking()).WillOnce(testing::Return(GetParam().isTicking));
    EXPECT_EQ(tickingBombModelGlow.shouldApplyGlow(mockPlantedC4), GetParam().shouldApplyGlow);
}

INSTANTIATE_TEST_SUITE_P(, TickingBombModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<TickingBombModelGlowShouldApplyTestParam>({
        {.isTicking{std::nullopt}, .shouldApplyGlow = true},
        {.isTicking{true}, .shouldApplyGlow = true},
        {.isTicking{false}, .shouldApplyGlow = false}
    })
));

```

`Tests/UnitTests/Features/Visuals/ModelGlow/WeaponModelGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/ModelGlow/WeaponModelGlow/WeaponModelGlow.h>
#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

class WeaponModelGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext{};
    testing::StrictMock<MockConfig> mockConfig{};
    FeaturesStates featuresStates{};
    WeaponModelGlow<MockHookContext> weaponModelGlow{mockHookContext};
};

TEST_F(WeaponModelGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>(false);
    EXPECT_FALSE(weaponModelGlow.enabled());
}

TEST_F(WeaponModelGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<model_glow_vars::GlowWeapons>(true);
    EXPECT_TRUE(weaponModelGlow.enabled());
}

TEST_F(WeaponModelGlowTest, CorrectDeactivationFlagIsReturned) {
    EXPECT_EQ(weaponModelGlow.deactivationFlag(), ModelGlowDeactivationFlags::WeaponModelGlowDeactivating);
}

TEST_F(WeaponModelGlowTest, CorrectOriginalSceneObjectUpdaterIsReturned) {
    EXPECT_CALL(mockHookContext, featuresStates()).WillOnce(testing::ReturnRef(featuresStates));
    EXPECT_THAT(weaponModelGlow.originalSceneObjectUpdater(), testing::Ref(featuresStates.visualFeaturesStates.modelGlowState.originalWeaponSceneObjectUpdater));
}

TEST_F(WeaponModelGlowTest, CorrectReplacementSceneObjectUpdaterIsReturned) {
    EXPECT_EQ(weaponModelGlow.replacementSceneObjectUpdater(), &Weapon_sceneObjectUpdater);
}

TEST_F(WeaponModelGlowTest, NoHueIsReturnedWhenDefaultShouldBeUsed) {
    EXPECT_FALSE(weaponModelGlow.hue(EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_AK47>()}).hasValue());
    EXPECT_FALSE(weaponModelGlow.hue(EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_WeaponAWP>()}).hasValue());
    EXPECT_FALSE(weaponModelGlow.hue(EntityTypeInfo{}).hasValue());
}

struct WeaponModelGlowShouldApplyTestParam {
    Optional<bool> hasOwner{};
    bool shouldApplyGlow{};
};

class WeaponModelGlowShouldApplyTest
    : public WeaponModelGlowTest,
      public testing::WithParamInterface<WeaponModelGlowShouldApplyTestParam> {
};

TEST_P(WeaponModelGlowShouldApplyTest, ShouldApplyGlowIfWeaponIsDropped) {
    testing::StrictMock<MockBaseEntity> mockBaseEntity;
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(GetParam().hasOwner));
    EXPECT_EQ(weaponModelGlow.shouldApplyGlow(mockBaseEntity), GetParam().shouldApplyGlow);
}

INSTANTIATE_TEST_SUITE_P(, WeaponModelGlowShouldApplyTest, testing::ValuesIn(
    std::to_array<WeaponModelGlowShouldApplyTestParam>({
        {.hasOwner{std::nullopt}, .shouldApplyGlow = false},
        {.hasOwner{true}, .shouldApplyGlow = false},
        {.hasOwner{false}, .shouldApplyGlow = true}
    })
));

struct WeaponModelGlowHueTestParam {
    EntityTypeInfo entityTypeInfo{};
    std::size_t configVarIndex{};
    std::any configuredHue{};
    color::HueInteger::UnderlyingType expectedHue{};
};

class WeaponModelGlowHueTest
    : public WeaponModelGlowTest,
      public testing::WithParamInterface<WeaponModelGlowHueTestParam> {
};

TEST_P(WeaponModelGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    EXPECT_CALL(mockConfig, getVariable(GetParam().configVarIndex))
        .WillRepeatedly(testing::Return(GetParam().configuredHue));

    const auto hue = weaponModelGlow.hue(GetParam().entityTypeInfo);
    ASSERT_TRUE(hue.hasValue());
    EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue);
}

static_assert(model_glow_vars::FlashbangHue::ValueType::kMin == 191, "Update the test below");
static_assert(model_glow_vars::HEGrenadeHue::ValueType::kMin == 300, "Update the test below");
static_assert(model_glow_vars::MolotovHue::ValueType::kMin == 20, "Update the test below");
static_assert(model_glow_vars::SmokeGrenadeHue::ValueType::kMin == 110, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, WeaponModelGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{191}}},
            .expectedHue = 191
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{300}}},
            .expectedHue = 300
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 20
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 20
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{110}}},
            .expectedHue = 110
        }
    })
));

static_assert(model_glow_vars::FlashbangHue::ValueType::kMax == 250, "Update the test below");
static_assert(model_glow_vars::HEGrenadeHue::ValueType::kMax == 359, "Update the test below");
static_assert(model_glow_vars::MolotovHue::ValueType::kMax == 60, "Update the test below");
static_assert(model_glow_vars::SmokeGrenadeHue::ValueType::kMax == 140, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, WeaponModelGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{250}}},
            .expectedHue = 250
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = 359
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 60
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 60
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{140}}},
            .expectedHue = 140
        }
    })
));

static_assert(model_glow_vars::FlashbangHue::kDefaultValue == color::HueInteger{219}, "Update the tests below");
static_assert(model_glow_vars::HEGrenadeHue::kDefaultValue == color::HueInteger{359}, "Update the tests below");
static_assert(model_glow_vars::MolotovHue::kDefaultValue == color::HueInteger{40}, "Update the tests below");
static_assert(model_glow_vars::SmokeGrenadeHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, WeaponModelGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{219}}},
            .expectedHue = 219
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = 359
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{40}}},
            .expectedHue = 40
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{40}}},
            .expectedHue = 40
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{120}}},
            .expectedHue = 120
        }
    })
));

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, WeaponModelGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponModelGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::FlashbangHue>(),
            .configuredHue{model_glow_vars::FlashbangHue::ValueType{color::HueInteger{222}}},
            .expectedHue = 222
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::HEGrenadeHue>(),
            .configuredHue{model_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{333}}},
            .expectedHue = 333
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{55}}},
            .expectedHue = 55
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::MolotovHue>(),
            .configuredHue{model_glow_vars::MolotovHue::ValueType{color::HueInteger{55}}},
            .expectedHue = 55
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<model_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{model_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{111}}},
            .expectedHue = 111
        }
    })
));

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  DefuseKitOutlineGlowTests.cpp
  DroppedBombOutlineGlowTests.cpp
  GrenadeProjectileOutlineGlowTests.cpp
  HostageOutlineGlowTests.cpp
  OutlineGlowTests.cpp
  PlayerOutlineGlowTests.cpp
  TickingBombOutlineGlowTests.cpp
  WeaponOutlineGlowTests.cpp
)

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/DefuseKitOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

#include <Features/Visuals/OutlineGlow/DefuseKitOutlineGlow/DefuseKitOutlineGlow.h>

class DefuseKitOutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockBaseEntity> mockBaseEntity;

    DefuseKitOutlineGlow<MockHookContext> defuseKitOutlineGlow{mockHookContext};
};

TEST_F(DefuseKitOutlineGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowDefuseKits>(false);
    EXPECT_FALSE(defuseKitOutlineGlow.enabled());
}

TEST_F(DefuseKitOutlineGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowDefuseKits>(true);
    EXPECT_TRUE(defuseKitOutlineGlow.enabled());
}

TEST_F(DefuseKitOutlineGlowTest, CorrectGlowRangeIsReturned) {
    EXPECT_EQ(defuseKitOutlineGlow.getGlowRange(), outline_glow_params::kDefuseKitGlowRange);
}

class DefuseKitOutlineGlowHueTest
    : public DefuseKitOutlineGlowTest,
      public testing::WithParamInterface<color::HueInteger::UnderlyingType> {
};

TEST_P(DefuseKitOutlineGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::DefuseKitHue>(outline_glow_vars::DefuseKitHue::ValueType{color::HueInteger{GetParam()}});

    EXPECT_EQ(defuseKitOutlineGlow.hue(), GetParam());
}

static_assert(outline_glow_vars::DefuseKitHue::ValueType::kMin == 0, "Update the test below");
INSTANTIATE_TEST_SUITE_P(MinConfigVar, DefuseKitOutlineGlowHueTest, testing::Values(0));

static_assert(outline_glow_vars::DefuseKitHue::ValueType::kMax == 359, "Update the test below");
INSTANTIATE_TEST_SUITE_P(MaxConfigVar, DefuseKitOutlineGlowHueTest, testing::Values(359));

static_assert(outline_glow_vars::DefuseKitHue::kDefaultValue == color::HueInteger{184}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVar, DefuseKitOutlineGlowHueTest, testing::Values(184));
INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVar, DefuseKitOutlineGlowHueTest, testing::Values(222));

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/DroppedBombOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

#include <Features/Visuals/OutlineGlow/DroppedBombOutlineGlow/DroppedBombOutlineGlow.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>
#include <Utils/Optional.h>

class DroppedBombOutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockBaseEntity> mockBaseEntity;

    DroppedBombOutlineGlow<MockHookContext> droppedBombOutlineGlow{mockHookContext};
};

TEST_F(DroppedBombOutlineGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowDroppedBomb>(false);
    EXPECT_FALSE(droppedBombOutlineGlow.enabled());
}

TEST_F(DroppedBombOutlineGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowDroppedBomb>(true);
    EXPECT_TRUE(droppedBombOutlineGlow.enabled());
}

struct DroppedBombOutlineGlowConditionTestParam {
    Optional<bool> bombHasOwner{};
    bool expectGlowApplied{};
};

class DroppedBombOutlineGlowConditionTest
    : public DroppedBombOutlineGlowTest,
      public testing::WithParamInterface<DroppedBombOutlineGlowConditionTestParam> {
};

TEST_P(DroppedBombOutlineGlowConditionTest, ShouldApplyGlowWhenExpected) {
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(GetParam().bombHasOwner));
    EXPECT_EQ(droppedBombOutlineGlow.shouldApplyGlow(EntityTypeInfo{}, mockBaseEntity), GetParam().expectGlowApplied);
}

INSTANTIATE_TEST_SUITE_P(, DroppedBombOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<DroppedBombOutlineGlowConditionTestParam>({
        {.bombHasOwner{std::nullopt}, .expectGlowApplied = false},
        {.bombHasOwner{true}, .expectGlowApplied = false},
        {.bombHasOwner{false}, .expectGlowApplied = true}
    })
));

class DroppedBombOutlineGlowHueTest
    : public DroppedBombOutlineGlowTest,
      public testing::WithParamInterface<color::HueInteger> {
};

TEST_P(DroppedBombOutlineGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::DroppedBombHue>(outline_glow_vars::DroppedBombHue::ValueType{GetParam()});
    EXPECT_EQ(droppedBombOutlineGlow.hue(), GetParam());
}

static_assert(outline_glow_vars::DroppedBombHue::ValueType::kMin == 0, "Update the test below");
INSTANTIATE_TEST_SUITE_P(MinConfigVar, DroppedBombOutlineGlowHueTest, testing::Values(color::HueInteger{0}));

static_assert(outline_glow_vars::DroppedBombHue::ValueType::kMax == 359, "Update the test below");
INSTANTIATE_TEST_SUITE_P(MaxConfigVar, DroppedBombOutlineGlowHueTest, testing::Values(color::HueInteger{359}));

static_assert(outline_glow_vars::DroppedBombHue::kDefaultValue == color::HueInteger{60}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVar, DroppedBombOutlineGlowHueTest, testing::Values(color::HueInteger{60}));
INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVar, DroppedBombOutlineGlowHueTest, testing::Values(color::HueInteger{140}));

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/GrenadeProjectileOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockSmokeGrenadeProjectile.h>
#include <Mocks/MockHookContext.h>

#include <Features/Visuals/OutlineGlow/GrenadeProjectileOutlineGlow/GrenadeProjectileOutlineGlow.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>

class GrenadeProjectileOutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockBaseEntity> mockGrenadeProjectile;
    testing::StrictMock<MockSmokeGrenadeProjectile> mockSmokeGrenadeProjectile;

    GrenadeProjectileOutlineGlow<MockHookContext> grenadeProjectileOutlineGlow{mockHookContext};
};

struct GrenadeProjectileOutlineGlowHueTestParam {
    EntityTypeInfo entityTypeInfo{};
    std::size_t configVarIndex{};
    std::any configuredHue{};
    color::HueInteger::UnderlyingType expectedHue{};
};

class GrenadeProjectileOutlineGlowHueTest
    : public GrenadeProjectileOutlineGlowTest,
      public testing::WithParamInterface<GrenadeProjectileOutlineGlowHueTestParam> {
};

TEST_P(GrenadeProjectileOutlineGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    EXPECT_CALL(mockConfig, getVariable(GetParam().configVarIndex))
        .WillOnce(testing::Return(GetParam().configuredHue));

    const auto hue = grenadeProjectileOutlineGlow.hue(GetParam().entityTypeInfo, mockGrenadeProjectile);
    ASSERT_TRUE(hue.hasValue());
    EXPECT_EQ(hue.value(), GetParam().expectedHue);
}

static_assert(outline_glow_vars::FlashbangHue::ValueType::kMin == 191, "Update the test below");
static_assert(outline_glow_vars::HEGrenadeHue::ValueType::kMin == 300, "Update the test below");
static_assert(outline_glow_vars::MolotovHue::ValueType::kMin == 20, "Update the test below");
static_assert(outline_glow_vars::SmokeGrenadeHue::ValueType::kMin == 110, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, GrenadeProjectileOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{191}}},
            .expectedHue = 191
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{300}}},
            .expectedHue = 300
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 20
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{110}}},
            .expectedHue = 110
        }
    })
));

static_assert(outline_glow_vars::FlashbangHue::ValueType::kMax == 250, "Update the test below");
static_assert(outline_glow_vars::HEGrenadeHue::ValueType::kMax == 359, "Update the test below");
static_assert(outline_glow_vars::MolotovHue::ValueType::kMax == 60, "Update the test below");
static_assert(outline_glow_vars::SmokeGrenadeHue::ValueType::kMax == 140, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, GrenadeProjectileOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{250}}},
            .expectedHue = 250
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = 359
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 60
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{140}}},
            .expectedHue = 140
        }
    })
));

static_assert(outline_glow_vars::FlashbangHue::kDefaultValue == color::HueInteger{219}, "Update the tests below");
static_assert(outline_glow_vars::HEGrenadeHue::kDefaultValue == color::HueInteger{359}, "Update the tests below");
static_assert(outline_glow_vars::MolotovHue::kDefaultValue == color::HueInteger{40}, "Update the tests below");
static_assert(outline_glow_vars::SmokeGrenadeHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, GrenadeProjectileOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{219}}},
            .expectedHue = 219
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = 359
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{40}}},
            .expectedHue = 40
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{120}}},
            .expectedHue = 120
        }
    })
));

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, GrenadeProjectileOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{222}}},
            .expectedHue = 222
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{333}}},
            .expectedHue = 333
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{55}}},
            .expectedHue = 55
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{111}}},
            .expectedHue = 111
        }
    })
));

struct GrenadeProjectileOutlineGlowConditionTestParam {
    EntityTypeInfo entityTypeInfo{};
    bool expectSmokeGrenadeCheck{};
    Optional<bool> didSmokeEffect{};
    bool expectGlowApplied{};
};

class GrenadeProjectileOutlineGlowConditionTest
    : public GrenadeProjectileOutlineGlowTest,
      public testing::WithParamInterface<GrenadeProjectileOutlineGlowConditionTestParam> {
};

TEST_P(GrenadeProjectileOutlineGlowConditionTest, GlowIsAppliedAsExpected) {
    if (GetParam().expectSmokeGrenadeCheck) {
        EXPECT_CALL(mockGrenadeProjectile, asSmokeGrenadeProjectile()).WillOnce(testing::ReturnRef(mockSmokeGrenadeProjectile));
        EXPECT_CALL(mockSmokeGrenadeProjectile, didSmokeEffect()).WillOnce(testing::Return(GetParam().didSmokeEffect));
    }

    EXPECT_EQ(grenadeProjectileOutlineGlow.shouldApplyGlow(GetParam().entityTypeInfo, mockGrenadeProjectile), GetParam().expectGlowApplied);
}

INSTANTIATE_TEST_SUITE_P(, GrenadeProjectileOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<GrenadeProjectileOutlineGlowConditionTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()},
            .expectGlowApplied = true
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenadeProjectile>()},
            .expectGlowApplied = true
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovProjectile>()},
            .expectGlowApplied = true
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .expectSmokeGrenadeCheck = true,
            .didSmokeEffect{std::nullopt},
            .expectGlowApplied = true
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .expectSmokeGrenadeCheck = true,
            .didSmokeEffect{false},
            .expectGlowApplied = true
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenadeProjectile>()},
            .expectSmokeGrenadeCheck = true,
            .didSmokeEffect{true},
            .expectGlowApplied = false
        }
    })
));

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/HostageOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

#include <Features/Visuals/OutlineGlow/HostageOutlineGlow/HostageOutlineGlow.h>

class HostageOutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockBaseEntity> mockBaseEntity;

    HostageOutlineGlow<MockHookContext> hostageOutlineGlow{mockHookContext};
};

TEST_F(HostageOutlineGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowHostages>(false);
    EXPECT_FALSE(hostageOutlineGlow.enabled());
}

TEST_F(HostageOutlineGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowHostages>(true);
    EXPECT_TRUE(hostageOutlineGlow.enabled());
}

class HostageOutlineGlowHueTest
    : public HostageOutlineGlowTest,
      public testing::WithParamInterface<color::HueInteger> {
};

TEST_P(HostageOutlineGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::HostageHue>(outline_glow_vars::HostageHue::ValueType{GetParam()});
    EXPECT_EQ(hostageOutlineGlow.hue(), GetParam());
}

static_assert(outline_glow_vars::HostageHue::kDefaultValue == color::HueInteger{50}, "Update the test below");
static_assert(outline_glow_vars::HostageHue::ValueType::kMin == 0, "Update the test below");
static_assert(outline_glow_vars::HostageHue::ValueType::kMax == 359, "Update the test below");

INSTANTIATE_TEST_SUITE_P(, HostageOutlineGlowHueTest, testing::Values(
    color::HueInteger{0},
    color::HueInteger{50},
    color::HueInteger{70},
    color::HueInteger{359}
));

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/OutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/OutlineGlow/OutlineGlow.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockGlowProperty.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockModelEntity.h>
#include <Mocks/MockPlayerController.h>
#include <Mocks/MockSmokeGrenadeProjectile.h>

class OutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockBaseEntity> mockBaseEntity;
    testing::StrictMock<MockModelEntity> mockModelEntity;
    testing::StrictMock<MockGlowProperty> mockGlowProperty;
    testing::StrictMock<MockPlayerPawn> mockPlayerPawn;
    testing::StrictMock<MockPlantedC4> mockPlantedC4;
    OutlineGlow<MockHookContext> outlineGlow{mockHookContext};
};

struct OutlineGlowInactiveTestParam {
    bool outlineGlowEnabled{};
    bool glowEnabled{};
    bool isGlowAppliedByTheGame{false};
};

class OutlineGlowInactiveTest
    : public OutlineGlowTest,
      public testing::WithParamInterface<OutlineGlowInactiveTestParam> {
protected:
    OutlineGlowInactiveTest()
    {
        EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
        mockConfig.expectGetVariable<outline_glow_vars::Enabled>().WillRepeatedly(testing::Return(GetParam().outlineGlowEnabled));
        if (GetParam().isGlowAppliedByTheGame) {
            EXPECT_CALL(mockBaseEntity, asModelEntity()).WillRepeatedly(testing::ReturnRef(mockModelEntity));
            EXPECT_CALL(mockModelEntity, glowProperty()).WillOnce(testing::ReturnRef(mockGlowProperty));
            EXPECT_CALL(mockGlowProperty, isGlowing()).WillOnce(testing::Return(true));
        }
    }
};

TEST_P(OutlineGlowInactiveTest, DefuseKit) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowDefuseKits>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(DefuseKitOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CBaseAnimGraph>()});
}

TEST_P(OutlineGlowInactiveTest, DroppedBomb) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowDroppedBomb>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(DroppedBombOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_C4>()});
}

TEST_P(OutlineGlowInactiveTest, GrenadeProjectile) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowGrenadeProjectiles>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(GrenadeProjectileOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()});
}

TEST_P(OutlineGlowInactiveTest, Hostage) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowHostages>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(HostageOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Hostage>()});
}

TEST_P(OutlineGlowInactiveTest, Player) {
    EXPECT_CALL(mockPlayerPawn, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));

    mockConfig.expectGetVariable<outline_glow_vars::GlowPlayers>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(PlayerOutlineGlow{mockHookContext}, mockPlayerPawn, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_P(OutlineGlowInactiveTest, TickingBomb) {
    EXPECT_CALL(mockPlantedC4, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));

    mockConfig.expectGetVariable<outline_glow_vars::GlowTickingBomb>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(TickingBombOutlineGlow{mockHookContext}, mockPlantedC4, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CPlantedC4>()});
}

TEST_P(OutlineGlowInactiveTest, Weapon) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowWeapons>().WillRepeatedly(testing::Return(GetParam().glowEnabled));
    outlineGlow.applyGlow()(WeaponOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_DEagle>()});
}

INSTANTIATE_TEST_SUITE_P(, OutlineGlowInactiveTest, testing::ValuesIn(
    std::to_array<OutlineGlowInactiveTestParam>({
        {.outlineGlowEnabled = false, .glowEnabled = false},
        {.outlineGlowEnabled = true, .glowEnabled = false},
        {.outlineGlowEnabled = false, .glowEnabled = true},
        {.outlineGlowEnabled = true, .glowEnabled = true, .isGlowAppliedByTheGame = true}
    })
));

class OutlineGlowActiveTest : public OutlineGlowTest {
protected:
    OutlineGlowActiveTest()
    {
        EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
        mockConfig.expectGetVariable<outline_glow_vars::Enabled>(true);
        EXPECT_CALL(mockBaseEntity, asModelEntity()).WillOnce(testing::ReturnRef(mockModelEntity));
        EXPECT_CALL(mockModelEntity, glowProperty()).WillOnce(testing::ReturnRef(mockGlowProperty));
        EXPECT_CALL(mockGlowProperty, isGlowing()).WillOnce(testing::Return(false));
    }
};

TEST_F(OutlineGlowActiveTest, DefuseKit) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowDefuseKits>(true);
    mockConfig.expectGetVariable<outline_glow_vars::DefuseKitHue>(outline_glow_vars::DefuseKitHue::ValueType{color::HueInteger{190}});
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{127, 233, 255, outline_glow_params::kGlowAlpha}, outline_glow_params::kDefuseKitGlowRange));
    outlineGlow.applyGlow()(DefuseKitOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CBaseAnimGraph>()});
}

TEST_F(OutlineGlowActiveTest, DroppedBomb) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowDroppedBomb>(true);
    mockConfig.expectGetVariable<outline_glow_vars::DroppedBombHue>(outline_glow_vars::DroppedBombHue::ValueType{color::HueInteger{102}});
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{165, 255, 127, outline_glow_params::kGlowAlpha}, 0));
    outlineGlow.applyGlow()(DroppedBombOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_C4>()});
}

TEST_F(OutlineGlowActiveTest, GrenadeProjectile) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowGrenadeProjectiles>(true);
    mockConfig.expectGetVariable<outline_glow_vars::FlashbangHue>(outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{240}});
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{127, 127, 255, outline_glow_params::kGlowAlpha}, 0));
    outlineGlow.applyGlow()(GrenadeProjectileOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_FlashbangProjectile>()});
}

TEST_F(OutlineGlowActiveTest, Hostage) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowHostages>(true);
    mockConfig.expectGetVariable<outline_glow_vars::HostageHue>(outline_glow_vars::HostageHue::ValueType{color::HueInteger{50}});
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{255, 233, 127, outline_glow_params::kGlowAlpha}, 0));
    outlineGlow.applyGlow()(HostageOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Hostage>()});
}

TEST_F(OutlineGlowActiveTest, Player) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowPlayers>(true);
    mockConfig.expectGetVariable<outline_glow_vars::GlowOnlyEnemies>(false);
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::TeamColor);
    mockConfig.expectGetVariable<outline_glow_vars::TeamTHue>(outline_glow_vars::TeamTHue::ValueType{color::HueInteger{36}});

    EXPECT_CALL(mockPlayerPawn, isAlive()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(100));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockPlayerPawn, teamNumber()).WillOnce(testing::Return(TeamNumber::TT));

    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{255, 204, 127, outline_glow_params::kGlowAlpha}, 0));
    outlineGlow.applyGlow()(PlayerOutlineGlow{mockHookContext}, mockPlayerPawn, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_F(OutlineGlowActiveTest, TickingBomb) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowTickingBomb>(true);
    mockConfig.expectGetVariable<outline_glow_vars::TickingBombHue>(outline_glow_vars::TickingBombHue::ValueType{color::HueInteger{87}});
    EXPECT_CALL(mockPlantedC4, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));
    EXPECT_CALL(mockPlantedC4, isTicking()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{197, 255, 127, outline_glow_params::kGlowAlpha}, 0));
    outlineGlow.applyGlow()(TickingBombOutlineGlow{mockHookContext}, mockPlantedC4, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CPlantedC4>()});
}

TEST_F(OutlineGlowActiveTest, Weapon) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowWeapons>(true);
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(outline_glow_params::kFallbackColor, outline_glow_params::kWeaponGlowRange));
    outlineGlow.applyGlow()(WeaponOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_DEagle>()});
}

class OutlineGlowNonDefaultAlphaTest : public OutlineGlowActiveTest {
};

TEST_F(OutlineGlowNonDefaultAlphaTest, ImmunePlayerHasCorrectAlpha) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowPlayers>(true);
    mockConfig.expectGetVariable<outline_glow_vars::GlowOnlyEnemies>(true);
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::EnemyAlly);
    mockConfig.expectGetVariable<outline_glow_vars::EnemyHue>(outline_glow_vars::EnemyHue::ValueType{color::HueInteger{120}});

    EXPECT_CALL(mockPlayerPawn, isAlive()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(100));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, isEnemy()).Times(2).WillRepeatedly(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));

    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{127, 255, 127, outline_glow_params::kImmunePlayerGlowAlpha}, 0));
    outlineGlow.applyGlow()(PlayerOutlineGlow{mockHookContext}, mockPlayerPawn, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

TEST_F(OutlineGlowNonDefaultAlphaTest, ImmunePlayerHasCorrectFallbackColorAlpha) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowPlayers>(true);
    mockConfig.expectGetVariable<outline_glow_vars::GlowOnlyEnemies>(true);
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::EnemyAlly);
 
    EXPECT_CALL(mockPlayerPawn, isAlive()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(100));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, isEnemy()).Times(2).WillRepeatedly(testing::Return(std::nullopt));
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(true));
    EXPECT_CALL(mockPlayerPawn, baseEntity()).WillRepeatedly(testing::ReturnRef(mockBaseEntity));

    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{191, 191, 191, outline_glow_params::kImmunePlayerGlowAlpha}, 0));
    outlineGlow.applyGlow()(PlayerOutlineGlow{mockHookContext}, mockPlayerPawn, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_CSPlayerPawn>()});
}

class OutlineGlowNonDefaultRangeTest : public OutlineGlowActiveTest {
};

TEST_F(OutlineGlowNonDefaultRangeTest, NonDefaultGlowRangeIsUsedForDefuseKits) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowDefuseKits>(true);
    mockConfig.expectGetVariable<outline_glow_vars::DefuseKitHue>(outline_glow_vars::DefuseKitHue::ValueType{color::HueInteger{188}});

    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{127, 238, 255, outline_glow_params::kGlowAlpha}, outline_glow_params::kDefuseKitGlowRange));
    outlineGlow.applyGlow()(DefuseKitOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::CBaseAnimGraph>()});
}

TEST_F(OutlineGlowNonDefaultRangeTest, NonDefaultGlowRangeIsUsedForWeapons) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowWeapons>(true);
    mockConfig.expectGetVariable<outline_glow_vars::MolotovHue>(outline_glow_vars::MolotovHue::ValueType{color::HueInteger{50}});

    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(false));
    EXPECT_CALL(mockBaseEntity, applyGlowRecursively(cs2::Color{255, 233, 127, outline_glow_params::kGlowAlpha}, outline_glow_params::kWeaponGlowRange));
    outlineGlow.applyGlow()(WeaponOutlineGlow{mockHookContext}, mockBaseEntity, EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()});
}

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/PlayerOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/OutlineGlow/PlayerOutlineGlow/PlayerOutlineGlow.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPlayerController.h>
#include <Mocks/MockPlayerPawn.h>

class PlayerOutlineGlowTest : public testing::Test {
protected:
    PlayerOutlineGlowTest()
    {
        EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
    }

    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockPlayerPawn> mockPlayerPawn;
    testing::StrictMock<MockPlayerController> mockPlayerController;

    PlayerOutlineGlow<MockHookContext> playerOutlineGlow{mockHookContext};
};

TEST_F(PlayerOutlineGlowTest, Disabled) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowPlayers>(false);
    EXPECT_FALSE(playerOutlineGlow.enabled());
}

TEST_F(PlayerOutlineGlowTest, Enabled) {
    mockConfig.expectGetVariable<outline_glow_vars::GlowPlayers>(true);
    EXPECT_TRUE(playerOutlineGlow.enabled());
}

struct PlayerOutlineGlowConditionTestParam {
    bool onlyEnemies{true};
    std::optional<bool> isAlive{true};
    Optional<int> health{100};
    bool isControlledByLocalPlayer{false};
    bool isTTorCT{true};
    std::optional<bool> isEnemy{true};
    bool expectEnemyCheck{true};
    bool expectGlowApplied{true};
};

class PlayerOutlineGlowConditionTest
    : public PlayerOutlineGlowTest,
      public testing::WithParamInterface<PlayerOutlineGlowConditionTestParam> {
};

TEST_P(PlayerOutlineGlowConditionTest, GlowIsAppliedWhenExpected) {
    EXPECT_CALL(mockConfig, getVariable(ConfigVariableTypes::indexOf<outline_glow_vars::GlowOnlyEnemies>()))
        .WillRepeatedly(testing::Return(GetParam().onlyEnemies));

    EXPECT_CALL(mockPlayerPawn, isAlive()).WillRepeatedly(testing::Return(GetParam().isAlive));
    EXPECT_CALL(mockPlayerPawn, health()).WillRepeatedly(testing::Return(GetParam().health));
    EXPECT_CALL(mockPlayerPawn, isControlledByLocalPlayer()).WillRepeatedly(testing::Return(GetParam().isControlledByLocalPlayer));
    EXPECT_CALL(mockPlayerPawn, isTTorCT()).WillRepeatedly(testing::Return(GetParam().isTTorCT));

    if (GetParam().expectEnemyCheck)
        EXPECT_CALL(mockPlayerPawn, isEnemy()).WillRepeatedly(testing::Return(GetParam().isEnemy));

    EXPECT_EQ(playerOutlineGlow.shouldApplyGlow(EntityTypeInfo{}, mockPlayerPawn), GetParam().expectGlowApplied);
}

INSTANTIATE_TEST_SUITE_P(OnlyEnemies, PlayerOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<PlayerOutlineGlowConditionTestParam>({
        {
            .onlyEnemies = true,
            .isEnemy{true},
            .expectEnemyCheck = true,
            .expectGlowApplied = true
        },
        {
            .onlyEnemies = true,
            .isEnemy{false},
            .expectEnemyCheck = true,
            .expectGlowApplied = false
        },
        {
            .onlyEnemies = true,
            .isEnemy{std::nullopt},
            .expectEnemyCheck = true,
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(NotOnlyEnemies, PlayerOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<PlayerOutlineGlowConditionTestParam>({
        {
            .onlyEnemies = false,
            .isEnemy{true},
            .expectEnemyCheck = false,
            .expectGlowApplied = true
        },
        {
            .onlyEnemies = false,
            .isEnemy{false},
            .expectEnemyCheck = false,
            .expectGlowApplied = true
        },
        {
            .onlyEnemies = false,
            .isEnemy{std::nullopt},
            .expectEnemyCheck = false,
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(IsAlive, PlayerOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<PlayerOutlineGlowConditionTestParam>({
        {
            .isAlive{true},
            .expectGlowApplied = true
        },
        {
            .isAlive{false},
            .expectGlowApplied = false
        },
        {
            .isAlive{std::nullopt},
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(Health, PlayerOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<PlayerOutlineGlowConditionTestParam>({
        {
            .health{100},
            .expectGlowApplied = true
        },
        {
            .health{120},
            .expectGlowApplied = true
        },
        {
            .health{0},
            .expectGlowApplied = false
        },
        {
            .health{std::nullopt},
            .expectGlowApplied = true
        }
    })
));

INSTANTIATE_TEST_SUITE_P(IsControlledByLocalPlayer, PlayerOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<PlayerOutlineGlowConditionTestParam>({
        {
            .isControlledByLocalPlayer = false,
            .expectGlowApplied = true
        },
        {
            .isControlledByLocalPlayer = true,
            .expectGlowApplied = false
        }
    })
));

INSTANTIATE_TEST_SUITE_P(IsTTorCT, PlayerOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<PlayerOutlineGlowConditionTestParam>({
        {
            .isTTorCT = true,
            .expectGlowApplied = true
        },
        {
            .isTTorCT = false,
            .expectGlowApplied = false
        }
    })
));

struct PlayerOutlineGlowHealthBasedHueConfigVariables {
    color::HueInteger::UnderlyingType lowHealthHue;
    color::HueInteger::UnderlyingType highHealthHue;
};

struct PlayerOutlineGlowHealthBasedHueParam {
    Optional<int> health{100};
    Optional<color::Hue::ValueType> expectedHue{};
};

class PlayerOutlineGlowHealthBasedHueTest :
    public PlayerOutlineGlowTest,
    public testing::WithParamInterface<std::tuple<PlayerOutlineGlowHealthBasedHueConfigVariables, PlayerOutlineGlowHealthBasedHueParam>> {
};

TEST_P(PlayerOutlineGlowHealthBasedHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::HealthBased);

    const auto [configVariables, param] = GetParam();
    EXPECT_CALL(mockConfig, getVariable(ConfigVariableTypes::indexOf<outline_glow_vars::LowHealthHue>()))
        .WillRepeatedly(testing::Return(outline_glow_vars::LowHealthHue::ValueType{color::HueInteger{configVariables.lowHealthHue}}));
    EXPECT_CALL(mockConfig, getVariable(ConfigVariableTypes::indexOf<outline_glow_vars::HighHealthHue>()))
        .WillRepeatedly(testing::Return(outline_glow_vars::HighHealthHue::ValueType{color::HueInteger{configVariables.highHealthHue}}));
    EXPECT_CALL(mockPlayerPawn, health()).WillOnce(testing::Return(param.health));

    const auto hue = playerOutlineGlow.hue(EntityTypeInfo{}, mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), param.expectedHue.hasValue());
    if (hue.hasValue() && param.expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), param.expectedHue.value());
}

static_assert(outline_glow_vars::LowHealthHue::ValueType::kMin == 0, "Update the tests below");
static_assert(outline_glow_vars::LowHealthHue::ValueType::kMax == 359, "Update the tests below");
static_assert(outline_glow_vars::HighHealthHue::ValueType::kMin == 0, "Update the tests below");
static_assert(outline_glow_vars::HighHealthHue::ValueType::kMax == 359, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(MinMax, PlayerOutlineGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerOutlineGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 0,
        .highHealthHue = 359}),
    testing::ValuesIn(std::to_array<PlayerOutlineGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.0f}},
        {.health{1}, .expectedHue{0.0f}},
        {.health{25}, .expectedHue{0.2417508f}},
        {.health{75}, .expectedHue{0.7453984f}},
        {.health{100}, .expectedHue{0.997222f}},
        {.health{120}, .expectedHue{0.997222f}}}))
));

INSTANTIATE_TEST_SUITE_P(MaxMin, PlayerOutlineGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerOutlineGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 359,
        .highHealthHue = 0}),
    testing::ValuesIn(std::to_array<PlayerOutlineGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.997222f}},
        {.health{1}, .expectedHue{0.997222f}},
        {.health{25}, .expectedHue{0.75547138f}},
        {.health{75}, .expectedHue{0.25182379f}},
        {.health{100}, .expectedHue{0.0f}},
        {.health{120}, .expectedHue{0.0f}}
    }))
));

INSTANTIATE_TEST_SUITE_P(MinMin, PlayerOutlineGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerOutlineGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 0,
        .highHealthHue = 0}),
    testing::ValuesIn(std::to_array<PlayerOutlineGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.0f}},
        {.health{1}, .expectedHue{0.0f}},
        {.health{25}, .expectedHue{0.0f}},
        {.health{75}, .expectedHue{0.0f}},
        {.health{100}, .expectedHue{0.0f}},
        {.health{120}, .expectedHue{0.0f}}
    }))
));

INSTANTIATE_TEST_SUITE_P(MaxMax, PlayerOutlineGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerOutlineGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 359,
        .highHealthHue = 359}),
    testing::ValuesIn(std::to_array<PlayerOutlineGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.997222f}},
        {.health{1}, .expectedHue{0.997222f}},
        {.health{25}, .expectedHue{0.997222f}},
        {.health{75}, .expectedHue{0.997222f}},
        {.health{100}, .expectedHue{0.997222f}},
        {.health{120}, .expectedHue{0.997222f}}
    }))
));

static_assert(outline_glow_vars::LowHealthHue::kDefaultValue == color::HueInteger{0}, "Update the tests below");
static_assert(outline_glow_vars::HighHealthHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(Default, PlayerOutlineGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerOutlineGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 0,
        .highHealthHue = 120}),
    testing::ValuesIn(std::to_array<PlayerOutlineGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.0f}},
        {.health{1}, .expectedHue{0.0f}},
        {.health{25}, .expectedHue{0.08080808f}},
        {.health{75}, .expectedHue{0.24915824f}},
        {.health{100}, .expectedHue{0.33333333f}},
        {.health{120}, .expectedHue{0.33333333f}}
    }))
));

INSTANTIATE_TEST_SUITE_P(NonDefault, PlayerOutlineGlowHealthBasedHueTest, testing::Combine(
    testing::Values(PlayerOutlineGlowHealthBasedHueConfigVariables{
        .lowHealthHue = 220,
        .highHealthHue = 280}),
    testing::ValuesIn(std::to_array<PlayerOutlineGlowHealthBasedHueParam>({
        {.health{std::nullopt}, .expectedHue{std::nullopt}},
        {.health{0}, .expectedHue{0.61111111f}},
        {.health{1}, .expectedHue{0.61111111f}},
        {.health{25}, .expectedHue{0.65151515f}},
        {.health{75}, .expectedHue{0.73569023f}},
        {.health{100}, .expectedHue{0.77777777f}},
        {.health{120}, .expectedHue{0.77777777f}}
    }))
));

struct PlayerOutlineGlowPlayerColorIndexHueTestParam {
    cs2::CCSPlayerController::m_iCompTeammateColor playerColorIndex{};
    std::size_t configVariableIndex{};
    std::any configuredHue{};
    color::Hue::ValueType expectedHue{};
};

class PlayerOutlineGlowPlayerColorIndexHueTest
    : public PlayerOutlineGlowTest,
      public testing::WithParamInterface<PlayerOutlineGlowPlayerColorIndexHueTestParam> {
};

TEST_P(PlayerOutlineGlowPlayerColorIndexHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::PlayerOrTeamColor);

    EXPECT_CALL(mockConfig, getVariable(GetParam().configVariableIndex))
        .WillRepeatedly(testing::Return(GetParam().configuredHue));

    EXPECT_CALL(mockPlayerPawn, playerController()).WillOnce(testing::ReturnRef(mockPlayerController));
    EXPECT_CALL(mockPlayerController, playerColorIndex()).WillOnce(testing::Return(GetParam().playerColorIndex));

    const auto hue = playerOutlineGlow.hue(EntityTypeInfo{}, mockPlayerPawn);
    ASSERT_TRUE(hue.hasValue());
    EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue);
}

static_assert(outline_glow_vars::PlayerBlueHue::ValueType::kMin == 191, "Update the test below");
static_assert(outline_glow_vars::PlayerGreenHue::ValueType::kMin == 110, "Update the test below");
static_assert(outline_glow_vars::PlayerYellowHue::ValueType::kMin == 47, "Update the test below");
static_assert(outline_glow_vars::PlayerOrangeHue::ValueType::kMin == 11, "Update the test below");
static_assert(outline_glow_vars::PlayerPurpleHue::ValueType::kMin == 250, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, PlayerOutlineGlowPlayerColorIndexHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowPlayerColorIndexHueTestParam>({
        {
            .playerColorIndex = cs2::PlayerColorIndex::Blue,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerBlueHue>(),
            .configuredHue{outline_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{191}}},
            .expectedHue = 0.53055555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Green,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerGreenHue>(),
            .configuredHue{outline_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{110}}},
            .expectedHue = 0.30555555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Yellow,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerYellowHue>(),
            .configuredHue{outline_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{47}}},
            .expectedHue = 0.13055555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Orange,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerOrangeHue>(),
            .configuredHue{outline_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{11}}},
            .expectedHue = 0.03055555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Purple,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerPurpleHue>(),
            .configuredHue{outline_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{250}}},
            .expectedHue = 0.69444444f
        }
    })
));

static_assert(outline_glow_vars::PlayerBlueHue::ValueType::kMax == 240, "Update the test below");
static_assert(outline_glow_vars::PlayerGreenHue::ValueType::kMax == 140, "Update the test below");
static_assert(outline_glow_vars::PlayerYellowHue::ValueType::kMax == 60, "Update the test below");
static_assert(outline_glow_vars::PlayerOrangeHue::ValueType::kMax == 20, "Update the test below");
static_assert(outline_glow_vars::PlayerPurpleHue::ValueType::kMax == 280, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, PlayerOutlineGlowPlayerColorIndexHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowPlayerColorIndexHueTestParam>({
        {
            .playerColorIndex = cs2::PlayerColorIndex::Blue,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerBlueHue>(),
            .configuredHue{outline_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{240}}},
            .expectedHue = 0.66666666f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Green,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerGreenHue>(),
            .configuredHue{outline_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{140}}},
            .expectedHue = 0.38888888f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Yellow,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerYellowHue>(),
            .configuredHue{outline_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 0.16666666f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Orange,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerOrangeHue>(),
            .configuredHue{outline_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 0.05555555f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Purple,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerPurpleHue>(),
            .configuredHue{outline_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{280}}},
            .expectedHue = 0.77777777f
        }
    })
));

static_assert(outline_glow_vars::PlayerBlueHue::kDefaultValue == color::HueInteger{215}, "Update the test below");
static_assert(outline_glow_vars::PlayerGreenHue::kDefaultValue == color::HueInteger{125}, "Update the test below");
static_assert(outline_glow_vars::PlayerYellowHue::kDefaultValue == color::HueInteger{53}, "Update the test below");
static_assert(outline_glow_vars::PlayerOrangeHue::kDefaultValue == color::HueInteger{15}, "Update the test below");
static_assert(outline_glow_vars::PlayerPurpleHue::kDefaultValue == color::HueInteger{265}, "Update the test below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, PlayerOutlineGlowPlayerColorIndexHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowPlayerColorIndexHueTestParam>({
        {
            .playerColorIndex = cs2::PlayerColorIndex::Blue,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerBlueHue>(),
            .configuredHue{outline_glow_vars::PlayerBlueHue::ValueType{color::HueInteger{215}}},
            .expectedHue = 0.59722222f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Green,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerGreenHue>(),
            .configuredHue{outline_glow_vars::PlayerGreenHue::ValueType{color::HueInteger{125}}},
            .expectedHue = 0.34722222f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Yellow,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerYellowHue>(),
            .configuredHue{outline_glow_vars::PlayerYellowHue::ValueType{color::HueInteger{53}}},
            .expectedHue = 0.14722222f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Orange,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerOrangeHue>(),
            .configuredHue{outline_glow_vars::PlayerOrangeHue::ValueType{color::HueInteger{15}}},
            .expectedHue = 0.04166666f
        },
        {
            .playerColorIndex = cs2::PlayerColorIndex::Purple,
            .configVariableIndex = ConfigVariableTypes::indexOf<outline_glow_vars::PlayerPurpleHue>(),
            .configuredHue{outline_glow_vars::PlayerPurpleHue::ValueType{color::HueInteger{265}}},
            .expectedHue = 0.73611111f
        }
    })
));

struct PlayerOutlineGlowTeamHueTestParam {
    TeamNumber teamNumber{};
    Optional<color::HueInteger::UnderlyingType> teamTHue{};
    Optional<color::HueInteger::UnderlyingType> teamCTHue{};
    Optional<color::Hue::ValueType> expectedHue{};
};

class PlayerOutlineGlowTeamHueTest
    : public PlayerOutlineGlowTest,
      public testing::WithParamInterface<PlayerOutlineGlowTeamHueTestParam> {
};

TEST_P(PlayerOutlineGlowTeamHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::TeamColor);

    if (GetParam().teamTHue.hasValue())
        mockConfig.expectGetVariable<outline_glow_vars::TeamTHue>(outline_glow_vars::TeamTHue::ValueType{color::HueInteger{GetParam().teamTHue.value()}});

    if (GetParam().teamCTHue.hasValue())
        mockConfig.expectGetVariable<outline_glow_vars::TeamCTHue>(outline_glow_vars::TeamCTHue::ValueType{color::HueInteger{GetParam().teamCTHue.value()}});

    EXPECT_CALL(mockPlayerPawn, teamNumber()).WillRepeatedly(testing::Return(GetParam().teamNumber));

    const auto hue = playerOutlineGlow.hue(EntityTypeInfo{}, mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), GetParam().expectedHue.hasValue());
    if (hue.hasValue() && GetParam().expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue.value());
}

TEST_P(PlayerOutlineGlowTeamHueTest, CorrectHueIsReturnedAsFallbackWhenInvalidPlayerColorIndex) {
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::PlayerOrTeamColor);

    if (GetParam().teamTHue.hasValue())
        mockConfig.expectGetVariable<outline_glow_vars::TeamTHue>(outline_glow_vars::TeamTHue::ValueType{color::HueInteger{GetParam().teamTHue.value()}});

    if (GetParam().teamCTHue.hasValue())
        mockConfig.expectGetVariable<outline_glow_vars::TeamCTHue>(outline_glow_vars::TeamCTHue::ValueType{color::HueInteger{GetParam().teamCTHue.value()}});

    EXPECT_CALL(mockPlayerPawn, teamNumber()).WillRepeatedly(testing::Return(GetParam().teamNumber));
    EXPECT_CALL(mockPlayerPawn, playerController()).WillRepeatedly(testing::ReturnRef(mockPlayerController));
    EXPECT_CALL(mockPlayerController, playerColorIndex()).WillRepeatedly(testing::Return(cs2::PlayerColorIndex{-1}));

    const auto hue = playerOutlineGlow.hue(EntityTypeInfo{}, mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), GetParam().expectedHue.hasValue());
    if (hue.hasValue() && GetParam().expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue.value());
}

INSTANTIATE_TEST_SUITE_P(InvalidTeam, PlayerOutlineGlowTeamHueTest,
    testing::Values(PlayerOutlineGlowTeamHueTestParam{.teamNumber{}, .expectedHue{std::nullopt}}));

static_assert(outline_glow_vars::TeamTHue::ValueType::kMin == 30, "Update the test below");
static_assert(outline_glow_vars::TeamCTHue::ValueType::kMin == 210, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, PlayerOutlineGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 30, .expectedHue{0.08333333f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 210, .expectedHue{0.58333333f}}
    }))
);

static_assert(outline_glow_vars::TeamTHue::ValueType::kMax == 40, "Update the test below");
static_assert(outline_glow_vars::TeamCTHue::ValueType::kMax == 230, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, PlayerOutlineGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 40, .expectedHue{0.11111111f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 230, .expectedHue{0.63888888f}}
    }))
);

static_assert(outline_glow_vars::TeamTHue::kDefaultValue == color::HueInteger{35}, "Update the tests below");
static_assert(outline_glow_vars::TeamCTHue::kDefaultValue == color::HueInteger{220}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, PlayerOutlineGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 35, .expectedHue{0.09722222f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 220, .expectedHue{0.61111111f}}
    }))
);

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, PlayerOutlineGlowTeamHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowTeamHueTestParam>({
        {.teamNumber = TeamNumber::TT, .teamTHue = 37, .expectedHue{0.10277777f}},
        {.teamNumber = TeamNumber::CT, .teamCTHue = 229, .expectedHue{0.63611111f}}
    }))
);

struct PlayerOutlineGlowEnemyHueTestParam {
    std::optional<bool> isEnemy;
    Optional<color::HueInteger::UnderlyingType> enemyHue{};
    Optional<color::HueInteger::UnderlyingType> allyHue{};
    Optional<color::Hue::ValueType> expectedHue{};
};

class PlayerOutlineGlowEnemyHueTest
    : public PlayerOutlineGlowTest,
      public testing::WithParamInterface<PlayerOutlineGlowEnemyHueTestParam> {
};

TEST_P(PlayerOutlineGlowEnemyHueTest, CorrectHueIsReturned) {
    mockConfig.expectGetVariable<outline_glow_vars::PlayerGlowColorMode>(PlayerOutlineGlowColorType::EnemyAlly);

    if (GetParam().enemyHue.hasValue())
        mockConfig.expectGetVariable<outline_glow_vars::EnemyHue>(outline_glow_vars::EnemyHue::ValueType{color::HueInteger{GetParam().enemyHue.value()}});
    if (GetParam().allyHue.hasValue())
        mockConfig.expectGetVariable<outline_glow_vars::AllyHue>(outline_glow_vars::AllyHue::ValueType{color::HueInteger{GetParam().allyHue.value()}});

    EXPECT_CALL(mockPlayerPawn, isEnemy()).WillOnce(testing::Return(GetParam().isEnemy));

    const auto hue = playerOutlineGlow.hue(EntityTypeInfo{}, mockPlayerPawn);
    EXPECT_EQ(hue.hasValue(), GetParam().expectedHue.hasValue());
    if (hue.hasValue() && GetParam().expectedHue.hasValue())
        EXPECT_FLOAT_EQ(hue.value(), GetParam().expectedHue.value());
}

INSTANTIATE_TEST_SUITE_P(UnknownIfIsEnemy, PlayerOutlineGlowEnemyHueTest,
    testing::Values(PlayerOutlineGlowEnemyHueTestParam{.isEnemy{std::nullopt}, .expectedHue{std::nullopt}}));

static_assert(outline_glow_vars::EnemyHue::ValueType::kMin == 0, "Update the test below");
static_assert(outline_glow_vars::AllyHue::ValueType::kMin == 0, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, PlayerOutlineGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{0}, .expectedHue{0.0f}},
        {.isEnemy{false}, .allyHue{0}, .expectedHue{0.0f}}
    }))
);

static_assert(outline_glow_vars::EnemyHue::ValueType::kMax == 359, "Update the test below");
static_assert(outline_glow_vars::AllyHue::ValueType::kMax == 359, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, PlayerOutlineGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{359}, .expectedHue{0.99722222f}},
        {.isEnemy{false}, .allyHue{359}, .expectedHue{0.99722222f}}
    }))
);

static_assert(outline_glow_vars::EnemyHue::kDefaultValue == color::HueInteger{0}, "Update the tests below");
static_assert(outline_glow_vars::AllyHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, PlayerOutlineGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{0}, .expectedHue{0.0f}},
        {.isEnemy{false}, .allyHue{120}, .expectedHue{0.33333333f}}
    }))
);

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, PlayerOutlineGlowEnemyHueTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowEnemyHueTestParam>({
        {.isEnemy{true}, .enemyHue{123}, .expectedHue{0.34166666f}},
        {.isEnemy{false}, .allyHue{234}, .expectedHue{0.65f}}
    }))
);

struct PlayerOutlineGlowAlphaTestParam {
    Optional<bool> hasImmunity{};
    std::uint8_t expectedAlpha{};
};

class PlayerOutlineGlowAlphaTest
    : public PlayerOutlineGlowTest,
      public testing::WithParamInterface<PlayerOutlineGlowAlphaTestParam> {
};

TEST_P(PlayerOutlineGlowAlphaTest, CorrectGlowColorAlphaIsReturned) {
    EXPECT_CALL(mockPlayerPawn, hasImmunity()).WillOnce(testing::Return(GetParam().hasImmunity));
    EXPECT_EQ(playerOutlineGlow.getGlowColorAlpha(mockPlayerPawn), GetParam().expectedAlpha);
}

INSTANTIATE_TEST_SUITE_P(, PlayerOutlineGlowAlphaTest,
    testing::ValuesIn(std::to_array<PlayerOutlineGlowAlphaTestParam>({
        {.hasImmunity{std::nullopt}, .expectedAlpha = outline_glow_params::kGlowAlpha},
        {.hasImmunity{false}, .expectedAlpha = outline_glow_params::kGlowAlpha},
        {.hasImmunity{true}, .expectedAlpha = outline_glow_params::kImmunePlayerGlowAlpha}
    }))
);

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/TickingBombOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Features/Visuals/OutlineGlow/TickingBombOutlineGlow/TickingBombOutlineGlow.h>
#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPlantedC4.h>
#include <Utils/Optional.h>

class TickingBombOutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockPlantedC4> mockPlantedC4;

    TickingBombOutlineGlow<MockHookContext> tickingBombOutlineGlow{mockHookContext};
};

TEST_F(TickingBombOutlineGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowTickingBomb>(false);
    EXPECT_FALSE(tickingBombOutlineGlow.enabled());
}

TEST_F(TickingBombOutlineGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowTickingBomb>(true);
    EXPECT_TRUE(tickingBombOutlineGlow.enabled());
}

struct TickingBombOutlineGlowConditionTestParam {
    Optional<bool> isTicking{};
    bool expectGlowApplied{};
};

class TickingBombOutlineGlowConditionTest
    : public TickingBombOutlineGlowTest,
      public testing::WithParamInterface<TickingBombOutlineGlowConditionTestParam> {
};

TEST_P(TickingBombOutlineGlowConditionTest, ShouldApplyGlowWhenExpected) {
    EXPECT_CALL(mockPlantedC4, isTicking()).WillOnce(testing::Return(GetParam().isTicking));
    EXPECT_EQ(tickingBombOutlineGlow.shouldApplyGlow(EntityTypeInfo{}, mockPlantedC4), GetParam().expectGlowApplied);
}

INSTANTIATE_TEST_SUITE_P(, TickingBombOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<TickingBombOutlineGlowConditionTestParam>({
        {.isTicking{true}, .expectGlowApplied = true},
        {.isTicking{false}, .expectGlowApplied = false},
        {.isTicking{std::nullopt}, .expectGlowApplied = true}
    })
));

class TickingBombOutlineGlowHueTest
    : public TickingBombOutlineGlowTest,
      public testing::WithParamInterface<color::HueInteger> {
};

TEST_P(TickingBombOutlineGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::TickingBombHue>(outline_glow_vars::TickingBombHue::ValueType{color::HueInteger{GetParam()}});
    EXPECT_EQ(tickingBombOutlineGlow.hue(), GetParam());
}

static_assert(outline_glow_vars::TickingBombHue::ValueType::kMin == 0, "Update the test below");
INSTANTIATE_TEST_SUITE_P(MinConfigVar, TickingBombOutlineGlowHueTest, testing::Values(color::HueInteger{0}));

static_assert(outline_glow_vars::TickingBombHue::ValueType::kMax == 359, "Update the test below");
INSTANTIATE_TEST_SUITE_P(MaxConfigVar, TickingBombOutlineGlowHueTest, testing::Values(color::HueInteger{359}));

static_assert(outline_glow_vars::TickingBombHue::kDefaultValue == color::HueInteger{0}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVar, TickingBombOutlineGlowHueTest, testing::Values(color::HueInteger{0}));
INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVar, TickingBombOutlineGlowHueTest, testing::Values(color::HueInteger{123}));

```

`Tests/UnitTests/Features/Visuals/OutlineGlow/WeaponOutlineGlowTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>

#include <Features/Visuals/OutlineGlow/WeaponOutlineGlow/WeaponOutlineGlow.h>
#include <Features/Visuals/OutlineGlow/OutlineGlowConfigVariables.h>

class WeaponOutlineGlowTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext;
    testing::StrictMock<MockConfig> mockConfig;
    testing::StrictMock<MockBaseEntity> mockBaseEntity;

    WeaponOutlineGlow<MockHookContext> weaponOutlineGlow{mockHookContext};
};

TEST_F(WeaponOutlineGlowTest, Disabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowWeapons>(false);
    EXPECT_FALSE(weaponOutlineGlow.enabled());
}

TEST_F(WeaponOutlineGlowTest, Enabled) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<outline_glow_vars::GlowWeapons>(true);
    EXPECT_TRUE(weaponOutlineGlow.enabled());
}

TEST_F(WeaponOutlineGlowTest, CorrectGlowRangeIsReturned) {
    EXPECT_EQ(weaponOutlineGlow.getGlowRange(), outline_glow_params::kWeaponGlowRange);
}

TEST_F(WeaponOutlineGlowTest, NoHueIsReturnedWhenDefaultShouldBeUsed) {
    EXPECT_FALSE(weaponOutlineGlow.hue(EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_AK47>()}, mockBaseEntity).hasValue());
    EXPECT_FALSE(weaponOutlineGlow.hue(EntityTypeInfo{EntityTypeInfo::indexOf<cs2::C_WeaponAWP>()}, mockBaseEntity).hasValue());
    EXPECT_FALSE(weaponOutlineGlow.hue(EntityTypeInfo{}, mockBaseEntity).hasValue());
}

struct WeaponOutlineGlowConditionTestParam {
    Optional<bool> hasOwner{};
    bool expectGlowApplied{};
};

class WeaponOutlineGlowConditionTest
    : public WeaponOutlineGlowTest,
      public testing::WithParamInterface<WeaponOutlineGlowConditionTestParam> {
};

TEST_P(WeaponOutlineGlowConditionTest, GlowShouldBeAppliedWhenExpected) {
    EXPECT_CALL(mockBaseEntity, hasOwner()).WillOnce(testing::Return(GetParam().hasOwner));
    EXPECT_EQ(weaponOutlineGlow.shouldApplyGlow(EntityTypeInfo{}, mockBaseEntity), GetParam().expectGlowApplied);
}

INSTANTIATE_TEST_SUITE_P(, WeaponOutlineGlowConditionTest, testing::ValuesIn(
    std::to_array<WeaponOutlineGlowConditionTestParam>({
        {.hasOwner{true}, .expectGlowApplied = false},
        {.hasOwner{false}, .expectGlowApplied = true},
        {.hasOwner{std::nullopt}, .expectGlowApplied = false}
    })
));

struct WeaponOutlineGlowHueTestParam {
    EntityTypeInfo entityTypeInfo{};
    std::size_t configVarIndex{};
    std::any configuredHue{};
    color::Hue::ValueType expectedHue{};
};

class WeaponOutlineGlowHueTest
    : public WeaponOutlineGlowTest,
      public testing::WithParamInterface<WeaponOutlineGlowHueTestParam> {
};

TEST_P(WeaponOutlineGlowHueTest, CorrectGlowHueIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    EXPECT_CALL(mockConfig, getVariable(GetParam().configVarIndex))
        .WillRepeatedly(testing::Return(GetParam().configuredHue));

    const auto hue = weaponOutlineGlow.hue(GetParam().entityTypeInfo, mockBaseEntity);
    ASSERT_TRUE(hue.hasValue());
    EXPECT_EQ(hue.value(), GetParam().expectedHue);
}

static_assert(outline_glow_vars::FlashbangHue::ValueType::kMin == 191, "Update the test below");
static_assert(outline_glow_vars::HEGrenadeHue::ValueType::kMin == 300, "Update the test below");
static_assert(outline_glow_vars::MolotovHue::ValueType::kMin == 20, "Update the test below");
static_assert(outline_glow_vars::SmokeGrenadeHue::ValueType::kMin == 110, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MinConfigVars, WeaponOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{191}}},
            .expectedHue = 191
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{300}}},
            .expectedHue = 300
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 20
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{20}}},
            .expectedHue = 20
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{110}}},
            .expectedHue = 110
        }
    })
));

static_assert(outline_glow_vars::FlashbangHue::ValueType::kMax == 250, "Update the test below");
static_assert(outline_glow_vars::HEGrenadeHue::ValueType::kMax == 359, "Update the test below");
static_assert(outline_glow_vars::MolotovHue::ValueType::kMax == 60, "Update the test below");
static_assert(outline_glow_vars::SmokeGrenadeHue::ValueType::kMax == 140, "Update the test below");

INSTANTIATE_TEST_SUITE_P(MaxConfigVars, WeaponOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{250}}},
            .expectedHue = 250
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = 359
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 60
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{60}}},
            .expectedHue = 60
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{140}}},
            .expectedHue = 140
        }
    })
));

static_assert(outline_glow_vars::FlashbangHue::kDefaultValue == color::HueInteger{219}, "Update the tests below");
static_assert(outline_glow_vars::HEGrenadeHue::kDefaultValue == color::HueInteger{359}, "Update the tests below");
static_assert(outline_glow_vars::MolotovHue::kDefaultValue == color::HueInteger{40}, "Update the tests below");
static_assert(outline_glow_vars::SmokeGrenadeHue::kDefaultValue == color::HueInteger{120}, "Update the tests below");

INSTANTIATE_TEST_SUITE_P(DefaultConfigVars, WeaponOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{219}}},
            .expectedHue = 219
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{359}}},
            .expectedHue = 359
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{40}}},
            .expectedHue = 40
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{40}}},
            .expectedHue = 40
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{120}}},
            .expectedHue = 120
        }
    })
));

INSTANTIATE_TEST_SUITE_P(NonDefaultConfigVars, WeaponOutlineGlowHueTest, testing::ValuesIn(
    std::to_array<WeaponOutlineGlowHueTestParam>({
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_Flashbang>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::FlashbangHue>(),
            .configuredHue{outline_glow_vars::FlashbangHue::ValueType{color::HueInteger{222}}},
            .expectedHue = 222
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_HEGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::HEGrenadeHue>(),
            .configuredHue{outline_glow_vars::HEGrenadeHue::ValueType{color::HueInteger{333}}},
            .expectedHue = 333
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_MolotovGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{55}}},
            .expectedHue = 55
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_IncendiaryGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::MolotovHue>(),
            .configuredHue{outline_glow_vars::MolotovHue::ValueType{color::HueInteger{55}}},
            .expectedHue = 55
        },
        {
            .entityTypeInfo{EntityTypeInfo::indexOf<cs2::C_SmokeGrenade>()},
            .configVarIndex = ConfigVariableTypes::indexOf<outline_glow_vars::SmokeGrenadeHue>(),
            .configuredHue{outline_glow_vars::SmokeGrenadeHue::ValueType{color::HueInteger{111}}},
            .expectedHue = 111
        }
    })
));

```

`Tests/UnitTests/Features/Visuals/ViewmodelMod/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  ViewmodelModTests.cpp
)

```

`Tests/UnitTests/Features/Visuals/ViewmodelMod/ViewmodelModTests.cpp`:

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include <Features/Visuals/ViewmodelMod/ViewmodelMod.h>
#include <Mocks/MockBaseEntity.h>
#include <Mocks/MockConfig.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPlayerController.h>

class ViewmodelModTest : public testing::Test {
protected:
    testing::StrictMock<MockHookContext> mockHookContext{};
    testing::StrictMock<MockConfig> mockConfig{};
    testing::StrictMock<MockPlayerController> mockLocalPlayerController{};
    testing::StrictMock<MockBaseEntity> mockBasePawn{};
    testing::StrictMock<MockPlayerPawn> mockLocalPlayerPawn{};
    ViewmodelMod<MockHookContext> viewmodelMod{mockHookContext};
};

struct ViewmodelModIsFovModificationActiveTestParam {
    bool viewmodelModEnabled{};
    bool fovModificationEnabled{};
    bool expectedFovModificationActive{};
};

class ViewmodelModIsFovModificationActiveTest
    : public ViewmodelModTest,
      public testing::WithParamInterface<ViewmodelModIsFovModificationActiveTestParam> {
};

TEST_P(ViewmodelModIsFovModificationActiveTest, FovModificationIsActiveWhenExpected) {
    EXPECT_CALL(mockHookContext, config()).WillRepeatedly(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<viewmodel_mod_vars::Enabled>().WillRepeatedly(testing::Return(GetParam().viewmodelModEnabled));
    mockConfig.expectGetVariable<viewmodel_mod_vars::ModifyFov>().WillRepeatedly(testing::Return(GetParam().fovModificationEnabled));
    EXPECT_EQ(viewmodelMod.fovModificationActive(), GetParam().expectedFovModificationActive);
}

INSTANTIATE_TEST_SUITE_P(, ViewmodelModIsFovModificationActiveTest, testing::ValuesIn(
    std::to_array<ViewmodelModIsFovModificationActiveTestParam>({
        {.viewmodelModEnabled = false, .fovModificationEnabled = false, .expectedFovModificationActive = false},
        {.viewmodelModEnabled = false, .fovModificationEnabled = true, .expectedFovModificationActive = false},
        {.viewmodelModEnabled = true, .fovModificationEnabled = false, .expectedFovModificationActive = false},
        {.viewmodelModEnabled = true, .fovModificationEnabled = true, .expectedFovModificationActive = true}
    })
));

struct ViewmodelModShouldModifyFovTestParam {
    bool hasLocalPlayerPawn{};
    Optional<bool> isLocalPlayerScoped{};
    bool shouldModifyViewmodelFov{};
};

class ViewmodelModShouldModifyFovTest
    : public ViewmodelModTest,
      public testing::WithParamInterface<ViewmodelModShouldModifyFovTestParam> {
};

TEST_P(ViewmodelModShouldModifyFovTest, ShouldModifyViewmodelFovWhenExpected) {
    EXPECT_CALL(mockHookContext, localPlayerController()).WillOnce(testing::ReturnRef(mockLocalPlayerController));
    EXPECT_CALL(mockLocalPlayerController, pawn()).WillOnce(testing::ReturnRef(mockBasePawn));
    EXPECT_CALL(mockBasePawn, castToPlayerPawn()).WillOnce(testing::ReturnRef(mockLocalPlayerPawn));
    EXPECT_CALL(mockLocalPlayerPawn, operatorBool()).WillRepeatedly(testing::Return(GetParam().hasLocalPlayerPawn));
    EXPECT_CALL(mockLocalPlayerPawn, isScoped()).WillRepeatedly(testing::Return(GetParam().isLocalPlayerScoped));
    EXPECT_EQ(viewmodelMod.shouldModifyViewmodelFov(), GetParam().shouldModifyViewmodelFov);
}

INSTANTIATE_TEST_SUITE_P(, ViewmodelModShouldModifyFovTest, testing::ValuesIn(
    std::to_array<ViewmodelModShouldModifyFovTestParam>({
        {.hasLocalPlayerPawn = false, .shouldModifyViewmodelFov = false},
        {.hasLocalPlayerPawn = true, .isLocalPlayerScoped{true}, .shouldModifyViewmodelFov = false},
        {.hasLocalPlayerPawn = true, .isLocalPlayerScoped{false}, .shouldModifyViewmodelFov = true},
        {.hasLocalPlayerPawn = true, .isLocalPlayerScoped{std::nullopt}, .shouldModifyViewmodelFov = true}
    })
));

struct ViewmodelModFovTestParam {
    viewmodel_mod_vars::Fov::ValueType::ValueType configuredFov{};
    float expectedFov{};
};

class ViewmodelModFovTest
    : public ViewmodelModTest,
      public testing::WithParamInterface<ViewmodelModFovTestParam> {
};

TEST_P(ViewmodelModFovTest, CorrectViewmodelFovIsReturned) {
    EXPECT_CALL(mockHookContext, config()).WillOnce(testing::ReturnRef(mockConfig));
    mockConfig.expectGetVariable<viewmodel_mod_vars::Fov>(viewmodel_mod_vars::Fov::ValueType{GetParam().configuredFov});
    EXPECT_EQ(viewmodelMod.viewmodelFov(), GetParam().expectedFov);
}

static_assert(viewmodel_mod_vars::Fov::ValueType::kMin == 40, "Update the test below");
static_assert(viewmodel_mod_vars::Fov::ValueType::kMax == 90, "Update the test below");
static_assert(viewmodel_mod_vars::Fov::kDefaultValue == 80, "Update the test below");

INSTANTIATE_TEST_SUITE_P(, ViewmodelModFovTest, testing::ValuesIn(
    std::to_array<ViewmodelModFovTestParam>({
        {.configuredFov = 40, .expectedFov = 40.0f}, 
        {.configuredFov = 90, .expectedFov = 90.0f}, 
        {.configuredFov = 80, .expectedFov = 80.0f}
    })
));

```

`Tests/UnitTests/GameClient/CMakeLists.txt`:

```txt
add_subdirectory(Hud)

```

`Tests/UnitTests/GameClient/Hud/BombStatus/BombStatusPanelManagerTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <GameClient/Hud/BombStatus/BombStatusPanelManager.h>

#include <Mocks/BombTimerMocks/MockBombTimer.h>
#include <Mocks/HudMocks/MockBombStatusPanel.h>
#include <Mocks/HudMocks/MockBombStatusPanelManagerContext.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/PostRoundTimer/MockPostRoundTimer.h>

class BombStatusPanelManagerTest : public testing::Test {
protected:
    BombStatusPanelManagerTest()
    {
        EXPECT_CALL(mockContext, postRoundTimer()).WillOnce(testing::ReturnRef(mockPostRoundTimer));
        EXPECT_CALL(mockContext, bombTimer()).WillOnce(testing::ReturnRef(mockBombTimer));
        EXPECT_CALL(mockContext, bombStatusPanel()).WillOnce(testing::ReturnRef(mockBombStatusPanel));
    }

    testing::StrictMock<MockBombStatusPanelManagerContext> mockContext;
    testing::StrictMock<MockPostRoundTimer> mockPostRoundTimer;
    testing::StrictMock<MockBombTimer> mockBombTimer;
    testing::StrictMock<MockBombStatusPanel> mockBombStatusPanel;

    BombStatusPanelManager<MockHookContext, MockBombStatusPanelManagerContext&> bombStatusPanelManager{mockContext};
};

TEST_F(BombStatusPanelManagerTest, BombStatusPanelAndBombTimerAreHiddenWhenPostRoundTimerIsVisible) {
    EXPECT_CALL(mockPostRoundTimer, update()).WillOnce(testing::Return(Visibility::Visible));
    EXPECT_CALL(mockBombTimer, forceHide());
    EXPECT_CALL(mockBombStatusPanel, hide());

    bombStatusPanelManager.run();
}

TEST_F(BombStatusPanelManagerTest, BombStatusPanelIsHiddenWhenPostRoundTimerIsNotVisibleAndBombTimerIsVisible) {
    EXPECT_CALL(mockPostRoundTimer, update()).WillOnce(testing::Return(Visibility::Hidden));
    EXPECT_CALL(mockBombTimer, update()).WillOnce(testing::Return(Visibility::Visible));
    EXPECT_CALL(mockBombStatusPanel, hide());

    bombStatusPanelManager.run();
}

TEST_F(BombStatusPanelManagerTest, BombStatusPanelIsRestoredWhenBothPostRoundTimerAndBombTimerAreNotVisible) {
    EXPECT_CALL(mockPostRoundTimer, update()).WillOnce(testing::Return(Visibility::Hidden));
    EXPECT_CALL(mockBombTimer, update()).WillOnce(testing::Return(Visibility::Hidden));
    EXPECT_CALL(mockBombStatusPanel, restore());

    bombStatusPanelManager.run();
}

```

`Tests/UnitTests/GameClient/Hud/BombStatus/BombStatusPanelTests.cpp`:

```cpp
#include <gtest/gtest.h>

#include <GameClient/Hud/BombStatus/BombStatusPanel.h>
#include <Mocks/HudMocks/MockBombStatusPanelContext.h>
#include <Mocks/MockHookContext.h>
#include <Mocks/MockPanel.h>

class BombStatusPanelTest : public testing::Test {
protected:
    BombStatusPanelTest()
    {
        EXPECT_CALL(mockContext, visibility()).WillOnce(testing::ReturnRef(visibility));
    }

    testing::StrictMock<MockBombStatusPanelContext> mockContext;
    testing::StrictMock<MockPanel> mockBombStatusPanel;
    testing::StrictMock<MockPanel> mockInvisiblePanel;
    testing::StrictMock<MockPanel> mockScoreAndTimeAndBombPanel;

    BombStatusPanel<MockHookContext, MockBombStatusPanelContext&> bombStatusPanel{mockContext};
    Visibility visibility{};
};

TEST_F(BombStatusPanelTest, HidesBombStatusPanelBySettingItsParentToInvisiblePanelIfPreviouslyVisible) {
    visibility = Visibility::Visible;

    EXPECT_CALL(mockContext, bombStatusPanel()).WillOnce(testing::ReturnRef(mockBombStatusPanel));
    EXPECT_CALL(mockContext, invisiblePanel()).WillOnce(testing::ReturnRef(mockInvisiblePanel));
    EXPECT_CALL(mockBombStatusPanel, setParent(testing::Ref(mockInvisiblePanel)));

    bombStatusPanel.hide();
    EXPECT_EQ(visibility, Visibility::Hidden);
}

TEST_F(BombStatusPanelTest, DoesNotHideAgainIfAlreadyHidden) {
    visibility = Visibility::Hidden;
    bombStatusPanel.hide();
    EXPECT_EQ(visibility, Visibility::Hidden);
}

TEST_F(BombStatusPanelTest, RestoresBombStatusPanelBySettingItsParentToTheOriginalPanelIfPreviouslyHidden) {
    visibility = Visibility::Hidden;

    EXPECT_CALL(mockContext, bombStatusPanel()).WillOnce(testing::ReturnRef(mockBombStatusPanel));
    EXPECT_CALL(mockContext, scoreAndTimeAndBombPanel()).WillOnce(testing::ReturnRef(mockScoreAndTimeAndBombPanel));
    EXPECT_CALL(mockBombStatusPanel, setParent(testing::Ref(mockScoreAndTimeAndBombPanel)));

    bombStatusPanel.restore();
    EXPECT_EQ(visibility, Visibility::Visible);
}

TEST_F(BombStatusPanelTest, DoesNotRestoreAgainIfAlreadyRestored) {
    visibility = Visibility::Visible;
    bombStatusPanel.restore();
    EXPECT_EQ(visibility, Visibility::Visible);
}

```

`Tests/UnitTests/GameClient/Hud/BombStatus/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  BombStatusPanelManagerTests.cpp
  BombStatusPanelTests.cpp
)

```

`Tests/UnitTests/GameClient/Hud/CMakeLists.txt`:

```txt
add_subdirectory(BombStatus)

```

`Tests/UnitTests/MemorySearch/BytePatternConverterTests.cpp`:

```cpp
#include <gtest/gtest.h>

#include <MemorySearch/BytePatternConverter.h>
#include <MemorySearch/PatternStringWildcard.h>

namespace
{

TEST(BytePatternConverterTest, ValidPatternIsFullyConvertedAndNoErrorIsReturned) {
    BytePatternConverter converter{ "8B CE E8 ? ? ? ? 02 C0" };
    const auto [converted, error] = converter();
    EXPECT_EQ(converted, "\x8B\xCE\xE8????\x02\xC0");
    EXPECT_EQ(error, BytePatternConverterError::NoError);
}

TEST(BytePatternConverterTest, EmptyPatternResultsInUnexpectedCharError) {
    BytePatternConverter converter{ "" };
    const auto [converted, error] = converter();
    EXPECT_EQ(converted, "");
    EXPECT_EQ(error, BytePatternConverterError::UnexpectedChar);
}

TEST(BytePatternConverterTest, PatternIsConvertedUntilAnErrorHappens) {
    BytePatternConverter converter{ "AA BB x" };
    const auto [converted, error] = converter();
    EXPECT_EQ(converted, "\xAA\xBB");
    EXPECT_EQ(error, BytePatternConverterError::UnexpectedChar);
}

TEST(BytePatternConverterTest, PatternCanStartWithWildcard) {
    BytePatternConverter converter{"? AA BB"};
    const auto [converted, error] = converter();
    EXPECT_EQ(converted, "?\xAA\xBB");
    EXPECT_EQ(error, BytePatternConverterError::NoError);
}

TEST(BytePatternConverterTest, PatternCanEndWithWildcard) {
    BytePatternConverter converter{"AA BB ?"};
    const auto [converted, error] = converter();
    EXPECT_EQ(converted, "\xAA\xBB?");
    EXPECT_EQ(error, BytePatternConverterError::NoError);
}

TEST(BytePatternConverterTest, NumericValueOfWildcardCharCannotBeUsed) {
    static_assert(kPatternStringWildcard == 0x3F);

    BytePatternConverter converter{ "AA BB 3F CC" };
    const auto [converted, error] = converter();
    EXPECT_EQ(converted, "\xAA\xBB");
    EXPECT_EQ(error, BytePatternConverterError::WildcardUsedAsByte);
}

}

```

`Tests/UnitTests/MemorySearch/BytePatternLiteralTests.cpp`:

```cpp
#include <string_view>
#include <type_traits>

#include <gtest/gtest.h>

#include <MemorySearch/BytePatternLiteral.h>
#include <MemorySearch/BytePatternStorage.h>

namespace
{

using namespace std::string_view_literals;

TEST(BytePatternLiteralTest, LiteralReturnsConvertedPattern) {
    constexpr auto expectedPattern = "\x00\x11\x22\x33\xAA\xBB\xCC"sv;

    const auto patternView = "00 11 22 33 AA BB CC"_pat;
    const auto actualPattern = std::string_view{patternView.data(), patternView.size()};
    EXPECT_EQ(actualPattern, expectedPattern);
}

}

```

`Tests/UnitTests/MemorySearch/BytePatternStorageTests.cpp`:

```cpp
#include <string_view>

#include <gtest/gtest.h>

#include <MemorySearch/BytePatternStorage.h>

namespace
{

using namespace std::string_view_literals;

TEST(BytePatternStorageTest, StorageHasSizeEqualToLengthOfConvertedPattern) {
    constexpr BytePatternStorage storage{ "83 EC ? ? 4C ? 80 3D" };
    EXPECT_EQ(storage.size, 8);
}

TEST(BytePatternStorageTest, PatternConversionIsPerformedInConstructor) {
    constexpr BytePatternStorage storage{ "E8 ? ? ? ? 48 00 C0 74 62" };
    constexpr auto expectedPattern = "\xE8????\x48\x00\xC0\x74\x62"sv;
    const auto actualPattern = std::string_view{ storage.pattern.data(), storage.size };
    EXPECT_EQ(actualPattern, expectedPattern);
}

}

```

`Tests/UnitTests/MemorySearch/BytePatternTests.cpp`:

```cpp
#include <algorithm>
#include <array>
#include <string>
#include <string_view>

#include <gtest/gtest.h>

#include <MemorySearch/BytePattern.h>
#include <MemorySearch/PatternStringWildcard.h>

namespace
{

using namespace std::string_view_literals;

template <std::size_t N>
[[nodiscard]] constexpr auto createByteArray(const unsigned char(&bytes)[N])
{
    std::array<std::byte, N> arr;
    std::ranges::transform(bytes, arr.begin(), [](unsigned char c) { return std::byte{c}; });
    return arr;
}

TEST(BytePatternWithoutWildcardTest, PatternMatchesMemoryWhenBytesAreTheSame) {
    EXPECT_TRUE(BytePattern{"\xAB\xCD\xEF"sv}.matches(createByteArray({ 0xAB, 0xCD, 0xEF })));
}

TEST(BytePatternWithoutWildcardTest, PatternDoesNotMatchMemoryWhenBytesAreDifferent) {
    EXPECT_FALSE(BytePattern{"\xAB\xCD\xAB"sv}.matches(createByteArray({ 0xAB, 0xCD, 0xEF })));
}

TEST(BytePatternWithoutWildcardTest, NullCharsInPatternDoesNotTerminateComparison) {
    EXPECT_FALSE(BytePattern{"\xAB\x00\xEF\x00\x13"sv}.matches(createByteArray({ 0xAB, 0x00, 0xEF, 0x00, 0x12 })));
}

class BytePatternWithWildcardTest : public testing::TestWithParam<char> {
protected:
    [[nodiscard]] auto makePattern(std::string_view pattern) noexcept
    {
        return BytePattern{pattern, GetParam()};
    }
};

TEST_P(BytePatternWithWildcardTest, PatternMatchesMemoryWhenBytesAreTheSame) {
    EXPECT_TRUE(makePattern("\xAB\xCD\xEF"sv).matches(createByteArray({ 0xAB, 0xCD, 0xEF })));
}

TEST_P(BytePatternWithWildcardTest, PatternDoesNotMatchMemoryWhenBytesAreDifferent) {
    EXPECT_FALSE(makePattern("\xAB\xCD\xAB"sv).matches(createByteArray({ 0xAB, 0xCD, 0xEF })));
}

TEST_P(BytePatternWithWildcardTest, NullCharsInPatternDoesNotTerminateComparison) {
    EXPECT_FALSE(makePattern("\xAB\x00\xEF\x00\x13"sv).matches(createByteArray({ 0xAB, 0x00, 0xEF, 0x00, 0x12 })));
}

TEST_P(BytePatternWithWildcardTest, BytesOnWildcardPositionsAreIgnored) {
    const auto pattern = std::string{"\xAB"} + GetParam() + "\xEF" + GetParam() + "\xFF";
    EXPECT_TRUE(makePattern(pattern).matches(createByteArray({ 0xAB, 0xCC, 0xEF, 0xDD, 0xFF })));
}

TEST_P(BytePatternWithWildcardTest, WildcardCharInMemoryDoesNotMatchEveryPatternChar) {
    EXPECT_FALSE(makePattern("\xAB\xCC\xEF\xDD\xFF"sv).matches(createByteArray({ 0xAB, static_cast<unsigned char>(GetParam()), 0xEF, static_cast<unsigned char>(GetParam()), 0xFF })));
}

INSTANTIATE_TEST_SUITE_P(, BytePatternWithWildcardTest, testing::Values('?', '.'));

}

```

`Tests/UnitTests/MemorySearch/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  BytePatternConverterTests.cpp
  BytePatternLiteralTests.cpp
  BytePatternStorageTests.cpp
  BytePatternTests.cpp
  PatternFinderSIMDTests.cpp
  PatternSearchResultTests.cpp
)

```

`Tests/UnitTests/MemorySearch/PatternFinderSIMDTests.cpp`:

```cpp
#include <array>
#include <cstddef>

#include <gtest/gtest.h>

#include <MemorySearch/BytePatternLiteral.h>
#include <MemorySearch/PatternFinderSIMD.h>

namespace
{

constexpr BytePattern dummyPattern{"\xAA\xBB"};

TEST(PatternFinderSIMD_NoBytesTest, NotCheckedBytesAreEmptySpan) {
    PatternFinderSIMD finder{ {}, dummyPattern };
    EXPECT_TRUE(finder.getNotCheckedBytes().empty());
}

TEST(PatternFinderSIMD_NoBytesTest, FinderReturnsNullptr) {
    PatternFinderSIMD finder{ {}, dummyPattern };
    EXPECT_EQ(finder(), nullptr);
}

TEST(PatternFinderSIMDTest, NoBytesAreCheckedUntilFinderIsInvoked) {
    std::array<std::byte, 1000> bytes{};
    PatternFinderSIMD finder{bytes, BytePattern{"\xAA"}};
    const auto notCheckedBytes = finder.getNotCheckedBytes();
    ASSERT_EQ(notCheckedBytes.size(), bytes.size());
    EXPECT_EQ(&notCheckedBytes.front(), &bytes.front());
    EXPECT_EQ(&notCheckedBytes.back(), &bytes.back());
}

TEST(PatternFinderSIMDTest, OneBytePatternCanBeMatched) {
    std::array<std::byte, 64> bytes{};
    bytes[20] = std::byte{ 0x12 };

    PatternFinderSIMD finder{bytes, BytePattern{"\x12"}};
    EXPECT_EQ(finder(), &bytes[20]);
}

TEST(PatternFinderSIMDTest, FirstAndLastCharOfPatternAreCheckedCorrectly) {
    std::array<std::byte, 64> bytes{};
    bytes[20] = std::byte{ 0xBB };
    bytes[21] = std::byte{ 0xBB };
    bytes[22] = std::byte{ 0xAA };
    bytes[23] = std::byte{ 0xAA };
    bytes[24] = std::byte{ 0xAA };
    bytes[25] = std::byte{ 0xBB };

    PatternFinderSIMD finder{bytes, BytePattern{"\xAA\xBB"}};
    EXPECT_EQ(finder(), &bytes[24]);
}

TEST(PatternFinderSIMDTest, PatternWithoutFirstAndLastCharIsCheckedCorrectly) {
    std::array<std::byte, 64> bytes{};
    bytes[20] = std::byte{ 0xAA };
    bytes[21] = std::byte{ 0x33 };
    bytes[22] = std::byte{ 0xBB };
    bytes[23] = std::byte{ 0xAA };
    bytes[24] = std::byte{ 0x12 };
    bytes[25] = std::byte{ 0xBB };

    PatternFinderSIMD finder{bytes, BytePattern{"\xAA\x12\xBB"}};
    EXPECT_EQ(finder(), &bytes[23]);
}

TEST(PatternFinderSIMDTest, BytesInTheLastXmmwordAreChecked) {
    std::array<std::byte, 64> bytes{};
    bytes[62] = std::byte{ 0xAA };
    PatternFinderSIMD finder{bytes, BytePattern{"\xAA"}};
    EXPECT_EQ(finder(), &bytes[62]);
}

}

```

`Tests/UnitTests/MemorySearch/PatternSearchResultTests.cpp`:

```cpp
#include <array>
#include <cstddef>
#include <cstring>
#include <tuple>

#include <gtest/gtest.h>

#include <MemorySearch/PatternSearchResult.h>

namespace
{

TEST(PatternSearchResultDefaultConstructedTest, HasNullPointer) {
    EXPECT_EQ(PatternSearchResult{}.as<void*>(), nullptr);
}

TEST(PatternSearchResultDefaultConstructedTest, AddMethodDoesNothing) {
    EXPECT_EQ(PatternSearchResult{}.add(5).as<void*>(), nullptr);
}

TEST(PatternSearchResultDefaultConstructedTest, AbsMethodReturnsNullPointer) {
    EXPECT_EQ(PatternSearchResult{}.add(7).abs().as<void*>(), nullptr);
}

class PatternSearchResultTest : public testing::Test {
protected:
    std::array<std::byte, 50> runtimeMemory;
    std::array<std::byte, 60> foundPatternMemory;
};

class PatternSearchResultToAbsoluteTest : public PatternSearchResultTest, public testing::WithParamInterface<std::tuple<std::size_t, std::int32_t>> {
protected:
    static constexpr auto kRuntimeMemoryOffset{3};

    PatternSearchResultToAbsoluteTest() noexcept
    {
        const auto relativeOffset{getRelativeOffset()};
        std::memcpy(foundPatternMemory.data(), &relativeOffset, sizeof(relativeOffset));
    }

    [[nodiscard]] std::size_t getFoundPatternOffset() const noexcept
    {
        return std::get<0>(GetParam());
    }

    [[nodiscard]] std::int32_t getRelativeOffset() const noexcept
    {
        return std::get<1>(GetParam());
    }

    [[nodiscard]] PatternSearchResult patternSearchResult() const noexcept
    {
        return PatternSearchResult{runtimeMemory.data() + kRuntimeMemoryOffset, getFoundPatternOffset(), foundPatternMemory};
    }
};

TEST_P(PatternSearchResultToAbsoluteTest, ToAbsoluteReturnsCorrectAddress) {
    EXPECT_EQ(patternSearchResult().abs().as<void*>(), &runtimeMemory.at(kRuntimeMemoryOffset + getFoundPatternOffset() + sizeof(std::int32_t) + getRelativeOffset()));
}

INSTANTIATE_TEST_SUITE_P(, PatternSearchResultToAbsoluteTest,
    testing::Combine(testing::Values(0, 1, 5), testing::Values(-5, 0, 7)));

}

```

`Tests/UnitTests/Platform/CMakeLists.txt`:

```txt
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
  add_subdirectory(Windows)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
  add_subdirectory(Linux)
endif()

```

`Tests/UnitTests/Platform/Linux/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE SharedObjectTests.cpp)

```

`Tests/UnitTests/Platform/Linux/SharedObjectTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Platform/Linux/LinuxDynamicLibrary.h>

namespace
{

using testing::_;
using testing::Return;
using testing::Values;

struct MockLinuxPlatformApi {
    MOCK_METHOD(void*, dlopen, (const char* file, int mode), (const noexcept));
    MOCK_METHOD(void*, dlsym, (void* handle, const char* name), (const noexcept));
    MOCK_METHOD(int, dlclose, (void* handle), (const noexcept));
    MOCK_METHOD(int, dlinfo, (void* handle, int request, void* info), (const noexcept));
    MOCK_METHOD(int, open, (const char* pathname, int flags, mode_t mode), (const noexcept));
    MOCK_METHOD(int, close, (int fd), (const noexcept));
    MOCK_METHOD(int, fstat, (int fd, struct stat* buf), (const noexcept));
    MOCK_METHOD(void*, mmap, (void* addr, size_t length, int prot, int flags, int fd, off_t offset), (const noexcept));
    MOCK_METHOD(int, munmap, (void* addr, size_t length), (const noexcept));
    MOCK_METHOD(char*, getenv, (const char* name), (const noexcept));

    static inline testing::StrictMock<MockLinuxPlatformApi>* instance = nullptr;
};

class TestLinuxDynamicLibrary : public testing::Test {
protected:
    TestLinuxDynamicLibrary()
    {
        MockLinuxPlatformApi::instance = &platformApi;
    }

    testing::StrictMock<MockLinuxPlatformApi> platformApi;
    void* dummyHandleValue = reinterpret_cast<void*>(0x1234567890ABCDEF);
    static constexpr auto dummyLibraryName = "lib.so";

    auto createSharedObject(const char* name)
    {
        return LinuxDynamicLibrary{ name };
    }
};

TEST_F(TestLinuxDynamicLibrary, LibraryIsOpenedWithCorrectFlags) {
    EXPECT_CALL(platformApi, dlopen(_, RTLD_LAZY | RTLD_NOLOAD)).WillOnce(Return(dummyHandleValue));
    EXPECT_CALL(platformApi, dlclose(dummyHandleValue));

    createSharedObject(dummyLibraryName);
}

TEST_F(TestLinuxDynamicLibrary, LibraryIsNotBeingClosedWhenOpeningFailed) {
    EXPECT_CALL(platformApi, dlopen(_, _)).WillOnce(Return(nullptr));
    EXPECT_CALL(platformApi, dlclose(_)).Times(0);

    createSharedObject(dummyLibraryName);
}

TEST_F(TestLinuxDynamicLibrary, GetFunctionAddressReturnsZeroIfOpeningFailed) {
    EXPECT_CALL(platformApi, dlopen(_, _)).WillOnce(Return(nullptr));
    EXPECT_CALL(platformApi, dlclose(_)).Times(0);
    EXPECT_CALL(platformApi, dlsym(_, _)).Times(0);

    const auto dll = createSharedObject(dummyLibraryName);
    EXPECT_EQ(dll.getFunctionAddress("functionA").as<std::uintptr_t>(), 0);
}

TEST_F(TestLinuxDynamicLibrary, GetLinkMapReturnsNullIfOpeningFailed) {
    EXPECT_CALL(platformApi, dlopen(_, _)).WillOnce(Return(nullptr));
    EXPECT_CALL(platformApi, dlclose(_)).Times(0);
    EXPECT_CALL(platformApi, dlinfo(_, _, _)).Times(0);

    const auto dll = createSharedObject(dummyLibraryName);
    EXPECT_EQ(dll.getLinkMap(), nullptr);
}

class TestLinuxDynamicLibrary_Handle
    : public TestLinuxDynamicLibrary, public testing::WithParamInterface<std::uintptr_t> {};

TEST_P(TestLinuxDynamicLibrary_Handle, LibraryIsClosedWithTheHandleThatWasOpened) {
    EXPECT_CALL(platformApi, dlopen(_, _)).WillOnce(Return(reinterpret_cast<void*>(GetParam())));
    EXPECT_CALL(platformApi, dlclose(reinterpret_cast<void*>(GetParam())));

    createSharedObject(dummyLibraryName);
}

INSTANTIATE_TEST_SUITE_P(, TestLinuxDynamicLibrary_Handle, testing::Values(0x12345678, std::uintptr_t(-1)));

class TestLinuxDynamicLibrary_FunctionAddress
    : public TestLinuxDynamicLibrary, public testing::WithParamInterface<std::tuple<void*, const char*, void*>> {};

TEST_P(TestLinuxDynamicLibrary_FunctionAddress, GetFunctionAddressReturnsCorrectAddress) {
    const auto [handle, functionName, functionAddress] = GetParam();

    EXPECT_CALL(platformApi, dlopen(_, _)).WillOnce(Return(handle));
    EXPECT_CALL(platformApi, dlclose(handle));

    const auto dll = createSharedObject(dummyLibraryName);
    EXPECT_CALL(platformApi, dlsym(handle, testing::StrEq(functionName))).WillOnce(Return(functionAddress));
    EXPECT_EQ(dll.getFunctionAddress(functionName).as<void*>(), functionAddress);
}

INSTANTIATE_TEST_SUITE_P(, TestLinuxDynamicLibrary_FunctionAddress, testing::Combine(
    Values((void*)0x12345678, (void*)-1),
    Values("function1", "function2"),
    Values((void*)0, (void*)0x123456789ABC, (void*)-1)
));

class TestLinuxDynamicLibrary_LinkMap
    : public TestLinuxDynamicLibrary, public testing::WithParamInterface<std::tuple<void*, link_map*>> {};

struct SetLinkMap {
    link_map* linkMap;

    int operator()(void* handle, int request, void* info) const
    {
        *reinterpret_cast<link_map**>(info) = linkMap;
        return 0;
    }
};

TEST_P(TestLinuxDynamicLibrary_LinkMap, GetLinkMapReturnsCorrectPointer) {
    const auto [handle, linkMap] = GetParam();

    EXPECT_CALL(platformApi, dlopen(_, _)).WillOnce(Return(handle));
    EXPECT_CALL(platformApi, dlclose(handle));

    const auto dll = createSharedObject(dummyLibraryName);
    EXPECT_CALL(platformApi, dlinfo(handle, RTLD_DI_LINKMAP, _)).WillOnce(SetLinkMap{ linkMap });
    EXPECT_EQ(dll.getLinkMap(), linkMap);
}

INSTANTIATE_TEST_SUITE_P(, TestLinuxDynamicLibrary_LinkMap, testing::Combine(
    Values((void*)0x12345678, (void*)-1),
    Values((link_map*)0x123456789ABC, (link_map*)-1)
));

class TestLinuxDynamicLibrary_String
    : public TestLinuxDynamicLibrary, public testing::WithParamInterface<const char*> {};

TEST_P(TestLinuxDynamicLibrary_String, LibraryWithCorrectNameIsOpened) {
    EXPECT_CALL(platformApi, dlopen(testing::StrEq(GetParam()), _)).WillOnce(Return(dummyHandleValue));
    EXPECT_CALL(platformApi, dlclose(dummyHandleValue));

    createSharedObject(GetParam());
}

INSTANTIATE_TEST_SUITE_P(, TestLinuxDynamicLibrary_String, testing::Values("client.so", "engine.so"));

}

void* LinuxPlatformApi::dlopen(const char* file, int mode) noexcept
{
    return MockLinuxPlatformApi::instance->dlopen(file, mode);
}

void* LinuxPlatformApi::dlsym(void* handle, const char* name) noexcept
{
    return MockLinuxPlatformApi::instance->dlsym(handle, name);
}

int LinuxPlatformApi::dlclose(void* handle) noexcept
{
    return MockLinuxPlatformApi::instance->dlclose(handle);
}

int LinuxPlatformApi::dlinfo(void* handle, int request, void* info) noexcept
{
    return MockLinuxPlatformApi::instance->dlinfo(handle, request, info);
}

int LinuxPlatformApi::open(const char* pathname, int flags, mode_t mode) noexcept
{
    return MockLinuxPlatformApi::instance->open(pathname, flags, mode);
}

int LinuxPlatformApi::close(int fd) noexcept
{
    return MockLinuxPlatformApi::instance->close(fd);
}

int LinuxPlatformApi::fstat(int fd, struct stat* buf) noexcept
{
    return MockLinuxPlatformApi::instance->fstat(fd, buf);
}

void* LinuxPlatformApi::mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) noexcept
{
    return MockLinuxPlatformApi::instance->mmap(addr, length, prot, flags, fd, offset);
}

int LinuxPlatformApi::munmap(void* addr, size_t length) noexcept
{
    return MockLinuxPlatformApi::instance->munmap(addr, length);
}

char* LinuxPlatformApi::getenv(const char* name) noexcept
{
    return MockLinuxPlatformApi::instance->getenv(name);
}

```

`Tests/UnitTests/Platform/Windows/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  MockWindowsPlatformApi.cpp
  PebLdrTests.cpp
)

```

`Tests/UnitTests/Platform/Windows/MockWindowsPlatformApi.cpp`:

```cpp
#include <Platform/Windows/WindowsPlatformApi.h>

win::Peb* WindowsPlatformApi::getPeb() noexcept
{
    return nullptr;
}

void WindowsPlatformApi::debugBreak() noexcept
{
}

```

`Tests/UnitTests/Platform/Windows/PebLdrBuilder.h`:

```h
#pragma once

#include <cwchar>
#include <iterator>
#include <list>

#include <Platform/Windows/PebLdr.h>
#include <Platform/Windows/Win.h>

class PebLdrBuilder {
public:
    void addModule(void* dllBase, const wchar_t* baseDllName)
    {
        win::LdrDataTableEntry entry{};
        entry.dllBase = dllBase;
        entry.baseDllName.buffer = const_cast<wchar_t*>(baseDllName);
        entry.baseDllName.length = std::wcslen(baseDllName);
        entry.baseDllName.maximumLength = entry.baseDllName.length;
        entries.push_back(entry);
    }

    [[nodiscard]] PebLdr pebLdr()
    {
        buildModuleList();
        return PebLdr{ &pebLdrData };
    }

private:
    void buildModuleList()
    {
        for (auto it = entries.begin(); it != entries.end(); ++it) {
            it->inLoadOrderLinks.bLink = (it != entries.begin()) ? &std::prev(it)->inLoadOrderLinks : &pebLdrData.inLoadOrderModuleList;
            it->inLoadOrderLinks.fLink = (it != std::prev(entries.end())) ? &std::next(it)->inLoadOrderLinks : &pebLdrData.inLoadOrderModuleList;
        }

        pebLdrData.inLoadOrderModuleList.bLink = &std::prev(entries.end())->inLoadOrderLinks;
        pebLdrData.inLoadOrderModuleList.fLink = &entries.begin()->inLoadOrderLinks;
    }
    
    std::list<win::LdrDataTableEntry> entries;
    win::PebLdrData pebLdrData{};
};

```

`Tests/UnitTests/Platform/Windows/PebLdrTests.cpp`:

```cpp
#include <string>

#include <gtest/gtest.h>

#include "PebLdrBuilder.h"

namespace
{

class TestPebLdr : public testing::Test {
protected:
    void addDummyModule1()
    {
        builder.addModule((void*)0x1234123412341234, L"dllone");
    }

    void addDummyModule2()
    {
        builder.addModule((void*)0x0BADC0DE0BADC0DE, L"another.dll");
    }

    PebLdrBuilder builder;
};

TEST_F(TestPebLdr, NullHandleIsReturnedWhenModuleIsNotFound) {
    addDummyModule1();
    addDummyModule2();
    EXPECT_EQ(builder.pebLdr().getModuleHandle("client.dll"), nullptr);
}

class TestPebLdr_Handle_Name
    : public TestPebLdr, public testing::WithParamInterface<std::tuple<void*, std::string>> {};

TEST_P(TestPebLdr_Handle_Name, FirstModuleInListCanBeFound) {
    const auto [handle, dllName] = GetParam();
    const std::wstring dllNameUnicode{ dllName.begin(), dllName.end() };
    builder.addModule(handle, dllNameUnicode.c_str());

    addDummyModule1();
    addDummyModule2();

    EXPECT_EQ(builder.pebLdr().getModuleHandle(dllName.c_str()), handle);
}

TEST_P(TestPebLdr_Handle_Name, LastModuleInListCanBeFound) {
    addDummyModule1();
    addDummyModule2();

    const auto [handle, dllName] = GetParam();
    const std::wstring dllNameUnicode{ dllName.begin(), dllName.end() };
    builder.addModule(handle, dllNameUnicode.c_str());

    EXPECT_EQ(builder.pebLdr().getModuleHandle(dllName.c_str()), handle);
}

TEST_P(TestPebLdr_Handle_Name, ModuleInTheCenterOfListCanBeFound) {
    addDummyModule1();

    const auto [handle, dllName] = GetParam();
    const std::wstring dllNameUnicode{ dllName.begin(), dllName.end() };
    builder.addModule(handle, dllNameUnicode.c_str());

    addDummyModule2();

    EXPECT_EQ(builder.pebLdr().getModuleHandle(dllName.c_str()), handle);
}

INSTANTIATE_TEST_SUITE_P(, TestPebLdr_Handle_Name, testing::Combine(
    testing::Values((void*)0xABABABABABABABAB, (void*)0xCDCDCDCDCDCDCDCD),
    testing::Values("client.dll", "engine.dll")
));

}

```

`Tests/UnitTests/Utils/BitsTests.cpp`:

```cpp
#include <tuple>

#include <gtest/gtest.h>

#include <Utils/Bits.h>

namespace
{

TEST(CountrZero, PassingZeroRaisesDebugAssertion) {
    EXPECT_DEBUG_DEATH(std::ignore = bits::countrZero(0), "");
}

struct CountrZeroParam {
    unsigned int x;
    int firstSetBitIndex;
};

class CountrZeroWithParam : public testing::TestWithParam<CountrZeroParam> {};

TEST_P(CountrZeroWithParam, IndexOfFirstSetBitFromRightIsReturned) {
    EXPECT_EQ(bits::countrZero(GetParam().x), GetParam().firstSetBitIndex);
}

INSTANTIATE_TEST_SUITE_P(, CountrZeroWithParam, testing::Values(
    CountrZeroParam{ 1, 0 },
    CountrZeroParam{ 0b100001000, 3 },
    CountrZeroParam{ 1u << 31, 31 }
));

}

```

`Tests/UnitTests/Utils/CMakeLists.txt`:

```txt
target_sources(UnitTests PRIVATE
  BitsTests.cpp
  EnumFlagsTests.cpp
  FlagsBuilderTests.cpp
  OptionalTests.cpp
  PatternFinderTests.cpp
  RefCountedHookTests.cpp
  ReturnAddressTests.cpp
  SpanSliceTests.cpp
  StringBuilderTests.cpp
)

```

`Tests/UnitTests/Utils/EnumFlagsTests.cpp`:

```cpp
#include <concepts>
#include <limits>
#include <gtest/gtest.h>
#include <Utils/EnumFlags.h>

template <std::integral T>
constexpr auto kHighestBitMask = static_cast<T>(T{1} << (std::numeric_limits<T>::digits + std::numeric_limits<T>::is_signed - 1));

enum class EnumChar : char {
    First = 1 << 0,
    Another = 1 << 5,
    Last = kHighestBitMask<char>
};

enum class EnumSignedChar : signed char {
    First = 1 << 0,
    Another = 1 << 5,
    Last = kHighestBitMask<signed char>
};

enum class EnumUnsignedChar : unsigned char {
    First = 1 << 0,
    Another = 1 << 5,
    Last = kHighestBitMask<unsigned char>
};

enum class EnumChar8 : char8_t {
    First = 1 << 0,
    Another = 1 << 5,
    Last = kHighestBitMask<char8_t>
};

enum class EnumChar16 : char16_t {
    First = 1 << 0,
    Another = 1 << 12,
    Last = kHighestBitMask<char16_t>
};

enum class EnumChar32 : char32_t {
    First = 1 << 0,
    Another = 1 << 25,
    Last = kHighestBitMask<char32_t>
};

enum class EnumWchar : wchar_t {
    First = 1 << 0,
    Another = 1 << 5,
    Last = kHighestBitMask<wchar_t>
};

enum class EnumSignedShort : signed short {
    First = 1 << 0,
    Another = 1 << 14,
    Last = kHighestBitMask<signed short>
};

enum class EnumUnsignedShort : unsigned short {
    First = 1 << 0,
    Another = 1 << 13,
    Last = kHighestBitMask<unsigned short>
};

enum class EnumSignedInt : signed int {
    First = 1 << 0,
    Another = 1 << 25,
    Last = kHighestBitMask<signed int>
};

enum class EnumUnsignedInt : unsigned int {
    First = 1 << 0,
    Another = 1 << 30,
    Last = kHighestBitMask<unsigned int>
};

enum class EnumSignedLong : signed long {
    First = 1 << 0,
    Another = 1 << 12,
    Last = kHighestBitMask<signed long>
};

enum class EnumUnsignedLong : unsigned long {
    First = 1 << 0,
    Another = 1 << 13,
    Last = kHighestBitMask<unsigned long>
};

enum class EnumSignedLongLong : signed long long {
    First = 1 << 0,
    Another = 1LL << 41,
    Last = kHighestBitMask<signed long long>
};

enum class EnumUnsignedLongLong : unsigned long long {
    First = 1 << 0,
    Another = 1ULL << 46,
    Last = kHighestBitMask<unsigned long long>
};

template <typename Enum>
class EnumFlagsTest : public testing::Test {
};

using EnumFlagsTestTypes = testing::Types<
    EnumChar,
    EnumSignedChar,
    EnumUnsignedChar,
    EnumChar8,
    EnumChar16,
    EnumChar32,
    EnumWchar,
    EnumSignedShort,
    EnumUnsignedShort,
    EnumSignedInt,
    EnumUnsignedInt,
    EnumSignedLong,
    EnumUnsignedLong,
    EnumSignedLongLong,
    EnumUnsignedLongLong
>;
TYPED_TEST_SUITE(EnumFlagsTest, EnumFlagsTestTypes);

TYPED_TEST(EnumFlagsTest, DefaultConstructedHasNoFlags) {
    EnumFlags<TypeParam> enumFlags;
    EXPECT_FALSE(enumFlags.has(TypeParam::First));
    EXPECT_FALSE(enumFlags.has(TypeParam::Another));
    EXPECT_FALSE(enumFlags.has(TypeParam::Last));
    EXPECT_FALSE(enumFlags.hasAny());
}

TYPED_TEST(EnumFlagsTest, FlagsCanBeSet) {
    EnumFlags<TypeParam> enumFlags;

    enumFlags.set(TypeParam::First);
    EXPECT_TRUE(enumFlags.has(TypeParam::First));
    EXPECT_TRUE(enumFlags.hasAny());

    enumFlags.set(TypeParam::Another);
    EXPECT_TRUE(enumFlags.has(TypeParam::Another));
    EXPECT_TRUE(enumFlags.hasAny());

    enumFlags.set(TypeParam::Last);
    EXPECT_TRUE(enumFlags.has(TypeParam::Last));
    EXPECT_TRUE(enumFlags.hasAny());
}

TYPED_TEST(EnumFlagsTest, SettingAlreadySetFlagDoesNothing) {
    EnumFlags<TypeParam> enumFlags;

    enumFlags.set(TypeParam::First);
    enumFlags.set(TypeParam::First);
    EXPECT_TRUE(enumFlags.has(TypeParam::First));
    EXPECT_TRUE(enumFlags.hasAny());

    enumFlags.set(TypeParam::Another);
    enumFlags.set(TypeParam::Another);
    EXPECT_TRUE(enumFlags.has(TypeParam::Another));
    EXPECT_TRUE(enumFlags.hasAny());

    enumFlags.set(TypeParam::Last);
    enumFlags.set(TypeParam::Last);
    EXPECT_TRUE(enumFlags.has(TypeParam::Last));
    EXPECT_TRUE(enumFlags.hasAny());
}

TYPED_TEST(EnumFlagsTest, AllFlagsCanBeSetAtOnce) {
    EnumFlags<TypeParam> enumFlags;

    enumFlags.setAll();
    EXPECT_TRUE(enumFlags.has(TypeParam::First));
    EXPECT_TRUE(enumFlags.has(TypeParam::Another));
    EXPECT_TRUE(enumFlags.has(TypeParam::Last));
    EXPECT_TRUE(enumFlags.hasAny());

    enumFlags.clear();
    enumFlags.set(TypeParam::First);
    enumFlags.setAll();
    EXPECT_TRUE(enumFlags.has(TypeParam::First));
    EXPECT_TRUE(enumFlags.has(TypeParam::Another));
    EXPECT_TRUE(enumFlags.has(TypeParam::Last));
    EXPECT_TRUE(enumFlags.hasAny());
}

TYPED_TEST(EnumFlagsTest, FlagsCanBeCleared) {
    EnumFlags<TypeParam> enumFlags;

    enumFlags.setAll();
    enumFlags.clear();
    EXPECT_FALSE(enumFlags.hasAny());

    enumFlags.set(TypeParam::First);
    enumFlags.clear();
    EXPECT_FALSE(enumFlags.hasAny());
}

```

`Tests/UnitTests/Utils/FlagsBuilderTests.cpp`:

```cpp
#include <concepts>
#include <limits>
#include <type_traits>

#include <gtest/gtest.h>

#include <Utils/FlagsBuilder.h>

namespace
{

template <std::integral T>
[[nodiscard]] constexpr auto maxValue() noexcept
{
    if constexpr (std::is_unsigned_v<T>) {
        return (std::numeric_limits<T>::max)();
    } else {
        return static_cast<T>(-1);
    }
}

template <typename T>
class Utils_FlagBuilderTest : public testing::Test {
protected:
    template <T flag>
    decltype(auto) set(bool b) noexcept
    {
        return builder.template set<flag>(b);
    }

    decltype(auto) setDummyFlag(bool b) noexcept
    {
        return set<dummyFlag>(b);
    }

    [[nodiscard]] T get() noexcept
    {
        return builder.get();
    }

    static constexpr T firstFlag{ 1 << 0 };
    static constexpr T secondFlag{ 1 << 1 };
    static constexpr auto dummyFlag = maxValue<T>();

private:
    FlagsBuilder<T, T> builder;
};

using Types = testing::Types<
    signed char, unsigned char,
    signed short, unsigned short,
    signed int, unsigned int,
    signed long, unsigned long,
    signed long long, unsigned long long
>;

TYPED_TEST_SUITE(Utils_FlagBuilderTest, Types);

TYPED_TEST(Utils_FlagBuilderTest, HasValueOfZeroWhenConstructed) {
    EXPECT_EQ(this->get(), static_cast<TypeParam>(0));
}

TYPED_TEST(Utils_FlagBuilderTest, FlagIsSetWhenPassingTrue) {
    this->setDummyFlag(true);
    EXPECT_EQ(this->get(), maxValue<TypeParam>());
}

TYPED_TEST(Utils_FlagBuilderTest, FlagIsNotSetWhenPassingFalse) {
    this->setDummyFlag(false);
    EXPECT_EQ(this->get(), static_cast<TypeParam>(0));
}

TYPED_TEST(Utils_FlagBuilderTest, FlagRemainsSetWhenTryingToSetAgain) {
    this->setDummyFlag(true);
    this->setDummyFlag(true);
    EXPECT_EQ(this->get(), this->dummyFlag);
}

TYPED_TEST(Utils_FlagBuilderTest, FlagRemainsSetWhenPassingFalseAfterSetting) {
    this->setDummyFlag(true);
    this->setDummyFlag(false);
    EXPECT_EQ(this->get(), this->dummyFlag);
}

TYPED_TEST(Utils_FlagBuilderTest, MultipleIndependentFlagsCanBeSet) {
    this->template set<TestFixture::firstFlag>(true);
    this->template set<TestFixture::secondFlag>(true);
    EXPECT_EQ(this->get(), TestFixture::firstFlag | TestFixture::secondFlag);
}

TYPED_TEST(Utils_FlagBuilderTest, SetMethodReturnsTheReferenceToSelf) {
    this->template set<TestFixture::firstFlag>(true).template set<TestFixture::secondFlag>(true);
    EXPECT_EQ(this->get(), TestFixture::firstFlag | TestFixture::secondFlag);
}

}

```

`Tests/UnitTests/Utils/OptionalTests.cpp`:

```cpp
#include <array>
#include <gtest/gtest.h>
#include <Utils/Optional.h>

TEST(OptionalBoolTest, DefaultConstructedHasNoValue) {
    EXPECT_FALSE(Optional<bool>{}.hasValue());
}

TEST(OptionalBoolTest, ConstructedFromNulloptHasNoValue) {
    EXPECT_FALSE(Optional<bool>{std::nullopt}.hasValue());
}

TEST(OptionalBoolTest, ConstructedFromTrueHasValueOfTrue) {
    Optional<bool> optional{true};
    EXPECT_TRUE(optional.hasValue());
    EXPECT_EQ(optional.value(), true);
}

TEST(OptionalBoolTest, ConstructedFromFalseHasValueOfFalse) {
    Optional<bool> optional{false};
    EXPECT_TRUE(optional.hasValue());
    EXPECT_EQ(optional.value(), false);
}

struct OptionalBoolEqualOperatorTestParam {
    Optional<bool> lhs{};
    Optional<bool> rhs{};
    bool expectedEqual{};
};

class OptionalBoolEqualOperatorTest : public testing::TestWithParam<OptionalBoolEqualOperatorTestParam> {
};

TEST_P(OptionalBoolEqualOperatorTest, OperatorEqualTo) {
    EXPECT_EQ(GetParam().lhs == GetParam().rhs, GetParam().expectedEqual);
}

INSTANTIATE_TEST_SUITE_P(, OptionalBoolEqualOperatorTest, testing::ValuesIn(
    std::to_array<OptionalBoolEqualOperatorTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedEqual = true},
        {.lhs{std::nullopt}, .rhs{true}, .expectedEqual = false},
        {.lhs{std::nullopt}, .rhs{false}, .expectedEqual = false},
        {.lhs{true}, .rhs{true}, .expectedEqual = true},
        {.lhs{true}, .rhs{false}, .expectedEqual = false},
        {.lhs{true}, .rhs{std::nullopt}, .expectedEqual = false},
        {.lhs{false}, .rhs{false}, .expectedEqual = true},
        {.lhs{false}, .rhs{true}, .expectedEqual = false},
        {.lhs{false}, .rhs{std::nullopt}, .expectedEqual = false}
    })
));

struct OptionalBoolValueOrTestParam {
    Optional<bool> optional{};
    bool defaultValue{};
    bool expectedValue{};
};

class OptionalBoolValueOrTest : public testing::TestWithParam<OptionalBoolValueOrTestParam> {
};

TEST_P(OptionalBoolValueOrTest, ConstructedFromFalseHasValueOfFalse) {
    EXPECT_EQ(GetParam().optional.valueOr(GetParam().defaultValue), GetParam().expectedValue);
}

INSTANTIATE_TEST_SUITE_P(, OptionalBoolValueOrTest, testing::ValuesIn(
    std::to_array<OptionalBoolValueOrTestParam>({
        {.optional{std::nullopt}, .defaultValue = true, .expectedValue = true},
        {.optional{std::nullopt}, .defaultValue = false, .expectedValue = false},
        {.optional{true}, .defaultValue = true, .expectedValue = true},
        {.optional{true}, .defaultValue = false, .expectedValue = true},
        {.optional{false}, .defaultValue = true, .expectedValue = false},
        {.optional{false}, .defaultValue = false, .expectedValue = false}
    })
));

TEST(OptionalTest, DefaultConstructedHasNoValue) {
    EXPECT_FALSE(Optional<int>{}.hasValue());
}

TEST(OptionalTest, ConstructedFromNulloptHasNoValue) {
    EXPECT_FALSE(Optional<int>{std::nullopt}.hasValue());
}

class OptionalValueTest : public testing::TestWithParam<int> {
};

TEST_P(OptionalValueTest, ConstructedFromValueHasThatValue) {
    Optional<int> optional{GetParam()};
    EXPECT_TRUE(optional.hasValue());
    EXPECT_EQ(optional.value(), GetParam());
}

INSTANTIATE_TEST_SUITE_P(, OptionalValueTest, testing::Values(0, 10));

struct OptionalEqualOperatorTestParam {
    Optional<int> lhs{};
    Optional<int> rhs{};
    bool expectedEqual{};
};

class OptionalEqualOperatorTest : public testing::TestWithParam<OptionalEqualOperatorTestParam> {
};

TEST_P(OptionalEqualOperatorTest, OperatorEqualTo) {
    EXPECT_EQ(GetParam().lhs == GetParam().rhs, GetParam().expectedEqual);
}

INSTANTIATE_TEST_SUITE_P(, OptionalEqualOperatorTest, testing::ValuesIn(
    std::to_array<OptionalEqualOperatorTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedEqual = true},
        {.lhs{std::nullopt}, .rhs{0}, .expectedEqual = false},
        {.lhs{std::nullopt}, .rhs{10}, .expectedEqual = false},
        {.lhs{0}, .rhs{0}, .expectedEqual = true},
        {.lhs{0}, .rhs{10}, .expectedEqual = false},
        {.lhs{0}, .rhs{std::nullopt}, .expectedEqual = false},
        {.lhs{10}, .rhs{10}, .expectedEqual = true},
        {.lhs{10}, .rhs{0}, .expectedEqual = false},
        {.lhs{10}, .rhs{std::nullopt}, .expectedEqual = false}
    })
));

struct OptionalComparisonOperatorOptionalTestParam {
    Optional<int> lhs{};
    Optional<int> rhs{};
    Optional<bool> expectedResult{};
};

struct OptionalComparisonOperatorValueTestParam {
    Optional<int> lhs{};
    int rhs{};
    Optional<bool> expectedResult{};
};

class OptionalEqualMethodOptionalTest : public testing::TestWithParam<OptionalComparisonOperatorOptionalTestParam> {
};

TEST_P(OptionalEqualMethodOptionalTest, Equal) {
    EXPECT_EQ(GetParam().lhs.equal(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalEqualMethodOptionalTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{0}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs{0}, .expectedResult{true}},
        {.lhs{0}, .rhs{10}, .expectedResult{false}},
        {.lhs{0}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{10}, .rhs{10}, .expectedResult{true}},
        {.lhs{10}, .rhs{0}, .expectedResult{false}},
        {.lhs{10}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalEqualMethodValueTest : public testing::TestWithParam<OptionalComparisonOperatorValueTestParam> {
};

TEST_P(OptionalEqualMethodValueTest, Equal) {
    EXPECT_EQ(GetParam().lhs.equal(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalEqualMethodValueTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 0, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs = 0, .expectedResult{true}},
        {.lhs{0}, .rhs = 10, .expectedResult{false}},
        {.lhs{10}, .rhs = 10, .expectedResult{true}},
        {.lhs{10}, .rhs = 0, .expectedResult{false}}
    })
));

class OptionalNotEqualMethodOptionalTest : public testing::TestWithParam<OptionalComparisonOperatorOptionalTestParam> {
};

TEST_P(OptionalNotEqualMethodOptionalTest, NotEqual) {
    EXPECT_EQ(GetParam().lhs.notEqual(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalNotEqualMethodOptionalTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{0}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs{0}, .expectedResult{false}},
        {.lhs{0}, .rhs{10}, .expectedResult{true}},
        {.lhs{0}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{10}, .rhs{10}, .expectedResult{false}},
        {.lhs{10}, .rhs{0}, .expectedResult{true}},
        {.lhs{10}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalNotEqualMethodValueTest : public testing::TestWithParam<OptionalComparisonOperatorValueTestParam> {
};

TEST_P(OptionalNotEqualMethodValueTest, NotEqual) {
    EXPECT_EQ(GetParam().lhs.notEqual(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalNotEqualMethodValueTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 0, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs = 0, .expectedResult{false}},
        {.lhs{0}, .rhs = 10, .expectedResult{true}},
        {.lhs{10}, .rhs = 10, .expectedResult{false}},
        {.lhs{10}, .rhs = 0, .expectedResult{true}}
    })
));

class OptionalLessThanMethodOptionalTest : public testing::TestWithParam<OptionalComparisonOperatorOptionalTestParam> {
};

TEST_P(OptionalLessThanMethodOptionalTest, LessThan) {
    EXPECT_EQ(GetParam().lhs.lessThan(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalLessThanMethodOptionalTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{0}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs{0}, .expectedResult{false}},
        {.lhs{0}, .rhs{10}, .expectedResult{true}},
        {.lhs{0}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{10}, .rhs{10}, .expectedResult{false}},
        {.lhs{10}, .rhs{0}, .expectedResult{false}},
        {.lhs{10}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalLessThanMethodValueTest : public testing::TestWithParam<OptionalComparisonOperatorValueTestParam> {
};

TEST_P(OptionalLessThanMethodValueTest, LessThan) {
    EXPECT_EQ(GetParam().lhs.lessThan(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalLessThanMethodValueTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 0, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs = 0, .expectedResult{false}},
        {.lhs{0}, .rhs = 10, .expectedResult{true}},
        {.lhs{10}, .rhs = 10, .expectedResult{false}},
        {.lhs{10}, .rhs = 0, .expectedResult{false}}
    })
));

class OptionalGreaterThanMethodOptionalTest : public testing::TestWithParam<OptionalComparisonOperatorOptionalTestParam> {
};

TEST_P(OptionalGreaterThanMethodOptionalTest, GreaterThan) {
    EXPECT_EQ(GetParam().lhs.greaterThan(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalGreaterThanMethodOptionalTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{0}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs{0}, .expectedResult{false}},
        {.lhs{0}, .rhs{10}, .expectedResult{false}},
        {.lhs{0}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{10}, .rhs{10}, .expectedResult{false}},
        {.lhs{10}, .rhs{0}, .expectedResult{true}},
        {.lhs{10}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalGreaterThanMethodValueTest : public testing::TestWithParam<OptionalComparisonOperatorValueTestParam> {
};

TEST_P(OptionalGreaterThanMethodValueTest, GreaterThan) {
    EXPECT_EQ(GetParam().lhs.greaterThan(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalGreaterThanMethodValueTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 0, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs = 0, .expectedResult{false}},
        {.lhs{0}, .rhs = 10, .expectedResult{false}},
        {.lhs{10}, .rhs = 10, .expectedResult{false}},
        {.lhs{10}, .rhs = 0, .expectedResult{true}}
    })
));

class OptionalLessEqualMethodOptionalTest : public testing::TestWithParam<OptionalComparisonOperatorOptionalTestParam> {
};

TEST_P(OptionalLessEqualMethodOptionalTest, LessEqual) {
    EXPECT_EQ(GetParam().lhs.lessEqual(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalLessEqualMethodOptionalTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{0}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs{0}, .expectedResult{true}},
        {.lhs{0}, .rhs{10}, .expectedResult{true}},
        {.lhs{0}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{10}, .rhs{10}, .expectedResult{true}},
        {.lhs{10}, .rhs{0}, .expectedResult{false}},
        {.lhs{10}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalLessEqualMethodValueTest : public testing::TestWithParam<OptionalComparisonOperatorValueTestParam> {
};

TEST_P(OptionalLessEqualMethodValueTest, LessEqual) {
    EXPECT_EQ(GetParam().lhs.lessEqual(GetParam().rhs), GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalLessEqualMethodValueTest, testing::ValuesIn(
    std::to_array<OptionalComparisonOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 0, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{0}, .rhs = 0, .expectedResult{true}},
        {.lhs{0}, .rhs = 10, .expectedResult{true}},
        {.lhs{10}, .rhs = 10, .expectedResult{true}},
        {.lhs{10}, .rhs = 0, .expectedResult{false}}
    })
));

struct OptionalBinaryOperatorOptionalTestParam {
    Optional<int> lhs{};
    Optional<int> rhs{};
    Optional<int> expectedResult{};
};

struct OptionalBinaryOperatorValueTestParam {
    Optional<int> lhs{};
    int rhs{};
    Optional<int> expectedResult{};
};

class OptionalMinusOperatorOptionalTest : public testing::TestWithParam<OptionalBinaryOperatorOptionalTestParam> {
};

TEST_P(OptionalMinusOperatorOptionalTest, MinusOperator) {
    EXPECT_EQ(GetParam().lhs - GetParam().rhs, GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalMinusOperatorOptionalTest, testing::ValuesIn(
    std::to_array<OptionalBinaryOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{1}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{1}, .rhs{1}, .expectedResult{0}},
        {.lhs{1}, .rhs{10}, .expectedResult{-9}},
        {.lhs{1}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{10}, .rhs{10}, .expectedResult{0}},
        {.lhs{10}, .rhs{1}, .expectedResult{9}},
        {.lhs{10}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalMinusOperatorValueTest : public testing::TestWithParam<OptionalBinaryOperatorValueTestParam> {
};

TEST_P(OptionalMinusOperatorValueTest, MinusOperator) {
    EXPECT_EQ(GetParam().lhs - GetParam().rhs, GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalMinusOperatorValueTest, testing::ValuesIn(
    std::to_array<OptionalBinaryOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 1, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{1}, .rhs = 1, .expectedResult{0}},
        {.lhs{1}, .rhs = 10, .expectedResult{-9}},
        {.lhs{10}, .rhs = 10, .expectedResult{0}},
        {.lhs{10}, .rhs = 1, .expectedResult{9}}
    })
));

class OptionalBitandOperatorOptionalTest : public testing::TestWithParam<OptionalBinaryOperatorOptionalTestParam> {
};

TEST_P(OptionalBitandOperatorOptionalTest, BitandOperator) {
    EXPECT_EQ(GetParam().lhs & GetParam().rhs, GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalBitandOperatorOptionalTest, testing::ValuesIn(
    std::to_array<OptionalBinaryOperatorOptionalTestParam>({
        {.lhs{std::nullopt}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{3}, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs{10}, .expectedResult{std::nullopt}},
        {.lhs{3}, .rhs{3}, .expectedResult{3}},
        {.lhs{3}, .rhs{4}, .expectedResult{0}},
        {.lhs{3}, .rhs{10}, .expectedResult{2}},
        {.lhs{10}, .rhs{10}, .expectedResult{10}},
        {.lhs{4}, .rhs{3}, .expectedResult{0}},
        {.lhs{10}, .rhs{3}, .expectedResult{2}},
        {.lhs{3}, .rhs{std::nullopt}, .expectedResult{std::nullopt}},
        {.lhs{4}, .rhs{std::nullopt}, .expectedResult{std::nullopt}}
    })
));

class OptionalBitandOperatorValueTest : public testing::TestWithParam<OptionalBinaryOperatorValueTestParam> {
};

TEST_P(OptionalBitandOperatorValueTest, BitandOperator) {
    EXPECT_EQ(GetParam().lhs & GetParam().rhs, GetParam().expectedResult);
}

INSTANTIATE_TEST_SUITE_P(, OptionalBitandOperatorValueTest, testing::ValuesIn(
    std::to_array<OptionalBinaryOperatorValueTestParam>({
        {.lhs{std::nullopt}, .rhs = 3, .expectedResult{std::nullopt}},
        {.lhs{std::nullopt}, .rhs = 10, .expectedResult{std::nullopt}},
        {.lhs{3}, .rhs = 3, .expectedResult{3}},
        {.lhs{3}, .rhs = 4, .expectedResult{0}},
        {.lhs{3}, .rhs = 10, .expectedResult{2}},
        {.lhs{10}, .rhs = 10, .expectedResult{10}},
        {.lhs{4}, .rhs = 3, .expectedResult{0}},
        {.lhs{10}, .rhs = 3, .expectedResult{2}},
    })
));

```

`Tests/UnitTests/Utils/PatternFinderTests.cpp`:

```cpp
#include <algorithm>
#include <array>
#include <cstddef>
#include <string>
#include <string_view>

#include <emmintrin.h>

#include <gtest/gtest.h>

#include <MemorySearch/BytePatternLiteral.h>
#include <MemorySearch/PatternFinder.h>

namespace pattern_finder_tests
{

template <std::size_t N>
[[nodiscard]] constexpr auto createByteArray(const unsigned char(&bytes)[N])
{
    std::array<std::byte, N> arr;
    std::ranges::transform(bytes, arr.begin(), [](unsigned char c) { return std::byte{ c }; });
    return arr;
}

template <std::size_t N>
[[nodiscard]] constexpr auto createByteArray()
{
    std::array<std::byte, N> arr;
    arr.fill(std::byte{ 0xCC });
    return arr;
}

struct DummyPatternNotFoundHandler {
    static void onPatternNotFound(BytePattern) {}
};

TEST(Utils_PatternFinderTest, ShortPatternCanBeFound) {
    constexpr auto bytes = createByteArray({ 0xA0, 0xA1, 0xA2 });
    const PatternFinder<DummyPatternNotFoundHandler> finder{bytes};
    EXPECT_EQ(finder("A1"_pat).as<std::uintptr_t>(), std::uintptr_t(&bytes[1]));
}

TEST(Utils_PatternFinderTest, ReturnsNullptrWhenByteBufferIsEmpty) {
    const PatternFinder<DummyPatternNotFoundHandler> finder{{}};
    EXPECT_EQ(finder("01 02 03 04"_pat).as<std::uintptr_t>(), 0);
}

TEST(Utils_PatternFinderTest, ReturnsNullptrWhenPatternWasNotFound) {
    constexpr auto bytes = createByteArray({ 0xA0 });
    const PatternFinder<DummyPatternNotFoundHandler> finder{bytes};
    EXPECT_EQ(finder("AB CD EF"_pat).as<std::uintptr_t>(), 0);
}

TEST(Utils_PatternFinderTest, PatternCanBeFoundWithSIMD) {
    auto bytes = createByteArray<100>();
    bytes[30] = std::byte{ 0xDE };
    bytes[41] = std::byte{ 0xDE };
    bytes[42] = std::byte{ 0xAD };
    bytes[43] = std::byte{ 0x00 };
    bytes[44] = std::byte{ 0xC0 };
    bytes[45] = std::byte{ 0xDE };
    
    const PatternFinder<DummyPatternNotFoundHandler> finder{bytes};
    EXPECT_EQ(finder("DE AD ? C0 DE"_pat).as<std::uintptr_t>(), std::uintptr_t(&bytes[41]));
}

}

```

`Tests/UnitTests/Utils/RefCountedHookTests.cpp`:

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Utils/RefCountedHook.h>

namespace
{

struct MockHook : RefCountedHook<MockHook> {
    MOCK_METHOD(bool, isInstalled, (), (const noexcept));
    MOCK_METHOD(void, install, (), (noexcept));
    MOCK_METHOD(void, uninstall, (), (noexcept));
};

class RefCountedHookTest : public testing::Test {
protected:
    testing::StrictMock<MockHook> hook;
};

using testing::Return;

TEST_F(RefCountedHookTest, WillBeInstalledIfReferenced) {
    hook.incrementReferenceCount();
    hook.incrementReferenceCount();
    hook.decrementReferenceCount();

    EXPECT_CALL(hook, isInstalled()).WillOnce(Return(false));
    EXPECT_CALL(hook, install());
    hook.update();
}

TEST_F(RefCountedHookTest, WillNotBeInstalledIfNotReferenced) {
    hook.incrementReferenceCount();
    hook.decrementReferenceCount();

    EXPECT_CALL(hook, isInstalled()).WillOnce(Return(false));
    EXPECT_CALL(hook, install()).Times(0);
    hook.update();
}

TEST_F(RefCountedHookTest, WillBeUninstalledIfNotReferenced) {
    hook.incrementReferenceCount();
    hook.decrementReferenceCount();

    EXPECT_CALL(hook, isInstalled()).WillOnce(Return(true));
    EXPECT_CALL(hook, uninstall());
    hook.update();
}

TEST_F(RefCountedHookTest, WillNotBeUninstalledIfReferenced) {
    hook.incrementReferenceCount();
    hook.incrementReferenceCount();
    hook.decrementReferenceCount();

    EXPECT_CALL(hook, isInstalled()).WillOnce(Return(true));
    EXPECT_CALL(hook, uninstall()).Times(0);
    hook.update();
}

TEST_F(RefCountedHookTest, WillBeForceUninstalledWhenInstalled) {
    EXPECT_CALL(hook, isInstalled()).WillOnce(Return(true));
    EXPECT_CALL(hook, uninstall());
    hook.forceUninstall();
}

TEST_F(RefCountedHookTest, WillNotBeForceUninstalledWhenNotInstalled) {
    EXPECT_CALL(hook, isInstalled()).WillOnce(Return(false));
    EXPECT_CALL(hook, uninstall()).Times(0);
    hook.forceUninstall();
}

}

```

`Tests/UnitTests/Utils/ReturnAddressTests.cpp`:

```cpp
#include <utility>

#include <gtest/gtest.h>

#include <Utils/ReturnAddress.h>

namespace
{

class ReturnAddressTest : public testing::TestWithParam<std::pair<void*, void*>> {};

TEST_P(ReturnAddressTest, SameReturnAddressesCompareEqual) {
    EXPECT_EQ(ReturnAddress{GetParam().first}, ReturnAddress{GetParam().first});
}

TEST_P(ReturnAddressTest, DifferentReturnAddressesDoNotCompareEqual) {
    EXPECT_NE(ReturnAddress{GetParam().first}, ReturnAddress{GetParam().second});
    EXPECT_NE(ReturnAddress{GetParam().second}, ReturnAddress{GetParam().first});
}

INSTANTIATE_TEST_SUITE_P(, ReturnAddressTest, testing::Values(
    std::pair{nullptr, reinterpret_cast<void*>(1234)},
    std::pair{reinterpret_cast<void*>(2048), reinterpret_cast<void*>(-1)},
    std::pair{reinterpret_cast<void*>(-1), nullptr}
));

}

```

`Tests/UnitTests/Utils/SpanSliceTests.cpp`:

```cpp
#include <gtest/gtest.h>
#include <vector>

#include <Utils/SpanSlice.h>

namespace
{

TEST(SpanSliceTest, SliceSizeIsClampedBySpanSize) {
    SpanSlice<10, int> slice{ {}, 123 };
    EXPECT_TRUE(slice().empty());
}

TEST(SpanSliceTest, SliceIsCreatedAroundCenterOffsetIfPossible) {
    std::vector<int> v(1000);
    SpanSlice<200, int> slice{ v, 256 };
    EXPECT_EQ(&slice().front(), &v[156]);
    EXPECT_EQ(&slice().back(), &v[355]);
}

TEST(SpanSliceTest, SliceIsCreatedFromStartIfCenterOffsetIsLowerThanHalfOfSliceSize) {
    std::vector<int> v(500);
    SpanSlice<200, int> slice{ v, 80 };
    EXPECT_EQ(&slice().front(), &v[0]);
    EXPECT_EQ(&slice().back(), &v[199]);
}

TEST(SpanSliceTest, SliceIsCreatedBeforeEndIfCenterOffsetIsHigherThanSpanSizeMinusHalfOfSliceSize) {
    std::vector<int> v(500);
    SpanSlice<200, int> slice{ v, 490 };
    EXPECT_EQ(&slice().front(), &v[300]);
    EXPECT_EQ(&slice().back(), &v[499]);
}

}

```

`Tests/UnitTests/Utils/StringBuilderTests.cpp`:

```cpp
#include <algorithm>
#include <memory>
#include <string_view>

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <Utils/StringBuilder.h>

namespace
{

class TestStringBuilder : public testing::Test {
protected:
    [[nodiscard]] auto bufferString() const noexcept
    {
        return std::string_view{ std::begin(buffer), std::end(buffer) };
    }

    void putIntoBuffer(std::string_view str)
    {
        std::copy_n(str.data(), (std::min)(str.size(), sizeof(buffer)), &buffer[0]);
    }

    char buffer[30]{};
    StringBuilder builder{ buffer };
};

TEST_F(TestStringBuilder, StringIsFormattedIntoProvidedBuffer) {
    builder.put('a', " first ", 1234, [](StringBuilder& builder) { builder.put(567); }, " end");
    EXPECT_TRUE(bufferString().starts_with("a first 1234567 end"));
}

TEST_F(TestStringBuilder, PutMethodReturnsReferenceToSelf) {
    decltype(auto) result = builder.put("str");
    EXPECT_EQ(std::addressof(result), std::addressof(builder));
}

TEST_F(TestStringBuilder, PutHexMethodReturnsReferenceToSelf) {
    decltype(auto) result = builder.putHex(0x123);
    EXPECT_EQ(std::addressof(result), std::addressof(builder));
}

TEST_F(TestStringBuilder, StringViewWithCanBeRetrieved) {
    builder.put("some string ").putHex(0xc0de);
    const auto string = builder.string();
    EXPECT_EQ(string.data(), &buffer[0]);
    EXPECT_EQ(string, "some string c0de");
}

TEST_F(TestStringBuilder, NullTerminatedCstringCanBeRetrieved) {
    putIntoBuffer("abcdef");
    builder.put("str");
    const auto cstring = builder.cstring();
    EXPECT_EQ(cstring, &buffer[0]);
    EXPECT_STREQ(cstring, "str");
}

TEST_F(TestStringBuilder, EmptyStringViewIsReturnedWhenNothingWasWritten) {
    const auto string = builder.string();
    EXPECT_EQ(string.data(), &buffer[0]);
    EXPECT_TRUE(string.empty());
}

TEST_F(TestStringBuilder, EmptyNullTerminatedCstringIsReturnedWhenNothingWasWritten) {
    const auto cstring = builder.cstring();
    EXPECT_EQ(cstring, &buffer[0]);
    EXPECT_EQ(cstring[0], '\0');
}

TEST_F(TestStringBuilder, StringCanBeWritten) {
    builder.put("one").put("two").put("three");
    EXPECT_EQ(builder.string(), "onetwothree");
}

TEST_F(TestStringBuilder, CharCanBeWritten) {
    builder.put('x').put('y').put('z');
    EXPECT_EQ(builder.string(), "xyz");
}

TEST_F(TestStringBuilder, IntegerCanBeWrittenAsDecimal) {
    builder.put(123).put(456).put(777);
    EXPECT_EQ(builder.string(), "123456777");
}

TEST_F(TestStringBuilder, IntegerCanBeWrittenAsHexadecimal) {
    builder.putHex(0xc).putHex(0xabcdef0123456789);
    EXPECT_EQ(builder.string(), "cabcdef0123456789");
}

TEST_F(TestStringBuilder, PutAcceptsInvocable) {
    testing::MockFunction<void(StringBuilder& builder)> mockInvocable;
    EXPECT_CALL(mockInvocable, Call(testing::Ref(builder))).WillOnce(testing::Invoke(
        [](StringBuilder& builder) { builder.put("123"); }
    ));
    builder.put(mockInvocable.AsStdFunction());
    EXPECT_EQ(builder.string(), "123");
}

}

```