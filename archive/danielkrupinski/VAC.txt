Project Path: arc_danielkrupinski_VAC_9_x9bvjr

Source Tree:

```txt
arc_danielkrupinski_VAC_9_x9bvjr
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ VAC
‚îÇ   ‚îú‚îÄ‚îÄ Encryption
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Ice.c
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Ice.h
‚îÇ   ‚îú‚îÄ‚îÄ Modules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DeviceInfo
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DeviceInfo.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DeviceInfo.h
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DriverInfo
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DriverInfo.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DriverInfo.h
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessHandleList
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessHandleList.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProcessHandleList.h
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessMonitor
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessMonitor.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProcessMonitor.h
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReadModules
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReadModules.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ReadModules.h
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SystemInfo
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SystemInfo.c
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SystemInfo.h
‚îÇ   ‚îú‚îÄ‚îÄ Utils.c
‚îÇ   ‚îú‚îÄ‚îÄ Utils.h
‚îÇ   ‚îú‚îÄ‚îÄ VAC.vcxproj
‚îÇ   ‚îú‚îÄ‚îÄ VAC.vcxproj.filters
‚îÇ   ‚îú‚îÄ‚îÄ Vector.c
‚îÇ   ‚îî‚îÄ‚îÄ Vector.h
‚îî‚îÄ‚îÄ VAC.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 Daniel Krupi≈Ñski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# VAC üõ°Ô∏è
This repository contains parts of source code of Valve Anti-Cheat for Windows systems recreated from machine code.

# Introduction
Valve Anti-Cheat (VAC) is user-mode noninvasive anti-cheat system developed by Valve. It is delivered in form of modules (dlls) streamed from the remote server. `steamservice.dll` loaded into `SteamService.exe` (or `Steam.exe` if run as admin) prepares and runs anti-cheat modules. Client VAC infrastructure is built using `C++` (indicated by many `thiscall` convention functions present in disassembly) but this repo contains `C` code for simplicity. Anti-cheat binaries are currently `32-bit`.

# Modules
| ID | Purpose | .text section raw size | Source folder |
| --- | --- | --- | --- |
| 1 | Collect information about system configuration.<br>This module is loaded first and sometimes even before any VAC-secured game is launched. | 0x5C00 | Modules/SystemInfo
| 2 | Enumerate running processes and handles.<br>This module is loaded shortly after game is launched but also repeatedly later. | 0x4A00 | Modules/ProcessHandleList
| 3 | Collect `VacProcessMonitor` data from filemapping created by `steamservice.dll`. It's the first module observed to use `virtual methods (polymorphism)`. | 0x6600 | Modules/ProcessMonitor

# Encryption / Hashing
VAC uses several encryption / hashing methods:
- MD5 - hashing data read from process memory
- ICE - decryption of imported functions names and encryption of scan results
- CRC32 - hashing table of WinAPI functions addresses
- Xor - encryption of function names on stack, e.g `NtQuerySystemInformation`. Strings are xor-ed with `^` or `>` or `&` char.

# Module Description

## #1 - SystemInfo
This module is loaded first and sometimes even before any VAC-secured game is launched.

At first module invokes [`GetVersion`](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion) function to retrieve **major and build** system version e.g `0x47BB0A00` - which means:
- 0x47BB - build version (decimal `18363‚Ä¨`) 
- 0x0A00 - major version (decimal `10`)

The module calls `GetNativeSystemInfo` function and reads fields from resultant [`SYSTEM_INFO`](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-system_info) struct:
- wProcessorArchitecture
- dwProcessorType

Then it calls [`NtQuerySystemInformation`](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation) API function with following `SystemInformationClass` values (in order they appear in code):
- SystemTimeOfDayInformation - returns undocumented [`SYSTEM_TIMEOFDAY_INFORMATION`](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/timeofday.htm) struct, VAC uses two fields:
    - LARGE_INTEGER CurrentTime
    - LARGE_INTEGER BootTime
- SystemCodeIntegrityInformation - returns [`SYSTEM_CODEINTEGRITY_INFORMATION`](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/codeintegrity.htm), module saves `CodeIntegrityOptions` field
- SystemDeviceInformation - returns [`SYSTEM_DEVICE_INFORMATION`](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/device.htm), module saves `NumberOfDisks` field
- SystemKernelDebuggerInformation - returns [`SYSTEM_KERNEL_DEBUGGER_INFORMATION`](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/kernel_debugger.htm), VAC uses whole struct
- SystemBootEnvironmentInformation - returns [`SYSTEM_BOOT_ENVIRONMENT_INFORMATION`](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/boot_environment.htm), VAC copies `BootIdentifier` GUID
- SystemRangeStartInformation - returns `SYSTEM_RANGE_START_INFORMATION` which is just `void*`. Anti-cheat saves returned **kernel space start address** and **sign bit** of that address (to check if executable inside which VAC is running is linked with [`LARGEADDRESSAWARE`](https://docs.microsoft.com/en-us/cpp/build/reference/largeaddressaware-handle-large-addresses) option)

For more information about `SYSTEM_INFORMATION_CLASS` enum see [Geoff Chappell's page](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/class.htm).

Next, anti-cheat calls [`GetProcessImageFileNameA`](https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamea) function to retrieve path of current executable and **reads last 36 characters** (e.g. `\Program Files (x86)\Steam\Steam.exe`).

Later VAC retrieves **system directory path** (e.g `C:\WINDOWS\system32`) using [`GetSystemDirectoryW`](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemdirectoryw), converts it from wide-char to multibyte string, and stores it (max length of multibyte string - 200).
Anti-cheat queries folder FileID (using [`GetFileInformationByHandleEx`](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfileinformationbyhandleex)) and **volume serial number** ([`GetVolumeInformationByHandleW`](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew)). Further it does the same with **windows directory** got from [`GetWindowsDirectoryW`](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectoryw) API.

Module reads `NtDll.dll` file from **system directory** and does some processing on it (not reversed yet).

VAC saves **handles (base addresses) of imported system dlls** (max 16, this VAC module loads 12 dlls) and **pointers to WINAPI functions** (max 160, module uses 172 functions‚Ä¨). This is done to detect **import address table hooking** on anti-cheat module, if **function address** is lower than corresponding **module base**, function has been hooked.

Anti-cheat gets self **module base** by performing **bitwise and** on **return address** (`_ReturnAddress() & 0xFFFF0000`). Then it collects:
- module base address
- first four bytes at module base address (from DOS header)
- DWORD at **module base + 0x114**
- DWORD at **module base + 0x400** (start of .text section)

Next it enumerates **volumes** using `FindFirstVolumeW` / `FindNextVolumeW` API. VAC queries volume information by calling `GetVolumeInformationW`, `GetDriveTypeW` and `GetVolumePathNamesForVolumeNameW` functions and fills following struct with collected data:

```cpp
struct VolumeData {
    UINT volumeGuidHash;
    DWORD getVolumeInformationError;
    DWORD fileSystemFlags;
    DWORD volumeSerialNumber;
    UINT volumeNameHash;
    UINT fileSystemNameHash;
    WORD driveType;
    WORD volumePathNameLength;
    DWORD volumePathNameHash;
}; // sizeof(VolumeData) == 32
```
VAC gathers data of max. 10 volumes.

If this module was streamed after VAC-secured game had started, it attemps to get handle to the game process (using `OpenProcess` API).

Eventually, module encrypts data (2048 bytes), DWORD by DWORD XORing with key received from server (e.g 0x1D4855D3)

## #2 - ProcessHandleList

To be disclosed...

## #3 - ProcessMonitor

This module seems to be relatively `new` or was disabled for a long time. First time I saw this module in `January 2020`. It has an ability to perform many different types of scans (currently `3`). Further scans depends on the results of previous ones.

Each scan type implements `four methods` of a base class.

Initially VAC server instructs client to perform `scan #1`.

### Scan #1 - VacProcessMonitor filemapping

First scan function attemps to open `Steam_{E9FD3C51-9B58-4DA0-962C-734882B19273}_Pid:%000008X` filemapping. The mapping has following layout:

```cpp
struct VacProcessMonitorMapping {
    DWORD magic; // when initialized - 0x30004
    PVOID vacProcessMonitor;
}; // sizeof(VacProcessMonitorMapping) == 8
```

`VacProcessMonitorMapping::vacProcessMonitor` is a pointer to the `VacProcessMonitor` object (size of which is `292 bytes`).

VAC then reads the whole `VacProcessMonitor` object (292 bytes) and its VMT (Virtual Method Table) containing pointers to `6` methods (24 bytes).
The base address of `steamservice.dll` is also gathered.

These data are probably used on VAC servers to detect hooking `VacProcessMonitor`. The procedure may be following:
```cpp
if (method_ptr & 0xFFFF0000 != steamservice_base)
    hook_detected();
```

```

`VAC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29215.179
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VAC", "VAC\VAC.vcxproj", "{F6E84D48-D08A-4CB7-9750-BDD8504A7232}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Debug|x64.ActiveCfg = Debug|x64
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Debug|x64.Build.0 = Debug|x64
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Debug|x86.ActiveCfg = Debug|Win32
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Debug|x86.Build.0 = Debug|Win32
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Release|x64.ActiveCfg = Release|x64
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Release|x64.Build.0 = Release|x64
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Release|x86.ActiveCfg = Release|Win32
		{F6E84D48-D08A-4CB7-9750-BDD8504A7232}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3F9BE67F-9BCD-4D1D-B049-2048627280C1}
	EndGlobalSection
EndGlobal

```

`VAC/Encryption/Ice.c`:

```c
#include "../Utils.h"
#include "Ice.h"

// BA ? ? ? ? 85 C9
static CONST UINT Ice_pbox[32] = {
    0x00000001, 0x00000080, 0x00000400, 0x00002000,
    0x00080000, 0x00200000, 0x01000000, 0x40000000,
    0x00000008, 0x00000020, 0x00000100, 0x00004000,
    0x00010000, 0x00800000, 0x04000000, 0x20000000,
    0x00000004, 0x00000010, 0x00000200, 0x00008000,
    0x00020000, 0x00400000, 0x08000000, 0x10000000,
    0x00000002, 0x00000040, 0x00000800, 0x00001000,
    0x00040000, 0x00100000, 0x02000000, 0x80000000 };

// 33 C0 BA ? ? ? ?
UINT Ice_perm32(UINT x)
{
    UINT result = 0;
    CONST UINT* pbox = Ice_pbox;

    while (x) {
        if (x & 1)
            result |= *pbox;
        pbox++;
        x >>= 1;
    }

    return result;
}

// E8 ? ? ? ? 59 5F (relative jump)
UINT Ice_gfMul(UINT a, UINT b, UINT m)
{
    UINT result = 0;

    while (b) {
        if (b & 1)
            result ^= a;

        a <<= 1;
        b >>= 1;

        if (a >= 256)
            a ^= m;
    }

    return result;
}

// E8 ? ? ? ? 8B C8 (relative jump)
UINT Ice_gfExp7(UINT b, UINT m)
{
    if (!b)
        return 0;

    UINT x = Ice_gfMul(b, b, m);
    x = Ice_gfMul(b, x, m);
    x = Ice_gfMul(x, x, m);
    return Ice_gfMul(b, x, m);
}

static UINT Ice_sbox[4][1024];
static BOOL Ice_sboxesInitialized = 0;

// E8 ? ? ? ? 89 3D ? ? ? ? (relative jump)
VOID Ice_InitSboxes(VOID)
{
    static CONST INT iceSmod[4][4] = {
        { 333, 313, 505, 369 },
        { 379, 375, 319, 391 },
        { 361, 445, 451, 397 },
        { 397, 425, 395, 505 } };

    static CONST INT iceSxor[4][4] = {
        { 0x83, 0x85, 0x9B, 0xCD },
        { 0xCC, 0xA7, 0xAD, 0x41 },
        { 0x4B, 0x2E, 0xD4, 0x33 },
        { 0xEA, 0xCB, 0x2E, 0x04 } };

    for (INT i = 0; i < 1024; i++) {
        CONST INT col = (i >> 1) & 0xFF;
        CONST INT row = (i & 1) | ((i & 0x200) >> 8);

        UINT x = Ice_gfExp7(col ^ iceSxor[0][row], iceSmod[0][row]) << 24;
        Ice_sbox[0][i] = Ice_perm32(x);

        x = Ice_gfExp7(col ^ iceSxor[1][row], iceSmod[1][row]) << 16;
        Ice_sbox[1][i] = Ice_perm32(x);

        x = Ice_gfExp7(col ^ iceSxor[2][row], iceSmod[2][row]) << 8;
        Ice_sbox[2][i] = Ice_perm32(x);

        x = Ice_gfExp7(col ^ iceSxor[3][row], iceSmod[3][row]);
        Ice_sbox[3][i] = Ice_perm32(x);
    }
}

// 56 57 33 FF 8B F1
IceKey* Ice_createKey(IceKey* iceKey, INT n)
{
    if (!Ice_sboxesInitialized) {
        Ice_InitSboxes();
        Ice_sboxesInitialized = TRUE;
    }

    iceKey->size = 1;
    iceKey->rounds = 16;
    iceKey->keys = Utils_heapAlloc(192);
    return iceKey;
}

// E8 ? ? ? ? EB 68 (relative jump)
VOID Ice_scheduleBuild(IceKey* iceKey, PUSHORT kb, INT n, CONST INT* keyrot)
{
    for (INT i = 0; i < 8; i++) {
        IceSubkey* iceSubkey = &iceKey->keys[n + i];

        for (INT j = 0; j < 3; j++)
            iceSubkey->val[j] = 0;

        for (INT j = 0; j < 15; j++) {
            PULONG currentSubkey = &iceSubkey->val[j % 3];

            for (INT k = 0; k < 4; k++) {
                PUSHORT currentKb = &kb[(keyrot[i] + k) & 3];
                CONST INT bit = *currentKb & 1;

                *currentSubkey = (*currentSubkey << 1) | bit;
                *currentKb = (*currentKb >> 1) | ((bit ^ 1) << 15);
            }
        }
    }
}

// E8 ? ? ? ? 2B FE (relative jump)
VOID Ice_set(IceKey* iceKey, PCSTR key)
{
    static CONST INT iceKeyrot[16] = {
         0, 1, 2, 3, 2, 1, 3, 0,
         1, 3, 2, 0, 3, 1, 0, 2 };

    if (iceKey->rounds == 8) {
        USHORT kb[4];

        for (INT i = 0; i < 4; i++)
            kb[3 - i] = (key[i * 2] << 8) | key[i * 2 + 1];

        Ice_scheduleBuild(iceKey, kb, 0, iceKeyrot);
        return;
    }

    for (INT i = 0; i < iceKey->size; i++) {
        USHORT kb[4];

        for (INT j = 0; j < 4; j++)
            kb[3 - j] = (key[i * 8 + j * 2] << 8) | key[i * 8 + j * 2 + 1];

        Ice_scheduleBuild(iceKey, kb, i * 8, iceKeyrot);
        Ice_scheduleBuild(iceKey, kb, iceKey->rounds - 8 - i * 8, &iceKeyrot[8]);
    }
}

// 53 33 DB 56 8B F3
BOOL Ice_destroyKey(IceKey* iceKey)
{
    for (INT i = 0; i < iceKey->rounds; i++)
        for (INT j = 0; j < 3; j++)
            iceKey->keys[i].val[j] = 0;

    iceKey->rounds = iceKey->size = 0;

    return Utils_heapFree(iceKey->keys);
}

// E8 ? ? ? ? 8B 4C 24 14 (relative jump) or E8 ? ? ? ? 8B 4D 08 (relative jump)
UINT Ice_f(UINT p, const IceSubkey* sk)
{
    UINT tl = ((p >> 16) & 0x3FF) | (((p >> 14) | (p << 18)) & 0xFFC00);
    UINT tr = (p & 0x3FF) | ((p << 2) & 0xFFC00);

    UINT al = sk->val[2] & (tl ^ tr);
    UINT ar = al ^ tr ^ tl;

    al ^= sk->val[0];
    ar ^= sk->val[1];

    return Ice_sbox[0][al >> 10] | Ice_sbox[1][al & 0x3FF] | Ice_sbox[2][ar >> 10] | Ice_sbox[3][ar & 0x3FF];
}

// E8 ? ? ? ? 83 C7 08 (relative jump)
VOID Ice_decrypt(IceKey* iceKey, PCSTR ctext, PSTR ptext)
{
    UINT l = ctext[3] | ((ctext[2] | ((ctext[1] | (ctext[0] << 8)) << 8)) << 8);
    UINT r = ctext[7] | ((ctext[6] | ((ctext[5] | (ctext[4] << 8)) << 8)) << 8);

    for (INT i = iceKey->rounds - 1; i > 0; i -= 2) {
        l ^= Ice_f(r, &iceKey->keys[i]);
        r ^= Ice_f(l, &iceKey->keys[i - 1]);
    }

    for (INT i = 0; i < 4; i++) {
        ptext[3 - i] = r & 0xff;
        ptext[7 - i] = l & 0xff;

        r >>= 8;
        l >>= 8;
    }
}

// E8 ? ? ? ? 83 C6 08 (relative jump)
VOID Ice_encrypt(IceKey* iceKey, PCSTR ptext, PSTR ctext)
{
    UINT l = ptext[3] | ((ptext[2] | ((ptext[1] | (ptext[0] << 8)) << 8)) << 8);
    UINT r = ptext[7] | ((ptext[6] | ((ptext[5] | (ptext[4] << 8)) << 8)) << 8);

    for (INT i = 0; i < iceKey->rounds; i += 2) {
        l ^= Ice_f(r, &iceKey->keys[i]);
        r ^= Ice_f(l, &iceKey->keys[i + 1]);
    }

    for (INT i = 0; i < 4; i++) {
        ctext[3 - i] = r & 0xff;
        ctext[7 - i] = l & 0xff;

        r >>= 8;
        l >>= 8;
    }
}

```

`VAC/Encryption/Ice.h`:

```h
#pragma once

#include <Windows.h>

// 33 C0 BA ? ? ? ?
UINT Ice_perm32(UINT);

// E8 ? ? ? ? 59 5F (relative jump)
UINT Ice_gfMul(UINT, UINT, UINT);

// E8 ? ? ? ? 8B C8 (relative jump)
UINT Ice_gfExp7(UINT, UINT);

// E8 ? ? ? ? 89 3D ? ? ? ? (relative jump)
VOID Ice_InitSboxes(VOID);

typedef struct IceSubkey {
    UINT val[3];
} IceSubkey;

typedef struct IceKey {
    INT size;
    INT rounds;
    IceSubkey* keys;
} IceKey;

// 56 57 33 FF 8B F1
IceKey* Ice_createKey(IceKey*, INT);

// E8 ? ? ? ? EB 68 (relative jump)
VOID Ice_scheduleBuild(IceKey*, PUSHORT, INT, CONST INT*);

// E8 ? ? ? ? 2B FE (relative jump)
VOID Ice_set(IceKey*, PCSTR);

// 53 33 DB 56 8B F3
BOOL Ice_destroyKey(IceKey*);

// E8 ? ? ? ? 8B 4C 24 14 (relative jump) or E8 ? ? ? ? 8B 4D 08 (relative jump)
UINT Ice_f(UINT, const IceSubkey*);

// E8 ? ? ? ? 83 C7 08 (relative jump)
VOID Ice_decrypt(IceKey*, PCSTR, PSTR);

// E8 ? ? ? ? 83 C6 08 (relative jump)
VOID Ice_encrypt(IceKey*, PCSTR, PSTR);

```

`VAC/Modules/DeviceInfo/DeviceInfo.c`:

```c
#include "DeviceInfo.h"

// E8 ? ? ? ? 8D 54 24 28 (relative jump)
PSTR DeviceInfo_strstr(PCSTR str1, PCSTR str2)
{
    PCSTR first = str1;
    PCSTR second = str2;

    while (*first && *second) {
        if (*first == *second) {
            ++second;
            ++first;
        } else {
            first = ++str1;
            second = str2;
        }
    }
    return !*second ? (PSTR)str1 : NULL;
}

```

`VAC/Modules/DeviceInfo/DeviceInfo.h`:

```h
#pragma once

#include <Windows.h>

// E8 ? ? ? ? 8D 54 24 28 (relative jump)
PSTR DeviceInfo_strstr(PCSTR, PCSTR);

```

`VAC/Modules/DriverInfo/DriverInfo.c`:

```c
#include "../../Utils.h"
#include "DriverInfo.h"

// 55 8B EC A1
BOOLEAN DriveInfo_getFileInfo(PCWSTR fileName, DWORD* volumeSerialNumber, DWORD fileIndex[2])
{
    if (!winApi.GetFileInformationByHandle)
        return FALSE;
    
    HANDLE fileHandle = winApi.CreateFileW(fileName, READ_CONTROL | SYNCHRONIZE | FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fileHandle == INVALID_HANDLE_VALUE)
        return FALSE;

    BY_HANDLE_FILE_INFORMATION fileInformation;
    BOOL getFileResult = winApi.GetFileInformationByHandle(fileHandle, &fileInformation);
    winApi.CloseHandle(fileHandle);

    if (!getFileResult)
        return FALSE;

    *volumeSerialNumber = fileInformation.dwVolumeSerialNumber;
    memcpy(&fileIndex[0], &fileInformation.nFileIndexLow, sizeof(DWORD));
    memcpy(&fileIndex[1], &fileInformation.nFileIndexHigh, sizeof(DWORD));

    return TRUE;
}

// E8 ? ? ? ? 89 44 24 10 (relative jump)
LPCWSTR DriverInfo_findSystem32InString(PCWSTR str)
{
    PCWSTR first = str;
    PCWSTR second = L"system32";

    while (*first && *second) {
        if (CharUpperW((LPWSTR)*first) == CharUpperW((LPWSTR)*second)) {
            ++second;
            ++first;
        } else {
            first = ++str;
            second = L"system32";
        }
    }
    return !*second ? str : NULL;
}

// 81 EC ? ? ? ? 53
DWORD DriverInfo_getDriverInfo(DriverInfo* data, INT driverNameHash)
{
    DWORD result = 0;
    SC_HANDLE scManager = winApi.OpenSCManagerA(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);

    if (scManager) {
        LPENUM_SERVICE_STATUSW serviceStatus = Utils_heapAlloc(65536);
        LPQUERY_SERVICE_CONFIGW serviceConfig = Utils_heapAlloc(0x1000);
        
        if (serviceStatus && serviceConfig) {
            DWORD bytesNeeded, servicesReturned, resumeHandle;
            if ((winApi.EnumServicesStatusW(scManager, SERVICE_DRIVER, SERVICE_ACTIVE, serviceStatus, 65536, &bytesNeeded, &servicesReturned, &resumeHandle) || winApi.GetLastError() == ERROR_MORE_DATA) && servicesReturned > 0) {
                memset((PBYTE)serviceStatus, 0, 65536);
                LPENUM_SERVICE_STATUSW currentServiceStatus = serviceStatus;
                
                for (DWORD i = 0; i < servicesReturned; ++i) {
                    CHAR serviceName[64];
                    Utils_wideCharToMultiByteN(currentServiceStatus->lpServiceName, serviceName, 64);

                    if (Utils_hash(serviceName, Utils_strlen(serviceName)) == driverNameHash) {
                        SC_HANDLE service = winApi.OpenServiceW(scManager, currentServiceStatus->lpServiceName, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

                        if (service && winApi.QueryServiceConfigW(service, serviceConfig, 4096, &bytesNeeded)) {
                            winApi.CloseServiceHandle(service);

                            Utils_wideCharToMultiByteN(currentServiceStatus->lpServiceName, data->serviceName, 256);
                            Utils_wideCharToMultiByteN(serviceConfig->lpDisplayName, data->displayName, 256);
                            data->serviceType = serviceConfig->dwServiceType;
                            data->startType = serviceConfig->dwStartType;
                            data->errorControl = serviceConfig->dwErrorControl;
                            WCHAR driverPath[256];
                            // TODO: sub_10004612(v4->lpBinaryPathName, &driverPath);
                            Utils_wideCharToMultiByteN(driverPath, data->driverPath, 256);
                            Utils_wideCharToMultiByteN(serviceConfig->lpLoadOrderGroup, data->loaderOrderGroup, 32);
                            Utils_wideCharToMultiByteN(serviceConfig->lpDependencies, data->dependencies, 256);
                            Utils_wideCharToMultiByteN(serviceConfig->lpServiceStartName, data->serviceStartName, 32);

                            LPCWSTR system32InPath = DriverInfo_findSystem32InString(driverPath);
                            if (system32InPath) {
                                // something if driver path contains "system32"

                                // TODO: sub_10004F09(system32InPath + 9, system32InPath + 8, lstrlenW(system32InPath + 8) * sizeof(WCHAR));
                                memcpy((PWSTR)system32InPath + 3, L"native", lstrlenW(L"native") * sizeof(WCHAR));
                            }
                            DriveInfo_getFileInfo(driverPath, &data->volumeSerial, data->fileIndex);
                            winApi.CloseServiceHandle(service);
                        }
                        break;

                    }
                    currentServiceStatus++;
                }
            } else {
                result = winApi.GetLastError();
            }
        } else {
            result = ERROR_NOT_ENOUGH_MEMORY;
        }
        Utils_heapFree(serviceConfig);
        Utils_heapFree(serviceStatus);
        winApi.CloseServiceHandle(scManager);
    } else {
        result = winApi.GetLastError();
    }
    return result;
}
```

`VAC/Modules/DriverInfo/DriverInfo.h`:

```h
#pragma once

#include <Windows.h>

// 55 8B EC A1
BOOLEAN DriveInfo_getFileInfo(PCWSTR, DWORD*, DWORD[2]);

// E8 ? ? ? ? 89 44 24 10 (relative jump)
LPCWSTR DriverInfo_findSystem32InString(PCWSTR);

typedef struct DriverInfo {
    DWORD unknown[4];
    DWORD mystery; // initialized to 0x6E1CA4EA
    DWORD scanResult; // return value from DriverInfo_getDriverInfo() or error code
    DWORD zero; // initialized to 0

    /* Members accessed by DriverInfo_getDriverInfo() */
    CHAR serviceName[256];
    CHAR displayName[256];
    DWORD serviceType;
    DWORD startType;
    DWORD errorControl;
    CHAR driverPath[256];
    CHAR loaderOrderGroup[32];
    CHAR dependencies[256];
    CHAR serviceStartName[32];
    DWORD fileIndex[2];
    DWORD volumeSerial;
    /* ---------------------------------------------- */
} DriverInfo;

// 81 EC ? ? ? ? 53
DWORD DriverInfo_getDriverInfo(DriverInfo* data, INT driverNameHash);

```

`VAC/Modules/ProcessHandleList/ProcessHandleList.c`:

```c
#define WIN32_NO_STATUS
#include "../../Utils.h"
#include "ProcessHandleList.h"
#undef WIN32_NO_STATUS

#include <ntstatus.h>

HMODULE ntdll;

typedef struct _SYSTEM_HANDLE {
    ULONG ProcessId;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG HandleCount;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

#define SystemHandleInformation 16

#define __PAIR__(high, low) (((unsigned long)(high)<<sizeof(high)*8) | low)

// 83 EC 2C
INT ProcessHandleList_getSystemHandles(DWORD pids[500], INT pidCount, INT unused, DWORD* handleCount, DWORD* systemHandleCount, LARGE_INTEGER out[500])
{
    CHAR ntQuerySystemInformation[] = { "\x10\x2a\xf\x2b\x3b\x2c\x27\xd\x27\x2d\x2a\x3b\x33\x17\x30\x38\x31\x2c\x33\x3f\x2a\x37\x31\x30\x5e" }; // NtQuerySystemInformation xored with '^'

    for (PCHAR current = ntQuerySystemInformation; *current; current++)
        *current ^= '^';

    NTSTATUS(NTAPI * NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG) = (PVOID)winApi.GetProcAddress(ntdll, ntQuerySystemInformation);

    INT result = 0;

    if (NtQuerySystemInformation) {
        INT handleInfoLength = 0;
        PSYSTEM_HANDLE_INFORMATION handleInfo = NULL;

        while (TRUE) {
            handleInfoLength += 0x100000;

            if (handleInfo)
                winApi.VirtualFree(handleInfo, 0, MEM_RELEASE);

            handleInfo = winApi.VirtualAlloc(NULL, handleInfoLength, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

            if (!handleInfo)
                break;

            result = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoLength, NULL);

            if (result != STATUS_INFO_LENGTH_MISMATCH) {
                if (result == STATUS_SUCCESS) {
                    *systemHandleCount = handleInfo->HandleCount;
                    *handleCount = 0;

                    INT counter = 0;

                    for (ULONG i = 0; i < handleInfo->HandleCount; ++i) {
                        SYSTEM_HANDLE handle = handleInfo->Handles[i];

                        for (INT j = 0; j < pidCount; ++j) {
                            if (pids[counter] == handle.ProcessId)
                                break;

                            if (++counter >= pidCount)
                                counter %= pidCount;
                        }


                        if (pids[counter] == handle.ProcessId) {
                            INT unknown1 = 0, unknown2 = 0;

                            if (handle.ObjectTypeIndex < 0x37) {
                                if (handle.ObjectTypeIndex >= 0x20)
                                    unknown2 = 1 << handle.ObjectTypeIndex;

                                unknown1 = unknown2 ^ (1 << handle.ObjectTypeIndex);

                                if (handle.ObjectTypeIndex >= 0x40)
                                    unknown2 ^= 1 << handle.ObjectTypeIndex;
                            }

                            LONG highPart = out[counter].HighPart;
                            if (highPart < 0xFF000000)
                                highPart = (__PAIR__(highPart, out[counter].LowPart) + 0x100000000000000) >> 32;

                            out[counter].LowPart |= unknown1;
                            out[counter].HighPart = unknown2 | highPart;
                        } else {
                            ++*handleCount;

                            if (pidCount < 500) {
                                pids[pidCount] = handle.ProcessId;
                                counter = pidCount++;
                            }
                        }
                    }
                    result = 0;
                }
                if (handleInfo)
                    winApi.VirtualFree(handleInfo, 0, MEM_RELEASE);
                return result;
            }
        }
    }
    return winApi.GetLastError();
}

```

`VAC/Modules/ProcessHandleList/ProcessHandleList.h`:

```h
#pragma once

#include <Windows.h>

// 83 EC 2C
INT ProcessHandleList_getSystemHandles(DWORD pids[500], INT pidCount, INT unused, DWORD* handleCount, DWORD* systemHandleCount, LARGE_INTEGER out[500]);

```

`VAC/Modules/ProcessMonitor/ProcessMonitor.c`:

```c
#include "ProcessMonitor.h"

// E8 ? ? ? ? 59 8B F8 (relative jump)
PVOID ProcessMonitor_readFileMapping(PBOOLEAN md5Computed, PBYTE md5, DWORD out[2])
{
    PVOID result = NULL;
    CHAR name[60];

    wsprintfA(name, "Steam_{E9FD3C51-9B58-4DA0-962C-734882B19273}_Pid:%000008X", GetCurrentProcessId());

    if (md5Computed)
        *md5Computed = FALSE;

    HANDLE fileMapping = OpenFileMappingA(FILE_MAP_READ, FALSE, name);

    if (fileMapping) {
        DWORD* mapped = MapViewOfFile(fileMapping, FILE_MAP_READ, 0, 0, 0);

        if (mapped) {
            if (out) {
                out[0] = mapped[0];
                out[1] = mapped[1];
            }
            if (mapped[0] == 0x30004) // magic number set by steamservice.dll when creating file mapping
                result = (PVOID)mapped[1];
            if (md5) {
                if (md5Computed)
                    *md5Computed = TRUE;

                // compute md5
            }
            UnmapViewOfFile(mapped);
        }
        CloseHandle(fileMapping);
    }
    return result;
}

```

`VAC/Modules/ProcessMonitor/ProcessMonitor.h`:

```h
#pragma once

#include <Windows.h>

// E8 ? ? ? ? 59 8B F8 (relative jump)
PVOID ProcessMonitor_readFileMapping(PBOOLEAN md5Computed, PBYTE md5, DWORD out[2]);

```

`VAC/Modules/ReadModules/ReadModules.c`:

```c
#include "../../Utils.h"
#include "ReadModules.h"

BOOL (WINAPI* openProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
BOOL (WINAPI* lookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
BOOL (WINAPI* adjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);

//  55 8B EC 83 EC 1C
VOID ReadModules_enableDebugPrivilege(VOID)
{
    if (!openProcessToken || !lookupPrivilegeValueA || !adjustTokenPrivileges)
        return;

    HANDLE tokenHandle;
    if (openProcessToken(winApi.GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle)) {
        LUID luid;
        if (lookupPrivilegeValueA(NULL, "SeDebugPrivilege", &luid)) {
            TOKEN_PRIVILEGES priv;
            priv.Privileges[0].Luid = luid;
            priv.PrivilegeCount = 1;
            priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            adjustTokenPrivileges(tokenHandle, FALSE, &priv, sizeof(TOKEN_PRIVILEGES), NULL, NULL); // BufferLength could be zero because PreviousState is NULL - https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges
        }
        winApi.CloseHandle(tokenHandle);
    }
}

// 55 8B EC A1
BOOLEAN ReadModules_getFileInformation(LPCWSTR filename, ReadModules_FileInfo* out)
{
    if (!winApi.GetFileInformationByHandle)
        return FALSE;

    HANDLE handle = winApi.CreateFileW(filename, READ_CONTROL | SYNCHRONIZE | FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    BY_HANDLE_FILE_INFORMATION fileInfo;
    BOOL success = winApi.GetFileInformationByHandle(handle, &fileInfo);
    winApi.CloseHandle(handle);

    if (!success)
        return FALSE;

    out->volumeSerialNumber = fileInfo.dwVolumeSerialNumber;
    memcpy(&out->fileIndexLow, &fileInfo.nFileIndexLow, sizeof(DWORD));
    memcpy(&out->fileIndexHigh, &fileInfo.nFileIndexHigh, sizeof(DWORD));
   
    return TRUE;
}

```

`VAC/Modules/ReadModules/ReadModules.h`:

```h
#pragma once

#include <Windows.h>

//  55 8B EC 83 EC 1C
VOID ReadModules_enableDebugPrivilege(VOID);

typedef struct {
    DWORD volumeSerialNumber;
    DWORD fileIndexLow;
    DWORD fileIndexHigh;
} ReadModules_FileInfo;

// 55 8B EC A1
BOOLEAN ReadModules_getFileInformation(LPCWSTR filename, ReadModules_FileInfo* out);

```

`VAC/Modules/SystemInfo/SystemInfo.c`:

```c
#include "../../Utils.h"
#include "SystemInfo.h"

#include <intrin.h>
#include <winternl.h>

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION_ {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION_, *PSYSTEM_TIMEOFDAY_INFORMATION_;

typedef struct _SYSTEM_DEVICE_INFORMATION {
    ULONG NumberOfDisks;
    ULONG NumberOfFloppies;
    ULONG NumberOfCdRoms;
    ULONG NumberOfTapes;
    ULONG NumberOfSerialPorts;
    ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    GUID BootIdentifier;
    FIRMWARE_TYPE FirmwareType;
    ULONGLONG BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

typedef struct _SYSTEM_RANGE_START_INFORMATION {
    PVOID SystemRangeStart;
} SYSTEM_RANGE_START_INFORMATION, *PSYSTEM_RANGE_START_INFORMATION;

#define SystemDeviceInformation 7
#define SystemKernelDebuggerInformation 35
#define SystemBootEnvironmentInformation 90
#define SystemRangeStartInformation 50

DWORD(WINAPI* getProcessImageFileNameA)(HANDLE, LPSTR, DWORD);

// 55 8B EC B8
INT SystemInfo_collectData(PVOID unk, PVOID unk1, DWORD data[2048], PDWORD dataSize)
{
    WCHAR ntDllWide[] = L"\x68\x52\x62\x4A\x4A\x8\x42\x4A\x4A";
    CHAR ntDll[] = "\x68\x52\x62\x4A\x4A\x8\x42\x4A\x4A";
    CHAR kernel32[] = "\x6D\x43\x54\x48\x43\x4A\x15\x14\x8\x42\x4A\x4A";
    CHAR ntQuerySystemInformation[] = "\x68\x52\x77\x53\x43\x54\x5F\x75\x5F\x55\x52\x43\x4B\x6F\x48\x40\x49\x54\x4B\x47\x52\x4F\x49\x48";
    CHAR getVersion[] = "\x61\x43\x52\x70\x43\x54\x55\x4F\x49\x48";
    CHAR getNativeSystemInfo[] = "\x61\x43\x52\x68\x47\x52\x4F\x50\x43\x75\x5F\x55\x52\x43\x4B\x6F\x48\x40\x49";
    CHAR wow64EnableWow64FsRedirection[] = "\x71\x49\x51\x10\x12\x63\x48\x47\x44\x4A\x43\x71\x49\x51\x10\x12\x60\x55\x74\x43\x42\x4F\x54\x43\x45\x52\x4F\x49\x48";

    memset(data, 0, 2048);
    *dataSize = 2048;
    data[4] = 0xA93E4B10;

    PWCHAR currW = ntDllWide;
    while (*currW) {
        *currW ^= L'&';
        ++currW;
    }

    PCHAR curr = ntDll;
    while (*curr) {
        *curr ^= '&';
        ++curr;
    }

    curr = kernel32;
    while (*curr) {
        *curr ^= '&';
        ++curr;
    }

    HMODULE _ntdll = winApi.GetModuleHandleA(ntDll);
    DWORD error;

    if (_ntdll) {
        HMODULE _kernel32 = winApi.GetModuleHandleA(kernel32);

        if (_kernel32) {
            curr = ntQuerySystemInformation;
            while (*curr) {
                *curr ^= '&';
                ++curr;
            }

            curr = getVersion;
            while (*curr) {
                *curr ^= '&';
                ++curr;
            }

            curr = getNativeSystemInfo;
            while (*curr) {
                *curr ^= '&';
                ++curr;
            }

            curr = wow64EnableWow64FsRedirection;
            while (*curr) {
                *curr ^= '&';
                ++curr;
            }
            
            NTSTATUS(NTAPI* _ntQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG) = (PVOID)winApi.GetProcAddress(_ntdll, ntQuerySystemInformation);
             
            if (_ntQuerySystemInformation) {
                DWORD(WINAPI* _getVersion)(VOID) = (PVOID)winApi.GetProcAddress(_kernel32, getVersion);
                
                if (_getVersion) {
                    VOID(WINAPI* _getNativeSystemInfo)(LPSYSTEM_INFO) = (PVOID)winApi.GetProcAddress(_kernel32, getNativeSystemInfo);

                    if (_getNativeSystemInfo) {
                        BOOLEAN(WINAPI* _wow64EnableWow64FsRedirection)(BOOLEAN) = (PVOID)winApi.GetProcAddress(_kernel32, wow64EnableWow64FsRedirection);

                        data[18] = _getVersion();

                        SYSTEM_INFO si;
                        _getNativeSystemInfo(&si);
                        data[20] = si.wProcessorArchitecture;
                        data[21] = si.dwProcessorType;

                        SYSTEM_TIMEOFDAY_INFORMATION_ sti;
                        data[6] = _ntQuerySystemInformation(SystemTimeOfDayInformation, &sti, sizeof(sti), NULL);
                        data[14] = sti.CurrentTime.LowPart;
                        data[15] = sti.CurrentTime.HighPart;
                        data[16] = sti.BootTime.LowPart;
                        data[17] = sti.BootTime.HighPart;

                        SYSTEM_CODEINTEGRITY_INFORMATION sci;
                        sci.Length = sizeof(sci);
                        data[7] = _ntQuerySystemInformation(SystemCodeIntegrityInformation, &sci, sizeof(sci), NULL);
                        data[19] = sci.CodeIntegrityOptions;

                        SYSTEM_DEVICE_INFORMATION sdi;
                        data[22] = _ntQuerySystemInformation(SystemDeviceInformation, &sdi, sizeof(sdi), NULL);
                        data[26] = sdi.NumberOfDisks;

                        SYSTEM_KERNEL_DEBUGGER_INFORMATION skdi;
                        data[23] = _ntQuerySystemInformation(SystemKernelDebuggerInformation, &skdi, sizeof(skdi), NULL);
                        *((PSYSTEM_KERNEL_DEBUGGER_INFORMATION)&data[27]) = skdi;

                        SYSTEM_BOOT_ENVIRONMENT_INFORMATION sbei;
                        memset(&sbei, 0, sizeof(sbei));
                        data[24] = _ntQuerySystemInformation(SystemBootEnvironmentInformation, &sbei, sizeof(sbei), NULL);
                        memcpy(&data[28], &sbei.BootIdentifier, sizeof(sbei.BootIdentifier));

                        SYSTEM_RANGE_START_INFORMATION srsi;
                        data[25] = _ntQuerySystemInformation(SystemRangeStartInformation, &srsi, sizeof(srsi), NULL);
                        data[32] = srsi.SystemRangeStart;
                        data[33] = (INT)srsi.SystemRangeStart >> 31;
                        data[34] = winApi.GetCurrentProcessId();
                        data[35] = winApi.GetCurrentThreadId();
                        data[36] = ERROR_FUNCTION_NOT_CALLED;

                        CHAR currentExe[MAX_PATH];
                        DWORD currentExeLen = 0;
                        
                        if (getProcessImageFileNameA)
                            currentExeLen = getProcessImageFileNameA(winApi.GetCurrentProcess(), currentExe, _countof(currentExe));

                        if (currentExeLen) {
                            data[36] = 0;
                            memcpy(&data[37], &currentExe[currentExeLen >= 36 ? currentExeLen - 36 : 0], 36);
                        } else {
                            data[36] = GetLastError();
                        }

                        WCHAR systemDir[MAX_PATH];
                        UINT systemDirLen = winApi.GetSystemDirectoryW(systemDir, sizeof(systemDir));
                       
                        if (systemDirLen) {
                            Utils_wideCharToMultiByte(systemDir, &data[106]);

                            DWORD systemVolumeSerial = 0;
                            LARGE_INTEGER systemFolderId = { 0 };

                            if (SystemInfo_getFileInfo(systemDir, &systemVolumeSerial, &systemFolderId)) {
                                data[156] = systemFolderId.LowPart;
                                data[157] = systemFolderId.HighPart;
                                data[158] = systemVolumeSerial;
                            } else {
                                data[159] = winApi.GetLastError();
                            }

                            systemDir[systemDirLen] = L'\\';
                            memcpy(systemDir[systemDirLen + 1], ntDllWide, sizeof(ntDllWide));

                            BOOLEAN fsRedirDisabled = FALSE;
                            if (_wow64EnableWow64FsRedirection)
                                fsRedirDisabled = _wow64EnableWow64FsRedirection(FALSE);

                            HANDLE ntdllHandle = winApi.CreateFileW(systemDir, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                            DWORD ntdllOpenErr = winApi.GetLastError();

                            if (fsRedirDisabled)
                                _wow64EnableWow64FsRedirection(TRUE);
                            
                            if (ntdllHandle != INVALID_HANDLE_VALUE) {
                               // read ntdll.dll file and do some processing
                            } else {
                                data[46] = ntdllOpenErr;
                            }

                            WCHAR windowsDir[MAX_PATH];

                            if (winApi.GetWindowsDirectoryW(windowsDir, sizeof(windowsDir))) {
                                Utils_wideCharToMultiByte(windowsDir, &data[52]);

                                DWORD windowsVolumeSerial = 0;
                                LARGE_INTEGER windowsFolderId = { 0 };

                                if (SystemInfo_getFileInfo(windowsDir, &windowsVolumeSerial, &windowsFolderId)) {
                                    data[102] = windowsFolderId.LowPart;
                                    data[103] = windowsFolderId.HighPart;
                                    data[104] = windowsVolumeSerial;
                                } else {
                                    data[105] = winApi.GetLastError();
                                }
                                data[180] = moduleHandlesCount;
                                data[181] = winapiFunctionsCount;
                                memcpy(&data[182], moduleHandles, sizeof(moduleHandles) /* == 64 */);
                                memcpy(&data[198], &winApi, 640);
                                data[358] = (DWORD)_ReturnAddress() & 0xFFFF0000;
                                data[359] = *(DWORD*)((DWORD)_ReturnAddress() & 0xFFFF0000);
                                data[360] = *(DWORD*)((DWORD)_ReturnAddress() & 0xFFFF0000 + 0x114);
                                data[361] = *(DWORD*)((DWORD)_ReturnAddress() & 0xFFFF0000 + 0x400);
                                data[363] = SystemInfo_enumVolumes((VolumeData*)&data[364]);

                                DWORD gamePid = *((DWORD*)unk1 + 24);
                                data[444] = gamePid;

                                if (gamePid) {
                                    HANDLE gameHandle = winApi.OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, gamePid);

                                    if (gameHandle && gameHandle != INVALID_HANDLE_VALUE) {
                                        data[445] = gameHandle;
                                        data[446] = 0;
                                        data[447] = winApi.GetProcessId(gameHandle);
                                        winApi.CloseHandle(gameHandle);
                                    } else {
                                        data[445] = 0;
                                        data[446] = winApi.GetLastError();
                                    }
                                }
                            } else {
                                data[105] = data[46] = winApi.GetLastError();
                            }
                        } else {
                            data[159] = data[46] = winApi.GetLastError();
                        }
                    }
                } else {
                    error = GetLastError();
                }
            } else {
                error = GetLastError();
            }
        } else {
            error = GetLastError();
        }
    } else {
        error = GetLastError();
    }
    return 0;
}

// 55 8D 6C 24 90
BOOLEAN SystemInfo_getFileInfo(PCWSTR fileName, DWORD* volumeSerialNumber, PLARGE_INTEGER fileId)
{
    if (!winApi.GetFileInformationByHandle)
        return FALSE;

    HANDLE file = winApi.CreateFileW(fileName, READ_CONTROL | SYNCHRONIZE | FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_SUPPORTS_USN_JOURNAL, NULL);

    if (file == INVALID_HANDLE_VALUE || !winApi.GetFileInformationByHandleEx)
        return FALSE;

    FILE_ID_BOTH_DIR_INFO fileInfo;
    memset(&fileInfo, 0, 132); // 132 while sizeof(FILE_ID_BOTH_DIR_INFO) = 112 ?
    BOOL gotInfo = winApi.GetFileInformationByHandleEx(file, FileIdBothDirectoryInfo, &fileInfo, 132);
    *volumeSerialNumber = 0;

    if (gotInfo && winApi.GetVolumeInformationByHandleW)
        winApi.GetVolumeInformationByHandleW(file, NULL, 0, volumeSerialNumber, NULL, NULL, NULL, 0);

    winApi.CloseHandle(file);

    if (!gotInfo) {
        winApi.GetLastError();
        return 0;
    }
    
    memcpy(&fileId->LowPart, &fileInfo.FileId.LowPart, sizeof(DWORD));
    memcpy(&fileId->HighPart, &fileInfo.FileId.HighPart, sizeof(LONG));
    return TRUE;
}

// E8 ? ? ? ? 89 86
INT SystemInfo_enumVolumes(VolumeData volumes[10])
{
    INT volCount = 0;

    // if (!dword_10008D68)
    //     return 0;

    WCHAR volGuid[MAX_PATH] = { 0 };

    HANDLE vol = winApi.FindFirstVolumeW(volGuid, MAX_PATH);

    if (vol == INVALID_HANDLE_VALUE) {
        VolumeData volData = { 0 };
        winApi.GetLastError();
        return 0;
    }

    if (!winApi.GetVolumeInformationW || !winApi.GetDriveTypeW || !winApi.GetVolumePathNamesForVolumeNameW)
        return 0;

    do {
        VolumeData volData = { 0 };
        volData.volumeGuidHash = Utils_hash(volGuid, lstrlenW(volGuid));

        DWORD volSerialNumber = 0, fileSystemFlags = 0;
        WCHAR volName[50], fileSystemName[50];

        if (winApi.GetVolumeInformationW(volGuid, volName, 50, &volSerialNumber, NULL, &fileSystemFlags, fileSystemName, 50)) {
            volData.fileSystemFlags = fileSystemFlags;
            volData.volumeSerialNumber = volSerialNumber;
            volData.volumeNameHash = Utils_hash(volName, lstrlenW(volName));
            volData.fileSystemNameHash = Utils_hash(fileSystemName, lstrlenW(fileSystemName));
        } else {
            volData.getVolumeInformationError = winApi.GetLastError();
        }
        volData.driveType = winApi.GetDriveTypeW(vol);

        WCHAR volPathName[50];
        DWORD volPathNameLen;
        UINT volPathNameHash;

        if (winApi.GetVolumePathNamesForVolumeNameW(volGuid, volPathName, 50, &volPathNameLen)) {
            volData.volumePathNameLength = volPathNameLen;
            volPathNameHash = Utils_hash(volPathName, lstrlenW(volPathName));
        } else {
            volData.volumePathNameLength = 0;
            volPathNameHash = winApi.GetLastError();
        }

        volData.volumePathNameHash = volPathNameHash;

        if (volCount < 10)
            volumes[volCount] = volData;

        ++volCount;
    } while (winApi.FindNextVolumeW(vol, volGuid, MAX_PATH));
    winApi.FindVolumeClose(vol);
    return volCount;
}

```

`VAC/Modules/SystemInfo/SystemInfo.h`:

```h
#pragma once

#include <Windows.h>

typedef struct VolumeData {
    UINT volumeGuidHash;
    DWORD getVolumeInformationError;
    DWORD fileSystemFlags;
    DWORD volumeSerialNumber;
    UINT volumeNameHash;
    UINT fileSystemNameHash;
    WORD driveType;
    WORD volumePathNameLength;
    DWORD volumePathNameHash;
} VolumeData;

typedef struct SystemInfo {
    DWORD unknown[4];
    DWORD scanType; // initialized to 0xA93E4B10
    DWORD scanError;
    NTSTATUS queryTimeInfo;
    NTSTATUS queryCodeIntegrity;
    /* TODO: time + something from KUSER_SHARED_DATA */
    DWORD unk;
    DWORD unk1;
    DWORD pad[4];
    /* END */
    LARGE_INTEGER currentTime;
    LARGE_INTEGER bootTime;
    DWORD systemVersion;
    ULONG codeIntegrityOptions;
    DWORD processorArchitecture;
    DWORD processorType;
    NTSTATUS queryDeviceInfo;
    NTSTATUS queryKernelDebuggerInfo;
    NTSTATUS queryBootEnvironmentInfo;
    NTSTATUS queryRangeStartInfo;
    ULONG numberOfDisks;
    DWORD kernelDebuggerInfo;
    GUID bootIdentifier;
    PVOID systemRangeStart;
    PVOID systemRangeExtended;
    DWORD currentProcessId;
    DWORD currentThreadId;
    DWORD getCurrentExeNameError;
    CHAR currentExeName[36];
    DWORD winapiError;
    DWORD pad2[5];
    CHAR windowsDir[200];
    LARGE_INTEGER windowsFolderId;
    DWORD windowsVolumeSerial;
    DWORD getWindowsDirError;
    CHAR systemDir[200];
    LARGE_INTEGER systemFolderId;
    DWORD systemVolumeSerial;
    DWORD getSystemDirError;
    DWORD pad3[20];
    INT moduleHandlesCount;
    INT winapiFunctionsCount;
    HMODULE moduleHandles[16];
    PVOID winapiFunctions[160];
    DWORD vacModuleBase;
    DWORD vacModuleBaseVal;
    DWORD vacModuleSomething;
    DWORD vacModuleTextStart;
    DWORD unk2;
    INT volumeCount;
    VolumeData volumes[10];
    DWORD gamePidFromSteam;
    HANDLE gameProcessHandle;
    DWORD gameProcessOpenError;
    DWORD gamePid;
    DWORD unused[64];
} SystemInfo;

// 55 8B EC B8
INT SystemInfo_collectData(PVOID unk, PVOID unk1, DWORD data[2048], PDWORD dataSize);

// 55 8D 6C 24 90
BOOLEAN SystemInfo_getFileInfo(PCWSTR fileName, DWORD* volumeSerialNumber, PLARGE_INTEGER fileId);

// E8 ? ? ? ? 89 86
INT SystemInfo_enumVolumes(VolumeData volumes[10]);

```

`VAC/Utils.c`:

```c
#include "Utils.h"
#include "Encryption/Ice.h"

// 83 C8 FF 83 E9 00
INT Utils_getProtect(BYTE a)
{
    switch (a) {
    case 0: return PAGE_NOACCESS;
    case 1: return PAGE_READONLY;
    case 3: return PAGE_READWRITE;
    case 4: return PAGE_EXECUTE;
    case 5: return PAGE_EXECUTE_READ;
    case 7: return PAGE_EXECUTE_READWRITE;
    default: return -1;
    }
}

// E8 ? ? ? ? 89 7E 04 (relative jump)
// E8 ? ? ? ? 8B E8 (relative jump)
LPVOID Utils_heapAlloc(SIZE_T size)
{
    return HeapAlloc(GetProcessHeap(), 0, size);
}

// E8 ? ? ? ? 5B (relative jump)
BOOL Utils_heapFree(LPVOID memory)
{
    return HeapFree(GetProcessHeap(), 0, memory);
}

// 83 61 10 00 83 61 14 00
VOID Utils_initializeMD5(DWORD* md5)
{
    md5[0] = 0x67452301;
    md5[1] = 0xEFCDAB89;
    md5[2] = 0x98BADCFE;
    md5[3] = 0x10325476;
    md5[4] = 0;
    md5[5] = 0;
}

// 52 85 C9
LPVOID Utils_heapReAlloc(LPVOID memory, SIZE_T size)
{
    if (memory)
        return HeapReAlloc(GetProcessHeap(), 0, memory, size);
    else
        return HeapAlloc(GetProcessHeap(), 0, size);
}

// 33 C0 38 01
INT Utils_strlen(PCSTR a1)
{
    INT result = 0;
    while (*a1)
        result++;

    return result;
}

// E8 ? ? ? ? A3 ? ? ? ? (relative jump)
UINT Utils_crc32ForByte(PBYTE data, INT size, UINT hash)
{
    for (INT i = 0; i < size; i++) {
        hash ^= data[i] << 24;

        for (INT j = 0; j < 8; j++) {
            if (hash & (1 << 31))
                hash = (hash << 2) ^ 0x488781ED;
            else
                hash <<= 2;
        }
    }
    return hash;
}

// FF 74 24 04
INT Utils_compareStringW(PCNZWCH string1 , PCNZWCH string2, INT count)
{
    return CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, string1, count, string2, count) - CSTR_EQUAL;
}

// E8 ? ? ? ? 59 59 33 F6 (relative jump)
BOOL Utils_iceEncrypt(INT n, PSTR text, INT _, PCSTR key)
{
    IceKey iceKey;
    Ice_createKey(&iceKey, n);
    Ice_set(&iceKey, key);
    for (INT i = 0; i < 512; i++) {
        Ice_encrypt(&iceKey, text, text);
        text += 8;
    }
    return Ice_destroyKey(&iceKey);
}

// E8 ? ? ? ? 83 4C 24 (relative jump)
BOOL Utils_iceDecrypt(INT n, PSTR text, INT size, PCSTR key)
{
    IceKey iceKey;
    Ice_createKey(&iceKey, n);
    Ice_set(&iceKey, key);

    for (INT i = 0; i < size / 8; i++) {
        Ice_decrypt(&iceKey, text, text);
        text += 8;
    }
    return Ice_destroyKey(&iceKey);
}

HMODULE moduleHandles[16];
INT winapiFunctionsCount;
INT moduleHandlesCount;
BOOL(WINAPI* freeLibrary)(HMODULE);

// E8 ? ? ? ? 8B 45 F0 (relative jump)
VOID Utils_resetFunctionsAndModuleHandles(VOID)
{
    for (INT i = 0; i < moduleHandlesCount; i++) {
        freeLibrary(moduleHandles[i]);
        moduleHandles[i] = NULL;
    }
    moduleHandlesCount = 0;

    memset((PBYTE)&winApi, 0, sizeof(winApi));
    winapiFunctionsCount = 0;
}

UINT winapiFunctionsHash;

// E8 ? ? ? ? B3 01 (relative jump)
BOOLEAN Utils_calculateWinapiFunctionsHash(VOID)
{
    winapiFunctionsHash = Utils_crc32ForByte((PBYTE)&winApi, sizeof(winApi), winapiFunctionsHash);
    return TRUE;
}

// 56 8B F1 56
LPCWSTR Utils_skipPath(LPCWSTR string)
{
    for (INT i = lstrlenW(string); i > 1; i--) {
        if (string[i] == L'\\')
            return string + i;
    }
    return string;
}

// E8 ? ? ? ? 32 C0 59 (relative jump)
VOID Utils_copyStringW(PWSTR dest, PCWSTR src, UINT count)
{
    memcpy((PBYTE)dest, (PBYTE)src, count * sizeof(WCHAR));
    UINT srcLength = lstrlenW(src);
    if (count > srcLength)
        memset((PBYTE)(dest + srcLength), 0, (count - srcLength) * sizeof(WCHAR));
}

Data data;
Snmp snmp;
WinApi winApi;

// 51 A1 ? ? ? ?
BOOLEAN Utils_getSystemInformation(VOID)
{
    data.currentProcessId = winApi.GetCurrentProcessId();
    data.currentThreadId = winApi.GetCurrentThreadId();

    if (data.currentProcessId && data.currentThreadId) {
        winApi.GetSystemInfo(&data.systemInfo);

        if (data.systemInfo.dwPageSize == 4096) {
            data.osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);

            if (winApi.GetVersionExA(&data.osVersionInfo)) {
                data.systemVersion = data.osVersionInfo.dwPlatformId | ((data.osVersionInfo.dwMajorVersion | (data.osVersionInfo.dwMinorVersion << 8)) << 8);
                if (winApi.GetSystemDirectoryW(data.systemDirectory, sizeof(data.systemDirectory)) && winApi.GetWindowsDirectoryW(data.windowsDirectory, sizeof(data.windowsDirectory))) // VALVE PLS FIX - BUFFER SIZE SHOULD BE MAX_PATH - https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectoryw
                    return TRUE;
            }
        }
    }
    return FALSE;
}

// A1 ? ? ? ? 53 56
int Utils_wideCharToMultiByte(LPCWCH wideCharStr, LPSTR multiByteStr)
{
    int result = winApi.WideCharToMultiByte(CP_UTF8, 0, wideCharStr, -1, multiByteStr, MAX_PATH, NULL, NULL);

    if (!result)
        multiByteStr[MAX_PATH - 1] = 0;
    return result;
}

// A1 ? ? ? ? 53
int Utils_wideCharToMultiByteN(LPCWCH wideCharStr, LPSTR multiByteStr, INT count)
{
    int result = winApi.WideCharToMultiByte(CP_UTF8, 0, wideCharStr, -1, multiByteStr, count, NULL, NULL);

    if (!result)
        multiByteStr[count - 1] = 0;
    return result;
}

// E8 ? ? ? ? 59 B0 01 (relative jump)
VOID Utils_copyStringW2(PWSTR dest, PCWSTR src)
{
    memcpy((PBYTE)dest, (PBYTE)src, 512 * sizeof(WCHAR));
    INT srcLength = lstrlenW(src);
    if (srcLength < 512)
        memset((PBYTE)(dest + srcLength), 0, (512 - srcLength) * sizeof(WCHAR));
}

// E8 ? ? ? ? 8D 44 24 48 (relative jump)
BOOLEAN Utils_replaceDevicePathWithName(PWSTR devicePath, INT unused)
{
    WCHAR driveStrings[250];
    if (!GetLogicalDriveStringsW(250, driveStrings))
        return FALSE;

    WCHAR deviceName[3] = { L"C:" };
    INT devicePathLength = 0;

    PCWSTR currentDrive = driveStrings;
    while (TRUE) {
        deviceName[0] = currentDrive[0];
        WCHAR devicePath[MAX_PATH];
        if (QueryDosDeviceW(deviceName, devicePath, MAX_PATH)) {
            devicePathLength = lstrlenW(devicePath);
            if (devicePathLength < MAX_PATH && !Utils_compareStringW(devicePath, devicePath, devicePathLength))
                break;
        }
        while (*currentDrive++);

        if (!*currentDrive)
            return FALSE;
    }

    WCHAR result[MAX_PATH];
    result[0] = L'\0';
    lstrcatW(result, deviceName);
    lstrcatW(result, devicePath + devicePathLength);
    Utils_copyStringW2(devicePath, result);
    return TRUE;
}

// E8 ? ? ? ? EB 07 (relative jump)
VOID Utils_freeSnmp(VOID)
{
    if (snmp.inetmib1) {
        VOID(WINAPI* SnmpExtensionClose)(VOID) = (PVOID)winApi.GetProcAddress(snmp.inetmib1, "SnmpExtensionClose");

        if (SnmpExtensionClose)
            SnmpExtensionClose();
        winApi.FreeLibrary(snmp.inetmib1);
        snmp.inetmib1 = NULL;
        snmp.SnmpExtensionQuery = NULL;
    }

    if (snmp.snmpapi) {
        winApi.FreeLibrary(snmp.snmpapi);
        snmp.snmpapi = NULL;
        snmp.SnmpUtilMemAlloc = NULL;
        snmp.SnmpUtilVarBindFree = NULL;
    }
}

// E8 ? ? ? ? 84 C0 74 6B (relative jump)
BOOLEAN Utils_initializeSnmp(VOID)
{
    if (snmp.inetmib1)
        Utils_freeSnmp();

    snmp.inetmib1 = winApi.LoadLibraryExA("inetmib1.dll", NULL, 0);
    BOOL(WINAPI* snmpExtensionInit)(DWORD, HANDLE*, AsnObjectIdentifier*) = (PVOID)winApi.GetProcAddress(snmp.inetmib1, "SnmpExtensionInit");
    snmp.SnmpExtensionQuery = (PVOID)winApi.GetProcAddress(snmp.inetmib1, "SnmpExtensionQuery");

    snmp.snmpapi = winApi.LoadLibraryExA("snmpapi.dll", NULL, 0);
    snmp.SnmpUtilMemAlloc = (PVOID)winApi.GetProcAddress(snmp.snmpapi, "SnmpUtilMemAlloc");
    snmp.SnmpUtilVarBindFree = (PVOID)winApi.GetProcAddress(snmp.snmpapi, "SnmpUtilVarBindFree");

    HANDLE dummy;
    AsnObjectIdentifier asnId;

    if (!snmp.inetmib1 || !snmpExtensionInit || !snmp.SnmpExtensionQuery || !snmp.snmpapi || !snmp.SnmpUtilMemAlloc || !snmp.SnmpUtilVarBindFree || !snmpExtensionInit(winApi.GetTickCount(), &dummy, &asnId)) {
        Utils_freeSnmp();
        return FALSE;
    }
    return TRUE;
}

static DWORD snmpIds[14] = { 1, 3, 6, 1, 2, 1, 4, 0x15, 1, 7, 0, 0, 0, 0 };
static DWORD snmpIds2[10] = { 1, 3, 6, 1, 2, 1, 4, 0x16, 1, 2 };

// 55 8B EC 83 EC 10
BOOLEAN Utils_retrieveAsnValue(AsnInteger32* out)
{
    SnmpVarBindList varBindList;
    varBindList.len = 1;

    PUINT ids = snmp.SnmpUtilMemAlloc(sizeof(snmpIds));
    memcpy((PBYTE)ids, (PBYTE)snmpIds, sizeof(snmpIds));
    SnmpVarBind* varBind = snmp.SnmpUtilMemAlloc(sizeof(SnmpVarBind));
    varBind->name.idLength = 14;
    varBind->name.ids = ids;
    varBind->value.asnType = ASN_NULL;
    varBind->value.asnValue.number = 0;

    varBindList.list = varBind;
    AsnInteger32 errorStatus, errorIndex;

    if (snmp.SnmpExtensionQuery(SNMP_PDU_GET, &varBindList, &errorStatus, &errorIndex) && !errorStatus && varBindList.len && varBindList.list->name.idLength == 14) {
        if (!memcmp((PBYTE)varBindList.list->name.ids, (PBYTE)snmpIds, sizeof(snmpIds)) && varBindList.list->value.asnType == ASN_IPADDRESS && varBindList.list->value.asnValue.counter64.HighPart == 4) {
            *out = varBindList.list->value.asnValue.number;
            snmp.SnmpUtilVarBindFree(varBind);
            return TRUE;
        }
    }
    snmp.SnmpUtilVarBindFree(varBind);
    return FALSE;
}

// 83 EC 10 53 55
BOOLEAN Utils_findAsnString(AsnInteger32 asnValue, PBYTE out)
{
    memset(out, 0, 6);
    SnmpVarBindList varBindList;
    varBindList.len = 1;

    PUINT ids = snmp.SnmpUtilMemAlloc(40);
    memcpy(ids, snmpIds2, sizeof(snmpIds2));
    SnmpVarBind* varBind = snmp.SnmpUtilMemAlloc(sizeof(SnmpVarBind));
    varBind->name.idLength = 10;
    varBind->name.ids = ids;
    varBind->value.asnType = ASN_NULL;
    varBind->value.asnValue.number = 0;

    varBindList.list = varBind;

    AsnInteger32 errorStatus = 0, errorIndex;

    BOOLEAN result = FALSE;

    while (!result) {
        if (!snmp.SnmpExtensionQuery(SNMP_PDU_GETNEXT, &varBindList, &errorStatus, &errorIndex) || errorStatus || varBindList.list->name.idLength < 15 || memcmp(varBindList.list->name.ids, snmpIds2, sizeof(snmpIds2)))
            break;

        if (varBindList.list->name.ids[11] | varBindList.list->name.ids[12] | (((varBindList.list->name.ids[14] << 8) | varBindList.list->name.ids[13] << 8)) << 8 == asnValue && varBindList.list->value.asnType == ASN_OCTETSTRING && varBindList.list->value.asnValue.counter64.HighPart == 6) {
            memcpy(out, varBindList.list->value.asnValue.string.stream, 6);
            result = TRUE;
        }
    }

    snmp.SnmpUtilVarBindFree(varBind);
    return result;
}

// E8 ? ? ? ? 89 45 54 (relative jump)
INT Utils_enumProcesses(DWORD pids[500], DWORD parentPids[500])
{
    INT processCount = 0;
    HANDLE snapshot = winApi.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (snapshot == INVALID_HANDLE_VALUE)
        return 60;
    PROCESSENTRY32W processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32W);

    if (winApi.Process32FirstW(snapshot, &processEntry)) {
        do {
            if (processCount < 500) {
                INT i;
                for (i = processCount - 1; i >= 0 && pids[i] > processEntry.th32ProcessID; i--)
                    pids[i + 1] = pids[i];

                processCount++;
                pids[i + 1] = processEntry.th32ProcessID;
                parentPids[i + 1] = processEntry.th32ParentProcessID;
            }
        } while (winApi.Process32NextW(snapshot, &processEntry));
    }
    winApi.CloseHandle(snapshot);
    return processCount;
}

// B8 ? ? ? ? 85 D2
UINT Utils_hash(LPCVOID data, INT count)
{
    UINT hash = 0x45D71892;

    while (count) {
        hash = (*((PBYTE)data)++ | 32) + 33 * hash;
        count--;
    }
    return hash;
}

```

`VAC/Utils.h`:

```h
#pragma once

#include <WinSock2.h>
#include <WS2tcpip.h>
#include <iphlpapi.h>
#include <Windows.h>
#include <Psapi.h>
#include <SetupAPI.h>
#include <TlHelp32.h>
#include <winternl.h>
#include <WinTrust.h>
#include <DbgHelp.h>
#define SECURITY_WIN32
#include <security.h>
#include <Snmp.h>

// 83 C8 FF 83 E9 00
INT Utils_getProtect(BYTE);

// E8 ? ? ? ? 89 7E 04 (relative jump)
LPVOID Utils_heapAlloc(SIZE_T);

// E8 ? ? ? ? 5B (relative jump)
BOOL Utils_heapFree(LPVOID);

// 83 61 10 00 83 61 14 00
VOID Utils_initializeMD5(DWORD*);

// 52 85 C9
LPVOID Utils_heapReAlloc(LPVOID, SIZE_T);

// 33 C0 38 01
INT Utils_strlen(PCSTR);

// E8 ? ? ? ? A3 ? ? ? ? (relative jump)
UINT Utils_crc32ForByte(PBYTE, INT, UINT);

// FF 74 24 04
INT Utils_compareStringW(PCNZWCH, PCNZWCH, INT);

// E8 ? ? ? ? 59 59 33 F6 (relative jump)
BOOL Utils_iceEncrypt(INT, PSTR, INT, PCSTR);

// E8 ? ? ? ? 83 4C 24 (relative jump)
BOOL Utils_iceDecrypt(INT, PSTR, INT, PCSTR);

extern HMODULE moduleHandles[16];
extern INT winapiFunctionsCount;
extern INT moduleHandlesCount;
extern BOOL(WINAPI* freeLibrary)(HMODULE);

// E8 ? ? ? ? 8B 45 F0 (relative jump)
VOID Utils_resetFunctionsAndModuleHandles(VOID);

extern UINT winapiFunctionsHash;

// E8 ? ? ? ? B3 01 (relative jump)
BOOLEAN Utils_calculateWinapiFunctionsHash(VOID);

// 56 8B F1 56
LPCWSTR Utils_skipPath(LPCWSTR);

// E8 ? ? ? ? 32 C0 59 (relative jump)
VOID Utils_copyStringW(PWSTR, PCWSTR, UINT);

typedef struct Data {
    DWORD currentProcessId;
    DWORD currentThreadId;
    SYSTEM_INFO systemInfo;
    OSVERSIONINFOEXA osVersionInfo;
    DWORD systemVersion;
    DWORD _unknown;
    BYTE _pad[6];
    WCHAR systemDirectory[MAX_PATH];
    WCHAR windowsDirectory[MAX_PATH];
} Data;

extern Data data;

typedef struct WinApi {
    HMODULE(WINAPI* LoadLibraryExA)(LPCSTR, HANDLE, DWORD);
    FARPROC(WINAPI* GetProcAddress)(HMODULE, LPCSTR);
    NTSTATUS(NTAPI* NtOpenProcess)(PHANDLE, ACCESS_MASK, PVOID, PVOID);
    BOOL(WINAPI* FreeLibrary)(HMODULE);
    BOOL(WINAPI* GetVolumeInformationW)(LPCWSTR, LPWSTR, DWORD, LPDWORD, LPDWORD, LPDWORD, LPWSTR, DWORD);
    BOOL(WINAPI* GetFileInformationByHandleEx)(HANDLE, FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD);
    BOOL(WINAPI* QueryFullProcessImageNameW)(HANDLE, DWORD, LPWSTR, PDWORD);
    DWORD(WINAPI* GetLastError)(VOID);
    HANDLE(WINAPI* OpenProcess)(DWORD, BOOL, DWORD);
    BOOL(WINAPI* CryptMsgGetParam)(HCRYPTMSG, DWORD, DWORD, void*, DWORD*);
    SC_HANDLE(WINAPI* OpenSCManagerA)(LPCSTR, LPCSTR, DWORD);
    BOOL(WINAPI* GetTokenInformation)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD);
    BOOL(WINAPI* CertCloseStore)(HCERTSTORE, DWORD);
    int(WINAPI* WideCharToMultiByte)(UINT, DWORD, LPCWCH, int, LPSTR, int, LPCCH, LPBOOL);
    BOOL(WINAPI* GetModuleHandleExA)(DWORD, LPCSTR, HMODULE*);
    BOOL(WINAPI* SetFilePointerEx)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD);
    HANDLE(WINAPI* FindFirstVolumeW)(LPWSTR, DWORD);
    BOOL(WINAPI* Module32FirstW)(HANDLE, LPMODULEENTRY32W);
    BOOL(WINAPI* CryptMsgClose)(HCRYPTMSG);
    DWORD(APIENTRY* GetFileVersionInfoSizeA)(LPCSTR, LPDWORD);
    HANDLE(WINAPI* GetCurrentProcess)(VOID);
    BOOL(WINAPI* GetModuleInformation)(HANDLE, HMODULE, LPMODULEINFO, DWORD);
    BOOL(APIENTRY* VerQueryValueA)(LPCVOID, LPCSTR, LPVOID*, PUINT);
    BOOL(WINAPI* FlushInstructionCache)(HANDLE, LPCVOID, SIZE_T);
    VOID(WINAPI* Sleep)(DWORD);
    DWORD(WINAPI* ResumeThread)(HANDLE);
    LONG(WINAPI* WinVerifyTrust)(HWND, GUID*, LPVOID);
    DWORD(WINAPI* GetModuleFileNameExA)(HANDLE, HMODULE, LPSTR, DWORD);
    HANDLE(WINAPI* GetCurrentThread)(VOID);
    DWORD(WINAPI* GetProcessId)(HANDLE);
    BOOL(WINAPI* GetFileInformationByHandle)(HANDLE, LPBY_HANDLE_FILE_INFORMATION);
    BOOL(WINAPI* GetVolumePathNamesForVolumeNameW)(LPCWSTR, LPWCH, DWORD, PDWORD);
    HDEVINFO(WINAPI* SetupDiGetClassDevsA)(CONST GUID*, PCSTR, HWND, DWORD);
    HANDLE(WINAPI* CreateToolhelp32Snapshot)(DWORD, DWORD);
    BOOL(WINAPI* ConvertSidToStringSidA)(PSID, LPSTR*);
    BOOL(WINAPI* WriteFile)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
    NTSTATUS(NTAPI* NtWow64QueryVirtualMemory64)(HANDLE, PVOID64, DWORD, PVOID, ULONG64, PULONG64);
    DWORD(WINAPI* GetModuleBaseNameA)(HANDLE, HMODULE, LPSTR, DWORD);
    LSTATUS(APIENTRY* RegEnumKeyExA)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPSTR, LPDWORD, PFILETIME);
    DWORD(WINAPI* CertGetNameStringW)(PCCERT_CONTEXT, DWORD, DWORD, void*, LPWSTR, DWORD);
    UINT(WINAPI* GetSystemDirectoryW)(LPWSTR, UINT);
    DWORD(WINAPI* GetProcessImageFileNameA)(HANDLE, LPSTR, DWORD);
    BOOL(WINAPI* QueryServiceConfigA)(SC_HANDLE, LPQUERY_SERVICE_CONFIGA, DWORD, LPDWORD);
    BOOLEAN(SEC_ENTRY* GetUserNameExW)(EXTENDED_NAME_FORMAT, LPWSTR, PULONG);
    BOOL(WINAPI* IsBadReadPtr)(CONST VOID*, UINT_PTR);
    BOOL(WINAPI* CryptQueryObject)(DWORD, const void*, DWORD, DWORD, DWORD, DWORD*, DWORD*, DWORD*, HCERTSTORE*, HCRYPTMSG*, const void**);
    DWORD(APIENTRY* GetFileVersionInfoSizeW)(LPCWSTR, LPDWORD);
    BOOL(WINAPI* CloseServiceHandle)(SC_HANDLE);
    LSTATUS(APIENTRY* RegQueryValueExA)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
    NTSTATUS(NTAPI* NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
    BOOL(WINAPI* GetVolumeInformationByHandleW)(HANDLE, LPWSTR, DWORD, LPDWORD, LPDWORD, LPDWORD, LPWSTR, DWORD);
    PVOID(WINAPI* EncodePointer)(PVOID);
    HANDLE(WINAPI* OpenThread)(DWORD, BOOL, DWORD);
    BOOL(APIENTRY* GetFileVersionInfoA)(LPCSTR, DWORD, DWORD, LPVOID);
    BOOL(WINAPI* QueryServiceConfigW)(SC_HANDLE, LPQUERY_SERVICE_CONFIGW, DWORD, LPDWORD);
    NTSTATUS(NTAPI* NtMapViewOfSection)(HANDLE, HANDLE, PVOID*, ULONG, ULONG, PLARGE_INTEGER, PULONG, DWORD, ULONG, ULONG);
    BOOL(WINAPI* ReadFile)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
    BOOL(WINAPI* GetProcessTimes)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
    PCCERT_CONTEXT(WINAPI* CertFindCertificateInStore)(HCERTSTORE, DWORD, DWORD, DWORD, const void*, PCCERT_CONTEXT);
    BOOL(WINAPI* EnumServicesStatusA)(SC_HANDLE, DWORD, DWORD, LPENUM_SERVICE_STATUSA, DWORD, LPDWORD, LPDWORD, LPDWORD);
    BOOL(APIENTRY* VerQueryValueW)(LPCVOID, LPCWSTR, LPVOID*, PUINT);
    BOOL(WINAPI* GetComputerNameExW)(COMPUTER_NAME_FORMAT, LPWSTR, LPDWORD);
    DWORD(WINAPI* GetMappedFileNameW)(HANDLE, LPVOID, LPWSTR, DWORD);
    SIZE_T(WINAPI* VirtualQueryEx)(HANDLE, LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T);
    DWORD(WINAPI* GetThreadId)(HANDLE);
    HANDLE(WINAPI* GetProcessHeap)(VOID);
    DWORD(WINAPI* GetModuleBaseNameW)(HANDLE, HMODULE, LPWSTR, DWORD);
    DWORD(WINAPI* GetModuleFileNameExW)(HANDLE, HMODULE, LPWSTR, DWORD);
    BOOL(WINAPI* CloseHandle)(HANDLE);
    NTSTATUS(NTAPI* NtQueryInformationThread)(HANDLE, THREADINFOCLASS, PVOID, ULONG, PULONG);
    BOOL(WINAPI* OpenProcessToken)(HANDLE, DWORD, PHANDLE);
    int(WINAPI* MultiByteToWideChar)(UINT, DWORD, LPCCH, int, LPWSTR, int);
    BOOL(WINAPI* VirtualFreeEx)(HANDLE, LPVOID, SIZE_T, DWORD);
    BOOL(WINAPI* Module32NextW)(HANDLE, LPMODULEENTRY32W);
    SC_HANDLE(WINAPI* OpenServiceA)(SC_HANDLE, LPCSTR, DWORD);
    SC_HANDLE(WINAPI* OpenServiceW)(SC_HANDLE, LPCWSTR, DWORD);
    BOOL(WINAPI* EnumServicesStatusW)(SC_HANDLE, DWORD, DWORD, LPENUM_SERVICE_STATUSW, DWORD, LPDWORD, LPDWORD, LPDWORD);
    BOOL(WINAPI* GetFileSizeEx)(HANDLE, PLARGE_INTEGER);
    BOOL(WINAPI* LookupPrivilegeValueA)(LPCSTR, LPCSTR, PLUID);
    BOOL(WINAPI* GetThreadContext)(HANDLE, LPCONTEXT);
    UINT(WINAPI* GetWindowsDirectoryW)(LPWSTR, UINT);
    LPVOID(WINAPI* HeapAlloc)(HANDLE, DWORD, SIZE_T);
    BOOL(WINAPI* Heap32First)(LPHEAPENTRY32, DWORD, ULONG_PTR);
    BOOL(WINAPI* UnmapViewOfFile)(LPCVOID);
    LSTATUS(APIENTRY* RegCloseKey)(HKEY);
    ULONG(WINAPI* GetUdp6Table)(PMIB_UDP6TABLE, PULONG, BOOL);
    BOOL(WINAPI* EnumProcessModules)(HANDLE, HMODULE*, DWORD, LPDWORD);
    LPVOID(WINAPI* MapViewOfFile)(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
    NTSTATUS(NTAPI* NtDuplicateObject)(HANDLE, PHANDLE, HANDLE, PHANDLE, ACCESS_MASK, BOOLEAN, ULONG);
    BOOL(WINAPI* Thread32Next)(HANDLE, LPTHREADENTRY32);
    HANDLE(WINAPI* CreateFileW)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
    BOOL(WINAPI* StackWalk64)(DWORD, HANDLE, HANDLE, LPSTACKFRAME64, PVOID, PREAD_PROCESS_MEMORY_ROUTINE64, PFUNCTION_TABLE_ACCESS_ROUTINE64, PGET_MODULE_BASE_ROUTINE64, PTRANSLATE_ADDRESS_ROUTINE64);
    BOOL(WINAPI* HeapFree)(HANDLE, DWORD, LPVOID);
    NTSTATUS(NTAPI* NtWow64ReadVirtualMemory64)(HANDLE, PVOID64, PVOID, ULONG64, PULONG64);
    DWORD(WINAPI* GetProcessImageFileNameW)(HANDLE, LPWSTR, DWORD);
    NTSTATUS(NTAPI* NtOpenSection)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES);
    HANDLE(WINAPI* CreateFileMappingW)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR);
    DWORD(WINAPI* QueryDosDeviceA)(LPCSTR, LPSTR, DWORD);
    BOOL(WINAPI* GetVersionExW)(LPOSVERSIONINFOEXW);
    BOOL(WINAPI* SwitchToThread)(VOID);
    BOOL(WINAPI* WriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
    HLOCAL(WINAPI* LocalAlloc)(UINT, SIZE_T);
    BOOL(WINAPI* EnumProcesses)(DWORD*, DWORD, LPDWORD);
    BOOL(APIENTRY* GetFileVersionInfoW)(LPCWSTR, DWORD, DWORD, LPVOID);
    NTSTATUS(NTAPI* NtQueryObject)(HANDLE, OBJECT_INFORMATION_CLASS, PVOID, ULONG, PULONG);
    NTSTATUS(NTAPI* NtWow64QueryInformationProcess64)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
    DWORD(WINAPI* QueryDosDeviceW)(LPCWSTR, LPWSTR, DWORD);
    HRESULT(WINAPI* WinVerifyTrustEx)(HWND, GUID*, WINTRUST_DATA*);
    DWORD(WINAPI* GetCurrentProcessId)(VOID);
    ULONG(WINAPI* GetTcp6Table)(PMIB_TCP6TABLE, PULONG, BOOL);
    DWORD_PTR(WINAPI* SetThreadAffinityMask)(HANDLE, DWORD_PTR);
    LPVOID(WINAPI* VirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD);
    SIZE_T(WINAPI* VirtualQuery)(LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T);
    DWORD(WINAPI* SetFilePointer)(HANDLE, LONG, PLONG, DWORD);
    BOOL(WINAPI* Process32FirstW)(HANDLE, LPPROCESSENTRY32W);
    HANDLE(WINAPI* CreateRemoteThread)(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
    NTSTATUS(NTAPI* NtQueryVirtualMemory)(HANDLE, PVOID, DWORD, PVOID, ULONG, PULONG);
    DWORD(WINAPI* SuspendThread)(HANDLE);
    BOOL(WINAPI* CryptDecodeObject)(DWORD, LPCSTR, const BYTE*, DWORD, DWORD, void*, DWORD*);
    NTSTATUS(NTAPI* NtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
    HMODULE(WINAPI* LoadLibraryA)(LPCSTR);
    BOOL(WINAPI* SetupDiGetDeviceRegistryPropertyA)(HDEVINFO, PSP_DEVINFO_DATA, DWORD, PDWORD, PBYTE, DWORD, PDWORD);
    BOOL(WINAPI* FindVolumeClose)(HANDLE);
    NTSTATUS(NTAPI* NtReadVirtualMemory)(HANDLE, PVOID, PVOID, ULONG, PULONG);
    BOOL(WINAPI* IsWow64Process)(HANDLE, PBOOL);
    HMODULE(WINAPI* GetModuleHandleA)(LPCSTR);
    UINT(WINAPI* GetDriveTypeW)(LPCWSTR);
    LSTATUS(APIENTRY* RegQueryInfoKeyA)(HKEY, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, PFILETIME);
    BOOL(WINAPI* AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES, DWORD, PTOKEN_PRIVILEGES, PDWORD);
    BOOL(WINAPI* Thread32First)(HANDLE, LPTHREADENTRY32);
    BOOL(WINAPI* GetVersionExA)(LPOSVERSIONINFOEXA);
    BOOL(WINAPI* FindNextVolumeW)(HANDLE, LPWSTR, DWORD);
    DWORD(WINAPI* GetCurrentThreadId)(VOID);
    NTSTATUS(NTAPI* NtQueryDirectoryObject)(HANDLE, PVOID, ULONG, BOOLEAN, BOOLEAN, PULONG, PULONG);
    NTSTATUS(NTAPI* RtlGetCompressionWorkSpaceSize)(ULONG, PULONG, PULONG);
    UINT(WINAPI* GetSystemDirectoryA)(LPSTR, UINT);
    BOOL(WINAPI* SetupDiDestroyDeviceInfoList)(HDEVINFO);
    BOOL(WINAPI* GetUserProfileDirectoryA)(HANDLE, LPSTR, LPDWORD);
    DWORD(WINAPI* GetTickCount)(VOID);
    BOOL(WINAPI* ReadProcessMemory)(HANDLE, LPCVOID, LPVOID, SIZE_T, SIZE_T*);
    BOOL(WINAPI* VirtualFree)(LPVOID, SIZE_T, DWORD);
    BOOL(WINAPI* CryptHashCertificate)(HCRYPTPROV_LEGACY, ALG_ID, DWORD, const BYTE*, DWORD, BYTE*, DWORD*);
    LPVOID(WINAPI* VirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
    NTSTATUS(NTAPI* NtClose)(HANDLE);
    BOOL(WINAPI* Process32NextW)(HANDLE, LPPROCESSENTRY32W);
    BOOL(WINAPI* CertFreeCertificateContext)(PCCERT_CONTEXT);
    NTSTATUS(WINAPI* NtOpenDirectoryObject)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES);
    VOID(WINAPI* GetSystemTimeAsFileTime)(LPFILETIME);
    VOID(WINAPI* OutputDebugStringA)(LPCSTR);
    BOOL(WINAPI* GetUserProfileDirectoryW)(HANDLE, LPWSTR, LPDWORD);
    PVOID(WINAPI* AddVectoredExceptionHandler)(ULONG, PVECTORED_EXCEPTION_HANDLER);
    VOID(WINAPI* GetSystemInfo)(LPSYSTEM_INFO);
    DWORD(WINAPI* GetModuleFileNameA)(HMODULE, LPSTR, DWORD);
    DWORD(WINAPI* WaitForSingleObject)(HANDLE, DWORD);
    PVOID(WINAPI* SymFunctionTableAccess64)(HANDLE, DWORD64);
    BOOL(WINAPI* SetupDiEnumDeviceInfo)(HDEVINFO, DWORD, PSP_DEVINFO_DATA);
    VOID(WINAPI* SetLastError)(DWORD);
    ULONG(WINAPI* GetUdpTable)(PMIB_UDPTABLE, PULONG, BOOL);
    HLOCAL(WINAPI* LocalFree)(HLOCAL);
    LSTATUS(APIENTRY* RegOpenKeyExA)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY);
    NTSTATUS(NTAPI* NtQuerySection)(HANDLE, DWORD, PVOID, ULONG, PULONG);
    DWORD64(WINAPI* SymGetModuleBase64)(HANDLE, DWORD64);
    DWORD(WINAPI* GetFileSize)(HANDLE, LPDWORD);
    NTSTATUS(NTAPI* RtlDecompressBufferEx)(USHORT, PUCHAR, ULONG, PUCHAR, ULONG, PULONG, PVOID);
    BOOL(WINAPI* VirtualProtect)(LPVOID, SIZE_T, DWORD, PDWORD);
    DWORD(WINAPI* GetLogicalDriveStringsA)(DWORD, LPSTR);
    HANDLE(WINAPI* OpenFileById)(HANDLE, LPFILE_ID_DESCRIPTOR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD);
    DWORD(WINAPI* GetLogicalDriveStringsW)(DWORD, LPWSTR);
    HANDLE(WINAPI* CreateFileA)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
    ULONG(WINAPI* GetTcpTable)(PMIB_TCPTABLE, PULONG, BOOL);
    UINT(WINAPI* GetWindowsDirectoryA)(LPSTR, UINT);
    DWORD(WINAPI* GetMappedFileNameA)(HANDLE, LPVOID, LPSTR, DWORD);
    DWORD pad[28];
} WinApi;

extern WinApi winApi;

// 51 A1 ? ? ? ?
BOOLEAN Utils_getSystemInformation(VOID);

// A1 ? ? ? ? 53 56
int Utils_wideCharToMultiByte(LPCWCH, LPSTR);

// A1 ? ? ? ? 53
int Utils_wideCharToMultiByteN(LPCWCH wideCharStr, LPSTR multiByteStr, INT count);

// E8 ? ? ? ? 59 B0 01 (relative jump)
VOID Utils_copyStringW2(PWSTR, PCWSTR);

// E8 ? ? ? ? 8D 44 24 48 (relative jump)
BOOLEAN Utils_replaceDevicePathWithName(PWSTR, INT);

typedef struct Snmp {
    VOID(WINAPI* SnmpUtilVarBindFree)(SnmpVarBind*);
    HMODULE inetmib1;
    LPVOID(WINAPI* SnmpUtilMemAlloc)(UINT);
    HMODULE snmpapi;
    BOOL(WINAPI* SnmpExtensionQuery)(BYTE, SnmpVarBindList*, AsnInteger32*, AsnInteger32*);
} Snmp;

extern Snmp snmp;

// E8 ? ? ? ? EB 07 (relative jump)
VOID Utils_freeSnmp(VOID);

// E8 ? ? ? ? 84 C0 74 6B (relative jump)
BOOLEAN Utils_initializeSnmp(VOID);

// 55 8B EC 83 EC 10
BOOLEAN Utils_retrieveAsnValue(AsnInteger32*);

// 83 EC 10 53 55
BOOLEAN Utils_findAsnString(AsnInteger32, PBYTE);

// E8 ? ? ? ? 89 45 54 (relative jump)
INT Utils_enumProcesses(DWORD[500], DWORD[500]);

// B8 ? ? ? ? 85 D2
UINT Utils_hash(LPCVOID data, INT count);

```

`VAC/VAC.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{F6E84D48-D08A-4CB7-9750-BDD8504A7232}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VAC</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;VAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;VAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;VAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;VAC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Encryption\Ice.c" />
    <ClCompile Include="Modules\DeviceInfo\DeviceInfo.c" />
    <ClCompile Include="Modules\DriverInfo\DriverInfo.c" />
    <ClCompile Include="Modules\ProcessHandleList\ProcessHandleList.c" />
    <ClCompile Include="Modules\ProcessMonitor\ProcessMonitor.c" />
    <ClCompile Include="Modules\ReadModules\ReadModules.c" />
    <ClCompile Include="Modules\SystemInfo\SystemInfo.c" />
    <ClCompile Include="Utils.c" />
    <ClCompile Include="Vector.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Encryption\Ice.h" />
    <ClInclude Include="Modules\DeviceInfo\DeviceInfo.h" />
    <ClInclude Include="Modules\DriverInfo\DriverInfo.h" />
    <ClInclude Include="Modules\ProcessHandleList\ProcessHandleList.h" />
    <ClInclude Include="Modules\ProcessMonitor\ProcessMonitor.h" />
    <ClInclude Include="Modules\ReadModules\ReadModules.h" />
    <ClInclude Include="Modules\SystemInfo\SystemInfo.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="Vector.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`VAC/VAC.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Encryption">
      <UniqueIdentifier>{c7e4e98e-48c8-4976-9369-c4adca5fbb0a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules">
      <UniqueIdentifier>{0cdbedfa-3e62-4558-93de-833e68381a67}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules\DeviceInfo">
      <UniqueIdentifier>{7181e515-6d3e-40e6-a8b0-301a8d3ca7b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules\DriverInfo">
      <UniqueIdentifier>{ddcf1cf0-62d2-438f-b61d-76a76e99a079}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules\SystemInfo">
      <UniqueIdentifier>{445b7b5a-cb2e-489c-8a38-929de2d074af}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules\ProcessHandleList">
      <UniqueIdentifier>{a30ea731-8e60-451e-8484-802f4db29fd2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules\ProcessMonitor">
      <UniqueIdentifier>{4a25f63e-9f52-498d-8426-35ef45be3823}</UniqueIdentifier>
    </Filter>
    <Filter Include="Modules\ReadModules">
      <UniqueIdentifier>{d6402769-90dd-4cd0-941a-0b4de4c3ce81}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Encryption\Ice.h">
      <Filter>Encryption</Filter>
    </ClInclude>
    <ClInclude Include="Vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Modules\DeviceInfo\DeviceInfo.h">
      <Filter>Modules\DeviceInfo</Filter>
    </ClInclude>
    <ClInclude Include="Modules\DriverInfo\DriverInfo.h">
      <Filter>Modules\DriverInfo</Filter>
    </ClInclude>
    <ClInclude Include="Modules\SystemInfo\SystemInfo.h">
      <Filter>Modules\SystemInfo</Filter>
    </ClInclude>
    <ClInclude Include="Modules\ProcessHandleList\ProcessHandleList.h">
      <Filter>Modules\ProcessHandleList</Filter>
    </ClInclude>
    <ClInclude Include="Modules\ProcessMonitor\ProcessMonitor.h">
      <Filter>Modules\ProcessMonitor</Filter>
    </ClInclude>
    <ClInclude Include="Modules\ReadModules\ReadModules.h">
      <Filter>Modules\ReadModules</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Encryption\Ice.c">
      <Filter>Encryption</Filter>
    </ClCompile>
    <ClCompile Include="Vector.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Modules\DeviceInfo\DeviceInfo.c">
      <Filter>Modules\DeviceInfo</Filter>
    </ClCompile>
    <ClCompile Include="Modules\DriverInfo\DriverInfo.c">
      <Filter>Modules\DriverInfo</Filter>
    </ClCompile>
    <ClCompile Include="Modules\SystemInfo\SystemInfo.c">
      <Filter>Modules\SystemInfo</Filter>
    </ClCompile>
    <ClCompile Include="Modules\ProcessHandleList\ProcessHandleList.c">
      <Filter>Modules\ProcessHandleList</Filter>
    </ClCompile>
    <ClCompile Include="Modules\ProcessMonitor\ProcessMonitor.c">
      <Filter>Modules\ProcessMonitor</Filter>
    </ClCompile>
    <ClCompile Include="Modules\ReadModules\ReadModules.c">
      <Filter>Modules\ReadModules</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`VAC/Vector.c`:

```c
#include "Utils.h"
#include "Vector.h"

// E8 ? ? ? ? 8B 16 (relative jump)
VOID Vector_ensureCapacity(Vector* vec, UINT capacity)
{
    if (vec->allocationCount < capacity) {
        DWORD* oldMemory = vec->memory;

        vec->allocationCount = capacity;
        vec->memory = Utils_heapAlloc(capacity * sizeof(DWORD));

        for (INT i = vec->size - 1; i; i--)
            vec->memory[i] = oldMemory[i];

        Utils_heapFree(oldMemory);
    }
}

// 56 FF 74 24 08
VOID Vector_resize(Vector* vec, UINT size)
{
    Vector_ensureCapacity(vec, size);

    while (vec->size < size) {
        vec->memory[vec->size] = 0;
        vec->size++;
    }

    vec->sizeInBits = size * sizeof(DWORD) * 8;
}

// E8 ? ? ? ? 8B CD (relative jump)
VOID Vector_swap(Vector* vec1, Vector* vec2)
{
    CONST Vector temp = *vec1;
    vec1->memory = vec2->memory;
    vec1->allocationCount = vec2->allocationCount;
    vec1->size = vec2->size;
    vec1->sizeInBits = vec2->sizeInBits;

    vec2->memory = temp.memory;
    vec2->allocationCount = temp.allocationCount;
    vec2->size = temp.size;
    vec2->sizeInBits = temp.sizeInBits;
}

```

`VAC/Vector.h`:

```h
#pragma once

#include <Windows.h>

typedef struct Vector {
    DWORD* memory;
    UINT allocationCount;
    UINT size;
    INT sizeInBits;
} Vector;

// E8 ? ? ? ? 8B 16 (relative jump)
VOID Vector_ensureCapacity(Vector*, UINT);

// 56 FF 74 24 08
VOID Vector_resize(Vector*, UINT);

// E8 ? ? ? ? 8B CD (relative jump)
VOID Vector_swap(Vector*, Vector*);

```