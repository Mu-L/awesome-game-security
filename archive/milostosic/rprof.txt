Project Path: arc_milostosic_rprof_tmi2eyas

Source Tree:

```txt
arc_milostosic_rprof_tmi2eyas
├── 3rd
│   ├── imgui
│   ├── implot
│   └── lz4-r191
│       ├── lz4.c
│       └── lz4.h
├── LICENSE
├── README.md
├── genie
│   ├── genie.lua
│   └── rprof.lua
├── img
│   ├── rprof_browser.gif
│   └── rprof_vis.jpg
├── inc
│   ├── rprof.h
│   └── rprof_imgui.h
├── makefile
├── samples
│   └── 01_demo
│       ├── demo.cpp
│       ├── demo_pch.cpp
│       └── demo_pch.h
├── scripts
│   ├── win_fetch_dependencies.bat
│   ├── win_generate_inspector_project.bat
│   └── win_generate_project.bat
├── src
│   ├── rprof_config.h
│   ├── rprof_context.cpp
│   ├── rprof_context.h
│   ├── rprof_freelist.cpp
│   ├── rprof_freelist.h
│   ├── rprof_lib.cpp
│   ├── rprof_mutex.h
│   ├── rprof_platform.h
│   └── rprof_tls.h
└── tools
    └── rprof_inspector
        ├── Makefile
        ├── capture.rprof
        ├── capture.rprofm
        ├── data
        │   └── MavenPro-Regular.ttf
        ├── main.cpp
        └── rprof.html

```

`3rd/lz4-r191/lz4.c`:

```c
/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-present, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*/

/*-************************************
*  Tuning parameters
**************************************/
/*
 * LZ4_HEAPMODE :
 * Select how default compression functions will allocate memory for their hash table,
 * in memory stack (0:default, fastest), or in memory heap (1:requires malloc()).
 */
#ifndef LZ4_HEAPMODE
#  define LZ4_HEAPMODE 0
#endif

/*
 * ACCELERATION_DEFAULT :
 * Select "acceleration" for LZ4_compress_fast() when parameter value <= 0
 */
#define ACCELERATION_DEFAULT 1


/*-************************************
*  CPU Feature Detection
**************************************/
/* LZ4_FORCE_MEMORY_ACCESS
 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
 * The below switch allow to select different access method for improved performance.
 * Method 0 (default) : use `memcpy()`. Safe and portable.
 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
 * Method 2 : direct access. This method is portable but violate C standard.
 *            It can generate buggy code on targets which assembly generation depends on alignment.
 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
 * See https://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
 * Prefer these methods in priority order (0 > 1 > 2)
 */
#ifndef LZ4_FORCE_MEMORY_ACCESS   /* can be defined externally */
#  if defined(__GNUC__) && \
  ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) \
  || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )
#    define LZ4_FORCE_MEMORY_ACCESS 2
#  elif (defined(__INTEL_COMPILER) && !defined(_WIN32)) || defined(__GNUC__)
#    define LZ4_FORCE_MEMORY_ACCESS 1
#  endif
#endif

/*
 * LZ4_FORCE_SW_BITCOUNT
 * Define this parameter if your target system or compiler does not support hardware bit count
 */
#if defined(_MSC_VER) && defined(_WIN32_WCE)   /* Visual Studio for WinCE doesn't support Hardware bit count */
#  define LZ4_FORCE_SW_BITCOUNT
#endif



/*-************************************
*  Dependency
**************************************/
/*
 * LZ4_SRC_INCLUDED:
 * Amalgamation flag, whether lz4.c is included
 */
#ifndef LZ4_SRC_INCLUDED
#  define LZ4_SRC_INCLUDED 1
#endif

#ifndef LZ4_STATIC_LINKING_ONLY
#define LZ4_STATIC_LINKING_ONLY
#endif

#ifndef LZ4_DISABLE_DEPRECATE_WARNINGS
#define LZ4_DISABLE_DEPRECATE_WARNINGS /* due to LZ4_decompress_safe_withPrefix64k */
#endif

#include "lz4.h"
/* see also "memory routines" below */


/*-************************************
*  Compiler Options
**************************************/
#ifdef _MSC_VER    /* Visual Studio */
#  include <intrin.h>
#  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */
#  pragma warning(disable : 4293)        /* disable: C4293: too large shift (32-bits) */
#endif  /* _MSC_VER */

#ifndef LZ4_FORCE_INLINE
#  ifdef _MSC_VER    /* Visual Studio */
#    define LZ4_FORCE_INLINE static __forceinline
#  else
#    if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#      ifdef __GNUC__
#        define LZ4_FORCE_INLINE static inline __attribute__((always_inline))
#      else
#        define LZ4_FORCE_INLINE static inline
#      endif
#    else
#      define LZ4_FORCE_INLINE static
#    endif /* __STDC_VERSION__ */
#  endif  /* _MSC_VER */
#endif /* LZ4_FORCE_INLINE */

/* LZ4_FORCE_O2_GCC_PPC64LE and LZ4_FORCE_O2_INLINE_GCC_PPC64LE
 * gcc on ppc64le generates an unrolled SIMDized loop for LZ4_wildCopy8,
 * together with a simple 8-byte copy loop as a fall-back path.
 * However, this optimization hurts the decompression speed by >30%,
 * because the execution does not go to the optimized loop
 * for typical compressible data, and all of the preamble checks
 * before going to the fall-back path become useless overhead.
 * This optimization happens only with the -O3 flag, and -O2 generates
 * a simple 8-byte copy loop.
 * With gcc on ppc64le, all of the LZ4_decompress_* and LZ4_wildCopy8
 * functions are annotated with __attribute__((optimize("O2"))),
 * and also LZ4_wildCopy8 is forcibly inlined, so that the O2 attribute
 * of LZ4_wildCopy8 does not affect the compression speed.
 */
#if defined(__PPC64__) && defined(__LITTLE_ENDIAN__) && defined(__GNUC__) && !defined(__clang__)
#  define LZ4_FORCE_O2_GCC_PPC64LE __attribute__((optimize("O2")))
#  define LZ4_FORCE_O2_INLINE_GCC_PPC64LE __attribute__((optimize("O2"))) LZ4_FORCE_INLINE
#else
#  define LZ4_FORCE_O2_GCC_PPC64LE
#  define LZ4_FORCE_O2_INLINE_GCC_PPC64LE static
#endif

#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)
#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )
#else
#  define expect(expr,value)    (expr)
#endif

#ifndef likely
#define likely(expr)     expect((expr) != 0, 1)
#endif
#ifndef unlikely
#define unlikely(expr)   expect((expr) != 0, 0)
#endif


/*-************************************
*  Memory routines
**************************************/
#include <stdlib.h>   /* malloc, calloc, free */
#define ALLOC(s)          malloc(s)
#define ALLOC_AND_ZERO(s) calloc(1,s)
#define FREEMEM(p)        free(p)
#include <string.h>   /* memset, memcpy */
#define MEM_INIT(p,v,s)   memset((p),(v),(s))


/*-************************************
*  Types
**************************************/
#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
# include <stdint.h>
  typedef  uint8_t BYTE;
  typedef uint16_t U16;
  typedef uint32_t U32;
  typedef  int32_t S32;
  typedef uint64_t U64;
  typedef uintptr_t uptrval;
#else
  typedef unsigned char       BYTE;
  typedef unsigned short      U16;
  typedef unsigned int        U32;
  typedef   signed int        S32;
  typedef unsigned long long  U64;
  typedef size_t              uptrval;   /* generally true, except OpenVMS-64 */
#endif

#if defined(__x86_64__)
  typedef U64    reg_t;   /* 64-bits in x32 mode */
#else
  typedef size_t reg_t;   /* 32-bits in x32 mode */
#endif

typedef enum {
    notLimited = 0,
    limitedOutput = 1,
    fillOutput = 2
} limitedOutput_directive;


/*-************************************
*  Reading and writing into memory
**************************************/
static unsigned LZ4_isLittleEndian(void)
{
    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental */
    return one.c[0];
}


#if defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==2)
/* lie to the compiler about data alignment; use with caution */

static U16 LZ4_read16(const void* memPtr) { return *(const U16*) memPtr; }
static U32 LZ4_read32(const void* memPtr) { return *(const U32*) memPtr; }
static reg_t LZ4_read_ARCH(const void* memPtr) { return *(const reg_t*) memPtr; }

static void LZ4_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }
static void LZ4_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }

#elif defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==1)

/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
/* currently only defined for gcc and icc */
typedef union { U16 u16; U32 u32; reg_t uArch; } __attribute__((packed)) unalign;

static U16 LZ4_read16(const void* ptr) { return ((const unalign*)ptr)->u16; }
static U32 LZ4_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }

static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }

#else  /* safe and portable access using memcpy() */

static U16 LZ4_read16(const void* memPtr)
{
    U16 val; memcpy(&val, memPtr, sizeof(val)); return val;
}

static U32 LZ4_read32(const void* memPtr)
{
    U32 val; memcpy(&val, memPtr, sizeof(val)); return val;
}

static reg_t LZ4_read_ARCH(const void* memPtr)
{
    reg_t val; memcpy(&val, memPtr, sizeof(val)); return val;
}

static void LZ4_write16(void* memPtr, U16 value)
{
    memcpy(memPtr, &value, sizeof(value));
}

static void LZ4_write32(void* memPtr, U32 value)
{
    memcpy(memPtr, &value, sizeof(value));
}

#endif /* LZ4_FORCE_MEMORY_ACCESS */


static U16 LZ4_readLE16(const void* memPtr)
{
    if (LZ4_isLittleEndian()) {
        return LZ4_read16(memPtr);
    } else {
        const BYTE* p = (const BYTE*)memPtr;
        return (U16)((U16)p[0] + (p[1]<<8));
    }
}

static void LZ4_writeLE16(void* memPtr, U16 value)
{
    if (LZ4_isLittleEndian()) {
        LZ4_write16(memPtr, value);
    } else {
        BYTE* p = (BYTE*)memPtr;
        p[0] = (BYTE) value;
        p[1] = (BYTE)(value>>8);
    }
}

/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */
LZ4_FORCE_O2_INLINE_GCC_PPC64LE
void LZ4_wildCopy8(void* dstPtr, const void* srcPtr, void* dstEnd)
{
    BYTE* d = (BYTE*)dstPtr;
    const BYTE* s = (const BYTE*)srcPtr;
    BYTE* const e = (BYTE*)dstEnd;

    do { memcpy(d,s,8); d+=8; s+=8; } while (d<e);
}

static const unsigned inc32table[8] = {0, 1, 2,  1,  0,  4, 4, 4};
static const int      dec64table[8] = {0, 0, 0, -1, -4,  1, 2, 3};


#ifndef LZ4_FAST_DEC_LOOP
#  if defined(__i386__) || defined(__x86_64__)
#    define LZ4_FAST_DEC_LOOP 1
#  else
#    define LZ4_FAST_DEC_LOOP 0
#  endif
#endif

#if LZ4_FAST_DEC_LOOP

LZ4_FORCE_O2_INLINE_GCC_PPC64LE void
LZ4_memcpy_using_offset_base(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
{
    if (offset < 8) {
        dstPtr[0] = srcPtr[0];
        dstPtr[1] = srcPtr[1];
        dstPtr[2] = srcPtr[2];
        dstPtr[3] = srcPtr[3];
        srcPtr += inc32table[offset];
        memcpy(dstPtr+4, srcPtr, 4);
        srcPtr -= dec64table[offset];
        dstPtr += 8;
    } else {
        memcpy(dstPtr, srcPtr, 8);
        dstPtr += 8;
        srcPtr += 8;
    }

    LZ4_wildCopy8(dstPtr, srcPtr, dstEnd);
}

/* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd
 * this version copies two times 16 bytes (instead of one time 32 bytes)
 * because it must be compatible with offsets >= 16. */
LZ4_FORCE_O2_INLINE_GCC_PPC64LE void
LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)
{
    BYTE* d = (BYTE*)dstPtr;
    const BYTE* s = (const BYTE*)srcPtr;
    BYTE* const e = (BYTE*)dstEnd;

    do { memcpy(d,s,16); memcpy(d+16,s+16,16); d+=32; s+=32; } while (d<e);
}

LZ4_FORCE_O2_INLINE_GCC_PPC64LE void
LZ4_memcpy_using_offset(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
{
    BYTE v[8];
    switch(offset) {
    case 1:
        memset(v, *srcPtr, 8);
        goto copy_loop;
    case 2:
        memcpy(v, srcPtr, 2);
        memcpy(&v[2], srcPtr, 2);
        memcpy(&v[4], &v[0], 4);
        goto copy_loop;
    case 4:
        memcpy(v, srcPtr, 4);
        memcpy(&v[4], srcPtr, 4);
        goto copy_loop;
    default:
        LZ4_memcpy_using_offset_base(dstPtr, srcPtr, dstEnd, offset);
        return;
    }

 copy_loop:
    memcpy(dstPtr, v, 8);
    dstPtr += 8;
    while (dstPtr < dstEnd) {
        memcpy(dstPtr, v, 8);
        dstPtr += 8;
    }
}
#endif


/*-************************************
*  Common Constants
**************************************/
#define MINMATCH 4

#define WILDCOPYLENGTH 8
#define LASTLITERALS   5   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
#define MFLIMIT       12   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
#define MATCH_SAFEGUARD_DISTANCE  ((2*WILDCOPYLENGTH) - MINMATCH)   /* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer */
#define FASTLOOP_SAFE_DISTANCE 64
static const int LZ4_minLength = (MFLIMIT+1);

#define KB *(1 <<10)
#define MB *(1 <<20)
#define GB *(1U<<30)

#ifndef LZ4_DISTANCE_MAX   /* can be user - defined at compile time */
#  define LZ4_DISTANCE_MAX 65535
#endif

#if (LZ4_DISTANCE_MAX > 65535)   /* max supported by LZ4 format */
#  error "LZ4_DISTANCE_MAX is too big : must be <= 65535"
#endif

#define ML_BITS  4
#define ML_MASK  ((1U<<ML_BITS)-1)
#define RUN_BITS (8-ML_BITS)
#define RUN_MASK ((1U<<RUN_BITS)-1)


/*-************************************
*  Error detection
**************************************/
#if defined(LZ4_DEBUG) && (LZ4_DEBUG>=1)
#  include <assert.h>
#else
#  ifndef assert
#    define assert(condition) ((void)0)
#  endif
#endif

#define LZ4_STATIC_ASSERT(c)   { enum { LZ4_static_assert = 1/(int)(!!(c)) }; }   /* use after variable declarations */

#if defined(LZ4_DEBUG) && (LZ4_DEBUG>=2)
#  include <stdio.h>
static int g_debuglog_enable = 1;
#  define DEBUGLOG(l, ...) {                                  \
                if ((g_debuglog_enable) && (l<=LZ4_DEBUG)) {  \
                    fprintf(stderr, __FILE__ ": ");           \
                    fprintf(stderr, __VA_ARGS__);             \
                    fprintf(stderr, " \n");                   \
            }   }
#else
#  define DEBUGLOG(l, ...)      {}    /* disabled */
#endif


/*-************************************
*  Common functions
**************************************/
static unsigned LZ4_NbCommonBytes (reg_t val)
{
    if (LZ4_isLittleEndian()) {
        if (sizeof(val)==8) {
#       if defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r = 0;
            _BitScanForward64( &r, (U64)val );
            return (int)(r>>3);
#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (__builtin_ctzll((U64)val) >> 3);
#       else
            static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,
                                                     0, 3, 1, 3, 1, 4, 2, 7,
                                                     0, 2, 3, 6, 1, 5, 3, 5,
                                                     1, 3, 4, 4, 2, 5, 6, 7,
                                                     7, 0, 1, 2, 3, 3, 4, 6,
                                                     2, 6, 5, 5, 3, 4, 5, 6,
                                                     7, 1, 2, 4, 6, 4, 4, 5,
                                                     7, 2, 6, 5, 7, 6, 7, 7 };
            return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
#       endif
        } else /* 32 bits */ {
#       if defined(_MSC_VER) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r;
            _BitScanForward( &r, (U32)val );
            return (int)(r>>3);
#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (__builtin_ctz((U32)val) >> 3);
#       else
            static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,
                                                     3, 2, 2, 1, 3, 2, 0, 1,
                                                     3, 3, 1, 2, 2, 2, 2, 0,
                                                     3, 1, 2, 0, 1, 0, 1, 1 };
            return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
#       endif
        }
    } else   /* Big Endian CPU */ {
        if (sizeof(val)==8) {   /* 64-bits */
#       if defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r = 0;
            _BitScanReverse64( &r, val );
            return (unsigned)(r>>3);
#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (__builtin_clzll((U64)val) >> 3);
#       else
            static const U32 by32 = sizeof(val)*4;  /* 32 on 64 bits (goal), 16 on 32 bits.
                Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.
                Note that this code path is never triggered in 32-bits mode. */
            unsigned r;
            if (!(val>>by32)) { r=4; } else { r=0; val>>=by32; }
            if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
            r += (!val);
            return r;
#       endif
        } else /* 32 bits */ {
#       if defined(_MSC_VER) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r = 0;
            _BitScanReverse( &r, (unsigned long)val );
            return (unsigned)(r>>3);
#       elif (defined(__clang__) || (defined(__GNUC__) && (__GNUC__>=3))) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (__builtin_clz((U32)val) >> 3);
#       else
            unsigned r;
            if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }
            r += (!val);
            return r;
#       endif
        }
    }
}

#define STEPSIZE sizeof(reg_t)
LZ4_FORCE_INLINE
unsigned LZ4_count(const BYTE* pIn, const BYTE* pMatch, const BYTE* pInLimit)
{
    const BYTE* const pStart = pIn;

    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
        if (!diff) {
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
        } else {
            return LZ4_NbCommonBytes(diff);
    }   }

    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
        pIn += LZ4_NbCommonBytes(diff);
        return (unsigned)(pIn - pStart);
    }

    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
    return (unsigned)(pIn - pStart);
}


#ifndef LZ4_COMMONDEFS_ONLY
/*-************************************
*  Local Constants
**************************************/
static const int LZ4_64Klimit = ((64 KB) + (MFLIMIT-1));
static const U32 LZ4_skipTrigger = 6;  /* Increase this value ==> compression run slower on incompressible data */


/*-************************************
*  Local Structures and types
**************************************/
typedef enum { clearedTable = 0, byPtr, byU32, byU16 } tableType_t;

/**
 * This enum distinguishes several different modes of accessing previous
 * content in the stream.
 *
 * - noDict        : There is no preceding content.
 * - withPrefix64k : Table entries up to ctx->dictSize before the current blob
 *                   blob being compressed are valid and refer to the preceding
 *                   content (of length ctx->dictSize), which is available
 *                   contiguously preceding in memory the content currently
 *                   being compressed.
 * - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere
 *                   else in memory, starting at ctx->dictionary with length
 *                   ctx->dictSize.
 * - usingDictCtx  : Like usingExtDict, but everything concerning the preceding
 *                   content is in a separate context, pointed to by
 *                   ctx->dictCtx. ctx->dictionary, ctx->dictSize, and table
 *                   entries in the current context that refer to positions
 *                   preceding the beginning of the current compression are
 *                   ignored. Instead, ctx->dictCtx->dictionary and ctx->dictCtx
 *                   ->dictSize describe the location and size of the preceding
 *                   content, and matches are found by looking in the ctx
 *                   ->dictCtx->hashTable.
 */
typedef enum { noDict = 0, withPrefix64k, usingExtDict, usingDictCtx } dict_directive;
typedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;


/*-************************************
*  Local Utils
**************************************/
int LZ4_versionNumber (void) { return LZ4_VERSION_NUMBER; }
const char* LZ4_versionString(void) { return LZ4_VERSION_STRING; }
int LZ4_compressBound(int isize)  { return LZ4_COMPRESSBOUND(isize); }
int LZ4_sizeofState() { return LZ4_STREAMSIZE; }


/*-************************************
*  Internal Definitions used in Tests
**************************************/
#if defined (__cplusplus)
extern "C" {
#endif

int LZ4_compress_forceExtDict (LZ4_stream_t* LZ4_stream, const char* source, char* dest, int inputSize);

int LZ4_decompress_safe_forceExtDict(const char* in, char* out, int inSize, int outSize, const void* dict, size_t dictSize);

#if defined (__cplusplus)
}
#endif

/*-******************************
*  Compression functions
********************************/
static U32 LZ4_hash4(U32 sequence, tableType_t const tableType)
{
    if (tableType == byU16)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
    else
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));
}

static U32 LZ4_hash5(U64 sequence, tableType_t const tableType)
{
    const U32 hashLog = (tableType == byU16) ? LZ4_HASHLOG+1 : LZ4_HASHLOG;
    if (LZ4_isLittleEndian()) {
        const U64 prime5bytes = 889523592379ULL;
        return (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));
    } else {
        const U64 prime8bytes = 11400714785074694791ULL;
        return (U32)(((sequence >> 24) * prime8bytes) >> (64 - hashLog));
    }
}

LZ4_FORCE_INLINE U32 LZ4_hashPosition(const void* const p, tableType_t const tableType)
{
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
    return LZ4_hash4(LZ4_read32(p), tableType);
}

static void LZ4_putIndexOnHash(U32 idx, U32 h, void* tableBase, tableType_t const tableType)
{
    switch (tableType)
    {
    default: /* fallthrough */
    case clearedTable: /* fallthrough */
    case byPtr: { /* illegal! */ assert(0); return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
    case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
    }
}

static void LZ4_putPositionOnHash(const BYTE* p, U32 h,
                                  void* tableBase, tableType_t const tableType,
                            const BYTE* srcBase)
{
    switch (tableType)
    {
    case clearedTable: { /* illegal! */ assert(0); return; }
    case byPtr: { const BYTE** hashTable = (const BYTE**)tableBase; hashTable[h] = p; return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
    case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
    }
}

LZ4_FORCE_INLINE void LZ4_putPosition(const BYTE* p, void* tableBase, tableType_t tableType, const BYTE* srcBase)
{
    U32 const h = LZ4_hashPosition(p, tableType);
    LZ4_putPositionOnHash(p, h, tableBase, tableType, srcBase);
}

/* LZ4_getIndexOnHash() :
 * Index of match position registered in hash table.
 * hash position must be calculated by using base+index, or dictBase+index.
 * Assumption 1 : only valid if tableType == byU32 or byU16.
 * Assumption 2 : h is presumed valid (within limits of hash table)
 */
static U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_t tableType)
{
    LZ4_STATIC_ASSERT(LZ4_MEMORY_USAGE > 2);
    if (tableType == byU32) {
        const U32* const hashTable = (const U32*) tableBase;
        assert(h < (1U << (LZ4_MEMORY_USAGE-2)));
        return hashTable[h];
    }
    if (tableType == byU16) {
        const U16* const hashTable = (const U16*) tableBase;
        assert(h < (1U << (LZ4_MEMORY_USAGE-1)));
        return hashTable[h];
    }
    assert(0); return 0;  /* forbidden case */
}

static const BYTE* LZ4_getPositionOnHash(U32 h, const void* tableBase, tableType_t tableType, const BYTE* srcBase)
{
    if (tableType == byPtr) { const BYTE* const* hashTable = (const BYTE* const*) tableBase; return hashTable[h]; }
    if (tableType == byU32) { const U32* const hashTable = (const U32*) tableBase; return hashTable[h] + srcBase; }
    { const U16* const hashTable = (const U16*) tableBase; return hashTable[h] + srcBase; }   /* default, to ensure a return */
}

LZ4_FORCE_INLINE const BYTE* LZ4_getPosition(const BYTE* p,
                                             const void* tableBase, tableType_t tableType,
                                             const BYTE* srcBase)
{
    U32 const h = LZ4_hashPosition(p, tableType);
    return LZ4_getPositionOnHash(h, tableBase, tableType, srcBase);
}

LZ4_FORCE_INLINE void LZ4_prepareTable(
        LZ4_stream_t_internal* const cctx,
        const int inputSize,
        const tableType_t tableType) {
    /* If compression failed during the previous step, then the context
     * is marked as dirty, therefore, it has to be fully reset.
     */
    if (cctx->dirty) {
        DEBUGLOG(5, "LZ4_prepareTable: Full reset for %p", cctx);
        MEM_INIT(cctx, 0, sizeof(LZ4_stream_t_internal));
        return;
    }

    /* If the table hasn't been used, it's guaranteed to be zeroed out, and is
     * therefore safe to use no matter what mode we're in. Otherwise, we figure
     * out if it's safe to leave as is or whether it needs to be reset.
     */
    if (cctx->tableType != clearedTable) {
        if (cctx->tableType != tableType
          || (tableType == byU16 && cctx->currentOffset + inputSize >= 0xFFFFU)
          || (tableType == byU32 && cctx->currentOffset > 1 GB)
          || tableType == byPtr
          || inputSize >= 4 KB)
        {
            DEBUGLOG(4, "LZ4_prepareTable: Resetting table in %p", cctx);
            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
            cctx->currentOffset = 0;
            cctx->tableType = clearedTable;
        } else {
            DEBUGLOG(4, "LZ4_prepareTable: Re-use hash table (no reset)");
        }
    }

    /* Adding a gap, so all previous entries are > LZ4_DISTANCE_MAX back, is faster
     * than compressing without a gap. However, compressing with
     * currentOffset == 0 is faster still, so we preserve that case.
     */
    if (cctx->currentOffset != 0 && tableType == byU32) {
        DEBUGLOG(5, "LZ4_prepareTable: adding 64KB to currentOffset");
        cctx->currentOffset += 64 KB;
    }

    /* Finally, clear history */
    cctx->dictCtx = NULL;
    cctx->dictionary = NULL;
    cctx->dictSize = 0;
}

/** LZ4_compress_generic() :
    inlined, to ensure branches are decided at compilation time */
LZ4_FORCE_INLINE int LZ4_compress_generic(
                 LZ4_stream_t_internal* const cctx,
                 const char* const source,
                 char* const dest,
                 const int inputSize,
                 int *inputConsumed, /* only written when outputDirective == fillOutput */
                 const int maxOutputSize,
                 const limitedOutput_directive outputDirective,
                 const tableType_t tableType,
                 const dict_directive dictDirective,
                 const dictIssue_directive dictIssue,
                 const int acceleration)
{
    int result;
    const BYTE* ip = (const BYTE*) source;

    U32 const startIndex = cctx->currentOffset;
    const BYTE* base = (const BYTE*) source - startIndex;
    const BYTE* lowLimit;

    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;
    const BYTE* const dictionary =
        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
    const U32 dictSize =
        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */

    int const maybe_extMem = (dictDirective == usingExtDict) || (dictDirective == usingDictCtx);
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
    const BYTE* const dictEnd = dictionary + dictSize;
    const BYTE* anchor = (const BYTE*) source;
    const BYTE* const iend = ip + inputSize;
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
    const BYTE* const matchlimit = iend - LASTLITERALS;

    /* the dictCtx currentOffset is indexed on the start of the dictionary,
     * while a dictionary in the current context precedes the currentOffset */
    const BYTE* dictBase = (dictDirective == usingDictCtx) ?
                            dictionary + dictSize - dictCtx->currentOffset :
                            dictionary + dictSize - startIndex;

    BYTE* op = (BYTE*) dest;
    BYTE* const olimit = op + maxOutputSize;

    U32 offset = 0;
    U32 forwardH;

    DEBUGLOG(5, "LZ4_compress_generic: srcSize=%i, tableType=%u", inputSize, tableType);
    /* If init conditions are not met, we don't have to mark stream
     * as having dirty context, since no action was taken yet */
    if (outputDirective == fillOutput && maxOutputSize < 1) return 0;   /* Impossible to store anything */
    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) return 0;           /* Unsupported inputSize, too large (or negative) */
    if ((tableType == byU16) && (inputSize>=LZ4_64Klimit)) return 0;  /* Size too large (not within 64K limit) */
    if (tableType==byPtr) assert(dictDirective==noDict);      /* only supported use case with byPtr */
    assert(acceleration >= 1);

    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);

    /* Update context state */
    if (dictDirective == usingDictCtx) {
        /* Subsequent linked blocks can't use the dictionary. */
        /* Instead, they use the block we just compressed. */
        cctx->dictCtx = NULL;
        cctx->dictSize = (U32)inputSize;
    } else {
        cctx->dictSize += (U32)inputSize;
    }
    cctx->currentOffset += (U32)inputSize;
    cctx->tableType = (U16)tableType;

    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */

    /* First Byte */
    LZ4_putPosition(ip, cctx->hashTable, tableType, base);
    ip++; forwardH = LZ4_hashPosition(ip, tableType);

    /* Main Loop */
    for ( ; ; ) {
        const BYTE* match;
        BYTE* token;

        /* Find a match */
        if (tableType == byPtr) {
            const BYTE* forwardIp = ip;
            int step = 1;
            int searchMatchNb = acceleration << LZ4_skipTrigger;
            do {
                U32 const h = forwardH;
                ip = forwardIp;
                forwardIp += step;
                step = (searchMatchNb++ >> LZ4_skipTrigger);

                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
                assert(ip < mflimitPlusOne);

                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType, base);
                forwardH = LZ4_hashPosition(forwardIp, tableType);
                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType, base);

            } while ( (match+LZ4_DISTANCE_MAX < ip)
                   || (LZ4_read32(match) != LZ4_read32(ip)) );

        } else {   /* byU32, byU16 */

            const BYTE* forwardIp = ip;
            int step = 1;
            int searchMatchNb = acceleration << LZ4_skipTrigger;
            do {
                U32 const h = forwardH;
                U32 const current = (U32)(forwardIp - base);
                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
                assert(matchIndex <= current);
                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));
                ip = forwardIp;
                forwardIp += step;
                step = (searchMatchNb++ >> LZ4_skipTrigger);

                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
                assert(ip < mflimitPlusOne);

                if (dictDirective == usingDictCtx) {
                    if (matchIndex < startIndex) {
                        /* there was no match, try the dictionary */
                        assert(tableType == byU32);
                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
                        match = dictBase + matchIndex;
                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */
                        lowLimit = dictionary;
                    } else {
                        match = base + matchIndex;
                        lowLimit = (const BYTE*)source;
                    }
                } else if (dictDirective==usingExtDict) {
                    if (matchIndex < startIndex) {
                        DEBUGLOG(7, "extDict candidate: matchIndex=%5u  <  startIndex=%5u", matchIndex, startIndex);
                        assert(startIndex - matchIndex >= MINMATCH);
                        match = dictBase + matchIndex;
                        lowLimit = dictionary;
                    } else {
                        match = base + matchIndex;
                        lowLimit = (const BYTE*)source;
                    }
                } else {   /* single continuous memory segment */
                    match = base + matchIndex;
                }
                forwardH = LZ4_hashPosition(forwardIp, tableType);
                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);

                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) continue;    /* match outside of valid area */
                assert(matchIndex < current);
                if ((tableType != byU16) && (matchIndex+LZ4_DISTANCE_MAX < current)) continue;  /* too far */
                if (tableType == byU16) assert((current - matchIndex) <= LZ4_DISTANCE_MAX);     /* too_far presumed impossible with byU16 */

                if (LZ4_read32(match) == LZ4_read32(ip)) {
                    if (maybe_extMem) offset = current - matchIndex;
                    break;   /* match found */
                }

            } while(1);
        }

        /* Catch up */
        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }

        /* Encode Literals */
        {   unsigned const litLength = (unsigned)(ip - anchor);
            token = op++;
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) )
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */

            if ((outputDirective == fillOutput) &&
                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {
                op--;
                goto _last_literals;
            }
            if (litLength >= RUN_MASK) {
                int len = (int)(litLength - RUN_MASK);
                *token = (RUN_MASK<<ML_BITS);
                for(; len >= 255 ; len-=255) *op++ = 255;
                *op++ = (BYTE)len;
            }
            else *token = (BYTE)(litLength<<ML_BITS);

            /* Copy Literals */
            LZ4_wildCopy8(op, anchor, op+litLength);
            op+=litLength;
            DEBUGLOG(6, "seq.start:%i, literals=%u, match.start:%i",
                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));
        }

_next_match:
        /* at this stage, the following variables must be correctly set :
         * - ip : at start of LZ operation
         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict
         * - offset : if maybe_ext_memSegment==1 (constant)
         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise
         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written
         */

        if ((outputDirective == fillOutput) &&
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
            /* the match was too close to the end, rewind and go to last literals */
            op = token;
            goto _last_literals;
        }

        /* Encode Offset */
        if (maybe_extMem) {   /* static test */
            DEBUGLOG(6, "             with offset=%u  (ext if > %i)", offset, (int)(ip - (const BYTE*)source));
            assert(offset <= LZ4_DISTANCE_MAX && offset > 0);
            LZ4_writeLE16(op, (U16)offset); op+=2;
        } else  {
            DEBUGLOG(6, "             with offset=%u  (same segment)", (U32)(ip - match));
            assert(ip-match <= LZ4_DISTANCE_MAX);
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
        }

        /* Encode MatchLength */
        {   unsigned matchCode;

            if ( (dictDirective==usingExtDict || dictDirective==usingDictCtx)
              && (lowLimit==dictionary) /* match within extDict */ ) {
                const BYTE* limit = ip + (dictEnd-match);
                assert(dictEnd > match);
                if (limit > matchlimit) limit = matchlimit;
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
                ip += (size_t)matchCode + MINMATCH;
                if (ip==limit) {
                    unsigned const more = LZ4_count(limit, (const BYTE*)source, matchlimit);
                    matchCode += more;
                    ip += more;
                }
                DEBUGLOG(6, "             with matchLength=%u starting in extDict", matchCode+MINMATCH);
            } else {
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
                ip += (size_t)matchCode + MINMATCH;
                DEBUGLOG(6, "             with matchLength=%u", matchCode+MINMATCH);
            }

            if ((outputDirective) &&    /* Check output buffer overflow */
                (unlikely(op + (1 + LASTLITERALS) + (matchCode>>8) > olimit)) ) {
                if (outputDirective == fillOutput) {
                    /* Match description too long : reduce it */
                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 2 - 1 - LASTLITERALS) * 255;
                    ip -= matchCode - newMatchCode;
                    matchCode = newMatchCode;
                } else {
                    assert(outputDirective == limitedOutput);
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
                }
            }
            if (matchCode >= ML_MASK) {
                *token += ML_MASK;
                matchCode -= ML_MASK;
                LZ4_write32(op, 0xFFFFFFFF);
                while (matchCode >= 4*255) {
                    op+=4;
                    LZ4_write32(op, 0xFFFFFFFF);
                    matchCode -= 4*255;
                }
                op += matchCode / 255;
                *op++ = (BYTE)(matchCode % 255);
            } else
                *token += (BYTE)(matchCode);
        }

        anchor = ip;

        /* Test end of chunk */
        if (ip >= mflimitPlusOne) break;

        /* Fill table */
        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);

        /* Test next position */
        if (tableType == byPtr) {

            match = LZ4_getPosition(ip, cctx->hashTable, tableType, base);
            LZ4_putPosition(ip, cctx->hashTable, tableType, base);
            if ( (match+LZ4_DISTANCE_MAX >= ip)
              && (LZ4_read32(match) == LZ4_read32(ip)) )
            { token=op++; *token=0; goto _next_match; }

        } else {   /* byU32, byU16 */

            U32 const h = LZ4_hashPosition(ip, tableType);
            U32 const current = (U32)(ip-base);
            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
            assert(matchIndex < current);
            if (dictDirective == usingDictCtx) {
                if (matchIndex < startIndex) {
                    /* there was no match, try the dictionary */
                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
                    match = dictBase + matchIndex;
                    lowLimit = dictionary;   /* required for match length counter */
                    matchIndex += dictDelta;
                } else {
                    match = base + matchIndex;
                    lowLimit = (const BYTE*)source;  /* required for match length counter */
                }
            } else if (dictDirective==usingExtDict) {
                if (matchIndex < startIndex) {
                    match = dictBase + matchIndex;
                    lowLimit = dictionary;   /* required for match length counter */
                } else {
                    match = base + matchIndex;
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
                }
            } else {   /* single memory segment */
                match = base + matchIndex;
            }
            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);
            assert(matchIndex < current);
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
              && ((tableType==byU16) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
              && (LZ4_read32(match) == LZ4_read32(ip)) ) {
                token=op++;
                *token=0;
                if (maybe_extMem) offset = current - matchIndex;
                DEBUGLOG(6, "seq.start:%i, literals=%u, match.start:%i",
                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));
                goto _next_match;
            }
        }

        /* Prepare next loop */
        forwardH = LZ4_hashPosition(++ip, tableType);

    }

_last_literals:
    /* Encode Last Literals */
    {   size_t lastRun = (size_t)(iend - anchor);
        if ( (outputDirective) &&  /* Check output buffer overflow */
            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
            if (outputDirective == fillOutput) {
                /* adapt lastRun to fill 'dst' */
                assert(olimit >= op);
                lastRun  = (size_t)(olimit-op) - 1;
                lastRun -= (lastRun+240)/255;
            } else {
                assert(outputDirective == limitedOutput);
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
            }
        }
        if (lastRun >= RUN_MASK) {
            size_t accumulator = lastRun - RUN_MASK;
            *op++ = RUN_MASK << ML_BITS;
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
            *op++ = (BYTE) accumulator;
        } else {
            *op++ = (BYTE)(lastRun<<ML_BITS);
        }
        memcpy(op, anchor, lastRun);
        ip = anchor + lastRun;
        op += lastRun;
    }

    if (outputDirective == fillOutput) {
        *inputConsumed = (int) (((const char*)ip)-source);
    }
    DEBUGLOG(5, "LZ4_compress_generic: compressed %i bytes into %i bytes", inputSize, (int)(((char*)op) - dest));
    result = (int)(((char*)op) - dest);
    assert(result > 0);
    return result;
}


int LZ4_compress_fast_extState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int acceleration)
{
    LZ4_stream_t_internal* const ctx = & LZ4_initStream(state, sizeof(LZ4_stream_t)) -> internal_donotuse;
    assert(ctx != NULL);
    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;
    if (maxOutputSize >= LZ4_compressBound(inputSize)) {
        if (inputSize < LZ4_64Klimit) {
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, 0, notLimited, byU16, noDict, noDictIssue, acceleration);
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);
        }
    } else {
        if (inputSize < LZ4_64Klimit) {;
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, byU16, noDict, noDictIssue, acceleration);
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)source > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            return LZ4_compress_generic(ctx, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, noDict, noDictIssue, acceleration);
        }
    }
}

/**
 * LZ4_compress_fast_extState_fastReset() :
 * A variant of LZ4_compress_fast_extState().
 *
 * Using this variant avoids an expensive initialization step. It is only safe
 * to call if the state buffer is known to be correctly initialized already
 * (see comment in lz4.h on LZ4_resetStream_fast() for a definition of
 * "correctly initialized").
 */
int LZ4_compress_fast_extState_fastReset(void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration)
{
    LZ4_stream_t_internal* ctx = &((LZ4_stream_t*)state)->internal_donotuse;
    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;

    if (dstCapacity >= LZ4_compressBound(srcSize)) {
        if (srcSize < LZ4_64Klimit) {
            const tableType_t tableType = byU16;
            LZ4_prepareTable(ctx, srcSize, tableType);
            if (ctx->currentOffset) {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, dictSmall, acceleration);
            } else {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);
            }
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            LZ4_prepareTable(ctx, srcSize, tableType);
            return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);
        }
    } else {
        if (srcSize < LZ4_64Klimit) {
            const tableType_t tableType = byU16;
            LZ4_prepareTable(ctx, srcSize, tableType);
            if (ctx->currentOffset) {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, dictSmall, acceleration);
            } else {
                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, noDictIssue, acceleration);
            }
        } else {
            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            LZ4_prepareTable(ctx, srcSize, tableType);
            return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, noDictIssue, acceleration);
        }
    }
}


int LZ4_compress_fast(const char* source, char* dest, int inputSize, int maxOutputSize, int acceleration)
{
    int result;
#if (LZ4_HEAPMODE)
    LZ4_stream_t* ctxPtr = ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */
    if (ctxPtr == NULL) return 0;
#else
    LZ4_stream_t ctx;
    LZ4_stream_t* const ctxPtr = &ctx;
#endif
    result = LZ4_compress_fast_extState(ctxPtr, source, dest, inputSize, maxOutputSize, acceleration);

#if (LZ4_HEAPMODE)
    FREEMEM(ctxPtr);
#endif
    return result;
}


int LZ4_compress_default(const char* src, char* dst, int srcSize, int maxOutputSize)
{
    return LZ4_compress_fast(src, dst, srcSize, maxOutputSize, 1);
}


/* hidden debug function */
/* strangely enough, gcc generates faster code when this function is uncommented, even if unused */
int LZ4_compress_fast_force(const char* src, char* dst, int srcSize, int dstCapacity, int acceleration)
{
    LZ4_stream_t ctx;
    LZ4_initStream(&ctx, sizeof(ctx));

    if (srcSize < LZ4_64Klimit) {
        return LZ4_compress_generic(&ctx.internal_donotuse, src, dst, srcSize, NULL, dstCapacity, limitedOutput, byU16,    noDict, noDictIssue, acceleration);
    } else {
        tableType_t const addrMode = (sizeof(void*) > 4) ? byU32 : byPtr;
        return LZ4_compress_generic(&ctx.internal_donotuse, src, dst, srcSize, NULL, dstCapacity, limitedOutput, addrMode, noDict, noDictIssue, acceleration);
    }
}


/* Note!: This function leaves the stream in an unclean/broken state!
 * It is not safe to subsequently use the same state with a _fastReset() or
 * _continue() call without resetting it. */
static int LZ4_compress_destSize_extState (LZ4_stream_t* state, const char* src, char* dst, int* srcSizePtr, int targetDstSize)
{
    void* const s = LZ4_initStream(state, sizeof (*state));
    assert(s != NULL); (void)s;

    if (targetDstSize >= LZ4_compressBound(*srcSizePtr)) {  /* compression success is guaranteed */
        return LZ4_compress_fast_extState(state, src, dst, *srcSizePtr, targetDstSize, 1);
    } else {
        if (*srcSizePtr < LZ4_64Klimit) {
            return LZ4_compress_generic(&state->internal_donotuse, src, dst, *srcSizePtr, srcSizePtr, targetDstSize, fillOutput, byU16, noDict, noDictIssue, 1);
        } else {
            tableType_t const addrMode = ((sizeof(void*)==4) && ((uptrval)src > LZ4_DISTANCE_MAX)) ? byPtr : byU32;
            return LZ4_compress_generic(&state->internal_donotuse, src, dst, *srcSizePtr, srcSizePtr, targetDstSize, fillOutput, addrMode, noDict, noDictIssue, 1);
    }   }
}


int LZ4_compress_destSize(const char* src, char* dst, int* srcSizePtr, int targetDstSize)
{
#if (LZ4_HEAPMODE)
    LZ4_stream_t* ctx = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */
    if (ctx == NULL) return 0;
#else
    LZ4_stream_t ctxBody;
    LZ4_stream_t* ctx = &ctxBody;
#endif

    int result = LZ4_compress_destSize_extState(ctx, src, dst, srcSizePtr, targetDstSize);

#if (LZ4_HEAPMODE)
    FREEMEM(ctx);
#endif
    return result;
}



/*-******************************
*  Streaming functions
********************************/

LZ4_stream_t* LZ4_createStream(void)
{
    LZ4_stream_t* const lz4s = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));
    LZ4_STATIC_ASSERT(LZ4_STREAMSIZE >= sizeof(LZ4_stream_t_internal));    /* A compilation error here means LZ4_STREAMSIZE is not large enough */
    DEBUGLOG(4, "LZ4_createStream %p", lz4s);
    if (lz4s == NULL) return NULL;
    LZ4_initStream(lz4s, sizeof(*lz4s));
    return lz4s;
}

#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
                     it reports an aligment of 8-bytes,
                     while actually aligning LZ4_stream_t on 4 bytes. */
static size_t LZ4_stream_t_alignment(void)
{
    struct { char c; LZ4_stream_t t; } t_a;
    return sizeof(t_a) - sizeof(t_a.t);
}
#endif

LZ4_stream_t* LZ4_initStream (void* buffer, size_t size)
{
    DEBUGLOG(5, "LZ4_initStream");
    if (buffer == NULL) return NULL;
    if (size < sizeof(LZ4_stream_t)) return NULL;
#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
                     it reports an aligment of 8-bytes,
                     while actually aligning LZ4_stream_t on 4 bytes. */
    if (((size_t)buffer) & (LZ4_stream_t_alignment() - 1)) return NULL;  /* alignment check */
#endif
    MEM_INIT(buffer, 0, sizeof(LZ4_stream_t));
    return (LZ4_stream_t*)buffer;
}

/* resetStream is now deprecated,
 * prefer initStream() which is more general */
void LZ4_resetStream (LZ4_stream_t* LZ4_stream)
{
    DEBUGLOG(5, "LZ4_resetStream (ctx:%p)", LZ4_stream);
    MEM_INIT(LZ4_stream, 0, sizeof(LZ4_stream_t));
}

void LZ4_resetStream_fast(LZ4_stream_t* ctx) {
    LZ4_prepareTable(&(ctx->internal_donotuse), 0, byU32);
}

int LZ4_freeStream (LZ4_stream_t* LZ4_stream)
{
    if (!LZ4_stream) return 0;   /* support free on NULL */
    DEBUGLOG(5, "LZ4_freeStream %p", LZ4_stream);
    FREEMEM(LZ4_stream);
    return (0);
}


#define HASH_UNIT sizeof(reg_t)
int LZ4_loadDict (LZ4_stream_t* LZ4_dict, const char* dictionary, int dictSize)
{
    LZ4_stream_t_internal* dict = &LZ4_dict->internal_donotuse;
    const tableType_t tableType = byU32;
    const BYTE* p = (const BYTE*)dictionary;
    const BYTE* const dictEnd = p + dictSize;
    const BYTE* base;

    DEBUGLOG(4, "LZ4_loadDict (%i bytes from %p into %p)", dictSize, dictionary, LZ4_dict);

    /* It's necessary to reset the context,
     * and not just continue it with prepareTable()
     * to avoid any risk of generating overflowing matchIndex
     * when compressing using this dictionary */
    LZ4_resetStream(LZ4_dict);

    /* We always increment the offset by 64 KB, since, if the dict is longer,
     * we truncate it to the last 64k, and if it's shorter, we still want to
     * advance by a whole window length so we can provide the guarantee that
     * there are only valid offsets in the window, which allows an optimization
     * in LZ4_compress_fast_continue() where it uses noDictIssue even when the
     * dictionary isn't a full 64k. */

    if ((dictEnd - p) > 64 KB) p = dictEnd - 64 KB;
    base = dictEnd - 64 KB - dict->currentOffset;
    dict->dictionary = p;
    dict->dictSize = (U32)(dictEnd - p);
    dict->currentOffset += 64 KB;
    dict->tableType = tableType;

    if (dictSize < (int)HASH_UNIT) {
        return 0;
    }

    while (p <= dictEnd-HASH_UNIT) {
        LZ4_putPosition(p, dict->hashTable, tableType, base);
        p+=3;
    }

    return (int)dict->dictSize;
}

void LZ4_attach_dictionary(LZ4_stream_t *working_stream, const LZ4_stream_t *dictionary_stream) {
    /* Calling LZ4_resetStream_fast() here makes sure that changes will not be
     * erased by subsequent calls to LZ4_resetStream_fast() in case stream was
     * marked as having dirty context, e.g. requiring full reset.
     */
    LZ4_resetStream_fast(working_stream);

    if (dictionary_stream != NULL) {
        /* If the current offset is zero, we will never look in the
         * external dictionary context, since there is no value a table
         * entry can take that indicate a miss. In that case, we need
         * to bump the offset to something non-zero.
         */
        if (working_stream->internal_donotuse.currentOffset == 0) {
            working_stream->internal_donotuse.currentOffset = 64 KB;
        }
        working_stream->internal_donotuse.dictCtx = &(dictionary_stream->internal_donotuse);
    } else {
        working_stream->internal_donotuse.dictCtx = NULL;
    }
}


static void LZ4_renormDictT(LZ4_stream_t_internal* LZ4_dict, int nextSize)
{
    assert(nextSize >= 0);
    if (LZ4_dict->currentOffset + (unsigned)nextSize > 0x80000000) {   /* potential ptrdiff_t overflow (32-bits mode) */
        /* rescale hash table */
        U32 const delta = LZ4_dict->currentOffset - 64 KB;
        const BYTE* dictEnd = LZ4_dict->dictionary + LZ4_dict->dictSize;
        int i;
        DEBUGLOG(4, "LZ4_renormDictT");
        for (i=0; i<LZ4_HASH_SIZE_U32; i++) {
            if (LZ4_dict->hashTable[i] < delta) LZ4_dict->hashTable[i]=0;
            else LZ4_dict->hashTable[i] -= delta;
        }
        LZ4_dict->currentOffset = 64 KB;
        if (LZ4_dict->dictSize > 64 KB) LZ4_dict->dictSize = 64 KB;
        LZ4_dict->dictionary = dictEnd - LZ4_dict->dictSize;
    }
}


int LZ4_compress_fast_continue (LZ4_stream_t* LZ4_stream,
                                const char* source, char* dest,
                                int inputSize, int maxOutputSize,
                                int acceleration)
{
    const tableType_t tableType = byU32;
    LZ4_stream_t_internal* streamPtr = &LZ4_stream->internal_donotuse;
    const BYTE* dictEnd = streamPtr->dictionary + streamPtr->dictSize;

    DEBUGLOG(5, "LZ4_compress_fast_continue (inputSize=%i)", inputSize);

    if (streamPtr->dirty) return 0;   /* Uninitialized structure detected */
    LZ4_renormDictT(streamPtr, inputSize);   /* avoid index overflow */
    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;

    /* invalidate tiny dictionaries */
    if ( (streamPtr->dictSize-1 < 4-1)   /* intentional underflow */
      && (dictEnd != (const BYTE*)source) ) {
        DEBUGLOG(5, "LZ4_compress_fast_continue: dictSize(%u) at addr:%p is too small", streamPtr->dictSize, streamPtr->dictionary);
        streamPtr->dictSize = 0;
        streamPtr->dictionary = (const BYTE*)source;
        dictEnd = (const BYTE*)source;
    }

    /* Check overlapping input/dictionary space */
    {   const BYTE* sourceEnd = (const BYTE*) source + inputSize;
        if ((sourceEnd > streamPtr->dictionary) && (sourceEnd < dictEnd)) {
            streamPtr->dictSize = (U32)(dictEnd - sourceEnd);
            if (streamPtr->dictSize > 64 KB) streamPtr->dictSize = 64 KB;
            if (streamPtr->dictSize < 4) streamPtr->dictSize = 0;
            streamPtr->dictionary = dictEnd - streamPtr->dictSize;
        }
    }

    /* prefix mode : source data follows dictionary */
    if (dictEnd == (const BYTE*)source) {
        if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset))
            return LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, withPrefix64k, dictSmall, acceleration);
        else
            return LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, withPrefix64k, noDictIssue, acceleration);
    }

    /* external dictionary mode */
    {   int result;
        if (streamPtr->dictCtx) {
            /* We depend here on the fact that dictCtx'es (produced by
             * LZ4_loadDict) guarantee that their tables contain no references
             * to offsets between dictCtx->currentOffset - 64 KB and
             * dictCtx->currentOffset - dictCtx->dictSize. This makes it safe
             * to use noDictIssue even when the dict isn't a full 64 KB.
             */
            if (inputSize > 4 KB) {
                /* For compressing large blobs, it is faster to pay the setup
                 * cost to copy the dictionary's tables into the active context,
                 * so that the compression loop is only looking into one table.
                 */
                memcpy(streamPtr, streamPtr->dictCtx, sizeof(LZ4_stream_t));
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, noDictIssue, acceleration);
            } else {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingDictCtx, noDictIssue, acceleration);
            }
        } else {
            if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, dictSmall, acceleration);
            } else {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, noDictIssue, acceleration);
            }
        }
        streamPtr->dictionary = (const BYTE*)source;
        streamPtr->dictSize = (U32)inputSize;
        return result;
    }
}


/* Hidden debug function, to force-test external dictionary mode */
int LZ4_compress_forceExtDict (LZ4_stream_t* LZ4_dict, const char* source, char* dest, int srcSize)
{
    LZ4_stream_t_internal* streamPtr = &LZ4_dict->internal_donotuse;
    int result;

    LZ4_renormDictT(streamPtr, srcSize);

    if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
        result = LZ4_compress_generic(streamPtr, source, dest, srcSize, NULL, 0, notLimited, byU32, usingExtDict, dictSmall, 1);
    } else {
        result = LZ4_compress_generic(streamPtr, source, dest, srcSize, NULL, 0, notLimited, byU32, usingExtDict, noDictIssue, 1);
    }

    streamPtr->dictionary = (const BYTE*)source;
    streamPtr->dictSize = (U32)srcSize;

    return result;
}


/*! LZ4_saveDict() :
 *  If previously compressed data block is not guaranteed to remain available at its memory location,
 *  save it into a safer place (char* safeBuffer).
 *  Note : you don't need to call LZ4_loadDict() afterwards,
 *         dictionary is immediately usable, you can therefore call LZ4_compress_fast_continue().
 *  Return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error.
 */
int LZ4_saveDict (LZ4_stream_t* LZ4_dict, char* safeBuffer, int dictSize)
{
    LZ4_stream_t_internal* const dict = &LZ4_dict->internal_donotuse;
    const BYTE* const previousDictEnd = dict->dictionary + dict->dictSize;

    if ((U32)dictSize > 64 KB) dictSize = 64 KB;   /* useless to define a dictionary > 64 KB */
    if ((U32)dictSize > dict->dictSize) dictSize = (int)dict->dictSize;

    memmove(safeBuffer, previousDictEnd - dictSize, dictSize);

    dict->dictionary = (const BYTE*)safeBuffer;
    dict->dictSize = (U32)dictSize;

    return dictSize;
}



/*-*******************************
 *  Decompression functions
 ********************************/

typedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive;
typedef enum { decode_full_block = 0, partial_decode = 1 } earlyEnd_directive;

#undef MIN
#define MIN(a,b)    ( (a) < (b) ? (a) : (b) )

/* Read the variable-length literal or match length.
 *
 * ip - pointer to use as input.
 * lencheck - end ip.  Return an error if ip advances >= lencheck.
 * loop_check - check ip >= lencheck in body of loop.  Returns loop_error if so.
 * initial_check - check ip >= lencheck before start of loop.  Returns initial_error if so.
 * error (output) - error code.  Should be set to 0 before call.
 */
typedef enum { loop_error = -2, initial_error = -1, ok = 0 } variable_length_error;
LZ4_FORCE_INLINE unsigned
read_variable_length(const BYTE**ip, const BYTE* lencheck, int loop_check, int initial_check, variable_length_error* error)
{
  unsigned length = 0;
  unsigned s;
  if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
    *error = initial_error;
    return length;
  }
  do {
    s = **ip;
    (*ip)++;
    length += s;
    if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
      *error = loop_error;
      return length;
    }
  } while (s==255);

  return length;
}

/*! LZ4_decompress_generic() :
 *  This generic decompression function covers all use cases.
 *  It shall be instantiated several times, using different sets of directives.
 *  Note that it is important for performance that this function really get inlined,
 *  in order to remove useless branches during compilation optimization.
 */
LZ4_FORCE_INLINE int
LZ4_decompress_generic(
                 const char* const src,
                 char* const dst,
                 int srcSize,
                 int outputSize,         /* If endOnInput==endOnInputSize, this value is `dstCapacity` */

                 endCondition_directive endOnInput,   /* endOnOutputSize, endOnInputSize */
                 earlyEnd_directive partialDecoding,  /* full, partial */
                 dict_directive dict,                 /* noDict, withPrefix64k, usingExtDict */
                 const BYTE* const lowPrefix,  /* always <= dst, == dst when no prefix */
                 const BYTE* const dictStart,  /* only if dict==usingExtDict */
                 const size_t dictSize         /* note : = 0 if noDict */
                 )
{
    if (src == NULL) return -1;

    {   const BYTE* ip = (const BYTE*) src;
        const BYTE* const iend = ip + srcSize;

        BYTE* op = (BYTE*) dst;
        BYTE* const oend = op + outputSize;
        BYTE* cpy;

        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;

        const int safeDecode = (endOnInput==endOnInputSize);
        const int checkOffset = ((safeDecode) && (dictSize < (int)(64 KB)));


        /* Set up the "end" pointers for the shortcut. */
        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;

        const BYTE* match;
        size_t offset;
        unsigned token;
        size_t length;


        DEBUGLOG(5, "LZ4_decompress_generic (srcSize:%i, dstSize:%i)", srcSize, outputSize);

        /* Special cases */
        assert(lowPrefix <= op);
        if ((endOnInput) && (unlikely(outputSize==0))) return ((srcSize==1) && (*ip==0)) ? 0 : -1;  /* Empty output buffer */
        if ((!endOnInput) && (unlikely(outputSize==0))) return (*ip==0 ? 1 : -1);
        if ((endOnInput) && unlikely(srcSize==0)) return -1;

	/* Currently the fast loop shows a regression on qualcomm arm chips. */
#if LZ4_FAST_DEC_LOOP
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
            DEBUGLOG(6, "skip fast decode loop");
            goto safe_decode;
        }

        /* Fast loop : decode sequences as long as output < iend-FASTLOOP_SAFE_DISTANCE */
        while (1) {
            /* Main fastloop assertion: We can always wildcopy FASTLOOP_SAFE_DISTANCE */
            assert(oend - op >= FASTLOOP_SAFE_DISTANCE);
            if (endOnInput) assert(ip < iend);
            token = *ip++;
            length = token >> ML_BITS;  /* literal length */

            assert(!endOnInput || ip <= iend); /* ip < iend before the increment */

            /* decode literal length */
            if (length == RUN_MASK) {
                variable_length_error error = ok;
                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
                if (error == initial_error) goto _output_error;
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) goto _output_error;   /* overflow detection */
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) goto _output_error;   /* overflow detection */

                /* copy literals */
                cpy = op+length;
                LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
                if (endOnInput) {  /* LZ4_decompress_safe() */
                    if ((cpy>oend-32) || (ip+length>iend-32)) goto safe_literal_copy;
                    LZ4_wildCopy32(op, ip, cpy);
                } else {   /* LZ4_decompress_fast() */
                    if (cpy>oend-8) goto safe_literal_copy;
                    LZ4_wildCopy8(op, ip, cpy); /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
                                                 * it doesn't know input length, and only relies on end-of-block properties */
                }
                ip += length; op = cpy;
            } else {
                cpy = op+length;
                if (endOnInput) {  /* LZ4_decompress_safe() */
                    DEBUGLOG(7, "copy %u bytes in a 16-bytes stripe", (unsigned)length);
                    /* We don't need to check oend, since we check it once for each loop below */
                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) goto safe_literal_copy;
                    /* Literals can only be 14, but hope compilers optimize if we copy by a register size */
                    memcpy(op, ip, 16);
                } else {  /* LZ4_decompress_fast() */
                    /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
                     * it doesn't know input length, and relies on end-of-block properties */
                    memcpy(op, ip, 8);
                    if (length > 8) memcpy(op+8, ip+8, 8);
                }
                ip += length; op = cpy;
            }

            /* get offset */
            offset = LZ4_readLE16(ip); ip+=2;
            match = op - offset;

            /* get matchlength */
            length = token & ML_MASK;

            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */

            if (length == ML_MASK) {
              variable_length_error error = ok;
              length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
              if (error != ok) goto _output_error;
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
                length += MINMATCH;
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
                    goto safe_match_copy;
                }
            } else {
                length += MINMATCH;
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
                    goto safe_match_copy;
                }

                /* Fastpath check: Avoids a branch in LZ4_wildCopy32 if true */
                if (!(dict == usingExtDict) || (match >= lowPrefix)) {
                    if (offset >= 8) {
                        memcpy(op, match, 8);
                        memcpy(op+8, match+8, 8);
                        memcpy(op+16, match+16, 2);
                        op += length;
                        continue;
            }   }   }

            /* match starting within external dictionary */
            if ((dict==usingExtDict) && (match < lowPrefix)) {
                if (unlikely(op+length > oend-LASTLITERALS)) {
                    if (partialDecoding) length = MIN(length, (size_t)(oend-op));
                    else goto _output_error;   /* doesn't respect parsing restriction */
                }

                if (length <= (size_t)(lowPrefix-match)) {
                    /* match fits entirely within external dictionary : just copy */
                    memmove(op, dictEnd - (lowPrefix-match), length);
                    op += length;
                } else {
                    /* match stretches into both external dictionary and current block */
                    size_t const copySize = (size_t)(lowPrefix - match);
                    size_t const restSize = length - copySize;
                    memcpy(op, dictEnd - copySize, copySize);
                    op += copySize;
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
                        BYTE* const endOfMatch = op + restSize;
                        const BYTE* copyFrom = lowPrefix;
                        while (op < endOfMatch) *op++ = *copyFrom++;
                    } else {
                        memcpy(op, lowPrefix, restSize);
                        op += restSize;
                }   }
                continue;
            }

            /* copy match within block */
            cpy = op + length;

            assert((op <= oend) && (oend-op >= 32));
            if (unlikely(offset<16)) {
                LZ4_memcpy_using_offset(op, match, cpy, offset);
            } else {
                LZ4_wildCopy32(op, match, cpy);
            }

            op = cpy;   /* wildcopy correction */
        }
    safe_decode:
#endif

        /* Main Loop : decode remaining sequences where output < FASTLOOP_SAFE_DISTANCE */
        while (1) {
            token = *ip++;
            length = token >> ML_BITS;  /* literal length */

            assert(!endOnInput || ip <= iend); /* ip < iend before the increment */

            /* A two-stage shortcut for the most common case:
             * 1) If the literal length is 0..14, and there is enough space,
             * enter the shortcut and copy 16 bytes on behalf of the literals
             * (in the fast mode, only 8 bytes can be safely copied this way).
             * 2) Further if the match length is 4..18, copy 18 bytes in a similar
             * manner; but we ensure that there's enough space in the output for
             * those 18 bytes earlier, upon entering the shortcut (in other words,
             * there is a combined check for both stages).
             */
            if ( (endOnInput ? length != RUN_MASK : length <= 8)
                /* strictly "less than" on input, to re-enter the loop with at least one byte */
              && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
                /* Copy the literals */
                memcpy(op, ip, endOnInput ? 16 : 8);
                op += length; ip += length;

                /* The second stage: prepare for match copying, decode full info.
                 * If it doesn't work out, the info won't be wasted. */
                length = token & ML_MASK; /* match length */
                offset = LZ4_readLE16(ip); ip += 2;
                match = op - offset;
                assert(match <= op); /* check overflow */

                /* Do not deal with overlapping matches. */
                if ( (length != ML_MASK)
                  && (offset >= 8)
                  && (dict==withPrefix64k || match >= lowPrefix) ) {
                    /* Copy the match. */
                    memcpy(op + 0, match + 0, 8);
                    memcpy(op + 8, match + 8, 8);
                    memcpy(op +16, match +16, 2);
                    op += length + MINMATCH;
                    /* Both stages worked, load the next token. */
                    continue;
                }

                /* The second stage didn't work out, but the info is ready.
                 * Propel it right to the point of match copying. */
                goto _copy_match;
            }

            /* decode literal length */
            if (length == RUN_MASK) {
              variable_length_error error = ok;
              length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
              if (error == initial_error) goto _output_error;
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) goto _output_error;   /* overflow detection */
                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) goto _output_error;   /* overflow detection */
            }

            /* copy literals */
            cpy = op+length;
#if LZ4_FAST_DEC_LOOP
        safe_literal_copy:
#endif
            LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
              || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
            {
                if (partialDecoding) {
                    if (cpy > oend) { cpy = oend; assert(op<=oend); length = (size_t)(oend-op); }  /* Partial decoding : stop in the middle of literal segment */
                    if ((endOnInput) && (ip+length > iend)) goto _output_error;   /* Error : read attempt beyond end of input buffer */
                } else {
                    if ((!endOnInput) && (cpy != oend)) goto _output_error;       /* Error : block decoding must stop exactly there */
                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) goto _output_error;   /* Error : input must be consumed */
                }
                memcpy(op, ip, length);
                ip += length;
                op += length;
                if (!partialDecoding || (cpy == oend)) {
                    /* Necessarily EOF, due to parsing restrictions */
                    break;
                }

            } else {
                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
                ip += length; op = cpy;
            }

            /* get offset */
            offset = LZ4_readLE16(ip); ip+=2;
            match = op - offset;

            /* get matchlength */
            length = token & ML_MASK;

    _copy_match:
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
            if (!partialDecoding) {
                assert(oend > op);
                assert(oend - op >= 4);
                LZ4_write32(op, 0);   /* silence an msan warning when offset==0; costs <1%; */
            }   /* note : when partialDecoding, there is no guarantee that at least 4 bytes remain available in output buffer */

            if (length == ML_MASK) {
              variable_length_error error = ok;
              length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
              if (error != ok) goto _output_error;
                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
            }
            length += MINMATCH;

#if LZ4_FAST_DEC_LOOP
        safe_match_copy:
#endif
            /* match starting within external dictionary */
            if ((dict==usingExtDict) && (match < lowPrefix)) {
                if (unlikely(op+length > oend-LASTLITERALS)) {
                    if (partialDecoding) length = MIN(length, (size_t)(oend-op));
                    else goto _output_error;   /* doesn't respect parsing restriction */
                }

                if (length <= (size_t)(lowPrefix-match)) {
                    /* match fits entirely within external dictionary : just copy */
                    memmove(op, dictEnd - (lowPrefix-match), length);
                    op += length;
                } else {
                    /* match stretches into both external dictionary and current block */
                    size_t const copySize = (size_t)(lowPrefix - match);
                    size_t const restSize = length - copySize;
                    memcpy(op, dictEnd - copySize, copySize);
                    op += copySize;
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
                        BYTE* const endOfMatch = op + restSize;
                        const BYTE* copyFrom = lowPrefix;
                        while (op < endOfMatch) *op++ = *copyFrom++;
                    } else {
                        memcpy(op, lowPrefix, restSize);
                        op += restSize;
                }   }
                continue;
            }

            /* copy match within block */
            cpy = op + length;

            /* partialDecoding : may end anywhere within the block */
            assert(op<=oend);
            if (partialDecoding && (cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
                size_t const mlen = MIN(length, (size_t)(oend-op));
                const BYTE* const matchEnd = match + mlen;
                BYTE* const copyEnd = op + mlen;
                if (matchEnd > op) {   /* overlap copy */
                    while (op < copyEnd) *op++ = *match++;
                } else {
                    memcpy(op, match, mlen);
                }
                op = copyEnd;
                if (op==oend) break;
                continue;
            }

            if (unlikely(offset<8)) {
                op[0] = match[0];
                op[1] = match[1];
                op[2] = match[2];
                op[3] = match[3];
                match += inc32table[offset];
                memcpy(op+4, match, 4);
                match -= dec64table[offset];
            } else {
                memcpy(op, match, 8);
                match += 8;
            }
            op += 8;

            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
                if (cpy > oend-LASTLITERALS) goto _output_error;    /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
                if (op < oCopyLimit) {
                    LZ4_wildCopy8(op, match, oCopyLimit);
                    match += oCopyLimit - op;
                    op = oCopyLimit;
                }
                while (op < cpy) *op++ = *match++;
            } else {
                memcpy(op, match, 8);
                if (length > 16) LZ4_wildCopy8(op+8, match+8, cpy);
            }
            op = cpy;   /* wildcopy correction */
        }

        /* end of decoding */
        if (endOnInput)
           return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
        else
           return (int) (((const char*)ip)-src);   /* Nb of input bytes read */

        /* Overflow error detected */
    _output_error:
        return (int) (-(((const char*)ip)-src))-1;
    }
}


/*===== Instantiate the API decoding functions. =====*/

LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
                                  endOnInputSize, decode_full_block, noDict,
                                  (BYTE*)dest, NULL, 0);
}

LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_safe_partial(const char* src, char* dst, int compressedSize, int targetOutputSize, int dstCapacity)
{
    dstCapacity = MIN(targetOutputSize, dstCapacity);
    return LZ4_decompress_generic(src, dst, compressedSize, dstCapacity,
                                  endOnInputSize, partial_decode,
                                  noDict, (BYTE*)dst, NULL, 0);
}

LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_fast(const char* source, char* dest, int originalSize)
{
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, withPrefix64k,
                                  (BYTE*)dest - 64 KB, NULL, 0);
}

/*===== Instantiate a few more decoding cases, used more than once. =====*/

LZ4_FORCE_O2_GCC_PPC64LE /* Exported, an obsolete API function. */
int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int compressedSize, int maxOutputSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, withPrefix64k,
                                  (BYTE*)dest - 64 KB, NULL, 0);
}

/* Another obsolete API function, paired with the previous one. */
int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int originalSize)
{
    /* LZ4_decompress_fast doesn't validate match offsets,
     * and thus serves well with any prefixed dictionary. */
    return LZ4_decompress_fast(source, dest, originalSize);
}

LZ4_FORCE_O2_GCC_PPC64LE
static int LZ4_decompress_safe_withSmallPrefix(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                               size_t prefixSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, noDict,
                                  (BYTE*)dest-prefixSize, NULL, 0);
}

LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
                                     int compressedSize, int maxOutputSize,
                                     const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest, (const BYTE*)dictStart, dictSize);
}

LZ4_FORCE_O2_GCC_PPC64LE
static int LZ4_decompress_fast_extDict(const char* source, char* dest, int originalSize,
                                       const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest, (const BYTE*)dictStart, dictSize);
}

/* The "double dictionary" mode, for use with e.g. ring buffers: the first part
 * of the dictionary is passed as prefix, and the second via dictStart + dictSize.
 * These routines are used only once, in LZ4_decompress_*_continue().
 */
LZ4_FORCE_INLINE
int LZ4_decompress_safe_doubleDict(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                   size_t prefixSize, const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  endOnInputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
}

LZ4_FORCE_INLINE
int LZ4_decompress_fast_doubleDict(const char* source, char* dest, int originalSize,
                                   size_t prefixSize, const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, 0, originalSize,
                                  endOnOutputSize, decode_full_block, usingExtDict,
                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
}

/*===== streaming decompression functions =====*/

LZ4_streamDecode_t* LZ4_createStreamDecode(void)
{
    LZ4_streamDecode_t* lz4s = (LZ4_streamDecode_t*) ALLOC_AND_ZERO(sizeof(LZ4_streamDecode_t));
    LZ4_STATIC_ASSERT(LZ4_STREAMDECODESIZE >= sizeof(LZ4_streamDecode_t_internal));    /* A compilation error here means LZ4_STREAMDECODESIZE is not large enough */
    return lz4s;
}

int LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream)
{
    if (LZ4_stream == NULL) return 0;   /* support free on NULL */
    FREEMEM(LZ4_stream);
    return 0;
}

/*! LZ4_setStreamDecode() :
 *  Use this function to instruct where to find the dictionary.
 *  This function is not necessary if previous data is still available where it was decoded.
 *  Loading a size of 0 is allowed (same effect as no dictionary).
 * @return : 1 if OK, 0 if error
 */
int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    lz4sd->prefixSize = (size_t) dictSize;
    lz4sd->prefixEnd = (const BYTE*) dictionary + dictSize;
    lz4sd->externalDict = NULL;
    lz4sd->extDictSize  = 0;
    return 1;
}

/*! LZ4_decoderRingBufferSize() :
 *  when setting a ring buffer for streaming decompression (optional scenario),
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 *  Note : in a ring buffer scenario,
 *  blocks are presumed decompressed next to each other.
 *  When not enough space remains for next block (remainingSize < maxBlockSize),
 *  decoding resumes from beginning of ring buffer.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 */
int LZ4_decoderRingBufferSize(int maxBlockSize)
{
    if (maxBlockSize < 0) return 0;
    if (maxBlockSize > LZ4_MAX_INPUT_SIZE) return 0;
    if (maxBlockSize < 16) maxBlockSize = 16;
    return LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize);
}

/*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ4_setStreamDecode()
*/
LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxOutputSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;

    if (lz4sd->prefixSize == 0) {
        /* The first call, no dictionary yet. */
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd = (BYTE*)dest + result;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
        /* They're rolling the current segment. */
        if (lz4sd->prefixSize >= 64 KB - 1)
            result = LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
        else if (lz4sd->extDictSize == 0)
            result = LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize,
                                                         lz4sd->prefixSize);
        else
            result = LZ4_decompress_safe_doubleDict(source, dest, compressedSize, maxOutputSize,
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)result;
        lz4sd->prefixEnd  += result;
    } else {
        /* The buffer wraps around, or they're switching to another buffer. */
        lz4sd->extDictSize = lz4sd->prefixSize;
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
        result = LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize,
                                                  lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd  = (BYTE*)dest + result;
    }

    return result;
}

LZ4_FORCE_O2_GCC_PPC64LE
int LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int originalSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;
    assert(originalSize >= 0);

    if (lz4sd->prefixSize == 0) {
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_fast(source, dest, originalSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)originalSize;
        lz4sd->prefixEnd = (BYTE*)dest + originalSize;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
        if (lz4sd->prefixSize >= 64 KB - 1 || lz4sd->extDictSize == 0)
            result = LZ4_decompress_fast(source, dest, originalSize);
        else
            result = LZ4_decompress_fast_doubleDict(source, dest, originalSize,
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)originalSize;
        lz4sd->prefixEnd  += originalSize;
    } else {
        lz4sd->extDictSize = lz4sd->prefixSize;
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
        result = LZ4_decompress_fast_extDict(source, dest, originalSize,
                                             lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)originalSize;
        lz4sd->prefixEnd  = (BYTE*)dest + originalSize;
    }

    return result;
}


/*
Advanced decoding functions :
*_usingDict() :
    These decoding functions work the same as "_continue" ones,
    the dictionary must be explicitly provided within parameters
*/

int LZ4_decompress_safe_usingDict(const char* source, char* dest, int compressedSize, int maxOutputSize, const char* dictStart, int dictSize)
{
    if (dictSize==0)
        return LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
    if (dictStart+dictSize == dest) {
        if (dictSize >= 64 KB - 1)
            return LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
        return LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize, dictSize);
    }
    return LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize, dictStart, dictSize);
}

int LZ4_decompress_fast_usingDict(const char* source, char* dest, int originalSize, const char* dictStart, int dictSize)
{
    if (dictSize==0 || dictStart+dictSize == dest)
        return LZ4_decompress_fast(source, dest, originalSize);
    return LZ4_decompress_fast_extDict(source, dest, originalSize, dictStart, dictSize);
}


/*=*************************************************
*  Obsolete Functions
***************************************************/
/* obsolete compression functions */
int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize)
{
    return LZ4_compress_default(source, dest, inputSize, maxOutputSize);
}
int LZ4_compress(const char* source, char* dest, int inputSize)
{
    return LZ4_compress_default(source, dest, inputSize, LZ4_compressBound(inputSize));
}
int LZ4_compress_limitedOutput_withState (void* state, const char* src, char* dst, int srcSize, int dstSize)
{
    return LZ4_compress_fast_extState(state, src, dst, srcSize, dstSize, 1);
}
int LZ4_compress_withState (void* state, const char* src, char* dst, int srcSize)
{
    return LZ4_compress_fast_extState(state, src, dst, srcSize, LZ4_compressBound(srcSize), 1);
}
int LZ4_compress_limitedOutput_continue (LZ4_stream_t* LZ4_stream, const char* src, char* dst, int srcSize, int dstCapacity)
{
    return LZ4_compress_fast_continue(LZ4_stream, src, dst, srcSize, dstCapacity, 1);
}
int LZ4_compress_continue (LZ4_stream_t* LZ4_stream, const char* source, char* dest, int inputSize)
{
    return LZ4_compress_fast_continue(LZ4_stream, source, dest, inputSize, LZ4_compressBound(inputSize), 1);
}

/*
These decompression functions are deprecated and should no longer be used.
They are only provided here for compatibility with older user programs.
- LZ4_uncompress is totally equivalent to LZ4_decompress_fast
- LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
*/
int LZ4_uncompress (const char* source, char* dest, int outputSize)
{
    return LZ4_decompress_fast(source, dest, outputSize);
}
int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize)
{
    return LZ4_decompress_safe(source, dest, isize, maxOutputSize);
}

/* Obsolete Streaming functions */

int LZ4_sizeofStreamState() { return LZ4_STREAMSIZE; }

int LZ4_resetStreamState(void* state, char* inputBuffer)
{
    (void)inputBuffer;
    LZ4_resetStream((LZ4_stream_t*)state);
    return 0;
}

void* LZ4_create (char* inputBuffer)
{
    (void)inputBuffer;
    return LZ4_createStream();
}

char* LZ4_slideInputBuffer (void* state)
{
    /* avoid const char * -> char * conversion warning */
    return (char *)(uptrval)((LZ4_stream_t*)state)->internal_donotuse.dictionary;
}

#endif   /* LZ4_COMMONDEFS_ONLY */

```

`3rd/lz4-r191/lz4.h`:

```h
/*
 *  LZ4 - Fast LZ compression algorithm
 *  Header File
 *  Copyright (C) 2011-present, Yann Collet.

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
    - LZ4 homepage : http://www.lz4.org
    - LZ4 source repository : https://github.com/lz4/lz4
*/
#if defined (__cplusplus)
extern "C" {
#endif

#ifndef LZ4_H_2983827168210
#define LZ4_H_2983827168210

/* --- Dependency --- */
#include <stddef.h>   /* size_t */


/**
  Introduction

  LZ4 is lossless compression algorithm, providing compression speed at 500 MB/s per core,
  scalable with multi-cores CPU. It features an extremely fast decoder, with speed in
  multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.

  The LZ4 compression library provides in-memory compression and decompression functions.
  It gives full buffer control to user.
  Compression can be done in:
    - a single step (described as Simple Functions)
    - a single step, reusing a context (described in Advanced Functions)
    - unbounded multiple steps (described as Streaming compression)

  lz4.h generates and decodes LZ4-compressed blocks (doc/lz4_Block_format.md).
  Decompressing a block requires additional metadata, such as its compressed size.
  Each application is free to encode and pass such metadata in whichever way it wants.

  lz4.h only handle blocks, it can not generate Frames.

  Blocks are different from Frames (doc/lz4_Frame_format.md).
  Frames bundle both blocks and metadata in a specified manner.
  This are required for compressed data to be self-contained and portable.
  Frame format is delivered through a companion API, declared in lz4frame.h.
  Note that the `lz4` CLI can only manage frames.
*/

/*^***************************************************************
*  Export parameters
*****************************************************************/
/*
*  LZ4_DLL_EXPORT :
*  Enable exporting of functions when building a Windows DLL
*  LZ4LIB_VISIBILITY :
*  Control library symbols visibility.
*/
#ifndef LZ4LIB_VISIBILITY
#  if defined(__GNUC__) && (__GNUC__ >= 4)
#    define LZ4LIB_VISIBILITY __attribute__ ((visibility ("default")))
#  else
#    define LZ4LIB_VISIBILITY
#  endif
#endif
#if defined(LZ4_DLL_EXPORT) && (LZ4_DLL_EXPORT==1)
#  define LZ4LIB_API __declspec(dllexport) LZ4LIB_VISIBILITY
#elif defined(LZ4_DLL_IMPORT) && (LZ4_DLL_IMPORT==1)
#  define LZ4LIB_API __declspec(dllimport) LZ4LIB_VISIBILITY /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
#else
#  define LZ4LIB_API LZ4LIB_VISIBILITY
#endif

/*------   Version   ------*/
#define LZ4_VERSION_MAJOR    1    /* for breaking interface changes  */
#define LZ4_VERSION_MINOR    9    /* for new (non-breaking) interface capabilities */
#define LZ4_VERSION_RELEASE  1    /* for tweaks, bug-fixes, or development */

#define LZ4_VERSION_NUMBER (LZ4_VERSION_MAJOR *100*100 + LZ4_VERSION_MINOR *100 + LZ4_VERSION_RELEASE)

#define LZ4_LIB_VERSION LZ4_VERSION_MAJOR.LZ4_VERSION_MINOR.LZ4_VERSION_RELEASE
#define LZ4_QUOTE(str) #str
#define LZ4_EXPAND_AND_QUOTE(str) LZ4_QUOTE(str)
#define LZ4_VERSION_STRING LZ4_EXPAND_AND_QUOTE(LZ4_LIB_VERSION)

LZ4LIB_API int LZ4_versionNumber (void);  /**< library version number; useful to check dll version */
LZ4LIB_API const char* LZ4_versionString (void);   /**< library version string; useful to check dll version */


/*-************************************
*  Tuning parameter
**************************************/
/*!
 * LZ4_MEMORY_USAGE :
 * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
 * Increasing memory usage improves compression ratio.
 * Reduced memory usage may improve speed, thanks to better cache locality.
 * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache
 */
#ifndef LZ4_MEMORY_USAGE
# define LZ4_MEMORY_USAGE 14
#endif


/*-************************************
*  Simple Functions
**************************************/
/*! LZ4_compress_default() :
    Compresses 'srcSize' bytes from buffer 'src'
    into already allocated 'dst' buffer of size 'dstCapacity'.
    Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).
    It also runs faster, so it's a recommended setting.
    If the function cannot compress 'src' into a more limited 'dst' budget,
    compression stops *immediately*, and the function result is zero.
    In which case, 'dst' content is undefined (invalid).
        srcSize : max supported value is LZ4_MAX_INPUT_SIZE.
        dstCapacity : size of buffer 'dst' (which must be already allocated)
       @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)
                  or 0 if compression fails
    Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer).
*/
LZ4LIB_API int LZ4_compress_default(const char* src, char* dst, int srcSize, int dstCapacity);

/*! LZ4_decompress_safe() :
    compressedSize : is the exact complete size of the compressed block.
    dstCapacity : is the size of destination buffer, which must be already allocated.
   @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)
             If destination buffer is not large enough, decoding will stop and output an error code (negative value).
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
    Note : This function is protected against malicious data packets (never writes outside 'dst' buffer, nor read outside 'source' buffer).
*/
LZ4LIB_API int LZ4_decompress_safe (const char* src, char* dst, int compressedSize, int dstCapacity);


/*-************************************
*  Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned)(isize) > (unsigned)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*! LZ4_compressBound() :
    Provides the maximum size that LZ4 compression may output in a "worst case" scenario (input data not compressible)
    This function is primarily useful for memory allocation purposes (destination buffer size).
    Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
    Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)
        inputSize  : max supported value is LZ4_MAX_INPUT_SIZE
        return : maximum output size in a "worst case" scenario
              or 0, if input size is incorrect (too large or negative)
*/
LZ4LIB_API int LZ4_compressBound(int inputSize);

/*! LZ4_compress_fast() :
    Same as LZ4_compress_default(), but allows selection of "acceleration" factor.
    The larger the acceleration value, the faster the algorithm, but also the lesser the compression.
    It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.
    An acceleration value of "1" is the same as regular LZ4_compress_default()
    Values <= 0 will be replaced by ACCELERATION_DEFAULT (currently == 1, see lz4.c).
*/
LZ4LIB_API int LZ4_compress_fast (const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);


/*! LZ4_compress_fast_extState() :
 *  Same as LZ4_compress_fast(), using an externally allocated memory space for its state.
 *  Use LZ4_sizeofState() to know how much memory must be allocated,
 *  and allocate it on 8-bytes boundaries (using `malloc()` typically).
 *  Then, provide this buffer as `void* state` to compression function.
 */
LZ4LIB_API int LZ4_sizeofState(void);
LZ4LIB_API int LZ4_compress_fast_extState (void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);


/*! LZ4_compress_destSize() :
 *  Reverse the logic : compresses as much data as possible from 'src' buffer
 *  into already allocated buffer 'dst', of size >= 'targetDestSize'.
 *  This function either compresses the entire 'src' content into 'dst' if it's large enough,
 *  or fill 'dst' buffer completely with as much data as possible from 'src'.
 *  note: acceleration parameter is fixed to "default".
 *
 * *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.
 *               New value is necessarily <= input value.
 * @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)
 *           or 0 if compression fails.
*/
LZ4LIB_API int LZ4_compress_destSize (const char* src, char* dst, int* srcSizePtr, int targetDstSize);


/*! LZ4_decompress_safe_partial() :
 *  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',
 *  into destination buffer 'dst' of size 'dstCapacity'.
 *  Up to 'targetOutputSize' bytes will be decoded.
 *  The function stops decoding on reaching this objective,
 *  which can boost performance when only the beginning of a block is required.
 *
 * @return : the number of bytes decoded in `dst` (necessarily <= dstCapacity)
 *           If source stream is detected malformed, function returns a negative result.
 *
 *  Note : @return can be < targetOutputSize, if compressed block contains less data.
 *
 *  Note 2 : this function features 2 parameters, targetOutputSize and dstCapacity,
 *           and expects targetOutputSize <= dstCapacity.
 *           It effectively stops decoding on reaching targetOutputSize,
 *           so dstCapacity is kind of redundant.
 *           This is because in a previous version of this function,
 *           decoding operation would not "break" a sequence in the middle.
 *           As a consequence, there was no guarantee that decoding would stop at exactly targetOutputSize,
 *           it could write more bytes, though only up to dstCapacity.
 *           Some "margin" used to be required for this operation to work properly.
 *           This is no longer necessary.
 *           The function nonetheless keeps its signature, in an effort to not break API.
 */
LZ4LIB_API int LZ4_decompress_safe_partial (const char* src, char* dst, int srcSize, int targetOutputSize, int dstCapacity);


/*-*********************************************
*  Streaming Compression Functions
***********************************************/
typedef union LZ4_stream_u LZ4_stream_t;  /* incomplete type (defined later) */

LZ4LIB_API LZ4_stream_t* LZ4_createStream(void);
LZ4LIB_API int           LZ4_freeStream (LZ4_stream_t* streamPtr);

/*! LZ4_resetStream_fast() : v1.9.0+
 *  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks
 *  (e.g., LZ4_compress_fast_continue()).
 *
 *  An LZ4_stream_t must be initialized once before usage.
 *  This is automatically done when created by LZ4_createStream().
 *  However, should the LZ4_stream_t be simply declared on stack (for example),
 *  it's necessary to initialize it first, using LZ4_initStream().
 *
 *  After init, start any new stream with LZ4_resetStream_fast().
 *  A same LZ4_stream_t can be re-used multiple times consecutively
 *  and compress multiple streams,
 *  provided that it starts each new stream with LZ4_resetStream_fast().
 *
 *  LZ4_resetStream_fast() is much faster than LZ4_initStream(),
 *  but is not compatible with memory regions containing garbage data.
 *
 *  Note: it's only useful to call LZ4_resetStream_fast()
 *        in the context of streaming compression.
 *        The *extState* functions perform their own resets.
 *        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive.
 */
LZ4LIB_API void LZ4_resetStream_fast (LZ4_stream_t* streamPtr);

/*! LZ4_loadDict() :
 *  Use this function to reference a static dictionary into LZ4_stream_t.
 *  The dictionary must remain available during compression.
 *  LZ4_loadDict() triggers a reset, so any previous data will be forgotten.
 *  The same dictionary will have to be loaded on decompression side for successful decoding.
 *  Dictionary are useful for better compression of small data (KB range).
 *  While LZ4 accept any input as dictionary,
 *  results are generally better when using Zstandard's Dictionary Builder.
 *  Loading a size of 0 is allowed, and is the same as reset.
 * @return : loaded dictionary size, in bytes (necessarily <= 64 KB)
 */
LZ4LIB_API int LZ4_loadDict (LZ4_stream_t* streamPtr, const char* dictionary, int dictSize);

/*! LZ4_compress_fast_continue() :
 *  Compress 'src' content using data from previously compressed blocks, for better compression ratio.
 * 'dst' buffer must be already allocated.
 *  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.
 *
 * @return : size of compressed block
 *           or 0 if there is an error (typically, cannot fit into 'dst').
 *
 *  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.
 *           Each block has precise boundaries.
 *           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.
 *           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.
 *
 *  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !
 *
 *  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.
 *           Make sure that buffers are separated, by at least one byte.
 *           This construction ensures that each block only depends on previous block.
 *
 *  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.
 *
 *  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed.
 */
LZ4LIB_API int LZ4_compress_fast_continue (LZ4_stream_t* streamPtr, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);

/*! LZ4_saveDict() :
 *  If last 64KB data cannot be guaranteed to remain available at its current memory location,
 *  save it into a safer place (char* safeBuffer).
 *  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),
 *  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.
 * @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error.
 */
LZ4LIB_API int LZ4_saveDict (LZ4_stream_t* streamPtr, char* safeBuffer, int maxDictSize);


/*-**********************************************
*  Streaming Decompression Functions
*  Bufferless synchronous API
************************************************/
typedef union LZ4_streamDecode_u LZ4_streamDecode_t;   /* tracking context */

/*! LZ4_createStreamDecode() and LZ4_freeStreamDecode() :
 *  creation / destruction of streaming decompression tracking context.
 *  A tracking context can be re-used multiple times.
 */
LZ4LIB_API LZ4_streamDecode_t* LZ4_createStreamDecode(void);
LZ4LIB_API int                 LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream);

/*! LZ4_setStreamDecode() :
 *  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.
 *  Use this function to start decompression of a new stream of blocks.
 *  A dictionary can optionally be set. Use NULL or size 0 for a reset order.
 *  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.
 * @return : 1 if OK, 0 if error
 */
LZ4LIB_API int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize);

/*! LZ4_decoderRingBufferSize() : v1.8.2+
 *  Note : in a ring buffer scenario (optional),
 *  blocks are presumed decompressed next to each other
 *  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),
 *  at which stage it resumes from beginning of ring buffer.
 *  When setting such a ring buffer for streaming decompression,
 *  provides the minimum size of this ring buffer
 *  to be compatible with any source respecting maxBlockSize condition.
 * @return : minimum ring buffer size,
 *           or 0 if there is an error (invalid maxBlockSize).
 */
LZ4LIB_API int LZ4_decoderRingBufferSize(int maxBlockSize);
#define LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize) (65536 + 14 + (maxBlockSize))  /* for static allocation; maxBlockSize presumed valid */

/*! LZ4_decompress_*_continue() :
 *  These decoding functions allow decompression of consecutive blocks in "streaming" mode.
 *  A block is an unsplittable entity, it must be presented entirely to a decompression function.
 *  Decompression functions only accepts one block at a time.
 *  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded.
 *  If less than 64KB of data has been decoded, all the data must be present.
 *
 *  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :
 *  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).
 *    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.
 *    In which case, encoding and decoding buffers do not need to be synchronized.
 *    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.
 *  - Synchronized mode :
 *    Decompression buffer size is _exactly_ the same as compression buffer size,
 *    and follows exactly same update rule (block boundaries at same positions),
 *    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),
 *    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).
 *  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.
 *    In which case, encoding and decoding buffers do not need to be synchronized,
 *    and encoding ring buffer can have any size, including small ones ( < 64 KB).
 *
 *  Whenever these conditions are not possible,
 *  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,
 *  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block.
*/
LZ4LIB_API int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* src, char* dst, int srcSize, int dstCapacity);


/*! LZ4_decompress_*_usingDict() :
 *  These decoding functions work the same as
 *  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()
 *  They are stand-alone, and don't need an LZ4_streamDecode_t structure.
 *  Dictionary is presumed stable : it must remain accessible and unmodified during decompression.
 *  Performance tip : Decompression speed can be substantially increased
 *                    when dst == dictStart + dictSize.
 */
LZ4LIB_API int LZ4_decompress_safe_usingDict (const char* src, char* dst, int srcSize, int dstCapcity, const char* dictStart, int dictSize);


/*^*************************************
 * !!!!!!   STATIC LINKING ONLY   !!!!!!
 ***************************************/

/*-****************************************************************************
 * Experimental section
 *
 * Symbols declared in this section must be considered unstable. Their
 * signatures or semantics may change, or they may be removed altogether in the
 * future. They are therefore only safe to depend on when the caller is
 * statically linked against the library.
 *
 * To protect against unsafe usage, not only are the declarations guarded,
 * the definitions are hidden by default
 * when building LZ4 as a shared/dynamic library.
 *
 * In order to access these declarations,
 * define LZ4_STATIC_LINKING_ONLY in your application
 * before including LZ4's headers.
 *
 * In order to make their implementations accessible dynamically, you must
 * define LZ4_PUBLISH_STATIC_FUNCTIONS when building the LZ4 library.
 ******************************************************************************/

#ifdef LZ4_PUBLISH_STATIC_FUNCTIONS
#define LZ4LIB_STATIC_API LZ4LIB_API
#else
#define LZ4LIB_STATIC_API
#endif

#ifdef LZ4_STATIC_LINKING_ONLY


/*! LZ4_compress_fast_extState_fastReset() :
 *  A variant of LZ4_compress_fast_extState().
 *
 *  Using this variant avoids an expensive initialization step.
 *  It is only safe to call if the state buffer is known to be correctly initialized already
 *  (see above comment on LZ4_resetStream_fast() for a definition of "correctly initialized").
 *  From a high level, the difference is that
 *  this function initializes the provided state with a call to something like LZ4_resetStream_fast()
 *  while LZ4_compress_fast_extState() starts with a call to LZ4_resetStream().
 */
LZ4LIB_STATIC_API int LZ4_compress_fast_extState_fastReset (void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);

/*! LZ4_attach_dictionary() :
 *  This is an experimental API that allows
 *  efficient use of a static dictionary many times.
 *
 *  Rather than re-loading the dictionary buffer into a working context before
 *  each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a
 *  working LZ4_stream_t, this function introduces a no-copy setup mechanism,
 *  in which the working stream references the dictionary stream in-place.
 *
 *  Several assumptions are made about the state of the dictionary stream.
 *  Currently, only streams which have been prepared by LZ4_loadDict() should
 *  be expected to work.
 *
 *  Alternatively, the provided dictionaryStream may be NULL,
 *  in which case any existing dictionary stream is unset.
 *
 *  If a dictionary is provided, it replaces any pre-existing stream history.
 *  The dictionary contents are the only history that can be referenced and
 *  logically immediately precede the data compressed in the first subsequent
 *  compression call.
 *
 *  The dictionary will only remain attached to the working stream through the
 *  first compression call, at the end of which it is cleared. The dictionary
 *  stream (and source buffer) must remain in-place / accessible / unchanged
 *  through the completion of the first compression call on the stream.
 */
LZ4LIB_STATIC_API void LZ4_attach_dictionary(LZ4_stream_t* workingStream, const LZ4_stream_t* dictionaryStream);

#endif


/*-************************************************************
 *  PRIVATE DEFINITIONS
 **************************************************************
 * Do not use these definitions directly.
 * They are only exposed to allow static allocation of `LZ4_stream_t` and `LZ4_streamDecode_t`.
 * Accessing members will expose code to API and/or ABI break in future versions of the library.
 **************************************************************/
#define LZ4_HASHLOG   (LZ4_MEMORY_USAGE-2)
#define LZ4_HASHTABLESIZE (1 << LZ4_MEMORY_USAGE)
#define LZ4_HASH_SIZE_U32 (1 << LZ4_HASHLOG)       /* required as macro for static allocation */

#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
#include <stdint.h>

typedef struct LZ4_stream_t_internal LZ4_stream_t_internal;
struct LZ4_stream_t_internal {
    uint32_t hashTable[LZ4_HASH_SIZE_U32];
    uint32_t currentOffset;
    uint16_t dirty;
    uint16_t tableType;
    const uint8_t* dictionary;
    const LZ4_stream_t_internal* dictCtx;
    uint32_t dictSize;
};

typedef struct {
    const uint8_t* externalDict;
    size_t extDictSize;
    const uint8_t* prefixEnd;
    size_t prefixSize;
} LZ4_streamDecode_t_internal;

#else

typedef struct LZ4_stream_t_internal LZ4_stream_t_internal;
struct LZ4_stream_t_internal {
    unsigned int hashTable[LZ4_HASH_SIZE_U32];
    unsigned int currentOffset;
    unsigned short dirty;
    unsigned short tableType;
    const unsigned char* dictionary;
    const LZ4_stream_t_internal* dictCtx;
    unsigned int dictSize;
};

typedef struct {
    const unsigned char* externalDict;
    const unsigned char* prefixEnd;
    size_t extDictSize;
    size_t prefixSize;
} LZ4_streamDecode_t_internal;

#endif

/*! LZ4_stream_t :
 *  information structure to track an LZ4 stream.
 *  LZ4_stream_t can also be created using LZ4_createStream(), which is recommended.
 *  The structure definition can be convenient for static allocation
 *  (on stack, or as part of larger structure).
 *  Init this structure with LZ4_initStream() before first use.
 *  note : only use this definition in association with static linking !
 *    this definition is not API/ABI safe, and may change in a future version.
 */
#define LZ4_STREAMSIZE_U64 ((1 << (LZ4_MEMORY_USAGE-3)) + 4 + ((sizeof(void*)==16) ? 4 : 0) /*AS-400*/ )
#define LZ4_STREAMSIZE     (LZ4_STREAMSIZE_U64 * sizeof(unsigned long long))
union LZ4_stream_u {
    unsigned long long table[LZ4_STREAMSIZE_U64];
    LZ4_stream_t_internal internal_donotuse;
} ;  /* previously typedef'd to LZ4_stream_t */

/*! LZ4_initStream() : v1.9.0+
 *  An LZ4_stream_t structure must be initialized at least once.
 *  This is automatically done when invoking LZ4_createStream(),
 *  but it's not when the structure is simply declared on stack (for example).
 *
 *  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t.
 *  It can also initialize any arbitrary buffer of sufficient size,
 *  and will @return a pointer of proper type upon initialization.
 *
 *  Note : initialization fails if size and alignment conditions are not respected.
 *         In which case, the function will @return NULL.
 *  Note2: An LZ4_stream_t structure guarantees correct alignment and size.
 *  Note3: Before v1.9.0, use LZ4_resetStream() instead
 */
LZ4LIB_API LZ4_stream_t* LZ4_initStream (void* buffer, size_t size);


/*! LZ4_streamDecode_t :
 *  information structure to track an LZ4 stream during decompression.
 *  init this structure  using LZ4_setStreamDecode() before first use.
 *  note : only use in association with static linking !
 *         this definition is not API/ABI safe,
 *         and may change in a future version !
 */
#define LZ4_STREAMDECODESIZE_U64 (4 + ((sizeof(void*)==16) ? 2 : 0) /*AS-400*/ )
#define LZ4_STREAMDECODESIZE     (LZ4_STREAMDECODESIZE_U64 * sizeof(unsigned long long))
union LZ4_streamDecode_u {
    unsigned long long table[LZ4_STREAMDECODESIZE_U64];
    LZ4_streamDecode_t_internal internal_donotuse;
} ;   /* previously typedef'd to LZ4_streamDecode_t */


/*-************************************
*  Obsolete Functions
**************************************/

/*! Deprecation warnings
 *
 *  Deprecated functions make the compiler generate a warning when invoked.
 *  This is meant to invite users to update their source code.
 *  Should deprecation warnings be a problem, it is generally possible to disable them,
 *  typically with -Wno-deprecated-declarations for gcc
 *  or _CRT_SECURE_NO_WARNINGS in Visual.
 *
 *  Another method is to define LZ4_DISABLE_DEPRECATE_WARNINGS
 *  before including the header file.
 */
#if 1 /*def LZ4_DISABLE_DEPRECATE_WARNINGS*/
#  define LZ4_DEPRECATED(message)   /* disable deprecation warnings */
#else
#  define LZ4_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
#  if defined (__cplusplus) && (__cplusplus >= 201402) /* C++14 or greater */
#    define LZ4_DEPRECATED(message) [[deprecated(message)]]
#  elif (LZ4_GCC_VERSION >= 405) || defined(__clang__)
#    define LZ4_DEPRECATED(message) __attribute__((deprecated(message)))
#  elif (LZ4_GCC_VERSION >= 301)
#    define LZ4_DEPRECATED(message) __attribute__((deprecated))
#  elif defined(_MSC_VER)
#    define LZ4_DEPRECATED(message) __declspec(deprecated(message))
#  else
#    pragma message("WARNING: You need to implement LZ4_DEPRECATED for this compiler")
#    define LZ4_DEPRECATED(message)
#  endif
#endif /* LZ4_DISABLE_DEPRECATE_WARNINGS */

/* Obsolete compression functions */
LZ4_DEPRECATED("use LZ4_compress_default() instead")       LZ4LIB_API int LZ4_compress               (const char* source, char* dest, int sourceSize);
LZ4_DEPRECATED("use LZ4_compress_default() instead")       LZ4LIB_API int LZ4_compress_limitedOutput (const char* source, char* dest, int sourceSize, int maxOutputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_extState() instead") LZ4LIB_API int LZ4_compress_withState               (void* state, const char* source, char* dest, int inputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_extState() instead") LZ4LIB_API int LZ4_compress_limitedOutput_withState (void* state, const char* source, char* dest, int inputSize, int maxOutputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_continue() instead") LZ4LIB_API int LZ4_compress_continue                (LZ4_stream_t* LZ4_streamPtr, const char* source, char* dest, int inputSize);
LZ4_DEPRECATED("use LZ4_compress_fast_continue() instead") LZ4LIB_API int LZ4_compress_limitedOutput_continue  (LZ4_stream_t* LZ4_streamPtr, const char* source, char* dest, int inputSize, int maxOutputSize);

/* Obsolete decompression functions */
LZ4_DEPRECATED("use LZ4_decompress_fast() instead") LZ4LIB_API int LZ4_uncompress (const char* source, char* dest, int outputSize);
LZ4_DEPRECATED("use LZ4_decompress_safe() instead") LZ4LIB_API int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize);

/* Obsolete streaming functions; degraded functionality; do not use!
 *
 * In order to perform streaming compression, these functions depended on data
 * that is no longer tracked in the state. They have been preserved as well as
 * possible: using them will still produce a correct output. However, they don't
 * actually retain any history between compression calls. The compression ratio
 * achieved will therefore be no better than compressing each chunk
 * independently.
 */
LZ4_DEPRECATED("Use LZ4_createStream() instead") LZ4LIB_API void* LZ4_create (char* inputBuffer);
LZ4_DEPRECATED("Use LZ4_createStream() instead") LZ4LIB_API int   LZ4_sizeofStreamState(void);
LZ4_DEPRECATED("Use LZ4_resetStream() instead")  LZ4LIB_API int   LZ4_resetStreamState(void* state, char* inputBuffer);
LZ4_DEPRECATED("Use LZ4_saveDict() instead")     LZ4LIB_API char* LZ4_slideInputBuffer (void* state);

/* Obsolete streaming decoding functions */
LZ4_DEPRECATED("use LZ4_decompress_safe_usingDict() instead") LZ4LIB_API int LZ4_decompress_safe_withPrefix64k (const char* src, char* dst, int compressedSize, int maxDstSize);
LZ4_DEPRECATED("use LZ4_decompress_fast_usingDict() instead") LZ4LIB_API int LZ4_decompress_fast_withPrefix64k (const char* src, char* dst, int originalSize);

/*! LZ4_decompress_fast() : **unsafe!**
 *  These functions used to be faster than LZ4_decompress_safe(),
 *  but it has changed, and they are now slower than LZ4_decompress_safe().
 *  This is because LZ4_decompress_fast() doesn't know the input size,
 *  and therefore must progress more cautiously in the input buffer to not read beyond the end of block.
 *  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.
 *  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.
 *
 *  The last remaining LZ4_decompress_fast() specificity is that
 *  it can decompress a block without knowing its compressed size.
 *  Such functionality could be achieved in a more secure manner,
 *  by also providing the maximum size of input buffer,
 *  but it would require new prototypes, and adaptation of the implementation to this new use case.
 *
 *  Parameters:
 *  originalSize : is the uncompressed size to regenerate.
 *                 `dst` must be already allocated, its size must be >= 'originalSize' bytes.
 * @return : number of bytes read from source buffer (== compressed size).
 *           The function expects to finish at block's end exactly.
 *           If the source stream is detected malformed, the function stops decoding and returns a negative result.
 *  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.
 *         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.
 *         Also, since match offsets are not validated, match reads from 'src' may underflow too.
 *         These issues never happen if input (compressed) data is correct.
 *         But they may happen if input data is invalid (error or intentional tampering).
 *         As a consequence, use these functions in trusted environments with trusted data **only**.
 */

LZ4_DEPRECATED("This function is deprecated and unsafe. Consider using LZ4_decompress_safe() instead")
LZ4LIB_API int LZ4_decompress_fast (const char* src, char* dst, int originalSize);
LZ4_DEPRECATED("This function is deprecated and unsafe. Consider using LZ4_decompress_safe_continue() instead")
LZ4LIB_API int LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* src, char* dst, int originalSize);
LZ4_DEPRECATED("This function is deprecated and unsafe. Consider using LZ4_decompress_safe_usingDict() instead")
LZ4LIB_API int LZ4_decompress_fast_usingDict (const char* src, char* dst, int originalSize, const char* dictStart, int dictSize);

/*! LZ4_resetStream() :
 *  An LZ4_stream_t structure must be initialized at least once.
 *  This is done with LZ4_initStream(), or LZ4_resetStream().
 *  Consider switching to LZ4_initStream(),
 *  invoking LZ4_resetStream() will trigger deprecation warnings in the future.
 */
LZ4LIB_API void LZ4_resetStream (LZ4_stream_t* streamPtr);


#endif /* LZ4_H_2983827168210 */


#if defined (__cplusplus)
}
#endif

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2025 by Milos Tosic
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
<img height="81" src="https://rudji.com/img/lib/rprof.svg"/>

[![Build status](https://ci.appveyor.com/api/projects/status/0498ey79muxvrh9t?svg=true)](https://ci.appveyor.com/project/milostosic/rprof-fbbqv)
[![License](https://img.shields.io/badge/license-BSD--2%20clause-blue.svg)](https://github.com/RudjiGames/rprof/blob/master/LICENSE)

About
======

**rprof** is a scope based CPU profiling library with [ImGui](https://github.com/ocornut/imgui) visulization and browser profile inspector. The core concept is a time threshold, which can be used to easily catch functions or entire frames that exceed certain time value. By doing this, optimization work can focus initially on frames and functions that are only occasionally slow and iteratively progress towards more consistent performance.

Profiler always runs when used, but will display only those frames that exceed given threshold. Default value of 0 means to display every frame. Level value refers to hierachical scope depth where value of 0 represents an entire frame.

![In game screenshot](https://github.com/RudjiGames/rprof/blob/master/img/rprof_vis.jpg) 

Source Code
======

You can get the latest source code by cloning it from github:

      git clone https://github.com/RudjiGames/rprof.git 

Build
======

[GENie](https://github.com/bkaradzic/GENie) script can generate Microsoft Visual Studio solution or makefiles for a GCC based compiler or cross compiler. Generating a MSVC
solution, for example, is done using the following command:

      genie vs2022

The generated solution will be located in the following folder:
   .build/projects/vs2022

Generating makefiles for a GCC based toolchain is done in a similar way, for
example:

      OSX   :   genie --gcc=oxc gmake
      PS4   :   genie --gcc=ps4 gmake

Generated makefiles will be located in the following folder:

      .build/projects/gmake/$(GCC_TOOLCHAIN)

All of the generated solutions/makefiles provide a Debug, Release and Retail configurations,
in both 32bit and 64bit versions. Some platforms support only one word size, for 
example OSX works with 64 bit builds only.

To build a GCC based library use the following command lines:

      Debug, 32bit   :  make -R config=debug32
      Release, 64bit :  make -R config=release64

For convenience, there are batch files in 'scripts' directory that can be used to fetch dependencies (for the demo) and generate project files.

Browser inspector
======

Captured frame profiles can be saved to binary files for offline inspection.
The browser based inspector is built using Emscripten. Makefile is included for convenience.
Browser inspector is based on [ImGui](https://github.com/ocornut/imgui) and is interacive provinding zooming and panning as well as statistical overview of the frame.  

Viewer is browser based in order to be able to use it as a part of QA pipeline during development process.  

[**Live demo**](https://rudji.com/rprof/rprof.html?path=https://rudji.com/rprof/&file=capture.rprofm)

![Inspector screenshot](https://github.com/milostosic/rprof/blob/master/img/rprof_browser.gif) 


License (BSD 2-clause)
======

<a href="http://opensource.org/licenses/BSD-2-Clause" target="_blank">
<img align="right" src="https://opensource.org/wp-content/uploads/2022/10/osi-badge-dark.svg" width="100" height="137">
</a>

	Copyright 2025 Milos Tosic. All rights reserved.
	
	https://github.com/RudjiGames/rprof
	
	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	
	   1. Redistributions of source code must retain the above copyright notice,
	      this list of conditions and the following disclaimer.
	
	   2. Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS OR
	IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
	EVENT SHALL COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

```

`genie/genie.lua`:

```lua
--
-- Copyright 2025 Milos Tosic. All rights reserved.
-- License: http://www.opensource.org/licenses/BSD-2-Clause
--

local currPath = path.getdirectory(debug.getinfo(2, "S").source:sub(2)) .. "/.."
while string.len(currPath) > 2 do 
	currPath = path.getabsolute(currPath .. "/..")
	if os.isfile(currPath .. "/build/build.lua") then dofile (currPath .. "/build/build.lua") break end
end

solution "rprof"
	setPlatforms()

	addLibProjects("rprof")

```

`genie/rprof.lua`:

```lua
--
-- Copyright 2025 Milos Tosic. All rights reserved.
-- License: http://www.opensource.org/licenses/BSD-2-Clause
--

function projectAdd_rprof() 
	addProject_lib("rprof")
end


```

`inc/rprof.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 *
 * rprof - profiling library
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE
 */

#ifndef RPROF_RPROF_H
#define RPROF_RPROF_H

#include <stdint.h> /* uint*_t */
#include <stddef.h> /* size_t  */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*--------------------------------------------------------------------------
 * Structures describing profiling data
 *------------------------------------------------------------------------*/

typedef struct ProfilerScopeStats
{
	uint64_t			m_inclusiveTime;
	uint64_t			m_exclusiveTime;
	uint64_t			m_inclusiveTimeTotal;
	uint64_t			m_exclusiveTimeTotal;
	uint32_t			m_occurences;

} ProfilerScopeStats;

typedef struct ProfilerScope
{
	uint64_t			m_start;
	uint64_t			m_end;
	uint64_t			m_threadID;
	const char*			m_name;
	const char*			m_file;
	uint32_t			m_line;
	uint32_t			m_level;
	ProfilerScopeStats*	m_stats;

} ProfilerScope;

typedef struct ProfilerThread
{
	uint64_t			m_threadID;
	const char*			m_name;

} ProfilerThread;

typedef struct ProfilerFrame
{
	uint32_t			m_numScopes;
	uint32_t			m_numThreads;
	uint32_t			m_platformID;
	float				m_timeThreshold;
	ProfilerScope*		m_scopes;
	ProfilerThread*		m_threads;
	uint64_t			m_startTime;
	uint64_t			m_endtime;
	uint64_t			m_prevFrameTime;
	uint64_t			m_CPUFrequency;
	uint32_t			m_levelThreshold;
	uint32_t			m_numScopesStats;
	ProfilerScope*		m_scopesStats;
	ProfilerScopeStats*	m_scopeStatsInfo;

} ProfilerFrame;

/*--------------------------------------------------------------------------
 * API
 *------------------------------------------------------------------------*/

	/* Initialize profiling library. */
	void rprofInit();

	/* Shut down profiling library and release all resources. */
	void rprofShutDown();

	/* Sets the minimum time (in ms) to trigger a capture call back. */
	/* @param[in] _ms    - time in ms to use as minimum, if set to 0 (defauult) then every frame triggers a call back */
	/* @param[in] _level - scope depth in which to look for scopes longer than _ms threshold, 0 is for entire frame. */
	void rprofSetThreshold(float _ms, int _level = 0);

	/* Registers thread name. */
	/* @param[in] _name     - name to use for this thread */
	/* @param[in] _threadID - ID of thread to register, 0 for current thread. */
	void rprofRegisterThread(const char* _name, uint64_t _threadID = 0);

	/* Unregisters thread name and releases name string. */
	/* @param[in] _threadID - thread ID */
	void rprofUnregisterThread(uint64_t _threadID);

	/* Must be called once per frame at the frame start */
	void rprofBeginFrame();

	/* Begins a profiling scope/block. */
	/* @param[in] _file - name of source file */
	/* @param[in] _line - line of source file */
	/* @param[in] _name - name of the scope */
	/* @returns scope handle */
	uintptr_t rprofBeginScope(const char* _file, int _line, const char* _name);

	/* Stops a profiling scope/block. */
	/* @param[in] _scopeHandle	- handle of the scope to be closed */
	void rprofEndScope(uintptr_t _scopeHandle);

	/* Returns non zero value if profiling is paused. */
	int rprofIsPaused();

	/* Returns non zero value if the last captured frame has crossed threshold. */
	int rprofWasThresholdCrossed();

	/* Pauses profiling if the value passed is 0, otherwise resumes profiling. */
	/* @param[in] _paused    	- 0 for pause, any other value to resume */
	void rprofSetPaused(int _paused);

	/* Fetches data of the last saved frame (either threshold exceeded or profiling is paused). */
	/* @param[out] _data    	- Pointer to frame data structure */
	void rprofGetFrame(ProfilerFrame* _data);

	/* Saves profiler data to a binary buffer. */
	/* @param[in] _data       - profiler data / single frame capture */
	/* @param[in,out] _buffer - buffer to store data to */
	/* @param[in] _bufferSize - maximum size of buffer, in bytes */
	/* @returns number of bytes written to buffer. 0 for failure. */
	int rprofSave(ProfilerFrame* _data, void* _buffer, size_t _bufferSize);

	/* Loads a single frame capture from a binary buffer. */
	/* @param[in] _data       - [in/out] profiler data / single frame capture. User is responsible to release memory using rprofRelease. */
	/* @param[in,out] _buffer - buffer to store data to */
	/* @param[in] _bufferSize - maximum size of buffer, in bytes */
	void rprofLoad(ProfilerFrame* _data, void* _buffer, size_t _bufferSize);

	/* Loads a only time in miliseconds for a single frame capture from a binary buffer. */
	/* @param[in] _time       - [in/out] frame timne in ms. */
	/* @param[in,out] _buffer - buffer to store data to */
	/* @param[in] _bufferSize - maximum size of buffer, in bytes */
	void rprofLoadTimeOnly(float* _time, void* _buffer, size_t _bufferSize);

	/* Releases resources for a single frame capture. Only valid for data loaded with rprofLoad. */
	/* @param[in] _data       - data to be released */
	void rprofRelease(ProfilerFrame* _data);
	
	/* Returns CPU clock. */
	/* @returns CPU clock counter. */
	uint64_t rprofGetClock();

	/* Returns CPU frequency. */
	/* @returns CPU frequency. */
	uint64_t rprofGetClockFrequency();

	/* Calculates miliseconds from CPU clock. */
	/* @param[in] _clock       - data to be released */
	/* @param[in] _frequency   - data to be released */
	/* @returns time in milliseconds. */
	float rprofClock2ms(uint64_t _clock, uint64_t _frequency);

	/* Returns name of the platform. */
	/* @param[in] _platformID - platform identifier */
	/* @returns platform name as string. */
	const char* rprofGetPlatformName(uint8_t _platformID);

#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#ifdef __cplusplus

struct rprofScoped
{
	uintptr_t	m_scope;

	rprofScoped(const char* _file, int _line, const char* _name)
	{
		m_scope = rprofBeginScope(_file, _line, _name);
	}

	~rprofScoped()
	{
		rprofEndScope(m_scope);
	}
};

/*--------------------------------------------------------------------------
 * Macro used to profile on a scope basis
 *------------------------------------------------------------------------*/
#ifndef RPROF_DISABLE_PROFILING

#define RPROF_CONCAT2(_x, _y) _x ## _y
#define RPROF_CONCAT(_x, _y) RPROF_CONCAT2(_x, _y)

#define RPROF_INIT()				rprofInit()
#define RPROF_SCOPE(x, ...)			rprofScoped RPROF_CONCAT(profileScope,__LINE__)(__FILE__, __LINE__, x)
#define RPROF_BEGIN_FRAME()			rprofBeginFrame()
#define RPROF_REGISTER_THREAD(n)	rprofRegisterThread(n)
#define RPROF_SHUTDOWN()			rprofShutDown()
#else
#define RPROF_INIT()				void()
#define RPROF_SCOPE(...)			void()
#define RPROF_BEGIN_FRAME()			void()
#define RPROF_REGISTER_THREAD(n)	void()
#define RPROF_SHUTDOWN()			void()
#endif /* RPROF_DISABLE_PROFILING */

#endif /* __cplusplus */

#endif /* RPROF_RPROF_H */

```

`inc/rprof_imgui.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_DRAW_H
#define RPROF_DRAW_H

#include "rprof.h"
#include <algorithm>
#include <inttypes.h>
#include <rapp/3rd/imgui/imgui.h>

	#define RPROF_DESIRED_FRAME_RATE	 30.0f
	#define RPROF_MINIMUM_FRAME_RATE	 20.0f
	#define RPROF_FLASHL_TIME_IN_MS		333.0f

	static const int	s_maxLevelColors = 11;
	static const ImU32	s_levelColors[s_maxLevelColors] = {
		IM_COL32( 90, 150, 110, 255),	IM_COL32( 80, 180, 115, 255),
		IM_COL32(129, 195, 110, 255),	IM_COL32(170, 190, 100, 255),
		IM_COL32(210, 200,  80, 255),	IM_COL32(230, 210, 115, 255),
		IM_COL32(240, 180,  90, 255),	IM_COL32(240, 140,  65, 255),
		IM_COL32(250, 110,  40, 255),	IM_COL32(250,  75,  25, 255),
		IM_COL32(250,  50,   0, 255)
	};

	static uint64_t		s_timeSinceStatClicked	= rprofGetClock();
	static const char*	s_statClickedName		= 0;
	static uint32_t		s_statClickedLevel		= 0;

	struct PanAndZoon
	{
		float	m_offset;
		float	m_startPan;
		float	m_zoom;

		PanAndZoon()
		{
			m_offset	= 0.0f;
			m_startPan	= 0.0f;
			m_zoom		= 1.0f;
		}

		inline float w2s(float wld, float minX, float maxX) {
			return minX + wld * (maxX - minX) * m_zoom - m_offset;
		}
		inline float w2sdelta(float wld, float minX, float maxX) {
			return wld * (maxX - minX) * m_zoom;
		}
		inline float s2w(float scr, float minX, float maxX) {
			return (scr + m_offset - minX) / ((maxX - minX) * m_zoom);
		}
	};

	template <typename T>
	static inline T rprofMax(T _v1, T _v2) { return _v1 > _v2 ? _v1 : _v2; }
	template <typename T>
	static inline T rprofMin(T _v1, T _v2) { return _v1 < _v2 ? _v1 : _v2; }

	static inline void flashColor(ImU32& _drawColor, uint64_t _elapsedTime)
	{
		ImVec4 white4 = ImColor(IM_COL32_WHITE);

		float msSince = rprofClock2ms(_elapsedTime, rprofGetClockFrequency());
		msSince = rprofMin(msSince, RPROF_FLASHL_TIME_IN_MS);
		msSince = 1.0f - (msSince / RPROF_FLASHL_TIME_IN_MS);

		ImVec4 col4 = ImColor(_drawColor);
		_drawColor = ImColor(	col4.x + (white4.x - col4.x) * msSince,
								col4.y + (white4.y - col4.y) * msSince,
								col4.z + (white4.z - col4.z) * msSince,
								255.0f);
	}

	static inline void flashColorNamed(ImU32& _drawColor, ProfilerScope& _cs, uint64_t _elapsedTime)
	{
		if (s_statClickedName && (strcmp(_cs.m_name, s_statClickedName) == 0) && (_cs.m_level == s_statClickedLevel))
			flashColor(_drawColor, _elapsedTime);
	}

	static inline ImVec4 triColor(float _cmp, float _min1, float _min2)
	{
		ImVec4 col = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
		if (_cmp > _min1) col = ImVec4(1.0f, 1.0f, 0.0f, 1.0f);
		if (_cmp > _min2) col = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
		return col;
	}

	struct SortScopes
	{
		bool operator()(const ProfilerScope& a, const ProfilerScope& b) const
		{
			if (a.m_threadID < b.m_threadID) return true;
			if (b.m_threadID < a.m_threadID) return false;

			if (a.m_level < b.m_level) return true;
			if (b.m_level < a.m_level) return false;

			if (a.m_start < b.m_start) return true;
			if (b.m_start < a.m_start) return false;

			return false;
		}
	};

	/* Draws a frame capture inspector dialog using ImGui. */
	/* _data       - [in/out] profiler data / single frame capture. User is responsible to release memory using rprofRelease */
	/* _buffer     - buffer to store data to */
	/* _bufferSize - maximum size of buffer, in bytes */
	/* Returns: if frame was saved, returns number of bytes written - see rprofSave. */
	static inline int rprofDrawFrame(ProfilerFrame* _data, void* _buffer = 0, size_t _bufferSize = 0, bool _inGame = true, bool _multi = false)
	{
		int ret = 0;

		SortScopes customLess;
		std::sort(&_data->m_scopes[0], &_data->m_scopes[_data->m_numScopes], customLess);

		ImGui::SetNextWindowPos(ImVec2(6.0f, _multi ? 150.0f : 6.0f), ImGuiCond_FirstUseEver);
		ImGui::SetNextWindowSize(ImVec2(900.0f, 480.0f), ImGuiCond_FirstUseEver);

		static bool pause = false;
		bool noMove = (pause && _inGame) || !_inGame;
		noMove =  noMove && ImGui::GetIO().KeyCtrl;

		static ImVec2 winpos = ImGui::GetWindowPos();

		if (noMove)
			ImGui::SetNextWindowPos(winpos);

		ImGui::Begin("Frame inspector", 0, noMove ? ImGuiWindowFlags_NoMove : 0);

		if (!noMove)
			winpos = ImGui::GetWindowPos();

		float deltaTime = rprofClock2ms(_data->m_endtime - _data->m_startTime, _data->m_CPUFrequency);
		float frameRate = 1000.0f / deltaTime;

		ImVec4 col = triColor(frameRate, RPROF_MINIMUM_FRAME_RATE, RPROF_DESIRED_FRAME_RATE);
		 
		ImGui::Text("FPS: ");
		ImGui::SameLine();
		ImGui::PushStyleColor(ImGuiCol_Text, col);
		ImGui::Text("%.1f    ", 1000.0f / deltaTime);
		ImGui::PopStyleColor();
		ImGui::SameLine();
		ImGui::Text("Frame time: ");
		ImGui::SameLine();
		ImGui::PushStyleColor(ImGuiCol_Text, col);
		ImGui::Text("%.3f ms   ", deltaTime);
		ImGui::PopStyleColor();
		ImGui::SameLine();

		if (_inGame)
		{
			ImGui::Text("Average FPS: ");
			ImGui::PushStyleColor(ImGuiCol_Text, triColor(ImGui::GetIO().Framerate, RPROF_MINIMUM_FRAME_RATE, RPROF_DESIRED_FRAME_RATE));
			ImGui::SameLine();
			ImGui::Text("%.1f   ", ImGui::GetIO().Framerate);
			ImGui::PopStyleColor();
		}
		else
		{
			float prevFrameTime = rprofClock2ms(_data->m_prevFrameTime, _data->m_CPUFrequency);
			ImGui::SameLine();
			ImGui::Text("Prev frame: ");
			ImGui::PushStyleColor(ImGuiCol_Text, triColor(1000.0f/prevFrameTime, RPROF_MINIMUM_FRAME_RATE, RPROF_DESIRED_FRAME_RATE));
			ImGui::SameLine();
			ImGui::Text("%.3f ms  %.2f fps   ", prevFrameTime, 1000.0f/prevFrameTime);
			ImGui::PopStyleColor();
			ImGui::SameLine();

			ImGui::Text("Platform: ");
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.0f, 1.0f, 1.0f));
			ImGui::SameLine();
			ImGui::Text("%s   ", rprofGetPlatformName(_data->m_platformID));
			ImGui::PopStyleColor();
		}

		if (_inGame)
		{
			ImGui::SameLine();
			ImGui::Checkbox("Pause captures   ", &pause);
		}

		bool resetZoom				= false;
		static float threshold		= 0.0f;
		static int thresholdLevel	= 0;

		if (_inGame)
		{
			ImGui::PushItemWidth(210);
			ImGui::SliderFloat("Threshold   ", &threshold, 0.0f, 15.0f);

			ImGui::SameLine();
			ImGui::PushItemWidth(120);
			ImGui::SliderInt("Level", &thresholdLevel, 0, 23);

			ImGui::SameLine();
			if (ImGui::Button("Save frame"))
				ret = rprofSave(_data, _buffer, _bufferSize);
		}
		else
		{
			ImGui::Text("Capture threshold: ");
			ImGui::SameLine();
			ImGui::TextColored(ImVec4(0, 1.0f, 1.0f, 1.0f), "%.2f ", _data->m_timeThreshold);
			ImGui::SameLine();
			ImGui::Text("ms   ");
			ImGui::SameLine();
			ImGui::Text("Threshold level: ");
			ImGui::SameLine();
			if (_data->m_levelThreshold == 0)
				ImGui::TextColored(ImVec4(0, 1.0f, 1.0f, 1.0f), "whole frame   ");
			else
				ImGui::TextColored(ImVec4(0, 1.0f, 1.0f, 1.0f), "%d   ", _data->m_levelThreshold);
		}

		ImGui::SameLine();
		resetZoom = ImGui::Button("Reset zoom and pan");

		const ImVec2 p = ImGui::GetCursorScreenPos();
		const ImVec2 s = ImGui::GetWindowSize();

		float frameStartX	= p.x + 3.0f;
		float frameEndX		= frameStartX + s.x - 23;
		float frameStartY	= p.y;

		static PanAndZoon paz;

		ImVec2 mpos = ImGui::GetMousePos();

		if (ImGui::IsMouseDragging(0) && ImGui::GetIO().KeyCtrl)
		{
			paz.m_offset  -= (mpos.x - paz.m_startPan);
			paz.m_startPan = mpos.x;
		}
		else
			paz.m_startPan = mpos.x;

		float mXpre = paz.s2w(mpos.x, frameStartX, frameEndX);

		if (ImGui::GetIO().KeyCtrl)
			paz.m_zoom += ImGui::GetIO().MouseWheel / 30.0f;
		if (ImGui::IsKeyPressed(ImGuiKey_A) && ImGui::IsWindowHovered())
			paz.m_zoom *= 1.1f;
		if (ImGui::IsKeyPressed(ImGuiKey_Z) && ImGui::IsWindowHovered())
			paz.m_zoom /= 1.1f;

		paz.m_zoom  = rprofMax(paz.m_zoom, 1.0f);

		float mXpost  = paz.s2w(mpos.x, frameStartX, frameEndX);
		float mXdelta = mXpost - mXpre;

		paz.m_offset -= paz.w2sdelta(mXdelta, frameStartX, frameEndX);

		// snap to edge
		float leX	= paz.w2s(0.0f, frameStartX, frameEndX);
		float reX	= paz.w2s(1.0f, frameStartX, frameEndX);

		if (leX > frameStartX)
			paz.m_offset += leX - frameStartX;
		if (reX < frameEndX)
			paz.m_offset -= frameEndX - reX;

		if (resetZoom || (_inGame ? !pause : false))
		{
			paz.m_offset = 0.0f;
			paz.m_zoom   = 1.0f;
		}

		rprofSetPaused(pause);
		rprofSetThreshold(threshold, thresholdLevel);

		static const int	RPROF_MAX_FRAME_TIMES = 128;
		static float s_frameTimes[RPROF_MAX_FRAME_TIMES];
		static int	 s_currentFrame = 0;

		float maxFrameTime = 0.0f;
		if (_inGame)
		{
			frameStartY	+= 62.0f;

			if (s_currentFrame == 0)
				memset(s_frameTimes, 0, sizeof(s_frameTimes));

			if (!rprofIsPaused())
			{
				s_frameTimes[s_currentFrame % RPROF_MAX_FRAME_TIMES] = deltaTime;
				++s_currentFrame;
			}

			float frameTimes[RPROF_MAX_FRAME_TIMES];
			for (int i=0; i<RPROF_MAX_FRAME_TIMES; ++i)
			{
				frameTimes[i] = s_frameTimes[(s_currentFrame  + i) % RPROF_MAX_FRAME_TIMES];
				maxFrameTime = rprofMax(maxFrameTime, frameTimes[i]);
			}

			ImGui::Separator();
			ImGui::PlotHistogram("frames", frameTimes, RPROF_MAX_FRAME_TIMES, 0, "", 0.f, maxFrameTime, ImVec2(s.x - 9.0f, 45));
		}
		else
		{
			frameStartY	+= 12.0f;
			ImGui::Separator();
		}

		ImDrawList* draw_list = ImGui::GetWindowDrawList();

		maxFrameTime = rprofMax(maxFrameTime, 0.001f);
		float pct30fps = 33.33f / maxFrameTime;
		float pct60fps = 16.66f / maxFrameTime;

		float minHistY = p.y + 6.0f;
		float maxHistY = p.y + 45.0f;
		
		float limit30Y = maxHistY - (maxHistY - minHistY) * pct30fps;
		float limit60Y = maxHistY - (maxHistY - minHistY) * pct60fps;

		if (pct30fps <= 1.0f)
		draw_list->AddLine(ImVec2(frameStartX - 3.0f, limit30Y), ImVec2(frameEndX + 3.0f, limit30Y), IM_COL32(255,255, 96,255));

		if (pct60fps <= 1.0f)
		draw_list->AddLine(ImVec2(frameStartX - 3.0f, limit60Y), ImVec2(frameEndX + 3.0f, limit60Y), IM_COL32( 96,255, 96,255));

		if (_data->m_numScopes == 0)
		{
			ImGui::TextColored(ImVec4(1.0f, 0.23f, 0.23f, 1.0f), "No scope data!");
			ImGui::End();
			return ret;
		}

		uint64_t threadID = _data->m_scopes[0].m_threadID;
		bool writeThreadName = true;

		uint64_t totalTime = _data->m_endtime - _data->m_startTime;

		float barHeight = 18.0f;
		float bottom	= 0.0f;

		uint64_t currTime = rprofGetClock();

		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& cs = _data->m_scopes[i];
			if (!cs.m_name)
				continue;

			if (cs.m_threadID != threadID)
			{
				threadID		= cs.m_threadID;
				frameStartY		= bottom + barHeight;
				writeThreadName	= true;
			}

			if (writeThreadName)
			{
				ImVec2 tlt = ImVec2(frameStartX,	frameStartY);
				ImVec2 brt = ImVec2(frameEndX,		frameStartY + barHeight);

				draw_list->PushClipRect(tlt, brt, true);
				draw_list->AddRectFilled(tlt, brt, IM_COL32(45, 45, 60, 255));
				const char* threadName = "Unnamed thread";
				for (uint32_t j=0; j<_data->m_numThreads; ++j)
					if (_data->m_threads[j].m_threadID == threadID)
					{
						threadName = _data->m_threads[j].m_name;
						break;
					}
				tlt.x += 3;
				char buffer[512];
				snprintf(buffer, 512, "%s  -  0x%" PRIx64, threadName, threadID);
				draw_list->AddText(tlt, IM_COL32(255, 255, 255, 255), buffer);
				draw_list->PopClipRect();

				frameStartY		+= barHeight;
				writeThreadName	 = false;
			}

			// handle wrap around
			int64_t sX = int64_t(cs.m_start	- _data->m_startTime);
			if (sX < 0) sX = -sX;
			int64_t eX = int64_t(cs.m_end - _data->m_startTime);
			if (eX < 0) eX = -eX;

			float startXpct = float(sX) / float(totalTime);
			float endXpct	= float(eX) / float(totalTime);

			float startX	= paz.w2s(startXpct, frameStartX, frameEndX);
			float endX		= paz.w2s(endXpct  , frameStartX, frameEndX);

			ImVec2 tl = ImVec2(startX,	frameStartY + cs.m_level * (barHeight + 1.0f));
			ImVec2 br = ImVec2(endX,	frameStartY + cs.m_level * (barHeight + 1.0f) + barHeight);
			
			bottom = rprofMax(bottom, br.y);

			int level = cs.m_level;
			if (cs.m_level >= s_maxLevelColors)
				level = s_maxLevelColors - 1;

			ImU32 drawColor = s_levelColors[level];
			flashColorNamed(drawColor, cs, currTime - s_timeSinceStatClicked);

			if (ImGui::IsMouseClicked(0) && ImGui::IsMouseHoveringRect(tl, br) && ImGui::IsWindowHovered())
			{
				s_timeSinceStatClicked	= currTime;
				s_statClickedName		= cs.m_name;
				s_statClickedLevel		= cs.m_level;
			}

			if ((thresholdLevel == (int)cs.m_level + 1) && (threshold <= rprofClock2ms(cs.m_end - cs.m_start, _data->m_CPUFrequency)))
				flashColor(drawColor, currTime - _data->m_endtime);

			draw_list->PushClipRect(tl, br, true);
			draw_list->AddRectFilled(tl, br, drawColor);
			tl.x += 3;
			draw_list->AddText(tl, IM_COL32(0, 0, 0, 255), cs.m_name);
			draw_list->PopClipRect();

			if (ImGui::IsMouseHoveringRect(tl, br) && ImGui::IsWindowHovered())
			{
				ImGui::BeginTooltip();
				ImGui::TextColored(ImVec4(255, 255, 0, 255), "%s", cs.m_name);
				ImGui::Separator();
				ImGui::TextColored(ImVec4(0, 255, 255, 255), "Time: ");
				ImGui::SameLine();
				ImGui::TextColored(ImVec4(230, 230, 230, 255), "%.3f ms", rprofClock2ms(cs.m_end - cs.m_start, _data->m_CPUFrequency));
				ImGui::TextColored(ImVec4(0, 255, 255, 255), "File: ");
				ImGui::SameLine();
				ImGui::Text("%s", cs.m_file);
				ImGui::TextColored(ImVec4(0, 255, 255, 255), "%s", "Line: ");
				ImGui::SameLine();
				ImGui::Text("%d", cs.m_line);
				ImGui::EndTooltip();
			}
		}

		ImGui::End();
		return ret;
	}

	static struct sortExcusive {
		bool operator()(const ProfilerScope& a, const ProfilerScope& b) const {
			return  (a.m_stats->m_exclusiveTimeTotal > b.m_stats->m_exclusiveTimeTotal);
		}
	} customLessExc;

	static struct sortInclusive {
		bool operator()(const ProfilerScope& a, const ProfilerScope& b) const {
			return  (a.m_stats->m_inclusiveTimeTotal > b.m_stats->m_inclusiveTimeTotal);
		}
	} customLessInc;

	/* Draws a frame capture statistics using ImGui. */
	/* NB: frame data **MUST** be processed (done in rprofLoad) before using this function. */
	/* _data       - [in/out] profiler data / single frame capture. User is responsible to release memory using rprofRelease */
	static inline void rprofDrawStats(ProfilerFrame* _data, bool _multi = false)
	{
		ImGui::SetNextWindowPos(ImVec2(912.0f, _multi ? 150.0f : 6.0f), ImGuiCond_FirstUseEver);
		ImGui::SetNextWindowSize(ImVec2(600.0f, 812.0f), ImGuiCond_FirstUseEver);

		ImGui::Begin("Frame stats");

		if (_data->m_numScopes == 0)
		{
			ImGui::TextColored(ImVec4(1.0f,0.23f,0.23f,1.0f), "No scope data!");
			ImGui::End();
			return;
		}

		float deltaTime = rprofClock2ms(_data->m_endtime - _data->m_startTime, _data->m_CPUFrequency);

		static int exclusive = 0;
		ImGui::Text("Sort by:  ");
		ImGui::SameLine();
		ImGui::RadioButton("Exclusive time", &exclusive, 0);
		ImGui::SameLine();
		ImGui::RadioButton("Inclusive time", &exclusive, 1);
		ImGui::Separator();

		if (exclusive == 0)
			std::sort(&_data->m_scopesStats[0], &_data->m_scopesStats[_data->m_numScopesStats], customLessExc);
		else
			std::sort(&_data->m_scopesStats[0], &_data->m_scopesStats[_data->m_numScopesStats], customLessInc);

		const ImVec2 p = ImGui::GetCursorScreenPos();
		const ImVec2 s = ImGui::GetWindowSize();

		float frameStartX	= p.x + 3.0f;
		float frameEndX		= frameStartX + s.x - 23;
		float frameStartY	= p.y + 6.0f;

		uint64_t totalTime = 0;
		if (exclusive == 0)
			totalTime = _data->m_scopesStats[0].m_stats->m_exclusiveTimeTotal;
		else
			totalTime = _data->m_scopesStats[0].m_stats->m_inclusiveTimeTotal;

		float barHeight = 15.0f;

		ImDrawList* draw_list = ImGui::GetWindowDrawList();

		for (uint32_t i=0; i<_data->m_numScopesStats; i++)
		{
			ProfilerScope& cs = _data->m_scopesStats[i];

			float endXpct = float(cs.m_stats->m_exclusiveTimeTotal) / float(totalTime);
			if (exclusive == 1)
				endXpct = float(cs.m_stats->m_inclusiveTimeTotal) / float(totalTime);

			float startX = frameStartX;
			float endX = frameStartX + endXpct * (frameEndX - frameStartX);

			ImVec2 tl  = ImVec2(startX, frameStartY);
			ImVec2 tlt = ImVec2(tl.x + 3, tl.y);
			ImVec2 br  = ImVec2(endX, frameStartY + barHeight);

			int colIdx = s_maxLevelColors - 1 - i;
			if (colIdx < 0) colIdx = 0;
			ImU32 drawColor = s_levelColors[colIdx];

			ImVec2 brE = ImVec2(frameEndX, frameStartY + barHeight);
			bool hoverRow = ImGui::IsMouseHoveringRect(tl, brE);

			if (ImGui::IsMouseClicked(0) && hoverRow && ImGui::IsWindowHovered())
			{
				s_timeSinceStatClicked	= rprofGetClock();
				s_statClickedName		= cs.m_name;
				s_statClickedLevel		= cs.m_level;
			}

			flashColorNamed(drawColor, cs, rprofGetClock() - s_timeSinceStatClicked);

			draw_list->PushClipRect(tl, br, true);
			draw_list->AddRectFilled(tl, br, drawColor);
			draw_list->AddText(tlt, IM_COL32(0, 0, 0, 255), cs.m_name);
			draw_list->PopClipRect();

			ImVec2 htl = ImVec2(endX, frameStartY);
			draw_list->PushClipRect(htl, brE, true);
			draw_list->AddText(tlt, IM_COL32(128, 128, 128, 255), cs.m_name);
			draw_list->PopClipRect();

			if (hoverRow && ImGui::IsWindowHovered())
			{
				draw_list->PushClipRect(htl, brE, true);
				draw_list->AddRectFilled(htl, brE, IM_COL32(64,64,64,255));
				draw_list->AddText(tlt, IM_COL32(0, 0, 0, 255), cs.m_name);
				draw_list->PopClipRect();

				ImGui::BeginTooltip();
				ImGui::TextColored(ImVec4(255, 255, 0, 255), "%s", cs.m_name);
				ImGui::Separator();

				float ttime;
				if (exclusive == 0)
				{
					ImGui::TextColored(ImVec4(0, 255, 255, 255), "Exclusive time total: ");
					ImGui::SameLine();
					ttime = rprofClock2ms(cs.m_stats->m_exclusiveTimeTotal, _data->m_CPUFrequency);
					ImGui::TextColored(ImVec4(230, 230, 230, 255), "%.4f ms", ttime);
				}
				else
				{
					ImGui::TextColored(ImVec4(0, 255, 255, 255), "Inclusive time total: ");
					ImGui::SameLine();
					ttime = rprofClock2ms(cs.m_stats->m_inclusiveTimeTotal, _data->m_CPUFrequency);
					ImGui::TextColored(ImVec4(230, 230, 230, 255), "%.4f ms", ttime);
				}

				ImGui::TextColored(ImVec4(0, 255, 255, 255), "Of frame: ");
				ImGui::SameLine();
				ImGui::TextColored(ImVec4(230, 230, 230, 255), "%2.2f %%", 100.0f*ttime/deltaTime);

				ImGui::TextColored(ImVec4(0, 255, 255, 255), "File: ");
				ImGui::SameLine();
				ImGui::Text("%s", cs.m_file);

				ImGui::TextColored(ImVec4(0, 255, 255, 255), "Line: ");
				ImGui::SameLine();
				ImGui::Text("%d", cs.m_line);

				ImGui::TextColored(ImVec4(0, 255, 255, 255), "Count: ");
				ImGui::SameLine();
				ImGui::Text("%d", cs.m_stats->m_occurences);

				ImGui::EndTooltip();
			}

			frameStartY += 1.0f + barHeight;
		}

		ImGui::End();
	}

#endif // RPROF_DRAW_H

```

`makefile`:

```
#
# Copyright (c) 2025 by Milos Toisc. All rights reserved.
# License: http://www.opensource.org/licenses/BSD-2-Clause
#

GENIE=../build/tools/bin/$(OS)/genie

all:
	$(GENIE) vs2015
	$(GENIE) vs2017
	$(GENIE) --gcc=android-arm gmake
	$(GENIE) --gcc=android-mips gmake
	$(GENIE) --gcc=android-x86 gmake
	$(GENIE) --gcc=mingw-gcc gmake
	$(GENIE) --gcc=linux-gcc gmake
	$(GENIE) --gcc=osx gmake
	$(GENIE) --gcc=ios-arm gmake
	$(GENIE) --gcc=ios-simulator gmake
	$(GENIE) --gcc=ios-simulator64 gmake
	$(GENIE) xcode4

gmake-linux:
	$(GENIE) --file=genie/genie.lua --gcc=linux-gcc gmake
linux-debug32: gmake-linux
	make -R -C ../.build/linux/gcc/rprof/projects config=debug32
linux-release32: gmake-linux
	make -R -C ../.build/linux/gcc/rprof/projects config=release32
linux-debug64: gmake-linux
	make -R -C ../.build/linux/gcc/rprof/projects config=debug64
linux-release64: gmake-linux
	make -R -C ../.build/linux/gcc/rprof/projects config=release64
linux: linux-debug64 linux-release64 ## linux-debug32 linux-release32 

gmake-mingw-gcc:
	$(GENIE) --file=genie/genie.lua --gcc=mingw-gcc gmake
mingw-gcc-debug32: gmake-mingw-gcc
	make -R -C ../.build/windows/mingw-gcc/rprof/projects config=debug32
mingw-gcc-release32: gmake-mingw-gcc
	make -R -C ../.build/windows/mingw-gcc/rprof/projects config=release32
mingw-gcc-debug64: gmake-mingw-gcc
	make -R -C ../.build/windows/mingw-gcc/rprof/projects config=debug64
mingw-gcc-release64: gmake-mingw-gcc
	make -R -C ../.build/windows/mingw-gcc/rprof/projects config=release64
mingw-gcc: mingw-gcc-debug32 mingw-gcc-release32 mingw-gcc-debug64 mingw-gcc-release64

gmake-mingw-clang:
	$(GENIE) --file=genie/genie.lua --clang=mingw-clang gmake
mingw-clang-debug32: gmake-mingw-clang
	make -R -C ../.build/windows/mingw-clang/rprof/projects config=debug32
mingw-clang-release32: gmake-mingw-clang
	make -R -C ../.build/windows/mingw-clang/rprof/projects config=release32
mingw-clang-debug64: gmake-mingw-clang
	make -R -C ../.build/windows/mingw-clang/rprof/projects config=debug64
mingw-clang-release64: gmake-mingw-clang
	make -R -C ../.build/windows/mingw-clang/rprof/projects config=release64
mingw-clang: mingw-clang-debug32 mingw-clang-release32 mingw-clang-debug64 mingw-clang-release64

vs2015:
	$(GENIE) --file=genie/genie.lua vs2015

vs2017:
	$(GENIE) --file=genie/genie.lua vs2017

../.build/osx/clang/rprof/projects:
	$(GENIE) --file=genie/genie.lua --gcc=osx gmake
osx-debug64: ../.build/osx/clang/rprof/projects
	make -C ../.build/osx/clang/rprof/projects config=debug64
osx-release64: ../.build/osx/clang/rprof/projects
	make -C ../.build/osx/clang/rprof/projects config=release64
osx: osx-debug64 osx-release64

clean:
	@echo Cleaning...
	-@rm -rf ../.build

###

SILENT ?= @

UNAME := $(shell uname)
ifeq ($(UNAME),$(filter $(UNAME),Linux GNU Darwin))
ifeq ($(UNAME),$(filter $(UNAME),Darwin))
OS=darwin
else
OS=linux
endif
else
OS=windows
endif 


```

`samples/01_demo/demo.cpp`:

```cpp
//--------------------------------------------------------------------------//
/// Copyright 2025 Milos Tosic. All Rights Reserved.                       ///
/// License: http://www.opensource.org/licenses/BSD-2-Clause               ///
//--------------------------------------------------------------------------//

#include <demo_pch.h>
#include <rprof/inc/rprof_imgui.h>

static int random(int max)
{
	return 1 + rand() % (max>1?max-1:1);
}

static void busyCPU()
{
	uint32_t loopCnt = (rand() % 10000);
	for (uint32_t i=0; i<loopCnt; ++i)
		rand();
}

static void func(int level=1)
{
	static char scopeName[6];
	static bool scopeNameInit = false;
	if (!scopeNameInit)
	{
		strcpy(scopeName, "funcX");
		scopeNameInit = true;
	}

	scopeName[4] = '0' + (char)level;

	RPROF_SCOPE(scopeName);
	busyCPU();
	if (level < 5)
	{
		int cnt = random(3);
		for (int i=0; i<cnt; ++i)
			func(level+1);
		busyCPU();
	}
}

struct rprofApp : public rapp::App
{
	RAPP_CLASS(rprofApp)

	rapp::WindowHandle	m_window;
	float				m_time;

	int init(int32_t /*_argc*/, const char* const* /*_argv*/, rtmLibInterface* /*_libInterface = 0*/)
	{
		m_time = 0.0f;

		static const rapp::InputBinding bindings[] =
		{
			{ NULL, "exit", 1, { rapp::KeyboardKey::KeyQ,   rapp::KeyboardModifier::LCtrl }},
			{ NULL, "exit", 1, { rapp::KeyboardKey::KeyQ,   rapp::KeyboardModifier::RCtrl }},
			{ NULL, "hide", 1, { rapp::KeyboardKey::Tilde,  rapp::KeyboardModifier::None  }},
			RAPP_INPUT_BINDING_END
		};

		rapp::inputAddBindings("bindings", bindings);
		rapp::cmdAdd("exit", cmdExit,			0, "quits application");
		rapp::cmdAdd("hide", cmdHideConsole,	0, "hides console");

		uint32_t width, height;
		rapp::windowGetDefaultSize(&width, &height);
		m_width		= width;
		m_height	= height;

		rapp::appGraphicsInit(this, m_width, m_height, RAPP_WINDOW_FLAG_DPI_AWARE);

		RPROF_INIT();
		RPROF_REGISTER_THREAD("Application thread");
		appRunOnMainThread(registerMainThread, this);
		return 0;
	}

	void suspend() {}
	void resume() {}
	void update(float _time)
	{
		RPROF_SCOPE("Update");
		m_time += _time;
		busyCPU();
	}

	void draw(float /*_alpha*/)
	{
		RPROF_BEGIN_FRAME();
		appRunOnMainThread(mainThreadFunc, this);

		func();
		busyCPU();
		func();

		// Use debug font to print information about this example.
		bgfx::dbgTextClear();
		bgfx::dbgTextPrintf(0, 1, 0x17, "rprof/samples/demo");
		bgfx::dbgTextPrintf(0, 2, 0x37, m_description);
	}

	void drawGUI()
	{
		RPROF_SCOPE("Draw GUI");
		ProfilerFrame data;
		rprofGetFrame(&data);

		char buffer[10*1024];
		if (int size = rprofDrawFrame(&data, buffer, 10*1024))
		{
			FILE* file = fopen("capture.rprof", "wb");
			if (file)
			{
				fwrite(buffer, 1, size, file);
				fclose(file);
			}

			ProfilerFrame data2;
			rprofLoad(&data2, buffer, size);
			data2.m_CPUFrequency = 0;
		}

		// Example of writing multi-frame data

		/*
		static bool headerWritten = false;
		FILE* file = 0;
		if (!headerWritten)
		{
			uint32_t sig = 0x23232323;
			file = fopen("capture.rprofm", "wb");
			fwrite(&sig, 1, 4, file);
			fclose(file);
			headerWritten = true;
		}

		uint32_t size = rprofSave(&data, buffer, 10 * 1024);
		file = fopen("capture.rprofm", "ab");
		fwrite(&size, 4, 1, file);
		fwrite(buffer, 1, size, file);
		fclose(file);
		*/
	}
	
	void shutDown()
	{
		rtm::Console::rgb(255, 255, 0, "Shutting down app\n");
		rapp::appGraphicsShutdown(this, m_window);
		rapp::inputRemoveBindings("bindings");
		RPROF_SHUTDOWN();
	}

	static void mainThreadFunc(void* /*_appClass*/)
	{
		RPROF_SCOPE("main thread");
		func();
	}

	static void registerMainThread(void* /*_appClass*/)
	{
		RPROF_REGISTER_THREAD("Main thread");
	}

	static int cmdExit(rapp::App* _app, void* _userData, int _argc, char const* const* _argv)
	{
		RTM_UNUSED_3(_userData, _argv, _argc);
		_app->quit();
		return 0;
	}

	static int cmdHideConsole(rapp::App* _app, void* _userData, int _argc, char const* const* _argv)
	{
		RTM_UNUSED_3(_userData, _argv, _argc);
		rapp::cmdConsoleToggle(_app);
		return 0;
	}
};

RAPP_REGISTER(rprofApp, "rprof", "Example of rprof ImGui visualization");

```

`samples/01_demo/demo_pch.cpp`:

```cpp
//--------------------------------------------------------------------------//
/// Copyright 2025 Milos Tosic. All Rights Reserved.                       ///
/// License: http://www.opensource.org/licenses/BSD-2-Clause               ///
//--------------------------------------------------------------------------//

#include <demo_pch.h>


```

`samples/01_demo/demo_pch.h`:

```h
//--------------------------------------------------------------------------//
/// Copyright 2025 Milos Tosic. All Rights Reserved.                       ///
/// License: http://www.opensource.org/licenses/BSD-2-Clause               ///
//--------------------------------------------------------------------------//

#include <rbase/inc/platform.h>
#include <rbase/inc/console.h>
#include <rbase/inc/thread.h>

#define RAPP_WITH_BGFX 1
#include <rapp/inc/rapp.h>

#include <rprof/inc/rprof.h>

```

`scripts/win_fetch_dependencies.bat`:

```bat
@echo off
echo This will clone dependencies in the parent directory.
echo Note that this is only needed if you want to generate the demo project.
echo _
:choice
set /P c=Are you sure you want to continue[Y/N]?
if /I "%c%" EQU "Y" goto :clone_deps
if /I "%c%" EQU "N" goto :exit
goto :choice

:clone_deps
if not exist ../../bx   ( git clone https://github.com/bkaradzic/bx.git   ../../bx   ) else ( echo skipping bx     - directory exists )
if not exist ../../bimg ( git clone https://github.com/bkaradzic/bimg.git ../../bimg ) else ( echo skipping bimg   - directory exists )
if not exist ../../bgfx ( git clone https://github.com/bkaradzic/bgfx.git ../../bgfx ) else ( echo skipping bgfx   - directory exists )

if not exist ../../build  ( git clone https://github.com/RudjiGames/build.git ../../build  )  else ( echo skipping build  - directory exists )
if not exist ../../rbase  ( git clone https://github.com/RudjiGames/rbase.git ../../rbase   ) else ( echo skipping rbase  - directory exists )
if not exist ../../rapp   ( git clone https://github.com/RudjiGames/rapp.git  ../../rapp  )   else ( echo skipping rapp   - directory exists )

:exit

```

`scripts/win_generate_inspector_project.bat`:

```bat
@echo off
IF not [%1]==[] goto EMSDK_PATH_ARG
echo Example usage: get_inspector_proj.bat D:/emsdk
GOTO END
:EMSDK_PATH_ARG
set EMSCRIPTEN=%1/upstream/emscripten
call %1/emsdk_env.bat
cd ../genie
genie --gcc=asmjs gmake
cd ../scripts
:END

```

`scripts/win_generate_project.bat`:

```bat
@echo off
cd ..\genie
..\..\build\tools\bin\windows\genie.exe vs2022
cd ..\scripts

```

`src/rprof_config.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_CONFIG_H
#define RPROF_CONFIG_H

#define RPROF_SCOPES_MAX            (16*1024)
#define RPROF_TEXT_MAX			    (1024*1024)
#define RPROF_DRAW_THREADS_MAX	    (1024)

/*--------------------------------------------------------------------------
 * Define to 1 if LZ4 is already statically linked with project using rprof
 *------------------------------------------------------------------------*/
#define RPROF_LZ4_NO_DEFINE			0

#endif /* RPROF_CONFIG_H */

```

`src/rprof_context.cpp`:

```cpp
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#include "../inc/rprof.h"
#include "rprof_config.h"
#include "rprof_platform.h"
#include "rprof_context.h"
#include "rprof_tls.h"

extern "C" uint64_t rprofGetClockFrequency();

namespace rprof {

	ProfilerContext::ProfilerContext()
		: m_scopesOpen(0)
		, m_displayScopes(0)
		, m_frameStartTime(0)
		, m_frameEndTime(0)
		, m_thresholdCrossed(false)
		, m_timeThreshold(0.0f)
		, m_levelThreshold(0)
		, m_pauseProfiling(false)
	{
		m_tlsLevel = tlsAllocate();
		rprofFreeListCreate(sizeof(ProfilerScope), RPROF_SCOPES_MAX, &m_scopesAllocator);

		for (int i=0; i<BufferUse::Count; ++i)
		{
			m_namesSize[i] = 0;
			m_namesData[i] = m_namesDataBuffers[i];
		}
	}

	ProfilerContext::~ProfilerContext()
	{
		rprofFreeListDestroy(&m_scopesAllocator);
		tlsFree(m_tlsLevel);
	}

	void ProfilerContext::setThreshold(float _ms, int _levelThreshold)
	{
		m_timeThreshold		= _ms;
		m_levelThreshold	= _levelThreshold;
	}

	bool ProfilerContext::isPaused()
	{
		return m_pauseProfiling;
	}

	bool ProfilerContext::wasThresholdCrossed()
	{
		return !m_pauseProfiling && m_thresholdCrossed;
	}

	void ProfilerContext::setPaused(bool _paused)
	{
		m_pauseProfiling = _paused;
	}

	void ProfilerContext::registerThread(uint64_t _threadID, const char* _name)
	{
		m_threadNames[_threadID] = _name;
	}

	void ProfilerContext::unregisterThread(uint64_t _threadID)
	{
		m_threadNames.erase(_threadID);
	}

	void ProfilerContext::beginFrame()
	{
		ScopedMutexLocker lock(m_mutex);

		uint64_t frameBeginTime, frameEndTime;
		static uint64_t beginPrevFrameTime = rprofGetClock();
		frameBeginTime		= beginPrevFrameTime;
		frameEndTime		= rprofGetClock();
		beginPrevFrameTime	= frameEndTime;

		m_thresholdCrossed = false;

		int level = (int)m_levelThreshold - 1;

		uint32_t scopesToRestart = 0;

		m_namesSize[BufferUse::Open] = 0;

		static ProfilerScope scopesDisplay[RPROF_SCOPES_MAX];
		for (uint32_t i=0; i<m_scopesOpen; ++i)
		{
			ProfilerScope* scope = m_scopesCapture[i];

			if (scope->m_start == scope->m_end)
				scope->m_name = addString(scope->m_name, BufferUse::Open);

			scopesDisplay[i] = *scope;

			// scope that was not closed, spans frame boundary
			// keep it for next frame
			if (scope->m_start == scope->m_end)
				m_scopesCapture[scopesToRestart++] = scope;
			else
			{
				rprofFreeListFree(&m_scopesAllocator, scope);
				scope = &scopesDisplay[i];
			}

			// did scope cross threshold?
			if (level == (int)scope->m_level)
			{
				uint64_t scopeEnd = scope->m_end;
				if (scope->m_start == scope->m_end)
					scopeEnd = frameEndTime;

				if (m_timeThreshold <= rprofClock2ms(scopeEnd - scope->m_start, rprofGetClockFrequency()))
					m_thresholdCrossed = true;
			}
		}

		// did frame cross threshold ?
		float prevFrameTime = rprofClock2ms(frameEndTime - frameBeginTime, rprofGetClockFrequency());
		if ((level == -1) && (m_timeThreshold <= prevFrameTime))
			m_thresholdCrossed = true;

		if (m_thresholdCrossed && !m_pauseProfiling)
		{
			std::swap(m_namesData[BufferUse::Capture], m_namesData[BufferUse::Display]);

			for (uint32_t i=0; i<m_scopesOpen; ++i)
				m_scopesDisplay[i] = scopesDisplay[i];

			m_displayScopes		= m_scopesOpen;
			m_frameStartTime	= frameBeginTime;
			m_frameEndTime		= frameEndTime;
		}

		m_namesSize[BufferUse::Capture] = 0;
		for (uint32_t i=0; i<scopesToRestart; ++i)
			m_scopesCapture[i]->m_name = addString(m_scopesCapture[i]->m_name, BufferUse::Capture);

		m_scopesOpen	= scopesToRestart;
	}

	int ProfilerContext::incLevel()
	{
		// may be a first call on this thread
		void* tl = tlsGetValue(m_tlsLevel);
		if (!tl)
		{
			// we'd like to start with -1 but then the ++ operator below
			// would result in NULL value for tls so we offset by 2
			tl = (void*)1;
			tlsSetValue(m_tlsLevel, tl);
		}
		intptr_t threadLevel = (intptr_t)tl - 1;
		tlsSetValue(m_tlsLevel, (void*)(threadLevel + 2));
		return (int)threadLevel;
	}

	void ProfilerContext::decLevel()
	{
		intptr_t threadLevel = (intptr_t)tlsGetValue(m_tlsLevel);
		--threadLevel;
		tlsSetValue(m_tlsLevel, (void*)threadLevel);
	}

	ProfilerScope* ProfilerContext::beginScope(const char* _file, int _line, const char* _name)
	{
		ProfilerScope* scope = 0;
		{
			ScopedMutexLocker lock(m_mutex);
			if (m_scopesOpen == RPROF_SCOPES_MAX)
				return 0;

			scope = (ProfilerScope*)rprofFreeListAlloc(&m_scopesAllocator);
			m_scopesCapture[m_scopesOpen++] = scope;

			scope->m_name	= addString(_name, BufferUse::Capture);
			scope->m_start	= rprofGetClock();
			scope->m_end	= scope->m_start;
		}

		scope->m_threadID	= getThreadID();
		scope->m_file		= _file;
		scope->m_line		= _line;
		scope->m_level		= incLevel();

		return scope;
	}

	void ProfilerContext::endScope(ProfilerScope* _scope)
	{
		if (!_scope)
			return;

		_scope->m_end = rprofGetClock();
		decLevel();
	}

	const char* ProfilerContext::addString(const char* _name, BufferUse _buffer)
	{
		char*	nameData = m_namesData[_buffer];
		int&	nameSize = m_namesSize[_buffer];

		char *ret = &nameData[nameSize];
		while (nameSize < RPROF_TEXT_MAX)
		{
			char c = *_name++;
			if (c)
				nameData[nameSize++] = c;
			else
				break;
		}

		if (nameSize < RPROF_TEXT_MAX)
			nameData[nameSize++] = 0;
		else
			nameData[RPROF_TEXT_MAX - 1] = 0;

		return ret;
	}

	void ProfilerContext::getFrameData(ProfilerFrame* _data)
	{
		ScopedMutexLocker lock(m_mutex);

		static ProfilerThread threadData[RPROF_DRAW_THREADS_MAX];

		uint32_t numThreads = (uint32_t)m_threadNames.size();
		if (numThreads > RPROF_DRAW_THREADS_MAX)
			numThreads = RPROF_DRAW_THREADS_MAX;

		_data->m_numScopes		= m_displayScopes;
		_data->m_scopes			= m_scopesDisplay;
		_data->m_numThreads		= numThreads;
		_data->m_threads		= threadData;
		_data->m_startTime		= m_frameStartTime;
		_data->m_endtime		= m_frameEndTime;
		_data->m_prevFrameTime	= m_frameEndTime - m_frameStartTime;
		_data->m_CPUFrequency	= rprofGetClockFrequency();
		_data->m_timeThreshold	= m_timeThreshold;
		_data->m_levelThreshold	= m_levelThreshold;
		_data->m_platformID		= getPlatformID();

		std::unordered_map<uint64_t, std::string>::iterator it = m_threadNames.begin();
		for (uint32_t i=0; i<numThreads; ++i)
		{
			threadData[i].m_threadID	= it->first;
			threadData[i].m_name		= it->second.c_str();
			++it;
		}
	}

} // namespace rprof

```

`src/rprof_context.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_LIB_H
#define RPROF_LIB_H

#include "../inc/rprof.h"
#include "rprof_config.h"
#include "rprof_mutex.h"
#include "rprof_freelist.h"

#include <unordered_map>
#include <string>

namespace rprof {

	class ProfilerContext
	{
		enum BufferUse
		{
			Capture,
			Display,
			Open,

			Count
		};


		Mutex			m_mutex;
		rprofFreeList_t	m_scopesAllocator;
		uint32_t		m_scopesOpen;
		ProfilerScope*	m_scopesCapture[RPROF_SCOPES_MAX];
		ProfilerScope	m_scopesDisplay[RPROF_SCOPES_MAX];
		uint32_t		m_displayScopes;
		uint64_t		m_frameStartTime;
		uint64_t		m_frameEndTime;
		bool			m_thresholdCrossed;
		float			m_timeThreshold;
		uint32_t		m_levelThreshold;
		bool			m_pauseProfiling;
		char			m_namesDataBuffers[BufferUse::Count][RPROF_TEXT_MAX];
		char*			m_namesData[BufferUse::Count];
		int				m_namesSize[BufferUse::Count];
		uint32_t		m_tlsLevel;

		std::unordered_map<uint64_t, std::string>	m_threadNames;

	public:
		ProfilerContext();
		~ProfilerContext();

		void			setThreshold(float _ms, int _levelThreshold);
		bool			isPaused();
		bool			wasThresholdCrossed();
		void			setPaused(bool _paused);
		void			registerThread(uint64_t _threadID, const char* _name);
		void			unregisterThread(uint64_t _threadID);
		void			beginFrame();
		int				incLevel();
		void			decLevel();
		ProfilerScope*	beginScope(const char* _file, int _line, const char* _name);
		void			endScope(ProfilerScope* _scope);
		const char*		addString(const char* _name, BufferUse _buffer);
		void			getFrameData(ProfilerFrame* _data);
	};

} // namespace rprof

#endif // RPROF_LIB_H

```

`src/rprof_freelist.cpp`:

```cpp
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */


#include <stdlib.h>
#include "rprof_freelist.h"

void rprofFreeListCreate(size_t _blockSize, uint32_t _maxBlocks, struct rprofFreeList_t* _freeList)
{
	_freeList->m_maxBlocks			= _maxBlocks;
	_freeList->m_blockSize			= (uint32_t)_blockSize;
	_freeList->m_blocksFree			= _maxBlocks;
	_freeList->m_blocksAlllocated	= 0;
	_freeList->m_buffer				= (uint8_t*)malloc(_blockSize * _maxBlocks);
	_freeList->m_next				= _freeList->m_buffer;
}

void rprofFreeListDestroy(struct rprofFreeList_t* _freeList)
{
	free(_freeList->m_buffer);
}

void* rprofFreeListAlloc(struct rprofFreeList_t* _freeList)
{
	if (_freeList->m_blocksAlllocated < _freeList->m_maxBlocks)
	{
		uint32_t* p = (uint32_t*)(_freeList->m_buffer + (_freeList->m_blocksAlllocated * _freeList->m_blockSize));
		*p = _freeList->m_blocksAlllocated + 1;
		_freeList->m_blocksAlllocated++;
	}
	
	void* ret = 0;
	if (_freeList->m_blocksFree)
	{
		ret = _freeList->m_next;
		--_freeList->m_blocksFree;
		if (_freeList->m_blocksFree)
			_freeList->m_next = _freeList->m_buffer + (*(uint32_t*)_freeList->m_next * _freeList->m_blockSize);
		else
			_freeList->m_next = 0;
	}
	return ret;
}

void rprofFreeListFree(struct rprofFreeList_t* _freeList, void* _ptr)
{
	if (_freeList->m_next)
	{
		uint32_t index		= ((uint32_t)(_freeList->m_next - _freeList->m_buffer)) / _freeList->m_blockSize;
		*(uint32_t*)_ptr	= index;
		_freeList->m_next	= (uint8_t*)_ptr;
	}
	else
	{
		*(uint32_t*)_ptr	= _freeList->m_maxBlocks;
		_freeList->m_next	= (uint8_t*)_ptr;
	}
	++_freeList->m_blocksFree;
}

int rprofFreeListCheckPtr(struct rprofFreeList_t* _freeList, void* _ptr)
{
	return	((uintptr_t)_freeList->m_maxBlocks * (uintptr_t)_freeList->m_blockSize) > 
			(uintptr_t)(((uint8_t*)_ptr) - _freeList->m_buffer) ? 1 : 0;
}

```

`src/rprof_freelist.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_FREELIST_H
#define RPROF_FREELIST_H

#include <stdint.h>

typedef struct rprofFreeList_t
{
	uint32_t	m_maxBlocks;
	uint32_t	m_blockSize;
	uint32_t	m_blocksFree;
	uint32_t	m_blocksAlllocated;
	uint8_t*	m_buffer;
	uint8_t*	m_next;

} rprofFreeList_t;

void  rprofFreeListCreate(size_t _blockSize, uint32_t _maxBlocks, struct rprofFreeList_t* _freeList);
void  rprofFreeListDestroy(struct rprofFreeList_t* _freeList);
void* rprofFreeListAlloc(struct rprofFreeList_t* _freeList);
void  rprofFreeListFree(struct rprofFreeList_t* _freeList, void* _ptr);
int   rprofFreeListCheckPtr(struct rprofFreeList_t* _freeList, void* _ptr);

#endif /* RPROF_FREELIST_H */

```

`src/rprof_lib.cpp`:

```cpp
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#include "../inc/rprof.h"
#include "rprof_config.h"
#include "rprof_context.h"

#include "../3rd/lz4-r191/lz4.h"
#if !RPROF_LZ4_NO_DEFINE
#include "../3rd/lz4-r191/lz4.c"
#endif

extern "C" uint64_t rprofGetClockFrequency();

/*--------------------------------------------------------------------------
 * Data load/save functions
 *------------------------------------------------------------------------*/

static inline void memoryCopy(void* _dst, const void* _src, size_t _len)
{
	const uint8_t* src = (const uint8_t*)_src;
	uint8_t* dst = (uint8_t*)_dst;
	for (size_t i=0; i<_len; ++i)
		dst[i] = src[i];
}

template <typename T>
static inline void writeVar(uint8_t*& _buffer, T _var)
{
	memoryCopy(_buffer, &_var, sizeof(T));
	_buffer += sizeof(T);
}

static inline void writeStr(uint8_t*& _buffer, const char* _str)
{
	uint32_t len = (uint32_t)strlen(_str);
	writeVar(_buffer, len);
	memoryCopy(_buffer, _str, len);
	_buffer += len;
}

template <typename T>
static inline void readVar(uint8_t*& _buffer, T& _var)
{
	memoryCopy(&_var, _buffer, sizeof(T));
	_buffer += sizeof(T);
}
	
static inline char* readString(uint8_t*& _buffer)
{
	uint32_t len;
	readVar(_buffer, len);
	char* str = new char[len+1];
	memoryCopy(str, _buffer, len);
	str[len] = 0;
	_buffer += len;
	return str;
}

const char* duplicateString(const char* _str)
{
	char* str = new char[strlen(_str)+1];
	strcpy(str, _str);
	return str;
}

struct StringStore
{
	typedef std::unordered_map<std::string, uint32_t> StringToIndexType;
	typedef std::unordered_map<uint32_t, std::string> IndexToStringType;

	uint32_t			m_totalSize;
	StringToIndexType	m_stringIndexMap;
	IndexToStringType	m_strings;

	StringStore()
		: m_totalSize(0)
	{
	}

	void addString(const char* _str)
	{
		StringToIndexType::iterator it = m_stringIndexMap.find(_str);
		if (it == m_stringIndexMap.end())
		{
			uint32_t index = (uint32_t)m_stringIndexMap.size();
			m_totalSize				+= 4 + (uint32_t)strlen(_str);	// see writeStr for details
			m_stringIndexMap[_str]	 = index;
			m_strings[index]		 = _str;
		}
	}

	uint32_t getString(const char* _str)
	{
		return m_stringIndexMap[_str];
	}
};

/*--------------------------------------------------------------------------
 * API functions
 *------------------------------------------------------------------------*/

rprof::ProfilerContext*	g_context = 0;

extern "C" {

	void rprofInit()
	{
		g_context = new rprof::ProfilerContext();
	}

	void rprofShutDown()
	{
		delete g_context;
		g_context = 0;
	}

	void rprofSetThreshold(float _ms, int _level)
	{
		g_context->setThreshold(_ms, _level);
	}

	void rprofRegisterThread(const char* _name, uint64_t _threadID)
	{
		if (_threadID == 0)
			_threadID = getThreadID();

		g_context->registerThread(_threadID, _name);
	}

	void rprofUnregisterThread(uint64_t _threadID)
	{
		g_context->unregisterThread(_threadID);
	}

	void rprofBeginFrame()
	{
		g_context->beginFrame();
	}

	uintptr_t rprofBeginScope(const char* _file, int _line, const char* _name)
	{
		return (uintptr_t)g_context->beginScope(_file, _line, _name);
	}

	void rprofEndScope(uintptr_t _scopeHandle)
	{
		g_context->endScope((ProfilerScope*)_scopeHandle);
	}

	int rprofIsPaused()
	{
		return g_context->isPaused() ? 1 : 0;
	}

	int rprofWasThresholdCrossed()
	{
		return g_context->wasThresholdCrossed() ? 1 : 0;
	}

	void rprofSetPaused(int _paused)
	{
		return g_context->setPaused(_paused != 0);
	}

	void rprofGetFrame(ProfilerFrame* _data)
	{
		g_context->getFrameData(_data);

		// clamp scopes crossing frame boundary
		const uint32_t numScopes = _data->m_numScopes;
		for (uint32_t i=0; i<numScopes; ++i)
		{
			ProfilerScope& cs = _data->m_scopes[i];

			if (cs.m_start == cs.m_end)
			{
				cs.m_end = _data->m_endtime;
				if (cs.m_start < _data->m_startTime)
					cs.m_start = _data->m_startTime;
			}
		}
	}

	int rprofSave(ProfilerFrame* _data, void* _buffer, size_t _bufferSize)
	{
		// fill string data
		StringStore strStore;
		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& scope = _data->m_scopes[i];
			strStore.addString(scope.m_name);
			strStore.addString(scope.m_file);
		}
		for (uint32_t i=0; i<_data->m_numThreads; ++i)
		{
			strStore.addString(_data->m_threads[i].m_name);
		}

		// calc data size
		uint32_t totalSize =	_data->m_numScopes  * sizeof(ProfilerScope)  +
								_data->m_numThreads * sizeof(ProfilerThread) +
								sizeof(ProfilerFrame) +
								strStore.m_totalSize;

		uint8_t* buffer = new uint8_t[totalSize];
		uint8_t* bufPtr = buffer;

		writeVar(buffer, _data->m_startTime);
		writeVar(buffer, _data->m_endtime);
		writeVar(buffer, _data->m_prevFrameTime);
		writeVar(buffer, _data->m_platformID);
		writeVar(buffer, rprofGetClockFrequency());

		// write scopes
		writeVar(buffer, _data->m_numScopes);
		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& scope = _data->m_scopes[i];
			writeVar(buffer, scope.m_start);
			writeVar(buffer, scope.m_end);
			writeVar(buffer, scope.m_threadID);
			writeVar(buffer, strStore.getString(scope.m_name));
			writeVar(buffer, strStore.getString(scope.m_file));
			writeVar(buffer, scope.m_line);
			writeVar(buffer, scope.m_level);
		}

		// write thread info
		writeVar(buffer, _data->m_numThreads);
		for (uint32_t i=0; i<_data->m_numThreads; ++i)
		{
			ProfilerThread& t = _data->m_threads[i];
			writeVar(buffer, t.m_threadID);
			writeVar(buffer, strStore.getString(t.m_name));
		}

		// write string data
		uint32_t numStrings = (uint32_t)strStore.m_strings.size();
		writeVar(buffer, numStrings);

		for (uint32_t i=0; i<strStore.m_strings.size(); ++i)
			writeStr(buffer, strStore.m_strings[i].c_str());

		int compSize = LZ4_compress_default((const char*)bufPtr, (char*)_buffer, (int)(buffer - bufPtr), (int)_bufferSize);
		delete[] bufPtr;
		return compSize;
	}

	void rprofLoad(ProfilerFrame* _data, void* _buffer, size_t _bufferSize)
	{
		size_t		bufferSize	= _bufferSize;
		uint8_t*	buffer		= 0;
		uint8_t*	bufferPtr;

		int decomp = -1;
		do 
		{
			delete[] buffer;
			bufferSize *= 2;
			buffer = new uint8_t[bufferSize];
			decomp = LZ4_decompress_safe((const char*)_buffer, (char*)buffer, (int)_bufferSize, (int)bufferSize);

		} while (decomp < 0);

		bufferPtr = buffer;

		uint32_t strIdx;

		readVar(buffer, _data->m_startTime);
		readVar(buffer, _data->m_endtime);
		readVar(buffer, _data->m_prevFrameTime);
		readVar(buffer, _data->m_platformID);
		readVar(buffer, _data->m_CPUFrequency);

		// read scopes
		readVar(buffer, _data->m_numScopes);

		_data->m_scopes			= new ProfilerScope[_data->m_numScopes * 2]; // extra space for viewer - m_scopesStats
		_data->m_scopesStats	= &_data->m_scopes[_data->m_numScopes];
		_data->m_scopeStatsInfo	= new ProfilerScopeStats[_data->m_numScopes * 2];

		for (uint32_t i=0; i<_data->m_numScopes*2; ++i)
			_data->m_scopes[i].m_stats = &_data->m_scopeStatsInfo[i];

		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& scope = _data->m_scopes[i];
			readVar(buffer, scope.m_start);
			readVar(buffer, scope.m_end);
			readVar(buffer, scope.m_threadID);
			readVar(buffer, strIdx);
			scope.m_name = (const char*)(uintptr_t)strIdx;
			readVar(buffer, strIdx);
			scope.m_file = (const char*)(uintptr_t)strIdx;
			readVar(buffer, scope.m_line);
			readVar(buffer, scope.m_level);

			scope.m_stats->m_inclusiveTime	= scope.m_end - scope.m_start;
			scope.m_stats->m_exclusiveTime	= scope.m_stats->m_inclusiveTime;
			scope.m_stats->m_occurences		= 0;
		}

		// read thread info
		readVar(buffer, _data->m_numThreads);
		_data->m_threads = new ProfilerThread[_data->m_numThreads];
		for (uint32_t i=0; i<_data->m_numThreads; ++i)
		{
			ProfilerThread& t = _data->m_threads[i];
			readVar(buffer, t.m_threadID);
			readVar(buffer, strIdx);
			t.m_name = (const char*)(uintptr_t)strIdx;
		}

		// read string data
		uint32_t numStrings;
		readVar(buffer, numStrings);

		const char*	strings[RPROF_SCOPES_MAX];
		for (uint32_t i=0; i<numStrings; ++i)
			strings[i] = readString(buffer);

		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& scope = _data->m_scopes[i];
			uintptr_t idx = (uintptr_t)scope.m_name;
			scope.m_name = duplicateString(strings[(uint32_t)idx]);

			idx = (uintptr_t)scope.m_file;
			scope.m_file = duplicateString(strings[(uint32_t)idx]);
		}

		for (uint32_t i=0; i<_data->m_numThreads; ++i)
		{
			ProfilerThread& t = _data->m_threads[i];
			uintptr_t idx = (uintptr_t)t.m_name;
			t.m_name = duplicateString(strings[(uint32_t)idx]);
		}

		for (uint32_t i=0; i<numStrings; ++i)
			delete[] strings[i];

		delete[] bufferPtr;

		// process frame data

		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		for (uint32_t j=0; j<_data->m_numScopes; ++j)
		{
			ProfilerScope& scopeI = _data->m_scopes[i];
			ProfilerScope& scopeJ = _data->m_scopes[j];

			if ((scopeJ.m_start > scopeI.m_start) && (scopeJ.m_end < scopeI.m_end) &&
				(scopeJ.m_level == scopeI.m_level + 1) && (scopeJ.m_threadID == scopeI.m_threadID))
				scopeI.m_stats->m_exclusiveTime -= scopeJ.m_stats->m_inclusiveTime;
		}

		_data->m_numScopesStats	= 0;

		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& scopeI = _data->m_scopes[i];

			scopeI.m_stats->m_inclusiveTimeTotal = scopeI.m_stats->m_inclusiveTime;
			scopeI.m_stats->m_exclusiveTimeTotal = scopeI.m_stats->m_exclusiveTime;

			int foundIndex = -1;
			for (uint32_t j=0; j<_data->m_numScopesStats; ++j)
			{
				ProfilerScope& scopeJ = _data->m_scopesStats[j];
				if (strcmp(scopeI.m_name, scopeJ.m_name) == 0)
				{
					foundIndex = j;
					break;
				}
			}

			if (foundIndex == -1)
			{
				int index = _data->m_numScopesStats++;
				ProfilerScope& scope = _data->m_scopesStats[index];
				scope						= scopeI;
				scope.m_stats->m_occurences	= 1;
			}
			else
			{
				ProfilerScope& scope = _data->m_scopesStats[foundIndex];
				scope.m_stats->m_inclusiveTimeTotal += scopeI.m_stats->m_inclusiveTime;
				scope.m_stats->m_exclusiveTimeTotal += scopeI.m_stats->m_exclusiveTime;
				scope.m_stats->m_occurences++;
			}
		}
	}

	void rprofLoadTimeOnly(float* _time, void* _buffer, size_t _bufferSize)
	{
		size_t		bufferSize = _bufferSize;
		uint8_t*	buffer = 0;

		int decomp = -1;
		do
		{
			delete[] buffer;
			bufferSize *= 2;
			buffer = new uint8_t[bufferSize];
			decomp = LZ4_decompress_safe((const char*)_buffer, (char*)buffer, (int)_bufferSize, (int)bufferSize);

		} while (decomp < 0);

		uint64_t startTime;
		uint64_t endtime;
		uint8_t  dummy8;
		uint64_t frequency;

		readVar(buffer, startTime);
		readVar(buffer, endtime);
		readVar(buffer, frequency);	// dummy
		readVar(buffer, dummy8);	// dummy
		readVar(buffer, frequency);
		*_time = rprofClock2ms(endtime - startTime, frequency);

		delete[] buffer;
	}

	void rprofRelease(ProfilerFrame* _data)
	{
		for (uint32_t i=0; i<_data->m_numScopes; ++i)
		{
			ProfilerScope& scope = _data->m_scopes[i];
			delete[] scope.m_name;
			delete[] scope.m_file;
		}

		for (uint32_t i=0; i<_data->m_numThreads; ++i)
		{
			ProfilerThread& t = _data->m_threads[i];
			delete[] t.m_name;
		}

		delete[] _data->m_scopes;
		delete[] _data->m_threads;
		delete[] _data->m_scopeStatsInfo;
	}

	uint64_t rprofGetClock()
	{
#if   RPROF_PLATFORM_WINDOWS
	#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__x86_64__)
		uint64_t q = __rdtsc();
	#else
		LARGE_INTEGER li;
		QueryPerformanceCounter(&li);
		int64_t q = li.QuadPart;
	#endif
#elif RPROF_PLATFORM_XBOXONE
		LARGE_INTEGER li;
		QueryPerformanceCounter(&li);
		int64_t q = li.QuadPart;
#elif RPROF_PLATFORM_PS4
		int64_t q = sceKernelReadTsc();
#elif RPROF_PLATFORM_ANDROID
		int64_t q = ::clock();
#elif RPROF_PLATFORM_EMSCRIPTEN
		int64_t q = (int64_t)(emscripten_get_now() * 1000.0);
#elif RPROF_PLATFORM_SWITCH
		int64_t q = nn::os::GetSystemTick().GetInt64Value();
#else
		struct timeval now;
		gettimeofday(&now, 0);
		int64_t q = now.tv_sec * 1000000 + now.tv_usec;
#endif
		return q;
	}

	uint64_t rprofGetClockFrequency()
	{
#if   RPROF_PLATFORM_WINDOWS
	#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__x86_64__)
		static uint64_t frequency = 1;
		static bool initialized = false;
		while (!initialized)
		{
			LARGE_INTEGER li1, li2;
			QueryPerformanceCounter(&li1);
			uint64_t tsc1 = __rdtsc();
			Sleep(230);
			uint64_t tsc2 = __rdtsc();
			QueryPerformanceCounter(&li2);

			LARGE_INTEGER lif;
			QueryPerformanceFrequency(&lif);
			uint64_t time = ((li2.QuadPart - li1.QuadPart) * 1000) / lif.QuadPart;
			frequency = (uint64_t)(1000 * ((tsc2 - tsc1) / time));
			initialized = true;
		}
		return frequency;
	#else
		LARGE_INTEGER li;
		QueryPerformanceFrequency(&li);
		return li.QuadPart;
	#endif
#elif RPROF_PLATFORM_XBOXONE
		LARGE_INTEGER li;
		QueryPerformanceFrequency(&li);
		return li.QuadPart;
#elif RPROF_PLATFORM_ANDROID
		return CLOCKS_PER_SEC;
#elif RPROF_PLATFORM_PS4
		return sceKernelGetTscFrequency();
#elif RPROF_PLATFORM_SWITCH
		return nn::os::GetSystemTickFrequency();
#else
		return 1000000;
#endif
	}

	float rprofClock2ms(uint64_t _clock, uint64_t _frequency)
	{
		return (float(_clock) / float(_frequency)) * 1000.0f;
	}

	const char* rprofGetPlatformName(uint8_t _platformID)
	{
		return getPlatformName(_platformID);
	}

} // extern "C"

```

`src/rprof_mutex.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_MUTEX_H
#define RPROF_MUTEX_H

#include "rprof_platform.h"

namespace rprof {

#if RPROF_PLATFORM_WINDOWS || RPROF_PLATFORM_XBOXONE
	typedef CRITICAL_SECTION rprof_mutex;

	static inline void rprof_mutex_init(rprof_mutex* _mutex) {
		InitializeCriticalSection(_mutex);
	}

	static inline void rprof_mutex_destroy(rprof_mutex* _mutex) {
		DeleteCriticalSection(_mutex);
	}

	static inline void rprof_mutex_lock(rprof_mutex* _mutex) {
		EnterCriticalSection(_mutex);
	}

	static inline int rprof_mutex_trylock(rprof_mutex* _mutex)	{
		return TryEnterCriticalSection(_mutex) ? 0 : 1;
	}

	static inline void rprof_mutex_unlock(rprof_mutex* _mutex)	{
		LeaveCriticalSection(_mutex);
	}

#elif RPROF_PLATFORM_PS3
	typedef sys_lwmutex_t rprof_mutex;

	static inline void rprof_mutex_init(rprof_mutex* _mutex) {
		sys_lwmutex_attribute_t	mutexAttr;
		sys_lwmutex_attribute_initialize(mutexAttr);
		mutexAttr.attr_recursive = SYS_SYNC_RECURSIVE;
		sys_lwmutex_create(_mutex, &mutexAttr);
	}

	static inline void rprof_mutex_destroy(rprof_mutex* _mutex) {
		sys_lwmutex_destroy(_mutex);
	}

	static inline void rprof_mutex_lock(rprof_mutex* _mutex) {
		sys_lwmutex_lock(_mutex, 0);
	}

	static inline int rprof_mutex_trylock(rprof_mutex* _mutex) {
		return (sys_lwmutex_trylock(_mutex) == CELL_OK) ? 0 : 1;
	}

	static inline void rprof_mutex_unlock(rprof_mutex* _mutex) {
		sys_lwmutex_unlock(_mutex);
	}

#elif RPROF_PLATFORM_PS4
	typedef ScePthreadMutex rprof_mutex;

	static inline void rprof_mutex_init(rprof_mutex* _mutex) {
		ScePthreadMutexattr mutexAttr;
		scePthreadMutexattrInit(&mutexAttr);
		scePthreadMutexattrSettype(&mutexAttr, SCE_PTHREAD_MUTEX_RECURSIVE);
		scePthreadMutexInit(_mutex, &mutexAttr, 0);
		scePthreadMutexattrDestroy(&mutexAttr);
	}

	static inline void rprof_mutex_destroy(rprof_mutex* _mutex) {
		scePthreadMutexDestroy(_mutex);
	}

	static inline void rprof_mutex_lock(rprof_mutex* _mutex) {
		scePthreadMutexLock(_mutex);
	}

	static inline int rprof_mutex_trylock(rprof_mutex* _mutex) {
		return (scePthreadMutexTrylock(_mutex) == 0) ? 0 : 1;
	}

	static inline void rprof_mutex_unlock(rprof_mutex* _mutex) {
		scePthreadMutexUnlock(_mutex);
	}

#elif RPROF_PLATFORM_POSIX
	typedef pthread_mutex_t rprof_mutex;

	static inline void rprof_mutex_init(rprof_mutex* _mutex) {
		pthread_mutex_init(_mutex, NULL);
	}

	static inline void rprof_mutex_destroy(rprof_mutex* _mutex) {
		pthread_mutex_destroy(_mutex);
	}

	static inline void rprof_mutex_lock(rprof_mutex* _mutex) {
		pthread_mutex_lock(_mutex);
	}

	static inline int rprof_mutex_trylock(rprof_mutex* _mutex) {
		return pthread_mutex_trylock(_mutex);
	}

	static inline void rprof_mutex_unlock(rprof_mutex* _mutex) {
		pthread_mutex_unlock(_mutex);
	}

#endif

	class Mutex
	{
		rprof_mutex m_mutex;

		Mutex(const Mutex& _rhs);
		Mutex& operator=(const Mutex& _rhs);
		
	public:

		inline Mutex()
		{
			rprof_mutex_init(&m_mutex);
		}

		inline ~Mutex() 
		{
			rprof_mutex_destroy(&m_mutex);
		}

		inline void lock()
		{
			rprof_mutex_lock(&m_mutex);
		}

		inline void unlock()
		{
			rprof_mutex_unlock(&m_mutex);
		}

		inline bool tryLock()
		{
			return (rprof_mutex_trylock(&m_mutex) == 0);
		}
	};

	class ScopedMutexLocker
	{
		Mutex& m_mutex;

		ScopedMutexLocker();
		ScopedMutexLocker(const ScopedMutexLocker&);
		ScopedMutexLocker& operator = (const ScopedMutexLocker&);

	public:

		inline ScopedMutexLocker(Mutex& _mutex) :
			m_mutex(_mutex)
		{
			m_mutex.lock();
		}

		inline ~ScopedMutexLocker()
		{
			m_mutex.unlock();
		}
	};

} // namespace rprof

#endif // RPROF_MUTEX_H

```

`src/rprof_platform.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_PLATFORM_H
#define RPROF_PLATFORM_H

#include "../inc/rprof.h"
#include "rprof_config.h"

/*--------------------------------------------------------------------------
 * Platforms
 *------------------------------------------------------------------------*/
#define RPROF_PLATFORM_WINDOWS		0
#define RPROF_PLATFORM_LINUX		0
#define RPROF_PLATFORM_IOS			0
#define RPROF_PLATFORM_OSX			0
#define RPROF_PLATFORM_PS3			0
#define RPROF_PLATFORM_PS4			0
#define RPROF_PLATFORM_ANDROID		0
#define RPROF_PLATFORM_XBOXONE		0
#define RPROF_PLATFORM_EMSCRIPTEN	0
#define RPROF_PLATFORM_SWITCH		0

/*--------------------------------------------------------------------------
 * Detect platform
 *------------------------------------------------------------------------*/
#if defined(_DURANGO) || defined(_XBOX_ONE)
#undef  RPROF_PLATFORM_XBOXONE
#define RPROF_PLATFORM_XBOXONE		1
#elif defined(_WIN32) || defined(_WIN64) || defined(__WINDOWS__)
#undef  RPROF_PLATFORM_WINDOWS
#define RPROF_PLATFORM_WINDOWS		1
#elif defined(__ANDROID__)
#undef  RPROF_PLATFORM_ANDROID
#define RPROF_PLATFORM_ANDROID		1
#elif defined(__linux__) || defined(linux)
#undef  RPROF_PLATFORM_LINUX
#define RPROF_PLATFORM_LINUX		1
#elif defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__)
#undef  RPROF_PLATFORM_IOS
#define RPROF_PLATFORM_IOS			1
#elif defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
#undef  RPROF_PLATFORM_OSX
#define RPROF_PLATFORM_OSX			1
#elif defined(__CELLOS_LV2__)
#undef  RPROF_PLATFORM_PS3
#define RPROF_PLATFORM_PS3			1
#elif defined(__ORBIS__)
#undef  RPROF_PLATFORM_PS4
#define RPROF_PLATFORM_PS4			1
#elif defined(__EMSCRIPTEN__)
#undef  RPROF_PLATFORM_EMSCRIPTEN
#define RPROF_PLATFORM_EMSCRIPTEN	1
#elif defined(__NINTENDO__)
#undef  RPROF_PLATFORM_SWITCH
#define RPROF_PLATFORM_SWITCH		1
#else
#error "Platform not supported!"
#endif

#define RPROF_PLATFORM_POSIX (	RPROF_PLATFORM_LINUX		|| \
								RPROF_PLATFORM_OSX			|| \
								RPROF_PLATFORM_ANDROID		|| \
								RPROF_PLATFORM_IOS			|| \
								RPROF_PLATFORM_PS4			|| \
								RPROF_PLATFORM_EMSCRIPTEN	|| \
								RPROF_PLATFORM_SWITCH		|| \
								0) 

/*--------------------------------------------------------------------------
 * Platform specific headers
 *------------------------------------------------------------------------*/
#if RPROF_PLATFORM_XBOXONE
	#include <windows.h>
#elif RPROF_PLATFORM_WINDOWS
	#define WINDOWS_LEAN_AND_MEAN
	#ifndef _WIN32_WINNT
		#define _WIN32_WINNT 0x601
	#endif
	#include <windows.h>
#elif RPROF_PLATFORM_PS3
	#include <sys/ppu_thread.h>
	#include <sys/sys_time.h>
#elif RPROF_PLATFORM_PS4
	#define _SYS__STDINT_H_
	#include <kernel.h>
#elif RPROF_PLATFORM_ANDROID
	#include <pthread.h>
	#include <time.h>
#elif RPROF_PLATFORM_EMSCRIPTEN
	#include <pthread.h>
	#include <time.h>
	#include <emscripten.h>
#elif RPROF_PLATFORM_SWITCH
	#include <pthread.h>
	#include <nn/os/os_Tick.h>
#elif RPROF_PLATFORM_POSIX
       #if RPROF_PLATFORM_LINUX
               #include <sys/syscall.h>
       #endif
	#include <unistd.h>	 // syscall
	#include <pthread.h>
	#include <sys/time.h>
#else
	#error "Unsupported platform!"
#endif

/*--------------------------------------------------------------------------*/
static inline uint64_t getThreadID()
{
#if RPROF_PLATFORM_WINDOWS || RPROF_PLATFORM_XBOXONE
	return (uint64_t)GetCurrentThreadId();
#elif RPROF_PLATFORM_LINUX
	return (uint64_t)syscall(SYS_gettid);
#elif RPROF_PLATFORM_IOS || RPROF_PLATFORM_OSX
	return (mach_port_t)::pthread_mach_thread_np(pthread_self() );
#elif RPROF_PLATFORM_PS3
	sys_ppu_thread_t tid;
	sys_ppu_thread_get_id(&tid);
	return (uint64_t)tid;
#elif RPROF_PLATFORM_PS4
	return (uint64_t)scePthreadSelf();
#elif RPROF_PLATFORM_ANDROID || RPROF_PLATFORM_EMSCRIPTEN || RPROF_PLATFORM_SWITCH
	return pthread_self();
#else
	#error "Unsupported platform!"
#endif
}

/*--------------------------------------------------------------------------*/
static inline uint8_t getPlatformID()
{
#if   RPROF_PLATFORM_WINDOWS
	return 1;
#elif RPROF_PLATFORM_LINUX
	return 2;
#elif RPROF_PLATFORM_IOS
	return 3;
#elif RPROF_PLATFORM_OSX
	return 4;
#elif RPROF_PLATFORM_PS3
	return 5;
#elif RPROF_PLATFORM_PS4
	return 6;
#elif RPROF_PLATFORM_ANDROID
	return 7;
#elif RPROF_PLATFORM_XBOXONE
	return 8;
#elif RPROF_PLATFORM_EMSCRIPTEN
	return 9;
#elif RPROF_PLATFORM_SWITCH
	return 10;
#else
	return 0xff;
#endif
}

/*--------------------------------------------------------------------------*/
static inline const char* getPlatformName(uint8_t _platformID)
{
	switch (_platformID)
	{
	case  1: return "Windows";
	case  2: return "Linux";
	case  3: return "iOS";
	case  4: return "OSX";
	case  5: return "PlayStation 3";
	case  6: return "PlayStation 4";
	case  7: return "Android";
	case  8: return "XboxOne";
	case  9: return "WebGL";
	case 10: return "Nintendo Switch";
	default: return "Unknown platform";
	};
}

#endif // RPROF_PLATFORM_H

```

`src/rprof_tls.h`:

```h
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef RPROF_TLS_H
#define RPROF_TLS_H

#include "../inc/rprof.h"
#include "rprof_config.h"

namespace rprof {

#if RPROF_PLATFORM_WINDOWS || RPROF_PLATFORM_XBOXONE

	static inline uint32_t tlsAllocate()
	{
		return (uint32_t)TlsAlloc();
	}

	static inline void tlsSetValue(uint32_t _handle, void* _value)
	{
		TlsSetValue(_handle, _value);
	}

	static inline void* tlsGetValue(uint32_t _handle)
	{
		return TlsGetValue(_handle);
	}

	static inline void tlsFree(uint32_t _handle)
	{
		TlsFree(_handle);
	}

#elif RPROF_PLATFORM_PS4

	static inline uint32_t tlsAllocate()
	{
		ScePthreadKey handle;
		scePthreadKeyCreate(&handle, 0);
		return handle;
	}

	static inline void tlsSetValue(uint32_t _handle, void* _value)
	{
		scePthreadSetspecific(_handle, _value);
	}

	static inline void* tlsGetValue(uint32_t _handle)
	{
		return scePthreadGetspecific(_handle);
	}

	static inline void tlsFree(uint32_t _handle)
	{
		scePthreadKeyDelete(_handle);
	}

#elif RPROF_PLATFORM_POSIX

	static inline uint32_t tlsAllocate()
	{
		uint32_t handle;
		pthread_key_create((pthread_key_t*)&handle, 0);
		return handle;
	}

	static inline void tlsSetValue(uint32_t _handle, void* _value)
	{
		pthread_setspecific(_handle, _value);
	}

	static inline void* tlsGetValue(uint32_t _handle)
	{
		return pthread_getspecific(_handle);
	}

	static inline void tlsFree(uint32_t _handle)
	{
		pthread_key_delete(_handle);
	}

#else
	#error "Unsupported platform!"
#endif

} // namespace rprof

#endif // RPROF_TLS_H

```

`tools/rprof_inspector/Makefile`:

```

CXX = emcc
OUTPUT = rprof.js

SOURCES = main.cpp
SOURCES += ../../3rd/imgui/imgui.cpp
SOURCES += ../../3rd/imgui/imgui_draw.cpp
SOURCES += ../../3rd/imgui/imgui_tables.cpp
SOURCES += ../../3rd/imgui/imgui_widgets.cpp 
SOURCES += ../../3rd/imgui/backends/imgui_impl_glfw.cpp
SOURCES += ../../3rd/imgui/backends/imgui_impl_opengl3.cpp
SOURCES += ../../3rd/implot/implot.cpp
SOURCES += ../../3rd/implot/implot_items.cpp
SOURCES += ../../src/rprof_context.cpp 
SOURCES += ../../src/rprof_freelist.cpp 
SOURCES += ../../src/rprof_lib.cpp 

INCLUDES = -I../../3rd/imgui -I../../3rd/implot
#LIBS = -lGL
LIBS = -lGL-webgl2-full_es3-getprocaddr
WEBGL_VER = -s USE_WEBGL2=1 -s USE_GLFW=3 -s FULL_ES3=1
FILE_SYSTEM = -s FORCE_FILESYSTEM=1 -s ASYNCIFY=1 --memory-init-file 0 -DIMGUI_DISABLE_DEBUG_TOOLS 
USE_WASM = -s WASM=1

PROJECTS :=  gui

GUI: 
	$(CXX)  $(SOURCES) -o $(OUTPUT) $(LIBS) $(WEBGL_VER) $(FILE_SYSTEM) $(INCLUDES) -O2 --no-heap-copy -s ALLOW_MEMORY_GROWTH=1 --preload-file data $(USE_WASM) -sASSERTIONS 

all: $(GUI)

clean:
	rm -f $(OUTPUT)

```

`tools/rprof_inspector/main.cpp`:

```cpp
/*
 * Copyright 2025 Milos Tosic. All Rights Reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <vector>
#include <algorithm>

#ifdef __EMSCRIPTEN__
#include <emscripten.h>

#define GLFW_INCLUDE_ES3
#include <GLFW/glfw3.h>
#include <GLES3/gl3.h>
#include "imgui.h"
#include "misc/freetype/imgui_freetype.h"
#include "backends/imgui_impl_glfw.h"
#include "backends/imgui_impl_opengl3.h"
#include "implot.h"
#include "../../3rd/lz4-r191/lz4.h"

#include "../../inc/rprof.h"
#include "../../inc/rprof_imgui.h"
#include "../../src/rprof_config.h"

#if RPROF_LZ4_NO_DEFINE
#include "../../3rd/lz4-r191/lz4.c"
#endif

EM_JS(int,	canvas_get_width, (),	{ return Module.canvas.width; });
EM_JS(int,	canvas_get_height, (),	{ return Module.canvas.height; });
EM_JS(void,	resizeCanvas, (),		{ js_resizeCanvas(); });

struct FrameInfo
{
	float		m_time;
	uint32_t	m_offset;
	uint32_t	m_size;
};

GLFWwindow*				g_window;
ImGuiContext*			g_imgui = 0;
ImPlotContext*			g_plot = 0;
int						g_multi = -1;
ProfilerFrame			g_frame;
char					g_fileName[1024];
std::vector<FrameInfo>	g_frameInfos;

struct SortFrameInfoChrono
{
	bool operator()(const FrameInfo& a, const FrameInfo& b) const
	{
		if (a.m_offset < b.m_offset) return true;
		return false;
	}
} customChrono;

struct SortFrameInfoDesc
{
	bool operator()(const FrameInfo& a, const FrameInfo& b) const
	{
		if (a.m_time > b.m_time) return true;
		return false;
	}
} customDesc;

struct SortFrameInfoAsc
{
	bool operator()(const FrameInfo& a, const FrameInfo& b) const
	{
		if (a.m_time < b.m_time) return true;
		return false;
	}
} customAsc;

void profilerFrameLoad(const char* _name, uint32_t _offset = 0, uint32_t _size = 0);

void rprofDrawTutorial(bool _multi)
{
	ImGui::SetNextWindowPos(ImVec2(6.0f, _multi ? 630.0f : 500.0f), ImGuiCond_FirstUseEver);
	ImGui::SetNextWindowSize(ImVec2(900.0f, 330.0f), ImGuiCond_FirstUseEver);

	ImGui::Begin("Usage instructions");
	ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Hovering scopes");
	ImGui::Separator();
	ImGui::Text("Hovering a scope will display additional information about the scope (file, line and time).");
	ImGui::Text("Scpoes in 'Frame stats' are cumulative and will show number of occurences and frame time percentage in addition.");
	ImGui::NewLine();
	ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Zooming and panning");
	ImGui::Separator();
	ImGui::Text("Zoom in and zoom out of 'Frame inspector' is done using 'a' and 'z' keys.");
	ImGui::Text("Zooming is centered around the mouse X axis and mouse must be hovering the 'Frame inspector'.");
	ImGui::Text("Paning is can be done on a zoomed in 'Frame inspector' by holding down CTRL key and moving mouse left/right.");
	ImGui::NewLine();
	ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Clicking on scopes");
	ImGui::Separator();
	ImGui::Text("Clicking on a scope will highlight a scope (or all matching scopes) with the same name.");
	ImGui::Text("This helps to locate all occurences of a scope in a frame.");
	ImGui::NewLine();
	ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Multi frame view");
	ImGui::Separator();
	ImGui::Text("If capture is multi-frame, a 'Frame navigator' window will appear.");
	ImGui::Text("Clicking on a frame will load the profiling data for that particular frame.");

	ImGui::End();
}

void Demo_LinePlots() {
	static float xs1[1001], ys1[1001];
	for (int i = 0; i < 1001; ++i) {
		xs1[i] = i * 0.001f;
		ys1[i] = 0.5f + 0.5f * sinf(50 * (xs1[i] + (float)ImGui::GetTime() / 10));
	}
	static double xs2[20], ys2[20];
	for (int i = 0; i < 20; ++i) {
		xs2[i] = i * 1 / 19.0f;
		ys2[i] = xs2[i] * xs2[i];
	}
	if (ImPlot::BeginPlot("Line Plots")) {
		ImPlot::SetupAxes("x", "y");
		ImPlot::PlotLine("f(x)", xs1, ys1, 1001);
		ImPlot::SetNextMarkerStyle(ImPlotMarker_Circle);
		ImPlot::PlotLine("g(x)", xs2, ys2, 20, ImPlotLineFlags_Segments);
		ImPlot::EndPlot();
	}
}

void rprofDrawFrameNavigation(FrameInfo* _infos, uint32_t _numInfos)
{
	ImGui::SetNextWindowPos(ImVec2(6.0f, 6.0f), ImGuiCond_FirstUseEver);
	ImGui::SetNextWindowSize(ImVec2(1510.0f, 140.0f), ImGuiCond_FirstUseEver);

	ImGui::Begin("Frame navigator", 0, ImGuiWindowFlags_NoScrollbar);

	static int sortKind = 0;
	ImGui::Text("Sort frames by:  ");
	ImGui::SameLine();
	ImGui::RadioButton("Number", &sortKind, 0);
	ImGui::SameLine();
	ImGui::RadioButton("Descending", &sortKind, 1);
	ImGui::SameLine();
	ImGui::RadioButton("Ascending", &sortKind, 2);
	ImGui::Separator();

	switch (sortKind)
	{
	case 0:
		std::sort(&_infos[0], &_infos[_numInfos], customChrono);
		break;

	case 1:
		std::sort(&_infos[0], &_infos[_numInfos], customDesc);
		break;

	case 2:
		std::sort(&_infos[0], &_infos[_numInfos], customAsc);
		break;
	};

	float maxTime = 0;
	for (uint32_t i=0; i<_numInfos; ++i)
	{
		if (maxTime < _infos[i].m_time)
			maxTime = _infos[i].m_time;
	}

	const ImVec2 s = ImGui::GetWindowSize();
	const ImVec2 p = ImGui::GetWindowPos();

	ImGui::BeginChild("##Child", ImVec2(s.x, 70), false, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);

	int idx = 0;	// TODO: Fetch hovered/clicked index from histogram
	ImGui::PlotHistogram("##Hist", (const float*)_infos, _numInfos, 0, "", 0.f, maxTime, ImVec2(_numInfos * 10, 50), sizeof(FrameInfo));

	if (ImGui::IsMouseClicked(0) && (idx != -1))
	{
		profilerFrameLoad(g_fileName, _infos[idx].m_offset, _infos[idx].m_size);
	}

	ImGui::EndChild();

	ImGui::End();
}

int init()
{
	if( !glfwInit() )
	{
		fprintf( stderr, "Failed to initialize GLFW\n" );
		return 1;
	}

	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // We don't want the old OpenGL
																   // Open a window and create its OpenGL context
	int canvasWidth = 800;
	int canvasHeight = 600;
	g_window = glfwCreateWindow( canvasWidth, canvasHeight, "rprof CPU profiler", NULL, NULL);
	if( g_window == NULL )
	{
		fprintf( stderr, "Failed to open GLFW window.\n" );
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(g_window); // Initialize GLEW

	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO();

	ImGui_ImplGlfw_InitForOpenGL(g_window, true);
	ImGui_ImplGlfw_InstallEmscriptenCallbacks(g_window, "#canvas");
	ImGui_ImplOpenGL3_Init();

	ImGui::StyleColorsDark();

	io.Fonts->AddFontDefault();

	g_imgui = ImGui::GetCurrentContext();
	g_plot	= ImPlot::CreateContext();

	glfwSetMouseButtonCallback(g_window, ImGui_ImplGlfw_MouseButtonCallback);
	glfwSetScrollCallback(g_window, ImGui_ImplGlfw_ScrollCallback);
	glfwSetKeyCallback(g_window, ImGui_ImplGlfw_KeyCallback);
	glfwSetCharCallback(g_window, ImGui_ImplGlfw_CharCallback);

	resizeCanvas();

	return 0;
}

void quit()
{
	rprofRelease(&g_frame);
	glfwTerminate();
}

void profilerFrameLoad(const char* _name, uint32_t _offset, uint32_t _size)
{
	FILE* file = fopen(_name, "rb");
	if (file)
	{
		long csize = _size;

		if (!csize)
		{
			fseek(file, 0, SEEK_END);
			csize = ftell(file);
			fseek(file, 0, SEEK_SET);
		}
		else
			fseek(file, _offset + 4, SEEK_SET);

		static const size_t maxDecompSize = 4 * 1024 * 1024;
		char* compBuffer = (char*)malloc(csize);
		char* decompBuffer = (char*)malloc(maxDecompSize);
		char* bufferReadPtr = decompBuffer;

		fread(compBuffer, 1, csize, file);
		rprofLoad(&g_frame, compBuffer, csize);
		free(decompBuffer);
		free(compBuffer);

		fclose(file);
	}
}

void profilerFrameLoadMulti(const char* _name)
{
	strcpy(g_fileName, _name);
	FILE* file = fopen(_name, "rb");
	if (file)
	{
		fseek(file, 0, SEEK_END);
		long fileSize = ftell(file);
		fseek(file, 0, SEEK_SET);

		uint8_t* fileBuffer = (uint8_t*)malloc(fileSize);
		fread(fileBuffer, 1, fileSize, file);
		fclose(file);

		uint32_t offset = 4;
		while (offset < (uint32_t)fileSize)
		{
			FrameInfo info;
			info.m_offset = offset;

			uint32_t frameSize = *reinterpret_cast<uint32_t*>(&fileBuffer[offset]);
			offset += 4;

			rprofLoadTimeOnly(&info.m_time, &fileBuffer[offset], frameSize);

			info.m_size = frameSize;
			g_frameInfos.push_back(info);															

			rprofRelease(&g_frame);
			offset += frameSize;
		}
	}

	profilerFrameLoad(g_fileName, g_frameInfos[0].m_offset, g_frameInfos[0].m_size);
}

void profilerFrameLoadCallback(const char* _name)
{
	FILE* file = fopen(_name, "rb");
	if (file)
	{
		uint32_t sig;
		fread(&sig, 1, 4, file);
		fclose(file);

		g_multi = sig == 0x23232323 ? 1 : 0;

		if (g_multi)
			profilerFrameLoadMulti(_name);
		else
			profilerFrameLoad(_name);
	}
}

void profilerFrameLoadError(const char* _name)
{
	printf("ERROR: Failed to load capture!");
}

void frameInspector();

void loop()
{
	int width = canvas_get_width();
	int height = canvas_get_height();

	glfwSetWindowSize(g_window, width, height);

	ImGui::SetCurrentContext(g_imgui);

	ImGui_ImplGlfw_NewFrame();
	ImGui_ImplOpenGL3_NewFrame();
	ImGui::NewFrame();

	if (g_multi != -1)
	{
		rprofDrawTutorial(g_multi == 1);

		if (g_multi)
			rprofDrawFrameNavigation(g_frameInfos.data(), g_frameInfos.size());

		rprofDrawFrame(&g_frame, 0, 0, false, g_multi == 1);

		rprofDrawStats(&g_frame, g_multi == 1);
	}

	ImGui::Render();

	int display_w, display_h;
	glfwMakeContextCurrent(g_window);
	glfwGetFramebufferSize(g_window, &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClearColor(0.21568f, 0.21568f, 0.34902f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT);

	ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
	glfwMakeContextCurrent(g_window);
}

extern "C" int main(int argc, char** argv)
{
	if (init() != 0) return 1;
#ifdef __EMSCRIPTEN__

	// path to capture passed via URL query, arguments are 'path' and 'file'
	// http://localhost/profile_inspector/imgui.html?path=http://localhost/profile_inspector/&file=capture.rprof

	char pathBuffer[1024];
	strcpy(pathBuffer,argv[1]);
	strcat(pathBuffer,argv[2]);

	printf("Path: %s\n", argv[1]);
	printf("File: %s\n", argv[2]);
	printf("Downloading %s\n", pathBuffer);

	emscripten_async_wget(pathBuffer, argv[2], profilerFrameLoadCallback, profilerFrameLoadError);

	printf("Download completed\n");

	emscripten_set_main_loop(loop, 0, 1);
#endif
	quit();
	return 0;
}

#else	//  __EMSCRIPTEN__
int main()
{
	return 0;
}
#endif	//  __EMSCRIPTEN__

```

`tools/rprof_inspector/rprof.html`:

```html
<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>rprof browser inspector</title>
    <style>
      body {
        font-family: arial;
        margin: 0;
        padding: none;
      }
      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      div.emscripten { text-align: center; }
      div.emscripten_border { border: none; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { border: 0px none; }
    </style>
  </head>
  <body>

    <div class="emscripten_border">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
    </div>

    <script type='text/javascript'>
      const params = new URLSearchParams(new URL(window.location).search)
      var capturePath = params.get('path') ? params.get('path') : 'localhost/';
	  var captureFile = params.get('file') ? params.get('file') : 'capture.rprof';
      var Module = {
		arguments: [capturePath, captureFile],
        preRun: [],
        postRun: [],
        print: (function() {})(),
        printErr: function(text) {},
        canvas: (function() {
          var canvas = document.getElementById('canvas');
          // As a default initial behavior, pop up an alert when webgl context is lost. To make your
          // application robust, you may want to override this behavior before shipping!
          // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
          canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);
          return canvas;
        })(),
        setStatus: function(text) {},
        totalDependencies: 0,
        monitorRunDependencies: function(left) {}
      };
      window.addEventListener('resize', js_resizeCanvas, false);
      function js_resizeCanvas() {
            document.getElementById('canvas').width = window.innerWidth;
            document.getElementById('canvas').height = window.innerHeight;
      }

    </script>
    <script async type="text/javascript" src="rprof.js"></script>
  </body>
</html>

```