Project Path: arc_HexRaysSA_ida-claude-code-plugins_4qjvfecl

Source Tree:

```txt
arc_HexRaysSA_ida-claude-code-plugins_4qjvfecl
├── LICENSE
├── README.md
└── plugins
    ├── code-eval-ida-domain
    │   ├── LICENSE
    │   ├── README.md
    │   ├── agents
    │   │   └── ida-domain-expert.md
    │   ├── commands
    │   │   └── ida-domain-skill
    │   │       └── bootstrap.md
    │   └── skills
    │       └── ida-domain-scripting
    │           ├── API_REFERENCE.md
    │           ├── SKILL.md
    │           ├── pyproject.toml
    │           ├── run.py
    │           └── setup.py
    └── ida-plugin-development
        ├── LICENSE
        ├── README.md
        └── skills
            ├── ida-domain-api
            │   └── SKILL.md
            ├── ida-plugin-development
            │   ├── SKILL.md
            │   └── scripts
            │       └── hcli-package.py
            └── package-ida-plugin
                └── SKILL.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2026 Hex-Rays SA

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Claude Code Resources for IDA Pro

Claude Code plugins and skills for IDA Pro reverse engineering workflows. These plugins enable Claude to autonomously create IDA Pro plugins and execute binary analysis scripts.

## [ida-plugin-development](plugins/ida-plugin-development/README.md)

Develop plugins for IDA Pro in Python, using idiomatic patterns, lessons, and tricks.


## (unsafe) [reverse-engineering-with-code-eval-and-ida-domain](plugins/code-eval-ida-domain/README.md)

> warning: this plugin generates and evaluates code on the current system, so it should only be used in a sandboxed environment.

(Unsafe) Skills, knowledge, and scripts for reverse engineering with IDA Pro. Autonomously writes and executes IDA Domain scripts to analyze binaries, extract functions, decompile code, and automate any reverse engineering task.

## Installation

```bash
/plugin marketplace add HexRaysSA/ida-claude-plugins
/plugin install ida-plugin-development@ida-claude-plugins
# unsafe: /plugin install reverse-engineering-with-code-eval-and-ida-domain@ida-claude-plugins
```

## Requirements

- IDA Pro 9.x
- `uv` package manager

## License

MIT License - Copyright 2026 Hex-Rays SA

```

`plugins/code-eval-ida-domain/LICENSE`:

```
MIT License

Copyright (c) 2026 Hex-Rays SA

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`plugins/code-eval-ida-domain/README.md`:

```md
# (unsafe) Reverse Engineering with Code Evaluation and the IDA Domain API

> warning: this plugin generates and evaluates code on the current system, so it should only be used in a sandboxed environment.

Analyze binaries using IDA Pro's Python Domain API (ida-domain) in headless mode (idalib). Use when examining program structure, functions, disassembly, cross-references, or strings without the GUI.

Provides:
- agent `ida-domain-expert`: Senior IDA Domain Python developer and IDA Pro reverse engineer. Use proactively when writing IDA Domain scripts, debugging IDA API issues, analyzing binary analysis problems, or when the user needs expert guidance on reverse engineering tasks with IDA Pro.
- skill `ida-domain-scripting`: Write and execute Python scripts using the IDA Domain API for reverse engineering. Analyze binaries, extract functions, strings, cross-references, decompile code, work with IDA Pro databases (.i64/.idb). Use when user wants to analyze binaries, reverse engineer executables, or automate IDA Pro tasks.

## Installation

```bash
/plugin marketplace add HexRaysSA/ida-claude-plugins
/plugin install reverse-engineering-with-code-eval-and-ida-domain@ida-claude-plugins
```

## License

MIT License - see [LICENSE](LICENSE) file for details.

```

`plugins/code-eval-ida-domain/agents/ida-domain-expert.md`:

```md
---
name: ida-domain-expert
description: Senior IDA Domain Python developer and IDA Pro reverse engineer. Use proactively when writing IDA Domain scripts, debugging IDA API issues, analyzing binary analysis problems, or when the user needs expert guidance on reverse engineering tasks with IDA Pro.
tools: Read, Grep, Glob, Bash
model: inherit
---

You are a Senior Python Developer and Expert Reverse Engineer with 15+ years of experience in IDA Pro scripting and
binary analysis. You specialize in the IDA Domain API and have deep knowledge of IDAPython internals.

## Your Expertise

- **IDA Domain API**: Complete mastery of the ida-domain library, its patterns, and best practices
- **Reverse Engineering**: Malware analysis, vulnerability research, firmware analysis, code deobfuscation
- **Binary Formats**: PE, ELF, Mach-O, firmware images, raw binaries
- **Architectures**: x86, x64, ARM, ARM64, MIPS, and processor-specific quirks
- **Python Best Practices**: Clean, efficient, well-documented code with proper error handling

**IMPORTANT - Path Resolution:**
You are to use the ida-domain-scripting skill. It can be installed in different locations. Before executing any
commands, determine the skill directory based on where you loaded this SKILL.md file, and use that path in all commands
below. Replace `$SKILL_DIR` with the actual
discovered path.

Common installation paths:

- Project-specific: `<project>/.claude/skills/ida-domain-scripting`
- Manual global: `~/.claude/skills/ida-domain-scripting`

## Critical Context

Before writing any IDA Domain code, you MUST read the API reference:

- **API Reference**: `skills/ida-domain-scripting/API_REFERENCE.md`

This file contains the complete, authoritative API documentation. Always verify method signatures and patterns against
this reference.

## Your Approach

1. **Understand First**: Ask clarifying questions about the binary type, analysis goals, and expected output format
   before writing code
2. **Read the API**: Always consult API_REFERENCE.md before writing code to ensure correct method signatures
3. **Write Clean Code**: Produce production-quality Python with proper error handling, type hints where helpful, and
   clear comments
4. **Explain Your Reasoning**: Share your reverse engineering thought process and why you chose specific approaches
5. **Validate Assumptions**: Check if functions/addresses exist before operating on them
6. **Handle Edge Cases**: Anticipate decompilation failures, missing symbols, and malformed data

## Common Patterns You Know Well

### Database Access

```python
# The db object is always available in wrapped scripts
db.analysis.wait()  # Always wait for analysis before querying
```

### Function Iteration

```python
for func in db.functions:
    name = db.functions.get_name(func)  # Call on db.functions, not func
    callers = db.functions.get_callers(func)
```

### Cross-References

```python
for xref in db.xrefs.to_ea(addr):  # NOT get_xrefs_to()
    print(f"From 0x{xref.from_ea:x}")
```

### Safe Decompilation

```python
try:
    lines = db.functions.get_pseudocode(func)
    print("\n".join(lines))
except RuntimeError as e:
    print(f"Decompilation failed: {e}")
```

### Safe String Handling

```python
for s in db.strings:
    try:
        content = str(s)
    except (UnicodeDecodeError, Exception):
        continue  # Skip problematic strings
```

## Anti-Patterns You Avoid

- **Never** call methods directly on func objects: `func.get_callers()` is WRONG
- **Never** use `db.xrefs.get_xrefs_to()` - use `db.xrefs.to_ea()` instead
- **Never** assume decompilation will succeed - always wrap in try/except
- **Never** modify the database without explicit user confirmation
- **Never** hardcode addresses without validation

## Script Execution

Scripts are executed via:

```bash
cd $SKILL_DIR && uv run python run.py <script.py> -f <binary>
```

Where:

- `$SKILL_DIR` is `skills/ida-domain-scripting`
- Scripts are written to `/tmp/ida-domain-TIMESTAMP-<name>/script.py`
- The `db` variable is automatically available (no Database.open() needed)

## When Asked to Help

1. Read API_REFERENCE.md to verify the exact API signatures
2. Write clean, well-structured Python code
3. Include appropriate error handling
4. Explain what the code does and why
5. Suggest optimizations or alternative approaches when relevant
6. Warn about potential pitfalls (large binaries, slow operations, etc.)

## Your Communication Style

- Direct and technical, but approachable
- Share insights from your "experience" in reverse engineering
- Proactively identify potential issues before they become problems
- Offer multiple solutions when trade-offs exist
- Always prioritize correctness over cleverness
   

```

`plugins/code-eval-ida-domain/commands/ida-domain-skill/bootstrap.md`:

```md
---
description: Generate API_REFERENCE.md from ida-domain source code
allowed-tools: Bash(find:*), Bash(grep:*), Bash(wc:*), Read, Write, Glob, Grep
---

# Bootstrap: Generate API_REFERENCE.md

You are generating a **hand-written style** API quick reference for the IDA Domain skill.

**IMPORTANT - Path Resolution:**
This skill can be installed in different locations. Before executing any commands, determine the skill directory based on where you loaded this command file, and use that path in all commands below. Replace `$SKILL_DIR` with the actual discovered path.

Common installation paths:
- Project-specific: `<project>/.claude/skills/ida-domain-scripting`
- Manual global: `~/.claude/skills/ida-domain-scripting`

## Context

The ida-domain source code is checked out at: `$SKILL_DIR/ida-domain/`

## Your Task

1. **Explore the ida-domain source code** in `$SKILL_DIR/ida-domain/ida_domain/`
2. **Identify the main classes and their key methods** by reading the Python files
3. **Launch one sub agent per python file** to avoid filling up the context and summarize
3. **Generate `API_REFERENCE.md`** in the skill root directory

## Output Format (API_REFERENCE.md)

Follow this structure - similar to playwright's API_REFERENCE.md (practical, pattern-focused, ~500-800 lines max):

```markdown
# IDA Domain Quick Reference

Quick reference for the IDA Domain API. For basic usage, see [SKILL.md](SKILL.md).

## Table of Contents
[Generate dynamically based on discovered entities]

## Database

### Database Properties
[table of properties discovered from database.py: db.module, db.path, db.architecture, etc.]

## [Entity Name]

### Iterating
[code example if the entity is iterable]

### Key Methods
[code examples for the most important methods]

### Properties
[table of properties if applicable]

... repeat for each entity discovered from database.py

## Enums

### [EnumName]
[table of enum values with descriptions]


```python
# Usage example
from ida_domain.xrefs import XrefType
if xref.type == XrefType.CALL_NEAR:
    print("This is a call")
```

... repeat for each enum discovered except hooks.py
```

## Guidelines

1. **Be practical** - Show how to DO things, not just what exists
2. **Use code examples** - Every section should have runnable code
3. **Document the gotchas** - Like `db.xrefs.to_ea()` not `get_xrefs_to()`
4. **Keep it concise** - 500-800 lines max, not 18,000 lines
5. **Focus on wrapped scripts** - Assume `db` is available (auto-wrapped mode)
6. **Include return types** - What does each method return?
7. **Group by use-case** - Not alphabetically by class

## Process

1. **Discover the API structure:**
   - Use Glob to find all .py files in `$SKILL_DIR/ida-domain/ida_domain/`
   - Read `database.py` first to find all `@property` methods that return entity handlers (e.g., `def functions(self) -> Functions`)
   - These properties define what entities are available via `db.*`

2. **For each entity handler discovered:**
   - Read the corresponding .py file
   - Extract class name, public methods, and their signatures
   - Note the docstrings for method descriptions
   - Identify common usage patterns

3. **Extract all Enums:**
   - Search all .py files for classes that inherit from `Enum` (e.g., `class XrefType(Enum)`)
   - Document each enum with its values
   - Show how to use them in code examples

4. **Generate API_REFERENCE.md:**
   - Start with Database properties and metadata
   - Add a section for each entity handler found
   - Include an "Enums" section listing all discovered enums and their values
   - Include practical code examples
   - Document any non-obvious method names (e.g., `to_ea()` vs `get_xrefs_to()`)

Start by exploring the source code structure - read `database.py` to discover what entities exist.

```

`plugins/code-eval-ida-domain/skills/ida-domain-scripting/API_REFERENCE.md`:

```md
# IDA Domain Quick Reference

Quick reference for the IDA Domain API. For basic usage, see [SKILL.md](SKILL.md).

## Table of Contents

- [Database](#database)
- [Functions](#functions)
- [Instructions](#instructions)
- [Segments](#segments)
- [Strings](#strings)
- [Xrefs](#xrefs)
- [Names](#names)
- [Types](#types)
- [Bytes](#bytes)
- [Comments](#comments)
- [Entries](#entries)
- [Heads](#heads)
- [Flowchart](#flowchart)
- [Signature Files](#signature-files)
- [Enums Reference](#enums-reference)

---

## Database

The `Database` class is your entry point. Use `db` in auto-wrapped scripts.

### Opening a Database

```python
# Library mode: Open and automatically close
with Database.open("path/to/file.exe", save_on_close=True) as db:
    print(f"Loaded: {db.module}")

# IDA GUI mode: Get handle to current database
db = Database.open()
```

### Database Properties

| Property | Type | Description |
|----------|------|-------------|
| `db.path` | `str` | Input file path |
| `db.module` | `str` | Module name |
| `db.base_address` | `ea_t` | Image base address |
| `db.minimum_ea` | `ea_t` | Minimum effective address |
| `db.maximum_ea` | `ea_t` | Maximum effective address |
| `db.filesize` | `int` | Input file size |
| `db.md5` | `str` | MD5 hash of input file |
| `db.sha256` | `str` | SHA256 hash of input file |
| `db.architecture` | `str` | Processor architecture |
| `db.bitness` | `int` | Application bitness (32/64) |
| `db.format` | `str` | File format type |
| `db.execution_mode` | `ExecutionMode` | User or Kernel mode |
| `db.current_ea` | `ea_t` | Current screen EA (readable/writable) |
| `db.start_ip` | `ea_t` | Start instruction pointer |

### Database Methods

```python
db.is_valid_ea(ea, strict_check=True)  # Check if address is valid
db.is_open()                            # Check if database is loaded
db.execute_script(file_path)            # Execute a Python script
db.close(save=True)                     # Close database (library mode only)
```

### Entity Handlers

Access all IDA data through these handlers:

```python
db.functions      # Function operations
db.instructions   # Instruction operations
db.segments       # Segment operations
db.strings        # String operations
db.xrefs          # Cross-reference operations
db.names          # Name/symbol operations
db.types          # Type information operations
db.bytes          # Raw byte operations
db.comments       # Comment operations
db.entries        # Entry point operations
db.heads          # Head (item) operations
db.signature_files # FLIRT signature operations
```

---

## Functions

### Iterating Functions

```python
# Iterate all functions
for func in db.functions:
    print(db.functions.get_name(func))

# Get function count
count = len(db.functions)
```

### Finding Functions

```python
func = db.functions.get_at(0x401000)           # By address
func = db.functions.get_function_by_name("main")  # By name
func = db.functions.get_next(ea)               # Next function after ea

# Functions in range
for func in db.functions.get_between(start_ea, end_ea):
    print(func.start_ea)
```

### Function Properties

```python
name = db.functions.get_name(func)
signature = db.functions.get_signature(func)
flags = db.functions.get_flags(func)  # Returns FunctionFlags

# Check function attributes
db.functions.is_far(func)
db.functions.does_return(func)
```

### Function Code

```python
# Get disassembly lines
lines = db.functions.get_disassembly(func, remove_tags=True)

# Get decompiled pseudocode
pseudocode = db.functions.get_pseudocode(func, remove_tags=True)

# Get microcode
microcode = db.functions.get_microcode(func, remove_tags=True)
```

### Function Analysis

```python
# Get instructions in function
for insn in db.functions.get_instructions(func):
    print(insn.ea)

# Get flowchart for basic blocks
flowchart = db.functions.get_flowchart(func)
for block in flowchart:
    print(f"Block: {block.start_ea:#x} - {block.end_ea:#x}")

# Get callers/callees
callers = db.functions.get_callers(func)
callees = db.functions.get_callees(func)

# Get function chunks
for chunk in db.functions.get_chunks(func):
    print(f"Chunk: {chunk.start_ea:#x}, main={chunk.is_main}")

# Get data items within function
for data_ea in db.functions.get_data_items(func):
    print(f"Data at {data_ea:#x}")
```

### Local Variables

```python
# Get all local variables
lvars = db.functions.get_local_variables(func)
for lvar in lvars:
    print(f"{lvar.name}: {lvar.type_str}, arg={lvar.is_argument}")

# Find variable by name
lvar = db.functions.get_local_variable_by_name(func, "result")

# Get variable references in pseudocode
refs = db.functions.get_local_variable_references(func, lvar)
for ref in refs:
    print(f"Line {ref.line_number}: {ref.access_type} in {ref.context}")
```

### Modifying Functions

```python
db.functions.set_name(func, "new_name")
db.functions.set_comment(func, "This function does X", repeatable=False)
db.functions.create(ea)   # Create function at address
db.functions.remove(ea)   # Remove function at address
```

---

## Instructions

### Iterating Instructions

```python
# All instructions in database
for insn in db.instructions:
    print(db.instructions.get_disassembly(insn))

# Instructions in range
for insn in db.instructions.get_between(start_ea, end_ea):
    print(insn.ea)
```

### Getting Instructions

```python
insn = db.instructions.get_at(ea)          # Decode at address
insn = db.instructions.get_previous(ea)    # Previous instruction
```

### Instruction Properties

```python
disasm = db.instructions.get_disassembly(insn)
mnemonic = db.instructions.get_mnemonic(insn)  # "mov", "push", etc.
db.instructions.is_valid(insn)
```

### Control Flow Analysis

```python
db.instructions.is_call_instruction(insn)      # Is this a call?
db.instructions.is_indirect_jump_or_call(insn) # Indirect jump/call?
db.instructions.breaks_sequential_flow(insn)   # Stops flow (ret, jmp)?
```

### Working with Operands

```python
count = db.instructions.get_operands_count(insn)
operands = db.instructions.get_operands(insn)  # List of Operand objects

for op in operands:
    info = op.get_info()
    print(f"Operand {op.number}: {op.type.name}")

    if isinstance(op, RegisterOperand):
        print(f"  Register: {op.get_register_name()}")
    elif isinstance(op, ImmediateOperand):
        print(f"  Value: 0x{op.get_value():x}")
    elif isinstance(op, MemoryOperand):
        if op.is_direct_memory():
            print(f"  Memory: 0x{op.get_address():x}")
```

---

## Segments

### Iterating Segments

```python
for segment in db.segments:
    name = db.segments.get_name(segment)
    size = db.segments.get_size(segment)
    print(f"{name}: {segment.start_ea:#x} - {segment.end_ea:#x}")

count = len(db.segments)
```

### Finding Segments

```python
seg = db.segments.get_at(0x401000)      # Segment containing address
seg = db.segments.get_by_name(".text")  # By name
```

### Segment Properties

```python
name = db.segments.get_name(segment)
size = db.segments.get_size(segment)
bitness = db.segments.get_bitness(segment)  # 16, 32, or 64
seg_class = db.segments.get_class(segment)   # "CODE", "DATA", etc.
```

### Creating Segments

```python
from ida_domain.segments import PredefinedClass, AddSegmentFlags

# Add segment with explicit range
seg = db.segments.add(
    seg_para=0,
    start_ea=0x1000,
    end_ea=0x2000,
    seg_name="MySegment",
    seg_class=PredefinedClass.CODE
)

# Append segment after last one
seg = db.segments.append(seg_para=0, seg_size=0x1000, seg_name="NewSeg")
```

### Modifying Segments

```python
from ida_domain.segments import SegmentPermissions, AddressingMode

db.segments.set_name(segment, "new_name")
db.segments.set_permissions(segment, SegmentPermissions.READ | SegmentPermissions.EXEC)
db.segments.add_permissions(segment, SegmentPermissions.WRITE)
db.segments.remove_permissions(segment, SegmentPermissions.WRITE)
db.segments.set_addressing_mode(segment, AddressingMode.BIT64)
db.segments.set_comment(segment, "Code section", repeatable=False)
```

---

## Strings

### Iterating Strings

```python
for string in db.strings:
    print(f"{string.address:#x}: {string}")

# By index
first_string = db.strings[0]
count = len(db.strings)
```

### Finding Strings

```python
string = db.strings.get_at(0x402000)  # String at address

# Strings in range
for s in db.strings.get_between(start_ea, end_ea):
    print(s.contents)
```

### String Properties

```python
print(string.address)       # Address
print(string.length)        # Length in characters
print(string.type)          # StringType enum
print(string.encoding)      # Internal encoding
print(string.contents)      # UTF-8 bytes
print(str(string))          # Decoded string
```

### Rebuilding String List

```python
from ida_domain.strings import StringListConfig, StringType

config = StringListConfig(
    string_types=[StringType.C, StringType.C_16],
    min_len=3,
    only_ascii_7bit=False
)
db.strings.rebuild(config)
db.strings.clear()  # Clear string list
```

---

## Xrefs

### Getting References TO an Address

```python
# All xrefs to an address
for xref in db.xrefs.to_ea(target_ea):
    print(f"{xref.from_ea:#x} -> {xref.to_ea:#x} ({xref.type.name})")

# Just code references
for ea in db.xrefs.code_refs_to_ea(target_ea, flow=False):
    print(f"Code ref from {ea:#x}")

# Just data references
for ea in db.xrefs.data_refs_to_ea(target_ea):
    print(f"Data ref from {ea:#x}")

# Call references only
for ea in db.xrefs.calls_to_ea(func_ea):
    print(f"Called from {ea:#x}")

# Detailed caller information
for caller in db.xrefs.get_callers(func_ea):
    print(f"Called from {caller.name} at {caller.ea:#x}")
```

### Getting References FROM an Address

```python
# All xrefs from an address
for xref in db.xrefs.from_ea(source_ea):
    print(f"{xref.from_ea:#x} -> {xref.to_ea:#x}")

# Code/data refs from
for ea in db.xrefs.code_refs_from_ea(source_ea):
    print(f"Code ref to {ea:#x}")

for ea in db.xrefs.calls_from_ea(source_ea):
    print(f"Calls {ea:#x}")
```

### Data Access Analysis

```python
# Who reads this data?
for ea in db.xrefs.reads_of_ea(data_ea):
    print(f"Read by {ea:#x}")

# Who writes to this data?
for ea in db.xrefs.writes_to_ea(data_ea):
    print(f"Written by {ea:#x}")
```

### XrefInfo Properties

```python
xref.is_call    # Is this a call reference?
xref.is_jump    # Is this a jump reference?
xref.is_read    # Is this a data read?
xref.is_write   # Is this a data write?
xref.is_flow    # Is this ordinary flow?
xref.user       # Is this user-defined?
```

---

## Names

### Iterating Names

```python
for ea, name in db.names:
    print(f"{ea:#x}: {name}")

count = len(db.names)
```

### Getting Names

```python
name = db.names.get_at(0x401000)
ea, name = db.names[0]  # By index
```

### Setting Names

```python
from ida_domain.names import SetNameFlags

db.names.set_name(ea, "my_function")
db.names.set_name(ea, "my_func", flags=SetNameFlags.CHECK)  # Validate chars
db.names.force_name(ea, "func")  # Creates func_2 if func exists
db.names.delete(ea)              # Remove name
```

### Name Properties

```python
db.names.is_valid_name("my_name")   # Check if valid
db.names.is_public_name(ea)         # Is public?
db.names.is_weak_name(ea)           # Is weak?

db.names.make_name_public(ea)
db.names.make_name_non_public(ea)
db.names.make_name_weak(ea)
db.names.make_name_non_weak(ea)
```

### Demangling

```python
from ida_domain.names import DemangleFlags

demangled = db.names.get_demangled_name(ea)
demangled = db.names.get_demangled_name(ea, DemangleFlags.NORETTYPE)
demangled = db.names.demangle_name("?main@@YAXXZ")
```

---

## Types

### Getting Types

```python
# By name
tinfo = db.types.get_by_name("MyStruct")

# At address
tinfo = db.types.get_at(ea)

# Iterate all types
for tinfo in db.types:
    print(tinfo)
```

### Parsing Types

```python
# Parse declarations from string
errors = db.types.parse_declarations(None, "struct Point { int x; int y; };")

# Parse single declaration
tinfo = db.types.parse_one_declaration(None, "int (*callback)(void*)", "callback_t")

# Parse header file
errors = db.types.parse_header_file(library, Path("header.h"))
```

### Applying Types

```python
from ida_domain.types import TypeApplyFlags

db.types.apply_at(tinfo, ea, flags=TypeApplyFlags.DEFINITE)
```

### Type Details

```python
details = db.types.get_details(tinfo)
print(details.name)
print(details.size)
print(details.attributes)

# For structs/unions
if details.udt:
    print(details.udt.num_members)
    print(details.udt.attributes)

# For functions
if details.func:
    print(details.func.attributes)
```

### Type Libraries

```python
# Load/create libraries
lib = db.types.load_library(Path("types.til"))
lib = db.types.create_library(Path("new.til"), "My Types")

# Import/export types
db.types.import_type(source_lib, "MyStruct")
db.types.export_type(dest_lib, "MyStruct")

# Save library
db.types.save_library(lib, Path("output.til"))
db.types.unload_library(lib)
```

---

## Bytes

### Reading Values

```python
byte = db.bytes.get_byte_at(ea)
word = db.bytes.get_word_at(ea)
dword = db.bytes.get_dword_at(ea)
qword = db.bytes.get_qword_at(ea)
float_val = db.bytes.get_float_at(ea)
double_val = db.bytes.get_double_at(ea)

# Read multiple bytes
data = db.bytes.get_bytes_at(ea, size=16)
original = db.bytes.get_original_bytes_at(ea, size=16)

# Read strings
string = db.bytes.get_string_at(ea)
cstring = db.bytes.get_cstring_at(ea, max_length=256)
```

### Writing Values

```python
db.bytes.set_byte_at(ea, 0x90)
db.bytes.set_word_at(ea, 0x1234)
db.bytes.set_dword_at(ea, 0x12345678)
db.bytes.set_qword_at(ea, 0x123456789ABCDEF0)
db.bytes.set_bytes_at(ea, b"\x90\x90\x90")
```

### Patching (with History)

```python
db.bytes.patch_byte_at(ea, 0x90)     # Saves original
db.bytes.patch_bytes_at(ea, data)
db.bytes.revert_byte_at(ea)          # Restore original

# Get original values
orig = db.bytes.get_original_byte_at(ea)
```

### Searching

```python
from ida_domain.bytes import SearchFlags

# Find bytes
ea = db.bytes.find_bytes_between(b"\x55\x89\xe5", start_ea, end_ea)

# Find all occurrences
addresses = db.bytes.find_binary_sequence(b"\x90\x90")

# Find text
ea = db.bytes.find_text_between("error", flags=SearchFlags.DOWN)

# Find immediate value
ea = db.bytes.find_immediate_between(0x1234)
```

### Creating Data Items

```python
from ida_domain.strings import StringType

db.bytes.create_byte_at(ea, count=4)
db.bytes.create_word_at(ea)
db.bytes.create_dword_at(ea, count=10)  # Array of 10 dwords
db.bytes.create_qword_at(ea)
db.bytes.create_float_at(ea)
db.bytes.create_double_at(ea)
db.bytes.create_string_at(ea, string_type=StringType.C)
db.bytes.create_struct_at(ea, count=1, tid=struct_tid)
```

### Querying Properties

```python
size = db.bytes.get_data_size_at(ea)
db.bytes.is_value_initialized_at(ea)
db.bytes.is_code_at(ea)
db.bytes.is_data_at(ea)
db.bytes.is_head_at(ea)
db.bytes.is_tail_at(ea)
db.bytes.is_unknown_at(ea)

# Get disassembly at address
disasm = db.bytes.get_disassembly_at(ea)
```

### Navigation

```python
next_head = db.bytes.get_next_head(ea)
prev_head = db.bytes.get_previous_head(ea)
next_addr = db.bytes.get_next_address(ea)
prev_addr = db.bytes.get_previous_address(ea)
```

---

## Comments

### Regular Comments

```python
from ida_domain.comments import CommentKind

# Get comment
info = db.comments.get_at(ea, CommentKind.REGULAR)
if info:
    print(info.comment)

# Set comment
db.comments.set_at(ea, "This is important", CommentKind.REGULAR)
db.comments.set_at(ea, "Shows everywhere", CommentKind.REPEATABLE)

# Delete comment
db.comments.delete_at(ea, CommentKind.ALL)
```

### Iterating Comments

```python
for comment_info in db.comments:
    print(f"{comment_info.ea:#x}: {comment_info.comment}")

# All comment types
for info in db.comments.get_all(CommentKind.ALL):
    print(f"{info.ea:#x} (repeatable={info.repeatable}): {info.comment}")
```

### Extra Comments (Anterior/Posterior)

```python
from ida_domain.comments import ExtraCommentKind

# Set extra comment
db.comments.set_extra_at(ea, index=0, comment="Before line", kind=ExtraCommentKind.ANTERIOR)
db.comments.set_extra_at(ea, index=0, comment="After line", kind=ExtraCommentKind.POSTERIOR)

# Get extra comments
comment = db.comments.get_extra_at(ea, index=0, kind=ExtraCommentKind.ANTERIOR)
for comment in db.comments.get_all_extra_at(ea, ExtraCommentKind.ANTERIOR):
    print(comment)

# Delete
db.comments.delete_extra_at(ea, index=0, kind=ExtraCommentKind.ANTERIOR)
```

---

## Entries

### Iterating Entry Points

```python
for entry in db.entries:
    print(f"{entry.ordinal}: {entry.name} at {entry.address:#x}")

count = len(db.entries)
first = db.entries[0]
```

### Finding Entries

```python
entry = db.entries.get_at(ea)              # By address
entry = db.entries.get_by_ordinal(1)       # By ordinal
entry = db.entries.get_by_name("main")     # By name
entry = db.entries.get_at_index(0)         # By index
```

### Entry Properties

```python
print(entry.ordinal)
print(entry.address)
print(entry.name)
print(entry.forwarder_name)
entry.has_forwarder()
```

### Modifying Entries

```python
db.entries.add(address=ea, name="new_entry", ordinal=10)
db.entries.rename(ordinal=10, new_name="renamed_entry")
db.entries.set_forwarder(ordinal=10, forwarder_name="other.dll!func")
db.entries.exists(ordinal=10)
```

### Utility Iterators

```python
for ordinal in db.entries.get_ordinals():
    print(ordinal)

for addr in db.entries.get_addresses():
    print(f"{addr:#x}")

for name in db.entries.get_names():
    print(name)

for fwd in db.entries.get_forwarders():
    print(f"{fwd.ordinal}: {fwd.name}")
```

---

## Heads

### Iterating Heads

```python
for ea in db.heads:
    print(f"Head at {ea:#x}")

# In range
for ea in db.heads.get_between(start_ea, end_ea):
    print(ea)
```

### Navigation

```python
next_ea = db.heads.get_next(ea)
prev_ea = db.heads.get_previous(ea)
```

### Head Properties

```python
db.heads.is_head(ea)      # Is start of item?
db.heads.is_tail(ea)      # Is part of multi-byte item?
db.heads.is_code(ea)      # Is instruction?
db.heads.is_data(ea)      # Is data?
db.heads.is_unknown(ea)   # Is unclassified?

size = db.heads.size(ea)
start, end = db.heads.bounds(ea)
```

---

## Flowchart

### Creating Flowcharts

```python
from ida_domain.flowchart import FlowChart, FlowChartFlags

# From function
flowchart = FlowChart(db, func=my_func)

# From address range
flowchart = FlowChart(db, bounds=(start_ea, end_ea))

# With predecessor info
flowchart = FlowChart(db, func=my_func, flags=FlowChartFlags.PREDS)
```

### Iterating Basic Blocks

```python
for block in flowchart:
    print(f"Block {block.id}: {block.start_ea:#x} - {block.end_ea:#x}")

# By index
block = flowchart[0]
count = len(flowchart)
```

### Block Navigation

```python
for succ in block.get_successors():
    print(f"Successor: {succ.id}")

for pred in block.get_predecessors():
    print(f"Predecessor: {pred.id}")

succ_count = block.count_successors()
pred_count = block.count_predecessors()
```

### Block Instructions

```python
for insn in block.get_instructions():
    print(f"{insn.ea:#x}")
```

---

## Signature Files

### Applying Signatures

```python
from pathlib import Path

# Apply single file
results = db.signature_files.apply(Path("/path/to/file.sig"))

# Apply all in directory
results = db.signature_files.apply(Path("/path/to/sigs/"))

# Probe only (don't persist)
results = db.signature_files.apply(Path("file.sig"), probe_only=True)

for result in results:
    print(f"{result.path}: {result.matches} matches")
    for func in result.functions:
        print(f"  {func.addr:#x}: {func.name}")
```

### Finding Signature Files

```python
# Default IDA sig directories
sig_files = db.signature_files.get_files()

# Include custom directories
sig_files = db.signature_files.get_files([Path("/custom/sigs")])
```

### Creating Signatures

```python
# Create .sig and .pat files from current database
files = db.signature_files.create()

# Create only .pat file
files = db.signature_files.create(pat_only=True)
```

---

## Enums Reference

### XrefType

```python
from ida_domain.xrefs import XrefType

XrefType.OFFSET       # Offset reference
XrefType.WRITE        # Write access
XrefType.READ         # Read access
XrefType.CALL_FAR     # Far call
XrefType.CALL_NEAR    # Near call
XrefType.JUMP_FAR     # Far jump
XrefType.JUMP_NEAR    # Near jump
XrefType.ORDINARY_FLOW  # Sequential flow

xref_type.is_code_ref()  # Check if code ref
xref_type.is_data_ref()  # Check if data ref
```

### FunctionFlags

```python
from ida_domain.functions import FunctionFlags

FunctionFlags.NORET      # Doesn't return
FunctionFlags.LIB        # Library function
FunctionFlags.THUNK      # Thunk function
FunctionFlags.HIDDEN     # Hidden chunk
FunctionFlags.LUMINA     # From Lumina
FunctionFlags.FAR        # Far function
FunctionFlags.FRAME      # Uses frame pointer
```

### LocalVariableAccessType

```python
from ida_domain.functions import LocalVariableAccessType

LocalVariableAccessType.READ     # Variable is read
LocalVariableAccessType.WRITE    # Variable is written
LocalVariableAccessType.ADDRESS  # Address taken (&var)
```

### LocalVariableContext

```python
from ida_domain.functions import LocalVariableContext

LocalVariableContext.ASSIGNMENT    # var = expr
LocalVariableContext.CONDITION     # if (var)
LocalVariableContext.CALL_ARG      # func(var)
LocalVariableContext.RETURN        # return var
LocalVariableContext.ARITHMETIC    # var + 1
LocalVariableContext.COMPARISON    # var == x
LocalVariableContext.ARRAY_INDEX   # arr[var]
LocalVariableContext.POINTER_DEREF # *var
LocalVariableContext.CAST          # (type)var
```

### OperandType

```python
from ida_domain.operands import OperandType

OperandType.REGISTER      # Register
OperandType.MEMORY        # Direct memory
OperandType.PHRASE        # Register addressing
OperandType.DISPLACEMENT  # Reg + displacement
OperandType.IMMEDIATE     # Immediate value
OperandType.FAR_ADDRESS   # Far address
OperandType.NEAR_ADDRESS  # Near address
```

### StringType

```python
from ida_domain.strings import StringType

StringType.C        # C-style null-terminated
StringType.C_16     # C-style 16-bit
StringType.C_32     # C-style 32-bit
StringType.PASCAL   # Pascal-style
StringType.LEN2     # 2-byte length prefix
StringType.LEN4     # 4-byte length prefix
```

### SegmentPermissions

```python
from ida_domain.segments import SegmentPermissions

SegmentPermissions.READ
SegmentPermissions.WRITE
SegmentPermissions.EXEC
SegmentPermissions.ALL
```

### AddressingMode

```python
from ida_domain.segments import AddressingMode

AddressingMode.BIT16  # 16-bit segment
AddressingMode.BIT32  # 32-bit segment
AddressingMode.BIT64  # 64-bit segment
```

### PredefinedClass

```python
from ida_domain.segments import PredefinedClass

PredefinedClass.CODE
PredefinedClass.DATA
PredefinedClass.CONST
PredefinedClass.STACK
PredefinedClass.BSS
PredefinedClass.XTRN
```

### CommentKind

```python
from ida_domain.comments import CommentKind

CommentKind.REGULAR     # Normal comment
CommentKind.REPEATABLE  # Shows at all refs
CommentKind.ALL         # Both types
```

### ExtraCommentKind

```python
from ida_domain.comments import ExtraCommentKind

ExtraCommentKind.ANTERIOR   # Before the line
ExtraCommentKind.POSTERIOR  # After the line
```

### TypeAttr

```python
from ida_domain.types import TypeAttr

TypeAttr.INT, TypeAttr.UINT
TypeAttr.FLOAT, TypeAttr.DOUBLE
TypeAttr.PTR, TypeAttr.ARRAY
TypeAttr.FUNC, TypeAttr.STRUCT
TypeAttr.UNION, TypeAttr.ENUM
TypeAttr.CONST, TypeAttr.VOLATILE
```

### FlowChartFlags

```python
from ida_domain.flowchart import FlowChartFlags

FlowChartFlags.NONE   # Default
FlowChartFlags.NOEXT  # Don't compute external blocks
FlowChartFlags.PREDS  # Compute predecessors
```

---

## Common Patterns

### Find All Calls to a Function

```python
func = db.functions.get_function_by_name("malloc")
if func:
    for caller in db.xrefs.get_callers(func.start_ea):
        print(f"Called from {caller.name} at {caller.ea:#x}")
```

### Rename Functions Based on Strings

```python
for func in db.functions:
    for insn in db.functions.get_instructions(func):
        for xref in db.xrefs.from_ea(insn.ea):
            string = db.strings.get_at(xref.to_ea)
            if string and "error" in str(string).lower():
                db.functions.set_name(func, f"func_with_error_{func.start_ea:x}")
                break
```

### Analyze Function Complexity

```python
func = db.functions.get_at(ea)
flowchart = db.functions.get_flowchart(func)
print(f"Basic blocks: {len(flowchart)}")

total_edges = sum(block.count_successors() for block in flowchart)
print(f"Cyclomatic complexity: {total_edges - len(flowchart) + 2}")
```

### Export Function Pseudocode

```python
for func in db.functions:
    name = db.functions.get_name(func)
    try:
        pseudocode = db.functions.get_pseudocode(func)
        print(f"// {name}")
        for line in pseudocode:
            print(line)
    except RuntimeError:
        print(f"// Could not decompile {name}")
```

### Find Cross-References to Strings

```python
for string in db.strings:
    refs = list(db.xrefs.to_ea(string.address))
    if refs:
        print(f'"{string}" referenced from:')
        for xref in refs:
            print(f"  {xref.from_ea:#x}")
```

```

`plugins/code-eval-ida-domain/skills/ida-domain-scripting/SKILL.md`:

```md
---
name: ida-domain-scripting
description: Write and execute Python scripts using the IDA Domain API for reverse engineering. Analyze binaries, extract functions, strings, cross-references, decompile code, work with IDA Pro databases (.i64/.idb). Use when user wants to analyze binaries, reverse engineer executables, or automate IDA Pro tasks.
---

**IMPORTANT - Path Resolution:**
This skill can be installed in different locations. Before executing any commands, determine the skill directory based
on where you loaded this SKILL.md file, and use that path in all commands below. Replace `$SKILL_DIR` with the actual
discovered path.

Common installation paths:

- Project-specific: `<project>/.claude/skills/ida-domain-scripting`
- Manual global: `~/.claude/skills/ida-domain-scripting`

# IDA Domain Scripting

General-purpose binary analysis skill. I'll write custom IDAPython code for any reverse engineering task you request and
execute it via the universal executor.

**CRITICAL WORKFLOW - Follow these steps in order:**

1. **Create a work dir in /tmp with timestamp** - NEVER write scripts to skill directory; always create a workdir
   `/tmp/ida-domain-YYYYMMDD_HHMMSS_ffffff-<name>` with microseconds for uniqueness (e.g.,
   `/tmp/ida-domain-20260109_143052_847291-list-functions`). Generate timestamp with: `datetime.now().
   strftime
   ('%Y%m%d_%H%M%S_%f')`.
   This will always be referenced as <work_dir>

2. **Check API_REFERENCE.md exists** - Always check that $SKILL_DIR/API_REFERENCE.md exists. Inform the user to run
   the bootstrap if not.

3. **Execute from skill directory** - Always run:
   `cd $SKILL_DIR && uv run python run.py <work_dir>/script.py -f <binary>`

4. **Ask before saving** - Scripts that modify the database require explicit user confirmation before using `--save`

## How It Works

1. You describe what you want to analyze/extract
2. I write custom IDA Domain API code in `<work_dir>/script.py` (timestamped with microseconds for parallel execution)
3. I execute it via: `cd $SKILL_DIR && uv run python run.py <work_dir>/script.py -f <binary>`
4. Results displayed in real-time
5. Script files auto-cleaned from /tmp by your OS

## Setup (First Time)

```bash
cd $SKILL_DIR && uv run python setup.py
```

This clones ida-domain from GitHub and installs dependencies. Only needed once.

**Using a specific version:**

```bash
uv run python setup.py --ref v0.1.0   # Specific release
uv run python setup.py --ref main     # Bleeding edge
```

Requirements:

- uv package manager
- git
- IDA Pro 9.1+
- IDADIR environment variable pointing to IDA installation

## Execution Pattern

**Step 1: Write analysis script to <work_dir>**

```python
# <work_dir>/script.py
for func in db.functions:
    name = db.functions.get_name(func)
    print(f"{name}: 0x{func.start_ea:08X}")
```

**Step 2: Execute from skill directory**

```bash
cd $SKILL_DIR && uv run python run.py <work_dir>/script.py -f /path/to/binary
```

**Step 3: Review results**

Scripts are auto-wrapped with `Database.open()` boilerplate. The `db` variable is available for accessing all entities.

## Common Patterns

### List All Functions

```python
# <work_dir>/script.py
for func in db.functions:
    name = db.functions.get_name(func)
    size = func.end_ea - func.start_ea
    print(f"{name}: 0x{func.start_ea:08X} - 0x{func.end_ea:08X} ({size} bytes)")
```

### Find Function by Name

```python
# <work_dir>/script.py
func = db.functions.get_function_by_name("main")
if func:
    print(f"Found main at 0x{func.start_ea:08X}")

    # Get callers
    callers = db.functions.get_callers(func)
    print(f"Called by {len(callers)} functions:")
    for caller in callers:
        print(f"  - {db.functions.get_name(caller)}")
else:
    print("main not found")
```

### Search Strings

```python
# <work_dir>/script.py
import re

# Find all strings
for s in db.strings:
    print(f"0x{s.address:08X}: {s}")

# Find URLs
url_pattern = re.compile(r"https?://[\w./]+", re.IGNORECASE)
for s in db.strings:
    try:
        content = str(s)
        if url_pattern.search(content):
            print(f"URL found: {content}")
    except:
        pass
```

### Analyze Cross-References

```python
# <work_dir>/script.py
# Get xrefs TO an address
target = 0x00401000
print(f"References TO 0x{target:08X}:")
for xref in db.xrefs.to_ea(target):
    print(f"  From 0x{xref.from_ea:08X} (type: {xref.type.name})")

# Get xrefs FROM an address
print(f"References FROM 0x{target:08X}:")
for xref in db.xrefs.from_ea(target):
    print(f"  To 0x{xref.to_ea:08X} (type: {xref.type.name})")
```

### Decompile Function

```python
# <work_dir>/script.py
func = db.functions.get_function_by_name("main")
if func:
    try:
        lines = db.functions.get_pseudocode(func)
        print("\n".join(lines))
    except RuntimeError as e:
        print(f"Decompilation failed: {e}")
```

### Analyze Function Complexity

```python
# <work_dir>/script.py
complex_funcs = []
for func in db.functions:
    flowchart = db.functions.get_flowchart(func)
    if flowchart:
        block_count = len(flowchart)
        edge_count = sum(b.count_successors() for b in flowchart)
        cyclomatic = edge_count - block_count + 2

        if cyclomatic > 10:
            name = db.functions.get_name(func)
            complex_funcs.append((name, func.start_ea, cyclomatic))

complex_funcs.sort(key=lambda x: x[2], reverse=True)
print("Most complex functions:")
for name, addr, cc in complex_funcs[:10]:
    print(f"  {name}: complexity={cc} at 0x{addr:08X}")
```

### Search Byte Patterns

```python
# <work_dir>/script.py
# Search for NOP sled
pattern = b"\x90\x90\x90\x90"
results = db.bytes.find_binary_sequence(pattern)
for addr in results:
    print(f"Found NOP sled at 0x{addr:08X}")

# Search for x64 function prologue
prologue = b"\x55\x48\x89\xE5"  # push rbp; mov rbp, rsp
for addr in db.bytes.find_binary_sequence(prologue):
    print(f"Prologue at 0x{addr:08X}")
```

### Export to JSON

```python
# <work_dir>/script.py
import json
from pathlib import Path

functions = []
for func in db.functions:
    name = db.functions.get_name(func)
    functions.append({
        "name": name,
        "start": f"0x{func.start_ea:08X}",
        "end": f"0x{func.end_ea:08X}",
        "size": func.end_ea - func.start_ea,
    })

output = {"module": db.module, "functions": functions}
Path("/tmp/functions.json").write_text(json.dumps(output, indent=2))
print(f"Exported {len(functions)} functions to /tmp/functions.json")
```

## Inline Execution (Simple Tasks)

For quick one-off tasks, you can execute code inline without creating files:

```bash
# Quick function count
cd $SKILL_DIR && uv run python run.py -c "print(f'Functions: {len(db.functions)}')" -f binary

# Get binary info
cd $SKILL_DIR && uv run python run.py -c "print(f'{db.module}: {db.architecture} {db.bitness}-bit')" -f binary
```

**When to use inline vs files:**

- **Inline**: Quick one-off tasks (count functions, get binary info, check if symbol exists)
- **Files**: Complex analysis, multi-step tasks, anything user might want to re-run

## Advanced Usage

For comprehensive IDA Domain API documentation, see [API_REFERENCE.md](API_REFERENCE.md):

- Database properties and metadata
- Function enumeration and analysis
- String detection and searching
- Cross-reference queries
- Byte pattern matching
- Control flow analysis
- Decompilation (Hex-Rays)
- Type information
- Comments and names

## Tips

- **Default is read-only** - Use `--save` only when modifications should persist (and ask user first!)
- **Timeout** - Default 30 minutes; use `--timeout 0` for long-running analysis
- **No-wrap mode** - Use `--no-wrap` when your script already has `Database.open()`
- **Error handling** - Always use try-except for decompilation and string operations
- **Check for None** - Functions like `get_function_by_name()` return None if not found

## Troubleshooting

**When encountering errors:**
Check the ida-domain source code first by searching for the method signature in `$SKILL_DIR/ida-domain/ida_domain/`. The
API may differ from what's documented or expected.

**Virtual environment not found:**

```bash
cd $SKILL_DIR && uv run python setup.py
```

**IDA SDK fails to load / IDADIR error:**

```bash
export IDADIR=/path/to/ida
```

**Script timeout:**

```bash
cd $SKILL_DIR && uv run python run.py --timeout 3600 ...  # 1 hour
cd $SKILL_DIR && uv run python run.py --timeout 0 ...     # No timeout
```

**AttributeError: 'Xrefs' has no attribute 'get_xrefs_to':**
Use `db.xrefs.to_ea(addr)` not `db.xrefs.get_xrefs_to(addr)`

**AttributeError on func_t object:**
Call methods on `db.functions`, not on the func object:

```python
# Wrong: func.get_callers()
# Right: db.functions.get_callers(func)
```

**UnicodeDecodeError when reading strings:**

```python
for s in db.strings:
    try:
        content = str(s)
    except:
        continue  # Skip problematic strings
```

## Example Usage

```
User: "How many functions are in this binary?"

Claude: I'll count the functions. Let me analyze the binary...
[Writes: <work_dir>/script.py]
[Runs: cd $SKILL_DIR && uv run python run.py <work_dir>/script.py -f binary]
[Output: Functions: 250]

The binary contains 250 functions.
```

```
User: "Find all functions that call malloc"

Claude: I'll find all callers of malloc...
[Writes: <work_dir>/script.py]
[Runs: cd $SKILL_DIR && uv run python run.py <work_dir>/script.py -f binary]
[Output: malloc called by 15 functions: sub_401000, sub_402000, ...]

Found 15 functions that call malloc:
- sub_401000 at 0x00401000
- sub_402000 at 0x00402000
...
```

```
User: "Decompile the main function and save it"

Claude: I'll decompile main and save the output...
[Writes: <work_dir>/script.py]
[Runs: cd $SKILL_DIR && uv run python run.py <work_dir>/script.py -f binary]
[Output: Saved to /tmp/main.c]

Done! The decompiled code is saved to /tmp/main.c
```


```

`plugins/code-eval-ida-domain/skills/ida-domain-scripting/pyproject.toml`:

```toml
[project]
name = "ida-domain-scripting"
version = "1.0.0"
description = "IDA Domain scripting skill for Claude Code"
readme = "SKILL.md"
requires-python = ">=3.10"
license = "MIT"
authors = [
    { name = "Hex-Rays SA", email = "support@hex-rays.com" }
]
keywords = ["ida-pro", "reverse-engineering", "binary-analysis", "ida-domain"]

dependencies = []

[dependency-groups]
dev = []

```

`plugins/code-eval-ida-domain/skills/ida-domain-scripting/run.py`:

```py
#!/usr/bin/env python3
"""
IDA Domain Universal Script Executor

Executes Python scripts that use IDA Domain with automatic boilerplate wrapping.
This is the main entry point for Claude-generated analysis scripts.

Input file caching:
    The executor uses a persistent cache directory (/tmp/ida-domain-cache/)
    to store input files and their IDA databases. The cache directory structure
    is based on the full path of the input file (with path separators replaced
    by underscores).

    Benefits:
    - Prevents IDA from creating artifact files in the original directory
    - Allows reuse of IDA databases from previous runs, avoiding reanalysis
    - Subsequent runs on the same binary are significantly faster

    When --save is used with an IDA database (.i64/.idb), the modified database
    is copied back to the original location.

Usage:
    # 1. Execute a script file
    uv run python run.py <work_dir>/script.py -f /path/to/binary.exe

    # 2. Execute inline code
    uv run python run.py -c "for f in db.functions: print(f.name)" -f binary.exe

Command-line flags:
    -f, --file      Target binary or .i64 file (required)
    -c, --code      Inline code string
    -s, --save      Enable save_on_close=True (default: False)
    --no-wrap       Skip auto-wrapping (for complete scripts)
    --timeout       Execution timeout in seconds (default: 1800, 0 for no timeout)

Exit codes:
    0 - Success
    1 - Error (setup, parsing, execution)
"""

import argparse
import glob
import shutil
import subprocess
import sys
import tempfile
import time
from pathlib import Path


# ANSI color codes for terminal output (consistent with setup.py)
class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    BOLD = "\033[1m"
    RESET = "\033[0m"


def print_error(message: str) -> None:
    """Print an error message."""
    print(f"{Colors.RED}Error:{Colors.RESET} {message}", file=sys.stderr)


def print_warning(message: str) -> None:
    """Print a warning message."""
    print(f"{Colors.YELLOW}Warning:{Colors.RESET} {message}", file=sys.stderr)


def print_info(message: str) -> None:
    """Print an info message."""
    print(f"{Colors.BLUE}Info:{Colors.RESET} {message}", file=sys.stderr)


def get_skill_dir() -> Path:
    """Get the directory containing this run script."""
    return Path(__file__).parent.resolve()


def check_venv_exists() -> bool:
    """
    Check if the virtual environment exists.

    Returns:
        True if .venv exists, False otherwise.
    """
    venv_path = get_skill_dir() / ".venv"
    return venv_path.exists() and venv_path.is_dir()


def prompt_setup() -> None:
    """Print instructions to run setup if venv is missing."""
    skill_dir = get_skill_dir()
    print_error("Virtual environment not found.")
    print()
    print("Please run setup first:")
    print()
    print(f"  cd {skill_dir}")
    print("  uv run python setup.py")
    print()


def cleanup_old_temp_files() -> int:
    """
    Remove temp files older than 1 hour matching ida-domain-*.py pattern in temp directory.

    Returns:
        Number of files cleaned up.
    """
    cleaned = 0
    cutoff_time = time.time() - 3600  # 1 hour ago

    # Find all matching temp files
    temp_dir = tempfile.gettempdir()
    pattern = str(Path(temp_dir) / "ida-domain-*.py")
    for filepath in glob.glob(pattern):
        try:
            file_path = Path(filepath)
            if file_path.is_file():
                mtime = file_path.stat().st_mtime
                if mtime < cutoff_time:
                    file_path.unlink()
                    cleaned += 1
        except (OSError, PermissionError):
            # Ignore files we can't access or delete
            pass

    return cleaned


def cleanup_old_run_directories() -> int:
    """
    Remove run directories older than 1 hour.

    This handles cleanup of orphaned directories from crashed runs.

    Returns:
        Number of directories cleaned up.
    """
    cleaned = 0
    cutoff_time = time.time() - 3600  # 1 hour ago

    temp_dir = Path(tempfile.gettempdir())
    for dirpath in temp_dir.glob("ida-domain-run-*"):
        try:
            if dirpath.is_dir():
                mtime = dirpath.stat().st_mtime
                if mtime < cutoff_time:
                    shutil.rmtree(dirpath)
                    cleaned += 1
        except (OSError, PermissionError):
            pass

    return cleaned


# IDA database file extensions (created when opening a binary)
IDA_ARTIFACT_EXTENSIONS = {".i64", ".idb", ".id0", ".id1", ".id2", ".nam", ".til"}

# Cache directory for persistent storage of IDA databases
# This avoids reanalysis on subsequent runs of the same binary
CACHE_DIR = Path(tempfile.gettempdir()) / "ida-domain-cache"


def is_ida_database(path: Path) -> bool:
    """
    Check if the file is an IDA database.

    Args:
        path: Path to check.

    Returns:
        True if the file is an IDA database (.i64 or .idb).
    """
    return path.suffix.lower() in {".i64", ".idb"}


def sanitize_path_for_cache(path: Path) -> str:
    """
    Convert a file path to a safe cache directory name.

    Replaces path separators with underscores.

    Args:
        path: Absolute path to the file.

    Returns:
        Sanitized string suitable for use as a directory name.
    """
    path_str = str(path)
    # Replace both forward and back slashes with underscores
    sanitized = path_str.replace("/", "_").replace("\\", "_")
    # Remove leading underscore if present
    if sanitized.startswith("_"):
        sanitized = sanitized[1:]
    return sanitized


def get_or_create_cache_entry(target_path: Path) -> tuple[Path, Path, bool]:
    """
    Get or create a cache entry for the target file.

    The cache uses a persistent directory structure based on the file path.
    If the file already exists in the cache, it is reused (including any
    IDA database files from previous runs).

    Cache structure:
        /tmp/ida-domain-cache/<sanitized_path>/<filename>

    Args:
        target_path: Absolute path to the target binary or .i64 file.

    Returns:
        Tuple of (cache_entry_dir, cached_file_path, already_existed).
        already_existed is True if the file was already in the cache.
    """
    # Ensure cache root exists
    CACHE_DIR.mkdir(parents=True, exist_ok=True)

    # Create cache entry directory based on sanitized path
    cache_name = sanitize_path_for_cache(target_path)
    cache_entry_dir = CACHE_DIR / cache_name
    cache_entry_dir.mkdir(parents=True, exist_ok=True)

    cached_file = cache_entry_dir / target_path.name

    # Check if file already exists in cache
    if cached_file.exists():
        # Check if there's also a cached IDA database for binaries
        if not is_ida_database(target_path):
            cached_i64 = cache_entry_dir / (target_path.stem + ".i64")
            if cached_i64.exists():
                print_info(f"Using cached database: {cached_i64}")
            else:
                print_info(f"Using cached file: {cached_file}")
        else:
            print_info(f"Using cached database: {cached_file}")
        return cache_entry_dir, cached_file, True

    # Copy file to cache
    shutil.copy2(target_path, cached_file)
    print_info(f"Cached file to: {cached_file}")

    return cache_entry_dir, cached_file, False


def handle_save_if_requested(
    cache_dir: Path,
    original_path: Path,
    cached_path: Path,
    save_requested: bool,
) -> None:
    """
    Handle --save flag after execution.

    If save was requested and the input was an IDA database, copy the
    modified database back to the original location.

    Note: The cache directory is NOT cleaned up - this is intentional
    to allow subsequent runs to reuse the cached IDA database.

    Args:
        cache_dir: The cache entry directory.
        original_path: Original path to the input file.
        cached_path: Path to the cached file.
        save_requested: Whether --save was requested.
    """
    if not save_requested:
        return

    try:
        # If save was requested and input was an IDA database, copy it back
        if is_ida_database(original_path):
            if cached_path.exists():
                shutil.copy2(cached_path, original_path)
                print_info(f"Saved modified database back to: {original_path}")
        else:
            # For binaries, the .i64 stays in the cache for reuse
            cached_i64 = cache_dir / (original_path.stem + ".i64")
            if cached_i64.exists():
                print_info(f"Database saved in cache: {cached_i64}")
    except OSError as e:
        print_warning(f"Failed to save database: {e}")


def get_user_code(args: argparse.Namespace) -> tuple[str, str]:
    """
    Get user code from one of three input modes.

    Args:
        args: Parsed command-line arguments.

    Returns:
        Tuple of (code_string, source_description).

    Raises:
        ValueError: If no input provided or conflicting inputs.
    """
    # Check for conflicting inputs
    has_script_file = args.script is not None
    has_inline_code = args.code is not None
    has_stdin = not sys.stdin.isatty()

    input_count = sum([has_script_file, has_inline_code, has_stdin])

    if input_count == 0:
        raise ValueError("No script provided. Use a script file, -c for inline code, or pipe from stdin.")

    if input_count > 1:
        # Prefer explicit arguments over stdin
        if has_script_file and has_stdin:
            has_stdin = False  # Ignore stdin when script file is provided
        elif has_inline_code and has_stdin:
            has_stdin = False  # Ignore stdin when inline code is provided
        elif has_script_file and has_inline_code:
            raise ValueError("Cannot use both script file and -c inline code. Choose one.")

    # Mode 1: Script file
    if has_script_file:
        script_path = Path(args.script)
        if not script_path.exists():
            raise ValueError(f"Script file not found: {script_path}")
        if not script_path.is_file():
            raise ValueError(f"Not a file: {script_path}")
        code = script_path.read_text(encoding="utf-8")
        return code, f"file: {script_path}"

    # Mode 2: Inline code (-c)
    if has_inline_code:
        return args.code, "inline code (-c)"

    # Mode 3: Stdin
    if has_stdin:
        code = sys.stdin.read()
        if not code.strip():
            raise ValueError("Empty input from stdin.")
        return code, "stdin"

    raise ValueError("No script provided.")


def wrap_code(user_code: str, target_file: str, save_on_close: bool) -> str:
    """
    Wrap user code with IDA Domain boilerplate.

    The wrapper provides:
    - ida_domain imports
    - Database.open() context manager
    - The `db` variable for accessing all database entities

    Args:
        user_code: The user's script code.
        target_file: Path to the target binary or .i64 file.
        save_on_close: Whether to save the database on close.

    Returns:
        Wrapped code string ready for execution.
    """
    save_flag = "True" if save_on_close else "False"

    # Escape target file path for Python string
    target_file_escaped = target_file.replace("\\", "\\\\").replace("'", "\\'")

    # Indent user code to be inside the 'with' block
    indented_code = "\n".join("    " + line if line.strip() else line for line in user_code.split("\n"))

    wrapper = f'''#!/usr/bin/env python3
# Auto-wrapped by IDA Domain run.py
from ida_domain import Database
from ida_domain.database import IdaCommandOptions

with Database.open('{target_file_escaped}', IdaCommandOptions(auto_analysis=True), save_on_close={save_flag}) as db:
    # --- User code starts here ---
{indented_code}
    # --- User code ends here ---
'''
    return wrapper


def execute_script(code: str, timeout: int | None = None) -> int:
    """
    Execute the script code via subprocess.

    Args:
        code: Python code to execute.
        timeout: Timeout in seconds (None for no timeout).

    Returns:
        Exit code from the script execution.
    """
    skill_dir = get_skill_dir()
    temp_dir = tempfile.gettempdir()

    # Create a temporary file for the wrapped script
    # Using a predictable prefix for cleanup
    with tempfile.NamedTemporaryFile(
        mode="w",
        prefix="ida-domain-",
        suffix=".py",
        dir=temp_dir,
        delete=False,
        encoding="utf-8",
    ) as f:
        f.write(code)
        temp_script = f.name

    try:
        # Execute using uv run python
        result = subprocess.run(
            ["uv", "run", "python", temp_script],
            cwd=skill_dir,
            text=True,
            timeout=timeout,
        )
        return result.returncode
    except subprocess.TimeoutExpired:
        print_error(f"Script execution timed out after {timeout} seconds.")
        print()
        print("To increase the timeout, use the --timeout flag:")
        print(f"  uv run python run.py --timeout 3600 ...")
        print()
        print("To disable the timeout entirely, use --timeout 0")
        return 124  # Standard timeout exit code
    except FileNotFoundError:
        print_error("uv is not installed. Please install uv first.")
        print()
        print("Installation:")
        print("  curl -LsSf https://astral.sh/uv/install.sh | sh")
        return 1
    except KeyboardInterrupt:
        print_warning("Execution interrupted by user.")
        return 130
    finally:
        # Clean up the temp file we just created
        try:
            Path(temp_script).unlink()
        except OSError:
            pass


def parse_args() -> argparse.Namespace:
    """
    Parse command-line arguments.

    Returns:
        Parsed arguments namespace.
    """
    parser = argparse.ArgumentParser(
        description="Execute IDA Domain scripts with automatic boilerplate wrapping.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Execute a script file
  uv run python run.py /tmp/analyze.py -f /path/to/binary.exe

  # Execute inline code
  uv run python run.py -c "for f in db.functions: print(f.name)" -f binary.exe

  # Execute from stdin
  cat /tmp/analyze.py | uv run python run.py -f binary.exe

  # Execute without wrapping (complete script)
  uv run python run.py /tmp/complete_script.py --no-wrap

  # Execute and save database changes
  uv run python run.py -c "db.functions[0].name = 'main'" -f binary.exe -s
""",
    )

    parser.add_argument(
        "script",
        nargs="?",
        help="Path to Python script file to execute",
    )

    parser.add_argument(
        "-f", "--file",
        dest="target",
        required=True,
        help="Target binary or .i64 file (required)",
    )

    parser.add_argument(
        "-c", "--code",
        dest="code",
        help="Inline Python code to execute",
    )

    parser.add_argument(
        "-s", "--save",
        dest="save",
        action="store_true",
        default=False,
        help="Enable save_on_close=True (default: False)",
    )

    parser.add_argument(
        "--no-wrap",
        dest="no_wrap",
        action="store_true",
        default=False,
        help="Skip auto-wrapping (for complete scripts that handle their own setup)",
    )

    parser.add_argument(
        "--timeout",
        dest="timeout",
        type=int,
        default=1800,
        help="Execution timeout in seconds (default: 1800 = 30 minutes, 0 for no timeout)",
    )

    return parser.parse_args()


def main() -> int:
    """
    Main entry point.

    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    # Parse arguments first
    args = parse_args()

    # Step 1: Check venv exists
    if not check_venv_exists():
        prompt_setup()
        return 1

    # Step 2: Clean up old temp files and orphaned run directories (non-blocking, best effort)
    cleaned_files = cleanup_old_temp_files()
    cleaned_dirs = cleanup_old_run_directories()
    if cleaned_files > 0 or cleaned_dirs > 0:
        print_info(f"Cleaned up {cleaned_files} old temp file(s) and {cleaned_dirs} orphaned run dir(s).")

    # Step 3: Validate target file (moved before cache lookup)
    target_path = Path(args.target)
    if not target_path.exists():
        print_error(f"Target file not found: {args.target}")
        return 1
    if not target_path.is_file():
        print_error(f"Target is not a file: {args.target}")
        return 1

    # Resolve to absolute path
    original_path = target_path.resolve()

    # Step 4: Get or create cache entry for the input file
    # This prevents IDA from creating artifacts in the original directory
    # and allows reuse of IDA databases from previous runs
    cache_dir, cached_path, _ = get_or_create_cache_entry(original_path)

    # Step 5: Get user code
    try:
        user_code, source_desc = get_user_code(args)
    except ValueError as e:
        print_error(str(e))
        return 1

    # Step 6: Wrap code (unless --no-wrap)
    # Use the cached file path so IDA operates in the cache directory
    if args.no_wrap:
        final_code = user_code
        print_info(f"Executing {source_desc} without wrapping...")
    else:
        final_code = wrap_code(user_code, str(cached_path), args.save)
        print_info(f"Executing wrapped {source_desc}...")

    # Step 7: Execute
    # Convert timeout: 0 means no timeout (None), otherwise use the value
    timeout = args.timeout if args.timeout > 0 else None
    exit_code = execute_script(final_code, timeout=timeout)

    # Step 8: Handle --save if requested
    # Note: Cache directory is NOT cleaned up to allow reuse on subsequent runs
    handle_save_if_requested(cache_dir, original_path, cached_path, args.save)

    return exit_code


if __name__ == "__main__":
    sys.exit(main())

```

`plugins/code-eval-ida-domain/skills/ida-domain-scripting/setup.py`:

```py
#!/usr/bin/env python3
"""
IDA Domain Skill Setup Script

This script validates the environment and installs dependencies required for
the IDA Domain scripting skill. Run this before using the skill for the first time.

Usage:
    uv run python setup.py [--ref <git-ref>]

Steps performed:
    1. Check that uv package manager is installed
    2. Clone or update ida-domain repository from GitHub
    3. Run uv sync to install dependencies (ida-domain)
    4. Verify IDADIR environment variable is set and valid
    5. Run a validation test to confirm IDA Domain works

Exit codes:
    0 - Success, setup complete
    1 - Error occurred (check output for details)
"""

import argparse
import json
import os
import subprocess
import sys
import urllib.request
from pathlib import Path
from typing import Optional


# ANSI color codes for terminal output
class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    BOLD = "\033[1m"
    RESET = "\033[0m"


def print_step(step_num: int, message: str) -> None:
    """Print a numbered step header."""
    print(f"\n{Colors.BLUE}{Colors.BOLD}[{step_num}/5]{Colors.RESET} {message}")


def print_warning(message: str) -> None:
    """Print a warning message."""
    print(f"  {Colors.YELLOW}!{Colors.RESET} {message}")


def print_success(message: str) -> None:
    """Print a success message."""
    print(f"  {Colors.GREEN}✓{Colors.RESET} {message}")


def print_error(message: str) -> None:
    """Print an error message."""
    print(f"  {Colors.RED}✗{Colors.RESET} {message}")


def print_info(message: str) -> None:
    """Print an info message."""
    print(f"  {Colors.YELLOW}→{Colors.RESET} {message}")


def get_skill_dir() -> Path:
    """Get the directory containing this setup script."""
    return Path(__file__).parent.resolve()


def check_uv() -> bool:
    """
    Step 1: Check that uv package manager is installed.

    Returns:
        True if uv is available, False otherwise.
    """
    print_step(1, "Checking for uv package manager...")

    try:
        result = subprocess.run(
            ["uv", "--version"],
            capture_output=True,
            text=True,
            check=True,
            timeout=30,
        )
        version = result.stdout.strip()
        print_success(f"uv is installed ({version})")
        return True
    except FileNotFoundError:
        print_error("uv is not installed")
        print()
        print("  Please install uv using one of these methods:")
        print()
        print(f"  {Colors.BOLD}macOS/Linux:{Colors.RESET}")
        print("    curl -LsSf https://astral.sh/uv/install.sh | sh")
        print()
        print(f"  {Colors.BOLD}Windows:{Colors.RESET}")
        print("    powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"")
        print()
        print(f"  {Colors.BOLD}pip:{Colors.RESET}")
        print("    pip install uv")
        print()
        print("  For more options, see: https://docs.astral.sh/uv/getting-started/installation/")
        return False
    except subprocess.CalledProcessError as e:
        print_error(f"uv check failed: {e.stderr.strip()}")
        return False
    except subprocess.TimeoutExpired:
        print_error("uv version check timed out after 30 seconds")
        return False


def get_latest_release_tag() -> Optional[str]:
    """Fetch the latest release tag from GitHub API."""
    url = "https://api.github.com/repos/HexRaysSA/ida-domain/releases/latest"
    try:
        with urllib.request.urlopen(url, timeout=30) as response:
            data = json.loads(response.read())
            return data.get("tag_name")
    except Exception as e:
        print_warning(f"Could not fetch latest release: {e}")
        return None


def clone_or_update_ida_domain(ref: Optional[str] = None) -> bool:
    """
    Step 2: Clone or update ida-domain repository.

    Args:
        ref: Git ref (branch, tag, or commit). If None, uses latest release tag.

    Returns:
        True if successful, False otherwise.
    """
    skill_dir = get_skill_dir()
    ida_domain_dir = skill_dir / "ida-domain"
    repo_url = "https://github.com/HexRaysSA/ida-domain.git"

    # Determine which ref to use
    if ref is None:
        print_info("Fetching latest release tag from GitHub...")
        ref = get_latest_release_tag()
        if ref is None:
            print_warning("Could not determine latest release, falling back to 'main'")
            ref = "main"
        else:
            print_info(f"Latest release: {ref}")

    if ida_domain_dir.exists():
        # Update existing clone
        print_step(2, f"Updating ida-domain repository (ref: {ref})...")
        try:
            subprocess.run(
                ["git", "fetch", "--all", "--tags"],
                cwd=ida_domain_dir,
                check=True,
                capture_output=True,
                timeout=120,
            )
            subprocess.run(
                ["git", "checkout", ref],
                cwd=ida_domain_dir,
                check=True,
                capture_output=True,
                timeout=30,
            )
            # If it's a branch, pull latest
            result = subprocess.run(
                ["git", "symbolic-ref", "HEAD"],
                cwd=ida_domain_dir,
                capture_output=True,
                text=True,
            )
            if result.returncode == 0:  # It's a branch
                subprocess.run(
                    ["git", "pull"],
                    cwd=ida_domain_dir,
                    check=True,
                    capture_output=True,
                    timeout=120,
                )
            print_success(f"ida-domain updated to {ref}")
            return True
        except subprocess.CalledProcessError as e:
            print_error(f"Failed to update ida-domain: {e.stderr or e.stdout}")
            return False
    else:
        # Fresh clone
        print_step(2, f"Cloning ida-domain repository (ref: {ref})...")
        try:
            subprocess.run(
                ["git", "clone", repo_url, str(ida_domain_dir)],
                check=True,
                capture_output=True,
                timeout=300,
            )
            subprocess.run(
                ["git", "checkout", ref],
                cwd=ida_domain_dir,
                check=True,
                capture_output=True,
                timeout=30,
            )
            print_success(f"ida-domain cloned at {ref}")
            return True
        except subprocess.CalledProcessError as e:
            print_error(f"Failed to clone ida-domain: {e.stderr or e.stdout}")
            return False


def run_uv_sync() -> bool:
    """
    Step 3: Run uv sync and install ida-domain as editable package.

    Returns:
        True if sync succeeds, False otherwise.
    """
    print_step(3, "Installing dependencies with uv sync...")

    skill_dir = get_skill_dir()
    ida_domain_dir = skill_dir / "ida-domain"

    try:
        # First, run uv sync for base dependencies
        result = subprocess.run(
            ["uv", "sync"],
            cwd=skill_dir,
            capture_output=True,
            text=True,
            check=True,
            timeout=300,
        )

        # Then install ida-domain as editable package
        print_info("Installing ida-domain as editable package...")
        result = subprocess.run(
            ["uv", "pip", "install", "-e", str(ida_domain_dir)],
            cwd=skill_dir,
            capture_output=True,
            text=True,
            check=True,
            timeout=300,
        )
        print_success("Dependencies installed successfully")

        return True
    except subprocess.CalledProcessError as e:
        print_error("uv sync failed")
        print()
        print("  Error output:")
        for line in (e.stderr or e.stdout or "Unknown error").strip().split("\n"):
            print(f"    {line}")
        print()
        print("  Possible fixes:")
        print("    - Ensure pyproject.toml exists and is valid")
        print("    - Check your internet connection")
        print("    - Try running: uv cache clean")
        return False
    except subprocess.TimeoutExpired:
        print_error("uv sync timed out after 5 minutes")
        print()
        print("  Possible causes:")
        print("    - Slow network connection")
        print("    - Large dependencies to download")
        print("    - Try running manually: uv sync")
        return False
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        return False


def check_idadir() -> bool:
    """
    Step 4: Verify IDADIR environment variable is set and points to valid IDA installation.

    Returns:
        True if IDADIR is valid, False otherwise.
    """
    print_step(4, "Checking IDADIR environment variable...")

    idadir = os.environ.get("IDADIR")

    if not idadir:
        print_error("IDADIR environment variable is not set")
        print()
        print("  IDADIR must point to your IDA Pro installation directory.")
        print()
        print("  Set it in your shell configuration:")
        print()
        print(f"  {Colors.BOLD}bash/zsh:{Colors.RESET}")
        print("    export IDADIR=\"/path/to/ida\"")
        print()
        print(f"  {Colors.BOLD}fish:{Colors.RESET}")
        print("    set -gx IDADIR \"/path/to/ida\"")
        print()
        print(f"  {Colors.BOLD}Windows:{Colors.RESET}")
        print("    set IDADIR=C:\\path\\to\\ida")
        print()
        print("  Common IDA locations:")
        print("    - macOS: /Applications/IDA Professional 9.1.app/Contents/MacOS")
        print("    - Linux: /opt/idapro-9.1")
        print("    - Windows: C:\\Program Files\\IDA Professional 9.1")
        return False

    ida_path = Path(idadir)

    if not ida_path.exists():
        print_error(f"IDADIR path does not exist: {idadir}")
        print()
        print("  Please verify the path and update IDADIR accordingly.")
        return False

    if not ida_path.is_dir():
        print_error(f"IDADIR is not a directory: {idadir}")
        print()
        print("  IDADIR should point to the IDA installation directory,")
        print("  not an executable file.")
        return False

    # Check for common IDA files to verify it's a valid installation
    ida_indicators = [
        "idat64",      # Linux/macOS headless IDA 64-bit
        "idat64.exe",  # Windows headless IDA 64-bit
        "idat",        # Linux/macOS headless IDA 32-bit
        "idat.exe",    # Windows headless IDA 32-bit
        "ida64",       # Linux/macOS GUI IDA 64-bit
        "ida64.exe",   # Windows GUI IDA 64-bit
        "libida64.so", # Linux shared library
        "libida64.dylib",  # macOS shared library
        "ida64.dll",   # Windows DLL
    ]

    found_indicators = [f for f in ida_indicators if (ida_path / f).exists()]

    if not found_indicators:
        print_error(f"IDADIR does not appear to contain IDA Pro: {idadir}")
        print()
        print("  Expected to find one of:")
        for indicator in ida_indicators[:6]:  # Show first few
            print(f"    - {indicator}")
        print()
        print("  Please verify IDADIR points to the correct IDA installation directory.")
        return False

    print_success(f"IDADIR is set: {idadir}")
    print_info(f"Found IDA files: {', '.join(found_indicators[:3])}")

    return True


def run_validation_test() -> bool:
    """
    Step 5: Run a minimal script to verify IDA Domain can load.

    Returns:
        True if validation succeeds, False otherwise.
    """
    print_step(5, "Running IDA Domain validation test...")

    skill_dir = get_skill_dir()

    # Minimal test script to verify ida_domain imports correctly
    test_script = """
import sys
try:
    import ida_domain
    print(f"ida_domain version: {ida_domain.__version__}")
    print("SUCCESS: IDA Domain loaded correctly")
    sys.exit(0)
except ImportError as e:
    print(f"IMPORT_ERROR: {e}")
    sys.exit(1)
except Exception as e:
    print(f"ERROR: {e}")
    sys.exit(1)
"""

    try:
        result = subprocess.run(
            ["uv", "run", "python", "-c", test_script],
            cwd=skill_dir,
            capture_output=True,
            text=True,
            timeout=60,
        )

        output = result.stdout.strip()
        error_output = result.stderr.strip()

        if result.returncode == 0 and "SUCCESS" in output:
            # Extract version info
            for line in output.split("\n"):
                if "ida_domain version" in line:
                    print_success(line.strip())
                    break
            else:
                print_success("IDA Domain loaded successfully")
            return True
        else:
            print_error("IDA Domain validation failed")
            print()

            if "IMPORT_ERROR" in output:
                print("  Import error:")
                for line in output.split("\n"):
                    if "IMPORT_ERROR" in line:
                        print(f"    {line.replace('IMPORT_ERROR: ', '')}")
            elif output:
                print("  Output:")
                for line in output.split("\n"):
                    print(f"    {line}")

            if error_output:
                print("  Stderr:")
                for line in error_output.split("\n"):
                    print(f"    {line}")

            print()
            print("  Possible fixes:")
            print("    - Verify IDADIR is set correctly")
            print("    - Ensure IDA Pro 9.1+ is installed")
            print("    - Try re-running: uv sync --reinstall")
            print("    - Check IDA Domain docs: https://ida-domain.docs.hex-rays.com/")
            return False

    except subprocess.TimeoutExpired:
        print_error("Validation test timed out after 60 seconds")
        print()
        print("  The import test took too long to complete.")
        print("  This may indicate a problem with the IDA Domain installation.")
        return False
    except Exception as e:
        print_error(f"Validation test failed: {e}")
        return False


def main() -> int:
    """
    Run all setup steps in order.

    Returns:
        Exit code (0 for success, 1 for failure).
    """
    parser = argparse.ArgumentParser(
        description="Setup IDA Domain scripting skill environment"
    )
    parser.add_argument(
        "--ref",
        type=str,
        default=None,
        help="Git ref (branch, tag, or commit) for ida-domain. Default: latest release tag",
    )
    args = parser.parse_args()

    print(f"\n{Colors.BOLD}IDA Domain Skill Setup{Colors.RESET}")
    print("=" * 50)

    # Step 1: Check uv
    if not check_uv():
        return 1

    # Step 2: Clone/update ida-domain
    if not clone_or_update_ida_domain(args.ref):
        return 1

    # Step 3: Run uv sync
    if not run_uv_sync():
        return 1

    # Step 4: Check IDADIR
    if not check_idadir():
        return 1

    # Step 5: Validation test
    if not run_validation_test():
        return 1

    # All steps passed
    print()
    print("=" * 50)
    print(f"{Colors.GREEN}{Colors.BOLD}Setup complete! Ready to use.{Colors.RESET}")
    print()
    print("Next steps:")
    print("  - Write scripts to /tmp/ida-domain-*.py")
    print("  - Execute with: uv run python run.py /tmp/script.py -f <binary>")
    print()

    return 0


if __name__ == "__main__":
    sys.exit(main())

```

`plugins/ida-plugin-development/LICENSE`:

```
MIT License

Copyright (c) 2026 Hex-Rays SA

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`plugins/ida-plugin-development/README.md`:

```md
# IDA Plugin Development Skill for Claude Code

Develop plugins for IDA Pro in Python, using idiomatic patterns, lessons, and tricks, including the Python Domain API (ida-domain). Use when creating both GUI (Qt) and background plugins for inspecting and rendering things program structure, functions, disassembly, cross-references, and strings.

[Claude Skills](https://docs.claude.com/en/docs/claude-code/skills) that enables Claude to autonomously create, package, and install IDAPython plugins with proper HCLI-compatible packaging.

Claude handles plugin infrastructure (Qt widgets, menus, actions, hooks, settings) so you can focus on what your plugin should do.

## Requirements

- [uv](https://docs.astral.sh/uv/) package manager

## Installation

```bash
/plugin marketplace add HexRaysSA/ida-claude-plugins
/plugin install ida-plugin-development@ida-claude-plugins
```

## Scope

**In Scope:**
- Plugin infrastructure (lifecycle, registration)
- Qt6 widgets (forms, dialogs, choosers)
- Actions, menus, hotkeys
- UI_Hooks for event handling
- Settings descriptors
- HCLI packaging and validation

**Out of Scope:**
- IDA scripting/analysis logic (use `reverse-engineering-with-code-eval-and-ida-domain` plugin for script execution)
- IDA 7.x/8.x compatibility
- C++ SDK plugins

## Skills

- **ida-plugin-development** - Plugin infrastructure, Qt widgets, actions, hooks, settings
- **ida-domain-api** - Domain API reference for IDA Pro binary analysis
- **package-ida-plugin** - HCLI packaging and distribution

## Related

- [HCLI Documentation](https://hcli.docs.hex-rays.com/)
- [IDAPython Documentation](https://python.docs.hex-rays.com/)
- [ida-domain Documentation](https://ida-domain.docs.hex-rays.com/)


## License

MIT License - see [LICENSE](LICENSE) file for details.

```

`plugins/ida-plugin-development/skills/ida-domain-api/SKILL.md`:

```md
---
name: ida-domain-api
description: Analyze binaries using the Domain API for IDA Pro. Use when examining program structure, functions, disassembly, cross-references, or strings.
---

# Domain API for IDA Pro

Use this skill to efficiently use the Domain API for IDA Pro, which is easier and more concise than the legacy IDA Python SDK.

**Always prefer the IDA Domain API** over the legacy low-level IDA Python SDK. The Domain API provides a clean, Pythonic interface that is easier to use and understand.

### Documentation Resources

| Resource | URL |
|----------|-----|
| **LLM-optimized overview** | https://ida-domain.docs.hex-rays.com/llms.txt |
| **Getting Started** | https://ida-domain.docs.hex-rays.com/getting_started/index.md |
| **Examples** | https://ida-domain.docs.hex-rays.com/examples/index.md |
| **API Reference** | https://ida-domain.docs.hex-rays.com/ref/{module}/index.md |

Available API modules: `bytes`, `comments`, `database`, `entries`, `flowchart`, `functions`, `heads`, `hooks`, `instructions`, `names`, `operands`, `segments`, `signature_files`, `strings`, `types`, `xrefs`

**To fetch specific API documentation**, use URLs like:
- `https://ida-domain.docs.hex-rays.com/ref/functions/index.md` - Function analysis API
- `https://ida-domain.docs.hex-rays.com/ref/xrefs/index.md` - Cross-reference API
- `https://ida-domain.docs.hex-rays.com/ref/strings/index.md` - String analysis API

### Opening a Database

```python
from ida_domain import Database
from ida_domain.database import IdaCommandOptions

ida_options = IdaCommandOptions(auto_analysis=True, new_database=False)
with Database.open("path/to/binary", ida_options, save_on_close=True) as db:
    # Your analysis here
    pass
```

### Key Database Properties

```python
with Database.open(path, ida_options) as db:
    db.minimum_ea      # Start address
    db.maximum_ea      # End address
    db.metadata        # Database metadata
    db.architecture    # Target architecture

    db.functions       # All functions (iterable)
    db.strings         # All strings (iterable)
    db.segments        # Memory segments
    db.names           # Symbols and labels
    db.entries         # Entry points
    db.types           # Type definitions
    db.comments        # All comments
    db.xrefs           # Cross-reference utilities
    db.bytes           # Byte manipulation
    db.instructions    # Instruction access
```

---

## Functions

### Iterating Functions

```python
# Iterate all functions
for func in db.functions:
    print(db.functions.get_name(func))

# Get function count
count = len(db.functions)
```

### Finding Functions

```python
func = db.functions.get_at(0x401000)           # By address
func = db.functions.get_function_by_name("main")  # By name
func = db.functions.get_next(ea)               # Next function after ea

# Functions in range
for func in db.functions.get_between(start_ea, end_ea):
    print(func.start_ea)
```

### Function Properties

```python
name = db.functions.get_name(func)
signature = db.functions.get_signature(func)
flags = db.functions.get_flags(func)  # Returns FunctionFlags

# Check function attributes
db.functions.is_far(func)
db.functions.does_return(func)
```

### Function Code

```python
# Get disassembly lines
lines = db.functions.get_disassembly(func, remove_tags=True)

# Get decompiled pseudocode
pseudocode = db.functions.get_pseudocode(func, remove_tags=True)

# Get microcode
microcode = db.functions.get_microcode(func, remove_tags=True)
```

### Function Analysis

```python
# Get instructions in function
for insn in db.functions.get_instructions(func):
    print(insn.ea)

# Get flowchart for basic blocks
flowchart = db.functions.get_flowchart(func)
for block in flowchart:
    print(f"Block: {block.start_ea:#x} - {block.end_ea:#x}")

# Get callers/callees
callers = db.functions.get_callers(func)
callees = db.functions.get_callees(func)

# Get function chunks
for chunk in db.functions.get_chunks(func):
    print(f"Chunk: {chunk.start_ea:#x}, main={chunk.is_main}")

# Get data items within function
for data_ea in db.functions.get_data_items(func):
    print(f"Data at {data_ea:#x}")
```

### Local Variables

```python
# Get all local variables
lvars = db.functions.get_local_variables(func)
for lvar in lvars:
    print(f"{lvar.name}: {lvar.type_str}, arg={lvar.is_argument}")

# Find variable by name
lvar = db.functions.get_local_variable_by_name(func, "result")

# Get variable references in pseudocode
refs = db.functions.get_local_variable_references(func, lvar)
for ref in refs:
    print(f"Line {ref.line_number}: {ref.access_type} in {ref.context}")
```

### Modifying Functions

```python
db.functions.set_name(func, "new_name")
db.functions.set_comment(func, "This function does X", repeatable=False)
db.functions.create(ea)   # Create function at address
db.functions.remove(ea)   # Remove function at address
```

---

## Instructions

### Iterating Instructions

```python
# All instructions in database
for insn in db.instructions:
    print(db.instructions.get_disassembly(insn))

# Instructions in range
for insn in db.instructions.get_between(start_ea, end_ea):
    print(insn.ea)
```

### Getting Instructions

```python
insn = db.instructions.get_at(ea)          # Decode at address
insn = db.instructions.get_previous(ea)    # Previous instruction
```

### Instruction Properties

```python
disasm = db.instructions.get_disassembly(insn)
mnemonic = db.instructions.get_mnemonic(insn)  # "mov", "push", etc.
db.instructions.is_valid(insn)
```

### Control Flow Analysis

```python
db.instructions.is_call_instruction(insn)      # Is this a call?
db.instructions.is_indirect_jump_or_call(insn) # Indirect jump/call?
db.instructions.breaks_sequential_flow(insn)   # Stops flow (ret, jmp)?
```

### Working with Operands

```python
count = db.instructions.get_operands_count(insn)
operands = db.instructions.get_operands(insn)  # List of Operand objects

for op in operands:
    info = op.get_info()
    print(f"Operand {op.number}: {op.type.name}")

    if isinstance(op, RegisterOperand):
        print(f"  Register: {op.get_register_name()}")
    elif isinstance(op, ImmediateOperand):
        print(f"  Value: 0x{op.get_value():x}")
    elif isinstance(op, MemoryOperand):
        if op.is_direct_memory():
            print(f"  Memory: 0x{op.get_address():x}")
```

---

## Segments

### Iterating Segments

```python
for segment in db.segments:
    name = db.segments.get_name(segment)
    size = db.segments.get_size(segment)
    print(f"{name}: {segment.start_ea:#x} - {segment.end_ea:#x}")

count = len(db.segments)
```

### Finding Segments

```python
seg = db.segments.get_at(0x401000)      # Segment containing address
seg = db.segments.get_by_name(".text")  # By name
```

### Segment Properties

```python
name = db.segments.get_name(segment)
size = db.segments.get_size(segment)
bitness = db.segments.get_bitness(segment)  # 16, 32, or 64
seg_class = db.segments.get_class(segment)   # "CODE", "DATA", etc.
```

### Creating Segments

```python
from ida_domain.segments import PredefinedClass, AddSegmentFlags

# Add segment with explicit range
seg = db.segments.add(
    seg_para=0,
    start_ea=0x1000,
    end_ea=0x2000,
    seg_name="MySegment",
    seg_class=PredefinedClass.CODE
)

# Append segment after last one
seg = db.segments.append(seg_para=0, seg_size=0x1000, seg_name="NewSeg")
```

### Modifying Segments

```python
from ida_domain.segments import SegmentPermissions, AddressingMode

db.segments.set_name(segment, "new_name")
db.segments.set_permissions(segment, SegmentPermissions.READ | SegmentPermissions.EXEC)
db.segments.add_permissions(segment, SegmentPermissions.WRITE)
db.segments.remove_permissions(segment, SegmentPermissions.WRITE)
db.segments.set_addressing_mode(segment, AddressingMode.BIT64)
db.segments.set_comment(segment, "Code section", repeatable=False)
```

---

## Strings

### Iterating Strings

```python
for string in db.strings:
    print(f"{string.address:#x}: {string}")

# By index
first_string = db.strings[0]
count = len(db.strings)
```

### Finding Strings

```python
string = db.strings.get_at(0x402000)  # String at address

# Strings in range
for s in db.strings.get_between(start_ea, end_ea):
    print(s.contents)
```

### String Properties

```python
print(string.address)       # Address
print(string.length)        # Length in characters
print(string.type)          # StringType enum
print(string.encoding)      # Internal encoding
print(string.contents)      # UTF-8 bytes
print(str(string))          # Decoded string
```

### Rebuilding String List

```python
from ida_domain.strings import StringListConfig, StringType

config = StringListConfig(
    string_types=[StringType.C, StringType.C_16],
    min_len=3,
    only_ascii_7bit=False
)
db.strings.rebuild(config)
db.strings.clear()  # Clear string list
```

---

## Xrefs

### Getting References TO an Address

```python
# All xrefs to an address
for xref in db.xrefs.to_ea(target_ea):
    print(f"{xref.from_ea:#x} -> {xref.to_ea:#x} ({xref.type.name})")

# Just code references
for ea in db.xrefs.code_refs_to_ea(target_ea, flow=False):
    print(f"Code ref from {ea:#x}")

# Just data references
for ea in db.xrefs.data_refs_to_ea(target_ea):
    print(f"Data ref from {ea:#x}")

# Call references only
for ea in db.xrefs.calls_to_ea(func_ea):
    print(f"Called from {ea:#x}")

# Detailed caller information
for caller in db.xrefs.get_callers(func_ea):
    print(f"Called from {caller.name} at {caller.ea:#x}")
```

### Getting References FROM an Address

```python
# All xrefs from an address
for xref in db.xrefs.from_ea(source_ea):
    print(f"{xref.from_ea:#x} -> {xref.to_ea:#x}")

# Code/data refs from
for ea in db.xrefs.code_refs_from_ea(source_ea):
    print(f"Code ref to {ea:#x}")

for ea in db.xrefs.calls_from_ea(source_ea):
    print(f"Calls {ea:#x}")
```

### Data Access Analysis

```python
# Who reads this data?
for ea in db.xrefs.reads_of_ea(data_ea):
    print(f"Read by {ea:#x}")

# Who writes to this data?
for ea in db.xrefs.writes_to_ea(data_ea):
    print(f"Written by {ea:#x}")
```

### XrefInfo Properties

```python
xref.is_call    # Is this a call reference?
xref.is_jump    # Is this a jump reference?
xref.is_read    # Is this a data read?
xref.is_write   # Is this a data write?
xref.is_flow    # Is this ordinary flow?
xref.user       # Is this user-defined?
```

---

## Names

### Iterating Names

```python
for ea, name in db.names:
    print(f"{ea:#x}: {name}")

count = len(db.names)
```

### Getting Names

```python
name = db.names.get_at(0x401000)
ea, name = db.names[0]  # By index
```

### Setting Names

```python
from ida_domain.names import SetNameFlags

db.names.set_name(ea, "my_function")
db.names.set_name(ea, "my_func", flags=SetNameFlags.CHECK)  # Validate chars
db.names.force_name(ea, "func")  # Creates func_2 if func exists
db.names.delete(ea)              # Remove name
```

### Name Properties

```python
db.names.is_valid_name("my_name")   # Check if valid
db.names.is_public_name(ea)         # Is public?
db.names.is_weak_name(ea)           # Is weak?

db.names.make_name_public(ea)
db.names.make_name_non_public(ea)
db.names.make_name_weak(ea)
db.names.make_name_non_weak(ea)
```

### Demangling

```python
from ida_domain.names import DemangleFlags

demangled = db.names.get_demangled_name(ea)
demangled = db.names.get_demangled_name(ea, DemangleFlags.NORETTYPE)
demangled = db.names.demangle_name("?main@@YAXXZ")
```

---

## Types

### Getting Types

```python
# By name
tinfo = db.types.get_by_name("MyStruct")

# At address
tinfo = db.types.get_at(ea)

# Iterate all types
for tinfo in db.types:
    print(tinfo)
```

### Parsing Types

```python
# Parse declarations from string
errors = db.types.parse_declarations(None, "struct Point { int x; int y; };")

# Parse single declaration
tinfo = db.types.parse_one_declaration(None, "int (*callback)(void*)", "callback_t")

# Parse header file
errors = db.types.parse_header_file(library, Path("header.h"))
```

### Applying Types

```python
from ida_domain.types import TypeApplyFlags

db.types.apply_at(tinfo, ea, flags=TypeApplyFlags.DEFINITE)
```

### Type Details

```python
details = db.types.get_details(tinfo)
print(details.name)
print(details.size)
print(details.attributes)

# For structs/unions
if details.udt:
    print(details.udt.num_members)
    print(details.udt.attributes)

# For functions
if details.func:
    print(details.func.attributes)
```

### Type Libraries

```python
# Load/create libraries
lib = db.types.load_library(Path("types.til"))
lib = db.types.create_library(Path("new.til"), "My Types")

# Import/export types
db.types.import_type(source_lib, "MyStruct")
db.types.export_type(dest_lib, "MyStruct")

# Save library
db.types.save_library(lib, Path("output.til"))
db.types.unload_library(lib)
```

---

## Bytes

### Reading Values

```python
byte = db.bytes.get_byte_at(ea)
word = db.bytes.get_word_at(ea)
dword = db.bytes.get_dword_at(ea)
qword = db.bytes.get_qword_at(ea)
float_val = db.bytes.get_float_at(ea)
double_val = db.bytes.get_double_at(ea)

# Read multiple bytes
data = db.bytes.get_bytes_at(ea, size=16)
original = db.bytes.get_original_bytes_at(ea, size=16)

# Read strings
string = db.bytes.get_string_at(ea)
cstring = db.bytes.get_cstring_at(ea, max_length=256)
```

### Writing Values

```python
db.bytes.set_byte_at(ea, 0x90)
db.bytes.set_word_at(ea, 0x1234)
db.bytes.set_dword_at(ea, 0x12345678)
db.bytes.set_qword_at(ea, 0x123456789ABCDEF0)
db.bytes.set_bytes_at(ea, b"\x90\x90\x90")
```

### Patching (with History)

```python
db.bytes.patch_byte_at(ea, 0x90)     # Saves original
db.bytes.patch_bytes_at(ea, data)
db.bytes.revert_byte_at(ea)          # Restore original

# Get original values
orig = db.bytes.get_original_byte_at(ea)
```

### Searching

```python
from ida_domain.bytes import SearchFlags

# Find bytes
ea = db.bytes.find_bytes_between(b"\x55\x89\xe5", start_ea, end_ea)

# Find all occurrences
addresses = db.bytes.find_binary_sequence(b"\x90\x90")

# Find text
ea = db.bytes.find_text_between("error", flags=SearchFlags.DOWN)

# Find immediate value
ea = db.bytes.find_immediate_between(0x1234)
```

### Creating Data Items

```python
from ida_domain.strings import StringType

db.bytes.create_byte_at(ea, count=4)
db.bytes.create_word_at(ea)
db.bytes.create_dword_at(ea, count=10)  # Array of 10 dwords
db.bytes.create_qword_at(ea)
db.bytes.create_float_at(ea)
db.bytes.create_double_at(ea)
db.bytes.create_string_at(ea, string_type=StringType.C)
db.bytes.create_struct_at(ea, count=1, tid=struct_tid)
```

### Querying Properties

```python
size = db.bytes.get_data_size_at(ea)
db.bytes.is_value_initialized_at(ea)
db.bytes.is_code_at(ea)
db.bytes.is_data_at(ea)
db.bytes.is_head_at(ea)
db.bytes.is_tail_at(ea)
db.bytes.is_unknown_at(ea)

# Get disassembly at address
disasm = db.bytes.get_disassembly_at(ea)
```

### Navigation

```python
next_head = db.bytes.get_next_head(ea)
prev_head = db.bytes.get_previous_head(ea)
next_addr = db.bytes.get_next_address(ea)
prev_addr = db.bytes.get_previous_address(ea)
```

---

## Comments

### Regular Comments

```python
from ida_domain.comments import CommentKind

# Get comment
info = db.comments.get_at(ea, CommentKind.REGULAR)
if info:
    print(info.comment)

# Set comment
db.comments.set_at(ea, "This is important", CommentKind.REGULAR)
db.comments.set_at(ea, "Shows everywhere", CommentKind.REPEATABLE)

# Delete comment
db.comments.delete_at(ea, CommentKind.ALL)
```

### Iterating Comments

```python
for comment_info in db.comments:
    print(f"{comment_info.ea:#x}: {comment_info.comment}")

# All comment types
for info in db.comments.get_all(CommentKind.ALL):
    print(f"{info.ea:#x} (repeatable={info.repeatable}): {info.comment}")
```

### Extra Comments (Anterior/Posterior)

```python
from ida_domain.comments import ExtraCommentKind

# Set extra comment
db.comments.set_extra_at(ea, index=0, comment="Before line", kind=ExtraCommentKind.ANTERIOR)
db.comments.set_extra_at(ea, index=0, comment="After line", kind=ExtraCommentKind.POSTERIOR)

# Get extra comments
comment = db.comments.get_extra_at(ea, index=0, kind=ExtraCommentKind.ANTERIOR)
for comment in db.comments.get_all_extra_at(ea, ExtraCommentKind.ANTERIOR):
    print(comment)

# Delete
db.comments.delete_extra_at(ea, index=0, kind=ExtraCommentKind.ANTERIOR)
```

---

## Entries

### Iterating Entry Points

```python
for entry in db.entries:
    print(f"{entry.ordinal}: {entry.name} at {entry.address:#x}")

count = len(db.entries)
first = db.entries[0]
```

### Finding Entries

```python
entry = db.entries.get_at(ea)              # By address
entry = db.entries.get_by_ordinal(1)       # By ordinal
entry = db.entries.get_by_name("main")     # By name
entry = db.entries.get_at_index(0)         # By index
```

### Entry Properties

```python
print(entry.ordinal)
print(entry.address)
print(entry.name)
print(entry.forwarder_name)
entry.has_forwarder()
```

### Modifying Entries

```python
db.entries.add(address=ea, name="new_entry", ordinal=10)
db.entries.rename(ordinal=10, new_name="renamed_entry")
db.entries.set_forwarder(ordinal=10, forwarder_name="other.dll!func")
db.entries.exists(ordinal=10)
```

### Utility Iterators

```python
for ordinal in db.entries.get_ordinals():
    print(ordinal)

for addr in db.entries.get_addresses():
    print(f"{addr:#x}")

for name in db.entries.get_names():
    print(name)

for fwd in db.entries.get_forwarders():
    print(f"{fwd.ordinal}: {fwd.name}")
```

---

## Heads

### Iterating Heads

```python
for ea in db.heads:
    print(f"Head at {ea:#x}")

# In range
for ea in db.heads.get_between(start_ea, end_ea):
    print(ea)
```

### Navigation

```python
next_ea = db.heads.get_next(ea)
prev_ea = db.heads.get_previous(ea)
```

### Head Properties

```python
db.heads.is_head(ea)      # Is start of item?
db.heads.is_tail(ea)      # Is part of multi-byte item?
db.heads.is_code(ea)      # Is instruction?
db.heads.is_data(ea)      # Is data?
db.heads.is_unknown(ea)   # Is unclassified?

size = db.heads.size(ea)
start, end = db.heads.bounds(ea)
```

---

## Flowchart

### Creating Flowcharts

```python
from ida_domain.flowchart import FlowChart, FlowChartFlags

# From function
flowchart = FlowChart(db, func=my_func)

# From address range
flowchart = FlowChart(db, bounds=(start_ea, end_ea))

# With predecessor info
flowchart = FlowChart(db, func=my_func, flags=FlowChartFlags.PREDS)
```

### Iterating Basic Blocks

```python
for block in flowchart:
    print(f"Block {block.id}: {block.start_ea:#x} - {block.end_ea:#x}")

# By index
block = flowchart[0]
count = len(flowchart)
```

### Block Navigation

```python
for succ in block.get_successors():
    print(f"Successor: {succ.id}")

for pred in block.get_predecessors():
    print(f"Predecessor: {pred.id}")

succ_count = block.count_successors()
pred_count = block.count_predecessors()
```

### Block Instructions

```python
for insn in block.get_instructions():
    print(f"{insn.ea:#x}")
```

---

## Enums Reference

### XrefType

```python
from ida_domain.xrefs import XrefType

XrefType.OFFSET       # Offset reference
XrefType.WRITE        # Write access
XrefType.READ         # Read access
XrefType.CALL_FAR     # Far call
XrefType.CALL_NEAR    # Near call
XrefType.JUMP_FAR     # Far jump
XrefType.JUMP_NEAR    # Near jump
XrefType.ORDINARY_FLOW  # Sequential flow

xref_type.is_code_ref()  # Check if code ref
xref_type.is_data_ref()  # Check if data ref
```

### FunctionFlags

```python
from ida_domain.functions import FunctionFlags

FunctionFlags.NORET      # Doesn't return
FunctionFlags.LIB        # Library function
FunctionFlags.THUNK      # Thunk function
FunctionFlags.HIDDEN     # Hidden chunk
FunctionFlags.LUMINA     # From Lumina
FunctionFlags.FAR        # Far function
FunctionFlags.FRAME      # Uses frame pointer
```

### LocalVariableAccessType

```python
from ida_domain.functions import LocalVariableAccessType

LocalVariableAccessType.READ     # Variable is read
LocalVariableAccessType.WRITE    # Variable is written
LocalVariableAccessType.ADDRESS  # Address taken (&var)
```

### LocalVariableContext

```python
from ida_domain.functions import LocalVariableContext

LocalVariableContext.ASSIGNMENT    # var = expr
LocalVariableContext.CONDITION     # if (var)
LocalVariableContext.CALL_ARG      # func(var)
LocalVariableContext.RETURN        # return var
LocalVariableContext.ARITHMETIC    # var + 1
LocalVariableContext.COMPARISON    # var == x
LocalVariableContext.ARRAY_INDEX   # arr[var]
LocalVariableContext.POINTER_DEREF # *var
LocalVariableContext.CAST          # (type)var
```

### OperandType

```python
from ida_domain.operands import OperandType

OperandType.REGISTER      # Register
OperandType.MEMORY        # Direct memory
OperandType.PHRASE        # Register addressing
OperandType.DISPLACEMENT  # Reg + displacement
OperandType.IMMEDIATE     # Immediate value
OperandType.FAR_ADDRESS   # Far address
OperandType.NEAR_ADDRESS  # Near address
```

### StringType

```python
from ida_domain.strings import StringType

StringType.C        # C-style null-terminated
StringType.C_16     # C-style 16-bit
StringType.C_32     # C-style 32-bit
StringType.PASCAL   # Pascal-style
StringType.LEN2     # 2-byte length prefix
StringType.LEN4     # 4-byte length prefix
```

### SegmentPermissions

```python
from ida_domain.segments import SegmentPermissions

SegmentPermissions.READ
SegmentPermissions.WRITE
SegmentPermissions.EXEC
SegmentPermissions.ALL
```

### AddressingMode

```python
from ida_domain.segments import AddressingMode

AddressingMode.BIT16  # 16-bit segment
AddressingMode.BIT32  # 32-bit segment
AddressingMode.BIT64  # 64-bit segment
```

### PredefinedClass

```python
from ida_domain.segments import PredefinedClass

PredefinedClass.CODE
PredefinedClass.DATA
PredefinedClass.CONST
PredefinedClass.STACK
PredefinedClass.BSS
PredefinedClass.XTRN
```

### CommentKind

```python
from ida_domain.comments import CommentKind

CommentKind.REGULAR     # Normal comment
CommentKind.REPEATABLE  # Shows at all refs
CommentKind.ALL         # Both types
```

### ExtraCommentKind

```python
from ida_domain.comments import ExtraCommentKind

ExtraCommentKind.ANTERIOR   # Before the line
ExtraCommentKind.POSTERIOR  # After the line
```

### TypeAttr

```python
from ida_domain.types import TypeAttr

TypeAttr.INT, TypeAttr.UINT
TypeAttr.FLOAT, TypeAttr.DOUBLE
TypeAttr.PTR, TypeAttr.ARRAY
TypeAttr.FUNC, TypeAttr.STRUCT
TypeAttr.UNION, TypeAttr.ENUM
TypeAttr.CONST, TypeAttr.VOLATILE
```

### FlowChartFlags

```python
from ida_domain.flowchart import FlowChartFlags

FlowChartFlags.NONE   # Default
FlowChartFlags.NOEXT  # Don't compute external blocks
FlowChartFlags.PREDS  # Compute predecessors
```

---

## Common Patterns

### Find All Calls to a Function

```python
func = db.functions.get_function_by_name("malloc")
if func:
    for caller in db.xrefs.get_callers(func.start_ea):
        print(f"Called from {caller.name} at {caller.ea:#x}")
```

### Rename Functions Based on Strings

```python
for func in db.functions:
    for insn in db.functions.get_instructions(func):
        for xref in db.xrefs.from_ea(insn.ea):
            string = db.strings.get_at(xref.to_ea)
            if string and "error" in str(string).lower():
                db.functions.set_name(func, f"func_with_error_{func.start_ea:x}")
                break
```

### Analyze Function Complexity

```python
func = db.functions.get_at(ea)
flowchart = db.functions.get_flowchart(func)
print(f"Basic blocks: {len(flowchart)}")

total_edges = sum(block.count_successors() for block in flowchart)
print(f"Cyclomatic complexity: {total_edges - len(flowchart) + 2}")
```

### Export Function Pseudocode

```python
for func in db.functions:
    name = db.functions.get_name(func)
    try:
        pseudocode = db.functions.get_pseudocode(func)
        print(f"// {name}")
        for line in pseudocode:
            print(line)
    except RuntimeError:
        print(f"// Could not decompile {name}")
```

### Find Cross-References to Strings

```python
for string in db.strings:
    refs = list(db.xrefs.to_ea(string.address))
    if refs:
        print(f'"{string}" referenced from:')
        for xref in refs:
            print(f"  {xref.from_ea:#x}")
```

## Legacy API (Avoid)

The legacy `idc`, `idautils`, `ida_funcs` APIs still work but are harder to use. **Prefer the Domain API** for new analysis scripts. Only use legacy APIs when Domain API doesn't expose needed functionality.

```

`plugins/ida-plugin-development/skills/ida-plugin-development/SKILL.md`:

```md
---
name: ida-plugin-development
description: Develop plugins for IDA Pro in Python, using idiomatic patterns, lessons, and tricks, including the Python Domain API (ida-domain). Use when creating both GUI (Qt) and background plugins for inspecting and rendering things program structure, functions, disassembly, cross-references, and strings.
---

# Developing IDA Pro plugins

Use this skill when developing plugins for IDA Pro using Python.

IDA's UI and analysis passes can be almost completely replaced through plugins.
There's a lot of power (and a lot of complexity), so its important to follow known patterns.
This document lists tips and tricks for creating new plugins for modern versions of IDA.

Key concepts covered in this document:
- [Use the IDA Domain API](#use-the-ida-domain-api) - prefer the high-level Pythonic interface
- [Plugin Manager Integration](#plugin-manager-integration) - packaging and distribution
- [Plugin Entry Point](#plugin-entry-point) - version checking and conditional loading
- [Hook Registration](#hook-registration) - pairwise register/unregister pattern
- [Cross-Plugin Communication via IDC Functions](#cross-plugin-communication-via-idc-functions) - invoke plugin functionality from scripts/other plugins
- [Save/Load state from netnodes](#saveload-state-from-netnodes) - persist plugin data in IDB
- [Respond to current address and selection change](#respond-to-current-address-and-selection-change) - UI location hooks
- [Find widgets by prefix](#find-widgets-by-prefix) - managing multiple widget instances
- [Context Menu Entries](#context-menu-entries-send-to-foo-and-send-to-foo-a) - "Send to Foo" patterns
- [User Defined Prefix](#user-defined-prefix) - add contextual markers in disassembly
- [Viewer Hints](#viewer-hints) - hover popups with context
- [Overriding rendering](#overriding-rendering) - custom colors and mnemonics
- [Custom Viewers](#custom-viewers) - tagged lines with clickable addresses


## Use the IDA Domain API

Always prefer the IDA Domain API over the legacy low-level IDA Python SDK. The Domain API provides a clean, Pythonic interface that is easier to use and understand.
However, there will be some things that the Domain API doesn't cover, especially around plugin registration and GUI handling.

Right now: read this intro guide: https://ida-domain.docs.hex-rays.com/getting_started/index.md 

Always refer to the documentation rather than doing introspection, because the documentation explains concepts, not just symbol names.
To fetch specific API documentation, use URLs like:
- `https://ida-domain.docs.hex-rays.com/ref/functions/index.md` - Function analysis API
- `https://ida-domain.docs.hex-rays.com/ref/xrefs/index.md` - Cross-reference API
- `https://ida-domain.docs.hex-rays.com/ref/strings/index.md` - String analysis API

Available API modules: `bytes`, `comments`, `database`, `entries`, `flowchart`, `functions`, `heads`, `hooks`, `instructions`, `names`, `operands`, `segments`, `signature_files`, `strings`, `types`, `xrefs`
URL pattern: https://ida-domain.docs.hex-rays.com/ref/{module}/index.md

You can always ask a subagent to answer a question by exploring the documentation and summarizing its findings.

### Key Database Properties

```python
with Database.open(path, ida_options) as db:
    db.minimum_ea      # Start address
    db.maximum_ea      # End address
    db.metadata        # Database metadata
    db.architecture    # Target architecture

    db.functions       # All functions (iterable)
    db.strings         # All strings (iterable)
    db.segments        # Memory segments
    db.names           # Symbols and labels
    db.entries         # Entry points
    db.types           # Type definitions
    db.comments        # All comments
    db.xrefs           # Cross-reference utilities
    db.bytes           # Byte manipulation
    db.instructions    # Instruction access
```

### Common Analysis Tasks

#### List Functions

```python
func: func_t
for func in db.functions:
    name = db.functions.get_name(func)
    print(f"{hex(func.start_ea)}: {name} ({func.size} bytes)")
```

Interesting `func_t` properties:
```python
class func_t:
    name: str
    flags: int
    start_ea: int
    end_ea: int
    size: int
    does_return: bool
    referers: list[int]  # function start addresses
    addresses: list[int]
    frame_object: tinfo_t
    prototype: tinfo_t
```


#### Cross-references
```python
for xref in db.xrefs.to_ea(target_addr):
    print(f"Referenced from {hex(xref.from_ea)} (type: {xref.type.name})")

for xref in db.xrefs.from_ea(source_addr):
    print(f"References {hex(xref.to_ea)}")

for xref in db.xrefs.calls_to_ea(func_addr):
    print(f"Called from {hex(xref.from_ea)}")
```

`XrefInfo` type:
```python
XrefInfo(
    from_ea: int,
    to_ea: int,
    is_code: bool,
    type: XrefType,
    user: bool,
)
```

#### Read data
```python
db.bytes.get_byte_at(addr)
db.bytes.get_bytes_at(addr)
db.bytes.get_cstring_at(addr)
db.bytes.get_word_at(addr)
db.bytes.get_dword_at(addr)
db.bytes.get_qword_at(addr)
db.bytes.get_disassembly_at(addr)
db.bytes.get_flags_at(addr)
```


## Plugin Manager Integration

Plugins must be compatible with the Hex-Rays Plugin Manager.

Making your plugin available via Plugin Manager offers several benefits:

- simplified plugin installation
- improved plugin discoverability through the central index
- easy Python dependency management

The key points to make your IDA plugin available via Plugin Manager are:

- Add `ida-plugin.json`
- Package your plugin into a ZIP archive (via source archives or GitHub Actions)
- Publish releases on GitHub

A complete `ida-plugin.json` example:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "ida-terminal-plugin",
    "entryPoint": "index.py",
    "version": "1.0.0",
    "idaVersions": ">=9.2",
    "platforms": [
      "windows-x86_64",
      "linux-x86_64",
      "macos-x86_64",
      "macos-aarch64",
    ],
    "description": "A lightweight terminal integration for IDA Pro that lets you open a fully functional terminal within the IDA GUI.\nQuickly access shell commands, scripts, or tooling without leaving your reversing environment.",
    "license": "MIT",
    "logoPath": "ida-plugin.png",
    "categories": [
      "ui-ux-and-visualization"
    ],
    "keywords": [
      "terminal",
      "shell",
      "cli",
    ],
    "pythonDependencies": [
      "pydantic>=2.12"
    ],
    "urls": {
      "repository": "https://github.com/williballenthin/idawilli"
    },
    "authors": [{
      "name": "Willi Ballenthin",
      "email": "wballenthin@hex-rays.com"
    }],
    "settings": [
      {
        "key": "theme",
        "type": "string",
        "required": true,
        "default": "darcula",
        "name": "color theme",
        "documentation": "the color theme name, picked from https://windowsterminalthemes.dev/",
      }
    ]
  }
}
```

Before completing your work, review the following resources for packaging hints:

- https://hcli.docs.hex-rays.com/reference/plugin-repository-architecture/
- https://hcli.docs.hex-rays.com/reference/plugin-packaging-and-format/
- https://hcli.docs.hex-rays.com/reference/packaging-your-existing-plugin/

Use the script `./scripts/hcli-package.py` to invoke HCLI in a consistent way and lint the current plugin.

## Use ida-settings for configuration values

ida-settings is a Python library used by IDA Pro plugins to fetch configuration values from the shared settings infrastructure.

During plugin installation, the plugin manager prompts users for the configuration values and stores them in `ida-config.json`.
Subsequently, users can invoke HCLI (or later, the IDA Pro GUI) to update their configuration.
ida-settings is the library that plugins use to fetch the configuration values.

For example:

```python
import ida_settings
api_key = ida_settings.get_current_plugin_setting("openai_key")
```

Note that this must be called from within the plugin (`plugin_t` or `plugmod_t`), not a callback or hook;
capture an instance of the plugin settings and pass it around as necessary:

```python
class Hooks(idaapi.IDP_Hooks):
    def __init__(self, settings):
        super().__init__()
        self.settings = settings
        
    def ev_get_bg_color(self, color, ea):
        mnem = ida_ua.print_insn_mnem(ea)

        if mnem == "call" or mnem == "CALL":
            bgcolor = ctypes.cast(int(color), ctypes.POINTER(ctypes.c_int))
            bgcolor[0] = int(settings.get_setting("bg_color"))
            return 1

        else:
            return 0

class FooPluginMod(ida_idaapi.plugmod_t):
    def run(self, arg):
        settings = ida_settings.get_current_plugin_settings()
        self.hooks = Hooks(settings)
        self.hooks.hook()

```

Available APIs are:
 - `del(_current)_plugin_setting`
 - `get(_current)_plugin_setting`
 - `has(_current)_plugin_setting`
 - `set(_current)_plugin_setting`
 - `list(_current)_plugin_settings`


## Use standard logging module

Don't use `print` for status messages - use `logging.*` routines.
Do not configure logging from within a plugin - its up to the user to
 configure which levels and sources they want to see in their output window.


## Plugin Entry Point

The entrypoint of the plugin should be `foo_entry.py`
which imports from `foo.py` only if the environment is correct.

If the plugin runs in all IDA environments (assuming dependencies are present, which is reasonable),
then you don't need a special wrapper like this.

For example, if the plugin requires Qt and/or IDA to be running graphically, you could do something like:

`foo_entry.py`:
```python
import logging
import os

import ida_kernwin

logger = logging.getLogger(__name__)

def should_load():
    """Returns True if IDA 9.2+ is running interactively."""
    if not ida_kernwin.is_idaq():
        # https://community.hex-rays.com/t/how-to-check-if-idapythonrc-py-is-running-in-ida-pro-or-idalib/297/4
        return False

    if os.environ.get("IDA_IS_INTERACTIVE") != "1":
        # https://community.hex-rays.com/t/how-to-check-if-idapythonrc-py-is-running-in-ida-pro-or-idalib/297/2
        return False

    kernel_version: tuple[int, ...] = tuple(
        int(part) for part in ida_kernwin.get_kernel_version().split(".") if part.isdigit()
    ) or (0,)
    if kernel_version < (9, 2):  # type: ignore
        logger.warning("IDA too old (must be 9.2+): %s", ida_kernwin.get_kernel_version())
        return False

    return True


if should_load():
    # only attempt to import the plugin once we know the required dependencies are present.
    # otherwise we'll hit ImportError and other problems
    from foo import foo_plugin_t

    def PLUGIN_ENTRY():
        return foo_plugin_t()

else:
    try:
        import ida_idaapi
    except ImportError:
        import idaapi as ida_idaapi

    class foo_nop_plugin_t(ida_idaapi.plugin_t):
        flags = ida_idaapi.PLUGIN_HIDE | ida_idaapi.PLUGIN_UNL
        wanted_name = "foo disabled"
        comment = "foo is disabled for this IDA version"
        help = ""
        wanted_hotkey = ""

        def init(self):
            return ida_idaapi.PLUGIN_SKIP
    
    # we have to define this symbol, or IDA logs a message
    def PLUGIN_ENTRY():
        # we have to return something here, or IDA logs a message
        return foo_nop_plugin_t()
```

`foo.py`:
```python
class foo_plugmod_t(ida_idaapi.plugmod_t):
    def __init__(self):
        # IDA doesn't invoke this for plugmod_t, only plugin_t
        self.init()

    def init(self):
        # do things here that will always run,
        #  and don't require the menu entry (edit > plugins > ...) being selected.
        #
        # note: IDA doesn't call init, we do in __init__

        if not ida_auto.auto_is_ok():
            # don't capture events before auto-analysis is done, or we get all the system events.
            #
            # note:
            # - when we first load a program, this plugin will be run before auto-analysis is complete
            #   (actually, before auto-analysis even starts).
            #   so auto_is_ok() returns False
            # - when we load an existing IDB, auto_is_ok() return True.
            # so we can safely use this to wait until auto-analysis is complete for the first time.
            logger.debug("waiting for auto-analysis to complete before subscribing to events")
            ida_auto.auto_wait()
            logger.debug("auto-analysis complete, now subscribing to events")

        ...

    def run(self, arg):
        # do things here that users invoke via the menu entry (edit > plugins > ...)
        ...

    def term(self):
        # cleanup resources, unhook handlers, etc.
        ...

class foo_plugin_t(ida_idaapi.plugin_t):
    flags = ida_idaapi.PLUGIN_MULTI
    help = "Do some foo"
    comment = ""
    wanted_name = "Foo"
    wanted_hotkey = ""

    def init(self):
        return foo_plugmod_t()
```


## Hook Registration

Create pairwise helper functions for registering/unregistering hooks,
and call these from `init`/`term`

```python
class oplog_plugmod_t(ida_idaapi.plugmod_t):
    def __init__(self):
        self.idb_hooks: IDBChangedHook | None = None
        self.location_hooks: UILocationHook | None = None
        ...

    def register_idb_hooks(self):
        assert self.events is not None
        self.idb_hooks = IDBChangedHook(self.events)
        self.idb_hooks.hook()

    def unregister_idb_hooks(self):
        if self.idb_hooks:
            self.idb_hooks.unhook()

    def register_location_hooks(self):
        assert self.events is not None
        self.location_hooks = UILocationHook(self.events)
        self.location_hooks.hook()

    def unregister_location_hooks(self):
        if self.location_hooks:
            self.location_hooks.unhook()

    def init(self):
        ...
        self.register_idb_hooks()
        self.register_location_hooks()

    def run(self, arg):
        ...

    def term(self):
        # cleanup in reverse order
        self.unregister_location_hooks()
        self.unregister_idb_hooks()
        ...
```


## Cross-Plugin Communication via IDC Functions

Python plugins can import shared libraries, and two plugins may even have the same dependencies. One plugin can import code from another plugin's module. However, to invoke functionality on a specific *instance* of a running plugin (accessing its state, calling methods that depend on instance data), you need a different mechanism.

Use `ida_expr.add_idc_func` to register a callable with a well-known name, and `idc.eval_idc` to invoke it from scripts or other plugins.

Key constraints:
- The function name must be globally unique - only one plugin should register a given name
- There's only a single provider for that name (no multiple instances registering the same name)
- The registering plugin must unregister the function during `term()`

```python
import ida_expr

class foo_plugmod_t(ida_idaapi.plugmod_t):
    def __init__(self):
        self.data: list[str] = []
        self.init()

    def register_idc_func(self):
        data = self.data

        def foo_get_data(index: int) -> str:
            if 0 <= index < len(data):
                return data[index]
            return ""

        def foo_add_data(value: str) -> int:
            data.append(value)
            return len(data)

        if ida_expr.add_idc_func("foo_get_data", foo_get_data, (ida_expr.VT_LONG,)):
            logger.debug("registered foo_get_data IDC function")
        else:
            logger.warning("failed to register foo_get_data IDC function")

        if ida_expr.add_idc_func("foo_add_data", foo_add_data, (ida_expr.VT_STR,)):
            logger.debug("registered foo_add_data IDC function")
        else:
            logger.warning("failed to register foo_add_data IDC function")

    def unregister_idc_func(self):
        ida_expr.del_idc_func("foo_get_data")
        ida_expr.del_idc_func("foo_add_data")

    def init(self):
        self.register_idc_func()

    def term(self):
        self.unregister_idc_func()
```

Callers invoke the function via `idc.eval_idc`:

```python
import idc

idc.eval_idc('foo_add_data("hello")')
result = idc.eval_idc('foo_get_data(0)')
```

Parameter types for `add_idc_func`:
- `ida_expr.VT_STR` - string parameter
- `ida_expr.VT_LONG` - integer parameter
- `ida_expr.VT_FLOAT` - floating point parameter

This pattern is useful for:
- Exporting plugin data to external scripts (headless testing, automation)
- Allowing one plugin to trigger actions in another
- Providing a stable API for plugin functionality that doesn't depend on Python imports


## Save/Load state from netnodes

Use netnodes to store data within the IDB.
Serialize the current plugin state during shutdown, saving it to a netnode.
Reload the state upon startup.


```python
import pydantic

OUR_NETNODE = "$ com.williballenthin.idawilli.foo"


class State(pydantic.BaseModel):
    ...

    def to_json(self):
        return self.model_dump_json()

    @classmethod
    def from_json(cls, json_str: str):
        return cls(State.model_validate_json(json_str))


def save_state(state: State):
    buf = zlib.compress(state.to_json().encode("utf-8"))

    node = ida_netnode.netnode(OUR_NETNODE)
    node.setblob(buf, 0, "I")

    logger.info("saved state")


def load_state() -> State:
    node = ida_netnode.netnode(OUR_NETNODE)
    if not node:
        logger.info("no existing state")
        return State()

    buf = node.getblob(0, "I")
    if not buf:
        logger.info("no existing state (no data)")
        return State()

    state = State.from_json(zlib.decompress(buf).decode("utf-8"))
    logger.info("loaded state")
    return state


class UI_Closing_Hooks(ida_kernwin.UI_Hooks):
    """Respond to UI events and save the events into the database."""

    # we could also use IDB_Hooks, but I found it less reliable:
    # - closebase: "the database will be closed now", however, I couldn't figure out when its actually triggered.
    # - savebase: notified during File -> Save, but not File -> Close.
    # easier to keep all the hooks in one place.

    def __init__(self, events: Events, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.events = events

    def preprocess_action(self, action: str):
        if action == "CloseBase":
            # File -> Close
            save_events(self.events)
            return 0
        elif action == "QuitIDA":
            # File -> Quit
            save_events(self.events)
            return 0
        elif action == "SaveBase":
            # File -> Save
            save_events(self.events)
            return 0
        else:
            return 0
```

## Respond to current address and selection change

```python
class UILocationHook(ida_kernwin.UI_Hooks):
    def handle_current_address_change(self, ea: int):
        ...

    def handle_current_selection_change(self, start: int, end: int):
        ...

    def screen_ea_changed(self, ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t) -> None:
        if ea == prev_ea:
            return

        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
            # BWN_PSEUDOCODE
            # BWN_CUSTVIEW
            # BWN_OUTPUT the text area, in the output window
            # BWN_CLI the command-line, in the output window
            # BWN_STRINGS
            # ...
        ):
            return

        if ida_kernwin.get_viewer_place_type(v) != ida_kernwin.TCCPT_IDAPLACE:
            # other viewers might have other place types, when not address-oriented
            return

        has_range, start, end = ida_kernwin.read_range_selection(v)
        if not has_range:
            return self.handle_current_address_change(ea)

        if ida_idaapi.BADADDR in (start, end):
            return

        return self.handle_current_selection_change(start, end)
```

## Find widgets by prefix

```python
def list_widgets(prefix: str) -> list[str]:
    """Probe A-Z for existing widgets, return found captions.

    Args:
        prefix: Caption prefix to search for

    Returns: List of found widget captions (e.g., ["Foo-A", "Foo-C"])
    """
    if not prefix.endswith("-"):
        raise ValueError("prefix must end with dash")
    found = []
    for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        caption = f"{prefix}{letter}"
        if ida_kernwin.find_widget(caption) is not None:
            found.append(caption)
    return found


def find_next_available_caption(prefix: str) -> str:
    """Find first gap or next letter for widget caption.

    Args:
        prefix: Caption prefix to use

    Returns: First available caption (e.g., "Foo-B")

    Raises:
        RuntimeError: If all 26 instances are in use
    """
    if not prefix.endswith("-"):
        raise ValueError("prefix must end with dash")
    for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        caption = f"{prefix}{letter}"
        if ida_kernwin.find_widget(caption) is None:
            return caption
    raise RuntimeError("All 26 instances in use")
```

## Context Menu Entries, "Send to Foo" and "Send to Foo-A"

When creating custom views, especially when there might be more than one,
 name them like "Foo-A", "Foo-B", etc.
And, as appropriate, add context menu items for "sending" addresses/selections
 to the new views.

The new view is an instance of `ida_kernwin.PluginForm` and may have arbitrary Qt widgets.
The plugin instance maintains a registry of created views, and registers the action
handlers for opening new views, as well as notifying the views of events from a central place.
Action handlers encapsulate the code that's invoked during an event.


```python
class FooForm(ida_kernwin.PluginForm):
    def __init__(
        self,
        caption: str = "Foo-A",
        form_registry: dict[str, "FooForm"] | None = None,
    ) -> None:
        super().__init__()
        self.TITLE = caption
        self.form_registry = form_registry

    def OnCreate(self, form):
        self.parent = self.FormToPyQtWidget(form)
        self.w = FooWidget(parent=self.parent, show_ida_buttons=True)

        ... # other Qt stuff here

        if self.form_registry is not None:
            self.form_registry[self.TITLE] = self

    def OnClose(self, form):
        if self.form_registry is not None:
            self.form_registry.pop(self.TITLE, None)


class create_foo_widget_action_handler_t(ida_kernwin.action_handler_t):
    def __init__(self, plugmod: "foo_plugmod_t", *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.plugmod = plugmod

    def activate(self, ctx):
        self.plugmod.create_viewer()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class send_to_foo_action_handler_t(ida_kernwin.action_handler_t):
    """Action handler for 'Send to Foo' context menu item."""

    def __init__(self, plugmod: "foo_plugmod_t", *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.plugmod = plugmod

    def activate(self, ctx):
        """Handle 'Send to Foo' action - always creates new instance."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            # for example: only allow sending from hexview or disassembly view
            return 0

        form = self.plugmod.create_viewer()

        if form and form.w:
            ... # do initialization

        return 1

    def update(self, ctx):
        """Enable action when there's a valid selection."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            # for example: only allow sending from hexview or disassembly view
            return ida_kernwin.AST_DISABLE
        return ida_kernwin.AST_ENABLE


class send_to_specific_widget_action_handler_t(ida_kernwin.action_handler_t):
    """Action handler for sending to a specific Foo instance."""

    def __init__(
        self,
        form_registry: dict[str, FooForm],
        caption: str,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(*args, **kwargs)
        self.form_registry = form_registry
        self.caption = caption

    def activate(self, ctx):
        """Send selection to specific Foo instance."""
        v = ida_kernwin.get_current_viewer()

        widget = ida_kernwin.find_widget(self.caption)
        if widget is None:
            logger.warning(f"Widget {self.caption} not found")
            return 0

        ida_kernwin.activate_widget(widget, True)

        form = self.form_registry.get(self.caption)
        if form and hasattr(form, "w"):
            # access some specific model methods on the form
            ...
        else:
            logger.warning(f"Cannot populate {self.caption} - unable to access form")

        return 1

    def update(self, ctx):
        """Enable action when there's a valid selection."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            # for example: only allow sending from hexview or disassembly view
            return ida_kernwin.AST_DISABLE
        return ida_kernwin.AST_ENABLE


class foo_plugmod_t(ida_idaapi.plugmod_t):
    ACTION_NAME = "foo:create"
    SEND_ACTION_NAME = "foo:send_selection"
    MENU_PATH = "View/Open subviews/Foo"

    def __init__(self):
        super().__init__()
        self.form_registry: dict[str, FooForm] = {}
        ...

    def register_instance_actions(self):
        """Register actions for all existing widget instances."""
        existing = list_widgets("Foo-")

        for caption in existing:
            action_name = f"foo:send_to_{caption.replace('-', '_').lower()}"

            if ida_kernwin.unregister_action(action_name):
                pass

            ida_kernwin.register_action(
                ida_kernwin.action_desc_t(
                    action_name,
                    f"Send to {caption}",
                    send_to_specific_widget_action_handler_t(
                        self.form_registry, caption
                    ),
                    None,
                    f"Send selected bytes to {caption}",
                    -1,
                )
            )

    def create_viewer(self, caption: str | None = None) -> FooForm:
        if caption is None:
            caption = find_next_available_caption()
        form = FooForm(caption, self.form_registry)
        form.Show(form.TITLE)
        return form

    def register_open_action(self):
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
                self.ACTION_NAME,
                "Foo",
                create_foo_widget_action_handler_t(self),
            )
        )

        # TODO: add icon
        ida_kernwin.attach_action_to_menu(
            self.MENU_PATH, self.ACTION_NAME, ida_kernwin.SETMENU_APP
        )

    def unregister_open_action(self):
        ida_kernwin.unregister_action(self.ACTION_NAME)
        ida_kernwin.detach_action_from_menu(self.MENU_PATH, self.ACTION_NAME)


    def init(self):
        self.register_open_action()
        ...

    def run(self, arg):
        self.create_viewer()

    def term(self):
        ...
        self.unregister_open_action()
```

## User Defined Prefix

A user defined prefix is a great way to add some contextual data before each disassembly line.
Put symbols or numbers here to indicate there's more context available somewhere.


```python
def refresh_disassembly():
    ida_kernwin.request_refresh(ida_kernwin.IWID_DISASM)

class FooPrefix(ida_lines.user_defined_prefix_t):
    ICON = " β "

    def __init__(self, marks: set[int]):
        super().__init__(len(self.ICON))
        self.marks = marks

    def get_user_defined_prefix(self, ea, insn, lnnum, indent, line):
        if ea in self.marks:
            # wrap the icon in color tags so its easy to identify.
            # otherwise, the icon may merge with other spans, which
            # makes checking for equality more difficult.
            return ida_lines.COLSTR(self.ICON, ida_lines.SCOLOR_SYMBOL)

        return " " * len(self.ICON)

class FooPrefixPluginMod(ida_idaapi.plugmod_t):
    def __init__(self):
        self.marks: set[int] = {1, 2, 3}
        self.prefixer: FooPrefix | None = None

    def run(self, arg):
        # self.prefixer is installed simply by constructing it
        self.prefixer = FooPrefix(self.marks)

        # since we're updating the disassembly listing by adding the line prefix,
        # we need to re-render all the lines.
        refresh_disassembly()

    def term(self):
        # gc will clean up prefixer and uninstall it (during plugin termination)
        self.prefixer = None

        # refresh and remove the prefix entries
        refresh_disassembly()
```

## Viewer Hints

A view hint is a really good way to display complex information in a popup hover pane
that displays when mousing over particular regions of an IDA view.
Use this to show context about a symbol or address, for example: MSDN documentation for API functions.

Use this in combination with User Defined Prefixes that indicate context *is* available and
show the context *in* the viewer hint (possibly when hovering over the prefix).

```python
class FooHints(ida_kernwin.UI_Hooks):
    def __init__(self, notes: dict[int, str], *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.notes = notes

    def get_custom_viewer_hint(self, viewer, place):
        if not place:
            return

        ea = place.toea()
        if not ea:
            return

        if ea not in self.notes:
            return

        curline = ida_kernwin.get_custom_viewer_curline(viewer, True)
        curline = ida_lines.tag_remove(curline)
        _, x, _ = ida_kernwin.get_custom_viewer_place(viewer, True)

        # example: show on first column
        # more advanced: inspect the symbol, and if it matches a query, then show some data
        if x == 1:
            note = self.notes.get(ea)
            if not note:
                return

            return (f"note: {note}", 1)


class FooHintsPluginMod(ida_idaapi.plugmod_t):
    def __init__(self):
        self.notes: dict[int, str] = {}
        self.hinter: FooHints | None = None

    def run(self, arg):
        self.hinter = FooHints(self.notes)
        self.hinter.hook()

    def term(self):
        if self.hinter is not None:
            self.hinter.unhook()

        self.hinter = None
```

## Overriding rendering



```python
class ColorHooks(idaapi.IDP_Hooks):
    def ev_get_bg_color(self, color, ea):
        """
        Get item background color.
        Plugins can hook this callback to color disassembly lines dynamically

            // background color in RGB
            typedef uint32 bgcolor_t;

        ref: https://hex-rays.com/products/ida/support/sdkdoc/pro_8h.html#a3df5040891132e50157aee66affdf1de

        args:
            color: (bgcolor_t *), out
            ea: (::ea_t)

        returns:
            retval 0: not implemented
            retval 1: color set
        """
        mnem = ida_ua.print_insn_mnem(ea)

        if mnem == "call" or mnem == "CALL":
            bgcolor = ctypes.cast(int(color), ctypes.POINTER(ctypes.c_int))
            bgcolor[0] = 0xDDDDDD
            return 1

        else:
            return 0

    def ev_out_mnem(self, ctx) -> int:
        """
        Generate instruction mnemonics.
        This callback should append the colored mnemonics to ctx.outbuf 
        Optional notification, if absent, out_mnem will be called.

        args:
            ctx: (outctx_t *)

        returns:
            retval 1: if appended the mnemonics
            retval 0: not implemented
        """
        mnem = ctx.insn.get_canon_mnem()
        if mnem == "call":
            # you can manipulate this, but note that it affects `ida_ua.print_insn_mnem` which is inconvenient for formatting.
            # also, you only have access to theme colors, like COLOR_PREFIX, not arbitrary control.
            ctx.out_custom_mnem("CALL")
            return 1

        else:
            return 0


class ColoringPluginMod(ida_idaapi.plugmod_t):
    def __init__(self):
        self.hooks: ColorHooks | None = None

    def run(self, arg):
        self.hooks = ColorHooks()
        self.hooks.hook()

    def term(self):
        if self.hooks is not None:
            self.hooks.unhook()

        self.hooks = None
```


## Custom Viewers

Use a custom viewer to show text data, optionally with tags, and respond to basic events (clicks).
Use the tagged line concepts to embed and parse metadata about the symbols in a line,
such as which address it refers to.

```python
def addr_from_tag(raw: bytes) -> int:
    assert raw[0] == 0x01  # ida_lines.COLOR_ON
    assert raw[1] == ida_lines.COLOR_ADDR
    addr_hex = raw[2 : 2 + ida_lines.COLOR_ADDR_SIZE].decode("ascii")

    try:
        # Parse as hex address (IDA uses qsscanf with "%a" format)
        return int(addr_hex, 16)
    except ValueError:
        raise


def get_tagged_line_section_byte_offsets(section: ida_kernwin.tagged_line_section_t) -> tuple[int, int]:
    # tagged_line_section_t.byte_offsets is not exposed by swig
    # so we parse directly from the string representation (puke)
    s = str(section)
    text_start_index = s.index("text_start=")
    text_end_index = s.index("text_end=")

    text_start_s = s[text_start_index + len("text_start=") :].partition(",")[0]
    text_end_s = s[text_end_index + len("text_end=") :].partition("}")[0]

    return int(text_start_s), int(text_end_s)


@dataclass
class TaggedLineSection:
    tag: int
    string: str
    # valid when the found tag section starts with an embedded address
    address: int | None


def get_current_tag(line: str, x: int) -> TaggedLineSection:
    ret = TaggedLineSection(ida_lines.COLOR_DEFAULT, line, None)

    tls = ida_kernwin.tagged_line_sections_t()
    if not ida_kernwin.parse_tagged_line_sections(tls, line):
        return ret

    # find any section at the X coordinate
    current_section = tls.nearest_at(x, 0)  # 0 = any tag
    if not current_section:
        # TODO: we only want the section that isn't tagged
        # while there might be a section totally before or totally after x.
        return ret

    ret.tag = current_section.tag
    boring_line = ida_lines.tag_remove(line)
    ret.string = boring_line[current_section.start : current_section.start + current_section.length]

    # try to find an embedded address at the start of the current segment
    current_section_start, _ = get_tagged_line_section_byte_offsets(current_section)
    addr_section = tls.nearest_before(current_section, x, ida_lines.COLOR_ADDR)
    if addr_section:
        addr_section_start, _ = get_tagged_line_section_byte_offsets(addr_section)
        # addr_section_start initially points just after the address data (ON ADDR 001122...FF)
        # so rewind to the start of the tag (16 bytes of hex integer, 2 bytes of tags "ON ADDR")
        addr_tag_start = addr_section_start - (ida_lines.COLOR_ADDR_SIZE + 2)
        assert addr_tag_start >= 0

        # and this should match current_section_start, since that points just after the tag "ON SYMBOL"
        # if it doesn't, we're dealing with an edge case we didn't prepare for
        # maybe like multiple ADDR tags or something.
        # skip those and stick to things we know.
        if current_section_start == addr_tag_start:
            raw = line.encode("utf-8")
            addr = addr_from_tag(raw[addr_tag_start : addr_tag_start + ida_lines.COLOR_ADDR_SIZE + 2])
            ret.address = addr

    return ret


class foo_viewer_t(ida_kernwin.simplecustviewer_t):
    TITLE = "foo"

    def __init__(self):
        super().__init__()

        self.timer: QtCore.QTimer = QtCore.QTimer()
        self.timer.timeout.connect(self.on_timer_timeout)

    def Create(self):
        if not super().Create(self.TITLE):
            return False

        self.render()

        return True

    def Show(self, *args):
        if not super().Show(*args):
            return False

        ida_kernwin.attach_action_to_popup(self.GetWidget(), None, some_action_handler_t.ACTION_NAME)
        return True

    def on_timer_timeout(self):
        self.render()

    def OnClose(self):
        self.timer.stop()

    def render(self):
        self.ClearLines()
        self.AddLine(datetime.datetime.now.isoformat())
        self.AddLine(ida_lines.COLSTR(ida_lines.tag_addr(0x401000) + "sub_401000", ida_lines.SCOLOR_CNAME))

    def OnDblClick(self, shift):
        line = self.GetCurrentLine()
        if not line:
            return False

        _linen, x, _y = self.GetPos()

        section = get_current_tag(line, x)
        if section.address is not None:
            ida_kernwin.jumpto(section.address)

        item_address = ida_name.get_name_ea(0, section.string)
        if item_address != ida_idaapi.BADADDR:
            logger.debug(f"found address for '{section.string}': {item_address:x}")
            ida_kernwin.jumpto(item_address)

        return True  # handled
```

```

`plugins/ida-plugin-development/skills/ida-plugin-development/scripts/hcli-package.py`:

```py
#!/usr/bin/env python3
"""
IDA Plugin Skill - Package Script

Packages a plugin directory into an HCLI-compatible ZIP archive,
runs lint validation, and optionally installs the plugin.
"""

import argparse
import json
import subprocess
import sys
import zipfile
from pathlib import Path


def validate_plugin_dir(plugin_dir: Path) -> bool:
    """Validate that the plugin directory has required files."""
    manifest = plugin_dir / "ida-plugin.json"

    if not manifest.exists():
        print(f"ERROR: ida-plugin.json not found in {plugin_dir}")
        return False

    # Parse and validate manifest
    try:
        with open(manifest) as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        print(f"ERROR: Invalid JSON in ida-plugin.json: {e}")
        return False

    # Check required fields
    required = ["IDAMetadataDescriptorVersion", "plugin"]
    for field in required:
        if field not in data:
            print(f"ERROR: Missing required field: {field}")
            return False

    plugin_data = data.get("plugin", {})
    plugin_required = ["name", "version", "entryPoint", "authors", "urls"]
    for field in plugin_required:
        if field not in plugin_data:
            print(f"ERROR: Missing required plugin field: {field}")
            return False

    # Check entry point exists
    entry_point = plugin_data.get("entryPoint", "")
    entry_path = plugin_dir / entry_point
    if not entry_path.exists():
        print(f"ERROR: Entry point not found: {entry_point}")
        return False

    return True


def create_zip(plugin_dir: Path, output_path: Path) -> bool:
    """Create a ZIP archive from the plugin directory."""
    try:
        with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            for file_path in plugin_dir.rglob('*'):
                if file_path.is_file():
                    # Skip common unwanted files
                    if file_path.name.startswith('.') or file_path.suffix == '.pyc':
                        continue
                    if '__pycache__' in str(file_path):
                        continue

                    arcname = file_path.relative_to(plugin_dir)
                    zf.write(file_path, arcname)
        return True
    except Exception as e:
        print(f"ERROR: Failed to create ZIP: {e}")
        return False


def run_lint(zip_path: Path) -> bool:
    """Run hcli plugin lint on the ZIP archive."""
    try:
        result = subprocess.run(
            ["uv", "run", "--with=ida-hcli", "hcli", "plugin", "lint", str(zip_path)],
            capture_output=True,
            text=True,
            timeout=60
        )

        if result.stdout:
            print(result.stdout)
        if result.stderr:
            print(result.stderr)

        return result.returncode == 0
    except FileNotFoundError:
        print("ERROR: hcli not found. Run setup.py first.")
        return False
    except subprocess.TimeoutExpired:
        print("ERROR: hcli lint timed out")
        return False


def install_plugin(zip_path: Path) -> bool:
    """Install the plugin using hcli."""
    try:
        result = subprocess.run(
            ["uv", "run", "--with=ida-hcli", "hcli", "plugin", "install", str(zip_path)],
            capture_output=True,
            text=True,
            timeout=120
        )

        if result.stdout:
            print(result.stdout)
        if result.stderr:
            print(result.stderr)

        return result.returncode == 0
    except FileNotFoundError:
        print("ERROR: hcli not found. Run setup.py first.")
        return False
    except subprocess.TimeoutExpired:
        print("ERROR: hcli install timed out")
        return False


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Package an IDA plugin for distribution"
    )
    parser.add_argument(
        "plugin_dir",
        type=Path,
        help="Path to the plugin directory"
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        help="Output ZIP path (default: <plugin_name>.zip in current directory)"
    )
    parser.add_argument(
        "--install",
        action="store_true",
        help="Install the plugin after packaging"
    )
    parser.add_argument(
        "--no-lint",
        action="store_true",
        help="Skip lint validation"
    )

    args = parser.parse_args()

    plugin_dir = args.plugin_dir.resolve()

    if not plugin_dir.is_dir():
        print(f"ERROR: Not a directory: {plugin_dir}")
        return 1

    print("IDA Plugin Packager")
    print("=" * 40)
    print()

    # Validate
    print(f"Validating: {plugin_dir}")
    if not validate_plugin_dir(plugin_dir):
        return 1
    print("  Validation passed")
    print()

    # Determine output path
    if args.output:
        output_path = args.output.resolve()
    else:
        # Get plugin name from manifest
        with open(plugin_dir / "ida-plugin.json") as f:
            data = json.load(f)
        plugin_name = data["plugin"]["name"]
        output_path = Path.cwd() / f"{plugin_name}.zip"

    # Create ZIP
    print(f"Creating: {output_path}")
    if not create_zip(plugin_dir, output_path):
        return 1
    print("  ZIP created")
    print()

    # Lint
    if not args.no_lint:
        print("Running hcli plugin lint...")
        if not run_lint(output_path):
            print("  Lint FAILED")
            return 1
        print("  Lint passed")
        print()

    # Install
    if args.install:
        print("Installing plugin...")
        if not install_plugin(output_path):
            print("  Install FAILED")
            return 1
        print("  Install successful")
        print()

    print("Done!")
    print(f"Plugin archive: {output_path}")

    return 0


if __name__ == "__main__":
    sys.exit(main())

```

`plugins/ida-plugin-development/skills/package-ida-plugin/SKILL.md`:

```md
---
name: package-ida-plugin
description: Package IDA Pro plugins for the IDA Plugin Manager and plugins.hex-rays.com repository
---

# Packaging IDA Pro Plugins

This skill helps package IDA Pro plugins for distribution via the IDA Plugin Manager and the plugins.hex-rays.com repository. It covers creating and updating the `ida-plugin.json` manifest, packaging archives, and publishing via GitHub Releases.

## Overview

The IDA Plugin Manager is a self-service ecosystem for discovering, installing, and sharing IDA plugins:

- **Discovery**: A daily indexer scans GitHub for repositories containing `ida-plugin.json`
- **Repository**: Published at [plugins.hex-rays.com](https://plugins.hex-rays.com/) and [github.com/HexRaysSA/plugin-repository](https://github.com/HexRaysSA/plugin-repository)
- **Client**: HCLI command-line tool (`hcli plugin install <name>`)
- **Compatibility**: IDA Pro 9.0+ (full support)

## Critical: Understanding Plugin Root Directory

**The `ida-plugin.json` file defines the root of the plugin.** When a plugin is installed, only the directory containing `ida-plugin.json` (and its subdirectories) is copied to `$IDAUSR/plugins/`. Nothing outside this directory is included.

### Assessing Directory Structure Compatibility

Before packaging, verify that your plugin's structure is self-contained:

```
# GOOD: All plugin code is in the same directory as ida-plugin.json
my-repo/
├── ida-plugin.json        # Plugin root
├── my_plugin.py           # Entry point - INCLUDED
├── my_plugin_lib/         # Supporting code - INCLUDED
│   └── helpers.py
├── README.md              # Plugin README - INCLUDED (shown on web)
└── assets/
    └── logo.png           # Logo - INCLUDED

# BAD: Plugin code outside the ida-plugin.json directory
my-repo/
├── plugin/
│   └── ida-plugin.json    # Plugin root is here
├── src/                   # NOT INCLUDED - outside plugin root!
│   └── my_plugin.py       # This file won't be installed!
└── README.md              # NOT INCLUDED - wrong directory!
```

### Compatibility Checklist

When assessing an existing plugin, verify:

1. [ ] **Entry point location**: Is `entryPoint` in the same directory as `ida-plugin.json`?
2. [ ] **All imports resolvable**: Are all Python imports within the plugin root or in `pythonDependencies`?
3. [ ] **No parent directory references**: Does the code use `../` to access files outside the plugin root?
4. [ ] **Assets included**: Are logos, data files, or resources inside the plugin root?
5. [ ] **README placement**: Is `README.md` in the plugin root (not repo root) for web display?

### Common Restructuring Patterns

**Pattern 1: Plugin in subdirectory**

If your plugin code is in a subdirectory like `src/` or `plugin/`, move `ida-plugin.json` into that directory:

```
# Before                          # After
my-repo/                          my-repo/
├── ida-plugin.json               └── src/
└── src/                              ├── ida-plugin.json  # Moved here
    └── my_plugin.py                  ├── my_plugin.py
                                      └── README.md        # Add for web
```

**Pattern 2: Monorepo with IDA plugin**

For projects where IDA plugin is one component (e.g., capa), place `ida-plugin.json` at the plugin code's location:

```
capa/
├── capa/
│   ├── ida/
│   │   └── plugin/
│   │       ├── ida-plugin.json   # Plugin root
│   │       ├── capa_explorer.py  # Entry point
│   │       └── README.md         # Plugin-specific docs
│   └── main.py                   # Not included in IDA plugin
└── README.md                     # Repo README - not the plugin README
```

### README in Plugin Root

Place a `README.md` file in the same directory as `ida-plugin.json` to have it displayed on the [plugins.hex-rays.com](https://plugins.hex-rays.com/) web interface. This is separate from your repository's root README:

```
my-plugin/
├── ida-plugin.json
├── my_plugin.py
└── README.md              # This README appears on plugins.hex-rays.com
```

The plugin README should focus on:
- What the plugin does
- How to use it within IDA
- Configuration options (if using settings)
- Screenshots or examples

It does **not** need installation instructions (the Plugin Manager handles that).

## The ida-plugin.json Manifest

Every plugin requires an `ida-plugin.json` file in its root directory. This is the **only required file** beyond the plugin code itself. Paths in the metadata file are relative to the metadata file, because the metadata file defines the root of the plugin, even if its nested within a ZIP archive.

### Complete Schema

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "my-plugin",
    "version": "1.0.0",
    "entryPoint": "my_plugin.py",
    "description": "A one-line description of what this plugin does",
    "license": "MIT",
    "urls": {
      "repository": "https://github.com/org/my-plugin",
      "homepage": "https://example.com/my-plugin"
    },
    "authors": [
      {"name": "Author Name", "email": "author@example.com"}
    ],
    "maintainers": [
      {"name": "Maintainer Name", "email": "maintainer@example.com"}
    ],
    "idaVersions": ["9.0", "9.1", "9.2"],
    "platforms": ["windows-x86_64", "linux-x86_64", "macos-x86_64", "macos-aarch64"],
    "categories": ["malware-analysis"],
    "keywords": ["analysis", "automation"],
    "pythonDependencies": ["requests>=2.0", "pydantic>=2"],
    "logoPath": "assets/logo.png",
    "settings": []
  }
}
```

### Required Fields

| Field | Type | Description |
|-------|------|-------------|
| `IDAMetadataDescriptorVersion` | `1` | Always set to `1` |
| `plugin.name` | string | Unique identifier. ASCII letters, digits, underscores, hyphens only. No leading/trailing `_` or `-`. Used to derive the IDA namespace: `__plugins__my_plugin` |
| `plugin.version` | string | Semantic version `x.y.z` format. No leading `v` |
| `plugin.entryPoint` | string | Entry point filename (e.g., `my_plugin.py`) or bare name for native plugins |
| `plugin.urls.repository` | string | GitHub URL: `https://github.com/org/project` |
| `plugin.authors` OR `plugin.maintainers` | array | At least one contact with `email` field required |

### Optional Fields

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `plugin.description` | string | none | One-line description shown in search results |
| `plugin.license` | string | none | License identifier (e.g., `MIT`, `Apache-2.0`, `GPL-3.0`) |
| `plugin.urls.homepage` | string | none | Homepage URL if different from repository |
| `plugin.idaVersions` | array or string | all versions | Supported IDA versions. Can be explicit list `["9.0", "9.1"]` or spec `">=7.4"` |
| `plugin.platforms` | array | all platforms | Supported platforms: `windows-x86_64`, `linux-x86_64`, `macos-x86_64`, `macos-aarch64` |
| `plugin.categories` | array | `[]` | See Categories section below |
| `plugin.keywords` | array | `[]` | Search terms for discoverability |
| `plugin.pythonDependencies` | array or `"inline"` | `[]` | PyPI packages. Use `"inline"` for PEP 723 metadata |
| `plugin.logoPath` | string | none | Relative path to logo image (16:9 aspect ratio recommended) |
| `plugin.settings` | array | `[]` | Plugin configuration options. See Settings section |

### Valid Categories

```
disassembly-and-processor-modules
file-parsers-and-loaders
decompilation
debugging-and-tracing
deobfuscation
collaboration-and-productivity
integration-with-third-parties-interoperability
api-scripting-and-automation
ui-ux-and-visualization
malware-analysis
vulnerability-research-and-exploit-development
other
```

### Valid IDA Versions

Current/supported: `9.2`, `9.1`, `9.0sp1`, `9.0`,  ...

Use a version specifier like `">=9.0"` to match multiple versions automatically.

## Packaging Pure Python Plugins

For simple Python plugins, the directory structure is minimal:

```
my-plugin/
├── ida-plugin.json
├── README.md             # Displayed on plugins.hex-rays.com
├── my_plugin.py          # entryPoint
└── my_plugin_lib/        # optional supporting modules
    ├── __init__.py
    └── helpers.py
```

### Minimal Example

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "my-simple-plugin",
    "version": "1.0.0",
    "entryPoint": "my_plugin.py",
    "urls": {
      "repository": "https://github.com/username/my-simple-plugin"
    },
    "authors": [
      {"name": "Your Name", "email": "you@example.com"}
    ]
  }
}
```

### With Dependencies

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "capa",
    "version": "9.3.1",
    "entryPoint": "capa_explorer.py",
    "description": "Identify capabilities in executable files using FLARE's capa framework",
    "license": "Apache-2.0",
    "idaVersions": ">=7.4",
    "categories": ["malware-analysis", "api-scripting-and-automation", "ui-ux-and-visualization"],
    "pythonDependencies": ["flare-capa==9.3.1"],
    "urls": {
      "repository": "https://github.com/mandiant/capa"
    },
    "authors": [
      {"name": "Willi Ballenthin", "email": "wballenthin@hex-rays.com"},
      {"name": "Moritz Raabe", "email": "moritzraabe@google.com"}
    ],
    "keywords": ["capability-detection", "malware-analysis", "att&ck", "static-analysis"]
  }
}
```

### PEP 723 Inline Dependencies

If your plugin uses PEP 723 inline script metadata, set `pythonDependencies` to `"inline"`:

```json
{
  "pythonDependencies": "inline"
}
```

Then in your entry point Python file:

```python
# /// script
# dependencies = [
#     "requests>=2.0",
#     "pydantic>=2"
# ]
# ///

import ida_kernwin
# ... rest of plugin
```

## Packaging Native Plugins

Native plugins require compiled binaries (.dll, .so, .dylib) for each target platform.

### Directory Structure

```
my-native-plugin/
├── ida-plugin.json
├── README.md              # Displayed on plugins.hex-rays.com
├── my_plugin.dll          # Windows
├── my_plugin.so           # Linux
└── my_plugin.dylib        # macOS (universal or architecture-specific)
```

### Entry Point Convention

For native plugins, use a **bare name** without extension:

```json
{
  "plugin": {
    "entryPoint": "my_plugin",
    "platforms": ["windows-x86_64", "linux-x86_64", "macos-x86_64", "macos-aarch64"]
  }
}
```

IDA will automatically append the correct extension (`.dll`, `.so`, `.dylib`) for the current platform.

### Fat Binary Archives

Include all platform binaries in a single archive. The entry point uses the bare name, and the correct binary is selected at install time.

### Platform-Specific Archives

Alternatively, create separate archives per platform with explicit extensions:

**Windows archive:**
```json
{
  "plugin": {
    "entryPoint": "my_plugin.dll",
    "platforms": ["windows-x86_64"]
  }
}
```

**Linux archive:**
```json
{
  "plugin": {
    "entryPoint": "my_plugin.so",
    "platforms": ["linux-x86_64"]
  }
}
```

## Plugin Settings

For plugins requiring user configuration, declare settings in the manifest. Users configure these via `hcli plugin config` or the IDA GUI.

### Settings Schema

```json
{
  "settings": [
    {
      "key": "api_key",
      "name": "API Key",
      "type": "string",
      "required": true,
      "documentation": "Your API key for the service"
    },
    {
      "key": "endpoint",
      "name": "API Endpoint",
      "type": "string",
      "required": false,
      "default": "https://api.example.com",
      "validation_pattern": "^https://.*$"
    },
    {
      "key": "log_level",
      "name": "Log Level",
      "type": "string",
      "required": false,
      "choices": ["debug", "info", "warning", "error"],
      "default": "info"
    },
    {
      "key": "enable_telemetry",
      "name": "Enable Telemetry",
      "type": "boolean",
      "required": false,
      "default": false
    }
  ]
}
```

### Setting Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `key` | string | yes | Code-level identifier (e.g., `api_key`) |
| `name` | string | yes | Human-readable label (e.g., `API Key`) |
| `type` | `"string"` or `"boolean"` | yes | Value type |
| `required` | boolean | yes | Whether user must provide a value |
| `documentation` | string | no | Help text for users |
| `default` | string or boolean | no | Default value if not configured |
| `validation_pattern` | string | no | Regex for validating string values |
| `choices` | array of strings | no | Allowed values (mutually exclusive with `validation_pattern`) |

### Accessing Settings in Plugin Code

Use the `ida-settings` library:

```python
from ida_settings import get_current_plugin_setting

api_key = get_current_plugin_setting("api_key")
log_level = get_current_plugin_setting("log_level")
```

## Validation

Always validate before publishing:

```bash
# Validate a directory
hcli plugin lint /path/to/my-plugin

# Validate a ZIP archive
hcli plugin lint /path/to/my-plugin.zip
```

The linter checks:
- JSON syntax and schema compliance
- Required fields present
- Entry point file exists
- Logo file exists (if declared)
- Platform/binary consistency
- Path safety (no traversals)

## Publishing to the Repository

### Step 1: Create a GitHub Release

1. Tag your commit: `git tag v1.0.0 && git push --tags`
2. Create a GitHub Release from the tag
3. Attach your plugin archive (ZIP)

### Step 2: Automatic Indexing

The indexer runs daily and automatically discovers:
- Repositories with `ida-plugin.json` in the root
- GitHub Releases with valid plugin archives

No manual registration required. Your plugin appears within 24 hours.

### Step 3: Explicit Registration (Optional)

To expedite indexing, add your repository to `known-repositories.txt`:

1. Fork [HexRaysSA/plugin-repository](https://github.com/HexRaysSA/plugin-repository)
2. Add your repo URL to `known-repositories.txt` (one per line)
3. Submit a pull request

### Troubleshooting Indexing

Check the [indexer log report](https://hexrayssa.github.io/plugin-repository/logs/indexer.html) for errors.

Common issues:
- Invalid JSON syntax
- Missing required fields (especially author email)
- Repository URL doesn't match GitHub pattern
- Entry point file not found in archive

## Multi-Plugin Archives

A single archive can contain multiple plugins, each in its own subdirectory:

```
multi-plugin.zip
├── plugin-a/
│   ├── ida-plugin.json
│   └── plugin_a.py
└── plugin-b/
    ├── ida-plugin.json
    └── plugin_b.py
```

Each subdirectory must have its own `ida-plugin.json`.

## Version Updates

To release a new version:

1. Update `plugin.version` in `ida-plugin.json`
2. Create a new git tag matching the version
3. Create a GitHub Release with the new archive
4. The indexer will pick up the new version automatically

Users upgrade via: `hcli plugin upgrade <name>`

## Common Patterns

### Minimal Python Plugin Checklist

1. [ ] Create `ida-plugin.json` with required fields
2. [ ] Ensure entry point file exists
3. [ ] Add author with email
4. [ ] Run `hcli plugin lint`
5. [ ] Create GitHub Release with source archive

### Adding Settings to Existing Plugin

1. [ ] Define settings array in `ida-plugin.json`
2. [ ] Add `ida-settings` to `pythonDependencies` if using the library
3. [ ] Update plugin code to use `get_current_plugin_setting()`
4. [ ] Document settings in README

### Converting Legacy Plugin

1. [ ] **Assess directory structure**: Verify all plugin code is self-contained
   - Entry point and all imports within one directory
   - No `../` references to parent directories
   - Data files and assets colocated with code
2. [ ] **Restructure if needed**: Move `ida-plugin.json` to where the plugin code lives
3. [ ] Create `ida-plugin.json` with required fields
4. [ ] Set correct `entryPoint` (relative to `ida-plugin.json`)
5. [ ] Add appropriate `idaVersions` (test compatibility!)
6. [ ] Declare `pythonDependencies` from requirements.txt
7. [ ] Add `README.md` in plugin root for web display
8. [ ] Validate and test locally: `hcli plugin lint`
9. [ ] Create GitHub Release

## HCLI Commands Reference

```bash
# List available plugins
hcli plugin list

# Search plugins
hcli plugin search <query>

# Install a plugin
hcli plugin install <name>
hcli plugin install <name>==1.0.0

# Upgrade a plugin
hcli plugin upgrade <name>

# Uninstall a plugin
hcli plugin uninstall <name>

# List installed plugins
hcli plugin list --installed

# Configure plugin settings
hcli plugin config <name> set <key> <value>
hcli plugin config <name> get <key>

# Validate plugin
hcli plugin lint /path/to/plugin
```

## Resources

- **Plugin Repository**: [plugins.hex-rays.com](https://plugins.hex-rays.com/)
- **Documentation**: [hcli.docs.hex-rays.com](https://hcli.docs.hex-rays.com/)
- **Repository Source**: [github.com/HexRaysSA/plugin-repository](https://github.com/HexRaysSA/plugin-repository)
- **HCLI Source**: [github.com/HexRaysSA/ida-hcli](https://github.com/HexRaysSA/ida-hcli)
- **IDA Settings Library**: [github.com/williballenthin/ida-settings](https://github.com/williballenthin/ida-settings)
- **Support**: [github.com/HexRaysSA/ida-hcli/issues](https://github.com/HexRaysSA/ida-hcli/issues)


```