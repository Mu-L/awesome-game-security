Project Path: arc_HexRaysSA_ida-cyberchef_cjuzo7dv

Source Tree:

```txt
arc_HexRaysSA_ida-cyberchef_cjuzo7dv
├── deps
│   ├── CyberChef
│   ├── CyberChef.patch
│   └── README.md
├── docs
│   ├── ops.md
│   └── screenshot1.png
├── entrypoint.py
├── ida-plugin.json
├── ida_cyberchef
│   ├── __init__.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── hex_formatter.py
│   │   ├── input_parser.py
│   │   ├── operation_doc_formatter.py
│   │   ├── operation_registry.py
│   │   ├── recipe_executor.py
│   │   └── recipe_models.py
│   ├── cyberchef.py
│   ├── cyberchef_widget.py
│   ├── data
│   │   ├── CyberChef.js
│   │   └── operation_schema.json
│   ├── main.py
│   ├── plugin
│   │   └── __init__.py
│   ├── qt_models
│   │   ├── __init__.py
│   │   ├── execution_model.py
│   │   ├── input_model.py
│   │   └── recipe_model.py
│   └── widgets
│       ├── __init__.py
│       ├── input_panel.py
│       ├── insert_indicator_widget.py
│       ├── location_input_widget.py
│       ├── operation_browser_widget.py
│       ├── operation_search_dialog.py
│       ├── operation_step_widget.py
│       ├── output_panel.py
│       └── recipe_panel.py
├── justfile
├── pyproject.toml
├── readme.md
├── tests
│   ├── test_cyberchef.py
│   ├── test_generate_operation_schema.py
│   ├── test_hex_formatter.py
│   ├── test_input_panel.py
│   ├── test_input_parser.py
│   ├── test_location_input_widget.py
│   ├── test_operation_doc_formatter.py
│   ├── test_operation_registry.py
│   ├── test_operation_step_widget.py
│   ├── test_qt_execution_model.py
│   ├── test_qt_input_model.py
│   ├── test_qt_recipe_model.py
│   ├── test_recipe_executor.py
│   ├── test_recipe_models.py
│   └── test_ui_verification.py
└── tools
    ├── cyberchef_operations.json
    ├── generate_docs.py
    └── generate_operation_schema.py

```

`deps/CyberChef.patch`:

```patch
diff --git a/Gruntfile.js b/Gruntfile.js
index d3f6b635..6d62e7bf 100755
--- a/Gruntfile.js
+++ b/Gruntfile.js
@@ -7,6 +7,7 @@ const glob = require("glob");
 const path = require("path");
 
 const nodeFlags = "--experimental-modules --experimental-json-modules --experimental-specifier-resolution=node --no-warnings --no-deprecation";
+const webpackNodeConfig = require("./webpack.node.config.js");
 
 /**
  * Grunt configuration for building the app in various formats.
@@ -28,14 +29,14 @@ module.exports = function (grunt) {
     grunt.registerTask("prod",
         "Creates a production-ready build. Use the --msg flag to add a compile message.",
         [
-            "eslint", "clean:prod", "clean:config", "exec:generateConfig", "findModules", "webpack:web",
+            "eslint", "clean:prod", "clean:config", "exec:generateConfig", "webpack:web",
             "copy:standalone", "zip:standalone", "clean:standalone", "exec:calcDownloadHash", "chmod"
         ]);
 
     grunt.registerTask("node",
-        "Compiles CyberChef into a single NodeJS module.",
+        "Compiles CyberChef into a single NodeJS CommonJS module.",
         [
-            "clean:node", "clean:config", "clean:nodeConfig", "exec:generateConfig", "exec:generateNodeIndex"
+            "clean:node", "clean:config", "clean:nodeConfig", "exec:generateConfig", "exec:generateNodeIndex", "webpack:node"
         ]);
 
     grunt.registerTask("configTests",
@@ -106,15 +107,22 @@ module.exports = function (grunt) {
             return {
                 mode: "production",
                 target: "web",
-                entry: Object.assign({
+                entry: {
                     main: "./src/web/index.js"
-                }, moduleEntryPoints),
+                },
                 output: {
                     path: __dirname + "/build/prod",
                     filename: chunkData => {
-                        return chunkData.chunk.name === "main" ? "assets/[name].js": "[name].js";
+                        return chunkData.chunk.name === "main" ? "cyberchef.js" : "[name].js";
                     },
-                    globalObject: "this"
+                    globalObject: "this",
+                    library: {
+                        type: "commonjs2"
+                    }
+                },
+                optimization: {
+                    splitChunks: false,
+                    runtimeChunk: false
                 },
                 resolve: {
                     alias: {
@@ -202,6 +210,7 @@ module.exports = function (grunt) {
             options: webpackConfig,
             myConfig: webpackConfig,
             web: webpackProdConf(),
+            node: webpackNodeConfig,
         },
         "webpack-dev-server": {
             options: webpackConfig,
diff --git a/babel.config.js b/babel.config.js
index deab9108..f7f062fa 100644
--- a/babel.config.js
+++ b/babel.config.js
@@ -4,14 +4,16 @@ module.exports = function(api) {
     return {
         "presets": [
             ["@babel/preset-env", {
-                "modules": false,
+                "modules": "commonjs",
                 "useBuiltIns": "entry",
                 "corejs": 3
             }]
         ],
         "plugins": [
             "dynamic-import-node",
-            "@babel/plugin-syntax-import-assertions",
+            ["@babel/plugin-syntax-import-assertions", {
+                "importAttributesKeyword": "with"
+            }],
             [
                 "babel-plugin-transform-builtin-extend", {
                     "globals": ["Error"]
@@ -22,6 +24,9 @@ module.exports = function(api) {
                     "regenerator": true
                 }
             ]
-        ]
+        ],
+        "generatorOpts": {
+            "importAttributesKeyword": "with"
+        }
     };
 };
diff --git a/package-lock.json b/package-lock.json
index b374df4b..e8b58a94 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -115,6 +115,7 @@
         "@codemirror/search": "^6.5.6",
         "@codemirror/state": "^6.4.1",
         "@codemirror/view": "^6.28.0",
+        "assert": "^2.1.0",
         "autoprefixer": "^10.4.19",
         "babel-loader": "^9.1.3",
         "babel-plugin-dynamic-import-node": "^2.3.3",
@@ -124,6 +125,7 @@
         "cli-progress": "^3.12.0",
         "colors": "^1.4.0",
         "compression-webpack-plugin": "^11.1.0",
+        "constants-browserify": "^1.0.0",
         "copy-webpack-plugin": "^12.0.2",
         "core-js": "^3.37.1",
         "cspell": "^8.17.3",
@@ -147,13 +149,20 @@
         "mini-css-extract-plugin": "2.9.0",
         "modify-source-webpack-plugin": "^4.1.0",
         "nightwatch": "^3.6.3",
+        "os-browserify": "^0.3.0",
+        "path-browserify": "^1.0.1",
         "postcss": "^8.4.38",
         "postcss-css-variables": "^0.19.0",
         "postcss-import": "^16.1.0",
         "postcss-loader": "^8.1.1",
         "prompt": "^1.3.0",
+        "querystring-es3": "^0.2.1",
         "sitemap": "^8.0.0",
+        "stream-http": "^3.2.0",
         "terser": "^5.31.1",
+        "url": "^0.11.4",
+        "util": "^0.12.5",
+        "vm-browserify": "^1.1.2",
         "webpack": "^5.91.0",
         "webpack-bundle-analyzer": "^4.10.2",
         "webpack-dev-server": "5.0.4",
@@ -5042,13 +5051,17 @@
       "license": "MIT"
     },
     "node_modules/assert": {
-      "version": "1.4.1",
-      "resolved": "https://registry.npmjs.org/assert/-/assert-1.4.1.tgz",
-      "integrity": "sha512-N+aAxov+CKVS3JuhDIQFr24XvZvwE96Wlhk9dytTg/GmwWoghdOvR8dspx8MVz71O+Y0pA3UPqHF68D6iy8UvQ==",
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/assert/-/assert-2.1.0.tgz",
+      "integrity": "sha512-eLHpSK/Y4nhMJ07gDaAzoX/XAKS8PSaojml3M0DM4JpV1LAi5JOJ/p6H/XWrl8L+DzVEvVCW1z3vWAaB9oTsQw==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
-        "util": "0.10.3"
+        "call-bind": "^1.0.2",
+        "is-nan": "^1.3.2",
+        "object-is": "^1.1.5",
+        "object.assign": "^4.1.4",
+        "util": "^0.12.5"
       }
     },
     "node_modules/assertion-error": {
@@ -6114,6 +6127,13 @@
       "integrity": "sha512-571s0T7nZWK6vB67HI5dyUF7wXiNcfaPPPTl6zYCNApANjIvYJTg7hlud/+cJpdAhS7dVzqMLmfhfHR3rAcOjQ==",
       "license": "MIT"
     },
+    "node_modules/builtin-status-codes": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/builtin-status-codes/-/builtin-status-codes-3.0.0.tgz",
+      "integrity": "sha512-HpGFw18DgFWlncDfjTa2rcQ4W88O1mC8e8yZ2AvQY5KDaktSTwo+KRf6nHK6FRI5FyRyb/5T6+TSxfP7QyGsmQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/bundle-name": {
       "version": "4.1.0",
       "resolved": "https://registry.npmjs.org/bundle-name/-/bundle-name-4.1.0.tgz",
@@ -6161,9 +6181,9 @@
       }
     },
     "node_modules/call-bind-apply-helpers": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.1.tgz",
-      "integrity": "sha512-BhYE+WDaywFg2TBWYNXAE+8B1ATnThNBqXHP5nQu0jWJdVvY2hvkpyB3qOmtmDePiS5/BDQ8wASEWGMWRG148g==",
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
+      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
       "license": "MIT",
       "dependencies": {
         "es-errors": "^1.3.0",
@@ -6174,13 +6194,13 @@
       }
     },
     "node_modules/call-bound": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.3.tgz",
-      "integrity": "sha512-YTd+6wGlNlPxSuri7Y6X8tY2dmm12UMH66RpKMhiX6rsk5wXXnYgbUcOt8kiS31/AjfoTOvCsE+w8nZQLQnzHA==",
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
+      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
       "license": "MIT",
       "dependencies": {
-        "call-bind-apply-helpers": "^1.0.1",
-        "get-intrinsic": "^1.2.6"
+        "call-bind-apply-helpers": "^1.0.2",
+        "get-intrinsic": "^1.3.0"
       },
       "engines": {
         "node": ">= 0.4"
@@ -6893,6 +6913,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/constants-browserify": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/constants-browserify/-/constants-browserify-1.0.0.tgz",
+      "integrity": "sha512-xFxOwqIzR/e1k1gLiWEophSCMqXcwVHIH7akf7b/vxcUeGunlj3hvZaaqxwHsTgn+IndtkQJgSztIDWeumWJDQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/content-disposition": {
       "version": "0.5.4",
       "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
@@ -10018,6 +10045,16 @@
         "node": ">= 4.0.0"
       }
     },
+    "node_modules/generator-function": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/generator-function/-/generator-function-2.0.1.tgz",
+      "integrity": "sha512-SFdFmIJi+ybC0vjlHN0ZGVGHc3lgE0DxPAT0djjVg+kjOnSqclqmj0KQ7ykTOLP6YxoqOvuAODGdcHJn+43q3g==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/gensequence": {
       "version": "7.0.0",
       "resolved": "https://registry.npmjs.org/gensequence/-/gensequence-7.0.0.tgz",
@@ -10065,17 +10102,17 @@
       }
     },
     "node_modules/get-intrinsic": {
-      "version": "1.2.7",
-      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.7.tgz",
-      "integrity": "sha512-VW6Pxhsrk0KAOqs3WEd0klDiF/+V7gQOpAvY1jVU/LHmaD/kQO4523aiJuikX/QAKYiW6x8Jh+RJej1almdtCA==",
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
+      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
       "license": "MIT",
       "dependencies": {
-        "call-bind-apply-helpers": "^1.0.1",
+        "call-bind-apply-helpers": "^1.0.2",
         "es-define-property": "^1.0.1",
         "es-errors": "^1.3.0",
-        "es-object-atoms": "^1.0.0",
+        "es-object-atoms": "^1.1.1",
         "function-bind": "^1.1.2",
-        "get-proto": "^1.0.0",
+        "get-proto": "^1.0.1",
         "gopd": "^1.2.0",
         "has-symbols": "^1.1.0",
         "hasown": "^2.0.2",
@@ -11795,6 +11832,26 @@
       "integrity": "sha512-lw7DUp0aWXYg+CBCN+JKkcE0Q2RayZnSvnZBlwgxHBQhqt5pZNVy4Ri7H9GmmXkdu7LUthszM+Tor1u/2iBcpQ==",
       "license": "MIT"
     },
+    "node_modules/is-generator-function": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.1.2.tgz",
+      "integrity": "sha512-upqt1SkGkODW9tsGNG5mtXTXtECizwtS2kA161M+gJPc1xdb/Ax629af6YrTwcOeQHbewrPNlE5Dx7kzvXTizA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.4",
+        "generator-function": "^2.0.0",
+        "get-proto": "^1.0.1",
+        "has-tostringtag": "^1.0.2",
+        "safe-regex-test": "^1.1.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/is-glob": {
       "version": "4.0.3",
       "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
@@ -11866,6 +11923,23 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/is-nan": {
+      "version": "1.3.2",
+      "resolved": "https://registry.npmjs.org/is-nan/-/is-nan-1.3.2.tgz",
+      "integrity": "sha512-E+zBKpQ2t6MEo1VsonYmluk9NxGrbzpeeLC2xIViuO2EjU2xsXsBPwTr3Ykv9l08UYEVEdWeRZNouaZqF6RN0w==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "call-bind": "^1.0.0",
+        "define-properties": "^1.1.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/is-network-error": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/is-network-error/-/is-network-error-1.1.0.tgz",
@@ -12057,6 +12131,22 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/is-typed-array": {
+      "version": "1.1.15",
+      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.15.tgz",
+      "integrity": "sha512-p3EcsicXjit7SaskXHs1hA91QxgTw46Fv6EFKKGS5DRFLD8yKnohjF3hxoju94b/OcMZoQukzpPpBE9uLVKzgQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "which-typed-array": "^1.1.16"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/is-unc-path": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/is-unc-path/-/is-unc-path-1.0.0.tgz",
@@ -14011,6 +14101,23 @@
         "node": ">=0.12.0"
       }
     },
+    "node_modules/node-http2/node_modules/assert": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/assert/-/assert-1.4.1.tgz",
+      "integrity": "sha512-N+aAxov+CKVS3JuhDIQFr24XvZvwE96Wlhk9dytTg/GmwWoghdOvR8dspx8MVz71O+Y0pA3UPqHF68D6iy8UvQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "util": "0.10.3"
+      }
+    },
+    "node_modules/node-http2/node_modules/inherits": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz",
+      "integrity": "sha512-8nWq2nLTAwd02jTqJExUYFSD/fKq6VH9Y/oG2accc/kdI0V98Bag8d5a4gi3XHz73rDWa2PvTtvcWYquKqSENA==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/node-http2/node_modules/stream-browserify": {
       "version": "2.0.1",
       "resolved": "https://registry.npmjs.org/stream-browserify/-/stream-browserify-2.0.1.tgz",
@@ -14022,6 +14129,16 @@
         "readable-stream": "^2.0.2"
       }
     },
+    "node_modules/node-http2/node_modules/util": {
+      "version": "0.10.3",
+      "resolved": "https://registry.npmjs.org/util/-/util-0.10.3.tgz",
+      "integrity": "sha512-5KiHfsmkqacuKjkRkdV7SsfDJ2EGiPsK92s2MhNSY0craxjTdKTtqKsJaCWp4LW33ZZ0OPUv1WO/TFvNQRiQxQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "inherits": "2.0.1"
+      }
+    },
     "node_modules/node-md6": {
       "version": "0.1.0",
       "resolved": "https://registry.npmjs.org/node-md6/-/node-md6-0.1.0.tgz",
@@ -14458,6 +14575,13 @@
         "node": ">=8"
       }
     },
+    "node_modules/os-browserify": {
+      "version": "0.3.0",
+      "resolved": "https://registry.npmjs.org/os-browserify/-/os-browserify-0.3.0.tgz",
+      "integrity": "sha512-gjcpUc3clBf9+210TRaDWbf+rZZZEshZ+DlXMRCeAjp0xhTrnQsKHypIy1J3d5hKdUzj69t708EHtU8P6bUn0A==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/os-homedir": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/os-homedir/-/os-homedir-1.0.2.tgz",
@@ -14785,6 +14909,13 @@
         "util": "^0.10.3"
       }
     },
+    "node_modules/path-browserify": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/path-browserify/-/path-browserify-1.0.1.tgz",
+      "integrity": "sha512-b7uo2UCUOYZcnF/3ID0lulOJi/bafxa1xPe7ZPsammBSpjSWQkjNxlt635YGS2MiR9GjvuXCtz2emr3jbsz98g==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/path-exists": {
       "version": "4.0.0",
       "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
@@ -14889,6 +15020,21 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/path/node_modules/inherits": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
+      "integrity": "sha512-x00IRNXNy63jwGkJmzPigoySHbaqpNuzKbBOmzK+g2OdZpQ9w+sxCN+VSB3ja7IAge2OP2qpfxTjeNcyjmW1uw==",
+      "license": "ISC"
+    },
+    "node_modules/path/node_modules/util": {
+      "version": "0.10.4",
+      "resolved": "https://registry.npmjs.org/util/-/util-0.10.4.tgz",
+      "integrity": "sha512-0Pm9hTQ3se5ll1XihRic3FDIku70C+iHUdT/W926rSgHV5QgXsYbKZN8MSC3tJtSkhuROzvsQjAaFENRXr+19A==",
+      "license": "MIT",
+      "dependencies": {
+        "inherits": "2.0.3"
+      }
+    },
     "node_modules/pathval": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz",
@@ -15636,6 +15782,15 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/querystring-es3": {
+      "version": "0.2.1",
+      "resolved": "https://registry.npmjs.org/querystring-es3/-/querystring-es3-0.2.1.tgz",
+      "integrity": "sha512-773xhDQnZBMFobEiztv8LIl70ch5MSF/jUQVlhwFyBILqq96anmoctVIYz+ZRp0qbCKATTn6ev02M3r7Ga5vqA==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.4.x"
+      }
+    },
     "node_modules/querystringify": {
       "version": "2.2.0",
       "resolved": "https://registry.npmjs.org/querystringify/-/querystringify-2.2.0.tgz",
@@ -17121,6 +17276,34 @@
         "node": ">= 6"
       }
     },
+    "node_modules/stream-http": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/stream-http/-/stream-http-3.2.0.tgz",
+      "integrity": "sha512-Oq1bLqisTyK3TSCXpPbT4sdeYNdmyZJv1LxpEm2vu1ZhK89kSE5YXwZc3cWk0MagGaKriBh9mCFbVGtO+vY29A==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "builtin-status-codes": "^3.0.0",
+        "inherits": "^2.0.4",
+        "readable-stream": "^3.6.0",
+        "xtend": "^4.0.2"
+      }
+    },
+    "node_modules/stream-http/node_modules/readable-stream": {
+      "version": "3.6.2",
+      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
+      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "inherits": "^2.0.3",
+        "string_decoder": "^1.1.1",
+        "util-deprecate": "^1.0.1"
+      },
+      "engines": {
+        "node": ">= 6"
+      }
+    },
     "node_modules/stream-shift": {
       "version": "1.0.3",
       "resolved": "https://registry.npmjs.org/stream-shift/-/stream-shift-1.0.3.tgz",
@@ -18122,12 +18305,17 @@
       }
     },
     "node_modules/util": {
-      "version": "0.10.3",
-      "resolved": "https://registry.npmjs.org/util/-/util-0.10.3.tgz",
-      "integrity": "sha512-5KiHfsmkqacuKjkRkdV7SsfDJ2EGiPsK92s2MhNSY0craxjTdKTtqKsJaCWp4LW33ZZ0OPUv1WO/TFvNQRiQxQ==",
+      "version": "0.12.5",
+      "resolved": "https://registry.npmjs.org/util/-/util-0.12.5.tgz",
+      "integrity": "sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==",
+      "dev": true,
       "license": "MIT",
       "dependencies": {
-        "inherits": "2.0.1"
+        "inherits": "^2.0.3",
+        "is-arguments": "^1.0.4",
+        "is-generator-function": "^1.0.7",
+        "is-typed-array": "^1.1.3",
+        "which-typed-array": "^1.1.2"
       }
     },
     "node_modules/util-deprecate": {
@@ -18136,12 +18324,6 @@
       "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
       "license": "MIT"
     },
-    "node_modules/util/node_modules/inherits": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz",
-      "integrity": "sha512-8nWq2nLTAwd02jTqJExUYFSD/fKq6VH9Y/oG2accc/kdI0V98Bag8d5a4gi3XHz73rDWa2PvTtvcWYquKqSENA==",
-      "license": "ISC"
-    },
     "node_modules/utila": {
       "version": "0.4.0",
       "resolved": "https://registry.npmjs.org/utila/-/utila-0.4.0.tgz",
@@ -18200,6 +18382,13 @@
       "integrity": "sha512-2ozZEFfmVvQcHWoHLNuiKlUfDKlhh4KGsy54U0UrlLMR1SO+XKAIDqBxtBwHgNrekurlJwE8A9K6L49T78ZQ9Q==",
       "license": "MIT"
     },
+    "node_modules/vm-browserify": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/vm-browserify/-/vm-browserify-1.1.2.tgz",
+      "integrity": "sha512-2ham8XPWTONajOR0ohOKOHXkm3+gaBmGut3SRuu75xLd/RRaY6vqgh8NBYYk7+RW3u5AtzPQZG8F10LHkl0lAQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/vscode-languageserver-textdocument": {
       "version": "1.0.12",
       "resolved": "https://registry.npmjs.org/vscode-languageserver-textdocument/-/vscode-languageserver-textdocument-1.0.12.tgz",
diff --git a/package.json b/package.json
index 9191ab6f..a3f11964 100644
--- a/package.json
+++ b/package.json
@@ -27,10 +27,10 @@
     "type": "git",
     "url": "https://github.com/gchq/CyberChef/"
   },
-  "main": "src/node/wrapper.js",
+  "main": "build/node/CyberChef.js",
   "exports": {
-    "import": "./src/node/index.mjs",
-    "require": "./src/node/wrapper.js"
+    "import": "./build/node/CyberChef.js",
+    "require": "./build/node/CyberChef.js"
   },
   "bugs": "https://github.com/gchq/CyberChef/issues",
   "browserslist": [
@@ -50,6 +50,7 @@
     "@codemirror/search": "^6.5.6",
     "@codemirror/state": "^6.4.1",
     "@codemirror/view": "^6.28.0",
+    "assert": "^2.1.0",
     "autoprefixer": "^10.4.19",
     "babel-loader": "^9.1.3",
     "babel-plugin-dynamic-import-node": "^2.3.3",
@@ -59,6 +60,7 @@
     "cli-progress": "^3.12.0",
     "colors": "^1.4.0",
     "compression-webpack-plugin": "^11.1.0",
+    "constants-browserify": "^1.0.0",
     "copy-webpack-plugin": "^12.0.2",
     "core-js": "^3.37.1",
     "cspell": "^8.17.3",
@@ -82,13 +84,20 @@
     "mini-css-extract-plugin": "2.9.0",
     "modify-source-webpack-plugin": "^4.1.0",
     "nightwatch": "^3.6.3",
+    "os-browserify": "^0.3.0",
+    "path-browserify": "^1.0.1",
     "postcss": "^8.4.38",
     "postcss-css-variables": "^0.19.0",
     "postcss-import": "^16.1.0",
     "postcss-loader": "^8.1.1",
     "prompt": "^1.3.0",
+    "querystring-es3": "^0.2.1",
     "sitemap": "^8.0.0",
+    "stream-http": "^3.2.0",
     "terser": "^5.31.1",
+    "url": "^0.11.4",
+    "util": "^0.12.5",
+    "vm-browserify": "^1.1.2",
     "webpack": "^5.91.0",
     "webpack-bundle-analyzer": "^4.10.2",
     "webpack-dev-server": "5.0.4",
diff --git a/src/core/ChefWorker.js b/src/core/ChefWorker.js
index a43993f9..3f56d855 100644
--- a/src/core/ChefWorker.js
+++ b/src/core/ChefWorker.js
@@ -7,7 +7,7 @@
  */
 
 import Chef from "./Chef.mjs";
-import OperationConfig from "./config/OperationConfig.json" assert {type: "json"};
+import OperationConfig from "./config/OperationConfig.json" with {type: "json"};
 import OpModules from "./config/modules/OpModules.mjs";
 import loglevelMessagePrefix from "loglevel-message-prefix";
 
diff --git a/src/core/Recipe.mjs b/src/core/Recipe.mjs
index 3ce40aa4..31c02ee2 100755
--- a/src/core/Recipe.mjs
+++ b/src/core/Recipe.mjs
@@ -4,7 +4,7 @@
  * @license Apache-2.0
  */
 
-import OperationConfig from "./config/OperationConfig.json" assert {type: "json"};
+import OperationConfig from "./config/OperationConfig.json" with {type: "json"};
 import OperationError from "./errors/OperationError.mjs";
 import Operation from "./Operation.mjs";
 import DishError from "./errors/DishError.mjs";
diff --git a/src/core/lib/Magic.mjs b/src/core/lib/Magic.mjs
index 14111ec7..d1a0f2d0 100644
--- a/src/core/lib/Magic.mjs
+++ b/src/core/lib/Magic.mjs
@@ -1,4 +1,4 @@
-import OperationConfig from "../config/OperationConfig.json" assert {type: "json"};
+import OperationConfig from "../config/OperationConfig.json" with {type: "json"};
 import Utils, { isWorkerEnvironment } from "../Utils.mjs";
 import Recipe from "../Recipe.mjs";
 import Dish from "../Dish.mjs";
diff --git a/src/node/api.mjs b/src/node/api.mjs
index 88b3f834..b704a2bb 100644
--- a/src/node/api.mjs
+++ b/src/node/api.mjs
@@ -10,7 +10,7 @@
 
 import NodeDish from "./NodeDish.mjs";
 import NodeRecipe from "./NodeRecipe.mjs";
-import OperationConfig from "../core/config/OperationConfig.json" assert {type: "json"};
+import OperationConfig from "../core/config/OperationConfig.json" with {type: "json"};
 import { sanitise, removeSubheadingsFromArray, sentenceToCamelCase } from "./apiUtils.mjs";
 import ExcludedOperationError from "../core/errors/ExcludedOperationError.mjs";
 
diff --git a/src/web/index.js b/src/web/index.js
index 90142b34..6e712d06 100755
--- a/src/web/index.js
+++ b/src/web/index.js
@@ -17,8 +17,8 @@ import * as CanvasComponents from "../core/lib/CanvasComponents.mjs";
 
 // CyberChef
 import App from "./App.mjs";
-import Categories from "../core/config/Categories.json" assert {type: "json"};
-import OperationConfig from "../core/config/OperationConfig.json" assert {type: "json"};
+import Categories from "../core/config/Categories.json" with {type: "json"};
+import OperationConfig from "../core/config/OperationConfig.json" with {type: "json"};
 
 
 /**
diff --git a/src/web/static/sitemap.mjs b/src/web/static/sitemap.mjs
index b96047fc..14ee8d73 100644
--- a/src/web/static/sitemap.mjs
+++ b/src/web/static/sitemap.mjs
@@ -1,5 +1,5 @@
 import sm from "sitemap";
-import OperationConfig from "../../core/config/OperationConfig.json" assert {type: "json"};
+import OperationConfig from "../../core/config/OperationConfig.json" with {type: "json"};
 
 
 /**
diff --git a/tests/node/tests/Categories.mjs b/tests/node/tests/Categories.mjs
index e6f8bd72..f37b43ec 100644
--- a/tests/node/tests/Categories.mjs
+++ b/tests/node/tests/Categories.mjs
@@ -1,6 +1,6 @@
 import TestRegister from "../../lib/TestRegister.mjs";
-import Categories from "../../../src/core/config/Categories.json" assert {type: "json"};
-import OperationConfig from "../../../src/core/config/OperationConfig.json" assert {type: "json"};
+import Categories from "../../../src/core/config/Categories.json" with {type: "json"};
+import OperationConfig from "../../../src/core/config/OperationConfig.json" with {type: "json"};
 import it from "../assertionHandler.mjs";
 import assert from "assert";
 
diff --git a/webpack.config.js b/webpack.config.js
index f23fab0e..baf50423 100644
--- a/webpack.config.js
+++ b/webpack.config.js
@@ -41,7 +41,10 @@ module.exports = {
     output: {
         publicPath: "",
         globalObject: "this",
-        assetModuleFilename: "assets/[hash][ext][query]"
+        assetModuleFilename: "assets/[hash][ext][query]",
+        library: {
+            type: "commonjs2"
+        }
     },
     plugins: [
         new webpack.ProvidePlugin({
diff --git a/webpack.node.config.js b/webpack.node.config.js
new file mode 100644
index 00000000..3b9674cc
--- /dev/null
+++ b/webpack.node.config.js
@@ -0,0 +1,134 @@
+const webpack = require("webpack");
+const path = require("path");
+
+/**
+ * Webpack configuration for minimal runtime CommonJS build
+ *
+ * This configuration bundles CyberChef for use in minimal JavaScript runtime
+ * environments that don't provide Node.js APIs. All dependencies and polyfills
+ * are bundled into the output file.
+ *
+ * @author Willi Ballenthin [wballenthin@hex-rays.com]
+ * @license Apache-2.0
+ */
+
+const banner = `/**
+ * CyberChef - The Cyber Swiss Army Knife
+ *
+ * @copyright Crown Copyright 2016-2025
+ * @license Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */`;
+
+module.exports = {
+    mode: "production",
+    target: ["web", "es2020"],
+    entry: "./src/node/index.mjs",
+    output: {
+        path: path.resolve(__dirname, "build/node"),
+        filename: "CyberChef.js",
+        library: {
+            type: "commonjs2"
+        },
+        globalObject: "this"
+    },
+    resolve: {
+        extensions: [".mjs", ".js", ".json"],
+        alias: {
+            "./config/modules/OpModules.mjs": "./config/modules/Default.mjs"
+        },
+        fallback: {
+            "fs": false,
+            "child_process": false,
+            "net": false,
+            "tls": false,
+            "path": require.resolve("path-browserify"),
+            "crypto": require.resolve("crypto-browserify"),
+            "stream": require.resolve("stream-browserify"),
+            "zlib": require.resolve("browserify-zlib"),
+            "buffer": require.resolve("buffer/"),
+            "process": require.resolve("process/browser"),
+            "vm": require.resolve("vm-browserify"),
+            "util": require.resolve("util/"),
+            "os": require.resolve("os-browserify/browser"),
+            "assert": require.resolve("assert/"),
+            "url": require.resolve("url/"),
+            "querystring": require.resolve("querystring-es3"),
+            "http": require.resolve("stream-http"),
+            "https": require.resolve("https-browserify"),
+            "events": require.resolve("events/"),
+            "domain": false,
+            "constants": require.resolve("constants-browserify"),
+            "timers": require.resolve("timers-browserify")
+        }
+    },
+    module: {
+        rules: [
+            {
+                test: /\.m?js$/,
+                exclude: /node_modules\/(?!crypto-api)/,
+                use: {
+                    loader: "babel-loader",
+                    options: {
+                        configFile: path.resolve(__dirname, "babel.config.js"),
+                        cacheDirectory: true
+                    }
+                },
+                type: "javascript/auto"
+            },
+            {
+                test: /\.json$/,
+                type: "json"
+            }
+        ]
+    },
+    plugins: [
+        new webpack.ProvidePlugin({
+            process: "process/browser",
+            Buffer: ["buffer", "Buffer"]
+        }),
+        new webpack.BannerPlugin({
+            banner: banner,
+            raw: true,
+            entryOnly: true
+        }),
+        new webpack.DefinePlugin({
+            "process.browser": "true",
+            // Provide process.versions.node so isNodeEnvironment() works
+            // This allows the bundle to work in both real Node.js and
+            // environments with Node.js polyfills (like STPyV8/PythonMonkey)
+            "process.versions.node": JSON.stringify("18.0.0")
+        })
+    ],
+    optimization: {
+        minimize: false,
+        nodeEnv: false
+    },
+    stats: {
+        children: false,
+        chunks: false,
+        modules: false,
+        entrypoints: false
+    },
+    ignoreWarnings: [
+        /source-map/,
+        /source map/,
+        /dependency is an expression/,
+        /export 'default'/,
+        /Can't resolve 'sodium'/
+    ],
+    performance: {
+        hints: false
+    }
+};

```

`deps/README.md`:

```md
We're using a minor fork of CyberChef: https://github.com/williballenthin/CyberChef/tree/commonjs-minimal-interpeter

But in the event that this fork disappears for some reason, versus [CyberChef at commit 2a1294f1c089bb8e68d38d1803d08858907f352a](https://github.com/gchq/CyberChef/commit/2a1294f1c089bb8e68d38d1803d08858907f352a)
we've applied the patch in ./CyberChef.patch.


```
Author: Willi Ballenthin <wballenthin@hex-rays.com>
Date:   Sat Oct 11 22:28:56 2025 +0200

    fix: inject process.versions.node at build time

    This makes isNodeEnvironment() return true during webpack bundling,
    ensuring the Node.js code paths are included in the bundle.

    This allows the bundle to work in alternative JS runtimes like
    STPyV8 and PythonMonkey that provide Node.js polyfills.

    Without this, the webpack closure captures 'false' from the browser
    polyfill at build time, and runtime polyfills can't override it.
    better minimal runtime detection

commit 724c3c88f29cb7ae39e9eea2ce958f6767dda2b2
Author: Willi Ballenthin <wballenthin@hex-rays.com>
Date:   Fri Oct 10 17:22:50 2025 +0200

    add CommonJS build for a minimal JS interpreter

commit ca1cc19af97acf9c4feaff9743597299eb2ecd9b
Author: Willi Ballenthin <wballenthin@hex-rays.com>
Date:   Sat Oct 11 13:17:48 2025 +0200

    update JS import syntax
```

Basically: we fix the JS syntax and then make the NodeJS profile even more minimal - it relies on *very* little from the interpreter environment.
This way we can load it into a barebones SpiderMonkey/V8 interpreter.


```

`docs/ops.md`:

```md
# CyberChef Operations Reference

This document lists all 469 available CyberChef operations.

## Operations

### `A1Z26CipherDecode()`

**Module:** Ciphers

Converts alphabet order numbers into their corresponding  alphabet character.

e.g. `1` becomes `a` and `2` becomes `b`.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)

---

### `A1Z26CipherEncode()`

**Module:** Ciphers

Converts alphabet characters into their corresponding alphabet order number.

e.g. `a` becomes `1` and `b` becomes `2`.

Non-alphabet characters are dropped.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)

---

### `ADD()`

**Module:** Default

ADD the input with the given key (e.g. `fe023da5`), MOD 255

[More info](https://wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Key** (toggleString): default ``

---

### `AESDecrypt()`

**Module:** Ciphers

Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.

Key: The following algorithms will be used based on the size of the key:16 bytes = AES-12824 bytes = AES-19232 bytes = AES-256

IV: The Initialization Vector should be 16 bytes long. If not entered, it will default to 16 null bytes.

Padding: In CBC and ECB mode, PKCS#7 padding will be used as a default.

GCM Tag: This field is ignored unless 'GCM' mode is used.

[More info](https://wikipedia.org/wiki/Advanced_Encryption_Standard)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (argSelector): default `[{'name': 'CBC', 'off': [5, 6]}, {'name': 'CFB', 'off': [5, 6]}, {'name': 'OFB', 'off': [5, 6]}, {'name': 'CTR', 'off': [5, 6]}, {'name': 'GCM', 'on': [5, 6]}, {'name': 'ECB', 'off': [5, 6]}, {'name': 'CBC/NoPadding', 'off': [5, 6]}, {'name': 'ECB/NoPadding', 'off': [5, 6]}]`
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`
  - **GCM Tag** (toggleString): default ``
  - **Additional Authenticated Data** (toggleString): default ``

---

### `AESEncrypt()`

**Module:** Ciphers

Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.

Key: The following algorithms will be used based on the size of the key:16 bytes = AES-12824 bytes = AES-19232 bytes = AES-256You can generate a password-based key using one of the KDF operations.

IV: The Initialization Vector should be 16 bytes long. If not entered, it will default to 16 null bytes.

Padding: In CBC and ECB mode, PKCS#7 padding will be used.

[More info](https://wikipedia.org/wiki/Advanced_Encryption_Standard)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (argSelector): default `[{'name': 'CBC', 'off': [5]}, {'name': 'CFB', 'off': [5]}, {'name': 'OFB', 'off': [5]}, {'name': 'CTR', 'off': [5]}, {'name': 'GCM', 'on': [5]}, {'name': 'ECB', 'off': [5]}, {'name': 'CBC/NoPadding', 'off': [5]}, {'name': 'ECB/NoPadding', 'off': [5]}]`
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`
  - **Additional Authenticated Data** (toggleString): default ``

---

### `AESKeyUnwrap()`

**Module:** Ciphers

Decryptor for a key wrapping algorithm defined in RFC3394, which is used to protect keys in untrusted storage or communications, using AES.

This algorithm uses an AES key (KEK: key-encryption key) and a 64-bit IV to decrypt 64-bit blocks.

[More info](https://wikipedia.org/wiki/Key_wrap)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key (KEK)** (toggleString): default ``
  - **IV** (toggleString): default `a6a6a6a6a6a6a6a6`
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Hex`, `Raw`

---

### `AESKeyWrap()`

**Module:** Ciphers

A key wrapping algorithm defined in RFC3394, which is used to protect keys in untrusted storage or communications, using AES.

This algorithm uses an AES key (KEK: key-encryption key) and a 64-bit IV to encrypt 64-bit blocks.

[More info](https://wikipedia.org/wiki/Key_wrap)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key (KEK)** (toggleString): default ``
  - **IV** (toggleString): default `a6a6a6a6a6a6a6a6`
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Hex`, `Raw`

---

### `AMFDecode()`

**Module:** Encodings

Action Message Format (AMF) is a binary format used to serialize object graphs such as ActionScript objects and XML, or send messages between an Adobe Flash client and a remote service, usually a Flash Media Server or third party alternatives.

[More info](https://wikipedia.org/wiki/Action_Message_Format)

**Input:** `ArrayBuffer` → **Output:** `JSON`

**Arguments:**
  - **Format** (option): `AMF0`, `AMF3`

---

### `AMFEncode()`

**Module:** Encodings

Action Message Format (AMF) is a binary format used to serialize object graphs such as ActionScript objects and XML, or send messages between an Adobe Flash client and a remote service, usually a Flash Media Server or third party alternatives.

[More info](https://wikipedia.org/wiki/Action_Message_Format)

**Input:** `JSON` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Format** (option): `AMF0`, `AMF3`

---

### `AND()`

**Module:** Default

AND the input with the given key. e.g. `fe023da5`

[More info](https://wikipedia.org/wiki/Bitwise_operation#AND)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Key** (toggleString): default ``

---

### `BLAKE2b()`

**Module:** Hashing

Performs BLAKE2b hashing on the input.  
        

 BLAKE2b is a flavour of the BLAKE cryptographic hash function that is optimized for 64-bit platforms and produces digests of any size between 1 and 64 bytes.
        

 Supports the use of an optional key.

[More info](https://wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2b_algorithm)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (option): `512`, `384`, `256` (+2 more)
  - **Output Encoding** (option): `Hex`, `Base64`, `Raw`
  - **Key** (toggleString): default ``

---

### `BLAKE2s()`

**Module:** Hashing

Performs BLAKE2s hashing on the input.  
        

BLAKE2s is a flavour of the BLAKE cryptographic hash function that is optimized for 8- to 32-bit platforms and produces digests of any size between 1 and 32 bytes.
        

Supports the use of an optional key.

[More info](https://wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (option): `256`, `160`, `128`
  - **Output Encoding** (option): `Hex`, `Base64`, `Raw`
  - **Key** (toggleString): default ``

---

### `BLAKE3()`

**Module:** Hashing

Hashes the input using BLAKE3 (UTF-8 encoded), with an optional key (also UTF-8), and outputs the result in hexadecimal format.

[More info](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE3)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Size (bytes)** (number): default ``
  - **Key** (string): default ``

---

### `BSONDeserialise()`

**Module:** Serialise

BSON is a computer data interchange format used mainly as a data storage and network transfer format in the MongoDB database. It is a binary form for representing simple data structures, associative arrays (called objects or documents in MongoDB), and various data types of specific interest to MongoDB. The name 'BSON' is based on the term JSON and stands for 'Binary JSON'.

Input data should be in a raw bytes format.

[More info](https://wikipedia.org/wiki/BSON)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `BSONSerialise()`

**Module:** Serialise

BSON is a computer data interchange format used mainly as a data storage and network transfer format in the MongoDB database. It is a binary form for representing simple data structures, associative arrays (called objects or documents in MongoDB), and various data types of specific interest to MongoDB. The name 'BSON' is based on the term JSON and stands for 'Binary JSON'.

Input data should be valid JSON.

[More info](https://wikipedia.org/wiki/BSON)

**Input:** `string` → **Output:** `ArrayBuffer`

---

### `CBORDecode()`

**Module:** Serialise

Concise Binary Object Representation (CBOR) is a binary data serialization format loosely based on JSON. Like JSON it allows the transmission of data objects that contain name–value pairs, but in a more concise manner. This increases processing and transfer speeds at the cost of human readability. It is defined in IETF RFC 8949.

[More info](https://wikipedia.org/wiki/CBOR)

**Input:** `ArrayBuffer` → **Output:** `JSON`

---

### `CBOREncode()`

**Module:** Serialise

Concise Binary Object Representation (CBOR) is a binary data serialization format loosely based on JSON. Like JSON it allows the transmission of data objects that contain name–value pairs, but in a more concise manner. This increases processing and transfer speeds at the cost of human readability. It is defined in IETF RFC 8949.

[More info](https://wikipedia.org/wiki/CBOR)

**Input:** `JSON` → **Output:** `ArrayBuffer`

---

### `CMAC()`

**Module:** Crypto

CMAC is a block-cipher based message authentication code algorithm.

RFC4493 defines AES-CMAC that uses AES encryption with a 128-bit key. NIST SP 800-38B suggests usages of AES with other key lengths and Triple DES.

[More info](https://wikipedia.org/wiki/CMAC)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Encryption algorithm** (option): `AES`, `Triple DES`

---

### `CRCChecksum()`

**Module:** Default

A Cyclic Redundancy Check (CRC) is an error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data.

[More info](https://wikipedia.org/wiki/Cyclic_redundancy_check)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Algorithm** (argSelector): default `[{'name': 'Custom', 'on': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-3/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-3/ROHC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-4/G-704', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-4/INTERLAKEN', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-4/ITU', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-5/EPC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-5/EPC-C1G2', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-5/G-704', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-5/ITU', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-5/USB', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-6/CDMA2000-A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-6/CDMA2000-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-6/DARC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-6/G-704', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-6/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-6/ITU', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-7/MMC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-7/ROHC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-7/UMTS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/8H2F', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/AES', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/AUTOSAR', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/BLUETOOTH', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/CDMA2000', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/DARC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/DVB-S2', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/EBU', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/GSM-A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/GSM-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/HITAG', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/I-432-1', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/I-CODE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/ITU', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/LTE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/MAXIM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/MAXIM-DOW', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/MIFARE-MAD', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/NRSC-5', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/OPENSAFETY', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/ROHC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/SAE-J1850', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/SAE-J1850-ZERO', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/SMBUS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/TECH-3250', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-8/WCDMA', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-10/ATM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-10/CDMA2000', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-10/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-10/I-610', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-11/FLEXRAY', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-11/UMTS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-12/3GPP', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-12/CDMA2000', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-12/DECT', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-12/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-12/UMTS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-13/BBC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-14/DARC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-14/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-15/CAN', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-15/MPT1327', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/ACORN', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/ARC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/AUG-CCITT', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/AUTOSAR', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/BLUETOOTH', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/BUYPASS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/CCITT', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/CCITT-FALSE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/CCITT-TRUE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/CCITT-ZERO', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/CDMA2000', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/CMS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/DARC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/DDS-110', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/DECT-R', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/DECT-X', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/DNP', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/EN-13757', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/EPC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/EPC-C1G2', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/GENIBUS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/I-CODE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/IBM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/IBM-3740', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/IBM-SDLC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/IEC-61158-2', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/ISO-HDLC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/ISO-IEC-14443-3-A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/ISO-IEC-14443-3-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/KERMIT', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/LHA', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/LJ1200', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/LTE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/M17', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/MAXIM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/MAXIM-DOW', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/MCRF4XX', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/MODBUS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/NRSC-5', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/OPENSAFETY-A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/OPENSAFETY-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/PROFIBUS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/RIELLO', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/SPI-FUJITSU', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/T10-DIF', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/TELEDISK', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/TMS37157', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/UMTS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/USB', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/V-41-LSB', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/V-41-MSB', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/VERIFONE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/X-25', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/XMODEM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-16/ZMODEM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-17/CAN-FD', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-21/CAN-FD', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/BLE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/FLEXRAY-A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/FLEXRAY-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/INTERLAKEN', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/LTE-A', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/LTE-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/OPENPGP', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-24/OS-9', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-30/CDMA', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-31/PHILIPS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/AAL5', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/ADCCP', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/AIXM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/AUTOSAR', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/BASE91-C', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/BASE91-D', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/BZIP2', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/C', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/CASTAGNOLI', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/CD-ROM-EDC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/CKSUM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/D', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/DECT-B', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/INTERLAKEN', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/ISCSI', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/ISO-HDLC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/JAMCRC', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/MEF', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/MPEG-2', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/NVME', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/PKZIP', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/POSIX', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/Q', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/SATA', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/V-42', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/XFER', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-32/XZ', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-40/GSM', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/ECMA-182', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/GO-ECMA', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/GO-ISO', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/MS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/NVME', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/REDIS', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/WE', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-64/XZ', 'off': [1, 2, 3, 4, 5, 6]}, {'name': 'CRC-82/DARC', 'off': [1, 2, 3, 4, 5, 6]}]`
  - **Width (bits)** (toggleString): default `0`
  - **Polynomial** (toggleString): default `0`
  - **Initialization** (toggleString): default `0`
  - **Reflect input** (option): `True`, `False`
  - **Reflect output** (option): `True`, `False`
  - **Xor Output** (toggleString): default `0`

---

### `CSSBeautify()`

**Module:** Code

Indents and prettifies Cascading Style Sheets (CSS) code.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Indent string** (binaryShortString): default `\t`

---

### `CSSMinify()`

**Module:** Code

Compresses Cascading Style Sheets (CSS) code.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Preserve comments** (boolean): default `False`

---

### `CSSSelector()`

**Module:** Code

Extract information from an HTML document with a CSS selector

[More info](https://wikipedia.org/wiki/Cascading_Style_Sheets#Selector)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **CSS selector** (string): default ``
  - **Delimiter** (binaryShortString): default `\n`

---

### `CSVToJSON()`

**Module:** Default

Converts a CSV file to JSON format.

[More info](https://wikipedia.org/wiki/Comma-separated_values)

**Input:** `string` → **Output:** `JSON`

**Arguments:**
  - **Cell delimiters** (binaryShortString): default `,`
  - **Row delimiters** (binaryShortString): default `\r\n`
  - **Format** (option): `Array of dictionaries`, `Array of arrays`

---

### `CTPH()`

**Module:** Crypto

Context Triggered Piecewise Hashing, also called Fuzzy Hashing, can match inputs that have homologies. Such inputs have sequences of identical bytes in the same order, although bytes in between these sequences may be different in both content and length.

CTPH was originally based on the work of Dr. Andrew Tridgell and a spam email detector called SpamSum. This method was adapted by Jesse Kornblum and published at the DFRWS conference in 2006 in a paper 'Identifying Almost Identical Files Using Context Triggered Piecewise Hashing'.

[More info](https://forensics.wiki/context_triggered_piecewise_hashing/)

**Input:** `string` → **Output:** `string`

---

### `DESDecrypt()`

**Module:** Ciphers

DES is a previously dominant algorithm for encryption, and was published as an official U.S. Federal Information Processing Standard (FIPS). It is now considered to be insecure due to its small key size.

Key: DES uses a key length of 8 bytes (64 bits).

IV: The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.

Padding: In CBC and ECB mode, PKCS#7 padding will be used as a default.

[More info](https://wikipedia.org/wiki/Data_Encryption_Standard)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+4 more)
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `DESEncrypt()`

**Module:** Ciphers

DES is a previously dominant algorithm for encryption, and was published as an official U.S. Federal Information Processing Standard (FIPS). It is now considered to be insecure due to its small key size.

Key: DES uses a key length of 8 bytes (64 bits).

You can generate a password-based key using one of the KDF operations.

IV: The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.

Padding: In CBC and ECB mode, PKCS#7 padding will be used.

[More info](https://wikipedia.org/wiki/Data_Encryption_Standard)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+2 more)
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`

---

### `DNSOverHTTPS()`

**Module:** Default

Takes a single domain name and performs a DNS lookup using DNS over HTTPS.



By default, Cloudflare and Google DNS over HTTPS services are supported.



Can be used with any service that supports the GET parameters `name` and `type`.

[More info](https://wikipedia.org/wiki/DNS_over_HTTPS)

**Input:** `string` → **Output:** `JSON`

**Arguments:**
  - **Resolver** (editableOption): `Google`, `Cloudflare`
  - **Request Type** (option): `A`, `AAAA`, `ANAME` (+20 more)
  - **Answer Data Only** (boolean): default `False`
  - **Disable DNSSEC validation** (boolean): default `False`

---

### `ECDSASign()`

**Module:** Ciphers

Sign a plaintext message with a PEM encoded EC key.

[More info](https://wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **ECDSA Private Key (PEM)** (text): default `-----BEGIN EC PRIVATE KEY-----`
  - **Message Digest Algorithm** (option): `SHA-256`, `SHA-384`, `SHA-512` (+2 more)
  - **Output Format** (option): `ASN.1 HEX`, `P1363 HEX`, `JSON Web Signature` (+1 more)

---

### `ECDSASignatureConversion()`

**Module:** Ciphers

Convert an ECDSA signature between hex, asn1 and json.

[More info](https://wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input Format** (option): `Auto`, `ASN.1 HEX`, `P1363 HEX` (+2 more)
  - **Output Format** (option): `ASN.1 HEX`, `P1363 HEX`, `JSON Web Signature` (+1 more)

---

### `ECDSAVerify()`

**Module:** Ciphers

Verify a message against a signature and a public PEM encoded EC key.

[More info](https://wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input Format** (option): `Auto`, `ASN.1 HEX`, `P1363 HEX` (+2 more)
  - **Message Digest Algorithm** (option): `SHA-256`, `SHA-384`, `SHA-512` (+2 more)
  - **ECDSA Public Key (PEM)** (text): default `-----BEGIN PUBLIC KEY-----`
  - **Message** (text): default ``
  - **Message format** (option): `Raw`, `Hex`, `Base64`

---

### `ELFInfo()`

**Module:** Default

Implements readelf-like functionality. This operation will extract the ELF Header, Program Headers, Section Headers and Symbol Table for an ELF file.

[More info](https://www.wikipedia.org/wiki/Executable_and_Linkable_Format)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `GOSTDecrypt()`

**Module:** Ciphers

The GOST block cipher (Magma), defined in the standard GOST 28147-89 (RFC 5830), is a Soviet and Russian government standard symmetric key block cipher with a block size of 64 bits. The original standard, published in 1989, did not give the cipher any name, but the most recent revision of the standard, GOST R 34.12-2015 (RFC 7801, RFC 8891), specifies that it may be referred to as Magma. The GOST hash function is based on this cipher. The new standard also specifies a new 128-bit block cipher called Kuznyechik.

Developed in the 1970s, the standard had been marked 'Top Secret' and then downgraded to 'Secret' in 1990. Shortly after the dissolution of the USSR, it was declassified and it was released to the public in 1994. GOST 28147 was a Soviet alternative to the United States standard algorithm, DES. Thus, the two are very similar in structure.

[More info](https://wikipedia.org/wiki/GOST_(block_cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Input type** (option): `Hex`, `Raw`
  - **Output type** (option): `Raw`, `Hex`
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1989)', 'on': [5]}, {'name': 'GOST R 34.12 (Magma, 2015)', 'off': [5]}, {'name': 'GOST R 34.12 (Kuznyechik, 2015)', 'off': [5]}]`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)
  - **Block mode** (option): `ECB`, `CFB`, `OFB` (+2 more)
  - **Key meshing mode** (option): `NO`, `CP`
  - **Padding** (option): `NO`, `PKCS5`, `ZERO` (+2 more)

---

### `GOSTEncrypt()`

**Module:** Ciphers

The GOST block cipher (Magma), defined in the standard GOST 28147-89 (RFC 5830), is a Soviet and Russian government standard symmetric key block cipher with a block size of 64 bits. The original standard, published in 1989, did not give the cipher any name, but the most recent revision of the standard, GOST R 34.12-2015 (RFC 7801, RFC 8891), specifies that it may be referred to as Magma. The GOST hash function is based on this cipher. The new standard also specifies a new 128-bit block cipher called Kuznyechik.

Developed in the 1970s, the standard had been marked 'Top Secret' and then downgraded to 'Secret' in 1990. Shortly after the dissolution of the USSR, it was declassified and it was released to the public in 1994. GOST 28147 was a Soviet alternative to the United States standard algorithm, DES. Thus, the two are very similar in structure.

[More info](https://wikipedia.org/wiki/GOST_(block_cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Input type** (option): `Raw`, `Hex`
  - **Output type** (option): `Hex`, `Raw`
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1989)', 'on': [5]}, {'name': 'GOST R 34.12 (Magma, 2015)', 'off': [5]}, {'name': 'GOST R 34.12 (Kuznyechik, 2015)', 'off': [5]}]`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)
  - **Block mode** (option): `ECB`, `CFB`, `OFB` (+2 more)
  - **Key meshing mode** (option): `NO`, `CP`
  - **Padding** (option): `NO`, `PKCS5`, `ZERO` (+2 more)

---

### `GOSTHash()`

**Module:** Hashing

The GOST hash function, defined in the standards GOST R 34.11-94 and GOST 34.311-95 is a 256-bit cryptographic hash function. It was initially defined in the Russian national standard GOST R 34.11-94 Information Technology – Cryptographic Information Security – Hash Function. The equivalent standard used by other member-states of the CIS is GOST 34.311-95.

This function must not be confused with a different Streebog hash function, which is defined in the new revision of the standard GOST R 34.11-2012.

The GOST hash function is based on the GOST block cipher.

[More info](https://wikipedia.org/wiki/GOST_(hash_function))

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1994)', 'off': [1], 'on': [2]}, {'name': 'GOST R 34.11 (Streebog, 2012)', 'on': [1], 'off': [2]}]`
  - **Digest length** (option): `256`, `512`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)

---

### `GOSTKeyUnwrap()`

**Module:** Ciphers

A decryptor for keys wrapped using one of the GOST block ciphers.

[More info](https://wikipedia.org/wiki/GOST_(block_cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **User Key Material** (toggleString): default ``
  - **Input type** (option): `Hex`, `Raw`
  - **Output type** (option): `Raw`, `Hex`
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1989)', 'on': [5]}, {'name': 'GOST R 34.12 (Magma, 2015)', 'off': [5]}, {'name': 'GOST R 34.12 (Kuznyechik, 2015)', 'off': [5]}]`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)
  - **Key wrapping** (option): `NO`, `CP`, `SC`

---

### `GOSTKeyWrap()`

**Module:** Ciphers

A key wrapping algorithm for protecting keys in untrusted storage using one of the GOST block cipers.

[More info](https://wikipedia.org/wiki/GOST_(block_cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **User Key Material** (toggleString): default ``
  - **Input type** (option): `Raw`, `Hex`
  - **Output type** (option): `Hex`, `Raw`
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1989)', 'on': [5]}, {'name': 'GOST R 34.12 (Magma, 2015)', 'off': [5]}, {'name': 'GOST R 34.12 (Kuznyechik, 2015)', 'off': [5]}]`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)
  - **Key wrapping** (option): `NO`, `CP`, `SC`

---

### `GOSTSign()`

**Module:** Ciphers

Sign a plaintext message using one of the GOST block ciphers.

[More info](https://wikipedia.org/wiki/GOST_(block_cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Input type** (option): `Raw`, `Hex`
  - **Output type** (option): `Hex`, `Raw`
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1989)', 'on': [5]}, {'name': 'GOST R 34.12 (Magma, 2015)', 'off': [5]}, {'name': 'GOST R 34.12 (Kuznyechik, 2015)', 'off': [5]}]`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)
  - **MAC length** (number): default `32`

---

### `GOSTVerify()`

**Module:** Ciphers

Verify the signature of a plaintext message using one of the GOST block ciphers. Enter the signature in the MAC field.

[More info](https://wikipedia.org/wiki/GOST_(block_cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **MAC** (toggleString): default ``
  - **Input type** (option): `Raw`, `Hex`
  - **Algorithm** (argSelector): default `[{'name': 'GOST 28147 (1989)', 'on': [5]}, {'name': 'GOST R 34.12 (Magma, 2015)', 'off': [5]}, {'name': 'GOST R 34.12 (Kuznyechik, 2015)', 'off': [5]}]`
  - **sBox** (option): `E-TEST`, `E-A`, `E-B` (+7 more)

---

### `HAS160()`

**Module:** Crypto

HAS-160 is a cryptographic hash function designed for use with the Korean KCDSA digital signature algorithm. It is derived from SHA-1, with assorted changes intended to increase its security. It produces a 160-bit output.

HAS-160 is used in the same way as SHA-1. First it divides input in blocks of 512 bits each and pads the final block. A digest function updates the intermediate hash value by processing the input blocks in turn.

The message digest algorithm consists, by default, of 80 rounds.

[More info](https://wikipedia.org/wiki/HAS-160)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Rounds** (number): default `80`

---

### `HASSHClientFingerprint()`

**Module:** Crypto

Generates a HASSH fingerprint to help identify SSH clients based on hashing together values from the Client Key Exchange Init message.

Input: A hex stream of the SSH_MSG_KEXINIT packet application layer from Client to Server.

[More info](https://engineering.salesforce.com/open-sourcing-hassh-abed3ae5044c)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Hex`, `Base64`, `Raw`
  - **Output format** (option): `Hash digest`, `HASSH algorithms string`, `Full details`

---

### `HASSHServerFingerprint()`

**Module:** Crypto

Generates a HASSH fingerprint to help identify SSH servers based on hashing together values from the Server Key Exchange Init message.

Input: A hex stream of the SSH_MSG_KEXINIT packet application layer from Server to Client.

[More info](https://engineering.salesforce.com/open-sourcing-hassh-abed3ae5044c)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Hex`, `Base64`, `Raw`
  - **Output format** (option): `Hash digest`, `HASSH algorithms string`, `Full details`

---

### `HMAC()`

**Module:** Crypto

Keyed-Hash Message Authentication Codes (HMAC) are a mechanism for message authentication using cryptographic hash functions.

[More info](https://wikipedia.org/wiki/HMAC)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Hashing function** (option): `MD2`, `MD4`, `MD5` (+17 more)

---

### `HTMLToText()`

**Module:** Default

Converts an HTML output from an operation to a readable string instead of being rendered in the DOM.

**Input:** `html` → **Output:** `string`

---

### `HTTPRequest()`

**Module:** Default

Makes an HTTP request and returns the response.



This operation supports different HTTP verbs like GET, POST, PUT, etc.



You can add headers line by line in the format `Key: Value`



The status code of the response, along with a limited selection of exposed headers, can be viewed by checking the 'Show response metadata' option. Only a limited set of response headers are exposed by the browser for security reasons.

[More info](https://wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Method** (option): `GET`, `POST`, `HEAD` (+6 more)
  - **URL** (string): default ``
  - **Headers** (text): default ``
  - **Mode** (option): `Cross-Origin Resource Sharing`, `No CORS (limited to HEAD, GET or POST)`
  - **Show response metadata** (boolean): default `False`

---

### `IPv6TransitionAddresses()`

**Module:** Default

Converts IPv4 addresses to their IPv6 Transition addresses. IPv6 Transition addresses can also be converted back into their original IPv4 address. MAC addresses can also be converted into the EUI-64 format, this can them be appended to your IPv6 /64 range to obtain a full /128 address.

Transition technologies enable translation between IPv4 and IPv6 addresses or tunneling to allow traffic to pass through the incompatible network, allowing the two standards to coexist.

Only /24 ranges and currently handled. Remove headers to easily copy out results.

[More info](https://wikipedia.org/wiki/IPv6_transition_mechanism)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Ignore ranges** (boolean): default `True`
  - **Remove headers** (boolean): default `False`

---

### `JA3Fingerprint()`

**Module:** Crypto

Generates a JA3 fingerprint to help identify TLS clients based on hashing together values from the Client Hello.

Input: A hex stream of the TLS Client Hello packet application layer.

[More info](https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Hex`, `Base64`, `Raw`
  - **Output format** (option): `Hash digest`, `JA3 string`, `Full details`

---

### `JA3SFingerprint()`

**Module:** Crypto

Generates a JA3S fingerprint to help identify TLS servers based on hashing together values from the Server Hello.

Input: A hex stream of the TLS Server Hello record application layer.

[More info](https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Hex`, `Base64`, `Raw`
  - **Output format** (option): `Hash digest`, `JA3S string`, `Full details`

---

### `JA4Fingerprint()`

**Module:** Crypto

Generates a JA4 fingerprint to help identify TLS clients based on hashing together values from the Client Hello.

Input: A hex stream of the TLS or QUIC Client Hello packet application layer.

[More info](https://medium.com/foxio/ja4-network-fingerprinting-9376fe9ca637)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Hex`, `Base64`, `Raw`
  - **Output format** (option): `JA4`, `JA4 Original Rendering`, `JA4 Raw` (+2 more)

---

### `JA4ServerFingerprint()`

**Module:** Crypto

Generates a JA4Server Fingerprint (JA4S) to help identify TLS servers or sessions based on hashing together values from the Server Hello.

Input: A hex stream of the TLS or QUIC Server Hello packet application layer.

[More info](https://medium.com/foxio/ja4-network-fingerprinting-9376fe9ca637)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Hex`, `Base64`, `Raw`
  - **Output format** (option): `JA4S`, `JA4S Raw`, `Both`

---

### `JPathExpression()`

**Module:** Code

Extract information from a JSON object with a JPath query.

[More info](http://goessner.net/articles/JsonPath/)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Query** (string): default ``
  - **Result delimiter** (binaryShortString): default `\n`

---

### `JSONBeautify()`

**Module:** Code

Indents and pretty prints JavaScript Object Notation (JSON) code.

Tags: json viewer, prettify, syntax highlighting

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Indent string** (binaryShortString): default `    `
  - **Sort Object Keys** (boolean): default `False`
  - **Formatted** (boolean): default `True`

---

### `JSONMinify()`

**Module:** Code

Compresses JavaScript Object Notation (JSON) code.

**Input:** `string` → **Output:** `string`

---

### `JSONToCSV()`

**Module:** Default

Converts JSON data to a CSV based on the definition in RFC 4180.

[More info](https://wikipedia.org/wiki/Comma-separated_values)

**Input:** `JSON` → **Output:** `string`

**Arguments:**
  - **Cell delimiter** (binaryShortString): default `,`
  - **Row delimiter** (binaryShortString): default `\r\n`

---

### `JSONtoYAML()`

**Module:** Default

Format a JSON object into YAML

[More info](https://en.wikipedia.org/wiki/YAML)

**Input:** `JSON` → **Output:** `string`

---

### `JWKToPem()`

**Module:** PublicKey

Converts Keys in JSON Web Key format to PEM format (PKCS#8).

[More info](https://datatracker.ietf.org/doc/html/rfc7517)

**Input:** `string` → **Output:** `string`

---

### `JWTDecode()`

**Module:** Crypto

Decodes a JSON Web Token without checking whether the provided secret / private key is valid. Use 'JWT Verify' to check if the signature is valid as well.

[More info](https://wikipedia.org/wiki/JSON_Web_Token)

**Input:** `string` → **Output:** `JSON`

---

### `JWTSign()`

**Module:** Crypto

Signs a JSON object as a JSON Web Token using a provided secret / private key.

The key should be either the secret for HMAC algorithms or the PEM-encoded private key for RSA and ECDSA.

[More info](https://wikipedia.org/wiki/JSON_Web_Token)

**Input:** `JSON` → **Output:** `string`

**Arguments:**
  - **Private/Secret Key** (text): default `secret`
  - **Signing algorithm** (option): `HS256`, `HS384`, `HS512` (+7 more)
  - **Header** (text): default `{}`

---

### `JWTVerify()`

**Module:** Crypto

Verifies that a JSON Web Token is valid and has been signed with the provided secret / private key.

The key should be either the secret for HMAC algorithms or the PEM-encoded public key for RSA and ECDSA.

[More info](https://wikipedia.org/wiki/JSON_Web_Token)

**Input:** `string` → **Output:** `JSON`

**Arguments:**
  - **Public/Secret Key** (text): default `secret`

---

### `LMHash()`

**Module:** Crypto

An LM Hash, or LAN Manager Hash, is a deprecated way of storing passwords on old Microsoft operating systems. It is particularly weak and can be cracked in seconds on modern hardware using rainbow tables.

[More info](https://wikipedia.org/wiki/LAN_Manager#Password_hashing_algorithm)

**Input:** `string` → **Output:** `string`

---

### `LS47Decrypt()`

**Module:** Crypto

This is a slight improvement of the ElsieFour cipher as described by Alan Kaminsky. We use 7x7 characters instead of original (barely fitting) 6x6, to be able to encrypt some structured information. We also describe a simple key-expansion algorithm, because remembering passwords is popular. Similar security considerations as with ElsieFour hold. The LS47 alphabet consists of following characters: `_abcdefghijklmnopqrstuvwxyz.0123456789,-+*/:?!'()` An LS47 key is a permutation of the alphabet that is then represented in a 7x7 grid used for the encryption or decryption.

[More info](https://github.com/exaexa/ls47)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Password** (string): default ``
  - **Padding** (number): default `10`

---

### `LS47Encrypt()`

**Module:** Crypto

This is a slight improvement of the ElsieFour cipher as described by Alan Kaminsky. We use 7x7 characters instead of original (barely fitting) 6x6, to be able to encrypt some structured information. We also describe a simple key-expansion algorithm, because remembering passwords is popular. Similar security considerations as with ElsieFour hold. The LS47 alphabet consists of following characters: `_abcdefghijklmnopqrstuvwxyz.0123456789,-+*/:?!'()` A LS47 key is a permutation of the alphabet that is then represented in a 7x7 grid used for the encryption or decryption.

[More info](https://github.com/exaexa/ls47)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Password** (string): default ``
  - **Padding** (number): default `10`
  - **Signature** (string): default ``

---

### `LZ4Compress()`

**Module:** Compression

LZ4 is a lossless data compression algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family of byte-oriented compression schemes.

[More info](https://wikipedia.org/wiki/LZ4_(compression_algorithm))

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `LZ4Decompress()`

**Module:** Compression

LZ4 is a lossless data compression algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family of byte-oriented compression schemes.

[More info](https://wikipedia.org/wiki/LZ4_(compression_algorithm))

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `LZMACompress()`

**Module:** Compression

Compresses data using the Lempel–Ziv–Markov chain algorithm. Compression mode determines the speed and effectiveness of the compression: 1 is fastest and less effective, 9 is slowest and most effective

[More info](https://wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Compression Mode** (option): `1`, `2`, `3` (+6 more)

---

### `LZMADecompress()`

**Module:** Compression

Decompresses data using the Lempel-Ziv-Markov chain Algorithm.

[More info](https://wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `LZNT1Decompress()`

**Module:** Compression

Decompresses data using the LZNT1 algorithm.

Similar to the Windows API `RtlDecompressBuffer`.

[More info](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-xca/5655f4a3-6ba4-489b-959f-e1f407c52f15)

**Input:** `byteArray` → **Output:** `byteArray`

---

### `LZStringCompress()`

**Module:** Compression

Compress the input with lz-string.

[More info](https://pieroxy.net/blog/pages/lz-string/index.html)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Compression Format** (option): `default`, `UTF16`, `Base64`

---

### `LZStringDecompress()`

**Module:** Compression

Decompresses data that was compressed with lz-string.

[More info](https://pieroxy.net/blog/pages/lz-string/index.html)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Compression Format** (option): `default`, `UTF16`, `Base64`

---

### `MD2()`

**Module:** Crypto

The MD2 (Message-Digest 2) algorithm is a cryptographic hash function developed by Ronald Rivest in 1989. The algorithm is optimized for 8-bit computers.

Although MD2 is no longer considered secure, even as of 2014, it remains in use in public key infrastructures as part of certificates generated with MD2 and RSA. The message digest algorithm consists, by default, of 18 rounds.

[More info](https://wikipedia.org/wiki/MD2_(cryptography))

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Rounds** (number): default `18`

---

### `MD4()`

**Module:** Crypto

The MD4 (Message-Digest 4) algorithm is a cryptographic hash function developed by Ronald Rivest in 1990. The digest length is 128 bits. The algorithm has influenced later designs, such as the MD5, SHA-1 and RIPEMD algorithms.

The security of MD4 has been severely compromised.

[More info](https://wikipedia.org/wiki/MD4)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `MD5()`

**Module:** Crypto

MD5 (Message-Digest 5) is a widely used hash function. It has been used in a variety of security applications and is also commonly used to check the integrity of files.

However, MD5 is not collision resistant and it isn't suitable for applications like SSL/TLS certificates or digital signatures that rely on this property.

[More info](https://wikipedia.org/wiki/MD5)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `MD6()`

**Module:** Crypto

The MD6 (Message-Digest 6) algorithm is a cryptographic hash function. It uses a Merkle tree-like structure to allow for immense parallel computation of hashes for very long inputs.

[More info](https://wikipedia.org/wiki/MD6)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Size** (number): default `256`
  - **Levels** (number): default `64`
  - **Key** (string): default ``

---

### `MIMEDecoding()`

**Module:** Default

Enables the decoding of MIME message header extensions for non-ASCII text

[More info](https://tools.ietf.org/html/rfc2047)

**Input:** `byteArray` → **Output:** `string`

---

### `NOT()`

**Module:** Default

Returns the inverse of each byte.

[More info](https://wikipedia.org/wiki/Bitwise_operation#NOT)

**Input:** `ArrayBuffer` → **Output:** `byteArray`

---

### `NTHash()`

**Module:** Crypto

An NT Hash, sometimes referred to as an NTLM hash, is a method of storing passwords on Windows systems. It works by running MD4 on UTF-16LE encoded input. NTLM hashes are considered weak because they can be brute-forced very easily with modern hardware.

[More info](https://wikipedia.org/wiki/NT_LAN_Manager)

**Input:** `string` → **Output:** `string`

---

### `OR()`

**Module:** Default

OR the input with the given key. e.g. `fe023da5`

[More info](https://wikipedia.org/wiki/Bitwise_operation#OR)

**Input:** `ArrayBuffer` → **Output:** `byteArray`

**Arguments:**
  - **Key** (toggleString): default ``

---

### `PEMToHex()`

**Module:** Default

Converts PEM (Privacy Enhanced Mail) format to a hexadecimal DER (Distinguished Encoding Rules) string.

[More info](https://wikipedia.org/wiki/Privacy-Enhanced_Mail#Format)

**Input:** `string` → **Output:** `string`

---

### `PEMToJWK()`

**Module:** PublicKey

Converts Keys in PEM format to a JSON Web Key format.

[More info](https://datatracker.ietf.org/doc/html/rfc7517)

**Input:** `string` → **Output:** `string`

---

### `PGPDecrypt()`

**Module:** PGP

Input: the ASCII-armoured PGP message you want to decrypt.



Arguments: the ASCII-armoured PGP private key of the recipient, 
(and the private key password if necessary).



Pretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.



This function uses the Keybase implementation of PGP.

[More info](https://wikipedia.org/wiki/Pretty_Good_Privacy)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Private key of recipient** (text): default ``
  - **Private key passphrase** (string): default ``

---

### `PGPDecryptAndVerify()`

**Module:** PGP

Input: the ASCII-armoured encrypted PGP message you want to verify.



Arguments: the ASCII-armoured PGP public key of the signer, 
the ASCII-armoured private key of the recipient (and the private key password if necessary).



This operation uses PGP to decrypt and verify an encrypted digital signature.



Pretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.



This function uses the Keybase implementation of PGP.

[More info](https://wikipedia.org/wiki/Pretty_Good_Privacy)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Public key of signer** (text): default ``
  - **Private key of recipient** (text): default ``
  - **Private key password** (string): default ``

---

### `PGPEncrypt()`

**Module:** PGP

Input: the message you want to encrypt.



Arguments: the ASCII-armoured PGP public key of the recipient.



Pretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.



This function uses the Keybase implementation of PGP.

[More info](https://wikipedia.org/wiki/Pretty_Good_Privacy)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Public key of recipient** (text): default ``

---

### `PGPEncryptAndSign()`

**Module:** PGP

Input: the cleartext you want to sign.



Arguments: the ASCII-armoured private key of the signer (plus the private key password if necessary)
and the ASCII-armoured PGP public key of the recipient.



This operation uses PGP to produce an encrypted digital signature.



Pretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.



This function uses the Keybase implementation of PGP.

[More info](https://wikipedia.org/wiki/Pretty_Good_Privacy)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Private key of signer** (text): default ``
  - **Private key passphrase** (string): default ``
  - **Public key of recipient** (text): default ``

---

### `PGPVerify()`

**Module:** PGP

Input: the ASCII-armoured encrypted PGP message you want to verify.



Argument: the ASCII-armoured PGP public key of the signer



This operation uses PGP to decrypt a clearsigned message.



Pretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.



This function uses the Keybase implementation of PGP.

[More info](https://wikipedia.org/wiki/Pretty_Good_Privacy)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Public key of signer** (text): default ``

---

### `PHPDeserialize()`

**Module:** Default

Deserializes PHP serialized data, outputting keyed arrays as JSON.

This function does not support `object` tags.

Example: `a:2:{s:1:&quot;a&quot;;i:10;i:0;a:1:{s:2:&quot;ab&quot;;b:1;}}` becomes `{&quot;a&quot;: 10,0: {&quot;ab&quot;: true}}`

Output valid JSON: JSON doesn't support integers as keys, whereas PHP serialization does. Enabling this will cast these integers to strings. This will also escape backslashes.

[More info](http://www.phpinternalsbook.com/classes_objects/serialization.html)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Output valid JSON** (boolean): default `True`

---

### `PHPSerialize()`

**Module:** Default

Performs PHP serialization on JSON data.

This function does not support `object` tags.

Since PHP doesn't distinguish dicts and arrays, this operation is not always symmetric to `PHP Deserialize`.

Example: `[5,&quot;abc&quot;,true]` becomes a:3:{i:0;i:5;i:1;s:3:&quot;abc&quot;;i:2;b:1;}

[More info](https://www.phpinternalsbook.com/php5/classes_objects/serialization.html)

**Input:** `JSON` → **Output:** `string`

---

### `PLISTViewer()`

**Module:** Default

In the macOS, iOS, NeXTSTEP, and GNUstep programming frameworks, property list files are files that store serialized objects. Property list files use the filename extension .plist, and thus are often referred to as p-list files.

This operation displays plist files in a human readable format.

[More info](https://wikipedia.org/wiki/Property_list)

**Input:** `string` → **Output:** `string`

---

### `RAKE()`

**Module:** Default

Rapid Keyword Extraction (RAKE)



RAKE is a domain-independent keyword extraction algorithm in Natural Language Processing.



The list of stop words are from the NLTK python package

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Word Delimiter (Regex)** (text): default `\s`
  - **Sentence Delimiter (Regex)** (text): default `\.\s|\n`
  - **Stop Words** (text): default `i,me,my,myself,we,our,ours,ourselves,you,you're,you've,you'll,you'd,your,yours,yourself,yourselves,he,him,his,himself,she,she's,her,hers,herself,it,it's,its,itsef,they,them,their,theirs,themselves,what,which,who,whom,this,that,that'll,these,those,am,is,are,was,were,be,been,being,have,has,had,having,do,does',did,doing,a,an,the,and,but,if,or,because,as,until,while,of,at,by,for,with,about,against,between,into,through,during,before,after,above,below,to,from,up,down,in,out,on,off,over,under,again,further,then,once,here,there,when,where,why,how,all,any,both,each,few,more,most,other,some,such,no,nor,not,only,own,same,so,than,too,very,s,t,can,will,just,don,don't,should,should've,now,d,ll,m,o,re,ve,y,ain,aren,aren't,couldn,couldn't,didn,didn't,doesn,doesn't,hadn,hadn't,hasn,hasn't,haven,haven't,isn,isn't,ma,mightn,mightn't,mustn,mustn't,needn,needn't,shan,shan't,shouldn,shouldn't,wasn,wasn't,weren,weren't,won,won't,wouldn,wouldn't`

---

### `RC2Decrypt()`

**Module:** Ciphers

RC2 (also known as ARC2) is a symmetric-key block cipher designed by Ron Rivest in 1987. 'RC' stands for 'Rivest Cipher'.

Key: RC2 uses a variable size key.

IV: To run the cipher in CBC mode, the Initialization Vector should be 8 bytes long. If the IV is left blank, the cipher will run in ECB mode.

Padding: In both CBC and ECB mode, PKCS#7 padding will be used.

[More info](https://wikipedia.org/wiki/RC2)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `RC2Encrypt()`

**Module:** Ciphers

RC2 (also known as ARC2) is a symmetric-key block cipher designed by Ron Rivest in 1987. 'RC' stands for 'Rivest Cipher'.

Key: RC2 uses a variable size key.

You can generate a password-based key using one of the KDF operations.

IV: To run the cipher in CBC mode, the Initialization Vector should be 8 bytes long. If the IV is left blank, the cipher will run in ECB mode.

Padding: In both CBC and ECB mode, PKCS#7 padding will be used.

[More info](https://wikipedia.org/wiki/RC2)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`

---

### `RC4()`

**Module:** Ciphers

RC4 (also known as ARC4) is a widely-used stream cipher designed by Ron Rivest. It is used in popular protocols such as SSL and WEP. Although remarkable for its simplicity and speed, the algorithm's history doesn't inspire confidence in its security.

[More info](https://wikipedia.org/wiki/RC4)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Passphrase** (toggleString): default ``
  - **Input format** (option): `Latin1`, `UTF8`, `UTF16` (+4 more)
  - **Output format** (option): `Latin1`, `UTF8`, `UTF16` (+4 more)

---

### `RC4Drop()`

**Module:** Ciphers

It was discovered that the first few bytes of the RC4 keystream are strongly non-random and leak information about the key. We can defend against this attack by discarding the initial portion of the keystream. This modified algorithm is traditionally called RC4-drop.

[More info](https://wikipedia.org/wiki/RC4#Fluhrer,_Mantin_and_Shamir_attack)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Passphrase** (toggleString): default ``
  - **Input format** (option): `Latin1`, `UTF8`, `UTF16` (+4 more)
  - **Output format** (option): `Latin1`, `UTF8`, `UTF16` (+4 more)
  - **Number of dwords to drop** (number): default `192`

---

### `RIPEMD()`

**Module:** Crypto

RIPEMD (RACE Integrity Primitives Evaluation Message Digest) is a family of cryptographic hash functions developed in Leuven, Belgium, by Hans Dobbertin, Antoon Bosselaers and Bart Preneel at the COSIC research group at the Katholieke Universiteit Leuven, and first published in 1996.

RIPEMD was based upon the design principles used in MD4, and is similar in performance to the more popular SHA-1.

[More info](https://wikipedia.org/wiki/RIPEMD)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (option): `320`, `256`, `160` (+1 more)

---

### `ROT13()`

**Module:** Default

A simple caesar substitution cipher which rotates alphabet characters by the specified amount (default 13).

[More info](https://wikipedia.org/wiki/ROT13)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Rotate lower case chars** (boolean): default `True`
  - **Rotate upper case chars** (boolean): default `True`
  - **Rotate numbers** (boolean): default `False`
  - **Amount** (number): default `13`

---

### `ROT13BruteForce()`

**Module:** Default

Try all meaningful amounts for ROT13.

Optionally you can enter your known plaintext (crib) to filter the result.

[More info](https://wikipedia.org/wiki/ROT13)

**Input:** `byteArray` → **Output:** `string`

**Arguments:**
  - **Rotate lower case chars** (boolean): default `True`
  - **Rotate upper case chars** (boolean): default `True`
  - **Rotate numbers** (boolean): default `False`
  - **Sample length** (number): default `100`
  - **Sample offset** (number): default `0`
  - **Print amount** (boolean): default `True`
  - **Crib (known plaintext string)** (string): default ``

---

### `ROT47()`

**Module:** Default

A slightly more complex variation of a caesar cipher, which includes ASCII characters from 33 '!' to 126 '~'. Default rotation: 47.

[More info](https://wikipedia.org/wiki/ROT13#Variants)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Amount** (number): default `47`

---

### `ROT47BruteForce()`

**Module:** Default

Try all meaningful amounts for ROT47.

Optionally you can enter your known plaintext (crib) to filter the result.

[More info](https://wikipedia.org/wiki/ROT13#Variants)

**Input:** `byteArray` → **Output:** `string`

**Arguments:**
  - **Sample length** (number): default `100`
  - **Sample offset** (number): default `0`
  - **Print amount** (boolean): default `True`
  - **Crib (known plaintext string)** (string): default ``

---

### `ROT8000()`

**Module:** Default

The simple Caesar-cypher encryption that replaces each Unicode character with the one 0x8000 places forward or back along the alphabet.

[More info](https://rot8000.com/info)

**Input:** `string` → **Output:** `string`

---

### `RSADecrypt()`

**Module:** Ciphers

Decrypt an RSA encrypted message with a PEM encoded private key.

[More info](https://wikipedia.org/wiki/RSA_(cryptosystem))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **RSA Private Key (PEM)** (text): default `-----BEGIN RSA PRIVATE KEY-----`
  - **Key Password** (text): default ``
  - **Encryption Scheme** (argSelector): default `[{'name': 'RSA-OAEP', 'on': [3]}, {'name': 'RSAES-PKCS1-V1_5', 'off': [3]}, {'name': 'RAW', 'off': [3]}]`
  - **Message Digest Algorithm** (option): `SHA-1`, `MD5`, `SHA-256` (+2 more)

---

### `RSAEncrypt()`

**Module:** Ciphers

Encrypt a message with a PEM encoded RSA public key.

[More info](https://wikipedia.org/wiki/RSA_(cryptosystem))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **RSA Public Key (PEM)** (text): default `-----BEGIN RSA PUBLIC KEY-----`
  - **Encryption Scheme** (argSelector): default `[{'name': 'RSA-OAEP', 'on': [2]}, {'name': 'RSAES-PKCS1-V1_5', 'off': [2]}, {'name': 'RAW', 'off': [2]}]`
  - **Message Digest Algorithm** (option): `SHA-1`, `MD5`, `SHA-256` (+2 more)

---

### `RSASign()`

**Module:** Ciphers

Sign a plaintext message with a PEM encoded RSA key.

[More info](https://wikipedia.org/wiki/RSA_(cryptosystem))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **RSA Private Key (PEM)** (text): default `-----BEGIN RSA PRIVATE KEY-----`
  - **Key Password** (text): default ``
  - **Message Digest Algorithm** (option): `SHA-1`, `MD5`, `SHA-256` (+2 more)

---

### `RSAVerify()`

**Module:** Ciphers

Verify a message against a signature and a public PEM encoded RSA key.

[More info](https://wikipedia.org/wiki/RSA_(cryptosystem))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **RSA Public Key (PEM)** (text): default `-----BEGIN RSA PUBLIC KEY-----`
  - **Message** (text): default ``
  - **Message format** (option): `Raw`, `Hex`, `Base64`
  - **Message Digest Algorithm** (option): `SHA-1`, `MD5`, `SHA-256` (+2 more)

---

### `Return()`

**Module:** Default

End execution of operations at this point in the recipe.

**Input:** `string` → **Output:** `string`

---

### `SHA0()`

**Module:** Crypto

SHA-0 is a retronym applied to the original version of the 160-bit hash function published in 1993 under the name 'SHA'. It was withdrawn shortly after publication due to an undisclosed 'significant flaw' and replaced by the slightly revised version SHA-1. The message digest algorithm consists, by default, of 80 rounds.

[More info](https://wikipedia.org/wiki/SHA-1#SHA-0)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Rounds** (number): default `80`

---

### `SHA1()`

**Module:** Crypto

The SHA (Secure Hash Algorithm) hash functions were designed by the NSA. SHA-1 is the most established of the existing SHA hash functions and it is used in a variety of security applications and protocols.

However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved. The message digest algorithm consists, by default, of 80 rounds.

[More info](https://wikipedia.org/wiki/SHA-1)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Rounds** (number): default `80`

---

### `SHA2()`

**Module:** Crypto

The SHA-2 (Secure Hash Algorithm 2) hash functions were designed by the NSA. SHA-2 includes significant changes from its predecessor, SHA-1. The SHA-2 family consists of hash functions with digests (hash values) that are 224, 256, 384 or 512 bits: SHA224, SHA256, SHA384, SHA512.

SHA-512 operates on 64-bit words.SHA-256 operates on 32-bit words.SHA-384 is largely identical to SHA-512 but is truncated to 384 bytes.SHA-224 is largely identical to SHA-256 but is truncated to 224 bytes.SHA-512/224 and SHA-512/256 are truncated versions of SHA-512, but the initial values are generated using the method described in Federal Information Processing Standards (FIPS) PUB 180-4. The message digest algorithm for SHA256 variants consists, by default, of 64 rounds, and for SHA512 variants, it is, by default, 160.

[More info](https://wikipedia.org/wiki/SHA-2)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (argSelector): default `[{'name': '512', 'on': [2], 'off': [1]}, {'name': '384', 'on': [2], 'off': [1]}, {'name': '256', 'on': [1], 'off': [2]}, {'name': '224', 'on': [1], 'off': [2]}, {'name': '512/256', 'on': [2], 'off': [1]}, {'name': '512/224', 'on': [2], 'off': [1]}]`
  - **Rounds** (number): default `64`
  - **Rounds** (number): default `160`

---

### `SHA3()`

**Module:** Crypto

The SHA-3 (Secure Hash Algorithm 3) hash functions were released by NIST on August 5, 2015. Although part of the same series of standards, SHA-3 is internally quite different from the MD5-like structure of SHA-1 and SHA-2.

SHA-3 is a subset of the broader cryptographic primitive family Keccak designed by Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche, building upon RadioGatún.

[More info](https://wikipedia.org/wiki/SHA-3)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (option): `512`, `384`, `256` (+1 more)

---

### `SIGABA()`

**Module:** Bletchley

Encipher/decipher with the WW2 SIGABA machine. 

SIGABA, otherwise known as ECM Mark II, was used by the United States for message encryption during WW2 up to the 1950s. It was developed in the 1930s by the US Army and Navy, and has up to this day never been broken. Consisting of 15 rotors: 5 cipher rotors and 10 rotors (5 control rotors and 5 index rotors) controlling the stepping of the cipher rotors, the rotor stepping for SIGABA is much more complex than other rotor machines of its time, such as Enigma. All example rotor wirings are random example sets.

To configure rotor wirings, for the cipher and control rotors enter a string of letters which map from A to Z, and for the index rotors enter a sequence of numbers which map from 0 to 9. Note that encryption is not the same as decryption, so first choose the desired mode. 

 Note: Whilst this has been tested against other software emulators, it has not been tested against hardware.

[More info](https://wikipedia.org/wiki/SIGABA)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **1st (left-hand) cipher rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **1st cipher rotor reversed** (boolean): default `False`
  - **1st cipher rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **2nd cipher rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **2nd cipher rotor reversed** (boolean): default `False`
  - **2nd cipher rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **3rd (middle) cipher rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **3rd cipher rotor reversed** (boolean): default `False`
  - **3rd cipher rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **4th cipher rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **4th cipher rotor reversed** (boolean): default `False`
  - **4th cipher rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **5th (right-hand) cipher rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **5th cipher rotor reversed** (boolean): default `False`
  - **5th cipher rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **1st (left-hand) control rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **1st control rotor reversed** (boolean): default `False`
  - **1st control rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **2nd control rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **2nd control rotor reversed** (boolean): default `False`
  - **2nd control rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **3rd (middle) control rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **3rd control rotor reversed** (boolean): default `False`
  - **3rd control rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **4th control rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **4th control rotor reversed** (boolean): default `False`
  - **4th control rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **5th (right-hand) control rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+7 more)
  - **5th control rotor reversed** (boolean): default `False`
  - **5th control rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **1st (left-hand) index rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+2 more)
  - **1st index rotor initial value** (option): `0`, `1`, `2` (+7 more)
  - **2nd index rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+2 more)
  - **2nd index rotor initial value** (option): `0`, `1`, `2` (+7 more)
  - **3rd (middle) index rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+2 more)
  - **3rd index rotor initial value** (option): `0`, `1`, `2` (+7 more)
  - **4th index rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+2 more)
  - **4th index rotor initial value** (option): `0`, `1`, `2` (+7 more)
  - **5th (right-hand) index rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+2 more)
  - **5th index rotor initial value** (option): `0`, `1`, `2` (+7 more)
  - **SIGABA mode** (option): `Encrypt`, `Decrypt`

---

### `SM2Decrypt()`

**Module:** Crypto

Decrypts a message utilizing the SM2 standard

**Input:** `string` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Private Key** (string): default `DEADBEEF`
  - **Input Format** (option): `C1C3C2`, `C1C2C3`
  - **Curve** (option): `sm2p256v1`

---

### `SM2Encrypt()`

**Module:** Crypto

Encrypts a message utilizing the SM2 standard

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Public Key X** (string): default `DEADBEEF`
  - **Public Key Y** (string): default `DEADBEEF`
  - **Output Format** (option): `C1C3C2`, `C1C2C3`
  - **Curve** (option): `sm2p256v1`

---

### `SM3()`

**Module:** Crypto

SM3 is a cryptographic hash function used in the Chinese National Standard. SM3 is mainly used in digital signatures, message authentication codes, and pseudorandom number generators. The message digest algorithm consists, by default, of 64 rounds and length of 256.

[More info](https://wikipedia.org/wiki/SM3_(hash_function))

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Length** (number): default `256`
  - **Rounds** (number): default `64`

---

### `SM4Decrypt()`

**Module:** Ciphers

SM4 is a 128-bit block cipher, currently established as a national standard (GB/T 32907-2016) of China.

[More info](https://wikipedia.org/wiki/SM4_(cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+4 more)
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`

---

### `SM4Encrypt()`

**Module:** Ciphers

SM4 is a 128-bit block cipher, currently established as a national standard (GB/T 32907-2016) of China. Multiple block cipher modes are supported. When using CBC or ECB mode, the PKCS#7 padding scheme is used.

[More info](https://wikipedia.org/wiki/SM4_(cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+2 more)
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`

---

### `SQLBeautify()`

**Module:** Code

Indents and prettifies Structured Query Language (SQL) code.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Indent string** (binaryShortString): default `\t`

---

### `SQLMinify()`

**Module:** Code

Compresses Structured Query Language (SQL) code.

**Input:** `string` → **Output:** `string`

---

### `SSDEEP()`

**Module:** Crypto

SSDEEP is a program for computing context triggered piecewise hashes (CTPH). Also called fuzzy hashes, CTPH can match inputs that have homologies. Such inputs have sequences of identical bytes in the same order, although bytes in between these sequences may be different in both content and length.

SSDEEP hashes are now widely used for simple identification purposes (e.g. the 'Basic Properties' section in VirusTotal). Although 'better' fuzzy hashes are available, SSDEEP is still one of the primary choices because of its speed and being a de facto standard.

This operation is fundamentally the same as the CTPH operation, however their outputs differ in format.

[More info](https://forensics.wiki/ssdeep)

**Input:** `string` → **Output:** `string`

---

### `SUB()`

**Module:** Default

SUB the input with the given key (e.g. `fe023da5`), MOD 255

[More info](https://wikipedia.org/wiki/Bitwise_operation#Bitwise_operators)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Key** (toggleString): default ``

---

### `TCPIPChecksum()`

**Module:** Crypto

Calculates the checksum for a TCP (Transport Control Protocol) or IP (Internet Protocol) header from an input of raw bytes.

[More info](https://wikipedia.org/wiki/IPv4_header_checksum)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `UNIXTimestampToWindowsFiletime()`

**Module:** Default

Converts a UNIX timestamp to a Windows Filetime value.

A Windows Filetime is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 UTC.

A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).

This operation also supports UNIX timestamps in milliseconds, microseconds and nanoseconds.

[More info](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284(v=vs.85).aspx)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input units** (option): `Seconds (s)`, `Milliseconds (ms)`, `Microseconds (μs)` (+1 more)
  - **Output format** (option): `Decimal`, `Hex (big endian)`, `Hex (little endian)`

---

### `URLDecode()`

**Module:** URL

Converts URI/URL percent-encoded characters back to their raw values.

e.g. `%3d` becomes `=`

[More info](https://wikipedia.org/wiki/Percent-encoding)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Treat "+" as space** (boolean): default `True`

---

### `URLEncode()`

**Module:** URL

Encodes problematic characters into percent-encoding, a format supported by URIs/URLs.

e.g. `=` becomes `%3d`

[More info](https://wikipedia.org/wiki/Percent-encoding)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Encode all special chars** (boolean): default `False`

---

### `XKCDRandomNumber()`

**Module:** Default

RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.

[More info](https://xkcd.com/221/)

**Input:** `string` → **Output:** `number`

---

### `XMLBeautify()`

**Module:** Code

Indents and prettifies eXtensible Markup Language (XML) code.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Indent string** (binaryShortString): default `\t`

---

### `XMLMinify()`

**Module:** Code

Compresses eXtensible Markup Language (XML) code.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Preserve comments** (boolean): default `False`

---

### `XOR()`

**Module:** Default

XOR the input with the given key. e.g. `fe023da5`

Options Null preserving: If the current byte is 0x00 or the same as the key, skip it.

Scheme:Standard - key is unchanged after each roundInput differential - key is set to the value of the previous unprocessed byteOutput differential - key is set to the value of the previous processed byteCascade - key is set to the input byte shifted by one

[More info](https://wikipedia.org/wiki/XOR)

**Input:** `ArrayBuffer` → **Output:** `byteArray`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Scheme** (option): `Standard`, `Input differential`, `Output differential` (+1 more)
  - **Null preserving** (boolean): default `False`

---

### `XORBruteForce()`

**Module:** Default

Enumerate all possible XOR solutions. Current maximum key length is 2 due to browser performance.

Optionally enter a string that you expect to find in the plaintext to filter results (crib).

[More info](https://wikipedia.org/wiki/Exclusive_or)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Key length** (number): default `1`
  - **Sample length** (number): default `100`
  - **Sample offset** (number): default `0`
  - **Scheme** (option): `Standard`, `Input differential`, `Output differential`
  - **Null preserving** (boolean): default `False`
  - **Print key** (boolean): default `True`
  - **Output as hex** (boolean): default `False`
  - **Crib (known plaintext string)** (binaryString): default ``

---

### `XORChecksum()`

**Module:** Crypto

XOR Checksum splits the input into blocks of a configurable size and performs the XOR operation on these blocks.

[More info](https://wikipedia.org/wiki/XOR)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Blocksize** (number): default `4`

---

### `XPathExpression()`

**Module:** Code

Extract information from an XML document with an XPath query

[More info](https://wikipedia.org/wiki/XPath)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **XPath** (string): default ``
  - **Result delimiter** (binaryShortString): default `\n`

---

### `XSalsa20()`

**Module:** Ciphers

XSalsa20 is a variant of the Salsa20 stream cipher designed by Daniel J. Bernstein; XSalsa uses longer nonces.

Key: XSalsa20 uses a key of 16 or 32 bytes (128 or 256 bits).

Nonce: XSalsa20 uses a nonce of 24 bytes (192 bits).

Counter: XSalsa uses a counter of 8 bytes (64 bits). The counter starts at zero at the start of the keystream, and is incremented at every 64 bytes.

[More info](https://en.wikipedia.org/wiki/Salsa20#XSalsa20_with_192-bit_nonce)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Nonce** (toggleString): default ``
  - **Counter** (number): default `0`
  - **Rounds** (option): `20`, `12`, `8`
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `XXTEADecrypt()`

**Module:** Ciphers

Corrected Block TEA (often referred to as XXTEA) is a block cipher designed to correct weaknesses in the original Block TEA. XXTEA operates on variable-length blocks that are some arbitrary multiple of 32 bits in size (minimum 64 bits). The number of full cycles depends on the block size, but there are at least six (rising to 32 for small block sizes). The original Block TEA applies the XTEA round function to each word in the block and combines it additively with its leftmost neighbour. Slow diffusion rate of the decryption process was immediately exploited to break the cipher. Corrected Block TEA uses a more involved round function which makes use of both immediate neighbours in processing each word in the block.

[More info](https://wikipedia.org/wiki/XXTEA)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Key** (toggleString): default ``

---

### `XXTEAEncrypt()`

**Module:** Ciphers

Corrected Block TEA (often referred to as XXTEA) is a block cipher designed to correct weaknesses in the original Block TEA. XXTEA operates on variable-length blocks that are some arbitrary multiple of 32 bits in size (minimum 64 bits). The number of full cycles depends on the block size, but there are at least six (rising to 32 for small block sizes). The original Block TEA applies the XTEA round function to each word in the block and combines it additively with its leftmost neighbour. Slow diffusion rate of the decryption process was immediately exploited to break the cipher. Corrected Block TEA uses a more involved round function which makes use of both immediate neighbours in processing each word in the block.

[More info](https://wikipedia.org/wiki/XXTEA)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Key** (toggleString): default ``

---

### `YAMLToJSON()`

**Module:** Default

Convert YAML to JSON

[More info](https://en.wikipedia.org/wiki/YAML)

**Input:** `string` → **Output:** `JSON`

---

### `YARARules()`

**Module:** Yara

YARA is a tool developed at VirusTotal, primarily aimed at helping malware researchers to identify and classify malware samples. It matches based on rules specified by the user containing textual or binary patterns and a boolean expression. For help on writing rules, see the YARA documentation.

[More info](https://wikipedia.org/wiki/YARA)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Rules** (text): default ``
  - **Show strings** (boolean): default `False`
  - **Show string lengths** (boolean): default `False`
  - **Show metadata** (boolean): default `False`
  - **Show counts** (boolean): default `True`
  - **Show rule warnings** (boolean): default `True`
  - **Show console module messages** (boolean): default `True`

---

### `addLineNumbers()`

**Module:** Default

Adds line numbers to the output.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Offset** (number): default `0`

---

### `addTextToImage()`

**Module:** Image

Adds text onto an image.

Text can be horizontally or vertically aligned, or the position can be manually specified. Variants of the Roboto font face are available in any size or colour.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Text** (string): default ``
  - **Horizontal align** (option): `None`, `Left`, `Center` (+1 more)
  - **Vertical align** (option): `None`, `Top`, `Middle` (+1 more)
  - **X position** (number): default `0`
  - **Y position** (number): default `0`
  - **Size** (number): default `32`
  - **Font face** (option): `Roboto`, `Roboto Black`, `Roboto Mono` (+1 more)
  - **Red** (number): default `255`
  - **Green** (number): default `255`
  - **Blue** (number): default `255`
  - **Alpha** (number): default `255`

---

### `adler32Checksum()`

**Module:** Crypto

Adler-32 is a checksum algorithm which was invented by Mark Adler in 1995, and is a modification of the Fletcher checksum. Compared to a cyclic redundancy check of the same length, it trades reliability for speed (preferring the latter).

Adler-32 is more reliable than Fletcher-16, and slightly less reliable than Fletcher-32.

[More info](https://wikipedia.org/wiki/Adler-32)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `affineCipherDecode()`

**Module:** Ciphers

The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.

[More info](https://wikipedia.org/wiki/Affine_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **a** (number): default `1`
  - **b** (number): default `0`

---

### `affineCipherEncode()`

**Module:** Ciphers

The Affine cipher is a type of monoalphabetic substitution cipher, wherein each letter in an alphabet is mapped to its numeric equivalent, encrypted using simple mathematical function, `(ax + b) % 26`, and converted back to a letter.

[More info](https://wikipedia.org/wiki/Affine_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **a** (number): default `1`
  - **b** (number): default `0`

---

### `alternatingCaps()`

**Module:** Default

Alternating caps, also known as studly caps, sticky caps, or spongecase is a form of text notation in which the capitalization of letters varies by some pattern, or arbitrarily. An example of this would be spelling 'alternative caps' as 'aLtErNaTiNg CaPs'.

[More info](https://en.wikipedia.org/wiki/Alternating_caps)

**Input:** `string` → **Output:** `string`

---

### `analyseHash()`

**Module:** Crypto

Tries to determine information about a given hash and suggests which algorithm may have been used to generate it based on its length.

[More info](https://wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions)

**Input:** `string` → **Output:** `string`

---

### `analyseUUID()`

**Module:** Crypto

Tries to determine information about a given UUID and suggests which version may have been used to generate it

[More info](https://wikipedia.org/wiki/Universally_unique_identifier)

**Input:** `string` → **Output:** `string`

---

### `argon2()`

**Module:** Crypto

Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from the University of Luxembourg.

Enter the password in the input to generate its hash.

[More info](https://wikipedia.org/wiki/Argon2)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Salt** (toggleString): default `somesalt`
  - **Iterations** (number): default `3`
  - **Memory (KiB)** (number): default `4096`
  - **Parallelism** (number): default `1`
  - **Hash length (bytes)** (number): default `32`
  - **Type** (option): `Argon2i`, `Argon2d`, `Argon2id`
  - **Output format** (option): `Encoded hash`, `Hex hash`, `Raw hash`

---

### `argon2Compare()`

**Module:** Crypto

Tests whether the input matches the given Argon2 hash. To test multiple possible passwords, use the 'Fork' operation.

[More info](https://wikipedia.org/wiki/Argon2)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Encoded hash** (string): default ``

---

### `atbashCipher()`

**Module:** Ciphers

Atbash is a mono-alphabetic substitution cipher originally used to encode the Hebrew alphabet. It has been modified here for use with the Latin alphabet.

[More info](https://wikipedia.org/wiki/Atbash)

**Input:** `string` → **Output:** `string`

---

### `avroToJSON()`

**Module:** Serialise

Converts Avro encoded data into JSON.

[More info](https://wikipedia.org/wiki/Apache_Avro)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Force Valid JSON** (boolean): default `True`

---

### `baconCipherDecode()`

**Module:** Default

Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.

[More info](https://wikipedia.org/wiki/Bacon%27s_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Alphabet** (option): `Standard (I=J and U=V)`, `Complete`
  - **Translation** (option): `0/1`, `A/B`, `Case` (+1 more)
  - **Invert Translation** (boolean): default `False`

---

### `baconCipherEncode()`

**Module:** Default

Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.

[More info](https://wikipedia.org/wiki/Bacon%27s_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Alphabet** (option): `Standard (I=J and U=V)`, `Complete`
  - **Translation** (option): `0/1`, `A/B`
  - **Keep extra characters** (boolean): default `False`
  - **Invert Translation** (boolean): default `False`

---

### `bcrypt()`

**Module:** Crypto

bcrypt is a password hashing function designed by Niels Provos and David Mazières, based on the Blowfish cipher, and presented at USENIX in 1999. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count (rounds) can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.

Enter the password in the input to generate its hash.

[More info](https://wikipedia.org/wiki/Bcrypt)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Rounds** (number): default `10`

---

### `bcryptCompare()`

**Module:** Crypto

Tests whether the input matches the given bcrypt hash. To test multiple possible passwords, use the 'Fork' operation.

[More info](https://wikipedia.org/wiki/Bcrypt)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Hash** (string): default ``

---

### `bcryptParse()`

**Module:** Crypto

Parses a bcrypt hash to determine the number of rounds used, the salt, and the password hash.

[More info](https://wikipedia.org/wiki/Bcrypt)

**Input:** `string` → **Output:** `string`

---

### `bifidCipherDecode()`

**Module:** Ciphers

The Bifid cipher is a cipher which uses a Polybius square in conjunction with transposition, which can be fairly difficult to decipher without knowing the alphabet keyword.

[More info](https://wikipedia.org/wiki/Bifid_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Keyword** (string): default ``

---

### `bifidCipherEncode()`

**Module:** Ciphers

The Bifid cipher is a cipher which uses a Polybius square in conjunction with transposition, which can be fairly difficult to decipher without knowing the alphabet keyword.

[More info](https://wikipedia.org/wiki/Bifid_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Keyword** (string): default ``

---

### `bitShiftLeft()`

**Module:** Default

Shifts the bits in each byte towards the left by the specified amount.

[More info](https://wikipedia.org/wiki/Bitwise_operation#Bit_shifts)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Amount** (number): default `1`

---

### `bitShiftRight()`

**Module:** Default

Shifts the bits in each byte towards the right by the specified amount.

Logical shifts replace the leftmost bits with zeros. Arithmetic shifts preserve the most significant bit (MSB) of the original byte keeping the sign the same (positive or negative).

[More info](https://wikipedia.org/wiki/Bitwise_operation#Bit_shifts)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Amount** (number): default `1`
  - **Type** (option): `Logical shift`, `Arithmetic shift`

---

### `blowfishDecrypt()`

**Module:** Ciphers

Blowfish is a symmetric-key block cipher designed in 1993 by Bruce Schneier and included in a large number of cipher suites and encryption products. AES now receives more attention.

IV: The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.

[More info](https://wikipedia.org/wiki/Blowfish_(cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+2 more)
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `blowfishEncrypt()`

**Module:** Ciphers

Blowfish is a symmetric-key block cipher designed in 1993 by Bruce Schneier and included in a large number of cipher suites and encryption products. AES now receives more attention.

IV: The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.

[More info](https://wikipedia.org/wiki/Blowfish_(cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+2 more)
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`

---

### `blurImage()`

**Module:** Image

Applies a blur effect to the image.

Gaussian blur is much slower than fast blur, but produces better results.

[More info](https://wikipedia.org/wiki/Gaussian_blur)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Amount** (number): default `5`
  - **Type** (option): `Fast`, `Gaussian`

---

### `bombe()`

**Module:** Bletchley

Emulation of the Bombe machine used at Bletchley Park to attack Enigma, based on work by Polish and British cryptanalysts.

To run this you need to have a 'crib', which is some known plaintext for a chunk of the target ciphertext, and know the rotors used. (See the 'Bombe (multiple runs)' operation if you don't know the rotors.) The machine will suggest possible configurations of the Enigma. Each suggestion has the rotor start positions (left to right) and known plugboard pairs.

Choosing a crib: First, note that Enigma cannot encrypt a letter to itself, which allows you to rule out some positions for possible cribs. Secondly, the Bombe does not simulate the Enigma's middle rotor stepping. The longer your crib, the more likely a step happened within it, which will prevent the attack working. However, other than that, longer cribs are generally better. The attack produces a 'menu' which maps ciphertext letters to plaintext, and the goal is to produce 'loops': for example, with ciphertext ABC and crib CAB, we have the mappings A&lt;-&gt;C, B&lt;-&gt;A, and C&lt;-&gt;B, which produces a loop A-B-C-A. The more loops, the better the crib. The operation will output this: if your menu has too few loops or is too short, a large number of incorrect outputs will usually be produced. Try a different crib. If the menu seems good but the right answer isn't produced, your crib may be wrong, or you may have overlapped the middle rotor stepping - try a different crib.

Output is not sufficient to fully decrypt the data. You will have to recover the rest of the plugboard settings by inspection. And the ring position is not taken into account: this affects when the middle rotor steps. If your output is correct for a bit, and then goes wrong, adjust the ring and start position on the right-hand rotor together until the output improves. If necessary, repeat for the middle rotor.

By default this operation runs the checking machine, a manual process to verify the quality of Bombe stops, on each stop, discarding stops which fail. If you want to see how many times the hardware actually stops for a given input, disable the checking machine.

More detailed descriptions of the Enigma, Typex and Bombe operations can be found here.

[More info](https://wikipedia.org/wiki/Bombe)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Model** (argSelector): default `[{'name': '3-rotor', 'off': [1]}, {'name': '4-rotor', 'on': [1]}]`
  - **Left-most (4th) rotor** (editableOption): `Beta`, `Gamma`
  - **Left-hand rotor** (editableOption): `I`, `II`, `III` (+5 more)
  - **Middle rotor** (editableOption): `I`, `II`, `III` (+5 more)
  - **Right-hand rotor** (editableOption): `I`, `II`, `III` (+5 more)
  - **Reflector** (editableOption): `B`, `C`, `B Thin` (+1 more)
  - **Crib** (string): default ``
  - **Crib offset** (number): default `0`
  - **Use checking machine** (boolean): default `True`

---

### `bzip2Compress()`

**Module:** Compression

Bzip2 is a compression library developed by Julian Seward (of GHC fame) that uses the Burrows-Wheeler algorithm. It only supports compressing single files and its compression is slow, however is more effective than Deflate (.gz & .zip).

[More info](https://wikipedia.org/wiki/Bzip2)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Block size (100s of kb)** (number): default `9`
  - **Work factor** (number): default `30`

---

### `bzip2Decompress()`

**Module:** Compression

Decompresses data using the Bzip2 algorithm.

[More info](https://wikipedia.org/wiki/Bzip2)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Use low-memory, slower decompression algorithm** (boolean): default `False`

---

### `caesarBoxCipher()`

**Module:** Ciphers

Caesar Box is a transposition cipher used in the Roman Empire, in which letters of the message are written in rows in a square (or a rectangle) and then, read by column.

[More info](https://www.dcode.fr/caesar-box-cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Box Height** (number): default `1`

---

### `caretMdecode()`

**Module:** Default

Decodes caret or M-encoded strings, i.e. ^M turns into a newline, M-^] turns into 0x9d. Sources such as `cat -v`.

Please be aware that when using `cat -v` ^_ (caret-underscore) will not be encoded, but represents a valid encoding (namely that of 0x1f).

[More info](https://en.wikipedia.org/wiki/Caret_notation)

**Input:** `string` → **Output:** `byteArray`

---

### `cartesianProduct()`

**Module:** Default

Calculates the cartesian product of multiple sets of data, returning all possible combinations.

[More info](https://wikipedia.org/wiki/Cartesian_product)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`
  - **Item delimiter** (binaryString): default `,`

---

### `cetaceanCipherDecode()`

**Module:** Ciphers

Decode Cetacean Cipher input. e.g. `EEEEEEEEEeeEeEEEEEEEEEEEEeeEeEEe` becomes `hi`

[More info](https://hitchhikers.fandom.com/wiki/Dolphins)

**Input:** `string` → **Output:** `string`

---

### `cetaceanCipherEncode()`

**Module:** Ciphers

Converts any input into Cetacean Cipher. e.g. `hi` becomes `EEEEEEEEEeeEeEEEEEEEEEEEEeeEeEEe`

[More info](https://hitchhikers.fandom.com/wiki/Dolphins)

**Input:** `string` → **Output:** `string`

---

### `chaCha()`

**Module:** Ciphers

ChaCha is a stream cipher designed by Daniel J. Bernstein. It is a variant of the Salsa stream cipher. Several parameterizations exist; 'ChaCha' may refer to the original construction, or to the variant as described in RFC-8439. ChaCha is often used with Poly1305, in the ChaCha20-Poly1305 AEAD construction.

Key: ChaCha uses a key of 16 or 32 bytes (128 or 256 bits).

Nonce: ChaCha uses a nonce of 8 or 12 bytes (64 or 96 bits).

Counter: ChaCha uses a counter of 4 or 8 bytes (32 or 64 bits); together, the nonce and counter must add up to 16 bytes. The counter starts at zero at the start of the keystream, and is incremented at every 64 bytes.

[More info](https://wikipedia.org/wiki/Salsa20#ChaCha_variant)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Nonce** (toggleString): default ``
  - **Counter** (number): default `0`
  - **Rounds** (option): `20`, `12`, `8`
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `changeIPFormat()`

**Module:** Default

Convert an IP address from one format to another, e.g. `172.20.23.54` to `ac141736`

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `Dotted Decimal`, `Decimal`, `Octal` (+1 more)
  - **Output format** (option): `Dotted Decimal`, `Decimal`, `Octal` (+1 more)

---

### `chiSquare()`

**Module:** Default

Calculates the Chi Square distribution of values.

[More info](https://wikipedia.org/wiki/Chi-squared_distribution)

**Input:** `ArrayBuffer` → **Output:** `number`

---

### `cipherSaber2Decrypt()`

**Module:** Crypto

CipherSaber is a simple symmetric encryption protocol based on the RC4 stream cipher. It gives reasonably strong protection of message confidentiality, yet it's designed to be simple enough that even novice programmers can memorize the algorithm and implement it from scratch.

[More info](https://wikipedia.org/wiki/CipherSaber)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Rounds** (number): default `20`

---

### `cipherSaber2Encrypt()`

**Module:** Crypto

CipherSaber is a simple symmetric encryption protocol based on the RC4 stream cipher. It gives reasonably strong protection of message confidentiality, yet it's designed to be simple enough that even novice programmers can memorize the algorithm and implement it from scratch.

[More info](https://wikipedia.org/wiki/CipherSaber)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Rounds** (number): default `20`

---

### `citrixCTX1Decode()`

**Module:** Encodings

Decodes strings in a Citrix CTX1 password format to plaintext.

[More info](https://www.reddit.com/r/AskNetsec/comments/1s3r6y/citrix_ctx1_hash_decoding/)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `citrixCTX1Encode()`

**Module:** Encodings

Encodes strings to Citrix CTX1 password format.

[More info](https://www.reddit.com/r/AskNetsec/comments/1s3r6y/citrix_ctx1_hash_decoding/)

**Input:** `string` → **Output:** `byteArray`

---

### `colossus()`

**Module:** Bletchley

Colossus is the name of the world's first electronic computer. Ten Colossi were designed by Tommy Flowers and built at the Post Office Research Labs at Dollis Hill in 1943 during World War 2. They assisted with the breaking of the German Lorenz cipher attachment, a machine created to encipher communications between Hitler and his generals on the front lines.

To learn more, Virtual Colossus, an online, browser based simulation of a Colossus computer is available at virtualcolossus.co.uk.

A more detailed description of this operation can be found here.

[More info](https://wikipedia.org/wiki/Colossus_computer)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Input** (label): default ``
  - **Pattern** (option): `KH Pattern`, `ZMUG Pattern`, `BREAM Pattern`
  - **QBusZ** (option): ``, `Z`, `ΔZ`
  - **QBusΧ** (option): ``, `Χ`, `ΔΧ`
  - **QBusΨ** (option): ``, `Ψ`, `ΔΨ`
  - **Limitation** (option): `None`, `Χ2`, `Χ2 + P5` (+2 more)
  - **K Rack Option** (argSelector): default `[{'name': 'Select Program', 'on': [7], 'off': [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]}, {'name': 'Top Section - Conditional', 'on': [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30], 'off': [7, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]}, {'name': 'Bottom Section - Addition', 'on': [31, 32, 33, 34, 35, 36, 37, 38, 39, 40], 'off': [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {'name': 'Advanced', 'on': [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], 'off': [7]}]`
  - **Program to run** (option): ``, `Letter Count`, `1+2=. (1+2 Break In, Find X1,X2)` (+2 more)
  - **K Rack: Conditional** (label): default ``
  - **R1-Q1** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R1-Q2** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R1-Q3** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R1-Q4** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R1-Q5** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R1-Negate** (boolean): default `False`
  - **R1-Counter** (option): ``, `1`, `2` (+3 more)
  - **R2-Q1** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R2-Q2** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R2-Q3** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R2-Q4** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R2-Q5** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R2-Negate** (boolean): default `False`
  - **R2-Counter** (option): ``, `1`, `2` (+3 more)
  - **R3-Q1** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R3-Q2** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R3-Q3** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R3-Q4** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R3-Q5** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **R3-Negate** (boolean): default `False`
  - **R3-Counter** (option): ``, `1`, `2` (+3 more)
  - **Negate All** (boolean): default `False`
  - **K Rack: Addition** (label): default ``
  - **Add-Q1** (boolean): default `False`
  - **Add-Q2** (boolean): default `False`
  - **Add-Q3** (boolean): default `False`
  - **Add-Q4** (boolean): default `False`
  - **Add-Q5** (boolean): default `False`
  - **Add-Equals** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **Add-Counter1** (boolean): default `False`
  - **Add Negate All** (boolean): default `False`
  - **Total Motor** (editableOptionShort): default `[{'name': 'Up (.)', 'value': '.'}, {'name': 'Centre', 'value': ''}, {'name': 'Down (x)', 'value': 'x'}]`
  - **Master Control Panel** (label): default ``
  - **Set Total** (number): default `0`
  - **Fast Step** (option): ``, `X1`, `X2` (+10 more)
  - **Slow Step** (option): ``, `X1`, `X2` (+10 more)
  - **Start Χ1** (number): default `1`
  - **Start Χ2** (number): default `1`
  - **Start Χ3** (number): default `1`
  - **Start Χ4** (number): default `1`
  - **Start Χ5** (number): default `1`
  - **Start M61** (number): default `1`
  - **Start M37** (number): default `1`
  - **Start Ψ1** (number): default `1`
  - **Start Ψ2** (number): default `1`
  - **Start Ψ3** (number): default `1`
  - **Start Ψ4** (number): default `1`
  - **Start Ψ5** (number): default `1`

---

### `comment()`

**Module:** Default

Provides a place to write comments within the flow of the recipe. This operation has no computational effect.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **** (text): default ``

---

### `compareCTPHHashes()`

**Module:** Crypto

Compares two Context Triggered Piecewise Hashing (CTPH) fuzzy hashes to determine the similarity between them on a scale of 0 to 100.

[More info](https://forensics.wiki/context_triggered_piecewise_hashing/)

**Input:** `string` → **Output:** `number`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+1 more)

---

### `compareSSDEEPHashes()`

**Module:** Crypto

Compares two SSDEEP fuzzy hashes to determine the similarity between them on a scale of 0 to 100.

[More info](https://forensics.wiki/ssdeep/)

**Input:** `string` → **Output:** `number`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+1 more)

---

### `conditionalJump()`

**Module:** Default

Conditionally jump forwards or backwards to the specified Label  based on whether the data matches the specified regular expression.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Match (regex)** (string): default ``
  - **Invert match** (boolean): default `False`
  - **Label name** (shortString): default ``
  - **Maximum jumps (if jumping backwards)** (number): default `10`

---

### `containImage()`

**Module:** Image

Scales an image to the specified width and height, maintaining the aspect ratio. The image may be letterboxed.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Width** (number): default `100`
  - **Height** (number): default `100`
  - **Horizontal align** (option): `Left`, `Center`, `Right`
  - **Vertical align** (option): `Top`, `Middle`, `Bottom`
  - **Resizing algorithm** (option): `Nearest Neighbour`, `Bilinear`, `Bicubic` (+2 more)
  - **Opaque background** (boolean): default `True`

---

### `convertArea()`

**Module:** Default

Converts a unit of area to another format.

[More info](https://wikipedia.org/wiki/Orders_of_magnitude_(area))

**Input:** `BigNumber` → **Output:** `BigNumber`

**Arguments:**
  - **Input units** (option): `[Metric]`, `Square metre (sq m)`, `Square kilometre (sq km)` (+42 more)
  - **Output units** (option): `[Metric]`, `Square metre (sq m)`, `Square kilometre (sq km)` (+42 more)

---

### `convertCoordinateFormat()`

**Module:** Hashing

Converts geographical coordinates between different formats.

Supported formats:Degrees Minutes Seconds (DMS)Degrees Decimal Minutes (DDM)Decimal Degrees (DD)GeohashMilitary Grid Reference System (MGRS)Ordnance Survey National Grid (OSNG)Universal Transverse Mercator (UTM) The operation can try to detect the input co-ordinate format and delimiter automatically, but this may not always work correctly.

[More info](https://wikipedia.org/wiki/Geographic_coordinate_conversion)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input Format** (option): `Auto`, `Degrees Minutes Seconds`, `Degrees Decimal Minutes` (+5 more)
  - **Input Delimiter** (option): `Auto`, `Direction Preceding`, `Direction Following` (+4 more)
  - **Output Format** (option): `Degrees Minutes Seconds`, `Degrees Decimal Minutes`, `Decimal Degrees` (+4 more)
  - **Output Delimiter** (option): `Space`, `\n`, `Comma` (+2 more)
  - **Include Compass Directions** (option): `None`, `Before`, `After`
  - **Precision** (number): default `3`

---

### `convertDataUnits()`

**Module:** Default

Converts a unit of data to another format.

[More info](https://wikipedia.org/wiki/Orders_of_magnitude_(data))

**Input:** `BigNumber` → **Output:** `BigNumber`

**Arguments:**
  - **Input units** (option): `Bits (b)`, `Nibbles`, `Octets` (+43 more)
  - **Output units** (option): `Bits (b)`, `Nibbles`, `Octets` (+43 more)

---

### `convertDistance()`

**Module:** Default

Converts a unit of distance to another format.

[More info](https://wikipedia.org/wiki/Orders_of_magnitude_(length))

**Input:** `BigNumber` → **Output:** `BigNumber`

**Arguments:**
  - **Input units** (option): `[Metric]`, `Nanometres (nm)`, `Micrometres (µm)` (+33 more)
  - **Output units** (option): `[Metric]`, `Nanometres (nm)`, `Micrometres (µm)` (+33 more)

---

### `convertImageFormat()`

**Module:** Image

Converts an image between different formats. Supported formats: Joint Photographic Experts Group (JPEG)Portable Network Graphics (PNG)Bitmap (BMP)Tagged Image File Format (TIFF) Note: GIF files are supported for input, but cannot be outputted.

[More info](https://wikipedia.org/wiki/Image_file_formats)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Output Format** (option): `JPEG`, `PNG`, `BMP` (+1 more)
  - **JPEG Quality** (number): default `80`
  - **PNG Filter Type** (option): `Auto`, `None`, `Sub` (+3 more)
  - **PNG Deflate Level** (number): default `9`

---

### `convertLeetSpeak()`

**Module:** Default

Converts to and from Leet Speak.

[More info](https://wikipedia.org/wiki/Leet)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Direction** (option): `To Leet Speak`, `From Leet Speak`

---

### `convertMass()`

**Module:** Default

Converts a unit of mass to another format.

[More info](https://wikipedia.org/wiki/Orders_of_magnitude_(mass))

**Input:** `BigNumber` → **Output:** `BigNumber`

**Arguments:**
  - **Input units** (option): `[Metric]`, `Yoctogram (yg)`, `Zeptogram (zg)` (+75 more)
  - **Output units** (option): `[Metric]`, `Yoctogram (yg)`, `Zeptogram (zg)` (+75 more)

---

### `convertSpeed()`

**Module:** Default

Converts a unit of speed to another format.

[More info](https://wikipedia.org/wiki/Orders_of_magnitude_(speed))

**Input:** `BigNumber` → **Output:** `BigNumber`

**Arguments:**
  - **Input units** (option): `[Metric]`, `Metres per second (m/s)`, `Kilometres per hour (km/h)` (+30 more)
  - **Output units** (option): `[Metric]`, `Metres per second (m/s)`, `Kilometres per hour (km/h)` (+30 more)

---

### `convertToNATOAlphabet()`

**Module:** Default

Converts characters to their representation in the NATO phonetic alphabet.

[More info](https://wikipedia.org/wiki/NATO_phonetic_alphabet)

**Input:** `string` → **Output:** `string`

---

### `countOccurrences()`

**Module:** Default

Counts the number of times the provided string occurs in the input.

**Input:** `string` → **Output:** `number`

**Arguments:**
  - **Search string** (toggleString): default ``

---

### `coverImage()`

**Module:** Image

Scales the image to the given width and height, keeping the aspect ratio. The image may be clipped.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Width** (number): default `100`
  - **Height** (number): default `100`
  - **Horizontal align** (option): `Left`, `Center`, `Right`
  - **Vertical align** (option): `Top`, `Middle`, `Bottom`
  - **Resizing algorithm** (option): `Nearest Neighbour`, `Bilinear`, `Bicubic` (+2 more)

---

### `cropImage()`

**Module:** Image

Crops an image to the specified region, or automatically crops edges.

Autocrop Automatically crops same-colour borders from the image.

Autocrop tolerance A percentage value for the tolerance of colour difference between pixels.

Only autocrop frames Only crop real frames (all sides must have the same border)

Symmetric autocrop Force autocrop to be symmetric (top/bottom and left/right are cropped by the same amount)

Autocrop keep border The number of pixels of border to leave around the image.

[More info](https://wikipedia.org/wiki/Cropping_(image))

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **X Position** (number): default `0`
  - **Y Position** (number): default `0`
  - **Width** (number): default `10`
  - **Height** (number): default `10`
  - **Autocrop** (boolean): default `False`
  - **Autocrop tolerance (%)** (number): default `0.02`
  - **Only autocrop frames** (boolean): default `True`
  - **Symmetric autocrop** (boolean): default `False`
  - **Autocrop keep border (px)** (number): default `0`

---

### `dateTimeDelta()`

**Module:** Default

Calculates a new DateTime value given an input DateTime value and a time difference (delta) from the input DateTime value.

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Built in formats** (populateOption): default `[{'name': 'Standard date and time', 'value': 'DD/MM/YYYY HH:mm:ss'}, {'name': 'American-style date and time', 'value': 'MM/DD/YYYY HH:mm:ss'}, {'name': 'International date and time', 'value': 'YYYY-MM-DD HH:mm:ss'}, {'name': 'Verbose date and time', 'value': 'dddd Do MMMM YYYY HH:mm:ss Z z'}, {'name': 'UNIX timestamp (seconds)', 'value': 'X'}, {'name': 'UNIX timestamp offset (milliseconds)', 'value': 'x'}, {'name': 'Automatic', 'value': ''}]`
  - **Input format string** (binaryString): default `DD/MM/YYYY HH:mm:ss`
  - **Time Operation** (option): `Add`, `Subtract`
  - **Days** (number): default `0`
  - **Hours** (number): default `0`
  - **Minutes** (number): default `0`
  - **Seconds** (number): default `0`

---

### `dechunkHTTPResponse()`

**Module:** Default

Parses an HTTP response transferred using Transfer-Encoding: Chunked

[More info](https://wikipedia.org/wiki/Chunked_transfer_encoding)

**Input:** `string` → **Output:** `string`

---

### `decodeNetBIOSName()`

**Module:** Default

NetBIOS names as seen across the client interface to NetBIOS are exactly 16 bytes long. Within the NetBIOS-over-TCP protocols, a longer representation is used.

There are two levels of encoding. The first level maps a NetBIOS name into a domain system name.  The second level maps the domain system name into the 'compressed' representation required for interaction with the domain name system.

This operation decodes the first level of encoding. See RFC 1001 for full details.

[More info](https://wikipedia.org/wiki/NetBIOS)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Offset** (number): default `65`

---

### `decodeText()`

**Module:** Encodings

Decodes text from the chosen character encoding.



Supported charsets are:

UTF-8 (65001)
UTF-7 (65000)
UTF-16LE (1200)
UTF-16BE (1201)
UTF-32LE (12000)
UTF-32BE (12001)
IBM EBCDIC International (500)
IBM EBCDIC US-Canada (37)
IBM EBCDIC Multilingual/ROECE (Latin 2) (870)
IBM EBCDIC Greek Modern (875)
IBM EBCDIC French (1010)
IBM EBCDIC Turkish (Latin 5) (1026)
IBM EBCDIC Latin 1/Open System (1047)
IBM EBCDIC Lao (1132/1133/1341)
IBM EBCDIC US-Canada (037 + Euro symbol) (1140)
IBM EBCDIC Germany (20273 + Euro symbol) (1141)
IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)
IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)
IBM EBCDIC Italy (20280 + Euro symbol) (1144)
IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)
IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)
IBM EBCDIC France (20297 + Euro symbol) (1147)
IBM EBCDIC International (500 + Euro symbol) (1148)
IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)
IBM EBCDIC Germany (20273)
IBM EBCDIC Denmark-Norway (20277)
IBM EBCDIC Finland-Sweden (20278)
IBM EBCDIC Italy (20280)
IBM EBCDIC Latin America-Spain (20284)
IBM EBCDIC United Kingdom (20285)
IBM EBCDIC Japanese Katakana Extended (20290)
IBM EBCDIC France (20297)
IBM EBCDIC Arabic (20420)
IBM EBCDIC Greek (20423)
IBM EBCDIC Hebrew (20424)
IBM EBCDIC Korean Extended (20833)
IBM EBCDIC Thai (20838)
IBM EBCDIC Icelandic (20871)
IBM EBCDIC Cyrillic Russian (20880)
IBM EBCDIC Turkish (20905)
IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)
IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)
OEM United States (437)
OEM Greek (formerly 437G); Greek (DOS) (737)
OEM Baltic; Baltic (DOS) (775)
OEM Russian; Cyrillic + Euro symbol (808)
OEM Multilingual Latin 1; Western European (DOS) (850)
OEM Latin 2; Central European (DOS) (852)
OEM Cyrillic (primarily Russian) (855)
OEM Turkish; Turkish (DOS) (857)
OEM Multilingual Latin 1 + Euro symbol (858)
OEM Portuguese; Portuguese (DOS) (860)
OEM Icelandic; Icelandic (DOS) (861)
OEM Hebrew; Hebrew (DOS) (862)
OEM French Canadian; French Canadian (DOS) (863)
OEM Arabic; Arabic (864) (864)
OEM Nordic; Nordic (DOS) (865)
OEM Russian; Cyrillic (DOS) (866)
OEM Modern Greek; Greek, Modern (DOS) (869)
OEM Cyrillic (primarily Russian) + Euro Symbol (872)
Windows-874 Thai (874)
Windows-1250 Central European (1250)
Windows-1251 Cyrillic (1251)
Windows-1252 Latin (1252)
Windows-1253 Greek (1253)
Windows-1254 Turkish (1254)
Windows-1255 Hebrew (1255)
Windows-1256 Arabic (1256)
Windows-1257 Baltic (1257)
Windows-1258 Vietnam (1258)
ISO-8859-1 Latin 1 Western European (28591)
ISO-8859-2 Latin 2 Central European (28592)
ISO-8859-3 Latin 3 South European (28593)
ISO-8859-4 Latin 4 North European (28594)
ISO-8859-5 Latin/Cyrillic (28595)
ISO-8859-6 Latin/Arabic (28596)
ISO-8859-7 Latin/Greek (28597)
ISO-8859-8 Latin/Hebrew (28598)
ISO 8859-8 Hebrew (ISO-Logical) (38598)
ISO-8859-9 Latin 5 Turkish (28599)
ISO-8859-10 Latin 6 Nordic (28600)
ISO-8859-11 Latin/Thai (28601)
ISO-8859-13 Latin 7 Baltic Rim (28603)
ISO-8859-14 Latin 8 Celtic (28604)
ISO-8859-15 Latin 9 (28605)
ISO-8859-16 Latin 10 (28606)
ISO 2022 JIS Japanese with no halfwidth Katakana (50220)
ISO 2022 JIS Japanese with halfwidth Katakana (50221)
ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)
ISO 2022 Korean (50225)
ISO 2022 Simplified Chinese (50227)
ISO 6937 Non-Spacing Accent (20269)
EUC Japanese (51932)
EUC Simplified Chinese (51936)
EUC Korean (51949)
ISCII Devanagari (57002)
ISCII Bengali (57003)
ISCII Tamil (57004)
ISCII Telugu (57005)
ISCII Assamese (57006)
ISCII Oriya (57007)
ISCII Kannada (57008)
ISCII Malayalam (57009)
ISCII Gujarati (57010)
ISCII Punjabi (57011)
Japanese Shift-JIS (932)
Simplified Chinese GBK (936)
Korean (949)
Traditional Chinese Big5 (950)
US-ASCII (7-bit) (20127)
Simplified Chinese GB2312 (20936)
KOI8-R Russian Cyrillic (20866)
KOI8-U Ukrainian Cyrillic (21866)
Mazovia (Polish) MS-DOS (620)
Arabic (ASMO 708) (708)
Arabic (Transparent ASMO); Arabic (DOS) (720)
Kamenický (Czech) MS-DOS (895)
Korean (Johab) (1361)
MAC Roman (10000)
Japanese (Mac) (10001)
MAC Traditional Chinese (Big5) (10002)
Korean (Mac) (10003)
Arabic (Mac) (10004)
Hebrew (Mac) (10005)
Greek (Mac) (10006)
Cyrillic (Mac) (10007)
MAC Simplified Chinese (GB 2312) (10008)
Romanian (Mac) (10010)
Ukrainian (Mac) (10017)
Thai (Mac) (10021)
MAC Latin 2 (Central European) (10029)
Icelandic (Mac) (10079)
Turkish (Mac) (10081)
Croatian (Mac) (10082)
CNS Taiwan (Chinese Traditional) (20000)
TCA Taiwan (20001)
ETEN Taiwan (Chinese Traditional) (20002)
IBM5550 Taiwan (20003)
TeleText Taiwan (20004)
Wang Taiwan (20005)
Western European IA5 (IRV International Alphabet 5) (20105)
IA5 German (7-bit) (20106)
IA5 Swedish (7-bit) (20107)
IA5 Norwegian (7-bit) (20108)
T.61 (20261)
Japanese (JIS 0208-1990 and 0212-1990) (20932)
Korean Wansung (20949)
Extended/Ext Alpha Lowercase (21027)
Europa 3 (29001)
Atari ST/TT (47451)
HZ-GB2312 Simplified Chinese (52936)
Simplified Chinese GB18030 (54936)

[More info](https://wikipedia.org/wiki/Character_encoding)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Encoding** (option): `UTF-8 (65001)`, `UTF-7 (65000)`, `UTF-16LE (1200)` (+149 more)

---

### `defangIPAddresses()`

**Module:** Default

Takes a IPv4 or IPv6 address and 'Defangs' it, meaning the IP becomes invalid, removing the risk of accidentally utilising it as an IP address.

[More info](https://isc.sans.edu/forums/diary/Defang+all+the+things/22744/)

**Input:** `string` → **Output:** `string`

---

### `defangURL()`

**Module:** Default

Takes a Universal Resource Locator (URL) and 'Defangs' it; meaning the URL becomes invalid, neutralising the risk of accidentally clicking on a malicious link.

This is often used when dealing with malicious links or IOCs.

Works well when combined with the 'Extract URLs' operation.

[More info](https://isc.sans.edu/forums/diary/Defang+all+the+things/22744/)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Escape dots** (boolean): default `True`
  - **Escape http** (boolean): default `True`
  - **Escape ://** (boolean): default `True`
  - **Process** (option): `Valid domains and full URLs`, `Only full URLs`, `Everything`

---

### `deriveEVPKey()`

**Module:** Ciphers

This operation performs a password-based key derivation function (PBKDF) used extensively in OpenSSL. In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.

A salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.

If you leave the salt argument empty, a random salt will be generated.

[More info](https://wikipedia.org/wiki/Key_derivation_function)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Passphrase** (toggleString): default ``
  - **Key size** (number): default `128`
  - **Iterations** (number): default `1`
  - **Hashing function** (option): `SHA1`, `SHA256`, `SHA384` (+2 more)
  - **Salt** (toggleString): default ``

---

### `deriveHKDFKey()`

**Module:** Crypto

A simple Hashed Message Authenticaton Code (HMAC)-based key derivation function (HKDF), defined in RFC5869.

[More info](https://wikipedia.org/wiki/HKDF)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Salt** (toggleString): default ``
  - **Info** (toggleString): default ``
  - **Hashing function** (option): `MD2`, `MD4`, `MD5` (+17 more)
  - **Extract mode** (argSelector): default `[{'name': 'with salt', 'on': [0]}, {'name': 'no salt', 'off': [0]}, {'name': 'skip', 'off': [0]}]`
  - **L (number of output octets)** (number): default `16`

---

### `derivePBKDF2Key()`

**Module:** Ciphers

PBKDF2 is a password-based key derivation function. It is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, specifically PKCS #5 v2.0, also published as Internet Engineering Task Force's RFC 2898.

In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.

A salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.

If you leave the salt argument empty, a random salt will be generated.

[More info](https://wikipedia.org/wiki/PBKDF2)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Passphrase** (toggleString): default ``
  - **Key size** (number): default `128`
  - **Iterations** (number): default `1`
  - **Hashing function** (option): `SHA1`, `SHA256`, `SHA384` (+2 more)
  - **Salt** (toggleString): default ``

---

### `detectFileType()`

**Module:** Default

Attempts to guess the MIME (Multipurpose Internet Mail Extensions) type of the data based on 'magic bytes'.

Currently supports the following file types: 123d, 7z, B64, abcdp, accda, accdb, accde, accdu, ace, ai, aif, aifc, alz, amr, arj, arw, au, auf, avi, axf, bash, bct, bin, bitlocker, bk!, bmp, bplist, bz2, cab, cat, cer, chi, chm, chw, class, com, cr2, crl, crt, crw, crx, db, dbx, deb, der, dex, dll, dmf, dmg, dmp, doc, docx, dot, drv, dwg, dwt, dylib, edb, elf, eot, eps, epub, evt, evtx, exe, f4v, fdb, flac, flv, fon, gif, gpg, gz, hbin, hdr, heic, heif, hqx, ichat, ico, ipmeta, iso, jar, job, jpe, jpeg, jpg, jxr, keychain, kgb, lnk, luac, lzo, lzop, m4a, m4v, mda, mdb, mdbackup, mde, mdi, mdinfo, mdt, midi, mkv, mov, mp3, mp4, mpg, mpo, mrw, msg, msi, nib, o, ocx, ogg, ogm, ogv, ogx, ole2, one, opus, ost, otf, p7b, p7c, p7m, p7s, pab, pdf, pf, pfa, pgd, phar, php, php-s, php3, php4, php5, php7, phps, pht, phtml, pkr, pl, plist, pm, png, pod, pot, ppa, pps, ppt, pptx, prx, ps, psa, psb, psd, psp, pst, pwl, py, pyc, pyd, pyo, pyw, pyz, qtz, raf, rar, rb, registry, rgs, rsa, rtf, scr, sdw, sh, skr, sml, so, sqlite, strings, swf, swz, sys, t, tar, tar.z, tcp, tga, thm, tif, torrent, ttf, txt, udp, utf16le, utf32le, vbx, vhd, vmdk, vsd, vxd, wallet, wasm, wav, wcm, webbookmark, webhistory, webm, webp, wmv, woff, woff2, wp, wp5, wp6, wpd, wpp, xcf, xla, xls, xlsx, xz, zip, zlib.

[More info](https://wikipedia.org/wiki/List_of_file_signatures)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Images** (boolean): default `True`
  - **Video** (boolean): default `True`
  - **Audio** (boolean): default `True`
  - **Documents** (boolean): default `True`
  - **Applications** (boolean): default `True`
  - **Archives** (boolean): default `True`
  - **Miscellaneous** (boolean): default `True`

---

### `diff()`

**Module:** Diff

Compares two inputs (separated by the specified delimiter) and highlights the differences between them.

[More info](https://wikipedia.org/wiki/File_comparison)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`
  - **Diff by** (option): `Character`, `Word`, `Line` (+3 more)
  - **Show added** (boolean): default `True`
  - **Show removed** (boolean): default `True`
  - **Show subtraction** (boolean): default `False`
  - **Ignore whitespace** (boolean): default `False`

---

### `disassembleX86()`

**Module:** Shellcode

Disassembly is the process of translating machine language into assembly language.

This operation supports 64-bit, 32-bit and 16-bit code written for Intel or AMD x86 processors. It is particularly useful for reverse engineering shellcode.

Input should be in hexadecimal.

[More info](https://wikipedia.org/wiki/X86)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Bit mode** (option): `64`, `32`, `16`
  - **Compatibility** (option): `Full x86 architecture`, `Knights Corner`, `Larrabee` (+4 more)
  - **Code Segment (CS)** (number): default `16`
  - **Offset (IP)** (number): default `0`
  - **Show instruction hex** (boolean): default `True`
  - **Show instruction position** (boolean): default `True`

---

### `ditherImage()`

**Module:** Image

Apply a dither effect to an image.

[More info](https://wikipedia.org/wiki/Dither)

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `divide()`

**Module:** Default

Divides a list of numbers. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 .5` becomes `2.5`

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `dropBytes()`

**Module:** Default

Cuts a slice of the specified number of bytes out of the data. Negative values are allowed.

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Start** (number): default `0`
  - **Length** (number): default `5`
  - **Apply to each line** (boolean): default `False`

---

### `dropNthBytes()`

**Module:** Default

Drops every nth byte starting with a given byte.

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Drop every** (number): default `4`
  - **Starting at** (number): default `0`
  - **Apply to each line** (boolean): default `False`

---

### `encodeNetBIOSName()`

**Module:** Default

NetBIOS names as seen across the client interface to NetBIOS are exactly 16 bytes long. Within the NetBIOS-over-TCP protocols, a longer representation is used.

There are two levels of encoding. The first level maps a NetBIOS name into a domain system name.  The second level maps the domain system name into the 'compressed' representation required for interaction with the domain name system.

This operation carries out the first level of encoding. See RFC 1001 for full details.

[More info](https://wikipedia.org/wiki/NetBIOS)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Offset** (number): default `65`

---

### `encodeText()`

**Module:** Encodings

Encodes text into the chosen character encoding.



Supported charsets are:

UTF-8 (65001)
UTF-7 (65000)
UTF-16LE (1200)
UTF-16BE (1201)
UTF-32LE (12000)
UTF-32BE (12001)
IBM EBCDIC International (500)
IBM EBCDIC US-Canada (37)
IBM EBCDIC Multilingual/ROECE (Latin 2) (870)
IBM EBCDIC Greek Modern (875)
IBM EBCDIC French (1010)
IBM EBCDIC Turkish (Latin 5) (1026)
IBM EBCDIC Latin 1/Open System (1047)
IBM EBCDIC Lao (1132/1133/1341)
IBM EBCDIC US-Canada (037 + Euro symbol) (1140)
IBM EBCDIC Germany (20273 + Euro symbol) (1141)
IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)
IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)
IBM EBCDIC Italy (20280 + Euro symbol) (1144)
IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)
IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)
IBM EBCDIC France (20297 + Euro symbol) (1147)
IBM EBCDIC International (500 + Euro symbol) (1148)
IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)
IBM EBCDIC Germany (20273)
IBM EBCDIC Denmark-Norway (20277)
IBM EBCDIC Finland-Sweden (20278)
IBM EBCDIC Italy (20280)
IBM EBCDIC Latin America-Spain (20284)
IBM EBCDIC United Kingdom (20285)
IBM EBCDIC Japanese Katakana Extended (20290)
IBM EBCDIC France (20297)
IBM EBCDIC Arabic (20420)
IBM EBCDIC Greek (20423)
IBM EBCDIC Hebrew (20424)
IBM EBCDIC Korean Extended (20833)
IBM EBCDIC Thai (20838)
IBM EBCDIC Icelandic (20871)
IBM EBCDIC Cyrillic Russian (20880)
IBM EBCDIC Turkish (20905)
IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)
IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)
OEM United States (437)
OEM Greek (formerly 437G); Greek (DOS) (737)
OEM Baltic; Baltic (DOS) (775)
OEM Russian; Cyrillic + Euro symbol (808)
OEM Multilingual Latin 1; Western European (DOS) (850)
OEM Latin 2; Central European (DOS) (852)
OEM Cyrillic (primarily Russian) (855)
OEM Turkish; Turkish (DOS) (857)
OEM Multilingual Latin 1 + Euro symbol (858)
OEM Portuguese; Portuguese (DOS) (860)
OEM Icelandic; Icelandic (DOS) (861)
OEM Hebrew; Hebrew (DOS) (862)
OEM French Canadian; French Canadian (DOS) (863)
OEM Arabic; Arabic (864) (864)
OEM Nordic; Nordic (DOS) (865)
OEM Russian; Cyrillic (DOS) (866)
OEM Modern Greek; Greek, Modern (DOS) (869)
OEM Cyrillic (primarily Russian) + Euro Symbol (872)
Windows-874 Thai (874)
Windows-1250 Central European (1250)
Windows-1251 Cyrillic (1251)
Windows-1252 Latin (1252)
Windows-1253 Greek (1253)
Windows-1254 Turkish (1254)
Windows-1255 Hebrew (1255)
Windows-1256 Arabic (1256)
Windows-1257 Baltic (1257)
Windows-1258 Vietnam (1258)
ISO-8859-1 Latin 1 Western European (28591)
ISO-8859-2 Latin 2 Central European (28592)
ISO-8859-3 Latin 3 South European (28593)
ISO-8859-4 Latin 4 North European (28594)
ISO-8859-5 Latin/Cyrillic (28595)
ISO-8859-6 Latin/Arabic (28596)
ISO-8859-7 Latin/Greek (28597)
ISO-8859-8 Latin/Hebrew (28598)
ISO 8859-8 Hebrew (ISO-Logical) (38598)
ISO-8859-9 Latin 5 Turkish (28599)
ISO-8859-10 Latin 6 Nordic (28600)
ISO-8859-11 Latin/Thai (28601)
ISO-8859-13 Latin 7 Baltic Rim (28603)
ISO-8859-14 Latin 8 Celtic (28604)
ISO-8859-15 Latin 9 (28605)
ISO-8859-16 Latin 10 (28606)
ISO 2022 JIS Japanese with no halfwidth Katakana (50220)
ISO 2022 JIS Japanese with halfwidth Katakana (50221)
ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)
ISO 2022 Korean (50225)
ISO 2022 Simplified Chinese (50227)
ISO 6937 Non-Spacing Accent (20269)
EUC Japanese (51932)
EUC Simplified Chinese (51936)
EUC Korean (51949)
ISCII Devanagari (57002)
ISCII Bengali (57003)
ISCII Tamil (57004)
ISCII Telugu (57005)
ISCII Assamese (57006)
ISCII Oriya (57007)
ISCII Kannada (57008)
ISCII Malayalam (57009)
ISCII Gujarati (57010)
ISCII Punjabi (57011)
Japanese Shift-JIS (932)
Simplified Chinese GBK (936)
Korean (949)
Traditional Chinese Big5 (950)
US-ASCII (7-bit) (20127)
Simplified Chinese GB2312 (20936)
KOI8-R Russian Cyrillic (20866)
KOI8-U Ukrainian Cyrillic (21866)
Mazovia (Polish) MS-DOS (620)
Arabic (ASMO 708) (708)
Arabic (Transparent ASMO); Arabic (DOS) (720)
Kamenický (Czech) MS-DOS (895)
Korean (Johab) (1361)
MAC Roman (10000)
Japanese (Mac) (10001)
MAC Traditional Chinese (Big5) (10002)
Korean (Mac) (10003)
Arabic (Mac) (10004)
Hebrew (Mac) (10005)
Greek (Mac) (10006)
Cyrillic (Mac) (10007)
MAC Simplified Chinese (GB 2312) (10008)
Romanian (Mac) (10010)
Ukrainian (Mac) (10017)
Thai (Mac) (10021)
MAC Latin 2 (Central European) (10029)
Icelandic (Mac) (10079)
Turkish (Mac) (10081)
Croatian (Mac) (10082)
CNS Taiwan (Chinese Traditional) (20000)
TCA Taiwan (20001)
ETEN Taiwan (Chinese Traditional) (20002)
IBM5550 Taiwan (20003)
TeleText Taiwan (20004)
Wang Taiwan (20005)
Western European IA5 (IRV International Alphabet 5) (20105)
IA5 German (7-bit) (20106)
IA5 Swedish (7-bit) (20107)
IA5 Norwegian (7-bit) (20108)
T.61 (20261)
Japanese (JIS 0208-1990 and 0212-1990) (20932)
Korean Wansung (20949)
Extended/Ext Alpha Lowercase (21027)
Europa 3 (29001)
Atari ST/TT (47451)
HZ-GB2312 Simplified Chinese (52936)
Simplified Chinese GB18030 (54936)

[More info](https://wikipedia.org/wiki/Character_encoding)

**Input:** `string` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Encoding** (option): `UTF-8 (65001)`, `UTF-7 (65000)`, `UTF-16LE (1200)` (+149 more)

---

### `enigma()`

**Module:** Bletchley

Encipher/decipher with the WW2 Enigma machine.

Enigma was used by the German military, among others, around the WW2 era as a portable cipher machine to protect sensitive military, diplomatic and commercial communications.

The standard set of German military rotors and reflectors are provided. To configure the plugboard, enter a string of connected pairs of letters, e.g. `AB CD EF` connects A to B, C to D, and E to F. This is also used to create your own reflectors. To create your own rotor, enter the letters that the rotor maps A to Z to, in order, optionally followed by `&lt;` then a list of stepping points. This is deliberately fairly permissive with rotor placements etc compared to a real Enigma (on which, for example, a four-rotor Enigma uses only the thin reflectors and the beta or gamma rotor in the 4th slot).

More detailed descriptions of the Enigma, Typex and Bombe operations can be found here.

[More info](https://wikipedia.org/wiki/Enigma_machine)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Model** (argSelector): default `[{'name': '3-rotor', 'off': [1, 2, 3]}, {'name': '4-rotor', 'on': [1, 2, 3]}]`
  - **Left-most (4th) rotor** (editableOption): `Beta`, `Gamma`
  - **Left-most rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **Left-most rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **Left-hand rotor** (editableOption): `I`, `II`, `III` (+5 more)
  - **Left-hand rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **Left-hand rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **Middle rotor** (editableOption): `I`, `II`, `III` (+5 more)
  - **Middle rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **Middle rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **Right-hand rotor** (editableOption): `I`, `II`, `III` (+5 more)
  - **Right-hand rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **Right-hand rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **Reflector** (editableOption): `B`, `C`, `B Thin` (+1 more)
  - **Plugboard** (string): default ``
  - **Strict output** (boolean): default `True`

---

### `entropy()`

**Module:** Charts

Shannon Entropy, in the context of information theory, is a measure of the rate at which information is produced by a source of data. It can be used, in a broad sense, to detect whether data is likely to be structured or unstructured. 8 is the maximum, representing highly unstructured, 'random' data. English language text usually falls somewhere between 3.5 and 5. Properly encrypted or compressed data should have an entropy of over 7.5.

[More info](https://wikipedia.org/wiki/Entropy_(information_theory))

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Visualisation** (option): `Shannon scale`, `Histogram (Bar)`, `Histogram (Line)` (+2 more)

---

### `escapeString()`

**Module:** Default

Escapes special characters in a string so that they do not cause conflicts. For example, `Don't stop me now` becomes `Don\'t stop me now`.

Supports the following escape sequences:`\n` (Line feed/newline)`\r` (Carriage return)`\t` (Horizontal tab)`\b` (Backspace)`\f` (Form feed)`\xnn` (Hex, where n is 0-f)`\\` (Backslash)`\'` (Single quote)`\&quot;` (Double quote)`\unnnn` (Unicode character)`\u{nnnnnn}` (Unicode code point)

[More info](https://wikipedia.org/wiki/Escape_sequence)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Escape level** (option): `Special chars`, `Everything`, `Minimal`
  - **Escape quote** (option): `Single`, `Double`, `Backtick`
  - **JSON compatible** (boolean): default `False`
  - **ES6 compatible** (boolean): default `True`
  - **Uppercase hex** (boolean): default `False`

---

### `escapeUnicodeCharacters()`

**Module:** Default

Converts characters to their unicode-escaped notations.

Supports the prefixes:`\u``%u``U+`e.g. `σου` becomes `\u03C3\u03BF\u03C5`

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Prefix** (option): `\u`, `%u`, `U+`
  - **Encode all chars** (boolean): default `False`
  - **Padding** (number): default `4`
  - **Uppercase hex** (boolean): default `True`

---

### `expandAlphabetRange()`

**Module:** Default

Expand an alphabet range string into a list of the characters in that range.

e.g. `a-z` becomes `abcdefghijklmnopqrstuvwxyz`.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (binaryString): default ``

---

### `extractDates()`

**Module:** Regex

Extracts dates in the following formats`yyyy-mm-dd``dd/mm/yyyy``mm/dd/yyyy`Dividers can be any of /, -, . or space

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Display total** (boolean): default `False`

---

### `extractDomains()`

**Module:** Regex

Extracts fully qualified domain names. Note that this will not include paths. Use Extract URLs to find entire URLs.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`
  - **Underscore (DMARC, DKIM, etc)** (boolean): default `False`

---

### `extractEXIF()`

**Module:** Image

Extracts EXIF data from an image.



EXIF data is metadata embedded in images (JPEG, JPG, TIFF) and audio files.



EXIF data from photos usually contains information about the image file itself as well as the device used to create it.

[More info](https://wikipedia.org/wiki/Exif)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `extractEmailAddresses()`

**Module:** Regex

Extracts all email addresses from the input.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`

---

### `extractFilePaths()`

**Module:** Regex

Extracts anything that looks like a Windows or UNIX file path.

Note that if UNIX is selected, there will likely be a lot of false positives.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Windows** (boolean): default `True`
  - **UNIX** (boolean): default `True`
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`

---

### `extractFiles()`

**Module:** Default

Performs file carving to attempt to extract files from the input.

This operation is currently capable of carving out the following formats:
            
                
                JPG,JPEG,JPE,THM,MPOGIFPNGWEBPBMPICOTGAFLVWAVMP3PDFRTFDOCX,XLSX,PPTXEPUBEXE,DLL,DRV,VXD,SYS,OCX,VBX,COM,FON,SCRELF,BIN,AXF,O,PRX,SODYLIBZIPTARGZBZ2ZLIBXZJARLZOP,LZODEBSQLITEEVTEVTXDMPPFPLISTKEYCHAINLNK
                
            Minimum File Size can be used to prune small false positives.

[More info](https://forensics.wiki/file_carving)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Images** (boolean): default `True`
  - **Video** (boolean): default `True`
  - **Audio** (boolean): default `True`
  - **Documents** (boolean): default `True`
  - **Applications** (boolean): default `True`
  - **Archives** (boolean): default `True`
  - **Miscellaneous** (boolean): default `False`
  - **Ignore failed extractions** (boolean): default `True`
  - **Minimum File Size** (number): default `100`

---

### `extractHashes()`

**Module:** Regex

Extracts potential hashes based on hash character length

[More info](https://wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Hash character length** (number): default `40`
  - **All hashes** (boolean): default `False`
  - **Display Total** (boolean): default `False`

---

### `extractID3()`

**Module:** Default

This operation extracts ID3 metadata from an MP3 file.

ID3 is a metadata container most often used in conjunction with the MP3 audio file format. It allows information such as the title, artist, album, track number, and other information about the file to be stored in the file itself.

[More info](https://wikipedia.org/wiki/ID3)

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `extractIPAddresses()`

**Module:** Regex

Extracts all IPv4 and IPv6 addresses.

Warning: Given a string `1.2.3.4.5.6.7.8`, this will match `1.2.3.4 and 5.6.7.8` so always check the original input!

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **IPv4** (boolean): default `True`
  - **IPv6** (boolean): default `False`
  - **Remove local IPv4 addresses** (boolean): default `False`
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`

---

### `extractLSB()`

**Module:** Image

Extracts the Least Significant Bit data from each pixel in an image. This is a common way to hide data in Steganography.

[More info](https://wikipedia.org/wiki/Bit_numbering#Least_significant_bit_in_digital_steganography)

**Input:** `ArrayBuffer` → **Output:** `byteArray`

**Arguments:**
  - **Colour Pattern #1** (option): `R`, `G`, `B` (+1 more)
  - **Colour Pattern #2** (option): ``, `R`, `G` (+2 more)
  - **Colour Pattern #3** (option): ``, `R`, `G` (+2 more)
  - **Colour Pattern #4** (option): ``, `R`, `G` (+2 more)
  - **Pixel Order** (option): `Row`, `Column`
  - **Bit** (number): default `0`

---

### `extractMACAddresses()`

**Module:** Regex

Extracts all Media Access Control (MAC) addresses from the input.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`

---

### `extractRGBA()`

**Module:** Image

Extracts each pixel's RGBA value in an image. These are sometimes used in Steganography to hide text or data.

[More info](https://wikipedia.org/wiki/RGBA_color_space)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Delimiter** (editableOption): `Comma`, `Space`, `CRLF` (+1 more)
  - **Include Alpha** (boolean): default `True`

---

### `extractURLs()`

**Module:** Regex

Extracts Uniform Resource Locators (URLs) from the input. The protocol (http, ftp etc.) is required otherwise there will be far too many false positives.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`

---

### `fangURL()`

**Module:** Default

Takes a 'Defanged' Universal Resource Locator (URL) and 'Fangs' it. Meaning, it removes the alterations (defanged) that render it useless so that it can be used again.

[More info](https://isc.sans.edu/forums/diary/Defang+all+the+things/22744/)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Restore [.]** (boolean): default `True`
  - **Restore hxxp** (boolean): default `True`
  - **Restore ://** (boolean): default `True`

---

### `fernetDecrypt()`

**Module:** Default

Fernet is a symmetric encryption method which makes sure that the message encrypted cannot be manipulated/read without the key. It uses URL safe encoding for the keys. Fernet uses 128-bit AES in CBC mode and PKCS7 padding, with HMAC using SHA256 for authentication. The IV is created from os.random().

Key: The key must be 32 bytes (256 bits) encoded with Base64.

[More info](https://asecuritysite.com/encryption/fer)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (string): default ``

---

### `fernetEncrypt()`

**Module:** Default

Fernet is a symmetric encryption method which makes sure that the message encrypted cannot be manipulated/read without the key. It uses URL safe encoding for the keys. Fernet uses 128-bit AES in CBC mode and PKCS7 padding, with HMAC using SHA256 for authentication. The IV is created from os.random().

Key: The key must be 32 bytes (256 bits) encoded with Base64.

[More info](https://asecuritysite.com/encryption/fer)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (string): default ``

---

### `fileTree()`

**Module:** Default

Creates a file tree from a list of file paths (similar to the tree command in Linux)

[More info](https://wikipedia.org/wiki/Tree_(command))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **File Path Delimiter** (binaryString): default `/`
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)

---

### `filter()`

**Module:** Regex

Splits up the input using the specified delimiter and then filters each branch based on a regular expression.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)
  - **Regex** (string): default ``
  - **Invert condition** (boolean): default `False`

---

### `findReplace()`

**Module:** Regex

Replaces all occurrences of the first string with the second.

Includes support for regular expressions (regex), simple strings and extended strings (which support \n, \r, \t, \b, \f and escaped hex bytes using \x notation, e.g. \x00 for a null byte).

[More info](https://wikipedia.org/wiki/Regular_expression)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Find** (toggleString): default ``
  - **Replace** (binaryString): default ``
  - **Global match** (boolean): default `True`
  - **Case insensitive** (boolean): default `False`
  - **Multiline matching** (boolean): default `True`
  - **Dot matches all** (boolean): default `False`

---

### `fletcher16Checksum()`

**Module:** Crypto

The Fletcher checksum is an algorithm for computing a position-dependent checksum devised by John Gould Fletcher at Lawrence Livermore Labs in the late 1970s.

The objective of the Fletcher checksum was to provide error-detection properties approaching those of a cyclic redundancy check but with the lower computational effort associated with summation techniques.

[More info](https://wikipedia.org/wiki/Fletcher%27s_checksum#Fletcher-16)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `fletcher32Checksum()`

**Module:** Crypto

The Fletcher checksum is an algorithm for computing a position-dependent checksum devised by John Gould Fletcher at Lawrence Livermore Labs in the late 1970s.

The objective of the Fletcher checksum was to provide error-detection properties approaching those of a cyclic redundancy check but with the lower computational effort associated with summation techniques.

[More info](https://wikipedia.org/wiki/Fletcher%27s_checksum#Fletcher-32)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `fletcher64Checksum()`

**Module:** Crypto

The Fletcher checksum is an algorithm for computing a position-dependent checksum devised by John Gould Fletcher at Lawrence Livermore Labs in the late 1970s.

The objective of the Fletcher checksum was to provide error-detection properties approaching those of a cyclic redundancy check but with the lower computational effort associated with summation techniques.

[More info](https://wikipedia.org/wiki/Fletcher%27s_checksum#Fletcher-64)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `fletcher8Checksum()`

**Module:** Crypto

The Fletcher checksum is an algorithm for computing a position-dependent checksum devised by John Gould Fletcher at Lawrence Livermore Labs in the late 1970s.

The objective of the Fletcher checksum was to provide error-detection properties approaching those of a cyclic redundancy check but with the lower computational effort associated with summation techniques.

[More info](https://wikipedia.org/wiki/Fletcher%27s_checksum)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `flipImage()`

**Module:** Image

Flips an image along its X or Y axis.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Axis** (option): `Horizontal`, `Vertical`

---

### `fork()`

**Module:** Default

Split the input data up based on the specified delimiter and run all subsequent operations on each branch separately.

For example, to decode multiple Base64 strings, enter them all on separate lines then add the 'Fork' and 'From Base64' operations to the recipe. Each string will be decoded separately.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Split delimiter** (binaryShortString): default `\n`
  - **Merge delimiter** (binaryShortString): default `\n`
  - **Ignore errors** (boolean): default `False`

---

### `formatMACAddresses()`

**Module:** Default

Displays given MAC addresses in multiple different formats.

Expects addresses in a list separated by newlines, spaces or commas.

WARNING: There are no validity checks.

[More info](https://wikipedia.org/wiki/MAC_address#Notational_conventions)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Output case** (option): `Both`, `Upper only`, `Lower only`
  - **No delimiter** (boolean): default `True`
  - **Dash delimiter** (boolean): default `True`
  - **Colon delimiter** (boolean): default `True`
  - **Cisco style** (boolean): default `False`
  - **IPv6 interface ID** (boolean): default `False`

---

### `frequencyDistribution()`

**Module:** Default

Displays the distribution of bytes in the data as a graph.

[More info](https://wikipedia.org/wiki/Frequency_distribution)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Show 0%s** (boolean): default `True`
  - **Show ASCII** (boolean): default `True`

---

### `fromBCD()`

**Module:** Default

Binary-Coded Decimal (BCD) is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four or eight. Special bit patterns are sometimes used for a sign.

[More info](https://wikipedia.org/wiki/Binary-coded_decimal)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Scheme** (option): `8 4 2 1`, `7 4 2 1`, `4 2 2 1` (+4 more)
  - **Packed** (boolean): default `True`
  - **Signed** (boolean): default `False`
  - **Input format** (option): `Nibbles`, `Bytes`, `Raw`

---

### `fromBase()`

**Module:** Default

Converts a number to decimal from a given numerical base.

[More info](https://wikipedia.org/wiki/Radix)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Radix** (number): default `36`

---

### `fromBase32()`

**Module:** Default

Base32 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. It uses a smaller set of characters than Base64, usually the uppercase alphabet and the numbers 2 to 7.

[More info](https://wikipedia.org/wiki/Base32)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Alphabet** (editableOption): `Standard`, `Hex Extended`
  - **Remove non-alphabet chars** (boolean): default `True`

---

### `fromBase45()`

**Module:** Default

Base45 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system. Base45 is optimized for usage with QR codes.

[More info](https://wikipedia.org/wiki/List_of_numeral_systems)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Alphabet** (string): default `0-9A-Z $%*+\-./:`
  - **Remove non-alphabet chars** (boolean): default `True`

---

### `fromBase58()`

**Module:** Default

Base58 (similar to Base64) is a notation for encoding arbitrary byte data. It differs from Base64 by removing easily misread characters (i.e. l, I, 0 and O) to improve human readability.

This operation decodes data from an ASCII string (with an alphabet of your choosing, presets included) back into its raw form.

e.g. `StV1DL6CwTryKyV` becomes `hello world`

Base58 is commonly used in cryptocurrencies (Bitcoin, Ripple, etc).

[More info](https://wikipedia.org/wiki/Base58)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Alphabet** (editableOption): `Bitcoin`, `Ripple`
  - **Remove non-alphabet chars** (boolean): default `True`

---

### `fromBase62()`

**Module:** Default

Base62 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system.

[More info](https://wikipedia.org/wiki/List_of_numeral_systems)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Alphabet** (string): default `0-9A-Za-z`

---

### `fromBase64()`

**Module:** Default

Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.

This operation decodes data from an ASCII Base64 string back into its raw format.

e.g. `aGVsbG8=` becomes `hello`

[More info](https://wikipedia.org/wiki/Base64)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Alphabet** (editableOption): `Standard (RFC 4648): A-Za-z0-9+/=`, `URL safe (RFC 4648 §5): A-Za-z0-9-_`, `Filename safe: A-Za-z0-9+-=` (+14 more)
  - **Remove non-alphabet chars** (boolean): default `True`
  - **Strict mode** (boolean): default `False`

---

### `fromBase85()`

**Module:** Default

Base85 (also called Ascii85) is a notation for encoding arbitrary byte data. It is usually more efficient that Base64.

This operation decodes data from an ASCII string (with an alphabet of your choosing, presets included).

e.g. `BOu!rD]j7BEbo7` becomes `hello world`

Base85 is commonly used in Adobe's PostScript and PDF file formats.

[More info](https://wikipedia.org/wiki/Ascii85)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Alphabet** (editableOption): `Standard`, `Z85 (ZeroMQ)`, `IPv6`
  - **Remove non-alphabet chars** (boolean): default `True`
  - **All-zero group char** (binaryShortString): default `z`

---

### `fromBase92()`

**Module:** Default

Base92 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.

[More info](https://wikipedia.org/wiki/List_of_numeral_systems)

**Input:** `string` → **Output:** `byteArray`

---

### `fromBinary()`

**Module:** Default

Converts a binary string back into its raw form.

e.g. `01001000 01101001` becomes `Hi`

[More info](https://wikipedia.org/wiki/Binary_code)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+4 more)
  - **Byte Length** (number): default `8`

---

### `fromBraille()`

**Module:** Default

Converts six-dot braille symbols to text.

[More info](https://wikipedia.org/wiki/Braille)

**Input:** `string` → **Output:** `string`

---

### `fromCaseInsensitiveRegex()`

**Module:** Default

Converts a case-insensitive regex string to a case sensitive regex string (no guarantee on it being the proper original casing) in case the i flag wasn't available at the time but now is, or you need it to be case-sensitive again.

e.g. `[mM][oO][zZ][iI][lL][lL][aA]/[0-9].[0-9] .*` becomes `Mozilla/[0-9].[0-9] .*`

[More info](https://wikipedia.org/wiki/Regular_expression)

**Input:** `string` → **Output:** `string`

---

### `fromCharcode()`

**Module:** Default

Converts unicode character codes back into text.

e.g. `0393 03b5 03b9 03ac 20 03c3 03bf 03c5` becomes `Γειά σου`

[More info](https://wikipedia.org/wiki/Plane_(Unicode))

**Input:** `string` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)
  - **Base** (number): default `16`

---

### `fromDecimal()`

**Module:** Default

Converts the data from an ordinal integer array back into its raw form.

e.g. `72 101 108 108 111` becomes `Hello`

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)
  - **Support signed values** (boolean): default `False`

---

### `fromFloat()`

**Module:** Default

Convert from IEEE754 Floating Point Numbers

[More info](https://wikipedia.org/wiki/IEEE_754)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Endianness** (option): `Big Endian`, `Little Endian`
  - **Size** (option): `Float (4 bytes)`, `Double (8 bytes)`
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)

---

### `fromHTMLEntity()`

**Module:** Encodings

Converts HTML entities back to characters

e.g. `&amp;amp;` becomes `&amp;`

[More info](https://wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references)

**Input:** `string` → **Output:** `string`

---

### `fromHex()`

**Module:** Default

Converts a hexadecimal byte string back into its raw value.

e.g. `ce 93 ce b5 ce b9 ce ac 20 cf 83 ce bf cf 85 0a` becomes the UTF-8 encoded string `Γειά σου`

[More info](https://wikipedia.org/wiki/Hexadecimal)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Delimiter** (option): `Auto`, `Space`, `Percent` (+9 more)

---

### `fromHexContent()`

**Module:** Default

Translates hexadecimal bytes in text back to raw bytes. This format is used by SNORT for representing hex within ASCII text.

e.g. `foo|3d|bar` becomes `foo=bar`.

[More info](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html#SECTION00451000000000000000)

**Input:** `string` → **Output:** `byteArray`

---

### `fromHexdump()`

**Module:** Default

Attempts to convert a hexdump back into raw data. This operation supports many different hexdump variations, but probably not all. Make sure you verify that the data it gives you is correct before continuing analysis.

[More info](https://wikipedia.org/wiki/Hex_dump)

**Input:** `string` → **Output:** `byteArray`

---

### `fromMessagePack()`

**Module:** Code

Converts MessagePack encoded data to JSON. MessagePack is a computer data interchange format. It is a binary form for representing simple data structures like arrays and associative arrays.

[More info](https://wikipedia.org/wiki/MessagePack)

**Input:** `ArrayBuffer` → **Output:** `JSON`

---

### `fromModhex()`

**Module:** Default

Converts a modhex byte string back into its raw value.

[More info](https://en.wikipedia.org/wiki/YubiKey#ModHex)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Delimiter** (option): `Auto`, `Space`, `Percent` (+6 more)

---

### `fromMorseCode()`

**Module:** Default

Translates Morse Code into (upper case) alphanumeric characters.

[More info](https://wikipedia.org/wiki/Morse_code)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Letter delimiter** (option): `Space`, `Line feed`, `CRLF` (+5 more)
  - **Word delimiter** (option): `Line feed`, `CRLF`, `Forward slash` (+4 more)

---

### `fromOctal()`

**Module:** Default

Converts an octal byte string back into its raw value.

e.g. `316 223 316 265 316 271 316 254 40 317 203 316 277 317 205` becomes the UTF-8 encoded string `Γειά σου`

[More info](https://wikipedia.org/wiki/Octal)

**Input:** `string` → **Output:** `byteArray`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)

---

### `fromPunycode()`

**Module:** Encodings

Punycode is a way to represent Unicode with the limited character subset of ASCII supported by the Domain Name System.

e.g. `mnchen-3ya` decodes to `münchen`

[More info](https://wikipedia.org/wiki/Punycode)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Internationalised domain name** (boolean): default `False`

---

### `fromQuotedPrintable()`

**Module:** Default

Converts QP-encoded text back to standard text.

e.g. The quoted-printable encoded string `hello=20world` becomes `hello world`

[More info](https://wikipedia.org/wiki/Quoted-printable)

**Input:** `string` → **Output:** `byteArray`

---

### `fromUNIXTimestamp()`

**Module:** Default

Converts a UNIX timestamp to a datetime string.

e.g. `978346800` becomes `Mon 1 January 2001 11:00:00 UTC`

A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).

[More info](https://wikipedia.org/wiki/Unix_time)

**Input:** `number` → **Output:** `string`

**Arguments:**
  - **Units** (option): `Seconds (s)`, `Milliseconds (ms)`, `Microseconds (μs)` (+1 more)

---

### `fuzzyMatch()`

**Module:** Default

Conducts a fuzzy search to find a pattern within the input based on weighted criteria.

e.g. A search for `dpan` will match on `Don't Panic`

[More info](https://wikipedia.org/wiki/Fuzzy_matching_(computer-assisted_translation))

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Search** (binaryString): default ``
  - **Sequential bonus** (number): default `15`
  - **Separator bonus** (number): default `30`
  - **Camel bonus** (number): default `30`
  - **First letter bonus** (number): default `15`
  - **Leading letter penalty** (number): default `-5`
  - **Max leading letter penalty** (number): default `-15`
  - **Unmatched letter penalty** (number): default `-1`

---

### `generateAllChecksums()`

**Module:** Crypto

Generates all available checksums for the input.

[More info](https://wikipedia.org/wiki/Checksum)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Length (bits)** (option): `All`, `3`, `4` (+20 more)
  - **Include names** (boolean): default `True`

---

### `generateAllHashes()`

**Module:** Crypto

Generates all available hashes and checksums for the input.

[More info](https://wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Length (bits)** (option): `All`, `128`, `160` (+5 more)
  - **Include names** (boolean): default `True`

---

### `generateDeBruijnSequence()`

**Module:** Default

Generates rolling keycode combinations given a certain alphabet size and key length.

[More info](https://wikipedia.org/wiki/De_Bruijn_sequence)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Alphabet size (k)** (number): default `2`
  - **Key length (n)** (number): default `3`

---

### `generateECDSAKeyPair()`

**Module:** Ciphers

Generate an ECDSA key pair with a given Curve.

WARNING: Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. We advise you not to use keys generated from CyberChef in operational contexts.

[More info](https://wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Elliptic Curve** (option): `P-256`, `P-384`, `P-521`
  - **Output Format** (option): `PEM`, `DER`, `JWK`

---

### `generateHOTP()`

**Module:** Default

The HMAC-based One-Time Password algorithm (HOTP) is an algorithm that computes a one-time password from a shared secret key and an incrementing counter. It has been adopted as Internet Engineering Task Force standard RFC 4226, is the cornerstone of Initiative For Open Authentication (OAUTH), and is used in a number of two-factor authentication systems.

Enter the secret as the input or leave it blank for a random secret to be generated.

[More info](https://wikipedia.org/wiki/HMAC-based_One-time_Password_algorithm)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Name** (string): default ``
  - **Code length** (number): default `6`
  - **Counter** (number): default `0`

---

### `generateImage()`

**Module:** Image

Generates an image using the input as pixel values.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Mode** (option): `Greyscale`, `RG`, `RGB` (+2 more)
  - **Pixel Scale Factor** (number): default `8`
  - **Pixels per row** (number): default `64`

---

### `generateLoremIpsum()`

**Module:** Default

Generate varying length lorem ipsum placeholder text.

[More info](https://wikipedia.org/wiki/Lorem_ipsum)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Length** (number): default `3`
  - **Length in** (option): `Paragraphs`, `Sentences`, `Words` (+1 more)

---

### `generatePGPKeyPair()`

**Module:** PGP

Generates a new public/private PGP key pair. Supports RSA and Eliptic Curve (EC) keys.

WARNING: Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. We advise you not to use keys generated from CyberChef in operational contexts.

[More info](https://wikipedia.org/wiki/Pretty_Good_Privacy)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key type** (option): `RSA-1024`, `RSA-2048`, `RSA-4096` (+3 more)
  - **Password (optional)** (string): default ``
  - **Name (optional)** (string): default ``
  - **Email (optional)** (string): default ``

---

### `generateQRCode()`

**Module:** Image

Generates a Quick Response (QR) code from the input text.

A QR code is a type of matrix barcode (or two-dimensional barcode) first designed in 1994 for the automotive industry in Japan. A barcode is a machine-readable optical label that contains information about the item to which it is attached.

[More info](https://wikipedia.org/wiki/QR_code)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Image Format** (option): `PNG`, `SVG`, `EPS` (+1 more)
  - **Module size (px)** (number): default `5`
  - **Margin (num modules)** (number): default `4`
  - **Error correction** (option): `Low`, `Medium`, `Quartile` (+1 more)

---

### `generateRSAKeyPair()`

**Module:** Ciphers

Generate an RSA key pair with a given number of bits.

WARNING: Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. We advise you not to use keys generated from CyberChef in operational contexts.

[More info](https://wikipedia.org/wiki/RSA_(cryptosystem))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **RSA Key Length** (option): `1024`, `2048`, `4096`
  - **Output Format** (option): `PEM`, `JSON`, `DER`

---

### `generateTOTP()`

**Module:** Default

The Time-based One-Time Password algorithm (TOTP) is an algorithm that computes a one-time password from a shared secret key and the current time. It has been adopted as Internet Engineering Task Force standard RFC 6238, is the cornerstone of Initiative For Open Authentication (OAUTH), and is used in a number of two-factor authentication systems. A TOTP is an HOTP where the counter is the current time.

Enter the secret as the input or leave it blank for a random secret to be generated. T0 and T1 are in seconds.

[More info](https://wikipedia.org/wiki/Time-based_One-time_Password_algorithm)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Name** (string): default ``
  - **Code length** (number): default `6`
  - **Epoch offset (T0)** (number): default `0`
  - **Interval (T1)** (number): default `30`

---

### `generateUUID()`

**Module:** Crypto

Generates an RFC 9562 (formerly RFC 4122) compliant Universally Unique Identifier (UUID), also known as a Globally Unique Identifier (GUID).

We currently support generating the following UUID versions: v1: Timestamp-basedv3: Namespace w/ MD5v4: Random (default)v5: Namespace w/ SHA-1v6: Timestamp, reorderedv7: Unix Epoch time-basedUUIDs are generated using the `uuid` package.

[More info](https://wikipedia.org/wiki/Universally_unique_identifier)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Version** (option): `v1`, `v3`, `v4` (+3 more)
  - **Namespace** (string): default `1b671a64-40d5-491e-99b0-da01ff1f3341`

---

### `genericCodeBeautify()`

**Module:** Code

Attempts to pretty print C-style languages such as C, C++, C#, Java, PHP, JavaScript etc.

This will not do a perfect job, and the resulting code may not work any more. This operation is designed purely to make obfuscated or minified code more easy to read and understand.

Things which will not work properly:For loop formattingDo-While loop formattingSwitch/Case indentationCertain bit shift operators

**Input:** `string` → **Output:** `string`

---

### `getAllCasings()`

**Module:** Default

Outputs all possible casing variations of a string.

**Input:** `string` → **Output:** `string`

---

### `getTime()`

**Module:** Default

Generates a timestamp showing the amount of time since the UNIX epoch (1970-01-01 00:00:00 UTC). Uses the W3C High Resolution Time API.

[More info](https://wikipedia.org/wiki/Unix_time)

**Input:** `string` → **Output:** `number`

**Arguments:**
  - **Granularity** (option): `Seconds (s)`, `Milliseconds (ms)`, `Microseconds (μs)` (+1 more)

---

### `groupIPAddresses()`

**Module:** Default

Groups a list of IP addresses into subnets. Supports both IPv4 and IPv6 addresses.

[More info](https://wikipedia.org/wiki/Subnetwork)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+2 more)
  - **Subnet (CIDR)** (number): default `24`
  - **Only show the subnets** (boolean): default `False`

---

### `gunzip()`

**Module:** Compression

Decompresses data which has been compressed using the deflate algorithm with gzip headers.

[More info](https://wikipedia.org/wiki/Gzip)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `gzip()`

**Module:** Compression

Compresses data using the deflate algorithm with gzip headers.

[More info](https://wikipedia.org/wiki/Gzip)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Compression type** (option): `Dynamic Huffman Coding`, `Fixed Huffman Coding`, `None (Store)`
  - **Filename (optional)** (string): default ``
  - **Comment (optional)** (string): default ``
  - **Include file checksum** (boolean): default `False`

---

### `hammingDistance()`

**Module:** Default

In information theory, the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different. In other words, it measures the minimum number of substitutions required to change one string into the other, or the minimum number of errors that could have transformed one string into the other. In a more general context, the Hamming distance is one of several string metrics for measuring the edit distance between two sequences.

[More info](https://wikipedia.org/wiki/Hamming_distance)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (binaryShortString): default `\n\n`
  - **Unit** (option): `Byte`, `Bit`
  - **Input type** (option): `Raw string`, `Hex`

---

### `haversineDistance()`

**Module:** Default

Returns the distance between two pairs of GPS latitude and longitude co-ordinates in metres.

e.g. `51.487263,-0.124323, 38.9517,-77.1467`

[More info](https://wikipedia.org/wiki/Haversine_formula)

**Input:** `string` → **Output:** `number`

---

### `head()`

**Module:** Default

Like the UNIX head utility. Gets the first n lines. You can select all but the last n lines by entering a negative value for n. The delimiter can be changed so that instead of lines, fields (i.e. commas) are selected instead.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)
  - **Number** (number): default `10`

---

### `heatmapChart()`

**Module:** Charts

A heatmap is a graphical representation of data where the individual values contained in a matrix are represented as colors.

[More info](https://wikipedia.org/wiki/Heat_map)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Record delimiter** (option): `Line feed`, `CRLF`
  - **Field delimiter** (option): `Space`, `Comma`, `Semi-colon` (+2 more)
  - **Number of vertical bins** (number): default `25`
  - **Number of horizontal bins** (number): default `25`
  - **Use column headers as labels** (boolean): default `True`
  - **X label** (string): default ``
  - **Y label** (string): default ``
  - **Draw bin edges** (boolean): default `False`
  - **Min colour value** (string): default `white`
  - **Max colour value** (string): default `black`

---

### `hexDensityChart()`

**Module:** Charts

Hex density charts are used in a similar way to scatter charts, however rather than rendering tens of thousands of points, it groups the points into a few hundred hexagons to show the distribution.

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Record delimiter** (option): `Line feed`, `CRLF`
  - **Field delimiter** (option): `Space`, `Comma`, `Semi-colon` (+2 more)
  - **Pack radius** (number): default `25`
  - **Draw radius** (number): default `15`
  - **Use column headers as labels** (boolean): default `True`
  - **X label** (string): default ``
  - **Y label** (string): default ``
  - **Draw hexagon edges** (boolean): default `False`
  - **Min colour value** (string): default `white`
  - **Max colour value** (string): default `black`
  - **Draw empty hexagons within data boundaries** (boolean): default `False`

---

### `hexToObjectIdentifier()`

**Module:** PublicKey

Converts a hexadecimal string into an object identifier (OID).

[More info](https://wikipedia.org/wiki/Object_identifier)

**Input:** `string` → **Output:** `string`

---

### `hexToPEM()`

**Module:** PublicKey

Converts a hexadecimal DER (Distinguished Encoding Rules) string into PEM (Privacy Enhanced Mail) format.

[More info](https://wikipedia.org/wiki/Privacy-Enhanced_Mail)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Header string** (string): default `CERTIFICATE`

---

### `imageBrightnessContrast()`

**Module:** Image

Adjust the brightness or contrast of an image.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Brightness** (number): default `0`
  - **Contrast** (number): default `0`

---

### `imageFilter()`

**Module:** Image

Applies a greyscale or sepia filter to an image.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Filter type** (option): `Greyscale`, `Sepia`

---

### `imageHueSaturationLightness()`

**Module:** Image

Adjusts the hue / saturation / lightness (HSL) values of an image.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Hue** (number): default `0`
  - **Saturation** (number): default `0`
  - **Lightness** (number): default `0`

---

### `imageOpacity()`

**Module:** Image

Adjust the opacity of an image.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Opacity (%)** (number): default `100`

---

### `indexOfCoincidence()`

**Module:** Default

Index of Coincidence (IC) is the probability of two randomly selected characters being the same. This can be used to determine whether text is readable or random, with English text having an IC of around 0.066. IC can therefore be a sound method to automate frequency analysis.

[More info](https://wikipedia.org/wiki/Index_of_coincidence)

**Input:** `string` → **Output:** `html`

---

### `invertImage()`

**Module:** Image

Invert the colours of an image.

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `javaScriptBeautify()`

**Module:** Code

Parses and pretty prints valid JavaScript code. Also works with JavaScript Object Notation (JSON).

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Indent string** (binaryShortString): default `\t`
  - **Quotes** (option): `Auto`, `Single`, `Double`
  - **Semicolons before closing braces** (boolean): default `True`
  - **Include comments** (boolean): default `True`

---

### `javaScriptMinify()`

**Module:** Code

Compresses JavaScript code.

**Input:** `string` → **Output:** `string`

---

### `javaScriptParser()`

**Module:** Code

Returns an Abstract Syntax Tree for valid JavaScript code.

[More info](https://wikipedia.org/wiki/Abstract_syntax_tree)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Location info** (boolean): default `False`
  - **Range info** (boolean): default `False`
  - **Include tokens array** (boolean): default `False`
  - **Include comments array** (boolean): default `False`
  - **Report errors and try to continue** (boolean): default `False`

---

### `jq()`

**Module:** Jq

jq is a lightweight and flexible command-line JSON processor.

[More info](https://github.com/jqlang/jq)

**Input:** `JSON` → **Output:** `string`

**Arguments:**
  - **Query** (string): default ``

---

### `jump()`

**Module:** Default

Jump forwards or backwards to the specified Label

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Label name** (string): default ``
  - **Maximum jumps (if jumping backwards)** (number): default `10`

---

### `keccak()`

**Module:** Crypto

The Keccak hash algorithm was designed by Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche, building upon RadioGatún. It was selected as the winner of the SHA-3 design competition.

This version of the algorithm is Keccak[c=2d] and differs from the SHA-3 specification.

[More info](https://wikipedia.org/wiki/SHA-3)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (option): `512`, `384`, `256` (+1 more)

---

### `label()`

**Module:** Default

Provides a location for conditional and fixed jumps to redirect execution to.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Name** (shortString): default ``

---

### `levenshteinDistance()`

**Module:** Default

Levenshtein Distance (also known as Edit Distance) is a string metric to measure a difference between two strings that counts operations (insertions, deletions, and substitutions) on single character that are required to change one string to another.

[More info](https://wikipedia.org/wiki/Levenshtein_distance)

**Input:** `string` → **Output:** `number`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n`
  - **Insertion cost** (number): default `1`
  - **Deletion cost** (number): default `1`
  - **Substitution cost** (number): default `1`

---

### `lorenz()`

**Module:** Bletchley

The Lorenz SZ40/42 cipher attachment was a WW2 German rotor cipher machine with twelve rotors which attached in-line between remote teleprinters.

It used the Vernam cipher with two groups of five rotors (named the psi(ψ) wheels and chi(χ) wheels at Bletchley Park) to create two pseudorandom streams of five bits, encoded in ITA2, which were XOR added to the plaintext. Two other rotors, dubbed the mu(μ) or motor wheels, could hold up the stepping of the psi wheels meaning they stepped intermittently.

Each rotor has a different number of cams/lugs around their circumference which could be set active or inactive changing the key stream.

Three models of the Lorenz are emulated, SZ40, SZ42a and SZ42b and three example wheel patterns (the lug settings) are included (KH, ZMUG & BREAM) with the option to set a custom set using the letter 'x' for active or '.' for an inactive lug.

The input can either be plaintext or ITA2 when sending and ITA2 when receiving.

To learn more, Virtual Lorenz, an online, browser based simulation of the Lorenz SZ40/42 is available at lorenz.virtualcolossus.co.uk.

A more detailed description of this operation can be found here.

[More info](https://wikipedia.org/wiki/Lorenz_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Model** (option): `SZ40`, `SZ42a`, `SZ42b`
  - **Wheel Pattern** (argSelector): default `[{'name': 'KH Pattern', 'off': [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {'name': 'ZMUG Pattern', 'off': [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {'name': 'BREAM Pattern', 'off': [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {'name': 'No Pattern', 'off': [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {'name': 'Custom', 'on': [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}]`
  - **KT-Schalter** (boolean): default `False`
  - **Mode** (argSelector): default `[{'name': 'Send', 'on': [4], 'off': [5]}, {'name': 'Receive', 'off': [4], 'on': [5]}]`
  - **Input Type** (option): `Plaintext`, `ITA2`
  - **Output Type** (option): `Plaintext`, `ITA2`
  - **ITA2 Format** (option): `5/8/9`, `+/-/.`
  - **Ψ1 start (1-43)** (number): default `1`
  - **Ψ2 start (1-47)** (number): default `1`
  - **Ψ3 start (1-51)** (number): default `1`
  - **Ψ4 start (1-53)** (number): default `1`
  - **Ψ5 start (1-59)** (number): default `1`
  - **Μ37 start (1-37)** (number): default `1`
  - **Μ61 start (1-61)** (number): default `1`
  - **Χ1 start (1-41)** (number): default `1`
  - **Χ2 start (1-31)** (number): default `1`
  - **Χ3 start (1-29)** (number): default `1`
  - **Χ4 start (1-26)** (number): default `1`
  - **Χ5 start (1-23)** (number): default `1`
  - **Ψ1 lugs (43)** (string): default `.x...xx.x.x..xxx.x.x.xxxx.x.x.x.x.x..x.xx.x`
  - **Ψ2 lugs (47)** (string): default `.xx.x.xxx..x.x.x..x.xx.x.xxx.x....x.xx.x.x.x..x`
  - **Ψ3 lugs (51)** (string): default `.x.x.x..xxx....x.x.xx.x.x.x..xxx.x.x..x.x.xx..x.x.x`
  - **Ψ4 lugs (53)** (string): default `.xx...xxxxx.x.x.xx...x.xx.x.x..x.x.xx.x..x.x.x.x.x.x.`
  - **Ψ5 lugs (59)** (string): default `xx...xx.x..x.xx.x...x.x.x.x.x.x.x.x.xx..xxxx.x.x...xx.x..x.`
  - **Μ37 lugs (37)** (string): default `x.x.x.x.x.x...x.x.x...x.x.x...x.x....`
  - **Μ61 lugs (61)** (string): default `.xxxx.xxxx.xxx.xxxx.xx....xxx.xxxx.xxxx.xxxx.xxxx.xxx.xxxx...`
  - **Χ1 lugs (41)** (string): default `.x...xxx.x.xxxx.x...x.x..xxx....xx.xxxx..`
  - **Χ2 lugs (31)** (string): default `x..xxx...x.xxxx..xx..x..xx.xx..`
  - **Χ3 lugs (29)** (string): default `..xx..x.xxx...xx...xx..xx.xx.`
  - **Χ4 lugs (26)** (string): default `xx..x..xxxx..xx.xxx....x..`
  - **Χ5 lugs (23)** (string): default `xx..xx....xxxx.x..x.x..`

---

### `luhnChecksum()`

**Module:** Default

The Luhn mod N algorithm using the english alphabet. The Luhn mod N algorithm is an extension to the Luhn algorithm (also known as mod 10 algorithm) that allows it to work with sequences of values in any even-numbered base. This can be useful when a check digit is required to validate an identification string composed of letters, a combination of letters and digits or any arbitrary set of N characters where N is divisible by 2.

[More info](https://en.wikipedia.org/wiki/Luhn_mod_N_algorithm)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Radix** (number): default `10`

---

### `magic()`

**Module:** Default

The Magic operation attempts to detect various properties of the input data and suggests which operations could help to make more sense of it.

Options Depth: If an operation appears to match the data, it will be run and the result will be analysed further. This argument controls the maximum number of levels of recursion.

Intensive mode: When this is turned on, various operations like XOR, bit rotates, and character encodings are brute-forced to attempt to detect valid data underneath. To improve performance, only the first 100 bytes of the data is brute-forced.

Extensive language support: At each stage, the relative byte frequencies of the data will be compared to average frequencies for a number of languages. The default set consists of ~40 of the most commonly used languages on the Internet. The extensive list consists of 284 languages and can result in many languages matching the data if their byte frequencies are similar.

Optionally enter a regular expression to match a string you expect to find to filter results (crib).

[More info](https://github.com/gchq/CyberChef/wiki/Automatic-detection-of-encoded-data-using-CyberChef-Magic)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Depth** (number): default `3`
  - **Intensive mode** (boolean): default `False`
  - **Extensive language support** (boolean): default `False`
  - **Crib (known plaintext string or regex)** (string): default ``

---

### `mean()`

**Module:** Default

Computes the mean (average) of a number list. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 .5 .5` becomes `4.75`

[More info](https://wikipedia.org/wiki/Arithmetic_mean)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `median()`

**Module:** Default

Computes the median of a number list. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 1 .5` becomes `4.5`

[More info](https://wikipedia.org/wiki/Median)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `merge()`

**Module:** Default

Consolidate all branches back into a single trunk. The opposite of Fork. Unticking the Merge All checkbox will only consolidate all branches up to the nearest Fork/Subsection.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Merge All** (boolean): default `True`

---

### `microsoftScriptDecoder()`

**Module:** Default

Decodes Microsoft Encoded Script files that have been encoded with Microsoft's custom encoding. These are often VBS (Visual Basic Script) files that are encoded and renamed with a '.vbe' extention or JS (JScript) files renamed with a '.jse' extention.

Sample

Encoded: `#@~^RQAAAA==-mD~sX|:/TP{~J:+dYbxL~@!F@*@!+@*@!&amp;@*eEI@#@&amp;@#@&amp;.jm.raY 214Wv:zms/obI0xEAAA==^#~@`

Decoded: var my_msg = &#34;Testing !&#34;;

VScript.Echo(my_msg);

[More info](https://wikipedia.org/wiki/JScript.Encode)

**Input:** `string` → **Output:** `string`

---

### `multipleBombe()`

**Module:** Bletchley

Emulation of the Bombe machine used to attack Enigma. This version carries out multiple Bombe runs to handle unknown rotor configurations.

You should test your menu on the single Bombe operation before running it here. See the description of the Bombe operation for instructions on choosing a crib.

More detailed descriptions of the Enigma, Typex and Bombe operations can be found here.

[More info](https://wikipedia.org/wiki/Bombe)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Standard Enigmas** (populateMultiOption): default `[{'name': 'German Service Enigma (First - 3 rotor)', 'value': ['EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A', '', 'AY BR CU DH EQ FS GL IP JX KN MO TZ VW']}, {'name': 'German Service Enigma (Second - 3 rotor)', 'value': ['EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A\nJPGVOUMFYQBENHZRDKASXLICTW<AN\nNZJHGRCXMYSWBOUFAIVLPEKQDT<AN\nFKQHTLXOCBJSPDZRAMEWNIUYGV<AN', '', 'AY BR CU DH EQ FS GL IP JX KN MO TZ VW\nAF BV CP DJ EI GO HY KR LZ MX NW TQ SU']}, {'name': 'German Service Enigma (Third - 4 rotor)', 'value': ['EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A\nJPGVOUMFYQBENHZRDKASXLICTW<AN\nNZJHGRCXMYSWBOUFAIVLPEKQDT<AN\nFKQHTLXOCBJSPDZRAMEWNIUYGV<AN', 'FSOKANUERHMBTIYCWLQPZXVGJD', 'AE BN CK DQ FU GY HW IJ LO MP RX SZ TV']}, {'name': 'German Service Enigma (Fourth - 4 rotor)', 'value': ['EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A\nJPGVOUMFYQBENHZRDKASXLICTW<AN\nNZJHGRCXMYSWBOUFAIVLPEKQDT<AN\nFKQHTLXOCBJSPDZRAMEWNIUYGV<AN', 'FSOKANUERHMBTIYCWLQPZXVGJD', 'AE BN CK DQ FU GY HW IJ LO MP RX SZ TV\nAR BD CO EJ FN GT HK IV LM PW QZ SX UY']}, {'name': 'User defined', 'value': ['', '', '']}]`
  - **Main rotors** (text): default ``
  - **4th rotor** (text): default ``
  - **Reflectors** (text): default ``
  - **Crib** (string): default ``
  - **Crib offset** (number): default `0`
  - **Use checking machine** (boolean): default `True`

---

### `multiply()`

**Module:** Default

Multiplies a list of numbers. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 .5` becomes `40`

[More info](https://wikipedia.org/wiki/Multiplication)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `murmurHash3()`

**Module:** Hashing

Generates a MurmurHash v3 for a string input and an optional seed input

[More info](https://wikipedia.org/wiki/MurmurHash)

**Input:** `string` → **Output:** `number`

**Arguments:**
  - **Seed** (number): default `0`
  - **Convert to Signed** (boolean): default `False`

---

### `normaliseImage()`

**Module:** Image

Normalise the image colours.

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `normaliseUnicode()`

**Module:** Encodings

Transform Unicode characters to one of the Normalisation Forms

[More info](https://wikipedia.org/wiki/Unicode_equivalence#Normal_forms)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Normal Form** (option): `NFD`, `NFC`, `NFKD` (+1 more)

---

### `numberwang()`

**Module:** Default

Based on the popular gameshow by Mitchell and Webb.

[More info](https://wikipedia.org/wiki/That_Mitchell_and_Webb_Look#Recurring_sketches)

**Input:** `string` → **Output:** `string`

---

### `objectIdentifierToHex()`

**Module:** PublicKey

Converts an object identifier (OID) into a hexadecimal string.

[More info](https://wikipedia.org/wiki/Object_identifier)

**Input:** `string` → **Output:** `string`

---

### `offsetChecker()`

**Module:** Default

Compares multiple inputs (separated by the specified delimiter) and highlights matching characters which appear at the same position in all samples.

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`

---

### `opticalCharacterRecognition()`

**Module:** OCR

Optical character recognition or optical character reader (OCR) is the mechanical or electronic conversion of images of typed, handwritten or printed text into machine-encoded text.

Supported image formats: png, jpg, bmp, pbm.

[More info](https://wikipedia.org/wiki/Optical_character_recognition)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Show confidence** (boolean): default `True`
  - **OCR Engine Mode** (option): `Tesseract only`, `LSTM only`, `Tesseract/LSTM Combined`

---

### `padLines()`

**Module:** Default

Add the specified number of the specified character to the beginning or end of each line

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Position** (option): `Start`, `End`
  - **Length** (number): default `5`
  - **Character** (binaryShortString): default ` `

---

### `parseASN1HexString()`

**Module:** PublicKey

Abstract Syntax Notation One (ASN.1) is a standard and notation that describes rules and structures for representing, encoding, transmitting, and decoding data in telecommunications and computer networking.

This operation parses arbitrary ASN.1 data (encoded as an hex string: use the 'To Hex' operation if necessary) and presents the resulting tree.

[More info](https://wikipedia.org/wiki/Abstract_Syntax_Notation_One)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Starting index** (number): default `0`
  - **Truncate octet strings longer than** (number): default `32`

---

### `parseCSR()`

**Module:** PublicKey

Parse Certificate Signing Request (CSR) for an X.509 certificate

[More info](https://wikipedia.org/wiki/Certificate_signing_request)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `PEM`

---

### `parseColourCode()`

**Module:** Default

Converts a colour code in a standard format to other standard formats and displays the colour itself.

Example inputs`#d9edf7``rgba(217,237,247,1)``hsla(200,65%,91%,1)``cmyk(0.12, 0.04, 0.00, 0.03)`

[More info](https://wikipedia.org/wiki/Web_colors)

**Input:** `string` → **Output:** `html`

---

### `parseDateTime()`

**Module:** Default

Parses a DateTime string in your specified format and displays it in whichever timezone you choose with the following information:DateTimePeriod (AM/PM)TimezoneUTC offsetDaylight Saving TimeLeap yearDays in this monthDay of yearWeek numberQuarterRun with no input to see format string examples if required.

[More info](https://momentjs.com/docs/#/parsing/string-format/)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Built in formats** (populateOption): default `[{'name': 'Standard date and time', 'value': 'DD/MM/YYYY HH:mm:ss'}, {'name': 'American-style date and time', 'value': 'MM/DD/YYYY HH:mm:ss'}, {'name': 'International date and time', 'value': 'YYYY-MM-DD HH:mm:ss'}, {'name': 'Verbose date and time', 'value': 'dddd Do MMMM YYYY HH:mm:ss Z z'}, {'name': 'UNIX timestamp (seconds)', 'value': 'X'}, {'name': 'UNIX timestamp offset (milliseconds)', 'value': 'x'}, {'name': 'Automatic', 'value': ''}]`
  - **Input format string** (binaryString): default `DD/MM/YYYY HH:mm:ss`
  - **Input timezone** (option): `UTC`, `Africa/Abidjan`, `Africa/Accra` (+594 more)

---

### `parseIPRange()`

**Module:** Default

Given a CIDR range (e.g. `10.0.0.0/24`), hyphenated range (e.g. `10.0.0.0 - 10.0.1.0`), or a list of IPs and/or CIDR ranges (separated by a new line), this operation provides network information and enumerates all IP addresses in the range.

IPv6 is supported but will not be enumerated.

[More info](https://wikipedia.org/wiki/Subnetwork)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Include network info** (boolean): default `True`
  - **Enumerate IP addresses** (boolean): default `True`
  - **Allow large queries** (boolean): default `False`

---

### `parseIPv4Header()`

**Module:** Default

Given an IPv4 header, this operations parses and displays each field in an easily readable format.

[More info](https://wikipedia.org/wiki/IPv4#Header)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Input format** (option): `Hex`, `Raw`

---

### `parseIPv6Address()`

**Module:** Default

Displays the longhand and shorthand versions of a valid IPv6 address.

Recognises all reserved ranges and parses encapsulated or tunnelled addresses including Teredo and 6to4.

[More info](https://wikipedia.org/wiki/IPv6_address)

**Input:** `string` → **Output:** `string`

---

### `parseObjectIDTimestamp()`

**Module:** Serialise

Parse timestamp from MongoDB/BSON ObjectID hex string.

[More info](https://docs.mongodb.com/manual/reference/method/ObjectId.getTimestamp/)

**Input:** `string` → **Output:** `string`

---

### `parseQRCode()`

**Module:** Image

Reads an image file and attempts to detect and read a Quick Response (QR) code from the image.

Normalise Image Attempts to normalise the image before parsing it to improve detection of a QR code.

[More info](https://wikipedia.org/wiki/QR_code)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Normalise image** (boolean): default `False`

---

### `parseSSHHostKey()`

**Module:** Default

Parses a SSH host key and extracts fields from it. The key type can be:ssh-rsassh-dssecdsa-sha2ssh-ed25519The key format can be either Hex or Base64.

[More info](https://wikipedia.org/wiki/Secure_Shell)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input Format** (option): `Auto`, `Base64`, `Hex`

---

### `parseTCP()`

**Module:** Default

Parses a TCP header and payload (if present).

[More info](https://wikipedia.org/wiki/Transmission_Control_Protocol)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Input format** (option): `Hex`, `Raw`

---

### `parseTLSRecord()`

**Module:** Default

Parses one or more TLS records

[More info](https://wikipedia.org/wiki/Transport_Layer_Security)

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `parseTLV()`

**Module:** Default

Converts a Type-Length-Value (TLV) encoded string into a JSON object.  Can optionally include a `Key` / `Type` entry. 

Tags: Key-Length-Value, KLV, Length-Value, LV

[More info](https://wikipedia.org/wiki/Type-length-value)

**Input:** `ArrayBuffer` → **Output:** `JSON`

**Arguments:**
  - **Type/Key size** (number): default `1`
  - **Length size** (number): default `1`
  - **Use BER** (boolean): default `False`

---

### `parseUDP()`

**Module:** Default

Parses a UDP header and payload (if present).

[More info](https://wikipedia.org/wiki/User_Datagram_Protocol)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Input format** (option): `Hex`, `Raw`

---

### `parseUNIXFilePermissions()`

**Module:** Default

Given a UNIX/Linux file permission string in octal or textual format, this operation explains which permissions are granted to which user groups.

Input should be in either octal (e.g. `755`) or textual (e.g. `drwxr-xr-x`) format.

[More info](https://wikipedia.org/wiki/File_system_permissions#Traditional_Unix_permissions)

**Input:** `string` → **Output:** `string`

---

### `parseURI()`

**Module:** URL

Pretty prints complicated Uniform Resource Identifier (URI) strings for ease of reading. Particularly useful for Uniform Resource Locators (URLs) with a lot of arguments.

[More info](https://wikipedia.org/wiki/Uniform_Resource_Identifier)

**Input:** `string` → **Output:** `string`

---

### `parseUserAgent()`

**Module:** UserAgent

Attempts to identify and categorise information contained in a user-agent string.

[More info](https://wikipedia.org/wiki/User_agent)

**Input:** `string` → **Output:** `string`

---

### `parseX509CRL()`

**Module:** PublicKey

Parse Certificate Revocation List (CRL)

[More info](https://wikipedia.org/wiki/Certificate_revocation_list)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `PEM`, `DER Hex`, `Base64` (+1 more)

---

### `parseX509Certificate()`

**Module:** PublicKey

X.509 is an ITU-T standard for a public key infrastructure (PKI) and Privilege Management Infrastructure (PMI). It is commonly involved with SSL/TLS security.

This operation displays the contents of a certificate in a human readable format, similar to the openssl command line tool.

Tags: X509, server hello, handshake

[More info](https://wikipedia.org/wiki/X.509)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Input format** (option): `PEM`, `DER Hex`, `Base64` (+1 more)

---

### `playMedia()`

**Module:** Default

Plays the input as audio or video depending on the type.

Tags: sound, movie, mp3, mp4, mov, webm, wav, ogg

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Input format** (option): `Raw`, `Base64`, `Hex`

---

### `powerSet()`

**Module:** Default

Calculates all the subsets of a set.

[More info](https://wikipedia.org/wiki/Power_set)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Item delimiter** (binaryString): default `,`

---

### `protobufDecode()`

**Module:** Protobuf

Decodes any Protobuf encoded data to a JSON representation of the data using the field number as the field key.

If a .proto schema is defined, the encoded data will be decoded with reference to the schema. Only one message instance will be decoded. 

Show Unknown Fields When a schema is used, this option shows fields that are present in the input data but not defined in the schema.

Show Types Show the type of a field next to its name. For undefined fields, the wiretype and example types are shown instead.

[More info](https://wikipedia.org/wiki/Protocol_Buffers)

**Input:** `ArrayBuffer` → **Output:** `JSON`

**Arguments:**
  - **Schema (.proto text)** (text): default ``
  - **Show Unknown Fields** (boolean): default `False`
  - **Show Types** (boolean): default `False`

---

### `protobufEncode()`

**Module:** Protobuf

Encodes a valid JSON object into a protobuf byte array using the input .proto schema.

[More info](https://developers.google.com/protocol-buffers/docs/encoding)

**Input:** `JSON` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Schema (.proto text)** (text): default ``

---

### `pseudoRandomNumberGenerator()`

**Module:** Ciphers

A cryptographically-secure pseudo-random number generator (PRNG).

This operation uses the browser's built-in `crypto.getRandomValues()` method if available. If this cannot be found, it falls back to a Fortuna-based PRNG algorithm.

[More info](https://wikipedia.org/wiki/Pseudorandom_number_generator)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Number of bytes** (number): default `32`
  - **Output as** (option): `Hex`, `Integer`, `Byte array` (+1 more)

---

### `rabbit()`

**Module:** Ciphers

Rabbit is a high-speed stream cipher introduced in 2003 and defined in RFC 4503.

The cipher uses a 128-bit key and an optional 64-bit initialization vector (IV).

big-endian: based on RFC4503 and RFC3447 little-endian: compatible with Crypto++

[More info](https://wikipedia.org/wiki/Rabbit_(cipher))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Endianness** (option): `Big`, `Little`
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Raw`, `Hex`

---

### `railFenceCipherDecode()`

**Module:** Ciphers

Decodes Strings that were created using the Rail fence Cipher provided a key and an offset

[More info](https://wikipedia.org/wiki/Rail_fence_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (number): default `2`
  - **Offset** (number): default `0`

---

### `railFenceCipherEncode()`

**Module:** Ciphers

Encodes Strings using the Rail fence Cipher provided a key and an offset

[More info](https://wikipedia.org/wiki/Rail_fence_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (number): default `2`
  - **Offset** (number): default `0`

---

### `randomizeColourPalette()`

**Module:** Image

Randomizes each colour in an image's colour palette. This can often reveal text or symbols that were previously a very similar colour to their surroundings, a technique sometimes used in Steganography.

[More info](https://wikipedia.org/wiki/Indexed_color)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Seed** (string): default ``

---

### `rawDeflate()`

**Module:** Compression

Compresses data using the deflate algorithm with no headers.

[More info](https://wikipedia.org/wiki/DEFLATE)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Compression type** (option): `Dynamic Huffman Coding`, `Fixed Huffman Coding`, `None (Store)`

---

### `rawInflate()`

**Module:** Compression

Decompresses data which has been compressed using the deflate algorithm with no headers.

[More info](https://wikipedia.org/wiki/DEFLATE)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Start index** (number): default `0`
  - **Initial output buffer size** (number): default `0`
  - **Buffer expansion type** (option): `Adaptive`, `Block`
  - **Resize buffer after decompression** (boolean): default `False`
  - **Verify result** (boolean): default `False`

---

### `register()`

**Module:** Regex

Extract data from the input and store it in registers which can then be passed into subsequent operations as arguments. Regular expression capture groups are used to select the data to extract.

To use registers in arguments, refer to them using the notation `$Rn` where n is the register number, starting at 0.

For example: Input: `Test` Extractor: `(.*)` Argument: `$R0` becomes `Test`

Registers can be escaped in arguments using a backslash. e.g. `\$R0` would become `$R0` rather than `Test`.

[More info](https://wikipedia.org/wiki/Regular_expression#Syntax)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Extractor** (binaryString): default `([\s\S]*)`
  - **Case insensitive** (boolean): default `True`
  - **Multiline matching** (boolean): default `False`
  - **Dot matches all** (boolean): default `False`

---

### `regularExpression()`

**Module:** Regex

Define your own regular expression (regex) to search the input data with, optionally choosing from a list of pre-defined patterns.

Supports extended regex syntax including the 'dot matches all' flag, named capture groups, full unicode coverage (including `\p{}` categories and scripts as well as astral codes) and recursive matching.

[More info](https://wikipedia.org/wiki/Regular_expression)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Built in regexes** (populateOption): default `[{'name': 'User defined', 'value': ''}, {'name': 'IPv4 address', 'value': '(?:(?:\\d|[01]?\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d|\\d)(?:\\/\\d{1,2})?'}, {'name': 'IPv6 address', 'value': '((?=.*::)(?!.*::.+::)(::)?([\\dA-Fa-f]{1,4}:(:|\\b)|){5}|([\\dA-Fa-f]{1,4}:){6})((([\\dA-Fa-f]{1,4}((?!\\3)::|:\\b|(?![\\dA-Fa-f])))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})'}, {'name': 'Email address', 'value': '(?:[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9!#$%&\'*+/=?^_`{|}~-]+(?:\\.[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9!#$%&\'*+/=?^_`{|}~-]+)*|"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*")@(?:(?:[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9](?:[\\u00A0-\\uD7FF\\uE000-\\uFFFF-a-z0-9-]*[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9])?\\.)+[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9](?:[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9-]*[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}\\])'}, {'name': 'URL', 'value': '([A-Za-z]+://)([-\\w]+(?:\\.\\w[-\\w]*)+)(:\\d+)?(/[^.!,?"<>\\[\\]{}\\s\\x7F-\\xFF]*(?:[.!,?]+[^.!,?"<>\\[\\]{}\\s\\x7F-\\xFF]+)*)?'}, {'name': 'Domain', 'value': '\\b((?=[a-z0-9-]{1,63}\\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,63}\\b'}, {'name': 'Windows file path', 'value': '([A-Za-z]):\\\\((?:[A-Za-z\\d][A-Za-z\\d\\- \\x27_\\(\\)~]{0,61}\\\\?)*[A-Za-z\\d][A-Za-z\\d\\- \\x27_\\(\\)]{0,61})(\\.[A-Za-z\\d]{1,6})?'}, {'name': 'UNIX file path', 'value': '(?:/[A-Za-z\\d.][A-Za-z\\d\\-.]{0,61})+'}, {'name': 'MAC address', 'value': '[A-Fa-f\\d]{2}(?:[:-][A-Fa-f\\d]{2}){5}'}, {'name': 'UUID', 'value': '[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}'}, {'name': 'Date (yyyy-mm-dd)', 'value': '((?:19|20)\\d\\d)[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])'}, {'name': 'Date (dd/mm/yyyy)', 'value': '(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.]((?:19|20)\\d\\d)'}, {'name': 'Date (mm/dd/yyyy)', 'value': '(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.]((?:19|20)\\d\\d)'}, {'name': 'Strings', 'value': '[A-Za-z\\d/\\-:.,_$%\\x27"()<>= !\\[\\]{}@]{4,}'}]`
  - **Regex** (text): default ``
  - **Case insensitive** (boolean): default `True`
  - **^ and $ match at newlines** (boolean): default `True`
  - **Dot matches all** (boolean): default `False`
  - **Unicode support** (boolean): default `False`
  - **Astral support** (boolean): default `False`
  - **Display total** (boolean): default `False`
  - **Output format** (option): `Highlight matches`, `List matches`, `List capture groups` (+1 more)

---

### `removeDiacritics()`

**Module:** Default

Replaces accented characters with their latin character equivalent. Accented characters are made up of Unicode combining characters, so unicode text formatting such as strikethroughs and underlines will also be removed.

[More info](https://wikipedia.org/wiki/Diacritic)

**Input:** `string` → **Output:** `string`

---

### `removeEXIF()`

**Module:** Image

Removes EXIF data from a JPEG image.



EXIF data embedded in photos usually contains information about the image file itself as well as the device used to create it.

[More info](https://wikipedia.org/wiki/Exif)

**Input:** `ArrayBuffer` → **Output:** `byteArray`

---

### `removeLineNumbers()`

**Module:** Default

Removes line numbers from the output if they can be trivially detected.

**Input:** `string` → **Output:** `string`

---

### `removeNullBytes()`

**Module:** Default

Removes all null bytes (`0x00`) from the input.

**Input:** `ArrayBuffer` → **Output:** `byteArray`

---

### `removeWhitespace()`

**Module:** Default

Optionally removes all spaces, carriage returns, line feeds, tabs and form feeds from the input data.

This operation also supports the removal of full stops which are sometimes used to represent non-printable bytes in ASCII output.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Spaces** (boolean): default `True`
  - **Carriage returns (\r)** (boolean): default `True`
  - **Line feeds (\n)** (boolean): default `True`
  - **Tabs** (boolean): default `True`
  - **Form feeds (\f)** (boolean): default `True`
  - **Full stops** (boolean): default `False`

---

### `renderImage()`

**Module:** Image

Displays the input as an image. Supports the following formats:

jpg/jpegpnggifwebpbmpico

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Input format** (option): `Raw`, `Base64`, `Hex`

---

### `renderMarkdown()`

**Module:** Code

Renders input Markdown as HTML. HTML rendering is disabled to avoid XSS.

[More info](https://wikipedia.org/wiki/Markdown)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Autoconvert URLs to links** (boolean): default `False`
  - **Enable syntax highlighting** (boolean): default `True`

---

### `resizeImage()`

**Module:** Image

Resizes an image to the specified width and height values.

[More info](https://wikipedia.org/wiki/Image_scaling)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Width** (number): default `100`
  - **Height** (number): default `100`
  - **Unit type** (option): `Pixels`, `Percent`
  - **Maintain aspect ratio** (boolean): default `False`
  - **Resizing algorithm** (option): `Nearest Neighbour`, `Bilinear`, `Bicubic` (+2 more)

---

### `reverse()`

**Module:** Default

Reverses the input string.

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **By** (option): `Byte`, `Character`, `Line`

---

### `risonDecode()`

**Module:** Encodings

Rison, a data serialization format optimized for compactness in URIs. Rison is a slight variation of JSON that looks vastly superior after URI encoding. Rison still expresses exactly the same set of data structures as JSON, so data can be translated back and forth without loss or guesswork.

[More info](https://github.com/Nanonid/rison)

**Input:** `string` → **Output:** `JSON`

**Arguments:**
  - **Decode Option** (editableOption): `Decode`, `Decode Object`, `Decode Array`

---

### `risonEncode()`

**Module:** Encodings

Rison, a data serialization format optimized for compactness in URIs. Rison is a slight variation of JSON that looks vastly superior after URI encoding. Rison still expresses exactly the same set of data structures as JSON, so data can be translated back and forth without loss or guesswork.

[More info](https://github.com/Nanonid/rison)

**Input:** `JSON` → **Output:** `string`

**Arguments:**
  - **Encode Option** (option): `Encode`, `Encode Object`, `Encode Array` (+1 more)

---

### `rotateImage()`

**Module:** Image

Rotates an image by the specified number of degrees.

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Rotation amount (degrees)** (number): default `90`

---

### `rotateLeft()`

**Module:** Default

Rotates each byte to the left by the number of bits specified, optionally carrying the excess bits over to the next byte. Currently only supports 8-bit values.

[More info](https://wikipedia.org/wiki/Bitwise_operation#Bit_shifts)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Amount** (number): default `1`
  - **Carry through** (boolean): default `False`

---

### `rotateRight()`

**Module:** Default

Rotates each byte to the right by the number of bits specified, optionally carrying the excess bits over to the next byte. Currently only supports 8-bit values.

[More info](https://wikipedia.org/wiki/Bitwise_operation#Bit_shifts)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Amount** (number): default `1`
  - **Carry through** (boolean): default `False`

---

### `salsa20()`

**Module:** Ciphers

Salsa20 is a stream cipher designed by Daniel J. Bernstein and submitted to the eSTREAM project; Salsa20/8 and Salsa20/12 are round-reduced variants. It is closely related to the ChaCha stream cipher.

Key: Salsa20 uses a key of 16 or 32 bytes (128 or 256 bits).

Nonce: Salsa20 uses a nonce of 8 bytes (64 bits).

Counter: Salsa uses a counter of 8 bytes (64 bits). The counter starts at zero at the start of the keystream, and is incremented at every 64 bytes.

[More info](https://wikipedia.org/wiki/Salsa20)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **Nonce** (toggleString): default ``
  - **Counter** (number): default `0`
  - **Rounds** (option): `20`, `12`, `8`
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `scanForEmbeddedFiles()`

**Module:** Default

Scans the data for potential embedded files by looking for magic bytes at all offsets. This operation is prone to false positives.

WARNING: Files over about 100KB in size will take a VERY long time to process.

[More info](https://wikipedia.org/wiki/List_of_file_signatures)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Images** (boolean): default `True`
  - **Video** (boolean): default `True`
  - **Audio** (boolean): default `True`
  - **Documents** (boolean): default `True`
  - **Applications** (boolean): default `True`
  - **Archives** (boolean): default `True`
  - **Miscellaneous** (boolean): default `False`

---

### `scatterChart()`

**Module:** Charts

Plots two-variable data as single points on a graph.

[More info](https://wikipedia.org/wiki/Scatter_plot)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Record delimiter** (option): `Line feed`, `CRLF`
  - **Field delimiter** (option): `Space`, `Comma`, `Semi-colon` (+2 more)
  - **Use column headers as labels** (boolean): default `True`
  - **X label** (string): default ``
  - **Y label** (string): default ``
  - **Colour** (string): default `black`
  - **Point radius** (number): default `10`
  - **Use colour from third column** (boolean): default `False`

---

### `scrypt()`

**Module:** Crypto

scrypt is a password-based key derivation function (PBKDF) created by Colin Percival. The algorithm was specifically designed to make it costly to perform large-scale custom hardware attacks by requiring large amounts of memory. In 2016, the scrypt algorithm was published by IETF as RFC 7914.

Enter the password in the input to generate its hash.

[More info](https://wikipedia.org/wiki/Scrypt)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Salt** (toggleString): default ``
  - **Iterations (N)** (number): default `16384`
  - **Memory factor (r)** (number): default `8`
  - **Parallelization factor (p)** (number): default `1`
  - **Key length** (number): default `64`

---

### `seriesChart()`

**Module:** Charts

A time series graph is a line graph of repeated measurements taken over regular time intervals.

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Record delimiter** (option): `Line feed`, `CRLF`
  - **Field delimiter** (option): `Space`, `Comma`, `Semi-colon` (+2 more)
  - **X label** (string): default ``
  - **Point radius** (number): default `1`
  - **Series colours** (string): default `mediumseagreen, dodgerblue, tomato`

---

### `setDifference()`

**Module:** Default

Calculates the difference, or relative complement, of two sets.

[More info](https://wikipedia.org/wiki/Complement_(set_theory)#Relative_complement)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`
  - **Item delimiter** (binaryString): default `,`

---

### `setIntersection()`

**Module:** Default

Calculates the intersection of two sets.

[More info](https://wikipedia.org/wiki/Intersection_(set_theory))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`
  - **Item delimiter** (binaryString): default `,`

---

### `setUnion()`

**Module:** Default

Calculates the union of two sets.

[More info](https://wikipedia.org/wiki/Union_(set_theory))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`
  - **Item delimiter** (binaryString): default `,`

---

### `shake()`

**Module:** Crypto

Shake is an Extendable Output Function (XOF) of the SHA-3 hash algorithm, part of the Keccak family, allowing for variable output length/size.

[More info](https://wikipedia.org/wiki/SHA-3#Instances)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Capacity** (option): `256`, `128`
  - **Size** (number): default `512`

---

### `sharpenImage()`

**Module:** Image

Sharpens an image (Unsharp mask)

[More info](https://wikipedia.org/wiki/Unsharp_masking)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Radius** (number): default `2`
  - **Amount** (number): default `1`
  - **Threshold** (number): default `10`

---

### `showBase64Offsets()`

**Module:** Default

When a string is within a block of data and the whole block is Base64'd, the string itself could be represented in Base64 in three distinct ways depending on its offset within the block.

This operation shows all possible offsets for a given string so that each possible encoding can be considered.

[More info](https://wikipedia.org/wiki/Base64#Output_padding)

**Input:** `byteArray` → **Output:** `html`

**Arguments:**
  - **Alphabet** (binaryString): default `A-Za-z0-9+/=`
  - **Show variable chars and padding** (boolean): default `True`
  - **Input format** (option): `Raw`, `Base64`

---

### `showOnMap()`

**Module:** Hashing

Displays co-ordinates on a slippy map.

Co-ordinates will be converted to decimal degrees before being shown on the map.

Supported formats:Degrees Minutes Seconds (DMS)Degrees Decimal Minutes (DDM)Decimal Degrees (DD)GeohashMilitary Grid Reference System (MGRS)Ordnance Survey National Grid (OSNG)Universal Transverse Mercator (UTM) This operation will not work offline.

[More info](https://osmfoundation.org/wiki/Terms_of_Use)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Zoom Level** (number): default `13`
  - **Input Format** (option): `Auto`, `Degrees Minutes Seconds`, `Degrees Decimal Minutes` (+5 more)
  - **Input Delimiter** (option): `Auto`, `Direction Preceding`, `Direction Following` (+4 more)

---

### `shuffle()`

**Module:** Default

Randomly reorders input elements.

[More info](https://wikipedia.org/wiki/Shuffling)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)

---

### `sleep()`

**Module:** Default

Sleep causes the recipe to wait for a specified number of milliseconds before continuing execution.

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Time (ms)** (number): default `1000`

---

### `snefru()`

**Module:** Crypto

Snefru is a cryptographic hash function invented by Ralph Merkle in 1990 while working at Xerox PARC. The function supports 128-bit and 256-bit output. It was named after the Egyptian Pharaoh Sneferu, continuing the tradition of the Khufu and Khafre block ciphers.

The original design of Snefru was shown to be insecure by Eli Biham and Adi Shamir who were able to use differential cryptanalysis to find hash collisions. The design was then modified by increasing the number of iterations of the main pass of the algorithm from two to eight.

[More info](https://wikipedia.org/wiki/Snefru)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Size** (number): default `128`
  - **Rounds** (option): `8`, `4`, `2`

---

### `sort()`

**Module:** Default

Alphabetically sorts strings separated by the specified delimiter.

The IP address option supports IPv4 only.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)
  - **Reverse** (boolean): default `False`
  - **Order** (option): `Alphabetical (case sensitive)`, `Alphabetical (case insensitive)`, `IP address` (+3 more)

---

### `split()`

**Module:** Default

Splits a string into sections around a given delimiter.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Split delimiter** (editableOptionShort): default `[{'name': 'Comma', 'value': ','}, {'name': 'Space', 'value': ' '}, {'name': 'Line feed', 'value': '\\n'}, {'name': 'CRLF', 'value': '\\r\\n'}, {'name': 'Semi-colon', 'value': ';'}, {'name': 'Colon', 'value': ':'}, {'name': 'Nothing (separate chars)', 'value': ''}]`
  - **Join delimiter** (editableOptionShort): default `[{'name': 'Line feed', 'value': '\\n'}, {'name': 'CRLF', 'value': '\\r\\n'}, {'name': 'Space', 'value': ' '}, {'name': 'Comma', 'value': ','}, {'name': 'Semi-colon', 'value': ';'}, {'name': 'Colon', 'value': ':'}, {'name': 'Nothing (join chars)', 'value': ''}]`

---

### `splitColourChannels()`

**Module:** Image

Splits the given image into its red, green and blue colour channels.

[More info](https://wikipedia.org/wiki/Channel_(digital_image))

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `standardDeviation()`

**Module:** Default

Computes the standard deviation of a number list. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 .5` becomes `4.089281382128433`

[More info](https://wikipedia.org/wiki/Standard_deviation)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `streebog()`

**Module:** Hashing

Streebog is a cryptographic hash function defined in the Russian national standard GOST R 34.11-2012 Information Technology – Cryptographic Information Security – Hash Function. It was created to replace an obsolete GOST hash function defined in the old standard GOST R 34.11-94, and as an asymmetric reply to SHA-3 competition by the US National Institute of Standards and Technology.

[More info](https://wikipedia.org/wiki/Streebog)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Digest length** (option): `256`, `512`

---

### `strings()`

**Module:** Regex

Extracts all strings from the input.

[More info](https://wikipedia.org/wiki/Strings_(Unix))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Encoding** (option): `Single byte`, `16-bit littleendian`, `16-bit bigendian` (+1 more)
  - **Minimum length** (number): default `4`
  - **Match** (option): `[ASCII]`, `Alphanumeric + punctuation (A)`, `All printable chars (A)` (+5 more)
  - **Display total** (boolean): default `False`
  - **Sort** (boolean): default `False`
  - **Unique** (boolean): default `False`

---

### `stripHTMLTags()`

**Module:** Default

Removes all HTML tags from the input.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Remove indentation** (boolean): default `True`
  - **Remove excess line breaks** (boolean): default `True`

---

### `stripHTTPHeaders()`

**Module:** Default

Removes HTTP headers from a request or response by looking for the first instance of a double newline.

[More info](https://wikipedia.org/wiki/Hypertext_Transfer_Protocol#Message_format)

**Input:** `string` → **Output:** `string`

---

### `stripIPv4Header()`

**Module:** Default

Strips the IPv4 header from an IPv4 packet, outputting the payload.

[More info](https://wikipedia.org/wiki/IPv4)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `stripTCPHeader()`

**Module:** Default

Strips the TCP header from a TCP segment, outputting the payload.

[More info](https://wikipedia.org/wiki/Transmission_Control_Protocol)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `stripUDPHeader()`

**Module:** Default

Strips the UDP header from a UDP datagram, outputting the payload.

[More info](https://wikipedia.org/wiki/User_Datagram_Protocol)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

---

### `subsection()`

**Module:** Default

Select a part of the input data using a regular expression (regex), and run all subsequent operations on each match separately.

You can use up to one capture group, where the recipe will only be run on the data in the capture group. If there's more than one capture group, only the first one will be operated on.

Use the Merge operation to reset the effects of subsection.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Section (regex)** (string): default ``
  - **Case sensitive matching** (boolean): default `True`
  - **Global matching** (boolean): default `True`
  - **Ignore errors** (boolean): default `False`

---

### `substitute()`

**Module:** Default

A substitution cipher allowing you to specify bytes to replace with other byte values. This can be used to create Caesar ciphers but is more powerful as any byte value can be substituted, not just letters, and the substitution values need not be in order.

Enter the bytes you want to replace in the Plaintext field and the bytes to replace them with in the Ciphertext field.

Non-printable bytes can be specified using string escape notation. For example, a line feed character can be written as either `\n` or `\x0a`.

Byte ranges can be specified using a hyphen. For example, the sequence `0123456789` can be written as `0-9`.

Note that blackslash characters are used to escape special characters, so will need to be escaped themselves if you want to use them on their own (e.g.`\\`).

[More info](https://wikipedia.org/wiki/Substitution_cipher)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Plaintext** (binaryString): default `ABCDEFGHIJKLMNOPQRSTUVWXYZ`
  - **Ciphertext** (binaryString): default `XYZABCDEFGHIJKLMNOPQRSTUVW`
  - **Ignore case** (boolean): default `False`

---

### `subtract()`

**Module:** Default

Subtracts a list of numbers. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 .5` becomes `1.5`

[More info](https://wikipedia.org/wiki/Subtraction)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `sum()`

**Module:** Default

Adds together a list of numbers. If an item in the string is not a number it is excluded from the list.

e.g. `0x0a 8 .5` becomes `18.5`

[More info](https://wikipedia.org/wiki/Summation)

**Input:** `string` → **Output:** `BigNumber`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `Space`, `Comma` (+3 more)

---

### `swapCase()`

**Module:** Default

Converts uppercase letters to lowercase ones, and lowercase ones to uppercase ones.

**Input:** `string` → **Output:** `string`

---

### `swapEndianness()`

**Module:** Default

Switches the data from big-endian to little-endian or vice-versa. Data can be read in as hexadecimal or raw bytes. It will be returned in the same format as it is entered.

[More info](https://wikipedia.org/wiki/Endianness)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Data format** (option): `Hex`, `Raw`
  - **Word length (bytes)** (number): default `4`
  - **Pad incomplete words** (boolean): default `True`

---

### `symmetricDifference()`

**Module:** Default

Calculates the symmetric difference of two sets.

[More info](https://wikipedia.org/wiki/Symmetric_difference)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Sample delimiter** (binaryString): default `\n\n`
  - **Item delimiter** (binaryString): default `,`

---

### `syntaxHighlighter()`

**Module:** Code

Adds syntax highlighting to a range of source code languages. Note that this will not indent the code. Use one of the 'Beautify' operations for that.

[More info](https://wikipedia.org/wiki/Syntax_highlighting)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Language** (option): `auto detect`, `1c`, `abnf` (+190 more)

---

### `tail()`

**Module:** Default

Like the UNIX tail utility. Gets the last n lines. Optionally you can select all lines after line n by entering a negative value for n. The delimiter can be changed so that instead of lines, fields (i.e. commas) are selected instead.

[More info](https://wikipedia.org/wiki/Tail_(Unix))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)
  - **Number** (number): default `10`

---

### `takeBytes()`

**Module:** Default

Takes a slice of the specified number of bytes from the data. Negative values are allowed.

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Start** (number): default `0`
  - **Length** (number): default `5`
  - **Apply to each line** (boolean): default `False`

---

### `takeNthBytes()`

**Module:** Default

Takes every nth byte starting with a given byte.

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Take every** (number): default `4`
  - **Starting at** (number): default `0`
  - **Apply to each line** (boolean): default `False`

---

### `tar()`

**Module:** Compression

Packs the input into a tarball.

No support for multiple files at this time.

[More info](https://wikipedia.org/wiki/Tar_(computing))

**Input:** `ArrayBuffer` → **Output:** `File`

**Arguments:**
  - **Filename** (string): default `file.txt`

---

### `template()`

**Module:** Handlebars

Render a template with Handlebars/Mustache substituting variables using JSON input. Templates will be rendered to plain-text only, to prevent XSS.

[More info](https://handlebarsjs.com/)

**Input:** `JSON` → **Output:** `string`

**Arguments:**
  - **Template definition (.handlebars)** (text): default ``

---

### `textEncodingBruteForce()`

**Module:** Encodings

Enumerates all supported text encodings for the input, allowing you to quickly spot the correct one.



Supported charsets are:

UTF-8 (65001)
UTF-7 (65000)
UTF-16LE (1200)
UTF-16BE (1201)
UTF-32LE (12000)
UTF-32BE (12001)
IBM EBCDIC International (500)
IBM EBCDIC US-Canada (37)
IBM EBCDIC Multilingual/ROECE (Latin 2) (870)
IBM EBCDIC Greek Modern (875)
IBM EBCDIC French (1010)
IBM EBCDIC Turkish (Latin 5) (1026)
IBM EBCDIC Latin 1/Open System (1047)
IBM EBCDIC Lao (1132/1133/1341)
IBM EBCDIC US-Canada (037 + Euro symbol) (1140)
IBM EBCDIC Germany (20273 + Euro symbol) (1141)
IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)
IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)
IBM EBCDIC Italy (20280 + Euro symbol) (1144)
IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)
IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)
IBM EBCDIC France (20297 + Euro symbol) (1147)
IBM EBCDIC International (500 + Euro symbol) (1148)
IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)
IBM EBCDIC Germany (20273)
IBM EBCDIC Denmark-Norway (20277)
IBM EBCDIC Finland-Sweden (20278)
IBM EBCDIC Italy (20280)
IBM EBCDIC Latin America-Spain (20284)
IBM EBCDIC United Kingdom (20285)
IBM EBCDIC Japanese Katakana Extended (20290)
IBM EBCDIC France (20297)
IBM EBCDIC Arabic (20420)
IBM EBCDIC Greek (20423)
IBM EBCDIC Hebrew (20424)
IBM EBCDIC Korean Extended (20833)
IBM EBCDIC Thai (20838)
IBM EBCDIC Icelandic (20871)
IBM EBCDIC Cyrillic Russian (20880)
IBM EBCDIC Turkish (20905)
IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)
IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)
OEM United States (437)
OEM Greek (formerly 437G); Greek (DOS) (737)
OEM Baltic; Baltic (DOS) (775)
OEM Russian; Cyrillic + Euro symbol (808)
OEM Multilingual Latin 1; Western European (DOS) (850)
OEM Latin 2; Central European (DOS) (852)
OEM Cyrillic (primarily Russian) (855)
OEM Turkish; Turkish (DOS) (857)
OEM Multilingual Latin 1 + Euro symbol (858)
OEM Portuguese; Portuguese (DOS) (860)
OEM Icelandic; Icelandic (DOS) (861)
OEM Hebrew; Hebrew (DOS) (862)
OEM French Canadian; French Canadian (DOS) (863)
OEM Arabic; Arabic (864) (864)
OEM Nordic; Nordic (DOS) (865)
OEM Russian; Cyrillic (DOS) (866)
OEM Modern Greek; Greek, Modern (DOS) (869)
OEM Cyrillic (primarily Russian) + Euro Symbol (872)
Windows-874 Thai (874)
Windows-1250 Central European (1250)
Windows-1251 Cyrillic (1251)
Windows-1252 Latin (1252)
Windows-1253 Greek (1253)
Windows-1254 Turkish (1254)
Windows-1255 Hebrew (1255)
Windows-1256 Arabic (1256)
Windows-1257 Baltic (1257)
Windows-1258 Vietnam (1258)
ISO-8859-1 Latin 1 Western European (28591)
ISO-8859-2 Latin 2 Central European (28592)
ISO-8859-3 Latin 3 South European (28593)
ISO-8859-4 Latin 4 North European (28594)
ISO-8859-5 Latin/Cyrillic (28595)
ISO-8859-6 Latin/Arabic (28596)
ISO-8859-7 Latin/Greek (28597)
ISO-8859-8 Latin/Hebrew (28598)
ISO 8859-8 Hebrew (ISO-Logical) (38598)
ISO-8859-9 Latin 5 Turkish (28599)
ISO-8859-10 Latin 6 Nordic (28600)
ISO-8859-11 Latin/Thai (28601)
ISO-8859-13 Latin 7 Baltic Rim (28603)
ISO-8859-14 Latin 8 Celtic (28604)
ISO-8859-15 Latin 9 (28605)
ISO-8859-16 Latin 10 (28606)
ISO 2022 JIS Japanese with no halfwidth Katakana (50220)
ISO 2022 JIS Japanese with halfwidth Katakana (50221)
ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)
ISO 2022 Korean (50225)
ISO 2022 Simplified Chinese (50227)
ISO 6937 Non-Spacing Accent (20269)
EUC Japanese (51932)
EUC Simplified Chinese (51936)
EUC Korean (51949)
ISCII Devanagari (57002)
ISCII Bengali (57003)
ISCII Tamil (57004)
ISCII Telugu (57005)
ISCII Assamese (57006)
ISCII Oriya (57007)
ISCII Kannada (57008)
ISCII Malayalam (57009)
ISCII Gujarati (57010)
ISCII Punjabi (57011)
Japanese Shift-JIS (932)
Simplified Chinese GBK (936)
Korean (949)
Traditional Chinese Big5 (950)
US-ASCII (7-bit) (20127)
Simplified Chinese GB2312 (20936)
KOI8-R Russian Cyrillic (20866)
KOI8-U Ukrainian Cyrillic (21866)
Mazovia (Polish) MS-DOS (620)
Arabic (ASMO 708) (708)
Arabic (Transparent ASMO); Arabic (DOS) (720)
Kamenický (Czech) MS-DOS (895)
Korean (Johab) (1361)
MAC Roman (10000)
Japanese (Mac) (10001)
MAC Traditional Chinese (Big5) (10002)
Korean (Mac) (10003)
Arabic (Mac) (10004)
Hebrew (Mac) (10005)
Greek (Mac) (10006)
Cyrillic (Mac) (10007)
MAC Simplified Chinese (GB 2312) (10008)
Romanian (Mac) (10010)
Ukrainian (Mac) (10017)
Thai (Mac) (10021)
MAC Latin 2 (Central European) (10029)
Icelandic (Mac) (10079)
Turkish (Mac) (10081)
Croatian (Mac) (10082)
CNS Taiwan (Chinese Traditional) (20000)
TCA Taiwan (20001)
ETEN Taiwan (Chinese Traditional) (20002)
IBM5550 Taiwan (20003)
TeleText Taiwan (20004)
Wang Taiwan (20005)
Western European IA5 (IRV International Alphabet 5) (20105)
IA5 German (7-bit) (20106)
IA5 Swedish (7-bit) (20107)
IA5 Norwegian (7-bit) (20108)
T.61 (20261)
Japanese (JIS 0208-1990 and 0212-1990) (20932)
Korean Wansung (20949)
Extended/Ext Alpha Lowercase (21027)
Europa 3 (29001)
Atari ST/TT (47451)
HZ-GB2312 Simplified Chinese (52936)
Simplified Chinese GB18030 (54936)

[More info](https://wikipedia.org/wiki/Character_encoding)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Mode** (option): `Encode`, `Decode`

---

### `toBCD()`

**Module:** Default

Binary-Coded Decimal (BCD) is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four or eight. Special bit patterns are sometimes used for a sign

[More info](https://wikipedia.org/wiki/Binary-coded_decimal)

**Input:** `BigNumber` → **Output:** `string`

**Arguments:**
  - **Scheme** (option): `8 4 2 1`, `7 4 2 1`, `4 2 2 1` (+4 more)
  - **Packed** (boolean): default `True`
  - **Signed** (boolean): default `False`
  - **Output format** (option): `Nibbles`, `Bytes`, `Raw`

---

### `toBase()`

**Module:** Default

Converts a decimal number to a given numerical base.

[More info](https://wikipedia.org/wiki/Radix)

**Input:** `BigNumber` → **Output:** `string`

**Arguments:**
  - **Radix** (number): default `36`

---

### `toBase32()`

**Module:** Default

Base32 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. It uses a smaller set of characters than Base64, usually the uppercase alphabet and the numbers 2 to 7.

[More info](https://wikipedia.org/wiki/Base32)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Alphabet** (editableOption): `Standard`, `Hex Extended`

---

### `toBase45()`

**Module:** Default

Base45 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system. Base45 is optimized for usage with QR codes.

[More info](https://wikipedia.org/wiki/List_of_numeral_systems)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Alphabet** (string): default `0-9A-Z $%*+\-./:`

---

### `toBase58()`

**Module:** Default

Base58 (similar to Base64) is a notation for encoding arbitrary byte data. It differs from Base64 by removing easily misread characters (i.e. l, I, 0 and O) to improve human readability.

This operation encodes data in an ASCII string (with an alphabet of your choosing, presets included).

e.g. `hello world` becomes `StV1DL6CwTryKyV`

Base58 is commonly used in cryptocurrencies (Bitcoin, Ripple, etc).

[More info](https://wikipedia.org/wiki/Base58)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Alphabet** (editableOption): `Bitcoin`, `Ripple`

---

### `toBase62()`

**Module:** Default

Base62 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system.

[More info](https://wikipedia.org/wiki/List_of_numeral_systems)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Alphabet** (string): default `0-9A-Za-z`

---

### `toBase64()`

**Module:** Default

Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.

This operation encodes raw data into an ASCII Base64 string.

e.g. `hello` becomes `aGVsbG8=`

[More info](https://wikipedia.org/wiki/Base64)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Alphabet** (editableOption): `Standard (RFC 4648): A-Za-z0-9+/=`, `URL safe (RFC 4648 §5): A-Za-z0-9-_`, `Filename safe: A-Za-z0-9+-=` (+14 more)

---

### `toBase85()`

**Module:** Default

Base85 (also called Ascii85) is a notation for encoding arbitrary byte data. It is usually more efficient that Base64.

This operation encodes data in an ASCII string (with an alphabet of your choosing, presets included).

e.g. `hello world` becomes `BOu!rD]j7BEbo7`

Base85 is commonly used in Adobe's PostScript and PDF file formats.

Options AlphabetStandard - The standard alphabet, referred to as Ascii85Z85 (ZeroMQ) - A string-safe variant of Base85, which avoids quote marks and backslash charactersIPv6 - A variant of Base85 suitable for encoding IPv6 addresses (RFC 1924)Include delimiter Adds a '' delimiter to the start and end of the data. This is standard for Adobe's implementation of Base85.

[More info](https://wikipedia.org/wiki/Ascii85)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Alphabet** (editableOption): `Standard`, `Z85 (ZeroMQ)`, `IPv6`
  - **Include delimeter** (boolean): default `False`

---

### `toBase92()`

**Module:** Default

Base92 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.

[More info](https://wikipedia.org/wiki/List_of_numeral_systems)

**Input:** `string` → **Output:** `byteArray`

---

### `toBinary()`

**Module:** Default

Displays the input data as a binary string.

e.g. `Hi` becomes `01001000 01101001`

[More info](https://wikipedia.org/wiki/Binary_code)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+4 more)
  - **Byte Length** (number): default `8`

---

### `toBraille()`

**Module:** Default

Converts text to six-dot braille symbols.

[More info](https://wikipedia.org/wiki/Braille)

**Input:** `string` → **Output:** `string`

---

### `toCamelCase()`

**Module:** Code

Converts the input string to camel case.



Camel case is all lower case except letters after word boundaries which are uppercase.



e.g. thisIsCamelCase



'Attempt to be context aware' will make the operation attempt to nicely transform variable and function names.

[More info](https://wikipedia.org/wiki/Camel_case)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Attempt to be context aware** (boolean): default `False`

---

### `toCaseInsensitiveRegex()`

**Module:** Default

Converts a case-sensitive regex string into a case-insensitive regex string in case the i flag is unavailable to you.

e.g. `Mozilla/[0-9].[0-9] .*` becomes `[mM][oO][zZ][iI][lL][lL][aA]/[0-9].[0-9] .*`

[More info](https://wikipedia.org/wiki/Regular_expression)

**Input:** `string` → **Output:** `string`

---

### `toCharcode()`

**Module:** Default

Converts text to its unicode character code equivalent.

e.g. `Γειά σου` becomes `0393 03b5 03b9 03ac 20 03c3 03bf 03c5`

[More info](https://wikipedia.org/wiki/Plane_(Unicode))

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)
  - **Base** (number): default `16`

---

### `toDecimal()`

**Module:** Default

Converts the input data to an ordinal integer array.

e.g. `Hello` becomes `72 101 108 108 111`

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)
  - **Support signed values** (boolean): default `False`

---

### `toFloat()`

**Module:** Default

Convert to IEEE754 Floating Point Numbers

[More info](https://wikipedia.org/wiki/IEEE_754)

**Input:** `byteArray` → **Output:** `string`

**Arguments:**
  - **Endianness** (option): `Big Endian`, `Little Endian`
  - **Size** (option): `Float (4 bytes)`, `Double (8 bytes)`
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)

---

### `toHTMLEntity()`

**Module:** Encodings

Converts characters to HTML entities

e.g. `&amp;` becomes `&amp;amp;`

[More info](https://wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Convert all characters** (boolean): default `False`
  - **Convert to** (option): `Named entities`, `Numeric entities`, `Hex entities`

---

### `toHex()`

**Module:** Default

Converts the input string to hexadecimal bytes separated by the specified delimiter.

e.g. The UTF-8 encoded string `Γειά σου` becomes `ce 93 ce b5 ce b9 ce ac 20 cf 83 ce bf cf 85 0a`

[More info](https://wikipedia.org/wiki/Hexadecimal)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Percent`, `Comma` (+8 more)
  - **Bytes per line** (number): default `0`

---

### `toHexContent()`

**Module:** Default

Converts special characters in a string to hexadecimal. This format is used by SNORT for representing hex within ASCII text.

e.g. `foo=bar` becomes `foo|3d|bar`.

[More info](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html#SECTION00451000000000000000)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Convert** (option): `Only special chars`, `Only special chars including spaces`, `All chars`
  - **Print spaces between bytes** (boolean): default `False`

---

### `toHexdump()`

**Module:** Default

Creates a hexdump of the input data, displaying both the hexadecimal values of each byte and an ASCII representation alongside.

The 'UNIX format' argument defines which subset of printable characters are displayed in the preview column.

[More info](https://wikipedia.org/wiki/Hex_dump)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Width** (number): default `16`
  - **Upper case hex** (boolean): default `False`
  - **Include final length** (boolean): default `False`
  - **UNIX format** (boolean): default `False`

---

### `toKebabCase()`

**Module:** Code

Converts the input string to kebab case.



Kebab case is all lower case with dashes as word boundaries.



e.g. this-is-kebab-case



'Attempt to be context aware' will make the operation attempt to nicely transform variable and function names.

[More info](https://wikipedia.org/wiki/Kebab_case)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Attempt to be context aware** (boolean): default `False`

---

### `toLowerCase()`

**Module:** Default

Converts every character in the input to lower case.

**Input:** `string` → **Output:** `string`

---

### `toMessagePack()`

**Module:** Code

Converts JSON to MessagePack encoded byte buffer. MessagePack is a computer data interchange format. It is a binary form for representing simple data structures like arrays and associative arrays.

[More info](https://wikipedia.org/wiki/MessagePack)

**Input:** `JSON` → **Output:** `ArrayBuffer`

---

### `toModhex()`

**Module:** Default

Converts the input string to modhex bytes separated by the specified delimiter.

[More info](https://en.wikipedia.org/wiki/YubiKey#ModHex)

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Percent`, `Comma` (+5 more)
  - **Bytes per line** (number): default `0`

---

### `toMorseCode()`

**Module:** Default

Translates alphanumeric characters into International Morse Code.

Ignores non-Morse characters.

e.g. `SOS` becomes `... --- ...`

[More info](https://wikipedia.org/wiki/Morse_code)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Format options** (option): `-/.`, `_/.`, `Dash/Dot` (+2 more)
  - **Letter delimiter** (option): `Space`, `Line feed`, `CRLF` (+5 more)
  - **Word delimiter** (option): `Line feed`, `CRLF`, `Forward slash` (+4 more)

---

### `toOctal()`

**Module:** Default

Converts the input string to octal bytes separated by the specified delimiter.

e.g. The UTF-8 encoded string `Γειά σου` becomes `316 223 316 265 316 271 316 254 40 317 203 316 277 317 205`

[More info](https://wikipedia.org/wiki/Octal)

**Input:** `byteArray` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Space`, `Comma`, `Semi-colon` (+3 more)

---

### `toPunycode()`

**Module:** Encodings

Punycode is a way to represent Unicode with the limited character subset of ASCII supported by the Domain Name System.

e.g. `münchen` encodes to `mnchen-3ya`

[More info](https://wikipedia.org/wiki/Punycode)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Internationalised domain name** (boolean): default `False`

---

### `toQuotedPrintable()`

**Module:** Default

Quoted-Printable, or QP encoding, is an encoding using printable ASCII characters (alphanumeric and the equals sign '=') to transmit 8-bit data over a 7-bit data path or, generally, over a medium which is not 8-bit clean. It is defined as a MIME content transfer encoding for use in e-mail.

QP works by using the equals sign '=' as an escape character. It also limits line length to 76, as some software has limits on line length.

[More info](https://wikipedia.org/wiki/Quoted-printable)

**Input:** `ArrayBuffer` → **Output:** `string`

---

### `toSnakeCase()`

**Module:** Code

Converts the input string to snake case.



Snake case is all lower case with underscores as word boundaries.



e.g. this_is_snake_case



'Attempt to be context aware' will make the operation attempt to nicely transform variable and function names.

[More info](https://wikipedia.org/wiki/Snake_case)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Attempt to be context aware** (boolean): default `False`

---

### `toTable()`

**Module:** Default

Data can be split on different characters and rendered as an HTML, ASCII or Markdown table with an optional header row.

Supports the CSV (Comma Separated Values) file format by default. Change the cell delimiter argument to `\t` to support TSV (Tab Separated Values) or `|` for PSV (Pipe Separated Values).

You can enter as many delimiters as you like. Each character will be treat as a separate possible delimiter.

[More info](https://wikipedia.org/wiki/Comma-separated_values)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Cell delimiters** (binaryShortString): default `,`
  - **Row delimiters** (binaryShortString): default `\r\n`
  - **Make first row header** (boolean): default `False`
  - **Format** (option): `ASCII`, `HTML`, `Markdown`

---

### `toUNIXTimestamp()`

**Module:** Default

Parses a datetime string in UTC and returns the corresponding UNIX timestamp.

e.g. `Mon 1 January 2001 11:00:00` becomes `978346800`

A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).

[More info](https://wikipedia.org/wiki/Unix_time)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Units** (option): `Seconds (s)`, `Milliseconds (ms)`, `Microseconds (μs)` (+1 more)
  - **Treat as UTC** (boolean): default `True`
  - **Show parsed datetime** (boolean): default `True`

---

### `toUpperCase()`

**Module:** Default

Converts the input string to upper case, optionally limiting scope to only the first character in each word, sentence or paragraph.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Scope** (option): `All`, `Word`, `Sentence` (+1 more)

---

### `translateDateTimeFormat()`

**Module:** Default

Parses a datetime string in one format and re-writes it in another.

Run with no input to see the relevant format string examples.

[More info](https://momentjs.com/docs/#/parsing/string-format/)

**Input:** `string` → **Output:** `html`

**Arguments:**
  - **Built in formats** (populateOption): default `[{'name': 'Standard date and time', 'value': 'DD/MM/YYYY HH:mm:ss'}, {'name': 'American-style date and time', 'value': 'MM/DD/YYYY HH:mm:ss'}, {'name': 'International date and time', 'value': 'YYYY-MM-DD HH:mm:ss'}, {'name': 'Verbose date and time', 'value': 'dddd Do MMMM YYYY HH:mm:ss Z z'}, {'name': 'UNIX timestamp (seconds)', 'value': 'X'}, {'name': 'UNIX timestamp offset (milliseconds)', 'value': 'x'}, {'name': 'Automatic', 'value': ''}]`
  - **Input format string** (binaryString): default `DD/MM/YYYY HH:mm:ss`
  - **Input timezone** (option): `UTC`, `Africa/Abidjan`, `Africa/Accra` (+594 more)
  - **Output format string** (binaryString): default `dddd Do MMMM YYYY HH:mm:ss Z z`
  - **Output timezone** (option): `UTC`, `Africa/Abidjan`, `Africa/Accra` (+594 more)

---

### `tripleDESDecrypt()`

**Module:** Ciphers

Triple DES applies DES three times to each block to increase key size.

Key: Triple DES uses a key length of 24 bytes (192 bits).

IV: The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.

Padding: In CBC and ECB mode, PKCS#7 padding will be used as a default.

[More info](https://wikipedia.org/wiki/Triple_DES)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+4 more)
  - **Input** (option): `Hex`, `Raw`
  - **Output** (option): `Raw`, `Hex`

---

### `tripleDESEncrypt()`

**Module:** Ciphers

Triple DES applies DES three times to each block to increase key size.

Key: Triple DES uses a key length of 24 bytes (192 bits).

You can generate a password-based key using one of the KDF operations.

IV: The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.

Padding: In CBC and ECB mode, PKCS#7 padding will be used.

[More info](https://wikipedia.org/wiki/Triple_DES)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Key** (toggleString): default ``
  - **IV** (toggleString): default ``
  - **Mode** (option): `CBC`, `CFB`, `OFB` (+2 more)
  - **Input** (option): `Raw`, `Hex`
  - **Output** (option): `Hex`, `Raw`

---

### `typex()`

**Module:** Bletchley

Encipher/decipher with the WW2 Typex machine.

Typex was originally built by the British Royal Air Force prior to WW2, and is based on the Enigma machine with some improvements made, including using five rotors with more stepping points and interchangeable wiring cores. It was used across the British and Commonwealth militaries. A number of later variants were produced; here we simulate a WW2 era Mark 22 Typex with plugboards for the reflector and input. Typex rotors were changed regularly and none are public: a random example set are provided.

To configure the reflector plugboard, enter a string of connected pairs of letters in the reflector box, e.g. `AB CD EF` connects A to B, C to D, and E to F (you'll need to connect every letter). There is also an input plugboard: unlike Enigma's plugboard, it's not restricted to pairs, so it's entered like a rotor (without stepping). To create your own rotor, enter the letters that the rotor maps A to Z to, in order, optionally followed by `&lt;` then a list of stepping points.

More detailed descriptions of the Enigma, Typex and Bombe operations can be found here.

[More info](https://wikipedia.org/wiki/Typex)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **1st (left-hand) rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+5 more)
  - **1st rotor reversed** (boolean): default `False`
  - **1st rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **1st rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **2nd rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+5 more)
  - **2nd rotor reversed** (boolean): default `False`
  - **2nd rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **2nd rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **3rd (middle) rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+5 more)
  - **3rd rotor reversed** (boolean): default `False`
  - **3rd rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **3rd rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **4th (static) rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+5 more)
  - **4th rotor reversed** (boolean): default `False`
  - **4th rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **4th rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **5th (right-hand, static) rotor** (editableOption): `Example 1`, `Example 2`, `Example 3` (+5 more)
  - **5th rotor reversed** (boolean): default `False`
  - **5th rotor ring setting** (option): `A`, `B`, `C` (+23 more)
  - **5th rotor initial value** (option): `A`, `B`, `C` (+23 more)
  - **Reflector** (editableOption): `Example`
  - **Plugboard** (string): default ``
  - **Typex keyboard emulation** (option): `None`, `Encrypt`, `Decrypt`
  - **Strict output** (boolean): default `True`

---

### `unescapeString()`

**Module:** Default

Unescapes characters in a string that have been escaped. For example, `Don\'t stop me now` becomes `Don't stop me now`.

Supports the following escape sequences:`\n` (Line feed/newline)`\r` (Carriage return)`\t` (Horizontal tab)`\b` (Backspace)`\f` (Form feed)`\nnn` (Octal, where n is 0-7)`\xnn` (Hex, where n is 0-f)`\\` (Backslash)`\'` (Single quote)`\&quot;` (Double quote)`\unnnn` (Unicode character)`\u{nnnnnn}` (Unicode code point)

[More info](https://wikipedia.org/wiki/Escape_sequence)

**Input:** `string` → **Output:** `string`

---

### `unescapeUnicodeCharacters()`

**Module:** Default

Converts unicode-escaped character notation back into raw characters.

Supports the prefixes:`\u``%u``U+`e.g. `\u03c3\u03bf\u03c5` becomes `σου`

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Prefix** (option): `\u`, `%u`, `U+`

---

### `unicodeTextFormat()`

**Module:** Default

Adds Unicode combining characters to change formatting of plaintext.

[More info](https://wikipedia.org/wiki/Combining_character)

**Input:** `byteArray` → **Output:** `byteArray`

**Arguments:**
  - **Underline** (boolean): default `false`
  - **Strikethrough** (boolean): default `false`

---

### `unique()`

**Module:** Default

Removes duplicate strings from the input.

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Delimiter** (option): `Line feed`, `CRLF`, `Space` (+4 more)
  - **Display count** (boolean): default `False`

---

### `untar()`

**Module:** Compression

Unpacks a tarball and displays it per file.

[More info](https://wikipedia.org/wiki/Tar_(computing))

**Input:** `ArrayBuffer` → **Output:** `html`

---

### `unzip()`

**Module:** Compression

Decompresses data using the PKZIP algorithm and displays it per file, with support for passwords.

[More info](https://wikipedia.org/wiki/Zip_(file_format))

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Password** (binaryString): default ``
  - **Verify result** (boolean): default `False`

---

### `varIntDecode()`

**Module:** Default

Decodes a VarInt encoded integer. VarInt is an efficient way of encoding variable length integers and is commonly used with Protobuf.

[More info](https://developers.google.com/protocol-buffers/docs/encoding#varints)

**Input:** `byteArray` → **Output:** `string`

---

### `varIntEncode()`

**Module:** Default

Encodes a Vn integer as a VarInt. VarInt is an efficient way of encoding variable length integers and is commonly used with Protobuf.

[More info](https://developers.google.com/protocol-buffers/docs/encoding#varints)

**Input:** `string` → **Output:** `byteArray`

---

### `viewBitPlane()`

**Module:** Image

Extracts and displays a bit plane of any given image. These show only a single bit from each pixel, and can be used to hide messages in Steganography.

[More info](https://wikipedia.org/wiki/Bit_plane)

**Input:** `ArrayBuffer` → **Output:** `html`

**Arguments:**
  - **Colour** (option): `Red`, `Green`, `Blue` (+1 more)
  - **Bit** (number): default `0`

---

### `whirlpool()`

**Module:** Crypto

Whirlpool is a cryptographic hash function designed by Vincent Rijmen (co-creator of AES) and Paulo S. L. M. Barreto, who first described it in 2000.

Several variants exist:Whirlpool-0 is the original version released in 2000.Whirlpool-T is the first revision, released in 2001, improving the generation of the s-box.Whirlpool is the latest revision, released in 2003, fixing a flaw in the diffusion matrix.

[More info](https://wikipedia.org/wiki/Whirlpool_(cryptography))

**Input:** `ArrayBuffer` → **Output:** `string`

**Arguments:**
  - **Variant** (option): `Whirlpool`, `Whirlpool-T`, `Whirlpool-0`
  - **Rounds** (number): default `10`

---

### `windowsFiletimeToUNIXTimestamp()`

**Module:** Default

Converts a Windows Filetime value to a UNIX timestamp.

A Windows Filetime is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 UTC.

A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).

This operation also supports UNIX timestamps in milliseconds, microseconds and nanoseconds.

[More info](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284(v=vs.85).aspx)

**Input:** `string` → **Output:** `string`

**Arguments:**
  - **Output units** (option): `Seconds (s)`, `Milliseconds (ms)`, `Microseconds (μs)` (+1 more)
  - **Input format** (option): `Decimal`, `Hex (big endian)`, `Hex (little endian)`

---

### `zip()`

**Module:** Compression

Compresses data using the PKZIP algorithm with the given filename.

No support for multiple files at this time.

[More info](https://wikipedia.org/wiki/Zip_(file_format))

**Input:** `ArrayBuffer` → **Output:** `File`

**Arguments:**
  - **Filename** (string): default `file.txt`
  - **Comment** (string): default ``
  - **Password** (binaryString): default ``
  - **Compression method** (option): `Deflate`, `None (Store)`
  - **Operating system** (option): `MSDOS`, `Unix`, `Macintosh`
  - **Compression type** (option): `Dynamic Huffman Coding`, `Fixed Huffman Coding`, `None (Store)`

---

### `zlibDeflate()`

**Module:** Compression

Compresses data using the deflate algorithm adding zlib headers.

[More info](https://wikipedia.org/wiki/Zlib)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Compression type** (option): `Dynamic Huffman Coding`, `Fixed Huffman Coding`, `None (Store)`

---

### `zlibInflate()`

**Module:** Compression

Decompresses data which has been compressed using the deflate algorithm with zlib headers.

[More info](https://wikipedia.org/wiki/Zlib)

**Input:** `ArrayBuffer` → **Output:** `ArrayBuffer`

**Arguments:**
  - **Start index** (number): default `0`
  - **Initial output buffer size** (number): default `0`
  - **Buffer expansion type** (option): `Adaptive`, `Block`
  - **Resize buffer after decompression** (boolean): default `False`
  - **Verify result** (boolean): default `False`

---

```

`entrypoint.py`:

```py
import logging

import ida_kernwin

logger = logging.getLogger(__name__)

MIN_KERNEL_VERSION = (9, 2)


cyberchef_ok = True

try:
    from PySide6 import QtCore  # noqa: F401
except ImportError:
    logger.warning("no PySide6, skipping")
    cyberchef_ok = False

kernel_version_str = ida_kernwin.get_kernel_version()
parts = [int(part) for part in kernel_version_str.split(".") if part.isdigit()]
kernel_version = tuple(parts) if parts else (0,)
if kernel_version < MIN_KERNEL_VERSION:
    logger.warning("IDA too old (must be 9.2+): %s", kernel_version_str)
    cyberchef_ok = False


if cyberchef_ok:
    # only attempt to import cyberchef once we know the required dependencies are present.
    # otherwise we'll hit ImportError and other problems
    from ida_cyberchef.plugin import cyberchef_plugin_t

    def PLUGIN_ENTRY():
        return cyberchef_plugin_t()

else:
    try:
        import ida_idaapi
    except ImportError:
        import idaapi as ida_idaapi

    class nop_plugin_t(ida_idaapi.plugin_t):
        flags = ida_idaapi.PLUGIN_HIDE | ida_idaapi.PLUGIN_UNL
        wanted_name = "cyberchef disabled"
        comment = "cyberchef is disabled for this IDA version"
        help = ""
        wanted_hotkey = ""

        def init(self):
            return ida_idaapi.PLUGIN_SKIP

    # we have to define this symbol, or IDA logs a message
    def PLUGIN_ENTRY():
        # we have to return something here, or IDA logs a message
        return nop_plugin_t()

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "ida-cyberchef",
    "entryPoint": "entrypoint.py",
    "version": "0.1.0",
    "idaVersions": ">=9.2",
    "description": "CyberChef in IDA",
    "categories": [
      "ui-ux-and-visualization"
    ],
    "pythonDependencies": ["pydantic>=2", "STPyV8"],
    "urls": {
      "repository": "https://github.com/HexRaysSA/ida-cyberchef"
    },
    "authors": [{
      "name": "Willi Ballenthin",
      "email": "wballenthin@hex-rays.com"
    }],
    "keywords": [
      "encoding",
      "decoding",
      "encryption",
      "decryption",
      "data",
      "transformation"
    ]
  }
}

```

`ida_cyberchef/__init__.py`:

```py
"""IDA CyberChef integration package.

This package provides CyberChef data transformation capabilities for IDA Pro
through both a Qt widget interface and a programmatic API.
"""

# Main widget
# Input parsing
from ida_cyberchef.core.input_parser import InputFormat

# Operation registry
from ida_cyberchef.core.operation_registry import OperationRegistry

# Recipe data structures
from ida_cyberchef.core.recipe_models import OperationStep, RecipeDefinition

# Core CyberChef API
from ida_cyberchef.cyberchef import (
    DishType,
    bake,
    get_chef,
    load_cyberchef,
    plate,
)
from ida_cyberchef.cyberchef_widget import CyberChefWidget

# Qt models
from ida_cyberchef.qt_models.execution_model import ExecutionModel
from ida_cyberchef.qt_models.input_model import InputModel, InputSource
from ida_cyberchef.qt_models.recipe_model import RecipeModel

__all__ = [
    # Main widget
    "CyberChefWidget",
    # Core CyberChef API
    "bake",
    "get_chef",
    "load_cyberchef",
    "plate",
    "DishType",
    # Qt models
    "InputModel",
    "RecipeModel",
    "ExecutionModel",
    # Enums
    "InputSource",
    "InputFormat",
    # Recipe structures
    "RecipeDefinition",
    "OperationStep",
    # Registry
    "OperationRegistry",
]

```

`ida_cyberchef/core/hex_formatter.py`:

```py
"""Format bytes as hex dump with ASCII preview."""


class HexFormatter:
    """Format bytes as hex dump display."""

    def __init__(self, bytes_per_line: int = 16):
        self.bytes_per_line = bytes_per_line

    def format_hex_dump(self, data: bytes, max_bytes: int = 65536) -> str:
        """Format bytes as hex dump with ASCII column.

        Args:
            data: Bytes to format
            max_bytes: Maximum bytes to format (default 64KB), truncates if exceeded

        Returns: Formatted hex dump string
        """
        original_size = len(data)
        truncated = original_size > max_bytes

        if truncated:
            data = data[:max_bytes]

        lines = []

        for i in range(0, len(data), self.bytes_per_line):
            chunk = data[i : i + self.bytes_per_line]

            # Offset
            offset = f"{i:08x}"

            # Hex bytes
            hex_part = " ".join(f"{b:02x}" for b in chunk)
            # Pad to align ASCII column
            hex_part = hex_part.ljust(self.bytes_per_line * 3 - 1)

            # ASCII representation
            ascii_part = "".join(chr(b) if 32 <= b < 127 else "." for b in chunk)

            lines.append(f"{offset}: {hex_part}  {ascii_part}")

        if truncated:
            lines.append(
                f"\n... (truncated, showing first {max_bytes:,} of {original_size:,} bytes)"
            )

        return "\n".join(lines)

    def format_hex_string_unspaced(self, data: bytes) -> str:
        """Format bytes as unspaced hex string.

        Args:
            data: Bytes to format

        Returns: Hex string like "48656c6c6f"
        """
        return data.hex()

    def format_hex_string_spaced(self, data: bytes) -> str:
        """Format bytes as spaced hex string.

        Args:
            data: Bytes to format

        Returns: Hex string like "48 65 6c 6c 6f"
        """
        return " ".join(f"{b:02x}" for b in data)

    def format_string_literal(self, data: bytes) -> str:
        """Format bytes as C string literal with escape sequences.

        Args:
            data: Bytes to format

        Returns: String like "Hello\\x00\\x0a"
        """
        result = []
        for b in data:
            if 32 <= b <= 126 and b not in (34, 92):  # Printable ASCII except " and \
                result.append(chr(b))
            elif b == 34:  # Double quote
                result.append('\\"')
            elif b == 92:  # Backslash
                result.append("\\\\")
            elif b == 9:  # Tab
                result.append("\\t")
            elif b == 10:  # Newline
                result.append("\\n")
            elif b == 13:  # Carriage return
                result.append("\\r")
            else:
                result.append(f"\\x{b:02x}")
        return '"' + "".join(result) + '"'

    def format_c_uchar_array_hex(self, data: bytes) -> str:
        """Format bytes as C unsigned char array in hex.

        Args:
            data: Bytes to format

        Returns: String like "0x48, 0x65, 0x6c, 0x6c, 0x6f"
        """
        return ", ".join(f"0x{b:02x}" for b in data)

    def format_c_uchar_array_decimal(self, data: bytes) -> str:
        """Format bytes as C unsigned char array in decimal.

        Args:
            data: Bytes to format

        Returns: String like "72, 101, 108, 108, 111"
        """
        return ", ".join(str(b) for b in data)

    def format_c_initialized_variable(self, data: bytes) -> str:
        """Format bytes as initialized C variable declaration.

        Args:
            data: Bytes to format

        Returns: Multi-line C variable declaration
        """
        if not data:
            return "unsigned char data[] = {};"

        # Format as hex bytes, 12 per line for readability
        hex_bytes = [f"0x{b:02x}" for b in data]
        lines = []
        lines.append(f"unsigned char data[{len(data)}] = {{")

        for i in range(0, len(hex_bytes), 12):
            chunk = hex_bytes[i : i + 12]
            line = "    " + ", ".join(chunk)
            if i + 12 < len(hex_bytes):
                line += ","
            lines.append(line)

        lines.append("};")
        return "\n".join(lines)

```

`ida_cyberchef/core/input_parser.py`:

```py
"""Parse various input formats into bytes."""

import base64
from enum import Enum
from typing import Optional


class InputFormat(Enum):
    """Supported input format types."""

    TEXT_UTF8 = "text_utf8"
    HEX_STRING = "hex_string"
    BASE64 = "base64"


class InputParser:
    """Parse text input into bytes based on format."""

    def parse(self, text: str, format: InputFormat) -> Optional[bytes]:
        """Parse text input into bytes.

        Args:
            text: Input text
            format: Format type

        Returns: Parsed bytes, or None if parsing fails
        """
        try:
            if format == InputFormat.TEXT_UTF8:
                return text.encode("utf-8")

            elif format == InputFormat.HEX_STRING:
                hex_str = text.replace(" ", "").replace(":", "").replace("-", "")
                return bytes.fromhex(hex_str)

            elif format == InputFormat.BASE64:
                return base64.b64decode(text)

        except Exception:
            return None

```

`ida_cyberchef/core/operation_doc_formatter.py`:

```py
"""Plain text formatter for operation documentation."""

import re


def strip_html_tags(text: str) -> str:
    """Strip HTML tags from text and convert <br> to newlines.

    Args:
        text: Text that may contain HTML tags

    Returns: Plain text with HTML tags removed and <br> converted to \n
    """
    text = re.sub(r"<br\s*/?>", "\n", text, flags=re.IGNORECASE)
    text = re.sub(r"<[^>]+>", "", text)
    return text


def format_operation_docs(operation: dict) -> str:
    """Format operation metadata as plain text documentation.

    Args:
        operation: Operation dict with name, category, description, args

    Returns: Formatted plain text documentation
    """
    lines = []

    lines.append(operation["name"])
    lines.append(f"Category: {operation.get('category', 'Unknown')}")
    lines.append("")

    description = operation.get("description", "No description available.")
    description = strip_html_tags(description)
    lines.append(description)
    lines.append("")

    args = operation.get("args", [])
    if not args:
        lines.append("Parameters: None")
    else:
        lines.append("Parameters:")
        for arg in args:
            arg_name = arg.get("name", "Unknown")
            arg_type = arg.get("type", "unknown")
            arg_value = arg.get("value")

            param_line = f"  {arg_name} ({arg_type})"

            if "toggleValues" in arg:
                toggle_vals = arg["toggleValues"]
                param_line += f" - Options: {', '.join(str(v) for v in toggle_vals)}"
            elif arg_value is not None and arg_value != "":
                if isinstance(arg_value, list):
                    param_line += f" - Options: {', '.join(str(v) for v in arg_value)}"
                else:
                    param_line += f" - Default: {arg_value}"

            lines.append(param_line)

    return "\n".join(lines)

```

`ida_cyberchef/core/operation_registry.py`:

```py
"""Registry for CyberChef operations with search capabilities."""

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional


class OperationRegistry:
    """Manages operation schema and provides search functionality."""

    def __init__(self, schema_path: Optional[Path] = None):
        if schema_path is None:
            schema_path = (
                Path(__file__).parent.parent / "data" / "operation_schema.json"
            )

        with open(schema_path) as f:
            self._schema = json.load(f)

        self._operations = self._schema["operations"]

    def get_all_operations(self) -> List[Dict[str, Any]]:
        """Get all available operations.

        Returns: List of all operations with their metadata
        """
        return self._operations.copy()

    def find_operation(self, name: str) -> Optional[Dict[str, Any]]:
        """Find operation by exact name.

        Args:
            name: Exact operation name to find

        Returns: Operation dict if found, None otherwise
        """
        for op in self._operations:
            if op["name"] == name:
                return op.copy()
        return None

    def search_operations(self, query: str) -> List[Dict[str, Any]]:
        """Fuzzy search operations by name.

        Args:
            query: Search term

        Returns: List of matching operations, ranked by relevance
        """
        query_lower = query.lower()
        results = []

        for op in self._operations:
            name_lower = op["name"].lower()

            # Exact match
            if name_lower == query_lower:
                results.append((0, op))
            # Starts with query
            elif name_lower.startswith(query_lower):
                results.append((1, op))
            # Contains query
            elif query_lower in name_lower:
                results.append((2, op))
            # Word boundary match
            elif any(word.startswith(query_lower) for word in name_lower.split()):
                results.append((3, op))
            # Acronym match (query matches subsequence of first letters of words)
            else:
                words = self._extract_words(op["name"])
                first_letters = "".join(word[0].lower() for word in words if word)
                if self._is_subsequence(query_lower, first_letters):
                    results.append((4, op))

        # Sort by rank, then alphabetically
        results.sort(key=lambda x: (x[0], x[1]["name"]))

        return [op.copy() for _, op in results]

    def _extract_words(self, name: str) -> List[str]:
        """Extract words from operation name, splitting on spaces and case boundaries.

        Args:
            name: Operation name

        Returns: List of words extracted from the name
        """
        # First split by spaces
        space_parts = name.split()
        words = []

        for part in space_parts:
            # Split by case boundaries, treating each digit as a separate word
            # This allows "Base64" -> ["Base", "6", "4"] for acronym "b64"
            subwords = re.findall(
                r"[A-Z]+(?=[A-Z][a-z]|\b|\d|[^A-Za-z0-9])|[A-Z]?[a-z]+|\d", part
            )
            if subwords:
                words.extend(subwords)
            else:
                # If no subwords found, use the original part
                words.append(part)

        return words

    def _is_subsequence(self, query: str, text: str) -> bool:
        """Check if query is a subsequence of text.

        Args:
            query: Query string to find
            text: Text to search in

        Returns: True if query is a subsequence of text
        """
        query_idx = 0
        for char in text:
            if query_idx < len(query) and char == query[query_idx]:
                query_idx += 1
        return query_idx == len(query)

```

`ida_cyberchef/core/recipe_executor.py`:

```py
"""Execute CyberChef recipes and return step-by-step results."""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from ida_cyberchef.cyberchef import bake


@dataclass
class StepResult:
    """Result of executing a single recipe step."""

    success: bool
    data: Optional[bytes | str]
    error: Optional[str]


class RecipeExecutor:
    """Executes CyberChef recipes and tracks results for each step."""

    def execute_recipe(
        self, input_data: bytes, recipe: List[Dict[str, Any]]
    ) -> List[StepResult]:
        """Execute recipe and return results for each step.

        Args:
            input_data: Input bytes to process
            recipe: List of operation dicts with "operation" and "args" keys

        Returns: List of StepResult for each step (stops at first error)
        """
        results = []

        for i, step in enumerate(recipe):
            try:
                recipe_prefix = recipe[: i + 1]

                chef_recipe = []
                for s in recipe_prefix:
                    if s["args"]:
                        chef_recipe.append({"op": s["operation"], "args": s["args"]})
                    else:
                        chef_recipe.append(s["operation"])

                output = bake(input_data, chef_recipe)  # type: ignore[arg-type]
                results.append(StepResult(success=True, data=output, error=None))

            except Exception as e:
                results.append(StepResult(success=False, data=None, error=str(e)))
                break

        return results

```

`ida_cyberchef/core/recipe_models.py`:

```py
"""Pydantic models for recipe serialization."""

from typing import Any, Dict, List

from pydantic import BaseModel, Field


class OperationStep(BaseModel):
    """Single operation in a recipe."""

    operation: str = Field(..., description="Operation name")
    args: Dict[str, Any] = Field(
        default_factory=dict, description="Operation arguments"
    )


class RecipeDefinition(BaseModel):
    """Complete recipe definition for serialization."""

    version: str = Field(default="1.0", description="Recipe format version")
    steps: List[OperationStep] = Field(default_factory=list, description="Recipe steps")

```

`ida_cyberchef/cyberchef.py`:

```py
import json
from enum import IntEnum
from typing import Any, TypedDict

import STPyV8

_chef_instance = None


class DishType(IntEnum):
    """CyberChef Dish type enumeration."""

    BYTE_ARRAY = 0
    STRING = 1
    NUMBER = 2
    HTML = 3
    ARRAY_BUFFER = 4
    BIG_NUMBER = 5
    JSON = 6
    FILE = 7
    LIST_FILE = 8


class Dish(TypedDict):
    """CyberChef Dish object structure."""

    value: Any
    type: DishType


class RecipeOperation(TypedDict, total=False):
    """CyberChef recipe operation structure.

    Either a string operation name or a dict with op and args.
    """

    op: str
    args: dict[str, Any]


def get_chef():
    """Get or create a cached CyberChef instance.

    Returns: CyberChef module exports object
    """
    global _chef_instance
    if _chef_instance is None:
        _chef_instance = load_cyberchef()
    return _chef_instance


def load_cyberchef(path: str | None = None):
    """Load CyberChef bundle into V8 context and return exports.

    Args:
        path: Path to CyberChef.js bundle. If None, uses package data path.

    Returns: CyberChef module exports object
    """
    if path is None:
        from pathlib import Path

        path = str(Path(__file__).parent / "data" / "CyberChef.js")
    ctx = STPyV8.JSContext()
    ctx.enter()

    # Setup minimal global environment for CyberChef
    ctx.eval("""
    globalThis.global = globalThis;
    globalThis.window = globalThis;
    globalThis.self = globalThis;
    globalThis.document = {};

    // Minimal process polyfill
    globalThis.process = {
        platform: 'linux',
        env: {},
        cwd: () => '/',
        version: 'v18.0.0',
        versions: {node: 'v18.0.0'},
        nextTick: (fn) => setTimeout(fn, 0)
    };

    // TextEncoder/TextDecoder polyfill
    if (typeof TextEncoder === 'undefined') {
        globalThis.TextEncoder = class TextEncoder {
            encode(str) {
                const utf8 = unescape(encodeURIComponent(str));
                const result = new Uint8Array(utf8.length);
                for (let i = 0; i < utf8.length; i++) {
                    result[i] = utf8.charCodeAt(i);
                }
                return result;
            }
        };
    }

    if (typeof TextDecoder === 'undefined') {
        globalThis.TextDecoder = class TextDecoder {
            decode(bytes) {
                const utf8 = Array.from(bytes).map(b => String.fromCharCode(b)).join('');
                return decodeURIComponent(escape(utf8));
            }
        };
    }

    // Crypto API polyfill
    if (typeof crypto === 'undefined') {
        globalThis.crypto = {};
    }
    if (!globalThis.crypto.getRandomValues) {
        globalThis.crypto.getRandomValues = function(array) {
            for (let i = 0; i < array.length; i++) {
                array[i] = Math.floor(Math.random() * 256);
            }
            return array;
        };
    }

    // Timer polyfills (minimal implementation for CyberChef)
    globalThis.setTimeout = function(fn, ms) {
        fn();
        return 0;
    };
    globalThis.setInterval = function(fn, ms) {
        return 0;
    };
    globalThis.clearTimeout = function(id) {};
    globalThis.clearInterval = function(id) {};
    """)

    # Setup minimal CommonJS environment
    ctx.eval("const module = { exports: {} };")

    # Load and execute CyberChef
    with open(path, "rb") as f:
        ctx.eval(f.read().decode("utf-8"))

    # Extract exports and attach context for later use
    chef = ctx.eval("module.exports")
    chef._stpyv8_context = ctx
    return chef


def plate(v: Dish | Any, chef=None) -> Dish | Any:
    """Convert between Python types and CyberChef Dish objects.

    Args:
        v: Either a Dish object or a native Python type
        chef: Optional CyberChef module for creating proper Dish instances from bytes

    Returns: Native Python type if input is Dish, Dish dict/instance if input is Python type
    """
    is_dish_object = (isinstance(v, dict) and "value" in v and "type" in v) or (
        hasattr(v, "value") and hasattr(v, "type")
    )

    if is_dish_object:
        dish_type = DishType(int(v["type"] if isinstance(v, dict) else v.type))
        value = v["value"] if isinstance(v, dict) else v.value

        if dish_type == DishType.BYTE_ARRAY:
            if isinstance(value, list) or hasattr(value, "__iter__"):
                value_list = list(value) if not isinstance(value, list) else value
                if value_list and isinstance(value_list[0], float):
                    return bytes(int(v) for v in value_list)
                elif value_list and isinstance(value_list[0], int):
                    return bytes(value_list)
                elif value_list:
                    raise NotImplementedError
                return b""

            return value
        elif dish_type == DishType.STRING:
            return str(value)
        elif dish_type == DishType.NUMBER:
            return float(value)
        elif dish_type == DishType.HTML:
            return str(value)
        elif dish_type == DishType.ARRAY_BUFFER:
            if isinstance(value, STPyV8.JSObject):
                if chef and hasattr(chef, "_stpyv8_context"):
                    ctx = chef._stpyv8_context
                    ctx.locals.array_buffer_value = value
                    array_data = ctx.eval("""
                    (function() {
                        return Array.from(new Uint8Array(array_buffer_value));
                    })
                    """)()
                    return bytes(list(array_data))
                else:
                    return value
            elif isinstance(value, list) or hasattr(value, "__iter__"):
                return bytes(list(value))
            return value
        elif dish_type == DishType.BIG_NUMBER:
            return int(value) if isinstance(value, (int, float)) else value
        elif dish_type == DishType.JSON:
            return value
        elif dish_type in (DishType.FILE, DishType.LIST_FILE):
            return value
        else:
            return value
    else:
        if isinstance(v, bytes):
            if chef is not None and hasattr(chef, "_stpyv8_context"):
                byte_list = list(v)
                byte_json = json.dumps(byte_list)
                ctx = chef._stpyv8_context
                dish = ctx.eval(f"""
                (function() {{
                    const byteArray = {byte_json};
                    const uint8 = new Uint8Array(byteArray);
                    return new module.exports.Dish(uint8.buffer, module.exports.Dish.ARRAY_BUFFER);
                }})
                """)()
                return dish
            else:
                return {"value": list(v), "type": DishType.ARRAY_BUFFER}
        elif isinstance(v, str):
            return {"value": v, "type": DishType.STRING}
        elif isinstance(v, (int, float)):
            return {"value": v, "type": DishType.NUMBER}
        elif isinstance(v, (dict, list)):
            return {"value": v, "type": DishType.JSON}
        else:
            return {"value": str(v), "type": DishType.STRING}


def bake(input_data: bytes | str, recipe: list[str | RecipeOperation]) -> bytes | str:
    """Execute CyberChef operations using native bake() function.

    Args:
        input_data: Input data as bytes or string
        recipe: List of operations. Each operation is either:
            - A string operation name: "To Base64"
            - A dict with op and args: {"op": "SHA2", "args": {"size": 256}}

    Returns: Result as bytes or string depending on the final operation output
    """
    chef = get_chef()

    if isinstance(input_data, bytes):
        input_dish = plate(input_data, chef)
    else:
        input_dish = input_data

    recipe_json = json.dumps(recipe)

    ctx = chef._stpyv8_context
    ctx.locals.input_dish = input_dish
    result = ctx.eval(f"""
    (function() {{
        const recipe = {recipe_json};
        return module.exports.bake(input_dish, recipe);
    }})
    """)()

    return plate(result, chef)  # type: ignore[return-value]

```

`ida_cyberchef/cyberchef_widget.py`:

```py
"""Main CyberChef widget integrating all panels."""

from PySide6.QtWidgets import QSizePolicy, QVBoxLayout, QWidget

from ida_cyberchef.core.operation_registry import OperationRegistry
from ida_cyberchef.qt_models.execution_model import ExecutionModel
from ida_cyberchef.qt_models.input_model import InputModel
from ida_cyberchef.qt_models.recipe_model import RecipeModel
from ida_cyberchef.widgets.input_panel import InputPanel
from ida_cyberchef.widgets.operation_browser_widget import OperationBrowserWidget
from ida_cyberchef.widgets.output_panel import OutputPanel
from ida_cyberchef.widgets.recipe_panel import RecipePanel


class CyberChefWidget(QWidget):
    """Main CyberChef widget with input, recipe, operation browser, and output panels.

    Layout (Vertical layout with fixed input/output/browser, expanding recipe):
    ┌──────────────────────────────────────────────────────────────────────┐
    │ ┌─ Input Panel (minimal fixed height) ────────────────────────────┐  │
    │ │ ◉ Manual Input  ○ From Cursor  ○ From Selection                 │  │
    │ │ Format: ◉ Text (UTF-8)  ○ Hex String  ○ Base64                  │  │
    │ │ ┌──────────────────────────────────────────────────────────────┐│  │
    │ │ │ Enter input data...                                          ││  │
    │ │ └──────────────────────────────────────────────────────────────┘│  │
    │ └─────────────────────────────────────────────────────────────────┘  │
    ├──────────────────────────────────────────────────────────────────────┤
    │ ┌─ Recipe Panel (expands to fill remaining space) ────────────────┐  │
    │ │                         [+ Insert]                              │  │
    │ │ ┌─ To Base64 ────────────────────────────────[Preview ▼] [✕] ─┐ │  │
    │ │ │  Alphabet: │ A-Za-z0-9+/=                                   │ │  │
    │ │ └─────────────────────────────────────────────────────────────┘ │  │
    │ │                         [+ Insert]                              │  │
    │ │ ┌─ XOR ──────────────────────────────────────[Preview ▼] [✕] ─┐ │  │
    │ │ │  Key:    │ secret               │ UTF8                      │ │  │
    │ │ └─────────────────────────────────────────────────────────────┘ │  │
    │ │                    [+ Add Operation]                            │  │
    │ └─────────────────────────────────────────────────────────────────┘  │
    ├──────────────────────────────────────────────────────────────────────┤
    │ ┌─ Operation Browser (fixed height) ──────────────────────────────┐  │
    │ │ Search: │ base64                                                │  │
    │ │ ┌─ Operations ───┬─ Documentation ──────────────────────────┐  │  │
    │ │ │ To Base64      │ **To Base64**                            │  │  │
    │ │ │ From Base64    │ Category: Data format                    │  │  │
    │ │ │ To Hex         │ Converts data to Base64 encoding.        │  │  │
    │ │ └────────────────┴──────────────────────────────────────────┘  │  │
    │ └─────────────────────────────────────────────────────────────────┘  │
    ├──────────────────────────────────────────────────────────────────────┤
    │ ┌─ Output Panel (minimal fixed height) ───────────────────────────┐  │
    │ │ ┌────────────────────────────────────────────────────────────┐  │  │
    │ │ │ 00000000: 48 65 6c 6c 6f 20 77  6f 72 6c 64   Hello world  │  │  │
    │ │ └────────────────────────────────────────────────────────────┘  │  │
    │ │ [Copy to Clipboard] [Save to File]  [Copy to DB] [Set Comment]  │  │
    │ └─────────────────────────────────────────────────────────────────┘  │
    └──────────────────────────────────────────────────────────────────────┘
    """

    def __init__(self, parent=None, show_ida_buttons: bool = False):
        """Initialize CyberChefWidget.

        Args:
            parent: Parent widget
            show_ida_buttons: Whether to show IDA-specific buttons in output panel
        """
        super().__init__(parent)

        self._registry = OperationRegistry()

        self._input_model = InputModel()
        self._recipe_model = RecipeModel()
        self._execution_model = ExecutionModel(self._input_model, self._recipe_model)
        self._show_ida_buttons = show_ida_buttons

        self._setup_ui()

    def _setup_ui(self):
        """Setup main widget UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(0)

        self._input_panel = InputPanel(self._input_model)
        self._input_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        layout.addWidget(self._input_panel)

        self._recipe_panel = RecipePanel(
            self._recipe_model, self._execution_model, self._registry
        )
        self._recipe_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        layout.addWidget(self._recipe_panel)

        self._operation_browser = OperationBrowserWidget(self._registry)
        self._operation_browser.operation_selected.connect(self._on_operation_selected)
        self._operation_browser.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        self._operation_browser.setMinimumHeight(200)
        layout.addWidget(self._operation_browser)

        self._output_panel = OutputPanel(
            self._execution_model,
            self._input_model,
            show_ida_buttons=self._show_ida_buttons,
        )
        self._output_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        layout.addWidget(self._output_panel)

    def get_input_model(self) -> InputModel:
        """Get input model for external data injection.

        Returns: InputModel instance
        """
        return self._input_model

    def get_recipe_model(self) -> RecipeModel:
        """Get recipe model for programmatic recipe manipulation.

        Returns: RecipeModel instance
        """
        return self._recipe_model

    def get_output_panel(self) -> OutputPanel:
        """Get output panel for signal connections.

        Returns: OutputPanel instance
        """
        return self._output_panel

    def get_input_panel(self) -> InputPanel:
        """Get the input panel widget.

        Returns: InputPanel instance
        """
        return self._input_panel

    def _on_operation_selected(self, operation: dict):
        """Handle operation selection from browser widget.

        Args:
            operation: Operation dictionary from registry
        """
        import json
        from typing import Any

        def get_default_arg_value(arg: dict) -> Any:
            """Extract default value from argument definition.

            Args:
                arg: Argument definition from schema

            Returns: Appropriate default value for CyberChef
            """
            arg_type = arg.get("type", "string")
            raw_value = arg.get("value", "")

            try:
                parsed_value = (
                    json.loads(raw_value) if isinstance(raw_value, str) else raw_value
                )
            except (json.JSONDecodeError, ValueError):
                parsed_value = raw_value

            if arg_type in ("option", "editableOption", "editableOptionShort"):
                if isinstance(parsed_value, list) and parsed_value:
                    return parsed_value[0]
                return parsed_value

            elif arg_type == "toggleString":
                toggle_values = arg.get("toggleValues", "[]")
                try:
                    toggle_list = (
                        json.loads(toggle_values)
                        if isinstance(toggle_values, str)
                        else toggle_values
                    )
                except (json.JSONDecodeError, ValueError):
                    toggle_list = []

                if isinstance(toggle_list, list) and toggle_list:
                    return {
                        "string": parsed_value if parsed_value else "",
                        "option": toggle_list[0],
                    }
                return parsed_value

            elif arg_type == "argSelector":
                if isinstance(parsed_value, list) and parsed_value:
                    first_mode = parsed_value[0]
                    if isinstance(first_mode, dict):
                        return first_mode.get("name", "")
                return parsed_value

            return parsed_value

        args = {}
        for arg in operation.get("args", []):
            args[arg["name"]] = get_default_arg_value(arg)

        self._recipe_model.add_operation(operation["name"], args, -1)

    def load_recipe_from_file(self, filename: str):
        """Load recipe from JSON file with validation.

        Args:
            filename: Path to recipe JSON file

        Raises:
            ValueError: If recipe contains operations not in registry
        """
        import json

        from ida_cyberchef.core.recipe_models import RecipeDefinition

        with open(filename) as f:
            data = json.load(f)

        recipe = RecipeDefinition.model_validate(data)

        missing_operations = []
        for step in recipe.steps:
            if not self._registry.find_operation(step.operation):
                missing_operations.append(step.operation)

        if missing_operations:
            raise ValueError(
                f"Recipe contains {len(missing_operations)} unknown operation(s): "
                f"{', '.join(missing_operations[:5])}"
                + (
                    f" and {len(missing_operations) - 5} more"
                    if len(missing_operations) > 5
                    else ""
                )
            )

        self._recipe_model.from_recipe_definition(recipe)

    def save_recipe_to_file(self, filename: str):
        """Save recipe to JSON file.

        Args:
            filename: Path to save recipe JSON
        """
        recipe = self._recipe_model.to_recipe_definition()

        with open(filename, "w") as f:
            f.write(recipe.model_dump_json(indent=2))

```

`ida_cyberchef/data/operation_schema.json`:

```json
{
  "operations": [
    {
      "name": "A1Z26 Cipher Decode",
      "module": "Ciphers",
      "description": "Converts alphabet order numbers into their corresponding  alphabet character.<br><br>e.g. <code>1</code> becomes <code>a</code> and <code>2</code> becomes <code>b</code>.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "A1Z26 Cipher Encode",
      "module": "Ciphers",
      "description": "Converts alphabet characters into their corresponding alphabet order number.<br><br>e.g. <code>a</code> becomes <code>1</code> and <code>b</code> becomes <code>2</code>.<br><br>Non-alphabet characters are dropped.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "ADD",
      "module": "Default",
      "description": "ADD the input with the given key (e.g. <code>fe023da5</code>), MOD 255",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Binary",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "AES Decrypt",
      "module": "Ciphers",
      "description": "Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.<br><br><b>Key:</b> The following algorithms will be used based on the size of the key:<ul><li>16 bytes = AES-128</li><li>24 bytes = AES-192</li><li>32 bytes = AES-256</li></ul><br><br><b>IV:</b> The Initialization Vector should be 16 bytes long. If not entered, it will default to 16 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used as a default.<br><br><b>GCM Tag:</b> This field is ignored unless 'GCM' mode is used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "argSelector",
          "value": [
            {
              "name": "CBC",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "CFB",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "OFB",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "CTR",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "GCM",
              "on": [
                5,
                6
              ]
            },
            {
              "name": "ECB",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "CBC/NoPadding",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "ECB/NoPadding",
              "off": [
                5,
                6
              ]
            }
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "GCM Tag",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Additional Authenticated Data",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "AES Encrypt",
      "module": "Ciphers",
      "description": "Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.<br><br><b>Key:</b> The following algorithms will be used based on the size of the key:<ul><li>16 bytes = AES-128</li><li>24 bytes = AES-192</li><li>32 bytes = AES-256</li></ul>You can generate a password-based key using one of the KDF operations.<br><br><b>IV:</b> The Initialization Vector should be 16 bytes long. If not entered, it will default to 16 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "argSelector",
          "value": [
            {
              "name": "CBC",
              "off": [
                5
              ]
            },
            {
              "name": "CFB",
              "off": [
                5
              ]
            },
            {
              "name": "OFB",
              "off": [
                5
              ]
            },
            {
              "name": "CTR",
              "off": [
                5
              ]
            },
            {
              "name": "GCM",
              "on": [
                5
              ]
            },
            {
              "name": "ECB",
              "off": [
                5
              ]
            },
            {
              "name": "CBC/NoPadding",
              "off": [
                5
              ]
            },
            {
              "name": "ECB/NoPadding",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Additional Authenticated Data",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "AES Key Unwrap",
      "module": "Ciphers",
      "description": "Decryptor for a key wrapping algorithm defined in RFC3394, which is used to protect keys in untrusted storage or communications, using AES.<br><br>This algorithm uses an AES key (KEK: key-encryption key) and a 64-bit IV to decrypt 64-bit blocks.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key (KEK)",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "a6a6a6a6a6a6a6a6",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "AES Key Wrap",
      "module": "Ciphers",
      "description": "A key wrapping algorithm defined in RFC3394, which is used to protect keys in untrusted storage or communications, using AES.<br><br>This algorithm uses an AES key (KEK: key-encryption key) and a 64-bit IV to encrypt 64-bit blocks.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key (KEK)",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "a6a6a6a6a6a6a6a6",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "AMF Decode",
      "module": "Encodings",
      "description": "Action Message Format (AMF) is a binary format used to serialize object graphs such as ActionScript objects and XML, or send messages between an Adobe Flash client and a remote service, usually a Flash Media Server or third party alternatives.",
      "inputType": "ArrayBuffer",
      "outputType": "JSON",
      "args": [
        {
          "name": "Format",
          "type": "option",
          "value": [
            "AMF0",
            "AMF3"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "AMF Encode",
      "module": "Encodings",
      "description": "Action Message Format (AMF) is a binary format used to serialize object graphs such as ActionScript objects and XML, or send messages between an Adobe Flash client and a remote service, usually a Flash Media Server or third party alternatives.",
      "inputType": "JSON",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Format",
          "type": "option",
          "value": [
            "AMF0",
            "AMF3"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "AND",
      "module": "Default",
      "description": "AND the input with the given key.<br>e.g. <code>fe023da5</code>",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Binary",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "BLAKE2b",
      "module": "Hashing",
      "description": "Performs BLAKE2b hashing on the input.  \n        <br><br> BLAKE2b is a flavour of the BLAKE cryptographic hash function that is optimized for 64-bit platforms and produces digests of any size between 1 and 64 bytes.\n        <br><br> Supports the use of an optional key.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "option",
          "value": [
            "512",
            "384",
            "256",
            "160",
            "128"
          ]
        },
        {
          "name": "Output Encoding",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "UTF8",
            "Decimal",
            "Base64",
            "Hex",
            "Latin1"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "BLAKE2s",
      "module": "Hashing",
      "description": "Performs BLAKE2s hashing on the input.  \n        <br><br>BLAKE2s is a flavour of the BLAKE cryptographic hash function that is optimized for 8- to 32-bit platforms and produces digests of any size between 1 and 32 bytes.\n        <br><br>Supports the use of an optional key.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "option",
          "value": [
            "256",
            "160",
            "128"
          ]
        },
        {
          "name": "Output Encoding",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "UTF8",
            "Decimal",
            "Base64",
            "Hex",
            "Latin1"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "BLAKE3",
      "module": "Hashing",
      "description": "Hashes the input using BLAKE3 (UTF-8 encoded), with an optional key (also UTF-8), and outputs the result in hexadecimal format.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Size (bytes)",
          "type": "number",
          "value": ""
        },
        {
          "name": "Key",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "BSON deserialise",
      "module": "Serialise",
      "description": "BSON is a computer data interchange format used mainly as a data storage and network transfer format in the MongoDB database. It is a binary form for representing simple data structures, associative arrays (called objects or documents in MongoDB), and various data types of specific interest to MongoDB. The name 'BSON' is based on the term JSON and stands for 'Binary JSON'.<br><br>Input data should be in a raw bytes format.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "BSON serialise",
      "module": "Serialise",
      "description": "BSON is a computer data interchange format used mainly as a data storage and network transfer format in the MongoDB database. It is a binary form for representing simple data structures, associative arrays (called objects or documents in MongoDB), and various data types of specific interest to MongoDB. The name 'BSON' is based on the term JSON and stands for 'Binary JSON'.<br><br>Input data should be valid JSON.",
      "inputType": "string",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "CBOR Decode",
      "module": "Serialise",
      "description": "Concise Binary Object Representation (CBOR) is a binary data serialization format loosely based on JSON. Like JSON it allows the transmission of data objects that contain name\u2013value pairs, but in a more concise manner. This increases processing and transfer speeds at the cost of human readability. It is defined in IETF RFC 8949.",
      "inputType": "ArrayBuffer",
      "outputType": "JSON",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "CBOR Encode",
      "module": "Serialise",
      "description": "Concise Binary Object Representation (CBOR) is a binary data serialization format loosely based on JSON. Like JSON it allows the transmission of data objects that contain name\u2013value pairs, but in a more concise manner. This increases processing and transfer speeds at the cost of human readability. It is defined in IETF RFC 8949.",
      "inputType": "JSON",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "CMAC",
      "module": "Crypto",
      "description": "CMAC is a block-cipher based message authentication code algorithm.<br><br>RFC4493 defines AES-CMAC that uses AES encryption with a 128-bit key.<br>NIST SP 800-38B suggests usages of AES with other key lengths and Triple DES.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Encryption algorithm",
          "type": "option",
          "value": [
            "AES",
            "Triple DES"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "CRC Checksum",
      "module": "Default",
      "description": "A Cyclic Redundancy Check (<b>CRC</b>) is an error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "Custom",
              "on": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-3/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-3/ROHC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-4/G-704",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-4/INTERLAKEN",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-4/ITU",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-5/EPC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-5/EPC-C1G2",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-5/G-704",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-5/ITU",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-5/USB",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-6/CDMA2000-A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-6/CDMA2000-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-6/DARC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-6/G-704",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-6/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-6/ITU",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-7/MMC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-7/ROHC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-7/UMTS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/8H2F",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/AES",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/AUTOSAR",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/BLUETOOTH",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/CDMA2000",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/DARC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/DVB-S2",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/EBU",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/GSM-A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/GSM-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/HITAG",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/I-432-1",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/I-CODE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/ITU",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/LTE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/MAXIM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/MAXIM-DOW",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/MIFARE-MAD",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/NRSC-5",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/OPENSAFETY",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/ROHC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/SAE-J1850",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/SAE-J1850-ZERO",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/SMBUS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/TECH-3250",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-8/WCDMA",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-10/ATM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-10/CDMA2000",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-10/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-10/I-610",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-11/FLEXRAY",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-11/UMTS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-12/3GPP",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-12/CDMA2000",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-12/DECT",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-12/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-12/UMTS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-13/BBC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-14/DARC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-14/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-15/CAN",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-15/MPT1327",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/ACORN",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/ARC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/AUG-CCITT",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/AUTOSAR",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/BLUETOOTH",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/BUYPASS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/CCITT",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/CCITT-FALSE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/CCITT-TRUE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/CCITT-ZERO",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/CDMA2000",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/CMS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/DARC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/DDS-110",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/DECT-R",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/DECT-X",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/DNP",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/EN-13757",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/EPC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/EPC-C1G2",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/GENIBUS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/I-CODE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/IBM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/IBM-3740",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/IBM-SDLC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/IEC-61158-2",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/ISO-HDLC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/ISO-IEC-14443-3-A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/ISO-IEC-14443-3-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/KERMIT",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/LHA",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/LJ1200",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/LTE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/M17",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/MAXIM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/MAXIM-DOW",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/MCRF4XX",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/MODBUS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/NRSC-5",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/OPENSAFETY-A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/OPENSAFETY-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/PROFIBUS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/RIELLO",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/SPI-FUJITSU",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/T10-DIF",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/TELEDISK",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/TMS37157",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/UMTS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/USB",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/V-41-LSB",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/V-41-MSB",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/VERIFONE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/X-25",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/XMODEM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-16/ZMODEM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-17/CAN-FD",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-21/CAN-FD",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/BLE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/FLEXRAY-A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/FLEXRAY-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/INTERLAKEN",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/LTE-A",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/LTE-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/OPENPGP",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-24/OS-9",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-30/CDMA",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-31/PHILIPS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/AAL5",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/ADCCP",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/AIXM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/AUTOSAR",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/BASE91-C",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/BASE91-D",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/BZIP2",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/C",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/CASTAGNOLI",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/CD-ROM-EDC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/CKSUM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/D",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/DECT-B",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/INTERLAKEN",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/ISCSI",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/ISO-HDLC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/JAMCRC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/MEF",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/MPEG-2",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/NVME",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/PKZIP",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/POSIX",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/Q",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/SATA",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/V-42",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/XFER",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-32/XZ",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-40/GSM",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/ECMA-182",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/GO-ECMA",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/GO-ISO",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/MS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/NVME",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/REDIS",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/WE",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-64/XZ",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            },
            {
              "name": "CRC-82/DARC",
              "off": [
                1,
                2,
                3,
                4,
                5,
                6
              ]
            }
          ]
        },
        {
          "name": "Width (bits)",
          "type": "toggleString",
          "value": "0",
          "toggleValues": [
            "Decimal"
          ]
        },
        {
          "name": "Polynomial",
          "type": "toggleString",
          "value": "0",
          "toggleValues": [
            "Hex"
          ]
        },
        {
          "name": "Initialization",
          "type": "toggleString",
          "value": "0",
          "toggleValues": [
            "Hex"
          ]
        },
        {
          "name": "Reflect input",
          "type": "option",
          "value": [
            "True",
            "False"
          ]
        },
        {
          "name": "Reflect output",
          "type": "option",
          "value": [
            "True",
            "False"
          ]
        },
        {
          "name": "Xor Output",
          "type": "toggleString",
          "value": "0",
          "toggleValues": [
            "Hex"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "CSS Beautify",
      "module": "Code",
      "description": "Indents and prettifies Cascading Style Sheets (CSS) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Indent string",
          "type": "binaryShortString",
          "value": "\\t"
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "CSS Minify",
      "module": "Code",
      "description": "Compresses Cascading Style Sheets (CSS) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Preserve comments",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "CSS selector",
      "module": "Code",
      "description": "Extract information from an HTML document with a CSS selector",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "CSS selector",
          "type": "string",
          "value": ""
        },
        {
          "name": "Delimiter",
          "type": "binaryShortString",
          "value": "\\n"
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "CSV to JSON",
      "module": "Default",
      "description": "Converts a CSV file to JSON format.",
      "inputType": "string",
      "outputType": "JSON",
      "args": [
        {
          "name": "Cell delimiters",
          "type": "binaryShortString",
          "value": ","
        },
        {
          "name": "Row delimiters",
          "type": "binaryShortString",
          "value": "\\r\\n"
        },
        {
          "name": "Format",
          "type": "option",
          "value": [
            "Array of dictionaries",
            "Array of arrays"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "CTPH",
      "module": "Crypto",
      "description": "Context Triggered Piecewise Hashing, also called Fuzzy Hashing, can match inputs that have homologies. Such inputs have sequences of identical bytes in the same order, although bytes in between these sequences may be different in both content and length.<br><br>CTPH was originally based on the work of Dr. Andrew Tridgell and a spam email detector called SpamSum. This method was adapted by Jesse Kornblum and published at the DFRWS conference in 2006 in a paper 'Identifying Almost Identical Files Using Context Triggered Piecewise Hashing'.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "DES Decrypt",
      "module": "Ciphers",
      "description": "DES is a previously dominant algorithm for encryption, and was published as an official U.S. Federal Information Processing Standard (FIPS). It is now considered to be insecure due to its small key size.<br><br><b>Key:</b> DES uses a key length of 8 bytes (64 bits).<br><br><b>IV:</b> The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used as a default.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB",
            "CBC/NoPadding",
            "ECB/NoPadding"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "DES Encrypt",
      "module": "Ciphers",
      "description": "DES is a previously dominant algorithm for encryption, and was published as an official U.S. Federal Information Processing Standard (FIPS). It is now considered to be insecure due to its small key size.<br><br><b>Key:</b> DES uses a key length of 8 bytes (64 bits).<br><br>You can generate a password-based key using one of the KDF operations.<br><br><b>IV:</b> The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "DNS over HTTPS",
      "module": "Default",
      "description": "Takes a single domain name and performs a DNS lookup using DNS over HTTPS.\n<br><br>\nBy default, <a href='https://developers.cloudflare.com/1.1.1.1/dns-over-https/'>Cloudflare</a> and <a href='https://developers.google.com/speed/public-dns/docs/dns-over-https'>Google</a> DNS over HTTPS services are supported.\n<br><br>\nCan be used with any service that supports the GET parameters <code>name</code> and <code>type</code>.",
      "inputType": "string",
      "outputType": "JSON",
      "args": [
        {
          "name": "Resolver",
          "type": "editableOption",
          "value": [
            {
              "name": "Google",
              "value": "https://dns.google.com/resolve"
            },
            {
              "name": "Cloudflare",
              "value": "https://cloudflare-dns.com/dns-query"
            }
          ]
        },
        {
          "name": "Request Type",
          "type": "option",
          "value": [
            "A",
            "AAAA",
            "ANAME",
            "CERT",
            "CNAME",
            "DNSKEY",
            "HTTPS",
            "IPSECKEY",
            "LOC",
            "MX",
            "NS",
            "OPENPGPKEY",
            "PTR",
            "RRSIG",
            "SIG",
            "SOA",
            "SPF",
            "SRV",
            "SSHFP",
            "TA",
            "TXT",
            "URI",
            "ANY"
          ]
        },
        {
          "name": "Answer Data Only",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Disable DNSSEC validation",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "ECDSA Sign",
      "module": "Ciphers",
      "description": "Sign a plaintext message with a PEM encoded EC key.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "ECDSA Private Key (PEM)",
          "type": "text",
          "value": "-----BEGIN EC PRIVATE KEY-----"
        },
        {
          "name": "Message Digest Algorithm",
          "type": "option",
          "value": [
            "SHA-256",
            "SHA-384",
            "SHA-512",
            "SHA-1",
            "MD5"
          ]
        },
        {
          "name": "Output Format",
          "type": "option",
          "value": [
            "ASN.1 HEX",
            "P1363 HEX",
            "JSON Web Signature",
            "Raw JSON"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "ECDSA Signature Conversion",
      "module": "Ciphers",
      "description": "Convert an ECDSA signature between hex, asn1 and json.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input Format",
          "type": "option",
          "value": [
            "Auto",
            "ASN.1 HEX",
            "P1363 HEX",
            "JSON Web Signature",
            "Raw JSON"
          ]
        },
        {
          "name": "Output Format",
          "type": "option",
          "value": [
            "ASN.1 HEX",
            "P1363 HEX",
            "JSON Web Signature",
            "Raw JSON"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "ECDSA Verify",
      "module": "Ciphers",
      "description": "Verify a message against a signature and a public PEM encoded EC key.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input Format",
          "type": "option",
          "value": [
            "Auto",
            "ASN.1 HEX",
            "P1363 HEX",
            "JSON Web Signature",
            "Raw JSON"
          ]
        },
        {
          "name": "Message Digest Algorithm",
          "type": "option",
          "value": [
            "SHA-256",
            "SHA-384",
            "SHA-512",
            "SHA-1",
            "MD5"
          ]
        },
        {
          "name": "ECDSA Public Key (PEM)",
          "type": "text",
          "value": "-----BEGIN PUBLIC KEY-----"
        },
        {
          "name": "Message",
          "type": "text",
          "value": ""
        },
        {
          "name": "Message format",
          "type": "option",
          "value": [
            "Raw",
            "Hex",
            "Base64"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "ELF Info",
      "module": "Default",
      "description": "Implements readelf-like functionality. This operation will extract the ELF Header, Program Headers, Section Headers and Symbol Table for an ELF file.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "GOST Decrypt",
      "module": "Ciphers",
      "description": "The GOST block cipher (Magma), defined in the standard GOST 28147-89 (RFC 5830), is a Soviet and Russian government standard symmetric key block cipher with a block size of 64 bits. The original standard, published in 1989, did not give the cipher any name, but the most recent revision of the standard, GOST R 34.12-2015 (RFC 7801, RFC 8891), specifies that it may be referred to as Magma. The GOST hash function is based on this cipher. The new standard also specifies a new 128-bit block cipher called Kuznyechik.<br><br>Developed in the 1970s, the standard had been marked 'Top Secret' and then downgraded to 'Secret' in 1990. Shortly after the dissolution of the USSR, it was declassified and it was released to the public in 1994. GOST 28147 was a Soviet alternative to the United States standard algorithm, DES. Thus, the two are very similar in structure.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output type",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1989)",
              "on": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Magma, 2015)",
              "off": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Kuznyechik, 2015)",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        },
        {
          "name": "Block mode",
          "type": "option",
          "value": [
            "ECB",
            "CFB",
            "OFB",
            "CTR",
            "CBC"
          ]
        },
        {
          "name": "Key meshing mode",
          "type": "option",
          "value": [
            "NO",
            "CP"
          ]
        },
        {
          "name": "Padding",
          "type": "option",
          "value": [
            "NO",
            "PKCS5",
            "ZERO",
            "RANDOM",
            "BIT"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "GOST Encrypt",
      "module": "Ciphers",
      "description": "The GOST block cipher (Magma), defined in the standard GOST 28147-89 (RFC 5830), is a Soviet and Russian government standard symmetric key block cipher with a block size of 64 bits. The original standard, published in 1989, did not give the cipher any name, but the most recent revision of the standard, GOST R 34.12-2015 (RFC 7801, RFC 8891), specifies that it may be referred to as Magma. The GOST hash function is based on this cipher. The new standard also specifies a new 128-bit block cipher called Kuznyechik.<br><br>Developed in the 1970s, the standard had been marked 'Top Secret' and then downgraded to 'Secret' in 1990. Shortly after the dissolution of the USSR, it was declassified and it was released to the public in 1994. GOST 28147 was a Soviet alternative to the United States standard algorithm, DES. Thus, the two are very similar in structure.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output type",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1989)",
              "on": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Magma, 2015)",
              "off": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Kuznyechik, 2015)",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        },
        {
          "name": "Block mode",
          "type": "option",
          "value": [
            "ECB",
            "CFB",
            "OFB",
            "CTR",
            "CBC"
          ]
        },
        {
          "name": "Key meshing mode",
          "type": "option",
          "value": [
            "NO",
            "CP"
          ]
        },
        {
          "name": "Padding",
          "type": "option",
          "value": [
            "NO",
            "PKCS5",
            "ZERO",
            "RANDOM",
            "BIT"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "GOST Hash",
      "module": "Hashing",
      "description": "The GOST hash function, defined in the standards GOST R 34.11-94 and GOST 34.311-95 is a 256-bit cryptographic hash function. It was initially defined in the Russian national standard GOST R 34.11-94 <i>Information Technology \u2013 Cryptographic Information Security \u2013 Hash Function</i>. The equivalent standard used by other member-states of the CIS is GOST 34.311-95.<br><br>This function must not be confused with a different Streebog hash function, which is defined in the new revision of the standard GOST R 34.11-2012.<br><br>The GOST hash function is based on the GOST block cipher.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1994)",
              "off": [
                1
              ],
              "on": [
                2
              ]
            },
            {
              "name": "GOST R 34.11 (Streebog, 2012)",
              "on": [
                1
              ],
              "off": [
                2
              ]
            }
          ]
        },
        {
          "name": "Digest length",
          "type": "option",
          "value": [
            "256",
            "512"
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "GOST Key Unwrap",
      "module": "Ciphers",
      "description": "A decryptor for keys wrapped using one of the GOST block ciphers.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "User Key Material",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output type",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1989)",
              "on": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Magma, 2015)",
              "off": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Kuznyechik, 2015)",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        },
        {
          "name": "Key wrapping",
          "type": "option",
          "value": [
            "NO",
            "CP",
            "SC"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "GOST Key Wrap",
      "module": "Ciphers",
      "description": "A key wrapping algorithm for protecting keys in untrusted storage using one of the GOST block cipers.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "User Key Material",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output type",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1989)",
              "on": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Magma, 2015)",
              "off": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Kuznyechik, 2015)",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        },
        {
          "name": "Key wrapping",
          "type": "option",
          "value": [
            "NO",
            "CP",
            "SC"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "GOST Sign",
      "module": "Ciphers",
      "description": "Sign a plaintext message using one of the GOST block ciphers.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output type",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1989)",
              "on": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Magma, 2015)",
              "off": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Kuznyechik, 2015)",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        },
        {
          "name": "MAC length",
          "type": "number",
          "value": 32
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "GOST Verify",
      "module": "Ciphers",
      "description": "Verify the signature of a plaintext message using one of the GOST block ciphers. Enter the signature in the MAC field.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "MAC",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Algorithm",
          "type": "argSelector",
          "value": [
            {
              "name": "GOST 28147 (1989)",
              "on": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Magma, 2015)",
              "off": [
                5
              ]
            },
            {
              "name": "GOST R 34.12 (Kuznyechik, 2015)",
              "off": [
                5
              ]
            }
          ]
        },
        {
          "name": "sBox",
          "type": "option",
          "value": [
            "E-TEST",
            "E-A",
            "E-B",
            "E-C",
            "E-D",
            "E-SC",
            "E-Z",
            "D-TEST",
            "D-A",
            "D-SC"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "HASSH Client Fingerprint",
      "module": "Crypto",
      "description": "Generates a HASSH fingerprint to help identify SSH clients based on hashing together values from the Client Key Exchange Init message.<br><br>Input: A hex stream of the SSH_MSG_KEXINIT packet application layer from Client to Server.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Hash digest",
            "HASSH algorithms string",
            "Full details"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "HASSH Server Fingerprint",
      "module": "Crypto",
      "description": "Generates a HASSH fingerprint to help identify SSH servers based on hashing together values from the Server Key Exchange Init message.<br><br>Input: A hex stream of the SSH_MSG_KEXINIT packet application layer from Server to Client.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Hash digest",
            "HASSH algorithms string",
            "Full details"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "HMAC",
      "module": "Crypto",
      "description": "Keyed-Hash Message Authentication Codes (HMAC) are a mechanism for message authentication using cryptographic hash functions.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        },
        {
          "name": "Hashing function",
          "type": "option",
          "value": [
            "MD2",
            "MD4",
            "MD5",
            "SHA0",
            "SHA1",
            "SHA224",
            "SHA256",
            "SHA384",
            "SHA512",
            "SHA512/224",
            "SHA512/256",
            "RIPEMD128",
            "RIPEMD160",
            "RIPEMD256",
            "RIPEMD320",
            "HAS160",
            "Whirlpool",
            "Whirlpool-0",
            "Whirlpool-T",
            "Snefru"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "HTML To Text",
      "module": "Default",
      "description": "Converts an HTML output from an operation to a readable string instead of being rendered in the DOM.",
      "inputType": "html",
      "outputType": "string",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "HTTP request",
      "module": "Default",
      "description": "Makes an HTTP request and returns the response.\n<br><br>\nThis operation supports different HTTP verbs like GET, POST, PUT, etc.\n<br><br>\nYou can add headers line by line in the format <code>Key: Value</code>\n<br><br>\nThe status code of the response, along with a limited selection of exposed headers, can be viewed by checking the 'Show response metadata' option. Only a limited set of response headers are exposed by the browser for security reasons.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Method",
          "type": "option",
          "value": [
            "GET",
            "POST",
            "HEAD",
            "PUT",
            "PATCH",
            "DELETE",
            "CONNECT",
            "TRACE",
            "OPTIONS"
          ]
        },
        {
          "name": "URL",
          "type": "string",
          "value": ""
        },
        {
          "name": "Headers",
          "type": "text",
          "value": ""
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "Cross-Origin Resource Sharing",
            "No CORS (limited to HEAD, GET or POST)"
          ]
        },
        {
          "name": "Show response metadata",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "IPv6 Transition Addresses",
      "module": "Default",
      "description": "Converts IPv4 addresses to their IPv6 Transition addresses. IPv6 Transition addresses can also be converted back into their original IPv4 address. MAC addresses can also be converted into the EUI-64 format, this can them be appended to your IPv6 /64 range to obtain a full /128 address.<br><br>Transition technologies enable translation between IPv4 and IPv6 addresses or tunneling to allow traffic to pass through the incompatible network, allowing the two standards to coexist.<br><br>Only /24 ranges and currently handled. Remove headers to easily copy out results.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Ignore ranges",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Remove headers",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "JA3 Fingerprint",
      "module": "Crypto",
      "description": "Generates a JA3 fingerprint to help identify TLS clients based on hashing together values from the Client Hello.<br><br>Input: A hex stream of the TLS Client Hello packet application layer.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Hash digest",
            "JA3 string",
            "Full details"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "JA3S Fingerprint",
      "module": "Crypto",
      "description": "Generates a JA3S fingerprint to help identify TLS servers based on hashing together values from the Server Hello.<br><br>Input: A hex stream of the TLS Server Hello record application layer.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Hash digest",
            "JA3S string",
            "Full details"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "JA4 Fingerprint",
      "module": "Crypto",
      "description": "Generates a JA4 fingerprint to help identify TLS clients based on hashing together values from the Client Hello.<br><br>Input: A hex stream of the TLS or QUIC Client Hello packet application layer.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "JA4",
            "JA4 Original Rendering",
            "JA4 Raw",
            "JA4 Raw Original Rendering",
            "All"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "JA4Server Fingerprint",
      "module": "Crypto",
      "description": "Generates a JA4Server Fingerprint (JA4S) to help identify TLS servers or sessions based on hashing together values from the Server Hello.<br><br>Input: A hex stream of the TLS or QUIC Server Hello packet application layer.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Base64",
            "Raw"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "JA4S",
            "JA4S Raw",
            "Both"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "JPath expression",
      "module": "Code",
      "description": "Extract information from a JSON object with a JPath query.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Query",
          "type": "string",
          "value": ""
        },
        {
          "name": "Result delimiter",
          "type": "binaryShortString",
          "value": "\\n"
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "JSON Beautify",
      "module": "Code",
      "description": "Indents and pretty prints JavaScript Object Notation (JSON) code.<br><br>Tags: json viewer, prettify, syntax highlighting",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Indent string",
          "type": "binaryShortString",
          "value": "    "
        },
        {
          "name": "Sort Object Keys",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Formatted",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "JSON Minify",
      "module": "Code",
      "description": "Compresses JavaScript Object Notation (JSON) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "JSON to CSV",
      "module": "Default",
      "description": "Converts JSON data to a CSV based on the definition in RFC 4180.",
      "inputType": "JSON",
      "outputType": "string",
      "args": [
        {
          "name": "Cell delimiter",
          "type": "binaryShortString",
          "value": ","
        },
        {
          "name": "Row delimiter",
          "type": "binaryShortString",
          "value": "\\r\\n"
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "JSON to YAML",
      "module": "Default",
      "description": "Format a JSON object into YAML",
      "inputType": "JSON",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "JWK to PEM",
      "module": "PublicKey",
      "description": "Converts Keys in JSON Web Key format to PEM format (PKCS#8).",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "JWT Decode",
      "module": "Crypto",
      "description": "Decodes a JSON Web Token <b>without</b> checking whether the provided secret / private key is valid. Use 'JWT Verify' to check if the signature is valid as well.",
      "inputType": "string",
      "outputType": "JSON",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "JWT Sign",
      "module": "Crypto",
      "description": "Signs a JSON object as a JSON Web Token using a provided secret / private key.<br><br>The key should be either the secret for HMAC algorithms or the PEM-encoded private key for RSA and ECDSA.",
      "inputType": "JSON",
      "outputType": "string",
      "args": [
        {
          "name": "Private/Secret Key",
          "type": "text",
          "value": "secret"
        },
        {
          "name": "Signing algorithm",
          "type": "option",
          "value": [
            "HS256",
            "HS384",
            "HS512",
            "RS256",
            "RS384",
            "RS512",
            "ES256",
            "ES384",
            "ES512",
            "None"
          ]
        },
        {
          "name": "Header",
          "type": "text",
          "value": "{}"
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "JWT Verify",
      "module": "Crypto",
      "description": "Verifies that a JSON Web Token is valid and has been signed with the provided secret / private key.<br><br>The key should be either the secret for HMAC algorithms or the PEM-encoded public key for RSA and ECDSA.",
      "inputType": "string",
      "outputType": "JSON",
      "args": [
        {
          "name": "Public/Secret Key",
          "type": "text",
          "value": "secret"
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "LM Hash",
      "module": "Crypto",
      "description": "An LM Hash, or LAN Manager Hash, is a deprecated way of storing passwords on old Microsoft operating systems. It is particularly weak and can be cracked in seconds on modern hardware using rainbow tables.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "LS47 Decrypt",
      "module": "Crypto",
      "description": "This is a slight improvement of the ElsieFour cipher as described by Alan Kaminsky. We use 7x7 characters instead of original (barely fitting) 6x6, to be able to encrypt some structured information. We also describe a simple key-expansion algorithm, because remembering passwords is popular. Similar security considerations as with ElsieFour hold.<br>The LS47 alphabet consists of following characters: <code>_abcdefghijklmnopqrstuvwxyz.0123456789,-+*/:?!'()</code><br>An LS47 key is a permutation of the alphabet that is then represented in a 7x7 grid used for the encryption or decryption.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Password",
          "type": "string",
          "value": ""
        },
        {
          "name": "Padding",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "LS47 Encrypt",
      "module": "Crypto",
      "description": "This is a slight improvement of the ElsieFour cipher as described by Alan Kaminsky. We use 7x7 characters instead of original (barely fitting) 6x6, to be able to encrypt some structured information. We also describe a simple key-expansion algorithm, because remembering passwords is popular. Similar security considerations as with ElsieFour hold.<br>The LS47 alphabet consists of following characters: <code>_abcdefghijklmnopqrstuvwxyz.0123456789,-+*/:?!'()</code><br>A LS47 key is a permutation of the alphabet that is then represented in a 7x7 grid used for the encryption or decryption.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Password",
          "type": "string",
          "value": ""
        },
        {
          "name": "Padding",
          "type": "number",
          "value": 10
        },
        {
          "name": "Signature",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "LZ4 Compress",
      "module": "Compression",
      "description": "LZ4 is a lossless data compression algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family of byte-oriented compression schemes.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "LZ4 Decompress",
      "module": "Compression",
      "description": "LZ4 is a lossless data compression algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family of byte-oriented compression schemes.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "LZMA Compress",
      "module": "Compression",
      "description": "Compresses data using the Lempel\u2013Ziv\u2013Markov chain algorithm. Compression mode determines the speed and effectiveness of the compression: 1 is fastest and less effective, 9 is slowest and most effective",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Compression Mode",
          "type": "option",
          "value": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
          ]
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "LZMA Decompress",
      "module": "Compression",
      "description": "Decompresses data using the Lempel-Ziv-Markov chain Algorithm.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "LZNT1 Decompress",
      "module": "Compression",
      "description": "Decompresses data using the LZNT1 algorithm.<br><br>Similar to the Windows API <code>RtlDecompressBuffer</code>.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "LZString Compress",
      "module": "Compression",
      "description": "Compress the input with lz-string.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Compression Format",
          "type": "option",
          "value": [
            "default",
            "UTF16",
            "Base64"
          ]
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "LZString Decompress",
      "module": "Compression",
      "description": "Decompresses data that was compressed with lz-string.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Compression Format",
          "type": "option",
          "value": [
            "default",
            "UTF16",
            "Base64"
          ]
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "MD2",
      "module": "Crypto",
      "description": "The MD2 (Message-Digest 2) algorithm is a cryptographic hash function developed by Ronald Rivest in 1989. The algorithm is optimized for 8-bit computers.<br><br>Although MD2 is no longer considered secure, even as of 2014, it remains in use in public key infrastructures as part of certificates generated with MD2 and RSA. The message digest algorithm consists, by default, of 18 rounds.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Rounds",
          "type": "number",
          "value": 18
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "MD4",
      "module": "Crypto",
      "description": "The MD4 (Message-Digest 4) algorithm is a cryptographic hash function developed by Ronald Rivest in 1990. The digest length is 128 bits. The algorithm has influenced later designs, such as the MD5, SHA-1 and RIPEMD algorithms.<br><br>The security of MD4 has been severely compromised.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "MD5",
      "module": "Crypto",
      "description": "MD5 (Message-Digest 5) is a widely used hash function. It has been used in a variety of security applications and is also commonly used to check the integrity of files.<br><br>However, MD5 is not collision resistant and it isn't suitable for applications like SSL/TLS certificates or digital signatures that rely on this property.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "MD6",
      "module": "Crypto",
      "description": "The MD6 (Message-Digest 6) algorithm is a cryptographic hash function. It uses a Merkle tree-like structure to allow for immense parallel computation of hashes for very long inputs.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "number",
          "value": 256
        },
        {
          "name": "Levels",
          "type": "number",
          "value": 64
        },
        {
          "name": "Key",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "MIME Decoding",
      "module": "Default",
      "description": "Enables the decoding of MIME message header extensions for non-ASCII text",
      "inputType": "byteArray",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "NOT",
      "module": "Default",
      "description": "Returns the inverse of each byte.",
      "inputType": "ArrayBuffer",
      "outputType": "byteArray",
      "args": [],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "NT Hash",
      "module": "Crypto",
      "description": "An NT Hash, sometimes referred to as an NTLM hash, is a method of storing passwords on Windows systems. It works by running MD4 on UTF-16LE encoded input. NTLM hashes are considered weak because they can be brute-forced very easily with modern hardware.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "OR",
      "module": "Default",
      "description": "OR the input with the given key.<br>e.g. <code>fe023da5</code>",
      "inputType": "ArrayBuffer",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Binary",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "PEM to Hex",
      "module": "Default",
      "description": "Converts PEM (Privacy Enhanced Mail) format to a hexadecimal DER (Distinguished Encoding Rules) string.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "PEM to JWK",
      "module": "PublicKey",
      "description": "Converts Keys in PEM format to a JSON Web Key format.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "PGP Decrypt",
      "module": "PGP",
      "description": "Input: the ASCII-armoured PGP message you want to decrypt.\n<br><br>\nArguments: the ASCII-armoured PGP private key of the recipient, \n(and the private key password if necessary).\n<br><br>\nPretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.\n<br><br>\nThis function uses the Keybase implementation of PGP.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Private key of recipient",
          "type": "text",
          "value": ""
        },
        {
          "name": "Private key passphrase",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "PGP Decrypt and Verify",
      "module": "PGP",
      "description": "Input: the ASCII-armoured encrypted PGP message you want to verify.\n<br><br>\nArguments: the ASCII-armoured PGP public key of the signer, \nthe ASCII-armoured private key of the recipient (and the private key password if necessary).\n<br><br>\nThis operation uses PGP to decrypt and verify an encrypted digital signature.\n<br><br>\nPretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.\n<br><br>\nThis function uses the Keybase implementation of PGP.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Public key of signer",
          "type": "text",
          "value": ""
        },
        {
          "name": "Private key of recipient",
          "type": "text",
          "value": ""
        },
        {
          "name": "Private key password",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "PGP Encrypt",
      "module": "PGP",
      "description": "Input: the message you want to encrypt.\n<br><br>\nArguments: the ASCII-armoured PGP public key of the recipient.\n<br><br>\nPretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.\n<br><br>\nThis function uses the Keybase implementation of PGP.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Public key of recipient",
          "type": "text",
          "value": ""
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "PGP Encrypt and Sign",
      "module": "PGP",
      "description": "Input: the cleartext you want to sign.\n<br><br>\nArguments: the ASCII-armoured private key of the signer (plus the private key password if necessary)\nand the ASCII-armoured PGP public key of the recipient.\n<br><br>\nThis operation uses PGP to produce an encrypted digital signature.\n<br><br>\nPretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.\n<br><br>\nThis function uses the Keybase implementation of PGP.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Private key of signer",
          "type": "text",
          "value": ""
        },
        {
          "name": "Private key passphrase",
          "type": "string",
          "value": ""
        },
        {
          "name": "Public key of recipient",
          "type": "text",
          "value": ""
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "PGP Verify",
      "module": "PGP",
      "description": "Input: the ASCII-armoured encrypted PGP message you want to verify.\n<br><br>\nArgument: the ASCII-armoured PGP public key of the signer\n<br><br>\nThis operation uses PGP to decrypt a clearsigned message.\n<br><br>\nPretty Good Privacy is an encryption standard (OpenPGP) used for encrypting, decrypting, and signing messages.\n<br><br>\nThis function uses the Keybase implementation of PGP.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Public key of signer",
          "type": "text",
          "value": ""
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "PHP Deserialize",
      "module": "Default",
      "description": "Deserializes PHP serialized data, outputting keyed arrays as JSON.<br><br>This function does not support <code>object</code> tags.<br><br>Example:<br><code>a:2:{s:1:&quot;a&quot;;i:10;i:0;a:1:{s:2:&quot;ab&quot;;b:1;}}</code><br>becomes<br><code>{&quot;a&quot;: 10,0: {&quot;ab&quot;: true}}</code><br><br><u>Output valid JSON:</u> JSON doesn't support integers as keys, whereas PHP serialization does. Enabling this will cast these integers to strings. This will also escape backslashes.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Output valid JSON",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "PHP Serialize",
      "module": "Default",
      "description": "Performs PHP serialization on JSON data.<br><br>This function does not support <code>object</code> tags.<br><br>Since PHP doesn't distinguish dicts and arrays, this operation is not always symmetric to <code>PHP Deserialize</code>.<br><br>Example:<br><code>[5,&quot;abc&quot;,true]</code><br>becomes<br><code>a:3:{i:0;i:5;i:1;s:3:&quot;abc&quot;;i:2;b:1;}<code>",
      "inputType": "JSON",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "RAKE",
      "module": "Default",
      "description": "Rapid Keyword Extraction (RAKE)\n<br><br>\nRAKE is a domain-independent keyword extraction algorithm in Natural Language Processing.\n<br><br>\nThe list of stop words are from the NLTK python package",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Word Delimiter (Regex)",
          "type": "text",
          "value": "\\s"
        },
        {
          "name": "Sentence Delimiter (Regex)",
          "type": "text",
          "value": "\\.\\s|\\n"
        },
        {
          "name": "Stop Words",
          "type": "text",
          "value": "i,me,my,myself,we,our,ours,ourselves,you,you're,you've,you'll,you'd,your,yours,yourself,yourselves,he,him,his,himself,she,she's,her,hers,herself,it,it's,its,itsef,they,them,their,theirs,themselves,what,which,who,whom,this,that,that'll,these,those,am,is,are,was,were,be,been,being,have,has,had,having,do,does',did,doing,a,an,the,and,but,if,or,because,as,until,while,of,at,by,for,with,about,against,between,into,through,during,before,after,above,below,to,from,up,down,in,out,on,off,over,under,again,further,then,once,here,there,when,where,why,how,all,any,both,each,few,more,most,other,some,such,no,nor,not,only,own,same,so,than,too,very,s,t,can,will,just,don,don't,should,should've,now,d,ll,m,o,re,ve,y,ain,aren,aren't,couldn,couldn't,didn,didn't,doesn,doesn't,hadn,hadn't,hasn,hasn't,haven,haven't,isn,isn't,ma,mightn,mightn't,mustn,mustn't,needn,needn't,shan,shan't,shouldn,shouldn't,wasn,wasn't,weren,weren't,won,won't,wouldn,wouldn't"
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "RC2 Decrypt",
      "module": "Ciphers",
      "description": "RC2 (also known as ARC2) is a symmetric-key block cipher designed by Ron Rivest in 1987. 'RC' stands for 'Rivest Cipher'.<br><br><b>Key:</b> RC2 uses a variable size key.<br><br><b>IV:</b> To run the cipher in CBC mode, the Initialization Vector should be 8 bytes long. If the IV is left blank, the cipher will run in ECB mode.<br><br><b>Padding:</b> In both CBC and ECB mode, PKCS#7 padding will be used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "RC2 Encrypt",
      "module": "Ciphers",
      "description": "RC2 (also known as ARC2) is a symmetric-key block cipher designed by Ron Rivest in 1987. 'RC' stands for 'Rivest Cipher'.<br><br><b>Key:</b> RC2 uses a variable size key.<br><br>You can generate a password-based key using one of the KDF operations.<br><br><b>IV:</b> To run the cipher in CBC mode, the Initialization Vector should be 8 bytes long. If the IV is left blank, the cipher will run in ECB mode.<br><br><b>Padding:</b> In both CBC and ECB mode, PKCS#7 padding will be used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "RC4",
      "module": "Ciphers",
      "description": "RC4 (also known as ARC4) is a widely-used stream cipher designed by Ron Rivest. It is used in popular protocols such as SSL and WEP. Although remarkable for its simplicity and speed, the algorithm's history doesn't inspire confidence in its security.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Passphrase",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "UTF8",
            "UTF16",
            "UTF16LE",
            "UTF16BE",
            "Latin1",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Latin1",
            "UTF8",
            "UTF16",
            "UTF16LE",
            "UTF16BE",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Latin1",
            "UTF8",
            "UTF16",
            "UTF16LE",
            "UTF16BE",
            "Hex",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "RC4 Drop",
      "module": "Ciphers",
      "description": "It was discovered that the first few bytes of the RC4 keystream are strongly non-random and leak information about the key. We can defend against this attack by discarding the initial portion of the keystream. This modified algorithm is traditionally called RC4-drop.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Passphrase",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "UTF8",
            "UTF16",
            "UTF16LE",
            "UTF16BE",
            "Latin1",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Latin1",
            "UTF8",
            "UTF16",
            "UTF16LE",
            "UTF16BE",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Latin1",
            "UTF8",
            "UTF16",
            "UTF16LE",
            "UTF16BE",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Number of dwords to drop",
          "type": "number",
          "value": 192
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "RIPEMD",
      "module": "Crypto",
      "description": "RIPEMD (RACE Integrity Primitives Evaluation Message Digest) is a family of cryptographic hash functions developed in Leuven, Belgium, by Hans Dobbertin, Antoon Bosselaers and Bart Preneel at the COSIC research group at the Katholieke Universiteit Leuven, and first published in 1996.<br><br>RIPEMD was based upon the design principles used in MD4, and is similar in performance to the more popular SHA-1.<br><br>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "option",
          "value": [
            "320",
            "256",
            "160",
            "128"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "ROT13",
      "module": "Default",
      "description": "A simple caesar substitution cipher which rotates alphabet characters by the specified amount (default 13).",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Rotate lower case chars",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Rotate upper case chars",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Rotate numbers",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Amount",
          "type": "number",
          "value": 13
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "ROT13 Brute Force",
      "module": "Default",
      "description": "Try all meaningful amounts for ROT13.<br><br>Optionally you can enter your known plaintext (crib) to filter the result.",
      "inputType": "byteArray",
      "outputType": "string",
      "args": [
        {
          "name": "Rotate lower case chars",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Rotate upper case chars",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Rotate numbers",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sample length",
          "type": "number",
          "value": 100
        },
        {
          "name": "Sample offset",
          "type": "number",
          "value": 0
        },
        {
          "name": "Print amount",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Crib (known plaintext string)",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "ROT47",
      "module": "Default",
      "description": "A slightly more complex variation of a caesar cipher, which includes ASCII characters from 33 '!' to 126 '~'. Default rotation: 47.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Amount",
          "type": "number",
          "value": 47
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "ROT47 Brute Force",
      "module": "Default",
      "description": "Try all meaningful amounts for ROT47.<br><br>Optionally you can enter your known plaintext (crib) to filter the result.",
      "inputType": "byteArray",
      "outputType": "string",
      "args": [
        {
          "name": "Sample length",
          "type": "number",
          "value": 100
        },
        {
          "name": "Sample offset",
          "type": "number",
          "value": 0
        },
        {
          "name": "Print amount",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Crib (known plaintext string)",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "ROT8000",
      "module": "Default",
      "description": "The simple Caesar-cypher encryption that replaces each Unicode character with the one 0x8000 places forward or back along the alphabet.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "RSA Decrypt",
      "module": "Ciphers",
      "description": "Decrypt an RSA encrypted message with a PEM encoded private key.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "RSA Private Key (PEM)",
          "type": "text",
          "value": "-----BEGIN RSA PRIVATE KEY-----"
        },
        {
          "name": "Key Password",
          "type": "text",
          "value": ""
        },
        {
          "name": "Encryption Scheme",
          "type": "argSelector",
          "value": [
            {
              "name": "RSA-OAEP",
              "on": [
                3
              ]
            },
            {
              "name": "RSAES-PKCS1-V1_5",
              "off": [
                3
              ]
            },
            {
              "name": "RAW",
              "off": [
                3
              ]
            }
          ]
        },
        {
          "name": "Message Digest Algorithm",
          "type": "option",
          "value": [
            "SHA-1",
            "MD5",
            "SHA-256",
            "SHA-384",
            "SHA-512"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "RSA Encrypt",
      "module": "Ciphers",
      "description": "Encrypt a message with a PEM encoded RSA public key.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "RSA Public Key (PEM)",
          "type": "text",
          "value": "-----BEGIN RSA PUBLIC KEY-----"
        },
        {
          "name": "Encryption Scheme",
          "type": "argSelector",
          "value": [
            {
              "name": "RSA-OAEP",
              "on": [
                2
              ]
            },
            {
              "name": "RSAES-PKCS1-V1_5",
              "off": [
                2
              ]
            },
            {
              "name": "RAW",
              "off": [
                2
              ]
            }
          ]
        },
        {
          "name": "Message Digest Algorithm",
          "type": "option",
          "value": [
            "SHA-1",
            "MD5",
            "SHA-256",
            "SHA-384",
            "SHA-512"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "RSA Sign",
      "module": "Ciphers",
      "description": "Sign a plaintext message with a PEM encoded RSA key.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "RSA Private Key (PEM)",
          "type": "text",
          "value": "-----BEGIN RSA PRIVATE KEY-----"
        },
        {
          "name": "Key Password",
          "type": "text",
          "value": ""
        },
        {
          "name": "Message Digest Algorithm",
          "type": "option",
          "value": [
            "SHA-1",
            "MD5",
            "SHA-256",
            "SHA-384",
            "SHA-512"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "RSA Verify",
      "module": "Ciphers",
      "description": "Verify a message against a signature and a public PEM encoded RSA key.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "RSA Public Key (PEM)",
          "type": "text",
          "value": "-----BEGIN RSA PUBLIC KEY-----"
        },
        {
          "name": "Message",
          "type": "text",
          "value": ""
        },
        {
          "name": "Message format",
          "type": "option",
          "value": [
            "Raw",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Message Digest Algorithm",
          "type": "option",
          "value": [
            "SHA-1",
            "MD5",
            "SHA-256",
            "SHA-384",
            "SHA-512"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Return",
      "module": "Default",
      "description": "End execution of operations at this point in the recipe.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "SHA0",
      "module": "Crypto",
      "description": "SHA-0 is a retronym applied to the original version of the 160-bit hash function published in 1993 under the name 'SHA'. It was withdrawn shortly after publication due to an undisclosed 'significant flaw' and replaced by the slightly revised version SHA-1. The message digest algorithm consists, by default, of 80 rounds.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Rounds",
          "type": "number",
          "value": 80
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "SHA1",
      "module": "Crypto",
      "description": "The SHA (Secure Hash Algorithm) hash functions were designed by the NSA. SHA-1 is the most established of the existing SHA hash functions and it is used in a variety of security applications and protocols.<br><br>However, SHA-1's collision resistance has been weakening as new attacks are discovered or improved. The message digest algorithm consists, by default, of 80 rounds.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Rounds",
          "type": "number",
          "value": 80
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "SHA2",
      "module": "Crypto",
      "description": "The SHA-2 (Secure Hash Algorithm 2) hash functions were designed by the NSA. SHA-2 includes significant changes from its predecessor, SHA-1. The SHA-2 family consists of hash functions with digests (hash values) that are 224, 256, 384 or 512 bits: SHA224, SHA256, SHA384, SHA512.<br><br><ul><li>SHA-512 operates on 64-bit words.</li><li>SHA-256 operates on 32-bit words.</li><li>SHA-384 is largely identical to SHA-512 but is truncated to 384 bytes.</li><li>SHA-224 is largely identical to SHA-256 but is truncated to 224 bytes.</li><li>SHA-512/224 and SHA-512/256 are truncated versions of SHA-512, but the initial values are generated using the method described in Federal Information Processing Standards (FIPS) PUB 180-4.</li></ul> The message digest algorithm for SHA256 variants consists, by default, of 64 rounds, and for SHA512 variants, it is, by default, 160.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "argSelector",
          "value": [
            {
              "name": "512",
              "on": [
                2
              ],
              "off": [
                1
              ]
            },
            {
              "name": "384",
              "on": [
                2
              ],
              "off": [
                1
              ]
            },
            {
              "name": "256",
              "on": [
                1
              ],
              "off": [
                2
              ]
            },
            {
              "name": "224",
              "on": [
                1
              ],
              "off": [
                2
              ]
            },
            {
              "name": "512/256",
              "on": [
                2
              ],
              "off": [
                1
              ]
            },
            {
              "name": "512/224",
              "on": [
                2
              ],
              "off": [
                1
              ]
            }
          ]
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 64
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 160
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "SHA3",
      "module": "Crypto",
      "description": "The SHA-3 (Secure Hash Algorithm 3) hash functions were released by NIST on August 5, 2015. Although part of the same series of standards, SHA-3 is internally quite different from the MD5-like structure of SHA-1 and SHA-2.<br><br>SHA-3 is a subset of the broader cryptographic primitive family Keccak designed by Guido Bertoni, Joan Daemen, Micha\u00ebl Peeters, and Gilles Van Assche, building upon RadioGat\u00fan.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "option",
          "value": [
            "512",
            "384",
            "256",
            "224"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "SIGABA",
      "module": "Bletchley",
      "description": "Encipher/decipher with the WW2 SIGABA machine. <br><br>SIGABA, otherwise known as ECM Mark II, was used by the United States for message encryption during WW2 up to the 1950s. It was developed in the 1930s by the US Army and Navy, and has up to this day never been broken. Consisting of 15 rotors: 5 cipher rotors and 10 rotors (5 control rotors and 5 index rotors) controlling the stepping of the cipher rotors, the rotor stepping for SIGABA is much more complex than other rotor machines of its time, such as Enigma. All example rotor wirings are random example sets.<br><br>To configure rotor wirings, for the cipher and control rotors enter a string of letters which map from A to Z, and for the index rotors enter a sequence of numbers which map from 0 to 9. Note that encryption is not the same as decryption, so first choose the desired mode. <br><br> Note: Whilst this has been tested against other software emulators, it has not been tested against hardware.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "1st (left-hand) cipher rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "1st cipher rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "1st cipher rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "2nd cipher rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "2nd cipher rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "2nd cipher rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "3rd (middle) cipher rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "3rd cipher rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "3rd cipher rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "4th cipher rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "4th cipher rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "4th cipher rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "5th (right-hand) cipher rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "5th cipher rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "5th cipher rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "1st (left-hand) control rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "1st control rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "1st control rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "2nd control rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "2nd control rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "2nd control rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "3rd (middle) control rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "3rd control rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "3rd control rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "4th control rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "4th control rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "4th control rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "5th (right-hand) control rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "SRGWANHPJZFXVIDQCEUKBYOLMT"
            },
            {
              "name": "Example 2",
              "value": "THQEFSAZVKJYULBODCPXNIMWRG"
            },
            {
              "name": "Example 3",
              "value": "XDTUYLEVFNQZBPOGIRCSMHWKAJ"
            },
            {
              "name": "Example 4",
              "value": "LOHDMCWUPSTNGVXYFJREQIKBZA"
            },
            {
              "name": "Example 5",
              "value": "ERXWNZQIJYLVOFUMSGHTCKPBDA"
            },
            {
              "name": "Example 6",
              "value": "FQECYHJIOUMDZVPSLKRTGWXBAN"
            },
            {
              "name": "Example 7",
              "value": "TBYIUMKZDJSOPEWXVANHLCFQGR"
            },
            {
              "name": "Example 8",
              "value": "QZUPDTFNYIAOMLEBWJXCGHKRSV"
            },
            {
              "name": "Example 9",
              "value": "CZWNHEMPOVXLKRSIDGJFYBTQAU"
            },
            {
              "name": "Example 10",
              "value": "ENPXJVKYQBFZTICAGMOHWRLDUS"
            }
          ]
        },
        {
          "name": "5th control rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "5th control rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "1st (left-hand) index rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "6201348957"
            },
            {
              "name": "Example 2",
              "value": "6147253089"
            },
            {
              "name": "Example 3",
              "value": "8239647510"
            },
            {
              "name": "Example 4",
              "value": "7194835260"
            },
            {
              "name": "Example 5",
              "value": "4873205916"
            }
          ]
        },
        {
          "name": "1st index rotor initial value",
          "type": "option",
          "value": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
          ]
        },
        {
          "name": "2nd index rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "6201348957"
            },
            {
              "name": "Example 2",
              "value": "6147253089"
            },
            {
              "name": "Example 3",
              "value": "8239647510"
            },
            {
              "name": "Example 4",
              "value": "7194835260"
            },
            {
              "name": "Example 5",
              "value": "4873205916"
            }
          ]
        },
        {
          "name": "2nd index rotor initial value",
          "type": "option",
          "value": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
          ]
        },
        {
          "name": "3rd (middle) index rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "6201348957"
            },
            {
              "name": "Example 2",
              "value": "6147253089"
            },
            {
              "name": "Example 3",
              "value": "8239647510"
            },
            {
              "name": "Example 4",
              "value": "7194835260"
            },
            {
              "name": "Example 5",
              "value": "4873205916"
            }
          ]
        },
        {
          "name": "3rd index rotor initial value",
          "type": "option",
          "value": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
          ]
        },
        {
          "name": "4th index rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "6201348957"
            },
            {
              "name": "Example 2",
              "value": "6147253089"
            },
            {
              "name": "Example 3",
              "value": "8239647510"
            },
            {
              "name": "Example 4",
              "value": "7194835260"
            },
            {
              "name": "Example 5",
              "value": "4873205916"
            }
          ]
        },
        {
          "name": "4th index rotor initial value",
          "type": "option",
          "value": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
          ]
        },
        {
          "name": "5th (right-hand) index rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "6201348957"
            },
            {
              "name": "Example 2",
              "value": "6147253089"
            },
            {
              "name": "Example 3",
              "value": "8239647510"
            },
            {
              "name": "Example 4",
              "value": "7194835260"
            },
            {
              "name": "Example 5",
              "value": "4873205916"
            }
          ]
        },
        {
          "name": "5th index rotor initial value",
          "type": "option",
          "value": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
          ]
        },
        {
          "name": "SIGABA mode",
          "type": "option",
          "value": [
            "Encrypt",
            "Decrypt"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "SM2 Decrypt",
      "module": "Crypto",
      "description": "Decrypts a message utilizing the SM2 standard",
      "inputType": "string",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Private Key",
          "type": "string",
          "value": "DEADBEEF"
        },
        {
          "name": "Input Format",
          "type": "option",
          "value": [
            "C1C3C2",
            "C1C2C3"
          ]
        },
        {
          "name": "Curve",
          "type": "option",
          "value": [
            "sm2p256v1"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "SM2 Encrypt",
      "module": "Crypto",
      "description": "Encrypts a message utilizing the SM2 standard",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Public Key X",
          "type": "string",
          "value": "DEADBEEF"
        },
        {
          "name": "Public Key Y",
          "type": "string",
          "value": "DEADBEEF"
        },
        {
          "name": "Output Format",
          "type": "option",
          "value": [
            "C1C3C2",
            "C1C2C3"
          ]
        },
        {
          "name": "Curve",
          "type": "option",
          "value": [
            "sm2p256v1"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "SM3",
      "module": "Crypto",
      "description": "SM3 is a cryptographic hash function used in the Chinese National Standard. SM3 is mainly used in digital signatures, message authentication codes, and pseudorandom number generators. The message digest algorithm consists, by default, of 64 rounds and length of 256.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Length",
          "type": "number",
          "value": 256
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 64
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "SM4 Decrypt",
      "module": "Ciphers",
      "description": "SM4 is a 128-bit block cipher, currently established as a national standard (GB/T 32907-2016) of China.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB",
            "CBC/NoPadding",
            "ECB/NoPadding"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "SM4 Encrypt",
      "module": "Ciphers",
      "description": "SM4 is a 128-bit block cipher, currently established as a national standard (GB/T 32907-2016) of China. Multiple block cipher modes are supported. When using CBC or ECB mode, the PKCS#7 padding scheme is used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "SQL Beautify",
      "module": "Code",
      "description": "Indents and prettifies Structured Query Language (SQL) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Indent string",
          "type": "binaryShortString",
          "value": "\\t"
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "SQL Minify",
      "module": "Code",
      "description": "Compresses Structured Query Language (SQL) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "SSDEEP",
      "module": "Crypto",
      "description": "SSDEEP is a program for computing context triggered piecewise hashes (CTPH). Also called fuzzy hashes, CTPH can match inputs that have homologies. Such inputs have sequences of identical bytes in the same order, although bytes in between these sequences may be different in both content and length.<br><br>SSDEEP hashes are now widely used for simple identification purposes (e.g. the 'Basic Properties' section in VirusTotal). Although 'better' fuzzy hashes are available, SSDEEP is still one of the primary choices because of its speed and being a de facto standard.<br><br>This operation is fundamentally the same as the CTPH operation, however their outputs differ in format.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "SUB",
      "module": "Default",
      "description": "SUB the input with the given key (e.g. <code>fe023da5</code>), MOD 255",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Binary",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "UNIX Timestamp to Windows Filetime",
      "module": "Default",
      "description": "Converts a UNIX timestamp to a Windows Filetime value.<br><br>A Windows Filetime is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 UTC.<br><br>A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).<br><br>This operation also supports UNIX timestamps in milliseconds, microseconds and nanoseconds.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input units",
          "type": "option",
          "value": [
            "Seconds (s)",
            "Milliseconds (ms)",
            "Microseconds (\u03bcs)",
            "Nanoseconds (ns)"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Decimal",
            "Hex (big endian)",
            "Hex (little endian)"
          ]
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "URL Decode",
      "module": "URL",
      "description": "Converts URI/URL percent-encoded characters back to their raw values.<br><br>e.g. <code>%3d</code> becomes <code>=</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Treat \"+\" as space",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "URL Encode",
      "module": "URL",
      "description": "Encodes problematic characters into percent-encoding, a format supported by URIs/URLs.<br><br>e.g. <code>=</code> becomes <code>%3d</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Encode all special chars",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "XKCD Random Number",
      "module": "Default",
      "description": "RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.",
      "inputType": "string",
      "outputType": "number",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "XML Beautify",
      "module": "Code",
      "description": "Indents and prettifies eXtensible Markup Language (XML) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Indent string",
          "type": "binaryShortString",
          "value": "\\t"
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "XML Minify",
      "module": "Code",
      "description": "Compresses eXtensible Markup Language (XML) code.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Preserve comments",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "XOR",
      "module": "Default",
      "description": "XOR the input with the given key.<br>e.g. <code>fe023da5</code><br><br><strong>Options</strong><br><u>Null preserving:</u> If the current byte is 0x00 or the same as the key, skip it.<br><br><u>Scheme:</u><ul><li>Standard - key is unchanged after each round</li><li>Input differential - key is set to the value of the previous unprocessed byte</li><li>Output differential - key is set to the value of the previous processed byte</li><li>Cascade - key is set to the input byte shifted by one</li></ul>",
      "inputType": "ArrayBuffer",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Binary",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        },
        {
          "name": "Scheme",
          "type": "option",
          "value": [
            "Standard",
            "Input differential",
            "Output differential",
            "Cascade"
          ]
        },
        {
          "name": "Null preserving",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "XOR Brute Force",
      "module": "Default",
      "description": "Enumerate all possible XOR solutions. Current maximum key length is 2 due to browser performance.<br><br>Optionally enter a string that you expect to find in the plaintext to filter results (crib).",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Key length",
          "type": "number",
          "value": 1
        },
        {
          "name": "Sample length",
          "type": "number",
          "value": 100
        },
        {
          "name": "Sample offset",
          "type": "number",
          "value": 0
        },
        {
          "name": "Scheme",
          "type": "option",
          "value": [
            "Standard",
            "Input differential",
            "Output differential"
          ]
        },
        {
          "name": "Null preserving",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Print key",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Output as hex",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Crib (known plaintext string)",
          "type": "binaryString",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "XOR Checksum",
      "module": "Crypto",
      "description": "XOR Checksum splits the input into blocks of a configurable size and performs the XOR operation on these blocks.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Blocksize",
          "type": "number",
          "value": 4
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "XPath expression",
      "module": "Code",
      "description": "Extract information from an XML document with an XPath query",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "XPath",
          "type": "string",
          "value": ""
        },
        {
          "name": "Result delimiter",
          "type": "binaryShortString",
          "value": "\\n"
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "XSalsa20",
      "module": "Ciphers",
      "description": "XSalsa20 is a variant of the Salsa20 stream cipher designed by Daniel J. Bernstein; XSalsa uses longer nonces.<br><br><b>Key:</b> XSalsa20 uses a key of 16 or 32 bytes (128 or 256 bits).<br><br><b>Nonce:</b> XSalsa20 uses a nonce of 24 bytes (192 bits).<br><br><b>Counter:</b> XSalsa uses a counter of 8 bytes (64 bits). The counter starts at zero at the start of the keystream, and is incremented at every 64 bytes.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Nonce",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64",
            "Integer"
          ]
        },
        {
          "name": "Counter",
          "type": "number",
          "value": 0
        },
        {
          "name": "Rounds",
          "type": "option",
          "value": [
            "20",
            "12",
            "8"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "XXTEA Decrypt",
      "module": "Ciphers",
      "description": "Corrected Block TEA (often referred to as XXTEA) is a block cipher designed to correct weaknesses in the original Block TEA. XXTEA operates on variable-length blocks that are some arbitrary multiple of 32 bits in size (minimum 64 bits). The number of full cycles depends on the block size, but there are at least six (rising to 32 for small block sizes). The original Block TEA applies the XTEA round function to each word in the block and combines it additively with its leftmost neighbour. Slow diffusion rate of the decryption process was immediately exploited to break the cipher. Corrected Block TEA uses a more involved round function which makes use of both immediate neighbours in processing each word in the block.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "XXTEA Encrypt",
      "module": "Ciphers",
      "description": "Corrected Block TEA (often referred to as XXTEA) is a block cipher designed to correct weaknesses in the original Block TEA. XXTEA operates on variable-length blocks that are some arbitrary multiple of 32 bits in size (minimum 64 bits). The number of full cycles depends on the block size, but there are at least six (rising to 32 for small block sizes). The original Block TEA applies the XTEA round function to each word in the block and combines it additively with its leftmost neighbour. Slow diffusion rate of the decryption process was immediately exploited to break the cipher. Corrected Block TEA uses a more involved round function which makes use of both immediate neighbours in processing each word in the block.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "YAML to JSON",
      "module": "Default",
      "description": "Convert YAML to JSON",
      "inputType": "string",
      "outputType": "JSON",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "YARA Rules",
      "module": "Yara",
      "description": "YARA is a tool developed at VirusTotal, primarily aimed at helping malware researchers to identify and classify malware samples. It matches based on rules specified by the user containing textual or binary patterns and a boolean expression. For help on writing rules, see the <a href='https://yara.readthedocs.io/en/latest/writingrules.html'>YARA documentation.</a>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Rules",
          "type": "text",
          "value": ""
        },
        {
          "name": "Show strings",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Show string lengths",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Show metadata",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Show counts",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show rule warnings",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show console module messages",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Add line numbers",
      "module": "Default",
      "description": "Adds line numbers to the output.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Offset",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Add Text To Image",
      "module": "Image",
      "description": "Adds text onto an image.<br><br>Text can be horizontally or vertically aligned, or the position can be manually specified.<br>Variants of the Roboto font face are available in any size or colour.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Text",
          "type": "string",
          "value": ""
        },
        {
          "name": "Horizontal align",
          "type": "option",
          "value": [
            "None",
            "Left",
            "Center",
            "Right"
          ]
        },
        {
          "name": "Vertical align",
          "type": "option",
          "value": [
            "None",
            "Top",
            "Middle",
            "Bottom"
          ]
        },
        {
          "name": "X position",
          "type": "number",
          "value": 0
        },
        {
          "name": "Y position",
          "type": "number",
          "value": 0
        },
        {
          "name": "Size",
          "type": "number",
          "value": 32
        },
        {
          "name": "Font face",
          "type": "option",
          "value": [
            "Roboto",
            "Roboto Black",
            "Roboto Mono",
            "Roboto Slab"
          ]
        },
        {
          "name": "Red",
          "type": "number",
          "value": 255
        },
        {
          "name": "Green",
          "type": "number",
          "value": 255
        },
        {
          "name": "Blue",
          "type": "number",
          "value": 255
        },
        {
          "name": "Alpha",
          "type": "number",
          "value": 255
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Affine Cipher Decode",
      "module": "Ciphers",
      "description": "The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "a",
          "type": "number",
          "value": 1
        },
        {
          "name": "b",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Affine Cipher Encode",
      "module": "Ciphers",
      "description": "The Affine cipher is a type of monoalphabetic substitution cipher, wherein each letter in an alphabet is mapped to its numeric equivalent, encrypted using simple mathematical function, <code>(ax + b) % 26</code>, and converted back to a letter.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "a",
          "type": "number",
          "value": 1
        },
        {
          "name": "b",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Alternating Caps",
      "module": "Default",
      "description": "Alternating caps, also known as studly caps, sticky caps, or spongecase is a form of text notation in which the capitalization of letters varies by some pattern, or arbitrarily. An example of this would be spelling 'alternative caps' as 'aLtErNaTiNg CaPs'.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Analyse hash",
      "module": "Crypto",
      "description": "Tries to determine information about a given hash and suggests which algorithm may have been used to generate it based on its length.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Analyse UUID",
      "module": "Crypto",
      "description": "Tries to determine information about a given UUID and suggests which version may have been used to generate it",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Argon2",
      "module": "Crypto",
      "description": "Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from the University of Luxembourg.<br><br>Enter the password in the input to generate its hash.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Salt",
          "type": "toggleString",
          "value": "somesalt",
          "toggleValues": [
            "UTF8",
            "Hex",
            "Base64",
            "Latin1"
          ]
        },
        {
          "name": "Iterations",
          "type": "number",
          "value": 3
        },
        {
          "name": "Memory (KiB)",
          "type": "number",
          "value": 4096
        },
        {
          "name": "Parallelism",
          "type": "number",
          "value": 1
        },
        {
          "name": "Hash length (bytes)",
          "type": "number",
          "value": 32
        },
        {
          "name": "Type",
          "type": "option",
          "value": [
            "Argon2i",
            "Argon2d",
            "Argon2id"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Encoded hash",
            "Hex hash",
            "Raw hash"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Argon2 compare",
      "module": "Crypto",
      "description": "Tests whether the input matches the given Argon2 hash. To test multiple possible passwords, use the 'Fork' operation.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Encoded hash",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Atbash Cipher",
      "module": "Ciphers",
      "description": "Atbash is a mono-alphabetic substitution cipher originally used to encode the Hebrew alphabet. It has been modified here for use with the Latin alphabet.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Avro to JSON",
      "module": "Serialise",
      "description": "Converts Avro encoded data into JSON.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Force Valid JSON",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Bacon Cipher Decode",
      "module": "Default",
      "description": "Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "option",
          "value": [
            "Standard (I=J and U=V)",
            "Complete"
          ]
        },
        {
          "name": "Translation",
          "type": "option",
          "value": [
            "0/1",
            "A/B",
            "Case",
            "A-M/N-Z first letter"
          ]
        },
        {
          "name": "Invert Translation",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Bacon Cipher Encode",
      "module": "Default",
      "description": "Bacon's cipher or the Baconian cipher is a method of steganography devised by Francis Bacon in 1605. A message is concealed in the presentation of text, rather than its content.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "option",
          "value": [
            "Standard (I=J and U=V)",
            "Complete"
          ]
        },
        {
          "name": "Translation",
          "type": "option",
          "value": [
            "0/1",
            "A/B"
          ]
        },
        {
          "name": "Keep extra characters",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Invert Translation",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Bcrypt",
      "module": "Crypto",
      "description": "bcrypt is a password hashing function designed by Niels Provos and David Mazi\u00e8res, based on the Blowfish cipher, and presented at USENIX in 1999. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count (rounds) can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power.<br><br>Enter the password in the input to generate its hash.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Rounds",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Bcrypt compare",
      "module": "Crypto",
      "description": "Tests whether the input matches the given bcrypt hash. To test multiple possible passwords, use the 'Fork' operation.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Hash",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Bcrypt parse",
      "module": "Crypto",
      "description": "Parses a bcrypt hash to determine the number of rounds used, the salt, and the password hash.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Bifid Cipher Decode",
      "module": "Ciphers",
      "description": "The Bifid cipher is a cipher which uses a Polybius square in conjunction with transposition, which can be fairly difficult to decipher without knowing the alphabet keyword.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Keyword",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Bifid Cipher Encode",
      "module": "Ciphers",
      "description": "The Bifid cipher is a cipher which uses a Polybius square in conjunction with transposition, which can be fairly difficult to decipher without knowing the alphabet keyword.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Keyword",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Bit shift left",
      "module": "Default",
      "description": "Shifts the bits in each byte towards the left by the specified amount.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Amount",
          "type": "number",
          "value": 1
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Bit shift right",
      "module": "Default",
      "description": "Shifts the bits in each byte towards the right by the specified amount.<br><br><i>Logical shifts</i> replace the leftmost bits with zeros.<br><i>Arithmetic shifts</i> preserve the most significant bit (MSB) of the original byte keeping the sign the same (positive or negative).",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Amount",
          "type": "number",
          "value": 1
        },
        {
          "name": "Type",
          "type": "option",
          "value": [
            "Logical shift",
            "Arithmetic shift"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Blowfish Decrypt",
      "module": "Ciphers",
      "description": "Blowfish is a symmetric-key block cipher designed in 1993 by Bruce Schneier and included in a large number of cipher suites and encryption products. AES now receives more attention.<br><br><b>IV:</b> The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Blowfish Encrypt",
      "module": "Ciphers",
      "description": "Blowfish is a symmetric-key block cipher designed in 1993 by Bruce Schneier and included in a large number of cipher suites and encryption products. AES now receives more attention.<br><br><b>IV:</b> The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Blur Image",
      "module": "Image",
      "description": "Applies a blur effect to the image.<br><br>Gaussian blur is much slower than fast blur, but produces better results.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Amount",
          "type": "number",
          "value": 5
        },
        {
          "name": "Type",
          "type": "option",
          "value": [
            "Fast",
            "Gaussian"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Bombe",
      "module": "Bletchley",
      "description": "Emulation of the Bombe machine used at Bletchley Park to attack Enigma, based on work by Polish and British cryptanalysts.<br><br>To run this you need to have a 'crib', which is some known plaintext for a chunk of the target ciphertext, and know the rotors used. (See the 'Bombe (multiple runs)' operation if you don't know the rotors.) The machine will suggest possible configurations of the Enigma. Each suggestion has the rotor start positions (left to right) and known plugboard pairs.<br><br>Choosing a crib: First, note that Enigma cannot encrypt a letter to itself, which allows you to rule out some positions for possible cribs. Secondly, the Bombe does not simulate the Enigma's middle rotor stepping. The longer your crib, the more likely a step happened within it, which will prevent the attack working. However, other than that, longer cribs are generally better. The attack produces a 'menu' which maps ciphertext letters to plaintext, and the goal is to produce 'loops': for example, with ciphertext ABC and crib CAB, we have the mappings A&lt;-&gt;C, B&lt;-&gt;A, and C&lt;-&gt;B, which produces a loop A-B-C-A. The more loops, the better the crib. The operation will output this: if your menu has too few loops or is too short, a large number of incorrect outputs will usually be produced. Try a different crib. If the menu seems good but the right answer isn't produced, your crib may be wrong, or you may have overlapped the middle rotor stepping - try a different crib.<br><br>Output is not sufficient to fully decrypt the data. You will have to recover the rest of the plugboard settings by inspection. And the ring position is not taken into account: this affects when the middle rotor steps. If your output is correct for a bit, and then goes wrong, adjust the ring and start position on the right-hand rotor together until the output improves. If necessary, repeat for the middle rotor.<br><br>By default this operation runs the checking machine, a manual process to verify the quality of Bombe stops, on each stop, discarding stops which fail. If you want to see how many times the hardware actually stops for a given input, disable the checking machine.<br><br>More detailed descriptions of the Enigma, Typex and Bombe operations <a href='https://github.com/gchq/CyberChef/wiki/Enigma,-the-Bombe,-and-Typex'>can be found here</a>.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Model",
          "type": "argSelector",
          "value": [
            {
              "name": "3-rotor",
              "off": [
                1
              ]
            },
            {
              "name": "4-rotor",
              "on": [
                1
              ]
            }
          ]
        },
        {
          "name": "Left-most (4th) rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Beta",
              "value": "LEYJVCNIXWPBQMDRTAKZGFUHOS"
            },
            {
              "name": "Gamma",
              "value": "FSOKANUERHMBTIYCWLQPZXVGJD"
            }
          ]
        },
        {
          "name": "Left-hand rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "I",
              "value": "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R"
            },
            {
              "name": "II",
              "value": "AJDKSIRUXBLHWTMCQGZNPYFVOE<F"
            },
            {
              "name": "III",
              "value": "BDFHJLCPRTXVZNYEIWGAKMUSQO<W"
            },
            {
              "name": "IV",
              "value": "ESOVPZJAYQUIRHXLNFTGKDCMWB<K"
            },
            {
              "name": "V",
              "value": "VZBRGITYUPSDNHLXAWMJQOFECK<A"
            },
            {
              "name": "VI",
              "value": "JPGVOUMFYQBENHZRDKASXLICTW<AN"
            },
            {
              "name": "VII",
              "value": "NZJHGRCXMYSWBOUFAIVLPEKQDT<AN"
            },
            {
              "name": "VIII",
              "value": "FKQHTLXOCBJSPDZRAMEWNIUYGV<AN"
            }
          ]
        },
        {
          "name": "Middle rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "I",
              "value": "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R"
            },
            {
              "name": "II",
              "value": "AJDKSIRUXBLHWTMCQGZNPYFVOE<F"
            },
            {
              "name": "III",
              "value": "BDFHJLCPRTXVZNYEIWGAKMUSQO<W"
            },
            {
              "name": "IV",
              "value": "ESOVPZJAYQUIRHXLNFTGKDCMWB<K"
            },
            {
              "name": "V",
              "value": "VZBRGITYUPSDNHLXAWMJQOFECK<A"
            },
            {
              "name": "VI",
              "value": "JPGVOUMFYQBENHZRDKASXLICTW<AN"
            },
            {
              "name": "VII",
              "value": "NZJHGRCXMYSWBOUFAIVLPEKQDT<AN"
            },
            {
              "name": "VIII",
              "value": "FKQHTLXOCBJSPDZRAMEWNIUYGV<AN"
            }
          ]
        },
        {
          "name": "Right-hand rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "I",
              "value": "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R"
            },
            {
              "name": "II",
              "value": "AJDKSIRUXBLHWTMCQGZNPYFVOE<F"
            },
            {
              "name": "III",
              "value": "BDFHJLCPRTXVZNYEIWGAKMUSQO<W"
            },
            {
              "name": "IV",
              "value": "ESOVPZJAYQUIRHXLNFTGKDCMWB<K"
            },
            {
              "name": "V",
              "value": "VZBRGITYUPSDNHLXAWMJQOFECK<A"
            },
            {
              "name": "VI",
              "value": "JPGVOUMFYQBENHZRDKASXLICTW<AN"
            },
            {
              "name": "VII",
              "value": "NZJHGRCXMYSWBOUFAIVLPEKQDT<AN"
            },
            {
              "name": "VIII",
              "value": "FKQHTLXOCBJSPDZRAMEWNIUYGV<AN"
            }
          ]
        },
        {
          "name": "Reflector",
          "type": "editableOption",
          "value": [
            {
              "name": "B",
              "value": "AY BR CU DH EQ FS GL IP JX KN MO TZ VW"
            },
            {
              "name": "C",
              "value": "AF BV CP DJ EI GO HY KR LZ MX NW TQ SU"
            },
            {
              "name": "B Thin",
              "value": "AE BN CK DQ FU GY HW IJ LO MP RX SZ TV"
            },
            {
              "name": "C Thin",
              "value": "AR BD CO EJ FN GT HK IV LM PW QZ SX UY"
            }
          ]
        },
        {
          "name": "Crib",
          "type": "string",
          "value": ""
        },
        {
          "name": "Crib offset",
          "type": "number",
          "value": 0
        },
        {
          "name": "Use checking machine",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Bzip2 Compress",
      "module": "Compression",
      "description": "Bzip2 is a compression library developed by Julian Seward (of GHC fame) that uses the Burrows-Wheeler algorithm. It only supports compressing single files and its compression is slow, however is more effective than Deflate (.gz & .zip).",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Block size (100s of kb)",
          "type": "number",
          "value": 9
        },
        {
          "name": "Work factor",
          "type": "number",
          "value": 30
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Bzip2 Decompress",
      "module": "Compression",
      "description": "Decompresses data using the Bzip2 algorithm.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Use low-memory, slower decompression algorithm",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Caesar Box Cipher",
      "module": "Ciphers",
      "description": "Caesar Box is a transposition cipher used in the Roman Empire, in which letters of the message are written in rows in a square (or a rectangle) and then, read by column.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Box Height",
          "type": "number",
          "value": 1
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Cartesian Product",
      "module": "Default",
      "description": "Calculates the cartesian product of multiple sets of data, returning all possible combinations.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        },
        {
          "name": "Item delimiter",
          "type": "binaryString",
          "value": ","
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Cetacean Cipher Decode",
      "module": "Ciphers",
      "description": "Decode Cetacean Cipher input. <br/><br/>e.g. <code>EEEEEEEEEeeEeEEEEEEEEEEEEeeEeEEe</code> becomes <code>hi</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Cetacean Cipher Encode",
      "module": "Ciphers",
      "description": "Converts any input into Cetacean Cipher. <br/><br/>e.g. <code>hi</code> becomes <code>EEEEEEEEEeeEeEEEEEEEEEEEEeeEeEEe</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "ChaCha",
      "module": "Ciphers",
      "description": "ChaCha is a stream cipher designed by Daniel J. Bernstein. It is a variant of the Salsa stream cipher. Several parameterizations exist; 'ChaCha' may refer to the original construction, or to the variant as described in RFC-8439. ChaCha is often used with Poly1305, in the ChaCha20-Poly1305 AEAD construction.<br><br><b>Key:</b> ChaCha uses a key of 16 or 32 bytes (128 or 256 bits).<br><br><b>Nonce:</b> ChaCha uses a nonce of 8 or 12 bytes (64 or 96 bits).<br><br><b>Counter:</b> ChaCha uses a counter of 4 or 8 bytes (32 or 64 bits); together, the nonce and counter must add up to 16 bytes. The counter starts at zero at the start of the keystream, and is incremented at every 64 bytes.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Nonce",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64",
            "Integer"
          ]
        },
        {
          "name": "Counter",
          "type": "number",
          "value": 0
        },
        {
          "name": "Rounds",
          "type": "option",
          "value": [
            "20",
            "12",
            "8"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Change IP format",
      "module": "Default",
      "description": "Convert an IP address from one format to another, e.g. <code>172.20.23.54</code> to <code>ac141736</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Dotted Decimal",
            "Decimal",
            "Octal",
            "Hex"
          ]
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Dotted Decimal",
            "Decimal",
            "Octal",
            "Hex"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Chi Square",
      "module": "Default",
      "description": "Calculates the Chi Square distribution of values.",
      "inputType": "ArrayBuffer",
      "outputType": "number",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "CipherSaber2 Decrypt",
      "module": "Crypto",
      "description": "CipherSaber is a simple symmetric encryption protocol based on the RC4 stream cipher. It gives reasonably strong protection of message confidentiality, yet it's designed to be simple enough that even novice programmers can memorize the algorithm and implement it from scratch.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 20
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "CipherSaber2 Encrypt",
      "module": "Crypto",
      "description": "CipherSaber is a simple symmetric encryption protocol based on the RC4 stream cipher. It gives reasonably strong protection of message confidentiality, yet it's designed to be simple enough that even novice programmers can memorize the algorithm and implement it from scratch.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 20
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Citrix CTX1 Decode",
      "module": "Encodings",
      "description": "Decodes strings in a Citrix CTX1 password format to plaintext.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Citrix CTX1 Encode",
      "module": "Encodings",
      "description": "Encodes strings to Citrix CTX1 password format.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Colossus",
      "module": "Bletchley",
      "description": "Colossus is the name of the world's first electronic computer. Ten Colossi were designed by Tommy Flowers and built at the Post Office Research Labs at Dollis Hill in 1943 during World War 2. They assisted with the breaking of the German Lorenz cipher attachment, a machine created to encipher communications between Hitler and his generals on the front lines.<br><br>To learn more, Virtual Colossus, an online, browser based simulation of a Colossus computer is available at <a href='https://virtualcolossus.co.uk' target='_blank'>virtualcolossus.co.uk</a>.<br><br>A more detailed description of this operation can be found <a href='https://github.com/gchq/CyberChef/wiki/Colossus' target='_blank'>here</a>.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Input",
          "type": "label",
          "value": ""
        },
        {
          "name": "Pattern",
          "type": "option",
          "value": [
            "KH Pattern",
            "ZMUG Pattern",
            "BREAM Pattern"
          ]
        },
        {
          "name": "QBusZ",
          "type": "option",
          "value": [
            "",
            "Z",
            "\u0394Z"
          ]
        },
        {
          "name": "QBus\u03a7",
          "type": "option",
          "value": [
            "",
            "\u03a7",
            "\u0394\u03a7"
          ]
        },
        {
          "name": "QBus\u03a8",
          "type": "option",
          "value": [
            "",
            "\u03a8",
            "\u0394\u03a8"
          ]
        },
        {
          "name": "Limitation",
          "type": "option",
          "value": [
            "None",
            "\u03a72",
            "\u03a72 + P5",
            "X2 + \u03a81",
            "X2 + \u03a81 + P5"
          ]
        },
        {
          "name": "K Rack Option",
          "type": "argSelector",
          "value": [
            {
              "name": "Select Program",
              "on": [
                7
              ],
              "off": [
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40
              ]
            },
            {
              "name": "Top Section - Conditional",
              "on": [
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ],
              "off": [
                7,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40
              ]
            },
            {
              "name": "Bottom Section - Addition",
              "on": [
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40
              ],
              "off": [
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ]
            },
            {
              "name": "Advanced",
              "on": [
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40
              ],
              "off": [
                7
              ]
            }
          ]
        },
        {
          "name": "Program to run",
          "type": "option",
          "value": [
            "",
            "Letter Count",
            "1+2=. (1+2 Break In, Find X1,X2)",
            "4=5=/1=2 (Given X1,X2 find X4,X5)",
            "/,5,U (Count chars to find X3)"
          ]
        },
        {
          "name": "K Rack: Conditional",
          "type": "label",
          "value": ""
        },
        {
          "name": "R1-Q1",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R1-Q2",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R1-Q3",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R1-Q4",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R1-Q5",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R1-Negate",
          "type": "boolean",
          "value": false
        },
        {
          "name": "R1-Counter",
          "type": "option",
          "value": [
            "",
            "1",
            "2",
            "3",
            "4",
            "5"
          ]
        },
        {
          "name": "R2-Q1",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R2-Q2",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R2-Q3",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R2-Q4",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R2-Q5",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R2-Negate",
          "type": "boolean",
          "value": false
        },
        {
          "name": "R2-Counter",
          "type": "option",
          "value": [
            "",
            "1",
            "2",
            "3",
            "4",
            "5"
          ]
        },
        {
          "name": "R3-Q1",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R3-Q2",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R3-Q3",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R3-Q4",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R3-Q5",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "R3-Negate",
          "type": "boolean",
          "value": false
        },
        {
          "name": "R3-Counter",
          "type": "option",
          "value": [
            "",
            "1",
            "2",
            "3",
            "4",
            "5"
          ]
        },
        {
          "name": "Negate All",
          "type": "boolean",
          "value": false
        },
        {
          "name": "K Rack: Addition",
          "type": "label",
          "value": ""
        },
        {
          "name": "Add-Q1",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Add-Q2",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Add-Q3",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Add-Q4",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Add-Q5",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Add-Equals",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "Add-Counter1",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Add Negate All",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Total Motor",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Up (.)",
              "value": "."
            },
            {
              "name": "Centre",
              "value": ""
            },
            {
              "name": "Down (x)",
              "value": "x"
            }
          ]
        },
        {
          "name": "Master Control Panel",
          "type": "label",
          "value": ""
        },
        {
          "name": "Set Total",
          "type": "number",
          "value": 0
        },
        {
          "name": "Fast Step",
          "type": "option",
          "value": [
            "",
            "X1",
            "X2",
            "X3",
            "X4",
            "X5",
            "M37",
            "M61",
            "S1",
            "S2",
            "S3",
            "S4",
            "S5"
          ]
        },
        {
          "name": "Slow Step",
          "type": "option",
          "value": [
            "",
            "X1",
            "X2",
            "X3",
            "X4",
            "X5",
            "M37",
            "M61",
            "S1",
            "S2",
            "S3",
            "S4",
            "S5"
          ]
        },
        {
          "name": "Start \u03a71",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a72",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a73",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a74",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a75",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start M61",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start M37",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a81",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a82",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a83",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a84",
          "type": "number",
          "value": 1
        },
        {
          "name": "Start \u03a85",
          "type": "number",
          "value": 1
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Comment",
      "module": "Default",
      "description": "Provides a place to write comments within the flow of the recipe. This operation has no computational effect.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "",
          "type": "text",
          "value": ""
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Compare CTPH hashes",
      "module": "Crypto",
      "description": "Compares two Context Triggered Piecewise Hashing (CTPH) fuzzy hashes to determine the similarity between them on a scale of 0 to 100.",
      "inputType": "string",
      "outputType": "number",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Compare SSDEEP hashes",
      "module": "Crypto",
      "description": "Compares two SSDEEP fuzzy hashes to determine the similarity between them on a scale of 0 to 100.",
      "inputType": "string",
      "outputType": "number",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Conditional Jump",
      "module": "Default",
      "description": "Conditionally jump forwards or backwards to the specified Label  based on whether the data matches the specified regular expression.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Match (regex)",
          "type": "string",
          "value": ""
        },
        {
          "name": "Invert match",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Label name",
          "type": "shortString",
          "value": ""
        },
        {
          "name": "Maximum jumps (if jumping backwards)",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Contain Image",
      "module": "Image",
      "description": "Scales an image to the specified width and height, maintaining the aspect ratio. The image may be letterboxed.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Width",
          "type": "number",
          "value": 100
        },
        {
          "name": "Height",
          "type": "number",
          "value": 100
        },
        {
          "name": "Horizontal align",
          "type": "option",
          "value": [
            "Left",
            "Center",
            "Right"
          ]
        },
        {
          "name": "Vertical align",
          "type": "option",
          "value": [
            "Top",
            "Middle",
            "Bottom"
          ]
        },
        {
          "name": "Resizing algorithm",
          "type": "option",
          "value": [
            "Nearest Neighbour",
            "Bilinear",
            "Bicubic",
            "Hermite",
            "Bezier"
          ]
        },
        {
          "name": "Opaque background",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Convert area",
      "module": "Default",
      "description": "Converts a unit of area to another format.",
      "inputType": "BigNumber",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Input units",
          "type": "option",
          "value": [
            "[Metric]",
            "Square metre (sq m)",
            "Square kilometre (sq km)",
            "Centiare (ca)",
            "Deciare (da)",
            "Are (a)",
            "Decare (daa)",
            "Hectare (ha)",
            "[/Metric]",
            "[Imperial]",
            "Square inch (sq in)",
            "Square foot (sq ft)",
            "Square yard (sq yd)",
            "Square mile (sq mi)",
            "Perch (sq per)",
            "Rood (ro)",
            "International acre (ac)",
            "[/Imperial]",
            "[US customary units]",
            "US survey acre (ac)",
            "US survey square mile (sq mi)",
            "US survey township",
            "[/US customary units]",
            "[Nuclear physics]",
            "Yoctobarn (yb)",
            "Zeptobarn (zb)",
            "Attobarn (ab)",
            "Femtobarn (fb)",
            "Picobarn (pb)",
            "Nanobarn (nb)",
            "Microbarn (\u03bcb)",
            "Millibarn (mb)",
            "Barn (b)",
            "Kilobarn (kb)",
            "Megabarn (Mb)",
            "Outhouse",
            "Shed",
            "Planck area",
            "[/Nuclear physics]",
            "[Comparisons]",
            "Washington D.C.",
            "Isle of Wight",
            "Wales",
            "Texas",
            "[/Comparisons]"
          ]
        },
        {
          "name": "Output units",
          "type": "option",
          "value": [
            "[Metric]",
            "Square metre (sq m)",
            "Square kilometre (sq km)",
            "Centiare (ca)",
            "Deciare (da)",
            "Are (a)",
            "Decare (daa)",
            "Hectare (ha)",
            "[/Metric]",
            "[Imperial]",
            "Square inch (sq in)",
            "Square foot (sq ft)",
            "Square yard (sq yd)",
            "Square mile (sq mi)",
            "Perch (sq per)",
            "Rood (ro)",
            "International acre (ac)",
            "[/Imperial]",
            "[US customary units]",
            "US survey acre (ac)",
            "US survey square mile (sq mi)",
            "US survey township",
            "[/US customary units]",
            "[Nuclear physics]",
            "Yoctobarn (yb)",
            "Zeptobarn (zb)",
            "Attobarn (ab)",
            "Femtobarn (fb)",
            "Picobarn (pb)",
            "Nanobarn (nb)",
            "Microbarn (\u03bcb)",
            "Millibarn (mb)",
            "Barn (b)",
            "Kilobarn (kb)",
            "Megabarn (Mb)",
            "Outhouse",
            "Shed",
            "Planck area",
            "[/Nuclear physics]",
            "[Comparisons]",
            "Washington D.C.",
            "Isle of Wight",
            "Wales",
            "Texas",
            "[/Comparisons]"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Convert data units",
      "module": "Default",
      "description": "Converts a unit of data to another format.",
      "inputType": "BigNumber",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Input units",
          "type": "option",
          "value": [
            "Bits (b)",
            "Nibbles",
            "Octets",
            "Bytes (B)",
            "[Binary bits (2^n)]",
            "Kibibits (Kib)",
            "Mebibits (Mib)",
            "Gibibits (Gib)",
            "Tebibits (Tib)",
            "Pebibits (Pib)",
            "Exbibits (Eib)",
            "Zebibits (Zib)",
            "Yobibits (Yib)",
            "[/Binary bits (2^n)]",
            "[Decimal bits (10^n)]",
            "Decabits",
            "Hectobits",
            "Kilobits (Kb)",
            "Megabits (Mb)",
            "Gigabits (Gb)",
            "Terabits (Tb)",
            "Petabits (Pb)",
            "Exabits (Eb)",
            "Zettabits (Zb)",
            "Yottabits (Yb)",
            "[/Decimal bits (10^n)]",
            "[Binary bytes (8 x 2^n)]",
            "Kibibytes (KiB)",
            "Mebibytes (MiB)",
            "Gibibytes (GiB)",
            "Tebibytes (TiB)",
            "Pebibytes (PiB)",
            "Exbibytes (EiB)",
            "Zebibytes (ZiB)",
            "Yobibytes (YiB)",
            "[/Binary bytes (8 x 2^n)]",
            "[Decimal bytes (8 x 10^n)]",
            "Kilobytes (KB)",
            "Megabytes (MB)",
            "Gigabytes (GB)",
            "Terabytes (TB)",
            "Petabytes (PB)",
            "Exabytes (EB)",
            "Zettabytes (ZB)",
            "Yottabytes (YB)",
            "[/Decimal bytes (8 x 10^n)]"
          ]
        },
        {
          "name": "Output units",
          "type": "option",
          "value": [
            "Bits (b)",
            "Nibbles",
            "Octets",
            "Bytes (B)",
            "[Binary bits (2^n)]",
            "Kibibits (Kib)",
            "Mebibits (Mib)",
            "Gibibits (Gib)",
            "Tebibits (Tib)",
            "Pebibits (Pib)",
            "Exbibits (Eib)",
            "Zebibits (Zib)",
            "Yobibits (Yib)",
            "[/Binary bits (2^n)]",
            "[Decimal bits (10^n)]",
            "Decabits",
            "Hectobits",
            "Kilobits (Kb)",
            "Megabits (Mb)",
            "Gigabits (Gb)",
            "Terabits (Tb)",
            "Petabits (Pb)",
            "Exabits (Eb)",
            "Zettabits (Zb)",
            "Yottabits (Yb)",
            "[/Decimal bits (10^n)]",
            "[Binary bytes (8 x 2^n)]",
            "Kibibytes (KiB)",
            "Mebibytes (MiB)",
            "Gibibytes (GiB)",
            "Tebibytes (TiB)",
            "Pebibytes (PiB)",
            "Exbibytes (EiB)",
            "Zebibytes (ZiB)",
            "Yobibytes (YiB)",
            "[/Binary bytes (8 x 2^n)]",
            "[Decimal bytes (8 x 10^n)]",
            "Kilobytes (KB)",
            "Megabytes (MB)",
            "Gigabytes (GB)",
            "Terabytes (TB)",
            "Petabytes (PB)",
            "Exabytes (EB)",
            "Zettabytes (ZB)",
            "Yottabytes (YB)",
            "[/Decimal bytes (8 x 10^n)]"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Convert distance",
      "module": "Default",
      "description": "Converts a unit of distance to another format.",
      "inputType": "BigNumber",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Input units",
          "type": "option",
          "value": [
            "[Metric]",
            "Nanometres (nm)",
            "Micrometres (\u00b5m)",
            "Millimetres (mm)",
            "Centimetres (cm)",
            "Metres (m)",
            "Kilometers (km)",
            "[/Metric]",
            "[Imperial]",
            "Thou (th)",
            "Inches (in)",
            "Feet (ft)",
            "Yards (yd)",
            "Chains (ch)",
            "Furlongs (fur)",
            "Miles (mi)",
            "Leagues (lea)",
            "[/Imperial]",
            "[Maritime]",
            "Fathoms (ftm)",
            "Cables",
            "Nautical miles",
            "[/Maritime]",
            "[Comparisons]",
            "Cars (4m)",
            "Buses (8.4m)",
            "American football fields (91m)",
            "Football pitches (105m)",
            "[/Comparisons]",
            "[Astronomical]",
            "Earth-to-Moons",
            "Earth's equators",
            "Astronomical units (au)",
            "Light-years (ly)",
            "Parsecs (pc)",
            "[/Astronomical]"
          ]
        },
        {
          "name": "Output units",
          "type": "option",
          "value": [
            "[Metric]",
            "Nanometres (nm)",
            "Micrometres (\u00b5m)",
            "Millimetres (mm)",
            "Centimetres (cm)",
            "Metres (m)",
            "Kilometers (km)",
            "[/Metric]",
            "[Imperial]",
            "Thou (th)",
            "Inches (in)",
            "Feet (ft)",
            "Yards (yd)",
            "Chains (ch)",
            "Furlongs (fur)",
            "Miles (mi)",
            "Leagues (lea)",
            "[/Imperial]",
            "[Maritime]",
            "Fathoms (ftm)",
            "Cables",
            "Nautical miles",
            "[/Maritime]",
            "[Comparisons]",
            "Cars (4m)",
            "Buses (8.4m)",
            "American football fields (91m)",
            "Football pitches (105m)",
            "[/Comparisons]",
            "[Astronomical]",
            "Earth-to-Moons",
            "Earth's equators",
            "Astronomical units (au)",
            "Light-years (ly)",
            "Parsecs (pc)",
            "[/Astronomical]"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Convert Image Format",
      "module": "Image",
      "description": "Converts an image between different formats. Supported formats:<br><ul><li>Joint Photographic Experts Group (JPEG)</li><li>Portable Network Graphics (PNG)</li><li>Bitmap (BMP)</li><li>Tagged Image File Format (TIFF)</li></ul><br>Note: GIF files are supported for input, but cannot be outputted.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Output Format",
          "type": "option",
          "value": [
            "JPEG",
            "PNG",
            "BMP",
            "TIFF"
          ]
        },
        {
          "name": "JPEG Quality",
          "type": "number",
          "value": 80
        },
        {
          "name": "PNG Filter Type",
          "type": "option",
          "value": [
            "Auto",
            "None",
            "Sub",
            "Up",
            "Average",
            "Paeth"
          ]
        },
        {
          "name": "PNG Deflate Level",
          "type": "number",
          "value": 9
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Convert Leet Speak",
      "module": "Default",
      "description": "Converts to and from Leet Speak.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Direction",
          "type": "option",
          "value": [
            "To Leet Speak",
            "From Leet Speak"
          ]
        }
      ],
      "category": "Language",
      "is_favorite": false
    },
    {
      "name": "Convert mass",
      "module": "Default",
      "description": "Converts a unit of mass to another format.",
      "inputType": "BigNumber",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Input units",
          "type": "option",
          "value": [
            "[Metric]",
            "Yoctogram (yg)",
            "Zeptogram (zg)",
            "Attogram (ag)",
            "Femtogram (fg)",
            "Picogram (pg)",
            "Nanogram (ng)",
            "Microgram (\u03bcg)",
            "Milligram (mg)",
            "Centigram (cg)",
            "Decigram (dg)",
            "Gram (g)",
            "Decagram (dag)",
            "Hectogram (hg)",
            "Kilogram (kg)",
            "Megagram (Mg)",
            "Tonne (t)",
            "Gigagram (Gg)",
            "Teragram (Tg)",
            "Petagram (Pg)",
            "Exagram (Eg)",
            "Zettagram (Zg)",
            "Yottagram (Yg)",
            "[/Metric]",
            "[Imperial Avoirdupois]",
            "Grain (gr)",
            "Dram (dr)",
            "Ounce (oz)",
            "Pound (lb)",
            "Nail",
            "Stone (st)",
            "Quarter (gr)",
            "Tod",
            "US hundredweight (cwt)",
            "Imperial hundredweight (cwt)",
            "US ton (t)",
            "Imperial ton (t)",
            "[/Imperial Avoirdupois]",
            "[Imperial Troy]",
            "Grain (gr)",
            "Pennyweight (dwt)",
            "Troy dram (dr t)",
            "Troy ounce (oz t)",
            "Troy pound (lb t)",
            "Mark",
            "[/Imperial Troy]",
            "[Archaic]",
            "Wey",
            "Wool wey",
            "Suffolk wey",
            "Wool sack",
            "Coal sack",
            "Load",
            "Last",
            "Flax or feather last",
            "Gunpowder last",
            "Picul",
            "Rice last",
            "[/Archaic]",
            "[Comparisons]",
            "Big Ben (14 tonnes)",
            "Blue whale (180 tonnes)",
            "International Space Station (417 tonnes)",
            "Space Shuttle (2,041 tonnes)",
            "RMS Titanic (52,000 tonnes)",
            "Great Pyramid of Giza (6,000,000 tonnes)",
            "Earth's oceans (1.4 yottagrams)",
            "[/Comparisons]",
            "[Astronomical]",
            "A teaspoon of neutron star (5,500 million tonnes)",
            "Lunar mass (ML)",
            "Earth mass (M\u2295)",
            "Jupiter mass (MJ)",
            "Solar mass (M\u2609)",
            "Sagittarius A* (7.5 x 10^36 kgs-ish)",
            "Milky Way galaxy (1.2 x 10^42 kgs)",
            "The observable universe (1.45 x 10^53 kgs)",
            "[/Astronomical]"
          ]
        },
        {
          "name": "Output units",
          "type": "option",
          "value": [
            "[Metric]",
            "Yoctogram (yg)",
            "Zeptogram (zg)",
            "Attogram (ag)",
            "Femtogram (fg)",
            "Picogram (pg)",
            "Nanogram (ng)",
            "Microgram (\u03bcg)",
            "Milligram (mg)",
            "Centigram (cg)",
            "Decigram (dg)",
            "Gram (g)",
            "Decagram (dag)",
            "Hectogram (hg)",
            "Kilogram (kg)",
            "Megagram (Mg)",
            "Tonne (t)",
            "Gigagram (Gg)",
            "Teragram (Tg)",
            "Petagram (Pg)",
            "Exagram (Eg)",
            "Zettagram (Zg)",
            "Yottagram (Yg)",
            "[/Metric]",
            "[Imperial Avoirdupois]",
            "Grain (gr)",
            "Dram (dr)",
            "Ounce (oz)",
            "Pound (lb)",
            "Nail",
            "Stone (st)",
            "Quarter (gr)",
            "Tod",
            "US hundredweight (cwt)",
            "Imperial hundredweight (cwt)",
            "US ton (t)",
            "Imperial ton (t)",
            "[/Imperial Avoirdupois]",
            "[Imperial Troy]",
            "Grain (gr)",
            "Pennyweight (dwt)",
            "Troy dram (dr t)",
            "Troy ounce (oz t)",
            "Troy pound (lb t)",
            "Mark",
            "[/Imperial Troy]",
            "[Archaic]",
            "Wey",
            "Wool wey",
            "Suffolk wey",
            "Wool sack",
            "Coal sack",
            "Load",
            "Last",
            "Flax or feather last",
            "Gunpowder last",
            "Picul",
            "Rice last",
            "[/Archaic]",
            "[Comparisons]",
            "Big Ben (14 tonnes)",
            "Blue whale (180 tonnes)",
            "International Space Station (417 tonnes)",
            "Space Shuttle (2,041 tonnes)",
            "RMS Titanic (52,000 tonnes)",
            "Great Pyramid of Giza (6,000,000 tonnes)",
            "Earth's oceans (1.4 yottagrams)",
            "[/Comparisons]",
            "[Astronomical]",
            "A teaspoon of neutron star (5,500 million tonnes)",
            "Lunar mass (ML)",
            "Earth mass (M\u2295)",
            "Jupiter mass (MJ)",
            "Solar mass (M\u2609)",
            "Sagittarius A* (7.5 x 10^36 kgs-ish)",
            "Milky Way galaxy (1.2 x 10^42 kgs)",
            "The observable universe (1.45 x 10^53 kgs)",
            "[/Astronomical]"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Convert speed",
      "module": "Default",
      "description": "Converts a unit of speed to another format.",
      "inputType": "BigNumber",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Input units",
          "type": "option",
          "value": [
            "[Metric]",
            "Metres per second (m/s)",
            "Kilometres per hour (km/h)",
            "[/Metric]",
            "[Imperial]",
            "Miles per hour (mph)",
            "Knots (kn)",
            "[/Imperial]",
            "[Comparisons]",
            "Human hair growth rate",
            "Bamboo growth rate",
            "World's fastest snail",
            "Usain Bolt's top speed",
            "Jet airliner cruising speed",
            "Concorde",
            "SR-71 Blackbird",
            "Space Shuttle",
            "International Space Station",
            "[/Comparisons]",
            "[Scientific]",
            "Sound in standard atmosphere",
            "Sound in water",
            "Lunar escape velocity",
            "Earth escape velocity",
            "Earth's solar orbit",
            "Solar system's Milky Way orbit",
            "Milky Way relative to the cosmic microwave background",
            "Solar escape velocity",
            "Neutron star escape velocity (0.3c)",
            "Light in a diamond (0.4136c)",
            "Signal in an optical fibre (0.667c)",
            "Light (c)",
            "[/Scientific]"
          ]
        },
        {
          "name": "Output units",
          "type": "option",
          "value": [
            "[Metric]",
            "Metres per second (m/s)",
            "Kilometres per hour (km/h)",
            "[/Metric]",
            "[Imperial]",
            "Miles per hour (mph)",
            "Knots (kn)",
            "[/Imperial]",
            "[Comparisons]",
            "Human hair growth rate",
            "Bamboo growth rate",
            "World's fastest snail",
            "Usain Bolt's top speed",
            "Jet airliner cruising speed",
            "Concorde",
            "SR-71 Blackbird",
            "Space Shuttle",
            "International Space Station",
            "[/Comparisons]",
            "[Scientific]",
            "Sound in standard atmosphere",
            "Sound in water",
            "Lunar escape velocity",
            "Earth escape velocity",
            "Earth's solar orbit",
            "Solar system's Milky Way orbit",
            "Milky Way relative to the cosmic microwave background",
            "Solar escape velocity",
            "Neutron star escape velocity (0.3c)",
            "Light in a diamond (0.4136c)",
            "Signal in an optical fibre (0.667c)",
            "Light (c)",
            "[/Scientific]"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Convert to NATO alphabet",
      "module": "Default",
      "description": "Converts characters to their representation in the NATO phonetic alphabet.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Language",
      "is_favorite": false
    },
    {
      "name": "Count occurrences",
      "module": "Default",
      "description": "Counts the number of times the provided string occurs in the input.",
      "inputType": "string",
      "outputType": "number",
      "args": [
        {
          "name": "Search string",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Regex",
            "Extended (\\n, \\t, \\x...)",
            "Simple string"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Cover Image",
      "module": "Image",
      "description": "Scales the image to the given width and height, keeping the aspect ratio. The image may be clipped.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Width",
          "type": "number",
          "value": 100
        },
        {
          "name": "Height",
          "type": "number",
          "value": 100
        },
        {
          "name": "Horizontal align",
          "type": "option",
          "value": [
            "Left",
            "Center",
            "Right"
          ]
        },
        {
          "name": "Vertical align",
          "type": "option",
          "value": [
            "Top",
            "Middle",
            "Bottom"
          ]
        },
        {
          "name": "Resizing algorithm",
          "type": "option",
          "value": [
            "Nearest Neighbour",
            "Bilinear",
            "Bicubic",
            "Hermite",
            "Bezier"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Crop Image",
      "module": "Image",
      "description": "Crops an image to the specified region, or automatically crops edges.<br><br><b><u>Autocrop</u></b><br>Automatically crops same-colour borders from the image.<br><br><u>Autocrop tolerance</u><br>A percentage value for the tolerance of colour difference between pixels.<br><br><u>Only autocrop frames</u><br>Only crop real frames (all sides must have the same border)<br><br><u>Symmetric autocrop</u><br>Force autocrop to be symmetric (top/bottom and left/right are cropped by the same amount)<br><br><u>Autocrop keep border</u><br>The number of pixels of border to leave around the image.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "X Position",
          "type": "number",
          "value": 0
        },
        {
          "name": "Y Position",
          "type": "number",
          "value": 0
        },
        {
          "name": "Width",
          "type": "number",
          "value": 10
        },
        {
          "name": "Height",
          "type": "number",
          "value": 10
        },
        {
          "name": "Autocrop",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Autocrop tolerance (%)",
          "type": "number",
          "value": 0.02
        },
        {
          "name": "Only autocrop frames",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Symmetric autocrop",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Autocrop keep border (px)",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "DateTime Delta",
      "module": "Default",
      "description": "Calculates a new DateTime value given an input DateTime value and a time difference (delta) from the input DateTime value.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Built in formats",
          "type": "populateOption",
          "value": [
            {
              "name": "Standard date and time",
              "value": "DD/MM/YYYY HH:mm:ss"
            },
            {
              "name": "American-style date and time",
              "value": "MM/DD/YYYY HH:mm:ss"
            },
            {
              "name": "International date and time",
              "value": "YYYY-MM-DD HH:mm:ss"
            },
            {
              "name": "Verbose date and time",
              "value": "dddd Do MMMM YYYY HH:mm:ss Z z"
            },
            {
              "name": "UNIX timestamp (seconds)",
              "value": "X"
            },
            {
              "name": "UNIX timestamp offset (milliseconds)",
              "value": "x"
            },
            {
              "name": "Automatic",
              "value": ""
            }
          ]
        },
        {
          "name": "Input format string",
          "type": "binaryString",
          "value": "DD/MM/YYYY HH:mm:ss"
        },
        {
          "name": "Time Operation",
          "type": "option",
          "value": [
            "Add",
            "Subtract"
          ]
        },
        {
          "name": "Days",
          "type": "number",
          "value": 0
        },
        {
          "name": "Hours",
          "type": "number",
          "value": 0
        },
        {
          "name": "Minutes",
          "type": "number",
          "value": 0
        },
        {
          "name": "Seconds",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Dechunk HTTP response",
      "module": "Default",
      "description": "Parses an HTTP response transferred using Transfer-Encoding: Chunked",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Decode NetBIOS Name",
      "module": "Default",
      "description": "NetBIOS names as seen across the client interface to NetBIOS are exactly 16 bytes long. Within the NetBIOS-over-TCP protocols, a longer representation is used.<br><br>There are two levels of encoding. The first level maps a NetBIOS name into a domain system name.  The second level maps the domain system name into the 'compressed' representation required for interaction with the domain name system.<br><br>This operation decodes the first level of encoding. See RFC 1001 for full details.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Offset",
          "type": "number",
          "value": 65
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Decode text",
      "module": "Encodings",
      "description": "Decodes text from the chosen character encoding.\n<br><br>\nSupported charsets are:\n<ul>\n<li>UTF-8 (65001)</li>\n<li>UTF-7 (65000)</li>\n<li>UTF-16LE (1200)</li>\n<li>UTF-16BE (1201)</li>\n<li>UTF-32LE (12000)</li>\n<li>UTF-32BE (12001)</li>\n<li>IBM EBCDIC International (500)</li>\n<li>IBM EBCDIC US-Canada (37)</li>\n<li>IBM EBCDIC Multilingual/ROECE (Latin 2) (870)</li>\n<li>IBM EBCDIC Greek Modern (875)</li>\n<li>IBM EBCDIC French (1010)</li>\n<li>IBM EBCDIC Turkish (Latin 5) (1026)</li>\n<li>IBM EBCDIC Latin 1/Open System (1047)</li>\n<li>IBM EBCDIC Lao (1132/1133/1341)</li>\n<li>IBM EBCDIC US-Canada (037 + Euro symbol) (1140)</li>\n<li>IBM EBCDIC Germany (20273 + Euro symbol) (1141)</li>\n<li>IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)</li>\n<li>IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)</li>\n<li>IBM EBCDIC Italy (20280 + Euro symbol) (1144)</li>\n<li>IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)</li>\n<li>IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)</li>\n<li>IBM EBCDIC France (20297 + Euro symbol) (1147)</li>\n<li>IBM EBCDIC International (500 + Euro symbol) (1148)</li>\n<li>IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)</li>\n<li>IBM EBCDIC Germany (20273)</li>\n<li>IBM EBCDIC Denmark-Norway (20277)</li>\n<li>IBM EBCDIC Finland-Sweden (20278)</li>\n<li>IBM EBCDIC Italy (20280)</li>\n<li>IBM EBCDIC Latin America-Spain (20284)</li>\n<li>IBM EBCDIC United Kingdom (20285)</li>\n<li>IBM EBCDIC Japanese Katakana Extended (20290)</li>\n<li>IBM EBCDIC France (20297)</li>\n<li>IBM EBCDIC Arabic (20420)</li>\n<li>IBM EBCDIC Greek (20423)</li>\n<li>IBM EBCDIC Hebrew (20424)</li>\n<li>IBM EBCDIC Korean Extended (20833)</li>\n<li>IBM EBCDIC Thai (20838)</li>\n<li>IBM EBCDIC Icelandic (20871)</li>\n<li>IBM EBCDIC Cyrillic Russian (20880)</li>\n<li>IBM EBCDIC Turkish (20905)</li>\n<li>IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)</li>\n<li>IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)</li>\n<li>OEM United States (437)</li>\n<li>OEM Greek (formerly 437G); Greek (DOS) (737)</li>\n<li>OEM Baltic; Baltic (DOS) (775)</li>\n<li>OEM Russian; Cyrillic + Euro symbol (808)</li>\n<li>OEM Multilingual Latin 1; Western European (DOS) (850)</li>\n<li>OEM Latin 2; Central European (DOS) (852)</li>\n<li>OEM Cyrillic (primarily Russian) (855)</li>\n<li>OEM Turkish; Turkish (DOS) (857)</li>\n<li>OEM Multilingual Latin 1 + Euro symbol (858)</li>\n<li>OEM Portuguese; Portuguese (DOS) (860)</li>\n<li>OEM Icelandic; Icelandic (DOS) (861)</li>\n<li>OEM Hebrew; Hebrew (DOS) (862)</li>\n<li>OEM French Canadian; French Canadian (DOS) (863)</li>\n<li>OEM Arabic; Arabic (864) (864)</li>\n<li>OEM Nordic; Nordic (DOS) (865)</li>\n<li>OEM Russian; Cyrillic (DOS) (866)</li>\n<li>OEM Modern Greek; Greek, Modern (DOS) (869)</li>\n<li>OEM Cyrillic (primarily Russian) + Euro Symbol (872)</li>\n<li>Windows-874 Thai (874)</li>\n<li>Windows-1250 Central European (1250)</li>\n<li>Windows-1251 Cyrillic (1251)</li>\n<li>Windows-1252 Latin (1252)</li>\n<li>Windows-1253 Greek (1253)</li>\n<li>Windows-1254 Turkish (1254)</li>\n<li>Windows-1255 Hebrew (1255)</li>\n<li>Windows-1256 Arabic (1256)</li>\n<li>Windows-1257 Baltic (1257)</li>\n<li>Windows-1258 Vietnam (1258)</li>\n<li>ISO-8859-1 Latin 1 Western European (28591)</li>\n<li>ISO-8859-2 Latin 2 Central European (28592)</li>\n<li>ISO-8859-3 Latin 3 South European (28593)</li>\n<li>ISO-8859-4 Latin 4 North European (28594)</li>\n<li>ISO-8859-5 Latin/Cyrillic (28595)</li>\n<li>ISO-8859-6 Latin/Arabic (28596)</li>\n<li>ISO-8859-7 Latin/Greek (28597)</li>\n<li>ISO-8859-8 Latin/Hebrew (28598)</li>\n<li>ISO 8859-8 Hebrew (ISO-Logical) (38598)</li>\n<li>ISO-8859-9 Latin 5 Turkish (28599)</li>\n<li>ISO-8859-10 Latin 6 Nordic (28600)</li>\n<li>ISO-8859-11 Latin/Thai (28601)</li>\n<li>ISO-8859-13 Latin 7 Baltic Rim (28603)</li>\n<li>ISO-8859-14 Latin 8 Celtic (28604)</li>\n<li>ISO-8859-15 Latin 9 (28605)</li>\n<li>ISO-8859-16 Latin 10 (28606)</li>\n<li>ISO 2022 JIS Japanese with no halfwidth Katakana (50220)</li>\n<li>ISO 2022 JIS Japanese with halfwidth Katakana (50221)</li>\n<li>ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)</li>\n<li>ISO 2022 Korean (50225)</li>\n<li>ISO 2022 Simplified Chinese (50227)</li>\n<li>ISO 6937 Non-Spacing Accent (20269)</li>\n<li>EUC Japanese (51932)</li>\n<li>EUC Simplified Chinese (51936)</li>\n<li>EUC Korean (51949)</li>\n<li>ISCII Devanagari (57002)</li>\n<li>ISCII Bengali (57003)</li>\n<li>ISCII Tamil (57004)</li>\n<li>ISCII Telugu (57005)</li>\n<li>ISCII Assamese (57006)</li>\n<li>ISCII Oriya (57007)</li>\n<li>ISCII Kannada (57008)</li>\n<li>ISCII Malayalam (57009)</li>\n<li>ISCII Gujarati (57010)</li>\n<li>ISCII Punjabi (57011)</li>\n<li>Japanese Shift-JIS (932)</li>\n<li>Simplified Chinese GBK (936)</li>\n<li>Korean (949)</li>\n<li>Traditional Chinese Big5 (950)</li>\n<li>US-ASCII (7-bit) (20127)</li>\n<li>Simplified Chinese GB2312 (20936)</li>\n<li>KOI8-R Russian Cyrillic (20866)</li>\n<li>KOI8-U Ukrainian Cyrillic (21866)</li>\n<li>Mazovia (Polish) MS-DOS (620)</li>\n<li>Arabic (ASMO 708) (708)</li>\n<li>Arabic (Transparent ASMO); Arabic (DOS) (720)</li>\n<li>Kamenick\u00fd (Czech) MS-DOS (895)</li>\n<li>Korean (Johab) (1361)</li>\n<li>MAC Roman (10000)</li>\n<li>Japanese (Mac) (10001)</li>\n<li>MAC Traditional Chinese (Big5) (10002)</li>\n<li>Korean (Mac) (10003)</li>\n<li>Arabic (Mac) (10004)</li>\n<li>Hebrew (Mac) (10005)</li>\n<li>Greek (Mac) (10006)</li>\n<li>Cyrillic (Mac) (10007)</li>\n<li>MAC Simplified Chinese (GB 2312) (10008)</li>\n<li>Romanian (Mac) (10010)</li>\n<li>Ukrainian (Mac) (10017)</li>\n<li>Thai (Mac) (10021)</li>\n<li>MAC Latin 2 (Central European) (10029)</li>\n<li>Icelandic (Mac) (10079)</li>\n<li>Turkish (Mac) (10081)</li>\n<li>Croatian (Mac) (10082)</li>\n<li>CNS Taiwan (Chinese Traditional) (20000)</li>\n<li>TCA Taiwan (20001)</li>\n<li>ETEN Taiwan (Chinese Traditional) (20002)</li>\n<li>IBM5550 Taiwan (20003)</li>\n<li>TeleText Taiwan (20004)</li>\n<li>Wang Taiwan (20005)</li>\n<li>Western European IA5 (IRV International Alphabet 5) (20105)</li>\n<li>IA5 German (7-bit) (20106)</li>\n<li>IA5 Swedish (7-bit) (20107)</li>\n<li>IA5 Norwegian (7-bit) (20108)</li>\n<li>T.61 (20261)</li>\n<li>Japanese (JIS 0208-1990 and 0212-1990) (20932)</li>\n<li>Korean Wansung (20949)</li>\n<li>Extended/Ext Alpha Lowercase (21027)</li>\n<li>Europa 3 (29001)</li>\n<li>Atari ST/TT (47451)</li>\n<li>HZ-GB2312 Simplified Chinese (52936)</li>\n<li>Simplified Chinese GB18030 (54936)</li>\n</ul>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Encoding",
          "type": "option",
          "value": [
            "UTF-8 (65001)",
            "UTF-7 (65000)",
            "UTF-16LE (1200)",
            "UTF-16BE (1201)",
            "UTF-32LE (12000)",
            "UTF-32BE (12001)",
            "IBM EBCDIC International (500)",
            "IBM EBCDIC US-Canada (37)",
            "IBM EBCDIC Multilingual/ROECE (Latin 2) (870)",
            "IBM EBCDIC Greek Modern (875)",
            "IBM EBCDIC French (1010)",
            "IBM EBCDIC Turkish (Latin 5) (1026)",
            "IBM EBCDIC Latin 1/Open System (1047)",
            "IBM EBCDIC Lao (1132/1133/1341)",
            "IBM EBCDIC US-Canada (037 + Euro symbol) (1140)",
            "IBM EBCDIC Germany (20273 + Euro symbol) (1141)",
            "IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)",
            "IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)",
            "IBM EBCDIC Italy (20280 + Euro symbol) (1144)",
            "IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)",
            "IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)",
            "IBM EBCDIC France (20297 + Euro symbol) (1147)",
            "IBM EBCDIC International (500 + Euro symbol) (1148)",
            "IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)",
            "IBM EBCDIC Germany (20273)",
            "IBM EBCDIC Denmark-Norway (20277)",
            "IBM EBCDIC Finland-Sweden (20278)",
            "IBM EBCDIC Italy (20280)",
            "IBM EBCDIC Latin America-Spain (20284)",
            "IBM EBCDIC United Kingdom (20285)",
            "IBM EBCDIC Japanese Katakana Extended (20290)",
            "IBM EBCDIC France (20297)",
            "IBM EBCDIC Arabic (20420)",
            "IBM EBCDIC Greek (20423)",
            "IBM EBCDIC Hebrew (20424)",
            "IBM EBCDIC Korean Extended (20833)",
            "IBM EBCDIC Thai (20838)",
            "IBM EBCDIC Icelandic (20871)",
            "IBM EBCDIC Cyrillic Russian (20880)",
            "IBM EBCDIC Turkish (20905)",
            "IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)",
            "IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)",
            "OEM United States (437)",
            "OEM Greek (formerly 437G); Greek (DOS) (737)",
            "OEM Baltic; Baltic (DOS) (775)",
            "OEM Russian; Cyrillic + Euro symbol (808)",
            "OEM Multilingual Latin 1; Western European (DOS) (850)",
            "OEM Latin 2; Central European (DOS) (852)",
            "OEM Cyrillic (primarily Russian) (855)",
            "OEM Turkish; Turkish (DOS) (857)",
            "OEM Multilingual Latin 1 + Euro symbol (858)",
            "OEM Portuguese; Portuguese (DOS) (860)",
            "OEM Icelandic; Icelandic (DOS) (861)",
            "OEM Hebrew; Hebrew (DOS) (862)",
            "OEM French Canadian; French Canadian (DOS) (863)",
            "OEM Arabic; Arabic (864) (864)",
            "OEM Nordic; Nordic (DOS) (865)",
            "OEM Russian; Cyrillic (DOS) (866)",
            "OEM Modern Greek; Greek, Modern (DOS) (869)",
            "OEM Cyrillic (primarily Russian) + Euro Symbol (872)",
            "Windows-874 Thai (874)",
            "Windows-1250 Central European (1250)",
            "Windows-1251 Cyrillic (1251)",
            "Windows-1252 Latin (1252)",
            "Windows-1253 Greek (1253)",
            "Windows-1254 Turkish (1254)",
            "Windows-1255 Hebrew (1255)",
            "Windows-1256 Arabic (1256)",
            "Windows-1257 Baltic (1257)",
            "Windows-1258 Vietnam (1258)",
            "ISO-8859-1 Latin 1 Western European (28591)",
            "ISO-8859-2 Latin 2 Central European (28592)",
            "ISO-8859-3 Latin 3 South European (28593)",
            "ISO-8859-4 Latin 4 North European (28594)",
            "ISO-8859-5 Latin/Cyrillic (28595)",
            "ISO-8859-6 Latin/Arabic (28596)",
            "ISO-8859-7 Latin/Greek (28597)",
            "ISO-8859-8 Latin/Hebrew (28598)",
            "ISO 8859-8 Hebrew (ISO-Logical) (38598)",
            "ISO-8859-9 Latin 5 Turkish (28599)",
            "ISO-8859-10 Latin 6 Nordic (28600)",
            "ISO-8859-11 Latin/Thai (28601)",
            "ISO-8859-13 Latin 7 Baltic Rim (28603)",
            "ISO-8859-14 Latin 8 Celtic (28604)",
            "ISO-8859-15 Latin 9 (28605)",
            "ISO-8859-16 Latin 10 (28606)",
            "ISO 2022 JIS Japanese with no halfwidth Katakana (50220)",
            "ISO 2022 JIS Japanese with halfwidth Katakana (50221)",
            "ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)",
            "ISO 2022 Korean (50225)",
            "ISO 2022 Simplified Chinese (50227)",
            "ISO 6937 Non-Spacing Accent (20269)",
            "EUC Japanese (51932)",
            "EUC Simplified Chinese (51936)",
            "EUC Korean (51949)",
            "ISCII Devanagari (57002)",
            "ISCII Bengali (57003)",
            "ISCII Tamil (57004)",
            "ISCII Telugu (57005)",
            "ISCII Assamese (57006)",
            "ISCII Oriya (57007)",
            "ISCII Kannada (57008)",
            "ISCII Malayalam (57009)",
            "ISCII Gujarati (57010)",
            "ISCII Punjabi (57011)",
            "Japanese Shift-JIS (932)",
            "Simplified Chinese GBK (936)",
            "Korean (949)",
            "Traditional Chinese Big5 (950)",
            "US-ASCII (7-bit) (20127)",
            "Simplified Chinese GB2312 (20936)",
            "KOI8-R Russian Cyrillic (20866)",
            "KOI8-U Ukrainian Cyrillic (21866)",
            "Mazovia (Polish) MS-DOS (620)",
            "Arabic (ASMO 708) (708)",
            "Arabic (Transparent ASMO); Arabic (DOS) (720)",
            "Kamenick\u00fd (Czech) MS-DOS (895)",
            "Korean (Johab) (1361)",
            "MAC Roman (10000)",
            "Japanese (Mac) (10001)",
            "MAC Traditional Chinese (Big5) (10002)",
            "Korean (Mac) (10003)",
            "Arabic (Mac) (10004)",
            "Hebrew (Mac) (10005)",
            "Greek (Mac) (10006)",
            "Cyrillic (Mac) (10007)",
            "MAC Simplified Chinese (GB 2312) (10008)",
            "Romanian (Mac) (10010)",
            "Ukrainian (Mac) (10017)",
            "Thai (Mac) (10021)",
            "MAC Latin 2 (Central European) (10029)",
            "Icelandic (Mac) (10079)",
            "Turkish (Mac) (10081)",
            "Croatian (Mac) (10082)",
            "CNS Taiwan (Chinese Traditional) (20000)",
            "TCA Taiwan (20001)",
            "ETEN Taiwan (Chinese Traditional) (20002)",
            "IBM5550 Taiwan (20003)",
            "TeleText Taiwan (20004)",
            "Wang Taiwan (20005)",
            "Western European IA5 (IRV International Alphabet 5) (20105)",
            "IA5 German (7-bit) (20106)",
            "IA5 Swedish (7-bit) (20107)",
            "IA5 Norwegian (7-bit) (20108)",
            "T.61 (20261)",
            "Japanese (JIS 0208-1990 and 0212-1990) (20932)",
            "Korean Wansung (20949)",
            "Extended/Ext Alpha Lowercase (21027)",
            "Europa 3 (29001)",
            "Atari ST/TT (47451)",
            "HZ-GB2312 Simplified Chinese (52936)",
            "Simplified Chinese GB18030 (54936)"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Defang IP Addresses",
      "module": "Default",
      "description": "Takes a IPv4 or IPv6 address and 'Defangs' it, meaning the IP becomes invalid, removing the risk of accidentally utilising it as an IP address.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Defang URL",
      "module": "Default",
      "description": "Takes a Universal Resource Locator (URL) and 'Defangs' it; meaning the URL becomes invalid, neutralising the risk of accidentally clicking on a malicious link.<br><br>This is often used when dealing with malicious links or IOCs.<br><br>Works well when combined with the 'Extract URLs' operation.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Escape dots",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Escape http",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Escape ://",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Process",
          "type": "option",
          "value": [
            "Valid domains and full URLs",
            "Only full URLs",
            "Everything"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "AES Decrypt",
      "module": "Ciphers",
      "description": "Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.<br><br><b>Key:</b> The following algorithms will be used based on the size of the key:<ul><li>16 bytes = AES-128</li><li>24 bytes = AES-192</li><li>32 bytes = AES-256</li></ul><br><br><b>IV:</b> The Initialization Vector should be 16 bytes long. If not entered, it will default to 16 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used as a default.<br><br><b>GCM Tag:</b> This field is ignored unless 'GCM' mode is used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "argSelector",
          "value": [
            {
              "name": "CBC",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "CFB",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "OFB",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "CTR",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "GCM",
              "on": [
                5,
                6
              ]
            },
            {
              "name": "ECB",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "CBC/NoPadding",
              "off": [
                5,
                6
              ]
            },
            {
              "name": "ECB/NoPadding",
              "off": [
                5,
                6
              ]
            }
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "GCM Tag",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Additional Authenticated Data",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Derive EVP key",
      "module": "Ciphers",
      "description": "This operation performs a password-based key derivation function (PBKDF) used extensively in OpenSSL. In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.<br><br>A salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.<br><br>If you leave the salt argument empty, a random salt will be generated.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Passphrase",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "UTF8",
            "Latin1",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Key size",
          "type": "number",
          "value": 128
        },
        {
          "name": "Iterations",
          "type": "number",
          "value": 1
        },
        {
          "name": "Hashing function",
          "type": "option",
          "value": [
            "SHA1",
            "SHA256",
            "SHA384",
            "SHA512",
            "MD5"
          ]
        },
        {
          "name": "Salt",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Derive HKDF key",
      "module": "Crypto",
      "description": "A simple Hashed Message Authenticaton Code (HMAC)-based key derivation function (HKDF), defined in RFC5869.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Salt",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        },
        {
          "name": "Info",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Decimal",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        },
        {
          "name": "Hashing function",
          "type": "option",
          "value": [
            "MD2",
            "MD4",
            "MD5",
            "SHA0",
            "SHA1",
            "SHA224",
            "SHA256",
            "SHA384",
            "SHA512",
            "SHA512/224",
            "SHA512/256",
            "RIPEMD128",
            "RIPEMD160",
            "RIPEMD256",
            "RIPEMD320",
            "HAS160",
            "Whirlpool",
            "Whirlpool-0",
            "Whirlpool-T",
            "Snefru"
          ]
        },
        {
          "name": "Extract mode",
          "type": "argSelector",
          "value": [
            {
              "name": "with salt",
              "on": [
                0
              ]
            },
            {
              "name": "no salt",
              "off": [
                0
              ]
            },
            {
              "name": "skip",
              "off": [
                0
              ]
            }
          ]
        },
        {
          "name": "L (number of output octets)",
          "type": "number",
          "value": 16
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Derive PBKDF2 key",
      "module": "Ciphers",
      "description": "PBKDF2 is a password-based key derivation function. It is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, specifically PKCS #5 v2.0, also published as Internet Engineering Task Force's RFC 2898.<br><br>In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.<br><br>A salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.<br><br>If you leave the salt argument empty, a random salt will be generated.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Passphrase",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "UTF8",
            "Latin1",
            "Hex",
            "Base64"
          ]
        },
        {
          "name": "Key size",
          "type": "number",
          "value": 128
        },
        {
          "name": "Iterations",
          "type": "number",
          "value": 1
        },
        {
          "name": "Hashing function",
          "type": "option",
          "value": [
            "SHA1",
            "SHA256",
            "SHA384",
            "SHA512",
            "MD5"
          ]
        },
        {
          "name": "Salt",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Detect File Type",
      "module": "Default",
      "description": "Attempts to guess the MIME (Multipurpose Internet Mail Extensions) type of the data based on 'magic bytes'.<br><br>Currently supports the following file types: 123d, 7z, B64, abcdp, accda, accdb, accde, accdu, ace, ai, aif, aifc, alz, amr, arj, arw, au, auf, avi, axf, bash, bct, bin, bitlocker, bk!, bmp, bplist, bz2, cab, cat, cer, chi, chm, chw, class, com, cr2, crl, crt, crw, crx, db, dbx, deb, der, dex, dll, dmf, dmg, dmp, doc, docx, dot, drv, dwg, dwt, dylib, edb, elf, eot, eps, epub, evt, evtx, exe, f4v, fdb, flac, flv, fon, gif, gpg, gz, hbin, hdr, heic, heif, hqx, ichat, ico, ipmeta, iso, jar, job, jpe, jpeg, jpg, jxr, keychain, kgb, lnk, luac, lzo, lzop, m4a, m4v, mda, mdb, mdbackup, mde, mdi, mdinfo, mdt, midi, mkv, mov, mp3, mp4, mpg, mpo, mrw, msg, msi, nib, o, ocx, ogg, ogm, ogv, ogx, ole2, one, opus, ost, otf, p7b, p7c, p7m, p7s, pab, pdf, pf, pfa, pgd, phar, php, php-s, php3, php4, php5, php7, phps, pht, phtml, pkr, pl, plist, pm, png, pod, pot, ppa, pps, ppt, pptx, prx, ps, psa, psb, psd, psp, pst, pwl, py, pyc, pyd, pyo, pyw, pyz, qtz, raf, rar, rb, registry, rgs, rsa, rtf, scr, sdw, sh, skr, sml, so, sqlite, strings, swf, swz, sys, t, tar, tar.z, tcp, tga, thm, tif, torrent, ttf, txt, udp, utf16le, utf32le, vbx, vhd, vmdk, vsd, vxd, wallet, wasm, wav, wcm, webbookmark, webhistory, webm, webp, wmv, woff, woff2, wp, wp5, wp6, wpd, wpp, xcf, xla, xls, xlsx, xz, zip, zlib.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Images",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Video",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Audio",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Documents",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Applications",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Archives",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Miscellaneous",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Diff",
      "module": "Diff",
      "description": "Compares two inputs (separated by the specified delimiter) and highlights the differences between them.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        },
        {
          "name": "Diff by",
          "type": "option",
          "value": [
            "Character",
            "Word",
            "Line",
            "Sentence",
            "CSS",
            "JSON"
          ]
        },
        {
          "name": "Show added",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show removed",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show subtraction",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Ignore whitespace",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Disassemble x86",
      "module": "Shellcode",
      "description": "Disassembly is the process of translating machine language into assembly language.<br><br>This operation supports 64-bit, 32-bit and 16-bit code written for Intel or AMD x86 processors. It is particularly useful for reverse engineering shellcode.<br><br>Input should be in hexadecimal.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Bit mode",
          "type": "option",
          "value": [
            "64",
            "32",
            "16"
          ]
        },
        {
          "name": "Compatibility",
          "type": "option",
          "value": [
            "Full x86 architecture",
            "Knights Corner",
            "Larrabee",
            "Cyrix",
            "Geode",
            "Centaur",
            "X86/486"
          ]
        },
        {
          "name": "Code Segment (CS)",
          "type": "number",
          "value": 16
        },
        {
          "name": "Offset (IP)",
          "type": "number",
          "value": 0
        },
        {
          "name": "Show instruction hex",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show instruction position",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Dither Image",
      "module": "Image",
      "description": "Apply a dither effect to an image.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Divide",
      "module": "Default",
      "description": "Divides a list of numbers. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 .5</code> becomes <code>2.5</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Drop bytes",
      "module": "Default",
      "description": "Cuts a slice of the specified number of bytes out of the data. Negative values are allowed.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Start",
          "type": "number",
          "value": 0
        },
        {
          "name": "Length",
          "type": "number",
          "value": 5
        },
        {
          "name": "Apply to each line",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Drop nth bytes",
      "module": "Default",
      "description": "Drops every nth byte starting with a given byte.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Drop every",
          "type": "number",
          "value": 4
        },
        {
          "name": "Starting at",
          "type": "number",
          "value": 0
        },
        {
          "name": "Apply to each line",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Encode NetBIOS Name",
      "module": "Default",
      "description": "NetBIOS names as seen across the client interface to NetBIOS are exactly 16 bytes long. Within the NetBIOS-over-TCP protocols, a longer representation is used.<br><br>There are two levels of encoding. The first level maps a NetBIOS name into a domain system name.  The second level maps the domain system name into the 'compressed' representation required for interaction with the domain name system.<br><br>This operation carries out the first level of encoding. See RFC 1001 for full details.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Offset",
          "type": "number",
          "value": 65
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Encode text",
      "module": "Encodings",
      "description": "Encodes text into the chosen character encoding.\n<br><br>\nSupported charsets are:\n<ul>\n<li>UTF-8 (65001)</li>\n<li>UTF-7 (65000)</li>\n<li>UTF-16LE (1200)</li>\n<li>UTF-16BE (1201)</li>\n<li>UTF-32LE (12000)</li>\n<li>UTF-32BE (12001)</li>\n<li>IBM EBCDIC International (500)</li>\n<li>IBM EBCDIC US-Canada (37)</li>\n<li>IBM EBCDIC Multilingual/ROECE (Latin 2) (870)</li>\n<li>IBM EBCDIC Greek Modern (875)</li>\n<li>IBM EBCDIC French (1010)</li>\n<li>IBM EBCDIC Turkish (Latin 5) (1026)</li>\n<li>IBM EBCDIC Latin 1/Open System (1047)</li>\n<li>IBM EBCDIC Lao (1132/1133/1341)</li>\n<li>IBM EBCDIC US-Canada (037 + Euro symbol) (1140)</li>\n<li>IBM EBCDIC Germany (20273 + Euro symbol) (1141)</li>\n<li>IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)</li>\n<li>IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)</li>\n<li>IBM EBCDIC Italy (20280 + Euro symbol) (1144)</li>\n<li>IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)</li>\n<li>IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)</li>\n<li>IBM EBCDIC France (20297 + Euro symbol) (1147)</li>\n<li>IBM EBCDIC International (500 + Euro symbol) (1148)</li>\n<li>IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)</li>\n<li>IBM EBCDIC Germany (20273)</li>\n<li>IBM EBCDIC Denmark-Norway (20277)</li>\n<li>IBM EBCDIC Finland-Sweden (20278)</li>\n<li>IBM EBCDIC Italy (20280)</li>\n<li>IBM EBCDIC Latin America-Spain (20284)</li>\n<li>IBM EBCDIC United Kingdom (20285)</li>\n<li>IBM EBCDIC Japanese Katakana Extended (20290)</li>\n<li>IBM EBCDIC France (20297)</li>\n<li>IBM EBCDIC Arabic (20420)</li>\n<li>IBM EBCDIC Greek (20423)</li>\n<li>IBM EBCDIC Hebrew (20424)</li>\n<li>IBM EBCDIC Korean Extended (20833)</li>\n<li>IBM EBCDIC Thai (20838)</li>\n<li>IBM EBCDIC Icelandic (20871)</li>\n<li>IBM EBCDIC Cyrillic Russian (20880)</li>\n<li>IBM EBCDIC Turkish (20905)</li>\n<li>IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)</li>\n<li>IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)</li>\n<li>OEM United States (437)</li>\n<li>OEM Greek (formerly 437G); Greek (DOS) (737)</li>\n<li>OEM Baltic; Baltic (DOS) (775)</li>\n<li>OEM Russian; Cyrillic + Euro symbol (808)</li>\n<li>OEM Multilingual Latin 1; Western European (DOS) (850)</li>\n<li>OEM Latin 2; Central European (DOS) (852)</li>\n<li>OEM Cyrillic (primarily Russian) (855)</li>\n<li>OEM Turkish; Turkish (DOS) (857)</li>\n<li>OEM Multilingual Latin 1 + Euro symbol (858)</li>\n<li>OEM Portuguese; Portuguese (DOS) (860)</li>\n<li>OEM Icelandic; Icelandic (DOS) (861)</li>\n<li>OEM Hebrew; Hebrew (DOS) (862)</li>\n<li>OEM French Canadian; French Canadian (DOS) (863)</li>\n<li>OEM Arabic; Arabic (864) (864)</li>\n<li>OEM Nordic; Nordic (DOS) (865)</li>\n<li>OEM Russian; Cyrillic (DOS) (866)</li>\n<li>OEM Modern Greek; Greek, Modern (DOS) (869)</li>\n<li>OEM Cyrillic (primarily Russian) + Euro Symbol (872)</li>\n<li>Windows-874 Thai (874)</li>\n<li>Windows-1250 Central European (1250)</li>\n<li>Windows-1251 Cyrillic (1251)</li>\n<li>Windows-1252 Latin (1252)</li>\n<li>Windows-1253 Greek (1253)</li>\n<li>Windows-1254 Turkish (1254)</li>\n<li>Windows-1255 Hebrew (1255)</li>\n<li>Windows-1256 Arabic (1256)</li>\n<li>Windows-1257 Baltic (1257)</li>\n<li>Windows-1258 Vietnam (1258)</li>\n<li>ISO-8859-1 Latin 1 Western European (28591)</li>\n<li>ISO-8859-2 Latin 2 Central European (28592)</li>\n<li>ISO-8859-3 Latin 3 South European (28593)</li>\n<li>ISO-8859-4 Latin 4 North European (28594)</li>\n<li>ISO-8859-5 Latin/Cyrillic (28595)</li>\n<li>ISO-8859-6 Latin/Arabic (28596)</li>\n<li>ISO-8859-7 Latin/Greek (28597)</li>\n<li>ISO-8859-8 Latin/Hebrew (28598)</li>\n<li>ISO 8859-8 Hebrew (ISO-Logical) (38598)</li>\n<li>ISO-8859-9 Latin 5 Turkish (28599)</li>\n<li>ISO-8859-10 Latin 6 Nordic (28600)</li>\n<li>ISO-8859-11 Latin/Thai (28601)</li>\n<li>ISO-8859-13 Latin 7 Baltic Rim (28603)</li>\n<li>ISO-8859-14 Latin 8 Celtic (28604)</li>\n<li>ISO-8859-15 Latin 9 (28605)</li>\n<li>ISO-8859-16 Latin 10 (28606)</li>\n<li>ISO 2022 JIS Japanese with no halfwidth Katakana (50220)</li>\n<li>ISO 2022 JIS Japanese with halfwidth Katakana (50221)</li>\n<li>ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)</li>\n<li>ISO 2022 Korean (50225)</li>\n<li>ISO 2022 Simplified Chinese (50227)</li>\n<li>ISO 6937 Non-Spacing Accent (20269)</li>\n<li>EUC Japanese (51932)</li>\n<li>EUC Simplified Chinese (51936)</li>\n<li>EUC Korean (51949)</li>\n<li>ISCII Devanagari (57002)</li>\n<li>ISCII Bengali (57003)</li>\n<li>ISCII Tamil (57004)</li>\n<li>ISCII Telugu (57005)</li>\n<li>ISCII Assamese (57006)</li>\n<li>ISCII Oriya (57007)</li>\n<li>ISCII Kannada (57008)</li>\n<li>ISCII Malayalam (57009)</li>\n<li>ISCII Gujarati (57010)</li>\n<li>ISCII Punjabi (57011)</li>\n<li>Japanese Shift-JIS (932)</li>\n<li>Simplified Chinese GBK (936)</li>\n<li>Korean (949)</li>\n<li>Traditional Chinese Big5 (950)</li>\n<li>US-ASCII (7-bit) (20127)</li>\n<li>Simplified Chinese GB2312 (20936)</li>\n<li>KOI8-R Russian Cyrillic (20866)</li>\n<li>KOI8-U Ukrainian Cyrillic (21866)</li>\n<li>Mazovia (Polish) MS-DOS (620)</li>\n<li>Arabic (ASMO 708) (708)</li>\n<li>Arabic (Transparent ASMO); Arabic (DOS) (720)</li>\n<li>Kamenick\u00fd (Czech) MS-DOS (895)</li>\n<li>Korean (Johab) (1361)</li>\n<li>MAC Roman (10000)</li>\n<li>Japanese (Mac) (10001)</li>\n<li>MAC Traditional Chinese (Big5) (10002)</li>\n<li>Korean (Mac) (10003)</li>\n<li>Arabic (Mac) (10004)</li>\n<li>Hebrew (Mac) (10005)</li>\n<li>Greek (Mac) (10006)</li>\n<li>Cyrillic (Mac) (10007)</li>\n<li>MAC Simplified Chinese (GB 2312) (10008)</li>\n<li>Romanian (Mac) (10010)</li>\n<li>Ukrainian (Mac) (10017)</li>\n<li>Thai (Mac) (10021)</li>\n<li>MAC Latin 2 (Central European) (10029)</li>\n<li>Icelandic (Mac) (10079)</li>\n<li>Turkish (Mac) (10081)</li>\n<li>Croatian (Mac) (10082)</li>\n<li>CNS Taiwan (Chinese Traditional) (20000)</li>\n<li>TCA Taiwan (20001)</li>\n<li>ETEN Taiwan (Chinese Traditional) (20002)</li>\n<li>IBM5550 Taiwan (20003)</li>\n<li>TeleText Taiwan (20004)</li>\n<li>Wang Taiwan (20005)</li>\n<li>Western European IA5 (IRV International Alphabet 5) (20105)</li>\n<li>IA5 German (7-bit) (20106)</li>\n<li>IA5 Swedish (7-bit) (20107)</li>\n<li>IA5 Norwegian (7-bit) (20108)</li>\n<li>T.61 (20261)</li>\n<li>Japanese (JIS 0208-1990 and 0212-1990) (20932)</li>\n<li>Korean Wansung (20949)</li>\n<li>Extended/Ext Alpha Lowercase (21027)</li>\n<li>Europa 3 (29001)</li>\n<li>Atari ST/TT (47451)</li>\n<li>HZ-GB2312 Simplified Chinese (52936)</li>\n<li>Simplified Chinese GB18030 (54936)</li>\n</ul>",
      "inputType": "string",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Encoding",
          "type": "option",
          "value": [
            "UTF-8 (65001)",
            "UTF-7 (65000)",
            "UTF-16LE (1200)",
            "UTF-16BE (1201)",
            "UTF-32LE (12000)",
            "UTF-32BE (12001)",
            "IBM EBCDIC International (500)",
            "IBM EBCDIC US-Canada (37)",
            "IBM EBCDIC Multilingual/ROECE (Latin 2) (870)",
            "IBM EBCDIC Greek Modern (875)",
            "IBM EBCDIC French (1010)",
            "IBM EBCDIC Turkish (Latin 5) (1026)",
            "IBM EBCDIC Latin 1/Open System (1047)",
            "IBM EBCDIC Lao (1132/1133/1341)",
            "IBM EBCDIC US-Canada (037 + Euro symbol) (1140)",
            "IBM EBCDIC Germany (20273 + Euro symbol) (1141)",
            "IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)",
            "IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)",
            "IBM EBCDIC Italy (20280 + Euro symbol) (1144)",
            "IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)",
            "IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)",
            "IBM EBCDIC France (20297 + Euro symbol) (1147)",
            "IBM EBCDIC International (500 + Euro symbol) (1148)",
            "IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)",
            "IBM EBCDIC Germany (20273)",
            "IBM EBCDIC Denmark-Norway (20277)",
            "IBM EBCDIC Finland-Sweden (20278)",
            "IBM EBCDIC Italy (20280)",
            "IBM EBCDIC Latin America-Spain (20284)",
            "IBM EBCDIC United Kingdom (20285)",
            "IBM EBCDIC Japanese Katakana Extended (20290)",
            "IBM EBCDIC France (20297)",
            "IBM EBCDIC Arabic (20420)",
            "IBM EBCDIC Greek (20423)",
            "IBM EBCDIC Hebrew (20424)",
            "IBM EBCDIC Korean Extended (20833)",
            "IBM EBCDIC Thai (20838)",
            "IBM EBCDIC Icelandic (20871)",
            "IBM EBCDIC Cyrillic Russian (20880)",
            "IBM EBCDIC Turkish (20905)",
            "IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)",
            "IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)",
            "OEM United States (437)",
            "OEM Greek (formerly 437G); Greek (DOS) (737)",
            "OEM Baltic; Baltic (DOS) (775)",
            "OEM Russian; Cyrillic + Euro symbol (808)",
            "OEM Multilingual Latin 1; Western European (DOS) (850)",
            "OEM Latin 2; Central European (DOS) (852)",
            "OEM Cyrillic (primarily Russian) (855)",
            "OEM Turkish; Turkish (DOS) (857)",
            "OEM Multilingual Latin 1 + Euro symbol (858)",
            "OEM Portuguese; Portuguese (DOS) (860)",
            "OEM Icelandic; Icelandic (DOS) (861)",
            "OEM Hebrew; Hebrew (DOS) (862)",
            "OEM French Canadian; French Canadian (DOS) (863)",
            "OEM Arabic; Arabic (864) (864)",
            "OEM Nordic; Nordic (DOS) (865)",
            "OEM Russian; Cyrillic (DOS) (866)",
            "OEM Modern Greek; Greek, Modern (DOS) (869)",
            "OEM Cyrillic (primarily Russian) + Euro Symbol (872)",
            "Windows-874 Thai (874)",
            "Windows-1250 Central European (1250)",
            "Windows-1251 Cyrillic (1251)",
            "Windows-1252 Latin (1252)",
            "Windows-1253 Greek (1253)",
            "Windows-1254 Turkish (1254)",
            "Windows-1255 Hebrew (1255)",
            "Windows-1256 Arabic (1256)",
            "Windows-1257 Baltic (1257)",
            "Windows-1258 Vietnam (1258)",
            "ISO-8859-1 Latin 1 Western European (28591)",
            "ISO-8859-2 Latin 2 Central European (28592)",
            "ISO-8859-3 Latin 3 South European (28593)",
            "ISO-8859-4 Latin 4 North European (28594)",
            "ISO-8859-5 Latin/Cyrillic (28595)",
            "ISO-8859-6 Latin/Arabic (28596)",
            "ISO-8859-7 Latin/Greek (28597)",
            "ISO-8859-8 Latin/Hebrew (28598)",
            "ISO 8859-8 Hebrew (ISO-Logical) (38598)",
            "ISO-8859-9 Latin 5 Turkish (28599)",
            "ISO-8859-10 Latin 6 Nordic (28600)",
            "ISO-8859-11 Latin/Thai (28601)",
            "ISO-8859-13 Latin 7 Baltic Rim (28603)",
            "ISO-8859-14 Latin 8 Celtic (28604)",
            "ISO-8859-15 Latin 9 (28605)",
            "ISO-8859-16 Latin 10 (28606)",
            "ISO 2022 JIS Japanese with no halfwidth Katakana (50220)",
            "ISO 2022 JIS Japanese with halfwidth Katakana (50221)",
            "ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)",
            "ISO 2022 Korean (50225)",
            "ISO 2022 Simplified Chinese (50227)",
            "ISO 6937 Non-Spacing Accent (20269)",
            "EUC Japanese (51932)",
            "EUC Simplified Chinese (51936)",
            "EUC Korean (51949)",
            "ISCII Devanagari (57002)",
            "ISCII Bengali (57003)",
            "ISCII Tamil (57004)",
            "ISCII Telugu (57005)",
            "ISCII Assamese (57006)",
            "ISCII Oriya (57007)",
            "ISCII Kannada (57008)",
            "ISCII Malayalam (57009)",
            "ISCII Gujarati (57010)",
            "ISCII Punjabi (57011)",
            "Japanese Shift-JIS (932)",
            "Simplified Chinese GBK (936)",
            "Korean (949)",
            "Traditional Chinese Big5 (950)",
            "US-ASCII (7-bit) (20127)",
            "Simplified Chinese GB2312 (20936)",
            "KOI8-R Russian Cyrillic (20866)",
            "KOI8-U Ukrainian Cyrillic (21866)",
            "Mazovia (Polish) MS-DOS (620)",
            "Arabic (ASMO 708) (708)",
            "Arabic (Transparent ASMO); Arabic (DOS) (720)",
            "Kamenick\u00fd (Czech) MS-DOS (895)",
            "Korean (Johab) (1361)",
            "MAC Roman (10000)",
            "Japanese (Mac) (10001)",
            "MAC Traditional Chinese (Big5) (10002)",
            "Korean (Mac) (10003)",
            "Arabic (Mac) (10004)",
            "Hebrew (Mac) (10005)",
            "Greek (Mac) (10006)",
            "Cyrillic (Mac) (10007)",
            "MAC Simplified Chinese (GB 2312) (10008)",
            "Romanian (Mac) (10010)",
            "Ukrainian (Mac) (10017)",
            "Thai (Mac) (10021)",
            "MAC Latin 2 (Central European) (10029)",
            "Icelandic (Mac) (10079)",
            "Turkish (Mac) (10081)",
            "Croatian (Mac) (10082)",
            "CNS Taiwan (Chinese Traditional) (20000)",
            "TCA Taiwan (20001)",
            "ETEN Taiwan (Chinese Traditional) (20002)",
            "IBM5550 Taiwan (20003)",
            "TeleText Taiwan (20004)",
            "Wang Taiwan (20005)",
            "Western European IA5 (IRV International Alphabet 5) (20105)",
            "IA5 German (7-bit) (20106)",
            "IA5 Swedish (7-bit) (20107)",
            "IA5 Norwegian (7-bit) (20108)",
            "T.61 (20261)",
            "Japanese (JIS 0208-1990 and 0212-1990) (20932)",
            "Korean Wansung (20949)",
            "Extended/Ext Alpha Lowercase (21027)",
            "Europa 3 (29001)",
            "Atari ST/TT (47451)",
            "HZ-GB2312 Simplified Chinese (52936)",
            "Simplified Chinese GB18030 (54936)"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Enigma",
      "module": "Bletchley",
      "description": "Encipher/decipher with the WW2 Enigma machine.<br><br>Enigma was used by the German military, among others, around the WW2 era as a portable cipher machine to protect sensitive military, diplomatic and commercial communications.<br><br>The standard set of German military rotors and reflectors are provided. To configure the plugboard, enter a string of connected pairs of letters, e.g. <code>AB CD EF</code> connects A to B, C to D, and E to F. This is also used to create your own reflectors. To create your own rotor, enter the letters that the rotor maps A to Z to, in order, optionally followed by <code>&lt;</code> then a list of stepping points.<br>This is deliberately fairly permissive with rotor placements etc compared to a real Enigma (on which, for example, a four-rotor Enigma uses only the thin reflectors and the beta or gamma rotor in the 4th slot).<br><br>More detailed descriptions of the Enigma, Typex and Bombe operations <a href='https://github.com/gchq/CyberChef/wiki/Enigma,-the-Bombe,-and-Typex'>can be found here</a>.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Model",
          "type": "argSelector",
          "value": [
            {
              "name": "3-rotor",
              "off": [
                1,
                2,
                3
              ]
            },
            {
              "name": "4-rotor",
              "on": [
                1,
                2,
                3
              ]
            }
          ]
        },
        {
          "name": "Left-most (4th) rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Beta",
              "value": "LEYJVCNIXWPBQMDRTAKZGFUHOS"
            },
            {
              "name": "Gamma",
              "value": "FSOKANUERHMBTIYCWLQPZXVGJD"
            }
          ]
        },
        {
          "name": "Left-most rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Left-most rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Left-hand rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "I",
              "value": "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R"
            },
            {
              "name": "II",
              "value": "AJDKSIRUXBLHWTMCQGZNPYFVOE<F"
            },
            {
              "name": "III",
              "value": "BDFHJLCPRTXVZNYEIWGAKMUSQO<W"
            },
            {
              "name": "IV",
              "value": "ESOVPZJAYQUIRHXLNFTGKDCMWB<K"
            },
            {
              "name": "V",
              "value": "VZBRGITYUPSDNHLXAWMJQOFECK<A"
            },
            {
              "name": "VI",
              "value": "JPGVOUMFYQBENHZRDKASXLICTW<AN"
            },
            {
              "name": "VII",
              "value": "NZJHGRCXMYSWBOUFAIVLPEKQDT<AN"
            },
            {
              "name": "VIII",
              "value": "FKQHTLXOCBJSPDZRAMEWNIUYGV<AN"
            }
          ]
        },
        {
          "name": "Left-hand rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Left-hand rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Middle rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "I",
              "value": "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R"
            },
            {
              "name": "II",
              "value": "AJDKSIRUXBLHWTMCQGZNPYFVOE<F"
            },
            {
              "name": "III",
              "value": "BDFHJLCPRTXVZNYEIWGAKMUSQO<W"
            },
            {
              "name": "IV",
              "value": "ESOVPZJAYQUIRHXLNFTGKDCMWB<K"
            },
            {
              "name": "V",
              "value": "VZBRGITYUPSDNHLXAWMJQOFECK<A"
            },
            {
              "name": "VI",
              "value": "JPGVOUMFYQBENHZRDKASXLICTW<AN"
            },
            {
              "name": "VII",
              "value": "NZJHGRCXMYSWBOUFAIVLPEKQDT<AN"
            },
            {
              "name": "VIII",
              "value": "FKQHTLXOCBJSPDZRAMEWNIUYGV<AN"
            }
          ]
        },
        {
          "name": "Middle rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Middle rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Right-hand rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "I",
              "value": "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R"
            },
            {
              "name": "II",
              "value": "AJDKSIRUXBLHWTMCQGZNPYFVOE<F"
            },
            {
              "name": "III",
              "value": "BDFHJLCPRTXVZNYEIWGAKMUSQO<W"
            },
            {
              "name": "IV",
              "value": "ESOVPZJAYQUIRHXLNFTGKDCMWB<K"
            },
            {
              "name": "V",
              "value": "VZBRGITYUPSDNHLXAWMJQOFECK<A"
            },
            {
              "name": "VI",
              "value": "JPGVOUMFYQBENHZRDKASXLICTW<AN"
            },
            {
              "name": "VII",
              "value": "NZJHGRCXMYSWBOUFAIVLPEKQDT<AN"
            },
            {
              "name": "VIII",
              "value": "FKQHTLXOCBJSPDZRAMEWNIUYGV<AN"
            }
          ]
        },
        {
          "name": "Right-hand rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Right-hand rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Reflector",
          "type": "editableOption",
          "value": [
            {
              "name": "B",
              "value": "AY BR CU DH EQ FS GL IP JX KN MO TZ VW"
            },
            {
              "name": "C",
              "value": "AF BV CP DJ EI GO HY KR LZ MX NW TQ SU"
            },
            {
              "name": "B Thin",
              "value": "AE BN CK DQ FU GY HW IJ LO MP RX SZ TV"
            },
            {
              "name": "C Thin",
              "value": "AR BD CO EJ FN GT HK IV LM PW QZ SX UY"
            }
          ]
        },
        {
          "name": "Plugboard",
          "type": "string",
          "value": ""
        },
        {
          "name": "Strict output",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Entropy",
      "module": "Charts",
      "description": "Shannon Entropy, in the context of information theory, is a measure of the rate at which information is produced by a source of data. It can be used, in a broad sense, to detect whether data is likely to be structured or unstructured. 8 is the maximum, representing highly unstructured, 'random' data. English language text usually falls somewhere between 3.5 and 5. Properly encrypted or compressed data should have an entropy of over 7.5.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Visualisation",
          "type": "option",
          "value": [
            "Shannon scale",
            "Histogram (Bar)",
            "Histogram (Line)",
            "Curve",
            "Image"
          ]
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Escape string",
      "module": "Default",
      "description": "Escapes special characters in a string so that they do not cause conflicts. For example, <code>Don't stop me now</code> becomes <code>Don\\'t stop me now</code>.<br><br>Supports the following escape sequences:<ul><li><code>\\n</code> (Line feed/newline)</li><li><code>\\r</code> (Carriage return)</li><li><code>\\t</code> (Horizontal tab)</li><li><code>\\b</code> (Backspace)</li><li><code>\\f</code> (Form feed)</li><li><code>\\xnn</code> (Hex, where n is 0-f)</li><li><code>\\\\</code> (Backslash)</li><li><code>\\'</code> (Single quote)</li><li><code>\\&quot;</code> (Double quote)</li><li><code>\\unnnn</code> (Unicode character)</li><li><code>\\u{nnnnnn}</code> (Unicode code point)</li></ul>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Escape level",
          "type": "option",
          "value": [
            "Special chars",
            "Everything",
            "Minimal"
          ]
        },
        {
          "name": "Escape quote",
          "type": "option",
          "value": [
            "Single",
            "Double",
            "Backtick"
          ]
        },
        {
          "name": "JSON compatible",
          "type": "boolean",
          "value": false
        },
        {
          "name": "ES6 compatible",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Uppercase hex",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Escape Unicode Characters",
      "module": "Default",
      "description": "Converts characters to their unicode-escaped notations.<br><br>Supports the prefixes:<ul><li><code>\\u</code></li><li><code>%u</code></li><li><code>U+</code></li></ul>e.g. <code>\u03c3\u03bf\u03c5</code> becomes <code>\\u03C3\\u03BF\\u03C5</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Prefix",
          "type": "option",
          "value": [
            "\\u",
            "%u",
            "U+"
          ]
        },
        {
          "name": "Encode all chars",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Padding",
          "type": "number",
          "value": 4
        },
        {
          "name": "Uppercase hex",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Expand alphabet range",
      "module": "Default",
      "description": "Expand an alphabet range string into a list of the characters in that range.<br><br>e.g. <code>a-z</code> becomes <code>abcdefghijklmnopqrstuvwxyz</code>.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "binaryString",
          "value": ""
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Extract dates",
      "module": "Regex",
      "description": "Extracts dates in the following formats<ul><li><code>yyyy-mm-dd</code></li><li><code>dd/mm/yyyy</code></li><li><code>mm/dd/yyyy</code></li></ul>Dividers can be any of /, -, . or space",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Extract domains",
      "module": "Regex",
      "description": "Extracts fully qualified domain names.<br>Note that this will not include paths. Use <strong>Extract URLs</strong> to find entire URLs.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Underscore (DMARC, DKIM, etc)",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract EXIF",
      "module": "Image",
      "description": "Extracts EXIF data from an image.\n<br><br>\nEXIF data is metadata embedded in images (JPEG, JPG, TIFF) and audio files.\n<br><br>\nEXIF data from photos usually contains information about the image file itself as well as the device used to create it.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract email addresses",
      "module": "Regex",
      "description": "Extracts all email addresses from the input.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract file paths",
      "module": "Regex",
      "description": "Extracts anything that looks like a Windows or UNIX file path.<br><br>Note that if UNIX is selected, there will likely be a lot of false positives.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Windows",
          "type": "boolean",
          "value": true
        },
        {
          "name": "UNIX",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract Files",
      "module": "Default",
      "description": "Performs file carving to attempt to extract files from the input.<br><br>This operation is currently capable of carving out the following formats:\n            <ul>\n                <li>\n                JPG,JPEG,JPE,THM,MPO</li><li>GIF</li><li>PNG</li><li>WEBP</li><li>BMP</li><li>ICO</li><li>TGA</li><li>FLV</li><li>WAV</li><li>MP3</li><li>PDF</li><li>RTF</li><li>DOCX,XLSX,PPTX</li><li>EPUB</li><li>EXE,DLL,DRV,VXD,SYS,OCX,VBX,COM,FON,SCR</li><li>ELF,BIN,AXF,O,PRX,SO</li><li>DYLIB</li><li>ZIP</li><li>TAR</li><li>GZ</li><li>BZ2</li><li>ZLIB</li><li>XZ</li><li>JAR</li><li>LZOP,LZO</li><li>DEB</li><li>SQLITE</li><li>EVT</li><li>EVTX</li><li>DMP</li><li>PF</li><li>PLIST</li><li>KEYCHAIN</li><li>LNK\n                </li>\n            </ul>Minimum File Size can be used to prune small false positives.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Images",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Video",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Audio",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Documents",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Applications",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Archives",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Miscellaneous",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Ignore failed extractions",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Minimum File Size",
          "type": "number",
          "value": 100
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract hashes",
      "module": "Regex",
      "description": "Extracts potential hashes based on hash character length",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Hash character length",
          "type": "number",
          "value": 40
        },
        {
          "name": "All hashes",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Display Total",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract ID3",
      "module": "Default",
      "description": "This operation extracts ID3 metadata from an MP3 file.<br><br>ID3 is a metadata container most often used in conjunction with the MP3 audio file format. It allows information such as the title, artist, album, track number, and other information about the file to be stored in the file itself.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract IP addresses",
      "module": "Regex",
      "description": "Extracts all IPv4 and IPv6 addresses.<br><br>Warning: Given a string <code>1.2.3.4.5.6.7.8</code>, this will match <code>1.2.3.4 and 5.6.7.8</code> so always check the original input!",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "IPv4",
          "type": "boolean",
          "value": true
        },
        {
          "name": "IPv6",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Remove local IPv4 addresses",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract LSB",
      "module": "Image",
      "description": "Extracts the Least Significant Bit data from each pixel in an image. This is a common way to hide data in Steganography.",
      "inputType": "ArrayBuffer",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Colour Pattern #1",
          "type": "option",
          "value": [
            "R",
            "G",
            "B",
            "A"
          ]
        },
        {
          "name": "Colour Pattern #2",
          "type": "option",
          "value": [
            "",
            "R",
            "G",
            "B",
            "A"
          ]
        },
        {
          "name": "Colour Pattern #3",
          "type": "option",
          "value": [
            "",
            "R",
            "G",
            "B",
            "A"
          ]
        },
        {
          "name": "Colour Pattern #4",
          "type": "option",
          "value": [
            "",
            "R",
            "G",
            "B",
            "A"
          ]
        },
        {
          "name": "Pixel Order",
          "type": "option",
          "value": [
            "Row",
            "Column"
          ]
        },
        {
          "name": "Bit",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Extract MAC addresses",
      "module": "Regex",
      "description": "Extracts all Media Access Control (MAC) addresses from the input.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Extract RGBA",
      "module": "Image",
      "description": "Extracts each pixel's RGBA value in an image. These are sometimes used in Steganography to hide text or data.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "editableOption",
          "value": [
            {
              "name": "Comma",
              "value": ","
            },
            {
              "name": "Space",
              "value": " "
            },
            {
              "name": "CRLF",
              "value": "\\r\\n"
            },
            {
              "name": "Line Feed",
              "value": "\n"
            }
          ]
        },
        {
          "name": "Include Alpha",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Extract URLs",
      "module": "Regex",
      "description": "Extracts Uniform Resource Locators (URLs) from the input. The protocol (http, ftp etc.) is required otherwise there will be far too many false positives.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Fang URL",
      "module": "Default",
      "description": "Takes a 'Defanged' Universal Resource Locator (URL) and 'Fangs' it. Meaning, it removes the alterations (defanged) that render it useless so that it can be used again.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Restore [.]",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Restore hxxp",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Restore ://",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Fernet Decrypt",
      "module": "Default",
      "description": "Fernet is a symmetric encryption method which makes sure that the message encrypted cannot be manipulated/read without the key. It uses URL safe encoding for the keys. Fernet uses 128-bit AES in CBC mode and PKCS7 padding, with HMAC using SHA256 for authentication. The IV is created from os.random().<br><br><b>Key:</b> The key must be 32 bytes (256 bits) encoded with Base64.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Fernet Encrypt",
      "module": "Default",
      "description": "Fernet is a symmetric encryption method which makes sure that the message encrypted cannot be manipulated/read without the key. It uses URL safe encoding for the keys. Fernet uses 128-bit AES in CBC mode and PKCS7 padding, with HMAC using SHA256 for authentication. The IV is created from os.random().<br><br><b>Key:</b> The key must be 32 bytes (256 bits) encoded with Base64.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "File Tree",
      "module": "Default",
      "description": "Creates a file tree from a list of file paths (similar to the tree command in Linux)",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "File Path Delimiter",
          "type": "binaryString",
          "value": "/"
        },
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Filter",
      "module": "Regex",
      "description": "Splits up the input using the specified delimiter and then filters each branch based on a regular expression.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        },
        {
          "name": "Regex",
          "type": "string",
          "value": ""
        },
        {
          "name": "Invert condition",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Flip Image",
      "module": "Image",
      "description": "Flips an image along its X or Y axis.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Axis",
          "type": "option",
          "value": [
            "Horizontal",
            "Vertical"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Fork",
      "module": "Default",
      "description": "Split the input data up based on the specified delimiter and run all subsequent operations on each branch separately.<br><br>For example, to decode multiple Base64 strings, enter them all on separate lines then add the 'Fork' and 'From Base64' operations to the recipe. Each string will be decoded separately.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Split delimiter",
          "type": "binaryShortString",
          "value": "\\n"
        },
        {
          "name": "Merge delimiter",
          "type": "binaryShortString",
          "value": "\\n"
        },
        {
          "name": "Ignore errors",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Format MAC addresses",
      "module": "Default",
      "description": "Displays given MAC addresses in multiple different formats.<br><br>Expects addresses in a list separated by newlines, spaces or commas.<br><br>WARNING: There are no validity checks.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Output case",
          "type": "option",
          "value": [
            "Both",
            "Upper only",
            "Lower only"
          ]
        },
        {
          "name": "No delimiter",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Dash delimiter",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Colon delimiter",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Cisco style",
          "type": "boolean",
          "value": false
        },
        {
          "name": "IPv6 interface ID",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Frequency distribution",
      "module": "Default",
      "description": "Displays the distribution of bytes in the data as a graph.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Show 0%s",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show ASCII",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "From BCD",
      "module": "Default",
      "description": "Binary-Coded Decimal (BCD) is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four or eight. Special bit patterns are sometimes used for a sign.",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Scheme",
          "type": "option",
          "value": [
            "8 4 2 1",
            "7 4 2 1",
            "4 2 2 1",
            "2 4 2 1",
            "8 4 -2 -1",
            "Excess-3",
            "IBM 8 4 2 1"
          ]
        },
        {
          "name": "Packed",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Signed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Nibbles",
            "Bytes",
            "Raw"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base",
      "module": "Default",
      "description": "Converts a number to decimal from a given numerical base.",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Radix",
          "type": "number",
          "value": 36
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base32",
      "module": "Default",
      "description": "Base32 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. It uses a smaller set of characters than Base64, usually the uppercase alphabet and the numbers 2 to 7.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Standard",
              "value": "A-Z2-7="
            },
            {
              "name": "Hex Extended",
              "value": "0-9A-V="
            }
          ]
        },
        {
          "name": "Remove non-alphabet chars",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base45",
      "module": "Default",
      "description": "Base45 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system. Base45 is optimized for usage with QR codes.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Alphabet",
          "type": "string",
          "value": "0-9A-Z $%*+\\-./:"
        },
        {
          "name": "Remove non-alphabet chars",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base58",
      "module": "Default",
      "description": "Base58 (similar to Base64) is a notation for encoding arbitrary byte data. It differs from Base64 by removing easily misread characters (i.e. l, I, 0 and O) to improve human readability.<br><br>This operation decodes data from an ASCII string (with an alphabet of your choosing, presets included) back into its raw form.<br><br>e.g. <code>StV1DL6CwTryKyV</code> becomes <code>hello world</code><br><br>Base58 is commonly used in cryptocurrencies (Bitcoin, Ripple, etc).",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Bitcoin",
              "value": "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
            },
            {
              "name": "Ripple",
              "value": "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"
            }
          ]
        },
        {
          "name": "Remove non-alphabet chars",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base62",
      "module": "Default",
      "description": "Base62 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Alphabet",
          "type": "string",
          "value": "0-9A-Za-z"
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base64",
      "module": "Default",
      "description": "Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation decodes data from an ASCII Base64 string back into its raw format.<br><br>e.g. <code>aGVsbG8=</code> becomes <code>hello</code>",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Standard (RFC 4648): A-Za-z0-9+/=",
              "value": "A-Za-z0-9+/="
            },
            {
              "name": "URL safe (RFC 4648 \u00a75): A-Za-z0-9-_",
              "value": "A-Za-z0-9-_"
            },
            {
              "name": "Filename safe: A-Za-z0-9+-=",
              "value": "A-Za-z0-9+\\-="
            },
            {
              "name": "itoa64: ./0-9A-Za-z=",
              "value": "./0-9A-Za-z="
            },
            {
              "name": "XML: A-Za-z0-9_.",
              "value": "A-Za-z0-9_."
            },
            {
              "name": "y64: A-Za-z0-9._-",
              "value": "A-Za-z0-9._-"
            },
            {
              "name": "z64: 0-9a-zA-Z+/=",
              "value": "0-9a-zA-Z+/="
            },
            {
              "name": "Radix-64 (RFC 4880): 0-9A-Za-z+/=",
              "value": "0-9A-Za-z+/="
            },
            {
              "name": "Uuencoding: [space]-_",
              "value": " -_"
            },
            {
              "name": "Xxencoding: +-0-9A-Za-z",
              "value": "+\\-0-9A-Za-z"
            },
            {
              "name": "BinHex: !-,-0-689@A-NP-VX-Z[`a-fh-mp-r",
              "value": "!-,-0-689@A-NP-VX-Z[`a-fh-mp-r"
            },
            {
              "name": "ROT13: N-ZA-Mn-za-m0-9+/=",
              "value": "N-ZA-Mn-za-m0-9+/="
            },
            {
              "name": "UNIX crypt: ./0-9A-Za-z",
              "value": "./0-9A-Za-z"
            },
            {
              "name": "Atom128: /128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC",
              "value": "/128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC"
            },
            {
              "name": "Megan35: 3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5",
              "value": "3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5"
            },
            {
              "name": "Zong22: ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2",
              "value": "ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2"
            },
            {
              "name": "Hazz15: HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5",
              "value": "HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5"
            }
          ]
        },
        {
          "name": "Remove non-alphabet chars",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Strict mode",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base85",
      "module": "Default",
      "description": "Base85 (also called Ascii85) is a notation for encoding arbitrary byte data. It is usually more efficient that Base64.<br><br>This operation decodes data from an ASCII string (with an alphabet of your choosing, presets included).<br><br>e.g. <code>BOu!rD]j7BEbo7</code> becomes <code>hello world</code><br><br>Base85 is commonly used in Adobe's PostScript and PDF file formats.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Standard",
              "value": "!-u"
            },
            {
              "name": "Z85 (ZeroMQ)",
              "value": "0-9a-zA-Z.\\-:+=^!/*?&<>()[]{}@%$#"
            },
            {
              "name": "IPv6",
              "value": "0-9A-Za-z!#$%&()*+\\-;<=>?@^_`{|}~"
            }
          ]
        },
        {
          "name": "Remove non-alphabet chars",
          "type": "boolean",
          "value": true
        },
        {
          "name": "All-zero group char",
          "type": "binaryShortString",
          "value": "z"
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Base92",
      "module": "Default",
      "description": "Base92 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Binary",
      "module": "Default",
      "description": "Converts a binary string back into its raw form.<br><br>e.g. <code>01001000 01101001</code> becomes <code>Hi</code>",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF",
            "None"
          ]
        },
        {
          "name": "Byte Length",
          "type": "number",
          "value": 8
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Braille",
      "module": "Default",
      "description": "Converts six-dot braille symbols to text.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Case Insensitive Regex",
      "module": "Default",
      "description": "Converts a case-insensitive regex string to a case sensitive regex string (no guarantee on it being the proper original casing) in case the i flag wasn't available at the time but now is, or you need it to be case-sensitive again.<br><br>e.g. <code>[mM][oO][zZ][iI][lL][lL][aA]/[0-9].[0-9] .*</code> becomes <code>Mozilla/[0-9].[0-9] .*</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "From Charcode",
      "module": "Default",
      "description": "Converts unicode character codes back into text.<br><br>e.g. <code>0393 03b5 03b9 03ac 20 03c3 03bf 03c5</code> becomes <code>\u0393\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5</code>",
      "inputType": "string",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Base",
          "type": "number",
          "value": 16
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Decimal",
      "module": "Default",
      "description": "Converts the data from an ordinal integer array back into its raw form.<br><br>e.g. <code>72 101 108 108 111</code> becomes <code>Hello</code>",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Support signed values",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Float",
      "module": "Default",
      "description": "Convert from IEEE754 Floating Point Numbers",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Endianness",
          "type": "option",
          "value": [
            "Big Endian",
            "Little Endian"
          ]
        },
        {
          "name": "Size",
          "type": "option",
          "value": [
            "Float (4 bytes)",
            "Double (8 bytes)"
          ]
        },
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From HTML Entity",
      "module": "Encodings",
      "description": "Converts HTML entities back to characters<br><br>e.g. <code>&amp;<span>amp;</span></code> becomes <code>&amp;</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Hex",
      "module": "Default",
      "description": "Converts a hexadecimal byte string back into its raw value.<br><br>e.g. <code>ce 93 ce b5 ce b9 ce ac 20 cf 83 ce bf cf 85 0a</code> becomes the UTF-8 encoded string <code>\u0393\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5</code>",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Auto",
            "Space",
            "Percent",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF",
            "0x",
            "0x with comma",
            "\\x",
            "None"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Hex Content",
      "module": "Default",
      "description": "Translates hexadecimal bytes in text back to raw bytes. This format is used by SNORT for representing hex within ASCII text.<br><br>e.g. <code>foo|3d|bar</code> becomes <code>foo=bar</code>.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Hexdump",
      "module": "Default",
      "description": "Attempts to convert a hexdump back into raw data. This operation supports many different hexdump variations, but probably not all. Make sure you verify that the data it gives you is correct before continuing analysis.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From MessagePack",
      "module": "Code",
      "description": "Converts MessagePack encoded data to JSON. MessagePack is a computer data interchange format. It is a binary form for representing simple data structures like arrays and associative arrays.",
      "inputType": "ArrayBuffer",
      "outputType": "JSON",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Modhex",
      "module": "Default",
      "description": "Converts a modhex byte string back into its raw value.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Auto",
            "Space",
            "Percent",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF",
            "None"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Morse Code",
      "module": "Default",
      "description": "Translates Morse Code into (upper case) alphanumeric characters.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Letter delimiter",
          "type": "option",
          "value": [
            "Space",
            "Line feed",
            "CRLF",
            "Forward slash",
            "Backslash",
            "Comma",
            "Semi-colon",
            "Colon"
          ]
        },
        {
          "name": "Word delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Forward slash",
            "Backslash",
            "Comma",
            "Semi-colon",
            "Colon"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "From Octal",
      "module": "Default",
      "description": "Converts an octal byte string back into its raw value.<br><br>e.g. <code>316 223 316 265 316 271 316 254 40 317 203 316 277 317 205</code> becomes the UTF-8 encoded string <code>\u0393\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5</code>",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Punycode",
      "module": "Encodings",
      "description": "Punycode is a way to represent Unicode with the limited character subset of ASCII supported by the Domain Name System.<br><br>e.g. <code>mnchen-3ya</code> decodes to <code>m\u00fcnchen</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Internationalised domain name",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From Quoted Printable",
      "module": "Default",
      "description": "Converts QP-encoded text back to standard text.<br><br>e.g. The quoted-printable encoded string <code>hello=20world</code> becomes <code>hello world</code>",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "From UNIX Timestamp",
      "module": "Default",
      "description": "Converts a UNIX timestamp to a datetime string.<br><br>e.g. <code>978346800</code> becomes <code>Mon 1 January 2001 11:00:00 UTC</code><br><br>A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).",
      "inputType": "number",
      "outputType": "string",
      "args": [
        {
          "name": "Units",
          "type": "option",
          "value": [
            "Seconds (s)",
            "Milliseconds (ms)",
            "Microseconds (\u03bcs)",
            "Nanoseconds (ns)"
          ]
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Fuzzy Match",
      "module": "Default",
      "description": "Conducts a fuzzy search to find a pattern within the input based on weighted criteria.<br><br>e.g. A search for <code>dpan</code> will match on <code><b>D</b>on't <b>Pan</b>ic</code>",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Search",
          "type": "binaryString",
          "value": ""
        },
        {
          "name": "Sequential bonus",
          "type": "number",
          "value": 15
        },
        {
          "name": "Separator bonus",
          "type": "number",
          "value": 30
        },
        {
          "name": "Camel bonus",
          "type": "number",
          "value": 30
        },
        {
          "name": "First letter bonus",
          "type": "number",
          "value": 15
        },
        {
          "name": "Leading letter penalty",
          "type": "number",
          "value": -5
        },
        {
          "name": "Max leading letter penalty",
          "type": "number",
          "value": -15
        },
        {
          "name": "Unmatched letter penalty",
          "type": "number",
          "value": -1
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Generate all checksums",
      "module": "Crypto",
      "description": "Generates all available checksums for the input.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Length (bits)",
          "type": "option",
          "value": [
            "All",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "21",
            "24",
            "30",
            "31",
            "32",
            "40",
            "64",
            "82"
          ]
        },
        {
          "name": "Include names",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Generate all hashes",
      "module": "Crypto",
      "description": "Generates all available hashes and checksums for the input.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Length (bits)",
          "type": "option",
          "value": [
            "All",
            "128",
            "160",
            "224",
            "256",
            "320",
            "384",
            "512"
          ]
        },
        {
          "name": "Include names",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Generate De Bruijn Sequence",
      "module": "Default",
      "description": "Generates rolling keycode combinations given a certain alphabet size and key length.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet size (k)",
          "type": "number",
          "value": 2
        },
        {
          "name": "Key length (n)",
          "type": "number",
          "value": 3
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Generate ECDSA Key Pair",
      "module": "Ciphers",
      "description": "Generate an ECDSA key pair with a given Curve.<br><br>WARNING: Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. We advise you not to use keys generated from CyberChef in operational contexts.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Elliptic Curve",
          "type": "option",
          "value": [
            "P-256",
            "P-384",
            "P-521"
          ]
        },
        {
          "name": "Output Format",
          "type": "option",
          "value": [
            "PEM",
            "DER",
            "JWK"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Generate HOTP",
      "module": "Default",
      "description": "The HMAC-based One-Time Password algorithm (HOTP) is an algorithm that computes a one-time password from a shared secret key and an incrementing counter. It has been adopted as Internet Engineering Task Force standard RFC 4226, is the cornerstone of Initiative For Open Authentication (OAUTH), and is used in a number of two-factor authentication systems.<br><br>Enter the secret as the input or leave it blank for a random secret to be generated.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Name",
          "type": "string",
          "value": ""
        },
        {
          "name": "Code length",
          "type": "number",
          "value": 6
        },
        {
          "name": "Counter",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Generate Image",
      "module": "Image",
      "description": "Generates an image using the input as pixel values.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "Greyscale",
            "RG",
            "RGB",
            "RGBA",
            "Bits"
          ]
        },
        {
          "name": "Pixel Scale Factor",
          "type": "number",
          "value": 8
        },
        {
          "name": "Pixels per row",
          "type": "number",
          "value": 64
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Generate Lorem Ipsum",
      "module": "Default",
      "description": "Generate varying length lorem ipsum placeholder text.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Length",
          "type": "number",
          "value": "3"
        },
        {
          "name": "Length in",
          "type": "option",
          "value": [
            "Paragraphs",
            "Sentences",
            "Words",
            "Bytes"
          ]
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Generate PGP Key Pair",
      "module": "PGP",
      "description": "Generates a new public/private PGP key pair. Supports RSA and Eliptic Curve (EC) keys.<br><br>WARNING: Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. We advise you not to use keys generated from CyberChef in operational contexts.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key type",
          "type": "option",
          "value": [
            "RSA-1024",
            "RSA-2048",
            "RSA-4096",
            "ECC-256",
            "ECC-384",
            "ECC-521"
          ]
        },
        {
          "name": "Password (optional)",
          "type": "string",
          "value": ""
        },
        {
          "name": "Name (optional)",
          "type": "string",
          "value": ""
        },
        {
          "name": "Email (optional)",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Generate QR Code",
      "module": "Image",
      "description": "Generates a Quick Response (QR) code from the input text.<br><br>A QR code is a type of matrix barcode (or two-dimensional barcode) first designed in 1994 for the automotive industry in Japan. A barcode is a machine-readable optical label that contains information about the item to which it is attached.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Image Format",
          "type": "option",
          "value": [
            "PNG",
            "SVG",
            "EPS",
            "PDF"
          ]
        },
        {
          "name": "Module size (px)",
          "type": "number",
          "value": 5
        },
        {
          "name": "Margin (num modules)",
          "type": "number",
          "value": 4
        },
        {
          "name": "Error correction",
          "type": "option",
          "value": [
            "Low",
            "Medium",
            "Quartile",
            "High"
          ]
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Generate RSA Key Pair",
      "module": "Ciphers",
      "description": "Generate an RSA key pair with a given number of bits.<br><br>WARNING: Cryptographic operations in CyberChef should not be relied upon to provide security in any situation. No guarantee is offered for their correctness. We advise you not to use keys generated from CyberChef in operational contexts.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "RSA Key Length",
          "type": "option",
          "value": [
            "1024",
            "2048",
            "4096"
          ]
        },
        {
          "name": "Output Format",
          "type": "option",
          "value": [
            "PEM",
            "JSON",
            "DER"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Generate TOTP",
      "module": "Default",
      "description": "The Time-based One-Time Password algorithm (TOTP) is an algorithm that computes a one-time password from a shared secret key and the current time. It has been adopted as Internet Engineering Task Force standard RFC 6238, is the cornerstone of Initiative For Open Authentication (OAUTH), and is used in a number of two-factor authentication systems. A TOTP is an HOTP where the counter is the current time.<br><br>Enter the secret as the input or leave it blank for a random secret to be generated. T0 and T1 are in seconds.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Name",
          "type": "string",
          "value": ""
        },
        {
          "name": "Code length",
          "type": "number",
          "value": 6
        },
        {
          "name": "Epoch offset (T0)",
          "type": "number",
          "value": 0
        },
        {
          "name": "Interval (T1)",
          "type": "number",
          "value": 30
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Generate UUID",
      "module": "Crypto",
      "description": "Generates an RFC 9562 (formerly RFC 4122) compliant Universally Unique Identifier (UUID), also known as a Globally Unique Identifier (GUID).<br><br>We currently support generating the following UUID versions:<br><ul><li><strong>v1</strong>: Timestamp-based</li><li><strong>v3</strong>: Namespace w/ MD5</li><li><strong>v4</strong>: Random (default)</li><li><strong>v5</strong>: Namespace w/ SHA-1</li><li><strong>v6</strong>: Timestamp, reordered</li><li><strong>v7</strong>: Unix Epoch time-based</li></ul>UUIDs are generated using the <a href='https://npmjs.org/uuid/'><code>uuid</code><a> package.<br>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Version",
          "type": "option",
          "value": [
            "v1",
            "v3",
            "v4",
            "v5",
            "v6",
            "v7"
          ]
        },
        {
          "name": "Namespace",
          "type": "string",
          "value": "1b671a64-40d5-491e-99b0-da01ff1f3341"
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Generic Code Beautify",
      "module": "Code",
      "description": "Attempts to pretty print C-style languages such as C, C++, C#, Java, PHP, JavaScript etc.<br><br>This will not do a perfect job, and the resulting code may not work any more. This operation is designed purely to make obfuscated or minified code more easy to read and understand.<br><br>Things which will not work properly:<ul><li>For loop formatting</li><li>Do-While loop formatting</li><li>Switch/Case indentation</li><li>Certain bit shift operators</li></ul>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Get All Casings",
      "module": "Default",
      "description": "Outputs all possible casing variations of a string.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Get Time",
      "module": "Default",
      "description": "Generates a timestamp showing the amount of time since the UNIX epoch (1970-01-01 00:00:00 UTC). Uses the W3C High Resolution Time API.",
      "inputType": "string",
      "outputType": "number",
      "args": [
        {
          "name": "Granularity",
          "type": "option",
          "value": [
            "Seconds (s)",
            "Milliseconds (ms)",
            "Microseconds (\u03bcs)",
            "Nanoseconds (ns)"
          ]
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Group IP addresses",
      "module": "Default",
      "description": "Groups a list of IP addresses into subnets. Supports both IPv4 and IPv6 addresses.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon"
          ]
        },
        {
          "name": "Subnet (CIDR)",
          "type": "number",
          "value": 24
        },
        {
          "name": "Only show the subnets",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Gunzip",
      "module": "Compression",
      "description": "Decompresses data which has been compressed using the deflate algorithm with gzip headers.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Gzip",
      "module": "Compression",
      "description": "Compresses data using the deflate algorithm with gzip headers.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Compression type",
          "type": "option",
          "value": [
            "Dynamic Huffman Coding",
            "Fixed Huffman Coding",
            "None (Store)"
          ]
        },
        {
          "name": "Filename (optional)",
          "type": "string",
          "value": ""
        },
        {
          "name": "Comment (optional)",
          "type": "string",
          "value": ""
        },
        {
          "name": "Include file checksum",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Hamming Distance",
      "module": "Default",
      "description": "In information theory, the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different. In other words, it measures the minimum number of substitutions required to change one string into the other, or the minimum number of errors that could have transformed one string into the other. In a more general context, the Hamming distance is one of several string metrics for measuring the edit distance between two sequences.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "binaryShortString",
          "value": "\\n\\n"
        },
        {
          "name": "Unit",
          "type": "option",
          "value": [
            "Byte",
            "Bit"
          ]
        },
        {
          "name": "Input type",
          "type": "option",
          "value": [
            "Raw string",
            "Hex"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Haversine distance",
      "module": "Default",
      "description": "Returns the distance between two pairs of GPS latitude and longitude co-ordinates in metres.<br><br>e.g. <code>51.487263,-0.124323, 38.9517,-77.1467</code>",
      "inputType": "string",
      "outputType": "number",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Head",
      "module": "Default",
      "description": "Like the UNIX head utility.<br>Gets the first n lines.<br>You can select all but the last n lines by entering a negative value for n.<br>The delimiter can be changed so that instead of lines, fields (i.e. commas) are selected instead.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        },
        {
          "name": "Number",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Heatmap chart",
      "module": "Charts",
      "description": "A heatmap is a graphical representation of data where the individual values contained in a matrix are represented as colors.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Record delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Field delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Tab"
          ]
        },
        {
          "name": "Number of vertical bins",
          "type": "number",
          "value": 25
        },
        {
          "name": "Number of horizontal bins",
          "type": "number",
          "value": 25
        },
        {
          "name": "Use column headers as labels",
          "type": "boolean",
          "value": true
        },
        {
          "name": "X label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Y label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Draw bin edges",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Min colour value",
          "type": "string",
          "value": "white"
        },
        {
          "name": "Max colour value",
          "type": "string",
          "value": "black"
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Hex Density chart",
      "module": "Charts",
      "description": "Hex density charts are used in a similar way to scatter charts, however rather than rendering tens of thousands of points, it groups the points into a few hundred hexagons to show the distribution.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Record delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Field delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Tab"
          ]
        },
        {
          "name": "Pack radius",
          "type": "number",
          "value": 25
        },
        {
          "name": "Draw radius",
          "type": "number",
          "value": 15
        },
        {
          "name": "Use column headers as labels",
          "type": "boolean",
          "value": true
        },
        {
          "name": "X label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Y label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Draw hexagon edges",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Min colour value",
          "type": "string",
          "value": "white"
        },
        {
          "name": "Max colour value",
          "type": "string",
          "value": "black"
        },
        {
          "name": "Draw empty hexagons within data boundaries",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Hex to Object Identifier",
      "module": "PublicKey",
      "description": "Converts a hexadecimal string into an object identifier (OID).",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Hex to PEM",
      "module": "PublicKey",
      "description": "Converts a hexadecimal DER (Distinguished Encoding Rules) string into PEM (Privacy Enhanced Mail) format.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Header string",
          "type": "string",
          "value": "CERTIFICATE"
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Image Filter",
      "module": "Image",
      "description": "Applies a greyscale or sepia filter to an image.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Filter type",
          "type": "option",
          "value": [
            "Greyscale",
            "Sepia"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Image Opacity",
      "module": "Image",
      "description": "Adjust the opacity of an image.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Opacity (%)",
          "type": "number",
          "value": 100
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Index of Coincidence",
      "module": "Default",
      "description": "Index of Coincidence (IC) is the probability of two randomly selected characters being the same. This can be used to determine whether text is readable or random, with English text having an IC of around 0.066. IC can therefore be a sound method to automate frequency analysis.",
      "inputType": "string",
      "outputType": "html",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Invert Image",
      "module": "Image",
      "description": "Invert the colours of an image.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "JavaScript Beautify",
      "module": "Code",
      "description": "Parses and pretty prints valid JavaScript code. Also works with JavaScript Object Notation (JSON).",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Indent string",
          "type": "binaryShortString",
          "value": "\\t"
        },
        {
          "name": "Quotes",
          "type": "option",
          "value": [
            "Auto",
            "Single",
            "Double"
          ]
        },
        {
          "name": "Semicolons before closing braces",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Include comments",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "JavaScript Minify",
      "module": "Code",
      "description": "Compresses JavaScript code.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "JavaScript Parser",
      "module": "Code",
      "description": "Returns an Abstract Syntax Tree for valid JavaScript code.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Location info",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Range info",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Include tokens array",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Include comments array",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Report errors and try to continue",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Jq",
      "module": "Jq",
      "description": "jq is a lightweight and flexible command-line JSON processor.",
      "inputType": "JSON",
      "outputType": "string",
      "args": [
        {
          "name": "Query",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Jsonata Query",
      "module": "Code",
      "description": "Query and transform JSON data with a jsonata query.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Query",
          "type": "text",
          "value": "string"
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Jump",
      "module": "Default",
      "description": "Jump forwards or backwards to the specified Label",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Label name",
          "type": "string",
          "value": ""
        },
        {
          "name": "Maximum jumps (if jumping backwards)",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Keccak",
      "module": "Crypto",
      "description": "The Keccak hash algorithm was designed by Guido Bertoni, Joan Daemen, Micha\u00ebl Peeters, and Gilles Van Assche, building upon RadioGat\u00fan. It was selected as the winner of the SHA-3 design competition.<br><br>This version of the algorithm is Keccak[c=2d] and differs from the SHA-3 specification.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "option",
          "value": [
            "512",
            "384",
            "256",
            "224"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Label",
      "module": "Default",
      "description": "Provides a location for conditional and fixed jumps to redirect execution to.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Name",
          "type": "shortString",
          "value": ""
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Levenshtein Distance",
      "module": "Default",
      "description": "Levenshtein Distance (also known as Edit Distance) is a string metric to measure a difference between two strings that counts operations (insertions, deletions, and substitutions) on single character that are required to change one string to another.",
      "inputType": "string",
      "outputType": "number",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n"
        },
        {
          "name": "Insertion cost",
          "type": "number",
          "value": 1
        },
        {
          "name": "Deletion cost",
          "type": "number",
          "value": 1
        },
        {
          "name": "Substitution cost",
          "type": "number",
          "value": 1
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Lorenz",
      "module": "Bletchley",
      "description": "The Lorenz SZ40/42 cipher attachment was a WW2 German rotor cipher machine with twelve rotors which attached in-line between remote teleprinters.<br><br>It used the Vernam cipher with two groups of five rotors (named the psi(\u03c8) wheels and chi(\u03c7) wheels at Bletchley Park) to create two pseudorandom streams of five bits, encoded in ITA2, which were XOR added to the plaintext. Two other rotors, dubbed the mu(\u03bc) or motor wheels, could hold up the stepping of the psi wheels meaning they stepped intermittently.<br><br>Each rotor has a different number of cams/lugs around their circumference which could be set active or inactive changing the key stream.<br><br>Three models of the Lorenz are emulated, SZ40, SZ42a and SZ42b and three example wheel patterns (the lug settings) are included (KH, ZMUG & BREAM) with the option to set a custom set using the letter 'x' for active or '.' for an inactive lug.<br><br>The input can either be plaintext or ITA2 when sending and ITA2 when receiving.<br><br>To learn more, Virtual Lorenz, an online, browser based simulation of the Lorenz SZ40/42 is available at <a href='https://lorenz.virtualcolossus.co.uk' target='_blank'>lorenz.virtualcolossus.co.uk</a>.<br><br>A more detailed description of this operation can be found <a href='https://github.com/gchq/CyberChef/wiki/Lorenz-SZ' target='_blank'>here</a>.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Model",
          "type": "option",
          "value": [
            "SZ40",
            "SZ42a",
            "SZ42b"
          ]
        },
        {
          "name": "Wheel Pattern",
          "type": "argSelector",
          "value": [
            {
              "name": "KH Pattern",
              "off": [
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ]
            },
            {
              "name": "ZMUG Pattern",
              "off": [
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ]
            },
            {
              "name": "BREAM Pattern",
              "off": [
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ]
            },
            {
              "name": "No Pattern",
              "off": [
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ]
            },
            {
              "name": "Custom",
              "on": [
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30
              ]
            }
          ]
        },
        {
          "name": "KT-Schalter",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Mode",
          "type": "argSelector",
          "value": [
            {
              "name": "Send",
              "on": [
                4
              ],
              "off": [
                5
              ]
            },
            {
              "name": "Receive",
              "off": [
                4
              ],
              "on": [
                5
              ]
            }
          ]
        },
        {
          "name": "Input Type",
          "type": "option",
          "value": [
            "Plaintext",
            "ITA2"
          ]
        },
        {
          "name": "Output Type",
          "type": "option",
          "value": [
            "Plaintext",
            "ITA2"
          ]
        },
        {
          "name": "ITA2 Format",
          "type": "option",
          "value": [
            "5/8/9",
            "+/-/."
          ]
        },
        {
          "name": "\u03a81 start (1-43)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a82 start (1-47)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a83 start (1-51)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a84 start (1-53)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a85 start (1-59)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u039c37 start (1-37)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u039c61 start (1-61)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a71 start (1-41)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a72 start (1-31)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a73 start (1-29)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a74 start (1-26)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a75 start (1-23)",
          "type": "number",
          "value": 1
        },
        {
          "name": "\u03a81 lugs (43)",
          "type": "string",
          "value": ".x...xx.x.x..xxx.x.x.xxxx.x.x.x.x.x..x.xx.x"
        },
        {
          "name": "\u03a82 lugs (47)",
          "type": "string",
          "value": ".xx.x.xxx..x.x.x..x.xx.x.xxx.x....x.xx.x.x.x..x"
        },
        {
          "name": "\u03a83 lugs (51)",
          "type": "string",
          "value": ".x.x.x..xxx....x.x.xx.x.x.x..xxx.x.x..x.x.xx..x.x.x"
        },
        {
          "name": "\u03a84 lugs (53)",
          "type": "string",
          "value": ".xx...xxxxx.x.x.xx...x.xx.x.x..x.x.xx.x..x.x.x.x.x.x."
        },
        {
          "name": "\u03a85 lugs (59)",
          "type": "string",
          "value": "xx...xx.x..x.xx.x...x.x.x.x.x.x.x.x.xx..xxxx.x.x...xx.x..x."
        },
        {
          "name": "\u039c37 lugs (37)",
          "type": "string",
          "value": "x.x.x.x.x.x...x.x.x...x.x.x...x.x...."
        },
        {
          "name": "\u039c61 lugs (61)",
          "type": "string",
          "value": ".xxxx.xxxx.xxx.xxxx.xx....xxx.xxxx.xxxx.xxxx.xxxx.xxx.xxxx..."
        },
        {
          "name": "\u03a71 lugs (41)",
          "type": "string",
          "value": ".x...xxx.x.xxxx.x...x.x..xxx....xx.xxxx.."
        },
        {
          "name": "\u03a72 lugs (31)",
          "type": "string",
          "value": "x..xxx...x.xxxx..xx..x..xx.xx.."
        },
        {
          "name": "\u03a73 lugs (29)",
          "type": "string",
          "value": "..xx..x.xxx...xx...xx..xx.xx."
        },
        {
          "name": "\u03a74 lugs (26)",
          "type": "string",
          "value": "xx..x..xxxx..xx.xxx....x.."
        },
        {
          "name": "\u03a75 lugs (23)",
          "type": "string",
          "value": "xx..xx....xxxx.x..x.x.."
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Luhn Checksum",
      "module": "Default",
      "description": "The Luhn mod N algorithm using the english alphabet. The Luhn mod N algorithm is an extension to the Luhn algorithm (also known as mod 10 algorithm) that allows it to work with sequences of values in any even-numbered base. This can be useful when a check digit is required to validate an identification string composed of letters, a combination of letters and digits or any arbitrary set of N characters where N is divisible by 2.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Radix",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Magic",
      "module": "Default",
      "description": "The Magic operation attempts to detect various properties of the input data and suggests which operations could help to make more sense of it.<br><br><b>Options</b><br><u>Depth:</u> If an operation appears to match the data, it will be run and the result will be analysed further. This argument controls the maximum number of levels of recursion.<br><br><u>Intensive mode:</u> When this is turned on, various operations like XOR, bit rotates, and character encodings are brute-forced to attempt to detect valid data underneath. To improve performance, only the first 100 bytes of the data is brute-forced.<br><br><u>Extensive language support:</u> At each stage, the relative byte frequencies of the data will be compared to average frequencies for a number of languages. The default set consists of ~40 of the most commonly used languages on the Internet. The extensive list consists of 284 languages and can result in many languages matching the data if their byte frequencies are similar.<br><br>Optionally enter a regular expression to match a string you expect to find to filter results (crib).",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Depth",
          "type": "number",
          "value": 3
        },
        {
          "name": "Intensive mode",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Extensive language support",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Crib (known plaintext string or regex)",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Mean",
      "module": "Default",
      "description": "Computes the mean (average) of a number list. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 .5 .5</code> becomes <code>4.75</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Median",
      "module": "Default",
      "description": "Computes the median of a number list. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 1 .5</code> becomes <code>4.5</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Merge",
      "module": "Default",
      "description": "Consolidate all branches back into a single trunk. The opposite of Fork. Unticking the Merge All checkbox will only consolidate all branches up to the nearest Fork/Subsection.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Merge All",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Microsoft Script Decoder",
      "module": "Default",
      "description": "Decodes Microsoft Encoded Script files that have been encoded with Microsoft's custom encoding. These are often VBS (Visual Basic Script) files that are encoded and renamed with a '.vbe' extention or JS (JScript) files renamed with a '.jse' extention.<br><br><b>Sample</b><br><br>Encoded:<br><code>#@~^RQAAAA==-mD~sX|:/TP{~J:+dYbxL~@!F@*@!+@*@!&amp;@*eEI@#@&amp;@#@&amp;.jm.raY 214Wv:zms/obI0xEAAA==^#~@</code><br><br>Decoded:<br><code>var my_msg = &#34;Testing <1><2><3>!&#34;;\n\nVScript.Echo(my_msg);</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Multiple Bombe",
      "module": "Bletchley",
      "description": "Emulation of the Bombe machine used to attack Enigma. This version carries out multiple Bombe runs to handle unknown rotor configurations.<br><br>You should test your menu on the single Bombe operation before running it here. See the description of the Bombe operation for instructions on choosing a crib.<br><br>More detailed descriptions of the Enigma, Typex and Bombe operations <a href='https://github.com/gchq/CyberChef/wiki/Enigma,-the-Bombe,-and-Typex'>can be found here</a>.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Standard Enigmas",
          "type": "populateMultiOption",
          "value": [
            {
              "name": "German Service Enigma (First - 3 rotor)",
              "value": [
                "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A",
                "",
                "AY BR CU DH EQ FS GL IP JX KN MO TZ VW"
              ]
            },
            {
              "name": "German Service Enigma (Second - 3 rotor)",
              "value": [
                "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A\nJPGVOUMFYQBENHZRDKASXLICTW<AN\nNZJHGRCXMYSWBOUFAIVLPEKQDT<AN\nFKQHTLXOCBJSPDZRAMEWNIUYGV<AN",
                "",
                "AY BR CU DH EQ FS GL IP JX KN MO TZ VW\nAF BV CP DJ EI GO HY KR LZ MX NW TQ SU"
              ]
            },
            {
              "name": "German Service Enigma (Third - 4 rotor)",
              "value": [
                "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A\nJPGVOUMFYQBENHZRDKASXLICTW<AN\nNZJHGRCXMYSWBOUFAIVLPEKQDT<AN\nFKQHTLXOCBJSPDZRAMEWNIUYGV<AN",
                "FSOKANUERHMBTIYCWLQPZXVGJD",
                "AE BN CK DQ FU GY HW IJ LO MP RX SZ TV"
              ]
            },
            {
              "name": "German Service Enigma (Fourth - 4 rotor)",
              "value": [
                "EKMFLGDQVZNTOWYHXUSPAIBRCJ<R\nAJDKSIRUXBLHWTMCQGZNPYFVOE<F\nBDFHJLCPRTXVZNYEIWGAKMUSQO<W\nESOVPZJAYQUIRHXLNFTGKDCMWB<K\nVZBRGITYUPSDNHLXAWMJQOFECK<A\nJPGVOUMFYQBENHZRDKASXLICTW<AN\nNZJHGRCXMYSWBOUFAIVLPEKQDT<AN\nFKQHTLXOCBJSPDZRAMEWNIUYGV<AN",
                "FSOKANUERHMBTIYCWLQPZXVGJD",
                "AE BN CK DQ FU GY HW IJ LO MP RX SZ TV\nAR BD CO EJ FN GT HK IV LM PW QZ SX UY"
              ]
            },
            {
              "name": "User defined",
              "value": [
                "",
                "",
                ""
              ]
            }
          ]
        },
        {
          "name": "Main rotors",
          "type": "text",
          "value": ""
        },
        {
          "name": "4th rotor",
          "type": "text",
          "value": ""
        },
        {
          "name": "Reflectors",
          "type": "text",
          "value": ""
        },
        {
          "name": "Crib",
          "type": "string",
          "value": ""
        },
        {
          "name": "Crib offset",
          "type": "number",
          "value": 0
        },
        {
          "name": "Use checking machine",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Multiply",
      "module": "Default",
      "description": "Multiplies a list of numbers. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 .5</code> becomes <code>40</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "MurmurHash3",
      "module": "Hashing",
      "description": "Generates a MurmurHash v3 for a string input and an optional seed input",
      "inputType": "string",
      "outputType": "number",
      "args": [
        {
          "name": "Seed",
          "type": "number",
          "value": 0
        },
        {
          "name": "Convert to Signed",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Normalise Image",
      "module": "Image",
      "description": "Normalise the image colours.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Normalise Unicode",
      "module": "Encodings",
      "description": "Transform Unicode characters to one of the Normalisation Forms",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Normal Form",
          "type": "option",
          "value": [
            "NFD",
            "NFC",
            "NFKD",
            "NFKC"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Numberwang",
      "module": "Default",
      "description": "Based on the popular gameshow by Mitchell and Webb.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Object Identifier to Hex",
      "module": "PublicKey",
      "description": "Converts an object identifier (OID) into a hexadecimal string.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Offset checker",
      "module": "Default",
      "description": "Compares multiple inputs (separated by the specified delimiter) and highlights matching characters which appear at the same position in all samples.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Optical Character Recognition",
      "module": "OCR",
      "description": "Optical character recognition or optical character reader (OCR) is the mechanical or electronic conversion of images of typed, handwritten or printed text into machine-encoded text.<br><br>Supported image formats: png, jpg, bmp, pbm.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Show confidence",
          "type": "boolean",
          "value": true
        },
        {
          "name": "OCR Engine Mode",
          "type": "option",
          "value": [
            "Tesseract only",
            "LSTM only",
            "Tesseract/LSTM Combined"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Pad lines",
      "module": "Default",
      "description": "Add the specified number of the specified character to the beginning or end of each line",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Position",
          "type": "option",
          "value": [
            "Start",
            "End"
          ]
        },
        {
          "name": "Length",
          "type": "number",
          "value": 5
        },
        {
          "name": "Character",
          "type": "binaryShortString",
          "value": " "
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Parse CSR",
      "module": "PublicKey",
      "description": "Parse Certificate Signing Request (CSR) for an X.509 certificate",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "PEM"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Parse colour code",
      "module": "Default",
      "description": "Converts a colour code in a standard format to other standard formats and displays the colour itself.<br><br><strong>Example inputs</strong><ul><li><code>#d9edf7</code></li><li><code>rgba(217,237,247,1)</code></li><li><code>hsla(200,65%,91%,1)</code></li><li><code>cmyk(0.12, 0.04, 0.00, 0.03)</code></li></ul>",
      "inputType": "string",
      "outputType": "html",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Parse DateTime",
      "module": "Default",
      "description": "Parses a DateTime string in your specified format and displays it in whichever timezone you choose with the following information:<ul><li>Date</li><li>Time</li><li>Period (AM/PM)</li><li>Timezone</li><li>UTC offset</li><li>Daylight Saving Time</li><li>Leap year</li><li>Days in this month</li><li>Day of year</li><li>Week number</li><li>Quarter</li></ul>Run with no input to see format string examples if required.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Built in formats",
          "type": "populateOption",
          "value": [
            {
              "name": "Standard date and time",
              "value": "DD/MM/YYYY HH:mm:ss"
            },
            {
              "name": "American-style date and time",
              "value": "MM/DD/YYYY HH:mm:ss"
            },
            {
              "name": "International date and time",
              "value": "YYYY-MM-DD HH:mm:ss"
            },
            {
              "name": "Verbose date and time",
              "value": "dddd Do MMMM YYYY HH:mm:ss Z z"
            },
            {
              "name": "UNIX timestamp (seconds)",
              "value": "X"
            },
            {
              "name": "UNIX timestamp offset (milliseconds)",
              "value": "x"
            },
            {
              "name": "Automatic",
              "value": ""
            }
          ]
        },
        {
          "name": "Input format string",
          "type": "binaryString",
          "value": "DD/MM/YYYY HH:mm:ss"
        },
        {
          "name": "Input timezone",
          "type": "option",
          "value": [
            "UTC",
            "Africa/Abidjan",
            "Africa/Accra",
            "Africa/Addis_Ababa",
            "Africa/Algiers",
            "Africa/Asmara",
            "Africa/Asmera",
            "Africa/Bamako",
            "Africa/Bangui",
            "Africa/Banjul",
            "Africa/Bissau",
            "Africa/Blantyre",
            "Africa/Brazzaville",
            "Africa/Bujumbura",
            "Africa/Cairo",
            "Africa/Casablanca",
            "Africa/Ceuta",
            "Africa/Conakry",
            "Africa/Dakar",
            "Africa/Dar_es_Salaam",
            "Africa/Djibouti",
            "Africa/Douala",
            "Africa/El_Aaiun",
            "Africa/Freetown",
            "Africa/Gaborone",
            "Africa/Harare",
            "Africa/Johannesburg",
            "Africa/Juba",
            "Africa/Kampala",
            "Africa/Khartoum",
            "Africa/Kigali",
            "Africa/Kinshasa",
            "Africa/Lagos",
            "Africa/Libreville",
            "Africa/Lome",
            "Africa/Luanda",
            "Africa/Lubumbashi",
            "Africa/Lusaka",
            "Africa/Malabo",
            "Africa/Maputo",
            "Africa/Maseru",
            "Africa/Mbabane",
            "Africa/Mogadishu",
            "Africa/Monrovia",
            "Africa/Nairobi",
            "Africa/Ndjamena",
            "Africa/Niamey",
            "Africa/Nouakchott",
            "Africa/Ouagadougou",
            "Africa/Porto-Novo",
            "Africa/Sao_Tome",
            "Africa/Timbuktu",
            "Africa/Tripoli",
            "Africa/Tunis",
            "Africa/Windhoek",
            "America/Adak",
            "America/Anchorage",
            "America/Anguilla",
            "America/Antigua",
            "America/Araguaina",
            "America/Argentina/Buenos_Aires",
            "America/Argentina/Catamarca",
            "America/Argentina/ComodRivadavia",
            "America/Argentina/Cordoba",
            "America/Argentina/Jujuy",
            "America/Argentina/La_Rioja",
            "America/Argentina/Mendoza",
            "America/Argentina/Rio_Gallegos",
            "America/Argentina/Salta",
            "America/Argentina/San_Juan",
            "America/Argentina/San_Luis",
            "America/Argentina/Tucuman",
            "America/Argentina/Ushuaia",
            "America/Aruba",
            "America/Asuncion",
            "America/Atikokan",
            "America/Atka",
            "America/Bahia",
            "America/Bahia_Banderas",
            "America/Barbados",
            "America/Belem",
            "America/Belize",
            "America/Blanc-Sablon",
            "America/Boa_Vista",
            "America/Bogota",
            "America/Boise",
            "America/Buenos_Aires",
            "America/Cambridge_Bay",
            "America/Campo_Grande",
            "America/Cancun",
            "America/Caracas",
            "America/Catamarca",
            "America/Cayenne",
            "America/Cayman",
            "America/Chicago",
            "America/Chihuahua",
            "America/Ciudad_Juarez",
            "America/Coral_Harbour",
            "America/Cordoba",
            "America/Costa_Rica",
            "America/Creston",
            "America/Cuiaba",
            "America/Curacao",
            "America/Danmarkshavn",
            "America/Dawson",
            "America/Dawson_Creek",
            "America/Denver",
            "America/Detroit",
            "America/Dominica",
            "America/Edmonton",
            "America/Eirunepe",
            "America/El_Salvador",
            "America/Ensenada",
            "America/Fort_Nelson",
            "America/Fort_Wayne",
            "America/Fortaleza",
            "America/Glace_Bay",
            "America/Godthab",
            "America/Goose_Bay",
            "America/Grand_Turk",
            "America/Grenada",
            "America/Guadeloupe",
            "America/Guatemala",
            "America/Guayaquil",
            "America/Guyana",
            "America/Halifax",
            "America/Havana",
            "America/Hermosillo",
            "America/Indiana/Indianapolis",
            "America/Indiana/Knox",
            "America/Indiana/Marengo",
            "America/Indiana/Petersburg",
            "America/Indiana/Tell_City",
            "America/Indiana/Vevay",
            "America/Indiana/Vincennes",
            "America/Indiana/Winamac",
            "America/Indianapolis",
            "America/Inuvik",
            "America/Iqaluit",
            "America/Jamaica",
            "America/Jujuy",
            "America/Juneau",
            "America/Kentucky/Louisville",
            "America/Kentucky/Monticello",
            "America/Knox_IN",
            "America/Kralendijk",
            "America/La_Paz",
            "America/Lima",
            "America/Los_Angeles",
            "America/Louisville",
            "America/Lower_Princes",
            "America/Maceio",
            "America/Managua",
            "America/Manaus",
            "America/Marigot",
            "America/Martinique",
            "America/Matamoros",
            "America/Mazatlan",
            "America/Mendoza",
            "America/Menominee",
            "America/Merida",
            "America/Metlakatla",
            "America/Mexico_City",
            "America/Miquelon",
            "America/Moncton",
            "America/Monterrey",
            "America/Montevideo",
            "America/Montreal",
            "America/Montserrat",
            "America/Nassau",
            "America/New_York",
            "America/Nipigon",
            "America/Nome",
            "America/Noronha",
            "America/North_Dakota/Beulah",
            "America/North_Dakota/Center",
            "America/North_Dakota/New_Salem",
            "America/Nuuk",
            "America/Ojinaga",
            "America/Panama",
            "America/Pangnirtung",
            "America/Paramaribo",
            "America/Phoenix",
            "America/Port-au-Prince",
            "America/Port_of_Spain",
            "America/Porto_Acre",
            "America/Porto_Velho",
            "America/Puerto_Rico",
            "America/Punta_Arenas",
            "America/Rainy_River",
            "America/Rankin_Inlet",
            "America/Recife",
            "America/Regina",
            "America/Resolute",
            "America/Rio_Branco",
            "America/Rosario",
            "America/Santa_Isabel",
            "America/Santarem",
            "America/Santiago",
            "America/Santo_Domingo",
            "America/Sao_Paulo",
            "America/Scoresbysund",
            "America/Shiprock",
            "America/Sitka",
            "America/St_Barthelemy",
            "America/St_Johns",
            "America/St_Kitts",
            "America/St_Lucia",
            "America/St_Thomas",
            "America/St_Vincent",
            "America/Swift_Current",
            "America/Tegucigalpa",
            "America/Thule",
            "America/Thunder_Bay",
            "America/Tijuana",
            "America/Toronto",
            "America/Tortola",
            "America/Vancouver",
            "America/Virgin",
            "America/Whitehorse",
            "America/Winnipeg",
            "America/Yakutat",
            "America/Yellowknife",
            "Antarctica/Casey",
            "Antarctica/Davis",
            "Antarctica/DumontDUrville",
            "Antarctica/Macquarie",
            "Antarctica/Mawson",
            "Antarctica/McMurdo",
            "Antarctica/Palmer",
            "Antarctica/Rothera",
            "Antarctica/South_Pole",
            "Antarctica/Syowa",
            "Antarctica/Troll",
            "Antarctica/Vostok",
            "Arctic/Longyearbyen",
            "Asia/Aden",
            "Asia/Almaty",
            "Asia/Amman",
            "Asia/Anadyr",
            "Asia/Aqtau",
            "Asia/Aqtobe",
            "Asia/Ashgabat",
            "Asia/Ashkhabad",
            "Asia/Atyrau",
            "Asia/Baghdad",
            "Asia/Bahrain",
            "Asia/Baku",
            "Asia/Bangkok",
            "Asia/Barnaul",
            "Asia/Beirut",
            "Asia/Bishkek",
            "Asia/Brunei",
            "Asia/Calcutta",
            "Asia/Chita",
            "Asia/Choibalsan",
            "Asia/Chongqing",
            "Asia/Chungking",
            "Asia/Colombo",
            "Asia/Dacca",
            "Asia/Damascus",
            "Asia/Dhaka",
            "Asia/Dili",
            "Asia/Dubai",
            "Asia/Dushanbe",
            "Asia/Famagusta",
            "Asia/Gaza",
            "Asia/Harbin",
            "Asia/Hebron",
            "Asia/Ho_Chi_Minh",
            "Asia/Hong_Kong",
            "Asia/Hovd",
            "Asia/Irkutsk",
            "Asia/Istanbul",
            "Asia/Jakarta",
            "Asia/Jayapura",
            "Asia/Jerusalem",
            "Asia/Kabul",
            "Asia/Kamchatka",
            "Asia/Karachi",
            "Asia/Kashgar",
            "Asia/Kathmandu",
            "Asia/Katmandu",
            "Asia/Khandyga",
            "Asia/Kolkata",
            "Asia/Krasnoyarsk",
            "Asia/Kuala_Lumpur",
            "Asia/Kuching",
            "Asia/Kuwait",
            "Asia/Macao",
            "Asia/Macau",
            "Asia/Magadan",
            "Asia/Makassar",
            "Asia/Manila",
            "Asia/Muscat",
            "Asia/Nicosia",
            "Asia/Novokuznetsk",
            "Asia/Novosibirsk",
            "Asia/Omsk",
            "Asia/Oral",
            "Asia/Phnom_Penh",
            "Asia/Pontianak",
            "Asia/Pyongyang",
            "Asia/Qatar",
            "Asia/Qostanay",
            "Asia/Qyzylorda",
            "Asia/Rangoon",
            "Asia/Riyadh",
            "Asia/Saigon",
            "Asia/Sakhalin",
            "Asia/Samarkand",
            "Asia/Seoul",
            "Asia/Shanghai",
            "Asia/Singapore",
            "Asia/Srednekolymsk",
            "Asia/Taipei",
            "Asia/Tashkent",
            "Asia/Tbilisi",
            "Asia/Tehran",
            "Asia/Tel_Aviv",
            "Asia/Thimbu",
            "Asia/Thimphu",
            "Asia/Tokyo",
            "Asia/Tomsk",
            "Asia/Ujung_Pandang",
            "Asia/Ulaanbaatar",
            "Asia/Ulan_Bator",
            "Asia/Urumqi",
            "Asia/Ust-Nera",
            "Asia/Vientiane",
            "Asia/Vladivostok",
            "Asia/Yakutsk",
            "Asia/Yangon",
            "Asia/Yekaterinburg",
            "Asia/Yerevan",
            "Atlantic/Azores",
            "Atlantic/Bermuda",
            "Atlantic/Canary",
            "Atlantic/Cape_Verde",
            "Atlantic/Faeroe",
            "Atlantic/Faroe",
            "Atlantic/Jan_Mayen",
            "Atlantic/Madeira",
            "Atlantic/Reykjavik",
            "Atlantic/South_Georgia",
            "Atlantic/St_Helena",
            "Atlantic/Stanley",
            "Australia/ACT",
            "Australia/Adelaide",
            "Australia/Brisbane",
            "Australia/Broken_Hill",
            "Australia/Canberra",
            "Australia/Currie",
            "Australia/Darwin",
            "Australia/Eucla",
            "Australia/Hobart",
            "Australia/LHI",
            "Australia/Lindeman",
            "Australia/Lord_Howe",
            "Australia/Melbourne",
            "Australia/NSW",
            "Australia/North",
            "Australia/Perth",
            "Australia/Queensland",
            "Australia/South",
            "Australia/Sydney",
            "Australia/Tasmania",
            "Australia/Victoria",
            "Australia/West",
            "Australia/Yancowinna",
            "Brazil/Acre",
            "Brazil/DeNoronha",
            "Brazil/East",
            "Brazil/West",
            "CET",
            "CST6CDT",
            "Canada/Atlantic",
            "Canada/Central",
            "Canada/Eastern",
            "Canada/Mountain",
            "Canada/Newfoundland",
            "Canada/Pacific",
            "Canada/Saskatchewan",
            "Canada/Yukon",
            "Chile/Continental",
            "Chile/EasterIsland",
            "Cuba",
            "EET",
            "EST",
            "EST5EDT",
            "Egypt",
            "Eire",
            "Etc/GMT",
            "Etc/GMT+0",
            "Etc/GMT+1",
            "Etc/GMT+10",
            "Etc/GMT+11",
            "Etc/GMT+12",
            "Etc/GMT+2",
            "Etc/GMT+3",
            "Etc/GMT+4",
            "Etc/GMT+5",
            "Etc/GMT+6",
            "Etc/GMT+7",
            "Etc/GMT+8",
            "Etc/GMT+9",
            "Etc/GMT-0",
            "Etc/GMT-1",
            "Etc/GMT-10",
            "Etc/GMT-11",
            "Etc/GMT-12",
            "Etc/GMT-13",
            "Etc/GMT-14",
            "Etc/GMT-2",
            "Etc/GMT-3",
            "Etc/GMT-4",
            "Etc/GMT-5",
            "Etc/GMT-6",
            "Etc/GMT-7",
            "Etc/GMT-8",
            "Etc/GMT-9",
            "Etc/GMT0",
            "Etc/Greenwich",
            "Etc/UCT",
            "Etc/UTC",
            "Etc/Universal",
            "Etc/Zulu",
            "Europe/Amsterdam",
            "Europe/Andorra",
            "Europe/Astrakhan",
            "Europe/Athens",
            "Europe/Belfast",
            "Europe/Belgrade",
            "Europe/Berlin",
            "Europe/Bratislava",
            "Europe/Brussels",
            "Europe/Bucharest",
            "Europe/Budapest",
            "Europe/Busingen",
            "Europe/Chisinau",
            "Europe/Copenhagen",
            "Europe/Dublin",
            "Europe/Gibraltar",
            "Europe/Guernsey",
            "Europe/Helsinki",
            "Europe/Isle_of_Man",
            "Europe/Istanbul",
            "Europe/Jersey",
            "Europe/Kaliningrad",
            "Europe/Kiev",
            "Europe/Kirov",
            "Europe/Kyiv",
            "Europe/Lisbon",
            "Europe/Ljubljana",
            "Europe/London",
            "Europe/Luxembourg",
            "Europe/Madrid",
            "Europe/Malta",
            "Europe/Mariehamn",
            "Europe/Minsk",
            "Europe/Monaco",
            "Europe/Moscow",
            "Europe/Nicosia",
            "Europe/Oslo",
            "Europe/Paris",
            "Europe/Podgorica",
            "Europe/Prague",
            "Europe/Riga",
            "Europe/Rome",
            "Europe/Samara",
            "Europe/San_Marino",
            "Europe/Sarajevo",
            "Europe/Saratov",
            "Europe/Simferopol",
            "Europe/Skopje",
            "Europe/Sofia",
            "Europe/Stockholm",
            "Europe/Tallinn",
            "Europe/Tirane",
            "Europe/Tiraspol",
            "Europe/Ulyanovsk",
            "Europe/Uzhgorod",
            "Europe/Vaduz",
            "Europe/Vatican",
            "Europe/Vienna",
            "Europe/Vilnius",
            "Europe/Volgograd",
            "Europe/Warsaw",
            "Europe/Zagreb",
            "Europe/Zaporozhye",
            "Europe/Zurich",
            "GB",
            "GB-Eire",
            "GMT",
            "GMT+0",
            "GMT-0",
            "GMT0",
            "Greenwich",
            "HST",
            "Hongkong",
            "Iceland",
            "Indian/Antananarivo",
            "Indian/Chagos",
            "Indian/Christmas",
            "Indian/Cocos",
            "Indian/Comoro",
            "Indian/Kerguelen",
            "Indian/Mahe",
            "Indian/Maldives",
            "Indian/Mauritius",
            "Indian/Mayotte",
            "Indian/Reunion",
            "Iran",
            "Israel",
            "Jamaica",
            "Japan",
            "Kwajalein",
            "Libya",
            "MET",
            "MST",
            "MST7MDT",
            "Mexico/BajaNorte",
            "Mexico/BajaSur",
            "Mexico/General",
            "NZ",
            "NZ-CHAT",
            "Navajo",
            "PRC",
            "PST8PDT",
            "Pacific/Apia",
            "Pacific/Auckland",
            "Pacific/Bougainville",
            "Pacific/Chatham",
            "Pacific/Chuuk",
            "Pacific/Easter",
            "Pacific/Efate",
            "Pacific/Enderbury",
            "Pacific/Fakaofo",
            "Pacific/Fiji",
            "Pacific/Funafuti",
            "Pacific/Galapagos",
            "Pacific/Gambier",
            "Pacific/Guadalcanal",
            "Pacific/Guam",
            "Pacific/Honolulu",
            "Pacific/Johnston",
            "Pacific/Kanton",
            "Pacific/Kiritimati",
            "Pacific/Kosrae",
            "Pacific/Kwajalein",
            "Pacific/Majuro",
            "Pacific/Marquesas",
            "Pacific/Midway",
            "Pacific/Nauru",
            "Pacific/Niue",
            "Pacific/Norfolk",
            "Pacific/Noumea",
            "Pacific/Pago_Pago",
            "Pacific/Palau",
            "Pacific/Pitcairn",
            "Pacific/Pohnpei",
            "Pacific/Ponape",
            "Pacific/Port_Moresby",
            "Pacific/Rarotonga",
            "Pacific/Saipan",
            "Pacific/Samoa",
            "Pacific/Tahiti",
            "Pacific/Tarawa",
            "Pacific/Tongatapu",
            "Pacific/Truk",
            "Pacific/Wake",
            "Pacific/Wallis",
            "Pacific/Yap",
            "Poland",
            "Portugal",
            "ROC",
            "ROK",
            "Singapore",
            "Turkey",
            "UCT",
            "US/Alaska",
            "US/Aleutian",
            "US/Arizona",
            "US/Central",
            "US/East-Indiana",
            "US/Eastern",
            "US/Hawaii",
            "US/Indiana-Starke",
            "US/Michigan",
            "US/Mountain",
            "US/Pacific",
            "US/Samoa",
            "UTC",
            "Universal",
            "W-SU",
            "WET",
            "Zulu"
          ]
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Parse IP range",
      "module": "Default",
      "description": "Given a CIDR range (e.g. <code>10.0.0.0/24</code>), hyphenated range (e.g. <code>10.0.0.0 - 10.0.1.0</code>), or a list of IPs and/or CIDR ranges (separated by a new line), this operation provides network information and enumerates all IP addresses in the range.<br><br>IPv6 is supported but will not be enumerated.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Include network info",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Enumerate IP addresses",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Allow large queries",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse IPv4 header",
      "module": "Default",
      "description": "Given an IPv4 header, this operations parses and displays each field in an easily readable format.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse IPv6 address",
      "module": "Default",
      "description": "Displays the longhand and shorthand versions of a valid IPv6 address.<br><br>Recognises all reserved ranges and parses encapsulated or tunnelled addresses including Teredo and 6to4.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse ObjectID timestamp",
      "module": "Serialise",
      "description": "Parse timestamp from MongoDB/BSON ObjectID hex string.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Parse QR Code",
      "module": "Image",
      "description": "Reads an image file and attempts to detect and read a Quick Response (QR) code from the image.<br><br><u>Normalise Image</u><br>Attempts to normalise the image before parsing it to improve detection of a QR code.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Normalise image",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Other",
      "is_favorite": false
    },
    {
      "name": "Parse SSH Host Key",
      "module": "Default",
      "description": "Parses a SSH host key and extracts fields from it.<br>The key type can be:<ul><li>ssh-rsa</li><li>ssh-dss</li><li>ecdsa-sha2</li><li>ssh-ed25519</li></ul>The key format can be either Hex or Base64.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Input Format",
          "type": "option",
          "value": [
            "Auto",
            "Base64",
            "Hex"
          ]
        }
      ],
      "category": "Public Key",
      "is_favorite": false
    },
    {
      "name": "Parse TCP",
      "module": "Default",
      "description": "Parses a TCP header and payload (if present).",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse TLS record",
      "module": "Default",
      "description": "Parses one or more TLS records",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse TLV",
      "module": "Default",
      "description": "Converts a Type-Length-Value (TLV) encoded string into a JSON object.  Can optionally include a <code>Key</code> / <code>Type</code> entry. <br><br>Tags: Key-Length-Value, KLV, Length-Value, LV",
      "inputType": "ArrayBuffer",
      "outputType": "JSON",
      "args": [
        {
          "name": "Type/Key size",
          "type": "number",
          "value": 1
        },
        {
          "name": "Length size",
          "type": "number",
          "value": 1
        },
        {
          "name": "Use BER",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Parse UDP",
      "module": "Default",
      "description": "Parses a UDP header and payload (if present).",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse UNIX file permissions",
      "module": "Default",
      "description": "Given a UNIX/Linux file permission string in octal or textual format, this operation explains which permissions are granted to which user groups.<br><br>Input should be in either octal (e.g. <code>755</code>) or textual (e.g. <code>drwxr-xr-x</code>) format.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Parse URI",
      "module": "URL",
      "description": "Pretty prints complicated Uniform Resource Identifier (URI) strings for ease of reading. Particularly useful for Uniform Resource Locators (URLs) with a lot of arguments.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Parse User Agent",
      "module": "UserAgent",
      "description": "Attempts to identify and categorise information contained in a user-agent string.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Play Media",
      "module": "Default",
      "description": "Plays the input as audio or video depending on the type.<br><br>Tags: sound, movie, mp3, mp4, mov, webm, wav, ogg",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Raw",
            "Base64",
            "Hex"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Power Set",
      "module": "Default",
      "description": "Calculates all the subsets of a set.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Item delimiter",
          "type": "binaryString",
          "value": ","
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Protobuf Decode",
      "module": "Protobuf",
      "description": "Decodes any Protobuf encoded data to a JSON representation of the data using the field number as the field key.<br><br>If a .proto schema is defined, the encoded data will be decoded with reference to the schema. Only one message instance will be decoded. <br><br><u>Show Unknown Fields</u><br>When a schema is used, this option shows fields that are present in the input data but not defined in the schema.<br><br><u>Show Types</u><br>Show the type of a field next to its name. For undefined fields, the wiretype and example types are shown instead.",
      "inputType": "ArrayBuffer",
      "outputType": "JSON",
      "args": [
        {
          "name": "Schema (.proto text)",
          "type": "text",
          "value": ""
        },
        {
          "name": "Show Unknown Fields",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Show Types",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Protobuf Encode",
      "module": "Protobuf",
      "description": "Encodes a valid JSON object into a protobuf byte array using the input .proto schema.",
      "inputType": "JSON",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Schema (.proto text)",
          "type": "text",
          "value": ""
        }
      ],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "SM3",
      "module": "Crypto",
      "description": "SM3 is a cryptographic hash function used in the Chinese National Standard. SM3 is mainly used in digital signatures, message authentication codes, and pseudorandom number generators. The message digest algorithm consists, by default, of 64 rounds and length of 256.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Length",
          "type": "number",
          "value": 256
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 64
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Rabbit",
      "module": "Ciphers",
      "description": "Rabbit is a high-speed stream cipher introduced in 2003 and defined in RFC 4503.<br><br>The cipher uses a 128-bit key and an optional 64-bit initialization vector (IV).<br><br>big-endian: based on RFC4503 and RFC3447<br>little-endian: compatible with Crypto++",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Endianness",
          "type": "option",
          "value": [
            "Big",
            "Little"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Rail Fence Cipher Decode",
      "module": "Ciphers",
      "description": "Decodes Strings that were created using the Rail fence Cipher provided a key and an offset",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "number",
          "value": 2
        },
        {
          "name": "Offset",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Rail Fence Cipher Encode",
      "module": "Ciphers",
      "description": "Encodes Strings using the Rail fence Cipher provided a key and an offset",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "number",
          "value": 2
        },
        {
          "name": "Offset",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Randomize Colour Palette",
      "module": "Image",
      "description": "Randomizes each colour in an image's colour palette. This can often reveal text or symbols that were previously a very similar colour to their surroundings, a technique sometimes used in Steganography.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Seed",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Raw Deflate",
      "module": "Compression",
      "description": "Compresses data using the deflate algorithm with no headers.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Compression type",
          "type": "option",
          "value": [
            "Dynamic Huffman Coding",
            "Fixed Huffman Coding",
            "None (Store)"
          ]
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Raw Inflate",
      "module": "Compression",
      "description": "Decompresses data which has been compressed using the deflate algorithm with no headers.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Start index",
          "type": "number",
          "value": 0
        },
        {
          "name": "Initial output buffer size",
          "type": "number",
          "value": 0
        },
        {
          "name": "Buffer expansion type",
          "type": "option",
          "value": [
            "Adaptive",
            "Block"
          ]
        },
        {
          "name": "Resize buffer after decompression",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Verify result",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Regular expression",
      "module": "Regex",
      "description": "Define your own regular expression (regex) to search the input data with, optionally choosing from a list of pre-defined patterns.<br><br>Supports extended regex syntax including the 'dot matches all' flag, named capture groups, full unicode coverage (including <code>\\p{}</code> categories and scripts as well as astral codes) and recursive matching.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Built in regexes",
          "type": "populateOption",
          "value": [
            {
              "name": "User defined",
              "value": ""
            },
            {
              "name": "IPv4 address",
              "value": "(?:(?:\\d|[01]?\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d|\\d)(?:\\/\\d{1,2})?"
            },
            {
              "name": "IPv6 address",
              "value": "((?=.*::)(?!.*::.+::)(::)?([\\dA-Fa-f]{1,4}:(:|\\b)|){5}|([\\dA-Fa-f]{1,4}:){6})((([\\dA-Fa-f]{1,4}((?!\\3)::|:\\b|(?![\\dA-Fa-f])))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})"
            },
            {
              "name": "Email address",
              "value": "(?:[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9](?:[\\u00A0-\\uD7FF\\uE000-\\uFFFF-a-z0-9-]*[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9])?\\.)+[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9](?:[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9-]*[\\u00A0-\\uD7FF\\uE000-\\uFFFFa-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}\\])"
            },
            {
              "name": "URL",
              "value": "([A-Za-z]+://)([-\\w]+(?:\\.\\w[-\\w]*)+)(:\\d+)?(/[^.!,?\"<>\\[\\]{}\\s\\x7F-\\xFF]*(?:[.!,?]+[^.!,?\"<>\\[\\]{}\\s\\x7F-\\xFF]+)*)?"
            },
            {
              "name": "Domain",
              "value": "\\b((?=[a-z0-9-]{1,63}\\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,63}\\b"
            },
            {
              "name": "Windows file path",
              "value": "([A-Za-z]):\\\\((?:[A-Za-z\\d][A-Za-z\\d\\- \\x27_\\(\\)~]{0,61}\\\\?)*[A-Za-z\\d][A-Za-z\\d\\- \\x27_\\(\\)]{0,61})(\\.[A-Za-z\\d]{1,6})?"
            },
            {
              "name": "UNIX file path",
              "value": "(?:/[A-Za-z\\d.][A-Za-z\\d\\-.]{0,61})+"
            },
            {
              "name": "MAC address",
              "value": "[A-Fa-f\\d]{2}(?:[:-][A-Fa-f\\d]{2}){5}"
            },
            {
              "name": "UUID",
              "value": "[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}"
            },
            {
              "name": "Date (yyyy-mm-dd)",
              "value": "((?:19|20)\\d\\d)[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])"
            },
            {
              "name": "Date (dd/mm/yyyy)",
              "value": "(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.]((?:19|20)\\d\\d)"
            },
            {
              "name": "Date (mm/dd/yyyy)",
              "value": "(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.]((?:19|20)\\d\\d)"
            },
            {
              "name": "Strings",
              "value": "[A-Za-z\\d/\\-:.,_$%\\x27\"()<>= !\\[\\]{}@]{4,}"
            }
          ]
        },
        {
          "name": "Regex",
          "type": "text",
          "value": ""
        },
        {
          "name": "Case insensitive",
          "type": "boolean",
          "value": true
        },
        {
          "name": "^ and $ match at newlines",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Dot matches all",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unicode support",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Astral support",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Highlight matches",
            "List matches",
            "List capture groups",
            "List matches with capture groups"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Remove Diacritics",
      "module": "Default",
      "description": "Replaces accented characters with their latin character equivalent. Accented characters are made up of Unicode combining characters, so unicode text formatting such as strikethroughs and underlines will also be removed.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Language",
      "is_favorite": false
    },
    {
      "name": "Remove EXIF",
      "module": "Image",
      "description": "Removes EXIF data from a JPEG image.\n<br><br>\nEXIF data embedded in photos usually contains information about the image file itself as well as the device used to create it.",
      "inputType": "ArrayBuffer",
      "outputType": "byteArray",
      "args": [],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Remove line numbers",
      "module": "Default",
      "description": "Removes line numbers from the output if they can be trivially detected.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Remove null bytes",
      "module": "Default",
      "description": "Removes all null bytes (<code>0x00</code>) from the input.",
      "inputType": "ArrayBuffer",
      "outputType": "byteArray",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Remove whitespace",
      "module": "Default",
      "description": "Optionally removes all spaces, carriage returns, line feeds, tabs and form feeds from the input data.<br><br>This operation also supports the removal of full stops which are sometimes used to represent non-printable bytes in ASCII output.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Spaces",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Carriage returns (\\r)",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Line feeds (\\n)",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Tabs",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Form feeds (\\f)",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Full stops",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Render Image",
      "module": "Image",
      "description": "Displays the input as an image. Supports the following formats:<br><br><ul><li>jpg/jpeg</li><li>png</li><li>gif</li><li>webp</li><li>bmp</li><li>ico</li></ul>",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Raw",
            "Base64",
            "Hex"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Render Markdown",
      "module": "Code",
      "description": "Renders input Markdown as HTML. HTML rendering is disabled to avoid XSS.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Autoconvert URLs to links",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Enable syntax highlighting",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Resize Image",
      "module": "Image",
      "description": "Resizes an image to the specified width and height values.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Width",
          "type": "number",
          "value": 100
        },
        {
          "name": "Height",
          "type": "number",
          "value": 100
        },
        {
          "name": "Unit type",
          "type": "option",
          "value": [
            "Pixels",
            "Percent"
          ]
        },
        {
          "name": "Maintain aspect ratio",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Resizing algorithm",
          "type": "option",
          "value": [
            "Nearest Neighbour",
            "Bilinear",
            "Bicubic",
            "Hermite",
            "Bezier"
          ]
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Reverse",
      "module": "Default",
      "description": "Reverses the input string.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "By",
          "type": "option",
          "value": [
            "Byte",
            "Character",
            "Line"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Rison Decode",
      "module": "Encodings",
      "description": "Rison, a data serialization format optimized for compactness in URIs. Rison is a slight variation of JSON that looks vastly superior after URI encoding. Rison still expresses exactly the same set of data structures as JSON, so data can be translated back and forth without loss or guesswork.",
      "inputType": "string",
      "outputType": "JSON",
      "args": [
        {
          "name": "Decode Option",
          "type": "editableOption",
          "value": [
            "Decode",
            "Decode Object",
            "Decode Array"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Rison Encode",
      "module": "Encodings",
      "description": "Rison, a data serialization format optimized for compactness in URIs. Rison is a slight variation of JSON that looks vastly superior after URI encoding. Rison still expresses exactly the same set of data structures as JSON, so data can be translated back and forth without loss or guesswork.",
      "inputType": "JSON",
      "outputType": "string",
      "args": [
        {
          "name": "Encode Option",
          "type": "option",
          "value": [
            "Encode",
            "Encode Object",
            "Encode Array",
            "Encode URI"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Rotate Image",
      "module": "Image",
      "description": "Rotates an image by the specified number of degrees.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Rotation amount (degrees)",
          "type": "number",
          "value": 90
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Rotate left",
      "module": "Default",
      "description": "Rotates each byte to the left by the number of bits specified, optionally carrying the excess bits over to the next byte. Currently only supports 8-bit values.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Amount",
          "type": "number",
          "value": 1
        },
        {
          "name": "Carry through",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Rotate right",
      "module": "Default",
      "description": "Rotates each byte to the right by the number of bits specified, optionally carrying the excess bits over to the next byte. Currently only supports 8-bit values.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Amount",
          "type": "number",
          "value": 1
        },
        {
          "name": "Carry through",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Salsa20",
      "module": "Ciphers",
      "description": "Salsa20 is a stream cipher designed by Daniel J. Bernstein and submitted to the eSTREAM project; Salsa20/8 and Salsa20/12 are round-reduced variants. It is closely related to the ChaCha stream cipher.<br><br><b>Key:</b> Salsa20 uses a key of 16 or 32 bytes (128 or 256 bits).<br><br><b>Nonce:</b> Salsa20 uses a nonce of 8 bytes (64 bits).<br><br><b>Counter:</b> Salsa uses a counter of 8 bytes (64 bits). The counter starts at zero at the start of the keystream, and is incremented at every 64 bytes.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Nonce",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64",
            "Integer"
          ]
        },
        {
          "name": "Counter",
          "type": "number",
          "value": 0
        },
        {
          "name": "Rounds",
          "type": "option",
          "value": [
            "20",
            "12",
            "8"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Scan for Embedded Files",
      "module": "Default",
      "description": "Scans the data for potential embedded files by looking for magic bytes at all offsets. This operation is prone to false positives.<br><br>WARNING: Files over about 100KB in size will take a VERY long time to process.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Images",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Video",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Audio",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Documents",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Applications",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Archives",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Miscellaneous",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Scatter chart",
      "module": "Charts",
      "description": "Plots two-variable data as single points on a graph.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Record delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Field delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Tab"
          ]
        },
        {
          "name": "Use column headers as labels",
          "type": "boolean",
          "value": true
        },
        {
          "name": "X label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Y label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Colour",
          "type": "string",
          "value": "black"
        },
        {
          "name": "Point radius",
          "type": "number",
          "value": 10
        },
        {
          "name": "Use colour from third column",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Scrypt",
      "module": "Crypto",
      "description": "scrypt is a password-based key derivation function (PBKDF) created by Colin Percival. The algorithm was specifically designed to make it costly to perform large-scale custom hardware attacks by requiring large amounts of memory. In 2016, the scrypt algorithm was published by IETF as RFC 7914.<br><br>Enter the password in the input to generate its hash.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Salt",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "Base64",
            "UTF8",
            "Latin1"
          ]
        },
        {
          "name": "Iterations (N)",
          "type": "number",
          "value": 16384
        },
        {
          "name": "Memory factor (r)",
          "type": "number",
          "value": 8
        },
        {
          "name": "Parallelization factor (p)",
          "type": "number",
          "value": 1
        },
        {
          "name": "Key length",
          "type": "number",
          "value": 64
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Series chart",
      "module": "Charts",
      "description": "A time series graph is a line graph of repeated measurements taken over regular time intervals.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Record delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Field delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Tab"
          ]
        },
        {
          "name": "X label",
          "type": "string",
          "value": ""
        },
        {
          "name": "Point radius",
          "type": "number",
          "value": 1
        },
        {
          "name": "Series colours",
          "type": "string",
          "value": "mediumseagreen, dodgerblue, tomato"
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Set Difference",
      "module": "Default",
      "description": "Calculates the difference, or relative complement, of two sets.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        },
        {
          "name": "Item delimiter",
          "type": "binaryString",
          "value": ","
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Set Intersection",
      "module": "Default",
      "description": "Calculates the intersection of two sets.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        },
        {
          "name": "Item delimiter",
          "type": "binaryString",
          "value": ","
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Set Union",
      "module": "Default",
      "description": "Calculates the union of two sets.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        },
        {
          "name": "Item delimiter",
          "type": "binaryString",
          "value": ","
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Shake",
      "module": "Crypto",
      "description": "Shake is an Extendable Output Function (XOF) of the SHA-3 hash algorithm, part of the Keccak family, allowing for variable output length/size.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Capacity",
          "type": "option",
          "value": [
            "256",
            "128"
          ]
        },
        {
          "name": "Size",
          "type": "number",
          "value": 512
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Sharpen Image",
      "module": "Image",
      "description": "Sharpens an image (Unsharp mask)",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Radius",
          "type": "number",
          "value": 2
        },
        {
          "name": "Amount",
          "type": "number",
          "value": 1
        },
        {
          "name": "Threshold",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Show Base64 offsets",
      "module": "Default",
      "description": "When a string is within a block of data and the whole block is Base64'd, the string itself could be represented in Base64 in three distinct ways depending on its offset within the block.<br><br>This operation shows all possible offsets for a given string so that each possible encoding can be considered.",
      "inputType": "byteArray",
      "outputType": "html",
      "args": [
        {
          "name": "Alphabet",
          "type": "binaryString",
          "value": "A-Za-z0-9+/="
        },
        {
          "name": "Show variable chars and padding",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Raw",
            "Base64"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Show on map",
      "module": "Hashing",
      "description": "Displays co-ordinates on a slippy map.<br><br>Co-ordinates will be converted to decimal degrees before being shown on the map.<br><br>Supported formats:<ul><li>Degrees Minutes Seconds (DMS)</li><li>Degrees Decimal Minutes (DDM)</li><li>Decimal Degrees (DD)</li><li>Geohash</li><li>Military Grid Reference System (MGRS)</li><li>Ordnance Survey National Grid (OSNG)</li><li>Universal Transverse Mercator (UTM)</li></ul><br>This operation will not work offline.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Zoom Level",
          "type": "number",
          "value": 13
        },
        {
          "name": "Input Format",
          "type": "option",
          "value": [
            "Auto",
            "Degrees Minutes Seconds",
            "Degrees Decimal Minutes",
            "Decimal Degrees",
            "Geohash",
            "Military Grid Reference System",
            "Ordnance Survey National Grid",
            "Universal Transverse Mercator"
          ]
        },
        {
          "name": "Input Delimiter",
          "type": "option",
          "value": [
            "Auto",
            "Direction Preceding",
            "Direction Following",
            "\\n",
            "Comma",
            "Semi-colon",
            "Colon"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Shuffle",
      "module": "Default",
      "description": "Randomly reorders input elements.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Sleep",
      "module": "Default",
      "description": "Sleep causes the recipe to wait for a specified number of milliseconds before continuing execution.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Time (ms)",
          "type": "number",
          "value": 1000
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Snefru",
      "module": "Crypto",
      "description": "Snefru is a cryptographic hash function invented by Ralph Merkle in 1990 while working at Xerox PARC. The function supports 128-bit and 256-bit output. It was named after the Egyptian Pharaoh Sneferu, continuing the tradition of the Khufu and Khafre block ciphers.<br><br>The original design of Snefru was shown to be insecure by Eli Biham and Adi Shamir who were able to use differential cryptanalysis to find hash collisions. The design was then modified by increasing the number of iterations of the main pass of the algorithm from two to eight.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Size",
          "type": "number",
          "value": 128
        },
        {
          "name": "Rounds",
          "type": "option",
          "value": [
            "8",
            "4",
            "2"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Sort",
      "module": "Default",
      "description": "Alphabetically sorts strings separated by the specified delimiter.<br><br>The IP address option supports IPv4 only.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        },
        {
          "name": "Reverse",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Order",
          "type": "option",
          "value": [
            "Alphabetical (case sensitive)",
            "Alphabetical (case insensitive)",
            "IP address",
            "Numeric",
            "Numeric (hexadecimal)",
            "Length"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Split",
      "module": "Default",
      "description": "Splits a string into sections around a given delimiter.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Split delimiter",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Comma",
              "value": ","
            },
            {
              "name": "Space",
              "value": " "
            },
            {
              "name": "Line feed",
              "value": "\\n"
            },
            {
              "name": "CRLF",
              "value": "\\r\\n"
            },
            {
              "name": "Semi-colon",
              "value": ";"
            },
            {
              "name": "Colon",
              "value": ":"
            },
            {
              "name": "Nothing (separate chars)",
              "value": ""
            }
          ]
        },
        {
          "name": "Join delimiter",
          "type": "editableOptionShort",
          "value": [
            {
              "name": "Line feed",
              "value": "\\n"
            },
            {
              "name": "CRLF",
              "value": "\\r\\n"
            },
            {
              "name": "Space",
              "value": " "
            },
            {
              "name": "Comma",
              "value": ","
            },
            {
              "name": "Semi-colon",
              "value": ";"
            },
            {
              "name": "Colon",
              "value": ":"
            },
            {
              "name": "Nothing (join chars)",
              "value": ""
            }
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Split Colour Channels",
      "module": "Image",
      "description": "Splits the given image into its red, green and blue colour channels.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Multimedia",
      "is_favorite": false
    },
    {
      "name": "Standard Deviation",
      "module": "Default",
      "description": "Computes the standard deviation of a number list. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 .5</code> becomes <code>4.089281382128433</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Streebog",
      "module": "Hashing",
      "description": "Streebog is a cryptographic hash function defined in the Russian national standard GOST R 34.11-2012 <i>Information Technology \u2013 Cryptographic Information Security \u2013 Hash Function</i>. It was created to replace an obsolete GOST hash function defined in the old standard GOST R 34.11-94, and as an asymmetric reply to SHA-3 competition by the US National Institute of Standards and Technology.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Digest length",
          "type": "option",
          "value": [
            "256",
            "512"
          ]
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Strings",
      "module": "Regex",
      "description": "Extracts all strings from the input.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Encoding",
          "type": "option",
          "value": [
            "Single byte",
            "16-bit littleendian",
            "16-bit bigendian",
            "All"
          ]
        },
        {
          "name": "Minimum length",
          "type": "number",
          "value": 4
        },
        {
          "name": "Match",
          "type": "option",
          "value": [
            "[ASCII]",
            "Alphanumeric + punctuation (A)",
            "All printable chars (A)",
            "Null-terminated strings (A)",
            "[Unicode]",
            "Alphanumeric + punctuation (U)",
            "All printable chars (U)",
            "Null-terminated strings (U)"
          ]
        },
        {
          "name": "Display total",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Sort",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Unique",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Strip HTML tags",
      "module": "Default",
      "description": "Removes all HTML tags from the input.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Remove indentation",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Remove excess line breaks",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Strip HTTP headers",
      "module": "Default",
      "description": "Removes HTTP headers from a request or response by looking for the first instance of a double newline.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Strip IPv4 header",
      "module": "Default",
      "description": "Strips the IPv4 header from an IPv4 packet, outputting the payload.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Strip TCP header",
      "module": "Default",
      "description": "Strips the TCP header from a TCP segment, outputting the payload.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Strip UDP header",
      "module": "Default",
      "description": "Strips the UDP header from a UDP datagram, outputting the payload.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "Subsection",
      "module": "Default",
      "description": "Select a part of the input data using a regular expression (regex), and run all subsequent operations on each match separately.<br><br>You can use up to one capture group, where the recipe will only be run on the data in the capture group. If there's more than one capture group, only the first one will be operated on.<br><br>Use the Merge operation to reset the effects of subsection.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Section (regex)",
          "type": "string",
          "value": ""
        },
        {
          "name": "Case sensitive matching",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Global matching",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Ignore errors",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Flow control",
      "is_favorite": false
    },
    {
      "name": "Substitute",
      "module": "Default",
      "description": "A substitution cipher allowing you to specify bytes to replace with other byte values. This can be used to create Caesar ciphers but is more powerful as any byte value can be substituted, not just letters, and the substitution values need not be in order.<br><br>Enter the bytes you want to replace in the Plaintext field and the bytes to replace them with in the Ciphertext field.<br><br>Non-printable bytes can be specified using string escape notation. For example, a line feed character can be written as either <code>\\n</code> or <code>\\x0a</code>.<br><br>Byte ranges can be specified using a hyphen. For example, the sequence <code>0123456789</code> can be written as <code>0-9</code>.<br><br>Note that blackslash characters are used to escape special characters, so will need to be escaped themselves if you want to use them on their own (e.g.<code>\\\\</code>).",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Plaintext",
          "type": "binaryString",
          "value": "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        },
        {
          "name": "Ciphertext",
          "type": "binaryString",
          "value": "XYZABCDEFGHIJKLMNOPQRSTUVW"
        },
        {
          "name": "Ignore case",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Subtract",
      "module": "Default",
      "description": "Subtracts a list of numbers. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 .5</code> becomes <code>1.5</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Sum",
      "module": "Default",
      "description": "Adds together a list of numbers. If an item in the string is not a number it is excluded from the list.<br><br>e.g. <code>0x0a 8 .5</code> becomes <code>18.5</code>",
      "inputType": "string",
      "outputType": "BigNumber",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "CRLF"
          ]
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Swap case",
      "module": "Default",
      "description": "Converts uppercase letters to lowercase ones, and lowercase ones to uppercase ones.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Swap endianness",
      "module": "Default",
      "description": "Switches the data from big-endian to little-endian or vice-versa. Data can be read in as hexadecimal or raw bytes. It will be returned in the same format as it is entered.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Data format",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Word length (bytes)",
          "type": "number",
          "value": 4
        },
        {
          "name": "Pad incomplete words",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Symmetric Difference",
      "module": "Default",
      "description": "Calculates the symmetric difference of two sets.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Sample delimiter",
          "type": "binaryString",
          "value": "\\n\\n"
        },
        {
          "name": "Item delimiter",
          "type": "binaryString",
          "value": ","
        }
      ],
      "category": "Arithmetic / Logic",
      "is_favorite": false
    },
    {
      "name": "Syntax highlighter",
      "module": "Code",
      "description": "Adds syntax highlighting to a range of source code languages. Note that this will not indent the code. Use one of the 'Beautify' operations for that.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Language",
          "type": "option",
          "value": [
            "auto detect",
            "1c",
            "abnf",
            "accesslog",
            "actionscript",
            "ada",
            "angelscript",
            "apache",
            "applescript",
            "arcade",
            "arduino",
            "armasm",
            "xml",
            "asciidoc",
            "aspectj",
            "autohotkey",
            "autoit",
            "avrasm",
            "awk",
            "axapta",
            "bash",
            "basic",
            "bnf",
            "brainfuck",
            "c",
            "cal",
            "capnproto",
            "ceylon",
            "clean",
            "clojure",
            "clojure-repl",
            "cmake",
            "coffeescript",
            "coq",
            "cos",
            "cpp",
            "crmsh",
            "crystal",
            "csharp",
            "csp",
            "css",
            "d",
            "markdown",
            "dart",
            "delphi",
            "diff",
            "django",
            "dns",
            "dockerfile",
            "dos",
            "dsconfig",
            "dts",
            "dust",
            "ebnf",
            "elixir",
            "elm",
            "ruby",
            "erb",
            "erlang-repl",
            "erlang",
            "excel",
            "fix",
            "flix",
            "fortran",
            "fsharp",
            "gams",
            "gauss",
            "gcode",
            "gherkin",
            "glsl",
            "gml",
            "go",
            "golo",
            "gradle",
            "graphql",
            "groovy",
            "haml",
            "handlebars",
            "haskell",
            "haxe",
            "hsp",
            "http",
            "hy",
            "inform7",
            "ini",
            "irpf90",
            "isbl",
            "java",
            "javascript",
            "jboss-cli",
            "json",
            "julia",
            "julia-repl",
            "kotlin",
            "lasso",
            "latex",
            "ldif",
            "leaf",
            "less",
            "lisp",
            "livecodeserver",
            "livescript",
            "llvm",
            "lsl",
            "lua",
            "makefile",
            "mathematica",
            "matlab",
            "maxima",
            "mel",
            "mercury",
            "mipsasm",
            "mizar",
            "perl",
            "mojolicious",
            "monkey",
            "moonscript",
            "n1ql",
            "nestedtext",
            "nginx",
            "nim",
            "nix",
            "node-repl",
            "nsis",
            "objectivec",
            "ocaml",
            "openscad",
            "oxygene",
            "parser3",
            "pf",
            "pgsql",
            "php",
            "php-template",
            "plaintext",
            "pony",
            "powershell",
            "processing",
            "profile",
            "prolog",
            "properties",
            "protobuf",
            "puppet",
            "purebasic",
            "python",
            "python-repl",
            "q",
            "qml",
            "r",
            "reasonml",
            "rib",
            "roboconf",
            "routeros",
            "rsl",
            "ruleslanguage",
            "rust",
            "sas",
            "scala",
            "scheme",
            "scilab",
            "scss",
            "shell",
            "smali",
            "smalltalk",
            "sml",
            "sqf",
            "sql",
            "stan",
            "stata",
            "step21",
            "stylus",
            "subunit",
            "swift",
            "taggerscript",
            "yaml",
            "tap",
            "tcl",
            "thrift",
            "tp",
            "twig",
            "typescript",
            "vala",
            "vbnet",
            "vbscript",
            "vbscript-html",
            "verilog",
            "vhdl",
            "vim",
            "wasm",
            "wren",
            "x86asm",
            "xl",
            "xquery",
            "zephir"
          ]
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "Tail",
      "module": "Default",
      "description": "Like the UNIX tail utility.<br>Gets the last n lines.<br>Optionally you can select all lines after line n by entering a negative value for n.<br>The delimiter can be changed so that instead of lines, fields (i.e. commas) are selected instead.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        },
        {
          "name": "Number",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Take bytes",
      "module": "Default",
      "description": "Takes a slice of the specified number of bytes from the data. Negative values are allowed.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Start",
          "type": "number",
          "value": 0
        },
        {
          "name": "Length",
          "type": "number",
          "value": 5
        },
        {
          "name": "Apply to each line",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Take nth bytes",
      "module": "Default",
      "description": "Takes every nth byte starting with a given byte.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Take every",
          "type": "number",
          "value": 4
        },
        {
          "name": "Starting at",
          "type": "number",
          "value": 0
        },
        {
          "name": "Apply to each line",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Tar",
      "module": "Compression",
      "description": "Packs the input into a tarball.<br><br>No support for multiple files at this time.",
      "inputType": "ArrayBuffer",
      "outputType": "File",
      "args": [
        {
          "name": "Filename",
          "type": "string",
          "value": "file.txt"
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Template",
      "module": "Handlebars",
      "description": "Render a template with Handlebars/Mustache substituting variables using JSON input. Templates will be rendered to plain-text only, to prevent XSS.",
      "inputType": "JSON",
      "outputType": "string",
      "args": [
        {
          "name": "Template definition (.handlebars)",
          "type": "text",
          "value": ""
        }
      ],
      "category": "Extractors",
      "is_favorite": false
    },
    {
      "name": "Text Encoding Brute Force",
      "module": "Encodings",
      "description": "Enumerates all supported text encodings for the input, allowing you to quickly spot the correct one.\n<br><br>\nSupported charsets are:\n<ul>\n<li>UTF-8 (65001)</li>\n<li>UTF-7 (65000)</li>\n<li>UTF-16LE (1200)</li>\n<li>UTF-16BE (1201)</li>\n<li>UTF-32LE (12000)</li>\n<li>UTF-32BE (12001)</li>\n<li>IBM EBCDIC International (500)</li>\n<li>IBM EBCDIC US-Canada (37)</li>\n<li>IBM EBCDIC Multilingual/ROECE (Latin 2) (870)</li>\n<li>IBM EBCDIC Greek Modern (875)</li>\n<li>IBM EBCDIC French (1010)</li>\n<li>IBM EBCDIC Turkish (Latin 5) (1026)</li>\n<li>IBM EBCDIC Latin 1/Open System (1047)</li>\n<li>IBM EBCDIC Lao (1132/1133/1341)</li>\n<li>IBM EBCDIC US-Canada (037 + Euro symbol) (1140)</li>\n<li>IBM EBCDIC Germany (20273 + Euro symbol) (1141)</li>\n<li>IBM EBCDIC Denmark-Norway (20277 + Euro symbol) (1142)</li>\n<li>IBM EBCDIC Finland-Sweden (20278 + Euro symbol) (1143)</li>\n<li>IBM EBCDIC Italy (20280 + Euro symbol) (1144)</li>\n<li>IBM EBCDIC Latin America-Spain (20284 + Euro symbol) (1145)</li>\n<li>IBM EBCDIC United Kingdom (20285 + Euro symbol) (1146)</li>\n<li>IBM EBCDIC France (20297 + Euro symbol) (1147)</li>\n<li>IBM EBCDIC International (500 + Euro symbol) (1148)</li>\n<li>IBM EBCDIC Icelandic (20871 + Euro symbol) (1149)</li>\n<li>IBM EBCDIC Germany (20273)</li>\n<li>IBM EBCDIC Denmark-Norway (20277)</li>\n<li>IBM EBCDIC Finland-Sweden (20278)</li>\n<li>IBM EBCDIC Italy (20280)</li>\n<li>IBM EBCDIC Latin America-Spain (20284)</li>\n<li>IBM EBCDIC United Kingdom (20285)</li>\n<li>IBM EBCDIC Japanese Katakana Extended (20290)</li>\n<li>IBM EBCDIC France (20297)</li>\n<li>IBM EBCDIC Arabic (20420)</li>\n<li>IBM EBCDIC Greek (20423)</li>\n<li>IBM EBCDIC Hebrew (20424)</li>\n<li>IBM EBCDIC Korean Extended (20833)</li>\n<li>IBM EBCDIC Thai (20838)</li>\n<li>IBM EBCDIC Icelandic (20871)</li>\n<li>IBM EBCDIC Cyrillic Russian (20880)</li>\n<li>IBM EBCDIC Turkish (20905)</li>\n<li>IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) (20924)</li>\n<li>IBM EBCDIC Cyrillic Serbian-Bulgarian (21025)</li>\n<li>OEM United States (437)</li>\n<li>OEM Greek (formerly 437G); Greek (DOS) (737)</li>\n<li>OEM Baltic; Baltic (DOS) (775)</li>\n<li>OEM Russian; Cyrillic + Euro symbol (808)</li>\n<li>OEM Multilingual Latin 1; Western European (DOS) (850)</li>\n<li>OEM Latin 2; Central European (DOS) (852)</li>\n<li>OEM Cyrillic (primarily Russian) (855)</li>\n<li>OEM Turkish; Turkish (DOS) (857)</li>\n<li>OEM Multilingual Latin 1 + Euro symbol (858)</li>\n<li>OEM Portuguese; Portuguese (DOS) (860)</li>\n<li>OEM Icelandic; Icelandic (DOS) (861)</li>\n<li>OEM Hebrew; Hebrew (DOS) (862)</li>\n<li>OEM French Canadian; French Canadian (DOS) (863)</li>\n<li>OEM Arabic; Arabic (864) (864)</li>\n<li>OEM Nordic; Nordic (DOS) (865)</li>\n<li>OEM Russian; Cyrillic (DOS) (866)</li>\n<li>OEM Modern Greek; Greek, Modern (DOS) (869)</li>\n<li>OEM Cyrillic (primarily Russian) + Euro Symbol (872)</li>\n<li>Windows-874 Thai (874)</li>\n<li>Windows-1250 Central European (1250)</li>\n<li>Windows-1251 Cyrillic (1251)</li>\n<li>Windows-1252 Latin (1252)</li>\n<li>Windows-1253 Greek (1253)</li>\n<li>Windows-1254 Turkish (1254)</li>\n<li>Windows-1255 Hebrew (1255)</li>\n<li>Windows-1256 Arabic (1256)</li>\n<li>Windows-1257 Baltic (1257)</li>\n<li>Windows-1258 Vietnam (1258)</li>\n<li>ISO-8859-1 Latin 1 Western European (28591)</li>\n<li>ISO-8859-2 Latin 2 Central European (28592)</li>\n<li>ISO-8859-3 Latin 3 South European (28593)</li>\n<li>ISO-8859-4 Latin 4 North European (28594)</li>\n<li>ISO-8859-5 Latin/Cyrillic (28595)</li>\n<li>ISO-8859-6 Latin/Arabic (28596)</li>\n<li>ISO-8859-7 Latin/Greek (28597)</li>\n<li>ISO-8859-8 Latin/Hebrew (28598)</li>\n<li>ISO 8859-8 Hebrew (ISO-Logical) (38598)</li>\n<li>ISO-8859-9 Latin 5 Turkish (28599)</li>\n<li>ISO-8859-10 Latin 6 Nordic (28600)</li>\n<li>ISO-8859-11 Latin/Thai (28601)</li>\n<li>ISO-8859-13 Latin 7 Baltic Rim (28603)</li>\n<li>ISO-8859-14 Latin 8 Celtic (28604)</li>\n<li>ISO-8859-15 Latin 9 (28605)</li>\n<li>ISO-8859-16 Latin 10 (28606)</li>\n<li>ISO 2022 JIS Japanese with no halfwidth Katakana (50220)</li>\n<li>ISO 2022 JIS Japanese with halfwidth Katakana (50221)</li>\n<li>ISO 2022 Japanese JIS X 0201-1989 (1 byte Kana-SO/SI) (50222)</li>\n<li>ISO 2022 Korean (50225)</li>\n<li>ISO 2022 Simplified Chinese (50227)</li>\n<li>ISO 6937 Non-Spacing Accent (20269)</li>\n<li>EUC Japanese (51932)</li>\n<li>EUC Simplified Chinese (51936)</li>\n<li>EUC Korean (51949)</li>\n<li>ISCII Devanagari (57002)</li>\n<li>ISCII Bengali (57003)</li>\n<li>ISCII Tamil (57004)</li>\n<li>ISCII Telugu (57005)</li>\n<li>ISCII Assamese (57006)</li>\n<li>ISCII Oriya (57007)</li>\n<li>ISCII Kannada (57008)</li>\n<li>ISCII Malayalam (57009)</li>\n<li>ISCII Gujarati (57010)</li>\n<li>ISCII Punjabi (57011)</li>\n<li>Japanese Shift-JIS (932)</li>\n<li>Simplified Chinese GBK (936)</li>\n<li>Korean (949)</li>\n<li>Traditional Chinese Big5 (950)</li>\n<li>US-ASCII (7-bit) (20127)</li>\n<li>Simplified Chinese GB2312 (20936)</li>\n<li>KOI8-R Russian Cyrillic (20866)</li>\n<li>KOI8-U Ukrainian Cyrillic (21866)</li>\n<li>Mazovia (Polish) MS-DOS (620)</li>\n<li>Arabic (ASMO 708) (708)</li>\n<li>Arabic (Transparent ASMO); Arabic (DOS) (720)</li>\n<li>Kamenick\u00fd (Czech) MS-DOS (895)</li>\n<li>Korean (Johab) (1361)</li>\n<li>MAC Roman (10000)</li>\n<li>Japanese (Mac) (10001)</li>\n<li>MAC Traditional Chinese (Big5) (10002)</li>\n<li>Korean (Mac) (10003)</li>\n<li>Arabic (Mac) (10004)</li>\n<li>Hebrew (Mac) (10005)</li>\n<li>Greek (Mac) (10006)</li>\n<li>Cyrillic (Mac) (10007)</li>\n<li>MAC Simplified Chinese (GB 2312) (10008)</li>\n<li>Romanian (Mac) (10010)</li>\n<li>Ukrainian (Mac) (10017)</li>\n<li>Thai (Mac) (10021)</li>\n<li>MAC Latin 2 (Central European) (10029)</li>\n<li>Icelandic (Mac) (10079)</li>\n<li>Turkish (Mac) (10081)</li>\n<li>Croatian (Mac) (10082)</li>\n<li>CNS Taiwan (Chinese Traditional) (20000)</li>\n<li>TCA Taiwan (20001)</li>\n<li>ETEN Taiwan (Chinese Traditional) (20002)</li>\n<li>IBM5550 Taiwan (20003)</li>\n<li>TeleText Taiwan (20004)</li>\n<li>Wang Taiwan (20005)</li>\n<li>Western European IA5 (IRV International Alphabet 5) (20105)</li>\n<li>IA5 German (7-bit) (20106)</li>\n<li>IA5 Swedish (7-bit) (20107)</li>\n<li>IA5 Norwegian (7-bit) (20108)</li>\n<li>T.61 (20261)</li>\n<li>Japanese (JIS 0208-1990 and 0212-1990) (20932)</li>\n<li>Korean Wansung (20949)</li>\n<li>Extended/Ext Alpha Lowercase (21027)</li>\n<li>Europa 3 (29001)</li>\n<li>Atari ST/TT (47451)</li>\n<li>HZ-GB2312 Simplified Chinese (52936)</li>\n<li>Simplified Chinese GB18030 (54936)</li>\n</ul>",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "Encode",
            "Decode"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To BCD",
      "module": "Default",
      "description": "Binary-Coded Decimal (BCD) is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four or eight. Special bit patterns are sometimes used for a sign",
      "inputType": "BigNumber",
      "outputType": "string",
      "args": [
        {
          "name": "Scheme",
          "type": "option",
          "value": [
            "8 4 2 1",
            "7 4 2 1",
            "4 2 2 1",
            "2 4 2 1",
            "8 4 -2 -1",
            "Excess-3",
            "IBM 8 4 2 1"
          ]
        },
        {
          "name": "Packed",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Signed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Output format",
          "type": "option",
          "value": [
            "Nibbles",
            "Bytes",
            "Raw"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base",
      "module": "Default",
      "description": "Converts a decimal number to a given numerical base.",
      "inputType": "BigNumber",
      "outputType": "string",
      "args": [
        {
          "name": "Radix",
          "type": "number",
          "value": 36
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base32",
      "module": "Default",
      "description": "Base32 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. It uses a smaller set of characters than Base64, usually the uppercase alphabet and the numbers 2 to 7.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Standard",
              "value": "A-Z2-7="
            },
            {
              "name": "Hex Extended",
              "value": "0-9A-V="
            }
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base45",
      "module": "Default",
      "description": "Base45 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system. Base45 is optimized for usage with QR codes.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "string",
          "value": "0-9A-Z $%*+\\-./:"
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base58",
      "module": "Default",
      "description": "Base58 (similar to Base64) is a notation for encoding arbitrary byte data. It differs from Base64 by removing easily misread characters (i.e. l, I, 0 and O) to improve human readability.<br><br>This operation encodes data in an ASCII string (with an alphabet of your choosing, presets included).<br><br>e.g. <code>hello world</code> becomes <code>StV1DL6CwTryKyV</code><br><br>Base58 is commonly used in cryptocurrencies (Bitcoin, Ripple, etc).",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Bitcoin",
              "value": "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
            },
            {
              "name": "Ripple",
              "value": "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"
            }
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base62",
      "module": "Default",
      "description": "Base62 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers. The high number base results in shorter strings than with the decimal or hexadecimal system.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "string",
          "value": "0-9A-Za-z"
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base64",
      "module": "Default",
      "description": "Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation encodes raw data into an ASCII Base64 string.<br><br>e.g. <code>hello</code> becomes <code>aGVsbG8=</code>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Standard (RFC 4648): A-Za-z0-9+/=",
              "value": "A-Za-z0-9+/="
            },
            {
              "name": "URL safe (RFC 4648 \u00a75): A-Za-z0-9-_",
              "value": "A-Za-z0-9-_"
            },
            {
              "name": "Filename safe: A-Za-z0-9+-=",
              "value": "A-Za-z0-9+\\-="
            },
            {
              "name": "itoa64: ./0-9A-Za-z=",
              "value": "./0-9A-Za-z="
            },
            {
              "name": "XML: A-Za-z0-9_.",
              "value": "A-Za-z0-9_."
            },
            {
              "name": "y64: A-Za-z0-9._-",
              "value": "A-Za-z0-9._-"
            },
            {
              "name": "z64: 0-9a-zA-Z+/=",
              "value": "0-9a-zA-Z+/="
            },
            {
              "name": "Radix-64 (RFC 4880): 0-9A-Za-z+/=",
              "value": "0-9A-Za-z+/="
            },
            {
              "name": "Uuencoding: [space]-_",
              "value": " -_"
            },
            {
              "name": "Xxencoding: +-0-9A-Za-z",
              "value": "+\\-0-9A-Za-z"
            },
            {
              "name": "BinHex: !-,-0-689@A-NP-VX-Z[`a-fh-mp-r",
              "value": "!-,-0-689@A-NP-VX-Z[`a-fh-mp-r"
            },
            {
              "name": "ROT13: N-ZA-Mn-za-m0-9+/=",
              "value": "N-ZA-Mn-za-m0-9+/="
            },
            {
              "name": "UNIX crypt: ./0-9A-Za-z",
              "value": "./0-9A-Za-z"
            },
            {
              "name": "Atom128: /128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC",
              "value": "/128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC"
            },
            {
              "name": "Megan35: 3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5",
              "value": "3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5"
            },
            {
              "name": "Zong22: ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2",
              "value": "ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2"
            },
            {
              "name": "Hazz15: HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5",
              "value": "HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5"
            }
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base85",
      "module": "Default",
      "description": "Base85 (also called Ascii85) is a notation for encoding arbitrary byte data. It is usually more efficient that Base64.<br><br>This operation encodes data in an ASCII string (with an alphabet of your choosing, presets included).<br><br>e.g. <code>hello world</code> becomes <code>BOu!rD]j7BEbo7</code><br><br>Base85 is commonly used in Adobe's PostScript and PDF file formats.<br><br><strong>Options</strong><br><u>Alphabet</u><ul><li>Standard - The standard alphabet, referred to as Ascii85</li><li>Z85 (ZeroMQ) - A string-safe variant of Base85, which avoids quote marks and backslash characters</li><li>IPv6 - A variant of Base85 suitable for encoding IPv6 addresses (RFC 1924)</li></ul><u>Include delimiter</u><br>Adds a '<~' and '~>' delimiter to the start and end of the data. This is standard for Adobe's implementation of Base85.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Alphabet",
          "type": "editableOption",
          "value": [
            {
              "name": "Standard",
              "value": "!-u"
            },
            {
              "name": "Z85 (ZeroMQ)",
              "value": "0-9a-zA-Z.\\-:+=^!/*?&<>()[]{}@%$#"
            },
            {
              "name": "IPv6",
              "value": "0-9A-Za-z!#$%&()*+\\-;<=>?@^_`{|}~"
            }
          ]
        },
        {
          "name": "Include delimeter",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Base92",
      "module": "Default",
      "description": "Base92 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Binary",
      "module": "Default",
      "description": "Displays the input data as a binary string.<br><br>e.g. <code>Hi</code> becomes <code>01001000 01101001</code>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF",
            "None"
          ]
        },
        {
          "name": "Byte Length",
          "type": "number",
          "value": 8
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Braille",
      "module": "Default",
      "description": "Converts text to six-dot braille symbols.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Camel case",
      "module": "Code",
      "description": "Converts the input string to camel case.\n<br><br>\nCamel case is all lower case except letters after word boundaries which are uppercase.\n<br><br>\ne.g. thisIsCamelCase\n<br><br>\n'Attempt to be context aware' will make the operation attempt to nicely transform variable and function names.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Attempt to be context aware",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "To Case Insensitive Regex",
      "module": "Default",
      "description": "Converts a case-sensitive regex string into a case-insensitive regex string in case the i flag is unavailable to you.<br><br>e.g. <code>Mozilla/[0-9].[0-9] .*</code> becomes <code>[mM][oO][zZ][iI][lL][lL][aA]/[0-9].[0-9] .*</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "To Charcode",
      "module": "Default",
      "description": "Converts text to its unicode character code equivalent.<br><br>e.g. <code>\u0393\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5</code> becomes <code>0393 03b5 03b9 03ac 20 03c3 03bf 03c5</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Base",
          "type": "number",
          "value": 16
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Decimal",
      "module": "Default",
      "description": "Converts the input data to an ordinal integer array.<br><br>e.g. <code>Hello</code> becomes <code>72 101 108 108 111</code>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        },
        {
          "name": "Support signed values",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Float",
      "module": "Default",
      "description": "Convert to IEEE754 Floating Point Numbers",
      "inputType": "byteArray",
      "outputType": "string",
      "args": [
        {
          "name": "Endianness",
          "type": "option",
          "value": [
            "Big Endian",
            "Little Endian"
          ]
        },
        {
          "name": "Size",
          "type": "option",
          "value": [
            "Float (4 bytes)",
            "Double (8 bytes)"
          ]
        },
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To HTML Entity",
      "module": "Encodings",
      "description": "Converts characters to HTML entities<br><br>e.g. <code>&amp;</code> becomes <code>&amp;<span>amp;</span></code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Convert all characters",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Convert to",
          "type": "option",
          "value": [
            "Named entities",
            "Numeric entities",
            "Hex entities"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Hex",
      "module": "Default",
      "description": "Converts the input string to hexadecimal bytes separated by the specified delimiter.<br><br>e.g. The UTF-8 encoded string <code>\u0393\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5</code> becomes <code>ce 93 ce b5 ce b9 ce ac 20 cf 83 ce bf cf 85 0a</code>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Percent",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF",
            "0x",
            "0x with comma",
            "\\x",
            "None"
          ]
        },
        {
          "name": "Bytes per line",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Hex Content",
      "module": "Default",
      "description": "Converts special characters in a string to hexadecimal. This format is used by SNORT for representing hex within ASCII text.<br><br>e.g. <code>foo=bar</code> becomes <code>foo|3d|bar</code>.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Convert",
          "type": "option",
          "value": [
            "Only special chars",
            "Only special chars including spaces",
            "All chars"
          ]
        },
        {
          "name": "Print spaces between bytes",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Hexdump",
      "module": "Default",
      "description": "Creates a hexdump of the input data, displaying both the hexadecimal values of each byte and an ASCII representation alongside.<br><br>The 'UNIX format' argument defines which subset of printable characters are displayed in the preview column.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Width",
          "type": "number",
          "value": 16
        },
        {
          "name": "Upper case hex",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Include final length",
          "type": "boolean",
          "value": false
        },
        {
          "name": "UNIX format",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Kebab case",
      "module": "Code",
      "description": "Converts the input string to kebab case.\n<br><br>\nKebab case is all lower case with dashes as word boundaries.\n<br><br>\ne.g. this-is-kebab-case\n<br><br>\n'Attempt to be context aware' will make the operation attempt to nicely transform variable and function names.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Attempt to be context aware",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "To Lower case",
      "module": "Default",
      "description": "Converts every character in the input to lower case.",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "To MessagePack",
      "module": "Code",
      "description": "Converts JSON to MessagePack encoded byte buffer. MessagePack is a computer data interchange format. It is a binary form for representing simple data structures like arrays and associative arrays.",
      "inputType": "JSON",
      "outputType": "ArrayBuffer",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Modhex",
      "module": "Default",
      "description": "Converts the input string to modhex bytes separated by the specified delimiter.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Percent",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF",
            "None"
          ]
        },
        {
          "name": "Bytes per line",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Morse Code",
      "module": "Default",
      "description": "Translates alphanumeric characters into International Morse Code.<br><br>Ignores non-Morse characters.<br><br>e.g. <code>SOS</code> becomes <code>... --- ...</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Format options",
          "type": "option",
          "value": [
            "-/.",
            "_/.",
            "Dash/Dot",
            "DASH/DOT",
            "dash/dot"
          ]
        },
        {
          "name": "Letter delimiter",
          "type": "option",
          "value": [
            "Space",
            "Line feed",
            "CRLF",
            "Forward slash",
            "Backslash",
            "Comma",
            "Semi-colon",
            "Colon"
          ]
        },
        {
          "name": "Word delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Forward slash",
            "Backslash",
            "Comma",
            "Semi-colon",
            "Colon"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "To Octal",
      "module": "Default",
      "description": "Converts the input string to octal bytes separated by the specified delimiter.<br><br>e.g. The UTF-8 encoded string <code>\u0393\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5</code> becomes <code>316 223 316 265 316 271 316 254 40 317 203 316 277 317 205</code>",
      "inputType": "byteArray",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Line feed",
            "CRLF"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Punycode",
      "module": "Encodings",
      "description": "Punycode is a way to represent Unicode with the limited character subset of ASCII supported by the Domain Name System.<br><br>e.g. <code>m\u00fcnchen</code> encodes to <code>mnchen-3ya</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Internationalised domain name",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Quoted Printable",
      "module": "Default",
      "description": "Quoted-Printable, or QP encoding, is an encoding using printable ASCII characters (alphanumeric and the equals sign '=') to transmit 8-bit data over a 7-bit data path or, generally, over a medium which is not 8-bit clean. It is defined as a MIME content transfer encoding for use in e-mail.<br><br>QP works by using the equals sign '=' as an escape character. It also limits line length to 76, as some software has limits on line length.",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "To Snake case",
      "module": "Code",
      "description": "Converts the input string to snake case.\n<br><br>\nSnake case is all lower case with underscores as word boundaries.\n<br><br>\ne.g. this_is_snake_case\n<br><br>\n'Attempt to be context aware' will make the operation attempt to nicely transform variable and function names.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Attempt to be context aware",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Code tidy",
      "is_favorite": false
    },
    {
      "name": "To Table",
      "module": "Default",
      "description": "Data can be split on different characters and rendered as an HTML, ASCII or Markdown table with an optional header row.<br><br>Supports the CSV (Comma Separated Values) file format by default. Change the cell delimiter argument to <code>\\t</code> to support TSV (Tab Separated Values) or <code>|</code> for PSV (Pipe Separated Values).<br><br>You can enter as many delimiters as you like. Each character will be treat as a separate possible delimiter.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Cell delimiters",
          "type": "binaryShortString",
          "value": ","
        },
        {
          "name": "Row delimiters",
          "type": "binaryShortString",
          "value": "\\r\\n"
        },
        {
          "name": "Make first row header",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Format",
          "type": "option",
          "value": [
            "ASCII",
            "HTML",
            "Markdown"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "To UNIX Timestamp",
      "module": "Default",
      "description": "Parses a datetime string in UTC and returns the corresponding UNIX timestamp.<br><br>e.g. <code>Mon 1 January 2001 11:00:00</code> becomes <code>978346800</code><br><br>A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Units",
          "type": "option",
          "value": [
            "Seconds (s)",
            "Milliseconds (ms)",
            "Microseconds (\u03bcs)",
            "Nanoseconds (ns)"
          ]
        },
        {
          "name": "Treat as UTC",
          "type": "boolean",
          "value": true
        },
        {
          "name": "Show parsed datetime",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "To Upper case",
      "module": "Default",
      "description": "Converts the input string to upper case, optionally limiting scope to only the first character in each word, sentence or paragraph.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Scope",
          "type": "option",
          "value": [
            "All",
            "Word",
            "Sentence",
            "Paragraph"
          ]
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Translate DateTime Format",
      "module": "Default",
      "description": "Parses a datetime string in one format and re-writes it in another.<br><br>Run with no input to see the relevant format string examples.",
      "inputType": "string",
      "outputType": "html",
      "args": [
        {
          "name": "Built in formats",
          "type": "populateOption",
          "value": [
            {
              "name": "Standard date and time",
              "value": "DD/MM/YYYY HH:mm:ss"
            },
            {
              "name": "American-style date and time",
              "value": "MM/DD/YYYY HH:mm:ss"
            },
            {
              "name": "International date and time",
              "value": "YYYY-MM-DD HH:mm:ss"
            },
            {
              "name": "Verbose date and time",
              "value": "dddd Do MMMM YYYY HH:mm:ss Z z"
            },
            {
              "name": "UNIX timestamp (seconds)",
              "value": "X"
            },
            {
              "name": "UNIX timestamp offset (milliseconds)",
              "value": "x"
            },
            {
              "name": "Automatic",
              "value": ""
            }
          ]
        },
        {
          "name": "Input format string",
          "type": "binaryString",
          "value": "DD/MM/YYYY HH:mm:ss"
        },
        {
          "name": "Input timezone",
          "type": "option",
          "value": [
            "UTC",
            "Africa/Abidjan",
            "Africa/Accra",
            "Africa/Addis_Ababa",
            "Africa/Algiers",
            "Africa/Asmara",
            "Africa/Asmera",
            "Africa/Bamako",
            "Africa/Bangui",
            "Africa/Banjul",
            "Africa/Bissau",
            "Africa/Blantyre",
            "Africa/Brazzaville",
            "Africa/Bujumbura",
            "Africa/Cairo",
            "Africa/Casablanca",
            "Africa/Ceuta",
            "Africa/Conakry",
            "Africa/Dakar",
            "Africa/Dar_es_Salaam",
            "Africa/Djibouti",
            "Africa/Douala",
            "Africa/El_Aaiun",
            "Africa/Freetown",
            "Africa/Gaborone",
            "Africa/Harare",
            "Africa/Johannesburg",
            "Africa/Juba",
            "Africa/Kampala",
            "Africa/Khartoum",
            "Africa/Kigali",
            "Africa/Kinshasa",
            "Africa/Lagos",
            "Africa/Libreville",
            "Africa/Lome",
            "Africa/Luanda",
            "Africa/Lubumbashi",
            "Africa/Lusaka",
            "Africa/Malabo",
            "Africa/Maputo",
            "Africa/Maseru",
            "Africa/Mbabane",
            "Africa/Mogadishu",
            "Africa/Monrovia",
            "Africa/Nairobi",
            "Africa/Ndjamena",
            "Africa/Niamey",
            "Africa/Nouakchott",
            "Africa/Ouagadougou",
            "Africa/Porto-Novo",
            "Africa/Sao_Tome",
            "Africa/Timbuktu",
            "Africa/Tripoli",
            "Africa/Tunis",
            "Africa/Windhoek",
            "America/Adak",
            "America/Anchorage",
            "America/Anguilla",
            "America/Antigua",
            "America/Araguaina",
            "America/Argentina/Buenos_Aires",
            "America/Argentina/Catamarca",
            "America/Argentina/ComodRivadavia",
            "America/Argentina/Cordoba",
            "America/Argentina/Jujuy",
            "America/Argentina/La_Rioja",
            "America/Argentina/Mendoza",
            "America/Argentina/Rio_Gallegos",
            "America/Argentina/Salta",
            "America/Argentina/San_Juan",
            "America/Argentina/San_Luis",
            "America/Argentina/Tucuman",
            "America/Argentina/Ushuaia",
            "America/Aruba",
            "America/Asuncion",
            "America/Atikokan",
            "America/Atka",
            "America/Bahia",
            "America/Bahia_Banderas",
            "America/Barbados",
            "America/Belem",
            "America/Belize",
            "America/Blanc-Sablon",
            "America/Boa_Vista",
            "America/Bogota",
            "America/Boise",
            "America/Buenos_Aires",
            "America/Cambridge_Bay",
            "America/Campo_Grande",
            "America/Cancun",
            "America/Caracas",
            "America/Catamarca",
            "America/Cayenne",
            "America/Cayman",
            "America/Chicago",
            "America/Chihuahua",
            "America/Ciudad_Juarez",
            "America/Coral_Harbour",
            "America/Cordoba",
            "America/Costa_Rica",
            "America/Creston",
            "America/Cuiaba",
            "America/Curacao",
            "America/Danmarkshavn",
            "America/Dawson",
            "America/Dawson_Creek",
            "America/Denver",
            "America/Detroit",
            "America/Dominica",
            "America/Edmonton",
            "America/Eirunepe",
            "America/El_Salvador",
            "America/Ensenada",
            "America/Fort_Nelson",
            "America/Fort_Wayne",
            "America/Fortaleza",
            "America/Glace_Bay",
            "America/Godthab",
            "America/Goose_Bay",
            "America/Grand_Turk",
            "America/Grenada",
            "America/Guadeloupe",
            "America/Guatemala",
            "America/Guayaquil",
            "America/Guyana",
            "America/Halifax",
            "America/Havana",
            "America/Hermosillo",
            "America/Indiana/Indianapolis",
            "America/Indiana/Knox",
            "America/Indiana/Marengo",
            "America/Indiana/Petersburg",
            "America/Indiana/Tell_City",
            "America/Indiana/Vevay",
            "America/Indiana/Vincennes",
            "America/Indiana/Winamac",
            "America/Indianapolis",
            "America/Inuvik",
            "America/Iqaluit",
            "America/Jamaica",
            "America/Jujuy",
            "America/Juneau",
            "America/Kentucky/Louisville",
            "America/Kentucky/Monticello",
            "America/Knox_IN",
            "America/Kralendijk",
            "America/La_Paz",
            "America/Lima",
            "America/Los_Angeles",
            "America/Louisville",
            "America/Lower_Princes",
            "America/Maceio",
            "America/Managua",
            "America/Manaus",
            "America/Marigot",
            "America/Martinique",
            "America/Matamoros",
            "America/Mazatlan",
            "America/Mendoza",
            "America/Menominee",
            "America/Merida",
            "America/Metlakatla",
            "America/Mexico_City",
            "America/Miquelon",
            "America/Moncton",
            "America/Monterrey",
            "America/Montevideo",
            "America/Montreal",
            "America/Montserrat",
            "America/Nassau",
            "America/New_York",
            "America/Nipigon",
            "America/Nome",
            "America/Noronha",
            "America/North_Dakota/Beulah",
            "America/North_Dakota/Center",
            "America/North_Dakota/New_Salem",
            "America/Nuuk",
            "America/Ojinaga",
            "America/Panama",
            "America/Pangnirtung",
            "America/Paramaribo",
            "America/Phoenix",
            "America/Port-au-Prince",
            "America/Port_of_Spain",
            "America/Porto_Acre",
            "America/Porto_Velho",
            "America/Puerto_Rico",
            "America/Punta_Arenas",
            "America/Rainy_River",
            "America/Rankin_Inlet",
            "America/Recife",
            "America/Regina",
            "America/Resolute",
            "America/Rio_Branco",
            "America/Rosario",
            "America/Santa_Isabel",
            "America/Santarem",
            "America/Santiago",
            "America/Santo_Domingo",
            "America/Sao_Paulo",
            "America/Scoresbysund",
            "America/Shiprock",
            "America/Sitka",
            "America/St_Barthelemy",
            "America/St_Johns",
            "America/St_Kitts",
            "America/St_Lucia",
            "America/St_Thomas",
            "America/St_Vincent",
            "America/Swift_Current",
            "America/Tegucigalpa",
            "America/Thule",
            "America/Thunder_Bay",
            "America/Tijuana",
            "America/Toronto",
            "America/Tortola",
            "America/Vancouver",
            "America/Virgin",
            "America/Whitehorse",
            "America/Winnipeg",
            "America/Yakutat",
            "America/Yellowknife",
            "Antarctica/Casey",
            "Antarctica/Davis",
            "Antarctica/DumontDUrville",
            "Antarctica/Macquarie",
            "Antarctica/Mawson",
            "Antarctica/McMurdo",
            "Antarctica/Palmer",
            "Antarctica/Rothera",
            "Antarctica/South_Pole",
            "Antarctica/Syowa",
            "Antarctica/Troll",
            "Antarctica/Vostok",
            "Arctic/Longyearbyen",
            "Asia/Aden",
            "Asia/Almaty",
            "Asia/Amman",
            "Asia/Anadyr",
            "Asia/Aqtau",
            "Asia/Aqtobe",
            "Asia/Ashgabat",
            "Asia/Ashkhabad",
            "Asia/Atyrau",
            "Asia/Baghdad",
            "Asia/Bahrain",
            "Asia/Baku",
            "Asia/Bangkok",
            "Asia/Barnaul",
            "Asia/Beirut",
            "Asia/Bishkek",
            "Asia/Brunei",
            "Asia/Calcutta",
            "Asia/Chita",
            "Asia/Choibalsan",
            "Asia/Chongqing",
            "Asia/Chungking",
            "Asia/Colombo",
            "Asia/Dacca",
            "Asia/Damascus",
            "Asia/Dhaka",
            "Asia/Dili",
            "Asia/Dubai",
            "Asia/Dushanbe",
            "Asia/Famagusta",
            "Asia/Gaza",
            "Asia/Harbin",
            "Asia/Hebron",
            "Asia/Ho_Chi_Minh",
            "Asia/Hong_Kong",
            "Asia/Hovd",
            "Asia/Irkutsk",
            "Asia/Istanbul",
            "Asia/Jakarta",
            "Asia/Jayapura",
            "Asia/Jerusalem",
            "Asia/Kabul",
            "Asia/Kamchatka",
            "Asia/Karachi",
            "Asia/Kashgar",
            "Asia/Kathmandu",
            "Asia/Katmandu",
            "Asia/Khandyga",
            "Asia/Kolkata",
            "Asia/Krasnoyarsk",
            "Asia/Kuala_Lumpur",
            "Asia/Kuching",
            "Asia/Kuwait",
            "Asia/Macao",
            "Asia/Macau",
            "Asia/Magadan",
            "Asia/Makassar",
            "Asia/Manila",
            "Asia/Muscat",
            "Asia/Nicosia",
            "Asia/Novokuznetsk",
            "Asia/Novosibirsk",
            "Asia/Omsk",
            "Asia/Oral",
            "Asia/Phnom_Penh",
            "Asia/Pontianak",
            "Asia/Pyongyang",
            "Asia/Qatar",
            "Asia/Qostanay",
            "Asia/Qyzylorda",
            "Asia/Rangoon",
            "Asia/Riyadh",
            "Asia/Saigon",
            "Asia/Sakhalin",
            "Asia/Samarkand",
            "Asia/Seoul",
            "Asia/Shanghai",
            "Asia/Singapore",
            "Asia/Srednekolymsk",
            "Asia/Taipei",
            "Asia/Tashkent",
            "Asia/Tbilisi",
            "Asia/Tehran",
            "Asia/Tel_Aviv",
            "Asia/Thimbu",
            "Asia/Thimphu",
            "Asia/Tokyo",
            "Asia/Tomsk",
            "Asia/Ujung_Pandang",
            "Asia/Ulaanbaatar",
            "Asia/Ulan_Bator",
            "Asia/Urumqi",
            "Asia/Ust-Nera",
            "Asia/Vientiane",
            "Asia/Vladivostok",
            "Asia/Yakutsk",
            "Asia/Yangon",
            "Asia/Yekaterinburg",
            "Asia/Yerevan",
            "Atlantic/Azores",
            "Atlantic/Bermuda",
            "Atlantic/Canary",
            "Atlantic/Cape_Verde",
            "Atlantic/Faeroe",
            "Atlantic/Faroe",
            "Atlantic/Jan_Mayen",
            "Atlantic/Madeira",
            "Atlantic/Reykjavik",
            "Atlantic/South_Georgia",
            "Atlantic/St_Helena",
            "Atlantic/Stanley",
            "Australia/ACT",
            "Australia/Adelaide",
            "Australia/Brisbane",
            "Australia/Broken_Hill",
            "Australia/Canberra",
            "Australia/Currie",
            "Australia/Darwin",
            "Australia/Eucla",
            "Australia/Hobart",
            "Australia/LHI",
            "Australia/Lindeman",
            "Australia/Lord_Howe",
            "Australia/Melbourne",
            "Australia/NSW",
            "Australia/North",
            "Australia/Perth",
            "Australia/Queensland",
            "Australia/South",
            "Australia/Sydney",
            "Australia/Tasmania",
            "Australia/Victoria",
            "Australia/West",
            "Australia/Yancowinna",
            "Brazil/Acre",
            "Brazil/DeNoronha",
            "Brazil/East",
            "Brazil/West",
            "CET",
            "CST6CDT",
            "Canada/Atlantic",
            "Canada/Central",
            "Canada/Eastern",
            "Canada/Mountain",
            "Canada/Newfoundland",
            "Canada/Pacific",
            "Canada/Saskatchewan",
            "Canada/Yukon",
            "Chile/Continental",
            "Chile/EasterIsland",
            "Cuba",
            "EET",
            "EST",
            "EST5EDT",
            "Egypt",
            "Eire",
            "Etc/GMT",
            "Etc/GMT+0",
            "Etc/GMT+1",
            "Etc/GMT+10",
            "Etc/GMT+11",
            "Etc/GMT+12",
            "Etc/GMT+2",
            "Etc/GMT+3",
            "Etc/GMT+4",
            "Etc/GMT+5",
            "Etc/GMT+6",
            "Etc/GMT+7",
            "Etc/GMT+8",
            "Etc/GMT+9",
            "Etc/GMT-0",
            "Etc/GMT-1",
            "Etc/GMT-10",
            "Etc/GMT-11",
            "Etc/GMT-12",
            "Etc/GMT-13",
            "Etc/GMT-14",
            "Etc/GMT-2",
            "Etc/GMT-3",
            "Etc/GMT-4",
            "Etc/GMT-5",
            "Etc/GMT-6",
            "Etc/GMT-7",
            "Etc/GMT-8",
            "Etc/GMT-9",
            "Etc/GMT0",
            "Etc/Greenwich",
            "Etc/UCT",
            "Etc/UTC",
            "Etc/Universal",
            "Etc/Zulu",
            "Europe/Amsterdam",
            "Europe/Andorra",
            "Europe/Astrakhan",
            "Europe/Athens",
            "Europe/Belfast",
            "Europe/Belgrade",
            "Europe/Berlin",
            "Europe/Bratislava",
            "Europe/Brussels",
            "Europe/Bucharest",
            "Europe/Budapest",
            "Europe/Busingen",
            "Europe/Chisinau",
            "Europe/Copenhagen",
            "Europe/Dublin",
            "Europe/Gibraltar",
            "Europe/Guernsey",
            "Europe/Helsinki",
            "Europe/Isle_of_Man",
            "Europe/Istanbul",
            "Europe/Jersey",
            "Europe/Kaliningrad",
            "Europe/Kiev",
            "Europe/Kirov",
            "Europe/Kyiv",
            "Europe/Lisbon",
            "Europe/Ljubljana",
            "Europe/London",
            "Europe/Luxembourg",
            "Europe/Madrid",
            "Europe/Malta",
            "Europe/Mariehamn",
            "Europe/Minsk",
            "Europe/Monaco",
            "Europe/Moscow",
            "Europe/Nicosia",
            "Europe/Oslo",
            "Europe/Paris",
            "Europe/Podgorica",
            "Europe/Prague",
            "Europe/Riga",
            "Europe/Rome",
            "Europe/Samara",
            "Europe/San_Marino",
            "Europe/Sarajevo",
            "Europe/Saratov",
            "Europe/Simferopol",
            "Europe/Skopje",
            "Europe/Sofia",
            "Europe/Stockholm",
            "Europe/Tallinn",
            "Europe/Tirane",
            "Europe/Tiraspol",
            "Europe/Ulyanovsk",
            "Europe/Uzhgorod",
            "Europe/Vaduz",
            "Europe/Vatican",
            "Europe/Vienna",
            "Europe/Vilnius",
            "Europe/Volgograd",
            "Europe/Warsaw",
            "Europe/Zagreb",
            "Europe/Zaporozhye",
            "Europe/Zurich",
            "GB",
            "GB-Eire",
            "GMT",
            "GMT+0",
            "GMT-0",
            "GMT0",
            "Greenwich",
            "HST",
            "Hongkong",
            "Iceland",
            "Indian/Antananarivo",
            "Indian/Chagos",
            "Indian/Christmas",
            "Indian/Cocos",
            "Indian/Comoro",
            "Indian/Kerguelen",
            "Indian/Mahe",
            "Indian/Maldives",
            "Indian/Mauritius",
            "Indian/Mayotte",
            "Indian/Reunion",
            "Iran",
            "Israel",
            "Jamaica",
            "Japan",
            "Kwajalein",
            "Libya",
            "MET",
            "MST",
            "MST7MDT",
            "Mexico/BajaNorte",
            "Mexico/BajaSur",
            "Mexico/General",
            "NZ",
            "NZ-CHAT",
            "Navajo",
            "PRC",
            "PST8PDT",
            "Pacific/Apia",
            "Pacific/Auckland",
            "Pacific/Bougainville",
            "Pacific/Chatham",
            "Pacific/Chuuk",
            "Pacific/Easter",
            "Pacific/Efate",
            "Pacific/Enderbury",
            "Pacific/Fakaofo",
            "Pacific/Fiji",
            "Pacific/Funafuti",
            "Pacific/Galapagos",
            "Pacific/Gambier",
            "Pacific/Guadalcanal",
            "Pacific/Guam",
            "Pacific/Honolulu",
            "Pacific/Johnston",
            "Pacific/Kanton",
            "Pacific/Kiritimati",
            "Pacific/Kosrae",
            "Pacific/Kwajalein",
            "Pacific/Majuro",
            "Pacific/Marquesas",
            "Pacific/Midway",
            "Pacific/Nauru",
            "Pacific/Niue",
            "Pacific/Norfolk",
            "Pacific/Noumea",
            "Pacific/Pago_Pago",
            "Pacific/Palau",
            "Pacific/Pitcairn",
            "Pacific/Pohnpei",
            "Pacific/Ponape",
            "Pacific/Port_Moresby",
            "Pacific/Rarotonga",
            "Pacific/Saipan",
            "Pacific/Samoa",
            "Pacific/Tahiti",
            "Pacific/Tarawa",
            "Pacific/Tongatapu",
            "Pacific/Truk",
            "Pacific/Wake",
            "Pacific/Wallis",
            "Pacific/Yap",
            "Poland",
            "Portugal",
            "ROC",
            "ROK",
            "Singapore",
            "Turkey",
            "UCT",
            "US/Alaska",
            "US/Aleutian",
            "US/Arizona",
            "US/Central",
            "US/East-Indiana",
            "US/Eastern",
            "US/Hawaii",
            "US/Indiana-Starke",
            "US/Michigan",
            "US/Mountain",
            "US/Pacific",
            "US/Samoa",
            "UTC",
            "Universal",
            "W-SU",
            "WET",
            "Zulu"
          ]
        },
        {
          "name": "Output format string",
          "type": "binaryString",
          "value": "dddd Do MMMM YYYY HH:mm:ss Z z"
        },
        {
          "name": "Output timezone",
          "type": "option",
          "value": [
            "UTC",
            "Africa/Abidjan",
            "Africa/Accra",
            "Africa/Addis_Ababa",
            "Africa/Algiers",
            "Africa/Asmara",
            "Africa/Asmera",
            "Africa/Bamako",
            "Africa/Bangui",
            "Africa/Banjul",
            "Africa/Bissau",
            "Africa/Blantyre",
            "Africa/Brazzaville",
            "Africa/Bujumbura",
            "Africa/Cairo",
            "Africa/Casablanca",
            "Africa/Ceuta",
            "Africa/Conakry",
            "Africa/Dakar",
            "Africa/Dar_es_Salaam",
            "Africa/Djibouti",
            "Africa/Douala",
            "Africa/El_Aaiun",
            "Africa/Freetown",
            "Africa/Gaborone",
            "Africa/Harare",
            "Africa/Johannesburg",
            "Africa/Juba",
            "Africa/Kampala",
            "Africa/Khartoum",
            "Africa/Kigali",
            "Africa/Kinshasa",
            "Africa/Lagos",
            "Africa/Libreville",
            "Africa/Lome",
            "Africa/Luanda",
            "Africa/Lubumbashi",
            "Africa/Lusaka",
            "Africa/Malabo",
            "Africa/Maputo",
            "Africa/Maseru",
            "Africa/Mbabane",
            "Africa/Mogadishu",
            "Africa/Monrovia",
            "Africa/Nairobi",
            "Africa/Ndjamena",
            "Africa/Niamey",
            "Africa/Nouakchott",
            "Africa/Ouagadougou",
            "Africa/Porto-Novo",
            "Africa/Sao_Tome",
            "Africa/Timbuktu",
            "Africa/Tripoli",
            "Africa/Tunis",
            "Africa/Windhoek",
            "America/Adak",
            "America/Anchorage",
            "America/Anguilla",
            "America/Antigua",
            "America/Araguaina",
            "America/Argentina/Buenos_Aires",
            "America/Argentina/Catamarca",
            "America/Argentina/ComodRivadavia",
            "America/Argentina/Cordoba",
            "America/Argentina/Jujuy",
            "America/Argentina/La_Rioja",
            "America/Argentina/Mendoza",
            "America/Argentina/Rio_Gallegos",
            "America/Argentina/Salta",
            "America/Argentina/San_Juan",
            "America/Argentina/San_Luis",
            "America/Argentina/Tucuman",
            "America/Argentina/Ushuaia",
            "America/Aruba",
            "America/Asuncion",
            "America/Atikokan",
            "America/Atka",
            "America/Bahia",
            "America/Bahia_Banderas",
            "America/Barbados",
            "America/Belem",
            "America/Belize",
            "America/Blanc-Sablon",
            "America/Boa_Vista",
            "America/Bogota",
            "America/Boise",
            "America/Buenos_Aires",
            "America/Cambridge_Bay",
            "America/Campo_Grande",
            "America/Cancun",
            "America/Caracas",
            "America/Catamarca",
            "America/Cayenne",
            "America/Cayman",
            "America/Chicago",
            "America/Chihuahua",
            "America/Ciudad_Juarez",
            "America/Coral_Harbour",
            "America/Cordoba",
            "America/Costa_Rica",
            "America/Creston",
            "America/Cuiaba",
            "America/Curacao",
            "America/Danmarkshavn",
            "America/Dawson",
            "America/Dawson_Creek",
            "America/Denver",
            "America/Detroit",
            "America/Dominica",
            "America/Edmonton",
            "America/Eirunepe",
            "America/El_Salvador",
            "America/Ensenada",
            "America/Fort_Nelson",
            "America/Fort_Wayne",
            "America/Fortaleza",
            "America/Glace_Bay",
            "America/Godthab",
            "America/Goose_Bay",
            "America/Grand_Turk",
            "America/Grenada",
            "America/Guadeloupe",
            "America/Guatemala",
            "America/Guayaquil",
            "America/Guyana",
            "America/Halifax",
            "America/Havana",
            "America/Hermosillo",
            "America/Indiana/Indianapolis",
            "America/Indiana/Knox",
            "America/Indiana/Marengo",
            "America/Indiana/Petersburg",
            "America/Indiana/Tell_City",
            "America/Indiana/Vevay",
            "America/Indiana/Vincennes",
            "America/Indiana/Winamac",
            "America/Indianapolis",
            "America/Inuvik",
            "America/Iqaluit",
            "America/Jamaica",
            "America/Jujuy",
            "America/Juneau",
            "America/Kentucky/Louisville",
            "America/Kentucky/Monticello",
            "America/Knox_IN",
            "America/Kralendijk",
            "America/La_Paz",
            "America/Lima",
            "America/Los_Angeles",
            "America/Louisville",
            "America/Lower_Princes",
            "America/Maceio",
            "America/Managua",
            "America/Manaus",
            "America/Marigot",
            "America/Martinique",
            "America/Matamoros",
            "America/Mazatlan",
            "America/Mendoza",
            "America/Menominee",
            "America/Merida",
            "America/Metlakatla",
            "America/Mexico_City",
            "America/Miquelon",
            "America/Moncton",
            "America/Monterrey",
            "America/Montevideo",
            "America/Montreal",
            "America/Montserrat",
            "America/Nassau",
            "America/New_York",
            "America/Nipigon",
            "America/Nome",
            "America/Noronha",
            "America/North_Dakota/Beulah",
            "America/North_Dakota/Center",
            "America/North_Dakota/New_Salem",
            "America/Nuuk",
            "America/Ojinaga",
            "America/Panama",
            "America/Pangnirtung",
            "America/Paramaribo",
            "America/Phoenix",
            "America/Port-au-Prince",
            "America/Port_of_Spain",
            "America/Porto_Acre",
            "America/Porto_Velho",
            "America/Puerto_Rico",
            "America/Punta_Arenas",
            "America/Rainy_River",
            "America/Rankin_Inlet",
            "America/Recife",
            "America/Regina",
            "America/Resolute",
            "America/Rio_Branco",
            "America/Rosario",
            "America/Santa_Isabel",
            "America/Santarem",
            "America/Santiago",
            "America/Santo_Domingo",
            "America/Sao_Paulo",
            "America/Scoresbysund",
            "America/Shiprock",
            "America/Sitka",
            "America/St_Barthelemy",
            "America/St_Johns",
            "America/St_Kitts",
            "America/St_Lucia",
            "America/St_Thomas",
            "America/St_Vincent",
            "America/Swift_Current",
            "America/Tegucigalpa",
            "America/Thule",
            "America/Thunder_Bay",
            "America/Tijuana",
            "America/Toronto",
            "America/Tortola",
            "America/Vancouver",
            "America/Virgin",
            "America/Whitehorse",
            "America/Winnipeg",
            "America/Yakutat",
            "America/Yellowknife",
            "Antarctica/Casey",
            "Antarctica/Davis",
            "Antarctica/DumontDUrville",
            "Antarctica/Macquarie",
            "Antarctica/Mawson",
            "Antarctica/McMurdo",
            "Antarctica/Palmer",
            "Antarctica/Rothera",
            "Antarctica/South_Pole",
            "Antarctica/Syowa",
            "Antarctica/Troll",
            "Antarctica/Vostok",
            "Arctic/Longyearbyen",
            "Asia/Aden",
            "Asia/Almaty",
            "Asia/Amman",
            "Asia/Anadyr",
            "Asia/Aqtau",
            "Asia/Aqtobe",
            "Asia/Ashgabat",
            "Asia/Ashkhabad",
            "Asia/Atyrau",
            "Asia/Baghdad",
            "Asia/Bahrain",
            "Asia/Baku",
            "Asia/Bangkok",
            "Asia/Barnaul",
            "Asia/Beirut",
            "Asia/Bishkek",
            "Asia/Brunei",
            "Asia/Calcutta",
            "Asia/Chita",
            "Asia/Choibalsan",
            "Asia/Chongqing",
            "Asia/Chungking",
            "Asia/Colombo",
            "Asia/Dacca",
            "Asia/Damascus",
            "Asia/Dhaka",
            "Asia/Dili",
            "Asia/Dubai",
            "Asia/Dushanbe",
            "Asia/Famagusta",
            "Asia/Gaza",
            "Asia/Harbin",
            "Asia/Hebron",
            "Asia/Ho_Chi_Minh",
            "Asia/Hong_Kong",
            "Asia/Hovd",
            "Asia/Irkutsk",
            "Asia/Istanbul",
            "Asia/Jakarta",
            "Asia/Jayapura",
            "Asia/Jerusalem",
            "Asia/Kabul",
            "Asia/Kamchatka",
            "Asia/Karachi",
            "Asia/Kashgar",
            "Asia/Kathmandu",
            "Asia/Katmandu",
            "Asia/Khandyga",
            "Asia/Kolkata",
            "Asia/Krasnoyarsk",
            "Asia/Kuala_Lumpur",
            "Asia/Kuching",
            "Asia/Kuwait",
            "Asia/Macao",
            "Asia/Macau",
            "Asia/Magadan",
            "Asia/Makassar",
            "Asia/Manila",
            "Asia/Muscat",
            "Asia/Nicosia",
            "Asia/Novokuznetsk",
            "Asia/Novosibirsk",
            "Asia/Omsk",
            "Asia/Oral",
            "Asia/Phnom_Penh",
            "Asia/Pontianak",
            "Asia/Pyongyang",
            "Asia/Qatar",
            "Asia/Qostanay",
            "Asia/Qyzylorda",
            "Asia/Rangoon",
            "Asia/Riyadh",
            "Asia/Saigon",
            "Asia/Sakhalin",
            "Asia/Samarkand",
            "Asia/Seoul",
            "Asia/Shanghai",
            "Asia/Singapore",
            "Asia/Srednekolymsk",
            "Asia/Taipei",
            "Asia/Tashkent",
            "Asia/Tbilisi",
            "Asia/Tehran",
            "Asia/Tel_Aviv",
            "Asia/Thimbu",
            "Asia/Thimphu",
            "Asia/Tokyo",
            "Asia/Tomsk",
            "Asia/Ujung_Pandang",
            "Asia/Ulaanbaatar",
            "Asia/Ulan_Bator",
            "Asia/Urumqi",
            "Asia/Ust-Nera",
            "Asia/Vientiane",
            "Asia/Vladivostok",
            "Asia/Yakutsk",
            "Asia/Yangon",
            "Asia/Yekaterinburg",
            "Asia/Yerevan",
            "Atlantic/Azores",
            "Atlantic/Bermuda",
            "Atlantic/Canary",
            "Atlantic/Cape_Verde",
            "Atlantic/Faeroe",
            "Atlantic/Faroe",
            "Atlantic/Jan_Mayen",
            "Atlantic/Madeira",
            "Atlantic/Reykjavik",
            "Atlantic/South_Georgia",
            "Atlantic/St_Helena",
            "Atlantic/Stanley",
            "Australia/ACT",
            "Australia/Adelaide",
            "Australia/Brisbane",
            "Australia/Broken_Hill",
            "Australia/Canberra",
            "Australia/Currie",
            "Australia/Darwin",
            "Australia/Eucla",
            "Australia/Hobart",
            "Australia/LHI",
            "Australia/Lindeman",
            "Australia/Lord_Howe",
            "Australia/Melbourne",
            "Australia/NSW",
            "Australia/North",
            "Australia/Perth",
            "Australia/Queensland",
            "Australia/South",
            "Australia/Sydney",
            "Australia/Tasmania",
            "Australia/Victoria",
            "Australia/West",
            "Australia/Yancowinna",
            "Brazil/Acre",
            "Brazil/DeNoronha",
            "Brazil/East",
            "Brazil/West",
            "CET",
            "CST6CDT",
            "Canada/Atlantic",
            "Canada/Central",
            "Canada/Eastern",
            "Canada/Mountain",
            "Canada/Newfoundland",
            "Canada/Pacific",
            "Canada/Saskatchewan",
            "Canada/Yukon",
            "Chile/Continental",
            "Chile/EasterIsland",
            "Cuba",
            "EET",
            "EST",
            "EST5EDT",
            "Egypt",
            "Eire",
            "Etc/GMT",
            "Etc/GMT+0",
            "Etc/GMT+1",
            "Etc/GMT+10",
            "Etc/GMT+11",
            "Etc/GMT+12",
            "Etc/GMT+2",
            "Etc/GMT+3",
            "Etc/GMT+4",
            "Etc/GMT+5",
            "Etc/GMT+6",
            "Etc/GMT+7",
            "Etc/GMT+8",
            "Etc/GMT+9",
            "Etc/GMT-0",
            "Etc/GMT-1",
            "Etc/GMT-10",
            "Etc/GMT-11",
            "Etc/GMT-12",
            "Etc/GMT-13",
            "Etc/GMT-14",
            "Etc/GMT-2",
            "Etc/GMT-3",
            "Etc/GMT-4",
            "Etc/GMT-5",
            "Etc/GMT-6",
            "Etc/GMT-7",
            "Etc/GMT-8",
            "Etc/GMT-9",
            "Etc/GMT0",
            "Etc/Greenwich",
            "Etc/UCT",
            "Etc/UTC",
            "Etc/Universal",
            "Etc/Zulu",
            "Europe/Amsterdam",
            "Europe/Andorra",
            "Europe/Astrakhan",
            "Europe/Athens",
            "Europe/Belfast",
            "Europe/Belgrade",
            "Europe/Berlin",
            "Europe/Bratislava",
            "Europe/Brussels",
            "Europe/Bucharest",
            "Europe/Budapest",
            "Europe/Busingen",
            "Europe/Chisinau",
            "Europe/Copenhagen",
            "Europe/Dublin",
            "Europe/Gibraltar",
            "Europe/Guernsey",
            "Europe/Helsinki",
            "Europe/Isle_of_Man",
            "Europe/Istanbul",
            "Europe/Jersey",
            "Europe/Kaliningrad",
            "Europe/Kiev",
            "Europe/Kirov",
            "Europe/Kyiv",
            "Europe/Lisbon",
            "Europe/Ljubljana",
            "Europe/London",
            "Europe/Luxembourg",
            "Europe/Madrid",
            "Europe/Malta",
            "Europe/Mariehamn",
            "Europe/Minsk",
            "Europe/Monaco",
            "Europe/Moscow",
            "Europe/Nicosia",
            "Europe/Oslo",
            "Europe/Paris",
            "Europe/Podgorica",
            "Europe/Prague",
            "Europe/Riga",
            "Europe/Rome",
            "Europe/Samara",
            "Europe/San_Marino",
            "Europe/Sarajevo",
            "Europe/Saratov",
            "Europe/Simferopol",
            "Europe/Skopje",
            "Europe/Sofia",
            "Europe/Stockholm",
            "Europe/Tallinn",
            "Europe/Tirane",
            "Europe/Tiraspol",
            "Europe/Ulyanovsk",
            "Europe/Uzhgorod",
            "Europe/Vaduz",
            "Europe/Vatican",
            "Europe/Vienna",
            "Europe/Vilnius",
            "Europe/Volgograd",
            "Europe/Warsaw",
            "Europe/Zagreb",
            "Europe/Zaporozhye",
            "Europe/Zurich",
            "GB",
            "GB-Eire",
            "GMT",
            "GMT+0",
            "GMT-0",
            "GMT0",
            "Greenwich",
            "HST",
            "Hongkong",
            "Iceland",
            "Indian/Antananarivo",
            "Indian/Chagos",
            "Indian/Christmas",
            "Indian/Cocos",
            "Indian/Comoro",
            "Indian/Kerguelen",
            "Indian/Mahe",
            "Indian/Maldives",
            "Indian/Mauritius",
            "Indian/Mayotte",
            "Indian/Reunion",
            "Iran",
            "Israel",
            "Jamaica",
            "Japan",
            "Kwajalein",
            "Libya",
            "MET",
            "MST",
            "MST7MDT",
            "Mexico/BajaNorte",
            "Mexico/BajaSur",
            "Mexico/General",
            "NZ",
            "NZ-CHAT",
            "Navajo",
            "PRC",
            "PST8PDT",
            "Pacific/Apia",
            "Pacific/Auckland",
            "Pacific/Bougainville",
            "Pacific/Chatham",
            "Pacific/Chuuk",
            "Pacific/Easter",
            "Pacific/Efate",
            "Pacific/Enderbury",
            "Pacific/Fakaofo",
            "Pacific/Fiji",
            "Pacific/Funafuti",
            "Pacific/Galapagos",
            "Pacific/Gambier",
            "Pacific/Guadalcanal",
            "Pacific/Guam",
            "Pacific/Honolulu",
            "Pacific/Johnston",
            "Pacific/Kanton",
            "Pacific/Kiritimati",
            "Pacific/Kosrae",
            "Pacific/Kwajalein",
            "Pacific/Majuro",
            "Pacific/Marquesas",
            "Pacific/Midway",
            "Pacific/Nauru",
            "Pacific/Niue",
            "Pacific/Norfolk",
            "Pacific/Noumea",
            "Pacific/Pago_Pago",
            "Pacific/Palau",
            "Pacific/Pitcairn",
            "Pacific/Pohnpei",
            "Pacific/Ponape",
            "Pacific/Port_Moresby",
            "Pacific/Rarotonga",
            "Pacific/Saipan",
            "Pacific/Samoa",
            "Pacific/Tahiti",
            "Pacific/Tarawa",
            "Pacific/Tongatapu",
            "Pacific/Truk",
            "Pacific/Wake",
            "Pacific/Wallis",
            "Pacific/Yap",
            "Poland",
            "Portugal",
            "ROC",
            "ROK",
            "Singapore",
            "Turkey",
            "UCT",
            "US/Alaska",
            "US/Aleutian",
            "US/Arizona",
            "US/Central",
            "US/East-Indiana",
            "US/Eastern",
            "US/Hawaii",
            "US/Indiana-Starke",
            "US/Michigan",
            "US/Mountain",
            "US/Pacific",
            "US/Samoa",
            "UTC",
            "Universal",
            "W-SU",
            "WET",
            "Zulu"
          ]
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Triple DES Decrypt",
      "module": "Ciphers",
      "description": "Triple DES applies DES three times to each block to increase key size.<br><br><b>Key:</b> Triple DES uses a key length of 24 bytes (192 bits).<br><br><b>IV:</b> The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used as a default.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB",
            "CBC/NoPadding",
            "ECB/NoPadding"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Triple DES Encrypt",
      "module": "Ciphers",
      "description": "Triple DES applies DES three times to each block to increase key size.<br><br><b>Key:</b> Triple DES uses a key length of 24 bytes (192 bits).<br><br>You can generate a password-based key using one of the KDF operations.<br><br><b>IV:</b> The Initialization Vector should be 8 bytes long. If not entered, it will default to 8 null bytes.<br><br><b>Padding:</b> In CBC and ECB mode, PKCS#7 padding will be used.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "IV",
          "type": "toggleString",
          "value": "",
          "toggleValues": [
            "Hex",
            "UTF8",
            "Latin1",
            "Base64"
          ]
        },
        {
          "name": "Mode",
          "type": "option",
          "value": [
            "CBC",
            "CFB",
            "OFB",
            "CTR",
            "ECB"
          ]
        },
        {
          "name": "Input",
          "type": "option",
          "value": [
            "Raw",
            "Hex"
          ]
        },
        {
          "name": "Output",
          "type": "option",
          "value": [
            "Hex",
            "Raw"
          ]
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Typex",
      "module": "Bletchley",
      "description": "Encipher/decipher with the WW2 Typex machine.<br><br>Typex was originally built by the British Royal Air Force prior to WW2, and is based on the Enigma machine with some improvements made, including using five rotors with more stepping points and interchangeable wiring cores. It was used across the British and Commonwealth militaries. A number of later variants were produced; here we simulate a WW2 era Mark 22 Typex with plugboards for the reflector and input. Typex rotors were changed regularly and none are public: a random example set are provided.<br><br>To configure the reflector plugboard, enter a string of connected pairs of letters in the reflector box, e.g. <code>AB CD EF</code> connects A to B, C to D, and E to F (you'll need to connect every letter). There is also an input plugboard: unlike Enigma's plugboard, it's not restricted to pairs, so it's entered like a rotor (without stepping). To create your own rotor, enter the letters that the rotor maps A to Z to, in order, optionally followed by <code>&lt;</code> then a list of stepping points.<br><br>More detailed descriptions of the Enigma, Typex and Bombe operations <a href='https://github.com/gchq/CyberChef/wiki/Enigma,-the-Bombe,-and-Typex'>can be found here</a>.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "1st (left-hand) rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "MCYLPQUVRXGSAOWNBJEZDTFKHI<BFHNQUW"
            },
            {
              "name": "Example 2",
              "value": "KHWENRCBISXJQGOFMAPVYZDLTU<BFHNQUW"
            },
            {
              "name": "Example 3",
              "value": "BYPDZMGIKQCUSATREHOJNLFWXV<BFHNQUW"
            },
            {
              "name": "Example 4",
              "value": "ZANJCGDLVHIXOBRPMSWQUKFYET<BFHNQUW"
            },
            {
              "name": "Example 5",
              "value": "QXBGUTOVFCZPJIHSWERYNDAMLK<BFHNQUW"
            },
            {
              "name": "Example 6",
              "value": "BDCNWUEIQVFTSXALOGZJYMHKPR<BFHNQUW"
            },
            {
              "name": "Example 7",
              "value": "WJUKEIABMSGFTQZVCNPHORDXYL<BFHNQUW"
            },
            {
              "name": "Example 8",
              "value": "TNVCZXDIPFWQKHSJMAOYLEURGB<BFHNQUW"
            }
          ]
        },
        {
          "name": "1st rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "1st rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "1st rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "2nd rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "MCYLPQUVRXGSAOWNBJEZDTFKHI<BFHNQUW"
            },
            {
              "name": "Example 2",
              "value": "KHWENRCBISXJQGOFMAPVYZDLTU<BFHNQUW"
            },
            {
              "name": "Example 3",
              "value": "BYPDZMGIKQCUSATREHOJNLFWXV<BFHNQUW"
            },
            {
              "name": "Example 4",
              "value": "ZANJCGDLVHIXOBRPMSWQUKFYET<BFHNQUW"
            },
            {
              "name": "Example 5",
              "value": "QXBGUTOVFCZPJIHSWERYNDAMLK<BFHNQUW"
            },
            {
              "name": "Example 6",
              "value": "BDCNWUEIQVFTSXALOGZJYMHKPR<BFHNQUW"
            },
            {
              "name": "Example 7",
              "value": "WJUKEIABMSGFTQZVCNPHORDXYL<BFHNQUW"
            },
            {
              "name": "Example 8",
              "value": "TNVCZXDIPFWQKHSJMAOYLEURGB<BFHNQUW"
            }
          ]
        },
        {
          "name": "2nd rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "2nd rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "2nd rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "3rd (middle) rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "MCYLPQUVRXGSAOWNBJEZDTFKHI<BFHNQUW"
            },
            {
              "name": "Example 2",
              "value": "KHWENRCBISXJQGOFMAPVYZDLTU<BFHNQUW"
            },
            {
              "name": "Example 3",
              "value": "BYPDZMGIKQCUSATREHOJNLFWXV<BFHNQUW"
            },
            {
              "name": "Example 4",
              "value": "ZANJCGDLVHIXOBRPMSWQUKFYET<BFHNQUW"
            },
            {
              "name": "Example 5",
              "value": "QXBGUTOVFCZPJIHSWERYNDAMLK<BFHNQUW"
            },
            {
              "name": "Example 6",
              "value": "BDCNWUEIQVFTSXALOGZJYMHKPR<BFHNQUW"
            },
            {
              "name": "Example 7",
              "value": "WJUKEIABMSGFTQZVCNPHORDXYL<BFHNQUW"
            },
            {
              "name": "Example 8",
              "value": "TNVCZXDIPFWQKHSJMAOYLEURGB<BFHNQUW"
            }
          ]
        },
        {
          "name": "3rd rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "3rd rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "3rd rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "4th (static) rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "MCYLPQUVRXGSAOWNBJEZDTFKHI<BFHNQUW"
            },
            {
              "name": "Example 2",
              "value": "KHWENRCBISXJQGOFMAPVYZDLTU<BFHNQUW"
            },
            {
              "name": "Example 3",
              "value": "BYPDZMGIKQCUSATREHOJNLFWXV<BFHNQUW"
            },
            {
              "name": "Example 4",
              "value": "ZANJCGDLVHIXOBRPMSWQUKFYET<BFHNQUW"
            },
            {
              "name": "Example 5",
              "value": "QXBGUTOVFCZPJIHSWERYNDAMLK<BFHNQUW"
            },
            {
              "name": "Example 6",
              "value": "BDCNWUEIQVFTSXALOGZJYMHKPR<BFHNQUW"
            },
            {
              "name": "Example 7",
              "value": "WJUKEIABMSGFTQZVCNPHORDXYL<BFHNQUW"
            },
            {
              "name": "Example 8",
              "value": "TNVCZXDIPFWQKHSJMAOYLEURGB<BFHNQUW"
            }
          ]
        },
        {
          "name": "4th rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "4th rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "4th rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "5th (right-hand, static) rotor",
          "type": "editableOption",
          "value": [
            {
              "name": "Example 1",
              "value": "MCYLPQUVRXGSAOWNBJEZDTFKHI<BFHNQUW"
            },
            {
              "name": "Example 2",
              "value": "KHWENRCBISXJQGOFMAPVYZDLTU<BFHNQUW"
            },
            {
              "name": "Example 3",
              "value": "BYPDZMGIKQCUSATREHOJNLFWXV<BFHNQUW"
            },
            {
              "name": "Example 4",
              "value": "ZANJCGDLVHIXOBRPMSWQUKFYET<BFHNQUW"
            },
            {
              "name": "Example 5",
              "value": "QXBGUTOVFCZPJIHSWERYNDAMLK<BFHNQUW"
            },
            {
              "name": "Example 6",
              "value": "BDCNWUEIQVFTSXALOGZJYMHKPR<BFHNQUW"
            },
            {
              "name": "Example 7",
              "value": "WJUKEIABMSGFTQZVCNPHORDXYL<BFHNQUW"
            },
            {
              "name": "Example 8",
              "value": "TNVCZXDIPFWQKHSJMAOYLEURGB<BFHNQUW"
            }
          ]
        },
        {
          "name": "5th rotor reversed",
          "type": "boolean",
          "value": false
        },
        {
          "name": "5th rotor ring setting",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "5th rotor initial value",
          "type": "option",
          "value": [
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
          ]
        },
        {
          "name": "Reflector",
          "type": "editableOption",
          "value": [
            {
              "name": "Example",
              "value": "AN BC FG IE KD LU MH OR TS VZ WQ XJ YP"
            }
          ]
        },
        {
          "name": "Plugboard",
          "type": "string",
          "value": ""
        },
        {
          "name": "Typex keyboard emulation",
          "type": "option",
          "value": [
            "None",
            "Encrypt",
            "Decrypt"
          ]
        },
        {
          "name": "Strict output",
          "type": "boolean",
          "value": true
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Unescape string",
      "module": "Default",
      "description": "Unescapes characters in a string that have been escaped. For example, <code>Don\\'t stop me now</code> becomes <code>Don't stop me now</code>.<br><br>Supports the following escape sequences:<ul><li><code>\\n</code> (Line feed/newline)</li><li><code>\\r</code> (Carriage return)</li><li><code>\\t</code> (Horizontal tab)</li><li><code>\\b</code> (Backspace)</li><li><code>\\f</code> (Form feed)</li><li><code>\\nnn</code> (Octal, where n is 0-7)</li><li><code>\\xnn</code> (Hex, where n is 0-f)</li><li><code>\\\\</code> (Backslash)</li><li><code>\\'</code> (Single quote)</li><li><code>\\&quot;</code> (Double quote)</li><li><code>\\unnnn</code> (Unicode character)</li><li><code>\\u{nnnnnn}</code> (Unicode code point)</li></ul>",
      "inputType": "string",
      "outputType": "string",
      "args": [],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Unescape Unicode Characters",
      "module": "Default",
      "description": "Converts unicode-escaped character notation back into raw characters.<br><br>Supports the prefixes:<ul><li><code>\\u</code></li><li><code>%u</code></li><li><code>U+</code></li></ul>e.g. <code>\\u03c3\\u03bf\\u03c5</code> becomes <code>\u03c3\u03bf\u03c5</code>",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Prefix",
          "type": "option",
          "value": [
            "\\u",
            "%u",
            "U+"
          ]
        }
      ],
      "category": "Data format",
      "is_favorite": false
    },
    {
      "name": "Unicode Text Format",
      "module": "Default",
      "description": "Adds Unicode combining characters to change formatting of plaintext.",
      "inputType": "byteArray",
      "outputType": "byteArray",
      "args": [
        {
          "name": "Underline",
          "type": "boolean",
          "value": "false"
        },
        {
          "name": "Strikethrough",
          "type": "boolean",
          "value": "false"
        }
      ],
      "category": "Language",
      "is_favorite": false
    },
    {
      "name": "Unique",
      "module": "Default",
      "description": "Removes duplicate strings from the input.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Delimiter",
          "type": "option",
          "value": [
            "Line feed",
            "CRLF",
            "Space",
            "Comma",
            "Semi-colon",
            "Colon",
            "Nothing (separate chars)"
          ]
        },
        {
          "name": "Display count",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Utils",
      "is_favorite": false
    },
    {
      "name": "Untar",
      "module": "Compression",
      "description": "Unpacks a tarball and displays it per file.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Unzip",
      "module": "Compression",
      "description": "Decompresses data using the PKZIP algorithm and displays it per file, with support for passwords.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Password",
          "type": "binaryString",
          "value": ""
        },
        {
          "name": "Verify result",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "VarInt Decode",
      "module": "Default",
      "description": "Decodes a VarInt encoded integer. VarInt is an efficient way of encoding variable length integers and is commonly used with Protobuf.",
      "inputType": "byteArray",
      "outputType": "string",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "VarInt Encode",
      "module": "Default",
      "description": "Encodes a Vn integer as a VarInt. VarInt is an efficient way of encoding variable length integers and is commonly used with Protobuf.",
      "inputType": "string",
      "outputType": "byteArray",
      "args": [],
      "category": "Networking",
      "is_favorite": false
    },
    {
      "name": "View Bit Plane",
      "module": "Image",
      "description": "Extracts and displays a bit plane of any given image. These show only a single bit from each pixel, and can be used to hide messages in Steganography.",
      "inputType": "ArrayBuffer",
      "outputType": "html",
      "args": [
        {
          "name": "Colour",
          "type": "option",
          "value": [
            "Red",
            "Green",
            "Blue",
            "Alpha"
          ]
        },
        {
          "name": "Bit",
          "type": "number",
          "value": 0
        }
      ],
      "category": "Forensics",
      "is_favorite": false
    },
    {
      "name": "Vigen\u00e8re Decode",
      "module": "Ciphers",
      "description": "The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword. It is a simple form of polyalphabetic substitution.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Vigen\u00e8re Encode",
      "module": "Ciphers",
      "description": "The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword. It is a simple form of polyalphabetic substitution.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Key",
          "type": "string",
          "value": ""
        }
      ],
      "category": "Encryption / Encoding",
      "is_favorite": false
    },
    {
      "name": "Whirlpool",
      "module": "Crypto",
      "description": "Whirlpool is a cryptographic hash function designed by Vincent Rijmen (co-creator of AES) and Paulo S. L. M. Barreto, who first described it in 2000.<br><br>Several variants exist:<ul><li>Whirlpool-0 is the original version released in 2000.</li><li>Whirlpool-T is the first revision, released in 2001, improving the generation of the s-box.</li><li>Whirlpool is the latest revision, released in 2003, fixing a flaw in the diffusion matrix.</li></ul>",
      "inputType": "ArrayBuffer",
      "outputType": "string",
      "args": [
        {
          "name": "Variant",
          "type": "option",
          "value": [
            "Whirlpool",
            "Whirlpool-T",
            "Whirlpool-0"
          ]
        },
        {
          "name": "Rounds",
          "type": "number",
          "value": 10
        }
      ],
      "category": "Hashing",
      "is_favorite": false
    },
    {
      "name": "Windows Filetime to UNIX Timestamp",
      "module": "Default",
      "description": "Converts a Windows Filetime value to a UNIX timestamp.<br><br>A Windows Filetime is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 UTC.<br><br>A UNIX timestamp is a 32-bit value representing the number of seconds since January 1, 1970 UTC (the UNIX epoch).<br><br>This operation also supports UNIX timestamps in milliseconds, microseconds and nanoseconds.",
      "inputType": "string",
      "outputType": "string",
      "args": [
        {
          "name": "Output units",
          "type": "option",
          "value": [
            "Seconds (s)",
            "Milliseconds (ms)",
            "Microseconds (\u03bcs)",
            "Nanoseconds (ns)"
          ]
        },
        {
          "name": "Input format",
          "type": "option",
          "value": [
            "Decimal",
            "Hex (big endian)",
            "Hex (little endian)"
          ]
        }
      ],
      "category": "Date / Time",
      "is_favorite": false
    },
    {
      "name": "Zip",
      "module": "Compression",
      "description": "Compresses data using the PKZIP algorithm with the given filename.<br><br>No support for multiple files at this time.",
      "inputType": "ArrayBuffer",
      "outputType": "File",
      "args": [
        {
          "name": "Filename",
          "type": "string",
          "value": "file.txt"
        },
        {
          "name": "Comment",
          "type": "string",
          "value": ""
        },
        {
          "name": "Password",
          "type": "binaryString",
          "value": ""
        },
        {
          "name": "Compression method",
          "type": "option",
          "value": [
            "Deflate",
            "None (Store)"
          ]
        },
        {
          "name": "Operating system",
          "type": "option",
          "value": [
            "MSDOS",
            "Unix",
            "Macintosh"
          ]
        },
        {
          "name": "Compression type",
          "type": "option",
          "value": [
            "Dynamic Huffman Coding",
            "Fixed Huffman Coding",
            "None (Store)"
          ]
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Zlib Deflate",
      "module": "Compression",
      "description": "Compresses data using the deflate algorithm adding zlib headers.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Compression type",
          "type": "option",
          "value": [
            "Dynamic Huffman Coding",
            "Fixed Huffman Coding",
            "None (Store)"
          ]
        }
      ],
      "category": "Compression",
      "is_favorite": false
    },
    {
      "name": "Zlib Inflate",
      "module": "Compression",
      "description": "Decompresses data which has been compressed using the deflate algorithm with zlib headers.",
      "inputType": "ArrayBuffer",
      "outputType": "ArrayBuffer",
      "args": [
        {
          "name": "Start index",
          "type": "number",
          "value": 0
        },
        {
          "name": "Initial output buffer size",
          "type": "number",
          "value": 0
        },
        {
          "name": "Buffer expansion type",
          "type": "option",
          "value": [
            "Adaptive",
            "Block"
          ]
        },
        {
          "name": "Resize buffer after decompression",
          "type": "boolean",
          "value": false
        },
        {
          "name": "Verify result",
          "type": "boolean",
          "value": false
        }
      ],
      "category": "Compression",
      "is_favorite": false
    }
  ]
}
```

`ida_cyberchef/main.py`:

```py
"""Standalone Qt application for CyberChef widget."""

import sys

from PySide6.QtGui import QAction, QKeySequence
from PySide6.QtWidgets import QApplication, QFileDialog, QMainWindow, QMessageBox

from ida_cyberchef.cyberchef_widget import CyberChefWidget


class CyberChefMainWindow(QMainWindow):
    """Main window wrapper for standalone application."""

    def __init__(self):
        super().__init__()

        self.setWindowTitle("CyberChef")
        self.resize(288, 600)

        self._widget = CyberChefWidget()
        self.setCentralWidget(self._widget)

        self._setup_menu()

    def _setup_menu(self):
        """Setup menu bar."""
        menubar = self.menuBar()

        file_menu = menubar.addMenu("File")

        load_action = QAction("Load Recipe...", self)
        load_action.setShortcut(QKeySequence.Open)
        load_action.triggered.connect(self._load_recipe)
        file_menu.addAction(load_action)

        save_action = QAction("Save Recipe...", self)
        save_action.setShortcut(QKeySequence.Save)
        save_action.triggered.connect(self._save_recipe)
        file_menu.addAction(save_action)

        file_menu.addSeparator()

        quit_action = QAction("Quit", self)
        quit_action.setShortcut(QKeySequence.Quit)
        quit_action.triggered.connect(self.close)
        file_menu.addAction(quit_action)

    def _load_recipe(self):
        """Load recipe from file."""
        filename, _ = QFileDialog.getOpenFileName(
            self, "Load Recipe", "", "Recipe Files (*.json)"
        )

        if filename:
            try:
                self._widget.load_recipe_from_file(filename)
                QMessageBox.information(
                    self, "Success", f"Recipe loaded from {filename}"
                )
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error loading recipe: {e}")

    def _save_recipe(self):
        """Save recipe to file."""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Recipe", "", "Recipe Files (*.json)"
        )

        if filename:
            try:
                self._widget.save_recipe_to_file(filename)
                QMessageBox.information(self, "Success", f"Recipe saved to {filename}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error saving recipe: {e}")


def main():
    """Main application entry point."""
    app = QApplication(sys.argv)

    window = CyberChefMainWindow()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()

```

`ida_cyberchef/plugin/__init__.py`:

```py
import logging

import ida_bytes
import ida_idaapi
import ida_kernwin
from PySide6 import QtWidgets

from ida_cyberchef.cyberchef_widget import CyberChefWidget
from ida_cyberchef.qt_models.input_model import InputSource

logger = logging.getLogger(__name__)


def list_widgets(prefix: str = "CyberChef-") -> list[str]:
    """Probe A-Z for existing widgets, return found captions.

    Args:
        prefix: Caption prefix to search for

    Returns: List of found widget captions (e.g., ["CyberChef-A", "CyberChef-C"])
    """
    found = []
    for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        caption = f"{prefix}{letter}"
        if ida_kernwin.find_widget(caption) is not None:
            found.append(caption)
    return found


def find_next_available_caption(prefix: str = "CyberChef-") -> str:
    """Find first gap or next letter for widget caption.

    Args:
        prefix: Caption prefix to use

    Returns: First available caption (e.g., "CyberChef-B")

    Raises:
        RuntimeError: If all 26 instances are in use
    """
    for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        caption = f"{prefix}{letter}"
        if ida_kernwin.find_widget(caption) is None:
            return caption
    raise RuntimeError("All 26 CyberChef instances in use")


class UILocationHook(ida_kernwin.UI_Hooks):
    def __init__(self, w, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.w: CyberChefWidget = w
        self.w.get_input_model().source_changed.connect(self._on_source_changed)
        self.populate(ida_kernwin.get_screen_ea())

    def populate_from_cursor(self, ea):
        buf = ida_bytes.get_bytes(ea, 0x100)
        self.w.get_input_model().set_external_data(buf)

    def populate_from_selection(self):
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            return

        if ida_kernwin.get_viewer_place_type(v) != ida_kernwin.TCCPT_IDAPLACE:
            # not the disassembly view
            # TODO: hex view
            return

        has_range, start, end = ida_kernwin.read_range_selection(v)
        if not has_range:
            return

        if ida_idaapi.BADADDR in (start, end):
            return

        # TODO: maybe use item head/end

        buf = ida_bytes.get_bytes(start, end - start)
        self.w.get_input_model().set_external_data(buf, start)

    def populate(self, ea: int):
        source = self.w.get_input_model().get_input_source()
        if source == InputSource.MANUAL:
            # nothing to do
            pass
        elif source == InputSource.FROM_CURSOR:
            self.populate_from_cursor(ea)
        elif source == InputSource.FROM_SELECTION:
            self.populate_from_selection()
        elif source == InputSource.FROM_LOCATION:
            # FROM_LOCATION mode maintains pinned address/length and should not
            # respond to cursor or selection changes. Data only updates when user
            # explicitly edits the location fields or uses 'Send to CyberChef' action.
            pass
        else:
            raise RuntimeError("unexpected input source")

    def _on_source_changed(self, source: InputSource):
        """Handle input source change by populating with current IDA state."""
        if source not in (InputSource.MANUAL, InputSource.FROM_LOCATION):
            self.populate(ida_kernwin.get_screen_ea())

    def screen_ea_changed(self, ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t) -> None:
        if ea == prev_ea:
            return
        self.populate(ea)


class ContextMenuUIHooks(ida_kernwin.UI_Hooks):
    def __init__(self, plugmod: "cyberchef_plugmod_t", *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.plugmod = plugmod

    def finish_populating_widget_popup(self, widget, popup, ctx):
        if ctx.widget_type in (ida_kernwin.BWN_HEXVIEW, ida_kernwin.BWN_DISASM):
            self.plugmod.register_instance_actions()

            existing = list_widgets()

            if existing:
                for caption in existing:
                    action_name = (
                        f"cyberchef:send_to_{caption.replace('-', '_').lower()}"
                    )
                    ida_kernwin.attach_action_to_popup(
                        widget, popup, action_name, "CyberChef/"
                    )

            ida_kernwin.attach_action_to_popup(
                widget, popup, "cyberchef:send_new", "CyberChef/"
            )


class CyberChefForm(ida_kernwin.PluginForm):
    def __init__(
        self,
        caption: str = "CyberChef-A",
        form_registry: dict[str, "CyberChefForm"] | None = None,
    ) -> None:
        super().__init__()
        self.TITLE = caption
        self.form_registry = form_registry

    def OnCreate(self, form):
        self.parent = self.FormToPyQtWidget(form)
        self.w = CyberChefWidget(parent=self.parent, show_ida_buttons=True)

        output_panel = self.w.get_output_panel()
        output_panel.copy_to_db_requested.connect(self._on_copy_to_db)
        output_panel.set_comment_requested.connect(self._on_set_comment)

        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(self.w)
        self.parent.setLayout(layout)

        self.location_hooks = UILocationHook(self.w)
        self.location_hooks.hook()

        if self.form_registry is not None:
            self.form_registry[self.TITLE] = self

    def _on_copy_to_db(self, address: int, data: bytes):
        """Handle copy to IDB request from output panel.

        Args:
            address: Address to patch
            data: Bytes to write
        """
        try:
            ida_bytes.patch_bytes(address, data)
            logger.info(
                "Patched %d bytes at address %s",
                len(data),
                hex(address),
            )
        except Exception as e:
            logger.error("Failed to patch bytes: %s", e)

    def _on_set_comment(self, text: str):
        """Handle set comment request from output panel.

        Args:
            text: Comment text to set
        """
        try:
            # Try to get the selection start address first, fall back to cursor
            ea = self.w.get_input_model().get_external_address()
            if ea is None:
                ea = ida_kernwin.get_screen_ea()

            ida_bytes.set_cmt(ea, text, False)
            logger.info("Set comment at address %s", hex(ea))
        except Exception as e:
            logger.error("Failed to set comment: %s", e)

    def OnClose(self, form):
        if self.location_hooks:
            self.location_hooks.unhook()

        if self.form_registry is not None:
            self.form_registry.pop(self.TITLE, None)


class create_cyberchef_widget_action_handler_t(ida_kernwin.action_handler_t):
    def __init__(self, plugmod: "cyberchef_plugmod_t", *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.plugmod = plugmod

    def activate(self, ctx):
        self.plugmod.create_viewer()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class send_to_cyberchef_action_handler_t(ida_kernwin.action_handler_t):
    """Action handler for 'Send to CyberChef' context menu item."""

    def __init__(self, plugmod: "cyberchef_plugmod_t", *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.plugmod = plugmod

    def activate(self, ctx):
        """Handle 'Send to CyberChef' action - always creates new instance."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            return 0

        has_range, start, end = ida_kernwin.read_range_selection(v)
        if not has_range or ida_idaapi.BADADDR in (start, end):
            logger.warning("No valid selection for Send to CyberChef")
            return 0

        length = end - start
        if length <= 0:
            logger.warning("Invalid selection length for Send to CyberChef")
            return 0

        form = self.plugmod.create_viewer()

        if form and form.w:
            input_model = form.w.get_input_model()
            input_panel = form.w.get_input_panel()

            input_model.set_input_source(InputSource.FROM_LOCATION)

            if input_panel._location_radio:
                input_panel._location_radio.setChecked(True)
                input_panel._on_source_changed()

            input_model.set_location_params(start, length)

            if input_panel._location_widget:
                input_panel._location_widget.set_location(start, length)

        return 1

    def update(self, ctx):
        """Enable action when there's a valid selection."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            return

        has_range, start, end = ida_kernwin.read_range_selection(v)
        if has_range and ida_idaapi.BADADDR not in (start, end) and end > start:
            return ida_kernwin.AST_ENABLE

        return ida_kernwin.AST_DISABLE


class send_to_specific_widget_action_handler_t(ida_kernwin.action_handler_t):
    """Action handler for sending to a specific CyberChef instance."""

    def __init__(
        self,
        form_registry: dict[str, CyberChefForm],
        caption: str,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(*args, **kwargs)
        self.form_registry = form_registry
        self.caption = caption

    def activate(self, ctx):
        """Send selection to specific CyberChef instance."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            return 0

        has_range, start, end = ida_kernwin.read_range_selection(v)
        if not has_range or ida_idaapi.BADADDR in (start, end):
            logger.warning("No valid selection for Send to CyberChef")
            return 0

        length = end - start
        if length <= 0:
            logger.warning("Invalid selection length for Send to CyberChef")
            return 0

        widget = ida_kernwin.find_widget(self.caption)
        if widget is None:
            logger.warning(f"Widget {self.caption} not found")
            return 0

        ida_kernwin.activate_widget(widget, True)

        form = self.form_registry.get(self.caption)
        if form and hasattr(form, "w"):
            input_model = form.w.get_input_model()
            input_panel = form.w.get_input_panel()

            input_model.set_input_source(InputSource.FROM_LOCATION)

            if input_panel._location_radio:
                input_panel._location_radio.setChecked(True)
                input_panel._on_source_changed()

            input_model.set_location_params(start, length)

            if input_panel._location_widget:
                input_panel._location_widget.set_location(start, length)
        else:
            logger.warning(f"Cannot populate {self.caption} - unable to access form")

        return 1

    def update(self, ctx):
        """Enable action when there's a valid selection."""
        v = ida_kernwin.get_current_viewer()

        if ida_kernwin.get_widget_type(v) not in (
            ida_kernwin.BWN_HEXVIEW,
            ida_kernwin.BWN_DISASM,
        ):
            return ida_kernwin.AST_DISABLE

        has_range, start, end = ida_kernwin.read_range_selection(v)
        if has_range and ida_idaapi.BADADDR not in (start, end) and end > start:
            return ida_kernwin.AST_ENABLE

        return ida_kernwin.AST_DISABLE


class create_desktop_widget_hooks_t(ida_kernwin.UI_Hooks):
    def __init__(self, plugmod: "cyberchef_plugmod_t", *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.plugmod = plugmod

    def create_desktop_widget(self, ttl, cfg):
        if ttl.startswith("CyberChef-"):
            return self.plugmod.create_viewer(caption=ttl).GetWidget()


class cyberchef_plugmod_t(ida_idaapi.plugmod_t):
    ACTION_NAME = "cyberchef:create"
    SEND_ACTION_NAME = "cyberchef:send_selection"
    MENU_PATH = "View/Open subviews/Strings"

    def __init__(self):
        super().__init__()
        self.installation_hooks: create_desktop_widget_hooks_t | None = None
        self.context_menu_hooks: ContextMenuUIHooks | None = None
        self.form_registry: dict[str, CyberChefForm] = {}

        # IDA doesn't invoke this for plugmod_t, only plugin_t
        self.init()

    def create_viewer(self, caption: str | None = None) -> CyberChefForm:
        if caption is None:
            caption = find_next_available_caption()
        form = CyberChefForm(caption, self.form_registry)
        form.Show(form.TITLE)
        return form

    def register_open_action(self):
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
                self.ACTION_NAME,
                "CyberChef",
                create_cyberchef_widget_action_handler_t(self),
            )
        )

        # TODO: add icon
        ida_kernwin.attach_action_to_menu(
            self.MENU_PATH, self.ACTION_NAME, ida_kernwin.SETMENU_APP
        )

    def unregister_open_action(self):
        ida_kernwin.unregister_action(self.ACTION_NAME)
        ida_kernwin.detach_action_from_menu(self.MENU_PATH, self.ACTION_NAME)

    def register_autoinst_hooks(self):
        self.installation_hooks = create_desktop_widget_hooks_t(self)
        assert self.installation_hooks is not None
        self.installation_hooks.hook()

    def unregister_autoinst_hooks(self):
        if self.installation_hooks:
            self.installation_hooks.unhook()

    def register_send_action(self):
        """Register 'Send to CyberChef' context menu actions."""
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
                "cyberchef:send_new",
                "New window",
                send_to_cyberchef_action_handler_t(self),
                None,
                "Send selected bytes to new CyberChef window",
                -1,
            )
        )

        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
                self.SEND_ACTION_NAME,
                "Send to CyberChef",
                send_to_cyberchef_action_handler_t(self),
                None,
                "Send selected bytes to CyberChef for transformation",
                -1,
            )
        )

    def unregister_send_action(self):
        """Unregister 'Send to CyberChef' actions."""
        ida_kernwin.unregister_action("cyberchef:send_new")
        ida_kernwin.unregister_action(self.SEND_ACTION_NAME)

    def register_instance_actions(self):
        """Register actions for all existing widget instances."""
        existing = list_widgets()

        for caption in existing:
            action_name = f"cyberchef:send_to_{caption.replace('-', '_').lower()}"

            if ida_kernwin.unregister_action(action_name):
                pass

            ida_kernwin.register_action(
                ida_kernwin.action_desc_t(
                    action_name,
                    f"Send to {caption}",
                    send_to_specific_widget_action_handler_t(
                        self.form_registry, caption
                    ),
                    None,
                    f"Send selected bytes to {caption}",
                    -1,
                )
            )

    def register_context_menu_hooks(self):
        self.context_menu_hooks = ContextMenuUIHooks(self)
        self.context_menu_hooks.hook()

    def unregister_context_menu_hooks(self):
        if self.context_menu_hooks:
            self.context_menu_hooks.unhook()

    def init(self):
        # do things here that will always run,
        #  and don't require the menu entry (edit > plugins > ...) being selected.
        #
        # note: IDA doesn't call init, we do in __init__
        self.register_autoinst_hooks()
        self.register_open_action()
        self.register_send_action()
        self.register_context_menu_hooks()

    def run(self, arg):
        # do things here that users invoke via the menu entry (edit > plugins > ...)
        self.create_viewer()

    def term(self):
        self.unregister_context_menu_hooks()
        self.unregister_send_action()
        self.unregister_open_action()
        self.unregister_autoinst_hooks()


class cyberchef_plugin_t(ida_idaapi.plugin_t):
    flags = ida_idaapi.PLUGIN_MULTI
    help = "CyberChef data transformations"
    comment = ""
    # TODO: don't show in plugins menu
    wanted_name = "CyberChef"
    wanted_hotkey = "Shift-e"

    def init(self):
        return cyberchef_plugmod_t()

```

`ida_cyberchef/qt_models/__init__.py`:

```py
"""Qt models for CyberChef widget."""

```

`ida_cyberchef/qt_models/execution_model.py`:

```py
"""Qt model for coordinating recipe execution with debouncing.

IMPORTANT: All execution happens in the main thread due to STPyV8 thread-safety
limitations. STPyV8 (the JavaScript engine used by PythonMonkey to execute
CyberChef operations) is not thread-safe and will segfault if called from a
background thread.

If future versions migrate to a thread-safe JavaScript engine, background
execution can be implemented using QThread workers.
"""

from typing import Dict, List, Optional

from PySide6.QtCore import QObject, QTimer, Signal

from ida_cyberchef.core.recipe_executor import RecipeExecutor, StepResult
from ida_cyberchef.qt_models.input_model import InputModel
from ida_cyberchef.qt_models.recipe_model import RecipeModel


class ExecutionModel(QObject):
    """Coordinates pipeline execution with debouncing.

    All CyberChef operations execute in the main thread due to STPyV8
    thread-safety constraints. Debouncing (default 100ms) prevents excessive
    executions when users rapidly change input or recipe.
    """

    execution_completed = Signal()

    def __init__(
        self,
        input_model: InputModel,
        recipe_model: RecipeModel,
        debounce_ms: int = 100,
        parent=None,
    ):
        super().__init__(parent)

        self._input_model = input_model
        self._recipe_model = recipe_model
        self._executor = RecipeExecutor()

        self._results: List[StepResult] = []
        self._preview_results: Dict[int, StepResult] = {}

        self._debounce_timer = QTimer(self)
        self._debounce_timer.setSingleShot(True)
        self._debounce_timer.setInterval(debounce_ms)
        self._debounce_timer.timeout.connect(self._execute_pipeline)

        self._input_model.input_changed.connect(self.schedule_execution)
        self._recipe_model.recipe_changed.connect(self.schedule_execution)

    def schedule_execution(self):
        """Schedule execution after debounce delay."""
        self._debounce_timer.start()

    def _execute_pipeline(self):
        """Execute pipeline (in main thread due to STPyV8 limitations)."""
        input_data = self._input_model.get_input_bytes()
        if input_data is None:
            self._results = []
            self.execution_completed.emit()
            return

        recipe = self._recipe_model.get_recipe_steps()
        if not recipe:
            passthrough_result = StepResult(success=True, data=input_data, error=None)
            self._results = [passthrough_result]
            self.execution_completed.emit()
            return

        try:
            results = self._executor.execute_recipe(input_data, recipe)
            self._results = results
        except Exception as e:
            error_result = StepResult(success=False, data=None, error=str(e))
            self._results = [error_result]

        self.execution_completed.emit()

    def get_results(self) -> List[StepResult]:
        """Get results from last execution."""
        return self._results.copy()

    def get_final_result(self) -> Optional[StepResult]:
        """Get final result (last successful step or first error)."""
        return self._results[-1] if self._results else None

```

`ida_cyberchef/qt_models/input_model.py`:

```py
"""Qt model for input data management."""

from enum import IntEnum
from typing import Optional

from PySide6.QtCore import QObject, Signal

from ida_cyberchef.core.input_parser import InputFormat, InputParser

try:
    import ida_bytes

    IDA_AVAILABLE = True
except ImportError:
    ida_bytes = None  # type: ignore
    IDA_AVAILABLE = False


class InputSource(IntEnum):
    """Input data source types."""

    MANUAL = 0
    FROM_CURSOR = 1
    FROM_SELECTION = 2
    FROM_LOCATION = 3


class InputModel(QObject):
    """Manages input data source and format."""

    input_changed = Signal()
    source_changed = Signal(InputSource)
    location_params_changed = Signal(int, int)

    def __init__(self, parent=None):
        super().__init__(parent)

        self._source = InputSource.MANUAL
        self._format = InputFormat.TEXT_UTF8
        self._manual_text = ""
        self._external_data: Optional[bytes] = None
        self._external_address: Optional[int] = None

        self._location_address: Optional[int] = None
        self._location_length: Optional[int] = None
        self._location_data: Optional[bytes] = None

        self._parser = InputParser()

    def get_input_source(self) -> InputSource:
        """Get current input source type."""
        return self._source

    def set_input_source(self, source: InputSource):
        """Set input source type."""
        if self._source != source:
            self._source = source
            self.source_changed.emit(source)
            self.input_changed.emit()

    def get_input_format(self) -> InputFormat:
        """Get current input format (for manual input only)."""
        return self._format

    def set_input_format(self, format: InputFormat):
        """Set input format for manual input."""
        if self._format != format:
            self._format = format
            self.input_changed.emit()

    def set_manual_text(self, text: str):
        """Set manual input text."""
        if self._manual_text != text:
            self._manual_text = text
            self.input_changed.emit()

    def get_manual_text(self) -> str:
        """Get current manual input text."""
        return self._manual_text

    def set_external_data(self, data: bytes, address: Optional[int] = None):
        """Set external input data (from cursor/selection).

        Args:
            data: The bytes data
            address: Optional address where the data came from
        """
        self._external_data = data
        self._external_address = address
        self.input_changed.emit()

    def get_external_address(self) -> Optional[int]:
        """Get the address where external data came from.

        Returns: Address if set, None otherwise
        """
        if self._source == InputSource.FROM_LOCATION:
            return self._location_address
        return self._external_address

    def get_input_bytes(self) -> Optional[bytes]:
        """Get current input as bytes based on source and format.

        Returns: Input bytes, or None if parsing fails
        """
        if self._source == InputSource.MANUAL:
            return self._parser.parse(self._manual_text, self._format)
        elif self._source == InputSource.FROM_LOCATION:
            return self._location_data if self._location_data else b""
        else:
            return self._external_data

    def set_location_params(self, address: int, length: int):
        """Set location parameters and fetch data from IDA.

        Only used when source == FROM_LOCATION.

        Args:
            address: Effective address to read from
            length: Number of bytes to read
        """
        self._location_address = address
        self._location_length = length

        if IDA_AVAILABLE:
            try:
                data = ida_bytes.get_bytes(address, length)
                self._location_data = data if data else b""
            except Exception:
                self._location_data = b""
        else:
            self._location_data = b""

        self.location_params_changed.emit(address, length)
        self.input_changed.emit()

    def get_location_address(self) -> Optional[int]:
        """Get location address (only valid when source == FROM_LOCATION)."""
        return self._location_address

    def get_location_length(self) -> Optional[int]:
        """Get location length (only valid when source == FROM_LOCATION)."""
        return self._location_length

```

`ida_cyberchef/qt_models/recipe_model.py`:

```py
"""Qt model for recipe step management."""

from typing import Any, Dict, List

from PySide6.QtCore import QAbstractListModel, Qt, Signal

from ida_cyberchef.core.recipe_models import OperationStep, RecipeDefinition


class RecipeModel(QAbstractListModel):
    """Qt model for managing recipe steps."""

    recipe_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._steps: List[Dict[str, Any]] = []

    def rowCount(self, parent=None):
        """Return number of steps in recipe."""
        return len(self._steps)

    def data(self, index, role=Qt.DisplayRole):
        """Return data for given index and role."""
        if not index.isValid() or index.row() >= len(self._steps):
            return None

        step = self._steps[index.row()]

        if role == Qt.DisplayRole:
            return step["operation"]
        elif role == Qt.UserRole:
            return step

        return None

    def add_operation(self, operation: str, args: Dict[str, Any], index: int = -1):
        """Add operation to recipe.

        Args:
            operation: Operation name
            args: Operation arguments
            index: Insert position (-1 = append)
        """
        if index < 0:
            index = len(self._steps)

        self.beginInsertRows(self.index(0, 0).parent(), index, index)
        self._steps.insert(index, {"operation": operation, "args": args.copy()})
        self.endInsertRows()

        self.recipe_changed.emit()

    def remove_operation(self, index: int):
        """Remove operation at index."""
        if 0 <= index < len(self._steps):
            self.beginRemoveRows(self.index(0, 0).parent(), index, index)
            self._steps.pop(index)
            self.endRemoveRows()

            self.recipe_changed.emit()

    def update_operation_args(self, index: int, args: Dict[str, Any]):
        """Update arguments for operation at index."""
        if 0 <= index < len(self._steps):
            self._steps[index]["args"] = args.copy()

            model_index = self.index(index, 0)
            self.dataChanged.emit(model_index, model_index)
            self.recipe_changed.emit()

    def get_recipe_steps(self) -> List[Dict[str, Any]]:
        """Get all recipe steps as list of dicts."""
        return [step.copy() for step in self._steps]

    def to_recipe_definition(self) -> RecipeDefinition:
        """Convert to Pydantic model for serialization."""
        steps = [
            OperationStep(operation=s["operation"], args=s["args"]) for s in self._steps
        ]
        return RecipeDefinition(steps=steps)

    def from_recipe_definition(self, recipe: RecipeDefinition):
        """Load from Pydantic model."""
        self.beginResetModel()
        self._steps = [{"operation": s.operation, "args": s.args} for s in recipe.steps]
        self.endResetModel()

        self.recipe_changed.emit()

```

`ida_cyberchef/widgets/__init__.py`:

```py
"""Qt widgets for CyberChef application."""

```

`ida_cyberchef/widgets/input_panel.py`:

```py
"""Input panel widget for data entry."""

from PySide6.QtCore import Qt
from PySide6.QtGui import QResizeEvent
from PySide6.QtWidgets import (
    QButtonGroup,
    QComboBox,
    QHBoxLayout,
    QLabel,
    QRadioButton,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from ida_cyberchef.core.hex_formatter import HexFormatter
from ida_cyberchef.core.input_parser import InputFormat
from ida_cyberchef.qt_models.input_model import InputModel, InputSource
from ida_cyberchef.widgets.location_input_widget import LocationInputWidget

try:
    import ida_bytes  # noqa: F401

    IDA_AVAILABLE = True
except ImportError:
    IDA_AVAILABLE = False


class InputPanel(QWidget):
    """Panel for input data entry and source selection.

    Layout (Manual Input mode):
    ┌─────────────────────────────────────────────────────────────────┐
    │ Input Source: ◉ Manual Input  ○ From Cursor  ○ From Selection  │
    ├─────────────────────────────────────────────────────────────────┤
    │ ┌─ Unified Text Area (editable) ──────────────────────────────┐  │
    │ │ Enter input data...                                        │  │
    │ │                                                            │  │
    │ │                                            [Text (UTF-8)▼] │  │
    │ └────────────────────────────────────────────────────────────┘  │
    └─────────────────────────────────────────────────────────────────┘

    Layout (From Cursor/Selection mode):
    ┌─────────────────────────────────────────────────────────────────┐
    │ Input Source: ○ Manual Input  ◉ From Cursor  ○ From Selection  │
    ├─────────────────────────────────────────────────────────────────┤
    │ ┌─ Unified Text Area (read-only) ─────────────────────────────┐  │
    │ │ 00000000: 48 65 6c 6c 6f 20 77 6f  72 6c 64     Hello world│  │
    │ │ 00000010: 21 0a                                 !.         │  │
    │ │                                        [Format Disabled ▼] │  │
    │ └────────────────────────────────────────────────────────────┘  │
    └─────────────────────────────────────────────────────────────────┘
    """

    def __init__(self, input_model: InputModel, parent=None):
        super().__init__(parent)

        self._input_model = input_model
        self._hex_formatter = HexFormatter()
        self._location_widget: LocationInputWidget | None

        self._setup_ui()
        self._connect_signals()

    def _setup_ui(self):
        """Setup panel UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        if IDA_AVAILABLE:
            self._source_widget = QWidget()
            self._source_layout = QHBoxLayout(self._source_widget)
            self._source_layout.setContentsMargins(0, 0, 0, 0)
            self._source_layout.addWidget(QLabel("Input Source:"))

            self._source_group = QButtonGroup(self)

            self._manual_radio = QRadioButton("Manual Input")
            self._manual_radio.setChecked(True)
            self._source_group.addButton(self._manual_radio, 0)
            self._source_layout.addWidget(self._manual_radio)

            self._cursor_radio = QRadioButton("From Cursor")
            self._source_group.addButton(self._cursor_radio, 1)
            self._source_layout.addWidget(self._cursor_radio)

            self._selection_radio = QRadioButton("From Selection")
            self._source_group.addButton(self._selection_radio, 2)
            self._source_layout.addWidget(self._selection_radio)

            self._location_radio = QRadioButton("From Location")
            self._source_group.addButton(self._location_radio, 3)
            self._source_layout.addWidget(self._location_radio)

            self._source_layout.addStretch()
            layout.addWidget(self._source_widget)

            self._location_widget = LocationInputWidget()
            self._location_widget.setVisible(False)
            layout.addWidget(self._location_widget)
        else:
            self._source_widget = None
            self._source_group = None
            self._manual_radio = None
            self._cursor_radio = None
            self._selection_radio = None
            self._location_radio = None
            self._location_widget = None

        self._text_area = QTextEdit()
        self._text_area.setPlaceholderText("Enter input data...")
        self._text_area.setMaximumHeight(90)
        self._text_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self._text_area.setStyleSheet("font-family: 'Courier New', Courier, monospace;")
        layout.addWidget(self._text_area)

        self._format_combo = QComboBox(self)
        self._format_combo.addItems(
            [
                "Text (UTF-8)",
                "Hex String",
                "Base64",
            ]
        )
        self._format_combo.setMinimumWidth(150)
        self._format_combo.raise_()

    def resizeEvent(self, event: QResizeEvent) -> None:
        """Reposition overlay combo box on resize."""
        super().resizeEvent(event)

        combo_width = self._format_combo.width()
        combo_height = self._format_combo.height()

        edit_rect = self._text_area.geometry()

        x = edit_rect.right() - combo_width - 6
        y = edit_rect.bottom() - combo_height - 6

        self._format_combo.move(x, y)

    def _connect_signals(self):
        """Connect signals and slots."""
        if self._source_group is not None:
            self._source_group.buttonClicked.connect(self._on_source_changed)

        if self._location_widget is not None:
            self._location_widget.location_changed.connect(
                self._on_location_params_changed
            )

        self._format_combo.currentTextChanged.connect(self._on_format_changed)

        self._text_area.textChanged.connect(self._on_manual_text_changed)

        self._input_model.input_changed.connect(self._on_model_changed)

    def _on_source_changed(self):
        """Handle input source change."""
        if self._manual_radio is None:
            return

        if self._manual_radio.isChecked():
            source = InputSource.MANUAL
            self._text_area.setReadOnly(False)
            self._text_area.setPlaceholderText("Enter input data...")
            self._text_area.setPlainText(self._input_model.get_manual_text())
            self._format_combo.setEnabled(True)
            if self._location_widget is not None:
                self._location_widget.setVisible(False)
        elif self._cursor_radio.isChecked():
            source = InputSource.FROM_CURSOR
            self._text_area.setReadOnly(True)
            self._text_area.setPlaceholderText("")
            self._format_combo.setEnabled(False)
            if self._location_widget is not None:
                self._location_widget.setVisible(False)
            self._update_preview_text()
        elif self._selection_radio.isChecked():
            source = InputSource.FROM_SELECTION
            self._text_area.setReadOnly(True)
            self._text_area.setPlaceholderText("")
            self._format_combo.setEnabled(False)
            if self._location_widget is not None:
                self._location_widget.setVisible(False)
            self._update_preview_text()
        elif self._location_radio.isChecked():
            source = InputSource.FROM_LOCATION
            self._text_area.setReadOnly(True)
            self._text_area.setPlaceholderText("")
            self._format_combo.setEnabled(False)
            if self._location_widget is not None:
                self._location_widget.setVisible(True)
            self._update_preview_text()
        else:
            source = InputSource.MANUAL

        self._input_model.set_input_source(source)

    def _on_format_changed(self):
        """Handle format change."""
        format_name = self._format_combo.currentText()

        if format_name == "Text (UTF-8)":
            format = InputFormat.TEXT_UTF8
        elif format_name == "Hex String":
            format = InputFormat.HEX_STRING
        else:
            format = InputFormat.BASE64

        self._input_model.set_input_format(format)

    def _on_manual_text_changed(self):
        """Handle manual text changes."""
        if not self._text_area.isReadOnly():
            text = self._text_area.toPlainText()
            self._input_model.set_manual_text(text)

    def _on_location_params_changed(self, address: int, length: int):
        """Handle location parameter changes from LocationInputWidget.

        Args:
            address: Effective address
            length: Number of bytes
        """
        self._input_model.set_location_params(address, length)

    def _on_model_changed(self):
        """Handle model changes (external data set)."""
        if self._input_model.get_input_source() != InputSource.MANUAL:
            self._update_preview_text()

    def _update_preview_text(self):
        """Update preview text for external data sources."""
        data = self._input_model.get_input_bytes()
        if data:
            hex_dump = self._hex_formatter.format_hex_dump(data[:256])
            self._text_area.setPlainText(hex_dump)
        else:
            self._text_area.setPlainText("")

```

`ida_cyberchef/widgets/insert_indicator_widget.py`:

```py
"""Insert indicator widget for recipe panel."""

from PySide6.QtCore import QEvent, Qt, Signal
from PySide6.QtGui import QEnterEvent, QMouseEvent, QResizeEvent
from PySide6.QtWidgets import QFrame, QHBoxLayout, QPushButton, QWidget


class InsertIndicatorWidget(QWidget):
    """Widget that shows a subtle insert indicator with hover effect.

    Default state: Small gray circle with "+" on the left
    Hover state: Blue circle with "+" and blue horizontal line across width
    Both circle and line are clickable.
    """

    clicked = Signal()

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)

        self._setup_ui()

    def _setup_ui(self) -> None:
        """Setup widget UI with circle button and horizontal line."""
        self.setFixedHeight(17)
        self.setCursor(Qt.PointingHandCursor)

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Horizontal line (hidden by default, positioned absolutely behind circle)
        self._line = QFrame()
        self._line.setFrameShape(QFrame.HLine)
        self._line.setFixedHeight(2)
        self._line.setStyleSheet("background-color: #2196F3;")
        self._line.setParent(self)
        self._line.setGeometry(0, 7, self.width(), 2)
        self._line.setVisible(False)

        # Circle button (positioned on top of line via absolute positioning)
        self._circle = QPushButton("+")
        self._circle.setFixedSize(17, 17)
        self._circle.setStyleSheet("""
            QPushButton {
                border: 1px solid #2196F3;
                border-radius: 8px;
                background-color: #2196F3;
                color: white;
                font-size: 16px;
                font-weight: bold;
                padding-top: -1px;
            }
        """)
        self._circle.clicked.connect(self.clicked.emit)
        self._circle.setVisible(False)

        # Position circle absolutely at left edge
        self._circle.setParent(self)
        self._circle.move(0, 0)
        self._circle.raise_()

    def enterEvent(self, event: QEnterEvent) -> None:
        """Show highlight on hover."""
        self._line.setVisible(True)
        self._circle.setVisible(True)
        super().enterEvent(event)

    def leaveEvent(self, event: QEvent) -> None:
        """Hide highlight when not hovering."""
        self._line.setVisible(False)
        self._circle.setVisible(False)
        super().leaveEvent(event)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Make entire widget clickable."""
        if event.button() == Qt.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)

    def resizeEvent(self, event: QResizeEvent) -> None:
        """Update line width on resize."""
        self._line.setGeometry(0, 7, self.width(), 2)
        super().resizeEvent(event)

```

`ida_cyberchef/widgets/location_input_widget.py`:

```py
"""Widget for address and length input in FROM_LOCATION mode."""

from PySide6.QtCore import Signal
from PySide6.QtWidgets import QHBoxLayout, QLabel, QLineEdit, QWidget


class LocationInputWidget(QWidget):
    """Widget for inputting location parameters (address and length).

    Layout:
    ┌─────────────────────────────────────────────────┐
    │ Address: [0x00401000          ] Length: [256  ] │
    └─────────────────────────────────────────────────┘
    """

    location_changed = Signal(int, int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._connect_signals()

    def _setup_ui(self):
        """Setup widget UI."""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        layout.addWidget(QLabel("Address:"))

        self._address_edit = QLineEdit()
        self._address_edit.setPlaceholderText("0x00000000")
        self._address_edit.setStyleSheet(
            "font-family: 'Courier New', Courier, monospace;"
        )
        self._address_edit.setMinimumWidth(120)
        layout.addWidget(self._address_edit)

        layout.addWidget(QLabel("Length:"))

        self._length_edit = QLineEdit()
        self._length_edit.setPlaceholderText("256")
        self._length_edit.setMinimumWidth(80)
        layout.addWidget(self._length_edit)

        layout.addStretch()

    def _connect_signals(self):
        """Connect signals and slots."""
        self._address_edit.editingFinished.connect(self._on_params_changed)
        self._length_edit.editingFinished.connect(self._on_params_changed)

    def _on_params_changed(self):
        """Handle parameter changes with validation."""
        address_text = self._address_edit.text().strip()
        length_text = self._length_edit.text().strip()

        if not address_text or not length_text:
            return

        try:
            if address_text.startswith("0x") or address_text.startswith("0X"):
                address = int(address_text, 16)
            else:
                address = int(address_text, 16)

            length = int(length_text, 10)

            if length <= 0:
                return

            self.location_changed.emit(address, length)
        except ValueError:
            pass

    def set_location(self, address: int, length: int):
        """Set address and length fields programmatically.

        Args:
            address: Effective address
            length: Number of bytes
        """
        self._address_edit.setText(f"0x{address:08x}")
        self._length_edit.setText(str(length))

```

`ida_cyberchef/widgets/operation_browser_widget.py`:

```py
"""Persistent operation browser widget with search and documentation."""

from PySide6.QtCore import Qt, QTimer, Signal
from PySide6.QtGui import QFont, QTextCursor
from PySide6.QtWidgets import (
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QPlainTextEdit,
    QSplitter,
    QVBoxLayout,
    QWidget,
)

from ida_cyberchef.core.operation_doc_formatter import format_operation_docs
from ida_cyberchef.core.operation_registry import OperationRegistry


class OperationBrowserWidget(QWidget):
    """Persistent widget for browsing and inserting operations.

    Layout:
    ┌─ Operation Browser ────────────────────────────────────────────────┐
    │ ┌─ Search ──────────────────────────────────────────────────────┐ │
    │ │ Search operations...                                          │ │
    │ └───────────────────────────────────────────────────────────────┘ │
    │ ┌─────────────────────────┬─────────────────────────────────────┐ │
    │ │ To Base64               │ **To Base64**                       │ │
    │ │ From Base64             │ Category: Data format               │ │
    │ │ To Hex                  │                                     │ │
    │ │ From Hex                │ Converts data to Base64 encoding.  │ │
    │ │ XOR                     │                                     │ │
    │ │ AES Decrypt             │ Parameters:                         │ │
    │ │ (more operations...)    │   Alphabet (option) - ...           │ │
    │ └─────────────────────────┴─────────────────────────────────────┘ │
    └───────────────────────────────────────────────────────────────────┘
    """

    operation_selected = Signal(dict)

    def __init__(self, registry: OperationRegistry, parent=None):
        super().__init__(parent)

        self._registry = registry
        self._search_timer = QTimer()
        self._search_timer.setSingleShot(True)
        self._search_timer.setInterval(100)
        self._search_timer.timeout.connect(self._perform_search)

        self._setup_ui()
        self._populate_default_view()

    def _setup_ui(self):
        """Setup widget UI structure."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 6)
        layout.setSpacing(4)

        # Search bar
        self._search_input = QLineEdit()
        self._search_input.setPlaceholderText("Search operations...")
        self._search_input.setStyleSheet(
            "border: 2px solid #2196F3; border-radius: 4px; padding: 4px 8px;"
        )
        self._search_input.textChanged.connect(self._on_search_changed)
        layout.addWidget(self._search_input)

        # Splitter with list and docs
        splitter = QSplitter(Qt.Horizontal)

        # Operation list (left)
        self._operation_list = QListWidget()
        self._operation_list.itemDoubleClicked.connect(
            self._on_operation_double_clicked
        )
        self._operation_list.currentItemChanged.connect(self._on_current_item_changed)
        self._operation_list.itemEntered.connect(self._on_item_hovered)
        self._operation_list.setMouseTracking(True)
        splitter.addWidget(self._operation_list)

        # Documentation panel (right)
        self._doc_panel = QPlainTextEdit()
        self._doc_panel.setReadOnly(True)
        self._doc_panel.setPlainText(
            "Hover over an operation to see documentation.\n\nKeyboard shortcuts:\n  Up/Down: Navigate\n  Enter: Add operation\n  Escape: Clear search\n  Ctrl+F or /: Focus search"
        )
        splitter.addWidget(self._doc_panel)

        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 1)

        layout.addWidget(splitter)

        self._search_input.setFocus()

    def _populate_default_view(self):
        """Populate list with favorites first, then all operations by category."""
        self._operation_list.clear()

        operations = self._registry.get_all_operations()

        # Favorites first
        favorites = [op for op in operations if op.get("is_favorite", False)]
        for op in favorites:
            self._add_operation_item(op)

        # All operations grouped by category
        from itertools import groupby

        operations_sorted = sorted(
            operations, key=lambda op: op.get("category", "Other")
        )
        for category, ops_iter in groupby(
            operations_sorted, key=lambda op: op.get("category", "Other")
        ):
            for op in ops_iter:
                self._add_operation_item(op)

    def _add_operation_item(self, operation: dict):
        """Add operation to list."""
        item = QListWidgetItem(operation["name"])
        item.setData(Qt.UserRole, operation)
        self._operation_list.addItem(item)

    def _on_search_changed(self, text: str):
        """Handle search text changes with debouncing."""
        self._search_timer.stop()
        self._search_timer.start()

    def _perform_search(self):
        """Perform the actual search operation."""
        text = self._search_input.text().strip()
        self._operation_list.clear()

        if not text:
            self._populate_default_view()
            return

        results = self._registry.search_operations(text)
        if not results:
            item = QListWidgetItem(f"No operations match '{text}'")
            item.setFlags(Qt.NoItemFlags)
            self._operation_list.addItem(item)
        else:
            for op in results:
                self._add_operation_item(op)
            self._operation_list.setCurrentRow(0)

    def _on_current_item_changed(
        self, current: QListWidgetItem, previous: QListWidgetItem
    ):
        """Handle current item changed (for keyboard navigation)."""
        if current and current.data(Qt.UserRole):
            self._update_documentation(current.data(Qt.UserRole))

    def _on_item_hovered(self, item: QListWidgetItem):
        """Handle mouse hover over item."""
        if item and item.data(Qt.UserRole):
            # Set this item as current when hovering over it
            index = self._operation_list.row(item)
            if index >= 0:
                self._operation_list.setCurrentRow(index)
            self._update_documentation(item.data(Qt.UserRole))

    def _update_documentation(self, operation: dict):
        """Update documentation panel with operation info."""
        doc_text = format_operation_docs(operation)
        self._doc_panel.setPlainText(doc_text)

    def _on_operation_double_clicked(self, item: QListWidgetItem):
        """Handle double-click on operation."""
        operation = item.data(Qt.UserRole)
        if operation:
            self.operation_selected.emit(operation)
            self._search_input.setFocus()

    def keyPressEvent(self, event):
        """Handle keyboard shortcuts."""
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            current_item = self._operation_list.currentItem()
            if current_item and current_item.data(Qt.UserRole):
                self._on_operation_double_clicked(current_item)
        elif event.key() == Qt.Key_Escape:
            self._search_input.clear()
            self._search_input.setFocus()
        elif event.key() == Qt.Key_Slash or (
            event.key() == Qt.Key_F and event.modifiers() == Qt.ControlModifier
        ):
            self._search_input.setFocus()
            self._search_input.selectAll()
        else:
            super().keyPressEvent(event)

```

`ida_cyberchef/widgets/operation_search_dialog.py`:

```py
"""Dialog for searching and selecting operations."""

from typing import Optional

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QDialog,
    QHBoxLayout,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QPushButton,
    QVBoxLayout,
)

from ida_cyberchef.core.operation_registry import OperationRegistry


class OperationSearchDialog(QDialog):
    """Dialog for fuzzy searching operations.

    Layout:
    ┌─ Select Operation ────────────────────────────────────────────────┐
    │ ┌─ Search Input ────────────────────────────────────────────────┐ │
    │ │ Search operations...                                          │ │
    │ └───────────────────────────────────────────────────────────────┘ │
    │ ┌─ Results List ────────────────────────────────────────────────┐ │
    │ │ To Base64                                                     │ │
    │ │ From Base64                                                   │ │
    │ │ To Hex                                                        │ │
    │ │ From Hex                                                      │ │
    │ │ XOR                                                           │ │
    │ │ AES Decrypt                                                   │ │
    │ │ (more operations...)                                          │ │
    │ │                                                               │ │
    │ └───────────────────────────────────────────────────────────────┘ │
    │                                            [Select] [Cancel]      │
    └───────────────────────────────────────────────────────────────────┘
    """

    operation_selected = Signal(dict)

    def __init__(self, registry: OperationRegistry, parent=None):
        super().__init__(parent)

        self._registry = registry
        self._selected_operation = None

        self.setWindowTitle("Select Operation")
        self.resize(300, 400)

        self._setup_ui()
        self._populate_all_operations()

    def _setup_ui(self):
        """Setup dialog UI."""
        layout = QVBoxLayout(self)

        self._search_input = QLineEdit()
        self._search_input.setPlaceholderText("Search operations...")
        self._search_input.textChanged.connect(self._on_search_changed)
        layout.addWidget(self._search_input)

        self._results_list = QListWidget()
        self._results_list.itemDoubleClicked.connect(self._on_item_double_clicked)
        layout.addWidget(self._results_list)

        button_layout = QHBoxLayout()

        self._select_button = QPushButton("Select")
        self._select_button.clicked.connect(self._on_select_clicked)
        button_layout.addWidget(self._select_button)

        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(cancel_button)

        layout.addLayout(button_layout)

        self._search_input.setFocus()

    def _populate_all_operations(self):
        """Populate list with all operations."""
        self._results_list.clear()

        operations = self._registry.get_all_operations()
        for op in operations:
            item = QListWidgetItem(op["name"])
            item.setData(Qt.UserRole, op)
            self._results_list.addItem(item)

    def _on_search_changed(self, text: str):
        """Handle search text changes."""
        self._results_list.clear()

        if not text.strip():
            self._populate_all_operations()
            return

        results = self._registry.search_operations(text)
        for op in results:
            item = QListWidgetItem(op["name"])
            item.setData(Qt.UserRole, op)
            self._results_list.addItem(item)

        if self._results_list.count() > 0:
            self._results_list.setCurrentRow(0)

    def _on_item_double_clicked(self, item: QListWidgetItem):
        """Handle double-click on item."""
        self._selected_operation = item.data(Qt.UserRole)
        self.accept()

    def _on_select_clicked(self):
        """Handle select button click."""
        current_item = self._results_list.currentItem()
        if current_item:
            self._selected_operation = current_item.data(Qt.UserRole)
            self.accept()

    def get_selected_operation(self) -> Optional[dict]:
        """Get selected operation.

        Returns: Operation dict or None if cancelled
        """
        return self._selected_operation

    def keyPressEvent(self, event):
        """Handle key presses."""
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            self._on_select_clicked()
        else:
            super().keyPressEvent(event)

```

`ida_cyberchef/widgets/operation_step_widget.py`:

```py
"""Widget for displaying and editing a single recipe step."""

import json
from typing import Any, Dict

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QCheckBox,
    QComboBox,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QSizePolicy,
    QSpinBox,
    QTextEdit,
    QWidget,
)

from ida_cyberchef.core.hex_formatter import HexFormatter


class OperationStepWidget(QFrame):
    """Frame widget for single recipe operation step.

    Layout:
    ┌─────────────────────────────────────────────────────────────────────┐
    │ Operation Name  │  Label (80px):  │ Widget spanning cols 2-3       │
    │ (bold, 100px)   │  Another:       │ Input field    │ Dropdown      │
    │      [✕]        │  ☑ Checkbox (no label, self-labeled)             │
    │                 │  Multiline:     │ Text edit spanning 2 columns   │
    ├─────────────────┼──────────────────────────────────────────────────┤
    │ ┌─ Preview (collapsible, 150px max height) ───────────────────────┐ │
    │ │ 00000000: 48 65 6c 6c 6f 20 77 6f  72 6c 64 21  Hello world!    │ │
    │ └─────────────────────────────────────────────────────────────────┘ │
    ├─────────────────────────────────────────────────────────────────────┤
    │ Error: Operation failed (red, bold, hidden by default)              │
    └─────────────────────────────────────────────────────────────────────┘
    """

    args_changed = Signal(int, dict)
    delete_requested = Signal(int)
    preview_toggled = Signal(int, bool)

    def __init__(self, index: int, operation: dict, parent=None):
        super().__init__(parent)

        self._index = index
        self._operation = operation
        self._arg_widgets: Dict[str, QWidget] = {}
        self._preview_visible = False
        self._error_visible = False

        self._hex_formatter = HexFormatter()

        self._setup_ui()

    def _setup_ui(self):
        """Setup widget UI."""
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        self.setObjectName("OperationStepWidget")
        self.setStyleSheet("""
            QFrame#OperationStepWidget {
                border: 1px solid #505050;
                border-radius: 4px;
                padding: 4px;
            }
        """)

        # Main grid layout with 7 columns
        # 0: Operation name | 1: Labels | 2: Inputs | 3: Secondary | 4: Spacer | 5: Preview | 6: Delete
        main_layout = QGridLayout(self)
        main_layout.setContentsMargins(4, 4, 4, 4)
        main_layout.setSpacing(2)
        main_layout.setHorizontalSpacing(4)
        main_layout.setVerticalSpacing(2)

        # Set column stretch: only column 4 (spacer) expands
        main_layout.setColumnStretch(0, 0)  # Operation name
        main_layout.setColumnStretch(1, 0)  # Arg labels
        main_layout.setColumnStretch(2, 0)  # Input widgets
        main_layout.setColumnStretch(3, 0)  # Secondary widgets
        main_layout.setColumnStretch(4, 1)  # Spacer (expands)
        main_layout.setColumnStretch(5, 0)  # Preview button
        main_layout.setColumnStretch(6, 0)  # Delete button

        # Set column minimum widths
        main_layout.setColumnMinimumWidth(0, 100)  # Operation name
        main_layout.setColumnMinimumWidth(1, 80)  # Arg labels
        main_layout.setColumnMinimumWidth(2, 100)  # Input widgets
        main_layout.setColumnMinimumWidth(5, 18)  # Preview button
        main_layout.setColumnMinimumWidth(6, 18)  # Delete button

        # Operation name label at (0, 0) - no spanning, fixed 100px width
        name_label = QLabel(self._operation["name"])
        name_label.setStyleSheet("font-weight: bold;")
        name_label.setWordWrap(True)
        name_label.setFixedWidth(100)
        name_label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)
        name_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        main_layout.addWidget(name_label, 0, 0)

        # Preview button at (0, 5) - no spanning
        self._preview_button = QPushButton("▼")
        self._preview_button.setToolTip("Preview the data")
        self._preview_button.setFixedSize(16, 16)
        self._preview_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid #505050;
                border-radius: 8px;
                color: #666666;
                font-size: 10px;
            }
            QPushButton:hover {
                color: #2196F3;
                border-color: #2196F3;
            }
        """)
        self._preview_button.clicked.connect(self._on_preview_clicked)
        main_layout.addWidget(self._preview_button, 0, 5, Qt.AlignTop)

        # Delete button at (0, 6) - no spanning
        delete_button = QPushButton("✕")
        delete_button.setFixedSize(16, 16)
        delete_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid #505050;
                border-radius: 8px;
                color: #666666;
                font-size: 12px;
            }
            QPushButton:hover {
                color: #2196F3;
                border-color: #2196F3;
            }
        """)
        delete_button.clicked.connect(lambda: self.delete_requested.emit(self._index))
        main_layout.addWidget(delete_button, 0, 6, Qt.AlignTop)

        # Args grid will be populated in columns 1-3
        self._args_grid = main_layout
        self._args_grid.setColumnMinimumWidth(1, 80)

        self._populate_args_grid()

        # Calculate next row for preview/error widgets
        arg_count = len(self._operation.get("args", []))
        next_row = arg_count if arg_count > 0 else 1

        # Preview widget (spans all 7 columns)
        self._preview_widget = QTextEdit()
        self._preview_widget.setReadOnly(True)
        self._preview_widget.setMaximumHeight(150)
        self._preview_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self._preview_widget.setVisible(False)
        self._preview_widget.setStyleSheet(
            "font-family: 'Courier New', Courier, monospace; margin-top: 8px;"
        )
        main_layout.addWidget(self._preview_widget, next_row, 0, 1, 7)

        # Error label (spans all 7 columns)
        self._error_label = QLabel()
        self._error_label.setStyleSheet("color: red; font-weight: bold;")
        self._error_label.setVisible(False)
        self._error_label.setWordWrap(True)
        self._error_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
        main_layout.addWidget(self._error_label, next_row + 1, 0, 1, 7)

    def _populate_args_grid(self):
        """Populate grid with argument widgets and labels."""
        row = 0  # Start at row 0 (same row as operation name)

        for arg in self._operation.get("args", []):
            arg_type = arg.get("type", "string")
            arg_name = arg["name"]

            widget = self._create_arg_widget(arg)
            self._arg_widgets[arg_name] = widget

            # Boolean checkbox is self-labeled, no separate label needed
            if arg_type == "boolean":
                self._args_grid.addWidget(widget, row, 2, 1, 2)

            # ToggleString needs 3 columns: label | input | format dropdown
            elif arg_type == "toggleString":
                label = QLabel(arg_name + ":")
                label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
                label.setStyleSheet("color: #666;")
                label.setWordWrap(True)
                label.setFixedWidth(80)
                self._args_grid.addWidget(label, row, 1)

                # Widget is container with value_input and format_combo
                # We need to extract and place them separately
                value_input = widget.property("value_input")
                format_combo = widget.property("format_combo")

                if value_input:
                    self._args_grid.addWidget(value_input, row, 2)
                if format_combo:
                    self._args_grid.addWidget(format_combo, row, 3)

            # Text/multiline: label | text edit spanning 2 columns
            elif arg_type in ("text", "binaryString"):
                label = QLabel(arg_name + ":")
                label.setAlignment(Qt.AlignRight | Qt.AlignTop)
                label.setStyleSheet("color: #666;")
                label.setWordWrap(True)
                label.setFixedWidth(80)
                self._args_grid.addWidget(label, row, 1)
                self._args_grid.addWidget(widget, row, 2, 1, 2)

            # Label type: no label, just display widget
            elif arg_type == "label":
                self._args_grid.addWidget(widget, row, 2, 1, 2)

            # All other types: label | widget spanning columns 2-3
            else:
                label = QLabel(arg_name + ":")
                label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
                label.setStyleSheet("color: #666;")
                label.setWordWrap(True)
                label.setFixedWidth(80)
                self._args_grid.addWidget(label, row, 1)
                self._args_grid.addWidget(widget, row, 2, 1, 2)

            row += 1

    def _parse_json_value(self, value: Any) -> Any:
        """Parse JSON-encoded value if it's a string.

        Args:
            value: Value from schema (may be JSON-encoded string)

        Returns: Parsed value or original if not JSON
        """
        if isinstance(value, str):
            try:
                return json.loads(value)
            except (json.JSONDecodeError, ValueError):
                return value
        return value

    def _create_arg_widget(self, arg: dict) -> QWidget:
        """Create appropriate widget for argument type.

        Args:
            arg: Argument definition dict

        Returns: Widget for editing argument value
        """
        arg_type = arg.get("type", "string")
        raw_value = arg.get("value", "")
        parsed_value = self._parse_json_value(raw_value)

        # Boolean checkbox
        if arg_type == "boolean":
            widget = QCheckBox(arg["name"])
            widget.setChecked(parsed_value if isinstance(parsed_value, bool) else False)
            # Connect signal AFTER setting initial value
            widget.stateChanged.connect(self._on_arg_changed)
            return widget

        # Number spinner
        elif arg_type == "number":
            widget = QSpinBox()
            widget.setValue(
                int(parsed_value) if isinstance(parsed_value, (int, float)) else 0
            )
            widget.setRange(-999999, 999999)
            widget.setMaximumWidth(100)
            # Connect signal AFTER setting initial value
            widget.valueChanged.connect(self._on_arg_changed)
            return widget

        # Option dropdown (JSON array of choices)
        elif arg_type == "option":
            widget = QComboBox()
            if isinstance(parsed_value, list):
                # Schema default: value is array of choices
                widget.addItems(parsed_value)
                widget.setCurrentIndex(0)

                # If there's a saved selection, use it
                saved = arg.get("saved_value")
                if saved and saved in parsed_value:
                    widget.setCurrentText(saved)
            elif isinstance(parsed_value, str):
                # Fallback: value is a single string (shouldn't happen with new recipe_panel)
                widget.addItem(parsed_value)

            widget.setMaximumWidth(200)
            widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            widget.currentTextChanged.connect(self._on_arg_changed)
            return widget

        # Editable option dropdown
        elif arg_type in ("editableOption", "editableOptionShort"):
            widget = QComboBox()
            widget.setEditable(True)
            if isinstance(parsed_value, list):
                widget.addItems(parsed_value)
                widget.setCurrentIndex(0)

                saved = arg.get("saved_value")
                if saved:
                    # For editable, saved might not be in list
                    widget.setCurrentText(saved)
            elif isinstance(parsed_value, str):
                widget.addItem(parsed_value)

            widget.setMaximumWidth(200)
            widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            widget.currentTextChanged.connect(self._on_arg_changed)
            return widget

        # Toggle string (value input + format dropdown)
        elif arg_type == "toggleString":
            container = QWidget()
            layout = QHBoxLayout(container)
            layout.setContentsMargins(0, 0, 0, 0)

            # Check for saved_value first (takes precedence when reloading)
            saved_value = arg.get("saved_value")
            value_to_use = saved_value if saved_value is not None else parsed_value

            # Extract string and option from dict or use raw value
            if isinstance(value_to_use, dict):
                string_value = value_to_use.get("string", "")
                selected_option = value_to_use.get("option", "")
            else:
                string_value = str(value_to_use) if value_to_use else ""
                selected_option = ""

            # Value input
            value_input = QLineEdit()
            value_input.setPlaceholderText(arg["name"])
            value_input.setText(string_value)
            value_input.setMaximumWidth(200)
            value_input.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            value_input.textChanged.connect(self._on_arg_changed)
            layout.addWidget(value_input)

            # Format dropdown
            toggle_values = self._parse_json_value(arg.get("toggleValues", "[]"))
            format_combo = None
            if isinstance(toggle_values, list) and toggle_values:
                format_combo = QComboBox()
                format_combo.addItems(toggle_values)
                format_combo.setMaximumWidth(100)
                layout.addWidget(format_combo)

                # Set saved option or default to first
                if selected_option and selected_option in toggle_values:
                    format_combo.setCurrentText(selected_option)
                else:
                    format_combo.setCurrentIndex(0)

                # Connect signal AFTER setting initial selection
                format_combo.currentTextChanged.connect(self._on_arg_changed)

            # Store both widgets in container's properties
            container.setProperty("value_input", value_input)
            container.setProperty("format_combo", format_combo)
            return container

        # Arg selector (mode dropdown with conditional args)
        elif arg_type == "argSelector":
            widget = QComboBox()
            if isinstance(parsed_value, list):
                mode_names = [
                    mode.get("name", f"Mode {i}")
                    if isinstance(mode, dict)
                    else str(mode)
                    for i, mode in enumerate(parsed_value)
                ]
                widget.addItems(mode_names)
                widget.setCurrentIndex(0)
            widget.setMaximumWidth(200)
            widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            widget.currentTextChanged.connect(self._on_arg_changed)
            return widget

        # Label (display-only)
        elif arg_type == "label":
            widget = QLabel(str(parsed_value))
            return widget

        # Text/multiline string
        elif arg_type in ("text", "binaryString"):
            widget = QTextEdit()
            widget.setPlainText(str(parsed_value) if parsed_value else "")
            widget.setMaximumHeight(80)
            widget.setMaximumWidth(300)
            widget.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            widget.textChanged.connect(self._on_arg_changed)
            return widget

        # Enum (legacy, kept for compatibility)
        elif arg_type == "enum":
            widget = QComboBox()
            widget.addItems(arg.get("options", []))
            current = str(parsed_value) if parsed_value else ""
            if current in arg.get("options", []):
                widget.setCurrentText(current)
            widget.setMaximumWidth(200)
            widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            widget.currentTextChanged.connect(self._on_arg_changed)
            return widget

        # Default: string/shortString/binaryShortString
        else:
            widget = QLineEdit()
            widget.setPlaceholderText(arg["name"])
            widget.setText(str(parsed_value) if parsed_value else "")
            widget.setMaximumWidth(200)
            widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            # Connect signal AFTER setting initial value
            widget.textChanged.connect(self._on_arg_changed)
            return widget

    def _on_arg_changed(self):
        """Handle argument value changes."""
        args = self.get_current_args()
        self.args_changed.emit(self._index, args)

    def _on_preview_clicked(self):
        """Handle preview button click."""
        self._preview_visible = not self._preview_visible
        self._preview_widget.setVisible(self._preview_visible)
        self.preview_toggled.emit(self._index, self._preview_visible)

    def get_current_args(self) -> Dict[str, Any]:
        """Get current argument values.

        Returns: Dict of argument name -> value
        """
        args = {}

        for arg in self._operation.get("args", []):
            arg_name = arg["name"]
            arg_type = arg.get("type", "string")
            widget = self._arg_widgets[arg_name]

            # Boolean checkbox
            if isinstance(widget, QCheckBox):
                args[arg_name] = widget.isChecked()

            # Number spinner
            elif isinstance(widget, QSpinBox):
                args[arg_name] = widget.value()

            # Combobox (option, editableOption, argSelector, enum)
            elif isinstance(widget, QComboBox):
                args[arg_name] = widget.currentText()

            # Text edit (text, binaryString)
            elif isinstance(widget, QTextEdit):
                args[arg_name] = widget.toPlainText()

            # Label (display-only, no value)
            elif isinstance(widget, QLabel):
                args[arg_name] = widget.text()

            # Compound toggleString widget
            elif arg_type == "toggleString":
                value_input = widget.property("value_input")
                format_combo = widget.property("format_combo")
                if value_input:
                    value = value_input.text()
                    # If format combo exists, CyberChef expects dict with value and option
                    if format_combo:
                        args[arg_name] = {
                            "string": value,
                            "option": format_combo.currentText(),
                        }
                    else:
                        args[arg_name] = value

            # Line edit (default for string types)
            elif isinstance(widget, QLineEdit):
                args[arg_name] = widget.text()

            # Fallback
            else:
                args[arg_name] = ""

        return args

    def set_preview_data(self, data: bytes):
        """Set preview data to display.

        Args:
            data: Bytes to display as hex dump
        """
        hex_dump = self._hex_formatter.format_hex_dump(data)
        self._preview_widget.setPlainText(hex_dump)

    def set_error(self, error: str):
        """Set error state and message.

        Args:
            error: Error message
        """
        self._error_visible = True
        self._error_label.setText(f"Error: {error}")
        self._error_label.setVisible(True)

        if not self._preview_visible:
            self._on_preview_clicked()

        self.setStyleSheet("""
            QFrame#OperationStepWidget {
                border: 1px solid #ff0000;
                border-radius: 4px;
                padding: 4px;
            }
        """)

    def clear_error(self):
        """Clear error state."""
        self._error_visible = False
        self._error_label.setVisible(False)
        self.setStyleSheet("""
            QFrame#OperationStepWidget {
                border: 1px solid #505050;
                border-radius: 4px;
                padding: 4px;
            }
        """)

```

`ida_cyberchef/widgets/output_panel.py`:

```py
"""Output panel widget for displaying results."""

import logging

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QResizeEvent
from PySide6.QtWidgets import (
    QApplication,
    QComboBox,
    QFileDialog,
    QHBoxLayout,
    QMessageBox,
    QPushButton,
    QSizePolicy,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from ida_cyberchef.core.hex_formatter import HexFormatter
from ida_cyberchef.qt_models.execution_model import ExecutionModel
from ida_cyberchef.qt_models.input_model import InputModel, InputSource

logger = logging.getLogger(__name__)


class OutputPanel(QWidget):
    """Panel for displaying output and actions.

    Layout:
    ┌──────────────────────────────────────────────────────────────────────┐
    │ ┌─ Output Display (monospace, read-only) ──────────────────────────┐ │
    │ │ 00000000: 48 65 6c 6c 6f 20 77 6f  72 6c 64 21  Hello world!     │ │
    │ │ 00000010: 0a                                     .               │ │
    │ │                                                                  │ │
    │ │ Output will appear here...                                       │ │
    │ └──────────────────────────────────────────────────────────────────┘ │
    ├──────────────────────────────────────────────────────────────────────┤
    │ [Copy to Clipboard] [Save to File]   [Copy to DB] [Set Comment]      │
    │                                       (enabled)    (disabled)        │
    └──────────────────────────────────────────────────────────────────────┘

    Note: Copy to DB button is enabled when input source is FROM_SELECTION or FROM_LOCATION.

    Signals:
        copy_to_db_requested: Emitted when user requests to copy output to IDB.
            Args: (address: int, data: bytes)
        set_comment_requested: Emitted when user requests to set a comment.
            Args: (text: str)
    """

    copy_to_db_requested = Signal(int, bytes)
    set_comment_requested = Signal(str)

    def __init__(
        self,
        execution_model: ExecutionModel,
        input_model: InputModel,
        parent=None,
        show_ida_buttons: bool = False,
    ):
        """Initialize OutputPanel.

        Args:
            execution_model: Model for recipe execution
            input_model: Model for input data
            parent: Parent widget
            show_ida_buttons: Whether to show IDA-specific buttons (Copy to DB, Set Comment)
        """
        super().__init__(parent)

        self._execution_model = execution_model
        self._input_model = input_model
        self._hex_formatter = HexFormatter()
        self._current_output: bytes | str = b""
        self._show_ida_buttons = show_ida_buttons

        self._setup_ui()
        self._connect_signals()

    def _setup_ui(self):
        """Setup panel UI."""
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(4)

        self._output_display = QTextEdit()
        self._output_display.setReadOnly(True)
        self._output_display.setStyleSheet(
            "font-family: 'Courier New', Courier, monospace;"
        )
        self._output_display.setPlaceholderText("Output will appear here...")
        self._output_display.setMinimumHeight(100)
        self._output_display.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self._output_display.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        main_layout.addWidget(self._output_display)

        # Output format combo box (overlay in bottom-right)
        self._output_format_combo = QComboBox(self)
        self._output_format_combo.addItems(
            [
                "Hex Dump",
                "Text",
                "Hex String (Unspaced)",
                "Hex String (Spaced)",
                "String Literal",
                "C Array (Hex)",
                "C Array (Decimal)",
                "C Variable",
            ]
        )
        self._output_format_combo.setMinimumWidth(150)
        self._output_format_combo.currentTextChanged.connect(self._on_format_changed)
        self._output_format_combo.raise_()

        button_container = QWidget()
        button_container.setFixedWidth(45)
        button_container.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        button_layout = QVBoxLayout(button_container)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.setSpacing(4)

        self._copy_button = QPushButton("📋")
        self._copy_button.setToolTip("Copy to clipboard")
        self._copy_button.clicked.connect(self._on_copy_clicked)
        button_layout.addWidget(self._copy_button)

        self._save_button = QPushButton("💾")
        self._save_button.setToolTip("Save to file")
        self._save_button.clicked.connect(self._on_save_clicked)
        button_layout.addWidget(self._save_button)

        if self._show_ida_buttons:
            self._copy_db_button = QPushButton("➡️")
            self._copy_db_button.setToolTip(
                "Copy to IDB (only available when input source is 'From Selection' or 'From Location')"
            )
            self._copy_db_button.setEnabled(False)
            self._copy_db_button.clicked.connect(self._on_copy_db_clicked)
            button_layout.addWidget(self._copy_db_button)

            self._set_comment_button = QPushButton("💬")
            self._set_comment_button.setToolTip("Set comment at cursor")
            self._set_comment_button.setEnabled(False)
            self._set_comment_button.clicked.connect(self._on_set_comment_clicked)
            button_layout.addWidget(self._set_comment_button)
        else:
            self._copy_db_button = None
            self._set_comment_button = None

        button_layout.addStretch()

        main_layout.addWidget(button_container)

    def resizeEvent(self, event: QResizeEvent) -> None:
        """Reposition overlay combo box on resize."""
        super().resizeEvent(event)

        # Position combo box in bottom-right of output display
        # Only position if there's enough horizontal space to avoid overlap
        if self._output_display.width() > 200:
            combo_width = self._output_format_combo.width()
            combo_height = self._output_format_combo.height()

            # Get output display geometry
            display_rect = self._output_display.geometry()

            x = display_rect.right() - combo_width - 10
            y = display_rect.bottom() - combo_height - 6

            self._output_format_combo.move(x, y)

    def _connect_signals(self):
        """Connect signals and slots."""
        self._execution_model.execution_completed.connect(self._update_output)
        self._input_model.source_changed.connect(self._on_input_source_changed)
        self._on_input_source_changed(self._input_model.get_input_source())

    def _update_output(self):
        """Update output display with execution results."""
        result = self._execution_model.get_final_result()

        if result and result.success and result.data is not None:
            self._current_output = result.data
            self._auto_select_format(result.data)
            self._render_output(result.data)
            if self._set_comment_button is not None:
                self._set_comment_button.setEnabled(True)
        elif result and not result.success:
            self._current_output = b""
            self._output_display.setPlainText(f"Error: {result.error}")
            if self._set_comment_button is not None:
                self._set_comment_button.setEnabled(False)
        else:
            self._current_output = b""
            self._output_display.clear()
            if self._set_comment_button is not None:
                self._set_comment_button.setEnabled(False)

    def _render_output(self, data: bytes | str):
        """Render output data using selected format.

        Args:
            data: Bytes or string to render
        """
        format_name = self._output_format_combo.currentText()

        if format_name == "Text":
            if isinstance(data, str):
                formatted = data
            else:
                try:
                    formatted = data.decode("utf-8")
                except UnicodeDecodeError:
                    formatted = data.decode("utf-8", errors="replace")
        else:
            if isinstance(data, str):
                data_bytes = data.encode("utf-8")
            else:
                data_bytes = data

            if format_name == "Hex Dump":
                formatted = self._hex_formatter.format_hex_dump(data_bytes)
            elif format_name == "Hex String (Unspaced)":
                formatted = self._hex_formatter.format_hex_string_unspaced(data_bytes)
            elif format_name == "Hex String (Spaced)":
                formatted = self._hex_formatter.format_hex_string_spaced(data_bytes)
            elif format_name == "String Literal":
                formatted = self._hex_formatter.format_string_literal(data_bytes)
            elif format_name == "C Array (Hex)":
                formatted = self._hex_formatter.format_c_uchar_array_hex(data_bytes)
            elif format_name == "C Array (Decimal)":
                formatted = self._hex_formatter.format_c_uchar_array_decimal(data_bytes)
            elif format_name == "C Variable":
                formatted = self._hex_formatter.format_c_initialized_variable(
                    data_bytes
                )
            else:
                formatted = self._hex_formatter.format_hex_dump(data_bytes)

        self._output_display.setPlainText(formatted)

    def _on_format_changed(self):
        """Handle output format change."""
        # Re-render current output with new format
        if self._current_output:
            self._render_output(self._current_output)

    def _auto_select_format(self, data: bytes | str):
        """Auto-select output format based on data type.

        Args:
            data: Output data (str for text, bytes for binary)
        """
        if isinstance(data, str):
            self._output_format_combo.setCurrentText("Text")
        else:
            self._output_format_combo.setCurrentText("Hex Dump")

    def _on_copy_clicked(self):
        """Handle copy to clipboard."""
        if self._current_output:
            clipboard = QApplication.clipboard()
            clipboard.setText(self._output_display.toPlainText())

            QMessageBox.information(
                self,
                "Copied",
                "Copied formatted output to clipboard",
            )

    def _on_save_clicked(self):
        """Handle save to file."""
        if not self._current_output:
            return

        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Output", "", "All Files (*)"
        )

        if filename:
            try:
                data_to_write = (
                    self._current_output.encode("utf-8")
                    if isinstance(self._current_output, str)
                    else self._current_output
                )

                with open(filename, "wb") as f:
                    f.write(data_to_write)

                QMessageBox.information(
                    self,
                    "Saved",
                    f"Saved {len(data_to_write)} bytes to {filename}",
                )
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save file: {e}")

    def _on_input_source_changed(self, source: InputSource):
        """Handle input source change to enable/disable Copy to IDB button.

        Args:
            source: The new input source
        """
        if self._copy_db_button is None:
            return

        if source in (InputSource.FROM_SELECTION, InputSource.FROM_LOCATION):
            self._copy_db_button.setEnabled(True)
            self._copy_db_button.setToolTip("Copy to IDB")
        else:
            self._copy_db_button.setEnabled(False)
            self._copy_db_button.setToolTip(
                "Copy to IDB (only available when input source is 'From Selection' or 'From Location')"
            )

    def _on_copy_db_clicked(self):
        """Handle copy to IDB action.

        Emits copy_to_db_requested signal with address and data.
        Only works when input source is FROM_SELECTION or FROM_LOCATION.
        """
        if not self._current_output:
            logger.warning("No output available to copy to IDB")
            return

        if isinstance(self._current_output, str):
            QMessageBox.warning(
                self,
                "Invalid Output Type",
                "Cannot copy string output to IDB. Only binary data can be patched.",
            )
            return

        address = self._input_model.get_external_address()
        if address is None:
            logger.warning(
                "Cannot determine address to patch (no selection address stored)"
            )
            return

        self.copy_to_db_requested.emit(address, self._current_output)

    def _on_set_comment_clicked(self):
        """Handle set comment at cursor action.

        Emits set_comment_requested signal with comment text.
        """
        comment_text = self._output_display.toPlainText()
        self.set_comment_requested.emit(comment_text)

```

`ida_cyberchef/widgets/recipe_panel.py`:

```py
"""Recipe panel widget for managing recipe steps."""

import json
from typing import Any, List

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QFrame, QScrollArea, QVBoxLayout, QWidget

from ida_cyberchef.core.operation_registry import OperationRegistry
from ida_cyberchef.qt_models.execution_model import ExecutionModel
from ida_cyberchef.qt_models.recipe_model import RecipeModel
from ida_cyberchef.widgets.insert_indicator_widget import InsertIndicatorWidget
from ida_cyberchef.widgets.operation_search_dialog import OperationSearchDialog
from ida_cyberchef.widgets.operation_step_widget import OperationStepWidget


class RecipePanel(QWidget):
    """Panel for recipe step management.

    Layout:
    ┌─────────────────────────────────────────────────────────────────────┐
    │ ┌─ Scroll Area ───────────────────────────────────────────────────┐ │
    │ │                        ⊕────────────────                        │ │
    │ │ ┌─ OperationStepWidget ──────────────────────────────────────┐  │ │
    │ │ │ To Base64                           [Preview ▼] [✕]       ││  │ │
    │ │ │  Alphabet: │ A-Za-z0-9+/=                                 ││  │ │
    │ │ └────────────────────────────────────────────────────────────┘  │ │
    │ │                        ⊕────────────────                        │ │
    │ │ ┌─ OperationStepWidget ──────────────────────────────────────┐  │ │
    │ │ │ XOR                                 [Preview ▼] [✕]       ││  │ │
    │ │ │  Key:      │ secret               │ UTF8                  ││  │ │
    │ │ │  Scheme:   │ Standard                                     ││  │ │
    │ │ └────────────────────────────────────────────────────────────┘  │ │
    │ │                        ⊕────────────────                        │ │
    │ │ (more steps...)                                                 │ │
    │ └─────────────────────────────────────────────────────────────────┘ │
    └─────────────────────────────────────────────────────────────────────┘

    Operations are added via the persistent Operation Browser Widget at bottom.
    """

    def __init__(
        self,
        recipe_model: RecipeModel,
        execution_model: ExecutionModel,
        registry: OperationRegistry,
        parent=None,
    ):
        super().__init__(parent)

        self._recipe_model = recipe_model
        self._execution_model = execution_model
        self._registry = registry

        self._step_widgets: List[OperationStepWidget] = []

        self._setup_ui()
        self._connect_signals()

    def _setup_ui(self):
        """Setup panel UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.NoFrame)
        scroll.setContentsMargins(0, 0, 0, 0)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)

        self._steps_container = QWidget()
        self._steps_layout = QVBoxLayout(self._steps_container)
        self._steps_layout.setContentsMargins(0, 0, 0, 0)
        self._steps_layout.setSpacing(4)

        scroll.setWidget(self._steps_container)
        layout.addWidget(scroll)

    def _connect_signals(self):
        """Connect signals and slots."""
        self._recipe_model.rowsInserted.connect(self._refresh_display)
        self._recipe_model.rowsRemoved.connect(self._refresh_display)
        self._recipe_model.modelReset.connect(self._refresh_display)

        self._execution_model.execution_completed.connect(self._update_results)

    def _refresh_display(self):
        """Refresh the display of recipe steps."""
        while self._steps_layout.count():
            item = self._steps_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self._step_widgets.clear()

        steps = self._recipe_model.get_recipe_steps()

        for i, step in enumerate(steps):
            insert_indicator = InsertIndicatorWidget()
            insert_indicator.clicked.connect(
                lambda idx=i: self._show_operation_dialog(idx)
            )
            self._steps_layout.addWidget(insert_indicator)

            op_info = self._registry.find_operation(step["operation"])
            if op_info:
                op_with_args = op_info.copy()
                op_with_args["args"] = [
                    arg.copy() for arg in op_with_args["args"]
                ]  # Deep copy args

                for arg in op_with_args["args"]:
                    if arg["name"] in step["args"]:
                        # Store saved value in separate field, preserve schema value
                        arg["saved_value"] = step["args"][arg["name"]]

                widget = OperationStepWidget(i, op_with_args)
                widget.args_changed.connect(self._on_args_changed)
                widget.delete_requested.connect(self._on_delete_requested)
                widget.preview_toggled.connect(self._on_preview_toggled)

                self._steps_layout.addWidget(widget)
                self._step_widgets.append(widget)

        self._steps_layout.addStretch()

    def _get_default_arg_value(self, arg: dict) -> Any:
        """Extract default value from argument definition.

        Args:
            arg: Argument definition from schema

        Returns: Appropriate default value for CyberChef
        """
        arg_type = arg.get("type", "string")
        raw_value = arg.get("value", "")

        # Parse JSON if it's a string
        try:
            parsed_value = (
                json.loads(raw_value) if isinstance(raw_value, str) else raw_value
            )
        except (json.JSONDecodeError, ValueError):
            parsed_value = raw_value

        # Extract sensible defaults based on type
        if arg_type in ("option", "editableOption", "editableOptionShort"):
            # For options, take first item from array
            if isinstance(parsed_value, list) and parsed_value:
                return parsed_value[0]
            return parsed_value

        elif arg_type == "toggleString":
            # For toggleString, return dict with string and option
            toggle_values = arg.get("toggleValues", "[]")
            try:
                toggle_list = (
                    json.loads(toggle_values)
                    if isinstance(toggle_values, str)
                    else toggle_values
                )
            except (json.JSONDecodeError, ValueError):
                toggle_list = []

            if isinstance(toggle_list, list) and toggle_list:
                return {
                    "string": parsed_value if parsed_value else "",
                    "option": toggle_list[0],
                }
            return parsed_value

        elif arg_type == "argSelector":
            # For argSelector, take first mode name
            if isinstance(parsed_value, list) and parsed_value:
                first_mode = parsed_value[0]
                if isinstance(first_mode, dict):
                    return first_mode.get("name", "")
            return parsed_value

        # For other types, return parsed value as-is
        return parsed_value

    def _show_operation_dialog(self, insert_index: int):
        """Show operation selection dialog.

        Args:
            insert_index: Index to insert at (-1 = append)
        """
        dialog = OperationSearchDialog(self._registry, self)
        if dialog.exec():
            op = dialog.get_selected_operation()
            if op:
                args = {}
                for arg in op.get("args", []):
                    args[arg["name"]] = self._get_default_arg_value(arg)

                self._recipe_model.add_operation(op["name"], args, insert_index)

    def _on_args_changed(self, index: int, args: dict):
        """Handle argument changes."""
        self._recipe_model.update_operation_args(index, args)

    def _on_delete_requested(self, index: int):
        """Handle delete request."""
        self._recipe_model.remove_operation(index)

    def _on_preview_toggled(self, index: int, expanded: bool):
        """Handle preview toggle."""
        if expanded:
            self._execution_model.schedule_execution()

    def _update_results(self):
        """Update step widgets with execution results."""
        results = self._execution_model.get_results()

        for i, widget in enumerate(self._step_widgets):
            if i < len(results):
                result = results[i]

                if result.success and result.data is not None:
                    widget.clear_error()
                    preview_bytes = (
                        result.data.encode("utf-8")
                        if isinstance(result.data, str)
                        else result.data
                    )
                    widget.set_preview_data(preview_bytes)
                elif not result.success and result.error is not None:
                    widget.set_error(result.error)

```

`justfile`:

```
install-npm:
    cd deps/CyberChef && npm install


build: install-npm
    # outputs to deps/CyberChef/build/node/CyberChef.js
    # takes around 40s
    cd deps/CyberChef && npm run node
    cp deps/CyberChef/build/node/CyberChef.js ida_cyberchef/data/CyberChef.js


clean:
    rm -rf deps/CyberChef/build ida_cyberchef/data/CyberChef.js

```

`pyproject.toml`:

```toml
[project]
name = "ida-cyberchef"
version = "0.1.0"
description = "A Qt-based CyberChef interface designed for malware analysis workflows, particularly in IDA Pro"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "pydantic>=2.0",
    "pyside6>=6.10.0",
    "rich>=13.0.0",
    "stpyv8>=13.1.201.22",
]

[dependency-groups]
dev = [
    "pytest>=8.4.2",
    "pytest-qt>=4.0",
]

[tool.setuptools.packages.find]
where = ["ida_cyberchef"]

[project.scripts]
cyberchef-qt = "ida_cyberchef.main:main"

[tool.pytest.ini_options]
pythonpath = "."

```

`readme.md`:

```md
# IDA CyberChef

A Qt-based CyberChef interface designed for malware analysis workflows, particularly in IDA Pro. This brings the power of [CyberChef](https://gchq.github.io/CyberChef/)'s data transformation operations directly into your reverse engineering toolkit.

**Install it** via Hex-Rays' IDA Pro plugin manager:

```console
hcli plugin install ida-cyberchef
```

[HCLI](https://hcli.docs.hex-rays.com) is the official Hex-Rays tool for managing IDA Pro installations, licenses, and SDKs.

![ida-cyberchef screenshot](docs/screenshot1.png)


## What is this?

If you've ever been knee-deep in a malware sample and needed to quickly decode some base64, XOR a blob with a key, or chain together a series of transformations on binary data - you know the pain of context switching. Copy data from IDA, paste into CyberChef web UI, get result, copy back. Repeat 47 times.

This project eliminates that workflow. It embeds CyberChef's JavaScript engine directly into IDA Pro's Qt user interface, integrating with common IDA features, like reading the current cursor/selection, settings comments, and patching bytes.

## How it works

We use [STPyV8](https://github.com/area1/stpyv8) to run CyberChef's JavaScript code inside Python. The `ida_cyberchef.cyberchef` module loads CyberChef's bundle, sets up polyfills for browser/Node.js APIs it expects, and exposes a clean `bake()` function that takes binary data and a recipe.

Then, we have a PySide6 Qt widget that exposes the recipe composer with the input/output hex dumps. The UI updates reactively - change the input or tweak an operation argument, and after a brief debounce, the entire pipeline re-executes and updates the output.

As a minor extension beyond traditional CyberChef, each operation step can be expanded to preview intermediate results, which might be useful for debugging complex recipes.

## Background

This started as an experiment to see if CyberChef could be embedded in Python without needing a browser or Electron. The GCHQ team built CyberChef as a web application, but they also exposed a Node.js API. We're using a minimal CommonJS-compatible build (from Willi Ballenthin's fork) that doesn't require the full Node.js runtime.

The project went through a few iterations:
1. First, just getting the JavaScript engine to work with proper type conversions between Python bytes and CyberChef's "Dish" objects
2. Then building a clean `bake()` API that chains operations
3. Then the Qt layer with reactive execution

There's also a standalone (non-IDA Pro) Qt application for running CyberChef on the desktop; but really, I'm not sure why you'd use this versus the standalone HTML file from upstream.

## Building

First, initialize the submodule if you haven't already:

```bash
git submodule update --init --recursive
```

Then build CyberChef's JavaScript bundle (you'll need Node.js for this):

```bash
just build
```

This installs npm dependencies in the CyberChef submodule, runs the Node.js build (takes about 40 seconds), and copies the resulting bundle to `ida_cyberchef/data/CyberChef.js`. That's the ~20MB file the Python code loads at runtime.

To run the plugin in IDA, symlink the development directory into `$IDAUSR/plugins/ida-cyberchef`:

```
ln -s (pwd) ~/.idapro/plugins/ida-cyberchef
```

You'll also want to install the dependencies into your IDA Pro Python virtual environment, something like:

```
~/.idapro/venv/bin/python -m pip install STPyV8 pydantic
```

Also, you can run the standalone QApplication (outside of IDA Pro) like this:

```bash
uv run cyberchef-qt
```

## Future Work

I'm not quite sure if this will survive or not - I started out to prove this could work, and then was surprised when things fell into place. The architecture is a little ugly: running V8 from Python inside IDA to load a huge blob from GCHQ. But, it works, and we benefit from the operations already supported by CyberChef. So, if you want to propose enhancements and bug fixes, go for it!

There's some risk that the underlying Javascript engine (STPyV8, though I also worked with PythonMonkey) might become unmaintained or not build/work with future versions of Python or IDA Pro. That'll be a good time to re-evaluate the best parts of ida-cyberchef and perhaps rebuild them carefully.

## License

This project's code is licensed Apache 2.0 by Hex-Rays. CyberChef itself is also licensed under Apache 2.0 by GCHQ.

```

`tests/test_cyberchef.py`:

```py
import hashlib

from ida_cyberchef.cyberchef import bake, get_chef, plate


def rechef(dish_result, chef):
    """Convert a CyberChef Dish result back to a proper Dish for the next operation.

    This does a double-plate: Dish -> Python type -> Dish
    Needed if Dish objects don't cross the Python/JS boundary cleanly.

    Args:
        dish_result: CyberChef Dish result from previous operation
        chef: CyberChef module instance

    Returns: Fresh Dish instance for next operation
    """
    return plate(plate(dish_result), chef)


def test_from_base64():
    chef = get_chef()
    test_input = "U28gbG9uZyBhbmQgdGhhbmtzIGZvciBhbGwgdGhlIGZpc2gu"
    result = plate(chef.fromBase64(test_input))
    assert result == b"So long and thanks for all the fish."


def test_to_hex():
    chef = get_chef()
    input_dish = plate(b"hello", chef)
    result = plate(chef.toHex(input_dish))
    assert result == "68 65 6c 6c 6f"


def test_md5():
    chef = get_chef()
    input_dish = plate(b"hello", chef)
    result = plate(chef.MD5(input_dish))
    assert result == "5d41402abc4b2a76b9719d911017c592"


def test_chained_operations_with_rechef():
    """Test chaining with rechef() if needed."""
    chef = get_chef()

    input_dish = plate(b"hello", chef)
    step1 = chef.toHex(input_dish)
    step2 = rechef(chef.fromHex(step1), chef)
    step3 = chef.MD5(step2)
    result = plate(step3)

    expected = "5d41402abc4b2a76b9719d911017c592"
    assert result == expected


def test_translate_datetime():
    chef = get_chef()
    result = plate(
        chef.translateDateTimeFormat(
            "15/06/2015 20:45:00", {"outputTimezone": "Australia/Queensland"}
        )
    )
    assert "2015" in result


def test_parse_ipv6():
    chef = get_chef()
    result = plate(chef.parseIPv6Address("2001:0000:4136:e378:8000:63bf:3fff:fdd2"))
    assert "2001:0:4136:e378:8000:63bf:3fff:fdd2" in result


def test_sha256():
    """Test SHA2-256 produces correct standard hash.

    Note: size must be a string "256", not integer 256.
    """

    chef = get_chef()
    input_dish = plate(b"hello", chef)
    result = plate(chef.SHA2(input_dish, {"size": "256"}))
    expected = hashlib.sha256(b"hello").hexdigest()
    assert result == expected


def test_url_encode():
    chef = get_chef()
    result = plate(chef.URLEncode("Hello World!"))
    assert result == "Hello%20World!"


def test_bake_simple():
    """Test bake with simple operations."""
    result = bake(b"hello", ["To Base64"])
    assert result == "aGVsbG8="


def test_bake_chain():
    """Test bake with multiple operations."""
    result = bake(b"hello", ["To Base64", "MD5"])
    assert isinstance(result, str)
    assert len(result) == 32


def test_bake_binary():
    """Test bake with binary data that needs to survive encoding."""
    binary_data = bytes(range(256))
    result = bake(binary_data, ["To Hex", "From Hex"])
    assert result == binary_data


def test_bake_with_args():
    """Test bake with operations that have arguments.

    Note: SHA2 size must be string "256", not integer 256.
    """
    result = bake(b"hello", [{"op": "SHA2", "args": {"size": "256"}}])

    # CyberChef's SHA2 should match standard hashlib
    expected = hashlib.sha256(b"hello").hexdigest()
    assert result == expected


def test_bake_sha2_composition():
    """Test SHA2 composition - double hashing works correctly."""
    # Chain two SHA2 operations
    result = bake(
        b"hello",
        [
            {"op": "SHA2", "args": {"size": "256"}},
            {"op": "SHA2", "args": {"size": "256"}},
        ],
    )

    # Expected: SHA256(SHA256("hello"))
    first_hash = hashlib.sha256(b"hello").hexdigest()
    expected = hashlib.sha256(first_hash.encode()).hexdigest()

    assert result == expected
    assert len(result) == 64  # SHA256 produces 64 hex characters


def test_bake_complex_chain():
    """Test bake with a complex chain of operations."""
    result = bake(b"hello", ["To Hex"])
    assert result == "68 65 6c 6c 6f"

    result = bake(result, ["From Hex"])
    assert result == b"hello"

    result = bake(result, ["MD5"])
    expected = "5d41402abc4b2a76b9719d911017c592"
    assert result == expected


def test_bake_hex_to_sha2_chain():
    """Test chaining To Hex followed by SHA2."""
    result = bake(b"hello", [{"op": "To Hex"}, {"op": "SHA2", "args": {"size": "256"}}])

    # Expected: SHA256 of "68 65 6c 6c 6f"
    hex_str = "68 65 6c 6c 6f"
    expected = hashlib.sha256(hex_str.encode()).hexdigest()

    assert result == expected


def test_bake_md5_chain():
    """Test chaining MD5 operations."""
    result = bake(b"hello", [{"op": "MD5"}, {"op": "MD5"}])

    # Expected: MD5(MD5("hello"))
    first_hash = hashlib.md5(b"hello").hexdigest()
    expected = hashlib.md5(first_hash.encode()).hexdigest()

    assert result == expected


def test_bake_url_operations():
    """Test bake with URL encoding operations."""
    result = bake("Hello World!", ["URL Encode"])
    assert result == "Hello%20World!"


def test_bake_empty_recipe():
    """Test bake with empty recipe returns input unchanged."""
    result = bake(b"hello", [])
    assert result == b"hello" or result == "hello"

```

`tests/test_generate_operation_schema.py`:

```py
"""Tests for operation schema generation."""

from pathlib import Path

from tools.generate_operation_schema import (
    enhance_schema_with_categories,
    extract_categories_and_favorites,
)


def test_extract_categories_and_favorites():
    """Test extracting category and favorites data from Categories.json."""
    categories_json_path = (
        Path(__file__).parent.parent
        / "deps"
        / "CyberChef"
        / "src"
        / "core"
        / "config"
        / "Categories.json"
    )

    result = extract_categories_and_favorites(categories_json_path)

    # Should have categories dict mapping operation name to category
    assert "categories" in result
    assert isinstance(result["categories"], dict)

    # Should have favorites list
    assert "favorites" in result
    assert isinstance(result["favorites"], list)

    # Check some known operations have categories
    assert "To Base64" in result["categories"]
    assert result["categories"]["To Base64"] == "Data format"
    assert "AES Decrypt" in result["categories"]
    assert result["categories"]["AES Decrypt"] == "Encryption / Encoding"

    # XOR appears in multiple categories - should pick first
    assert "XOR" in result["categories"]


def test_enhance_schema_with_categories():
    """Test enhancing schema with category and favorites data."""
    categories_json_path = (
        Path(__file__).parent.parent
        / "deps"
        / "CyberChef"
        / "src"
        / "core"
        / "config"
        / "Categories.json"
    )

    schema = {
        "operations": [
            {"name": "To Base64", "module": "Data", "description": "Encode to base64"},
            {
                "name": "To Hex",
                "module": "Data",
                "description": "Encode to hexadecimal",
            },
            {"name": "AES Decrypt", "module": "Crypto", "description": "Decrypt AES"},
        ]
    }

    enhanced = enhance_schema_with_categories(schema, categories_json_path)

    # All operations should have category field
    assert all("category" in op for op in enhanced["operations"])
    assert all("is_favorite" in op for op in enhanced["operations"])

    # Check categories are correct
    to_base64 = next(op for op in enhanced["operations"] if op["name"] == "To Base64")
    assert to_base64["category"] == "Data format"

    aes_decrypt = next(
        op for op in enhanced["operations"] if op["name"] == "AES Decrypt"
    )
    assert aes_decrypt["category"] == "Encryption / Encoding"

    # Unknown operations should have "Other" category
    to_hex = next(op for op in enhanced["operations"] if op["name"] == "To Hex")
    # Since "To Hex" is in the Categories.json, it should have its category
    # But if it wasn't, it would be "Other"
    assert "category" in to_hex

```

`tests/test_hex_formatter.py`:

```py
from ida_cyberchef.core.hex_formatter import HexFormatter


def test_format_simple_bytes():
    formatter = HexFormatter()
    result = formatter.format_hex_dump(b"Hello")

    assert "48 65 6c 6c 6f" in result
    assert "Hello" in result


def test_format_multiple_lines():
    formatter = HexFormatter()
    data = b"A" * 32
    result = formatter.format_hex_dump(data)

    lines = result.strip().split("\n")
    assert len(lines) == 2  # 16 bytes per line


def test_format_with_non_printable():
    formatter = HexFormatter()
    result = formatter.format_hex_dump(b"\x00\x01\x02")

    assert "00 01 02" in result
    assert "." in result  # Non-printable shown as dots


class TestHexStringUnspaced:
    """Tests for format_hex_string_unspaced method."""

    def test_basic_functionality(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_unspaced(b"Hello")
        assert result == "48656c6c6f"

    def test_empty_data(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_unspaced(b"")
        assert result == ""

    def test_single_byte(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_unspaced(b"\x00")
        assert result == "00"

    def test_non_printable_bytes(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_unspaced(b"\x00\x01\xff")
        assert result == "0001ff"


class TestHexStringSpaced:
    """Tests for format_hex_string_spaced method."""

    def test_basic_functionality(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_spaced(b"Hello")
        assert result == "48 65 6c 6c 6f"

    def test_empty_data(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_spaced(b"")
        assert result == ""

    def test_single_byte(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_spaced(b"\x00")
        assert result == "00"

    def test_non_printable_bytes(self):
        formatter = HexFormatter()
        result = formatter.format_hex_string_spaced(b"\x00\x01\xff")
        assert result == "00 01 ff"


class TestStringLiteral:
    """Tests for format_string_literal method."""

    def test_basic_printable_ascii(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"Hello")
        assert result == '"Hello"'

    def test_empty_data(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"")
        assert result == '""'

    def test_double_quote_escaped(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b'Say "Hi"')
        assert result == '"Say \\"Hi\\""'

    def test_backslash_escaped(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"C:\\Path")
        assert result == '"C:\\\\Path"'

    def test_tab_escaped(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"A\tB")
        assert result == '"A\\tB"'

    def test_newline_escaped(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"Line1\nLine2")
        assert result == '"Line1\\nLine2"'

    def test_carriage_return_escaped(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"A\rB")
        assert result == '"A\\rB"'

    def test_non_printable_hex_escaped(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b"\x00\x01\xff")
        assert result == '"\\x00\\x01\\xff"'

    def test_mixed_content(self):
        formatter = HexFormatter()
        result = formatter.format_string_literal(b'Hello\n"World"\t\x00')
        assert result == '"Hello\\n\\"World\\"\\t\\x00"'


class TestCUcharArrayHex:
    """Tests for format_c_uchar_array_hex method."""

    def test_basic_functionality(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_hex(b"Hello")
        assert result == "0x48, 0x65, 0x6c, 0x6c, 0x6f"

    def test_empty_data(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_hex(b"")
        assert result == ""

    def test_single_byte(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_hex(b"\x00")
        assert result == "0x00"

    def test_non_printable_bytes(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_hex(b"\x00\x01\xff")
        assert result == "0x00, 0x01, 0xff"

    def test_hex_formatting_lowercase(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_hex(b"\xab\xcd\xef")
        assert result == "0xab, 0xcd, 0xef"


class TestCUcharArrayDecimal:
    """Tests for format_c_uchar_array_decimal method."""

    def test_basic_functionality(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_decimal(b"Hello")
        assert result == "72, 101, 108, 108, 111"

    def test_empty_data(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_decimal(b"")
        assert result == ""

    def test_single_byte(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_decimal(b"\x00")
        assert result == "0"

    def test_non_printable_bytes(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_decimal(b"\x00\x01\xff")
        assert result == "0, 1, 255"

    def test_max_byte_value(self):
        formatter = HexFormatter()
        result = formatter.format_c_uchar_array_decimal(b"\xff")
        assert result == "255"


class TestCInitializedVariable:
    """Tests for format_c_initialized_variable method."""

    def test_basic_functionality(self):
        formatter = HexFormatter()
        result = formatter.format_c_initialized_variable(b"Hello")
        assert "unsigned char data[5] = {" in result
        assert "0x48, 0x65, 0x6c, 0x6c, 0x6f" in result
        assert result.endswith("};")

    def test_empty_data(self):
        formatter = HexFormatter()
        result = formatter.format_c_initialized_variable(b"")
        assert result == "unsigned char data[] = {};"

    def test_single_byte(self):
        formatter = HexFormatter()
        result = formatter.format_c_initialized_variable(b"\x00")
        expected = "unsigned char data[1] = {\n    0x00\n};"
        assert result == expected

    def test_multiline_12_per_line(self):
        formatter = HexFormatter()
        data = bytes(range(25))
        result = formatter.format_c_initialized_variable(data)

        lines = result.split("\n")
        assert lines[0] == "unsigned char data[25] = {"
        assert lines[-1] == "};"

        first_data_line = lines[1]
        assert first_data_line.startswith("    ")
        assert first_data_line.count("0x") == 12
        assert first_data_line.endswith(",")

        second_data_line = lines[2]
        assert second_data_line.startswith("    ")
        assert second_data_line.count("0x") == 12
        assert second_data_line.endswith(",")

        third_data_line = lines[3]
        assert third_data_line.startswith("    ")
        assert third_data_line.count("0x") == 1
        assert not third_data_line.endswith(",")

    def test_exactly_12_bytes(self):
        formatter = HexFormatter()
        data = b"A" * 12
        result = formatter.format_c_initialized_variable(data)

        lines = result.split("\n")
        assert len(lines) == 3
        assert lines[0] == "unsigned char data[12] = {"
        assert not lines[1].endswith(",")
        assert lines[2] == "};"

    def test_13_bytes_creates_two_lines(self):
        formatter = HexFormatter()
        data = b"A" * 13
        result = formatter.format_c_initialized_variable(data)

        lines = result.split("\n")
        assert len(lines) == 4
        assert lines[0] == "unsigned char data[13] = {"
        assert lines[1].endswith(",")
        assert not lines[2].endswith(",")
        assert lines[3] == "};"

    def test_indentation(self):
        formatter = HexFormatter()
        result = formatter.format_c_initialized_variable(b"Hello")

        lines = result.split("\n")
        for line in lines[1:-1]:
            assert line.startswith("    ")

    def test_hex_formatting_lowercase(self):
        formatter = HexFormatter()
        result = formatter.format_c_initialized_variable(b"\xab\xcd\xef")
        assert "0xab" in result
        assert "0xcd" in result
        assert "0xef" in result

```

`tests/test_input_panel.py`:

```py
import pytest

from ida_cyberchef.qt_models.input_model import InputModel
from ida_cyberchef.widgets.input_panel import InputPanel


@pytest.fixture
def input_panel_with_ida(qtbot, monkeypatch):
    """Create InputPanel with IDA_AVAILABLE = True."""
    import ida_cyberchef.widgets.input_panel as panel_module

    monkeypatch.setattr(panel_module, "IDA_AVAILABLE", True)

    model = InputModel()
    panel = InputPanel(model)
    qtbot.addWidget(panel)
    return panel, model


def test_input_panel_has_from_location_radio(input_panel_with_ida):
    panel, model = input_panel_with_ida
    assert panel._location_radio is not None
    assert panel._location_radio.text() == "From Location"


def test_input_panel_shows_location_widget_when_from_location_selected(
    input_panel_with_ida,
):
    panel, model = input_panel_with_ida
    assert panel._location_widget is not None
    assert not panel._location_widget.isVisible()

    panel.show()
    panel._location_radio.setChecked(True)
    panel._on_source_changed()

    assert panel._location_widget.isVisible()
    assert panel._text_area.isReadOnly()

```

`tests/test_input_parser.py`:

```py
from ida_cyberchef.core.input_parser import InputFormat, InputParser


def test_parse_text_utf8():
    parser = InputParser()
    result = parser.parse("Hello", InputFormat.TEXT_UTF8)

    assert result == b"Hello"


def test_parse_hex_string():
    parser = InputParser()
    result = parser.parse("48656c6c6f", InputFormat.HEX_STRING)

    assert result == b"Hello"


def test_parse_hex_with_spaces():
    parser = InputParser()
    result = parser.parse("48 65 6c 6c 6f", InputFormat.HEX_STRING)

    assert result == b"Hello"


def test_parse_base64():
    parser = InputParser()
    result = parser.parse("SGVsbG8=", InputFormat.BASE64)

    assert result == b"Hello"


def test_parse_invalid_hex():
    parser = InputParser()
    result = parser.parse("not hex", InputFormat.HEX_STRING)

    assert result is None

```

`tests/test_location_input_widget.py`:

```py
"""Tests for LocationInputWidget."""

from ida_cyberchef.widgets.location_input_widget import LocationInputWidget


def test_location_widget_has_address_field(qtbot):
    """LocationInputWidget should have address QLineEdit with proper placeholder."""
    widget = LocationInputWidget()
    qtbot.addWidget(widget)
    assert widget._address_edit is not None
    assert widget._address_edit.placeholderText() == "0x00000000"


def test_location_widget_has_length_field(qtbot):
    """LocationInputWidget should have length QLineEdit with proper placeholder."""
    widget = LocationInputWidget()
    qtbot.addWidget(widget)
    assert widget._length_edit is not None
    assert widget._length_edit.placeholderText() == "256"


def test_location_widget_emits_signal_on_valid_input(qtbot):
    """LocationInputWidget should emit location_changed signal with parsed values."""
    widget = LocationInputWidget()
    qtbot.addWidget(widget)

    with qtbot.waitSignal(widget.location_changed, timeout=1000) as blocker:
        widget._address_edit.setText("0x401000")
        widget._length_edit.setText("128")
        widget._address_edit.editingFinished.emit()

    assert blocker.args == [0x401000, 128]

```

`tests/test_operation_doc_formatter.py`:

```py
"""Tests for operation documentation formatting."""

from ida_cyberchef.core.operation_doc_formatter import (
    format_operation_docs,
    strip_html_tags,
)


def test_format_operation_docs_full():
    """Test formatting operation with all fields."""
    operation = {
        "name": "AES Decrypt",
        "category": "Encryption / Encoding",
        "description": "Advanced Encryption Standard (AES) decryption.",
        "args": [
            {"name": "Key", "type": "string", "value": ""},
            {"name": "IV", "type": "string", "value": ""},
            {
                "name": "Mode",
                "type": "option",
                "value": ["CBC", "ECB"],
                "toggleValues": ["CBC", "ECB"],
            },
        ],
    }

    result = format_operation_docs(operation)

    assert "AES Decrypt" in result
    assert "Category: Encryption / Encoding" in result
    assert "Advanced Encryption Standard" in result
    assert "Parameters:" in result
    assert "Key (string)" in result
    assert "Mode (option)" in result
    assert "CBC, ECB" in result


def test_format_operation_docs_minimal():
    """Test formatting operation with minimal fields."""
    operation = {
        "name": "XOR",
        "category": "Encryption / Encoding",
        "description": "XOR operation.",
        "args": [],
    }

    result = format_operation_docs(operation)

    assert "XOR" in result
    assert "Category: Encryption / Encoding" in result
    assert "XOR operation." in result
    assert "Parameters: None" in result


def test_strip_html_tags_basic():
    """Test stripping basic HTML tags."""
    assert strip_html_tags("<b>bold</b> text") == "bold text"
    assert strip_html_tags("<code>code</code>") == "code"
    assert strip_html_tags("<strong>strong</strong>") == "strong"
    assert strip_html_tags("<i>italic</i>") == "italic"
    assert strip_html_tags("<u>underline</u>") == "underline"


def test_strip_html_tags_br_conversion():
    """Test <br> tag conversion to newlines."""
    assert strip_html_tags("line1<br>line2") == "line1\nline2"
    assert strip_html_tags("line1<BR>line2") == "line1\nline2"
    assert strip_html_tags("line1<br/>line2") == "line1\nline2"
    assert strip_html_tags("line1<br />line2") == "line1\nline2"
    assert strip_html_tags("line1<br><br>line2") == "line1\n\nline2"


def test_strip_html_tags_complex():
    """Test stripping complex HTML with nested tags."""
    text = "<b>Key:</b> The <code>key</code> parameter<br><br>More info"
    expected = "Key: The key parameter\n\nMore info"
    assert strip_html_tags(text) == expected


def test_strip_html_tags_lists():
    """Test stripping list HTML tags."""
    text = "<ul><li>item1</li><li>item2</li></ul>"
    assert strip_html_tags(text) == "item1item2"


def test_strip_html_tags_links():
    """Test stripping anchor tags but keeping text."""
    text = "<a href='http://example.com'>link text</a>"
    assert strip_html_tags(text) == "link text"


def test_format_operation_docs_with_html():
    """Test formatting operation with HTML in description."""
    operation = {
        "name": "A1Z26 Cipher Decode",
        "category": "Encryption / Encoding",
        "description": "Converts alphabet order numbers into their corresponding  alphabet character.<br><br>e.g. <code>1</code> becomes <code>a</code> and <code>2</code> becomes <code>b</code>.",
        "args": [],
    }

    result = format_operation_docs(operation)

    assert "A1Z26 Cipher Decode" in result
    assert "Category: Encryption / Encoding" in result
    assert "<br>" not in result
    assert "<code>" not in result
    assert "</code>" not in result
    assert "1 becomes a" in result
    assert "2 becomes b" in result
    assert result.count("\n\n") >= 2


def test_format_operation_docs_with_complex_html():
    """Test formatting operation with complex HTML description."""
    operation = {
        "name": "AES Decrypt",
        "category": "Encryption / Encoding",
        "description": "<b>Key:</b> The following algorithms will be used based on the size of the key:<ul><li>16 bytes = AES-128</li><li>24 bytes = AES-192</li></ul><br><br><b>IV:</b> The Initialization Vector should be 16 bytes long.",
        "args": [],
    }

    result = format_operation_docs(operation)

    assert "AES Decrypt" in result
    assert "<b>" not in result
    assert "</b>" not in result
    assert "<ul>" not in result
    assert "<li>" not in result
    assert "</li>" not in result
    assert "</ul>" not in result
    assert "Key:" in result
    assert "16 bytes = AES-128" in result
    assert "24 bytes = AES-192" in result
    assert "IV:" in result
    assert "Initialization Vector" in result

```

`tests/test_operation_registry.py`:

```py
import json
from pathlib import Path

from ida_cyberchef.core.operation_registry import OperationRegistry


def test_operation_schema_exists():
    schema_path = Path("ida_cyberchef/data/operation_schema.json")
    assert schema_path.exists(), (
        "operation_schema.json must exist in ida_cyberchef/data/"
    )


def test_operation_schema_structure():
    with open("ida_cyberchef/data/operation_schema.json") as f:
        schema = json.load(f)

    assert "operations" in schema
    assert isinstance(schema["operations"], list)
    assert len(schema["operations"]) > 0

    op = schema["operations"][0]
    assert "name" in op
    assert "module" in op
    assert "description" in op
    assert "args" in op
    assert isinstance(op["args"], list)


def test_load_operations():
    registry = OperationRegistry()
    ops = registry.get_all_operations()

    assert len(ops) > 0
    assert all("name" in op for op in ops)
    assert all("args" in op for op in ops)


def test_find_operation_by_name():
    registry = OperationRegistry()
    op = registry.find_operation("To Hex")

    assert op is not None
    assert op["name"] == "To Hex"


def test_fuzzy_search_operations():
    registry = OperationRegistry()
    results = registry.search_operations("hex")

    assert len(results) > 0
    assert any("hex" in r["name"].lower() for r in results)
    # Results should be ranked by relevance
    assert results[0]["name"].lower().find("hex") >= 0


def test_acronym_search_operations():
    """Test searching operations by acronyms (e.g., 'b64' for 'Base64').

    Acronym search should match first letters of words separated by spaces or case boundaries.
    """
    registry = OperationRegistry()

    # Test acronyms should work
    results = registry.search_operations("tdd")  # Triple DES Decrypt should match
    assert len(results) > 0
    # Should find operations like "Triple DES"
    triple_des_results = [r for r in results if "Triple DES" in r["name"]]
    assert len(triple_des_results) > 0, (
        "Acronym 'tdd' should match 'Triple DES' or similar"
    )

    # Test "b64" should match "To Base64", "From Base64" etc
    results = registry.search_operations("b64")
    assert len(results) > 0
    base64_results = [r for r in results if "Base64" in r["name"]]
    assert len(base64_results) > 0, "Acronym 'b64' should match Base64 operations"

```

`tests/test_operation_step_widget.py`:

```py
"""Tests for OperationStepWidget."""

from ida_cyberchef.core.operation_registry import OperationRegistry
from ida_cyberchef.widgets.operation_step_widget import OperationStepWidget


def test_option_dropdown_shows_all_choices(qtbot):
    """Option dropdown should show all choices from schema, not just selected value."""
    registry = OperationRegistry()
    xor_op = registry.find_operation("XOR")
    assert xor_op is not None

    # Simulate saved step with "Output differential" selected
    op_with_saved = xor_op.copy()
    for arg in op_with_saved["args"]:
        if arg["name"] == "Scheme":
            arg["saved_value"] = "Output differential"

    widget = OperationStepWidget(0, op_with_saved)
    qtbot.addWidget(widget)

    # Find the Scheme dropdown
    scheme_widget = widget._arg_widgets["Scheme"]

    # Should have all 4 options
    assert scheme_widget.count() == 4
    assert scheme_widget.itemText(0) == "Standard"
    assert scheme_widget.itemText(1) == "Input differential"
    assert scheme_widget.itemText(2) == "Output differential"
    assert scheme_widget.itemText(3) == "Cascade"

    # Should have "Output differential" selected
    assert scheme_widget.currentText() == "Output differential"


def test_togglestring_dict_value_displays_correctly(qtbot):
    """ToggleString with dict value should extract string part for display."""
    registry = OperationRegistry()
    xor_op = registry.find_operation("XOR")
    assert xor_op is not None

    # Simulate saved step with toggleString dict value
    op_with_saved = xor_op.copy()
    for arg in op_with_saved["args"]:
        if arg["name"] == "Key":
            arg["value"] = {"string": "deadbeef", "option": "Hex"}

    widget = OperationStepWidget(0, op_with_saved)
    qtbot.addWidget(widget)

    # Find the Key input (it's a container with properties)
    key_container = widget._arg_widgets["Key"]
    value_input = key_container.property("value_input")
    format_combo = key_container.property("format_combo")

    # Should extract "deadbeef" for input, "Hex" for dropdown
    assert value_input.text() == "deadbeef"
    assert format_combo.currentText() == "Hex"

```

`tests/test_qt_execution_model.py`:

```py
from ida_cyberchef.qt_models.execution_model import ExecutionModel
from ida_cyberchef.qt_models.input_model import InputModel
from ida_cyberchef.qt_models.recipe_model import RecipeModel


def test_create_execution_model():
    input_model = InputModel()
    recipe_model = RecipeModel()

    exec_model = ExecutionModel(input_model, recipe_model)
    assert exec_model is not None


def test_execution_completed_signal(qtbot):
    input_model = InputModel()
    recipe_model = RecipeModel()
    exec_model = ExecutionModel(input_model, recipe_model, debounce_ms=50)

    input_model.set_manual_text("Hello")
    recipe_model.add_operation("To Hex", {})

    with qtbot.waitSignal(exec_model.execution_completed, timeout=2000):
        exec_model.schedule_execution()


def test_get_execution_results(qtbot):
    input_model = InputModel()
    recipe_model = RecipeModel()
    exec_model = ExecutionModel(input_model, recipe_model, debounce_ms=50)

    input_model.set_manual_text("Hello")
    recipe_model.add_operation("To Hex", {})

    with qtbot.waitSignal(exec_model.execution_completed, timeout=2000):
        exec_model.schedule_execution()

    results = exec_model.get_results()
    assert len(results) == 1
    assert results[0].success is True


def test_debouncing(qtbot):
    input_model = InputModel()
    recipe_model = RecipeModel()
    exec_model = ExecutionModel(input_model, recipe_model, debounce_ms=50)

    input_model.set_manual_text("A")

    signals = []
    exec_model.execution_completed.connect(lambda: signals.append(1))

    input_model.set_manual_text("B")
    input_model.set_manual_text("C")

    qtbot.wait(200)

    # Should get 1-2 signals: initial "A" may still be pending when we connect,
    # then "B" and "C" are debounced into a single execution
    assert 1 <= len(signals) <= 2


def test_empty_recipe_passes_through_input(qtbot):
    input_model = InputModel()
    recipe_model = RecipeModel()
    exec_model = ExecutionModel(input_model, recipe_model, debounce_ms=50)

    test_data = "Hello World"
    input_model.set_manual_text(test_data)

    with qtbot.waitSignal(exec_model.execution_completed, timeout=2000):
        exec_model.schedule_execution()

    results = exec_model.get_results()
    assert len(results) == 1
    assert results[0].success is True
    assert results[0].data == test_data.encode("utf-8")
    assert results[0].error is None

    final_result = exec_model.get_final_result()
    assert final_result is not None
    assert final_result.data == test_data.encode("utf-8")

```

`tests/test_qt_input_model.py`:

```py
from ida_cyberchef.core.input_parser import InputFormat
from ida_cyberchef.qt_models.input_model import InputModel, InputSource


def test_create_input_model():
    model = InputModel()

    assert model.get_input_source() == InputSource.MANUAL
    assert model.get_input_format() == InputFormat.TEXT_UTF8


def test_set_manual_text():
    model = InputModel()
    model.set_manual_text("Hello")

    data = model.get_input_bytes()
    assert data == b"Hello"


def test_set_input_format():
    model = InputModel()
    model.set_input_format(InputFormat.HEX_STRING)
    model.set_manual_text("48656c6c6f")

    data = model.get_input_bytes()
    assert data == b"Hello"


def test_set_external_data():
    model = InputModel()
    model.set_input_source(InputSource.FROM_CURSOR)
    model.set_external_data(b"External")

    data = model.get_input_bytes()
    assert data == b"External"


def test_input_changed_signal(qtbot):
    model = InputModel()

    with qtbot.waitSignal(model.input_changed):
        model.set_manual_text("Test")


def test_source_changed_signal_emitted():
    model = InputModel()
    received = []
    model.source_changed.connect(lambda source: received.append(source))

    model.set_input_source(InputSource.FROM_CURSOR)

    assert len(received) == 1
    assert received[0] == InputSource.FROM_CURSOR


def test_source_changed_not_emitted_when_same():
    model = InputModel()
    model.set_input_source(InputSource.MANUAL)
    received = []
    model.source_changed.connect(lambda source: received.append(source))

    model.set_input_source(InputSource.MANUAL)

    assert len(received) == 0


def test_input_source_from_location_exists():
    assert hasattr(InputSource, "FROM_LOCATION")
    assert InputSource.FROM_LOCATION == 3


def test_location_fields_and_methods():
    model = InputModel()
    # Should have methods for location params
    assert hasattr(model, "set_location_params")
    assert hasattr(model, "get_location_address")
    assert hasattr(model, "get_location_length")
    # Initial state should be None
    assert model.get_location_address() is None
    assert model.get_location_length() is None


def test_set_location_params_fetches_ida_bytes(monkeypatch):
    """Test that set_location_params fetches bytes from IDA."""
    mock_bytes = b"\x48\x65\x6c\x6c\x6f"

    def mock_get_bytes(address, length):
        assert address == 0x401000
        assert length == 5
        return mock_bytes

    import types
    from typing import Any

    import ida_cyberchef.qt_models.input_model as model_module

    mock_ida_bytes: Any = types.ModuleType("ida_bytes")
    mock_ida_bytes.get_bytes = mock_get_bytes
    monkeypatch.setattr(model_module, "ida_bytes", mock_ida_bytes)
    monkeypatch.setattr(model_module, "IDA_AVAILABLE", True)

    model = InputModel()
    model.set_location_params(0x401000, 5)

    assert model.get_location_address() == 0x401000
    assert model.get_location_length() == 5
    assert model._location_data == mock_bytes

```

`tests/test_qt_recipe_model.py`:

```py
from PySide6.QtCore import Qt

from ida_cyberchef.core.recipe_models import OperationStep, RecipeDefinition
from ida_cyberchef.qt_models.recipe_model import RecipeModel


def test_create_empty_model():
    model = RecipeModel()

    assert model.rowCount() == 0


def test_add_operation():
    model = RecipeModel()
    model.add_operation("To Hex", {})

    assert model.rowCount() == 1
    index = model.index(0, 0)
    assert model.data(index, Qt.DisplayRole) == "To Hex"


def test_remove_operation():
    model = RecipeModel()
    model.add_operation("To Hex", {})
    model.add_operation("XOR", {"key": "test"})

    model.remove_operation(0)
    assert model.rowCount() == 1


def test_get_recipe_steps():
    model = RecipeModel()
    model.add_operation("To Hex", {})
    model.add_operation("XOR", {"key": "test"})

    steps = model.get_recipe_steps()
    assert len(steps) == 2
    assert steps[0]["operation"] == "To Hex"
    assert steps[1]["operation"] == "XOR"


def test_to_recipe_definition():
    model = RecipeModel()
    model.add_operation("To Hex", {})

    recipe = model.to_recipe_definition()
    assert isinstance(recipe, RecipeDefinition)
    assert len(recipe.steps) == 1


def test_from_recipe_definition():
    recipe = RecipeDefinition(
        steps=[
            OperationStep(operation="To Hex", args={}),
            OperationStep(operation="XOR", args={"key": "test"}),
        ]
    )

    model = RecipeModel()
    model.from_recipe_definition(recipe)

    assert model.rowCount() == 2

```

`tests/test_recipe_executor.py`:

```py
from ida_cyberchef.core.recipe_executor import RecipeExecutor


def test_execute_single_operation():
    executor = RecipeExecutor()

    recipe = [{"operation": "To Hex", "args": {}}]
    results = executor.execute_recipe(b"hello", recipe)

    assert len(results) == 1
    assert results[0].success is True
    assert results[0].data is not None
    assert results[0].error is None


def test_execute_chained_operations():
    executor = RecipeExecutor()

    recipe = [
        {"operation": "To Hex", "args": {}},
        {"operation": "To Upper case", "args": {}},
    ]
    results = executor.execute_recipe(b"test", recipe)

    assert len(results) == 2
    assert all(r.success for r in results)


def test_execution_stops_on_error():
    executor = RecipeExecutor()

    recipe = [
        {"operation": "To Hex", "args": {}},
        {"operation": "InvalidOp", "args": {}},
        {"operation": "To Upper case", "args": {}},
    ]
    results = executor.execute_recipe(b"test", recipe)

    assert len(results) == 2
    assert results[0].success is True
    assert results[1].success is False
    assert results[1].error is not None


def test_empty_recipe_returns_empty_list():
    executor = RecipeExecutor()

    recipe: list[dict[str, object]] = []
    results = executor.execute_recipe(b"hello", recipe)

    assert len(results) == 0


def test_step_result_holds_string_data():
    from ida_cyberchef.core.recipe_executor import StepResult

    result = StepResult(success=True, data="hello world", error=None)
    assert result.data == "hello world"
    assert isinstance(result.data, str)


def test_step_result_holds_bytes_data():
    from ida_cyberchef.core.recipe_executor import StepResult

    result = StepResult(success=True, data=b"hello world", error=None)
    assert result.data == b"hello world"
    assert isinstance(result.data, bytes)


def test_recipe_executor_preserves_string_output():
    """Verify RecipeExecutor preserves str output from bake()."""
    executor = RecipeExecutor()
    # To Base64 returns string
    recipe = [{"operation": "To Base64", "args": {}}]
    results = executor.execute_recipe(b"test", recipe)

    assert len(results) == 1
    assert results[0].success
    assert isinstance(results[0].data, str)
    assert results[0].data == "dGVzdA=="  # "test" in base64


def test_recipe_executor_preserves_bytes_output():
    """Verify RecipeExecutor preserves bytes output from bake()."""
    executor = RecipeExecutor()
    # From Base64 returns bytes
    recipe = [{"operation": "From Base64", "args": {}}]
    results = executor.execute_recipe(b"dGVzdA==", recipe)

    assert len(results) == 1
    assert results[0].success
    assert isinstance(results[0].data, bytes)
    assert results[0].data == b"test"

```

`tests/test_recipe_models.py`:

```py
import json

from ida_cyberchef.core.recipe_models import OperationStep, RecipeDefinition


def test_create_recipe_definition():
    recipe = RecipeDefinition(
        version="1.0",
        steps=[
            OperationStep(operation="To Hex", args={}),
            OperationStep(operation="XOR", args={"key": "secret"}),
        ],
    )

    assert recipe.version == "1.0"
    assert len(recipe.steps) == 2


def test_serialize_to_json():
    recipe = RecipeDefinition(
        steps=[
            OperationStep(operation="To Hex", args={}),
        ]
    )

    json_str = recipe.model_dump_json()
    data = json.loads(json_str)

    assert data["version"] == "1.0"
    assert len(data["steps"]) == 1
    assert data["steps"][0]["operation"] == "To Hex"


def test_deserialize_from_json():
    json_data = {"version": "1.0", "steps": [{"operation": "To Hex", "args": {}}]}

    recipe = RecipeDefinition.model_validate(json_data)

    assert recipe.version == "1.0"
    assert len(recipe.steps) == 1

```

`tests/test_ui_verification.py`:

```py
"""Automated UI verification tests for Task 7 manual testing requirements."""

from PySide6.QtWidgets import QComboBox, QLabel

from ida_cyberchef.core.operation_registry import OperationRegistry
from ida_cyberchef.widgets.operation_step_widget import OperationStepWidget


def test_xor_operation_layout(qtbot):
    """Test case 1: Verify XOR operation shows proper layout.

    Requirements:
    - Key field shows empty input
    - Hex dropdown with label "Key:"
    - Can type "deadbeef" in Key input
    - Can select "Decimal" from dropdown
    - Layout shows clean with proper labels
    """
    registry = OperationRegistry()
    xor_op = registry.find_operation("XOR")
    assert xor_op is not None

    widget = OperationStepWidget(0, xor_op)
    qtbot.addWidget(widget)

    # Verify Key toggleString widget exists
    key_container = widget._arg_widgets["Key"]
    value_input = key_container.property("value_input")
    format_combo = key_container.property("format_combo")

    assert value_input is not None, "Key input should exist"
    assert format_combo is not None, "Format dropdown should exist"

    # Initially empty
    assert value_input.text() == "", "Key input should be empty initially"

    # Verify dropdown has Hex options
    assert format_combo.count() > 0, "Format dropdown should have options"
    assert "Hex" in [format_combo.itemText(i) for i in range(format_combo.count())], (
        "Should have Hex option"
    )
    assert "Decimal" in [
        format_combo.itemText(i) for i in range(format_combo.count())
    ], "Should have Decimal option"

    # Simulate user typing "deadbeef"
    value_input.setText("deadbeef")
    assert value_input.text() == "deadbeef", "Should accept text input"

    # Simulate selecting "Decimal"
    format_combo.setCurrentText("Decimal")
    assert format_combo.currentText() == "Decimal", "Should change dropdown selection"

    # Verify get_current_args returns correct format
    args = widget.get_current_args()
    assert "Key" in args, "Args should contain Key"
    assert isinstance(args["Key"], dict), "Key value should be dict"
    assert args["Key"]["string"] == "deadbeef", "Key string should match"
    assert args["Key"]["option"] == "Decimal", "Key option should match"


def test_to_base64_operation_no_args(qtbot):
    """Test case 2: Verify To Base64 operation (simple, no args).

    Requirements:
    - Should show operation name + buttons only
    - No grid layout for args
    """
    registry = OperationRegistry()
    base64_op = registry.find_operation("To Base64")
    assert base64_op is not None

    widget = OperationStepWidget(0, base64_op)
    qtbot.addWidget(widget)

    # Should have minimal or no arg widgets
    # To Base64 has optional alphabet argument, but we verify structure

    # Operation name should be visible in widget
    assert "To Base64" in [
        child.text() for child in widget.findChildren(QLabel) if hasattr(child, "text")
    ], "Operation name should be displayed"

    # Preview button should exist
    assert widget._preview_button is not None, "Preview button should exist"


def test_aes_decrypt_operation_many_args(qtbot):
    """Test case 3: Verify AES Decrypt operation (many args).

    Requirements:
    - Verify toggleString args (Key, IV, GCM Tag) show correctly with labels and format dropdowns
    - Verify option dropdowns (Mode, Input, Output) have all choices
    """
    registry = OperationRegistry()
    aes_op = registry.find_operation("AES Decrypt")
    assert aes_op is not None

    widget = OperationStepWidget(0, aes_op)
    qtbot.addWidget(widget)

    # Verify toggleString args exist
    togglestring_args = ["Key", "IV"]  # AES Decrypt has these
    for arg_name in togglestring_args:
        if arg_name in widget._arg_widgets:
            container = widget._arg_widgets[arg_name]
            value_input = container.property("value_input")
            format_combo = container.property("format_combo")

            assert value_input is not None, f"{arg_name} should have input field"
            assert format_combo is not None, f"{arg_name} should have format dropdown"
            assert format_combo.count() > 0, f"{arg_name} dropdown should have options"

    # Verify option dropdowns have multiple choices
    option_args = ["Mode", "Input format", "Output format"]
    for arg_name in option_args:
        if arg_name in widget._arg_widgets:
            dropdown = widget._arg_widgets[arg_name]
            if isinstance(dropdown, QComboBox):
                assert dropdown.count() > 1, f"{arg_name} should have multiple options"


def test_save_and_reload_recipe_preserves_values(qtbot):
    """Test case 4: Verify save and reload recipe functionality.

    Requirements:
    - Save recipe with XOR operation (Key="deadbeef", option="Decimal")
    - Verify values preserved correctly when reloading
    - Verify dropdowns still show all options (not just selected)
    """
    registry = OperationRegistry()
    xor_op = registry.find_operation("XOR")
    assert xor_op is not None

    # First widget: simulate initial state with user input
    widget1 = OperationStepWidget(0, xor_op)
    qtbot.addWidget(widget1)

    key_container1 = widget1._arg_widgets["Key"]
    value_input1 = key_container1.property("value_input")
    format_combo1 = key_container1.property("format_combo")

    value_input1.setText("deadbeef")
    format_combo1.setCurrentText("Decimal")

    # Get the saved args (simulating save)
    saved_args = widget1.get_current_args()

    # Second widget: simulate reload with saved values
    xor_op_reload = registry.find_operation("XOR")
    assert xor_op_reload is not None
    xor_op_reload_copy = xor_op_reload.copy()
    xor_op_reload_copy["args"] = [arg.copy() for arg in xor_op_reload_copy["args"]]

    # Merge saved values using saved_value field (as recipe_panel does)
    for arg in xor_op_reload_copy["args"]:
        if arg["name"] in saved_args:
            arg["saved_value"] = saved_args[arg["name"]]

    widget2 = OperationStepWidget(0, xor_op_reload_copy)
    qtbot.addWidget(widget2)

    # Verify values are preserved
    key_container2 = widget2._arg_widgets["Key"]
    value_input2 = key_container2.property("value_input")
    format_combo2 = key_container2.property("format_combo")

    assert value_input2.text() == "deadbeef", "Key value should be preserved"
    assert format_combo2.currentText() == "Decimal", (
        "Format selection should be preserved"
    )

    # Verify dropdown still has all options (not just selected)
    assert format_combo2.count() > 1, "Format dropdown should have multiple options"
    assert "Hex" in [format_combo2.itemText(i) for i in range(format_combo2.count())], (
        "Dropdown should still have Hex option"
    )
    assert "Decimal" in [
        format_combo2.itemText(i) for i in range(format_combo2.count())
    ], "Dropdown should still have Decimal option"

    # Verify Scheme option dropdown also preserves all choices
    if "Scheme" in widget2._arg_widgets:
        scheme_dropdown = widget2._arg_widgets["Scheme"]
        assert scheme_dropdown.count() == 4, "Scheme should have all 4 options"
        assert scheme_dropdown.itemText(0) == "Standard"
        assert scheme_dropdown.itemText(1) == "Input differential"
        assert scheme_dropdown.itemText(2) == "Output differential"
        assert scheme_dropdown.itemText(3) == "Cascade"


def test_grid_layout_labels_exist(qtbot):
    """Verify grid layout has proper labels for arguments."""
    registry = OperationRegistry()
    xor_op = registry.find_operation("XOR")
    assert xor_op is not None

    widget = OperationStepWidget(0, xor_op)
    qtbot.addWidget(widget)

    # Find all labels in the grid
    labels = widget.findChildren(QLabel)
    label_texts = [label.text() for label in labels]

    # Should have labels for arguments (excluding operation name label)
    # XOR has: Key, Scheme, Null preserving (checkbox - no label)
    assert "Key:" in label_texts, "Should have label for Key argument"
    assert "Scheme:" in label_texts, "Should have label for Scheme argument"

    # Verify label styling (gray color)
    for label in labels:
        if label.text().endswith(":"):
            style = label.styleSheet()
            assert "color" in style.lower(), "Argument labels should have color styling"

```

`tools/cyberchef_operations.json`:

```json
[
  "A1Z26CipherDecode",
  "A1Z26CipherEncode",
  "ADD",
  "AESDecrypt",
  "AESEncrypt",
  "AESKeyUnwrap",
  "AESKeyWrap",
  "AMFDecode",
  "AMFEncode",
  "AND",
  "BLAKE2b",
  "BLAKE2s",
  "BLAKE3",
  "BSONDeserialise",
  "BSONSerialise",
  "CBORDecode",
  "CBOREncode",
  "CMAC",
  "CRCChecksum",
  "CSSBeautify",
  "CSSMinify",
  "CSSSelector",
  "CSVToJSON",
  "CTPH",
  "DESDecrypt",
  "DESEncrypt",
  "DNSOverHTTPS",
  "Dish",
  "DishError",
  "ECDSASign",
  "ECDSASignatureConversion",
  "ECDSAVerify",
  "ELFInfo",
  "ExcludedOperationError",
  "GOSTDecrypt",
  "GOSTEncrypt",
  "GOSTHash",
  "GOSTKeyUnwrap",
  "GOSTKeyWrap",
  "GOSTSign",
  "GOSTVerify",
  "HAS160",
  "HASSHClientFingerprint",
  "HASSHServerFingerprint",
  "HMAC",
  "HTMLToText",
  "HTTPRequest",
  "IPv6TransitionAddresses",
  "JA3Fingerprint",
  "JA3SFingerprint",
  "JA4Fingerprint",
  "JA4ServerFingerprint",
  "JPathExpression",
  "JSONBeautify",
  "JSONMinify",
  "JSONToCSV",
  "JSONtoYAML",
  "JWKToPem",
  "JWTDecode",
  "JWTSign",
  "JWTVerify",
  "LMHash",
  "LS47Decrypt",
  "LS47Encrypt",
  "LZ4Compress",
  "LZ4Decompress",
  "LZMACompress",
  "LZMADecompress",
  "LZNT1Decompress",
  "LZStringCompress",
  "LZStringDecompress",
  "MD2",
  "MD4",
  "MD5",
  "MD6",
  "MIMEDecoding",
  "NOT",
  "NTHash",
  "OR",
  "OperationError",
  "PEMToHex",
  "PEMToJWK",
  "PGPDecrypt",
  "PGPDecryptAndVerify",
  "PGPEncrypt",
  "PGPEncryptAndSign",
  "PGPVerify",
  "PHPDeserialize",
  "PHPSerialize",
  "PLISTViewer",
  "RAKE",
  "RC2Decrypt",
  "RC2Encrypt",
  "RC4",
  "RC4Drop",
  "RIPEMD",
  "ROT13",
  "ROT13BruteForce",
  "ROT47",
  "ROT47BruteForce",
  "ROT8000",
  "RSADecrypt",
  "RSAEncrypt",
  "RSASign",
  "RSAVerify",
  "Return",
  "SHA0",
  "SHA1",
  "SHA2",
  "SHA3",
  "SIGABA",
  "SM2Decrypt",
  "SM2Encrypt",
  "SM3",
  "SM4Decrypt",
  "SM4Encrypt",
  "SQLBeautify",
  "SQLMinify",
  "SSDEEP",
  "SUB",
  "TCPIPChecksum",
  "UNIXTimestampToWindowsFiletime",
  "URLDecode",
  "URLEncode",
  "XKCDRandomNumber",
  "XMLBeautify",
  "XMLMinify",
  "XOR",
  "XORBruteForce",
  "XORChecksum",
  "XPathExpression",
  "XSalsa20",
  "XXTEADecrypt",
  "XXTEAEncrypt",
  "YAMLToJSON",
  "YARARules",
  "addLineNumbers",
  "addTextToImage",
  "adler32Checksum",
  "affineCipherDecode",
  "affineCipherEncode",
  "alternatingCaps",
  "analyseHash",
  "analyseUUID",
  "argon2",
  "argon2Compare",
  "atbashCipher",
  "avroToJSON",
  "baconCipherDecode",
  "baconCipherEncode",
  "bake",
  "bcrypt",
  "bcryptCompare",
  "bcryptParse",
  "bifidCipherDecode",
  "bifidCipherEncode",
  "bitShiftLeft",
  "bitShiftRight",
  "blowfishDecrypt",
  "blowfishEncrypt",
  "blurImage",
  "bombe",
  "bzip2Compress",
  "bzip2Decompress",
  "caesarBoxCipher",
  "caretMdecode",
  "cartesianProduct",
  "cetaceanCipherDecode",
  "cetaceanCipherEncode",
  "chaCha",
  "changeIPFormat",
  "chiSquare",
  "cipherSaber2Decrypt",
  "cipherSaber2Encrypt",
  "citrixCTX1Decode",
  "citrixCTX1Encode",
  "colossus",
  "comment",
  "compareCTPHHashes",
  "compareSSDEEPHashes",
  "conditionalJump",
  "containImage",
  "convertArea",
  "convertCoordinateFormat",
  "convertDataUnits",
  "convertDistance",
  "convertImageFormat",
  "convertLeetSpeak",
  "convertMass",
  "convertSpeed",
  "convertToNATOAlphabet",
  "countOccurrences",
  "coverImage",
  "cropImage",
  "dateTimeDelta",
  "dechunkHTTPResponse",
  "decodeNetBIOSName",
  "decodeText",
  "defangIPAddresses",
  "defangURL",
  "deriveEVPKey",
  "deriveHKDFKey",
  "derivePBKDF2Key",
  "detectFileType",
  "diff",
  "disassembleX86",
  "ditherImage",
  "divide",
  "dropBytes",
  "dropNthBytes",
  "encodeNetBIOSName",
  "encodeText",
  "enigma",
  "entropy",
  "escapeString",
  "escapeUnicodeCharacters",
  "expandAlphabetRange",
  "extractDates",
  "extractDomains",
  "extractEXIF",
  "extractEmailAddresses",
  "extractFilePaths",
  "extractFiles",
  "extractHashes",
  "extractID3",
  "extractIPAddresses",
  "extractLSB",
  "extractMACAddresses",
  "extractRGBA",
  "extractURLs",
  "fangURL",
  "fernetDecrypt",
  "fernetEncrypt",
  "fileTree",
  "filter",
  "findReplace",
  "fletcher16Checksum",
  "fletcher32Checksum",
  "fletcher64Checksum",
  "fletcher8Checksum",
  "flipImage",
  "fork",
  "formatMACAddresses",
  "frequencyDistribution",
  "fromBCD",
  "fromBase",
  "fromBase32",
  "fromBase45",
  "fromBase58",
  "fromBase62",
  "fromBase64",
  "fromBase85",
  "fromBase92",
  "fromBinary",
  "fromBraille",
  "fromCaseInsensitiveRegex",
  "fromCharcode",
  "fromDecimal",
  "fromFloat",
  "fromHTMLEntity",
  "fromHex",
  "fromHexContent",
  "fromHexdump",
  "fromMessagePack",
  "fromModhex",
  "fromMorseCode",
  "fromOctal",
  "fromPunycode",
  "fromQuotedPrintable",
  "fromUNIXTimestamp",
  "fuzzyMatch",
  "generateAllChecksums",
  "generateAllHashes",
  "generateDeBruijnSequence",
  "generateECDSAKeyPair",
  "generateHOTP",
  "generateImage",
  "generateLoremIpsum",
  "generatePGPKeyPair",
  "generateQRCode",
  "generateRSAKeyPair",
  "generateTOTP",
  "generateUUID",
  "genericCodeBeautify",
  "getAllCasings",
  "getTime",
  "groupIPAddresses",
  "gunzip",
  "gzip",
  "hammingDistance",
  "haversineDistance",
  "head",
  "heatmapChart",
  "help",
  "hexDensityChart",
  "hexToObjectIdentifier",
  "hexToPEM",
  "imageBrightnessContrast",
  "imageFilter",
  "imageHueSaturationLightness",
  "imageOpacity",
  "indexOfCoincidence",
  "invertImage",
  "javaScriptBeautify",
  "javaScriptMinify",
  "javaScriptParser",
  "jq",
  "jsonata",
  "jump",
  "keccak",
  "label",
  "levenshteinDistance",
  "lorenz",
  "luhnChecksum",
  "magic",
  "mean",
  "median",
  "merge",
  "microsoftScriptDecoder",
  "multipleBombe",
  "multiply",
  "murmurHash3",
  "normaliseImage",
  "normaliseUnicode",
  "numberwang",
  "objectIdentifierToHex",
  "offsetChecker",
  "opticalCharacterRecognition",
  "padLines",
  "parseASN1HexString",
  "parseCSR",
  "parseColourCode",
  "parseDateTime",
  "parseIPRange",
  "parseIPv4Header",
  "parseIPv6Address",
  "parseObjectIDTimestamp",
  "parseQRCode",
  "parseSSHHostKey",
  "parseTCP",
  "parseTLSRecord",
  "parseTLV",
  "parseUDP",
  "parseUNIXFilePermissions",
  "parseURI",
  "parseUserAgent",
  "parseX509CRL",
  "parseX509Certificate",
  "playMedia",
  "powerSet",
  "protobufDecode",
  "protobufEncode",
  "pseudoRandomNumberGenerator",
  "pubKeyFromCert",
  "pubKeyFromPrivKey",
  "rabbit",
  "railFenceCipherDecode",
  "railFenceCipherEncode",
  "randomizeColourPalette",
  "rawDeflate",
  "rawInflate",
  "register",
  "regularExpression",
  "removeDiacritics",
  "removeEXIF",
  "removeLineNumbers",
  "removeNullBytes",
  "removeWhitespace",
  "renderImage",
  "renderMarkdown",
  "resizeImage",
  "reverse",
  "risonDecode",
  "risonEncode",
  "rotateImage",
  "rotateLeft",
  "rotateRight",
  "salsa20",
  "scanForEmbeddedFiles",
  "scatterChart",
  "scrypt",
  "seriesChart",
  "setDifference",
  "setIntersection",
  "setUnion",
  "shake",
  "sharpenImage",
  "showBase64Offsets",
  "showOnMap",
  "shuffle",
  "sleep",
  "snefru",
  "sort",
  "split",
  "splitColourChannels",
  "standardDeviation",
  "streebog",
  "strings",
  "stripHTMLTags",
  "stripHTTPHeaders",
  "stripIPv4Header",
  "stripTCPHeader",
  "stripUDPHeader",
  "subsection",
  "substitute",
  "subtract",
  "sum",
  "swapCase",
  "swapEndianness",
  "symmetricDifference",
  "syntaxHighlighter",
  "tail",
  "takeBytes",
  "takeNthBytes",
  "tar",
  "template",
  "textEncodingBruteForce",
  "toBCD",
  "toBase",
  "toBase32",
  "toBase45",
  "toBase58",
  "toBase62",
  "toBase64",
  "toBase85",
  "toBase92",
  "toBinary",
  "toBraille",
  "toCamelCase",
  "toCaseInsensitiveRegex",
  "toCharcode",
  "toDecimal",
  "toFloat",
  "toHTMLEntity",
  "toHex",
  "toHexContent",
  "toHexdump",
  "toKebabCase",
  "toLowerCase",
  "toMessagePack",
  "toModhex",
  "toMorseCode",
  "toOctal",
  "toPunycode",
  "toQuotedPrintable",
  "toSnakeCase",
  "toTable",
  "toUNIXTimestamp",
  "toUpperCase",
  "translateDateTimeFormat",
  "tripleDESDecrypt",
  "tripleDESEncrypt",
  "typex",
  "unescapeString",
  "unescapeUnicodeCharacters",
  "unicodeTextFormat",
  "unique",
  "untar",
  "unzip",
  "varIntDecode",
  "varIntEncode",
  "viewBitPlane",
  "vigen\u00e8reDecode",
  "vigen\u00e8reEncode",
  "whirlpool",
  "windowsFiletimeToUNIXTimestamp",
  "zip",
  "zlibDeflate",
  "zlibInflate"
]
```

`tools/generate_docs.py`:

```py
import json
import re
from pathlib import Path


def title_to_camel(title_str: str) -> str:
    """Convert Title Case with spaces to camelCase.

    Args:
        title_str: Title Case string like 'From Base64'

    Returns:
        camelCase string like 'fromBase64'
    """
    words = title_str.split()
    if not words:
        return ""

    # First word lowercase, rest title case, remove spaces
    result = words[0].lower() + "".join(w.capitalize() for w in words[1:])
    # Remove any remaining spaces or special chars that shouldn't be in camelCase
    result = re.sub(r"[^a-zA-Z0-9]", "", result)
    return result


def format_arg(arg: dict) -> str:
    """Format an argument definition for markdown."""
    name = arg.get("name", "")
    arg_type = arg.get("type", "")
    value = arg.get("value", "")

    if arg_type == "option" and isinstance(value, list):
        options = ", ".join(f"`{v}`" for v in value[:3])
        if len(value) > 3:
            options += f" (+{len(value) - 3} more)"
        return f"  - **{name}** ({arg_type}): {options}"
    elif arg_type == "editableOption" and isinstance(value, list):
        # Handle both dict format and string format
        opt_names = []
        for v in value[:3]:
            if isinstance(v, dict):
                opt_names.append(f"`{v.get('name', '')}`")
            else:
                opt_names.append(f"`{v}`")
        options = ", ".join(opt_names)
        if len(value) > 3:
            options += f" (+{len(value) - 3} more)"
        return f"  - **{name}** ({arg_type}): {options}"
    elif arg_type == "boolean":
        return f"  - **{name}** ({arg_type}): default `{value}`"
    elif arg_type == "number":
        return f"  - **{name}** ({arg_type}): default `{value}`"
    else:
        return f"  - **{name}** ({arg_type}): default `{value}`"


def clean_html_description(desc: str) -> str:
    """Remove HTML tags from description."""
    # Remove <br> tags
    desc = desc.replace("<br><br>", "\n\n").replace("<br>", " ")
    # Remove <code> tags but keep content
    desc = re.sub(r"<code>(.*?)</code>", r"`\1`", desc)
    # Remove any other HTML tags
    desc = re.sub(r"<[^>]+>", "", desc)
    return desc.strip()


def generate_operation_doc(func_name: str, config: dict) -> str:
    """Generate markdown documentation for a single operation."""
    lines = []

    # Header
    lines.append(f"### `{func_name}()`")
    lines.append("")

    # Module
    module = config.get("module", "Unknown")
    lines.append(f"**Module:** {module}")
    lines.append("")

    # Description
    desc = clean_html_description(
        config.get("description", "No description available.")
    )
    lines.append(desc)
    lines.append("")

    # Info URL
    if info_url := config.get("infoURL"):
        lines.append(f"[More info]({info_url})")
        lines.append("")

    # Input/Output types
    input_type = config.get("inputType", "unknown")
    output_type = config.get("outputType", "unknown")
    lines.append(f"**Input:** `{input_type}` → **Output:** `{output_type}`")
    lines.append("")

    # Arguments
    if args := config.get("args"):
        lines.append("**Arguments:**")
        for arg in args:
            lines.append(format_arg(arg))
        lines.append("")

    lines.append("---")
    lines.append("")

    return "\n".join(lines)


def main():
    # Load operation list
    with open("cyberchef_operations.json") as f:
        operations = json.load(f)

    # Load operation config
    config_path = Path("deps/CyberChef/src/core/config/OperationConfig.json")
    with open(config_path) as f:
        operation_config = json.load(f)

    # Build reverse mapping: camelCase -> config_key
    # Convert each config key to camelCase and map it back
    # Use case-insensitive keys for lookup
    camel_to_config = {}
    for config_key in operation_config.keys():
        camel_name = title_to_camel(config_key)
        # Store both exact case and lowercase for flexible matching
        camel_to_config[camel_name] = config_key
        camel_to_config[camel_name.lower()] = config_key

    # Build documentation
    docs = []
    docs.append("# CyberChef Operations Reference")
    docs.append("")
    docs.append(
        f"This document lists all {len(operations)} available CyberChef operations."
    )
    docs.append("")
    docs.append("## Operations")
    docs.append("")

    mapped = 0
    unmapped = []

    for func_name in sorted(operations):
        # Look up the config key using the reverse mapping
        # Try exact match first, then case-insensitive
        config_key = camel_to_config.get(func_name) or camel_to_config.get(
            func_name.lower()
        )

        if config_key:
            config = operation_config[config_key]
            docs.append(generate_operation_doc(func_name, config))
            mapped += 1
        else:
            unmapped.append(func_name)

    # Save documentation
    docs_dir = Path("docs")
    docs_dir.mkdir(exist_ok=True)

    docs_path = docs_dir / "ops.md"
    with open(docs_path, "w") as f:
        f.write("\n".join(docs))

    print(f"Documentation generated: {docs_path}")
    print(f"Mapped: {mapped}/{len(operations)}")
    print(f"Unmapped: {len(unmapped)}")

    if unmapped:
        print("\nUnmapped operations (first 20):")
        for op in unmapped[:20]:
            print(f"  - {op}")


if __name__ == "__main__":
    main()

```

`tools/generate_operation_schema.py`:

```py
"""Generate operation schema from CyberChef runtime introspection."""

import json
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

from ida_cyberchef import cyberchef


def extract_js_value(ctx, js_expression):
    """Extract JavaScript value as Python object without double-encoding.

    Args:
        ctx: STPyV8 context
        js_expression: JavaScript expression to evaluate

    Returns: Python value (str, int, float, bool, list, dict, or None)
    """
    js_type = ctx.eval(f"typeof ({js_expression})")

    if js_type in ("string", "number", "boolean"):
        return ctx.eval(js_expression)
    elif js_type == "undefined" or ctx.eval(f"({js_expression}) === null"):
        return None
    else:
        try:
            json_str = ctx.eval(f"JSON.stringify({js_expression})")
            return json.loads(json_str) if json_str else None
        except Exception:
            return None


def extract_operation_metadata(chef, ctx, op_attr_name):
    """Extract metadata for a single operation using runtime introspection.

    Args:
        chef: CyberChef module instance
        ctx: STPyV8 context
        op_attr_name: Operation attribute name (camelCase)

    Returns: Dict with operation metadata or None if extraction fails
    """
    try:
        help_result = chef.help(op_attr_name)

        if not help_result or len(help_result) == 0:
            return None

        ctx.locals.help_result = help_result
        ctx.locals.item_index = 0

        name = ctx.eval("help_result[item_index].name")
        module = ctx.eval("help_result[item_index].module")
        description = ctx.eval("help_result[item_index].description")
        input_type = ctx.eval("help_result[item_index].inputType")
        output_type = ctx.eval("help_result[item_index].outputType")
        args_length = ctx.eval(
            "help_result[item_index].args ? help_result[item_index].args.length : 0"
        )

        op_info = {
            "name": name or op_attr_name,
            "module": module or "Unknown",
            "description": description or "",
            "inputType": input_type or "string",
            "outputType": output_type or "string",
            "args": [],
        }

        for i in range(args_length):
            ctx.locals.arg_index = i

            arg_name = ctx.eval("help_result[item_index].args[arg_index].name")
            arg_type = ctx.eval("help_result[item_index].args[arg_index].type")
            arg_value = extract_js_value(
                ctx, "help_result[item_index].args[arg_index].value"
            )

            arg_info = {
                "name": arg_name or "",
                "type": arg_type or "string",
                "value": arg_value if arg_value is not None else "",
            }

            has_toggle = ctx.eval(
                "help_result[item_index].args[arg_index].toggleValues !== undefined"
            )
            if has_toggle:
                toggle_values = extract_js_value(
                    ctx, "help_result[item_index].args[arg_index].toggleValues"
                )
                if toggle_values is not None:
                    arg_info["toggleValues"] = toggle_values

            op_info["args"].append(arg_info)

        return op_info

    except Exception as e:
        print(
            f"Warning: Failed to extract metadata for {op_attr_name}: {e}",
            file=sys.stderr,
        )
        return None


def extract_categories_and_favorites(categories_json_path):
    """Extract category and favorites data from CyberChef Categories.json.

    Args:
        categories_json_path: Path to Categories.json file

    Returns: Dict with 'categories' (operation name -> category) and 'favorites' list
    """
    with open(categories_json_path, "r") as f:
        categories_data = json.load(f)

    categories = {}
    favorites = []

    for category_group in categories_data:
        category_name = category_group.get("name", "")

        if category_name == "Favourites":
            favorites = category_group.get("ops", [])
            continue

        for op_name in category_group.get("ops", []):
            if op_name not in categories:
                categories[op_name] = category_name

    return {"categories": categories, "favorites": favorites}


def enhance_schema_with_categories(schema, categories_json_path):
    """Enhance operation schema with category and favorites data.

    Args:
        schema: Operation schema dict with 'operations' list
        categories_json_path: Path to Categories.json file

    Returns: Enhanced schema with category and is_favorite fields added to each operation
    """
    category_data = extract_categories_and_favorites(categories_json_path)
    categories = category_data["categories"]
    favorites = category_data["favorites"]

    for operation in schema["operations"]:
        op_name = operation.get("name", "")
        operation["category"] = categories.get(op_name, "Other")
        operation["is_favorite"] = op_name in favorites

    return schema


def introspect_operations():
    """Introspect CyberChef operations using runtime API.

    Returns: Dict with operations list
    """
    print("Loading CyberChef...", file=sys.stderr)
    chef = cyberchef.get_chef()
    ctx = chef._stpyv8_context

    print("Discovering operations...", file=sys.stderr)

    excluded_attrs = {
        "bake",
        "help",
        "operations",
        "Dish",
        "DishError",
        "OperationError",
        "ExcludedOperationError",
        "register",
    }

    operation_names = [
        name
        for name in dir(chef)
        if not name.startswith("_") and name not in excluded_attrs
    ]

    print(f"Found {len(operation_names)} operations to introspect", file=sys.stderr)

    operations = []
    failed_count = 0

    for i, op_name in enumerate(operation_names):
        if (i + 1) % 50 == 0:
            print(f"  Progress: {i + 1}/{len(operation_names)}", file=sys.stderr)

        op_info = extract_operation_metadata(chef, ctx, op_name)
        if op_info:
            operations.append(op_info)
        else:
            failed_count += 1

    print(f"\nSuccessfully extracted {len(operations)} operations", file=sys.stderr)
    if failed_count > 0:
        print(f"Failed to extract {failed_count} operations", file=sys.stderr)

    return {"operations": operations}


def main():
    schema = introspect_operations()

    categories_json_path = (
        Path(__file__).parent.parent
        / "deps"
        / "CyberChef"
        / "src"
        / "core"
        / "config"
        / "Categories.json"
    )

    print("\nEnhancing schema with categories and favorites...", file=sys.stderr)
    schema = enhance_schema_with_categories(schema, categories_json_path)

    output_path = (
        Path(__file__).parent.parent
        / "ida_cyberchef"
        / "data"
        / "operation_schema.json"
    )
    with open(output_path, "w") as f:
        json.dump(schema, f, indent=2)

    print(f"\nGenerated schema with {len(schema['operations'])} operations")
    print(f"Saved to: {output_path}")


if __name__ == "__main__":
    main()

```