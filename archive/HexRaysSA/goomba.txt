Project Path: arc_HexRaysSA_goomba_w4n4nw7g

Source Tree:

```txt
arc_HexRaysSA_goomba_w4n4nw7g
├── BUILDING.md
├── README.md
├── bitwise_expr_lookup_tbl.cpp
├── bitwise_expr_lookup_tbl.hpp
├── consts.hpp
├── equiv_class.cpp
├── equiv_class.hpp
├── file.cpp
├── file.hpp
├── generate_oracle.bat
├── generate_oracle.sh
├── goomba.cfg
├── goomba.cpp
├── heuristics.cpp
├── heuristics.hpp
├── images
│   ├── mba1_after.png
│   └── mba1_before.png
├── lin_conj_exprs.hpp
├── linear_exprs.cpp
├── linear_exprs.hpp
├── makefile
├── mcode_emu.hpp
├── minsn_template.hpp
├── msynth_parser.cpp
├── msynth_parser.hpp
├── nonlin_expr.hpp
├── optimizer.cpp
├── optimizer.hpp
├── simp_lin_conj_exprs.hpp
├── smt_convert.cpp
├── smt_convert.hpp
├── z3
│   └── readme.txt
└── z3++_no_warn.h

```

`BUILDING.md`:

```md

# Bulding gooMBA

## dependencies

gooMBA requires IDA SDK (8.2 or later) and the [z3 library](https://github.com/Z3Prover/z3).

## Building

1. After unpacking and setting up the SDK, copy goomba source tree under SDK's `plugins` directory, 
for example `C:\idasdk_pro82\plugins\goomba`.

2. Download and extract [z3 build for your OS](https://github.com/Z3Prover/z3/releases) into the `z3` subdirectory.

Under it, you should have `bin` and `include` directories:

    z3/bin/
    z3/include/

Alternatively, set `Z3_BIN` and `Z3_INCLUDE` to point to the directories elsewhere.

3. build the necessary version of gooMBA, for example:

```make -j```  for 32-bit IDA
```make __EA64__=1 -j```  for IDA64

4. Copy generated files from SDK's bin directory to your IDA install (or [user directory](https://hex-rays.com/blog/igors-tip-of-the-week-33-idas-user-directory-idausr/)):

On Windows:

 * `C:\idasdk_pro82\bin\plugins\goomba*` -> `C:\Program Files\IDA Pro 8.2\plugins\`
 * `C:\idasdk_pro82\bin\cfg\goomba.cfg` -> `C:\Program Files\IDA Pro 8.2\cfg\`
 * `C:\idasdk_pro82\bin\libz3.*` -> `C:\Program Files\IDA Pro 8.2\`

On linux:

 * `/path/to/idasdk_pro82/bin/plugins/goomba*` -> `/path/to/ida82/plugins/`
 * `/path/to/idasdk_pro82/bin/cfg/goomba.cfg` -> `/path/to/ida82/cfg/`
 * `/path/to/idasdk_pro82/bin/libz3.*` -> `/path/to/ida82/`

On macOS:

 * `/path/to/idasdk_pro82/bin/plugins/goomba*` -> `/path/to/ida82/ida.app/Contents/MacOS/plugins/`
 * `/path/to/idasdk_pro82/bin/cfg/goomba.cfg` -> `/path/to/ida82/ida.app/Contents/MacOS/cfg/`
 * `/path/to/idasdk_pro82/bin/libz3.*` -> `/path/to/ida82/ida.app/Contents/MacOS/`
 * `/path/to/idasdk_pro82/bin/libz3.*` -> `/path/to/ida82/ida64.app/Contents/MacOS/`


```

`README.md`:

```md
# gooMBA

gooMBA is a Hex-Rays Decompiler plugin that simplifies Mixed Boolean-Arithmetic
(MBA) expressions. It achieves this using several heuristics and algorithms to
achieve orders-of-magnitude better performance than existing state-of-the-art
solutions.

More information on the inner workings of this tool is available in our [blog
post](https://hex-rays.com/blog/deobfuscation-with-goomba/).

## Core Features
- Full integration with the Hex-Rays Decompiler
- Simplifies linear MBAs, including opaque predicates
- Handles sign extension for linear functions
- Verifies soundness of simplifications using the z3 SMT solver
- Simplifies non-linear MBAs with the use of a function fingerprint oracle

## Usage

By default, the plugin does not run automatically. You can invoke the plugin
by right clicking in the pseudocode view and selecting "Run gooMBA Optimizer".
In addition, you can set up a keyboard shortcut in IDA by opening Options ->
Shortcuts... and adding a shortcut for the `goomba:run` action.

Several options for usage are available within `goomba.cfg`. You can set up a
fingerprint oracle, configure the z3 proof timeout time, choose the desired behavior when
timeouts occur, and choose to make the plugin run automatically without needing
to be invoked from the right-click menu.

## Demo

The sample database `tests/idb/mba_challenge.i64` was created from the `mba_challenge` binary. The functions
`mba1`, `mba2`, `mba3`, `mba`, `solve_me` contain MBA expressions of varying complexity.

For example, the `mba1` function's initial pseudocode:
![mba1 initial pseudocode](./images/mba1_before.png)

And after running gooMBA optimization:
![mba1 pseudocode optimized](./images/mba1_after.png)


## Fingerprint oracle

The oracle can be used for simplifying non-linear MBAs.
The input for generaring it is a list of candidate expressions in [msynth](https://github.com/mrphrazer/msynth) syntax.
You can use `generate_oracle.sh` or `generate_oracle.bat` to generate a binary 
oracle file which can then be used by the plugin by specifying the path to it 
in `goomba.cfg` (parameter `MBA_ORACLE_PATH`).

A large pre-computed oracle is available [here](https://hex-rays.com/products/ida/support/freefiles/goomba-oracle.7z)

NOTE: oracle files generated with IDA 8.2 can only be used with 64-bit binaries, otherwise you may hit internal error 30661.

## Obtaining gooMBA

Please see the [releases](https://github.com/HexRaysSA/goomba/releases) section for `goomba` builds that will work with IDA Pro & IDA Teams v8.2.

Starting with version 8.3, `goomba` is shipped with IDA Pro & IDA Teams.

```

`bitwise_expr_lookup_tbl.cpp`:

```cpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include "bitwise_expr_lookup_tbl.hpp"

bw_expr_tbl_t bw_expr_tbl_t::instance;

bw_expr_tbl_t::bw_expr_tbl_t()
{
  minsn_templates_t X;
  X.push_back(std::make_shared<mt_varref_t>(0));
  X.push_back(std::make_shared<mt_varref_t>(1));
  X.push_back(std::make_shared<mt_varref_t>(2));

  minsn_template_ptr_t zero = std::make_shared<mt_constant_t>(0ull);

  // note that all expressions are ordered by the numeric value of the instruction trace
  // see lin_conj_exprs.hpp for more info on ordering.
  auto &onevar = tbl.push_back();
  onevar.push_back(zero); // [0 0]
  onevar.push_back(X[0]); // [0 1]

  auto &twovar = tbl.push_back();
  twovar.push_back(zero);           // [0 0 0 0]
  twovar.push_back(X[0]&~X[1]);     // [0 1 0 0]
  twovar.push_back(~(X[0]|~X[1]));  // [0 0 1 0]
  twovar.push_back(X[0]^X[1]);      // [0 1 1 0]
  twovar.push_back(X[0]&X[1]);      // [0 0 0 1]
  twovar.push_back(X[0]);           // [0 1 0 1]
  twovar.push_back(X[1]);           // [0 0 1 1]
  twovar.push_back(X[0]|X[1]);      // [0 1 1 1]

  auto &threevar = tbl.push_back();
  threevar.push_back(zero);                                   // [0 0 0 0 0 0 0 0]
  threevar.push_back(~(~X[0]|(X[1]|X[2])));                   // [0 1 0 0 0 0 0 0]
  threevar.push_back(~(X[0]|(~X[1]|X[2])));                   // [0 0 1 0 0 0 0 0]
  threevar.push_back(~X[2]&(X[0]^X[1]));                      // [0 1 1 0 0 0 0 0]
  threevar.push_back(~(~X[0]|(~X[1]|X[2])));                  // [0 0 0 1 0 0 0 0]
  threevar.push_back(X[0]&~X[2]);                             // [0 1 0 1 0 0 0 0]
  threevar.push_back(X[1]&~X[2]);                             // [0 0 1 1 0 0 0 0]
  threevar.push_back(X[2]^(X[0]|(X[1]|X[2])));                // [0 1 1 1 0 0 0 0]
  threevar.push_back(~X[0]&(~X[1]&X[2]));                     // [0 0 0 0 1 0 0 0]
  threevar.push_back(~X[1]&(X[0]^X[2]));                      // [0 1 0 0 1 0 0 0]
  threevar.push_back(~X[0]&(X[1]^X[2]));                      // [0 0 1 0 1 0 0 0]
  threevar.push_back(~(X[0]&X[1])&(X[0]^(X[1]^X[2])));        // [0 1 1 0 1 0 0 0]
  threevar.push_back(~(X[0]^X[1])&(X[0]^X[2]));               // [0 0 0 1 1 0 0 0]
  threevar.push_back(X[2]^(X[0]|(X[1]&X[2])));                // [0 1 0 1 1 0 0 0]
  threevar.push_back(~(X[0]&~X[1])&(X[1]^X[2]));              // [0 0 1 1 1 0 0 0]
  threevar.push_back(X[2]^(X[0]|X[1]));                       // [0 1 1 1 1 0 0 0]
  threevar.push_back(X[0]&(~X[1]&X[2]));                      // [0 0 0 0 0 1 0 0]
  threevar.push_back(X[0]&~X[1]);                             // [0 1 0 0 0 1 0 0]
  threevar.push_back((X[0]^X[1])&~(X[0]^X[2]));               // [0 0 1 0 0 1 0 0]
  threevar.push_back(X[1]^(X[0]|(X[1]&X[2])));                // [0 1 1 0 0 1 0 0]
  threevar.push_back(X[0]&(X[1]^X[2]));                       // [0 0 0 1 0 1 0 0]
  threevar.push_back(~(~X[0]|(X[1]&X[2])));                   // [0 1 0 1 0 1 0 0]
  threevar.push_back((X[0]|X[1])&(X[1]^X[2]));                // [0 0 1 1 0 1 0 0]
  threevar.push_back((X[0]&X[1])^~(X[0]^(~X[1]|X[2])));       // [0 1 1 1 0 1 0 0]
  threevar.push_back(~(X[1]|~X[2]));                          // [0 0 0 0 1 1 0 0]
  threevar.push_back(X[1]^(X[0]|(X[1]|X[2])));                // [0 1 0 0 1 1 0 0]
  threevar.push_back(~(X[0]&X[1])&(X[1]^X[2]));               // [0 0 1 0 1 1 0 0]
  threevar.push_back(X[1]^(X[0]|X[2]));                       // [0 1 1 0 1 1 0 0]
  threevar.push_back((X[0]|~X[1])&(X[1]^X[2]));               // [0 0 0 1 1 1 0 0]
  threevar.push_back((X[0]&X[2])^(X[0]^(~X[1]&X[2])));        // [0 1 0 1 1 1 0 0]
  threevar.push_back(X[1]^X[2]);                              // [0 0 1 1 1 1 0 0]
  threevar.push_back((X[0]&~X[1])|(X[1]^X[2]));               // [0 1 1 1 1 1 0 0]
  threevar.push_back(~X[0]&(X[1]&X[2]));                      // [0 0 0 0 0 0 1 0]
  threevar.push_back((X[0]^X[1])&(X[0]^X[2]));                // [0 1 0 0 0 0 1 0]
  threevar.push_back(~(X[0]|~X[1]));                          // [0 0 1 0 0 0 1 0]
  threevar.push_back(X[1]^~(~X[0]|(~X[1]&X[2])));             // [0 1 1 0 0 0 1 0]
  threevar.push_back(X[1]&(X[0]^X[2]));                       // [0 0 0 1 0 0 1 0]
  threevar.push_back(X[2]^(X[0]|(~X[1]&X[2])));               // [0 1 0 1 0 0 1 0]
  threevar.push_back(X[1]&~(X[0]&X[2]));                      // [0 0 1 1 0 0 1 0]
  threevar.push_back(X[1]^~(~X[0]|(X[1]^X[2])));              // [0 1 1 1 0 0 1 0]
  threevar.push_back(~(X[0]|~X[2]));                          // [0 0 0 0 1 0 1 0]
  threevar.push_back(X[2]^(X[0]&(~X[1]|X[2])));               // [0 1 0 0 1 0 1 0]
  threevar.push_back(~X[0]&(X[1]|X[2]));                      // [0 0 1 0 1 0 1 0]
  threevar.push_back(X[0]^(X[1]|X[2]));                       // [0 1 1 0 1 0 1 0]
  threevar.push_back(X[2]^(X[0]&(X[1]|X[2])));                // [0 0 0 1 1 0 1 0]
  threevar.push_back(X[0]^X[2]);                              // [0 1 0 1 1 0 1 0]
  threevar.push_back((X[0]&X[2])^(X[1]|X[2]));                // [0 0 1 1 1 0 1 0]
  threevar.push_back(X[2]^~(~X[0]&(~X[1]|X[2])));             // [0 1 1 1 1 0 1 0]
  threevar.push_back(X[2]&(X[0]^X[1]));                       // [0 0 0 0 0 1 1 0]
  threevar.push_back(X[1]^~(~X[0]&(~X[1]|X[2])));             // [0 1 0 0 0 1 1 0]
  threevar.push_back(X[1]^(X[0]&(X[1]|X[2])));                // [0 0 1 0 0 1 1 0]
  threevar.push_back(X[0]^X[1]);                              // [0 1 1 0 0 1 1 0]
  threevar.push_back((X[0]|X[1])&~(X[0]^(X[1]^X[2])));        // [0 0 0 1 0 1 1 0]
  threevar.push_back(X[0]^(X[1]&X[2]));                       // [0 1 0 1 0 1 1 0]
  threevar.push_back(X[1]^(X[0]&X[2]));                       // [0 0 1 1 0 1 1 0]
  threevar.push_back(X[1]^(X[0]&(~X[1]|X[2])));               // [0 1 1 1 0 1 1 0]
  threevar.push_back(X[2]&~(X[0]&X[1]));                      // [0 0 0 0 1 1 1 0]
  threevar.push_back(X[1]^(X[0]|(X[1]^X[2])));                // [0 1 0 0 1 1 1 0]
  threevar.push_back((X[0]&X[1])^(X[1]|X[2]));                // [0 0 1 0 1 1 1 0]
  threevar.push_back(X[1]^(X[0]|(~X[1]&X[2])));               // [0 1 1 0 1 1 1 0]
  threevar.push_back(X[2]^(X[0]&X[1]));                       // [0 0 0 1 1 1 1 0]
  threevar.push_back(X[2]^~(~X[0]|(~X[1]&X[2])));             // [0 1 0 1 1 1 1 0]
  threevar.push_back(~(X[0]|~X[1])|(X[1]^X[2]));              // [0 0 1 1 1 1 1 0]
  threevar.push_back((X[0]^X[1])|(X[0]^X[2]));                // [0 1 1 1 1 1 1 0]
  threevar.push_back(X[0]&(X[1]&X[2]));                       // [0 0 0 0 0 0 0 1]
  threevar.push_back(~(~X[0]|(X[1]^X[2])));                   // [0 1 0 0 0 0 0 1]
  threevar.push_back(X[1]&~(X[0]^X[2]));                      // [0 0 1 0 0 0 0 1]
  threevar.push_back((X[0]|X[1])&(X[0]^(X[1]^X[2])));         // [0 1 1 0 0 0 0 1]
  threevar.push_back(X[0]&X[1]);                              // [0 0 0 1 0 0 0 1]
  threevar.push_back(~(~X[0]|(~X[1]&X[2])));                  // [0 1 0 1 0 0 0 1]
  threevar.push_back(X[1]&(X[0]|~X[2]));                      // [0 0 1 1 0 0 0 1]
  threevar.push_back((X[1]&~X[2])|~(~X[0]|(~X[1]&X[2])));     // [0 1 1 1 0 0 0 1]
  threevar.push_back(X[2]&~(X[0]^X[1]));                      // [0 0 0 0 1 0 0 1]
  threevar.push_back((X[0]|~X[1])&(X[0]^(X[1]^X[2])));        // [0 1 0 0 1 0 0 1]
  threevar.push_back(~(X[0]&~X[1])&(X[0]^(X[1]^X[2])));       // [0 0 1 0 1 0 0 1]
  threevar.push_back(X[0]^(X[1]^X[2]));                       // [0 1 1 0 1 0 0 1]
  threevar.push_back(X[1]^(~X[0]&(X[1]|X[2])));               // [0 0 0 1 1 0 0 1]
  threevar.push_back(X[0]^(~X[1]&X[2]));                      // [0 1 0 1 1 0 0 1]
  threevar.push_back(X[1]^~(X[0]|~X[2]));                     // [0 0 1 1 1 0 0 1]
  threevar.push_back((X[0]&X[1])|(X[0]^(X[1]^X[2])));         // [0 1 1 1 1 0 0 1]
  threevar.push_back(X[0]&X[2]);                              // [0 0 0 0 0 1 0 1]
  threevar.push_back(X[0]&(~X[1]|X[2]));                      // [0 1 0 0 0 1 0 1]
  threevar.push_back(X[2]^(~X[0]&(X[1]|X[2])));               // [0 0 1 0 0 1 0 1]
  threevar.push_back(~(X[0]^(~X[1]|X[2])));                   // [0 1 1 0 0 1 0 1]
  threevar.push_back(X[0]&(X[1]|X[2]));                       // [0 0 0 1 0 1 0 1]
  threevar.push_back(X[0]);                                   // [0 1 0 1 0 1 0 1]
  threevar.push_back((X[0]&X[2])|(X[1]&~X[2]));               // [0 0 1 1 0 1 0 1]
  threevar.push_back(~(~X[0]&(~X[1]|X[2])));                  // [0 1 1 1 0 1 0 1]
  threevar.push_back(X[2]&(X[0]|~X[1]));                      // [0 0 0 0 1 1 0 1]
  threevar.push_back((X[1]&~X[2])^(X[0]|(X[1]^X[2])));        // [0 1 0 0 1 1 0 1]
  threevar.push_back(X[2]^~(X[0]|~X[1]));                     // [0 0 1 0 1 1 0 1]
  threevar.push_back((X[0]&~X[1])|(X[0]^(X[1]^X[2])));        // [0 1 1 0 1 1 0 1]
  threevar.push_back((X[0]&X[1])|~(X[1]|~X[2]));              // [0 0 0 1 1 1 0 1]
  threevar.push_back(X[0]|(~X[1]&X[2]));                      // [0 1 0 1 1 1 0 1]
  threevar.push_back((X[0]&X[1])|(X[1]^X[2]));                // [0 0 1 1 1 1 0 1]
  threevar.push_back(X[0]|(X[1]^X[2]));                       // [0 1 1 1 1 1 0 1]
  threevar.push_back(X[1]&X[2]);                              // [0 0 0 0 0 0 1 1]
  threevar.push_back((X[0]|X[1])&~(X[1]^X[2]));               // [0 1 0 0 0 0 1 1]
  threevar.push_back(X[1]&~(X[0]&~X[2]));                     // [0 0 1 0 0 0 1 1]
  threevar.push_back(X[1]^(X[0]&~X[2]));                      // [0 1 1 0 0 0 1 1]
  threevar.push_back(X[1]&(X[0]|X[2]));                       // [0 0 0 1 0 0 1 1]
  threevar.push_back((X[0]&X[2])^(X[0]^(X[1]&X[2])));         // [0 1 0 1 0 0 1 1]
  threevar.push_back(X[1]);                                   // [0 0 1 1 0 0 1 1]
  threevar.push_back(X[1]|(X[0]&~X[2]));                      // [0 1 1 1 0 0 1 1]
  threevar.push_back(X[2]&~(X[0]&~X[1]));                     // [0 0 0 0 1 0 1 1]
  threevar.push_back(X[2]^(X[0]&~X[1]));                      // [0 1 0 0 1 0 1 1]
  threevar.push_back((X[1]&X[2])|(~X[0]&(X[1]|X[2])));        // [0 0 1 0 1 0 1 1]
  threevar.push_back(~(X[0]|~X[1])|(X[0]^(X[1]^X[2])));       // [0 1 1 0 1 0 1 1]
  threevar.push_back(X[1]^(~X[0]&(X[1]^X[2])));               // [0 0 0 1 1 0 1 1]
  threevar.push_back(X[2]^~(~X[0]|(X[1]&X[2])));              // [0 1 0 1 1 0 1 1]
  threevar.push_back(X[1]|~(X[0]|~X[2]));                     // [0 0 1 1 1 0 1 1]
  threevar.push_back(X[1]|(X[0]^X[2]));                       // [0 1 1 1 1 0 1 1]
  threevar.push_back(X[2]&(X[0]|X[1]));                       // [0 0 0 0 0 1 1 1]
  threevar.push_back((X[0]&X[1])^(X[0]^(X[1]&X[2])));         // [0 1 0 0 0 1 1 1]
  threevar.push_back(X[1]^(X[0]&(X[1]^X[2])));                // [0 0 1 0 0 1 1 1]
  threevar.push_back(X[1]^~(~X[0]|(X[1]&X[2])));              // [0 1 1 0 0 1 1 1]
  threevar.push_back((X[1]&X[2])|(X[0]&(X[1]|X[2])));         // [0 0 0 1 0 1 1 1]
  threevar.push_back(X[0]|(X[1]&X[2]));                       // [0 1 0 1 0 1 1 1]
  threevar.push_back(X[1]|(X[0]&X[2]));                       // [0 0 1 1 0 1 1 1]
  threevar.push_back(X[0]|X[1]);                              // [0 1 1 1 0 1 1 1]
  threevar.push_back(X[2]);                                   // [0 0 0 0 1 1 1 1]
  threevar.push_back(X[2]|(X[0]&~X[1]));                      // [0 1 0 0 1 1 1 1]
  threevar.push_back(X[2]|~(X[0]|~X[1]));                     // [0 0 1 0 1 1 1 1]
  threevar.push_back(X[2]|(X[0]^X[1]));                       // [0 1 1 0 1 1 1 1]
  threevar.push_back(X[2]|(X[0]&X[1]));                       // [0 0 0 1 1 1 1 1]
  threevar.push_back(X[0]|X[2]);                              // [0 1 0 1 1 1 1 1]
  threevar.push_back(X[1]|X[2]);                              // [0 0 1 1 1 1 1 1]
  threevar.push_back(X[0]|(X[1]|X[2]));                       // [0 1 1 1 1 1 1 1]
}

```

`bitwise_expr_lookup_tbl.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include "minsn_template.hpp"

// bw_expr_tbl_t is a singleton class that maintains a lookup table mapping
// boolean function evaluation traces (i.e. I/O behavior) to the shortest
// representation of each boolean function.
// for instance, if you found a boolean function f(x, y) with the following
// behavior: f(0, 0) = 0, f(0, 1) = 0, f(1, 0) = 0, f(1, 1) = 1, then you
// can query this object to find that f(x, y) = x & y.
// note that we do not consider any functions that return 1 on the all-zeros
// input.
class bw_expr_tbl_t
{
  qvector<minsn_templates_t> tbl;

public:
  static bw_expr_tbl_t instance;

  // do not call directly, use instance instead
  bw_expr_tbl_t();

  // eval_trace is a bitmap whose i'th bit contains the
  // boolean function's evaluation on the i'th conjunction,
  // where conjunctions are ordered in the same way as in lin_conj_exprs.hpp
  minsn_template_ptr_t lookup(int nvars, uint64_t bit_trace)
  {
    QASSERT(30698, (bit_trace & 1) == 0);
    QASSERT(30699, nvars <= 3);
    QASSERT(30700, nvars >= 1);
    QASSERT(30701, bit_trace < (1ull << (1ull << (nvars))));
    return tbl[nvars-1][bit_trace >> 1];
    // since the 0th conjunction is never considered, all vector indices are
    // divided by 2. See the corresponding .cpp file for more info.
  }
};

```

`consts.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#define ACTION_NAME "goomba:run"
// Z3_TIMEOUT_MS defines the amount of time we allow the z3 theorem prover to
// take to prove any given statement
#define Z3_TIMEOUT_MS 1000

// Only used for *generating* oracles: how many test cases to run against each
// function to generate fingerprints. Note that an existing oracle will report
// its own number, and the below constant will not be used
#define TCS_PER_EQUIV_CLASS 128
// The number of inputs used when evaluating functions for fingerprinting
#define CANDIDATE_EXPR_NUMINPUTS 5
// The maximum number of candidates to consider which have the same fingerprint
// as the expression being simplified
#define EQUIV_CLASS_MAX_CANDIDATES 10
// The maximum number of fingerprints to consider for each expression being
// simplified -- this number is greater than one since we consider every
// possible assignment of input variables
#define EQUIV_CLASS_MAX_FINGERPRINTS 50
```

`equiv_class.cpp`:

```cpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include "equiv_class.hpp"
#include "optimizer.hpp"


//-------------------------------------------------------------------------
// replaces all references to abstract mop_l's with variables from new_vars
minsn_t *make_concrete_minsn(ea_t ea, const minsn_t &minsn, const mopvec_t &new_vars, int newsz)
{
  struct mop_reassigner_t : public mop_visitor_t
  {
    const mopvec_t &new_vars;
    ea_t ea;
    mop_reassigner_t(ea_t e, const mopvec_t &nm)
      : new_vars(nm), ea(e) {}
    int idaapi visit_mop(mop_t *op, const tinfo_t *, bool)
    {
      if ( op->t == mop_l )
      {
        int idx = op->l->idx;
        if ( idx >= new_vars.size() )
          return -1;
        op->t = mop_d;
        op->d = resize_mop(ea, new_vars.at(idx), op->size, false);
      }
      return 0;
    }
  };

  minsn_t *res = nullptr;
  minsn_t *copy = new minsn_t(minsn);

  mop_reassigner_t mr(ea, new_vars);
  int code = copy->for_all_ops(mr);
  if ( code >= 0 )
  {
    copy->setaddr(ea);

    // resize res to the correct output size
    mop_t res_mop;
    res_mop.create_from_insn(copy);
    res = resize_mop(ea, res_mop, newsz, false);
  }
  delete copy;
  return res;
}

//-------------------------------------------------------------------------
static void create_var_mapping(var_mapping_t &dest, const mopvec_t &mops)
{
  for ( size_t i = 0; i < mops.size(); i++ )
    dest.insert( { mops[i], i } );
}

//-------------------------------------------------------------------------
void equiv_class_finder_t::find_candidates(minsnptrs_t *out, const minsn_t &insn)
{
  std::set<func_fingerprint_t> seen;
  int num_fingerprints = 0; // includes duplicate fingerprints
  int num_candidates = 0;

  mopvec_t input_mops = get_input_mops(insn);
  do
  {
    var_mapping_t mapping;
    create_var_mapping(mapping, input_mops);

    func_fingerprint_t fingerprint = compute_fingerprint(insn, &mapping);
//    msg("goomba: computed fingerprint %" FMT_64 "x\n", fingerprint);

    num_fingerprints++;
    if ( num_fingerprints > EQUIV_CLASS_MAX_FINGERPRINTS )
      break;

    if ( !seen.insert(fingerprint).second )
      continue; // already seen

    const minsn_set_t *equiv_class = find_equiv_class(fingerprint);
    if ( equiv_class != nullptr )
    {
      for ( const auto &mi : *equiv_class )
      {
        num_candidates++;
//        msg("goomba: fingerprint matches: %s\n", mi->dstr());
        minsn_t *concrete = make_concrete_minsn(insn.ea, *mi, input_mops, insn.d.size);
        if ( concrete != nullptr )
          out->push_back(concrete);

        if ( num_candidates >= EQUIV_CLASS_MAX_CANDIDATES )
          break;
      }
    }

  } while ( std::next_permutation(input_mops.begin(), input_mops.end()) );
}

```

`equiv_class.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>
#include "msynth_parser.hpp"
#include "heuristics.hpp"
#include "linear_exprs.hpp"
#include "consts.hpp"

struct minsn_with_mapping_t;

typedef std::set<minsn_t*, minsn_complexity_cmptr_t> minsn_set_t;

typedef qvector<uint64> output_behavior_t;
typedef qvector<uint64> testcase_t;
typedef std::map<mop_t, int> var_mapping_t;
typedef uint64 func_fingerprint_t;
typedef std::map<func_fingerprint_t, minsn_set_t> equiv_class_map_t;

#define CHECK_SERIALIZATION_CONSISTENCY true

//-------------------------------------------------------------------------
// output behavior is summarized as a list of uint64's, each corresponding to a test case
inline func_fingerprint_t compute_fingerprint_from_outputs(const output_behavior_t &outputs)
{
  // FNV-1a, as per Wikipedia
  const uint64 FNV_BASIS = 0xcbf29ce484222325;
  const uint64 FNV_PRIME = 0x100000001b3;
  uint64 sum = FNV_BASIS;
  for ( uint64 c : outputs )
  {
    sum ^= c;
    sum *= FNV_PRIME;
  }
  return sum;
}

//-------------------------------------------------------------------------
inline void gen_testcase(testcase_t *tc)
{
  tc->resize(CANDIDATE_EXPR_NUMINPUTS);
  for ( auto &v : *tc )
    v = gen_rand_mcode_val(8).val;
}

//-------------------------------------------------------------------------
class equiv_class_finder_t
{
public:
  equiv_class_map_t equiv_classes;
  qvector<testcase_t> testcases;

  //-------------------------------------------------------------------------
  // helper_emu_t evaluates expressions for a given test case and variable mapping
  struct helper_emu_t : public int64_emulator_t
  {
    const testcase_t &tc;
    const var_mapping_t *var_mapping; // maps variables to input index
    // assigning a nullptr var_mapping indicates that the indexing should be done
    // according to the abstract mop's self-declared index

    helper_emu_t (const testcase_t &t, const var_mapping_t *vm)
      : tc(t), var_mapping(vm) {}

    virtual intval64_t get_mop_value(const mop_t &mop) override
    {
      if ( var_mapping == nullptr )
      {
        // the instruction must be abstract, get the index from the mop itself
        QASSERT(30773, mop.t == mop_l);
        return intval64_t(tc[mop.l->idx], mop.size);
      }
      return intval64_t(tc.at(var_mapping->at(mop)), mop.size);
    }
  };

  virtual ~equiv_class_finder_t() {}

  //-------------------------------------------------------------------------
  equiv_class_finder_t()
  {
    testcases.resize(TCS_PER_EQUIV_CLASS);
    for ( auto &tc : testcases )
      gen_testcase(&tc);
  }

  //-------------------------------------------------------------------------
  // mapping = nullptr means the instruction is abstract (all terminal mops
  // have type mop_l), and mop indices will be retrieved by querying mop.l->idx
  func_fingerprint_t compute_fingerprint(
        const minsn_t &ins,
        const var_mapping_t *mapping = nullptr)
  {
    output_behavior_t res;
    res.reserve(testcases.size());
    for ( const auto &tc : testcases )
    {
      helper_emu_t emu(tc, mapping);
      res.push_back(emu.minsn_value(ins).val);
    }
    return compute_fingerprint_from_outputs(res);
  }

  //-------------------------------------------------------------------------
  func_fingerprint_t compute_fingerprint_from_serialization(
        uchar *buf, uint32 sz,
        int version = -1,
        const var_mapping_t *mapping = nullptr)
  {
    if ( version == -1 ) // use current serialization version
    {
      bytevec_t bv;
      version = minsn_t(0).serialize(&bv);
    }
    minsn_t minsn(0);
    minsn.deserialize(buf, sz, version);

    return compute_fingerprint(minsn, mapping);
  }

  //-------------------------------------------------------------------------
  // computes the fingerprint of the abstract minsn and adds it to the index
  void add_abstract_minsn(minsn_t *ins)
  {
    auto fingerprint = compute_fingerprint(*ins);
    auto it = equiv_classes.find(fingerprint);
    if ( it != equiv_classes.end() )
    {
      // check if semantically equivalent expression already exists
      for ( const auto &o : it->second )
        if ( probably_equivalent(*o, *ins) )
          return;
      it->second.insert(ins);
    }
    else
    {
      minsn_set_t new_entry;
      new_entry.insert(ins);
      equiv_classes.insert( { fingerprint, new_entry } );
    }
  }

  //-------------------------------------------------------------------------
  virtual const minsn_set_t *find_equiv_class(func_fingerprint_t fingerprint)
  {
    auto p = equiv_classes.find(fingerprint);
    if ( p != equiv_classes.end() )
      return &p->second;
    return nullptr;
  }

  //-------------------------------------------------------------------------
  // find candidate minsns that match the fingerprint of the given minsn
  // before being added, these are made concrete -- the abstract mop_l's are
  // replaced by real mops from the input insn
  void find_candidates(minsnptrs_t *out, const minsn_t &insn);
};

//-------------------------------------------------------------------------
struct equiv_class_idx_entry_t
{
  func_fingerprint_t fingerprint;
  uint64_t offset;
  // offset relative to the beginning of where minsns are stored within the oracle file

  bool operator<(const equiv_class_idx_entry_t &o) const
  {
    return fingerprint < o.fingerprint;
  }
};

//-------------------------------------------------------------------------
struct equiv_class_idx_t
{
  qvector<equiv_class_idx_entry_t> index;

  //-------------------------------------------------------------------------
  void read_from_file(FILE *file)
  {
    uint32 idx_sz;
    if ( qfread(file, &idx_sz, sizeof(idx_sz)) != sizeof(idx_sz) )
      INTERR(30719);
    CASSERT(sizeof(equiv_class_idx_entry_t) == 16);

    index.resize_noinit(idx_sz);
    size_t nbytes = idx_sz * sizeof(equiv_class_idx_entry_t);
    if ( qfread(file, index.begin(), nbytes) != nbytes )
      INTERR(30767);
  }

  //-------------------------------------------------------------------------
  size_t find(func_fingerprint_t fp)
  {
    equiv_class_idx_entry_t key;
    key.fingerprint = fp;
    auto p = std::lower_bound(index.begin(), index.end(), key);
    if ( p == index.end() || p->fingerprint != fp )
      return -1;
    return p->offset;
  }
};

//-------------------------------------------------------------------------
// lazy-loading collection of equivalence classes
struct equiv_class_finder_lazy_t : public equiv_class_finder_t
{
  FILE *file;
  qoff64_t fsize;
  uint32 format_version; // format version used to serialize minsn_t's
  equiv_class_idx_t index;
  uint64 minsns_offset; // offset at which the minsns table begins

  virtual ~equiv_class_finder_lazy_t() { qfclose(file); }

  //-------------------------------------------------------------------------
  //lint -sem(equiv_class_finder_lazy_t::equiv_class_finder_lazy_t, custodial(1))
  equiv_class_finder_lazy_t(FILE *f) : file(f)
  {
    fsize = qfsize(file);

    // read in the format version
    if ( qfread(file, &format_version, sizeof(format_version)) != sizeof(format_version) )
      INTERR(30774);

    // read and validate the number of the test cases
    uint32 n_tcs;
    if ( qfread(file, &n_tcs, sizeof(n_tcs)) != sizeof(n_tcs) )
      INTERR(30775);
    if ( n_tcs > fsize )
      INTERR(30768);

    // read in the test cases
    testcases.resize(n_tcs);
    for ( auto &new_tc : testcases )
    {
      new_tc.resize(CANDIDATE_EXPR_NUMINPUTS);
      for ( uint64 &new_inp : new_tc )
        if ( qfread(file, &new_inp, sizeof(new_inp)) != sizeof(new_inp) )
          INTERR(30776);
    }

    // read in the index
    index.read_from_file(file);

    minsns_offset = qftell(file);
//    msg("minsns offset %llu", minsns_offset);
  }

  //-------------------------------------------------------------------------
  // populates the equiv_classes map with the minsn set included in the file
  // for the given fingerprint
  void read_minsn_set_from_file(func_fingerprint_t fp)
  {
    int64 idx_lookup = index.find(fp);
    if ( idx_lookup < 0 )
      return; // fingerprint doesn't exist in oracle
    if ( equiv_classes.count(fp) != 0 )
      return; // we already loaded in the equiv class

    uint64 minsn_offset = minsns_offset + idx_lookup;
    if ( qfseek(file, minsn_offset, SEEK_SET) != 0 )
      INTERR(30722);

    uint32 n_minsns;
    if ( qfread(file, &n_minsns, sizeof(n_minsns)) != sizeof(n_minsns) )
      INTERR(30723);
    if ( n_minsns > fsize ) // sanity check
      INTERR(30769);

    bytevec_t bv;
    minsn_set_t &set = equiv_classes[fp];
    for ( uint32 i = 0; i < n_minsns; i++ )
    {
      uint32 minsn_sz;
      if ( qfread(file, &minsn_sz, sizeof(minsn_sz)) != sizeof(minsn_sz) )
        INTERR(30724);
      if ( minsn_sz > fsize ) // sanity check
        INTERR(30770);
      bv.resize(minsn_sz);
      if ( qfread(file, bv.begin(), minsn_sz) != minsn_sz )
        INTERR(30725);
      minsn_t *minsn = new minsn_t(0);
      minsn->deserialize(bv.begin(), minsn_sz, format_version);
      set.insert(minsn);
    }
  }

  //-------------------------------------------------------------------------
  const minsn_set_t *find_equiv_class(func_fingerprint_t fingerprint) override
  {
    read_minsn_set_from_file(fingerprint);
    return equiv_class_finder_t::find_equiv_class(fingerprint);
  }

  //-------------------------------------------------------------------------
  bool optimize(minsn_t &insn);
};

```

`file.cpp`:

```cpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include <hexrays.hpp>
#include <fpro.h>
#include "file.hpp"
#include "msynth_parser.hpp"
#include "simp_lin_conj_exprs.hpp"
#include "heuristics.hpp"
#include "equiv_class.hpp"

//-------------------------------------------------------------------------
// In fact this function is not really needed. The user can simply turn on
// the timestamp display in the output window.
static qstring curtime()
{
  char buf[64];
  char *ptr = buf;
  char *end = buf + sizeof(buf);
  qtime64_t ts = qtime64();
  ptr += qstrftime64(ptr, end-ptr, "%H:%M:%S", ts);
  uint32 msecs = get_usecs(ts) / 1000;
  qsnprintf(ptr, end-ptr, ".%03d", msecs);
  return qstring(buf);
}

//-------------------------------------------------------------------------
static bool is_linear(const minsn_t *insn)
{
  switch ( insn->opcode )
  {
    case m_ldc:     // constant
      return true;
    case m_mov:     // variable
      return !insn->l.is_insn();

    case m_add:
    case m_sub:
      return is_linear(insn->l.d) && is_linear(insn->r.d);

    case m_mul:
      return (insn->l.is_constant() && is_linear(insn->r.d))
          || (insn->r.is_constant() && is_linear(insn->l.d));

    default:
      return false;
  }
}

//-------------------------------------------------------------------------
void create_minsns_file(FILE *msynth_in, FILE *minsns_out)
{
  qstring line;
  int n_proc = 0;
  int n_written = 0;
  while ( qgetline(&line, msynth_in) >= 0 )
  {
    n_proc++;
    if ( line.size() == 0 )
      continue;
    if ( n_proc % REPORT_FREQ == 0 )
      msg("%s: Processed %d, Wrote %d\n", curtime().c_str(), n_proc, n_written);
    mopvec_t default_vars;
    //-------------------------------------------------------------------------
    // an *abstract* mop is a mop_l that does not refer to anything within a
    // specific program, it is a placeholder for minsn templates
    for ( int i = 0; i < CANDIDATE_EXPR_NUMINPUTS; i++ )
    {
      mop_t new_var;
      new_var.t = mop_l;
      new_var.l = new lvar_ref_t(nullptr, i);
      new_var.size = 8;
      default_vars.push_back(new_var);
    }

    msynth_expr_parser_t mep(line.c_str(), default_vars);
    minsn_t *insn = mep.parse_next_expr();

    if ( is_linear(insn) )
      continue;

    bytevec_t bv;
    insn->serialize(&bv);
    uint32 bv_sz = bv.size();
    qfwrite(minsns_out, &bv_sz, sizeof(bv_sz));
    qfwrite(minsns_out, bv.begin(), bv_sz);
    n_written++;

    delete insn;
  }

  msg("%s: Processed %d, Wrote %d\n", curtime().c_str(), n_proc, n_written);
}

//-------------------------------------------------------------------------
// bytevec comparison based on length
struct bv_len_cmptr_t
{
  inline bool operator()(const bytevec_t &a, const bytevec_t &b) const
  {
    auto asz = a.size();
    auto bsz = b.size();
    return std::tie(asz, a) < std::tie(bsz, b);
  }
};
typedef std::set<bytevec_t, bv_len_cmptr_t> bvset_t;

//-------------------------------------------------------------------------
inline size_t bv_sz_on_disk(const bytevec_t &bv)
{
  return sizeof(uint32) + bv.size();
}

//-------------------------------------------------------------------------
static void write_bv_to_disk(FILE *fout, const bytevec_t &bv)
{
  uint32 bv_sz = bv.size();
  qfwrite(fout, &bv_sz, sizeof(bv_sz));
  qfwrite(fout, bv.begin(), bv_sz);
}

//-------------------------------------------------------------------------
static size_t bvset_sz_on_disk(const bvset_t &bvset)
{
  size_t res = sizeof(uint32);
  for ( const auto &bv : bvset )
    res += bv_sz_on_disk(bv);
  return res;
}

//-------------------------------------------------------------------------
static void write_bvset_to_disk(FILE *fout, const bvset_t &bvset)
{
  uint32 bvset_sz = bvset.size();
  qfwrite(fout, &bvset_sz, sizeof(bvset_sz));
  for ( const auto &bv : bvset )
    write_bv_to_disk(fout, bv);
}

//-------------------------------------------------------------------------
bool create_oracle_file(FILE *minsns_in, FILE *oracle_out)
{
  // begin by loading the minsns from the file and generating fingerprints
  // keeping full minsns in memory would take too much space, so we store them as strings
  // and use string length as a proxy for complexity
  std::map<func_fingerprint_t, bvset_t> oracle;
  equiv_class_finder_t ecf;

  int n_proc = 0;
  while ( true )
  {
    if ( n_proc % REPORT_FREQ == 0 )
      msg("%s: Processed %d, #Fingerprints %" FMT_Z "\n", curtime().c_str(), n_proc, oracle.size());
    n_proc++;
    uint32 minsn_sz;
    if ( qfread(minsns_in, &minsn_sz, sizeof(minsn_sz)) != sizeof(minsn_sz) )
      break;
    if ( minsn_sz > qfsize(minsns_in) ) // sanity check on minsn_sz
    {
      msg("Wrong instruction size %d in the oracle file, stopped reading it\n", minsn_sz);
      return false;
    }
    bytevec_t buf;
    buf.resize(minsn_sz);
    if ( qfread(minsns_in, buf.begin(), minsn_sz) != minsn_sz )
      break;

    func_fingerprint_t fp = ecf.compute_fingerprint_from_serialization(buf.begin(), minsn_sz);

    if ( oracle.count(fp) == 0 )
      oracle.insert( { fp, std::set<bytevec_t, bv_len_cmptr_t>() } );

    oracle[fp].insert(buf);
  }

  msg("%s: Processed %d, #Fingerprints %" FMT_Z "\n", curtime().c_str(), n_proc, oracle.size());

  // write the resulting oracle to the file
  // begin by writing the format version
  {
    bytevec_t bv;
    uint32 format_version = minsn_t(0).serialize(&bv);
    qfwrite(oracle_out, &format_version, sizeof(format_version));
  }

  // write the ecf's test cases to file
  uint32 n_tcs = ecf.testcases.size();
  qfwrite(oracle_out, &n_tcs, sizeof(n_tcs));
  for ( const testcase_t &tc : ecf.testcases )
    for ( const uint64 input : tc )
      qfwrite(oracle_out, &input, sizeof(input));

  msg("Wrote test cases to file\n");

  // write the index to file
  // the index is a list of entries, each consisting of a uint64 (fingerprint) and a uint64 (offset)
  uint32 index_sz = oracle.size();
  qfwrite(oracle_out, &index_sz, sizeof(index_sz));
  qoff64_t current_offset = 0;
  int n_written = 0;
  for ( const auto &entry : oracle )
  {
    if ( n_written % REPORT_FREQ == 0 )
      msg("%s: Wrote %d index entries\n", curtime().c_str(), n_written);
    n_written++;

    auto fingerprint = entry.first;
    auto bvset = entry.second;
    qfwrite(oracle_out, &fingerprint, sizeof(fingerprint));
    qfwrite(oracle_out, &current_offset, sizeof(current_offset));

    current_offset += bvset_sz_on_disk(bvset);
  }

  msg("Size of oracle on disk: %llu\n", current_offset);
  msg("Current file position: %llu\n", qftell(oracle_out));

  // write the actual microinstructions to disk
  n_written = 0;
  for ( const auto &entry : oracle )
  {
    if ( n_written % REPORT_FREQ == 0 )
      msg("%s: Wrote %d microinstruction vectors\n", curtime().c_str(), n_written);
    n_written++;

    write_bvset_to_disk(oracle_out, entry.second);
  }

  msg("%s: Wrote %d microinstruction vectors\n", curtime().c_str(), n_written);
  msg("Current file position: %" FMT_64 "u\n", qftell(oracle_out));
  return true;
}

```

`file.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>

// functions that convert huge files in a streaming fashion without using too much memory

const int REPORT_FREQ = 10000; // how often we should report progress in the log
// generates a file that is just a list of minsns
void create_minsns_file(FILE *msynth_in, FILE *minsns_out);
// given a minsns file, fingerprints each minsn and serializes it into the oracle
bool create_oracle_file(FILE *minsns_in, FILE *oracle_out);
```

`generate_oracle.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  gooMBA oracle file generation script
@rem
@rem ##########################################################################
@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

if .%1 == . goto usage
set VD_MSYNTH_PATH=%~f1
echo generating minsns file (step 1/2)...
idat -A -Llog.txt tests/idb/mba_challenge.i64
set VD_MSYNTH_PATH=
set VD_MBA_MINSNS_PATH=%~dpnx1.b
echo generating oracle file (step 2/2)...
idat -A -Llog.txt tests/idb/mba_challenge.i64
echo. >> log.txt
echo finished!
move %~dpnx1.b.c %~dpn1.oracle
echo finished! Result is in %~dpn1.oracle
tail log.txt
exit /b
:usage
echo "Usage: generate_oracle.bat all_combined.txt"

```

`generate_oracle.sh`:

```sh
#!/bin/bash

# usage: ./generate_oracle.sh all_combined.txt
# after the script finishes running, the oracle file will be available in all_combined.txt.oracle

(
  VD_MSYNTH_PATH=`realpath $1` ida64 -A -S`realpath script.py` -Llog.txt tests/idb/mba_challenge.i64
  VD_MBA_MINSNS_PATH=`realpath $1.b` ida64 -A -S`realpath script.py` -Llog.txt tests/idb/mba_challenge.i64
  mv $1.b.c $1.oracle
  echo -e "\nfinished! Result is in $1.oracle" >> log.txt
) &

tail -F log.txt
```

`goomba.cfg`:

```cfg

// This configuration file is used by the mixed_bool_arith plugin, which
// provides deobfuscation functionality for expressions obfuscated with
// mixed boolean arithmetic expressions.

// By default, the plugin only engages through a right-click menu option.
// Set the below option to YES to make the plugin engage automatically
// when the decompiler is invoked.
MBA_RUN_AUTOMATICALLY = NO
// The timeout in ms for z3 proofs. Set this to 0 to disable z3 proofs
// entirely and assume simplifications are correct after heuristic checks.
MBA_Z3_TIMEOUT = 1000
// When z3 times out, should the simplification be assumed correct?
MBA_Z3_ASSUME_TIMEOUTS_CORRECT = YES
// Path to an MBA oracle. Leave this empty to disable the function
// fingerprinting algorithm and use only linear methods.
MBA_ORACLE_PATH = "";

```

`goomba.cpp`:

```cpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *      It deobfuscates the MBA (mixed boolean arithmetic) epxressions.
 *
 */

#include <chrono>

#include "z3++_no_warn.h"
#include "consts.hpp"
#include "optimizer.hpp"
#include "equiv_class.hpp"
#include "file.hpp"
#include <hexrays.hpp>
#include <err.h>

struct plugin_ctx_t;

//--------------------------------------------------------------------------
// returns true if the environment variables indicate the plugin should
// always be enabled (i.e. in testing environments)
inline bool always_on(void)
{
  return qgetenv("VD_MBA_AUTO");
}

//--------------------------------------------------------------------------
struct run_ah_t : public action_handler_t
{
  plugin_ctx_t *plugmod;

  run_ah_t(plugin_ctx_t *_plugmod) : plugmod(_plugmod) {}

  virtual int idaapi activate(action_activation_ctx_t *ctx) override;
  virtual action_state_t idaapi update(action_update_ctx_t *ctx) override
  {
    return ctx->widget_type == BWN_PSEUDOCODE
         ? AST_ENABLE_FOR_WIDGET
         : AST_DISABLE_FOR_WIDGET;
  };
};

//--------------------------------------------------------------------------
//lint -e{958} padding of 7 bytes needed to align member on a 8 byte boundary
struct plugin_ctx_t : public plugmod_t
{
  bool run_automatically = false;
  qstring oracle_path;

  run_ah_t run_ah;
  optimizer_t optimizer;
  bool plugmod_active = false;
  bool inited_oracle = false;
  plugin_ctx_t();
  ~plugin_ctx_t() { term_hexrays_plugin(); }
  virtual bool idaapi run(size_t) override;
  void init_oracle();
};

//--------------------------------------------------------------------------
void plugin_ctx_t::init_oracle()
{
  // a guard to initialize the oracle only once
  if ( inited_oracle )
    return;
  inited_oracle = true;

  const char *idb_path = get_path(PATH_TYPE_IDB);
  if ( idb_path != nullptr )
  {
    char buf[QMAXPATH];
    set_file_ext(buf, sizeof(buf), idb_path, ".disable_oracle");
    if ( qfileexist(buf) )
      return; // do not use the oracle for this file
  }

  if ( oracle_path.empty() )
    qgetenv("VD_MBA_ORACLE_PATH", &oracle_path);

  if ( !oracle_path.empty() )
  {
    const char *path = oracle_path.c_str();
    FILE *fin = qfopen(path, "rb");
    if ( fin != nullptr )
    {
      optimizer.equiv_classes = new equiv_class_finder_lazy_t(fin);
      msg("%s: loaded MBA oracle for goomba\n", path);
    }
    else
    {
      msg("%s: %s\n", path, qstrerror(-1));
    }
  }
}

//--------------------------------------------------------------------------
static plugmod_t *idaapi init()
{
  if ( !init_hexrays_plugin() )
    return nullptr; // no decompiler

  const char *hxver = get_hexrays_version();
  msg("Hex-rays version %s has been detected, %s ready to use\n",
      hxver, PLUGIN.wanted_name);

  plugin_ctx_t *plugmod = new plugin_ctx_t;

  const cfgopt_t cfgopts[] =
  {
    cfgopt_t("MBA_RUN_AUTOMATICALLY", &plugmod->run_automatically, 1),
    cfgopt_t("MBA_Z3_TIMEOUT", &plugmod->optimizer.z3_timeout),
    cfgopt_t("MBA_ORACLE_PATH", &plugmod->oracle_path),
    cfgopt_t("MBA_Z3_ASSUME_TIMEOUTS_CORRECT", &plugmod->optimizer.z3_assume_timeouts_correct, 1)
  };

  read_config_file("goomba", cfgopts, qnumber(cfgopts), nullptr);

  qstring ifpath;
  if ( qgetenv("VD_MSYNTH_PATH", &ifpath) )
  {
    qstring ofpath = ifpath + ".b";
    FILE *fin = qfopen(ifpath.c_str(), "r");
    if ( fin == nullptr )
      error("%s: failed to open for reading", ifpath.c_str());
    FILE *fout = qfopen(ofpath.c_str(), "wb");
    if ( fout == nullptr )
      error("%s: failed to open for writing", ofpath.c_str());
    create_minsns_file(fin, fout);
    qfclose(fin);
    qfclose(fout);
    // do not save the IDB
    set_database_flag(DBFL_KILL);
    qexit(0);
  }

  if ( qgetenv("VD_MBA_MINSNS_PATH", &ifpath) )
  {
    qstring ofpath = ifpath + ".c";
    FILE *fin = qfopen(ifpath.c_str(), "rb");
    if ( fin == nullptr )
      error("%s: failed to open for reading", ifpath.c_str());
    FILE *fout = qfopen(ofpath.c_str(), "wb");
    if ( fout == nullptr )
      error("%s: failed to open for writing", ofpath.c_str());
    bool ok = create_oracle_file(fin, fout);
    qfclose(fin);
    qfclose(fout);
    if ( !ok )
      error("%s: failed to process", ifpath.c_str());
    // do not save the IDB
    set_database_flag(DBFL_KILL);
    qexit(0);
  }

  return plugmod;
}

//--------------------------------------------------------------------------
int idaapi run_ah_t::activate(action_activation_ctx_t *ctx)
{
  vdui_t *vu = get_widget_vdui(ctx->widget);
  if ( vu != nullptr )
  {
    plugmod->plugmod_active = true;
    vu->refresh_view(true);
    return 1;
  }
  return 0;
}

//--------------------------------------------------------------------------
// To satisfy our curiosity: find and print overlapping operands
static void find_and_print_overlapped_operands(mba_t *mba)
{
#if 0
  struct ida_local overlap_finder_t : public minsn_visitor_t
  {
    //------------------------------------------------------------
    static int compare_mops(const mop_t &op1, const mop_t &op2)
    {
      int code = compare(op1.t, op2.t);
      if ( code != 0 )
        return code;
      switch ( op1.t )
      {
        case mop_S:         // stack variable
          code = ::lexcompare(op1.s->off, op2.s->off);
          break;
        case mop_v:         // global variable
          code = ::lexcompare(op1.g, op2.g);
          break;
        case mop_r:         // register
          code = compare(op1.r, op2.r);
          break;
        case mop_l:
          code = op1.l->compare(*op2.l);
          break;
        default:
          INTERR(30822);
      }
      if ( code != 0 )
        return code;
      return compare(op1.size, op2.size);
    }

    //------------------------------------------------------------
    // 0-no overlap, 1-op1 includes op2, -1-op2 includes op1, 2-partial overlap
    static int mops_overlap(const mop_t &op1, const mop_t &op2)
    {
      if ( op1.t != op2.t )
        return 0;
      uval_t off1, off2;
      switch ( op1.t )
      {
        case mop_r:
          off1 = op1.r;
          off2 = op2.r;
          break;
        case mop_S:
          off1 = op1.s->off;
          off2 = op2.s->off;
          break;
        case mop_v:
          off1 = op1.g;
          off2 = op2.g;
          break;
        case mop_l:
          if ( op1.l->idx != op2.l->idx )
            return 0;
          off1 = op1.l->off;
          off2 = op2.l->off;
          break;
        default:
          INTERR(30823);
      }
      if ( !interval::overlap(off1, op1.size, off2, op2.size) )
        return 0;
      if ( interval::includes(off1, op1.size, off2, op2.size) )
        return 1;
      if ( interval::includes(off2, op2.size, off1, op1.size) )
        return -1;
      return 2;
    }

    //----------------------------------------------------------------
    int idaapi visit_minsn() override
    {
      struct mop_collector_t : public mop_visitor_t
      {
        qvector<mop_t> seen;
        qstring info;

        int idaapi visit_mop(mop_t *op, const tinfo_t *, bool)
        {
          mopt_t t = op->t;
          if ( t == mop_r || t == mop_S || t == mop_v || t == mop_l )
          {
            for ( mop_t &op2 : seen )
            {
              int code = compare_mops(*op, op2);
              if ( code == 0 )
                return 0; // already seen
              code = mops_overlap(*op, op2);
              switch ( code )
              {
                case 0:
                  break;
                case 1: // *op includes op2
                  op2 = *op;
                  return 0;
                case -1: // op2 includes *op, nothing to do
                  return 0;
                case 2: // found overlap
                  info.sprnt("%s and %s%s", op->dstr(), op2.dstr(), op->t == mop_r ? " REG" : "");
                  return 1;
              }
            }
            seen.push_back(*op);
          }
          return 0;
        }
      };
      mop_collector_t mc;
      if ( curins->for_all_ops(mc) != 0 )
      {
        msg("%s:%a: detected overlap %s: %s\n",
            qbasename(get_path(PATH_TYPE_IDB)),
            curins->ea,
            mc.info.c_str(), curins->dstr());
      }
      return 0;
    }
  };
  overlap_finder_t find_overlaps;
  mba->for_all_topinsns(find_overlaps);
#else
  qnotused(mba);
#endif
}

//--------------------------------------------------------------------------
// This callback handles various hexrays events.
static ssize_t idaapi callback(void *ud, hexrays_event_t event, va_list va)
{
  plugin_ctx_t *plugmod = (plugin_ctx_t *) ud;
  switch ( event )
  {
    case hxe_microcode: // microcode has been generated
      {
        mba_t *mba = va_arg(va, mba_t *);
        if ( always_on() || plugmod->run_automatically )
          plugmod->plugmod_active = true;
        if ( plugmod->plugmod_active )
          mba->set_mba_flags2(MBA2_PROP_COMPLEX); // increase acceptable complexity
      }
      break;

    case hxe_populating_popup:
      {
        TWidget *widget = va_arg(va, TWidget *);
        TPopupMenu *popup = va_arg(va, TPopupMenu *);
        attach_action_to_popup(widget, popup, ACTION_NAME);
      }
      break;

    case hxe_glbopt:
      {
        mba_t *mba = va_arg(va, mba_t *);

        find_and_print_overlapped_operands(mba);

        if ( !plugmod->plugmod_active )
          return MERR_OK;
        // read the oracle file if not done yet
        plugmod->init_oracle();

        struct ida_local insn_optimize_t : public minsn_visitor_t
        {
          optimizer_t &optimizer;
          int cnt = 0;
          insn_optimize_t ( optimizer_t &o ) : optimizer(o) {}
          int idaapi visit_minsn() override
          {
            // msg("goomba: optimizing %s\n", curins->dstr());
            if ( optimizer.optimize_insn_recurse(curins) )
            {
              cnt++;
              blk->mark_lists_dirty();
              mba->dump_mba(true, "vd_mba success %a", curins->ea);
            }
            return 0;
          }
        };

        insn_optimize_t visitor(plugmod->optimizer);
        mba->for_all_topinsns(visitor);

        plugmod->plugmod_active = false;
        mba->clr_mba_flags2(MBA2_PROP_COMPLEX);
        if ( visitor.cnt != 0 )
        {
          mba->verify(true);
          msg("goomba: completed mba optimization pass, improved %d expressions\n", visitor.cnt);
          return MERR_LOOP; // restart optimization
        }
        return MERR_OK;
      }
      break;

    default:
      break;
  }
  return 0;
}

//--------------------------------------------------------------------------
plugin_ctx_t::plugin_ctx_t() : run_ah(this)
{
  install_hexrays_callback(callback, this);
  register_action(ACTION_DESC_LITERAL_PLUGMOD(
                    ACTION_NAME,
                    "De-obfuscate arithmetic expressions",
                    &run_ah,
                    this,
                    nullptr,
                    "Attempt to simplify Mixed Boolean Arithmetic-obfuscated expressions using gooMBA",
                    -1));
}

//--------------------------------------------------------------------------
bool idaapi plugin_ctx_t::run(size_t)
{
  return true;
}

//--------------------------------------------------------------------------
static char comment[] = "gooMBA plugin for Hex-Rays decompiler";

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------
plugin_t PLUGIN =
{
  IDP_INTERFACE_VERSION,
  PLUGIN_MULTI          // The plugin can work with multiple idbs in parallel
| PLUGIN_HIDE,          // no menu items in Edit, Plugins
  init,                 // initialize
  nullptr,
  nullptr,
  comment,              // long comment about the plugin
  nullptr,              // multiline help about the plugin
  "gooMBA plugin",         // the preferred short name of the plugin
  nullptr,              // the preferred hotkey to run the plugin
};

```

`heuristics.cpp`:

```cpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include "heuristics.hpp"

//-------------------------------------------------------------------------
inline uint64 rand64()
{
  uint32 r1 = rand();
  uint32 r2 = rand();
  return uint64(r1) << 32 | uint64(r2);
}

//-------------------------------------------------------------------------
intval64_t gen_rand_mcode_val(int size)
{
  if ( rand() > SPECIAL_PROBABILITY * RAND_MAX )
  {
    // select from uniform random distribution
    return intval64_t(rand64(), size);
  }
  else
  {
    // select from special cases
    return intval64_t(SPECIAL[rand() % NUM_SPECIAL], size);
  }
}

//-------------------------------------------------------------------------
uint8 gen_rand_byte()
{
  if ( rand() > SPECIAL_PROBABILITY * RAND_MAX )
  {
    // select from uniform random distribution
    return rand() % 256;
  }
  else
  {
    // select from special cases
    return SPECIAL8[rand() % NUM_SPECIAL];
  }
}

//-------------------------------------------------------------------------
// guesses whether or not the instruction is MBA
bool is_mba(const minsn_t &insn)
{
  struct mba_opc_counter_t : public minsn_visitor_t
  {
    int bool_cnt = 0;
    int arith_cnt = 0;
    int idaapi visit_minsn(void) override
    {
      switch ( curins->opcode )
      {
        case m_neg:
        case m_add:
        case m_sub:
        case m_mul:
        case m_udiv:
        case m_sdiv:
        case m_umod:
        case m_smod:
        case m_shl:
        case m_shr:
          arith_cnt++;
          break;
        case m_bnot:
        case m_or:
        case m_and:
        case m_xor:
        case m_sar:
          bool_cnt++;
          break;
        default:
          return 0;
      }
      return bool_cnt >= MIN_MBA_BOOL_OPS && arith_cnt >= MIN_MBA_ARITH_OPS;
    }
  };

  if ( is_mcode_xdsu(insn.opcode) )
    return false; // exclude xdsu, it is better to optimize its operand

  if ( insn.opcode >= m_jcnd )
    return false; // not supported by int64_emulator_t

  if ( insn.d.size > 8 )
    return false; // we only support 64-bit math

  mba_opc_counter_t cntr;
  return CONST_CAST(minsn_t*)(&insn)->for_all_insns(cntr) != 0;
}

//-------------------------------------------------------------------------
// runs a battery of random test cases against both expressions to see if they are equivalent
bool probably_equivalent(const minsn_t &insn, const candidate_expr_t &expr)
{
  for ( int i = 0; i < NUM_TEST_CASES; i++ )
  {
    mcode_emu_rand_vals_t emu;
    intval64_t insn_eval = emu.minsn_value(insn);
    intval64_t expr_eval = expr.evaluate(emu);

    if ( insn_eval != expr_eval )
      return false;
  }

  return true;
}

//-------------------------------------------------------------------------
// runs a battery of random test cases against both expressions to see if they are equivalent
bool probably_equivalent(const minsn_t &a, const minsn_t &b)
{
  for ( int i = 0; i < NUM_TEST_CASES; i++ )
  {
    mcode_emu_rand_vals_t emu;
    intval64_t insn_eval = emu.minsn_value(a);
    intval64_t expr_eval = emu.minsn_value(b);

    if ( insn_eval != expr_eval )
      return false;
  }

  return true;
}

//-------------------------------------------------------------------------
// estimates the "complexity" of a given instruction
int score_complexity(const minsn_t &insn)
{
  struct ida_local complexity_counter_t : public minsn_visitor_t
  {
    int cnt = 0;
    int idaapi visit_minsn() override
    {
      cnt++;
      return 0;
    }
  };
  complexity_counter_t cc;
  CONST_CAST(minsn_t&)(insn).for_all_insns(cc);
  return cc.cnt;
}

```

`heuristics.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include "linear_exprs.hpp"

const uint64 SPECIAL[] = { 0, 1, 0xffffffffffffffff };
const uint8 SPECIAL8[] = { 0, 1, 0xff };
const int NUM_SPECIAL = qnumber(SPECIAL);
const double SPECIAL_PROBABILITY = 0.2; // probability of selecting a special number when sampling

// an expression must have at least this many subinstructions of each type to count as an MBA
const int MIN_MBA_BOOL_OPS = 1;
const int MIN_MBA_ARITH_OPS = 1;

// number of test cases to run when checking if an instruction matches the candidate expression's behavior
const int NUM_TEST_CASES = 256;

//-------------------------------------------------------------------------
intval64_t gen_rand_mcode_val(int size);
uint8 gen_rand_byte();

//-------------------------------------------------------------------------
// a data structure for storing the values of memory mops as bytes to solve
// the overlaping problems, e.g,.:
// mem_op1: [0x1000, 0x1003]
// mem_op2: [0x1002, 0x1005]
struct byte_val_map_t
{
  std::map<const uval_t, uint8> stk_map;      // stack variable mapping
  std::map<const uval_t, uint8> glb_map;      // global variable mapping
  std::map<const uval_t, uint8> local_map;    // local variable mapping
  std::map<const uval_t, uint8> reg_map;      // register mapping

  std::map<const mop_t, intval64_t> cache;   // save the seen mop->mcode_val pair

  //-------------------------------------------------------------------------
  // build a mcode_val from a byte qvector
  intval64_t bv2mcode_val(qvector<uint8> &bv)
  {
    uint64 result = 0;
    for ( uint8 b : bv )
    {
      result = (result << 8) | b;
    }

    return intval64_t(result, bv.size());
  }

  //-------------------------------------------------------------------------
  // find the value of the bytes [off, off+size) in map, assemble the result
  // as a intval64_t. Create random bytes for new values and update the map.
  intval64_t find_update(uval_t off, size_t size, std::map<const uval_t, uint8> &map)
  {
    qvector<uint8> bytes;

    for ( int i = size - 1; i >= 0; --i )
    {                               // iterate the addresses from high to low, so the most
      uval_t mem_addr = off + i;    // significant digit is the first element of the expr_vector
      auto result = map.find(mem_addr);
      if ( result != map.end() )
      {
        bytes.add(result->second);
      }
      else
      {
        // create a new random byte
        uint8 rand_byte = gen_rand_byte();
        bytes.add(rand_byte);
        map[mem_addr] = rand_byte;
      }
    }

    return bv2mcode_val(bytes);
  }

  //-------------------------------------------------------------------------
  intval64_t lookup(const mop_t &op)
  {
    auto it = cache.find(op);
    if ( it != cache.end() )
      return it->second;

    intval64_t result(0, 1);   // initialize intval64_t, size must be at least 1
    switch ( op.t )
    {
      case mop_S:         // stack variable
        result = find_update(op.s->off, op.size, stk_map);
        break;
      case mop_v:         // global variable
        result = find_update(op.g, op.size, glb_map);
        break;
      case mop_l:         // local variable
        result = find_update(op.l->off, op.size, local_map);
        break;
      case mop_r:         // register
        result = find_update(op.r, op.size, reg_map);
        break;
      default:
        INTERR(30824);
    }

    cache.insert( { op, result } );
    return result;
  }
};

//-------------------------------------------------------------------------
// emulates the microcode, assigning random values to unknown variables
// (but keeping them consistent across executions)
struct mcode_emu_rand_vals_t : public int64_emulator_t
{
  byte_val_map_t var_vals;

  intval64_t get_mop_value(const mop_t &mop) override
  {
    // check that the mop is indeed a variable
    mopt_t t = mop.t;
    QASSERT(30672, t == mop_r || t == mop_S || t == mop_v || t == mop_l);

    intval64_t v = var_vals.lookup(mop);
    // msg("mop: %s, mcode_val: %s\n", mop.dstr(), v.dstr());
    return v;
  }
};

//-------------------------------------------------------------------------
bool is_mba(const minsn_t &insn);

//-------------------------------------------------------------------------
bool probably_equivalent(const minsn_t &insn, const candidate_expr_t &expr);
bool probably_equivalent(const minsn_t &a, const minsn_t &b);

//-------------------------------------------------------------------------
// estimates the "complexity" of a given instruction
int score_complexity(const minsn_t &insn);

struct minsn_complexity_cmptr_t
{
  bool operator()(const minsn_t *a, const minsn_t *b) const
  {
    auto score_a = score_complexity(*a);
    auto score_b = score_complexity(*b);
    return score_a < score_b;
  }
};

inline mopvec_t get_input_mops(const minsn_t &insn)
{
  default_zero_mcode_emu_t emu;
  emu.minsn_value(insn); // populate emu.assigned_vals

  mopvec_t res;
  res.reserve(emu.assigned_vals.size());
  for ( auto const &entry : emu.assigned_vals )
    res.push_back(entry.first);

  std::sort(res.begin(), res.end());
  return res;
}
```

`lin_conj_exprs.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>
#include "linear_exprs.hpp"

typedef qvector<intval64_t> coeff_vector_t;
typedef qvector<intval64_t> eval_trace_t;
const int LIN_CONJ_MAX_VARS = 16;

// represents a linear combination of conjunctions
class lin_conj_expr_t : public candidate_expr_t
{
protected:
  mopvec_t mops;
  coeff_vector_t coeffs;
  eval_trace_t eval_trace;

public:
  //-------------------------------------------------------------------------
  const char *dstr() const override
  {
    static char buf[MAXSTR];
    char *ptr = buf;
    char *end = buf + sizeof(buf);

    ptr += qsnprintf(ptr, end-ptr, "0x%" FMT_64 "x", coeffs[0].val);
    for ( uint32 i = 1; i < coeffs.size(); i++ )
    {
      if ( coeffs[i].val == 0 )
        continue;
      ptr += qsnprintf(ptr, end-ptr, " + 0x%" FMT_64 "x(", coeffs[i].val);
      ptr = print_assignment(ptr, end, i);
      APPEND(ptr, end, ")");
    }
    return buf;
  }

  //-------------------------------------------------------------------------
  // each boolean assignment is represented as a uint32, where the nth bit
  // represents the 0/1 value of the corresponding variable
  char *print_assignment(char *ptr, char *end, uint32 assn) const
  {
    bool first_printed = false;
    for ( int i = 0; i < mops.size(); i++ )
    {
      if ( ((assn >> i) & 1) != 0 )
      {
        if ( first_printed )
          APPCHAR(ptr, end, '&');
        APPEND(ptr, end, mops[i].dstr());
        first_printed = true;
      }
    }
    return ptr;
  }

  //-------------------------------------------------------------------------
  // each boolean assignment is represented as a uint32, where the nth bit
  // represents the 0/1 value of the corresponding variable
  void apply_assignment(uint32 assn, std::map<const mop_t, intval64_t> &dest)
  {
    // recall std::map keeps keys in sorted order
    int curr_idx = 0;
    for ( auto &kv : dest )
    {
      kv.second.val = (assn >> curr_idx) & 1;
      curr_idx++;
    }
  }

  //-------------------------------------------------------------------------
  // the i'th index in output_vals contains the output value corresponding to
  // the i'th assignment, where the i'th assignment is defined as in
  // apply_assignment.
  // the return value of this function is the corresponding coefficients in
  // the linear combination of conjunctions that would yield the output
  // behavior. The coefficients are ordered based on the same indexing pattern.
  void compute_coeffs(coeff_vector_t &dest, const qvector<intval64_t> &output_vals)
  {
    dest = coeff_vector_t();
    dest.reserve(output_vals.size());
    dest.push_back(output_vals[0]); // the zero coeff = the zero assignment

    // we can think of the problem as solving the linear equation Ax = y,
    // where y is the output_vals and x is the desired coefficient set.
    // A is defined as the binary matrix where row numbers represent
    // assignments and columns represent conjunctions. See the SiMBA paper
    // for more details.
    // We do an additional simplification, noting that
    // A_{ij} = (i & j) == j. Also, we use forward substitution since A is a
    // lower-triangular matrix.

    for ( uint32 i = 1; i < output_vals.size(); i++ )
    {
      intval64_t curr_coeff = output_vals[i];
      for ( uint32 j = 0; j < i; j++ )
      {
        if ( (i & j) == j )
          curr_coeff = curr_coeff - dest[j];
      }
      dest.push_back(curr_coeff);
    }
  }

  //-------------------------------------------------------------------------
  void recompute_coeffs()
  {
    compute_coeffs(coeffs, eval_trace);
  }

  //-------------------------------------------------------------------------
  intval64_t evaluate(int64_emulator_t &emu) const override
  {
    minsn_t *minsn = to_minsn(0);
    intval64_t res = emu.minsn_value(*minsn);
    delete minsn;
    return res;
  }

  //-------------------------------------------------------------------------
  // eliminates all variables that are not needed in the expression
  void eliminate_variables()
  {
    for ( int i = 0; i < mops.size(); i++ )
    {
      if ( can_eliminate_variable(i) )
      {
        eliminate_variable(i);
        i--; // the mop at mop[i] no longer exists
      }
    }
  }

  //-------------------------------------------------------------------------
  // creates a linear combination of conjunctions based on the minsn behavior
  lin_conj_expr_t(const minsn_t &insn)
  {
    default_zero_mcode_emu_t emu;
    intval64_t const_term = emu.minsn_value(insn);     // first-time emulation returns the result when setting all inputs as 0

    int nvars = emu.assigned_vals.size();
    if ( nvars > LIN_CONJ_MAX_VARS )
      throw "lin_conj_expr_t: too many input variables";

    uint32 max_assignment = 1 << nvars;       // 2^n possible values in the truth table
    // we have already gotten the value for the all-zeroes assignment, which is const_term
    eval_trace.push_back(const_term);
    eval_trace.reserve(max_assignment);

    // Compute signature vectors
    for ( uint32 assn = 1; assn < max_assignment; assn++ )
    {
      apply_assignment(assn, emu.assigned_vals);
      intval64_t output_val = emu.minsn_value(insn);

      eval_trace.push_back(output_val);
    }
    compute_coeffs(coeffs, eval_trace);

    // Collect all the input operands from the emulator
    mops.reserve(emu.assigned_vals.size());
    for ( const auto &kv : emu.assigned_vals )
      mops.push_back(kv.first);

    QASSERT(30679, coeffs.size() == (1ull << mops.size()));
  }

  //-------------------------------------------------------------------------
  z3::expr to_smt(z3_converter_t &cvtr) const override
  {
    minsn_t *minsn = to_minsn(0);
    z3::expr res = cvtr.minsn_to_expr(*minsn);
    delete minsn;
    return res;
  }

  //-------------------------------------------------------------------------
  // converts an assignment to the corresponding conjunction. e.g.
  // 0b1101 => x0 & x2 & x3
  minsn_t *assn_to_minsn(uint32 assn, int size, ea_t ea) const
  {
    QASSERT(30680, assn != 0);
    minsn_t *res = nullptr;

    for ( int i = 0; i < mops.size(); i++ )
    {
      if ( ((assn >> i) & 1) != 0 )
      {
        if ( res == nullptr )
        {
          res = resize_mop(ea, mops[i], size, false);
        }
        else
        {
          minsn_t *new_res = new minsn_t(ea);
          new_res->opcode = m_and;
          new_res->l.create_from_insn(res);
          minsn_t *rsz = resize_mop(ea, mops[i], size, false);
          new_res->r.create_from_insn(rsz);
          delete rsz;
          new_res->d.size = size;

          delete res;
          res = new_res;
        }
      }
    }

    QASSERT(30681, res->opcode != m_ldc);

    return res;
  }

  //-------------------------------------------------------------------------
  minsn_t *to_minsn(ea_t ea) const override
  {
    minsn_t *res = new minsn_t(ea);
    res->opcode = m_ldc;
    res->l.make_number(coeffs[0].val, coeffs[0].size, ea);
    res->r.zero();
    res->d.size = coeffs[0].size;

    for ( uint32 assn = 1; assn < coeffs.size(); assn++ )
    {
      auto coeff = coeffs[assn];
      if ( coeff.val == 0 )
        continue;

      // mul = coeff * F(mops)
      minsn_t mul(ea);
      mul.opcode = m_mul;
      mul.l.make_number(coeff.val, coeff.size);
      minsn_t *F = assn_to_minsn(assn, coeff.size, ea);
      mul.r.create_from_insn(F);
      delete F;
      mul.d.size = coeff.size;

      // add = res + mul
      minsn_t *add = new minsn_t(ea);
      add->opcode = m_add;
      add->l.create_from_insn(res);
      add->r.create_from_insn(&mul);
      add->d.size = coeff.size;

      delete res; // mop_t::create_from_insn makes a copy of the insn
      res = add;
    }

    return res;
  }

private:
  //-------------------------------------------------------------------------
  // returns true if the variable can be eliminated safely
  // i.e. all terms containing it have coeff = 0
  bool can_eliminate_variable(int idx)
  {
    for ( uint32 assn = 0; assn < coeffs.size(); assn++ )
    {
      if ( ((assn >> idx) & 1) != 0 && coeffs[assn].val != 0 )
        return false;
    }
    return true;
  }

  //-------------------------------------------------------------------------
  // removes the variable from the expression
  // make sure to check can_eliminate_variable before calling
  void eliminate_variable(int idx)
  {
    coeff_vector_t new_coeffs;
    eval_trace_t new_evals;
    new_coeffs.reserve(coeffs.size() / 2);
    new_evals.reserve(coeffs.size() / 2);
    for ( uint32 assn = 0; assn < coeffs.size(); assn++ )
    {
      if ( ((assn >> idx) & 1) == 0 )
      {
        new_coeffs.push_back(coeffs[assn]);
        new_evals.push_back(eval_trace[assn]);
      }
      else
      {
        QASSERT(30682, coeffs[assn].val == 0);
      }
    }
    coeffs = new_coeffs;
    eval_trace = new_evals;
    mops.erase(mops.begin() + idx);
  }
};

```

`linear_exprs.cpp`:

```cpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include "linear_exprs.hpp"

//-------------------------------------------------------------------------
const char *linear_expr_t::dstr() const
{
  static char buf[MAXSTR];
  char *ptr = buf;
  char *end = buf + sizeof(buf);

  ptr += qsnprintf(ptr, end-ptr, "0x%" FMT_64 "x", const_term.val);
  for ( const auto &term : coeffs )
  {
    if ( term.second.val == 0 )
      continue;
    ptr += qsnprintf(ptr, end-ptr, " + 0x%" FMT_64 "x*", term.second.val);
    if ( term.first.size < const_term.size )
    {
      ptr += qsnprintf(ptr, end-ptr, "%s(%s)",
                       sext.count(term.first) ? "SEXT" : "ZEXT",
                       term.first.dstr());
    }
    else if ( term.first.size > const_term.size )
    {
      ptr += qsnprintf(ptr, end-ptr, "TRUNC(%s)", term.first.dstr());
    }
    else
    {
      APPEND(ptr, end, term.first.dstr());
    }
  }
  return buf;
}

//-------------------------------------------------------------------------
linear_expr_t::linear_expr_t(const minsn_t &insn) // creates a linear expression based on the instruction behavior
{
  default_zero_mcode_emu_t emu;
  const_term = emu.minsn_value(insn); // the value when all variables are assigned to zero

  for ( auto &p : emu.assigned_vals )
  {
    mop_t mop = p.first;
    p.second = intval64_t(1, mop.size);
    intval64_t coeff = emu.minsn_value(insn) - const_term;

    if ( mop.size < const_term.size )
    {
      // check if a sign extension is necessary
      p.second = intval64_t(-1, mop.size);
      intval64_t eval = emu.minsn_value(insn); // eval = const + (-1)*coeff if x was sign extended

      if ( const_term - eval == coeff )
        sext.insert(mop);
    }

    coeffs.insert( { mop, emu.minsn_value(insn) - const_term } );
    p.second = intval64_t(0, mop.size);
  }
}

//-------------------------------------------------------------------------
intval64_t linear_expr_t::evaluate(int64_emulator_t &emu) const
{
  intval64_t res = const_term;

  for ( const auto &term : coeffs )
  {
    const mop_t &mop = term.first;
    const intval64_t &coeff = term.second;
    intval64_t mop_val = emu.get_mop_value(mop);

    // extend the value to 64 bits first
    uint64 ext_val = sext.count(mop) ? mop_val.sval() : mop_val.val;

    res = res + coeff * intval64_t(ext_val, coeff.size);
  }

  return res;
}

//-------------------------------------------------------------------------
z3::expr linear_expr_t::to_smt(z3_converter_t &cvtr) const
{
  z3::expr res = cvtr.intval64_to_expr(const_term);

  for ( const auto &term : coeffs )
  {
    const mop_t &mop = term.first;
    const intval64_t &coeff = term.second;
    z3::expr mop_expr = cvtr.mop_to_expr(mop);

    z3::expr ext_expr = cvtr.bv_resize_to_len(mop_expr, const_term.size * 8, sext.count(mop) != 0);

    res = res
        + cvtr.intval64_to_expr(coeff) * ext_expr;
  }

  return res;
}

//-------------------------------------------------------------------------
minsn_t *linear_expr_t::to_minsn(ea_t ea) const
{
  minsn_t *res = new minsn_t(ea);
  res->opcode = m_ldc;
  res->l.make_number(const_term.val, const_term.size);
  res->r.zero();
  res->d.size = const_term.size;

  for ( const auto &term : coeffs )
  {
    const mop_t &mop = term.first;
    const intval64_t &coeff = term.second;

    if ( coeff.val == 0 )
      continue;

    // mul = coeff * ext(mop)
    minsn_t mul(ea);
    mul.opcode = m_mul;
    mul.l.make_number(coeff.val, coeff.size);
    minsn_t *rsz = resize_mop(ea, mop, const_term.size, sext.count(mop) != 0);
    mul.r.create_from_insn(rsz);
    delete rsz;

    mul.d.size = const_term.size;

    // add = res + mul
    minsn_t *add = new minsn_t(ea);
    add->opcode = m_add;
    add->l.create_from_insn(res);
    add->r.create_from_insn(&mul);
    add->d.size = const_term.size;

    delete res; // mop_t::create_from_insn makes a copy of the insn
    res = add;
  }

  return res;
}

```

`linear_exprs.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>

#include "smt_convert.hpp"

//-------------------------------------------------------------------------
class candidate_expr_t
{
public:
  virtual ~candidate_expr_t() {}
  virtual intval64_t evaluate(int64_emulator_t &emu) const = 0;
  virtual z3::expr to_smt(z3_converter_t &converter) const = 0;
  virtual minsn_t *to_minsn(ea_t ea) const = 0;
  virtual const char *dstr() const = 0;
};

//-------------------------------------------------------------------------
// resize_mop generates a minsn that resizes the source operand (truncates or extends)
inline minsn_t *resize_mop(ea_t ea, const mop_t &mop, int dest_sz, bool sext)
{
  minsn_t *res = new minsn_t(ea);
  if ( dest_sz == mop.size )
    res->opcode = m_mov;
  else if ( dest_sz < mop.size )
    res->opcode = m_low;
  else
    res->opcode = sext ? m_xds : m_xdu;

  res->l = mop;
  res->d.size = dest_sz;
  return res;
}

//-------------------------------------------------------------------------
// this emulator automatically assigns variables to 0
// after the first run, the assigned_vals field can be modified
// and the emulation can be rerun to obtain coefficients
class default_zero_mcode_emu_t : public int64_emulator_t
{
public:
  std::map<const mop_t, intval64_t> assigned_vals;

  intval64_t get_mop_value(const mop_t &mop) override
  {
    // check that the mop is indeed a variable
    mopt_t t = mop.t;
    QASSERT(30695, t == mop_r || t == mop_S || t == mop_v || t == mop_l);

    auto p = assigned_vals.find(mop);
    if ( p != assigned_vals.end() )
      return p->second;

    intval64_t new_val = intval64_t(0, mop.size);
    assigned_vals.insert( { mop, new_val } );
    return new_val;
  }
};

//-------------------------------------------------------------------------
class linear_expr_t : public candidate_expr_t
{
public:
  intval64_t const_term { 0, 1 };
  std::map<mop_t, intval64_t> coeffs;
  std::set<mop_t> sext;

  const char *dstr() const override;
  linear_expr_t(const minsn_t &insn);
  intval64_t evaluate(int64_emulator_t &emu) const override;
  z3::expr to_smt(z3_converter_t &cvtr) const override;
  minsn_t *to_minsn(ea_t ea) const override;
};

```

`makefile`:

```
PROC=goomba

GOALS += $(R)libz3$(DLLEXT)
O2=heuristics
O3=smt_convert
O4=linear_exprs
O5=msynth_parser
O6=bitwise_expr_lookup_tbl
O7=optimizer
O8=equiv_class
O9=file

CONFIGS=goomba.cfg
include ../plugin.mak

ifeq ($(THIRD_PARTY),)
  # building outside of Hex-Rays tree, use a local z3 build
  Z3_BIN = z3/bin/
  Z3_INCLUDE = z3/include/
endif

ifdef __MAC__
  ifndef __CODE_CHECKER__
    POSTACTION=install_name_tool -change libz3.dylib @rpath/libz3.dylib $@
  endif
endif

ifdef __NT__
  # link to the import library on Windows
  STDLIBS += $(Z3_BIN)libz3.lib
else
  # link directly to dylib/shared object on Unix
  STDLIBS += -L$(R) -lz3
endif

$(F)$(PROC)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O2)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O3)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O4)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O5)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O6)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O7)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O8)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(O9)$(O): CC_INCP += $(Z3_INCLUDE) $(Z3_INCLUDE)c++
$(F)$(PROC)$(O): $(R)libz3$(DLLEXT)

$(R)libz3$(DLLEXT): $(Z3_BIN)libz3$(DLLEXT)
	$(Q)$(CP) $? $@

# MAKEDEP dependency list ------------------
$(F)bitwise_expr_lookup_tbl$(O): $(I)bitrange.hpp $(I)bytes.hpp             \
                  $(I)config.hpp $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp       \
                  $(I)hexrays.hpp $(I)ida.hpp $(I)idp.hpp $(I)ieee.h        \
                  $(I)kernwin.hpp $(I)lines.hpp $(I)llong.hpp               \
                  $(I)loader.hpp $(I)nalt.hpp $(I)name.hpp $(I)netnode.hpp  \
                  $(I)pro.h $(I)range.hpp $(I)segment.hpp $(I)typeinf.hpp   \
                  $(I)ua.hpp $(I)xref.hpp bitwise_expr_lookup_tbl.cpp       \
                  bitwise_expr_lookup_tbl.hpp consts.hpp linear_exprs.hpp   \
                  minsn_template.hpp smt_convert.hpp z3++_no_warn.h
$(F)equiv_class$(O): $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp          \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  bitwise_expr_lookup_tbl.hpp consts.hpp equiv_class.cpp    \
                  equiv_class.hpp heuristics.hpp lin_conj_exprs.hpp         \
                  linear_exprs.hpp minsn_template.hpp msynth_parser.hpp     \
                  nonlin_expr.hpp optimizer.hpp simp_lin_conj_exprs.hpp     \
                  smt_convert.hpp z3++_no_warn.h
$(F)file$(O)    : $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp $(I)fpro.h  \
                  $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp $(I)ida.hpp     \
                  $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp $(I)lines.hpp      \
                  $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp $(I)name.hpp    \
                  $(I)netnode.hpp $(I)pro.h $(I)range.hpp $(I)segment.hpp   \
                  $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp                   \
                  bitwise_expr_lookup_tbl.hpp consts.hpp equiv_class.hpp    \
                  file.cpp file.hpp heuristics.hpp lin_conj_exprs.hpp       \
                  linear_exprs.hpp minsn_template.hpp msynth_parser.hpp     \
                  simp_lin_conj_exprs.hpp smt_convert.hpp z3++_no_warn.h
$(F)goomba$(O)  : $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp $(I)err.h   \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  bitwise_expr_lookup_tbl.hpp consts.hpp equiv_class.hpp    \
                  file.hpp goomba.cpp heuristics.hpp lin_conj_exprs.hpp     \
                  linear_exprs.hpp minsn_template.hpp msynth_parser.hpp     \
                  nonlin_expr.hpp optimizer.hpp simp_lin_conj_exprs.hpp     \
                  smt_convert.hpp z3++_no_warn.h
$(F)heuristics$(O): $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp           \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  heuristics.cpp heuristics.hpp linear_exprs.hpp            \
                  smt_convert.hpp z3++_no_warn.h
$(F)linear_exprs$(O): $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp         \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  linear_exprs.cpp linear_exprs.hpp smt_convert.hpp         \
                  z3++_no_warn.h
$(F)msynth_parser$(O): $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp        \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  consts.hpp linear_exprs.hpp minsn_template.hpp            \
                  msynth_parser.cpp msynth_parser.hpp smt_convert.hpp       \
                  z3++_no_warn.h
$(F)optimizer$(O): $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp            \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  bitwise_expr_lookup_tbl.hpp consts.hpp equiv_class.hpp    \
                  heuristics.hpp lin_conj_exprs.hpp linear_exprs.hpp        \
                  minsn_template.hpp msynth_parser.hpp nonlin_expr.hpp      \
                  optimizer.cpp optimizer.hpp simp_lin_conj_exprs.hpp       \
                  smt_convert.hpp z3++_no_warn.h
$(F)smt_convert$(O): $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp          \
                  $(I)fpro.h $(I)funcs.hpp $(I)gdl.hpp $(I)hexrays.hpp      \
                  $(I)ida.hpp $(I)idp.hpp $(I)ieee.h $(I)kernwin.hpp        \
                  $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
                  $(I)name.hpp $(I)netnode.hpp $(I)pro.h $(I)range.hpp      \
                  $(I)segment.hpp $(I)typeinf.hpp $(I)ua.hpp $(I)xref.hpp   \
                  smt_convert.cpp smt_convert.hpp z3++_no_warn.h

```

`mcode_emu.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *      This file implements a simple microcode emulator class
 *
 */

#pragma once
#include <hexrays.hpp>

//-------------------------------------------------------------------------
// truncate v to w bytes
inline uint64 trunc(uint64 v, int w)
{
  QASSERT(30660, w == 1 || w == 2 || w == 4 || w == 8);
  return v & make_mask<uint64>(w * 8);
}

//-------------------------------------------------------------------------
struct mcode_val_t
{
  uint64 val;
  int size; // in bytes

  //-------------------------------------------------------------------------
  void check_size_equal(const mcode_val_t &o) const
  {
    QASSERT(30661, size == o.size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t(uint64 v, int s) : val(trunc(v, s)), size(s) {}

  //-------------------------------------------------------------------------
  int64 signed_val() const
  {
    return extend_sign(val, size, true);
  }

  //-------------------------------------------------------------------------
  mcode_val_t sext(int target_sz) const
  {
    QASSERT(30662, target_sz >= size);
    return mcode_val_t(signed_val(), target_sz);
  }

  //-------------------------------------------------------------------------
  mcode_val_t zext(int target_sz) const
  {
    QASSERT(30663, target_sz >= size);
    return mcode_val_t(val, target_sz);
  }

  //-------------------------------------------------------------------------
  mcode_val_t low(int target_sz) const
  {
    QASSERT(30664, target_sz <= size);
    return mcode_val_t(val, target_sz);
  }

  //-------------------------------------------------------------------------
  mcode_val_t high(int target_sz) const
  {
    QASSERT(30665, target_sz <= size);
    int bytes_to_remove = size - target_sz;
    return mcode_val_t(right_ushift<uint64>(val, 8 * bytes_to_remove), target_sz);
  }

  //-------------------------------------------------------------------------
  bool operator==(const mcode_val_t &o) const
  {
    return size == o.size && val == o.val;
  }

  //-------------------------------------------------------------------------
  bool operator!=(const mcode_val_t &o) const
  {
    return !(*this == o);
  }

  //-------------------------------------------------------------------------
  bool operator<(const mcode_val_t &o) const
  {
    QASSERT(30702, size == o.size);
    return val < o.val;
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator+(const mcode_val_t &o) const
  {
    check_size_equal(o);
    return mcode_val_t(val + o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator-(const mcode_val_t &o) const
  {
    check_size_equal(o);
    return mcode_val_t(val - o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator*(const mcode_val_t &o) const
  {
    check_size_equal(o);
    return mcode_val_t(val * o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator/(const mcode_val_t &o) const
  {
    check_size_equal(o);
    if ( o.val == 0 )
      throw "division by zero occurred when emulating instruction";
    return mcode_val_t(val / o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t sdiv(const mcode_val_t &o) const
  {
    check_size_equal(o);
    if ( o.val == 0 )
      throw "division by zero occurred when emulating instruction";
    int64 res;
    uint64 l = val;
    uint64 r = o.val;
    switch ( size )
    {
      case 1: res = int8(l)  / int8(r); break;
      case 2: res = int16(l) / int16(r); break;
      case 4: res = int32(l) / int32(r); break;
      case 8: res = int64(l) / int64(r); break;
      default: INTERR(30666);
    }

    return mcode_val_t(res, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator%(const mcode_val_t &o) const
  {
    check_size_equal(o);
    if ( o.val == 0 )
      throw "division by zero occurred when emulating instruction";
    return mcode_val_t(val % o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t smod(const mcode_val_t &o) const
  {
    check_size_equal(o);
    if ( o.val == 0 )
      throw "division by zero occurred when emulating instruction";
    int64 res = -1;
    uint64 l = val;
    uint64 r = o.val;
    switch ( size )
    {
      case 1: res = int8(l)  % int8(r); break;
      case 2: res = int16(l) % int16(r); break;
      case 4: res = int32(l) % int32(r); break;
      case 8: res = int64(l) % int64(r); break;
      default: QASSERT(30667, false);
    }

    return mcode_val_t(res, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator<<(const mcode_val_t &o) const
  {
    return mcode_val_t(left_shift<uint64>(val, o.val), size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator>>(const mcode_val_t &o) const
  {
    return mcode_val_t(right_ushift<uint64>(val, o.val), size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t sar(const mcode_val_t &o) const
  {
    return mcode_val_t(right_sshift<int64>(signed_val(), o.val), size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator|(const mcode_val_t &o) const
  {
    check_size_equal(o);
    return mcode_val_t(val | o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator&(const mcode_val_t &o) const
  {
    check_size_equal(o);
    return mcode_val_t(val & o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator^(const mcode_val_t &o) const
  {
    check_size_equal(o);
    return mcode_val_t(val ^ o.val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator-() const
  {
    return mcode_val_t(0-val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator!() const
  {
    return mcode_val_t(!val, size);
  }

  //-------------------------------------------------------------------------
  mcode_val_t operator~() const
  {
    return mcode_val_t(~val, size);
  }
};

//-------------------------------------------------------------------------
class mcode_emulator_t
{
public:
  // base classes with virtual functions should have a virtual dtr
  virtual ~mcode_emulator_t() {}
  // returns the value assigned to a register, stack, global, or local variable
  virtual mcode_val_t get_var_val(const mop_t &mop) = 0;

  //-------------------------------------------------------------------------
  mcode_val_t mop_value(const mop_t &mop)
  {
    if ( mop.size > 8 )
      throw "too big mop size in mcode emulator";
    switch ( mop.t )
    {
      case mop_n:
        return mcode_val_t(mop.nnn->value, mop.size);
      case mop_d:
        return minsn_value(*mop.d);
      case mop_r: // register
      case mop_S: // stack variable
      case mop_v: // global variable
      case mop_l:
        return get_var_val(mop);
      default:
        throw "unhandled mop type in mcode emulator";
    }
  }

  //-------------------------------------------------------------------------
  mcode_val_t minsn_value(const minsn_t &insn)
  {
    if ( insn.is_fpinsn() )
    {
      msg("Emulator does not support floating point\n");
      throw "Emulator does not support floating point";
    }
    switch ( insn.opcode )
    {
      case m_ldc:
      case m_mov:
        return mop_value(insn.l);
      case m_neg:
        return -mop_value(insn.l);
      case m_lnot:
        return !mop_value(insn.l);
      case m_bnot:
        return ~mop_value(insn.l);
      case m_xds:
        return mop_value(insn.l).sext(insn.d.size);
      case m_xdu:
        return mop_value(insn.l).zext(insn.d.size);
      case m_low:
        return mop_value(insn.l).low(insn.d.size);
      case m_high:
        return mop_value(insn.l).high(insn.d.size);
      case m_add:
        return mop_value(insn.l) + mop_value(insn.r);
      case m_sub:
        return mop_value(insn.l) - mop_value(insn.r);
      case m_mul:
        return mop_value(insn.l) * mop_value(insn.r);
      case m_udiv:
        return mop_value(insn.l) / mop_value(insn.r);
      case m_sdiv:
        return mop_value(insn.l).sdiv(mop_value(insn.r));
      case m_umod:
        return mop_value(insn.l) & mop_value(insn.r);
      case m_smod:
        return mop_value(insn.l).smod(mop_value(insn.r));
      case m_or:
        return mop_value(insn.l) | mop_value(insn.r);
      case m_and:
        return mop_value(insn.l) & mop_value(insn.r);
      case m_xor:
        return mop_value(insn.l) ^ mop_value(insn.r);
      case m_shl:
        return mop_value(insn.l) << mop_value(insn.r);
      case m_shr:
        return mop_value(insn.l) >> mop_value(insn.r);
      case m_sar:
        return mop_value(insn.l).sar(mop_value(insn.r));
      case m_sets:
        return mcode_val_t(mop_value(insn.l).signed_val() < 0, insn.d.size);
      case m_setnz:
        return mcode_val_t(mop_value(insn.l) != mop_value(insn.r), insn.d.size);
      case m_setz:
        return mcode_val_t(mop_value(insn.l) == mop_value(insn.r), insn.d.size);
      case m_setae:
        return mcode_val_t(mop_value(insn.l).val >= mop_value(insn.r).val, insn.d.size);
      case m_setb:
        return mcode_val_t(mop_value(insn.l).val < mop_value(insn.r).val, insn.d.size);
      case m_seta:
        return mcode_val_t(mop_value(insn.l).val > mop_value(insn.r).val, insn.d.size);
      case m_setbe:
        return mcode_val_t(mop_value(insn.l).val <= mop_value(insn.r).val, insn.d.size);
      case m_setg:
        return mcode_val_t(mop_value(insn.l).signed_val() > mop_value(insn.r).signed_val(), insn.d.size);
      case m_setge:
        return mcode_val_t(mop_value(insn.l).signed_val() >= mop_value(insn.r).signed_val(), insn.d.size);
      case m_setl:
        return mcode_val_t(mop_value(insn.l).signed_val() < mop_value(insn.r).signed_val(), insn.d.size);
      case m_setle:
        return mcode_val_t(mop_value(insn.l).signed_val() <= mop_value(insn.r).signed_val(), insn.d.size);
      default:
        msg("Unhandled opcode in emulator %d\n", insn.opcode);
        throw "Unhandled opcode";
    }
  }
};

```

`minsn_template.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>
#include "linear_exprs.hpp"
#include "consts.hpp"

//-------------------------------------------------------------------------
struct default_mops_t
{
  mopvec_t mops;

  static default_mops_t *get_instance()
  {
    if ( instance == nullptr )
      instance = new default_mops_t();
    return instance;
  }

private:
  static default_mops_t *instance;
  default_mops_t()
  {
    for ( int i = 0; i < CANDIDATE_EXPR_NUMINPUTS; i++ )
    {
      mop_t new_var;
      new_var.t = mop_l;
      new_var.l = new lvar_ref_t(nullptr, i);
      new_var.size = 8;
      mops.push_back(new_var);
    }
  }
};

//-------------------------------------------------------------------------
// a minsn template has no defined size or assigned terminal mops
class minsn_template_t
{
public:
  // caller is responsible for freeing the minsn_t *
  virtual minsn_t *synthesize(ea_t ea, int size, const qvector<mop_t> &mops) const = 0;
  virtual ~minsn_template_t() {}

  const char *dstr() const
  {
    minsn_t *insn = synthesize(0, 8, default_mops_t::get_instance()->mops);
    const char *res = insn->dstr();
    delete insn;
    return res;
  }
};

typedef std::shared_ptr<minsn_template_t> minsn_template_ptr_t;
typedef qvector<minsn_template_ptr_t> minsn_templates_t;

//-------------------------------------------------------------------------
struct mt_constant_t : public minsn_template_t
{
  uint64_t val;

  mt_constant_t(uint64_t v) : val(v) {}
  minsn_t *synthesize(ea_t ea, int size, const qvector<mop_t>&) const override
  {
    minsn_t *res = new minsn_t(ea);
    res->opcode = m_ldc;
    res->l.make_number(val, size, ea);
    res->r.zero();
    res->d.size = size;
    return res;
  }
};

//-------------------------------------------------------------------------
struct mt_varref_t : public minsn_template_t
{
  int var_idx;

  mt_varref_t(int v) : var_idx(v) {}
  minsn_t *synthesize(ea_t ea, int size, const qvector<mop_t> &mops) const override
  {
    QASSERT(30704, var_idx < mops.size());
    return resize_mop(ea, mops[var_idx], size, false);
  }
};

//-------------------------------------------------------------------------
struct mt_comp_t : public minsn_template_t
{
  mcode_t opc;
  minsn_templates_t operands;

  mt_comp_t(mcode_t op, minsn_templates_t opr) : opc(op), operands(opr) {}

  minsn_t *synthesize(ea_t ea, int size, const qvector<mop_t> &mops) const override
  {
    minsn_t *res = new minsn_t(ea);
    res->opcode = opc;
    res->l.zero();
    res->r.zero();

    if ( operands.size() >= 1 )
    {
      minsn_t *l = operands[0]->synthesize(ea, size, mops);
      res->l.create_from_insn(l);
      delete l;
    }
    if ( operands.size() >= 2 )
    {
      minsn_t *r = operands[1]->synthesize(ea, size, mops);
      res->r.create_from_insn(r);
      delete r;
    }

    res->d.size = size;
    return res;
  }
};

inline minsn_template_ptr_t make_un(mcode_t opc, minsn_template_ptr_t a)
{
  minsn_templates_t operands;
  operands.push_back(a);
  return std::make_shared<mt_comp_t>(opc, operands);
}

inline minsn_template_ptr_t make_bin(mcode_t opc, minsn_template_ptr_t a, minsn_template_ptr_t b)
{
  minsn_templates_t operands;
  operands.push_back(a);
  operands.push_back(b);
  return std::make_shared<mt_comp_t>(opc, operands);
}

inline minsn_template_ptr_t operator+(minsn_template_ptr_t a, minsn_template_ptr_t b)
{
  return make_bin(m_add, a, b);
}
inline minsn_template_ptr_t operator*(minsn_template_ptr_t a, minsn_template_ptr_t b)
{
  return make_bin(m_mul, a, b);
}
inline minsn_template_ptr_t operator&(minsn_template_ptr_t a, minsn_template_ptr_t b)
{
  return make_bin(m_and, a, b);
}
inline minsn_template_ptr_t operator|(minsn_template_ptr_t a, minsn_template_ptr_t b)
{
  return make_bin(m_or, a, b);
}
inline minsn_template_ptr_t operator^(minsn_template_ptr_t a, minsn_template_ptr_t b)
{
  return make_bin(m_xor, a, b);
}
inline minsn_template_ptr_t operator~(minsn_template_ptr_t a)
{
  return make_un(m_bnot, a);
}

```

`msynth_parser.cpp`:

```cpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include "msynth_parser.hpp"
#include "minsn_template.hpp"

default_mops_t *default_mops_t::instance = nullptr;

minsn_t *msynth_expr_parser_t::parse_next_expr()
{
  if ( *next == '~' )
  {
    next++;
    minsn_t *res = new minsn_t(0);
    res->opcode = m_bnot;
    minsn_t *next_expr = parse_next_expr();
    res->l.create_from_insn(next_expr);
    delete next_expr;
    next_expr = nullptr;
    res->d.size = res->l.size;
    return res;
  }

  // ExprInt(val: uint64, bitw: int)
  {
    int nread;
    uint64 val;
    int bitw;
    int sr = qsscanf(next, "ExprInt(%" FMT_64 "u, %d)%n", &val, &bitw, &nread);
    if ( sr == 2 )
    {
      next += nread;

      minsn_t *res = new minsn_t(0);
      res->opcode = m_ldc;
      res->l.make_number(val, bitw/8);
      res->r.zero();
      res->d.size = bitw/8;
      return res;
    }
  }

  // ExprId(id: str, bitw: int)
  {
    int nread;
    int varnum, bitw;
    int sr = qsscanf(next, "ExprId(\"p%d\", %d)%n", &varnum, &bitw, &nread);
    if ( sr == 2 )
    {
      next += nread;
      minsn_t *res = new minsn_t(0);
      res->opcode = bitw == 64 ? m_mov : m_low;
      res->l = vars[varnum];
      res->d.size = bitw/8;
      return res;
    }
  }

  // ExprOp(op: str, expr*)
  {
    int sc = strncmp(next, "ExprOp", 6);
    if ( sc == 0 )
    {
      int nread;
      next += 6;
      char op[3];
      int sr = qsscanf(next, "(\"%2[^\"]\"%n", op, &nread);
      QASSERT(30688, sr == 1);
      next += nread;

      minsnptrs_t args;
      while ( *next != ')' )
      {
        sc = strncmp(next, ", ", 2);
        QASSERT(30689, sc == 0);
        next += 2;

        args.push_back(parse_next_expr());
      }

      next++; // consume the ')'

      // - can be either unary or binary
      if ( streq(op, "-") )
      {
        if ( args.size() == 1 )
          return make_un(m_neg, &args);
        if ( args.size() == 2 )
          return make_bin(m_sub, &args);
        INTERR(30690);
      }
      else
      {
        mcode_t code = get_binop(op);
        if ( code != m_nop )
          return make_bin(code, &args);
      }
      INTERR(30691);
    }
  }

  // ExprSlice(expr, low, hi)
  {
    int sc = strncmp(next, "ExprSlice", 9);
    if ( sc == 0 )
    {
      next += 9;
      QASSERT(30692, *next == '(');
      next++;
      minsn_t *to_slice = parse_next_expr();
      int lo, hi, nread;
      int sr = qsscanf(next, ", %d, %d)%n", &lo, &hi, &nread);
      QASSERT(30693, sr == 2);
      next += nread;
      minsn_t *res = make_slice(to_slice, lo, hi);
      delete to_slice;
      return res;
    }
  }

  INTERR(30694);
}

```

`msynth_parser.hpp`:

```hpp
/*
 *      Copyright (c) 2023 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>
#include "linear_exprs.hpp"

//-------------------------------------------------------------------------
struct bin_op_t
{
  const char *text;
  mcode_t opcode;
};

static const bin_op_t bin_ops[] =
{
  { "+",  m_add  }, // "-" is handled separately since it can also be unary
  { "*",  m_mul  },
  { "/",  m_udiv },
  { "&",  m_and  },
  { "|",  m_or   },
  { "^",  m_xor  },
  { "<<", m_shl  },
};

//-------------------------------------------------------------------------
inline mcode_t get_binop(const char *op)
{
  for ( size_t i=0; i < qnumber(bin_ops); i++ )
    if ( streq(bin_ops[i].text, op) )
      return bin_ops[i].opcode;
  return m_nop;
}

//-------------------------------------------------------------------------
class msynth_expr_parser_t
{
public:
  const char *next;
  const mopvec_t &vars;


  //-------------------------------------------------------------------------
  void init_from_arg(mop_t *op, minsn_t **pp_ins)
  {
    minsn_t *ins = *pp_ins;
    op->create_from_insn(ins);
    delete ins;
    *pp_ins = nullptr;
  }

  //-------------------------------------------------------------------------
  minsn_t *make_un(mcode_t opcode, minsnptrs_t *args)
  {
    QASSERT(30683, args->size() == 1);
    minsn_t *res = new minsn_t(0);
    res->opcode = opcode;
    init_from_arg(&res->l, args->begin() + 0);
    res->d.size = res->l.size;
    return res;
  }

  //-------------------------------------------------------------------------
  minsn_t *make_bin(mcode_t opcode, minsnptrs_t *args)
  {
    QASSERT(30684, args->size() == 2);
    minsn_t *res = new minsn_t(0);
    res->opcode = opcode;
    init_from_arg(&res->l, args->begin() + 0);
    init_from_arg(&res->r, args->begin() + 1);
    if ( opcode == m_shl && res->r.size != 1 )
      res->r.change_size(1);
    res->d.size = res->l.size;
    return res;
  }

  //-------------------------------------------------------------------------
  minsn_t *make_slice(minsn_t *src, int lo, int hi)
  {
    QASSERT(30686, lo == 0);
    QASSERT(30687, hi == 8 || hi == 16 || hi == 32);

    minsn_t *res = new minsn_t(0);
    res->opcode = m_low;
    res->l.create_from_insn(src);
    res->d.size = hi / 8;
    return res;
  }

  minsn_t *parse_next_expr();

public:
  msynth_expr_parser_t(const char *s, const mopvec_t &v) : next(s), vars(v) {}
};

```

`nonlin_expr.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <hexrays.hpp>

#define LDEB      // enable debug print

//--------------------------------------------------------------------------
inline AS_PRINTF(1, 2) void dmsg(const char *format, ...)
{
#ifdef LDEB
  va_list va;
  va_start(va, format);
  vmsg(format, va);
  va_end(va);
#else
  qnotused(format);
#endif
}

//--------------------------------------------------------------------------
class nonlin_expr_t : public candidate_expr_t
{
  // constant values to be used when building new candidates
  mop_t one;
  mop_t two;
  mop_t minus_one;

  minsn_t *cur_mba = nullptr; // copy of the instruction to normalize
  ea_t cur_ea = BADADDR;      // during recursion: address of the current insn
  bool ok = false;

  // Terminology of MBA
  // ==================
  //
  //   3 * x * (x&y) + 2 * y * z + 1
  //       -   -----       -   -        factor
  //       ---------       -----        product
  //   -               -           -    coefficient
  //   -------------   ---------   -    term

  // A factor could be a variable or an AND expression.
  // A variable could be x or -x
  // An AND expression could include -x, x+y, or x-y
  class factor_t
  {
    enum factor_type_t { VAR, AND_EXPR };

    factor_type_t t;

  public:
    std::set<mop_t> ops;
    mop_t op;

    factor_t(const mop_t &arg1) : t(VAR), op(arg1) {}
    factor_t(const std::set<mop_t> &arg1, mop_t arg2) : t(AND_EXPR), ops(arg1), op(arg2) {}

    bool is_var() const { return t == VAR; }
    bool is_and_expr() const { return t == AND_EXPR; }

    //--------------------------------------------------------------------------
    // override < and == operator for using std::map
    bool operator<(const factor_t &right) const
    {
      if ( t == VAR && right.t == VAR )
        return op < right.op;
      if ( t == AND_EXPR && right.t == AND_EXPR )
        return ops < right.ops;
      // either t == VAR && right.t == AND_EXPR  or  t == AND_EXPR && right.t == VAR
      return t == VAR;
    }

    //--------------------------------------------------------------------------
    bool operator==(const factor_t &right) const
    {
      if ( t == VAR && right.t == VAR )
        return op == right.op;
      if ( t == AND_EXPR && right.t == AND_EXPR )
        return ops == right.ops;
      return false;
    }

    //--------------------------------------------------------------------------
    qstring dstr() const
    {
      if ( t == VAR )
        return op.dstr();

      if ( t == AND_EXPR )
      {
        int i = 0;
        qstring s("AND(");
        for ( const mop_t &elem : ops )
        {
          if ( ++i > 1 )
            s.append(',');
          s.append(elem.dstr());
        }
        s.append(')');
        return s;
      }
      INTERR(30825);
    }

    //--------------------------------------------------------------------------
    mop_t to_mop() const
    {
      return op;
    }
  };

  //--------------------------------------------------------------------------
  // The product of factors is represented by a frequency map, where the number of each factor
  // are counted. It works because multiplication is commutative and associative, so the order of
  // the factors doesn't matter. For example:
  // x*y*(x&y)*y*x*y*z can be represented as: { (x, 2), (y, 3), (z, 1), (x&y, 1) }
  typedef std::map<factor_t, int> product_t;

  //--------------------------------------------------------------------------
  // A term is the multiplication of a signed coefficient and a prodcut
  class term_t
  {
  public:
    int coeff;
    product_t prod;

    //--------------------------------------------------------------------------
    term_t(minsn_t *ins, int is_add) : term_t(insn_to_mop(ins), is_add)
    {
    }
    //--------------------------------------------------------------------------
    term_t(const mop_t &op, int is_add)
    {
      if ( op.is_constant() )
      {
        coeff = is_add * op.signed_value();       // is_add is 1 for + and -1 for -
        return;
      }
      if ( is_product(op) )
      {
        coeff = is_add;
        build_product(&prod, op);
        return;
      }
      if ( op.is_insn(m_mul) )
      {
        minsn_t *ins = op.d;
        if ( ins->l.is_constant() && is_product(ins->r) )          // n * product
        {
          coeff = is_add * ins->l.signed_value();
          build_product(&prod, ins->r);
        }
        else if ( ins->r.is_constant() && is_product(ins->l) )     // product * n
        {
          coeff = is_add * ins->r.signed_value();
          build_product(&prod, ins->l);
        }
        return;
      }
      INTERR(30826);
    }

    //--------------------------------------------------------------------------
    mop_t to_mop(const nonlin_expr_t *nlex) const
    {
      mop_t res;
      res.make_number(coeff, nlex->one.size);

      for ( auto &p : prod )
      {
        mop_t f = p.first.to_mop();

        for ( int i = 0; i < p.second; i++ )
        {
          minsn_t *temp = nlex->new_minsn(m_mul, res, f);
          res.create_from_insn(temp);                 // Probably this is not the best way, double-check later
          delete temp;
        }
      }

      return res;
    }

    //--------------------------------------------------------------------------
    qstring print() const
    {
      qstring s;
      s.sprnt("%d*[", coeff);
      for ( const auto &elem : prod )
      {
        s += "(";
        s += elem.first.dstr();
        s += "),";
      }
      s += "]";

      return s.c_str();
    }

    //--------------------------------------------------------------------------
    bool operator==(const term_t &right) const
    {
      return this->coeff == right.coeff && this->prod == right.prod;
    }
  };

  //--------------------------------------------------------------------------
  class normal_mba_t
  {
  public:
    qvector<term_t> terms;    // a normalized mba is a list of terms

    //--------------------------------------------------------------------------
    // dump a normal mba expression as terms
    void dump()
    {
      for ( const auto &elem : terms )
        dmsg("%s, ", elem.print().c_str());
      dmsg("\n");
    }
  };

  normal_mba_t nm_mba;

public:
  //--------------------------------------------------------------------------
  nonlin_expr_t(const minsn_t &insn)
  {
    // prepare the constants before recursing, so it is done only once
    one.make_number(1, insn.l.size);
    two.make_number(2, insn.l.size);
    minus_one.make_number(-1, insn.l.size);

    cur_mba = new minsn_t(insn);

    dmsg("pre-processing ... \n");
    recur_preprocess(cur_mba);
    dmsg("%s\n", cur_mba->dstr());

    dmsg("normalizing ... \n");
    ok = recur_normalize(cur_mba);
    if ( !ok )
      return;
    dmsg("%s\n", cur_mba->dstr());

    dmsg("multiplication distribution ... \n");
    ok = recur_mul_dist(cur_mba);
    if ( !ok )
      return;
    dmsg("%s\n", cur_mba->dstr());

    dmsg("remove parenthesis ... \n");
    apply_rm_par(cur_mba);
    dmsg("%s\n", cur_mba->dstr());

    cur_mba->optimize_solo();

    if ( is_normalized(cur_mba) )
    {
      build_normal_mba(cur_mba, nm_mba);
      dmsg("Normalized MBA: ");
      nm_mba.dump();

      simp_nm_mba(nm_mba);
      dmsg("Simplification Result: ");
      nm_mba.dump();
    }
    else
    {
      dmsg("The mba expr is not normal form!\n");
      ok = false;
    }

    // ok = false; // disabled non-linear optimization because the tests fail with it
  }

  ~nonlin_expr_t() { delete cur_mba; }
  bool success() const { return ok; }

  //--------------------------------------------------------------------------
  // recursively apply mul_dist() to ins
  bool recur_mul_dist(minsn_t *ins)
  {
    // dmsg("recur_mul_dist on: %s\n", ins->dstr());
    mul_dist(ins);
    if ( ins->l.is_insn() )
      recur_mul_dist(ins->l.d);
    if ( ins->r.is_insn() )
      recur_mul_dist(ins->r.d);
    return true;
  }

  //--------------------------------------------------------------------------
  // Apply multiplicative distribution law to ins
  // (a+b)*c => a*c+b*c
  bool mul_dist(minsn_t *ins) const
  {
    if ( ins->opcode != m_mul )
      return false;

    if ( !ins->l.is_insn() && !ins->r.is_insn() )
      return false; // at least one operand must be an instruction

    mop_t *c;
    minsn_t *addsub;
    if ( ins->r.is_insn(m_add) || ins->r.is_insn(m_sub) )
    {
      c = &ins->l;
      addsub = ins->r.d;
    }
    else if ( ins->l.is_insn(m_add) || ins->l.is_insn(m_sub) )
    {
      addsub = ins->l.d;
      c = &ins->r;
    }
    else
    {
      return false; // could not locate 'c'
    }

    minsn_t *ins_a = new_minsn(m_mul, addsub->l, *c);
    minsn_t *ins_b = new_minsn(m_mul, addsub->r, *c);     // Note that operand order could change: c*(a +/- b) becomes a*c +/- b*c

    ins->opcode = addsub->opcode;
    ins->l = insn_to_mop(ins_a);
    ins->r = insn_to_mop(ins_b);
    return true;
  }

  //--------------------------------------------------------------------------
  // recursively apply the pre-process rules to ins
  void recur_preprocess(minsn_t *ins, minsn_t *parent=nullptr)
  {
    preprocess(ins, parent);
    if ( ins->l.is_insn() )
      recur_preprocess(ins->l.d, ins);
    if ( ins->r.is_insn() )
      recur_preprocess(ins->r.d, ins);
  }

  //--------------------------------------------------------------------------
  // do some pattern replacing
  void preprocess(minsn_t *ins, minsn_t *parent)
  {
    cur_ea = ins->ea; // will be used by new_minsn()
    minsn_t *sub;

    // (x - 1) --> ~ -x
    if ( parent != nullptr
      && parent->opcode == m_and
      && ins->opcode == m_sub
      && ins->r.is_one() )
    {
      mop_t &x = ins->l;
      // ~ -x
      sub = new_minsn(m_bnot, new_minsn(m_neg, x));
      ins->swap(*sub);
      delete sub;
    }

    // xdu ( and reg, imm ) --> and new_reg, new_imm
    if ( parent != nullptr
      && parent->opcode == m_xdu
      && ins->opcode == m_and
      && ins->l.is_reg()
      && ins->r.is_constant() )
    {
      // The size of the destination and source operands of the xdu insn
      int dst_size = parent->d.size;
      // int src_size = parent->l.size;

      unsigned int imm = ins->r.unsigned_value();

      // build the operands for the new substitution instruction
      mop_t new_reg;
      new_reg.make_reg(ins->l.r, dst_size);
      mop_t new_imm;
      new_imm.make_number(imm, dst_size);

      sub = new_minsn(m_and, new_reg, new_imm);
      parent->swap(*sub);
      delete sub;
    }

    // TODO: non-linear simplification works well on two-variable and most three-
    // variable MBAs, but not work well on MBAs with more than four-variables.
    // The following code can somehow group the variables together to alleviate the
    // problem a little bit.
    //
    // Group the variables together in an AND expression of multiple variables
    // swap the mops so that the non-insn mops are grouped to the left child.
    //
    // if ( parent != nullptr
    //   && parent->opcode == m_and
    //   && ins->opcode == m_and
    //   && !parent->r.is_insn()
    //   && ins->r.is_insn() )
    // {
    //   parent->r.swap(ins->r);
    // }

  }

  //--------------------------------------------------------------------------
  // recursively apply normalization to ins
  bool recur_normalize(minsn_t *ins)
  {
    // dmsg("recur_normalize on: %s\n", ins->dstr());
    normalize(ins);
    if ( ins->l.is_insn() )
      recur_normalize(ins->l.d);
    if ( ins->r.is_insn() )
      recur_normalize(ins->r.d);
    return true;
  }

  //--------------------------------------------------------------------------
  // Normalize any boolean expr to a simple MBA with only x, y, x and y, and constants
  // Rules:
  // 1. (not x) and y = y - (x and y)
  // 2. x and (not y): swap left and right, then use rule 1
  // 3. (not x) or y  = -x + (x and y) - 1
  // 4. x or (not y): swap left and right, then use rule 8
  // 5. not (x or y)  = -x - y + (x and y) - 1
  // 6. not (x xor y) = -x - y + 2*(x and y) - 1
  // 7. not (x and y) = - (x and y) - 1
  // 8. x xor y = x + y - 2*(x and y)
  // 9. x or y  = x + y - (x and y)
  // 10. not x  = - x - 1
  bool normalize(minsn_t *ins)
  {
    cur_ea = ins->ea; // will be used by new_minsn()

    minsn_t *sub;
    switch ( match(ins) )
    {
      // Rules 1 and 2
      case 2:
        ins->l.swap(ins->r);
        [[fallthrough]];
      case 1:
        {
          mop_t &x = ins->l.d->l;
          mop_t &y = ins->r;
          // y - (x and y)
          sub = new_minsn(m_sub, y,
                  new_minsn(m_and, x, y));
        }
        break;

      // Rules 3 and 4
      case 4:
        ins->l.swap(ins->r);
        [[fallthrough]];
      case 3:
        {
          mop_t &x = ins->l.d->l;
          mop_t &y = ins->r;
          // -1 * x + (x and y) - 1
          sub = new_minsn(m_sub,
                  new_minsn(m_add,
                    new_minsn(m_mul, minus_one, x),
                    new_minsn(m_and, x, y)),
                  one);
        }
        break;

      // Rule 5
      case 5:
        {
          mop_t &x = ins->l.d->l;
          mop_t &y = ins->l.d->r;
          // -1 * x - y + (x and y) - 1
          sub = new_minsn(m_sub,
                  new_minsn(m_add,
                    new_minsn(m_sub, new_minsn(m_mul, minus_one, x), y),
                    new_minsn(m_and, x, y)),
                  one);
        }
        break;

      // Rule 6
      case 6:
        {
          mop_t &x = ins->l.d->l;
          mop_t &y = ins->l.d->r;
          // -1 * x - y + 2*(x and y) - 1
          sub = new_minsn(m_sub,
                  new_minsn(m_add,
                    new_minsn(m_sub, new_minsn(m_mul, minus_one, x), y),
                    new_minsn(m_mul, two, new_minsn(m_and, x, y))),
                  one);
        }
        break;

      // Rule 7
      case 7:
        {
          mop_t &x = ins->l.d->l;
          mop_t &y = ins->l.d->r;
          // -1 * (x and y) - 1
          sub = new_minsn(m_sub,
                  new_minsn(m_mul, minus_one, new_minsn(m_and, x, y)),
                  one);
        }
        break;

      // Rule 8
      case 8:
        {
          mop_t &x = ins->l;
          mop_t &y = ins->r;
          // x + y - 2*(x and y)
          sub = new_minsn(m_sub,
                  new_minsn(m_add, x, y),
                  new_minsn(m_mul, two, new_minsn(m_and, x, y)));
        }
        break;

      // Rule 9
      case 9:
        {
          mop_t &x = ins->l;
          mop_t &y = ins->r;
          // x + y - (x and y)
          sub = new_minsn(m_sub,
                  new_minsn(m_add, x, y),
                  new_minsn(m_and, x, y));
        }
        break;

      // Rule 10
      case 10:
        {
          mop_t &x = ins->l;
          // -1 * x - 1
          sub = new_minsn(m_sub,
                  new_minsn(m_mul, minus_one, x),
                  one);
        }
        break;

      // // Rule 11
      // case 11:
      //   {
      //     mop_t &x = ins->l;
      //     // -1 * x
      //     sub = new_minsn(m_mul, minus_one, x);
      //   }
      //   break;

      default:
        return false;
    }

    ins->swap(*sub);
    delete sub;
    return true;
  }

  //--------------------------------------------------------------------------
  // optimized code that can handle only the special case when:
  //   - op is empty
  //   - ins is a simple arithmetic instruction with no d operand (but with d.size)
  // this function takes ownership of 'ins'
  static mop_t insn_to_mop(minsn_t *ins)
  {
    mop_t mop;
    mop._make_insn(ins);
    mop.size = ins->d.size;
    return mop;
  }

  //--------------------------------------------------------------------------
  // Six overloaded functions for creating new minsn from mop or sub-minsn.
  // Four functions for creating binary-op instructions
  minsn_t *new_minsn(mcode_t mc, minsn_t *left, minsn_t *right) const
  {
    return new_minsn(mc, insn_to_mop(left), insn_to_mop(right));
  }

  //--------------------------------------------------------------------------
  minsn_t *new_minsn(mcode_t mc, const mop_t &left, minsn_t *right) const
  {
    return new_minsn(mc, left, insn_to_mop(right));
  }

  //--------------------------------------------------------------------------
  minsn_t *new_minsn(mcode_t mc, minsn_t *left, const mop_t &right) const
  {
    return new_minsn(mc, insn_to_mop(left), right);
  }

  //--------------------------------------------------------------------------
  minsn_t *new_minsn(mcode_t mc, const mop_t &left, const mop_t &right) const
  {
    minsn_t *ins = new minsn_t(cur_ea);
    ins->opcode = mc;
    ins->l = left;
    ins->r = right;
    ins->d.size = left.size;
    return ins;
  }

  //--------------------------------------------------------------------------
  // Two functions for creating unary-op instructions
  minsn_t *new_minsn(mcode_t mc, minsn_t *left) const
  {
    return new_minsn(mc, insn_to_mop(left));
  }

  //--------------------------------------------------------------------------
  minsn_t *new_minsn(mcode_t mc, const mop_t &left) const
  {
    minsn_t *ins = new minsn_t(cur_ea);
    ins->opcode = mc;
    ins->l = left;
    ins->d.size = left.size;
    return ins;
  }

  //--------------------------------------------------------------------------
  static int match(const minsn_t *ins)
  {
    // Attention: the order of matching these rules matters!!!
    if ( ins->opcode == m_and && ins->l.is_insn(m_bnot) )  // 1. (not x) and y
      return 1;
    if ( ins->opcode == m_and && ins->r.is_insn(m_bnot) )  // 2. x and (not y)
      return 2;
    if ( ins->opcode == m_or && ins->l.is_insn(m_bnot) )   // 3. (not x) or y
      return 3;
    if ( ins->opcode == m_or && ins->r.is_insn(m_bnot) )   // 4. x or (not y)
      return 4;
    if ( ins->opcode == m_bnot && ins->l.is_insn(m_or) )   // 5. not (x or y)
      return 5;
    if ( ins->opcode == m_bnot && ins->l.is_insn(m_xor) )  // 6. not (x xor y)
      return 6;
    if ( ins->opcode == m_bnot && ins->l.is_insn(m_and) )  // 7. not (x and y)
      return 7;
    if ( ins->opcode == m_xor )                            // 8. x xor y
      return 8;
    if ( ins->opcode == m_or )                             // 9. x or y
      return 9;
    if ( ins->opcode == m_bnot )                           // 10. not x
      return 10;
    // if ( ins->opcode == m_neg )                            // 11. -x  --> -1 * x
    //   return 11;
    return 0;
  }

  //--------------------------------------------------------------------------
  // Remove the parentheses in the math expression stored in ins
  // E.g., a-(b+c) = a-b-c
  minsn_t *rm_par(minsn_t *ins)
  {
    minsn_t *rst = ins->r.d;   // ins's right sub-tree
    mop_t &a = ins->l;
    mop_t &b = rst->l;
    mop_t &c = rst->r;

    if ( ins->opcode == m_sub )   // flip the add/sub in a-(b+c), a-(b-c)
      rst->opcode = rst->opcode == m_add ? m_sub : m_add;

    minsn_t *sub = new_minsn(rst->opcode,
                    new_minsn(ins->opcode, a, b),
                    c);

    ins->swap(*sub);
    delete sub;

    return ins;
  }

  //--------------------------------------------------------------------------
  // Apply rm_par on all sub-expressions of ins. The result is somehow like
  // a left-skewed tree that is easy for extracting and merging like-terms.
  void apply_rm_par(minsn_t *ins)
  {
    // Process the current ins until the right sub-tree does not fit, then
    // go to the left sub-tree
    while ( (ins->opcode == m_add || ins->opcode == m_sub)        // a+(b+c), a+(b-c), a-(b+c), a-(b-c)
         && (ins->r.is_insn(m_add) || ins->r.is_insn(m_sub)) )
      ins = rm_par(ins);

    if ( ins->l.is_insn() )
      apply_rm_par(ins->l.d);
  }

  //--------------------------------------------------------------------------
  // Check an operand is an MBA factor, i.e., a (negate) variable, or an AND expression
  // examples: x, -x, x&y, x&(-y), x&(-y&z)
  static bool is_factor(const mop_t &op)
  {
    if ( op.t == mop_S || op.is_reg() )
      return true;
    if ( op.is_insn(m_neg) )
      return is_factor(op.d->l);
    if ( op.is_insn(m_and) )
      return is_factor(op.d->l) && is_factor(op.d->r);
    else
      return false;
  }

  //--------------------------------------------------------------------------
  // Check an operand is an MBA product, i.e., the product of a variable with their AND expressions.
  // like: (x&y) * x * (x&y) * y
  static bool is_product(const mop_t &op)
  {
    if ( is_factor(op) )
      return true;
    if ( op.is_insn(m_mul) )
      return is_product(op.d->l) && is_product(op.d->r);
    else
      return false;
  }

  //--------------------------------------------------------------------------
  // Check an operand is a normalized mba term, which is a constant, variable, or a mba factor
  // with/without coefficient.
  // Examples:
  // x, 3*x*y*(x&y)
  static bool is_mba_term(const mop_t &op)
  {
    if ( op.is_constant() )     // constant term
      return true;
    if ( op.t == mop_S || op.is_reg() )     // single variable term
      return true;
    if ( is_product(op) )     // no coefficient
      return true;
    if ( op.is_insn(m_neg) )
    {
      minsn_t *ins = op.d;
      if ( is_product(ins->l) )     // negate a product like -(x&y*y&z)
        return true;
      if ( ins->l.is_constant() )     // negate a constant like -1
        return true;
    }
    if ( op.is_insn(m_mul) )
    {
      minsn_t *ins = op.d;
      if ( ins->l.is_constant() && is_product(ins->r) )     // n*(a&b)
        return true;
      if ( ins->r.is_constant() && is_product(ins->l) )     // (a&b)*n
        return true;
    }
    return false;
  }

  //--------------------------------------------------------------------------
  // Check if an MBA has been successfully normalized
  static bool is_normalized(minsn_t *minsn)
  {
    minsn_t *ins = minsn;
    // check every insn node is a left subtree +/- a mba_term
    while ( ins->l.is_insn(m_add) || ins->l.is_insn(m_sub) )
    {
      if ( (ins->opcode == m_add || ins->opcode == m_sub) && is_mba_term(ins->r) )
        ins = ins->l.d;
      else
        return false;
    }

    // Check the left most term
    if ( (ins->opcode == m_add || ins->opcode == m_sub)
      && is_mba_term(ins->r)
      && is_mba_term(ins->l) )
    {
      return true;
    }
    return false;
  }


  //--------------------------------------------------------------------------
  // Recursively collect all variables in the sub-instructions of an operand op,
  // and put them into a set. Here it is only used for the AND expression.
  static bool build_op_set(mop_t op, std::set<mop_t> *op_set)
  {
    if ( op.t == mop_S || op.is_reg() )             // single variables
    {
      op_set->insert(op);
      return true;
    }
    if ( op.is_insn() )
    {
      if ( op.d->opcode == m_neg )      // allow m_neg in a factor
      {
        op_set->insert(op);
        return true;
      }
      else
        return build_op_set(op.d->l, op_set) && build_op_set(op.d->r, op_set);
    }
    else
      return false;
  }

  //--------------------------------------------------------------------------
  static bool build_product(product_t *p, mop_t op)
  {
    if ( op.t == mop_S || op.is_reg() )
    {
      factor_t f(op);
      (*p)[f]++;
      return true;
    }
    if ( op.is_insn() )
    {
      if ( op.d->opcode == m_mul )
        return build_product(p, op.d->l) && build_product(p, op.d->r);
      if ( op.d->opcode == m_and )
      {
        std::set<mop_t> and_expr;
        build_op_set(op, &and_expr);
        factor_t f(and_expr, op);
        (*p)[f]++;
        return true;
      }
      if ( op.d->opcode == m_neg )      // allow -x as a factor
      {
        factor_t f(op);
        (*p)[f]++;
        return true;
      }
    }
    return false;
  }

  //--------------------------------------------------------------------------
  // Check whether two mba products are equivalent. It is used for getting the like-terms.
  static bool eq_mba_product(const mop_t &op1, const mop_t &op2)
  {
    if ( op1.t == mop_S && op2.t == mop_S )
      return op1 == op2;
    if ( op1.is_reg() && op2.is_reg() )
      return op1 == op2;
    if ( op1.is_insn() && op2.is_insn() )
    {
      product_t p1, p2;
      if ( build_product(&p1, op1) && build_product(&p2, op2) )
        return p1 == p2;
      dmsg("build_product error!\n");
      INTERR(30827);
    }
    return false;
  }

  //--------------------------------------------------------------------------
  static bool build_normal_mba(minsn_t *ins, normal_mba_t &nm_mba)
  {
    while ( ins->l.is_insn(m_add) || ins->l.is_insn(m_sub) )
    {
      if ( ins->opcode == m_add )
      {
        term_t new_term(ins->r, 1);
        nm_mba.terms.push_back(new_term);
      }
      else if ( ins->opcode == m_sub )
      {
        term_t new_term(ins->r, -1);
        nm_mba.terms.push_back(new_term);
      }
      else
      {
        dmsg("build_normal_mba error: unrecognized term.");
        return false;
      }

      ins = ins->l.d;
    }

    // add the leftmost term and the second leftmost one
    if ( ins->opcode == m_add || ins->opcode == m_sub )
    {
      int leftmost_sign;
      mop_t leftmost_node;
      if ( ins->l.is_insn(m_neg) )      // the leftmost instruction could be negative
      {
        leftmost_sign = -1;
        leftmost_node = ins->l.d->l;
      }
      else
      {
        leftmost_sign = 1;
        leftmost_node = ins->l;
      }
      term_t new_term_l(leftmost_node, leftmost_sign);
      nm_mba.terms.push_back(new_term_l);

      int right_sign = ins->opcode == m_add ? 1 : -1;
      term_t new_term_r(ins->r, right_sign);
      nm_mba.terms.push_back(new_term_r);

      return true;
    }

    dmsg("build_normal_mba error: unrecognized leftmost term.");
    return false;
  }

  //--------------------------------------------------------------------------
  // Simplify a normalized mba
  static bool simp_nm_mba(normal_mba_t &nm_mba)
  {
    auto &terms = nm_mba.terms;
    for ( size_t i = 0; i < terms.size(); i++ )
    {
      for ( size_t j = i+1; j < terms.size(); j++ )
      {
        if ( terms[i].prod == terms[j].prod )       // like-terms
        {
          terms[i].coeff += terms[j].coeff;         // merge like-terms
          terms.erase(terms.begin() + j);
          j--;
        }
      }
    }

    for ( size_t i = 0; i < terms.size(); i++ )
    {
      if ( terms[i].coeff == 0 )                    // Delete the terms whose coefficient is 0
      {
        terms.erase(terms.begin() + i);
        i--;
      }
    }

    return true;
  }

  //--------------------------------------------------------------------------
  // dump the elements in a set of mop_t
  static void dump(const std::set<mop_t> &ops)
  {
#ifdef LDEB
    for ( const mop_t &elem : ops )
      dmsg("%s ", elem.dstr());
    dmsg("\n");
#else
    qnotused(ops);
#endif
  }

  //--------------------------------------------------------------------------
  // dump the elements in a vector of mop_t
  static void dump(const qvector<mop_t> &ops)
  {
    for ( const mop_t &elem : ops )
      dmsg("%s ", elem.dstr());
    dmsg("\n");
  }

  //--------------------------------------------------------------------------
  minsn_t *to_minsn(ea_t ea) const override
  {
    int size = one.size;
    minsn_t *res = new minsn_t(ea);
    res->opcode = m_ldc;
    res->l.make_number(0, size, ea);  // Use 0 as the init value, like const_term in linear_exprs.cpp
    res->d.size = size;

    // generate minsn for the terms
    for ( const term_t &term : nm_mba.terms )
    {
      // add terms
      minsn_t *add = new minsn_t(ea);
      add->opcode = m_add;
      add->l.t = mop_d;
      add->l.d = res;
      add->l.size = size;
      add->r = term.to_mop(this);
      add->d.size = size;
      res = add;
    }

    return res;
  }

  //--------------------------------------------------------------------------
  // The following functions are only place holders.
  const char *dstr() const override
  {
    // Not implemented yet
    static char buf[MAXSTR];
    return buf;
  }

  //--------------------------------------------------------------------------
  intval64_t evaluate(int64_emulator_t &emu) const override
  {
    intval64_t res = emu.minsn_value(*cur_mba);
    return res;
  }

  //--------------------------------------------------------------------------
  z3::expr to_smt(z3_converter_t &cvtr) const override
  {
    z3::expr res = cvtr.minsn_to_expr(*cur_mba);
    return res;
  }
};

```

`optimizer.cpp`:

```cpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include <chrono>

#include "z3++_no_warn.h"
#include "optimizer.hpp"

//--------------------------------------------------------------------------
// check whether or not we should skip the proving step of optimization
inline bool skip_proofs()
{
  return qgetenv("VD_MBA_SKIP_PROOFS");
}

//--------------------------------------------------------------------------
inline void set_cmt(ea_t ea, const char *cmt)
{
  func_t *pfn = get_func(ea);
  set_func_cmt(pfn, cmt, false);
}

//--------------------------------------------------------------------------
static bool check_and_substitute(
        minsn_t *insn,
        minsn_t *cand_insn,
        uint z3_timeout,
        bool z3_assume_timeouts_correct)
{
  bool ok = false;
  int original_score = score_complexity(*insn);
  int candidate_score = score_complexity(*cand_insn);
  msg("goomba: testing candidate: %s\n", cand_insn->dstr());
  if ( candidate_score > original_score )
  {
    msg("goomba: candidate (%d) is not simpler than original (%d), skipping\n", candidate_score, original_score);
  }
  else
  {
    z3_converter_t converter;
    if ( probably_equivalent(*insn, *cand_insn) )
    {
      msg("goomba: instruction is probably equivalent to candidate\n");
      if ( skip_proofs() || z3_timeout == 0 )
      {
        set_cmt(insn->ea, "goomba: z3 proof skipped, simplification assumed correct");
        ok = true;
      }
      else
      {
        z3::expr lge = converter.minsn_to_expr(*cand_insn);
        z3::expr ie = converter.minsn_to_expr(*insn);
        // msg("lge: %s\n", lge.to_string().c_str());
        // msg("ie: %s\n", ie.to_string().c_str());
        z3::solver s(converter.context);
        s.set("timeout", z3_timeout);
        s.add(lge != ie);
        z3::check_result res = s.check();
        msg("goomba: SMT check result: %d\n", res);
        if ( res == z3::check_result::sat )
        {
          msg("Satisfiable. Counterexample: \n");
          z3::model m = s.get_model();
          for ( unsigned i = 0; i < m.size(); i++ )
          {
            z3::func_decl v = m[i];
            msg("%s = %s\n", v.name().str().c_str(), m.get_const_interp(v).to_string().c_str());
          }
        }

        if ( res == z3::check_result::unsat )
        {
          ok = true;
        }

        if ( z3_assume_timeouts_correct && res == z3::check_result::unknown )
        {
          bool add_cmt = true;
#ifdef TESTABLE_BUILD
          // when running the testable build, do not append comments about z3 timeouts
          if ( add_cmt )
          {
            qstring dummy;
            if ( qgetenv("IDA_TEST_NAME", &dummy) )
              add_cmt = false;
          }
#endif
          if ( add_cmt )
            set_cmt(insn->ea, "goomba: z3 proof timed out, simplification assumed correct");
          ok = true;
        }
      }
    }
    else
    {
      msg("goomba: candidate not equivalent, skipping\n");
    }
  }

  if ( ok )
  {
    msg("goomba: SUCCESS: %s\n", cand_insn->dstr());
    substitute(insn, cand_insn);
  }
  return ok;
}

//--------------------------------------------------------------------------
bool optimizer_t::optimize_insn_recurse(minsn_t *insn)
{
  if ( optimize_insn(insn) )
    return true;

  // if unable to optimize insn, try to optimize all of its mops
  struct optimizer_visitor_t : public mop_visitor_t
  {
    optimizer_t *opt;
    optimizer_visitor_t(optimizer_t *o) : opt(o) {}
    bool result = false;

    int idaapi visit_mop(mop_t *op, const tinfo_t *, bool)
    {
      if ( op->is_insn() )
      {
        result |= opt->optimize_insn(op->d);
      }
      return 0;
    }
  };

  optimizer_visitor_t opt_mop(this);
  insn->for_all_ops(opt_mop);

  return opt_mop.result;
}

//--------------------------------------------------------------------------
static void add_candidate(minsnptrs_t *out, minsn_t *cand, const char *source)
{
  cand->optimize_solo();
  msg("goomba: %s guess: %s\n", source, cand->dstr());
  out->push_back(cand);
}

//--------------------------------------------------------------------------
bool optimizer_t::optimize_insn(minsn_t *insn)
{
  if ( insn->has_side_effects(true) )
  {
    // msg("goomba: instruction has side effects, skipping\n");
    return false;
  }

  if ( !is_mba(*insn) )
    return false; // not an MBA instruction
  msg("goomba: found an MBA instruction %s\n", insn->dstr());

  bool success = false;
  auto start_time = std::chrono::high_resolution_clock::now();
  minsnptrs_t candidates;
  try
  {
    auto equiv_class_start = std::chrono::high_resolution_clock::now();
    if ( equiv_classes != nullptr )
    { // Find candidates from the oracle file
      minsnptrs_t tmp;
      equiv_classes->find_candidates(&tmp, *insn);
      for ( minsn_t *i : tmp )
        add_candidate(&candidates, i, "Oracle");
    }
    auto equiv_class_end = std::chrono::high_resolution_clock::now();

    // Produce one candidate using naive linear guess
    auto linear_start = equiv_class_end;
    linear_expr_t linear_guess(*insn);
    add_candidate(&candidates, linear_guess.to_minsn(insn->ea), "Linear");
    auto linear_end = std::chrono::high_resolution_clock::now();

    // Produce one candidate using SiMBA's algorithm
    auto lin_conj_start = linear_end;
    lin_conj_expr_t lin_conj_guess(*insn);      // MBA Solver's simplification
    simp_lin_conj_expr_t simp_lin_conj_expr(lin_conj_guess);      // Simba's simplification
    add_candidate(&candidates, simp_lin_conj_expr.to_minsn(insn->ea), "Simplified lin conj");
    auto lin_conj_end = std::chrono::high_resolution_clock::now();

    // Produce one candidate using non-linear MBA simplification
    auto nonlin_start = lin_conj_end;
    nonlin_expr_t nonlin_guess(*insn);
    if ( nonlin_guess.success() )
    {
      add_candidate(&candidates, nonlin_guess.to_minsn(insn->ea), "Non-linear");
    }
    auto nonlin_end = std::chrono::high_resolution_clock::now();

    // Verify the candidates. Return the simplest one that passed verification.
    std::sort(candidates.begin(), candidates.end(), minsn_complexity_cmptr_t());
    for ( minsn_t *cand : candidates )
    {
      if ( check_and_substitute(insn, cand, z3_timeout, z3_assume_timeouts_correct) )
      {
        if ( qgetenv("VD_MBA_LOG_PERF") )
        {
          int nvars = get_input_mops(*insn).size();
          msg("goomba: Equiv class time: %d %" FMT_64 "d us\n", nvars,
            std::chrono::duration_cast<std::chrono::microseconds>(equiv_class_end - equiv_class_start).count());
          msg("goomba: Linear time: %d %" FMT_64 "d us\n", nvars,
            std::chrono::duration_cast<std::chrono::microseconds>(linear_end - linear_start).count());
          msg("goomba: Lin conj time: %d %" FMT_64 "d us\n", nvars,
            std::chrono::duration_cast<std::chrono::microseconds>(lin_conj_end - lin_conj_start).count());
          msg("goomba: Non-linear time: %d %" FMT_64 "d us\n", nvars,
            std::chrono::duration_cast<std::chrono::microseconds>(nonlin_end - nonlin_start).count());
        }
        success = true;
        break;
      }
    }
  }
  catch ( const vd_failure_t &vf )
  {
    msg("goomba: %s\n", vf.hf.str.c_str());
  }

  // delete all candidates
  for ( minsn_t *cand : candidates )
    delete cand;

  if ( success )
  {
    auto end_time = std::chrono::high_resolution_clock::now();
    msg("goomba: Time taken: %" FMT_64 "d us\n",
      std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count());
  }
  return success;
}

```

`optimizer.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once

#include "equiv_class.hpp"
#include "smt_convert.hpp"
#include "heuristics.hpp"
#include "lin_conj_exprs.hpp"
#include "simp_lin_conj_exprs.hpp"
#include "nonlin_expr.hpp"

//--------------------------------------------------------------------------
inline void substitute(minsn_t *insn, minsn_t *cand)
{
  cand->d.swap(insn->d);
  insn->swap(*cand);
}

//--------------------------------------------------------------------------
class optimizer_t
{
public:
  uint z3_timeout = 1000;
  bool z3_assume_timeouts_correct = true;
  equiv_class_finder_t *equiv_classes = nullptr;
  bool optimize_insn(minsn_t *insn); // attempts to replace the instruction with a simpler version
  bool optimize_insn_recurse(minsn_t *insn); // attempts to optimize the instruction, and if it fails, optimizes its subinstructions
};

```

`simp_lin_conj_exprs.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include <memory>
#include <hexrays.hpp>
#include "lin_conj_exprs.hpp"
#include "minsn_template.hpp"
#include "bitwise_expr_lookup_tbl.hpp"

//-------------------------------------------------------------------------
// represents a simplified linear combination of conjunctions,
// essentially just a lin_conj_expr with more bitwise expressions
// other than just conjunctions
class simp_lin_conj_expr_t : public lin_conj_expr_t
{
  minsn_template_ptr_t non_conj_term = std::make_shared<mt_constant_t>(0ull);
  qvector<intval64_t> range; // sorted lowest to highest

  //-------------------------------------------------------------------------
  void recompute_range()
  {
    std::set<intval64_t> new_range;

    for ( const auto &mval : eval_trace )
      new_range.insert(mval);

    range.qclear();
    for ( auto &mval : new_range )
      range.push_back(mval);
  }

  //-------------------------------------------------------------------------
  // returns a bitfield where the i'th bit indicates whether the i'th evaluation
  // returns the value of pos
  uint64 eval_trace_to_bit_trace(const eval_trace_t &src_trace, intval64_t pos)
  {
    QASSERT(30703, src_trace.size() <= 64);

    uint64 res = 0;
    for ( int i = 0; i < src_trace.size(); i++ )
    {
      if ( src_trace[i] == pos )
        res |= (1ull << i);
    }

    return res;
  }

  //-------------------------------------------------------------------------
  bool reset_eval_trace()
  {
    for ( auto &et : eval_trace )
      et.val = 0;
    recompute_coeffs();
    recompute_range();
    return true;
  }

public:
  //-------------------------------------------------------------------------
  simp_lin_conj_expr_t(const lin_conj_expr_t &o) : lin_conj_expr_t(o)
  {
    eliminate_variables();
    recompute_range();
    simplify();
  }

  //-------------------------------------------------------------------------
  const char *dstr() const override
  {
    static char res[MAXSTR];

    minsn_t *ins = non_conj_term->synthesize(0, coeffs[0].size, mops);
    qsnprintf(res, sizeof(res), "%s + %s", lin_conj_expr_t::dstr(), ins->dstr());
    delete ins;
    return res;
  }

  // (1) A constant expression would lead to all variables getting eliminated by eliminate_variables,
  // so there's no need for a simplification step here.

  //-------------------------------------------------------------------------
  // (2) If F has two unique entries and its first entry is zero, we replace the nonzero element a by
  // 1, find the lookup table's entry for the corresponding truth vector and multiply the found
  // expression by a.
  bool simp_2()
  {
    if ( range.size() != 2 )
      return false;
    if ( eval_trace[0].val != 0 )
      return false;

    intval64_t a = range[1];

    uint64 bit_trace = eval_trace_to_bit_trace(eval_trace, a);
    auto minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), bit_trace);

    non_conj_term = non_conj_term
                  + std::make_shared<mt_constant_t>(a.val) * minsn_template;

    return reset_eval_trace();
  }

  //-------------------------------------------------------------------------
  // (3) If F has two unique entries a and b, both of them are nonzero, w.l.o.g., b = 2a mod 2^n, and
  // F's first entry is a, we can express the result in terms of a negated single expression. We
  // replace all occurences of a by zeros and that of b by ones, find the corresponding expression
  // in the lookup table, negate it, and multiply it by -a.
  bool simp_3()
  {
    if ( range.size() != 2 )
      return false;

    intval64_t a = eval_trace[0];
    intval64_t b = range[0] == a ? range[1] : range[0];

    if ( a * intval64_t(2, b.size) != b )
      return false;

    uint64 bit_trace = eval_trace_to_bit_trace(eval_trace, b);
    auto minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), bit_trace);

    non_conj_term = non_conj_term
                  + std::make_shared<mt_constant_t>(0-a.val) * ~minsn_template;

    return reset_eval_trace();
  }

  //-------------------------------------------------------------------------
  // (4) If F has two unique entries a and b, but the previous cases do not apply, and F's very first
  // entry is a, we first identify a as the constant term. Then we find an expression with ones
  // exactly where F has the entry b in the lookup table, multiply it by b - a and add the term to
  // the constant.
  bool simp_4()
  {
    if ( range.size() != 2 )
      return false;

    intval64_t a = eval_trace[0];
    intval64_t b = range[0] == a? range[1] : range[0];

    uint64 bit_trace = eval_trace_to_bit_trace(eval_trace, b);
    auto minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), bit_trace);

    non_conj_term = non_conj_term
                  + std::make_shared<mt_constant_t>(a.val)
                  + std::make_shared<mt_constant_t>((b-a).val) * minsn_template;

    return reset_eval_trace();
  }

  //-------------------------------------------------------------------------
  // (5) If F has two unique nonzero entries a and b and its first one is zero, we split it into two vectors
  // with ones where F has entries a or b, resp., find the corresponding expressions in the lookup
  // table, multiply them by a and b, resp., and add the terms together.
  bool simp_5()
  {
    if ( range.size() != 3 )
      return false;
    if ( eval_trace[0].val != 0ull )
      return false;

    intval64_t a = range[1];
    intval64_t b = range[2];

    uint64 a_bit_trace = eval_trace_to_bit_trace(eval_trace, a);
    uint64 b_bit_trace = eval_trace_to_bit_trace(eval_trace, b);
    auto a_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), a_bit_trace);
    auto b_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), b_bit_trace);

    non_conj_term = non_conj_term
                  + std::make_shared<mt_constant_t>(a.val) * a_minsn_template
                  + std::make_shared<mt_constant_t>(b.val) * b_minsn_template;

    return reset_eval_trace();
  }

  //-------------------------------------------------------------------------
  // (6) If F has three unique nonzero entries a, b and c and its first one is 0, we try to express one
  // of them as a sum of the others modulo 2n, e.g., a = b + c. In that case we split F into two
  // vectors with ones where F has entries b or c, resp., or a, find the corresponding expressions in
  // the lookup table, multiply them by b and c, resp., and add the terms together.
  bool simp_6()
  {
    if ( range.size() != 4 )
      return false;
    if ( eval_trace[0].val != 0ull )
      return false;

    intval64_t a = range[1];
    intval64_t b = range[2];
    intval64_t c = range[3];

    // make sure that a = b + c
    if ( b == a + c )
      qswap(a, b);
    else if ( c == a + b )
      qswap(a, c);
    else if ( a != b + c )
      return false;

    QASSERT(30705, a == b + c);

    uint64 a_bit_trace = eval_trace_to_bit_trace(eval_trace, a);
    uint64 b_bit_trace = eval_trace_to_bit_trace(eval_trace, b);
    uint64 c_bit_trace = eval_trace_to_bit_trace(eval_trace, c);
    auto ab_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), a_bit_trace | b_bit_trace);
    auto ac_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), a_bit_trace | c_bit_trace);

    non_conj_term = non_conj_term
                  + std::make_shared<mt_constant_t>(b.val) * ab_minsn_template
                  + std::make_shared<mt_constant_t>(c.val) * ac_minsn_template;

    return reset_eval_trace();
  }

  //-------------------------------------------------------------------------
  // (7) If F has three unique nonzero entries a, b and c, its first one is 0 and the previous case does
  // not apply, we split it into three vectors with ones where F has entries a, b or c, resp., find the
  // corresponding expressions in the lookup table, multiply them by a, b and c, resp., and add the
  // terms together.
  bool simp_7()
  {
    if ( range.size() != 4 )
      return false;
    if ( eval_trace[0].val != 0ull )
      return false;

    intval64_t a = range[1];
    intval64_t b = range[2];
    intval64_t c = range[3];

    uint64 a_bit_trace = eval_trace_to_bit_trace(eval_trace, a);
    uint64 b_bit_trace = eval_trace_to_bit_trace(eval_trace, b);
    uint64 c_bit_trace = eval_trace_to_bit_trace(eval_trace, c);
    auto a_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), a_bit_trace);
    auto b_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), b_bit_trace);
    auto c_minsn_template = bw_expr_tbl_t::instance.lookup(mops.size(), c_bit_trace);

    non_conj_term = non_conj_term
                  + std::make_shared<mt_constant_t>(a.val) * a_minsn_template
                  + std::make_shared<mt_constant_t>(b.val) * b_minsn_template
                  + std::make_shared<mt_constant_t>(c.val) * c_minsn_template;

    return reset_eval_trace();
  }

  //-------------------------------------------------------------------------
  bool simp_8()
  {
    if ( range.size() != 4 )
      return false;
    if ( eval_trace[0].val == 0ull )
      return false;

    intval64_t a = eval_trace[0];

    non_conj_term = non_conj_term + std::make_shared<mt_constant_t>(a.val);

    for ( int i = 0; i < eval_trace.size(); i++ )
      eval_trace[i] = eval_trace[i] - a;
    recompute_coeffs();
    recompute_range();
    return simplify(); // start again
  }

  //-------------------------------------------------------------------------
  bool simplify()
  {
    if ( mops.size() < 1 || mops.size() > 3 )
      return false;
    if ( simp_2() )
      return true;
    if ( simp_3() )
      return true;
    if ( simp_4() )
      return true;
    if ( simp_5() )
      return true;
    if ( simp_6() )
      return true;
    if ( simp_7() )
      return true;
    if ( simp_8() )
      return true;
    return false;
  }

  //-------------------------------------------------------------------------
  minsn_t *to_minsn(ea_t ea) const override
  {
    minsn_t *res = new minsn_t(ea);
    minsn_t *l = lin_conj_expr_t::to_minsn(ea);
    minsn_t *r = non_conj_term->synthesize(ea, coeffs[0].size, mops);

    res->opcode = m_add;
    res->l.create_from_insn(l);
    res->r.create_from_insn(r);
    res->d.size = coeffs[0].size;

    delete l;
    delete r;
    return res;
  }
};

```

`smt_convert.cpp`:

```cpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#include "z3++_no_warn.h"
#include "smt_convert.hpp"

//--------------------------------------------------------------------------
z3::expr z3_converter_t::create_new_z3_var(const mop_t &mop)
{
  const char *name = build_new_varname();
  return context.bv_const(name, mop.size * 8);
}

//--------------------------------------------------------------------------
z3::expr z3_converter_t::mop_to_expr(const mop_t &mop)
{
  switch ( mop.t )
  {
    case mop_n: // immediate value
      {
        int bytesz = mop.size;
        uint64_t value = mop.nnn->value;
        return context.bv_val(value, bytesz * 8); // z3 counts size in bits
      }

    case mop_d: // result of another instruction
      return minsn_to_expr(*mop.d);

    case mop_r: // register
    case mop_S: // stack variable
    case mop_v: // global variable
      {
        return lookup(mop);
      }

    case mop_p: // operand pair
      {
        z3::expr vhi = mop_to_expr(mop.pair->hop);
        z3::expr vlo = mop_to_expr(mop.pair->lop);
        return z3::concat(vhi, vlo);
      }
    default:
      INTERR(30696); // it is better to check this before running z3, when detecting mba
  }
}

//--------------------------------------------------------------------------
z3::expr z3_converter_t::minsn_to_expr(const minsn_t &insn)
{
  switch ( insn.opcode )
  {
    case m_ldc: // load constant
    case m_mov: // move
      return mop_to_expr(insn.l);
    case m_neg:
      return -mop_to_expr(insn.l);
    case m_lnot:
      {
        int bitsz = insn.l.size * 8;
        z3::expr bool_res = mop_to_expr(insn.l) == context.bv_val(0, bitsz);
        // !x === (x == 0)
        return bool_to_bv(bool_res, bitsz);
      }
    case m_bnot:
      return ~mop_to_expr(insn.l);
    case m_xds: // signed extension
    case m_xdu: // unsigned (zero) extension
      {
        auto e = mop_to_expr(insn.l);
        int orig_bitsz = e.get_sort().bv_size();
        int dest_bitsz = insn.d.size * 8;
        QASSERT(30674, dest_bitsz >= orig_bitsz);
        if ( insn.opcode == m_xdu )
          return z3::zext(e, dest_bitsz - orig_bitsz);
        else
          return z3::sext(e, dest_bitsz - orig_bitsz);
      }
    case m_low:
      {
        auto dest_bitsz = insn.d.size * 8;
        return mop_to_expr(insn.l).extract(dest_bitsz - 1, 0);
      }
    case m_high:
      {
        auto src_bitsz = insn.l.size * 8;
        auto dest_bitsz = insn.d.size * 8;
        return mop_to_expr(insn.l).extract(src_bitsz - 1, src_bitsz - dest_bitsz);
      }
    case m_add:
      return mop_to_expr(insn.l) + mop_to_expr(insn.r);
    case m_sub:
      return mop_to_expr(insn.l) - mop_to_expr(insn.r);
    case m_mul:
      return mop_to_expr(insn.l) * mop_to_expr(insn.r);
    case m_udiv:
      return z3::udiv(mop_to_expr(insn.l), mop_to_expr(insn.r));
    case m_sdiv:
      return mop_to_expr(insn.l) / mop_to_expr(insn.r);
    case m_umod:
      return mop_to_expr(insn.l) % mop_to_expr(insn.r);
    case m_smod:
      return z3::smod(mop_to_expr(insn.l), mop_to_expr(insn.r));
    case m_or:
      return mop_to_expr(insn.l) | mop_to_expr(insn.r);
    case m_and:
      return mop_to_expr(insn.l) & mop_to_expr(insn.r);
    case m_xor:
      return mop_to_expr(insn.l) ^ mop_to_expr(insn.r);
    case m_shl:
      return z3::shl(
        mop_to_expr(insn.l),
        bv_zext_to_len(mop_to_expr(insn.r), insn.l.size * 8));
    case m_shr:
      return z3::lshr(
        mop_to_expr(insn.l),
        bv_zext_to_len(mop_to_expr(insn.r), insn.l.size * 8));
    case m_sar:
      return z3::ashr(
        mop_to_expr(insn.l),
        bv_zext_to_len(mop_to_expr(insn.r), insn.l.size * 8));
    case m_sets: // get sign bit of expression
      return bool_to_bv(mop_to_expr(insn.l) < 0, insn.d.size * 8);
    // TODO: m_seto, m_setp
    case m_setnz:
      return bool_to_bv(mop_to_expr(insn.l) != mop_to_expr(insn.r), insn.d.size * 8);
    case m_setz:
      return bool_to_bv(mop_to_expr(insn.l) == mop_to_expr(insn.r), insn.d.size * 8);
    case m_setae:
      return bool_to_bv(z3::uge(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_setb:
      return bool_to_bv(z3::ult(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_seta:
      return bool_to_bv(z3::ugt(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_setbe:
      return bool_to_bv(z3::ule(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_setg:
      return bool_to_bv(z3::sgt(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_setge:
      return bool_to_bv(z3::sge(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_setl:
      return bool_to_bv(z3::slt(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_setle:
      return bool_to_bv(z3::sle(mop_to_expr(insn.l), mop_to_expr(insn.r)), insn.d.size * 8);
    case m_cfshl: // not tested
      {
        auto nbits = insn.l.size * 8;
        auto x = mop_to_expr(insn.l);
        auto y = mop_to_expr(insn.r);
        auto xsize = context.bv_val(nbits, nbits);
        auto bit = z3::shl(context.bv_val(1, nbits), xsize - y);
        return bool_to_bv((x & bit) != 0, insn.d.size * 8);
      }
    case m_cfshr: // not tested
      {
        auto nbits = insn.l.size * 8;
        auto x = mop_to_expr(insn.l);
        auto y = mop_to_expr(insn.r);
        auto one = context.bv_val(1, nbits);
        auto bit = z3::shl(one, y - one);
        return bool_to_bv((x & bit) != 0, insn.d.size * 8);
      }
    case m_cfadd:
      {
        auto nbits = insn.l.size * 8;
        auto x = mop_to_expr(insn.l);
        auto y = mop_to_expr(insn.r);
        auto mone = context.bv_val(-1, nbits);
        return bool_to_bv(x > mone - y, insn.d.size * 8);
      }
    case m_ofadd:
      {
        auto x = mop_to_expr(insn.l);
        auto y = mop_to_expr(insn.r);
        auto r = x + y;
        return bool_to_bv(((x ^ r) & (y ^ r)) < 0, insn.d.size * 8);
      }
    case m_seto:
      {
        auto x = mop_to_expr(insn.l);
        auto y = mop_to_expr(insn.r);
        auto r = x - y;
        return bool_to_bv(((x ^ r) & (y ^ r)) < 0, insn.d.size * 8);
      }
    default:
      INTERR(30697); // it is better to check this before running z3, when detecting mba
  }
}

```

`smt_convert.hpp`:

```hpp
/*
 *      Copyright (c) 2025 by Hex-Rays, support@hex-rays.com
 *      ALL RIGHTS RESERVED.
 *
 *      gooMBA plugin for Hex-Rays Decompiler.
 *
 */

#pragma once
#include "z3++_no_warn.h"
#include <hexrays.hpp>

//-------------------------------------------------------------------------
class z3_converter_t
{
  char namebuf[12];
  int next_free_varnum = 0;
  const char *build_new_varname()
  {
    qsnprintf(namebuf, sizeof(namebuf), "y%d", next_free_varnum++);
    return namebuf;
  }

public:
  z3::context context;

  // These maps store register and memory variables as 8-bit bitvectors.
  // Similarly as the byte_val_map_t in heuristics.hpp, it is for solving the
  // overlapping problem.
  std::map<const uval_t, z3::expr> stk_map;      // stack variable mapping
  std::map<const uval_t, z3::expr> glb_map;      // global variable mapping
  std::map<const uval_t, z3::expr> local_map;    // local variable mapping
  std::map<const uval_t, z3::expr> reg_map;      // register mapping

  std::map<const mop_t, z3::expr> cache;

  z3_converter_t() { namebuf[0] = '\0'; }
  virtual ~z3_converter_t() {}

  // create_new_z3_var is called when var_to_expr fails to find an assigned_var in the cache
  virtual z3::expr create_new_z3_var(const mop_t &mop);
  z3::expr mop_to_expr(const mop_t &mop);
  z3::expr minsn_to_expr(const minsn_t &insn);

  //-------------------------------------------------------------------------
  z3::expr bool_to_bv(z3::expr boolean, uint bitsz)
  {
    return z3::ite(boolean, context.bv_val(1, bitsz), context.bv_val(0, bitsz));
  }

  //-------------------------------------------------------------------------
  z3::expr bv_zext_to_len(z3::expr bv, uint target_bitsz)
  {
    uint orig_bitsz = bv.get_sort().bv_size();
    if ( target_bitsz == orig_bitsz )
      return bv; // no need to extend
    return z3::zext(bv, target_bitsz - orig_bitsz);
  }

  //-------------------------------------------------------------------------
  z3::expr bv_sext_to_len(z3::expr bv, uint target_bitsz)
  {
    uint orig_bitsz = bv.get_sort().bv_size();
    if ( target_bitsz == orig_bitsz )
      return bv; // no need to extend
    return z3::sext(bv, target_bitsz - orig_bitsz);
  }

  //-------------------------------------------------------------------------
  z3::expr bv_resize_to_len(z3::expr bv, uint target_bitsz, bool sext)
  {
    uint orig_bitsz = bv.get_sort().bv_size();
    if ( target_bitsz == orig_bitsz )
      return bv;
    if ( target_bitsz < orig_bitsz )
      return bv.extract(target_bitsz - 1, 0);
    else
      return sext
           ? bv_sext_to_len(bv, target_bitsz)
           : bv_zext_to_len(bv, target_bitsz);
  }

  //-------------------------------------------------------------------------
  z3::expr intval64_to_expr(intval64_t v)
  {
    return context.bv_val(uint64_t(v.val), v.size * 8);
  }

  //-------------------------------------------------------------------------
  // find the value of the bytes [off, off+size) from the associated map,
  // assemble the result as a bitvector. Create a new bv_const for new values
  // and update the map.
  z3::expr find_update(uval_t off, size_t size, std::map<const uval_t, z3::expr> &map)
  {
    z3::expr_vector byte_exprs(context);

    for ( int i = size - 1; i >= 0; --i )
    {                                 // iterate the addresses from high to low, so the most
      uval_t mem_addr = off + i;      // significant digit is the first element of the expr_vector
      auto result = map.find(mem_addr);
      if ( result != map.end() )
      {
        byte_exprs.push_back(result->second);
      }
      else
      {
        // create a new byte variable
        const char *name = build_new_varname();
        z3::expr new_byte_var = context.bv_const(name, 8);
        byte_exprs.push_back(new_byte_var);
        map.insert( { mem_addr, new_byte_var } );
      }
    }

    return z3::concat(byte_exprs);
  }

  //-------------------------------------------------------------------------
  z3::expr lookup(const mop_t &op)
  {
    auto it = cache.find(op);
    if ( it != cache.end() )
      return it->second;

    z3::expr result(context);
    switch ( op.t )
    {
      case mop_S:         // stack variable
        result = find_update(op.s->off, op.size, stk_map);
        break;
      case mop_v:         // global variable
        result = find_update(op.g, op.size, glb_map);
        break;
      case mop_l:         // local variable
        result = find_update(op.l->off, op.size, local_map);
        break;
      case mop_r:         // register
        result = find_update(op.r, op.size, reg_map);
        break;
      default:
        INTERR(30821);
    }

    cache.insert( { op, result } );
    return result;
  }

};

```

`z3++_no_warn.h`:

```h
#pragma once
// using z3++.h directly leads to compiler warnings about shadowing declaractions
#ifdef __GNUC__
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wshadow"
#endif
#include <z3++.h>
#ifdef __GNUC__
#  pragma GCC diagnostic pop
#endif

```

`z3/readme.txt`:

```txt
bin and include directories of the z3 build should be extracted here

```